[
  {
    "label": "UCLASS",
    "kind": "Snippet",
    "detail": "Unreal macro",
    "documentation": "Marks a class as a UObject-derived type.",
    "insertText": "UCLASS()"
  },
  {
    "label": "GENERATED_BODY",
    "kind": "Snippet",
    "detail": "Unreal macro",
    "documentation": "Required in UE class declarations.",
    "insertText": "GENERATED_BODY()"
  },
  {
    "label": "UPROPERTY",
    "kind": "Snippet",
    "detail": "Unreal macro",
    "documentation": "Expose class member to UE reflection.",
    "insertText": "UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\\\"DefaultCategory\\\")\nType VariableName;",
    "isMultiline": true
  },
  {
    "label": "UFUNCTION",
    "kind": "Snippet",
    "detail": "Unreal macro",
    "documentation": "Expose function to UE reflection / Blueprints.",
    "insertText": "UFUNCTION(BlueprintCallable, Category=\\\"DefaultCategory\\\")\nvoid FunctionName();",
    "isMultiline": true
  },
  {
    "label": "AActor class stub",
    "kind": "Snippet",
    "detail": "Actor C++ header skeleton",
    "documentation": "Minimal Actor-derived class boilerplate.",
    "insertText": "UCLASS()\nclass MYMODULE_API AMyActor : public AActor\n{\n  GENERATED_BODY()\n\npublic:\n  AMyActor();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaSeconds) override;\n};",
    "isMultiline": true
  },
  {
    "label": "AActor class def",
    "kind": "Snippet",
    "detail": "Actor C++ source skeleton",
    "documentation": "Minimal Actor-derived class implementation.",
    "insertText": "AMyActor::AMyActor()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyActor::BeginPlay()\n{\n  Super::BeginPlay();\n  // TODO: Init here\n}\n\nvoid AMyActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n  // TODO: per-frame logic\n}",
    "isMultiline": true
  },
  {
    "label": "ACharacter class stub",
    "kind": "Snippet",
    "detail": "Character C++ header skeleton",
    "documentation": "Minimal Character-derived class boilerplate.",
    "insertText": "UCLASS()\nclass MYMODULE_API AMyCharacter : public ACharacter\n{\n  GENERATED_BODY()\n\npublic:\n  AMyCharacter();\n\nprotected:\n  virtual void BeginPlay() override;\n\npublic:\n  virtual void Tick(float DeltaSeconds) override;\n};",
    "isMultiline": true
  },
  {
    "label": "ACharacter class def",
    "kind": "Snippet",
    "detail": "Character C++ source skeleton",
    "documentation": "Minimal Character-derived class implementation.",
    "insertText": "AMyCharacter::AMyCharacter()\n{\n  PrimaryActorTick.bCanEverTick = true;\n}\n\nvoid AMyCharacter::BeginPlay()\n{\n  Super::BeginPlay();\n  // TODO: Init here\n}\n\nvoid AMyCharacter::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n  // TODO: per-frame logic\n}",
    "isMultiline": true
  },
  {
    "label": "BeginPlay def",
    "kind": "Snippet",
    "detail": "AActor .cpp body",
    "documentation": "Definition for BeginPlay override.",
    "insertText": "void AMyActor::BeginPlay()\n{\n  Super::BeginPlay();\n  // TODO: Init here\n}",
    "isMultiline": true
  },
  {
    "label": "Tick def",
    "kind": "Snippet",
    "detail": "AActor .cpp body",
    "documentation": "Definition for Tick override.",
    "insertText": "void AMyActor::Tick(float DeltaTime)\n{\n  Super::Tick(DeltaTime);\n  // TODO: per-frame logic\n}",
    "isMultiline": true
  },
  {
    "label": "UE_LOG",
    "kind": "Snippet",
    "detail": "Logging macro",
    "documentation": "UE_LOG(LogTemp, Warning, TEXT(\"Hello\"));",
    "insertText": "UE_LOG(LogTemp, Warning, TEXT(\"Message\"));"
  },
  {
    "label": "UENUM",
    "kind": "Snippet",
    "detail": "Unreal enum declaration",
    "documentation": "Declares an enum type for use in Unreal Engine.",
    "insertText": "UENUM(BlueprintType)\nenum class MyEnum : uint8\n{\n  Value1,\n  Value2,\n  Value3\n};",
    "isMultiline": true
  },
  {
    "label": "USTRUCT",
    "kind": "Snippet",
    "detail": "Unreal struct declaration",
    "documentation": "Declares a struct type for use in Unreal Engine.",
    "insertText": "USTRUCT(BlueprintType)\nstruct MyStruct\n{\n  GENERATED_BODY()\n\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = 'DefaultCategory')\n  int32 MyVariable;\n};",
    "isMultiline": true
  },
  {
    "label": "FVector constructor",
    "kind": "Snippet",
    "detail": "FVector constructor",
    "documentation": "Constructs an FVector with X, Y, Z values.",
    "insertText": "FVector(0.0f, 0.0f, 0.0f)"
  },
  {
    "label": "FRotator constructor",
    "kind": "Snippet",
    "detail": "FRotator constructor",
    "documentation": "Constructs an FRotator with Pitch, Yaw, Roll values.",
    "insertText": "FRotator(0.0f, 0.0f, 0.0f)"
  },
  {
    "label": "FTransform constructor",
    "kind": "Snippet",
    "detail": "FTransform constructor",
    "documentation": "Constructs an FTransform with location, rotation, scale.",
    "insertText": "FTransform(FRotator(0.0f, 0.0f, 0.0f), FVector(0.0f, 0.0f, 0.0f), FVector(1.0f, 1.0f, 1.0f))"
  },
  { "label": "FVector::Distance()", "kind": "Method", "detail": "Calculate distance between two vectors", "insertText": "FVector::Dist(Start, End)" },
  { "label": "FVector::DotProduct()", "kind": "Method", "detail": "Dot product of two vectors", "insertText": "FVector::DotProduct(VectorA, VectorB)" },
  { "label": "FVector::CrossProduct()", "kind": "Method", "detail": "Cross product of two vectors", "insertText": "FVector::CrossProduct(VectorA, VectorB)" },
  { "label": "FRotator::Add()", "kind": "Method", "detail": "Add two rotators", "insertText": "FRotatorA.Add(FRotatorB)" },
  { "label": "FRotator::Subtract()", "kind": "Method", "detail": "Subtract two rotators", "insertText": "FRotatorA.Subtract(FRotatorB)" },
  { "label": "FRotator::GetNormalized()", "kind": "Method", "detail": "Normalize a rotator", "insertText": "FRotator.GetNormalized()" },
  { "label": "FQuat::Inverse()", "kind": "Method", "detail": "Inverse of a quaternion", "insertText": "FQuat.Inverse()" },
  { "label": "FQuat::RotateVector()", "kind": "Method", "detail": "Rotate a vector by quaternion", "insertText": "FQuat.RotateVector(FVector)" },
  { "label": "AActor", "kind": "Text", "detail": "UE base Actor", "insertText": "AActor" },
  { "label": "ACharacter", "kind": "Text", "detail": "Playable character", "insertText": "ACharacter" },
  { "label": "APawn", "kind": "Text", "detail": "Controllable pawn", "insertText": "APawn" },
  { "label": "UObject", "kind": "Text", "detail": "Base UE object", "insertText": "UObject" },
  { "label": "USceneComponent", "kind": "Text", "detail": "Scene component", "insertText": "USceneComponent" },
  { "label": "FVector", "kind": "Text", "detail": "3D vector", "insertText": "FVector" },
  { "label": "FRotator", "kind": "Text", "detail": "Rotation (pitch/yaw/roll)", "insertText": "FRotator" },
  { "label": "GetWorld()", "kind": "Method", "detail": "World accessor", "insertText": "GetWorld()" },
  { "label": "GetActorLocation()", "kind": "Method", "detail": "Actor location", "insertText": "GetActorLocation()" },
  { "label": "SetActorLocation()", "kind": "Method", "detail": "Move actor", "insertText": "SetActorLocation(NewLocation);" },
  { "label": "AddMovementInput()", "kind": "Method", "detail": "Movement input", "insertText": "AddMovementInput(WorldDirection, ScaleValue);" },
  { "label": "GetActorRotation()", "kind": "Method", "detail": "Actor rotation", "insertText": "GetActorRotation()" },
  { "label": "SetActorRotation()", "kind": "Method", "detail": "Set actor rotation", "insertText": "SetActorRotation(NewRotation);" },
  { "label": "GetActorForwardVector()", "kind": "Method", "detail": "Get forward vector", "insertText": "GetActorForwardVector()" },
  { "label": "GetActorRightVector()", "kind": "Method", "detail": "Get right vector", "insertText": "GetActorRightVector()" },
  { "label": "GetActorUpVector()", "kind": "Method", "detail": "Get up vector", "insertText": "GetActorUpVector()" },
  { "label": "GetComponentLocation()", "kind": "Method", "detail": "Get component location", "insertText": "UYourComponent->GetComponentLocation();" },
  { "label": "SetComponentLocation()", "kind": "Method", "detail": "Set component location", "insertText": "UYourComponent->SetWorldLocation(NewLocation);" },
  { "label": "GetComponentRotation()", "kind": "Method", "detail": "Get component rotation", "insertText": "UYourComponent->GetComponentRotation();" },
  { "label": "SetComponentRotation()", "kind": "Method", "detail": "Set component rotation", "insertText": "UYourComponent->SetWorldRotation(NewRotation);" },
  { "label": "GetActorBounds()", "kind": "Method", "detail": "Get actor bounds", "insertText": "GetActorBounds(false, Origin, BoxExtent);" },
  { "label": "GetDistanceTo()", "kind": "Method", "detail": "Get distance to another actor", "insertText": "OtherActor->GetDistanceTo(this);" },
  { "label": "GetOverlappingActors()", "kind": "Method", "detail": "Get overlapping actors", "insertText": "GetOverlappingActors(OutActors, nullptr);" },
  { "label": "GetOverlappingComponents()", "kind": "Method", "detail": "Get overlapping components", "insertText": "GetOverlappingComponents(OutComponents);" },
  { "label": "LineTraceSingleByChannel()", "kind": "Method", "detail": "Line trace single by channel", "insertText": "GetWorld()->LineTraceSingleByChannel(HitResult, Start, End, ECC_Visibility);" },
  { "label": "SphereTraceSingleByChannel()", "kind": "Method", "detail": "Sphere trace single by channel", "insertText": "GetWorld()->SphereTraceSingleByChannel(HitResult, Start, End, 50.0f, ECC_Visibility);" },
  { "label": "BoxTraceSingleByChannel()", "kind": "Method", "detail": "Box trace single by channel", "insertText": "GetWorld()->BoxTraceSingleByChannel(HitResult, Start, End, FVector(1.0f), FQuat::Identity, ECC_Visibility);" },
  { "label": "CapsuleTraceSingleByChannel()", "kind": "Method", "detail": "Capsule trace single by channel", "insertText": "GetWorld()->CapsuleTraceSingleByChannel(HitResult, Start, End, 50.0f, 100.0f, ECC_Visibility);" },
  { "label": "SpawnActor()", "kind": "Method", "detail": "Spawn actor", "insertText": "GetWorld()->SpawnActor<AMyActor>(SpawnLocation, SpawnRotation);" },
  { "label": "GetPlayerController()", "kind": "Method", "detail": "Get player controller", "insertText": "GetWorld()->GetFirstPlayerController();" },
  { "label": "GetGameState()", "kind": "Method", "detail": "Get game state", "insertText": "GetWorld()->GetGameState();" },
  { "label": "GetGameInstance()", "kind": "Method", "detail": "Get game instance", "insertText": "GetGameInstance()" },
  { "label": "GetGameMode()", "kind": "Method", "detail": "Get game mode", "insertText": "GetWorld()->GetAuthGameMode();" },
  { "label": "GetPlayerPawn()", "kind": "Method", "detail": "Get player pawn", "insertText": "GetWorld()->GetFirstPlayerController()->GetPawn();" },
  { "label": "GetComponentByClass()", "kind": "Method", "detail": "Get component by class", "insertText": "GetComponentByClass<UYourComponentClass>();" },
  { "label": "GetComponentsByClass()", "kind": "Method", "detail": "Get components by class", "insertText": "GetComponentsByClass<UYourComponentClass>(OutComponents);" },
  { "label": "IsValid()", "kind": "Method", "detail": "Check if object is valid", "insertText": "IsValid(Object)" },
  { "label": "Cast()", "kind": "Method", "detail": "Cast to type", "insertText": "Cast<TargetType>(Object)" },
  { "label": "StaticClass()", "kind": "Method", "detail": "Get static class type", "insertText": "UYourClass::StaticClass()" },
  { "label": "FVector::ZeroVector", "kind": "Constant", "detail": "Zero vector constant", "insertText": "FVector::ZeroVector" },
  { "label": "FRotator::ZeroRotator", "kind": "Constant", "detail": "Zero rotator constant", "insertText": "FRotator::ZeroRotator" },
  { "label": "FVector::UpVector", "kind": "Constant", "detail": "Up vector constant", "insertText": "FVector::UpVector" },
  { "label": "FVector::ForwardVector", "kind": "Constant", "detail": "Forward vector constant", "insertText": "FVector::ForwardVector" },
  { "label": "FVector::RightVector", "kind": "Constant", "detail": "Right vector constant", "insertText": "FVector::RightVector" },
  { "label": "TEXT()", "kind": "Macro", "detail": "String literal macro", "insertText": "TEXT('YourString')" },
  { "label": "__FUNCTION__", "kind": "Macro", "detail": "__FUNCTION__ macro for current function name", "insertText": "__FUNCTION__" },
  { "label": "FString", "kind": "Type", "detail": "String type", "insertText": "FString" },
  { "label": "TArray", "kind": "Type", "detail": "Dynamic array type", "insertText": "TArray<Type>" },
  { "label": "TMap", "kind": "Type", "detail": "Key-value map type", "insertText": "TMap<KeyType, ValueType>" },
  { "label": "TSet", "kind": "Type", "detail": "Set type", "insertText": "TSet<ElementType>" },
  { "label": "FName", "kind": "Type", "detail": "Name type", "insertText": "FName" },
  { "label": "FText", "kind": "Type", "detail": "Text type", "insertText": "FText" },
  { "label": "FColor", "kind": "Type", "detail": "Color type", "insertText": "FColor" },
  { "label": "FLinearColor", "kind": "Type", "detail": "Linear color type", "insertText": "FLinearColor" },
  { "label": "FQuat", "kind": "Type", "detail": "Quaternion type", "insertText": "FQuat" },
  { "label": "FHitResult", "kind": "Type", "detail": "Hit result type", "insertText": "FHitResult" },
  { "label": "FTransform", "kind": "Type", "detail": "Transform type", "insertText": "FTransform" },
  { "label": "FDelegate", "kind": "Type", "detail": "Delegate type", "insertText": "FDelegate" },
  { "label": "FTimerHandle", "kind": "Type", "detail": "Timer handle type", "insertText": "FTimerHandle" },
  { "label": "FVector2D", "kind": "Type", "detail": "2D vector type", "insertText": "FVector2D" },
  { "label": "FVector4", "kind": "Type", "detail": "4D vector type", "insertText": "FVector4" },
  { "label": "FBox", "kind": "Type", "detail": "Axis-aligned bounding box", "insertText": "FBox" },
  { "label": "FPlane", "kind": "Type", "detail": "Plane type", "insertText": "FPlane" },
  { "label": "FMatrix", "kind": "Type", "detail": "Matrix type", "insertText": "FMatrix" },
  { "label": "FMath", "kind": "Class", "detail": "Math utility class", "insertText": "FMath" },
  { "label": "FPlatformMisc", "kind": "Class", "detail": "Platform utilities", "insertText": "FPlatformMisc" },
  { "label": "FPlatformTime", "kind": "Class", "detail": "Platform time utilities", "insertText": "FPlatformTime" },
  { "label": "FPlatformFileManager", "kind": "Class", "detail": "File system manager", "insertText": "FPlatformFileManager" }
]