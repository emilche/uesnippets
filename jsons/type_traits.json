[
  {
    "label": "is_trivially_destructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_trivially_destructible"
  },
  {
    "label": "is_trivially_move_assignable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_trivially_move_assignable"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "IsTriviallyMoveConstructibleObject",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsTriviallyMoveConstructibleObject"
  },
  {
    "label": "IsTriviallyCopyConstructibleObject",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsTriviallyCopyConstructibleObject"
  },
  {
    "label": "IsTriviallyMoveAssignableReference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsTriviallyMoveAssignableReference"
  },
  {
    "label": "VoidTImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VoidTImpl"
  },
  {
    "label": "default_alignment_of_aligned_storage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "default_alignment_of_aligned_storage"
  },
  {
    "label": "Enabler",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Enabler"
  },
  {
    "label": "Op",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Op"
  },
  {
    "label": "is_detected_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_detected_impl"
  },
  {
    "label": "is_detected",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_detected"
  },
  {
    "label": "To",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "To"
  },
  {
    "label": "is_detected_convertible_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_detected_convertible_impl"
  },
  {
    "label": "is_detected_convertible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_detected_convertible"
  },
  {
    "label": "is_copy_assignable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_copy_assignable"
  },
  {
    "label": "is_move_assignable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_move_assignable"
  },
  {
    "label": "conjunction",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "conjunction"
  },
  {
    "label": "disjunction",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "disjunction"
  },
  {
    "label": "negation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "negation"
  },
  {
    "label": "is_function",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_function"
  },
  {
    "label": "is_trivially_default_constructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_trivially_default_constructible"
  },
  {
    "label": "is_trivially_move_constructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_trivially_move_constructible"
  },
  {
    "label": "is_trivially_copy_constructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_trivially_copy_constructible"
  },
  {
    "label": "is_trivially_copy_assignable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_trivially_copy_assignable"
  },
  {
    "label": "remove_cvref",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "remove_cvref"
  },
  {
    "label": "is_trivially_copyable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_trivially_copyable"
  },
  {
    "label": "is_trivially_copyable_impl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "is_trivially_copyable_impl"
  },
  {
    "label": "result_of",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "result_of"
  },
  {
    "label": "IsHashable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsHashable"
  },
  {
    "label": "AssertHashEnabledHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AssertHashEnabledHelper"
  },
  {
    "label": "NAT",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NAT"
  },
  {
    "label": "Key",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Key"
  },
  {
    "label": "IsNoexcept",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IsNoexcept"
  },
  {
    "label": "IsSwappable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsSwappable"
  },
  {
    "label": "IsNothrowSwappable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsNothrowSwappable"
  },
  {
    "label": "is_trivially_relocatable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_trivially_relocatable"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_META_TYPE_TRAITS_H_ # define ABSL_META_TYPE_TRAITS_H_ # include<cstddef> # include<functional> # include<type_traits> # include \" absl / base / config . h \" # if)",
    "insertText": "defined(_MSC_VER) && !defined(__clang__) && !defined(__GNUC__) #define ABSL_META_INTERNAL_STD_CONSTRUCTION_TRAITS_DONT_CHECK_DESTRUCTION 1 #endif #if defined(__STDCPP_DEFAULT_NEW_ALIGNMENT__) #define ABSL_INTERNAL_DEFAULT_NEW_ALIGNMENT __STDCPP_DEFAULT_NEW_ALIGNMENT__ #else #define ABSL_INTERNAL_DEFAULT_NEW_ALIGNMENT alignof(std::max_align_t)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (ABSL_NAMESPACE_BEGIN # if)",
    "insertText": "defined(__clang__)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (template<T> struct is_trivially_move_assignable ; namespace type_traits_internal { # if)",
    "insertText": "defined(_MSC_VER) && !defined(__GNUC__) #pragma warning(push) #pragma warning(disable : 4624)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (T t ; } ; # if)",
    "insertText": "defined(_MSC_VER) && !defined(__GNUC__) #pragma warning(pop)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> struct IsTriviallyCopyConstructibleObject : std::integral_constant<bool,std::is_copy_constructible<type_traits_internal::SingleMemberUnion<T>>::value&& absl::is_trivially_destructible<T>::value> { } ; template<class T> struct IsTriviallyMoveAssignableReference : std::false_type { } ; template<class T> struct IsTriviallyMoveAssignableReference<T&> : absl::is_trivially_move_assignable<T>::type { } ; template<class T> struct IsTriviallyMoveAssignableReference<T&&> : absl::is_trivially_move_assignable<T>::type { } ; template<. . . Ts> struct VoidTImpl { using type = void ; } ; template<size_t Len,T = std::aligned_storage<Len>> struct default_alignment_of_aligned_storage ; template<size_t Len,size_t Align> struct default_alignment_of_aligned_storage<Len,std::aligned_storage<Len,Align>> { size_t value = Align ; } ; template<class Enabler,template<class . . .> class Op,class . . . Args> struct is_detected_impl { using type = std::false_type ; } ; template<template<class . . .> class Op,class . . . Args> struct is_detected_impl<VoidTImpl<Op<Args . . .>>::type,Op,Args . . .> { using type = std::true_type ; } ; template<template<class . . .> class Op,class . . . Args> struct is_detected : is_detected_impl<void,Op,Args . . .>::type { } ; template<class Enabler,class To,template<class . . .> class Op,class . . . Args> struct is_detected_convertible_impl { using type = std::false_type ; } ; template<class To,template<class . . .> class Op,class . . . Args> struct is_detected_convertible_impl<std::enable_if<std::is_convertible<Op<Args . . .>,To>::value>::type,To,Op,Args . . .> { using type = std::true_type ; } ; template<class To,template<class . . .> class Op,class . . . Args> struct is_detected_convertible : is_detected_convertible_impl<void,To,Op,Args . . .>::type { } ; template<T> using IsCopyAssignableImpl =)",
    "insertText": "decltype(std::declval<T&>() = std::declval<const T&>())"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<T> using IsMoveAssignableImpl =)",
    "insertText": "decltype(std::declval<T&>() = std::declval<T&&>())"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(_MSC_VER) && !defined(__clang__) && (_MSC_VER >= 1920)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (template<T> using is_move_assignable = std::is_move_assignable<T> ; # else template<T> struct is_copy_assignable : type_traits_internal::is_detected<type_traits_internal::IsCopyAssignableImpl,T> { } ; template<T> struct is_move_assignable : type_traits_internal::is_detected<type_traits_internal::IsMoveAssignableImpl,T> { } ; # endif template<. . . Ts> using void_t = type_traits_internal::VoidTImpl<Ts . . .>::type ; template<. . . Ts> struct conjunction : std::true_type { } ; template<T,. . . Ts> struct conjunction<T,Ts . . .> : std::conditional<T::value,conjunction<Ts . . .>,T>::type { } ; template<T> struct conjunction<T> : T { } ; template<. . . Ts> struct disjunction : std::false_type { } ; template<T,. . . Ts> struct disjunction<T,Ts . . .> : std::conditional<T::value,T,disjunction<Ts . . .>>::type { } ; template<T> struct disjunction<T> : T { } ; template<T> struct negation : std::integral_constant<bool,! T::value> { } ; template<T> struct is_function : std::integral_constant<)",
    "insertText": "bool(std::is_reference<T>::value || std::is_const<typename std::add_const<T>::type>::value)"
  },
  {
    "label": "__has_trivial_destructor()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct is_trivially_destructible # ifdef ABSL_HAVE_STD_IS_TRIVIALLY_DESTRUCTIBLE : std::is_trivially_destructible<T> { # else : std::integral_constant<bool,)",
    "insertText": "__has_trivial_destructor(T)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # endif } ; template<T> struct is_trivially_default_constructible # if)",
    "insertText": "defined(ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE)"
  },
  {
    "label": "__has_trivial_constructor()",
    "kind": "Method",
    "detail": "Function (# else : std::integral_constant<bool,)",
    "insertText": "__has_trivial_constructor(T)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # if 0 # if)",
    "insertText": "defined(ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE) && \\ !defined( \\ ABSL_META_INTERNAL_STD_CONSTRUCTION_TRAITS_DONT_CHECK_DESTRUCTION) private: static constexpr bool compliant = std::is_trivially_default_constructible<T>::value == std::integral_constant<bool, __has_trivial_constructor(T)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# else : std::conditional<std::is_object<T>::value&& ! std::is_array<T>::value,type_traits_internal::IsTriviallyMoveConstructibleObject<T>,std::is_reference<T>>::type::type { # endif # if 0 # if)",
    "insertText": "defined(ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE) && \\ !defined( \\ ABSL_META_INTERNAL_STD_CONSTRUCTION_TRAITS_DONT_CHECK_DESTRUCTION)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # endif } ; template<T> struct is_trivially_copy_constructible : std::conditional<std::is_object<T>::value&& ! std::is_array<T>::value,type_traits_internal::IsTriviallyCopyConstructibleObject<T>,std::is_lvalue_reference<T>>::type::type { # if 0 # if)",
    "insertText": "defined(ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE) && \\ !defined( \\ ABSL_META_INTERNAL_STD_CONSTRUCTION_TRAITS_DONT_CHECK_DESTRUCTION) private: static constexpr bool compliant = std::is_trivially_copy_constructible<T>::value == std::integral_constant<bool, __has_trivial_copy(T)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# endif # endif } ; template<T> struct is_trivially_move_assignable : std::conditional<std::is_object<T>::value&& ! std::is_array<T>::value&& std::is_move_assignable<T>::value,std::is_move_assignable<type_traits_internal::SingleMemberUnion<T>>,type_traits_internal::IsTriviallyMoveAssignableReference<T>>::type::type { # if 0 # ifdef ABSL_HAVE_STD_IS_TRIVIALLY_ASSIGNABLE private : bool compliant = std::is_trivially_move_assignable<T>::value = = is_trivially_move_assignable::value ;)",
    "insertText": "static_assert(compliant || std::is_trivially_move_assignable<T>::value, \"Not compliant with std::is_trivially_move_assignable; \" \"Standard: false, Implementation: true\")"
  },
  {
    "label": "__has_trivial_assign()",
    "kind": "Method",
    "detail": "Function (# endif # endif } ; template<T> struct is_trivially_copy_assignable # ifdef ABSL_HAVE_STD_IS_TRIVIALLY_ASSIGNABLE : std::is_trivially_copy_assignable<T> { # else : std::integral_constant<bool,)",
    "insertText": "__has_trivial_assign(typename std::remove_reference<T>::type)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # if 0 # ifdef ABSL_HAVE_STD_IS_TRIVIALLY_ASSIGNABLE private : # if !)",
    "insertText": "defined(WEBRTC_WIN) static constexpr bool compliant = std::is_trivially_copy_assignable<T>::value == std::integral_constant< bool, __has_trivial_assign(typename std::remove_reference<T>::type)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # endif # endif } ; # if)",
    "insertText": "defined(__cpp_lib_remove_cvref)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (template<T> using remove_cvref_t = std::remove_cvref<T>::type ; # else template<T> struct remove_cvref { using type = std::remove_cv<std::remove_reference<T>::type>::type ; } ; template<T> using remove_cvref_t = remove_cvref<T>::type ; # endif namespace type_traits_internal { # if)",
    "insertText": "defined(ABSL_HAVE_STD_IS_TRIVIALLY_COPYABLE)"
  },
  {
    "label": "kValue()",
    "kind": "Method",
    "detail": "Function (} ; # else template<T> class is_trivially_copyable_impl { using ExtentsRemoved = std::remove_all_extents<T>::type ; bool kIsCopyOrMoveConstructible = std::is_copy_constructible<ExtentsRemoved>::value | | std::is_move_constructible<ExtentsRemoved>::value ; bool kIsCopyOrMoveAssignable = absl::is_copy_assignable<ExtentsRemoved>::value | | absl::is_move_assignable<ExtentsRemoved>::value ; public : bool)",
    "insertText": "kValue(__has_trivial_copy(ExtentsRemoved) || !kIsCopyOrMoveConstructible) && (__has_trivial_assign(ExtentsRemoved) || !kIsCopyOrMoveAssignable) && (kIsCopyOrMoveConstructible || kIsCopyOrMoveAssignable)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct is_trivially_copyable : std::integral_constant<bool,type_traits_internal::is_trivially_copyable_impl<T>::kValue> { } ; # endif } template<T> using remove_cv_t = std::remove_cv<T>::type ; template<T> using remove_const_t = std::remove_const<T>::type ; template<T> using remove_volatile_t = std::remove_volatile<T>::type ; template<T> using add_cv_t = std::add_cv<T>::type ; template<T> using add_const_t = std::add_const<T>::type ; template<T> using add_volatile_t = std::add_volatile<T>::type ; template<T> using remove_reference_t = std::remove_reference<T>::type ; template<T> using add_lvalue_reference_t = std::add_lvalue_reference<T>::type ; template<T> using add_rvalue_reference_t = std::add_rvalue_reference<T>::type ; template<T> using remove_pointer_t = std::remove_pointer<T>::type ; template<T> using add_pointer_t = std::add_pointer<T>::type ; template<T> using make_signed_t = std::make_signed<T>::type ; template<T> using make_unsigned_t = std::make_unsigned<T>::type ; template<T> using remove_extent_t = std::remove_extent<T>::type ; template<T> using remove_all_extents_t = std::remove_all_extents<T>::type ; template<size_t Len,size_t Align = type_traits_internal::default_alignment_of_aligned_storage<Len>::value> using aligned_storage_t = std::aligned_storage<Len,Align>::type ; template<T> using decay_t = std::decay<T>::type ; template<bool B,T = void> using enable_if_t = std::enable_if<B,T>::type ; template<bool B,T,F> using conditional_t = std::conditional<B,T,F>::type ; template<. . . T> using common_type_t = std::common_type<T . . .>::type ; template<T> using underlying_type_t = std::underlying_type<T>::type ; namespace type_traits_internal { #)",
    "insertText": "if(defined(__cpp_lib_is_invocable) && __cpp_lib_is_invocable >= 201703L) || \\ (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)"
  },
  {
    "label": "F()",
    "kind": "Method",
    "detail": "Function (template<F,. . . Args> struct result_of<)",
    "insertText": "F(Args...)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} ; # else template<F> using result_of = std::result_of<F> ; # endif } template<F> using result_of_t = type_traits_internal::result_of<F>::type ; namespace type_traits_internal { # if)",
    "insertText": "defined(_MSC_VER) || (defined(_LIBCPP_VERSION) && \\ _LIBCPP_VERSION < 4000 && _LIBCPP_STD_VER > 11)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; # else template<Key,= void> struct IsHashable : std::false_type { } ; template<Key> struct IsHashable<Key,absl::enable_if_t<std::is_convertible<)",
    "insertText": "decltype(std::declval<std::hash<Key>&>()(std::declval<Key const&>()))"
  },
  {
    "label": "Sink()",
    "kind": "Method",
    "detail": "Function (} ; # endif struct AssertHashEnabledHelper { private : void)",
    "insertText": "Sink(...)"
  },
  {
    "label": "GetReturnType()",
    "kind": "Method",
    "detail": "Function (} struct NAT { } ; template<class Key> auto)",
    "insertText": "GetReturnType(int) -> decltype(std::declval<std::hash<Key>>()(std::declval<Key const&>()))"
  },
  {
    "label": "GetReturnType()",
    "kind": "Method",
    "detail": "Function (template<class Key> NAT)",
    "insertText": "GetReturnType(...)"
  },
  {
    "label": "DoIt()",
    "kind": "Method",
    "detail": "Function (template<class Key> std::nullptr_t)",
    "insertText": "DoIt()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using ReturnType =)",
    "insertText": "decltype(GetReturnType<Key>(0))"
  },
  {
    "label": "AssertHashEnabled()",
    "kind": "Method",
    "detail": "Function (} ; template<class . . . Ts> void)",
    "insertText": "AssertHashEnabled()"
  },
  {
    "label": "Sink()",
    "kind": "Method",
    "detail": "Function (using Helper = AssertHashEnabledHelper ;)",
    "insertText": "Sink(Helper::DoIt<Ts>()...)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} } namespace swap_internal { using std::swap ; void)",
    "insertText": "swap()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<class T> using IsSwappableImpl =)",
    "insertText": "decltype(swap(std::declval<T&>(), std::declval<T&>()))"
  },
  {
    "label": "noexcept()",
    "kind": "Method",
    "detail": "Function (template<class T,class IsNoexcept = std::integral_constant<bool,)",
    "insertText": "noexcept(swap(std::declval<T&>(), std::declval<T&>()))"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (template<class T> struct IsSwappable : absl::type_traits_internal::is_detected<IsSwappableImpl,T> { } ; template<class T> struct IsNothrowSwappable : absl::type_traits_internal::is_detected<IsNothrowSwappableImpl,T> { } ; template<class T,absl::enable_if_t<IsSwappable<T>::value,int> = 0> void)",
    "insertText": "Swap(T& lhs, T& rhs) noexcept(IsNothrowSwappable<T>::value)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(lhs, rhs)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} using StdSwapIsUnconstrained = IsSwappable<)",
    "insertText": "void()"
  },
  {
    "label": "ABSL_HAVE_BUILTIN()",
    "kind": "Method",
    "detail": "Function (} namespace type_traits_internal { using swap_internal::IsNothrowSwappable ; using swap_internal::IsSwappable ; using swap_internal::Swap ; using swap_internal::StdSwapIsUnconstrained ; } # if)",
    "insertText": "ABSL_HAVE_BUILTIN(__is_trivially_relocatable) template <class T> struct is_trivially_relocatable : std::integral_constant<bool, __is_trivially_relocatable(T)"
  }
]