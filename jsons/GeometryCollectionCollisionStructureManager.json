[
  {
    "label": "FErrorReporter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FErrorReporter"
  },
  {
    "label": "FTriangleMesh",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTriangleMesh"
  },
  {
    "label": "FLevelSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLevelSet"
  },
  {
    "label": "TParticles",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TParticles"
  },
  {
    "label": "FCollisionStructureManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCollisionStructureManager"
  },
  {
    "label": "FCollisionStructureManager()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" GeometryCollection / GeometryCollection . h \" # include \" GeometryCollection / GeometryCollectionSimulationCoreTypes . h \" # include \" GeometryCollection / GeometryCollectionSimulationTypes . h \" # include \" UObject / ObjectMacros . h \" namespace Chaos { class FErrorReporter ; } namespace Chaos { class FTriangleMesh ; class FLevelSet ; template<T,int d> class TParticles ; using FParticles = TParticles<FReal,3> ; } class FCollisionStructureManager { public :)",
    "insertText": "FCollisionStructureManager()"
  },
  {
    "label": "NewSimplicial()",
    "kind": "Method",
    "detail": "Function (} typedef TArray<Chaos::FVec3> FPoints ; typedef Chaos::FBVHParticles FSimplicial ; typedef Chaos::FImplicitObject FImplicit ; FSimplicial*)",
    "insertText": "NewSimplicial(const Chaos::FParticles& Vertices, const Chaos::FTriangleMesh& TriMesh, const Chaos::FImplicitObject* Implicit, const int32 CollisionParticlesMaxInput)"
  },
  {
    "label": "NewSimplicial()",
    "kind": "Method",
    "detail": "Function (FSimplicial*)",
    "insertText": "NewSimplicial(const Chaos::FParticles& AllParticles, const TManagedArray<int32>& BoneMap, const ECollisionTypeEnum CollisionType, Chaos::FTriangleMesh& TriMesh, const float CollisionParticlesFraction)"
  },
  {
    "label": "UpdateImplicitFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateImplicitFlags(FImplicit* Implicit, const ECollisionTypeEnum CollisionType)"
  },
  {
    "label": "NewImplicit()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectRef)",
    "insertText": "NewImplicit(Chaos::FErrorReporter ErrorReporter, const Chaos::FParticles& MeshParticles, const Chaos::FTriangleMesh& TriMesh, const FBox& CollisionBounds, const Chaos::FReal Radius, const int32 MinRes, const int32 MaxRes, const float CollisionObjectReduction, const ECollisionTypeEnum CollisionType, const EImplicitTypeEnum ImplicitType)"
  },
  {
    "label": "NewImplicitBox()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectRef)",
    "insertText": "NewImplicitBox(const FBox& CollisionBounds, const float CollisionObjectReduction, const ECollisionTypeEnum CollisionType)"
  },
  {
    "label": "NewImplicitSphere()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectRef)",
    "insertText": "NewImplicitSphere(const Chaos::FReal Radius, const float CollisionObjectReduction, const ECollisionTypeEnum CollisionType)"
  },
  {
    "label": "NewImplicitCapsule()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectRef)",
    "insertText": "NewImplicitCapsule(const Chaos::FReal Radius, const Chaos::FReal Length, const float CollisionObjectReduction, const ECollisionTypeEnum CollisionType)"
  },
  {
    "label": "NewImplicitCapsule()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectRef)",
    "insertText": "NewImplicitCapsule(const FBox& CollisionBounds, const float CollisionObjectReduction, const ECollisionTypeEnum CollisionType)"
  },
  {
    "label": "NewImplicitConvex()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectRef)",
    "insertText": "NewImplicitConvex(const TArray<int32>& ConvexIndices, const TManagedArray<Chaos::FConvexPtr>* ConvexGeometry, const ECollisionTypeEnum CollisionType, const FTransform& MassTransform, const Chaos::FReal CollisionMarginFraction, const float CollisionObjectReduction)"
  },
  {
    "label": "NewImplicitLevelset()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectRef)",
    "insertText": "NewImplicitLevelset(Chaos::FErrorReporter ErrorReporter, const Chaos::FParticles& MeshParticles, const Chaos::FTriangleMesh& TriMesh, const FBox& CollisionBounds, const int32 MinRes, const int32 MaxRes, const float CollisionObjectReduction, const ECollisionTypeEnum CollisionType)"
  },
  {
    "label": "NewLevelset()",
    "kind": "Method",
    "detail": "Function (Chaos::FLevelSetRef)",
    "insertText": "NewLevelset(Chaos::FErrorReporter ErrorReporter, const Chaos::FParticles& MeshParticles, const Chaos::FTriangleMesh& TriMesh, const FBox& CollisionBounds, const int32 MinRes, const int32 MaxRes, const ECollisionTypeEnum CollisionType)"
  },
  {
    "label": "CalculateUnitMassInertiaTensor()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "CalculateUnitMassInertiaTensor(const FBox& BoundingBox, const Chaos::FReal Radius, const EImplicitTypeEnum ImplicitType)"
  },
  {
    "label": "CalculateVolume()",
    "kind": "Method",
    "detail": "Function (Chaos::FReal)",
    "insertText": "CalculateVolume(const FBox& BoundingBox, const Chaos::FReal Radius, const EImplicitTypeEnum ImplicitType)"
  }
]