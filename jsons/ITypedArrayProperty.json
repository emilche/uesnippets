[
  {
    "label": "TRAITS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRAITS"
  },
  {
    "label": "ITypedArrayProperty",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ITypedArrayProperty"
  },
  {
    "label": "getInterpretation()",
    "kind": "Method",
    "detail": "Function (# ifndef Alembic_Abc_ITypedArrayProperty_h # define Alembic_Abc_ITypedArrayProperty_h # include<Alembic / Abc / Foundation . h> # include<Alembic / Abc / IArrayProperty . h> # include<Alembic / Abc / TypedPropertyTraits . h> # include<Alembic / Abc / TypedArraySample . h> namespace Alembic { namespace Abc { namespace ALEMBIC_VERSION_NS { template<class TRAITS> class ITypedArrayProperty : public IArrayProperty { public : typedef TRAITS traits_type ; typedef ITypedArrayProperty<TRAITS> this_type ; typedef TRAITS::value_type value_type ; typedef TypedArraySample<TRAITS> sample_type ; typedef shared_ptr<sample_type> sample_ptr_type ; const char*)",
    "insertText": "getInterpretation()"
  },
  {
    "label": "matches()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "matches(const AbcA::MetaData &iMetaData, SchemaInterpMatching iMatching = kStrictMatching)"
  },
  {
    "label": "matches()",
    "kind": "Method",
    "detail": "Function (} return true ; } bool)",
    "insertText": "matches(const AbcA::PropertyHeader &iHeader, SchemaInterpMatching iMatching = kStrictMatching)"
  },
  {
    "label": "ITypedArrayProperty()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ITypedArrayProperty()"
  },
  {
    "label": "ITypedArrayProperty()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ITypedArrayProperty(const ICompoundProperty &iParent, const std::string &iName, const Argument &iArg0 = Argument(), const Argument &iArg1 = Argument())"
  },
  {
    "label": "args()",
    "kind": "Method",
    "detail": "Function (Arguments)",
    "insertText": "args(GetErrorHandlerPolicy( iParent ))"
  },
  {
    "label": "setInto()",
    "kind": "Method",
    "detail": "Function (iArg0 .)",
    "insertText": "setInto(args)"
  },
  {
    "label": "getErrorHandler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getErrorHandler().setPolicy( args.getErrorHandlerPolicy())"
  },
  {
    "label": "ALEMBIC_ABC_SAFE_CALL_BEGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ALEMBIC_ABC_SAFE_CALL_BEGIN(\"ITypedArrayProperty::ITypedArrayProperty()\")"
  },
  {
    "label": "getPtr()",
    "kind": "Method",
    "detail": "Function (AbcA::CompoundPropertyReaderPtr parent = iParent .)",
    "insertText": "getPtr()"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(parent != NULL, \"NULL CompoundPropertyReader passed into \" << \"ITypedArrayProperty ctor\")"
  },
  {
    "label": "getPropertyHeader()",
    "kind": "Method",
    "detail": "Function (const AbcA::PropertyHeader* pheader = parent ->)",
    "insertText": "getPropertyHeader(iName)"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(pheader != NULL, \"Nonexistent array property: \" << iName)"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(matches( *pheader, args.getSchemaInterpMatching() ), \"Incorrect match of header datatype: \" << pheader->getDataType() << \" to expected: \" << TRAITS::dataType() << \",\\n...or incorrect match of interpretation: \" << pheader->getMetaData().get( \"interpretation\" ) << \" to expected: \" << TRAITS::interpretation())"
  },
  {
    "label": "getArrayProperty()",
    "kind": "Method",
    "detail": "Function (m_property = parent ->)",
    "insertText": "getArrayProperty(iName)"
  },
  {
    "label": "ALEMBIC_ABC_SAFE_CALL_END_RESET()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ALEMBIC_ABC_SAFE_CALL_END_RESET()"
  },
  {
    "label": "ITypedArrayProperty()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ITypedArrayProperty(AbcA::ArrayPropertyReaderPtr iProperty, const Argument &iArg0 = Argument(), const Argument &iArg1 = Argument())"
  },
  {
    "label": "getHeader()",
    "kind": "Method",
    "detail": "Function (const AbcA::PropertyHeader& pheader = iProperty ->)",
    "insertText": "getHeader()"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(matches( pheader,GetSchemaInterpMatching( iArg0, iArg1 ) ), \"Incorrect match of header datatype: \" << pheader.getDataType() << \" to expected: \" << TRAITS::dataType() << \",\\n...or incorrect match of interpretation: \" << pheader.getMetaData().get( \"interpretation\" ) << \" to expected: \" << TRAITS::interpretation())"
  },
  {
    "label": "ITypedArrayProperty()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ITypedArrayProperty(AbcA::ArrayPropertyReaderPtr iProp, WrapExistingFlag iWrapFlag, const Argument &iArg0 = Argument(), const Argument &iArg1 = Argument())"
  },
  {
    "label": "ITypedArrayProperty()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "ITypedArrayProperty(iProp, iArg0, iArg1)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "get(sample_ptr_type& iVal, const ISampleSelector &iSS = ISampleSelector())"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (AbcA::ArraySamplePtr ptr ;)",
    "insertText": "get(ptr, iSS)"
  },
  {
    "label": "ArraySample()",
    "kind": "Method",
    "detail": "Function (iVal = Alembic::Util::static_pointer_cast<sample_type,)",
    "insertText": "ArraySample(ptr)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} sample_ptr_type)",
    "insertText": "getValue(const ISampleSelector &iSS = ISampleSelector())"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (sample_ptr_type ret ;)",
    "insertText": "get(ret, iSS)"
  }
]