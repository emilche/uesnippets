[
  {
    "label": "FPage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPage"
  },
  {
    "label": "FLinearAllocator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLinearAllocator"
  },
  {
    "label": "FLinearAllocatorPolicy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLinearAllocatorPolicy"
  },
  {
    "label": "ForElementType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ForElementType"
  },
  {
    "label": "FLinearBitArrayAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLinearBitArrayAllocator"
  },
  {
    "label": "FLinearSparseArrayAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLinearSparseArrayAllocator"
  },
  {
    "label": "FLinearSetAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLinearSetAllocator"
  },
  {
    "label": "TLinearArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TLinearArray"
  },
  {
    "label": "FSourceInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSourceInfo"
  },
  {
    "label": "FCompilerMessages",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompilerMessages"
  },
  {
    "label": "FMessage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMessage"
  },
  {
    "label": "FPage()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # define USE_UNREAL_ALLOCATOR 0 # define USE_PAGE_POOLING 0 namespace CrossCompiler { namespace Memory { struct FPage { int8* Current ; int8* Begin ; int8* End ;)",
    "insertText": "FPage(SIZE_T Size)"
  },
  {
    "label": "FPage()",
    "kind": "Method",
    "detail": "Function (Begin = new int8 [ Size ] ; End = Begin + Size ; Current = Begin ; } ~)",
    "insertText": "FPage()"
  },
  {
    "label": "AllocatePage()",
    "kind": "Method",
    "detail": "Function (delete [ ] Begin ; } FPage*)",
    "insertText": "AllocatePage(SIZE_T PageSize)"
  },
  {
    "label": "FreePage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreePage(FPage* Page)"
  },
  {
    "label": "FLinearAllocator()",
    "kind": "Method",
    "detail": "Function (} ; enum { MinPageSize = 6 4* 1 0 2 4 } ; } struct FLinearAllocator {)",
    "insertText": "FLinearAllocator()"
  },
  {
    "label": "AllocatePage()",
    "kind": "Method",
    "detail": "Function (auto* Initial = Memory::)",
    "insertText": "AllocatePage(Memory::MinPageSize)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Pages .)",
    "insertText": "Add(Initial)"
  },
  {
    "label": "FreePage()",
    "kind": "Method",
    "detail": "Function (Memory::)",
    "insertText": "FreePage(Page)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (} } void*)",
    "insertText": "Alloc(SIZE_T NumBytes)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (auto* Page = Pages .)",
    "insertText": "Last()"
  },
  {
    "label": "SIZE_T()",
    "kind": "Method",
    "detail": "Function (SIZE_T PageSize = FMath::Max<)",
    "insertText": "SIZE_T(Memory::MinPageSize, NumBytes)"
  },
  {
    "label": "AllocatePage()",
    "kind": "Method",
    "detail": "Function (Page = Memory::)",
    "insertText": "AllocatePage(PageSize)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Pages .)",
    "insertText": "Add(Page)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (} void* Ptr = Page -> Current ; Page -> Current + = NumBytes ; return Ptr ; } void*)",
    "insertText": "Alloc(SIZE_T NumBytes, SIZE_T Align)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (void* Data =)",
    "insertText": "Alloc(NumBytes + Align - 1)"
  },
  {
    "label": "Address()",
    "kind": "Method",
    "detail": "Function (UPTRINT)",
    "insertText": "Address(UPTRINT)"
  },
  {
    "label": "Address()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Address(Align - (Address % (UPTRINT)Align))"
  },
  {
    "label": "Strdup()",
    "kind": "Method",
    "detail": "Function (} TCHAR*)",
    "insertText": "Strdup(const TCHAR* String)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (const auto)",
    "insertText": "Size(Length + 1) * sizeof(TCHAR)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (auto*)",
    "insertText": "Data(TCHAR*)Alloc(Size, sizeof(TCHAR))"
  },
  {
    "label": "Strcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Strcpy(Data, Length, String)"
  },
  {
    "label": "ForElementType()",
    "kind": "Method",
    "detail": "Function (} TArray<Memory::FPage*,TInlineAllocator<8>> Pages ; } ; # if ! USE_UNREAL_ALLOCATOR class FLinearAllocatorPolicy { public : using SizeType = int32 ; enum { NeedsElementType = false } ; enum { RequireRangeCheck = true } ; template<ElementType> class ForElementType { public :)",
    "insertText": "ForElementType() : LinearAllocator(nullptr), Data(nullptr)"
  },
  {
    "label": "GetAllocation()",
    "kind": "Method",
    "detail": "Function (} ElementType*)",
    "insertText": "GetAllocation()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (void* OldData = Data ;)",
    "insertText": "if(NewMax)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Data(ElementType*)LinearAllocator->Alloc(NewMax * NumBytesPerElement, FMath::Max((uint32)sizeof(void*), (uint32)alignof(ElementType)))"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (const SizeType NumCopiedElements =)",
    "insertText": "Min(NewMax, CurrentNum)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(Data, OldData, NumCopiedElements * NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackReserve()",
    "kind": "Method",
    "detail": "Function (} } } SizeType)",
    "insertText": "CalculateSlackReserve(SizeType NewMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackShrink()",
    "kind": "Method",
    "detail": "Function (} SizeType)",
    "insertText": "CalculateSlackShrink(SizeType NewMax, SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackGrow()",
    "kind": "Method",
    "detail": "Function (} SizeType)",
    "insertText": "CalculateSlackGrow(SizeType NewMax, SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetAllocatedSize(SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "FSourceInfo()",
    "kind": "Method",
    "detail": "Function (TArray<TType,FLinearAllocatorPolicy>::AllocatorInstance . LinearAllocator = Allocator ; } } ; # endif struct FSourceInfo { FString* Filename ; int32 Line ; int32 Column ;)",
    "insertText": "FSourceInfo() : Filename(nullptr), Line(0), Column(0)"
  },
  {
    "label": "FMessage()",
    "kind": "Method",
    "detail": "Function (} } ; struct FCompilerMessages { struct FMessage { bool bIsError ; FString Message ;)",
    "insertText": "FMessage(bool bInIsError, const FString& InMessage) : bIsError(bInIsError), Message(InMessage)"
  },
  {
    "label": "AddMessage()",
    "kind": "Method",
    "detail": "Function (} } ; TArray<FMessage> MessageList ; void)",
    "insertText": "AddMessage(bool bIsError, const FString& Message)"
  },
  {
    "label": "Emplace_GetRef()",
    "kind": "Method",
    "detail": "Function (auto& NewMessage = MessageList .)",
    "insertText": "Emplace_GetRef(bIsError, Message)"
  },
  {
    "label": "SourceError()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SourceError(const FSourceInfo& SourceInfo, const TCHAR* String)"
  },
  {
    "label": "AddMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddMessage(true, FString::Printf(TEXT(\"%s(%d): (%d) %s\\n\"), **SourceInfo.Filename, SourceInfo.Line, SourceInfo.Column, String))"
  },
  {
    "label": "AddMessage()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "AddMessage(true, FString::Printf(TEXT(\"<unknown>(%d): (%d) %s\\n\"), SourceInfo.Line, SourceInfo.Column, String))"
  },
  {
    "label": "SourceError()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SourceError(const TCHAR* String)"
  },
  {
    "label": "AddMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddMessage(true, FString::Printf(TEXT(\"%s\\n\"), String))"
  },
  {
    "label": "SourceWarning()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SourceWarning(const FSourceInfo& SourceInfo, const TCHAR* String)"
  },
  {
    "label": "AddMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddMessage(false, FString::Printf(TEXT(\"%s(%d): (%d) %s\\n\"), **SourceInfo.Filename, SourceInfo.Line, SourceInfo.Column, String))"
  },
  {
    "label": "AddMessage()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "AddMessage(false, FString::Printf(TEXT(\"<unknown>(%d): (%d) %s\\n\"), SourceInfo.Line, SourceInfo.Column, String))"
  },
  {
    "label": "SourceWarning()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SourceWarning(const TCHAR* String)"
  },
  {
    "label": "AddMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddMessage(false, FString::Printf(TEXT(\"%s\\n\"), String))"
  }
]