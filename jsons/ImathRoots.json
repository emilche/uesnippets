[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "solveLinear()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHROOTS_H # define INCLUDED_IMATHROOTS_H # include \" ImathMath . h \" # include \" ImathNamespace . h \" # include<complex> # ifdef __CUDACC__ # include<thrust / complex . h> # define COMPLEX_NAMESPACE thrust # else # define COMPLEX_NAMESPACE std # endif IMATH_INTERNAL_NAMESPACE_HEADER_ENTER template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 int)",
    "insertText": "solveLinear(T a, T b, T& x)"
  },
  {
    "label": "solveQuadratic()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 int)",
    "insertText": "solveQuadratic(T a, T b, T c, T x[2])"
  },
  {
    "label": "solveNormalizedCubic()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 int)",
    "insertText": "solveNormalizedCubic(T r, T s, T t, T x[3])"
  },
  {
    "label": "solveCubic()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 int)",
    "insertText": "solveCubic(T a, T b, T c, T d, T x[3])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (x = - b / a ; return 1 ; } else)",
    "insertText": "if(b != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { T D = b* b - 4* a* c ;)",
    "insertText": "if(D > 0)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (T s =)",
    "insertText": "sqrt(D)"
  },
  {
    "label": "q()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "q(b + (b > 0 ? 1 : -1) * s) / T (2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] = q / a ; x [ 1 ] = c / q ; return 2 ; })",
    "insertText": "if(D == 0)"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] = -)",
    "insertText": "b(2 * a)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "p(3 * s - r * r)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T q = 2* r* r* r / 2 7 - r* s / 3 + t ; T p3 = p / 3 ; T q2 = q / 2 ; T D = p3* p3* p3 + q2* q2 ;)",
    "insertText": "if(D == 0 && p3 == 0)"
  },
  {
    "label": "real_root()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "real_root(T a, T x)"
  },
  {
    "label": "copysign()",
    "kind": "Method",
    "detail": "Function (T sign =)",
    "insertText": "copysign(T(1), a)"
  },
  {
    "label": "real_root()",
    "kind": "Method",
    "detail": "Function (} ; T u =)",
    "insertText": "real_root(-q / 2 + std::sqrt (D), 3)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (T v = -)",
    "insertText": "p(T (3) * u)"
  },
  {
    "label": "pow()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] = u + v - r / 3 ; return 1 ; } namespace CN = COMPLEX_NAMESPACE ; CN::complex<T> u =)",
    "insertText": "pow(-q / 2 + CN::sqrt (CN::complex<T> (D)), T (1) / T (3))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T sqrt3 =)",
    "insertText": "T(1.73205080756887729352744634150587)"
  },
  {
    "label": "y0()",
    "kind": "Method",
    "detail": "Function (CN::complex<T>)",
    "insertText": "y0(u + v)"
  },
  {
    "label": "y1()",
    "kind": "Method",
    "detail": "Function (CN::complex<T>)",
    "insertText": "y1(-(u + v) / T (2) + (u - v) / T (2) * CN::complex<T> (0, sqrt3))"
  },
  {
    "label": "y2()",
    "kind": "Method",
    "detail": "Function (CN::complex<T>)",
    "insertText": "y2(-(u + v) / T (2) - (u - v) / T (2) * CN::complex<T> (0, sqrt3))"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] = y0 .)",
    "insertText": "real()"
  },
  {
    "label": "solveNormalizedCubic()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "solveNormalizedCubic(b / a, c / a, d / a, x)"
  }
]