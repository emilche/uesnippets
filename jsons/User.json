[
  {
    "label": "OperandTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OperandTraits"
  },
  {
    "label": "User",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "User"
  },
  {
    "label": "HungoffOperandTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HungoffOperandTraits"
  },
  {
    "label": "value_op_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "value_op_iterator"
  },
  {
    "label": "simplify_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "simplify_type"
  },
  {
    "label": "User()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_IR_USER_H # define LLVM_IR_USER_H # include \" llvm / ADT / iterator . h \" # include \" llvm / ADT / iterator_range . h \" # include \" llvm / IR / Value . h \" # include \" llvm / Support / AlignOf . h \" # include \" llvm / Support / ErrorHandling . h \" namespace llvm { template<class> struct OperandTraits ; class User : public Value {)",
    "insertText": "User(const User &)"
  },
  {
    "label": "anchor()",
    "kind": "Method",
    "detail": "Function (template<unsigned> struct HungoffOperandTraits ; void)",
    "insertText": "anchor()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (protected : void* operator)",
    "insertText": "new(size_t Size)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void* operator)",
    "insertText": "new(size_t Size, unsigned Us)"
  },
  {
    "label": "User()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "User(Type *ty, unsigned vty, Use *OpList, unsigned NumOps) : Value(ty, vty)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(NumOps < (1u << NumUserOperandsBits) && \"Too many operands\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (NumUserOperands = NumOps ;)",
    "insertText": "assert((!HasHungOffUses || !getOperandList()) && \"Error in initializing hung off uses for User\")"
  },
  {
    "label": "allocHungoffUses()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "allocHungoffUses(unsigned N, bool IsPhi = false)"
  },
  {
    "label": "growHungoffUses()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "growHungoffUses(unsigned N, bool IsPhi = false)"
  },
  {
    "label": "User()",
    "kind": "Method",
    "detail": "Function (public : ~)",
    "insertText": "User()"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (} void operator)",
    "insertText": "delete(void *Usr)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (void operator)",
    "insertText": "delete(void*, unsigned)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (void operator)",
    "insertText": "delete(void*, unsigned, bool)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Constructor throws?\")"
  },
  {
    "label": "OpFrom()",
    "kind": "Method",
    "detail": "Function (} protected : template<int Idx,U> Use&)",
    "insertText": "OpFrom(const U *that)"
  },
  {
    "label": "Op()",
    "kind": "Method",
    "detail": "Function (} template<int Idx> Use&)",
    "insertText": "Op()"
  },
  {
    "label": "getHungOffOperands()",
    "kind": "Method",
    "detail": "Function (} private : Use*&)",
    "insertText": "getHungOffOperands()"
  },
  {
    "label": "getIntrusiveOperands()",
    "kind": "Method",
    "detail": "Function (} Use*)",
    "insertText": "getIntrusiveOperands()"
  },
  {
    "label": "setOperandList()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setOperandList(Use *NewList)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(HasHungOffUses && \"Setting operand list only required for hung off uses\")"
  },
  {
    "label": "getOperandList()",
    "kind": "Method",
    "detail": "Function (} public : Use*)",
    "insertText": "getOperandList()"
  },
  {
    "label": "getOperand()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "getOperand(unsigned i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < NumUserOperands && \"getOperand() out of range!\")"
  },
  {
    "label": "setOperand()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setOperand(unsigned i, Value *Val)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < NumUserOperands && \"setOperand() out of range!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((!isa<Constant>((const Value*)this) || isa<GlobalValue>((const Value*)this)) && \"Cannot mutate a constant with setOperand!\")"
  },
  {
    "label": "getOperandUse()",
    "kind": "Method",
    "detail": "Function (} const Use&)",
    "insertText": "getOperandUse(unsigned i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < NumUserOperands && \"getOperandUse() out of range!\")"
  },
  {
    "label": "getNumOperands()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getNumOperands()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(NumOps <= 1 && \"GlobalVariable can only have 0 or 1 operands\")"
  },
  {
    "label": "setFunctionNumOperands()",
    "kind": "Method",
    "detail": "Function (NumUserOperands = NumOps ; } void)",
    "insertText": "setFunctionNumOperands(unsigned NumOps)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(NumOps <= 1 && \"Function can only have 0 or 1 operands\")"
  },
  {
    "label": "setNumHungOffUseOperands()",
    "kind": "Method",
    "detail": "Function (NumUserOperands = NumOps ; } void)",
    "insertText": "setNumHungOffUseOperands(unsigned NumOps)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(HasHungOffUses && \"Must have hung off uses to use this method\")"
  },
  {
    "label": "op_begin()",
    "kind": "Method",
    "detail": "Function (NumUserOperands = NumOps ; } typedef Use* op_iterator ; typedef const Use* const_op_iterator ; typedef iterator_range<op_iterator> op_range ; typedef iterator_range<const_op_iterator> const_op_range ; op_iterator)",
    "insertText": "op_begin()"
  },
  {
    "label": "op_end()",
    "kind": "Method",
    "detail": "Function (} op_iterator)",
    "insertText": "op_end()"
  },
  {
    "label": "operands()",
    "kind": "Method",
    "detail": "Function (} op_range)",
    "insertText": "operands()"
  },
  {
    "label": "value_op_iterator()",
    "kind": "Method",
    "detail": "Function (} struct value_op_iterator : iterator_adaptor_base<value_op_iterator,op_iterator,std::random_access_iterator_tag,Value*,ptrdiff_t,Value*,Value*> {)",
    "insertText": "value_op_iterator(Use *U = nullptr) : iterator_adaptor_base(U)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "operator()"
  },
  {
    "label": "value_op_begin()",
    "kind": "Method",
    "detail": "Function (} } ; value_op_iterator)",
    "insertText": "value_op_begin()"
  },
  {
    "label": "value_op_end()",
    "kind": "Method",
    "detail": "Function (} value_op_iterator)",
    "insertText": "value_op_end()"
  },
  {
    "label": "operand_values()",
    "kind": "Method",
    "detail": "Function (} iterator_range<value_op_iterator>)",
    "insertText": "operand_values()"
  },
  {
    "label": "dropAllReferences()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "dropAllReferences()"
  },
  {
    "label": "replaceUsesOfWith()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "replaceUsesOfWith(Value *From, Value *To)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "classof(const Value *V)"
  },
  {
    "label": "getSimplifiedValue()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct simplify_type<User::op_iterator> { typedef Value* SimpleType ; SimpleType)",
    "insertText": "getSimplifiedValue(User::op_iterator &Val)"
  },
  {
    "label": "getSimplifiedValue()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct simplify_type<User::const_op_iterator> { typedef Value* SimpleType ; SimpleType)",
    "insertText": "getSimplifiedValue(User::const_op_iterator &Val)"
  }
]