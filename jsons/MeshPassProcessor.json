[
  {
    "label": "FGPUScene",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGPUScene"
  },
  {
    "label": "FInstanceCullingDrawParams",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FInstanceCullingDrawParams"
  },
  {
    "label": "FRayTracingLocalShaderBindingWriter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRayTracingLocalShaderBindingWriter"
  },
  {
    "label": "FMeshProcessorShaders",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshProcessorShaders"
  },
  {
    "label": "FSceneTexturesConfig",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSceneTexturesConfig"
  },
  {
    "label": "FVisibleMeshDrawCommandStatsData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVisibleMeshDrawCommandStatsData"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "FMeshPassMask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshPassMask"
  },
  {
    "label": "FMinimalBoundShaderStateInput",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMinimalBoundShaderStateInput"
  },
  {
    "label": "FGraphicsMinimalPipelineStateInitializer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGraphicsMinimalPipelineStateInitializer"
  },
  {
    "label": "FHashKey",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHashKey"
  },
  {
    "label": "FGraphicsMinimalPipelineStateId",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGraphicsMinimalPipelineStateId"
  },
  {
    "label": "FRefCountedGraphicsMinimalPipelineState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRefCountedGraphicsMinimalPipelineState"
  },
  {
    "label": "FShaderBindingState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FShaderBindingState"
  },
  {
    "label": "FMeshDrawCommandDebugData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshDrawCommandDebugData"
  },
  {
    "label": "FMeshDrawCommandStatsData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshDrawCommandStatsData"
  },
  {
    "label": "FMeshDrawCommandStateCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshDrawCommandStateCache"
  },
  {
    "label": "FMeshDrawShaderBindings",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshDrawShaderBindings"
  },
  {
    "label": "FData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FData"
  },
  {
    "label": "FReadOnlyMeshDrawSingleShaderBindings",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FReadOnlyMeshDrawSingleShaderBindings"
  },
  {
    "label": "FMeshDrawCommandOverrideArgs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshDrawCommandOverrideArgs"
  },
  {
    "label": "FMeshDrawCommandSceneArgs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshDrawCommandSceneArgs"
  },
  {
    "label": "FMeshDrawCommand",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshDrawCommand"
  },
  {
    "label": "FMeshDrawCommandSortKey",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshDrawCommandSortKey"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FPersistentPrimitiveIndex",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPersistentPrimitiveIndex"
  },
  {
    "label": "FMeshDrawCommandPrimitiveIdInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshDrawCommandPrimitiveIdInfo"
  },
  {
    "label": "FMeshDrawCommandCullingPayload",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshDrawCommandCullingPayload"
  },
  {
    "label": "FMeshPassDrawListContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshPassDrawListContext"
  },
  {
    "label": "FDynamicMeshDrawCommandStorage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDynamicMeshDrawCommandStorage"
  },
  {
    "label": "FVisibleMeshDrawCommand",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVisibleMeshDrawCommand"
  },
  {
    "label": "FCompareFMeshDrawCommands",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompareFMeshDrawCommands"
  },
  {
    "label": "TUseBitwiseSwap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TUseBitwiseSwap"
  },
  {
    "label": "FDynamicPassMeshDrawListContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDynamicPassMeshDrawListContext"
  },
  {
    "label": "FCachedMeshDrawCommandInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCachedMeshDrawCommandInfo"
  },
  {
    "label": "FCachedPassMeshDrawList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCachedPassMeshDrawList"
  },
  {
    "label": "FMeshDrawCommandCount",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshDrawCommandCount"
  },
  {
    "label": "MeshDrawCommandKeyFuncs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MeshDrawCommandKeyFuncs"
  },
  {
    "label": "FCachedPassMeshDrawListContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCachedPassMeshDrawListContext"
  },
  {
    "label": "FMeshPassScope",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshPassScope"
  },
  {
    "label": "FCachedPassMeshDrawListContextImmediate",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCachedPassMeshDrawListContextImmediate"
  },
  {
    "label": "FCachedPassMeshDrawListContextDeferred",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCachedPassMeshDrawListContextDeferred"
  },
  {
    "label": "TMeshProcessorShaders",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TMeshProcessorShaders"
  },
  {
    "label": "FMeshPassProcessorRenderState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshPassProcessorRenderState"
  },
  {
    "label": "FMeshPassProcessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshPassProcessor"
  },
  {
    "label": "FMeshDrawingPolicyOverrideSettings",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMeshDrawingPolicyOverrideSettings"
  },
  {
    "label": "FPassProcessorManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPassProcessorManager"
  },
  {
    "label": "value",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "value"
  },
  {
    "label": "FRegisterPassProcessorCreateFunction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRegisterPassProcessorCreateFunction"
  },
  {
    "label": "MESH_DRAW_COMMAND_DEBUG_DATA()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" MeshDrawShaderBindings . h \" # include \" MeshMaterialShader . h \" # include \" SceneUtils . h \" # include \" MeshBatch . h \" # include \" MeshDrawCommandStatsDefines . h \" # include \" PSOPrecacheMaterial . h \" # include \" Hash / CityHash . h \" # include \" Experimental / Containers / RobinHoodHashTable . h \" # include \" RHIImmutableSamplerState . h \" # include<atomic> # define)",
    "insertText": "MESH_DRAW_COMMAND_DEBUG_DATA((!UE_BUILD_SHIPPING && !UE_BUILD_TEST) || VALIDATE_MESH_COMMAND_BINDINGS || WANTS_DRAW_MESH_EVENTS || WITH_DEBUG_VIEW_MODES)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (class FInstanceCullingDrawParams ; class FRayTracingLocalShaderBindingWriter ; struct FMeshProcessorShaders ; struct FSceneTexturesConfig ; struct FVisibleMeshDrawCommandStatsData ; namespace EMeshPass { enum Type : uint8 { DepthPass,SecondStageDepthPass,BasePass,AnisotropyPass,SkyPass,SingleLayerWaterPass,SingleLayerWaterDepthPrepass,CSMShadowDepth,VSMShadowDepth,OnePassPointLightShadowDepth,Distortion,Velocity,TranslucentVelocity,TranslucencyStandard,TranslucencyStandardModulate,TranslucencyAfterDOF,TranslucencyAfterDOFModulate,TranslucencyAfterMotionBlur,TranslucencyHoldout,TranslucencyAll,LightmapDensity,DebugViewMode,CustomDepth,MobileBasePassCSM,VirtualTexture,LumenCardCapture,LumenCardNanite,LumenTranslucencyRadianceCacheMark,LumenFrontLayerTranslucencyGBuffer,DitheredLODFadingOutMaskPass,NaniteMeshPass,MeshDecal_DBuffer,MeshDecal_SceneColorAndGBuffer,MeshDecal_SceneColorAndGBufferNoNormal,MeshDecal_SceneColor,MeshDecal_AmbientOcclusion,WaterInfoTextureDepthPass,WaterInfoTexturePass,# if WITH_EDITOR HitProxy,HitProxyOpaqueOnly,EditorLevelInstance,EditorSelection,# endif Num,NumBits = 6,} ; })",
    "insertText": "static_assert(EMeshPass::Num <= (1 << EMeshPass::NumBits), \"EMeshPass::Num will not fit in EMeshPass::NumBits\")"
  },
  {
    "label": "GetMeshPassName()",
    "kind": "Method",
    "detail": "Function (const TCHAR*)",
    "insertText": "GetMeshPassName(EMeshPass::Type MeshPass)"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR case EMeshPass::HitProxy : return)",
    "insertText": "TEXT(\"HitProxy\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# endif } # if WITH_EDITOR)",
    "insertText": "static_assert(EMeshPass::Num == 38 + 4, \"Need to update switch(MeshPass) after changing EMeshPass\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "static_assert(EMeshPass::Num == 38, \"Need to update switch(MeshPass) after changing EMeshPass\")"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "checkf(0, TEXT(\"Missing case for EMeshPass %u\"), (uint32)MeshPass)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(EMeshPass::Type Pass)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Data(uint64(1) << Pass)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Get(EMeshPass::Type Pass)"
  },
  {
    "label": "SkipEmpty()",
    "kind": "Method",
    "detail": "Function (} EMeshPass::Type)",
    "insertText": "SkipEmpty(EMeshPass::Type Pass)"
  },
  {
    "label": "Type()",
    "kind": "Method",
    "detail": "Function (uint64 Mask = 0 xFFffFFffFFffFFffULL<<Pass ; return)",
    "insertText": "Type(FMath::Min<uint64>(EMeshPass::Num, FMath::CountTrailingZeros64(Data & Mask)))"
  },
  {
    "label": "GetNum()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetNum()"
  },
  {
    "label": "AppendTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendTo(FMeshPassMask& Mask)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (Mask . Data | = Data ; } void)",
    "insertText": "Reset()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (Data = 0 ; } bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "AsBoundShaderState()",
    "kind": "Method",
    "detail": "Function (} FBoundShaderStateInput)",
    "insertText": "AsBoundShaderState()"
  },
  {
    "label": "AllowSkipUnloadedShaders()",
    "kind": "Method",
    "detail": "Function (bool bLocalAllShaderAreLoaded = true ; bool bCanSkipShader =)",
    "insertText": "AllowSkipUnloadedShaders()"
  },
  {
    "label": "bLocalAllShaderAreLoaded()",
    "kind": "Method",
    "detail": "Function (FRHIShader*)",
    "insertText": "bLocalAllShaderAreLoaded(FRHIShader* Shader)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bLocalAllShaderAreLoaded& = false ; } return Shader ; } ;)",
    "insertText": "if(!CachedVertexShader || !bAllShaderAreLoaded)"
  },
  {
    "label": "FRHIPixelShader()",
    "kind": "Method",
    "detail": "Function (CachedPixelShader = PixelShaderResource ? static_cast<)",
    "insertText": "FRHIPixelShader(GetShaderResource(PixelShaderResource->GetShader(PixelShaderIndex, !bCanSkipShader)))"
  },
  {
    "label": "FRHIGeometryShader()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_SUPPORTS_GEOMETRY_SHADERS CachedGeometryShader = GeometryShaderResource ? static_cast<)",
    "insertText": "FRHIGeometryShader(GeometryShaderResource->GetShader(GeometryShaderIndex))"
  },
  {
    "label": "FRHIMeshShader()",
    "kind": "Method",
    "detail": "Function (# endif # if PLATFORM_SUPPORTS_MESH_SHADERS CachedMeshShader = MeshShaderResource ? static_cast<)",
    "insertText": "FRHIMeshShader(MeshShaderResource->GetShader(MeshShaderIndex))"
  },
  {
    "label": "FRHIVertexShader()",
    "kind": "Method",
    "detail": "Function (# endif CachedVertexShader = VertexShaderResource ? static_cast<)",
    "insertText": "FRHIVertexShader(GetShaderResource(VertexShaderResource->GetShader(VertexShaderIndex, !bCanSkipShader)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bAllShaderAreLoaded = bLocalAllShaderAreLoaded ; } # if PLATFORM_SUPPORTS_MESH_SHADERS)",
    "insertText": "if(CachedMeshShader)"
  },
  {
    "label": "FBoundShaderStateInput()",
    "kind": "Method",
    "detail": "Function (} else # endif { return)",
    "insertText": "FBoundShaderStateInput(VertexDeclarationRHI , CachedVertexShader , CachedPixelShader #if PLATFORM_SUPPORTS_GEOMETRY_SHADERS , CachedGeometryShader #endif)"
  },
  {
    "label": "IsShaderAllLoaded()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsShaderAllLoaded()"
  },
  {
    "label": "FRHIPixelShader()",
    "kind": "Method",
    "detail": "Function (CachedPixelShader = PixelShaderResource ? static_cast<)",
    "insertText": "FRHIPixelShader(PixelShaderResource->GetShader(PixelShaderIndex))"
  },
  {
    "label": "FRHIVertexShader()",
    "kind": "Method",
    "detail": "Function (# endif CachedVertexShader = VertexShaderResource ? static_cast<)",
    "insertText": "FRHIVertexShader(VertexShaderResource->GetShader(VertexShaderIndex))"
  },
  {
    "label": "LazilyInitShaders()",
    "kind": "Method",
    "detail": "Function (bAllShaderAreLoaded = true ; } } void)",
    "insertText": "LazilyInitShaders()"
  },
  {
    "label": "NeedsShaderInitialisation()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "NeedsShaderInitialisation()"
  },
  {
    "label": "FGraphicsMinimalPipelineStateInitializer()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FGraphicsMinimalPipelineStateInitializer(FMinimalBoundShaderStateInput InBoundShaderState, FRHIBlendState* InBlendState, FRHIRasterizerState* InRasterizerState, FRHIDepthStencilState* InDepthStencilState, FImmutableSamplerState InImmutableSamplerState, EPrimitiveType InPrimitiveType ) : BoundShaderState(InBoundShaderState) , BlendState(InBlendState) , RasterizerState(InRasterizerState) , DepthStencilState(InDepthStencilState) , ImmutableSamplerState(InImmutableSamplerState) , PrimitiveType(InPrimitiveType)"
  },
  {
    "label": "FGraphicsMinimalPipelineStateInitializer()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FGraphicsMinimalPipelineStateInitializer(const FGraphicsMinimalPipelineStateInitializer& InMinimalState) : BoundShaderState(InMinimalState.BoundShaderState) , BlendState(InMinimalState.BlendState) , RasterizerState(InMinimalState.RasterizerState) , DepthStencilState(InMinimalState.DepthStencilState) , ImmutableSamplerState(InMinimalState.ImmutableSamplerState) , bDepthBounds(InMinimalState.bDepthBounds) , bAllowVariableRateShading(InMinimalState.bAllowVariableRateShading) , DrawShadingRate(InMinimalState.DrawShadingRate) , PrimitiveType(InMinimalState.PrimitiveType) , StatePrecachePSOHash(InMinimalState.StatePrecachePSOHash) , PSOPrecacheState(InMinimalState.PSOPrecacheState)"
  },
  {
    "label": "SetupBoundShaderState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetupBoundShaderState(FRHIVertexDeclaration* VertexDeclaration, const FMeshProcessorShaders& Shaders)"
  },
  {
    "label": "ComputeStatePrecachePSOHash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeStatePrecachePSOHash()"
  },
  {
    "label": "AsGraphicsPipelineStateInitializer()",
    "kind": "Method",
    "detail": "Function (FGraphicsPipelineStateInitializer)",
    "insertText": "AsGraphicsPipelineStateInitializer()"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (FGraphicsPipelineStateInitializer)",
    "insertText": "result(BoundShaderState.AsBoundShaderState() , BlendState , RasterizerState , DepthStencilState , ImmutableSamplerState , PrimitiveType , 0 , FGraphicsPipelineStateInitializer::TRenderTargetFormats(InPlace, PF_Unknown) , FGraphicsPipelineStateInitializer::TRenderTargetFlags(InPlace, TexCreate_None) , PF_Unknown , TexCreate_None , ERenderTargetLoadAction::ENoAction , ERenderTargetStoreAction::ENoAction , ERenderTargetLoadAction::ENoAction , ERenderTargetStoreAction::ENoAction , FExclusiveDepthStencil::DepthNop , 0 , ESubpassHint::None , 0 , EConservativeRasterization::Disabled , 0 , bDepthBounds , 0 , false , bAllowVariableRateShading , DrawShadingRate)"
  },
  {
    "label": "RHIComputeStatePrecachePSOHash()",
    "kind": "Method",
    "detail": "Function (result . StatePrecachePSOHash = StatePrecachePSOHash = = 0 ?)",
    "insertText": "RHIComputeStatePrecachePSOHash(result)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return result ; } bool)",
    "insertText": "operator(const FGraphicsMinimalPipelineStateInitializer& rhs)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(const FGraphicsMinimalPipelineStateInitializer& Initializer)"
  },
  {
    "label": "PointerHash()",
    "kind": "Method",
    "detail": "Function (struct FHashKey { uint32 VertexDeclaration ; uint32 VertexShader ; uint32 PixelShader ; uint32 RasterizerState ; } HashKey ; HashKey . VertexDeclaration =)",
    "insertText": "PointerHash(Initializer.BoundShaderState.VertexDeclarationRHI)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (HashKey . VertexShader =)",
    "insertText": "GetTypeHash(Initializer.BoundShaderState.VertexShaderIndex)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (HashKey . PixelShader =)",
    "insertText": "GetTypeHash(Initializer.BoundShaderState.PixelShaderIndex)"
  },
  {
    "label": "PointerHash()",
    "kind": "Method",
    "detail": "Function (HashKey . RasterizerState =)",
    "insertText": "PointerHash(Initializer.RasterizerState)"
  },
  {
    "label": "COMPARE_FIELD_BEGIN()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "COMPARE_FIELD_BEGIN(Field) \\ if (Field != rhs.Field)"
  },
  {
    "label": "COMPARE_FIELD_BEGIN()",
    "kind": "Method",
    "detail": "Function (# define COMPARE_OP<)",
    "insertText": "COMPARE_FIELD_BEGIN(BoundShaderState.VertexDeclarationRHI) COMPARE_FIELD(BoundShaderState.VertexShaderIndex) COMPARE_FIELD(BoundShaderState.PixelShaderIndex) COMPARE_FIELD(BoundShaderState.VertexShaderResource) COMPARE_FIELD(BoundShaderState.PixelShaderResource) #if PLATFORM_SUPPORTS_GEOMETRY_SHADERS COMPARE_FIELD(BoundShaderState.GeometryShaderIndex) COMPARE_FIELD(BoundShaderState.GeometryShaderResource) #endif COMPARE_FIELD(BlendState) COMPARE_FIELD(RasterizerState) COMPARE_FIELD(DepthStencilState) COMPARE_FIELD(bDepthBounds) COMPARE_FIELD(bAllowVariableRateShading) COMPARE_FIELD(DrawShadingRate) COMPARE_FIELD(PrimitiveType)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# undef COMPARE_OP } # undef COMPARE_FIELD_BEGIN # undef COMPARE_FIELD # undef COMPARE_FIELD_END FMinimalBoundShaderStateInput BoundShaderState ; FRHIBlendState* BlendState ; FRHIRasterizerState* RasterizerState ; FRHIDepthStencilState* DepthStencilState ; FImmutableSamplerState ImmutableSamplerState ; bool bDepthBounds = false ; bool bAllowVariableRateShading = true ; EVRSShadingRate DrawShadingRate = EVRSShadingRate::VRSSR_1x1 ; EPrimitiveType PrimitiveType ; uint64 StatePrecachePSOHash = 0 ; EPSOPrecacheResult PSOPrecacheState = EPSOPrecacheResult::Unknown ; } ;)",
    "insertText": "static_assert(sizeof(FMeshPassMask::Data) * 8 >= EMeshPass::Num, \"FMeshPassMask::Data is too small to fit all mesh passes.\")"
  },
  {
    "label": "GetId()",
    "kind": "Method",
    "detail": "Function (typedef Experimental::TRobinHoodHashSet<FGraphicsMinimalPipelineStateInitializer> FGraphicsMinimalPipelineStateSet ; class FGraphicsMinimalPipelineStateId { public : uint32)",
    "insertText": "GetId()"
  },
  {
    "label": "GetPipelineState()",
    "kind": "Method",
    "detail": "Function (} const FGraphicsMinimalPipelineStateInitializer&)",
    "insertText": "GetPipelineState(const FGraphicsMinimalPipelineStateSet& InPipelineSet)"
  },
  {
    "label": "ReadLock()",
    "kind": "Method",
    "detail": "Function (} { FRWScopeLock)",
    "insertText": "ReadLock(PersistentIdTableLock, SLT_ReadOnly)"
  },
  {
    "label": "GetByElementId()",
    "kind": "Method",
    "detail": "Function (const auto& Result = PersistentIdTable .)",
    "insertText": "GetByElementId(SetElementIndex)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (# if MESH_DRAW_COMMAND_DEBUG_DATA)",
    "insertText": "checkf(Result.Value.RefNum && Result.Value.DebugSalt == DebugSalt, TEXT(\"Pipeline state ID used after release. Call 'AddRefPersistentId' to ensure pipeline state doesn't get released while in use.\"))"
  },
  {
    "label": "InitializePersistentIds()",
    "kind": "Method",
    "detail": "Function (# endif return Result . Key ; } } void)",
    "insertText": "InitializePersistentIds()"
  },
  {
    "label": "GetPersistentId()",
    "kind": "Method",
    "detail": "Function (FGraphicsMinimalPipelineStateId)",
    "insertText": "GetPersistentId(const FGraphicsMinimalPipelineStateInitializer& InPipelineState)"
  },
  {
    "label": "RemovePersistentId()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemovePersistentId(FGraphicsMinimalPipelineStateId Id)"
  },
  {
    "label": "GetPipelineStateId()",
    "kind": "Method",
    "detail": "Function (FGraphicsMinimalPipelineStateId)",
    "insertText": "GetPipelineStateId(const FGraphicsMinimalPipelineStateInitializer& InPipelineState, FGraphicsMinimalPipelineStateSet& InOutPassSet, bool& NeedsShaderInitialisation)"
  },
  {
    "label": "GetLocalPipelineIdTableSize()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetLocalPipelineIdTableSize()"
  },
  {
    "label": "ResetLocalPipelineIdTableSize()",
    "kind": "Method",
    "detail": "Function (# if MESH_DRAW_COMMAND_DEBUG_DATA return LocalPipelineIdTableSize ; # else return 0 ; # endif } void)",
    "insertText": "ResetLocalPipelineIdTableSize()"
  },
  {
    "label": "AddSizeToLocalPipelineIdTableSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddSizeToLocalPipelineIdTableSize(SIZE_T Size)"
  },
  {
    "label": "GetPersistentIdTableSize()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetPersistentIdTableSize()"
  },
  {
    "label": "GetPersistentIdNum()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetPersistentIdNum()"
  },
  {
    "label": "FreezeIdTable()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FreezeIdTable(bool bEnable)"
  },
  {
    "label": "FRefCountedGraphicsMinimalPipelineState()",
    "kind": "Method",
    "detail": "Function (private : union { uint32 PackedId = 0 ; struct { uint32 SetElementIndex : 3 0 ; uint32 bComesFromLocalPipelineStateSet : 1 ; uint32 bValid : 1 ; } ; } ; struct FRefCountedGraphicsMinimalPipelineState {)",
    "insertText": "FRefCountedGraphicsMinimalPipelineState() : RefNum(0)"
  },
  {
    "label": "FRefCountedGraphicsMinimalPipelineState()",
    "kind": "Method",
    "detail": "Function (# if MESH_DRAW_COMMAND_DEBUG_DATA DebugSalt = DebugSaltAllocationIndex + + ; # endif })",
    "insertText": "FRefCountedGraphicsMinimalPipelineState(const FRefCountedGraphicsMinimalPipelineState&& Other) : RefNum(Other.RefNum.load())"
  },
  {
    "label": "GetShader()",
    "kind": "Method",
    "detail": "Function (# if MESH_DRAW_COMMAND_DEBUG_DATA DebugSalt = Other . DebugSalt ; # endif } std::atomic<uint32> RefNum ; # if MESH_DRAW_COMMAND_DEBUG_DATA int32 DebugSalt ; # endif } ; FRWLock PersistentIdTableLock ; using PersistentTableType = Experimental::TRobinHoodHashMap<FGraphicsMinimalPipelineStateInitializer,FRefCountedGraphicsMinimalPipelineState> ; PersistentTableType PersistentIdTable ; bool NeedsShaderInitialisation ; bool bIsIdTableFrozen ; std::atomic<int32> ReffedItemCount ; # if MESH_DRAW_COMMAND_DEBUG_DATA int32 DebugSalt ; std::atomic<int32> DebugSaltAllocationIndex ; std::atomic<int32> LocalPipelineIdTableSize ; std::atomic<int32> CurrentLocalPipelineIdTableSize ; # endif } ; class FShaderBindingState { enum { MAX_UNIFORM_BUFFERS_PER_STAGE = 1 4 } ; public : int32 MaxUniformBufferUsed = - 1 ; FRHIUniformBuffer* UniformBuffers [ MAX_UNIFORM_BUFFERS_PER_STAGE ] = { } ; } ; struct FMeshProcessorShaders { TShaderRef<FShader> VertexShader ; TShaderRef<FShader> PixelShader ; TShaderRef<FShader> GeometryShader ; TShaderRef<FShader> ComputeShader ; TShaderRef<FShader> WorkGraphShader ; # if RHI_RAYTRACING TShaderRef<FShader> RayTracingShader ; # endif TShaderRef<FShader>)",
    "insertText": "GetShader(EShaderFrequency Frequency)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (} return RayTracingShader ; } # endif)",
    "insertText": "checkf(0, TEXT(\"Unhandled shader frequency\"))"
  },
  {
    "label": "GetValidShaders()",
    "kind": "Method",
    "detail": "Function (} TArray<TShaderRef<FShader>,TInlineAllocator<3>>)",
    "insertText": "GetValidShaders()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<TShaderRef<FShader>,TInlineAllocator<3>> Shaders ;)",
    "insertText": "if(VertexShader.IsValid())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Shaders .)",
    "insertText": "Add(VertexShader)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(PixelShader.IsValid())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Shaders .)",
    "insertText": "Add(PixelShader)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(GeometryShader.IsValid())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Shaders .)",
    "insertText": "Add(GeometryShader)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ComputeShader.IsValid())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Shaders .)",
    "insertText": "Add(ComputeShader)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # if RHI_RAYTRACING)",
    "insertText": "if(RayTracingShader.IsValid())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Shaders .)",
    "insertText": "Add(RayTracingShader)"
  },
  {
    "label": "FMeshDrawCommandStateCache()",
    "kind": "Method",
    "detail": "Function (} # endif return Shaders ; } } ; const int32 NumInlineShaderBindings = 1 0 ; struct FMeshDrawCommandDebugData { # if MESH_DRAW_COMMAND_DEBUG_DATA TShaderRef<FShader> VertexShader ; TShaderRef<FShader> PixelShader ; const FPrimitiveSceneProxy* PrimitiveSceneProxyIfNotUsingStateBuckets ; const FMaterial* Material ; const FMaterialRenderProxy* MaterialRenderProxy ; # if PSO_PRECACHING_VALIDATE const FVertexFactory* VertexFactory ; const FVertexFactoryType* VertexFactoryType ; # endif FName ResourceName ; # if PSO_PRECACHING_VALIDATE uint32 PSOCollectorIndex ; # endif int8 LODIndex ; int32 SegmentIndex ; # endif } ; struct FMeshDrawCommandStatsData { # if MESH_DRAW_COMMAND_STATS FName CategoryName ; # endif } ; class FMeshDrawCommandStateCache { public : uint32 PipelineId ; uint32 StencilRef ; FShaderBindingState ShaderBindings [ SF_NumStandardFrequencies ] ; FVertexInputStream VertexStreams [ MaxVertexElementCount ] ;)",
    "insertText": "FMeshDrawCommandStateCache()"
  },
  {
    "label": "SetPipelineState()",
    "kind": "Method",
    "detail": "Function (PipelineId = - 1 ; StencilRef = - 1 ; } void)",
    "insertText": "SetPipelineState(int32 NewPipelineId)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (PipelineId = NewPipelineId ; StencilRef = - 1 ;)",
    "insertText": "for(int32 VertexStreamIndex = 0; VertexStreamIndex < UE_ARRAY_COUNT(VertexStreams); ++VertexStreamIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (VertexStreams [ VertexStreamIndex ] . VertexBuffer = nullptr ; })",
    "insertText": "for(int32 FrequencyIndex = 0; FrequencyIndex < UE_ARRAY_COUNT(ShaderBindings); FrequencyIndex++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FShaderBindingState& RESTRICT ShaderBinding = ShaderBindings [ FrequencyIndex ] ;)",
    "insertText": "for(int32 SlotIndex = 0; SlotIndex <= ShaderBinding.MaxUniformBufferUsed; SlotIndex++)"
  },
  {
    "label": "InvalidateUniformBuffer()",
    "kind": "Method",
    "detail": "Function (ShaderBinding . UniformBuffers [ SlotIndex ] = nullptr ; } ShaderBinding . MaxUniformBufferUsed = - 1 ; } } void)",
    "insertText": "InvalidateUniformBuffer(const FRHIUniformBuffer* UniformBuffer)"
  },
  {
    "label": "FMeshDrawShaderBindings()",
    "kind": "Method",
    "detail": "Function (ShaderBinding . UniformBuffers [ SlotIndex ] = nullptr ; } } } } } ; class FMeshDrawShaderBindings { public :)",
    "insertText": "FMeshDrawShaderBindings()"
  },
  {
    "label": "FMeshDrawShaderBindings()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FMeshDrawShaderBindings(FMeshDrawShaderBindings&& Other)"
  },
  {
    "label": "GetHeapData()",
    "kind": "Method",
    "detail": "Function (delete [ ] Data .)",
    "insertText": "GetHeapData()"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (} Size = Other . Size ; ShaderFrequencyBits = Other . ShaderFrequencyBits ; ShaderLayouts =)",
    "insertText": "MoveTemp(Other.ShaderLayouts)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Data =)",
    "insertText": "MoveTemp(Other.Data)"
  },
  {
    "label": "SetHeapData()",
    "kind": "Method",
    "detail": "Function (} else { Data .)",
    "insertText": "SetHeapData(Other.Data.GetHeapData())"
  },
  {
    "label": "SetHeapData()",
    "kind": "Method",
    "detail": "Function (Other . Data .)",
    "insertText": "SetHeapData(nullptr)"
  },
  {
    "label": "FMeshDrawShaderBindings()",
    "kind": "Method",
    "detail": "Function (} Other . Size = 0 ; })",
    "insertText": "FMeshDrawShaderBindings(const FMeshDrawShaderBindings& Other)"
  },
  {
    "label": "CopyFrom()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyFrom(Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FMeshDrawShaderBindings&)",
    "insertText": "operator(const FMeshDrawShaderBindings& Other)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} Other . Size = 0 ; return* this ; } void)",
    "insertText": "Initialize(const FMeshProcessorShaders& Shaders)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize(const TShaderRef<FShader>& Shader)"
  },
  {
    "label": "Finalize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Finalize(const FMeshProcessorShaders* ShadersForDebugging)"
  },
  {
    "label": "CountBits()",
    "kind": "Method",
    "detail": "Function (int FrequencyIndex =)",
    "insertText": "CountBits(ShaderFrequencyBits & ((1 << (Frequency + 1)) - 1))"
  },
  {
    "label": "DO_CHECK()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DO_CHECK(UE_BUILD_TEST || UE_BUILD_SHIPPING)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "checkf(CheckedDataOffset == DataOffset, TEXT(\"GetSingleShaderBindings was not called in the order of ShaderFrequencies\"))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(FrequencyIndex >= 0)"
  },
  {
    "label": "GetDataSizeBytes()",
    "kind": "Method",
    "detail": "Function (int32 StartDataOffset = DataOffset ; DataOffset + = ShaderLayouts [ FrequencyIndex ] .)",
    "insertText": "GetDataSizeBytes()"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "checkf(0, TEXT(\"Invalid shader binding frequency requested\"))"
  },
  {
    "label": "GetSingleShaderBindings()",
    "kind": "Method",
    "detail": "Function (} FMeshDrawSingleShaderBindings)",
    "insertText": "GetSingleShaderBindings(EShaderFrequency Frequency)"
  },
  {
    "label": "GetSingleShaderBindings()",
    "kind": "Method",
    "detail": "Function (int32 DataOffset = 0 ; return)",
    "insertText": "GetSingleShaderBindings(Frequency, DataOffset)"
  },
  {
    "label": "SetOnCommandList()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetOnCommandList(FRHICommandList& RHICmdList, const FBoundShaderStateInput& Shaders, class FShaderBindingState* StateCacheShaderBindings)"
  },
  {
    "label": "SetParameters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetParameters(FRHIBatchedShaderParameters& BatchedParameters, class FShaderBindingState* StateCacheShaderBindings = nullptr)"
  },
  {
    "label": "SetOnCommandList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOnCommandList(FRHIComputeCommandList& RHICmdList, FRHIComputeShader* Shader, class FShaderBindingState* StateCacheShaderBindings = nullptr)"
  },
  {
    "label": "SetParameters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetParameters(BatchedParameters, StateCacheShaderBindings)"
  },
  {
    "label": "SetRayTracingShaderBindings()",
    "kind": "Method",
    "detail": "Function (} # if RHI_RAYTRACING FRayTracingLocalShaderBindings*)",
    "insertText": "SetRayTracingShaderBindings(FRayTracingLocalShaderBindingWriter* BindingWriter, uint32 ShaderIndexInPipeline, uint32 RecordIndex, uint32 UserData = 0)"
  },
  {
    "label": "SetRayTracingShaderBindingsForHitGroup()",
    "kind": "Method",
    "detail": "Function (FRayTracingLocalShaderBindings*)",
    "insertText": "SetRayTracingShaderBindingsForHitGroup(FRayTracingLocalShaderBindingWriter* BindingWriter, uint32 RecordIndex, const FRHIRayTracingGeometry* Geometry, uint32 GeometrySegmentIndex, uint32 HitGroupIndexInPipeline)"
  },
  {
    "label": "SetRayTracingShaderBindingsForMissShader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetRayTracingShaderBindingsForMissShader(FRHICommandList& RHICmdList, FRHIShaderBindingTable* SBT, uint32 RecordIndex, FRayTracingPipelineState* Pipeline, uint32 ShaderIndexInPipeline)"
  },
  {
    "label": "MatchesForDynamicInstancing()",
    "kind": "Method",
    "detail": "Function (# endif bool)",
    "insertText": "MatchesForDynamicInstancing(const FMeshDrawShaderBindings& Rhs)"
  },
  {
    "label": "GetDynamicInstancingHash()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetDynamicInstancingHash()"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "GetShaderFrequencies()",
    "kind": "Method",
    "detail": "Function (Bytes + = Size ; } return Bytes ; } void)",
    "insertText": "GetShaderFrequencies(TArray<EShaderFrequency, TInlineAllocator<SF_NumFrequencies>>& OutShaderFrequencies)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (OutShaderFrequencies .)",
    "insertText": "Empty(ShaderLayouts.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutShaderFrequencies .)",
    "insertText": "Add(EShaderFrequency(BindingIndex))"
  },
  {
    "label": "GetDataSize()",
    "kind": "Method",
    "detail": "Function (} } } int32)",
    "insertText": "GetDataSize()"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (InlineStorage [ 0 ] = HeapData ; } } Data = { } ; uint16 ShaderFrequencyBits = 0 ; uint16 Size = 0 ; void)",
    "insertText": "Allocate(uint16 InSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Size = InSize ;)",
    "insertText": "if(InSize > sizeof(FData))"
  },
  {
    "label": "SetHeapData()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "SetHeapData(new uint8[InSize])"
  },
  {
    "label": "AllocateZeroed()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "AllocateZeroed(uint16 InSize)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Allocate(InSize)"
  },
  {
    "label": "Memzero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memzero(GetData(), InSize)"
  },
  {
    "label": "UsesInlineStorage()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "UsesInlineStorage()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} uint8*)",
    "insertText": "GetData()"
  },
  {
    "label": "CopyFrom()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CopyFrom(const FMeshDrawShaderBindings& Other)"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Release()"
  },
  {
    "label": "SetShaderBindings()",
    "kind": "Method",
    "detail": "Function (} ; class FReadOnlyMeshDrawSingleShaderBindings : public FMeshDrawShaderBindingsLayout { public : void)",
    "insertText": "SetShaderBindings(FRHIBatchedShaderParameters& BatchedParameters, const class FReadOnlyMeshDrawSingleShaderBindings& RESTRICT SingleShaderBindings, FShaderBindingState& RESTRICT ShaderBindingState)"
  },
  {
    "label": "SetShaderBindings()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetShaderBindings(FRHIBatchedShaderParameters& BatchedParameters, const class FReadOnlyMeshDrawSingleShaderBindings& RESTRICT SingleShaderBindings)"
  },
  {
    "label": "FReadOnlyMeshDrawSingleShaderBindings()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FReadOnlyMeshDrawSingleShaderBindings(const FMeshDrawSingleShaderBindings& Bindings) : FMeshDrawShaderBindingsLayout(Bindings)"
  },
  {
    "label": "FReadOnlyMeshDrawSingleShaderBindings()",
    "kind": "Method",
    "detail": "Function (Data = Bindings . Data ; })",
    "insertText": "FReadOnlyMeshDrawSingleShaderBindings(const FMeshDrawShaderBindingsLayout& InLayout, const uint8* InData) : FMeshDrawShaderBindingsLayout(InLayout)"
  },
  {
    "label": "GetUniformBufferStart()",
    "kind": "Method",
    "detail": "Function (Data = InData ; } FRHIUniformBuffer* const*)",
    "insertText": "GetUniformBufferStart()"
  },
  {
    "label": "GetSamplerStart()",
    "kind": "Method",
    "detail": "Function (} FRHISamplerState**)",
    "insertText": "GetSamplerStart()"
  },
  {
    "label": "GetSamplerOffset()",
    "kind": "Method",
    "detail": "Function (const uint8* SamplerDataStart = Data +)",
    "insertText": "GetSamplerOffset()"
  },
  {
    "label": "GetSRVStart()",
    "kind": "Method",
    "detail": "Function (} FRHIResource**)",
    "insertText": "GetSRVStart()"
  },
  {
    "label": "GetSRVOffset()",
    "kind": "Method",
    "detail": "Function (const uint8* SRVDataStart = Data +)",
    "insertText": "GetSRVOffset()"
  },
  {
    "label": "GetSRVTypeStart()",
    "kind": "Method",
    "detail": "Function (} const uint8*)",
    "insertText": "GetSRVTypeStart()"
  },
  {
    "label": "GetSRVTypeOffset()",
    "kind": "Method",
    "detail": "Function (const uint8* SRVTypeDataStart = Data +)",
    "insertText": "GetSRVTypeOffset()"
  },
  {
    "label": "GetLooseDataOffset()",
    "kind": "Method",
    "detail": "Function (const uint8* LooseDataStart = Data +)",
    "insertText": "GetLooseDataOffset()"
  },
  {
    "label": "FMeshDrawCommandSceneArgs()",
    "kind": "Method",
    "detail": "Function (InstanceBuffer = nullptr ; IndirectArgsBuffer = nullptr ; InstanceDataByteOffset = 0 u ; IndirectArgsByteOffset = 0 u ; } } ; struct FMeshDrawCommandSceneArgs { FRHIBuffer* PrimitiveIdsBuffer ; FRHIBuffer* IndirectArgsBuffer ; uint32 PrimitiveIdOffset ; uint32 IndirectArgsByteOffset ; FUniformBufferStaticSlot BatchedPrimitiveSlot ;)",
    "insertText": "FMeshDrawCommandSceneArgs()"
  },
  {
    "label": "FMeshDrawCommand()",
    "kind": "Method",
    "detail": "Function (PrimitiveIdsBuffer = nullptr ; IndirectArgsBuffer = nullptr ; PrimitiveIdOffset = 0 u ; IndirectArgsByteOffset = 0 u ; BatchedPrimitiveSlot = MAX_UNIFORM_BUFFER_STATIC_SLOTS ; } } ; class FMeshDrawCommand { public : FMeshDrawShaderBindings ShaderBindings ; FVertexInputStreamArray VertexStreams ; FRHIBuffer* IndexBuffer ; FGraphicsMinimalPipelineStateId CachedPipelineId ; uint32 FirstIndex ; uint32 NumPrimitives ; uint32 NumInstances ; union { struct { uint32 BaseVertexIndex ; uint32 NumVertices ; } VertexParams ; struct { FRHIBuffer* Buffer ; uint32 Offset ; } IndirectArgs ; } ; int8 PrimitiveIdStreamIndex ; uint8 StencilRef ; EPrimitiveType PrimitiveType : PT_NumBits ;)",
    "insertText": "FMeshDrawCommand()"
  },
  {
    "label": "FMeshDrawCommand()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "FMeshDrawCommand(FMeshDrawCommand&& Other)"
  },
  {
    "label": "FMeshDrawCommand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FMeshDrawCommand(const FMeshDrawCommand& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FMeshDrawCommand&)",
    "insertText": "operator(const FMeshDrawCommand& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FMeshDrawCommand&)",
    "insertText": "operator(FMeshDrawCommand&& Other)"
  },
  {
    "label": "MatchesForDynamicInstancing()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MatchesForDynamicInstancing(const FMeshDrawCommand& Rhs)"
  },
  {
    "label": "PointerHash()",
    "kind": "Method",
    "detail": "Function (struct FHashKey { uint32 IndexBuffer ; uint32 VertexBuffers = 0 ; uint32 VertexStreams = 0 ; uint32 PipelineId ; uint32 DynamicInstancingHash ; uint32 FirstIndex ; uint32 NumPrimitives ; uint32 NumInstances ; uint32 IndirectArgsBufferOrBaseVertexIndex ; uint32 NumVertices ; uint32 StencilRefAndPrimitiveIdStreamIndex ; uint32)",
    "insertText": "PointerHash(const void* Key)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_64BITS return static_cast<)",
    "insertText": "uint32(reinterpret_cast<UPTRINT>(Key) >> 4)"
  },
  {
    "label": "UPTRINT()",
    "kind": "Method",
    "detail": "Function (# else return reinterpret_cast<)",
    "insertText": "UPTRINT(Key)"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (# endif } ; uint32)",
    "insertText": "HashCombine(uint32 A, uint32 B)"
  },
  {
    "label": "StencilRef()",
    "kind": "Method",
    "detail": "Function (HashKey . StencilRefAndPrimitiveIdStreamIndex =)",
    "insertText": "StencilRef(PrimitiveIdStreamIndex << 8)"
  },
  {
    "label": "Packed()",
    "kind": "Method",
    "detail": "Function (const FVertexInputStream& VertexInputStream = VertexStreams [ index ] ; const uint32 StreamIndex = VertexInputStream . StreamIndex ; const uint32 Offset = VertexInputStream . Offset ; uint32)",
    "insertText": "Packed(StreamIndex << 28)"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (HashKey . VertexStreams =)",
    "insertText": "HashCombine(HashKey.VertexStreams, Packed)"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (HashKey . VertexBuffers =)",
    "insertText": "HashCombine(HashKey.VertexBuffers, FHashKey::PointerHash(VertexInputStream.Pointer))"
  },
  {
    "label": "PointerHash()",
    "kind": "Method",
    "detail": "Function (} HashKey . IndexBuffer =)",
    "insertText": "PointerHash(IndexBuffer)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (HashKey . FirstIndex = FirstIndex ; HashKey . NumPrimitives = NumPrimitives ; HashKey . NumInstances = NumInstances ;)",
    "insertText": "if(NumPrimitives > 0)"
  },
  {
    "label": "PointerHash()",
    "kind": "Method",
    "detail": "Function (HashKey . IndirectArgsBufferOrBaseVertexIndex = VertexParams . BaseVertexIndex ; HashKey . NumVertices = VertexParams . NumVertices ; } else { HashKey . IndirectArgsBufferOrBaseVertexIndex =)",
    "insertText": "PointerHash(IndirectArgs.Buffer)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (HashKey . NumVertices = IndirectArgs . Offset ; } return)",
    "insertText": "uint32(CityHash64((char*)&HashKey, sizeof(FHashKey)))"
  },
  {
    "label": "InitializeShaderBindings()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitializeShaderBindings(const FMeshProcessorShaders& Shaders)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (ShaderBindings .)",
    "insertText": "Initialize(Shaders)"
  },
  {
    "label": "SetStencilRef()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetStencilRef(uint32 InStencilRef)"
  },
  {
    "label": "uint8()",
    "kind": "Method",
    "detail": "Function (StencilRef = static_cast<)",
    "insertText": "uint8(InStencilRef)"
  },
  {
    "label": "SetDrawParametersAndFinalize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetDrawParametersAndFinalize(const FMeshBatch& MeshBatch, int32 BatchElementIndex, FGraphicsMinimalPipelineStateId PipelineId, const FMeshProcessorShaders* ShadersForDebugging)"
  },
  {
    "label": "Finalize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Finalize(FGraphicsMinimalPipelineStateId PipelineId, const FMeshProcessorShaders* ShadersForDebugging)"
  },
  {
    "label": "Finalize()",
    "kind": "Method",
    "detail": "Function (CachedPipelineId = PipelineId ; ShaderBindings .)",
    "insertText": "Finalize(ShadersForDebugging)"
  },
  {
    "label": "SubmitDrawBegin()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "SubmitDrawBegin(const FMeshDrawCommand& RESTRICT MeshDrawCommand, const FGraphicsMinimalPipelineStateSet& GraphicsMinimalPipelineStateSet, const FMeshDrawCommandSceneArgs& SceneArgs, uint32 InstanceFactor, FRHICommandList& RHICmdList, FMeshDrawCommandStateCache& RESTRICT StateCache, bool bAllowSkipDrawCommand)"
  },
  {
    "label": "SubmitDrawEnd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubmitDrawEnd(const FMeshDrawCommand& MeshDrawCommand, const FMeshDrawCommandSceneArgs& SceneArgs, uint32 InstanceFactor, FRHICommandList& RHICmdList)"
  },
  {
    "label": "SubmitDrawIndirectBegin()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SubmitDrawIndirectBegin(const FMeshDrawCommand& RESTRICT MeshDrawCommand, const FGraphicsMinimalPipelineStateSet& GraphicsMinimalPipelineStateSet, const FMeshDrawCommandSceneArgs& SceneArgs, uint32 InstanceFactor, FRHICommandList& RHICmdList, FMeshDrawCommandStateCache& RESTRICT StateCache, bool bAllowSkipDrawCommand)"
  },
  {
    "label": "SubmitDrawIndirectEnd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubmitDrawIndirectEnd(const FMeshDrawCommand& MeshDrawCommand, const FMeshDrawCommandSceneArgs& SceneArgs, uint32 InstanceFactor, FRHICommandList& RHICmdList)"
  },
  {
    "label": "SubmitDraw()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SubmitDraw(const FMeshDrawCommand& RESTRICT MeshDrawCommand, const FGraphicsMinimalPipelineStateSet& GraphicsMinimalPipelineStateSet, const FMeshDrawCommandSceneArgs& SceneArgs, uint32 InstanceFactor, FRHICommandList& CommandList, class FMeshDrawCommandStateCache& RESTRICT StateCache)"
  },
  {
    "label": "GetPipelineStateSortingKey()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "GetPipelineStateSortingKey(FRHICommandList& RHICmdList, const FGraphicsPipelineRenderTargetsInfo& RenderTargetsInfo)"
  },
  {
    "label": "GetPipelineStateSortingKey()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "GetPipelineStateSortingKey(const FGraphicsPipelineRenderTargetsInfo& RenderTargetsInfo)"
  },
  {
    "label": "SetDebugData()",
    "kind": "Method",
    "detail": "Function (} # if MESH_DRAW_COMMAND_DEBUG_DATA void)",
    "insertText": "SetDebugData(const FPrimitiveSceneProxy* PrimitiveSceneProxy, const FMaterial* Material, const FMaterialRenderProxy* MaterialRenderProxy, const FMeshProcessorShaders& UntypedShaders, const FVertexFactory* VertexFactory, const FMeshBatch& MeshBatch, int32 PSOCollectorIndex)"
  },
  {
    "label": "GetDebugDataSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetDebugDataSize()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (# if MESH_DRAW_COMMAND_DEBUG_DATA return)",
    "insertText": "sizeof(DebugData)"
  },
  {
    "label": "ClearDebugPrimitiveSceneProxy()",
    "kind": "Method",
    "detail": "Function (# else return 0 ; # endif } # if MESH_DRAW_COMMAND_DEBUG_DATA void)",
    "insertText": "ClearDebugPrimitiveSceneProxy()"
  },
  {
    "label": "GetDebugData()",
    "kind": "Method",
    "detail": "Function (DebugData . PrimitiveSceneProxyIfNotUsingStateBuckets = nullptr ; } const FMeshDrawCommandDebugData&)",
    "insertText": "GetDebugData()"
  },
  {
    "label": "GetStatsData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetStatsData(FVisibleMeshDrawCommandStatsData& OutVisibleStatsData)"
  },
  {
    "label": "SetStatsData()",
    "kind": "Method",
    "detail": "Function (# else public : void)",
    "insertText": "SetStatsData(const FPrimitiveSceneProxy* PrimitiveSceneProxy)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif } ; class FMeshDrawCommandSortKey { public : union { uint64 PackedData ; struct { uint64 VertexShaderHash : 1 6 ; uint64 PixelShaderHash : 3 2 ; uint64 Background : 1 ; uint64 Masked : 1 5 ; } BasePass ; struct { uint64 MeshIdInPrimitive : 1 6 ; uint64 Distance : 3 2 ; uint64 Priority : 1 6 ; } Translucent ; struct { uint64 VertexShaderHash : 3 2 ; uint64 PixelShaderHash : 3 2 ; } Generic ; } ; bool)",
    "insertText": "operator(FMeshDrawCommandSortKey B)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (struct FPersistentPrimitiveIndex { bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "FMeshDrawCommandPrimitiveIdInfo()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "FMeshDrawCommandPrimitiveIdInfo(int32 InScenePrimitiveId, FPersistentPrimitiveIndex InDrawPrimitiveId, int32 InInstanceSceneDataOffset) : DrawPrimitiveId(InDrawPrimitiveId.Index), ScenePrimitiveId(InScenePrimitiveId), InstanceSceneDataOffset(InInstanceSceneDataOffset), bIsDynamicPrimitive(0)"
  },
  {
    "label": "PackScreenSize()",
    "kind": "Method",
    "detail": "Function (} int32 DrawPrimitiveId ; int32 ScenePrimitiveId ; int32 InstanceSceneDataOffset : 3 1 ; uint32 bIsDynamicPrimitive : 1 ; } ; struct FMeshDrawCommandCullingPayload { union { uint32 PackedData = 0 ; struct { uint32 LodIndex : 4 ; uint32 MinScreenSize : 1 2 ; uint32 MaxScreenSize : 1 2 ; } ; } ; uint32)",
    "insertText": "PackScreenSize(float ScreenSize)"
  },
  {
    "label": "MaxExpressibleValue()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "MaxExpressibleValue(float)(0xFFFU) / (float)(1 << 9)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (ScreenSize =)",
    "insertText": "Clamp(ScreenSize, 0.f, MaxExpressibleValue)"
  },
  {
    "label": "UnpackScreenSize()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "UnpackScreenSize(uint32 PackedScreenSize)"
  },
  {
    "label": "CreateCullingPayload()",
    "kind": "Method",
    "detail": "Function (} } ; FMeshDrawCommandCullingPayload)",
    "insertText": "CreateCullingPayload(FMeshBatch const& MeshBatch, FMeshBatchElement const& MeshBatchElement)"
  },
  {
    "label": "PackScreenSize()",
    "kind": "Method",
    "detail": "Function (FMeshDrawCommandCullingPayload CullingPayload ; CullingPayload . LodIndex = MeshBatch . LODIndex ; CullingPayload . MinScreenSize =)",
    "insertText": "PackScreenSize(MeshBatchElement.MinScreenSize)"
  },
  {
    "label": "PackScreenSize()",
    "kind": "Method",
    "detail": "Function (CullingPayload . MaxScreenSize =)",
    "insertText": "PackScreenSize(MeshBatchElement.MaxScreenSize)"
  },
  {
    "label": "FMeshPassDrawListContext()",
    "kind": "Method",
    "detail": "Function (class FMeshPassDrawListContext { public : ~)",
    "insertText": "FMeshPassDrawListContext()"
  },
  {
    "label": "AddCommand()",
    "kind": "Method",
    "detail": "Function (} FMeshDrawCommand&)",
    "insertText": "AddCommand(FMeshDrawCommand& Initializer, uint32 NumElements)"
  },
  {
    "label": "FinalizeCommand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FinalizeCommand(const FMeshBatch& MeshBatch, int32 BatchElementIndex, const FMeshDrawCommandPrimitiveIdInfo& IdInfo, ERasterizerFillMode MeshFillMode, ERasterizerCullMode MeshCullMode, FMeshDrawCommandSortKey SortKey, EFVisibleMeshDrawCommandFlags Flags, const FGraphicsMinimalPipelineStateInitializer& PipelineState, const FMeshProcessorShaders* ShadersForDebugging, FMeshDrawCommand& MeshDrawCommand)"
  },
  {
    "label": "Setup()",
    "kind": "Method",
    "detail": "Function (} ; class FDynamicMeshDrawCommandStorage { public : TChunkedArray<FMeshDrawCommand> MeshDrawCommands ; } ; class FVisibleMeshDrawCommand { public : void)",
    "insertText": "Setup(const FMeshDrawCommand* InMeshDrawCommand, const FMeshDrawCommandPrimitiveIdInfo& InPrimitiveIdInfo, int32 InStateBucketId, ERasterizerFillMode InMeshFillMode, ERasterizerCullMode InMeshCullMode, EFVisibleMeshDrawCommandFlags InFlags, FMeshDrawCommandSortKey InSortKey, FMeshDrawCommandCullingPayload InCullingPayload, EMeshDrawCommandCullingPayloadFlags InCullingPayloadFlags, const uint32* InRunArray = nullptr, int32 InNumRuns = 0)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (MeshDrawCommand = InMeshDrawCommand ; PrimitiveIdInfo = InPrimitiveIdInfo ; PrimitiveIdBufferOffset = - 1 ; StateBucketId = InStateBucketId ; MeshFillMode = InMeshFillMode ; MeshCullMode = InMeshCullMode ; SortKey = InSortKey ; Flags = InFlags ; CullingPayload = InCullingPayload ; CullingPayloadFlags = InCullingPayloadFlags ; RunArray = InRunArray ; NumRuns = InNumRuns ; } const FMeshDrawCommand* MeshDrawCommand ; FMeshDrawCommandSortKey SortKey ; FMeshDrawCommandPrimitiveIdInfo PrimitiveIdInfo ; int32 PrimitiveIdBufferOffset ; int32 StateBucketId ; const uint32* RunArray ; int32 NumRuns ; FMeshDrawCommandCullingPayload CullingPayload ; EMeshDrawCommandCullingPayloadFlags CullingPayloadFlags :)",
    "insertText": "uint32(EMeshDrawCommandCullingPayloadFlags::NumBits)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (ERasterizerFillMode MeshFillMode : ERasterizerFillMode_NumBits + 1 ; ERasterizerCullMode MeshCullMode : ERasterizerCullMode_NumBits + 1 ; EFVisibleMeshDrawCommandFlags Flags :)",
    "insertText": "uint32(EFVisibleMeshDrawCommandFlags::NumBits)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; struct FCompareFMeshDrawCommands { bool)",
    "insertText": "operator() (const FVisibleMeshDrawCommand& A, const FVisibleMeshDrawCommand& B)"
  },
  {
    "label": "AddElement()",
    "kind": "Method",
    "detail": "Function (const int32 Index = DrawListStorage . MeshDrawCommands .)",
    "insertText": "AddElement(Initializer)"
  },
  {
    "label": "FinalizeCommand()",
    "kind": "Method",
    "detail": "Function (FMeshDrawCommand& NewCommand = DrawListStorage . MeshDrawCommands [ Index ] ; return NewCommand ; } void)",
    "insertText": "FinalizeCommand(const FMeshBatch& MeshBatch, int32 BatchElementIndex, const FMeshDrawCommandPrimitiveIdInfo &IdInfo, ERasterizerFillMode MeshFillMode, ERasterizerCullMode MeshCullMode, FMeshDrawCommandSortKey SortKey, EFVisibleMeshDrawCommandFlags Flags, const FGraphicsMinimalPipelineStateInitializer& PipelineState, const FMeshProcessorShaders* ShadersForDebugging, FMeshDrawCommand& MeshDrawCommand)"
  },
  {
    "label": "GetPipelineStateId()",
    "kind": "Method",
    "detail": "Function (FGraphicsMinimalPipelineStateId PipelineId =)",
    "insertText": "GetPipelineStateId(PipelineState, GraphicsMinimalPipelineStateSet, NeedsShaderInitialisation)"
  },
  {
    "label": "SetDrawParametersAndFinalize()",
    "kind": "Method",
    "detail": "Function (MeshDrawCommand .)",
    "insertText": "SetDrawParametersAndFinalize(MeshBatch, BatchElementIndex, PipelineId, ShadersForDebugging)"
  },
  {
    "label": "Setup()",
    "kind": "Method",
    "detail": "Function (FVisibleMeshDrawCommand NewVisibleMeshDrawCommand ; const FMeshBatchElement& MeshBatchElement = MeshBatch . Elements [ BatchElementIndex ] ; NewVisibleMeshDrawCommand .)",
    "insertText": "Setup(&MeshDrawCommand, IdInfo, -1, MeshFillMode, MeshCullMode, Flags, SortKey, CreateCullingPayload(MeshBatch, MeshBatchElement), EMeshDrawCommandCullingPayloadFlags::NoScreenSizeCull, MeshBatchElement.bIsInstanceRuns ? MeshBatchElement.InstanceRuns : nullptr, MeshBatchElement.bIsInstanceRuns ? MeshBatchElement.NumInstances : 0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (DrawList .)",
    "insertText": "Add(NewVisibleMeshDrawCommand)"
  },
  {
    "label": "AddVisibleMeshDrawCommand()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddVisibleMeshDrawCommand(const FVisibleMeshDrawCommand& VisibleMeshDrawCommand)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (DrawList .)",
    "insertText": "Add(VisibleMeshDrawCommand)"
  },
  {
    "label": "pack()",
    "kind": "Method",
    "detail": "Function (} private : FDynamicMeshDrawCommandStorage& DrawListStorage ; FMeshCommandOneFrameArray& DrawList ; FGraphicsMinimalPipelineStateSet& GraphicsMinimalPipelineStateSet ; bool& NeedsShaderInitialisation ; } ; # if PLATFORM_SUPPORTS_PRAGMA_PACK # pragma)",
    "insertText": "pack(push,4)"
  },
  {
    "label": "FCachedMeshDrawCommandInfo()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FCachedMeshDrawCommandInfo() : FCachedMeshDrawCommandInfo(EMeshPass::Num)"
  },
  {
    "label": "FCachedMeshDrawCommandInfo()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FCachedMeshDrawCommandInfo(EMeshPass::Type InMeshPass) : SortKey(FMeshDrawCommandSortKey::Default), CommandIndex(INDEX_NONE), StateBucketId(INDEX_NONE), MeshPass(InMeshPass), MeshFillMode(ERasterizerFillMode_Num), MeshCullMode(ERasterizerCullMode_Num), Flags(EFVisibleMeshDrawCommandFlags::Default)"
  },
  {
    "label": "pack()",
    "kind": "Method",
    "detail": "Function (} ; # if PLATFORM_SUPPORTS_PRAGMA_PACK # pragma)",
    "insertText": "pack(pop)"
  },
  {
    "label": "FCachedPassMeshDrawList()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FCachedPassMeshDrawList() : LowestFreeIndexSearchStart(0)"
  },
  {
    "label": "FMeshDrawCommandCount()",
    "kind": "Method",
    "detail": "Function (} TSparseArray<FMeshDrawCommand> MeshDrawCommands ; int32 LowestFreeIndexSearchStart ; } ; struct FMeshDrawCommandCount {)",
    "insertText": "FMeshDrawCommandCount() : Num(0)"
  },
  {
    "label": "FMeshDrawCommandCount()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FMeshDrawCommandCount(FMeshDrawCommandCount&& Other) : Num(Other.Num.load())"
  },
  {
    "label": "Matches()",
    "kind": "Method",
    "detail": "Function (} std::atomic<uint32> Num ; } ; struct MeshDrawCommandKeyFuncs : TDefaultMapHashableKeyFuncs<FMeshDrawCommand,FMeshDrawCommandCount,false> { bool)",
    "insertText": "Matches(KeyInitType A, KeyInitType B)"
  },
  {
    "label": "GetKeyHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetKeyHash(KeyInitType Key)"
  },
  {
    "label": "FMeshPassScope()",
    "kind": "Method",
    "detail": "Function (} } ; using FDrawCommandIndices = TArray<int32,TInlineAllocator<5>> ; using FStateBucketMap = Experimental::TRobinHoodHashMap<FMeshDrawCommand,FMeshDrawCommandCount,MeshDrawCommandKeyFuncs> ; class FCachedPassMeshDrawListContext : public FMeshPassDrawListContext { public : struct FMeshPassScope {)",
    "insertText": "FMeshPassScope(const FMeshPassScope&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FMeshPassScope&)",
    "insertText": "operator(const FMeshPassScope&)"
  },
  {
    "label": "FMeshPassScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FMeshPassScope(FCachedPassMeshDrawListContext& InContext, EMeshPass::Type MeshPass) : Context(InContext)"
  },
  {
    "label": "BeginMeshPass()",
    "kind": "Method",
    "detail": "Function (Context .)",
    "insertText": "BeginMeshPass(MeshPass)"
  },
  {
    "label": "FMeshPassScope()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FMeshPassScope()"
  },
  {
    "label": "EndMeshPass()",
    "kind": "Method",
    "detail": "Function (Context .)",
    "insertText": "EndMeshPass()"
  },
  {
    "label": "FCachedPassMeshDrawListContext()",
    "kind": "Method",
    "detail": "Function (} private : FCachedPassMeshDrawListContext& Context ; } ;)",
    "insertText": "FCachedPassMeshDrawListContext(FScene& InScene)"
  },
  {
    "label": "BeginMeshPass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginMeshPass(EMeshPass::Type MeshPass)"
  },
  {
    "label": "BeginMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginMesh(int32 SceneInfoIndex, int32 MeshIndex)"
  },
  {
    "label": "EndMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndMesh()"
  },
  {
    "label": "GetCommandInfoAndReset()",
    "kind": "Method",
    "detail": "Function (FCachedMeshDrawCommandInfo)",
    "insertText": "GetCommandInfoAndReset()"
  },
  {
    "label": "HasAnyLooseParameterBuffers()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasAnyLooseParameterBuffers()"
  },
  {
    "label": "FCachedPassMeshDrawListContextImmediate()",
    "kind": "Method",
    "detail": "Function (FScene& Scene ; FMeshDrawCommand MeshDrawCommandForStateBucketing ; FCachedMeshDrawCommandInfo CommandInfo ; EMeshPass::Type CurrMeshPass = EMeshPass::Num ; bool bUseGPUScene = false ; bool bAnyLooseParameterBuffers = false ; } ; class FCachedPassMeshDrawListContextImmediate : public FCachedPassMeshDrawListContext { public :)",
    "insertText": "FCachedPassMeshDrawListContextImmediate(FScene& InScene) : FCachedPassMeshDrawListContext(InScene)"
  },
  {
    "label": "FCachedPassMeshDrawListContextDeferred()",
    "kind": "Method",
    "detail": "Function (} ; class FCachedPassMeshDrawListContextDeferred : public FCachedPassMeshDrawListContext { public :)",
    "insertText": "FCachedPassMeshDrawListContextDeferred(FScene& InScene) : FCachedPassMeshDrawListContext(InScene)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (DeferredCommandHashes .)",
    "insertText": "Reserve(DeferredCommands.Max())"
  },
  {
    "label": "DeferredFinalizeMeshDrawCommands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeferredFinalizeMeshDrawCommands(const TArrayView<FPrimitiveSceneInfo*>& SceneInfos, int32 Start, int32 End)"
  },
  {
    "label": "TMeshProcessorShaders()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "TMeshProcessorShaders()"
  },
  {
    "label": "GetUntypedShaders()",
    "kind": "Method",
    "detail": "Function (FMeshProcessorShaders)",
    "insertText": "GetUntypedShaders()"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (FMeshProcessorShaders Shaders ; Shaders . VertexShader = VertexShader ; Shaders . PixelShader = PixelShader ; Shaders . GeometryShader = GeometryShader ; PRAGMA_DISABLE_DEPRECATION_WARNINGS Shaders . ComputeShader = ComputeShader ; # if RHI_RAYTRACING Shaders . RayTracingShader = RayTracingShader ; # endif PRAGMA_ENABLE_DEPRECATION_WARNINGS return Shaders ; } } ; enum class EMeshPassFeatures { Default = 0,PositionOnly = 1<<0,PositionAndNormalOnly = 1<<1,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(EMeshPassFeatures)"
  },
  {
    "label": "FMeshPassProcessorRenderState()",
    "kind": "Method",
    "detail": "Function (struct FMeshPassProcessorRenderState {)",
    "insertText": "FMeshPassProcessorRenderState()"
  },
  {
    "label": "FMeshPassProcessorRenderState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FMeshPassProcessorRenderState(const FMeshPassProcessorRenderState& DrawRenderState)"
  },
  {
    "label": "SetBlendState()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "SetBlendState(FRHIBlendState* InBlendState)"
  },
  {
    "label": "GetBlendState()",
    "kind": "Method",
    "detail": "Function (BlendState = InBlendState ; } FRHIBlendState*)",
    "insertText": "GetBlendState()"
  },
  {
    "label": "GetDepthStencilState()",
    "kind": "Method",
    "detail": "Function (StencilRef = InStencilRef ; } FRHIDepthStencilState*)",
    "insertText": "GetDepthStencilState()"
  },
  {
    "label": "GetDepthStencilAccess()",
    "kind": "Method",
    "detail": "Function (DepthStencilAccess = InDepthStencilAccess ; } FExclusiveDepthStencil::Type)",
    "insertText": "GetDepthStencilAccess()"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (GraphicsPSOInit . BlendState = BlendState ; GraphicsPSOInit . DepthStencilState = DepthStencilState ; } private : FRHIBlendState* BlendState = nullptr ; FRHIDepthStencilState* DepthStencilState = nullptr ; FExclusiveDepthStencil::Type DepthStencilAccess = FExclusiveDepthStencil::DepthRead_StencilRead ; ; FRHIUniformBuffer* ViewUniformBuffer = nullptr ; FRHIUniformBuffer* InstancedViewUniformBuffer = nullptr ; FRHIUniformBuffer* PassUniformBuffer = nullptr ; FRHIUniformBuffer* NaniteUniformBuffer = nullptr ; uint32 StencilRef = 0 ; } ; enum class EDrawingPolicyOverrideFlags { None = 0,TwoSided = 1<<0,DitheredLODTransition = 1<<1,Wireframe = 1<<2,ReverseCullMode = 1<<3,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(EDrawingPolicyOverrideFlags)"
  },
  {
    "label": "FMeshPassProcessor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FMeshPassProcessor(EMeshPass::Type InMeshPassType, const FScene* InScene, ERHIFeatureLevel::Type InFeatureLevel, const FSceneView* InViewIfDynamicMeshCommand, FMeshPassDrawListContext* InDrawListContext)"
  },
  {
    "label": "FMeshPassProcessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FMeshPassProcessor(const TCHAR* InMeshPassName, const FScene* InScene, ERHIFeatureLevel::Type InFeatureLevel, const FSceneView* InViewIfDynamicMeshCommand, FMeshPassDrawListContext* InDrawListContext)"
  },
  {
    "label": "FMeshPassProcessor()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FMeshPassProcessor()"
  },
  {
    "label": "SetDrawListContext()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetDrawListContext(FMeshPassDrawListContext* InDrawListContext)"
  },
  {
    "label": "AddMeshBatch()",
    "kind": "Method",
    "detail": "Function (DrawListContext = InDrawListContext ; } void)",
    "insertText": "AddMeshBatch(const FMeshBatch& RESTRICT MeshBatch, uint64 BatchElementMask, const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy, int32 StaticMeshId = -1)"
  },
  {
    "label": "CollectPSOInitializers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CollectPSOInitializers(const FSceneTexturesConfig& SceneTexturesConfig, const FMaterial& Material, const FPSOPrecacheVertexFactoryData& VertexFactoryData, const FPSOPrecacheParams& PreCacheParams, TArray<FPSOPrecacheData>& PSOInitializers)"
  },
  {
    "label": "InverseCullMode()",
    "kind": "Method",
    "detail": "Function (} ERasterizerCullMode)",
    "insertText": "InverseCullMode(ERasterizerCullMode CullMode)"
  },
  {
    "label": "ComputeMeshOverrideSettings()",
    "kind": "Method",
    "detail": "Function (} struct FMeshDrawingPolicyOverrideSettings { EDrawingPolicyOverrideFlags MeshOverrideFlags = EDrawingPolicyOverrideFlags::None ; EPrimitiveType MeshPrimitiveType = PT_TriangleList ; } ; FMeshDrawingPolicyOverrideSettings)",
    "insertText": "ComputeMeshOverrideSettings(const FPSOPrecacheParams& PrecachePSOParams)"
  },
  {
    "label": "ComputeMeshOverrideSettings()",
    "kind": "Method",
    "detail": "Function (FMeshDrawingPolicyOverrideSettings)",
    "insertText": "ComputeMeshOverrideSettings(const FMeshBatch& Mesh)"
  },
  {
    "label": "ComputeMeshFillMode()",
    "kind": "Method",
    "detail": "Function (ERasterizerFillMode)",
    "insertText": "ComputeMeshFillMode(const FMaterial& InMaterialResource, const FMeshDrawingPolicyOverrideSettings& InOverrideSettings)"
  },
  {
    "label": "ComputeMeshCullMode()",
    "kind": "Method",
    "detail": "Function (ERasterizerCullMode)",
    "insertText": "ComputeMeshCullMode(const FMaterial& InMaterialResource, const FMeshDrawingPolicyOverrideSettings& InOverrideSettings)"
  },
  {
    "label": "BuildMeshDrawCommands()",
    "kind": "Method",
    "detail": "Function (template<PassShadersType,ShaderElementDataType> void)",
    "insertText": "BuildMeshDrawCommands(const FMeshBatch& RESTRICT MeshBatch, uint64 BatchElementMask, const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy, const FMaterialRenderProxy& RESTRICT MaterialRenderProxy, const FMaterial& RESTRICT MaterialResource, const FMeshPassProcessorRenderState& RESTRICT DrawRenderState, const PassShadersType& PassShaders, ERasterizerFillMode MeshFillMode, ERasterizerCullMode MeshCullMode, FMeshDrawCommandSortKey SortKey, EMeshPassFeatures MeshPassFeatures, const ShaderElementDataType& ShaderElementData)"
  },
  {
    "label": "AddGraphicsPipelineStateInitializer()",
    "kind": "Method",
    "detail": "Function (template<PassShadersType> void)",
    "insertText": "AddGraphicsPipelineStateInitializer(const FPSOPrecacheVertexFactoryData& VertexFactoryData, const FMaterial& RESTRICT MaterialResource, const FMeshPassProcessorRenderState& RESTRICT DrawRenderState, const FGraphicsPipelineRenderTargetsInfo& RESTRICT RenderTargetsInfo, const PassShadersType& PassShaders, ERasterizerFillMode MeshFillMode, ERasterizerCullMode MeshCullMode, EPrimitiveType PrimitiveType, EMeshPassFeatures MeshPassFeatures, bool bRequired, TArray<FPSOPrecacheData>& PSOInitializers)"
  },
  {
    "label": "AddGraphicsPipelineStateInitializer()",
    "kind": "Method",
    "detail": "Function (template<PassShadersType> void)",
    "insertText": "AddGraphicsPipelineStateInitializer(const FPSOPrecacheVertexFactoryData& VertexFactoryData, const FMaterial& RESTRICT MaterialResource, const FMeshPassProcessorRenderState& RESTRICT DrawRenderState, const FGraphicsPipelineRenderTargetsInfo& RESTRICT RenderTargetsInfo, const PassShadersType& PassShaders, ERasterizerFillMode MeshFillMode, ERasterizerCullMode MeshCullMode, EPrimitiveType PrimitiveType, EMeshPassFeatures MeshPassFeatures, ESubpassHint SubpassHint, uint8 SubpassIndex, bool bRequired, int32 PSOCollectorIndex, TArray<FPSOPrecacheData>& PSOInitializers)"
  },
  {
    "label": "GetDrawCommandPrimitiveId()",
    "kind": "Method",
    "detail": "Function (protected : FMeshDrawCommandPrimitiveIdInfo)",
    "insertText": "GetDrawCommandPrimitiveId(const FPrimitiveSceneInfo* RESTRICT PrimitiveSceneInfo, const FMeshBatchElement& BatchElement)"
  },
  {
    "label": "ShouldSkipMeshDrawCommand()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldSkipMeshDrawCommand(const FMeshBatch& RESTRICT MeshBatch, const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy)"
  },
  {
    "label": "PipelineVariableRateShadingEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PipelineVariableRateShadingEnabled()"
  },
  {
    "label": "HardwareVariableRateShadingSupportedByScene()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HardwareVariableRateShadingSupportedByScene()"
  },
  {
    "label": "GetShadersOnlyInitializer()",
    "kind": "Method",
    "detail": "Function (} ; # if PSO_PRECACHING_VALIDATE namespace PSOCollectorStats { FGraphicsMinimalPipelineStateInitializer)",
    "insertText": "GetShadersOnlyInitializer(const FGraphicsMinimalPipelineStateInitializer& Initializer)"
  },
  {
    "label": "PatchMinimalPipelineStateToCheck()",
    "kind": "Method",
    "detail": "Function (FGraphicsMinimalPipelineStateInitializer)",
    "insertText": "PatchMinimalPipelineStateToCheck(const FGraphicsMinimalPipelineStateInitializer& Initializer)"
  },
  {
    "label": "GetPSOPrecacheHash()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "GetPSOPrecacheHash(const FGraphicsMinimalPipelineStateInitializer& Initializer)"
  },
  {
    "label": "CheckShaderOnlyStateInCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckShaderOnlyStateInCache(const FGraphicsMinimalPipelineStateInitializer& Initializer, const FMaterial& Material, const FVertexFactoryType* VFType, const FPrimitiveSceneProxy* PrimitiveSceneProxy, int32 PSOCollectorIndex)"
  },
  {
    "label": "CheckMinimalPipelineStateInCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckMinimalPipelineStateInCache(const FGraphicsMinimalPipelineStateInitializer& Initializer, const FMaterial& Material, const FVertexFactoryType* VFType, const FPrimitiveSceneProxy* PrimitiveSceneProxy, int32 PSOCollectorIndex)"
  },
  {
    "label": "FMeshPassProcessor()",
    "kind": "Method",
    "detail": "Function (} # endif typedef)",
    "insertText": "FMeshPassProcessor(*DeprecatedPassProcessorCreateFunction)(const FScene* Scene, const FSceneView* InViewIfDynamicMeshCommand, FMeshPassDrawListContext* InDrawListContext)"
  },
  {
    "label": "FMeshPassProcessor()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "FMeshPassProcessor(*PassProcessorCreateFunction)(ERHIFeatureLevel::Type FeatureLevel, const FScene* Scene, const FSceneView* InViewIfDynamicMeshCommand, FMeshPassDrawListContext* InDrawListContext)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (enum class EMeshPassFlags { None = 0,CachedMeshCommands = 1<<0,MainView = 1<<1 } ;)",
    "insertText": "ENUM_CLASS_FLAGS(EMeshPassFlags)"
  },
  {
    "label": "CreateMeshPassProcessor()",
    "kind": "Method",
    "detail": "Function (class FPassProcessorManager { public : FMeshPassProcessor*)",
    "insertText": "CreateMeshPassProcessor(EShadingPath ShadingPath, EMeshPass::Type PassType, ERHIFeatureLevel::Type FeatureLevel, const FScene* Scene, const FSceneView* InViewIfDynamicMeshCommand, FMeshPassDrawListContext* InDrawListContext)"
  },
  {
    "label": "ShadingPathIdx()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "ShadingPathIdx(uint32)"
  },
  {
    "label": "PassType()",
    "kind": "Method",
    "detail": "Function (} else { return DeprecatedJumpTable [ ShadingPathIdx ] [)",
    "insertText": "PassType(Scene, InViewIfDynamicMeshCommand, InDrawListContext)"
  },
  {
    "label": "GetPassFlags()",
    "kind": "Method",
    "detail": "Function (} } EMeshPassFlags)",
    "insertText": "GetPassFlags(EShadingPath ShadingPath, EMeshPass::Type PassType)"
  },
  {
    "label": "JumpTable()",
    "kind": "Method",
    "detail": "Function (private : PassProcessorCreateFunction)",
    "insertText": "JumpTable(uint32)"
  },
  {
    "label": "DeprecatedJumpTable()",
    "kind": "Method",
    "detail": "Function (DeprecatedPassProcessorCreateFunction)",
    "insertText": "DeprecatedJumpTable(uint32)"
  },
  {
    "label": "Flags()",
    "kind": "Method",
    "detail": "Function (EMeshPassFlags)",
    "insertText": "Flags(uint32)"
  },
  {
    "label": "PSOCollectorIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "PSOCollectorIndex(uint32)"
  },
  {
    "label": "FRegisterPassProcessorCreateFunction()",
    "kind": "Method",
    "detail": "Function (class FRegisterPassProcessorCreateFunction ; } ; class FRegisterPassProcessorCreateFunction { public :)",
    "insertText": "FRegisterPassProcessorCreateFunction(PassProcessorCreateFunction CreateFunction, EShadingPath InShadingPath, EMeshPass::Type InPassType, EMeshPassFlags PassFlags, int32 PSOCollectorIndex = INDEX_NONE) : ShadingPath(InShadingPath) , PassType(InPassType)"
  },
  {
    "label": "FRegisterPassProcessorCreateFunction()",
    "kind": "Method",
    "detail": "Function (FPassProcessorManager::JumpTable [ ShadingPathIdx ] [ PassType ] = CreateFunction ; FPassProcessorManager::Flags [ ShadingPathIdx ] [ PassType ] = PassFlags ; FPassProcessorManager::PSOCollectorIndex [ ShadingPathIdx ] [ PassType ] = PSOCollectorIndex ; } ~)",
    "insertText": "FRegisterPassProcessorCreateFunction()"
  },
  {
    "label": "REGISTER_MESHPASSPROCESSOR_AND_PSOCOLLECTOR()",
    "kind": "Method",
    "detail": "Function (FPassProcessorManager::JumpTable [ ShadingPathIdx ] [ PassType ] = nullptr ; FPassProcessorManager::Flags [ ShadingPathIdx ] [ PassType ] = EMeshPassFlags::None ; FPassProcessorManager::PSOCollectorIndex [ ShadingPathIdx ] [ PassType ] = INDEX_NONE ; } private : EShadingPath ShadingPath ; EMeshPass::Type PassType ; } ; # define)",
    "insertText": "REGISTER_MESHPASSPROCESSOR_AND_PSOCOLLECTOR(Name, MeshPassProcessorCreateFunction, ShadingPath, MeshPass, MeshPassFlags) \\ IPSOCollector* CreatePSOCollector##Name(ERHIFeatureLevel::Type FeatureLevel)"
  },
  {
    "label": "MeshPassProcessorCreateFunction()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "MeshPassProcessorCreateFunction(FeatureLevel, nullptr, nullptr, nullptr)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ } \\ FRegisterPSOCollectorCreateFunction RegisterPSOCollector # #)",
    "insertText": "Name(&CreatePSOCollector##Name, ShadingPath, GetMeshPassName(MeshPass))"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ FRegisterPassProcessorCreateFunction RegisterMeshPassProcesser # #)",
    "insertText": "Name(&MeshPassProcessorCreateFunction, ShadingPath, MeshPass, MeshPassFlags, RegisterPSOCollector##Name.GetIndex())"
  },
  {
    "label": "SubmitMeshDrawCommands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubmitMeshDrawCommands(const FMeshCommandOneFrameArray& VisibleMeshDrawCommands, const FGraphicsMinimalPipelineStateSet& GraphicsMinimalPipelineStateSet, const FMeshDrawCommandSceneArgs& SceneArgs, uint32 PrimitiveIdBufferStride, bool bDynamicInstancing, uint32 InstanceFactor, FRHICommandList& RHICmdList)"
  },
  {
    "label": "SubmitMeshDrawCommandsRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubmitMeshDrawCommandsRange(const FMeshCommandOneFrameArray& VisibleMeshDrawCommands, const FGraphicsMinimalPipelineStateSet& GraphicsMinimalPipelineStateSet, const FMeshDrawCommandSceneArgs& SceneArgs, uint32 PrimitiveIdBufferStride, bool bDynamicInstancing, int32 StartIndex, int32 NumMeshDrawCommands, uint32 InstanceFactor, FRHICommandList& RHICmdList)"
  },
  {
    "label": "ApplyViewOverridesToMeshDrawCommands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyViewOverridesToMeshDrawCommands(const FSceneView& View, FMeshCommandOneFrameArray& VisibleMeshDrawCommands, FDynamicMeshDrawCommandStorage& DynamicMeshDrawCommandStorage, FGraphicsMinimalPipelineStateSet& GraphicsMinimalPipelineStateSet, bool& NeedsShaderInitialisation)"
  },
  {
    "label": "DrawDynamicMeshPassPrivate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DrawDynamicMeshPassPrivate(const FSceneView& View, FRHICommandList& RHICmdList, FMeshCommandOneFrameArray& VisibleMeshDrawCommands, FDynamicMeshDrawCommandStorage& DynamicMeshDrawCommandStorage, FGraphicsMinimalPipelineStateSet& GraphicsMinimalPipelineStateSet, bool& InNeedsShaderInitialisation, uint32 InstanceFactor)"
  },
  {
    "label": "CalculateMeshStaticSortKey()",
    "kind": "Method",
    "detail": "Function (FMeshDrawCommandSortKey)",
    "insertText": "CalculateMeshStaticSortKey(const FMeshMaterialShader* VertexShader, const FMeshMaterialShader* PixelShader)"
  },
  {
    "label": "AddRenderTargetInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRenderTargetInfo(EPixelFormat PixelFormat, ETextureCreateFlags CreateFlags, FGraphicsPipelineRenderTargetsInfo& RenderTargetsInfo)"
  },
  {
    "label": "SetupDepthStencilInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetupDepthStencilInfo(EPixelFormat DepthStencilFormat, ETextureCreateFlags DepthStencilCreateFlags, ERenderTargetLoadAction DepthTargetLoadAction, ERenderTargetLoadAction StencilTargetLoadAction, FExclusiveDepthStencil DepthStencilAccess, FGraphicsPipelineRenderTargetsInfo& RenderTargetsInfo)"
  },
  {
    "label": "SetupGBufferRenderTargetInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetupGBufferRenderTargetInfo(const FSceneTexturesConfig& SceneTexturesConfig, FGraphicsPipelineRenderTargetsInfo& RenderTargetsInfo, bool bSetupDepthStencil)"
  },
  {
    "label": "ApplyTargetsInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyTargetsInfo(FGraphicsPipelineStateInitializer& GraphicsPSOInit, const FGraphicsPipelineRenderTargetsInfo& RenderTargetsInfo)"
  },
  {
    "label": "GetSubpassHint()",
    "kind": "Method",
    "detail": "Function (ESubpassHint)",
    "insertText": "GetSubpassHint(const FStaticShaderPlatform Platform, bool bIsUsingGBuffers, bool bMultiViewRendering, uint32 NumSamples)"
  },
  {
    "label": "CalculateMeshStaticSortKey()",
    "kind": "Method",
    "detail": "Function (FMeshDrawCommandSortKey)",
    "insertText": "CalculateMeshStaticSortKey(const TShaderRef<FMeshMaterialShader>& VertexShader, const TShaderRef<FMeshMaterialShader>& PixelShader)"
  }
]