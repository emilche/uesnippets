[
  {
    "label": "ConvertableToTraceFormat",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConvertableToTraceFormat"
  },
  {
    "label": "SequenceManagerForTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SequenceManagerForTest"
  },
  {
    "label": "TaskQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TaskQueue"
  },
  {
    "label": "TaskTimeObserver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TaskTimeObserver"
  },
  {
    "label": "TimeDomain",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TimeDomain"
  },
  {
    "label": "TaskQueueImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TaskQueueImpl"
  },
  {
    "label": "DefaultWakeUpQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DefaultWakeUpQueue"
  },
  {
    "label": "ThreadControllerImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadControllerImpl"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "NativeWorkHandleImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NativeWorkHandleImpl"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "ExecutingTask",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExecutingTask"
  },
  {
    "label": "MainThreadOnly",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MainThreadOnly"
  },
  {
    "label": "SequenceManagerImpl()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TASK_SEQUENCE_MANAGER_SEQUENCE_MANAGER_IMPL_H_ # define BASE_TASK_SEQUENCE_MANAGER_SEQUENCE_MANAGER_IMPL_H_ # include<deque> # include<map> # include<memory> # include<set> # include<string> # include<utility> # include \" base / atomic_sequence_num . h \" # include \" base / base_export . h \" # include \" base / callback_forward . h \" # include \" base / cancelable_callback . h \" # include \" base / containers / circular_deque . h \" # include \" base / debug / crash_logging . h \" # include \" base / feature_list . h \" # include \" base / memory / raw_ptr . h \" # include \" base / memory / scoped_refptr . h \" # include \" base / memory / weak_ptr . h \" # include \" base / message_loop / message_pump_type . h \" # include \" base / observer_list . h \" # include \" base / pending_task . h \" # include \" base / rand_util . h \" # include \" base / run_loop . h \" # include \" base / synchronization / lock . h \" # include \" base / task / current_thread . h \" # include \" base / task / sequence_manager / associated_thread_id . h \" # include \" base / task / sequence_manager / enqueue_order . h \" # include \" base / task / sequence_manager / enqueue_order_generator . h \" # include \" base / task / sequence_manager / sequence_manager . h \" # include \" base / task / sequence_manager / task_queue_impl . h \" # include \" base / task / sequence_manager / task_queue_selector . h \" # include \" base / task / sequence_manager / thread_controller . h \" # include \" base / task / sequenced_task_runner . h \" # include \" base / task / single_thread_task_runner . h \" # include \" base / threading / thread_checker . h \" # include \" base / time / default_tick_clock . h \" # include \" base / values . h \" # include \" build / build_config . h \" # include \" third_party / abseil - cpp / absl / types / optional . h \" namespace base { namespace trace_event { class ConvertableToTraceFormat ; } namespace sequence_manager { class SequenceManagerForTest ; class TaskQueue ; class TaskTimeObserver ; class TimeDomain ; namespace internal { class TaskQueueImpl ; class DefaultWakeUpQueue ; class ThreadControllerImpl ; class BASE_EXPORT SequenceManagerImpl : public SequenceManager,public internal::SequencedTaskSource,public internal::TaskQueueSelector::Observer,public RunLoop::NestingObserver { public : using Observer = SequenceManager::Observer ;)",
    "insertText": "SequenceManagerImpl(const SequenceManagerImpl&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (SequenceManagerImpl&)",
    "insertText": "operator(const SequenceManagerImpl&)"
  },
  {
    "label": "SequenceManagerImpl()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "SequenceManagerImpl()"
  },
  {
    "label": "CreateOnCurrentThread()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<SequenceManagerImpl>)",
    "insertText": "CreateOnCurrentThread(SequenceManager::Settings settings = SequenceManager::Settings())"
  },
  {
    "label": "CreateUnbound()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<SequenceManagerImpl>)",
    "insertText": "CreateUnbound(SequenceManager::Settings settings)"
  },
  {
    "label": "InitializeFeatures()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeFeatures()"
  },
  {
    "label": "ApplyNoWakeUpsForCanceledTasks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyNoWakeUpsForCanceledTasks()"
  },
  {
    "label": "ResetNoWakeUpsForCanceledTasksForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetNoWakeUpsForCanceledTasksForTesting()"
  },
  {
    "label": "MaybeEmitTaskDetails()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeEmitTaskDetails(perfetto::EventContext& ctx, const SequencedTaskSource::SelectedTask& selected_task)"
  },
  {
    "label": "BindToCurrentThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BindToCurrentThread()"
  },
  {
    "label": "GetTaskRunnerForCurrentTask()",
    "kind": "Method",
    "detail": "Function (scoped_refptr<SequencedTaskRunner>)",
    "insertText": "GetTaskRunnerForCurrentTask()"
  },
  {
    "label": "BindToMessagePump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BindToMessagePump(std::unique_ptr<MessagePump> message_pump)"
  },
  {
    "label": "SetObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetObserver(Observer* observer)"
  },
  {
    "label": "AddTaskTimeObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTaskTimeObserver(TaskTimeObserver* task_time_observer)"
  },
  {
    "label": "RemoveTaskTimeObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveTaskTimeObserver(TaskTimeObserver* task_time_observer)"
  },
  {
    "label": "SetTimeDomain()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTimeDomain(TimeDomain* time_domain)"
  },
  {
    "label": "ResetTimeDomain()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetTimeDomain()"
  },
  {
    "label": "GetTickClock()",
    "kind": "Method",
    "detail": "Function (const TickClock*)",
    "insertText": "GetTickClock()"
  },
  {
    "label": "NowTicks()",
    "kind": "Method",
    "detail": "Function (TimeTicks)",
    "insertText": "NowTicks()"
  },
  {
    "label": "SetDefaultTaskRunner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDefaultTaskRunner(scoped_refptr<SingleThreadTaskRunner> task_runner)"
  },
  {
    "label": "ReclaimMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReclaimMemory()"
  },
  {
    "label": "GetAndClearSystemIsQuiescentBit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetAndClearSystemIsQuiescentBit()"
  },
  {
    "label": "SetWorkBatchSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetWorkBatchSize(int work_batch_size)"
  },
  {
    "label": "SetTimerSlack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTimerSlack(TimerSlack timer_slack)"
  },
  {
    "label": "EnableCrashKeys()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnableCrashKeys(const char* async_stack_crash_key)"
  },
  {
    "label": "GetMetricRecordingSettings()",
    "kind": "Method",
    "detail": "Function (const MetricRecordingSettings&)",
    "insertText": "GetMetricRecordingSettings()"
  },
  {
    "label": "GetPendingTaskCountForTesting()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetPendingTaskCountForTesting()"
  },
  {
    "label": "CreateTaskQueue()",
    "kind": "Method",
    "detail": "Function (scoped_refptr<TaskQueue>)",
    "insertText": "CreateTaskQueue(const TaskQueue::Spec& spec)"
  },
  {
    "label": "DescribeAllPendingTasks()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "DescribeAllPendingTasks()"
  },
  {
    "label": "OnNativeWorkPending()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<NativeWorkHandle>)",
    "insertText": "OnNativeWorkPending(TaskQueue::QueuePriority priority)"
  },
  {
    "label": "PrioritizeYieldingToNative()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrioritizeYieldingToNative(base::TimeTicks prioritize_until)"
  },
  {
    "label": "EnablePeriodicYieldingToNative()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnablePeriodicYieldingToNative(base::TimeDelta interval)"
  },
  {
    "label": "AddTaskObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTaskObserver(TaskObserver* task_observer)"
  },
  {
    "label": "RemoveTaskObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveTaskObserver(TaskObserver* task_observer)"
  },
  {
    "label": "GetNextDelayedWakeUp()",
    "kind": "Method",
    "detail": "Function (absl::optional<WakeUp>)",
    "insertText": "GetNextDelayedWakeUp()"
  },
  {
    "label": "SelectNextTask()",
    "kind": "Method",
    "detail": "Function (absl::optional<SelectedTask>)",
    "insertText": "SelectNextTask(LazyNow& lazy_now, SelectTaskOption option = SelectTaskOption::kDefault)"
  },
  {
    "label": "DidRunTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DidRunTask(LazyNow& lazy_now)"
  },
  {
    "label": "RemoveAllCanceledDelayedTasksFromFront()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAllCanceledDelayedTasksFromFront(LazyNow* lazy_now)"
  },
  {
    "label": "GetPendingWakeUp()",
    "kind": "Method",
    "detail": "Function (absl::optional<WakeUp>)",
    "insertText": "GetPendingWakeUp(LazyNow* lazy_now, SelectTaskOption option = SelectTaskOption::kDefault)"
  },
  {
    "label": "HasPendingHighResolutionTasks()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasPendingHighResolutionTasks()"
  },
  {
    "label": "OnSystemIdle()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OnSystemIdle()"
  },
  {
    "label": "AddDestructionObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddDestructionObserver(CurrentThread::DestructionObserver* destruction_observer)"
  },
  {
    "label": "RemoveDestructionObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveDestructionObserver(CurrentThread::DestructionObserver* destruction_observer)"
  },
  {
    "label": "RegisterOnNextIdleCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterOnNextIdleCallback(OnceClosure on_next_idle_callback)"
  },
  {
    "label": "SetTaskRunner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTaskRunner(scoped_refptr<SingleThreadTaskRunner> task_runner)"
  },
  {
    "label": "GetTaskRunner()",
    "kind": "Method",
    "detail": "Function (scoped_refptr<SingleThreadTaskRunner>)",
    "insertText": "GetTaskRunner()"
  },
  {
    "label": "IsBoundToCurrentThread()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsBoundToCurrentThread()"
  },
  {
    "label": "GetMessagePump()",
    "kind": "Method",
    "detail": "Function (MessagePump*)",
    "insertText": "GetMessagePump()"
  },
  {
    "label": "IsType()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsType(MessagePumpType type)"
  },
  {
    "label": "SetAddQueueTimeToTasks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAddQueueTimeToTasks(bool enable)"
  },
  {
    "label": "SetTaskExecutionAllowed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTaskExecutionAllowed(bool allowed)"
  },
  {
    "label": "IsTaskExecutionAllowed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsTaskExecutionAllowed()"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_IOS) void AttachToMessagePump()"
  },
  {
    "label": "IsIdleForTesting()",
    "kind": "Method",
    "detail": "Function (# endif bool)",
    "insertText": "IsIdleForTesting()"
  },
  {
    "label": "EnableMessagePumpTimeKeeperMetrics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnableMessagePumpTimeKeeperMetrics(const char* thread_name)"
  },
  {
    "label": "ScheduleWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScheduleWork()"
  },
  {
    "label": "currently_executing_task_queue()",
    "kind": "Method",
    "detail": "Function (internal::TaskQueueImpl*)",
    "insertText": "currently_executing_task_queue()"
  },
  {
    "label": "UnregisterTaskQueueImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterTaskQueueImpl(std::unique_ptr<internal::TaskQueueImpl> task_queue)"
  },
  {
    "label": "ShutdownTaskQueueGracefully()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ShutdownTaskQueueGracefully(std::unique_ptr<internal::TaskQueueImpl> task_queue)"
  },
  {
    "label": "associated_thread()",
    "kind": "Method",
    "detail": "Function (scoped_refptr<const AssociatedThreadId>)",
    "insertText": "associated_thread()"
  },
  {
    "label": "Seconds()",
    "kind": "Method",
    "detail": "Function (TimeDelta kReclaimMemoryInterval =)",
    "insertText": "Seconds(30)"
  },
  {
    "label": "CreateThreadControllerImplForCurrentThread()",
    "kind": "Method",
    "detail": "Function (protected : std::unique_ptr<ThreadControllerImpl>)",
    "insertText": "CreateThreadControllerImplForCurrentThread(const TickClock* clock)"
  },
  {
    "label": "SequenceManagerImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SequenceManagerImpl(std::unique_ptr<internal::ThreadController> controller, SequenceManager::Settings settings = Settings())"
  },
  {
    "label": "GetCurrent()",
    "kind": "Method",
    "detail": "Function (class internal::TaskQueueImpl ; class internal::DefaultWakeUpQueue ; class::base::sequence_manager::SequenceManagerForTest ; private : class NativeWorkHandleImpl ; SequenceManagerImpl*)",
    "insertText": "GetCurrent()"
  },
  {
    "label": "ExecutingTask()",
    "kind": "Method",
    "detail": "Function (class::base::CurrentThread ; enum class ProcessTaskResult { kDeferred,kExecuted,kSequenceManagerDeleted,} ; using NonNestableTaskDeque = circular_deque<internal::TaskQueueImpl::DeferredNonNestableTask> ; struct ExecutingTask {)",
    "insertText": "ExecutingTask(Task&& task, internal::TaskQueueImpl* task_queue, TaskQueue::TaskTiming task_timing) : pending_task(std::move(task)), task_queue(task_queue), task_queue_name(task_queue->GetProtoName()), task_timing(task_timing), priority(task_queue->GetQueuePriority()), task_type(pending_task.task_type)"
  },
  {
    "label": "MainThreadOnly()",
    "kind": "Method",
    "detail": "Function (} Task pending_task ; RAW_PTR_EXCLUSION internal::TaskQueueImpl* task_queue = nullptr ; QueueName task_queue_name ; TaskQueue::TaskTiming task_timing ; TaskQueue::QueuePriority priority ; int task_type ; } ; struct MainThreadOnly {)",
    "insertText": "MainThreadOnly(SequenceManagerImpl* sequence_manager, const scoped_refptr<AssociatedThreadId>& associated_thread, const SequenceManager::Settings& settings, const base::TickClock* clock)"
  },
  {
    "label": "MainThreadOnly()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "MainThreadOnly()"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (int nesting_depth = 0 ; NonNestableTaskDeque non_nestable_task_queue ; raw_ptr<debug::CrashKeyString> file_name_crash_key = nullptr ; raw_ptr<debug::CrashKeyString> function_name_crash_key = nullptr ; raw_ptr<debug::CrashKeyString> async_stack_crash_key = nullptr ; std::array<char,static_cast<)",
    "insertText": "size_t(debug::CrashKeySize::Size64)"
  },
  {
    "label": "CompleteInitializationOnBoundThread()",
    "kind": "Method",
    "detail": "Function (} ; absl::optional<base::MetricsSubSampler> metrics_subsampler ; internal::TaskQueueSelector selector ; ObserverList<TaskObserver>::Unchecked task_observers ; ObserverList<TaskTimeObserver>::Unchecked task_time_observers ; const raw_ptr<const base::TickClock> default_clock ; raw_ptr<TimeDomain> time_domain = nullptr ; std::unique_ptr<WakeUpQueue> wake_up_queue ; std::unique_ptr<WakeUpQueue> non_waking_wake_up_queue ; bool memory_reclaim_scheduled = false ; TimeTicks next_time_to_reclaim_memory ; std::set<internal::TaskQueueImpl*> active_queues ; std::map<internal::TaskQueueImpl*,std::unique_ptr<internal::TaskQueueImpl>> queues_to_gracefully_shutdown ; std::map<internal::TaskQueueImpl*,std::unique_ptr<internal::TaskQueueImpl>> queues_to_delete ; bool task_was_run_on_quiescence_monitored_queue = false ; bool nesting_observer_registered_ = false ; std::deque<ExecutingTask> task_execution_stack ; raw_ptr<Observer> observer = nullptr ; ObserverList<CurrentThread::DestructionObserver>::Unchecked destruction_observers ; OnceClosure on_next_idle_callback ; std::multiset<TaskQueue::QueuePriority> pending_native_work { TaskQueue::kBestEffortPriority } ; } ; void)",
    "insertText": "CompleteInitializationOnBoundThread()"
  },
  {
    "label": "OnTaskQueueEnabled()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnTaskQueueEnabled(internal::TaskQueueImpl* queue)"
  },
  {
    "label": "OnBeginNestedRunLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnBeginNestedRunLoop()"
  },
  {
    "label": "OnExitNestedRunLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnExitNestedRunLoop()"
  },
  {
    "label": "SetNextWakeUp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNextWakeUp(LazyNow* lazy_now, absl::optional<WakeUp> wake_up)"
  },
  {
    "label": "WillQueueTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WillQueueTask(Task* pending_task)"
  },
  {
    "label": "MoveReadyDelayedTasksToWorkQueues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MoveReadyDelayedTasksToWorkQueues(LazyNow* lazy_now)"
  },
  {
    "label": "NotifyWillProcessTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NotifyWillProcessTask(ExecutingTask* task, LazyNow* time_before_task)"
  },
  {
    "label": "NotifyDidProcessTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NotifyDidProcessTask(ExecutingTask* task, LazyNow* time_after_task)"
  },
  {
    "label": "GetNextSequenceNumber()",
    "kind": "Method",
    "detail": "Function (EnqueueOrder)",
    "insertText": "GetNextSequenceNumber()"
  },
  {
    "label": "GetAddQueueTimeToTasks()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetAddQueueTimeToTasks()"
  },
  {
    "label": "AsValueWithSelectorResultForTracing()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<trace_event::ConvertableToTraceFormat>)",
    "insertText": "AsValueWithSelectorResultForTracing(internal::WorkQueue* selected_work_queue, bool force_verbose)"
  },
  {
    "label": "AsValueWithSelectorResult()",
    "kind": "Method",
    "detail": "Function (Value::Dict)",
    "insertText": "AsValueWithSelectorResult(internal::WorkQueue* selected_work_queue, bool force_verbose)"
  },
  {
    "label": "GetFlagToRequestReloadForEmptyQueue()",
    "kind": "Method",
    "detail": "Function (AtomicFlagSet::AtomicFlag)",
    "insertText": "GetFlagToRequestReloadForEmptyQueue(TaskQueueImpl* task_queue)"
  },
  {
    "label": "ReloadEmptyWorkQueues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReloadEmptyWorkQueues()"
  },
  {
    "label": "CreateTaskQueueImpl()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<internal::TaskQueueImpl>)",
    "insertText": "CreateTaskQueueImpl(const TaskQueue::Spec& spec)"
  },
  {
    "label": "MaybeReclaimMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeReclaimMemory()"
  },
  {
    "label": "CleanUpQueues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CleanUpQueues()"
  },
  {
    "label": "RemoveAllCanceledTasksFromFrontOfWorkQueues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAllCanceledTasksFromFrontOfWorkQueues()"
  },
  {
    "label": "ShouldRecordTaskTiming()",
    "kind": "Method",
    "detail": "Function (TaskQueue::TaskTiming::TimeRecordingPolicy)",
    "insertText": "ShouldRecordTaskTiming(const internal::TaskQueueImpl* task_queue)"
  },
  {
    "label": "ShouldRecordCPUTimeForTask()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldRecordCPUTimeForTask()"
  },
  {
    "label": "RecordCrashKeys()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecordCrashKeys(const PendingTask&)"
  },
  {
    "label": "SelectNextTaskImpl()",
    "kind": "Method",
    "detail": "Function (absl::optional<SelectedTask>)",
    "insertText": "SelectNextTaskImpl(LazyNow& lazy_now, SelectTaskOption option)"
  },
  {
    "label": "ShouldRunTaskOfPriority()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldRunTaskOfPriority(TaskQueue::QueuePriority priority)"
  },
  {
    "label": "GetNextDelayedWakeUpWithOption()",
    "kind": "Method",
    "detail": "Function (absl::optional<WakeUp>)",
    "insertText": "GetNextDelayedWakeUpWithOption(SelectTaskOption option)"
  },
  {
    "label": "AdjustWakeUp()",
    "kind": "Method",
    "detail": "Function (absl::optional<WakeUp>)",
    "insertText": "AdjustWakeUp(absl::optional<WakeUp> wake_up, LazyNow* lazy_now)"
  },
  {
    "label": "MaybeAddLeewayToTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeAddLeewayToTask(Task& task)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() void LogTaskDebugInfo(const internal::WorkQueue* work_queue)"
  },
  {
    "label": "InitializeTaskTiming()",
    "kind": "Method",
    "detail": "Function (# endif TaskQueue::TaskTiming)",
    "insertText": "InitializeTaskTiming(internal::TaskQueueImpl* task_queue)"
  },
  {
    "label": "main_thread_only()",
    "kind": "Method",
    "detail": "Function (const scoped_refptr<AssociatedThreadId> associated_thread_ ; EnqueueOrderGenerator enqueue_order_generator_ ; const std::unique_ptr<internal::ThreadController> controller_ ; const Settings settings_ ; const MetricRecordingSettings metric_recording_settings_ ; base::subtle::Atomic32 add_queue_time_to_tasks_ ; AtomicFlagSet empty_queues_to_reload_ ; MainThreadOnly main_thread_only_ ; MainThreadOnly&)",
    "insertText": "main_thread_only()"
  },
  {
    "label": "DCHECK_CALLED_ON_VALID_THREAD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_CALLED_ON_VALID_THREAD(associated_thread_->thread_checker)"
  },
  {
    "label": "any_thread_clock()",
    "kind": "Method",
    "detail": "Function (} const base::TickClock*)",
    "insertText": "any_thread_clock()"
  }
]