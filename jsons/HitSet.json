[
  {
    "label": "FHitSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FHitSet"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FHitSet()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" TaggedPtr . h \" # include \" Utils . h \" namespace AutoRTFM { class FHitSet final { uint64_t LinearProbeDepth = 1 6 ; uint64_t LogInitialCapacity = 4 ; public : using Key = TTaggedPtr<void> ;)",
    "insertText": "FHitSet()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (uint64_t InitialCapacity = 1 u<<LogInitialCapacity ;)",
    "insertText": "static_assert(0 != InitialCapacity)"
  },
  {
    "label": "uintptr_t()",
    "kind": "Method",
    "detail": "Function (Payload = static_cast<)",
    "insertText": "uintptr_t(FMemory::MallocZeroed(InitialCapacity * sizeof(uintptr_t)))"
  },
  {
    "label": "ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ASSERT(nullptr != Payload)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(Payload)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Insert(Key K)"
  },
  {
    "label": "Unreachable()",
    "kind": "Method",
    "detail": "Function (default :)",
    "insertText": "Unreachable()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (continue ; } } } UE_AUTORTFM_FORCEINLINE bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(Payload, 0, sizeof(uintptr_t) * Capacity())"
  },
  {
    "label": "GetCapacity()",
    "kind": "Method",
    "detail": "Function (Size = 0 ; } uint64_t)",
    "insertText": "GetCapacity()"
  },
  {
    "label": "GetSize()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "GetSize()"
  },
  {
    "label": "IncreaseCapacity()",
    "kind": "Method",
    "detail": "Function (} UE_AUTORTFM_FORCEINLINE void)",
    "insertText": "IncreaseCapacity()"
  },
  {
    "label": "ASSERT()",
    "kind": "Method",
    "detail": "Function (SixtyFourMinusLogCapacity - = 1 ;)",
    "insertText": "ASSERT(0 != SixtyFourMinusLogCapacity)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Resize()"
  },
  {
    "label": "Capacity()",
    "kind": "Method",
    "detail": "Function (uintptr_t* const OldPayload = Payload ; const uint64_t OldCapacity =)",
    "insertText": "Capacity()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const uint64_t OldSize = Size ;)",
    "insertText": "while(true)"
  },
  {
    "label": "uintptr_t()",
    "kind": "Method",
    "detail": "Function (Payload = static_cast<)",
    "insertText": "uintptr_t(FMemory::MallocZeroed(Capacity() * sizeof(uintptr_t)))"
  },
  {
    "label": "InsertNoResize()",
    "kind": "Method",
    "detail": "Function (continue ; } const EInsertResult Result =)",
    "insertText": "InsertNoResize(OldPayload[I])"
  },
  {
    "label": "ASSERT()",
    "kind": "Method",
    "detail": "Function (NeedAnotherResize = true ; break ; } else {)",
    "insertText": "ASSERT(EInsertResult::Inserted == Result)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(NeedAnotherResize)"
  },
  {
    "label": "ASSERT()",
    "kind": "Method",
    "detail": "Function (continue ; } break ; })",
    "insertText": "ASSERT(OldSize == Size)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(OldPayload)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (uintptr_t Fibonacci = 0 x9E3779B97F4A7C15 ;)",
    "insertText": "return(Hashee * Fibonacci)"
  },
  {
    "label": "SecondHash()",
    "kind": "Method",
    "detail": "Function (} UE_AUTORTFM_FORCEINLINE uintptr_t)",
    "insertText": "SecondHash(const uintptr_t Hashee)"
  },
  {
    "label": "TryInsertAtIndex()",
    "kind": "Method",
    "detail": "Function (uintptr_t A = 0 x65d200ce55b19ad8 ; uintptr_t B = 0 x4f2162926e40c299 ; uintptr_t C = 0 x162dd799029970f8 ; const uintptr_t Low = Hashee& 0 x00000000FFFFFFFF ; const uintptr_t High = Hashee>> 3 2 ; const uintptr_t Hash = A* Low + B* High + C ; return Hash ; } UE_AUTORTFM_FORCEINLINE EInsertResult)",
    "insertText": "TryInsertAtIndex(const uintptr_t Raw, const uintptr_t I)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Payload [ I ] = Raw ; Size + + ; return EInsertResult::Inserted ; })",
    "insertText": "if(Raw == Payload[I])"
  },
  {
    "label": "FirstHashInRange()",
    "kind": "Method",
    "detail": "Function ({ const uintptr_t I =)",
    "insertText": "FirstHashInRange(Raw)"
  },
  {
    "label": "TryInsertAtIndex()",
    "kind": "Method",
    "detail": "Function (const EInsertResult R =)",
    "insertText": "TryInsertAtIndex(Raw, I)"
  },
  {
    "label": "unroll()",
    "kind": "Method",
    "detail": "Function (# ifdef __clang__ # pragma clang loop)",
    "insertText": "unroll(disable) #endif for (uint64_t D = 0; D < LinearProbeDepth; D++)"
  },
  {
    "label": "FirstHashInRange()",
    "kind": "Method",
    "detail": "Function (const uintptr_t I =)",
    "insertText": "FirstHashInRange(Hash + D)"
  }
]