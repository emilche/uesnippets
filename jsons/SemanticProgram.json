[
  {
    "label": "CAstModule",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CAstModule"
  },
  {
    "label": "CModulePart",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CModulePart"
  },
  {
    "label": "SEffectDescriptor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SEffectDescriptor"
  },
  {
    "label": "SDecompositionMapping",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SDecompositionMapping"
  },
  {
    "label": "CAstPackageRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CAstPackageRef"
  },
  {
    "label": "VERSECOMPILER_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VERSECOMPILER_API"
  },
  {
    "label": "CSnippet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CSnippet"
  },
  {
    "label": "TCachedIntrinsicDefinition",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCachedIntrinsicDefinition"
  },
  {
    "label": "SExplicitTypeParam",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SExplicitTypeParam"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "CScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CScope"
  },
  {
    "label": "CLogicalScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CLogicalScope"
  },
  {
    "label": "SetAstPackage()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" uLang / Common / Containers / SharedPointer . h \" # include \" uLang / Common / Containers / UniquePointer . h \" # include \" uLang / Common / Containers / UniquePointerArray . h \" # include \" uLang / Common / Containers / UniquePointerSet . h \" # include \" uLang / Common / Containers / Map . h \" # include \" uLang / Semantics / Definition . h \" # include \" uLang / Semantics / MemberOrigin . h \" # include \" uLang / Semantics / SemanticClass . h \" # include \" uLang / Semantics / SemanticInterface . h \" # include \" uLang / Semantics / SmallDefinitionArray . h \" # include \" uLang / Semantics / UnknownType . h \" # include \" uLang / Semantics / VisitStamp . h \" namespace uLang { class CAstModule ; class CModulePart ; struct SEffectDescriptor { SEffectSet _EffectSet ; SEffectSet _RescindFromDefault ; uLang::TArray<const CClass*> _MutualExclusions ; bool _AllowInDecomposition = true ; } ; struct SDecompositionMapping { SEffectSet Effects ; const CClass* Class ; } ; class CAstPackageRef { public : void)",
    "insertText": "SetAstPackage(CAstPackage* AstPackage)"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(!_IrPackage, \"Called AST function when IR available\")"
  },
  {
    "label": "GetAstPackage()",
    "kind": "Method",
    "detail": "Function (_AstPackage = AstPackage ; } CAstPackage*)",
    "insertText": "GetAstPackage()"
  },
  {
    "label": "GetIrPackage()",
    "kind": "Method",
    "detail": "Function (_IrPackage = IrPackage ; } CAstPackage*)",
    "insertText": "GetIrPackage()"
  },
  {
    "label": "HasParts()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasParts()"
  },
  {
    "label": "GetParts()",
    "kind": "Method",
    "detail": "Function (} const PartArray&)",
    "insertText": "GetParts()"
  },
  {
    "label": "IsExplicitDefinition()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsExplicitDefinition()"
  },
  {
    "label": "GetScopeName()",
    "kind": "Method",
    "detail": "Function (CSymbol)",
    "insertText": "GetScopeName()"
  },
  {
    "label": "ScopeAsType()",
    "kind": "Method",
    "detail": "Function (} const CTypeBase*)",
    "insertText": "ScopeAsType()"
  },
  {
    "label": "FindInstanceMember()",
    "kind": "Method",
    "detail": "Function (SmallDefinitionArray)",
    "insertText": "FindInstanceMember(const CSymbol& Name, EMemberOrigin Origin, const SQualifier& Qualifier, const CAstPackage* ContextPackage = nullptr, VisitStampType VisitStamp = CScope::GenerateNewVisitStamp())"
  },
  {
    "label": "CanBeCustomAccessorDataType()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanBeCustomAccessorDataType()"
  },
  {
    "label": "SetAstNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAstNode(AstNode)"
  },
  {
    "label": "GetAstNode()",
    "kind": "Method",
    "detail": "Function (} CExprModuleDefinition*)",
    "insertText": "GetAstNode()"
  },
  {
    "label": "SetIrNode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetIrNode(CExprModuleDefinition* AstNode)"
  },
  {
    "label": "SetIrNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetIrNode(AstNode)"
  },
  {
    "label": "GetIrNode()",
    "kind": "Method",
    "detail": "Function (} CExprModuleDefinition*)",
    "insertText": "GetIrNode(bool bForce = false)"
  },
  {
    "label": "MarkPersistenceCompatConstraint()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MarkPersistenceCompatConstraint()"
  },
  {
    "label": "IsPersistenceCompatConstraint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPersistenceCompatConstraint()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (} const CModule*)",
    "insertText": "GetModule()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} } ; class CIntrinsicSymbols { public : void)",
    "insertText": "Initialize(CSymbolTable&)"
  },
  {
    "label": "GetArithmeticOpName()",
    "kind": "Method",
    "detail": "Function (CSymbol)",
    "insertText": "GetArithmeticOpName(CExprBinaryArithmetic::EOp)"
  },
  {
    "label": "GetComparisonOpName()",
    "kind": "Method",
    "detail": "Function (CSymbol)",
    "insertText": "GetComparisonOpName(CExprComparison::EOp)"
  },
  {
    "label": "GetAssignmentOpName()",
    "kind": "Method",
    "detail": "Function (CSymbol)",
    "insertText": "GetAssignmentOpName(CExprAssignment::EOp)"
  },
  {
    "label": "MakeExtensionFieldOpName()",
    "kind": "Method",
    "detail": "Function (CUTF8String)",
    "insertText": "MakeExtensionFieldOpName(CSymbol FieldName)"
  },
  {
    "label": "StripExtensionFieldOpName()",
    "kind": "Method",
    "detail": "Function (CUTF8StringView)",
    "insertText": "StripExtensionFieldOpName(CSymbol FieldName)"
  },
  {
    "label": "IsOperatorOpName()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsOperatorOpName(CSymbol)"
  },
  {
    "label": "IsPrefixOpName()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPrefixOpName(CSymbol)"
  },
  {
    "label": "IsPostfixOpName()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPostfixOpName(CSymbol)"
  },
  {
    "label": "CCompatConstraintRoot()",
    "kind": "Method",
    "detail": "Function (CSymbol _OpNameNegate ; CSymbol _OpNameAdd ; CSymbol _OpNameSub ; CSymbol _OpNameMul ; CSymbol _OpNameDiv ; CSymbol _OpNameLess ; CSymbol _OpNameLessEqual ; CSymbol _OpNameGreater ; CSymbol _OpNameGreaterEqual ; CSymbol _OpNameEqual ; CSymbol _OpNameNotEqual ; CSymbol _OpNameAddRMW ; CSymbol _OpNameSubRMW ; CSymbol _OpNameMulRMW ; CSymbol _OpNameDivRMW ; CSymbol _OpNameCall ; CSymbol _OpNameQuery ; CSymbol _FuncNameAbs ; CSymbol _FuncNameCeil ; CSymbol _FuncNameFloor ; CSymbol _FuncNameWeakMap ; CSymbol _FuncNameFitsInPlayerMap ; CSymbol _FieldNameLength ; CSymbol _Wildcard ; CSymbol _Inf ; CSymbol _NaN ; CSymbol _MinUploadedAtFNVersion ; private : CUTF8StringView _OperatorOpNamePrefix ; CUTF8StringView _PrefixOpNamePrefix ; CUTF8StringView _PostfixOpNamePrefix ; CUTF8StringView _OpNameSuffix ; CUTF8StringView _ExtensionFieldPrefix ; CUTF8StringView _ExtensionFieldSuffix ; } ; class CCompatConstraintRoot : public CSharedMix,public CLogicalScope { public :)",
    "insertText": "CCompatConstraintRoot(CSemanticProgram& Program) : CLogicalScope(CScope::EKind::CompatConstraintRoot, nullptr, Program)"
  },
  {
    "label": "FindDefinitions()",
    "kind": "Method",
    "detail": "Function (} SmallDefinitionArray)",
    "insertText": "FindDefinitions(const CSymbol& Name, EMemberOrigin, const SQualifier& Qualifier, const CAstPackage* ContextPackage, VisitStampType)"
  },
  {
    "label": "GetTaskFunction()",
    "kind": "Method",
    "detail": "Function (} ; class CSemanticProgram : public CSharedMix,public CLogicalScope { public : TSPtr<CCompatConstraintRoot> _GeneralCompatConstraintRoot ; TSPtr<CCompatConstraintRoot> _PersistenceCompatConstraintRoot ; TSPtr<CCompatConstraintRoot> _PersistenceSoftCompatConstraintRoot ; TSPtr<CAstPackage> _BuiltInPackage ; CModule* _VerseModule { nullptr } ; CFalseType _falseType {* this } ; CTrueType _trueType {* this } ; CVoidType _voidType {* this } ; CAnyType _anyType {* this } ; CComparableType _comparableType {* this } ; CPersistableType _persistableType {* this } ; CLogicType _logicType {* this } ; CRationalType _rationalType {* this } ; CChar8Type _char8Type {* this } ; CChar32Type _char32Type {* this } ; CPathType _pathType {* this } ; CRangeType _rangeType {* this } ; const CTypeType* _typeType { nullptr } ; const CIntType* _intType { nullptr } ; const CFloatType* _floatType { nullptr } ; CTypeAlias* _falseAlias { nullptr } ; CTypeAlias* _trueAlias { nullptr } ; CTypeAlias* _voidAlias { nullptr } ; CTypeAlias* _anyAlias { nullptr } ; CTypeAlias* _comparableAlias { nullptr } ; CTypeAlias* _logicAlias { nullptr } ; CTypeAlias* _intAlias { nullptr } ; CTypeAlias* _rationalAlias { nullptr } ; CTypeAlias* _floatAlias { nullptr } ; CTypeAlias* _char8Alias { nullptr } ; CTypeAlias* _char32Alias { nullptr } ; CTypeAlias* _stringAlias { nullptr } ; CTypeAlias* _typeAlias { nullptr } ; const CFunction*)",
    "insertText": "GetTaskFunction()"
  },
  {
    "label": "GetTaskClass()",
    "kind": "Method",
    "detail": "Function (const CClass*)",
    "insertText": "GetTaskClass()"
  },
  {
    "label": "InstantiateTaskType()",
    "kind": "Method",
    "detail": "Function (const CTypeBase*)",
    "insertText": "InstantiateTaskType(const CTypeBase* TypeArgument)"
  },
  {
    "label": "TCachedIntrinsicDefinition()",
    "kind": "Method",
    "detail": "Function (CClass* _attributeClass { nullptr } ; CClass* _abstractClass { nullptr } ; CClass* _finalClass { nullptr } ; CClass* _concreteClass { nullptr } ; CClass* _uniqueClass { nullptr } ; CClass* _intrinsicClass { nullptr } ; CClass* _nativeClass { nullptr } ; CClass* _nativeCallClass { nullptr } ; CClass* _suspendsClass { nullptr } ; CClass* _decidesClass { nullptr } ; CClass* _variesClassDeprecated { nullptr } ; CClass* _computesClass { nullptr } ; CClass* _convergesClass { nullptr } ; CClass* _transactsClass { nullptr } ; CClass* _readsClass { nullptr } ; CClass* _writesClass { nullptr } ; CClass* _allocatesClass { nullptr } ; CClass* _constructorClass { nullptr } ; CClass* _overrideClass { nullptr } ; CClass* _publicClass { nullptr } ; CClass* _privateClass { nullptr } ; CClass* _protectedClass { nullptr } ; CClass* _internalClass { nullptr } ; CClass* _scopedClass { nullptr } ; CClass* _epicInternalClass { nullptr } ; CClass* _localizes { nullptr } ; CClass* _ignore_unreachable { nullptr } ; CClass* _deprecatedClass { nullptr } ; CClass* _experimentalClass { nullptr } ; CClass* _persistentClass { nullptr } ; CClass* _persistableClass { nullptr } ; CClass* _moduleScopedVarWeakMapKeyClass { nullptr } ; CClass* _getterClass { nullptr } ; CClass* _setterClass { nullptr } ; CClass* _attributeScopeAttribute { nullptr } ; CClass* _attributeScopeSpecifier { nullptr } ; CClass* _attributeScopeModule { nullptr } ; CClass* _attributeScopeClass { nullptr } ; CClass* _attributeScopeStruct { nullptr } ; CClass* _attributeScopeData { nullptr } ; CClass* _attributeScopeFunction { nullptr } ; CClass* _attributeScopeEnum { nullptr } ; CClass* _attributeScopeEnumerator { nullptr } ; CClass* _attributeScopeAttributeClass { nullptr } ; CClass* _attributeScopeInterface { nullptr } ; CClass* _attributeScopeIdentifier { nullptr } ; CClass* _attributeScopeExpression { nullptr } ; CClass* _attributeScopeClassMacro { nullptr } ; CClass* _attributeScopeStructMacro { nullptr } ; CClass* _attributeScopeInterfaceMacro { nullptr } ; CClass* _attributeScopeEnumMacro { nullptr } ; CClass* _attributeScopeVar { nullptr } ; CClass* _attributeScopeName { nullptr } ; CClass* _attributeScopeEffect { nullptr } ; CClass* _attributeScopeTypeDefinition { nullptr } ; CClass* _attributeScopeScopedDefinition { nullptr } ; CClass* _customAttributeHandler { nullptr } ; CClass* _availableClass { nullptr } ; template<DefinitionType> struct TCachedIntrinsicDefinition {)",
    "insertText": "TCachedIntrinsicDefinition(CSemanticProgram& Program, CUTF8StringView Path) : _Program(Program), _Path(Path)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} DefinitionType*)",
    "insertText": "Get()"
  },
  {
    "label": "DefinitionType()",
    "kind": "Method",
    "detail": "Function (_CachedValue = _Program . FindDefinitionByVersePath<)",
    "insertText": "DefinitionType(_Path)"
  },
  {
    "label": "GetIrProject()",
    "kind": "Method",
    "detail": "Function (} return* _CachedValue ; } private : CSemanticProgram& _Program ; CUTF8String _Path ; TOptional<DefinitionType*> _CachedValue ; } ; TCachedIntrinsicDefinition<CClassDefinition> _editable {* this,\" / Verse . org / Simulation / editable \" } ; TCachedIntrinsicDefinition<CClassDefinition> _editable_non_concrete {* this,\" / Verse . org / Simulation / editable_non_concrete \" } ; TCachedIntrinsicDefinition<CClassDefinition> _import_as_attribute {* this,\" / Verse . org / Native / import_as_attribute \" } ; TCachedIntrinsicDefinition<CFunction> _import_as {* this,\" / Verse . org / Native / import_as \" } ; TCachedIntrinsicDefinition<CClassDefinition> _doc_attribute {* this,\" / Verse . org / Native / doc_attribute \" } ; CFunction* _ComparableEqualOp { nullptr } ; CFunction* _ComparableNotEqualOp { nullptr } ; CFunction* _IntNegateOp { nullptr } ; CFunction* _IntAddOp { nullptr } ; CFunction* _IntSubtractOp { nullptr } ; CFunction* _IntMultiplyOp { nullptr } ; CFunction* _IntDivideOp { nullptr } ; CFunction* _IntAddAssignOp { nullptr } ; CFunction* _IntSubtractAssignOp { nullptr } ; CFunction* _IntMultiplyAssignOp { nullptr } ; CFunction* _IntAbs { nullptr } ; CFunction* _IntGreaterOp { nullptr } ; CFunction* _IntGreaterEqualOp { nullptr } ; CFunction* _IntLessOp { nullptr } ; CFunction* _IntLessEqualOp { nullptr } ; CFunction* _RationalCeil { nullptr } ; CFunction* _RationalFloor { nullptr } ; CFunction* _FloatNegateOp { nullptr } ; CFunction* _FloatAddOp { nullptr } ; CFunction* _FloatSubtractOp { nullptr } ; CFunction* _FloatMultiplyOp { nullptr } ; CFunction* _FloatDivideOp { nullptr } ; CFunction* _FloatAddAssignOp { nullptr } ; CFunction* _FloatSubtractAssignOp { nullptr } ; CFunction* _FloatMultiplyAssignOp { nullptr } ; CFunction* _FloatDivideAssignOp { nullptr } ; CFunction* _FloatAbs { nullptr } ; CFunction* _IntMultiplyFloatOp { nullptr } ; CFunction* _FloatMultiplyIntOp { nullptr } ; CFunction* _FloatGreaterOp { nullptr } ; CFunction* _FloatGreaterEqualOp { nullptr } ; CFunction* _FloatLessOp { nullptr } ; CFunction* _FloatLessEqualOp { nullptr } ; CFunction* _ArrayAddOp { nullptr } ; CFunction* _ArrayAddAssignOp { nullptr } ; CFunction* _ArrayLength { nullptr } ; CFunction* _ArrayCallOp { nullptr } ; CFunction* _ArrayRefCallOp { nullptr } ; CFunction* _MapRefCallOp { nullptr } ; CFunction* _MapLength { nullptr } ; CFunction* _MapConcatenateMaps { nullptr } ; CFunction* _WeakMapCallOp { nullptr } ; CFunction* _WeakMapRefCallOp { nullptr } ; CFunction* _WeakMapOp { nullptr } ; CFunction* _LogicQueryOp { nullptr } ; CFunction* _OptionQueryOp { nullptr } ; CFunction* _FitsInPlayerMap { nullptr } ; CDataDefinition* _InfDefinition { nullptr } ; CDataDefinition* _NaNDefinition { nullptr } ; CFunction* _Getter { nullptr } ; CFunction* _Setter { nullptr } ; CFunction* _UnsafeCast { nullptr } ; CIntrinsicSymbols _IntrinsicSymbols ; TArray<CUTF8String> _EpicInternalModulePrefixes ; TSPtr<CAstProject> _AstProject ; private : TSPtr<CAstProject> _IrProject ; public : TSPtr<CAstProject>&)",
    "insertText": "GetIrProject()"
  },
  {
    "label": "CSemanticProgram()",
    "kind": "Method",
    "detail": "Function (_IrProject = project ; } ULANG_FORCEINLINE)",
    "insertText": "CSemanticProgram() : CLogicalScope(CScope::EKind::Program, nullptr, *this)"
  },
  {
    "label": "CSemanticProgram()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE ~)",
    "insertText": "CSemanticProgram()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (_IrProject .)",
    "insertText": "Reset()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Initialize(TSPtr<CSymbolTable> Symbols = TSPtr<CSymbolTable>())"
  },
  {
    "label": "GetSymbols()",
    "kind": "Method",
    "detail": "Function (ULANG_FORCEINLINE const TSPtr<CSymbolTable>&)",
    "insertText": "GetSymbols()"
  },
  {
    "label": "FindSnippet()",
    "kind": "Method",
    "detail": "Function (CSnippet*)",
    "insertText": "FindSnippet(const CUTF8StringView& NameStr)"
  },
  {
    "label": "GetOrCreateArrayType()",
    "kind": "Method",
    "detail": "Function (CArrayType&)",
    "insertText": "GetOrCreateArrayType(const CTypeBase* ElementType)"
  },
  {
    "label": "GetOrCreateGeneratorType()",
    "kind": "Method",
    "detail": "Function (CGeneratorType&)",
    "insertText": "GetOrCreateGeneratorType(const CTypeBase* ElementType)"
  },
  {
    "label": "GetOrCreateMapType()",
    "kind": "Method",
    "detail": "Function (CMapType&)",
    "insertText": "GetOrCreateMapType(const CTypeBase* KeyType, const CTypeBase* ValueType)"
  },
  {
    "label": "GetOrCreateWeakMapType()",
    "kind": "Method",
    "detail": "Function (CMapType&)",
    "insertText": "GetOrCreateWeakMapType(const CTypeBase& KeyType, const CTypeBase& ValueType)"
  },
  {
    "label": "GetOrCreateMapType()",
    "kind": "Method",
    "detail": "Function (CMapType&)",
    "insertText": "GetOrCreateMapType(const CTypeBase& KeyType, const CTypeBase& ValueType, bool bWeak)"
  },
  {
    "label": "GetOrCreatePointerType()",
    "kind": "Method",
    "detail": "Function (CPointerType&)",
    "insertText": "GetOrCreatePointerType(const CTypeBase* NegativeValueType, const CTypeBase* PositiveValueType)"
  },
  {
    "label": "GetOrCreateReferenceType()",
    "kind": "Method",
    "detail": "Function (CReferenceType&)",
    "insertText": "GetOrCreateReferenceType(const CTypeBase* NegativeValueType, const CTypeBase* PositiveValueType)"
  },
  {
    "label": "GetOrCreateOptionType()",
    "kind": "Method",
    "detail": "Function (COptionType&)",
    "insertText": "GetOrCreateOptionType(const CTypeBase* ValueType)"
  },
  {
    "label": "GetOrCreateTypeType()",
    "kind": "Method",
    "detail": "Function (CTypeType&)",
    "insertText": "GetOrCreateTypeType(const CTypeBase* NegativeType, const CTypeBase* PositiveType)"
  },
  {
    "label": "GetOrCreateSubtypeType()",
    "kind": "Method",
    "detail": "Function (CTypeType&)",
    "insertText": "GetOrCreateSubtypeType(const CTypeBase* PositiveType)"
  },
  {
    "label": "GetOrCreateTupleType()",
    "kind": "Method",
    "detail": "Function (CTupleType&)",
    "insertText": "GetOrCreateTupleType(CTupleType::ElementArray&& Elements)"
  },
  {
    "label": "GetOrCreateTupleType()",
    "kind": "Method",
    "detail": "Function (CTupleType&)",
    "insertText": "GetOrCreateTupleType(CTupleType::ElementArray&& Elements, int32_t FirstNamedIndex)"
  },
  {
    "label": "GetOrCreateNamedType()",
    "kind": "Method",
    "detail": "Function (CNamedType&)",
    "insertText": "GetOrCreateNamedType(CSymbol Name, const CTypeBase* ValueType, bool HasValue)"
  },
  {
    "label": "GetOrCreateFunctionType()",
    "kind": "Method",
    "detail": "Function (const CFunctionType&)",
    "insertText": "GetOrCreateFunctionType(const CTypeBase& ParamsType, const CTypeBase& ReturnType, SEffectSet Effects = EffectSets::FunctionDefault, TArray<const CTypeVariable*> TypeVariables = {}, bool ImplicitlySpecialized = false)"
  },
  {
    "label": "GetOrCreateConstrainedIntType()",
    "kind": "Method",
    "detail": "Function (const CIntType&)",
    "insertText": "GetOrCreateConstrainedIntType(CIntType::Constraint Min, CIntType::Constraint Max)"
  },
  {
    "label": "GetOrCreateConstrainedFloatType()",
    "kind": "Method",
    "detail": "Function (const CFloatType&)",
    "insertText": "GetOrCreateConstrainedFloatType(double Min, double Max)"
  },
  {
    "label": "CreateFlowType()",
    "kind": "Method",
    "detail": "Function (CFlowType&)",
    "insertText": "CreateFlowType(ETypePolarity)"
  },
  {
    "label": "CreateFlowType()",
    "kind": "Method",
    "detail": "Function (CFlowType&)",
    "insertText": "CreateFlowType(ETypePolarity, const CTypeBase*)"
  },
  {
    "label": "CreateNegativeFlowType()",
    "kind": "Method",
    "detail": "Function (CFlowType&)",
    "insertText": "CreateNegativeFlowType()"
  },
  {
    "label": "CreatePositiveFlowType()",
    "kind": "Method",
    "detail": "Function (} CFlowType&)",
    "insertText": "CreatePositiveFlowType()"
  },
  {
    "label": "CreateInstantiatedClass()",
    "kind": "Method",
    "detail": "Function (} CInstantiatedClass&)",
    "insertText": "CreateInstantiatedClass(const CClass&, ETypePolarity, TArray<STypeVariableSubstitution>)"
  },
  {
    "label": "CreateInstantiatedInterface()",
    "kind": "Method",
    "detail": "Function (CInstantiatedInterface&)",
    "insertText": "CreateInstantiatedInterface(const CInterface&, ETypePolarity, TArray<STypeVariableSubstitution>)"
  },
  {
    "label": "CreateExplicitTypeParam()",
    "kind": "Method",
    "detail": "Function (struct SExplicitTypeParam { CDataDefinition* DataDefinition ; CTypeVariable* TypeVariable ; CTypeVariable* NegativeTypeVariable ; } ; SExplicitTypeParam)",
    "insertText": "CreateExplicitTypeParam(CFunction*, CSymbol DataName, CSymbol TypeName, CSymbol NegativeTypeName, const CTypeType* Type)"
  },
  {
    "label": "AddStandardAccessLevelAttributes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddStandardAccessLevelAttributes(CAttributable* NewAccessLevel)"
  },
  {
    "label": "GetDefaultUnknownType()",
    "kind": "Method",
    "detail": "Function (const CUnknownType*)",
    "insertText": "GetDefaultUnknownType()"
  },
  {
    "label": "FindDefinitionByVersePath()",
    "kind": "Method",
    "detail": "Function (} template<class T> T*)",
    "insertText": "FindDefinitionByVersePath(CUTF8StringView VersePath)"
  },
  {
    "label": "FindDefinitionByVersePathInternal()",
    "kind": "Method",
    "detail": "Function (CDefinition* Definition =)",
    "insertText": "FindDefinitionByVersePathInternal(VersePath)"
  },
  {
    "label": "GetNextRevision()",
    "kind": "Method",
    "detail": "Function (} SemanticRevision)",
    "insertText": "GetNextRevision()"
  },
  {
    "label": "PopulateCoreAPI()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PopulateCoreAPI()"
  },
  {
    "label": "NextFunctionIndex()",
    "kind": "Method",
    "detail": "Function (} int32_t)",
    "insertText": "NextFunctionIndex()"
  },
  {
    "label": "GetAllEffectClasses()",
    "kind": "Method",
    "detail": "Function (const TArray<const CClass*>&)",
    "insertText": "GetAllEffectClasses()"
  },
  {
    "label": "ConvertEffectSetToEffectClasses()",
    "kind": "Method",
    "detail": "Function (TOptional<TArray<const CClass*>>)",
    "insertText": "ConvertEffectSetToEffectClasses(const SEffectSet& EffectSet, const SEffectSet& DefaultEffectSet)"
  },
  {
    "label": "PopulateEffectDescriptorTable()",
    "kind": "Method",
    "detail": "Function (private : class CScope ; class CLogicalScope ; TURefSet<CSnippet,CSymbol> _Snippets ; TURefSet<CArrayType,const CTypeBase*> _ArrayTypes ; TURefSet<CGeneratorType,const CTypeBase*> _GeneratorTypes ; TURefSet<CMapType,CMapType::SKey> _MapTypes ; TURefSet<CPointerType,CPointerType::Key> _PointerTypes ; TURefSet<CReferenceType,CReferenceType::Key> _ReferenceTypes ; TURefSet<COptionType,const CTypeBase*> _OptTypes ; TURefSet<CTypeType,CTypeType::Key> _TypeTypes ; CTupleType _EmptyTupleType {* this,{ },0 } ; TURefSet<CNamedType,CNamedType::Key> _NamedTypes ; TURefArray<CFlowType> _FlowTypes ; TURefArray<CIntType> _ConstrainedIntTypes ; TURefArray<CFloatType> _ConstrainedFloatTypes ; TURefArray<CInstantiatedClass> _InstantiatedClasses ; TURefArray<CInstantiatedInterface> _InstantiatedInterfaces ; TUPtr<CUnknownType> _DefaultUnknownType ; TSPtr<CSymbolTable> _Symbols ; CFunction* _taskFunction { nullptr } ; int32_t _NumFunctions { 0 } ; TMap<const CClass*,SEffectDescriptor> _EffectDescriptorTable ; TMap<const CClass*,SEffectDescriptor> _EffectDescriptorTable_Pre3100 ; TArray<const CClass*> _AllEffectClasses ; TArray<SDecompositionMapping> _OrderedDecompositionData ; bool bEffectsTablePopulated { false } ; void)",
    "insertText": "PopulateEffectDescriptorTable()"
  },
  {
    "label": "ValidateEffectDescriptorTable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateEffectDescriptorTable(const TMap<const CClass*, SEffectDescriptor>& DescriptorTable)"
  },
  {
    "label": "FindDefinitionByVersePathInternal()",
    "kind": "Method",
    "detail": "Function (CDefinition*)",
    "insertText": "FindDefinitionByVersePathInternal(CUTF8StringView VersePath)"
  },
  {
    "label": "GetEffectDescriptorTableForVersion()",
    "kind": "Method",
    "detail": "Function (const TMap<const CClass*,SEffectDescriptor>&)",
    "insertText": "GetEffectDescriptorTableForVersion(uint32_t UploadedAtFNVersion)"
  }
]