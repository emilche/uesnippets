[
  {
    "label": "WatchHangsInScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "WatchHangsInScope"
  },
  {
    "label": "HangWatchState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HangWatchState"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "WatchStateCopy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "WatchStateCopy"
  },
  {
    "label": "Seconds()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_THREADING_HANG_WATCHER_H_ # define BASE_THREADING_HANG_WATCHER_H_ # include<atomic> # include<cstdint> # include<memory> # include<type_traits> # include<vector> # include \" base / atomicops . h \" # include \" base / base_export . h \" # include \" base / bits . h \" # include \" base / callback . h \" # include \" base / callback_forward . h \" # include \" base / callback_helpers . h \" # include \" base / compiler_specific . h \" # include \" base / dcheck_is_on . h \" # include \" base / debug / crash_logging . h \" # include \" base / gtest_prod_util . h \" # include \" base / memory / memory_pressure_listener . h \" # include \" base / memory / raw_ptr . h \" # include \" base / synchronization / lock . h \" # include \" base / synchronization / waitable_event . h \" # include \" base / template_util . h \" # include \" base / thread_annotations . h \" # include \" base / threading / platform_thread . h \" # include \" base / threading / simple_thread . h \" # include \" base / threading / thread_checker . h \" # include \" base / threading / thread_local . h \" # include \" base / time / tick_clock . h \" # include \" base / time / time . h \" # include \" build / build_config . h \" namespace base { class WatchHangsInScope ; namespace internal { class HangWatchState ; } } namespace base { class BASE_EXPORT WatchHangsInScope { public : base::TimeDelta kDefaultHangWatchTime =)",
    "insertText": "Seconds(10)"
  },
  {
    "label": "WatchHangsInScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WatchHangsInScope(TimeDelta timeout = kDefaultHangWatchTime)"
  },
  {
    "label": "WatchHangsInScope()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "WatchHangsInScope()"
  },
  {
    "label": "WatchHangsInScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WatchHangsInScope(const WatchHangsInScope&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (WatchHangsInScope&)",
    "insertText": "operator(const WatchHangsInScope&)"
  },
  {
    "label": "THREAD_CHECKER()",
    "kind": "Method",
    "detail": "Function (private : bool took_effect_ = true ;)",
    "insertText": "THREAD_CHECKER(thread_checker_)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (TimeTicks previous_deadline_ ; bool set_hangs_ignored_on_exit_ = false ; # if)",
    "insertText": "DCHECK_IS_ON()"
  },
  {
    "label": "HangWatcher()",
    "kind": "Method",
    "detail": "Function (# endif } ; class BASE_EXPORT HangWatcher : public DelegateSimpleThread::Delegate { public : enum class ProcessType { kUnknownProcess = 0,kBrowserProcess = 1,kGPUProcess = 2,kRendererProcess = 3,kUtilityProcess = 4,kMax = kUtilityProcess } ; enum class ThreadType { kIOThread = 0,kMainThread = 1,kThreadPoolThread = 2,kMax = kThreadPoolThread } ;)",
    "insertText": "HangWatcher()"
  },
  {
    "label": "HangWatcher()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HangWatcher(const HangWatcher&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (HangWatcher&)",
    "insertText": "operator(const HangWatcher&)"
  },
  {
    "label": "CreateHangWatcherInstance()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateHangWatcherInstance()"
  },
  {
    "label": "GetInstance()",
    "kind": "Method",
    "detail": "Function (HangWatcher*)",
    "insertText": "GetInstance()"
  },
  {
    "label": "InitializeOnMainThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeOnMainThread(ProcessType process_type)"
  },
  {
    "label": "UnitializeOnMainThreadForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnitializeOnMainThreadForTesting()"
  },
  {
    "label": "IsEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEnabled()"
  },
  {
    "label": "IsThreadPoolHangWatchingEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsThreadPoolHangWatchingEnabled()"
  },
  {
    "label": "IsIOThreadHangWatchingEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsIOThreadHangWatchingEnabled()"
  },
  {
    "label": "IsCrashReportingEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsCrashReportingEnabled()"
  },
  {
    "label": "InvalidateActiveExpectations()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InvalidateActiveExpectations()"
  },
  {
    "label": "RegisterThread()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] ScopedClosureRunner)",
    "insertText": "RegisterThread(ThreadType thread_type)"
  },
  {
    "label": "SetAfterMonitorClosureForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAfterMonitorClosureForTesting(base::RepeatingClosure closure)"
  },
  {
    "label": "SetOnHangClosureForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOnHangClosureForTesting(base::RepeatingClosure closure)"
  },
  {
    "label": "SetMonitoringPeriodForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMonitoringPeriodForTesting(base::TimeDelta period)"
  },
  {
    "label": "SetAfterWaitCallbackForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAfterWaitCallbackForTesting(RepeatingCallback<void(TimeTicks)> callback)"
  },
  {
    "label": "SignalMonitorEventForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SignalMonitorEventForTesting()"
  },
  {
    "label": "StopMonitoringForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StopMonitoringForTesting()"
  },
  {
    "label": "SetTickClockForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTickClockForTesting(const base::TickClock* tick_clock)"
  },
  {
    "label": "BlockIfCaptureInProgress()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BlockIfCaptureInProgress()"
  },
  {
    "label": "Start()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Start()"
  },
  {
    "label": "GetTimeSinceLastSystemPowerResumeCrashKeyValue()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "GetTimeSinceLastSystemPowerResumeCrashKeyValue()"
  },
  {
    "label": "RegisterThreadInternal()",
    "kind": "Method",
    "detail": "Function (private : [ [ nodiscard ] ] ScopedClosureRunner)",
    "insertText": "RegisterThreadInternal(ThreadType thread_type) LOCKS_EXCLUDED(watch_state_lock_)"
  },
  {
    "label": "THREAD_CHECKER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "THREAD_CHECKER(hang_watcher_thread_checker_)"
  },
  {
    "label": "THREAD_CHECKER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "THREAD_CHECKER(constructing_thread_checker_)"
  },
  {
    "label": "OnMemoryPressure()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnMemoryPressure(base::MemoryPressureListener::MemoryPressureLevel memory_pressure_level)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "BUILDFLAG(IS_NACL) [[nodiscard]] debug::ScopedCrashKeyString GetTimeSinceLastCriticalMemoryPressureCrashKey()"
  },
  {
    "label": "RecordHang()",
    "kind": "Method",
    "detail": "Function (# endif NOINLINE void)",
    "insertText": "RecordHang()"
  },
  {
    "label": "WatchStateSnapShot()",
    "kind": "Method",
    "detail": "Function (using HangWatchStates = std::vector<std::unique_ptr<internal::HangWatchState>> ; class BASE_EXPORT WatchStateSnapShot { public : struct WatchStateCopy { base::TimeTicks deadline ; base::PlatformThreadId thread_id ; } ;)",
    "insertText": "WatchStateSnapShot()"
  },
  {
    "label": "WatchStateSnapShot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WatchStateSnapShot(const WatchStateSnapShot& other)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(const HangWatchStates& watch_states, base::TimeTicks deadline_ignore_threshold)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear()"
  },
  {
    "label": "PrepareHungThreadListCrashKey()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "PrepareHungThreadListCrashKey()"
  },
  {
    "label": "GetHighestDeadline()",
    "kind": "Method",
    "detail": "Function (base::TimeTicks)",
    "insertText": "GetHighestDeadline()"
  },
  {
    "label": "IsActionable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsActionable()"
  },
  {
    "label": "GrabWatchStateSnapshotForTesting()",
    "kind": "Method",
    "detail": "Function (private : bool initialized_ = false ; std::vector<WatchStateCopy> hung_watch_state_copies_ ; } ; WatchStateSnapShot)",
    "insertText": "GrabWatchStateSnapshotForTesting()"
  },
  {
    "label": "Monitor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Monitor() LOCKS_EXCLUDED(watch_state_lock_)"
  },
  {
    "label": "DoDumpWithoutCrashing()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DoDumpWithoutCrashing(const WatchStateSnapShot& watch_state_snapshot) EXCLUSIVE_LOCKS_REQUIRED(watch_state_lock_) LOCKS_EXCLUDED(capture_lock_)"
  },
  {
    "label": "Stop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Stop()"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Wait()"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Run()"
  },
  {
    "label": "IsWatchListEmpty()",
    "kind": "Method",
    "detail": "Function (base::TimeDelta monitor_period_ ; WaitableEvent should_monitor_ ; bool)",
    "insertText": "IsWatchListEmpty() LOCKS_EXCLUDED(watch_state_lock_)"
  },
  {
    "label": "UnregisterThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterThread() LOCKS_EXCLUDED(watch_state_lock_)"
  },
  {
    "label": "GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (Lock watch_state_lock_ ; std::vector<std::unique_ptr<internal::HangWatchState>> watch_states_)",
    "insertText": "GUARDED_BY(watch_state_lock_)"
  },
  {
    "label": "GUARDED_BY_CONTEXT()",
    "kind": "Method",
    "detail": "Function (WatchStateSnapShot watch_state_snapshot_)",
    "insertText": "GUARDED_BY_CONTEXT(hang_watcher_thread_checker_)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (base::DelegateSimpleThread thread_ ; RepeatingClosure after_monitor_closure_for_testing_ ; RepeatingClosure on_hang_closure_for_testing_ ; RepeatingCallback<)",
    "insertText": "void(TimeTicks)"
  },
  {
    "label": "ACQUIRED_AFTER()",
    "kind": "Method",
    "detail": "Function (base::Lock capture_lock_)",
    "insertText": "ACQUIRED_AFTER(watch_state_lock_)"
  },
  {
    "label": "TimeTicks()",
    "kind": "Method",
    "detail": "Function (std::atomic<bool> capture_in_progress_ { false } ; raw_ptr<const base::TickClock> tick_clock_ ; base::MemoryPressureListener memory_pressure_listener_ ; std::atomic<base::TimeTicks> last_critical_memory_pressure_ {)",
    "insertText": "TimeTicks()"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (base::TimeTicks deadline_ignore_threshold_ ;)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(HangWatcherTest, NestedScopes)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(HangWatcherSnapshotTest, HungThreadIDs)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(HangWatcherSnapshotTest, NonActionableReport)"
  },
  {
    "label": "uint64_t()",
    "kind": "Method",
    "detail": "Function (} ; namespace internal { class BASE_EXPORT HangWatchDeadline { public : enum class Flag : uint64_t { kMinValue = bits::LeftmostBit<)",
    "insertText": "uint64_t() >> 7, kIgnoreCurrentWatchHangsInScope = bits::LeftmostBit<uint64_t>() >> 1, kShouldBlockOnHang = bits::LeftmostBit<uint64_t>()"
  },
  {
    "label": "HangWatchDeadline()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HangWatchDeadline()"
  },
  {
    "label": "HangWatchDeadline()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HangWatchDeadline(const HangWatchDeadline&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (HangWatchDeadline&)",
    "insertText": "operator(const HangWatchDeadline&)"
  },
  {
    "label": "GetDeadline()",
    "kind": "Method",
    "detail": "Function (TimeTicks)",
    "insertText": "GetDeadline()"
  },
  {
    "label": "GetFlagsAndDeadline()",
    "kind": "Method",
    "detail": "Function (std::pair<uint64_t,TimeTicks>)",
    "insertText": "GetFlagsAndDeadline()"
  },
  {
    "label": "IsFlagSet()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFlagSet(Flag flag)"
  },
  {
    "label": "IsFlagSet()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFlagSet(Flag flag, uint64_t flags)"
  },
  {
    "label": "SetDeadline()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDeadline(TimeTicks new_value)"
  },
  {
    "label": "SetShouldBlockOnHang()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SetShouldBlockOnHang(uint64_t old_flags, TimeTicks old_deadline)"
  },
  {
    "label": "SetIgnoreCurrentWatchHangsInScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetIgnoreCurrentWatchHangsInScope()"
  },
  {
    "label": "UnsetIgnoreCurrentWatchHangsInScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnsetIgnoreCurrentWatchHangsInScope()"
  },
  {
    "label": "SetSwitchBitsClosureForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSwitchBitsClosureForTesting(RepeatingCallback<uint64_t(void)> closure)"
  },
  {
    "label": "ResetSwitchBitsClosureForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetSwitchBitsClosureForTesting()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (private : using TimeTicksInternalRepresentation = std::invoke_result<)",
    "insertText": "decltype(&TimeTicks::ToInternalValue)"
  },
  {
    "label": "SwitchBitsForTesting()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "SwitchBitsForTesting()"
  },
  {
    "label": "SetPersistentFlag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPersistentFlag(Flag flag)"
  },
  {
    "label": "ClearPersistentFlag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearPersistentFlag(Flag flag)"
  },
  {
    "label": "DeadlineFromBits()",
    "kind": "Method",
    "detail": "Function (TimeTicks)",
    "insertText": "DeadlineFromBits(uint64_t bits)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (TimeTicks)",
    "insertText": "Max()"
  },
  {
    "label": "ExtractFlags()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "ExtractFlags(uint64_t bits)"
  },
  {
    "label": "ExtractDeadline()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "ExtractDeadline(uint64_t bits)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using BitsType = uint64_t ;)",
    "insertText": "static_assert(std::is_same<std::underlying_type<Flag>::type, BitsType>::value, \"Flag should have the same underlying type as bits_ to \" \"simplify thinking about bit operations\")"
  },
  {
    "label": "uint64_t()",
    "kind": "Method",
    "detail": "Function (std::atomic<BitsType> bits_ { static_cast<)",
    "insertText": "uint64_t(Max().ToInternalValue())"
  },
  {
    "label": "uint64_t()",
    "kind": "Method",
    "detail": "Function (RepeatingCallback<)",
    "insertText": "uint64_t(void)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(HangWatchDeadlineTest, BitsPreservedThroughExtract)"
  },
  {
    "label": "HangWatchState()",
    "kind": "Method",
    "detail": "Function (} ; class BASE_EXPORT HangWatchState { public :)",
    "insertText": "HangWatchState(HangWatcher::ThreadType thread_type)"
  },
  {
    "label": "HangWatchState()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "HangWatchState()"
  },
  {
    "label": "HangWatchState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HangWatchState(const HangWatchState&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (HangWatchState&)",
    "insertText": "operator(const HangWatchState&)"
  },
  {
    "label": "CreateHangWatchStateForCurrentThread()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<HangWatchState>)",
    "insertText": "CreateHangWatchStateForCurrentThread(HangWatcher::ThreadType thread_type)"
  },
  {
    "label": "GetHangWatchStateForCurrentThread()",
    "kind": "Method",
    "detail": "Function (ThreadLocalPointer<HangWatchState>*)",
    "insertText": "GetHangWatchStateForCurrentThread()"
  },
  {
    "label": "SetDeadline()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDeadline(TimeTicks deadline)"
  },
  {
    "label": "IsFlagSet()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFlagSet(HangWatchDeadline::Flag flag)"
  },
  {
    "label": "IsOverDeadline()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsOverDeadline()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() void SetCurrentWatchHangsInScope(WatchHangsInScope* scope)"
  },
  {
    "label": "GetCurrentWatchHangsInScope()",
    "kind": "Method",
    "detail": "Function (WatchHangsInScope*)",
    "insertText": "GetCurrentWatchHangsInScope()"
  },
  {
    "label": "GetThreadID()",
    "kind": "Method",
    "detail": "Function (# endif PlatformThreadId)",
    "insertText": "GetThreadID()"
  },
  {
    "label": "GetHangWatchDeadlineForTesting()",
    "kind": "Method",
    "detail": "Function (HangWatchDeadline*)",
    "insertText": "GetHangWatchDeadlineForTesting()"
  },
  {
    "label": "nesting_level()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "nesting_level()"
  },
  {
    "label": "DecrementNestingLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecrementNestingLevel()"
  },
  {
    "label": "thread_type()",
    "kind": "Method",
    "detail": "Function (HangWatcher::ThreadType)",
    "insertText": "thread_type()"
  }
]