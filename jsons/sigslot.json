[
  {
    "label": "single_threaded",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "single_threaded"
  },
  {
    "label": "multi_threaded_global",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "multi_threaded_global"
  },
  {
    "label": "multi_threaded_local",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "multi_threaded_local"
  },
  {
    "label": "mt_policy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "mt_policy"
  },
  {
    "label": "lock_block",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "lock_block"
  },
  {
    "label": "_signal_base_interface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_signal_base_interface"
  },
  {
    "label": "has_slots_interface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "has_slots_interface"
  },
  {
    "label": "_opaque_connection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_opaque_connection"
  },
  {
    "label": "_signal_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_signal_base"
  },
  {
    "label": "has_slots",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "has_slots"
  },
  {
    "label": "signal_with_thread_policy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "signal_with_thread_policy"
  },
  {
    "label": "desttype",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "desttype"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef RTC_BASE_THIRD_PARTY_SIGSLOT_SIGSLOT_H_ # define RTC_BASE_THIRD_PARTY_SIGSLOT_SIGSLOT_H_ # include<cstring> # include<list> # include<set> # define SIGSLOT_DEFAULT_MT_POLICY single_threaded # if)",
    "insertText": "defined(SIGSLOT_PURE_ISO) || \\ (!defined(WEBRTC_WIN) && !defined(__GNUG__) && \\ !defined(SIGSLOT_USE_POSIX_THREADS)) #define _SIGSLOT_SINGLE_THREADED #elif defined(WEBRTC_WIN) #define _SIGSLOT_HAS_WIN32_THREADS #include \"windows.h\" #elif defined(__GNUG__) || defined(SIGSLOT_USE_POSIX_THREADS)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (class single_threaded { public : void)",
    "insertText": "lock()"
  },
  {
    "label": "unlock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "unlock()"
  },
  {
    "label": "multi_threaded_global()",
    "kind": "Method",
    "detail": "Function (} } ; # ifdef _SIGSLOT_HAS_WIN32_THREADS class multi_threaded_global { public :)",
    "insertText": "multi_threaded_global()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool isinitialised = false ;)",
    "insertText": "if(!isinitialised)"
  },
  {
    "label": "InitializeCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeCriticalSection(get_critsec())"
  },
  {
    "label": "EnterCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnterCriticalSection(get_critsec())"
  },
  {
    "label": "LeaveCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeaveCriticalSection(get_critsec())"
  },
  {
    "label": "get_critsec()",
    "kind": "Method",
    "detail": "Function (} private : CRITICAL_SECTION*)",
    "insertText": "get_critsec()"
  },
  {
    "label": "multi_threaded_local()",
    "kind": "Method",
    "detail": "Function (CRITICAL_SECTION g_critsec ; return& g_critsec ; } } ; class multi_threaded_local { public :)",
    "insertText": "multi_threaded_local()"
  },
  {
    "label": "InitializeCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeCriticalSection(&m_critsec)"
  },
  {
    "label": "multi_threaded_local()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "multi_threaded_local(const multi_threaded_local&)"
  },
  {
    "label": "DeleteCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeleteCriticalSection(&m_critsec)"
  },
  {
    "label": "EnterCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnterCriticalSection(&m_critsec)"
  },
  {
    "label": "LeaveCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeaveCriticalSection(&m_critsec)"
  },
  {
    "label": "pthread_mutex_lock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_lock(get_mutex())"
  },
  {
    "label": "pthread_mutex_unlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_unlock(get_mutex())"
  },
  {
    "label": "get_mutex()",
    "kind": "Method",
    "detail": "Function (} private : pthread_mutex_t*)",
    "insertText": "get_mutex()"
  },
  {
    "label": "pthread_mutex_init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_init(&m_mutex, nullptr)"
  },
  {
    "label": "pthread_mutex_destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_destroy(&m_mutex)"
  },
  {
    "label": "pthread_mutex_lock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_lock(&m_mutex)"
  },
  {
    "label": "pthread_mutex_unlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_unlock(&m_mutex)"
  },
  {
    "label": "lock_block()",
    "kind": "Method",
    "detail": "Function (} private : pthread_mutex_t m_mutex ; } ; # endif template<class mt_policy> class lock_block { public : mt_policy* m_mutex ;)",
    "insertText": "lock_block(mt_policy* mtx) : m_mutex(mtx)"
  },
  {
    "label": "lock_block()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "lock_block()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} } ; class _signal_base_interface ; class has_slots_interface { private : typedef)",
    "insertText": "void(*signal_connect_t)(has_slots_interface* self, _signal_base_interface* sender)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(*signal_disconnect_t)(has_slots_interface* self, _signal_base_interface* sender)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(*disconnect_all_t)(has_slots_interface* self)"
  },
  {
    "label": "has_slots_interface()",
    "kind": "Method",
    "detail": "Function (const signal_connect_t m_signal_connect ; const signal_disconnect_t m_signal_disconnect ; const disconnect_all_t m_disconnect_all ; protected :)",
    "insertText": "has_slots_interface(signal_connect_t conn, signal_disconnect_t disc, disconnect_all_t disc_all) : m_signal_connect(conn), m_signal_disconnect(disc), m_disconnect_all(disc_all)"
  },
  {
    "label": "has_slots_interface()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "has_slots_interface()"
  },
  {
    "label": "signal_connect()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "signal_connect(_signal_base_interface* sender)"
  },
  {
    "label": "m_signal_connect()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_signal_connect(this, sender)"
  },
  {
    "label": "signal_disconnect()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "signal_disconnect(_signal_base_interface* sender)"
  },
  {
    "label": "m_signal_disconnect()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_signal_disconnect(this, sender)"
  },
  {
    "label": "disconnect_all()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "disconnect_all()"
  },
  {
    "label": "m_disconnect_all()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_disconnect_all(this)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} } ; class _signal_base_interface { private : typedef)",
    "insertText": "void(*slot_disconnect_t)(_signal_base_interface* self, has_slots_interface* pslot)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(*slot_duplicate_t)(_signal_base_interface* self, const has_slots_interface* poldslot, has_slots_interface* pnewslot)"
  },
  {
    "label": "_signal_base_interface()",
    "kind": "Method",
    "detail": "Function (const slot_disconnect_t m_slot_disconnect ; const slot_duplicate_t m_slot_duplicate ; protected :)",
    "insertText": "_signal_base_interface(slot_disconnect_t disc, slot_duplicate_t dupl) : m_slot_disconnect(disc), m_slot_duplicate(dupl)"
  },
  {
    "label": "_signal_base_interface()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "_signal_base_interface()"
  },
  {
    "label": "slot_disconnect()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "slot_disconnect(has_slots_interface* pslot)"
  },
  {
    "label": "m_slot_disconnect()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_slot_disconnect(this, pslot)"
  },
  {
    "label": "slot_duplicate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "slot_duplicate(const has_slots_interface* poldslot, has_slots_interface* pnewslot)"
  },
  {
    "label": "m_slot_duplicate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_slot_duplicate(this, poldslot, pnewslot)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} } ; class _opaque_connection { private : typedef)",
    "insertText": "void(*emit_t)(const _opaque_connection*)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (template<FromT,ToT> union union_caster { FromT from ; ToT to ; } ; emit_t pemit ; has_slots_interface* pdest ; # if)",
    "insertText": "defined(_MSC_VER) && !defined(__clang__)"
  },
  {
    "label": "_opaque_connection()",
    "kind": "Method",
    "detail": "Function (# else unsigned char pmethod [ 1 6 ] ; # endif public : template<DestT,. . . Args>)",
    "insertText": "_opaque_connection(DestT* pd, void (DestT::*pm)(Args...)) : pdest(pd)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(DestT::*pm_t)(Args...)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(pmethod, &pm, sizeof(pm_t))"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(*em_t)(const _opaque_connection* self, Args...)"
  },
  {
    "label": "getdest()",
    "kind": "Method",
    "detail": "Function (union_caster<em_t,emit_t> caster2 ; caster2 . from =& _opaque_connection::emitter<DestT,Args . . .> ; pemit = caster2 . to ; } has_slots_interface*)",
    "insertText": "getdest()"
  },
  {
    "label": "emit()",
    "kind": "Method",
    "detail": "Function (_opaque_connection res =* this ; res . pdest = newtarget ; return res ; } template<. . . Args> void)",
    "insertText": "emit(Args... args)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(*em_t)(const _opaque_connection*, Args...)"
  },
  {
    "label": "pemit()",
    "kind": "Method",
    "detail": "Function (union_caster<emit_t,em_t> caster ; caster . from =)",
    "insertText": "pemit(caster.to)(this, args...)"
  },
  {
    "label": "emitter()",
    "kind": "Method",
    "detail": "Function (} private : template<DestT,. . . Args> void)",
    "insertText": "emitter(const _opaque_connection* self, Args... args)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (pm_t pm ;)",
    "insertText": "static_assert(sizeof(pm_t) <= sizeof(pmethod), \"Size of slot function pointer too large.\")"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&pm, self->pmethod, sizeof(pm_t))"
  },
  {
    "label": "_signal_base()",
    "kind": "Method",
    "detail": "Function (} } ; template<class mt_policy> class _signal_base : public _signal_base_interface,public mt_policy { protected : typedef std::list<_opaque_connection> connections_list ;)",
    "insertText": "_signal_base() : _signal_base_interface(&_signal_base::do_slot_disconnect, &_signal_base::do_slot_duplicate), m_current_iterator(m_connected_slots.end())"
  },
  {
    "label": "_signal_base()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "_signal_base()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : _signal_base&)",
    "insertText": "operator(_signal_base const& that)"
  },
  {
    "label": "_signal_base()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "_signal_base(const _signal_base& o) : _signal_base_interface(&_signal_base::do_slot_disconnect, &_signal_base::do_slot_duplicate), m_current_iterator(m_connected_slots.end())"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (lock_block<mt_policy>)",
    "insertText": "lock(this)"
  },
  {
    "label": "getdest()",
    "kind": "Method",
    "detail": "Function (connection .)",
    "insertText": "getdest()->signal_connect(this)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (m_connected_slots .)",
    "insertText": "push_back(connection)"
  },
  {
    "label": "is_empty()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "is_empty()"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (has_slots_interface* pdest = m_connected_slots .)",
    "insertText": "front().getdest()"
  },
  {
    "label": "pop_front()",
    "kind": "Method",
    "detail": "Function (m_connected_slots .)",
    "insertText": "pop_front()"
  },
  {
    "label": "signal_disconnect()",
    "kind": "Method",
    "detail": "Function (pdest ->)",
    "insertText": "signal_disconnect(static_cast<_signal_base_interface*>(this))"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} m_current_iterator = m_connected_slots .)",
    "insertText": "end()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if !)",
    "insertText": "defined(NDEBUG) bool connected(has_slots_interface* pclass)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (connections_list::const_iterator it = m_connected_slots .)",
    "insertText": "begin()"
  },
  {
    "label": "disconnect()",
    "kind": "Method",
    "detail": "Function (+ + it ; } return false ; } # endif void)",
    "insertText": "disconnect(has_slots_interface* pclass)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (m_current_iterator = m_connected_slots .)",
    "insertText": "erase(it)"
  },
  {
    "label": "_signal_base()",
    "kind": "Method",
    "detail": "Function (_signal_base* const self = static_cast<)",
    "insertText": "_signal_base(p)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (lock_block<mt_policy>)",
    "insertText": "lock(self)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (connections_list::iterator itNext = it ; + + itNext ;)",
    "insertText": "if(it->getdest() == pslot)"
  },
  {
    "label": "do_slot_duplicate()",
    "kind": "Method",
    "detail": "Function (} } it = itNext ; } } void)",
    "insertText": "do_slot_duplicate(_signal_base_interface* p, const has_slots_interface* oldtarget, has_slots_interface* newtarget)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (self -> m_connected_slots .)",
    "insertText": "push_back(it->duplicate(newtarget))"
  },
  {
    "label": "has_slots()",
    "kind": "Method",
    "detail": "Function (} + + it ; } } protected : connections_list m_connected_slots ; connections_list::iterator m_current_iterator ; bool m_erase_current_iterator = false ; } ; template<class mt_policy = SIGSLOT_DEFAULT_MT_POLICY> class has_slots : public has_slots_interface,public mt_policy { private : typedef std::set<_signal_base_interface*> sender_set ; typedef sender_set::const_iterator const_iterator ; public :)",
    "insertText": "has_slots() : has_slots_interface(&has_slots::do_signal_connect, &has_slots::do_signal_disconnect, &has_slots::do_disconnect_all)"
  },
  {
    "label": "has_slots()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "has_slots(has_slots const& o) : has_slots_interface(&has_slots::do_signal_connect, &has_slots::do_signal_disconnect, &has_slots::do_disconnect_all)"
  },
  {
    "label": "slot_duplicate()",
    "kind": "Method",
    "detail": "Function (sender ->)",
    "insertText": "slot_duplicate(&o, this)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (m_senders .)",
    "insertText": "insert(sender)"
  },
  {
    "label": "has_slots()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "has_slots()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : has_slots&)",
    "insertText": "operator(has_slots const&)"
  },
  {
    "label": "do_signal_connect()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "do_signal_connect(has_slots_interface* p, _signal_base_interface* sender)"
  },
  {
    "label": "has_slots()",
    "kind": "Method",
    "detail": "Function (has_slots* const self = static_cast<)",
    "insertText": "has_slots(p)"
  },
  {
    "label": "do_signal_disconnect()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "do_signal_disconnect(has_slots_interface* p, _signal_base_interface* sender)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (self -> m_senders .)",
    "insertText": "erase(sender)"
  },
  {
    "label": "do_disconnect_all()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "do_disconnect_all(has_slots_interface* p)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (std::set<_signal_base_interface*> senders ; senders .)",
    "insertText": "swap(self->m_senders)"
  },
  {
    "label": "slot_disconnect()",
    "kind": "Method",
    "detail": "Function (_signal_base_interface* s =* it ; + + it ; s ->)",
    "insertText": "slot_disconnect(p)"
  },
  {
    "label": "signal_with_thread_policy()",
    "kind": "Method",
    "detail": "Function (} } } private : sender_set m_senders ; } ; template<class mt_policy,. . . Args> class signal_with_thread_policy : public _signal_base<mt_policy> { private : typedef _signal_base<mt_policy> base ; protected : typedef base::connections_list connections_list ; public :)",
    "insertText": "signal_with_thread_policy()"
  },
  {
    "label": "connect()",
    "kind": "Method",
    "detail": "Function (} template<class desttype> void)",
    "insertText": "connect(desttype* pclass, void (desttype::*pmemfun)(Args...))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (this -> m_connected_slots .)",
    "insertText": "push_back(_opaque_connection(pclass, pmemfun))"
  },
  {
    "label": "signal_connect()",
    "kind": "Method",
    "detail": "Function (pclass ->)",
    "insertText": "signal_connect(static_cast<_signal_base_interface*>(this))"
  },
  {
    "label": "m_current_iterator()",
    "kind": "Method",
    "detail": "Function (_opaque_connection const& conn =* this ->)",
    "insertText": "m_current_iterator(this->m_current_iterator)"
  },
  {
    "label": "Args()",
    "kind": "Method",
    "detail": "Function (conn . emit<)",
    "insertText": "Args(args...)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "operator()(Args... args)"
  },
  {
    "label": "emit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "emit(args...)"
  }
]