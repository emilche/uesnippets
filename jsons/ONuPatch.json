[
  {
    "label": "ALEMBIC_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ALEMBIC_EXPORT"
  },
  {
    "label": "Sample",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Sample"
  },
  {
    "label": "ABC_GEOM_NUPATCH_NULL_INT_VALUE()",
    "kind": "Method",
    "detail": "Function (# ifndef Alembic_AbcGeom_ONuPatch_h # define Alembic_AbcGeom_ONuPatch_h # include<Alembic / Util / Export . h> # include<Alembic / AbcGeom / Foundation . h> # include<Alembic / AbcGeom / Basis . h> # include<Alembic / AbcGeom / SchemaInfoDeclarations . h> # include<Alembic / AbcGeom / OGeomParam . h> # include<Alembic / AbcGeom / OGeomBase . h> namespace Alembic { namespace AbcGeom { namespace ALEMBIC_VERSION_NS { const int32_t)",
    "insertText": "ABC_GEOM_NUPATCH_NULL_INT_VALUE(-536870912)"
  },
  {
    "label": "Sample()",
    "kind": "Method",
    "detail": "Function (class ALEMBIC_EXPORT ONuPatchSchema : public OGeomBaseSchema<NuPatchSchemaInfo> { public : class Sample { public :)",
    "insertText": "Sample()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset()"
  },
  {
    "label": "Sample()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Sample(const Abc::P3fArraySample &iPos, const int32_t &iNumU, const int32_t &iNumV, const int32_t &iUOrder, const int32_t &iVOrder, const Abc::FloatArraySample &iUKnot, const Abc::FloatArraySample &iVKnot, const ON3fGeomParam::Sample &iNormals = ON3fGeomParam::Sample(), const OV2fGeomParam::Sample &iUVs = OV2fGeomParam::Sample(), const Abc::FloatArraySample & iPosWeight = Abc::FloatArraySample() ): m_positions( iPos ) , m_numU( iNumU ) , m_numV( iNumV ) , m_uOrder( iUOrder ) , m_vOrder( iVOrder ) , m_uKnot( iUKnot ) , m_vKnot( iVKnot ) , m_positionWeights( iPosWeight ) , m_normals( iNormals ) , m_uvs( iUVs ) , m_trimNumLoops( ABC_GEOM_NUPATCH_NULL_INT_VALUE ) , m_trimNumVertices( Abc::Int32ArraySample() ) , m_trimOrder( Abc::Int32ArraySample() ) , m_trimKnot( Abc::FloatArraySample() ) , m_trimMin( Abc::FloatArraySample() ) , m_trimMax( Abc::FloatArraySample() ) , m_trimU( Abc::FloatArraySample() ) , m_trimV( Abc::FloatArraySample() ) , m_trimW( Abc::FloatArraySample() ) , m_hasTrimCurve( false)"
  },
  {
    "label": "getPositions()",
    "kind": "Method",
    "detail": "Function (} const Abc::P3fArraySample&)",
    "insertText": "getPositions()"
  },
  {
    "label": "getPositionWeights()",
    "kind": "Method",
    "detail": "Function (m_positions = iSmp ; } const Abc::FloatArraySample&)",
    "insertText": "getPositionWeights()"
  },
  {
    "label": "getNu()",
    "kind": "Method",
    "detail": "Function (m_positionWeights = iSmp ; } int32_t)",
    "insertText": "getNu()"
  },
  {
    "label": "getNv()",
    "kind": "Method",
    "detail": "Function (m_numU = iNu ; } int32_t)",
    "insertText": "getNv()"
  },
  {
    "label": "getUOrder()",
    "kind": "Method",
    "detail": "Function (m_numV = iNv ; } int32_t)",
    "insertText": "getUOrder()"
  },
  {
    "label": "getVOrder()",
    "kind": "Method",
    "detail": "Function (m_uOrder = iUOrder ; } int32_t)",
    "insertText": "getVOrder()"
  },
  {
    "label": "getUKnot()",
    "kind": "Method",
    "detail": "Function (m_vOrder = iVOrder ; } const Abc::FloatArraySample&)",
    "insertText": "getUKnot()"
  },
  {
    "label": "getVKnot()",
    "kind": "Method",
    "detail": "Function (m_uKnot = iUKnot ; } const Abc::FloatArraySample&)",
    "insertText": "getVKnot()"
  },
  {
    "label": "getUVs()",
    "kind": "Method",
    "detail": "Function (m_vKnot = iVKnot ; } const OV2fGeomParam::Sample&)",
    "insertText": "getUVs()"
  },
  {
    "label": "getNormals()",
    "kind": "Method",
    "detail": "Function (m_uvs = iUVs ; } const ON3fGeomParam::Sample&)",
    "insertText": "getNormals()"
  },
  {
    "label": "getSelfBounds()",
    "kind": "Method",
    "detail": "Function (m_normals = iNormals ; } const Abc::Box3d&)",
    "insertText": "getSelfBounds()"
  },
  {
    "label": "getVelocities()",
    "kind": "Method",
    "detail": "Function (m_selfBounds = iBnds ; } const Abc::V3fArraySample&)",
    "insertText": "getVelocities()"
  },
  {
    "label": "setTrimCurve()",
    "kind": "Method",
    "detail": "Function (m_velocities = iVelocities ; } void)",
    "insertText": "setTrimCurve(const int32_t i_trim_nLoops, const Abc::Int32ArraySample &i_trim_nCurves, const Abc::Int32ArraySample &i_trim_n, const Abc::Int32ArraySample &i_trim_order, const Abc::FloatArraySample &i_trim_knot, const Abc::FloatArraySample &i_trim_min, const Abc::FloatArraySample &i_trim_max, const Abc::FloatArraySample &i_trim_u, const Abc::FloatArraySample &i_trim_v, const Abc::FloatArraySample &i_trim_w)"
  },
  {
    "label": "getTrimNumLoops()",
    "kind": "Method",
    "detail": "Function (m_trimNumLoops = i_trim_nLoops ; m_trimNumCurves = i_trim_nCurves ; m_trimNumVertices = i_trim_n ; m_trimOrder = i_trim_order ; m_trimKnot = i_trim_knot ; m_trimMin = i_trim_min ; m_trimMax = i_trim_max ; m_trimU = i_trim_u ; m_trimV = i_trim_v ; m_trimW = i_trim_w ; m_hasTrimCurve = true ; } int32_t)",
    "insertText": "getTrimNumLoops()"
  },
  {
    "label": "makeEmpty()",
    "kind": "Method",
    "detail": "Function (m_selfBounds .)",
    "insertText": "makeEmpty()"
  },
  {
    "label": "isPartialSample()",
    "kind": "Method",
    "detail": "Function (m_hasTrimCurve = false ; } bool)",
    "insertText": "isPartialSample()"
  },
  {
    "label": "ONuPatchSchema()",
    "kind": "Method",
    "detail": "Function (m_selectiveExport = false ; m_numSamples = 0 ; m_timeSamplingIndex = 0 ; })",
    "insertText": "ONuPatchSchema(AbcA::CompoundPropertyWriterPtr iParent, const std::string &iName, const Abc::Argument &iArg0 = Abc::Argument(), const Abc::Argument &iArg1 = Abc::Argument(), const Abc::Argument &iArg2 = Abc::Argument(), const Abc::Argument &iArg3 = Abc::Argument())"
  },
  {
    "label": "ONuPatchSchema()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ONuPatchSchema(Abc::OCompoundProperty iParent, const std::string &iName, const Abc::Argument &iArg0 = Abc::Argument(), const Abc::Argument &iArg1 = Abc::Argument(), const Abc::Argument &iArg2 = Abc::Argument())"
  },
  {
    "label": "getTimeSampling()",
    "kind": "Method",
    "detail": "Function (AbcA::TimeSamplingPtr)",
    "insertText": "getTimeSampling()"
  },
  {
    "label": "getObject()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "getObject().getArchive().getTimeSampling( 0)"
  },
  {
    "label": "setTimeSampling()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "setTimeSampling(uint32_t iIndex)"
  },
  {
    "label": "setTimeSampling()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setTimeSampling(AbcA::TimeSamplingPtr iTime)"
  },
  {
    "label": "getNumSamples()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "getNumSamples()"
  },
  {
    "label": "setFromPrevious()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setFromPrevious()"
  },
  {
    "label": "valid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "valid()"
  },
  {
    "label": "ALEMBIC_OVERRIDE_OPERATOR_BOOL()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ALEMBIC_OVERRIDE_OPERATOR_BOOL(ONuPatchSchema::valid())"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "init(const AbcA::index_t iTsIdx, bool isSparse)"
  },
  {
    "label": "selectiveSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "selectiveSet(const Sample &iSamp)"
  },
  {
    "label": "createPositionProperties()",
    "kind": "Method",
    "detail": "Function (bool m_selectiveExport ; size_t m_numSamples ; AbcA::index_t m_timeSamplingIndex ; void)",
    "insertText": "createPositionProperties()"
  },
  {
    "label": "createKnotProperties()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "createKnotProperties()"
  },
  {
    "label": "createVelocityProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "createVelocityProperty()"
  },
  {
    "label": "createUVsProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "createUVsProperty(const Sample &iSamp)"
  },
  {
    "label": "createNormalsProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "createNormalsProperty(const Sample &iSamp)"
  },
  {
    "label": "createPositionWeightsProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "createPositionWeightsProperty()"
  },
  {
    "label": "createTrimPropreties()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "createTrimPropreties()"
  }
]