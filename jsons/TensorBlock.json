[
  {
    "label": "TensorBlockIO",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorBlockIO"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "TensorBlockResourceRequirements",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TensorBlockResourceRequirements"
  },
  {
    "label": "TensorBlockDescriptor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorBlockDescriptor"
  },
  {
    "label": "DestinationBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DestinationBuffer"
  },
  {
    "label": "DestinationBufferKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "DestinationBufferKind"
  },
  {
    "label": "TensorBlockMapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorBlockMapper"
  },
  {
    "label": "TensorBlockScratchAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorBlockScratchAllocator"
  },
  {
    "label": "Allocation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Allocation"
  },
  {
    "label": "TensorBlockKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "TensorBlockKind"
  },
  {
    "label": "TensorBlockNotImplemented",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorBlockNotImplemented"
  },
  {
    "label": "XprScalar",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "XprScalar"
  },
  {
    "label": "TensorMaterializedBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorMaterializedBlock"
  },
  {
    "label": "Storage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Storage"
  },
  {
    "label": "TensorCwiseUnaryBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorCwiseUnaryBlock"
  },
  {
    "label": "TensorCwiseBinaryBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorCwiseBinaryBlock"
  },
  {
    "label": "TensorUnaryExprBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorUnaryExprBlock"
  },
  {
    "label": "TensorTernaryExprBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorTernaryExprBlock"
  },
  {
    "label": "StridedLinearBufferCopy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StridedLinearBufferCopy"
  },
  {
    "label": "Dst",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Dst"
  },
  {
    "label": "Src",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Src"
  },
  {
    "label": "BlockIteratorState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BlockIteratorState"
  },
  {
    "label": "TensorBlockAssignment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorBlockAssignment"
  },
  {
    "label": "InnerDimAssign",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InnerDimAssign"
  },
  {
    "label": "Target",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Target"
  },
  {
    "label": "strides()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_CXX11_TENSOR_TENSOR_BLOCK_H # define EIGEN_CXX11_TENSOR_TENSOR_BLOCK_H namespace Eigen { namespace internal { template<Scalar,IndexType,int NumDims,int Layout> class TensorBlockIO ; template<int Layout,IndexType,int NumDims> EIGEN_ALWAYS_INLINE DSizes<IndexType,NumDims>)",
    "insertText": "strides(const DSizes<IndexType, NumDims>& dimensions)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (DSizes<IndexType,NumDims> strides ;)",
    "insertText": "if(NumDims == 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (strides [ 0 ] = 1 ;)",
    "insertText": "for(int i = 1; i < NumDims; ++i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (strides [ i ] = strides [ i - 1 ]* dimensions [ i - 1 ] ; } } else { strides [ NumDims - 1 ] = 1 ;)",
    "insertText": "for(int i = NumDims - 2; i >= 0; --i)"
  },
  {
    "label": "strides()",
    "kind": "Method",
    "detail": "Function (strides [ i ] = strides [ i + 1 ]* dimensions [ i + 1 ] ; } } return strides ; } template<int Layout,IndexType,size_t NumDims> EIGEN_ALWAYS_INLINE DSizes<IndexType,NumDims>)",
    "insertText": "strides(const Eigen::array<IndexType, NumDims>& dimensions)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} template<int Layout,std::ptrdiff_t . . . Indices> EIGEN_STRONG_INLINE DSizes<std::ptrdiff_t,)",
    "insertText": "sizeof(Indices)> strides( const Sizes<Indices...>& sizes)"
  },
  {
    "label": "TensorBlockResourceRequirements()",
    "kind": "Method",
    "detail": "Function (} enum class TensorBlockShapeType { kUniformAllDims,kSkewedInnerDims } ; struct TensorBlockResourceRequirements { TensorBlockShapeType shape_type ; size_t size ; TensorOpCost cost_per_coeff ; # ifdef EIGEN_HIPCC EIGEN_DEVICE_FUNC)",
    "insertText": "TensorBlockResourceRequirements(TensorBlockShapeType shape_type_, size_t size_, TensorOpCost cost_) : shape_type(shape_type_), size(size_), cost_per_coeff(cost_)"
  },
  {
    "label": "withShapeAndSize()",
    "kind": "Method",
    "detail": "Function (} # endif template<Scalar> EIGEN_DEVICE_FUNC TensorBlockResourceRequirements)",
    "insertText": "withShapeAndSize(TensorBlockShapeType shape_type, size_t size_in_bytes, TensorOpCost cost)"
  },
  {
    "label": "maxi()",
    "kind": "Method",
    "detail": "Function (const size_t size =)",
    "insertText": "maxi(size_t(1), size_in_bytes / sizeof(Scalar))"
  },
  {
    "label": "skewed()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC TensorBlockResourceRequirements)",
    "insertText": "skewed(size_t size_in_bytes)"
  },
  {
    "label": "uniform()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC TensorBlockResourceRequirements)",
    "insertText": "uniform(size_t size_in_bytes)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorBlockResourceRequirements)",
    "insertText": "merge(const TensorBlockResourceRequirements& lhs, const TensorBlockResourceRequirements& rhs)"
  },
  {
    "label": "addCostPerCoeff()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC TensorBlockResourceRequirements&)",
    "insertText": "addCostPerCoeff(TensorOpCost cost)"
  },
  {
    "label": "any()",
    "kind": "Method",
    "detail": "Function (cost_per_coeff + = cost ; return* this ; } EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorBlockResourceRequirements)",
    "insertText": "any()"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorBlockShapeType)",
    "insertText": "merge(TensorBlockShapeType lhs, TensorBlockShapeType rhs)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost)",
    "insertText": "merge(TensorOpCost lhs_cost, TensorOpCost rhs_cost)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_data_type_size == sizeof(Scalar))"
  },
  {
    "label": "strides()",
    "kind": "Method",
    "detail": "Function (} const Dimensions&)",
    "insertText": "strides()"
  },
  {
    "label": "DestinationBuffer()",
    "kind": "Method",
    "detail": "Function (} template<Scalar>)",
    "insertText": "DestinationBuffer(Scalar* data, const Dimensions& strides, DestinationBufferKind kind) : m_data(static_cast<void*>(data)), m_data_type_size(sizeof(Scalar)), m_strides(strides), m_kind(kind)"
  },
  {
    "label": "make()",
    "kind": "Method",
    "detail": "Function (} template<int Layout,Scalar> DestinationBuffer)",
    "insertText": "make(const TensorBlockDescriptor& desc, Scalar* data, const Dimensions& strides)"
  },
  {
    "label": "kind()",
    "kind": "Method",
    "detail": "Function (} template<int Layout> DestinationBufferKind)",
    "insertText": "kind(const TensorBlockDescriptor& desc, const Dimensions& strides)"
  },
  {
    "label": "dimensions()",
    "kind": "Method",
    "detail": "Function (const Dimensions& desc_dims = desc .)",
    "insertText": "dimensions()"
  },
  {
    "label": "Layout()",
    "kind": "Method",
    "detail": "Function (const Dimensions& desc_strides = internal::strides<)",
    "insertText": "Layout(desc_dims)"
  },
  {
    "label": "TensorBlockDescriptor()",
    "kind": "Method",
    "detail": "Function (} return kContiguous ; } void* m_data ; size_t m_data_type_size ; Dimensions m_strides ; DestinationBufferKind m_kind ; } ;)",
    "insertText": "TensorBlockDescriptor(const IndexType offset, const Dimensions& dimensions, const DestinationBuffer& destination) : m_offset(offset), m_dimensions(dimensions), m_destination(destination)"
  },
  {
    "label": "TensorBlockDescriptor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TensorBlockDescriptor(const IndexType offset, const Dimensions& dimensions) : m_offset(offset), m_dimensions(dimensions), m_destination(DestinationBuffer())"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (} IndexType)",
    "insertText": "offset()"
  },
  {
    "label": "destination()",
    "kind": "Method",
    "detail": "Function (} const DestinationBuffer&)",
    "insertText": "destination()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(dst_base != NULL)"
  },
  {
    "label": "Layout()",
    "kind": "Method",
    "detail": "Function (m_destination = DestinationBuffer::template make<)",
    "insertText": "Layout(*this, dst_base, dst_strides)"
  },
  {
    "label": "AddDestinationBuffer()",
    "kind": "Method",
    "detail": "Function (} template<int Layout,Scalar,DstStridesIndexType> void)",
    "insertText": "AddDestinationBuffer(Scalar* dst_base, const DSizes<DstStridesIndexType, NumDims>& dst_strides)"
  },
  {
    "label": "Layout()",
    "kind": "Method",
    "detail": "Function (AddDestinationBuffer<)",
    "insertText": "Layout(dst_base, Dimensions(dst_strides))"
  },
  {
    "label": "DropDestinationBuffer()",
    "kind": "Method",
    "detail": "Function (} TensorBlockDescriptor&)",
    "insertText": "DropDestinationBuffer()"
  },
  {
    "label": "HasDestinationBuffer()",
    "kind": "Method",
    "detail": "Function (m_destination . m_data = NULL ; m_destination . m_kind = DestinationBuffer::kEmpty ; return* this ; } bool)",
    "insertText": "HasDestinationBuffer()"
  },
  {
    "label": "WithOffset()",
    "kind": "Method",
    "detail": "Function (} TensorBlockDescriptor)",
    "insertText": "WithOffset(IndexType offset)"
  },
  {
    "label": "TensorBlockMapper()",
    "kind": "Method",
    "detail": "Function (} private : const IndexType m_offset ; const Dimensions m_dimensions ; DestinationBuffer m_destination ; } ; template<int NumDims,int Layout,IndexType = Eigen::Index> class TensorBlockMapper { typedef TensorBlockDescriptor<NumDims,IndexType> BlockDescriptor ; public : typedef DSizes<IndexType,NumDims> Dimensions ;)",
    "insertText": "TensorBlockMapper()"
  },
  {
    "label": "TensorBlockMapper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TensorBlockMapper(const DSizes<IndexType, NumDims>& dimensions, const TensorBlockResourceRequirements& requirements) : m_tensor_dimensions(dimensions), m_requirements(requirements)"
  },
  {
    "label": "InitializeBlockDimensions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeBlockDimensions()"
  },
  {
    "label": "blockCount()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE IndexType)",
    "insertText": "blockCount()"
  },
  {
    "label": "blockDimensions()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const DSizes<IndexType,NumDims>&)",
    "insertText": "blockDimensions()"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (const bool isColMajor = Layout = = static_cast<)",
    "insertText": "int(ColMajor)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (IndexType offset = 0 ; DSizes<IndexType,NumDims> dimensions ;)",
    "insertText": "if(NumDims == 0) return BlockDescriptor(offset, dimensions)"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (const int dim = isColMajor ? i : NumDims - i - 1 ; const IndexType idx = block_index / m_block_strides [ dim ] ; block_index - = idx* m_block_strides [ dim ] ; const IndexType coord = idx* m_block_dimensions [ dim ] ; dimensions [ dim ] =)",
    "insertText": "mini(m_tensor_dimensions[dim] - coord, m_block_dimensions[dim])"
  },
  {
    "label": "IndexType()",
    "kind": "Method",
    "detail": "Function (const TensorBlockShapeType shape_type = m_requirements . shape_type ; IndexType target_block_size = numext::maxi<)",
    "insertText": "IndexType(1, static_cast<IndexType>(m_requirements.size))"
  },
  {
    "label": "TotalSize()",
    "kind": "Method",
    "detail": "Function (IndexType tensor_size = m_tensor_dimensions .)",
    "insertText": "TotalSize()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_block_dimensions [ i ] = 1 ; } m_total_block_count = 0 ; return ; })",
    "insertText": "if(tensor_size <= target_block_size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (m_block_dimensions = m_tensor_dimensions ; m_total_block_count = 1 ;)",
    "insertText": "for(int i = 0; i < NumDims; ++i)"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (const int dim = isColMajor ? i : NumDims - i - 1 ; m_block_dimensions [ dim ] =)",
    "insertText": "mini(coeff_to_allocate, m_tensor_dimensions[dim])"
  },
  {
    "label": "divup()",
    "kind": "Method",
    "detail": "Function (coeff_to_allocate =)",
    "insertText": "divup(coeff_to_allocate, numext::maxi(static_cast<IndexType>(1), m_block_dimensions[dim]))"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "eigen_assert(coeff_to_allocate == 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(shape_type == TensorBlockShapeType::kUniformAllDims)"
  },
  {
    "label": "IndexType()",
    "kind": "Method",
    "detail": "Function (const IndexType dim_size_target = convert_index<)",
    "insertText": "IndexType(std::pow(static_cast<float>(target_block_size), 1.0f / static_cast<float>(m_block_dimensions.rank())))"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (m_block_dimensions [ i ] =)",
    "insertText": "mini(dim_size_target, m_tensor_dimensions[i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int dim = isColMajor ? i : NumDims - i - 1 ;)",
    "insertText": "if(m_block_dimensions[dim] < m_tensor_dimensions[dim])"
  },
  {
    "label": "IndexType()",
    "kind": "Method",
    "detail": "Function (const IndexType total_size_other_dims = total_size / m_block_dimensions [ dim ] ; const IndexType alloc_avail = divup<)",
    "insertText": "IndexType(target_block_size, total_size_other_dims)"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (break ; } m_block_dimensions [ dim ] =)",
    "insertText": "mini(m_tensor_dimensions[dim], alloc_avail)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (total_size = total_size_other_dims* m_block_dimensions [ dim ] ; } } } else {)",
    "insertText": "eigen_assert(false)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "eigen_assert(m_block_dimensions.TotalSize() >= numext::mini<IndexType>(target_block_size, m_tensor_dimensions.TotalSize()))"
  },
  {
    "label": "divup()",
    "kind": "Method",
    "detail": "Function (block_count [ i ] =)",
    "insertText": "divup(m_tensor_dimensions[i], m_block_dimensions[i])"
  },
  {
    "label": "array_prod()",
    "kind": "Method",
    "detail": "Function (} m_total_block_count =)",
    "insertText": "array_prod(block_count)"
  },
  {
    "label": "Layout()",
    "kind": "Method",
    "detail": "Function (m_tensor_strides = strides<)",
    "insertText": "Layout(m_tensor_dimensions)"
  },
  {
    "label": "Layout()",
    "kind": "Method",
    "detail": "Function (m_block_strides = strides<)",
    "insertText": "Layout(block_count)"
  },
  {
    "label": "TensorBlockScratchAllocator()",
    "kind": "Method",
    "detail": "Function (} DSizes<IndexType,NumDims> m_tensor_dimensions ; TensorBlockResourceRequirements m_requirements ; DSizes<IndexType,NumDims> m_block_dimensions ; IndexType m_total_block_count ; DSizes<IndexType,NumDims> m_tensor_strides ; DSizes<IndexType,NumDims> m_block_strides ; } ; template<Device> class TensorBlockScratchAllocator { public :)",
    "insertText": "TensorBlockScratchAllocator(const Device& device) : m_device(device), m_allocation_index(0)"
  },
  {
    "label": "TensorBlockScratchAllocator()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TensorBlockScratchAllocator()"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (m_device .)",
    "insertText": "deallocate(m_allocations[i].ptr)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} } void*)",
    "insertText": "allocate(size_t size)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (const int num_allocations = static_cast<)",
    "insertText": "int(m_allocations.size())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (const bool has_allocation = m_allocation_index<num_allocations ;)",
    "insertText": "eigen_assert(m_allocation_index <= num_allocations)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (m_device .)",
    "insertText": "deallocate(m_allocations[m_allocation_index].ptr)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (m_allocations [ m_allocation_index ] . ptr = m_device .)",
    "insertText": "allocate(size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_allocations [ m_allocation_index ] . size = size ; })",
    "insertText": "if(!has_allocation)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (allocation . size = size ; m_allocations .)",
    "insertText": "push_back(allocation)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "eigen_assert(m_allocations[m_allocation_index].ptr != NULL)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_allocations[m_allocation_index].size >= size)"
  },
  {
    "label": "TensorMaterializedBlock()",
    "kind": "Method",
    "detail": "Function (m_allocation_index = 0 ; } private : struct Allocation { void* ptr ; size_t size ; } ; const Device& m_device ; int m_allocation_index ; std::vector<Allocation> m_allocations ; } ; enum TensorBlockKind { kExpr,kView,kMaterializedInScratch,kMaterializedInOutput } ; class TensorBlockNotImplemented { public : typedef void XprType ; } ; template<XprType> struct XprScalar { typedef XprType::Scalar type ; } ; template<> struct XprScalar<void> { typedef void type ; } ; template<Scalar,int NumDims,int Layout,IndexType = Eigen::Index> class TensorMaterializedBlock { public : typedef DSizes<IndexType,NumDims> Dimensions ; typedef TensorMap<const Tensor<Scalar,NumDims,Layout>> XprType ;)",
    "insertText": "TensorMaterializedBlock(TensorBlockKind kind, const Scalar* data, const Dimensions& dimensions, bool valid_expr = true) : m_kind(kind), m_data(data), m_dimensions(dimensions), m_expr(m_data, m_dimensions), m_valid_expr(valid_expr)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_kind == internal::TensorBlockKind::kView || m_kind == internal::TensorBlockKind::kMaterializedInScratch || m_kind == internal::TensorBlockKind::kMaterializedInOutput)"
  },
  {
    "label": "kind()",
    "kind": "Method",
    "detail": "Function (} TensorBlockKind)",
    "insertText": "kind()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_valid_expr)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (} typedef internal::TensorBlockDescriptor<NumDims,IndexType> TensorBlockDesc ; class Storage { public : Scalar*)",
    "insertText": "data()"
  },
  {
    "label": "Storage()",
    "kind": "Method",
    "detail": "Function (} private : class TensorMaterializedBlock ;)",
    "insertText": "Storage(Scalar* data, const Dimensions& dimensions, const Dimensions& strides, bool materialized_in_output, bool strided_storage) : m_data(data), m_dimensions(dimensions), m_strides(strides), m_materialized_in_output(materialized_in_output), m_strided_storage(strided_storage)"
  },
  {
    "label": "prepareStorage()",
    "kind": "Method",
    "detail": "Function (} Scalar* m_data ; Dimensions m_dimensions ; Dimensions m_strides ; bool m_materialized_in_output ; bool m_strided_storage ; } ; template<TensorBlockScratch> EIGEN_STRONG_INLINE Storage)",
    "insertText": "prepareStorage(TensorBlockDesc& desc, TensorBlockScratch& scratch, bool allow_strided_storage = false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (typedef TensorBlockDesc::DestinationBuffer DestinationBuffer ;)",
    "insertText": "if(desc.destination().kind() == DestinationBuffer::kContiguous)"
  },
  {
    "label": "destination()",
    "kind": "Method",
    "detail": "Function (Scalar* buffer = desc .)",
    "insertText": "destination().template data<Scalar>()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(desc.destination().kind() == DestinationBuffer::kStrided && allow_strided_storage)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} else { void* mem = scratch .)",
    "insertText": "allocate(desc.size() * sizeof(Scalar))"
  },
  {
    "label": "materialize()",
    "kind": "Method",
    "detail": "Function (} } template<DataDimensions,TensorBlockScratch> EIGEN_STRONG_INLINE TensorMaterializedBlock)",
    "insertText": "materialize(const Scalar* data, const DataDimensions& data_dims, TensorBlockDesc& desc, TensorBlockScratch& scratch)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(array_size<DataDimensions>::value == desc.dimensions().size())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int dim = is_col_major ? i : NumDims - i - 1 ;)",
    "insertText": "if(data_dims[dim] != desc.dimensions()[dim])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (+ + num_matching_inner_dims ; } bool can_use_direct_access = true ;)",
    "insertText": "for(int i = num_matching_inner_dims + 1; i < NumDims; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int dim = is_col_major ? i : NumDims - i - 1 ;)",
    "insertText": "if(desc.dimension(dim) != 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (can_use_direct_access = false ; break ; } })",
    "insertText": "if(can_use_direct_access)"
  },
  {
    "label": "prepareStorage()",
    "kind": "Method",
    "detail": "Function (} else { const Storage storage =)",
    "insertText": "prepareStorage(desc, scratch)"
  },
  {
    "label": "src()",
    "kind": "Method",
    "detail": "Function (typedef internal::TensorBlockIO<Scalar,IndexType,NumDims,Layout> TensorBlockIO ; typedef TensorBlockIO::Dst TensorBlockIODst ; typedef TensorBlockIO::Src TensorBlockIOSrc ; TensorBlockIOSrc)",
    "insertText": "src(internal::strides<Layout>(Dimensions(data_dims)), data, desc.offset())"
  },
  {
    "label": "dst()",
    "kind": "Method",
    "detail": "Function (TensorBlockIODst)",
    "insertText": "dst(storage.dimensions(), storage.strides(), storage.data())"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Copy(dst, src)"
  },
  {
    "label": "TensorCwiseUnaryBlock()",
    "kind": "Method",
    "detail": "Function (} } private : TensorBlockKind m_kind ; const Scalar* m_data ; Dimensions m_dimensions ; XprType m_expr ; bool m_valid_expr ; } ; template<UnaryOp,ArgTensorBlock> class TensorCwiseUnaryBlock { const bool NoArgBlockAccess = internal::is_void<ArgTensorBlock::XprType>::value ; public : typedef conditional<NoArgBlockAccess,void,TensorCwiseUnaryOp<UnaryOp,const ArgTensorBlock::XprType>>::type XprType ; typedef XprScalar<XprType>::type Scalar ;)",
    "insertText": "TensorCwiseUnaryBlock(const ArgTensorBlock& arg_block, const UnaryOp& functor) : m_arg_block(arg_block), m_functor(functor)"
  },
  {
    "label": "cleanup()",
    "kind": "Method",
    "detail": "Function (m_arg_block .)",
    "insertText": "cleanup()"
  },
  {
    "label": "TensorCwiseBinaryBlock()",
    "kind": "Method",
    "detail": "Function (} private : ArgTensorBlock m_arg_block ; UnaryOp m_functor ; } ; template<BinaryOp,LhsTensorBlock,RhsTensorBlock> class TensorCwiseBinaryBlock { const bool NoArgBlockAccess = internal::is_void<LhsTensorBlock::XprType>::value | | internal::is_void<RhsTensorBlock::XprType>::value ; public : typedef conditional<NoArgBlockAccess,void,TensorCwiseBinaryOp<BinaryOp,const LhsTensorBlock::XprType,const RhsTensorBlock::XprType>>::type XprType ; typedef XprScalar<XprType>::type Scalar ;)",
    "insertText": "TensorCwiseBinaryBlock(const LhsTensorBlock& left_block, const RhsTensorBlock& right_block, const BinaryOp& functor) : m_left_block(left_block), m_right_block(right_block), m_functor(functor)"
  },
  {
    "label": "TensorUnaryExprBlock()",
    "kind": "Method",
    "detail": "Function (} private : LhsTensorBlock m_left_block ; RhsTensorBlock m_right_block ; BinaryOp m_functor ; } ; template<BlockFactory,ArgTensorBlock> class TensorUnaryExprBlock { typedef ArgTensorBlock::XprType ArgXprType ; const bool NoArgBlockAccess = internal::is_void<ArgXprType>::value ; public : typedef conditional<NoArgBlockAccess,void,BlockFactory::template XprType<ArgXprType>::type>::type XprType ; typedef XprScalar<XprType>::type Scalar ;)",
    "insertText": "TensorUnaryExprBlock(const ArgTensorBlock& arg_block, const BlockFactory& factory) : m_arg_block(arg_block), m_factory(factory)"
  },
  {
    "label": "TensorTernaryExprBlock()",
    "kind": "Method",
    "detail": "Function (} private : ArgTensorBlock m_arg_block ; BlockFactory m_factory ; } ; template<BlockFactory,Arg1TensorBlock,Arg2TensorBlock,Arg3TensorBlock> class TensorTernaryExprBlock { typedef Arg1TensorBlock::XprType Arg1XprType ; typedef Arg2TensorBlock::XprType Arg2XprType ; typedef Arg3TensorBlock::XprType Arg3XprType ; const bool NoArgBlockAccess = internal::is_void<Arg1XprType>::value | | internal::is_void<Arg2XprType>::value | | internal::is_void<Arg3XprType>::value ; public : typedef conditional<NoArgBlockAccess,void,BlockFactory::template XprType<Arg1XprType,Arg2XprType,Arg3XprType>::type>::type XprType ; typedef XprScalar<XprType>::type Scalar ;)",
    "insertText": "TensorTernaryExprBlock(const Arg1TensorBlock& arg1_block, const Arg2TensorBlock& arg2_block, const Arg3TensorBlock& arg3_block, const BlockFactory& factory) : m_arg1_block(arg1_block), m_arg2_block(arg2_block), m_arg3_block(arg3_block), m_factory(factory)"
  },
  {
    "label": "Dst()",
    "kind": "Method",
    "detail": "Function (} private : Arg1TensorBlock m_arg1_block ; Arg2TensorBlock m_arg2_block ; Arg3TensorBlock m_arg3_block ; BlockFactory m_factory ; } ; template<Scalar,IndexType> class StridedLinearBufferCopy { typedef packet_traits<Scalar>::type Packet ; enum { Vectorizable = packet_traits<Scalar>::Vectorizable,PacketSize = packet_traits<Scalar>::size } ; public : enum class Kind { Linear = 0,Scatter = 1,FillLinear = 2,FillScatter = 3,Gather = 4,Random = 5 } ; struct Dst {)",
    "insertText": "Dst(IndexType o, IndexType s, Scalar* d) : offset(o), stride(s), data(d)"
  },
  {
    "label": "Src()",
    "kind": "Method",
    "detail": "Function (} IndexType offset ; IndexType stride ; Scalar* data ; } ; struct Src {)",
    "insertText": "Src(IndexType o, IndexType s, const Scalar* d) : offset(o), stride(s), data(d)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (} IndexType offset ; IndexType stride ; const Scalar* data ; } ; template<StridedLinearBufferCopy::Kind kind> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "Run(const Dst& dst, const Src& src, const size_t count)"
  },
  {
    "label": "kind()",
    "kind": "Method",
    "detail": "Function (Run<)",
    "insertText": "kind(count, dst.offset, dst.stride, dst.data, src.offset, src.stride, src.data)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (} private : template<StridedLinearBufferCopy::Kind kind> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "Run(const IndexType count, const IndexType dst_offset, const IndexType dst_stride, Scalar* EIGEN_RESTRICT dst_data, const IndexType src_offset, const IndexType src_stride, const Scalar* EIGEN_RESTRICT src_data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Scalar* src =& src_data [ src_offset ] ; Scalar* dst =& dst_data [ dst_offset ] ;)",
    "insertText": "if(!Vectorizable)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dst [ i* dst_stride ] = src [ i* src_stride ] ; } return ; } const IndexType vectorized_size = count - PacketSize ; IndexType i = 0 ;)",
    "insertText": "if(kind == StridedLinearBufferCopy::Kind::Linear)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (const IndexType unrolled_size = count - 4* PacketSize ;)",
    "insertText": "eigen_assert(src_stride == 1 && dst_stride == 1)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet p = ploadu<)",
    "insertText": "Packet(src + i + j * PacketSize)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (pstoreu<Scalar,)",
    "insertText": "Packet(dst + i + j * PacketSize, p)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(; i <= vectorized_size; i += PacketSize)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet p = ploadu<)",
    "insertText": "Packet(src + i)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (pstoreu<Scalar,)",
    "insertText": "Packet(dst + i, p)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(; i < count; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dst [ i ] = src [ i ] ; } } else)",
    "insertText": "if(kind == StridedLinearBufferCopy::Kind::Scatter)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(src_stride == 1 && dst_stride != 1)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (pscatter<Scalar,)",
    "insertText": "Packet(dst + i * dst_stride, p, dst_stride)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dst [ i* dst_stride ] = src [ i ] ; } } else)",
    "insertText": "if(kind == StridedLinearBufferCopy::Kind::FillLinear)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(src_stride == 0 && dst_stride == 1)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const IndexType unrolled_size = count - 4* PacketSize ; Packet p = pload1<)",
    "insertText": "Packet(src)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dst [ i ] =* src ; } } else)",
    "insertText": "if(kind == StridedLinearBufferCopy::Kind::FillScatter)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(src_stride == 0 && dst_stride != 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dst [ i* dst_stride ] =* src ; } } else)",
    "insertText": "if(kind == StridedLinearBufferCopy::Kind::Gather)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(dst_stride == 1)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet p = pgather<Scalar,)",
    "insertText": "Packet(src + i * src_stride, src_stride)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dst [ i ] = src [ i* src_stride ] ; } } else)",
    "insertText": "if(kind == StridedLinearBufferCopy::Kind::Random)"
  },
  {
    "label": "IsColMajor()",
    "kind": "Method",
    "detail": "Function (} } } ; template<Scalar,IndexType,int NumDims,int Layout> class TensorBlockIO { const bool)",
    "insertText": "IsColMajor(Layout == ColMajor)"
  },
  {
    "label": "Dst()",
    "kind": "Method",
    "detail": "Function (typedef StridedLinearBufferCopy<Scalar,IndexType> LinCopy ; public : typedef DSizes<IndexType,NumDims> Dimensions ; typedef DSizes<int,NumDims> DimensionsMap ; struct Dst {)",
    "insertText": "Dst(const Dimensions& dst_dims, const Dimensions& dst_strides, Scalar* dst, IndexType dst_offset = 0) : dims(dst_dims), strides(dst_strides), data(dst), offset(dst_offset)"
  },
  {
    "label": "Src()",
    "kind": "Method",
    "detail": "Function (} Dimensions dims ; Dimensions strides ; Scalar* data ; IndexType offset ; } ; struct Src {)",
    "insertText": "Src(const Dimensions& src_strides, const Scalar* src, IndexType src_offset = 0) : strides(src_strides), data(src), offset(src_offset)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (} Dimensions strides ; const Scalar* data ; IndexType offset ; } ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE IndexType)",
    "insertText": "Copy(const Dst& dst, const Src& src, const DimensionsMap& dst_to_src_dim_map)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(dst.strides[inner_dim] == 1 || dst.strides[inner_dim] == 0)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(src.strides[inner_dim] == 1 || src.strides[inner_dim] == 0)"
  },
  {
    "label": "NumSqueezableInnerDims()",
    "kind": "Method",
    "detail": "Function (} const DimensionsMap& dim_map = dst_to_src_dim_map ; int num_squeezable_dims =)",
    "insertText": "NumSqueezableInnerDims(dim_map)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int num_size_one_inner_dims = 0 ;)",
    "insertText": "for(int i = 0; i < num_squeezable_dims; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int dst_dim = IsColMajor ? i : NumDims - i - 1 ;)",
    "insertText": "if(dst.dims[dst_dim] != 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (num_size_one_inner_dims + + ; })",
    "insertText": "if(num_size_one_inner_dims == NumDims)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int dst_dim = IsColMajor ? i : NumDims - i - 1 ; const IndexType dst_stride = dst . strides [ dst_dim ] ; const IndexType src_stride = src . strides [ dim_map [ dst_dim ] ] ;)",
    "insertText": "if(dst_inner_dim_size == dst_stride && dst_stride == src_stride)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (dst_inner_dim_size* = dst . dims [ dst_dim ] ; + + num_size_one_inner_dims ; } else { break ; } } IndexType input_offset = src . offset ; IndexType output_offset = dst . offset ; IndexType input_stride = NumDims = = 0 ? 1 : src . strides [ src_dim_for_dst_stride1_dim ] ; IndexType output_stride = NumDims = = 0 ? 1 : dst . strides [ dst_stride1_dim ] ; const int at_least_1_dim = NumDims<= 1 ? 1 : NumDims - 1 ; array<BlockIteratorState,at_least_1_dim> it ; int idx = 0 ;)",
    "insertText": "for(int i = num_size_one_inner_dims; i < NumDims - 1; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int dst_dim = IsColMajor ? i + 1 : NumDims - i - 2 ;)",
    "insertText": "if(dst.dims[dst_dim] == 1)"
  },
  {
    "label": "input_stride()",
    "kind": "Method",
    "detail": "Function (it [ idx ] . size = dst . dims [ dst_dim ] ; it [ idx ] . input_stride = src . strides [ dim_map [ dst_dim ] ] ; it [ idx ] . output_stride = dst . strides [ dst_dim ] ; it [ idx ] . input_span = it [ idx ] .)",
    "insertText": "input_stride(it[idx].size - 1)"
  },
  {
    "label": "output_stride()",
    "kind": "Method",
    "detail": "Function (it [ idx ] . output_span = it [ idx ] .)",
    "insertText": "output_stride(it[idx].size - 1)"
  },
  {
    "label": "COPY_INNER_DIM()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "COPY_INNER_DIM(KIND)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "for(num_copied = 0; num_copied < block_total_size; \\ num_copied += dst_inner_dim_size)"
  },
  {
    "label": "KIND()",
    "kind": "Method",
    "detail": "Function (\\ LinCopy::template Run<)",
    "insertText": "KIND(\\ typename LinCopy::Dst(output_offset, output_stride, dst.data), \\ typename LinCopy::Src(input_offset, input_stride, src.data), \\ dst_inner_dim_size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (\\ \\)",
    "insertText": "for(int j = 0; j < idx; ++j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(++it[j].count < it[j].size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ input_offset + = it [ j ] . input_stride ; \\ output_offset + = it [ j ] . output_stride ; \\ break ; \\ } \\ it [ j ] . count = 0 ; \\ input_offset - = it [ j ] . input_span ; \\ output_offset - = it [ j ] . output_span ; \\ } \\ } \\ return num_copied ;)",
    "insertText": "if(input_stride == 1 && output_stride == 1)"
  },
  {
    "label": "COPY_INNER_DIM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "COPY_INNER_DIM(LinCopy::Kind::Linear)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(input_stride == 1 && output_stride != 1)"
  },
  {
    "label": "COPY_INNER_DIM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "COPY_INNER_DIM(LinCopy::Kind::Scatter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(input_stride == 0 && output_stride == 1)"
  },
  {
    "label": "COPY_INNER_DIM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "COPY_INNER_DIM(LinCopy::Kind::FillLinear)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(input_stride == 0 && output_stride != 1)"
  },
  {
    "label": "COPY_INNER_DIM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "COPY_INNER_DIM(LinCopy::Kind::FillScatter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(output_stride == 1)"
  },
  {
    "label": "COPY_INNER_DIM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "COPY_INNER_DIM(LinCopy::Kind::Gather)"
  },
  {
    "label": "COPY_INNER_DIM()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "COPY_INNER_DIM(LinCopy::Kind::Random)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (} # undef COPY_INNER_DIM } EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE IndexType)",
    "insertText": "Copy(const Dst& dst, const Src& src)"
  },
  {
    "label": "BlockIteratorState()",
    "kind": "Method",
    "detail": "Function (} private : struct BlockIteratorState {)",
    "insertText": "BlockIteratorState() : size(0), count(0), input_stride(0), output_stride(0), input_span(0), output_span(0)"
  },
  {
    "label": "NumSqueezableInnerDims()",
    "kind": "Method",
    "detail": "Function (} IndexType size ; IndexType count ; IndexType input_stride ; IndexType output_stride ; IndexType input_span ; IndexType output_span ; } ; int)",
    "insertText": "NumSqueezableInnerDims(const DimensionsMap& dim_map)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int dim = IsColMajor ? i : NumDims - i - 1 ;)",
    "insertText": "if(dim_map[dim] != dim)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (num_squeezable_dims + + ; } return num_squeezable_dims ; } } ; template<Scalar,int NumDims,TensorBlockExpr,IndexType = Eigen::Index> class TensorBlockAssignment { typedef TensorEvaluator<const TensorBlockExpr,DefaultDevice> TensorBlockEvaluator ; typedef DSizes<IndexType,NumDims> Dimensions ; enum { Vectorizable = packet_traits<Scalar>::Vectorizable,PacketSize = packet_traits<Scalar>::size } ; template<bool Vectorizable,Evaluator> struct InnerDimAssign { EIGEN_ALWAYS_INLINE void)",
    "insertText": "Run(Scalar* target, IndexType count, const Evaluator& eval, IndexType eval_offset)"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (target [ i ] = eval .)",
    "insertText": "coeff(eval_offset + i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (typedef packet_traits<Scalar>::type Packet ; const IndexType unrolled_size = count - 4* PacketSize ; const IndexType vectorized_size = count - PacketSize ; IndexType i = 0 ;)",
    "insertText": "for(; i <= unrolled_size; i += 4 * PacketSize)"
  },
  {
    "label": "Unaligned()",
    "kind": "Method",
    "detail": "Function (const IndexType idx = eval_offset + i + j* PacketSize ; Packet p = eval . template packet<)",
    "insertText": "Unaligned(idx)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (pstoreu<)",
    "insertText": "Scalar(target + i + j * PacketSize, p)"
  },
  {
    "label": "Unaligned()",
    "kind": "Method",
    "detail": "Function (Packet p = eval . template packet<)",
    "insertText": "Unaligned(eval_offset + i)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (pstoreu<)",
    "insertText": "Scalar(target + i, p)"
  },
  {
    "label": "Target()",
    "kind": "Method",
    "detail": "Function (} } } ; public : struct Target {)",
    "insertText": "Target(const Dimensions& target_dims, const Dimensions& target_strides, Scalar* target_data, IndexType target_offset = 0) : dims(target_dims), strides(target_strides), data(target_data), offset(target_offset)"
  },
  {
    "label": "target()",
    "kind": "Method",
    "detail": "Function (} Dimensions dims ; Dimensions strides ; Scalar* data ; IndexType offset ; } ; Target)",
    "insertText": "target(const Dimensions& target_dims, const Dimensions& target_strides, Scalar* target_data, IndexType target_offset = 0)"
  },
  {
    "label": "target()",
    "kind": "Method",
    "detail": "Function (} template<TargetDimsIndexType,TargetStridesIndexType> Target)",
    "insertText": "target(const DSizes<TargetDimsIndexType, NumDims>& target_dims, const DSizes<TargetStridesIndexType, NumDims>& target_strides, Scalar* target_data, IndexType target_offset = 0)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "Run(const Target& target, const TensorBlockExpr& expr)"
  },
  {
    "label": "eval()",
    "kind": "Method",
    "detail": "Function (DefaultDevice default_device ; TensorBlockEvaluator)",
    "insertText": "eval(expr, default_device)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(dimensions_match(target.dims, eval.dimensions()))"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (const int inner_dim_idx = is_col_major ? 0 : NumDims - 1 ; IndexType output_inner_dim_size = target . dims [ inner_dim_idx ] ;)",
    "insertText": "eigen_assert(target.strides[inner_dim_idx] == 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (IndexType num_squeezed_dims = 0 ;)",
    "insertText": "for(Index i = 1; i < NumDims; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index dim = is_col_major ? i : NumDims - i - 1 ; const IndexType target_stride = target . strides [ dim ] ;)",
    "insertText": "if(output_inner_dim_size == target_stride)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (output_inner_dim_size* = target . dims [ dim ] ; num_squeezed_dims + + ; } else { break ; } } array<BlockIteratorState,NumDims> it ; int idx = 0 ;)",
    "insertText": "for(Index i = num_squeezed_dims; i < NumDims - 1; ++i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (idx + + ; } IndexType input_offset = 0 ; IndexType output_offset = target . offset ;)",
    "insertText": "for(IndexType i = 0; i < output_size; i += output_inner_dim_size)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (InnerDimAssign<Vectorizable&& TensorBlockEvaluator::PacketAccess,TensorBlockEvaluator)",
    "insertText": "Run(target.data + output_offset, output_inner_dim_size, eval, input_offset)"
  },
  {
    "label": "BlockIteratorState()",
    "kind": "Method",
    "detail": "Function (output_offset + = it [ j ] . output_stride ; break ; } it [ j ] . count = 0 ; output_offset - = it [ j ] . output_span ; } } } private : struct BlockIteratorState {)",
    "insertText": "BlockIteratorState() : count(0), size(0), output_stride(0), output_span(0)"
  }
]