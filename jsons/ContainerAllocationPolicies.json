[
  {
    "label": "FArraySlackTrackingHeader",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FArraySlackTrackingHeader"
  },
  {
    "label": "FDefaultBitArrayAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDefaultBitArrayAllocator"
  },
  {
    "label": "TSizedDefaultAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSizedDefaultAllocator"
  },
  {
    "label": "FScriptContainerElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FScriptContainerElement"
  },
  {
    "label": "TAllocatorTraitsBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAllocatorTraitsBase"
  },
  {
    "label": "TAllocatorTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAllocatorTraits"
  },
  {
    "label": "TCanMoveBetweenAllocators",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCanMoveBetweenAllocators"
  },
  {
    "label": "FContainerAllocatorInterface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FContainerAllocatorInterface"
  },
  {
    "label": "ForElementType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ForElementType"
  },
  {
    "label": "TAlignedHeapAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TAlignedHeapAllocator"
  },
  {
    "label": "ForAnyElementType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ForAnyElementType"
  },
  {
    "label": "TBitsToSizeType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TBitsToSizeType"
  },
  {
    "label": "TSizedHeapAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSizedHeapAllocator"
  },
  {
    "label": "TSizedInlineAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSizedInlineAllocator"
  },
  {
    "label": "TNonRelocatableInlineAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TNonRelocatableInlineAllocator"
  },
  {
    "label": "TFixedAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TFixedAllocator"
  },
  {
    "label": "TSparseArrayAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSparseArrayAllocator"
  },
  {
    "label": "TAlignedSparseArrayAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TAlignedSparseArrayAllocator"
  },
  {
    "label": "TInlineSparseArrayAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TInlineSparseArrayAllocator"
  },
  {
    "label": "TFixedSparseArrayAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TFixedSparseArrayAllocator"
  },
  {
    "label": "TSetAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSetAllocator"
  },
  {
    "label": "TInlineSetAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TInlineSetAllocator"
  },
  {
    "label": "TFixedSetAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TFixedSetAllocator"
  },
  {
    "label": "FDefaultSetAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDefaultSetAllocator"
  },
  {
    "label": "FDefaultSparseArrayAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDefaultSparseArrayAllocator"
  },
  {
    "label": "UE_ENABLE_ARRAY_SLACK_TRACKING()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Containers / ContainerHelpers . h \" # include \" Containers / ContainerAllocationPolicies . h \" # include \" HAL / PlatformMath . h \" # include \" HAL / UnrealMemory . h \" # include \" Math / NumericLimits . h \" # include \" Misc / AssertionMacros . h \" # include \" Templates / IsPolymorphic . h \" # include \" Templates / MemoryOps . h \" # include \" Templates / TypeCompatibleBytes . h \" # include<type_traits> # ifndef UE_ENABLE_ARRAY_SLACK_TRACKING # define)",
    "insertText": "UE_ENABLE_ARRAY_SLACK_TRACKING(0 && !WITH_EDITOR) #endif #if UE_ENABLE_ARRAY_SLACK_TRACKING CORE_API uint8 LlmGetActiveTag()"
  },
  {
    "label": "ArraySlackTrackInit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ArraySlackTrackInit()"
  },
  {
    "label": "ArraySlackTrackGenerateReport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ArraySlackTrackGenerateReport(const TCHAR* Cmd, FOutputDevice& Ar)"
  },
  {
    "label": "AddAllocation()",
    "kind": "Method",
    "detail": "Function (struct FArraySlackTrackingHeader { FArraySlackTrackingHeader* Next ; FArraySlackTrackingHeader** Prev ; uint16 AllocOffset ; uint8 Tag ; int8 NumStackFrames ; uint32 FirstAllocFrame ; uint32 ReallocCount ; uint32 ArrayPeak ; uint64 ElemSize ; int64 ArrayNum ; int64 ArrayMax ; uint64 StackFrames [ 9 ] ; void)",
    "insertText": "AddAllocation()"
  },
  {
    "label": "RemoveAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAllocation()"
  },
  {
    "label": "UpdateNumUsed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateNumUsed(int64 NewNumUsed)"
  },
  {
    "label": "Realloc()",
    "kind": "Method",
    "detail": "Function (FORCENOINLINE void*)",
    "insertText": "Realloc(void* Ptr, int64 Count, uint64 ElemSize, int32 Alignment)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(void* Ptr)"
  },
  {
    "label": "TrackingHeader()",
    "kind": "Method",
    "detail": "Function (FArraySlackTrackingHeader*)",
    "insertText": "TrackingHeader(FArraySlackTrackingHeader*)((uint8*)Ptr - sizeof(FArraySlackTrackingHeader))"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (AllocOffset)",
    "insertText": "Ptr(uint8*)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(Ptr)"
  },
  {
    "label": "UpdateNumUsed()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "UpdateNumUsed(void* Ptr, int64 NewNumUsed)"
  },
  {
    "label": "UpdateNumUsed()",
    "kind": "Method",
    "detail": "Function (TrackingHeader ->)",
    "insertText": "UpdateNumUsed(NewNumUsed)"
  },
  {
    "label": "DisableTracking()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DisableTracking(void* Ptr)"
  },
  {
    "label": "SlackSizeInBytes()",
    "kind": "Method",
    "detail": "Function (TrackingHeader -> ArrayNum = INDEX_NONE ; } } int64)",
    "insertText": "SlackSizeInBytes()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # endif # ifndef CONTAINER_INITIAL_ALLOC_ZERO_SLACK # define CONTAINER_INITIAL_ALLOC_ZERO_SLACK 1 # endif # if)",
    "insertText": "defined(UE_CONTAINER_SLACK_GROWTH_FACTOR_NUMERATOR) && !defined(UE_CONTAINER_SLACK_GROWTH_FACTOR_DENOMINATOR) #error If UE_CONTAINER_SLACK_GROWTH_FACTOR_NUMERATOR is defined you must also define UE_CONTAINER_SLACK_GROWTH_FACTOR_DENOMINATOR #endif #if defined(UE_CONTAINER_SLACK_GROWTH_FACTOR_DENOMINATOR) && !defined(UE_CONTAINER_SLACK_GROWTH_FACTOR_NUMERATOR) #error If UE_CONTAINER_SLACK_GROWTH_FACTOR_DENOMINATOR is defined you must also define UE_CONTAINER_SLACK_GROWTH_FACTOR_NUMERATOR #endif #ifndef UE_CONTAINER_SLACK_GROWTH_FACTOR_NUMERATOR #if AGGRESSIVE_MEMORY_SAVING #define UE_CONTAINER_SLACK_GROWTH_FACTOR_NUMERATOR 1 #else #define UE_CONTAINER_SLACK_GROWTH_FACTOR_NUMERATOR 3 #endif #endif #ifndef UE_CONTAINER_SLACK_GROWTH_FACTOR_DENOMINATOR #if AGGRESSIVE_MEMORY_SAVING #define UE_CONTAINER_SLACK_GROWTH_FACTOR_DENOMINATOR 4 #else #define UE_CONTAINER_SLACK_GROWTH_FACTOR_DENOMINATOR 8 #endif #endif static_assert(UE_CONTAINER_SLACK_GROWTH_FACTOR_DENOMINATOR > 0, \"UE_CONTAINER_SLACK_GROWTH_FACTOR_DENOMINATOR must be greater than 0\")"
  },
  {
    "label": "DefaultCalculateSlackShrink()",
    "kind": "Method",
    "detail": "Function (class FDefaultBitArrayAllocator ; template<int IndexSize> class TSizedDefaultAllocator ; using FDefaultAllocator = TSizedDefaultAllocator<3 2> ; template<SizeType> SizeType)",
    "insertText": "DefaultCalculateSlackShrink(SizeType NewMax, SizeType CurrentMax, SIZE_T BytesPerElement, bool bAllowQuantize, uint32 Alignment = DEFAULT_ALIGNMENT)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (SizeType Retval ;)",
    "insertText": "checkSlow(NewMax < CurrentMax)"
  },
  {
    "label": "CurrentSlackBytes()",
    "kind": "Method",
    "detail": "Function (const SizeType CurrentSlackElements = CurrentMax - NewMax ; const SIZE_T)",
    "insertText": "CurrentSlackBytes(CurrentMax - NewMax)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const bool bTooManySlackBytes = CurrentSlackBytes> = 1 6 3 8 4 ; const bool bTooManySlackElements = 3* NewMax<2* CurrentMax ;)",
    "insertText": "if((bTooManySlackBytes || bTooManySlackElements) && (CurrentSlackElements > 64 || !NewMax))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Retval = NewMax ;)",
    "insertText": "if(Retval > 0)"
  },
  {
    "label": "Retval()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Retval(SizeType)(FMemory::QuantizeSize(Retval * BytesPerElement, Alignment) / BytesPerElement)"
  },
  {
    "label": "DefaultCalculateSlackGrow()",
    "kind": "Method",
    "detail": "Function (} } } else { Retval = CurrentMax ; } return Retval ; } template<SizeType> SizeType)",
    "insertText": "DefaultCalculateSlackGrow(SizeType NewMax, SizeType CurrentMax, SIZE_T BytesPerElement, bool bAllowQuantize, uint32 Alignment = DEFAULT_ALIGNMENT)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(AGGRESSIVE_MEMORY_SAVING)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (const SIZE_T ConstantGrow = 0 ; # else const SIZE_T FirstGrow = 4 ; const SIZE_T ConstantGrow = 1 6 ; # endif SizeType Retval ;)",
    "insertText": "checkSlow(NewMax > CurrentMax && NewMax > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SIZE_T Grow = FirstGrow ; # if CONTAINER_INITIAL_ALLOC_ZERO_SLACK)",
    "insertText": "if(CurrentMax)"
  },
  {
    "label": "SIZE_T()",
    "kind": "Method",
    "detail": "Function (Grow =)",
    "insertText": "SIZE_T(NewMax) + UE_CONTAINER_SLACK_GROWTH_FACTOR_NUMERATOR * SIZE_T(NewMax)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(SIZE_T(NewMax) > Grow)"
  },
  {
    "label": "SIZE_T()",
    "kind": "Method",
    "detail": "Function (Grow =)",
    "insertText": "SIZE_T(NewMax)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # else)",
    "insertText": "if(CurrentMax || SIZE_T(NewMax) > Grow)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "if(bAllowQuantize)"
  },
  {
    "label": "Retval()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Retval(SizeType)(FMemory::QuantizeSize(Grow * BytesPerElement, Alignment) / BytesPerElement)"
  },
  {
    "label": "Retval()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "Retval(SizeType)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(NewMax > Retval)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Retval = TNumericLimits<SizeType)",
    "insertText": "Max()"
  },
  {
    "label": "DefaultCalculateSlackReserve()",
    "kind": "Method",
    "detail": "Function (} return Retval ; } template<SizeType> SizeType)",
    "insertText": "DefaultCalculateSlackReserve(SizeType NewMax, SIZE_T BytesPerElement, bool bAllowQuantize, uint32 Alignment = DEFAULT_ALIGNMENT)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (SizeType Retval = NewMax ;)",
    "insertText": "checkSlow(NewMax > 0)"
  },
  {
    "label": "Retval()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Retval(SizeType)(FMemory::QuantizeSize(SIZE_T(Retval) * SIZE_T(BytesPerElement), Alignment) / BytesPerElement)"
  },
  {
    "label": "MoveToEmpty()",
    "kind": "Method",
    "detail": "Function (} } return Retval ; } struct FScriptContainerElement { } ; template<AllocatorType> struct TAllocatorTraitsBase { enum { IsZeroConstruct = false } ; enum { SupportsFreezeMemoryImage = false } ; enum { SupportsElementAlignment = false } ; enum { SupportsSlackTracking = false } ; } ; template<AllocatorType> struct TAllocatorTraits : TAllocatorTraitsBase<AllocatorType> { } ; template<FromAllocatorType,ToAllocatorType> struct TCanMoveBetweenAllocators { enum { Value = false } ; } ; class FContainerAllocatorInterface { public : using SizeType = int32 ; enum { NeedsElementType = true } ; enum { RequireRangeCheck = true } ; template<ElementType> class ForElementType { void)",
    "insertText": "MoveToEmpty(ForElementType& Other)"
  },
  {
    "label": "MoveToEmptyFromOtherAllocator()",
    "kind": "Method",
    "detail": "Function (template<OtherAllocatorType> void)",
    "insertText": "MoveToEmptyFromOtherAllocator(typename OtherAllocatorType::template ForElementType<ElementType>& Other)"
  },
  {
    "label": "GetAllocation()",
    "kind": "Method",
    "detail": "Function (ElementType*)",
    "insertText": "GetAllocation()"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeAllocation(SizeType CurrentNum, SizeType NewMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeAllocation(SizeType CurrentNum, SizeType NewMax, SIZE_T NumBytesPerElement, uint32 AlignmentOfElement)"
  },
  {
    "label": "CalculateSlackReserve()",
    "kind": "Method",
    "detail": "Function (SizeType)",
    "insertText": "CalculateSlackReserve(SizeType NewMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackReserve()",
    "kind": "Method",
    "detail": "Function (SizeType)",
    "insertText": "CalculateSlackReserve(SizeType NewMax, SIZE_T NumBytesPerElement, uint32 AlignmentOfElement)"
  },
  {
    "label": "CalculateSlackShrink()",
    "kind": "Method",
    "detail": "Function (SizeType)",
    "insertText": "CalculateSlackShrink(SizeType NewMax, SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackShrink()",
    "kind": "Method",
    "detail": "Function (SizeType)",
    "insertText": "CalculateSlackShrink(SizeType NewMax, SizeType CurrentMax, SIZE_T NumBytesPerElement, uint32 AlignmentOfElement)"
  },
  {
    "label": "CalculateSlackGrow()",
    "kind": "Method",
    "detail": "Function (SizeType)",
    "insertText": "CalculateSlackGrow(SizeType NewMax, SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackGrow()",
    "kind": "Method",
    "detail": "Function (SizeType)",
    "insertText": "CalculateSlackGrow(SizeType NewMax, SizeType CurrentMax, SIZE_T NumBytesPerElement, uint32 AlignmentOfElement)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetAllocatedSize(SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "HasAllocation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasAllocation()"
  },
  {
    "label": "GetInitialCapacity()",
    "kind": "Method",
    "detail": "Function (SizeType)",
    "insertText": "GetInitialCapacity()"
  },
  {
    "label": "SlackTrackerLogNum()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SlackTrackerLogNum(SizeType NewNumUsed)"
  },
  {
    "label": "OnInvalidAlignedHeapAllocatorNum()",
    "kind": "Method",
    "detail": "Function (} ; typedef ForElementType<FScriptContainerElement> ForAnyElementType ; } ; namespace UE::Core::Private { [ [ noreturn ] ] void)",
    "insertText": "OnInvalidAlignedHeapAllocatorNum(int32 NewNum, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "OnInvalidSizedHeapAllocatorNum()",
    "kind": "Method",
    "detail": "Function ([ [ noreturn ] ] void)",
    "insertText": "OnInvalidSizedHeapAllocatorNum(int32 IndexSize, int64 NewNum, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "ForAnyElementType()",
    "kind": "Method",
    "detail": "Function (} template<uint32 Alignment = DEFAULT_ALIGNMENT> class TAlignedHeapAllocator { public : using SizeType = int32 ; enum { NeedsElementType = false } ; enum { RequireRangeCheck = true } ; class ForAnyElementType { public :)",
    "insertText": "ForAnyElementType() : Data(nullptr)"
  },
  {
    "label": "MoveToEmpty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MoveToEmpty(ForAnyElementType& Other)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (# if UE_ENABLE_ARRAY_SLACK_TRACKING)",
    "insertText": "Free(Data)"
  },
  {
    "label": "ForAnyElementType()",
    "kind": "Method",
    "detail": "Function (# endif } Data = Other . Data ; Other . Data = nullptr ; } ~)",
    "insertText": "ForAnyElementType()"
  },
  {
    "label": "OnInvalidAlignedHeapAllocatorNum()",
    "kind": "Method",
    "detail": "Function (UE::Core::)",
    "insertText": "OnInvalidAlignedHeapAllocatorNum(NewMax, NumBytesPerElement)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (} # if UE_ENABLE_ARRAY_SLACK_TRACKING)",
    "insertText": "Data(FScriptContainerElement*)FArraySlackTrackingHeader::Realloc(Data, NewMax, NumBytesPerElement, Alignment > alignof(FArraySlackTrackingHeader) ? Alignment : alignof(FArraySlackTrackingHeader))"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "Data(FScriptContainerElement*)FMemory::Realloc( Data, NewMax*NumBytesPerElement, Alignment)"
  },
  {
    "label": "UpdateNumUsed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateNumUsed(Data, (int64)NewNumUsed)"
  },
  {
    "label": "DisableSlackTracking()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DisableSlackTracking()"
  },
  {
    "label": "DisableTracking()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisableTracking(Data)"
  },
  {
    "label": "ForAnyElementType()",
    "kind": "Method",
    "detail": "Function (} # endif private :)",
    "insertText": "ForAnyElementType(const ForAnyElementType&)"
  },
  {
    "label": "MinimumAlignment()",
    "kind": "Method",
    "detail": "Function (FScriptContainerElement* Data ; } ; template<ElementType> class ForElementType : public ForAnyElementType { SIZE_T)",
    "insertText": "MinimumAlignment(Alignment <= __STDCPP_DEFAULT_NEW_ALIGNMENT__)"
  },
  {
    "label": "ForElementType()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "ForElementType()"
  },
  {
    "label": "UE_STATIC_DEPRECATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_STATIC_DEPRECATE(5.0, alignof(ElementType) > MinimumAlignment, \"Using TAlignedHeapAllocator with an alignment lower than the element type's alignment - please update the alignment parameter\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } ; } ; template<uint32 Alignment> struct TAllocatorTraits<TAlignedHeapAllocator<Alignment>> : TAllocatorTraitsBase<TAlignedHeapAllocator<Alignment>> { enum { IsZeroConstruct = true } ; enum { SupportsSlackTracking = true } ; } ; template<int IndexSize> struct TBitsToSizeType {)",
    "insertText": "static_assert(IndexSize == IndexSize+1, \"Unsupported allocator index size.\")"
  },
  {
    "label": "MoveToEmptyFromOtherAllocator()",
    "kind": "Method",
    "detail": "Function (} template<OtherAllocator> void)",
    "insertText": "MoveToEmptyFromOtherAllocator(typename OtherAllocator::ForAnyElementType& Other)"
  },
  {
    "label": "TSizedHeapAllocator()",
    "kind": "Method",
    "detail": "Function (this -> MoveToEmptyFromOtherAllocator<)",
    "insertText": "TSizedHeapAllocator(Other)"
  },
  {
    "label": "NumBytesPerElement()",
    "kind": "Method",
    "detail": "Function (bool bInvalidResize = NewMax<0 | | NumBytesPerElement<1 | |)",
    "insertText": "NumBytesPerElement(SIZE_T)"
  },
  {
    "label": "bInvalidResize()",
    "kind": "Method",
    "detail": "Function (bInvalidResize =)",
    "insertText": "bInvalidResize(SIZE_T)(USizeType)NewMax > (SIZE_T)TNumericLimits<SizeType>::Max()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(UNLIKELY(bInvalidResize))"
  },
  {
    "label": "OnInvalidSizedHeapAllocatorNum()",
    "kind": "Method",
    "detail": "Function (UE::Core::)",
    "insertText": "OnInvalidSizedHeapAllocatorNum(IndexSize, NewMax, NumBytesPerElement)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (} # if UE_ENABLE_ARRAY_SLACK_TRACKING)",
    "insertText": "Data(FScriptContainerElement*)FArraySlackTrackingHeader::Realloc(Data, NewMax, NumBytesPerElement, 0)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "Data(FScriptContainerElement*)BaseMallocType::Realloc( Data, NewMax*NumBytesPerElement)"
  },
  {
    "label": "bInvalidResize()",
    "kind": "Method",
    "detail": "Function (bInvalidResize =)",
    "insertText": "bInvalidResize((SIZE_T)(USizeType)NewMax > (SIZE_T)TNumericLimits<SizeType>::Max() / NumBytesPerElement)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (} # if UE_ENABLE_ARRAY_SLACK_TRACKING)",
    "insertText": "Data(FScriptContainerElement*)FArraySlackTrackingHeader::Realloc(Data, NewMax, NumBytesPerElement, AlignmentOfElement > alignof(FArraySlackTrackingHeader) ? AlignmentOfElement : alignof(FArraySlackTrackingHeader))"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "Data(FScriptContainerElement*)BaseMallocType::Realloc( Data, NewMax*NumBytesPerElement, AlignmentOfElement)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# endif template<uint8 IndexSize> struct TAllocatorTraits<TSizedHeapAllocator<IndexSize>> : TAllocatorTraitsBase<TSizedHeapAllocator<IndexSize>> { enum { IsZeroConstruct = true } ; enum { SupportsElementAlignment = true } ; enum { SupportsSlackTracking = true } ; } ; using FHeapAllocator = TSizedHeapAllocator<3 2> ; template<uint8 FromIndexSize,uint8 ToIndexSize> struct TCanMoveBetweenAllocators<TSizedHeapAllocator<FromIndexSize>,TSizedHeapAllocator<ToIndexSize>> { enum { Value = true } ; } ; template<uint32 NumInlineElements,int IndexSize,SecondaryAllocator = FDefaultAllocator> class TSizedInlineAllocator { public : using SizeType = TBitsToSizeType<IndexSize>::Type ;)",
    "insertText": "static_assert(std::is_same_v<SizeType, typename SecondaryAllocator::SizeType>, \"Secondary allocator SizeType mismatch\")"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (RelocateConstructItems<)",
    "insertText": "ElementType((void*)InlineData, Other.GetInlineElements(), NumInlineElements)"
  },
  {
    "label": "MoveToEmpty()",
    "kind": "Method",
    "detail": "Function (} SecondaryData .)",
    "insertText": "MoveToEmpty(Other.SecondaryData)"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ResizeAllocation(SizeType CurrentNum, SizeType NewMax,SIZE_T NumBytesPerElement)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (RelocateConstructItems<)",
    "insertText": "ElementType((void*)InlineData, (ElementType*)SecondaryData.GetAllocation(), CurrentNum)"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (SecondaryData .)",
    "insertText": "ResizeAllocation(0,0,NumBytesPerElement)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(!SecondaryData.GetAllocation())"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (SecondaryData .)",
    "insertText": "ResizeAllocation(0,NewMax,NumBytesPerElement)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (RelocateConstructItems<)",
    "insertText": "ElementType((void*)SecondaryData.GetAllocation(), GetInlineElements(), CurrentNum)"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (} else { SecondaryData .)",
    "insertText": "ResizeAllocation(CurrentNum, NewMax, NumBytesPerElement)"
  },
  {
    "label": "SlackTrackerLogNum()",
    "kind": "Method",
    "detail": "Function (SecondaryData .)",
    "insertText": "SlackTrackerLogNum(NewNumUsed)"
  },
  {
    "label": "ForElementType()",
    "kind": "Method",
    "detail": "Function (} } # endif private :)",
    "insertText": "ForElementType(const ForElementType&)"
  },
  {
    "label": "GetInlineElements()",
    "kind": "Method",
    "detail": "Function (TTypeCompatibleBytes<ElementType> InlineData [ NumInlineElements ] ; SecondaryAllocator::template ForElementType<ElementType> SecondaryData ; ElementType*)",
    "insertText": "GetInlineElements()"
  },
  {
    "label": "ForElementType()",
    "kind": "Method",
    "detail": "Function (} } ; typedef void ForAnyElementType ; } ; template<uint32 NumInlineElements,int IndexSize,SecondaryAllocator> struct TAllocatorTraits<TSizedInlineAllocator<NumInlineElements,IndexSize,SecondaryAllocator>> : TAllocatorTraitsBase<TSizedInlineAllocator<NumInlineElements,IndexSize,SecondaryAllocator>> { enum { SupportsSlackTracking = true } ; } ; template<uint32 NumInlineElements,SecondaryAllocator = FDefaultAllocator> using TInlineAllocator = TSizedInlineAllocator<NumInlineElements,3 2,SecondaryAllocator> ; template<uint32 NumInlineElements,SecondaryAllocator = FDefaultAllocator64> using TInlineAllocator64 = TSizedInlineAllocator<NumInlineElements,6 4,SecondaryAllocator> ; template<uint32 NumInlineElements> class TNonRelocatableInlineAllocator { public : using SizeType = int32 ; enum { NeedsElementType = true } ; enum { RequireRangeCheck = true } ; template<ElementType> class ForElementType { public :)",
    "insertText": "ForElementType() : Data(GetInlineElements())"
  },
  {
    "label": "UE_STATIC_DEPRECATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_STATIC_DEPRECATE(5.0, alignof(ElementType) > __STDCPP_DEFAULT_NEW_ALIGNMENT__, \"TNonRelocatableInlineAllocator uses GMalloc's default alignment, which is lower than the element type's alignment - please consider a different approach\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif })",
    "insertText": "if(Other.HasAllocation())"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (RelocateConstructItems<)",
    "insertText": "ElementType(GetInlineElements(), Other.GetInlineElements(), NumInlineElements)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (RelocateConstructItems<)",
    "insertText": "ElementType(GetInlineElements(), Data, CurrentNum)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(HasAllocation())"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (# if UE_ENABLE_ARRAY_SLACK_TRACKING)",
    "insertText": "Data(ElementType*)FArraySlackTrackingHeader::Realloc(Data, (int32)NewMax, (int32)NumBytesPerElement, 0)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "Data(ElementType*)FMemory::Realloc(Data, NewMax*NumBytesPerElement)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (# endif } else { # if UE_ENABLE_ARRAY_SLACK_TRACKING)",
    "insertText": "Data(ElementType*)FArraySlackTrackingHeader::Realloc(nullptr, (int32)NewMax, (int32)NumBytesPerElement, 0)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "Data(ElementType*)FMemory::Realloc(nullptr, NewMax*NumBytesPerElement)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (# endif RelocateConstructItems<)",
    "insertText": "ElementType(Data, GetInlineElements(), CurrentNum)"
  },
  {
    "label": "TrackingHeader()",
    "kind": "Method",
    "detail": "Function (FArraySlackTrackingHeader*)",
    "insertText": "TrackingHeader(FArraySlackTrackingHeader*)((uint8*)Data - sizeof(FArraySlackTrackingHeader))"
  },
  {
    "label": "UpdateNumUsed()",
    "kind": "Method",
    "detail": "Function (TrackingHeader ->)",
    "insertText": "UpdateNumUsed((int64)NewNumUsed)"
  },
  {
    "label": "NumBitsPerDWORD()",
    "kind": "Method",
    "detail": "Function (} } ; typedef void ForAnyElementType ; } ; # define)",
    "insertText": "NumBitsPerDWORD((int32)32) #define NumBitsPerDWORDLogTwo ((int32)5)"
  },
  {
    "label": "InlineBitArrayDWORDs()",
    "kind": "Method",
    "detail": "Function (public : typedef InElementAllocator ElementAllocator ; typedef InBitArrayAllocator BitArrayAllocator ; } ; template<uint32 Alignment = DEFAULT_ALIGNMENT,InElementAllocator = TAlignedHeapAllocator<Alignment>,InBitArrayAllocator = FDefaultBitArrayAllocator> class TAlignedSparseArrayAllocator { public : typedef InElementAllocator ElementAllocator ; typedef InBitArrayAllocator BitArrayAllocator ; } ; template<uint32 NumInlineElements,SecondaryAllocator = TSparseArrayAllocator<FDefaultAllocator,FDefaultAllocator>> class TInlineSparseArrayAllocator { private : enum {)",
    "insertText": "InlineBitArrayDWORDs(NumInlineElements + NumBitsPerDWORD - 1)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (public : typedef TFixedAllocator<NumInlineElements> ElementAllocator ; typedef TFixedAllocator<InlineBitArrayDWORDs> BitArrayAllocator ; } ; # if !)",
    "insertText": "defined(DEFAULT_NUMBER_OF_ELEMENTS_PER_HASH_BUCKET)"
  },
  {
    "label": "GetNumberOfHashBuckets()",
    "kind": "Method",
    "detail": "Function (public : uint32)",
    "insertText": "GetNumberOfHashBuckets(uint32 NumHashedElements)"
  },
  {
    "label": "NumInlineHashBuckets()",
    "kind": "Method",
    "detail": "Function (} return 1 ; } typedef InSparseArrayAllocator SparseArrayAllocator ; typedef InHashAllocator HashAllocator ; } ; template<InSparseArrayAllocator,InHashAllocator,uint32 AverageNumberOfElementsPerHashBucket,uint32 BaseNumberOfHashBuckets,uint32 MinNumberOfHashedElements> struct TAllocatorTraits<TSetAllocator<InSparseArrayAllocator,InHashAllocator,AverageNumberOfElementsPerHashBucket,BaseNumberOfHashBuckets,MinNumberOfHashedElements>> : TAllocatorTraitsBase<TSetAllocator<InSparseArrayAllocator,InHashAllocator,AverageNumberOfElementsPerHashBucket,BaseNumberOfHashBuckets,MinNumberOfHashedElements>> { enum { SupportsFreezeMemoryImage = TAllocatorTraits<InSparseArrayAllocator>::SupportsFreezeMemoryImage&& TAllocatorTraits<InHashAllocator>::SupportsFreezeMemoryImage,} ; } ; template<uint32 NumInlineElements,SecondaryAllocator = TSetAllocator<TSparseArrayAllocator<FDefaultAllocator,FDefaultAllocator>,FDefaultAllocator>,uint32 AverageNumberOfElementsPerHashBucket = DEFAULT_NUMBER_OF_ELEMENTS_PER_HASH_BUCKET,uint32 MinNumberOfHashedElements = DEFAULT_MIN_NUMBER_OF_HASHED_ELEMENTS> class TInlineSetAllocator { private : enum {)",
    "insertText": "NumInlineHashBuckets(NumInlineElements + AverageNumberOfElementsPerHashBucket - 1)"
  },
  {
    "label": "RoundUpToPowerOfTwo()",
    "kind": "Method",
    "detail": "Function (const uint32 NumDesiredHashBuckets =)",
    "insertText": "RoundUpToPowerOfTwo(NumHashedElements / AverageNumberOfElementsPerHashBucket)"
  }
]