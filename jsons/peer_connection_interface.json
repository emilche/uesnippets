[
  {
    "label": "Thread",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Thread"
  },
  {
    "label": "StreamCollectionInterface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StreamCollectionInterface"
  },
  {
    "label": "StatsObserver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StatsObserver"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "RTC_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RTC_EXPORT"
  },
  {
    "label": "SignalingState",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "SignalingState"
  },
  {
    "label": "IceGatheringState",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "IceGatheringState"
  },
  {
    "label": "IceConnectionState",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "IceConnectionState"
  },
  {
    "label": "TlsCertPolicy",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "TlsCertPolicy"
  },
  {
    "label": "IceTransportsType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "IceTransportsType"
  },
  {
    "label": "BundlePolicy",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "BundlePolicy"
  },
  {
    "label": "RtcpMuxPolicy",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "RtcpMuxPolicy"
  },
  {
    "label": "TcpCandidatePolicy",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "TcpCandidatePolicy"
  },
  {
    "label": "CandidateNetworkPolicy",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "CandidateNetworkPolicy"
  },
  {
    "label": "ContinualGatheringPolicy",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ContinualGatheringPolicy"
  },
  {
    "label": "PortAllocatorConfig",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PortAllocatorConfig"
  },
  {
    "label": "cricket",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cricket"
  },
  {
    "label": "RTCOfferAnswerOptions",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RTCOfferAnswerOptions"
  },
  {
    "label": "StatsOutputLevel",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "StatsOutputLevel"
  },
  {
    "label": "PeerConnectionObserver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PeerConnectionObserver"
  },
  {
    "label": "Options",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Options"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (# ifndef API_PEER_CONNECTION_INTERFACE_H_ # define API_PEER_CONNECTION_INTERFACE_H_ # include<stdint . h> # include<stdio . h> # include<functional> # include<memory> # include<string> # include<vector> # include \" absl / base / attributes . h \" # include \" absl / strings / string_view . h \" # include \" absl / types / optional . h \" # include \" api / adaptation / resource . h \" # include \" api / async_dns_resolver . h \" # include \" api / async_resolver_factory . h \" # include \" api / audio / audio_mixer . h \" # include \" api / audio_codecs / audio_decoder_factory . h \" # include \" api / audio_codecs / audio_encoder_factory . h \" # include \" api / audio_options . h \" # include \" api / call / call_factory_interface . h \" # include \" api / candidate . h \" # include \" api / crypto / crypto_options . h \" # include \" api / data_channel_interface . h \" # include \" api / dtls_transport_interface . h \" # include \" api / fec_controller . h \" # include \" api / field_trials_view . h \" # include \" api / ice_transport_interface . h \" # include \" api / jsep . h \" # include \" api / media_stream_interface . h \" # include \" api / media_types . h \" # include \" api / metronome / metronome . h \" # include \" api / neteq / neteq_factory . h \" # include \" api / network_state_predictor . h \" # include \" api / packet_socket_factory . h \" # include \" api / rtc_error . h \" # include \" api / rtc_event_log / rtc_event_log_factory_interface . h \" # include \" api / rtc_event_log_output . h \" # include \" api / rtp_parameters . h \" # include \" api / rtp_receiver_interface . h \" # include \" api / rtp_sender_interface . h \" # include \" api / rtp_transceiver_interface . h \" # include \" api / scoped_refptr . h \" # include \" api / sctp_transport_interface . h \" # include \" api / set_local_description_observer_interface . h \" # include \" api / set_remote_description_observer_interface . h \" # include \" api / stats / rtc_stats_collector_callback . h \" # include \" api / stats_types . h \" # include \" api / task_queue / task_queue_factory . h \" # include \" api / transport / bitrate_settings . h \" # include \" api / transport / enums . h \" # include \" api / transport / network_control . h \" # include \" api / transport / sctp_transport_factory_interface . h \" # include \" api / turn_customizer . h \" # include \" api / video / video_bitrate_allocator_factory . h \" # include \" call / rtp_transport_controller_send_factory_interface . h \" # include \" media / base / media_config . h \" # include \" media / base / media_engine . h \" # include \" p2p / base / port_allocator . h \" # include \" rtc_base / network . h \" # include \" rtc_base / network_constants . h \" # include \" rtc_base / network_monitor_factory . h \" # include \" rtc_base / ref_count . h \" # include \" rtc_base / rtc_certificate . h \" # include \" rtc_base / rtc_certificate_generator . h \" # include \" rtc_base / socket_address . h \" # include \" rtc_base / ssl_certificate . h \" # include \" rtc_base / ssl_stream_adapter . h \" # include \" rtc_base / system / rtc_export . h \" # include \" rtc_base / thread . h \" namespace rtc { class Thread ; } namespace webrtc { class StreamCollectionInterface : public rtc::RefCountInterface { public : size_t)",
    "insertText": "count()"
  },
  {
    "label": "at()",
    "kind": "Method",
    "detail": "Function (MediaStreamInterface*)",
    "insertText": "at(size_t index)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (MediaStreamInterface*)",
    "insertText": "find(const std::string& label)"
  },
  {
    "label": "FindAudioTrack()",
    "kind": "Method",
    "detail": "Function (MediaStreamTrackInterface*)",
    "insertText": "FindAudioTrack(const std::string& id)"
  },
  {
    "label": "FindVideoTrack()",
    "kind": "Method",
    "detail": "Function (MediaStreamTrackInterface*)",
    "insertText": "FindVideoTrack(const std::string& id)"
  },
  {
    "label": "StreamCollectionInterface()",
    "kind": "Method",
    "detail": "Function (protected : ~)",
    "insertText": "StreamCollectionInterface()"
  },
  {
    "label": "OnComplete()",
    "kind": "Method",
    "detail": "Function (} ; class StatsObserver : public rtc::RefCountInterface { public : void)",
    "insertText": "OnComplete(const StatsReports& reports)"
  },
  {
    "label": "StatsObserver()",
    "kind": "Method",
    "detail": "Function (protected : ~)",
    "insertText": "StatsObserver()"
  },
  {
    "label": "AsString()",
    "kind": "Method",
    "detail": "Function (} ; enum class SdpSemantics { kPlanB_DEPRECATED,kPlanB [ [ deprecated ] ] = kPlanB_DEPRECATED,kUnifiedPlan,} ; class RTC_EXPORT PeerConnectionInterface : public rtc::RefCountInterface { public : enum SignalingState { kStable,kHaveLocalOffer,kHaveLocalPrAnswer,kHaveRemoteOffer,kHaveRemotePrAnswer,kClosed,} ; absl::string_view)",
    "insertText": "AsString(SignalingState)"
  },
  {
    "label": "AsString()",
    "kind": "Method",
    "detail": "Function (enum IceGatheringState { kIceGatheringNew,kIceGatheringGathering,kIceGatheringComplete } ; absl::string_view)",
    "insertText": "AsString(IceGatheringState state)"
  },
  {
    "label": "AsString()",
    "kind": "Method",
    "detail": "Function (enum class PeerConnectionState { kNew,kConnecting,kConnected,kDisconnected,kFailed,kClosed,} ; absl::string_view)",
    "insertText": "AsString(PeerConnectionState state)"
  },
  {
    "label": "AsString()",
    "kind": "Method",
    "detail": "Function (enum IceConnectionState { kIceConnectionNew,kIceConnectionChecking,kIceConnectionConnected,kIceConnectionCompleted,kIceConnectionFailed,kIceConnectionDisconnected,kIceConnectionClosed,kIceConnectionMax,} ; absl::string_view)",
    "insertText": "AsString(IceConnectionState state)"
  },
  {
    "label": "IceServer()",
    "kind": "Method",
    "detail": "Function (enum TlsCertPolicy { kTlsCertPolicySecure,kTlsCertPolicyInsecureNoCheck,} ; struct RTC_EXPORT IceServer {)",
    "insertText": "IceServer()"
  },
  {
    "label": "IceServer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IceServer(const IceServer&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (std::string uri ; std::vector<std::string> urls ; std::string username ; std::string password ; TlsCertPolicy tls_cert_policy = kTlsCertPolicySecure ; std::string hostname ; std::vector<std::string> tls_alpn_protocols ; std::vector<std::string> tls_elliptic_curves ; bool)",
    "insertText": "operator(const IceServer& o)"
  },
  {
    "label": "RTCConfiguration()",
    "kind": "Method",
    "detail": "Function (} } ; typedef std::vector<IceServer> IceServers ; enum IceTransportsType { kNone,kRelay,kNoHost,kAll } ; enum BundlePolicy { kBundlePolicyBalanced,kBundlePolicyMaxBundle,kBundlePolicyMaxCompat } ; enum RtcpMuxPolicy { kRtcpMuxPolicyNegotiate,kRtcpMuxPolicyRequire,} ; enum TcpCandidatePolicy { kTcpCandidatePolicyEnabled,kTcpCandidatePolicyDisabled } ; enum CandidateNetworkPolicy { kCandidateNetworkPolicyAll,kCandidateNetworkPolicyLowCost } ; enum ContinualGatheringPolicy { GATHER_ONCE,GATHER_CONTINUALLY } ; struct PortAllocatorConfig { int min_port = 0 ; int max_port = 0 ; uint32_t flags = 0 ; } ; enum class RTCConfigurationType { kSafe,kAggressive } ; struct RTC_EXPORT RTCConfiguration {)",
    "insertText": "RTCConfiguration()"
  },
  {
    "label": "RTCConfiguration()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTCConfiguration(const RTCConfiguration&)"
  },
  {
    "label": "RTCConfiguration()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTCConfiguration(RTCConfigurationType type)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const RTCConfiguration& o)"
  },
  {
    "label": "dscp()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "dscp()"
  },
  {
    "label": "cpu_adaptation()",
    "kind": "Method",
    "detail": "Function (media_config . enable_dscp = enable ; } bool)",
    "insertText": "cpu_adaptation()"
  },
  {
    "label": "suspend_below_min_bitrate()",
    "kind": "Method",
    "detail": "Function (media_config . video . enable_cpu_adaptation = enable ; } bool)",
    "insertText": "suspend_below_min_bitrate()"
  },
  {
    "label": "prerenderer_smoothing()",
    "kind": "Method",
    "detail": "Function (media_config . video . suspend_below_min_bitrate = enable ; } bool)",
    "insertText": "prerenderer_smoothing()"
  },
  {
    "label": "experiment_cpu_load_estimator()",
    "kind": "Method",
    "detail": "Function (media_config . video . enable_prerenderer_smoothing = enable ; } bool)",
    "insertText": "experiment_cpu_load_estimator()"
  },
  {
    "label": "audio_rtcp_report_interval_ms()",
    "kind": "Method",
    "detail": "Function (media_config . video . experiment_cpu_load_estimator = enable ; } int)",
    "insertText": "audio_rtcp_report_interval_ms()"
  },
  {
    "label": "video_rtcp_report_interval_ms()",
    "kind": "Method",
    "detail": "Function (media_config . audio . rtcp_report_interval_ms = audio_rtcp_report_interval_ms ; } int)",
    "insertText": "video_rtcp_report_interval_ms()"
  },
  {
    "label": "min_port()",
    "kind": "Method",
    "detail": "Function (media_config . video . rtcp_report_interval_ms = video_rtcp_report_interval_ms ; } int)",
    "insertText": "min_port()"
  },
  {
    "label": "max_port()",
    "kind": "Method",
    "detail": "Function (port_allocator_config . min_port = port ; } int)",
    "insertText": "max_port()"
  },
  {
    "label": "port_allocator_flags()",
    "kind": "Method",
    "detail": "Function (port_allocator_config . max_port = port ; } uint32_t)",
    "insertText": "port_allocator_flags()"
  }
]