[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FPropertyStack",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPropertyStack"
  },
  {
    "label": "FPropertyStackScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPropertyStackScope"
  },
  {
    "label": "FSchemaHeader",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSchemaHeader"
  },
  {
    "label": "FSchemaView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSchemaView"
  },
  {
    "label": "FMemberId",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMemberId"
  },
  {
    "label": "FMemberInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMemberInfo"
  },
  {
    "label": "FMemberPacked",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMemberPacked"
  },
  {
    "label": "alignas",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "alignas"
  },
  {
    "label": "FMemberDeclaration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMemberDeclaration"
  },
  {
    "label": "FSchemaBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSchemaBuilder"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TMemberDeclaration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TMemberDeclaration"
  },
  {
    "label": "TSchemaBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSchemaBuilder"
  },
  {
    "label": "R",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "R"
  },
  {
    "label": "O",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "O"
  },
  {
    "label": "S",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "S"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / Map . h \" # include \" Misc / Optional . h \" # include \" UObject / GarbageCollection . h \" # include \" UObject / NameTypes . h \" # include \" UObject / ObjectPtr . h \" # include \" UObject / VerseTypesFwd . h \" #)",
    "insertText": "if(WITH_VERSE_VM && DO_GUARD_SLOW) || defined(__INTELLISENSE__) #include \"VerseVM/VVMRestValue.h\" #endif #ifndef UE_GC_DEBUGNAMES #define UE_GC_DEBUGNAMES (!UE_BUILD_SHIPPING)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (enum class EMemberType : uint8 { Stop,Jump,Reference,ReferenceArray,StructArray,StridedArray,SparseStructArray,FieldPath,FieldPathArray,FreezableReferenceArray,FreezableStructArray,Optional,DynamicallyTypedValue,ARO,SlowARO,MemberARO,# if WITH_VERSE_VM | |)",
    "insertText": "defined(__INTELLISENSE__)"
  },
  {
    "label": "ToName()",
    "kind": "Method",
    "detail": "Function (FName)",
    "insertText": "ToName(EMemberType Type)"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (enum class EOrigin : uint8 { Other,Blueprint } ; class FPropertyStack { public :)",
    "insertText": "UE_NONCOPYABLE(FPropertyStack)"
  },
  {
    "label": "FPropertyStack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPropertyStack()"
  },
  {
    "label": "GetPropertyPath()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "GetPropertyPath()"
  },
  {
    "label": "ConvertPathToProperties()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ConvertPathToProperties(UClass* ObjectClass, FName InPropertyPath, TArray<FProperty*>& OutProperties)"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (private : class FPropertyStackScope ; TArray<const FProperty*> Props ; } ; class FPropertyStackScope { FPropertyStack& Stack ; public :)",
    "insertText": "UE_NONCOPYABLE(FPropertyStackScope)"
  },
  {
    "label": "FPropertyStackScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPropertyStackScope(FPropertyStack& InStack, FProperty* Property) : Stack(InStack)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (Stack . Props .)",
    "insertText": "Push(Property)"
  },
  {
    "label": "FPropertyStackScope()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FPropertyStackScope()"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (Stack . Props .)",
    "insertText": "Pop()"
  },
  {
    "label": "FSchemaView()",
    "kind": "Method",
    "detail": "Function (} } ; struct FSchemaHeader { uint32 StructStride ; std::atomic<int32> RefCount ; } ; union FMemberWord ; class FSchemaView { uint64 OriginBit = 1 ; uint64 Handle ; public :)",
    "insertText": "FSchemaView() : Handle(0)"
  },
  {
    "label": "FSchemaView()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSchemaView(ENoInit)"
  },
  {
    "label": "FSchemaView()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSchemaView(FSchemaView View, EOrigin Origin) : FSchemaView(View.GetWords(), Origin)"
  },
  {
    "label": "FSchemaView()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSchemaView(const FMemberWord* Data, EOrigin Origin = EOrigin::Other) : Handle(reinterpret_cast<uint64>(Data) | static_cast<uint64>(Origin))"
  },
  {
    "label": "GetWords()",
    "kind": "Method",
    "detail": "Function (} const FMemberWord*)",
    "insertText": "GetWords()"
  },
  {
    "label": "GetOrigin()",
    "kind": "Method",
    "detail": "Function (} EOrigin)",
    "insertText": "GetOrigin()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "SetOrigin()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetOrigin(EOrigin Origin)"
  },
  {
    "label": "Handle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Handle(Handle & ~OriginBit) | static_cast<uint64>(Origin)"
  },
  {
    "label": "GetStructStride()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetStructStride()"
  },
  {
    "label": "GetHeader()",
    "kind": "Method",
    "detail": "Function (} FSchemaHeader&)",
    "insertText": "GetHeader()"
  },
  {
    "label": "TryGetHeader()",
    "kind": "Method",
    "detail": "Function (FSchemaHeader*)",
    "insertText": "TryGetHeader()"
  },
  {
    "label": "FMemberId()",
    "kind": "Method",
    "detail": "Function (} ; enum class EMemberlessId { Collector = 1,Class,Outer,ExternalPackage,ClassOuter,InitialReference,Max = InitialReference } ; class FMemberId { public :)",
    "insertText": "FMemberId(EMemberlessId Memberless) : Index(0), MemberlessId((uint32)Memberless)"
  },
  {
    "label": "FMemberId()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FMemberId(uint32 Idx) : Index(Idx), MemberlessId(0)"
  },
  {
    "label": "IsMemberless()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsMemberless()"
  },
  {
    "label": "AsMemberless()",
    "kind": "Method",
    "detail": "Function (} EMemberlessId)",
    "insertText": "AsMemberless()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(FMemberId A, FMemberId B)"
  },
  {
    "label": "StaticAssert()",
    "kind": "Method",
    "detail": "Function (} private : uint32 MemberlessIdBits = 3 ; uint32 IndexBits = 3 2 - MemberlessIdBits ; uint32 Index : IndexBits ; uint32 MemberlessId : MemberlessIdBits ; void)",
    "insertText": "StaticAssert()"
  },
  {
    "label": "GetMemberDebugInfo()",
    "kind": "Method",
    "detail": "Function (} ; struct FMemberInfo { int32 Offset ; FName Name ; } ; FMemberInfo)",
    "insertText": "GetMemberDebugInfo(FSchemaView Schema, FMemberId Id)"
  },
  {
    "label": "CountSchemas()",
    "kind": "Method",
    "detail": "Function (# if ! UE_BUILD_SHIPPING uint32)",
    "insertText": "CountSchemas(uint32& OutNumWords)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (# endif struct FMemberPacked { uint32 TypeBits = 5 ; uint32 OffsetBits = 1 6 - TypeBits ; uint32 OffsetRange = 1 u<<FMemberPacked::OffsetBits ; uint16 Type : TypeBits ; uint16 WordOffset : OffsetBits ; } ; using ObjectAROFn =)",
    "insertText": "void(*)(UObject*, FReferenceCollector&)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using StructAROFn =)",
    "insertText": "void(*)(void*, FReferenceCollector&)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (struct)",
    "insertText": "alignas(4)"
  },
  {
    "label": "ToWord()",
    "kind": "Method",
    "detail": "Function (uint16 WordOffset ; uint16 WordStride ; } ; union FMemberWord { FMemberPacked Members [ 4 ] ; FSchemaView InnerSchema { NoInit } ; ObjectAROFn ObjectARO ; StructAROFn StructARO ; FStridedLayout StridedLayout ; } ; FMemberWord)",
    "insertText": "ToWord(FSchemaView In)"
  },
  {
    "label": "ToWord()",
    "kind": "Method",
    "detail": "Function (FMemberWord Out ; Out . InnerSchema = In ; return Out ; } FMemberWord)",
    "insertText": "ToWord(StructAROFn In)"
  },
  {
    "label": "ToName()",
    "kind": "Method",
    "detail": "Function (FMemberWord Out ; Out . StructARO = In ; return Out ; } struct FMemberDeclaration { FName DebugName ; uint32 Offset = 0 ; EMemberType Type = EMemberType::Stop ; FMemberWord ExtraWord = { { } } ; } ; FName)",
    "insertText": "ToName(const char* Name)"
  },
  {
    "label": "ToName()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "ToName(FPropertyStack& Stack)"
  },
  {
    "label": "DeclareMember()",
    "kind": "Method",
    "detail": "Function (} template<NameType> FMemberDeclaration)",
    "insertText": "DeclareMember(NameType&& Name, uint32 Offset, EMemberType Type)"
  },
  {
    "label": "ToName()",
    "kind": "Method",
    "detail": "Function (FName DebugName = UE_GC_DEBUGNAMES ?)",
    "insertText": "ToName(Forward<NameType>(Name)) : ToName(Type)"
  },
  {
    "label": "FSchemaBuilder()",
    "kind": "Method",
    "detail": "Function (} class FSchemaBuilder { public :)",
    "insertText": "FSchemaBuilder(uint32 InStride, std::initializer_list<FMemberDeclaration> InMembers = {})"
  },
  {
    "label": "FSchemaBuilder()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FSchemaBuilder()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(FMemberDeclaration Member)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(FSchemaView SuperSchema)"
  },
  {
    "label": "Build()",
    "kind": "Method",
    "detail": "Function (FSchemaView)",
    "insertText": "Build(ObjectAROFn ARO = nullptr)"
  },
  {
    "label": "NumMembers()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "NumMembers()"
  },
  {
    "label": "TMemberDeclaration()",
    "kind": "Method",
    "detail": "Function (} private : TArray<FMemberDeclaration,TInlineAllocator<1 6>> Members ; const uint32 StructStride ; TOptional<FSchemaOwner> BuiltSchema ; } ; template<class T> struct TMemberDeclaration : FMemberDeclaration { template<. . . Ts>)",
    "insertText": "TMemberDeclaration(Ts&&... Args) : FMemberDeclaration(DeclareMember(Forward<Ts>(Args)...))"
  },
  {
    "label": "TSchemaBuilder()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T> class TSchemaBuilder : public FSchemaBuilder { public :)",
    "insertText": "TSchemaBuilder(std::initializer_list<TMemberDeclaration<T>> InMembers = {}) : FSchemaBuilder(sizeof(T), reinterpret_cast<std::initializer_list<FMemberDeclaration>&&>(InMembers))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Add(TMemberDeclaration<T> Member)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(Member)"
  },
  {
    "label": "MakeMember()",
    "kind": "Method",
    "detail": "Function (} } ; namespace Private { template<class T,class R> TMemberDeclaration<T>)",
    "insertText": "MakeMember(const char* Name, uint32 Offset, R T::*)"
  },
  {
    "label": "MakeMember()",
    "kind": "Method",
    "detail": "Function (} template<class T,class R> TMemberDeclaration<T>)",
    "insertText": "MakeMember(const char* Name, uint32 Offset, TArray<R> T::*)"
  },
  {
    "label": "MakeMember()",
    "kind": "Method",
    "detail": "Function (} template<class T,class O> TMemberDeclaration<T>)",
    "insertText": "MakeMember(const char* Name, uint32 Offset, TObjectPtr<O> T::*)"
  },
  {
    "label": "MakeMember()",
    "kind": "Method",
    "detail": "Function (} template<class T,class O> TMemberDeclaration<T>)",
    "insertText": "MakeMember(const char* Name, uint32 Offset, TArray<TObjectPtr<O>> T::*)"
  },
  {
    "label": "MakeNestedMember()",
    "kind": "Method",
    "detail": "Function (} template<class T,class S> TMemberDeclaration<T>)",
    "insertText": "MakeNestedMember(const char* Name, uint32 Offset, TArray<S> T::*, TSchemaBuilder<S>& InnerSchema)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if WITH_VERSE_VM | |)",
    "insertText": "defined(__INTELLISENSE__) #if DO_GUARD_SLOW static_assert(sizeof(::Verse::VValue) == sizeof(::Verse::VCell*), \"\")"
  },
  {
    "label": "MakeMember()",
    "kind": "Method",
    "detail": "Function (# endif template<class T> TMemberDeclaration<T>)",
    "insertText": "MakeMember(const char* Name, uint32 Offset, ::Verse::VRestValue T::*)"
  },
  {
    "label": "MakeMember()",
    "kind": "Method",
    "detail": "Function (} template<class T> TMemberDeclaration<T>)",
    "insertText": "MakeMember(const char* Name, uint32 Offset, TArray<::Verse::VRestValue> T::*)"
  },
  {
    "label": "MakeMember()",
    "kind": "Method",
    "detail": "Function (} template<class T,U> TMemberDeclaration<T>)",
    "insertText": "MakeMember(const char* Name, uint32 Offset, ::Verse::TWriteBarrier<U> T::*)"
  },
  {
    "label": "MakeMember()",
    "kind": "Method",
    "detail": "Function (} template<class T,U> TMemberDeclaration<T>)",
    "insertText": "MakeMember(const char* Name, uint32 Offset, TArray<::Verse::TWriteBarrier<U>> T::*)"
  },
  {
    "label": "_UE_EXPAND()",
    "kind": "Method",
    "detail": "Function (} # endif } # define)",
    "insertText": "_UE_EXPAND(x) x #define _UE_GC_MEMBER2(Type, Member) UE::GC::Private::MakeMember(#Member, offsetof(Type, Member), &Type::Member) #define _UE_GC_MEMBER3(Type, Member, InnerSchema) UE::GC::Private::MakeNestedMember(#Member, offsetof(Type, Member), &Type::Member, InnerSchema) #define _UE_GC_MEMBER(_1,_2,_3,CHOSEN_OVERLOAD,...) CHOSEN_OVERLOAD #define UE_GC_MEMBER(...) _UE_EXPAND(_UE_EXPAND(_UE_GC_MEMBER(__VA_ARGS__, _UE_GC_MEMBER3, _UE_GC_MEMBER2)) (__VA_ARGS__)) COREUOBJECT_API void DeclareIntrinsicSchema(UClass* Class, FSchemaView IntrinsicSchema)"
  },
  {
    "label": "DeclareIntrinsicMembers()",
    "kind": "Method",
    "detail": "Function (template<class T> void)",
    "insertText": "DeclareIntrinsicMembers(UClass* Class, std::initializer_list<TMemberDeclaration<T>> Members)"
  },
  {
    "label": "DeclareIntrinsicSchema()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeclareIntrinsicSchema(Class, TSchemaBuilder<T>(Members).Build())"
  },
  {
    "label": "GetIntrinsicSchema()",
    "kind": "Method",
    "detail": "Function (} FSchemaView)",
    "insertText": "GetIntrinsicSchema(UClass* Class)"
  }
]