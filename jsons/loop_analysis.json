[
  {
    "label": "loop_state",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "loop_state"
  },
  {
    "label": "loop_variable_state",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "loop_variable_state"
  },
  {
    "label": "loop_variable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "loop_variable"
  },
  {
    "label": "loop_terminator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "loop_terminator"
  },
  {
    "label": "loop_analysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "loop_analysis"
  },
  {
    "label": "analyze_loop_variables()",
    "kind": "Method",
    "detail": "Function (# pragma once # ifndef LOOP_ANALYSIS_H # define LOOP_ANALYSIS_H # include \" ir . h \" # include \" hash_table . h \" class loop_state*)",
    "insertText": "analyze_loop_variables(exec_list *instructions)"
  },
  {
    "label": "set_loop_controls()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "set_loop_controls(exec_list *instructions, loop_state *ls)"
  },
  {
    "label": "unroll_loops()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "unroll_loops(exec_list *instructions, loop_state *ls, unsigned max_iterations, _mesa_glsl_parse_state *state)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (class loop_variable_state : public exec_node { public : class loop_variable*)",
    "insertText": "get(const ir_variable *)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (class loop_variable*)",
    "insertText": "insert(ir_variable *)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (class loop_terminator*)",
    "insertText": "insert(ir_if *)"
  },
  {
    "label": "loop_variable_state()",
    "kind": "Method",
    "detail": "Function (ir_loop* loop ; exec_list variables ; exec_list constants ; exec_list induction_variables ; exec_list terminators ; hash_table* var_hash ; int max_iterations ; unsigned num_loop_jumps ; bool contains_calls ; bool only_builtin_calls ;)",
    "insertText": "loop_variable_state()"
  },
  {
    "label": "hash_table_ctor()",
    "kind": "Method",
    "detail": "Function (this -> max_iterations = - 1 ; this -> num_loop_jumps = 0 ; this -> contains_calls = false ; this -> only_builtin_calls = true ; this -> var_hash =)",
    "insertText": "hash_table_ctor(0, ir_hash_table_pointer_hash, ir_hash_table_pointer_compare)"
  },
  {
    "label": "hash_table_dtor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "hash_table_dtor(this->var_hash)"
  },
  {
    "label": "is_loop_constant()",
    "kind": "Method",
    "detail": "Function (} } ; class loop_variable : public exec_node { public : ir_variable* var ; bool read_before_write ; bool rhs_clean ; bool atomic_result ; bool conditional_assignment ; ir_assignment* first_assignment ; unsigned num_assignments ; ir_rvalue* iv_scale ; ir_variable* biv ; ir_rvalue* increment ; bool)",
    "insertText": "is_loop_constant()"
  },
  {
    "label": "is_const()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "is_const(this->num_assignments == 0) || ((this->num_assignments == 1) && !this->conditional_assignment && !this->read_before_write && !this->atomic_result && this->rhs_clean)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (loop_variable_state*)",
    "insertText": "get(const ir_loop *)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (loop_variable_state*)",
    "insertText": "insert(ir_loop *ir)"
  },
  {
    "label": "loop_state()",
    "kind": "Method",
    "detail": "Function (bool loop_found ; private :)",
    "insertText": "loop_state()"
  }
]