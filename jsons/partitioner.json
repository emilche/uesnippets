[
  {
    "label": "auto_partitioner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "auto_partitioner"
  },
  {
    "label": "simple_partitioner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "simple_partitioner"
  },
  {
    "label": "static_partitioner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "static_partitioner"
  },
  {
    "label": "affinity_partitioner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "affinity_partitioner"
  },
  {
    "label": "affinity_partition_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "affinity_partition_type"
  },
  {
    "label": "affinity_partitioner_base_v3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "affinity_partitioner_base_v3"
  },
  {
    "label": "tbb",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "tbb"
  },
  {
    "label": "partition_type_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "partition_type_base"
  },
  {
    "label": "start_scan",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "start_scan"
  },
  {
    "label": "start_for",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "start_for"
  },
  {
    "label": "start_reduce",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "start_reduce"
  },
  {
    "label": "start_deterministic_reduce",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "start_deterministic_reduce"
  },
  {
    "label": "flag_task",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "flag_task"
  },
  {
    "label": "range_vector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "range_vector"
  },
  {
    "label": "adaptive_mode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "adaptive_mode"
  },
  {
    "label": "proportion_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "proportion_helper"
  },
  {
    "label": "proportional_mode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "proportional_mode"
  },
  {
    "label": "linear_affinity_mode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "linear_affinity_mode"
  },
  {
    "label": "Mode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mode"
  },
  {
    "label": "dynamic_grainsize_mode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "dynamic_grainsize_mode"
  },
  {
    "label": "auto_partition_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "auto_partition_type"
  },
  {
    "label": "simple_partition_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "simple_partition_type"
  },
  {
    "label": "static_partition_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "static_partition_type"
  },
  {
    "label": "old_auto_partition_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "old_auto_partition_type"
  },
  {
    "label": "serial",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "serial"
  },
  {
    "label": "interface9",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "interface9"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "partition_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "partition_type"
  },
  {
    "label": "__TBB_task_duration()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_partitioner_H # define __TBB_partitioner_H # ifndef __TBB_INITIAL_CHUNKS # define __TBB_INITIAL_CHUNKS 2 # endif # ifndef __TBB_RANGE_POOL_CAPACITY # define __TBB_RANGE_POOL_CAPACITY 8 # endif # ifndef __TBB_INIT_DEPTH # define __TBB_INIT_DEPTH 5 # endif # ifndef __TBB_DEMAND_DEPTH_ADD # define __TBB_DEMAND_DEPTH_ADD 1 # endif # ifndef __TBB_STATIC_THRESHOLD # define __TBB_STATIC_THRESHOLD 4 0 0 0 0 # endif # if __TBB_DEFINE_MIC # define __TBB_NONUNIFORM_TASK_CREATION 1 # ifdef __TBB_time_stamp # define __TBB_USE_MACHINE_TIME_STAMPS 1 # define)",
    "insertText": "__TBB_task_duration() __TBB_STATIC_THRESHOLD #endif #endif #include \"task.h\" #include \"task_arena.h\" #include \"aligned_space.h\" #include \"atomic.h\" #include \"internal/_template_helpers.h\" #if defined(_MSC_VER) && !defined(__INTEL_COMPILER) #pragma warning (push) #pragma warning (disable: 4244)"
  },
  {
    "label": "get_initial_auto_partitioner_divisor()",
    "kind": "Method",
    "detail": "Function (class auto_partitioner ; class simple_partitioner ; class static_partitioner ; class affinity_partitioner ; namespace interface9 { namespace internal { class affinity_partition_type ; } } namespace internal { size_t __TBB_EXPORTED_FUNC)",
    "insertText": "get_initial_auto_partitioner_divisor()"
  },
  {
    "label": "affinity_partitioner_base_v3()",
    "kind": "Method",
    "detail": "Function (class affinity_partitioner_base_v3 : no_copy { class tbb::affinity_partitioner ; class tbb::interface9::internal::affinity_partition_type ; affinity_id* my_array ; size_t my_size ;)",
    "insertText": "affinity_partitioner_base_v3() : my_array(NULL), my_size(0)"
  },
  {
    "label": "affinity_partitioner_base_v3()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "affinity_partitioner_base_v3()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} void __TBB_EXPORTED_METHOD)",
    "insertText": "resize(unsigned factor)"
  },
  {
    "label": "set_affinity()",
    "kind": "Method",
    "detail": "Function (} ; class partition_type_base { public : void)",
    "insertText": "set_affinity(task &)"
  },
  {
    "label": "note_affinity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "note_affinity(task::affinity_id)"
  },
  {
    "label": "continue_after_execute_range()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "continue_after_execute_range()"
  },
  {
    "label": "spawn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn(b)"
  },
  {
    "label": "flag_task()",
    "kind": "Method",
    "detail": "Function (} } ; template<Range,Body,Partitioner> class start_scan ; } namespace serial { namespace interface9 { template<Range,Body,Partitioner> class start_for ; } } namespace interface9 { namespace internal { using namespace tbb::internal ; template<Range,Body,Partitioner> class start_for ; template<Range,Body,Partitioner> class start_reduce ; template<Range,Body,Partitioner> class start_deterministic_reduce ; class flag_task : public task { public : tbb::atomic<bool> my_child_stolen ;)",
    "insertText": "flag_task()"
  },
  {
    "label": "execute()",
    "kind": "Method",
    "detail": "Function (my_child_stolen = false ; } task*)",
    "insertText": "execute()"
  },
  {
    "label": "flag_task()",
    "kind": "Method",
    "detail": "Function (my_child_stolen)",
    "insertText": "flag_task(t.parent())"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (# if TBB_USE_THREADING_TOOLS flag . fetch_and_store<)",
    "insertText": "release(true)"
  },
  {
    "label": "is_peer_stolen()",
    "kind": "Method",
    "detail": "Function (# else flag = true ; # endif } bool)",
    "insertText": "is_peer_stolen(task &t)"
  },
  {
    "label": "range_vector()",
    "kind": "Method",
    "detail": "Function (} } ; typedef unsigned char depth_t ; template<T,depth_t MaxCapacity> class range_vector { depth_t my_head ; depth_t my_tail ; depth_t my_size ; depth_t my_depth [ MaxCapacity ] ; tbb::aligned_space<T,MaxCapacity> my_pool ; public :)",
    "insertText": "range_vector(const T& elem) : my_head(0), my_tail(0), my_size(1)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (my_depth [ 0 ] = 0 ;)",
    "insertText": "new(static_cast<void *>(my_pool.begin()) ) T(elem)"
  },
  {
    "label": "range_vector()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "range_vector()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "my_head()",
    "kind": "Method",
    "detail": "Function (depth_t prev = my_head ;)",
    "insertText": "my_head(my_head + 1)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(my_pool.begin()+my_head) T(my_pool.begin()[prev])"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (my_pool .)",
    "insertText": "begin()[prev].~T()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(my_pool.begin()+prev) T(my_pool.begin()[my_head], split())"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (my_depth [ my_head ] = + + my_depth [ prev ] ; my_size + + ; } } void)",
    "insertText": "pop_back()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_size > 0, \"range_vector::pop_back() with empty size\")"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (my_pool .)",
    "insertText": "begin()[my_head].~T()"
  },
  {
    "label": "my_head()",
    "kind": "Method",
    "detail": "Function (my_size - - ;)",
    "insertText": "my_head(my_head + MaxCapacity - 1)"
  },
  {
    "label": "pop_front()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pop_front()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_size > 0, \"range_vector::pop_front() with empty size\")"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (my_pool .)",
    "insertText": "begin()[my_tail].~T()"
  },
  {
    "label": "my_tail()",
    "kind": "Method",
    "detail": "Function (my_size - - ;)",
    "insertText": "my_tail(my_tail + 1)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "back()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_size > 0, \"range_vector::back() with empty size\")"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "front()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_size > 0, \"range_vector::front() with empty size\")"
  },
  {
    "label": "front_depth()",
    "kind": "Method",
    "detail": "Function (} depth_t)",
    "insertText": "front_depth()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_size > 0, \"range_vector::front_depth() with empty size\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_size > 0, \"range_vector::back_depth() with empty size\")"
  },
  {
    "label": "check_being_stolen()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "check_being_stolen(task &)"
  },
  {
    "label": "get_split()",
    "kind": "Method",
    "detail": "Function (} template<Range> split_type)",
    "insertText": "get_split()"
  },
  {
    "label": "self()",
    "kind": "Method",
    "detail": "Function (} Partition&)",
    "insertText": "self()"
  },
  {
    "label": "work_balance()",
    "kind": "Method",
    "detail": "Function (} template<StartType,Range> void)",
    "insertText": "work_balance(StartType &start, Range &range)"
  },
  {
    "label": "run_body()",
    "kind": "Method",
    "detail": "Function (start .)",
    "insertText": "run_body(range)"
  },
  {
    "label": "execute()",
    "kind": "Method",
    "detail": "Function (} template<StartType,Range> void)",
    "insertText": "execute(StartType &start, Range &range)"
  },
  {
    "label": "offer_work()",
    "kind": "Method",
    "detail": "Function (start .)",
    "insertText": "offer_work(split_obj)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(range.is_divisible() && self().is_divisible())"
  },
  {
    "label": "self()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "self().work_balance(start, range)"
  },
  {
    "label": "adaptive_mode()",
    "kind": "Method",
    "detail": "Function (} } ; template<Partition> struct adaptive_mode : partition_type_base<Partition> { typedef Partition my_partition ; size_t my_divisor ; const unsigned factor = 1 ;)",
    "insertText": "adaptive_mode() : my_divisor(tbb::internal::get_initial_auto_partitioner_divisor() / 4 * my_partition::factor)"
  },
  {
    "label": "adaptive_mode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "adaptive_mode(adaptive_mode &src, split) : my_divisor(do_split(src, split()))"
  },
  {
    "label": "do_split()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "do_split(adaptive_mode &src, split)"
  },
  {
    "label": "get_split()",
    "kind": "Method",
    "detail": "Function (} } ; template<Range> struct proportion_helper<Range,enable_if<Range::is_splittable_in_proportion,void>::type> { proportional_split)",
    "insertText": "get_split(size_t n)"
  },
  {
    "label": "right()",
    "kind": "Method",
    "detail": "Function (# if __TBB_NONUNIFORM_TASK_CREATION size_t)",
    "insertText": "right(n + 2)"
  },
  {
    "label": "proportional_split()",
    "kind": "Method",
    "detail": "Function (# else size_t right = n / 2 ; # endif size_t left = n - right ; return)",
    "insertText": "proportional_split(left, right)"
  },
  {
    "label": "proportional_mode()",
    "kind": "Method",
    "detail": "Function (} } ; template<Partition> struct proportional_mode : adaptive_mode<Partition> { typedef Partition my_partition ; using partition_type_base<Partition>::self ;)",
    "insertText": "proportional_mode() : adaptive_mode<Partition>()"
  },
  {
    "label": "proportional_mode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "proportional_mode(proportional_mode &src, split) : adaptive_mode<Partition>(src, split())"
  },
  {
    "label": "proportional_mode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "proportional_mode(proportional_mode &src, const proportional_split& split_obj)"
  },
  {
    "label": "self()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "self().my_divisor = do_split(src, split_obj)"
  },
  {
    "label": "do_split()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "do_split(proportional_mode &src, const proportional_split& split_obj)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (# if __TBB_ENABLE_RANGE_FEEDBACK size_t portion =)",
    "insertText": "size_t(float(src.my_divisor) * float(split_obj.right()) / float(split_obj.left() + split_obj.right()) + 0.5f)"
  },
  {
    "label": "right()",
    "kind": "Method",
    "detail": "Function (# else size_t portion = split_obj .)",
    "insertText": "right()"
  },
  {
    "label": "portion()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "portion(portion + my_partition::factor/2) & (0ul - my_partition::factor)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if __TBB_ENABLE_RANGE_FEEDBACK)",
    "insertText": "if(!portion)"
  },
  {
    "label": "is_divisible()",
    "kind": "Method",
    "detail": "Function (# endif src . my_divisor - = portion ; return portion ; } bool)",
    "insertText": "is_divisible()"
  },
  {
    "label": "get_initial_partition_head()",
    "kind": "Method",
    "detail": "Function (} } ; size_t)",
    "insertText": "get_initial_partition_head()"
  },
  {
    "label": "current_thread_index()",
    "kind": "Method",
    "detail": "Function (int current_index = tbb::)",
    "insertText": "current_thread_index()"
  },
  {
    "label": "linear_affinity_mode()",
    "kind": "Method",
    "detail": "Function (} template<Partition> struct linear_affinity_mode : proportional_mode<Partition> { size_t my_head ; size_t my_max_affinity ; using proportional_mode<Partition>::self ;)",
    "insertText": "linear_affinity_mode() : proportional_mode<Partition>(), my_head(get_initial_partition_head()), my_max_affinity(self().my_divisor)"
  },
  {
    "label": "linear_affinity_mode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "linear_affinity_mode(linear_affinity_mode &src, split) : proportional_mode<Partition>(src, split()) , my_head((src.my_head + src.my_divisor) % src.my_max_affinity), my_max_affinity(src.my_max_affinity)"
  },
  {
    "label": "linear_affinity_mode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "linear_affinity_mode(linear_affinity_mode &src, const proportional_split& split_obj) : proportional_mode<Partition>(src, split_obj) , my_head((src.my_head + src.my_divisor) % src.my_max_affinity), my_max_affinity(src.my_max_affinity)"
  },
  {
    "label": "set_affinity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_affinity(task &t)"
  },
  {
    "label": "dynamic_grainsize_mode()",
    "kind": "Method",
    "detail": "Function (} } ; template<class Mode> struct dynamic_grainsize_mode : Mode { using Mode::self ; # ifdef __TBB_USE_MACHINE_TIME_STAMPS tbb::internal::machine_tsc_t my_dst_tsc ; # endif enum { begin = 0,run,pass } my_delay ; depth_t my_max_depth ; const unsigned range_pool_size = __TBB_RANGE_POOL_CAPACITY ;)",
    "insertText": "dynamic_grainsize_mode(): Mode() #ifdef __TBB_USE_MACHINE_TIME_STAMPS , my_dst_tsc(0) #endif , my_delay(begin) , my_max_depth(__TBB_INIT_DEPTH)"
  },
  {
    "label": "dynamic_grainsize_mode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "dynamic_grainsize_mode(dynamic_grainsize_mode& p, split) : Mode(p, split()) #ifdef __TBB_USE_MACHINE_TIME_STAMPS , my_dst_tsc(0) #endif , my_delay(pass) , my_max_depth(p.my_max_depth)"
  },
  {
    "label": "dynamic_grainsize_mode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "dynamic_grainsize_mode(dynamic_grainsize_mode& p, const proportional_split& split_obj) : Mode(p, split_obj) #ifdef __TBB_USE_MACHINE_TIME_STAMPS , my_dst_tsc(0) #endif , my_delay(begin) , my_max_depth(p.my_max_depth)"
  },
  {
    "label": "check_being_stolen()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "check_being_stolen(task &t)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (# if __TBB_USE_OPTIONAL_RTTI)",
    "insertText": "__TBB_ASSERT(dynamic_cast<flag_task*>(t.parent()), 0)"
  },
  {
    "label": "mark_task_stolen()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "mark_task_stolen(t)"
  },
  {
    "label": "max_depth()",
    "kind": "Method",
    "detail": "Function (my_max_depth + = __TBB_DEMAND_DEPTH_ADD ; return true ; } } return false ; } depth_t)",
    "insertText": "max_depth()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(base <= my_max_depth, 0)"
  },
  {
    "label": "range_pool()",
    "kind": "Method",
    "detail": "Function (} else { internal::range_vector<Range,range_pool_size>)",
    "insertText": "range_pool(range)"
  },
  {
    "label": "offer_work()",
    "kind": "Method",
    "detail": "Function (start .)",
    "insertText": "offer_work(range_pool.front(), range_pool.front_depth())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(range_pool.is_divisible(self().max_depth()))"
  },
  {
    "label": "run_body()",
    "kind": "Method",
    "detail": "Function (} start .)",
    "insertText": "run_body(range_pool.back())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(!range_pool.empty() && !start.is_cancelled())"
  },
  {
    "label": "check_for_demand()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "check_for_demand(task &t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (my_max_depth + = __TBB_DEMAND_DEPTH_ADD ; return true ; } } else)",
    "insertText": "if(begin == my_delay)"
  },
  {
    "label": "__TBB_time_stamp()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_USE_MACHINE_TIME_STAMPS my_delay = pass ; # else my_dst_tsc =)",
    "insertText": "__TBB_time_stamp() + __TBB_task_duration()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (my_delay = run ; } else)",
    "insertText": "if(run == my_delay)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_max_depth > 0, NULL)"
  },
  {
    "label": "auto_partition_type()",
    "kind": "Method",
    "detail": "Function (my_max_depth - - ; return false ; } my_delay = pass ; return true ; # endif } return false ; } } ; class auto_partition_type : public dynamic_grainsize_mode<adaptive_mode<auto_partition_type>> { public :)",
    "insertText": "auto_partition_type(const auto_partitioner& ) : dynamic_grainsize_mode<adaptive_mode<auto_partition_type> >()"
  },
  {
    "label": "auto_partition_type()",
    "kind": "Method",
    "detail": "Function (my_divisor* = __TBB_INITIAL_CHUNKS ; })",
    "insertText": "auto_partition_type(auto_partition_type& src, split) : dynamic_grainsize_mode<adaptive_mode<auto_partition_type> >(src, split())"
  },
  {
    "label": "simple_partition_type()",
    "kind": "Method",
    "detail": "Function (my_max_depth + = __TBB_DEMAND_DEPTH_ADD ; return true ; } else return false ; } } ; class simple_partition_type : public partition_type_base<simple_partition_type> { public :)",
    "insertText": "simple_partition_type(const simple_partitioner&)"
  },
  {
    "label": "simple_partition_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "simple_partition_type(const simple_partition_type&, split)"
  },
  {
    "label": "split()",
    "kind": "Method",
    "detail": "Function (split_type split_obj =)",
    "insertText": "split()"
  },
  {
    "label": "static_partition_type()",
    "kind": "Method",
    "detail": "Function (} } ; class static_partition_type : public linear_affinity_mode<static_partition_type> { public : typedef proportional_split split_type ;)",
    "insertText": "static_partition_type(const static_partitioner& ) : linear_affinity_mode<static_partition_type>()"
  },
  {
    "label": "static_partition_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "static_partition_type(static_partition_type& p, split ) : linear_affinity_mode<static_partition_type>(p, split())"
  },
  {
    "label": "static_partition_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "static_partition_type(static_partition_type& p, const proportional_split& split_obj ) : linear_affinity_mode<static_partition_type>(p, split_obj)"
  },
  {
    "label": "affinity_partition_type()",
    "kind": "Method",
    "detail": "Function (} } ; class affinity_partition_type : public dynamic_grainsize_mode<linear_affinity_mode<affinity_partition_type>> { const unsigned factor_power = 4 ; tbb::internal::affinity_id* my_array ; public : const unsigned factor = 1<<factor_power ; typedef proportional_split split_type ;)",
    "insertText": "affinity_partition_type(tbb::internal::affinity_partitioner_base_v3& ap ) : dynamic_grainsize_mode<linear_affinity_mode<affinity_partition_type> >()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT((factor&(factor-1))==0, \"factor must be power of two\")"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (ap .)",
    "insertText": "resize(factor)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (my_array = ap . my_array ; my_max_depth = factor_power + 1 ;)",
    "insertText": "__TBB_ASSERT(my_max_depth < __TBB_RANGE_POOL_CAPACITY, 0)"
  },
  {
    "label": "affinity_partition_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "affinity_partition_type(affinity_partition_type& p, split) : dynamic_grainsize_mode<linear_affinity_mode<affinity_partition_type> >(p, split()) , my_array(p.my_array)"
  },
  {
    "label": "affinity_partition_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "affinity_partition_type(affinity_partition_type& p, const proportional_split& split_obj) : dynamic_grainsize_mode<linear_affinity_mode<affinity_partition_type> >(p, split_obj) , my_array(p.my_array)"
  },
  {
    "label": "note_affinity()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "note_affinity(task::affinity_id id)"
  },
  {
    "label": "should_execute_range()",
    "kind": "Method",
    "detail": "Function (} } ; class old_auto_partition_type : public tbb::internal::partition_type_base { size_t num_chunks ; const size_t VICTIM_CHUNKS = 4 ; public : bool)",
    "insertText": "should_execute_range(const task &t)"
  },
  {
    "label": "old_auto_partition_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "old_auto_partition_type(const affinity_partitioner& ) : num_chunks(internal::get_initial_auto_partitioner_divisor()*__TBB_INITIAL_CHUNKS/4)"
  },
  {
    "label": "old_auto_partition_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "old_auto_partition_type(old_auto_partition_type& pt, split)"
  },
  {
    "label": "num_chunks()",
    "kind": "Method",
    "detail": "Function (num_chunks = pt .)",
    "insertText": "num_chunks(pt.num_chunks+1u)"
  },
  {
    "label": "simple_partitioner()",
    "kind": "Method",
    "detail": "Function (} } ; } } class simple_partitioner { public :)",
    "insertText": "simple_partitioner()"
  },
  {
    "label": "should_execute_range()",
    "kind": "Method",
    "detail": "Function (} private : template<Range,Body,Partitioner> class serial::interface9::start_for ; template<Range,Body,Partitioner> class interface9::internal::start_for ; template<Range,Body,Partitioner> class interface9::internal::start_reduce ; template<Range,Body,Partitioner> class interface9::internal::start_deterministic_reduce ; template<Range,Body,Partitioner> class internal::start_scan ; class partition_type : public internal::partition_type_base { public : bool)",
    "insertText": "should_execute_range(const task&)"
  },
  {
    "label": "partition_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "partition_type(const partition_type&, split)"
  },
  {
    "label": "auto_partitioner()",
    "kind": "Method",
    "detail": "Function (} } ; typedef interface9::internal::simple_partition_type task_partition_type ; typedef interface9::internal::simple_partition_type::split_type split_type ; } ; class auto_partitioner { public :)",
    "insertText": "auto_partitioner()"
  },
  {
    "label": "static_partitioner()",
    "kind": "Method",
    "detail": "Function (} private : template<Range,Body,Partitioner> class serial::interface9::start_for ; template<Range,Body,Partitioner> class interface9::internal::start_for ; template<Range,Body,Partitioner> class interface9::internal::start_reduce ; template<Range,Body,Partitioner> class internal::start_scan ; typedef interface9::internal::old_auto_partition_type partition_type ; typedef interface9::internal::auto_partition_type task_partition_type ; typedef interface9::internal::auto_partition_type::split_type split_type ; } ; class static_partitioner { public :)",
    "insertText": "static_partitioner()"
  },
  {
    "label": "affinity_partitioner()",
    "kind": "Method",
    "detail": "Function (} private : template<Range,Body,Partitioner> class serial::interface9::start_for ; template<Range,Body,Partitioner> class interface9::internal::start_for ; template<Range,Body,Partitioner> class interface9::internal::start_reduce ; template<Range,Body,Partitioner> class interface9::internal::start_deterministic_reduce ; template<Range,Body,Partitioner> class internal::start_scan ; typedef interface9::internal::old_auto_partition_type partition_type ; typedef interface9::internal::static_partition_type task_partition_type ; typedef interface9::internal::static_partition_type::split_type split_type ; } ; class affinity_partitioner : internal::affinity_partitioner_base_v3 { public :)",
    "insertText": "affinity_partitioner()"
  }
]