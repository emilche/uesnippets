[
  {
    "label": "BLUTILITY_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BLUTILITY_API"
  },
  {
    "label": "add",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "add"
  },
  {
    "label": "UCLASS()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" EditorUtilityObject . h \" # include \" IEditorUtilityExtension . h \" # include \" ActorActionUtility . generated . h \")",
    "insertText": "UCLASS(Abstract, hideCategories=(Object), Blueprintable)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() public: UE_DEPRECATED(5.2, \"GetSupportedClasses() instead, but ideally you're not requesting this directly and are instead using the FAssetActionUtilityPrototype to wrap access to an unload utility asset.\") UFUNCTION(BlueprintPure, BlueprintImplementableEvent, Category=\"Assets\", meta=(DeprecatedFunction, DeprecationMessage=\"If you were just returning a single class add it to the SupportedClasses array (you can find it listed in the Class Defaults). If you were doing complex logic to simulate having multiple classes act as filters, add them to the SupportedClasses array. If you were doing 'other' logic, you'll need to do that upon action execution.\")) UClass* GetSupportedClass()"
  }
]