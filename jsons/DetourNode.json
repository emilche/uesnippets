[
  {
    "label": "dtNodeFlags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "dtNodeFlags"
  },
  {
    "label": "dtNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "dtNode"
  },
  {
    "label": "dtNodePool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "dtNodePool"
  },
  {
    "label": "dtNodeQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "dtNodeQueue"
  },
  {
    "label": "DT_NULL_IDX()",
    "kind": "Method",
    "detail": "Function (# ifndef DETOURNODE_H # define DETOURNODE_H # include \" CoreMinimal . h \" # include \" Detour / DetourLargeWorldCoordinates . h \" # include \" Detour / DetourNavMesh . h \" enum dtNodeFlags { DT_NODE_OPEN = 0 x01,DT_NODE_CLOSED = 0 x02,} ; typedef unsigned short dtNodeIndex ; const dtNodeIndex)",
    "insertText": "DT_NULL_IDX(dtNodeIndex)"
  },
  {
    "label": "dtNodePool()",
    "kind": "Method",
    "detail": "Function (struct dtNode { dtReal pos [ 3 ] ; dtReal cost ; dtReal total ; unsigned int pidx : 3 0 ; unsigned int flags : 2 ; dtPolyRef id ; } ; class dtNodePool { public :)",
    "insertText": "dtNodePool(int maxNodes, int hashSize)"
  },
  {
    "label": "dtNodePool()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "dtNodePool()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const dtNodePool&)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear()"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (dtNode*)",
    "insertText": "getNode(dtPolyRef id)"
  },
  {
    "label": "findNode()",
    "kind": "Method",
    "detail": "Function (dtNode*)",
    "insertText": "findNode(dtPolyRef id)"
  },
  {
    "label": "getNodeIdx()",
    "kind": "Method",
    "detail": "Function (unsigned int)",
    "insertText": "getNodeIdx(const dtNode* node)"
  },
  {
    "label": "getNodeAtIdx()",
    "kind": "Method",
    "detail": "Function (} dtNode*)",
    "insertText": "getNodeAtIdx(unsigned int idx)"
  },
  {
    "label": "getMaxNodes()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "getMaxNodes()"
  },
  {
    "label": "dtNodeQueue()",
    "kind": "Method",
    "detail": "Function (m_maxRuntimeNodes = newMaxRuntimeNodes ; } private : dtNode* m_nodes ; dtNodeIndex* m_first ; dtNodeIndex* m_next ; const int m_maxNodes ; const int m_hashSize ; int m_maxRuntimeNodes ; int m_nodeCount ; } ; class dtNodeQueue { public :)",
    "insertText": "dtNodeQueue(int n)"
  },
  {
    "label": "dtNodeQueue()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "dtNodeQueue()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(dtNodeQueue&)"
  },
  {
    "label": "top()",
    "kind": "Method",
    "detail": "Function (m_size = 0 ; } dtNode*)",
    "insertText": "top()"
  },
  {
    "label": "trickleDown()",
    "kind": "Method",
    "detail": "Function (dtNode* result = m_heap [ 0 ] ; m_size - - ;)",
    "insertText": "trickleDown(0, m_heap[m_size])"
  },
  {
    "label": "bubbleUp()",
    "kind": "Method",
    "detail": "Function (m_size + + ;)",
    "insertText": "bubbleUp(m_size-1, node)"
  },
  {
    "label": "modify()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "modify(dtNode* node)"
  },
  {
    "label": "bubbleUp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bubbleUp(i, node)"
  },
  {
    "label": "getCapacity()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "getCapacity()"
  },
  {
    "label": "trickleDown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "trickleDown(int i, dtNode* node)"
  }
]