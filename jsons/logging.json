[
  {
    "label": "LoggingSeverity",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "LoggingSeverity"
  },
  {
    "label": "LogErrorContext",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "LogErrorContext"
  },
  {
    "label": "LogMessage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LogMessage"
  },
  {
    "label": "LogLineRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LogLineRef"
  },
  {
    "label": "LogSink",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LogSink"
  },
  {
    "label": "LogMetadata",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LogMetadata"
  },
  {
    "label": "LogMetadataErr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LogMetadataErr"
  },
  {
    "label": "LogMetadataTag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LogMetadataTag"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "Val",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Val"
  },
  {
    "label": "ToStringVal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ToStringVal"
  },
  {
    "label": "has_to_log_string",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_to_log_string"
  },
  {
    "label": "LogStreamer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LogStreamer"
  },
  {
    "label": "LogCall",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LogCall"
  },
  {
    "label": "LogMessageVoidify",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LogMessageVoidify"
  },
  {
    "label": "LogMessageForTesting",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LogMessageForTesting"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef RTC_BASE_LOGGING_H_ # define RTC_BASE_LOGGING_H_ # include<errno . h> # include<atomic> # include<sstream> # include<string> # include<type_traits> # include<utility> # include \" absl / base / attributes . h \" # include \" absl / meta / type_traits . h \" # include \" absl / strings / string_view . h \" # include \" absl / types / optional . h \" # include \" api / units / timestamp . h \" # include \" rtc_base / platform_thread_types . h \" # include \" rtc_base / strings / string_builder . h \" # include \" rtc_base / system / . h \" # if !)",
    "insertText": "defined(NDEBUG) || defined(DLOG_ALWAYS_ON) #define RTC_DLOG_IS_ON 1 #else #define RTC_DLOG_IS_ON 0 #endif #if defined(RTC_DISABLE_LOGGING) #define RTC_LOG_ENABLED() 0 #else #define RTC_LOG_ENABLED()"
  },
  {
    "label": "message()",
    "kind": "Method",
    "detail": "Function (enum LoggingSeverity { LS_VERBOSE,LS_INFO,LS_WARNING,LS_ERROR,LS_NONE,} ; enum LogErrorContext { ERRCTX_NONE,ERRCTX_ERRNO,ERRCTX_HRESULT,ERRCTX_EN = ERRCTX_ERRNO,ERRCTX_HR = ERRCTX_HRESULT,} ; class LogMessage ; class LogLineRef { public : absl::string_view)",
    "insertText": "message()"
  },
  {
    "label": "DefaultLogLine()",
    "kind": "Method",
    "detail": "Function (# else std::string)",
    "insertText": "DefaultLogLine()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (message_ =)",
    "insertText": "move(message)"
  },
  {
    "label": "set_filename()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_filename(absl::string_view filename)"
  },
  {
    "label": "set_line()",
    "kind": "Method",
    "detail": "Function (filename_ = filename ; } void)",
    "insertText": "set_line(int line)"
  },
  {
    "label": "set_thread_id()",
    "kind": "Method",
    "detail": "Function (line_ = line ; } void)",
    "insertText": "set_thread_id(absl::optional<PlatformThreadId> thread_id)"
  },
  {
    "label": "set_timestamp()",
    "kind": "Method",
    "detail": "Function (thread_id_ = thread_id ; } void)",
    "insertText": "set_timestamp(webrtc::Timestamp timestamp)"
  },
  {
    "label": "set_tag()",
    "kind": "Method",
    "detail": "Function (timestamp_ = timestamp ; } void)",
    "insertText": "set_tag(absl::string_view tag)"
  },
  {
    "label": "set_severity()",
    "kind": "Method",
    "detail": "Function (tag_ = tag ; } void)",
    "insertText": "set_severity(LoggingSeverity severity)"
  },
  {
    "label": "MinusInfinity()",
    "kind": "Method",
    "detail": "Function (severity_ = severity ; } std::string message_ ; absl::string_view filename_ ; int line_ = 0 ; absl::optional<PlatformThreadId> thread_id_ ; webrtc::Timestamp timestamp_ = webrtc::)",
    "insertText": "MinusInfinity()"
  },
  {
    "label": "LogSink()",
    "kind": "Method",
    "detail": "Function (absl::string_view tag_ = \" libjingle \" ; LoggingSeverity severity_ ; } ; class LogSink { public :)",
    "insertText": "LogSink()"
  },
  {
    "label": "OnLogMessage()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnLogMessage(const std::string& msg, LoggingSeverity severity, const char* tag)"
  },
  {
    "label": "OnLogMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnLogMessage(const std::string& message, LoggingSeverity severity)"
  },
  {
    "label": "OnLogMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnLogMessage(const std::string& message)"
  },
  {
    "label": "OnLogMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnLogMessage(absl::string_view msg, LoggingSeverity severity, const char* tag)"
  },
  {
    "label": "OnLogMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnLogMessage(absl::string_view message, LoggingSeverity severity)"
  },
  {
    "label": "OnLogMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnLogMessage(absl::string_view message)"
  },
  {
    "label": "OnLogMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnLogMessage(const LogLineRef& line)"
  },
  {
    "label": "RTC_LOG_ENABLED()",
    "kind": "Method",
    "detail": "Function (private : class::rtc::LogMessage ; # if)",
    "insertText": "RTC_LOG_ENABLED()"
  },
  {
    "label": "LogMetadata()",
    "kind": "Method",
    "detail": "Function (LoggingSeverity min_severity_ ; # endif } ; namespace webrtc_logging_impl { class LogMetadata { public :)",
    "insertText": "LogMetadata(const char* file, int line, LoggingSeverity severity) : file_(file), line_and_sev_(static_cast<uint32_t>(line) << 3 | severity)"
  },
  {
    "label": "LogMetadata()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "LogMetadata()"
  },
  {
    "label": "File()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "File()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} private : const char* file_ ; uint32_t line_and_sev_ ; } ;)",
    "insertText": "static_assert(std::is_trivial<LogMetadata>::value, \"\")"
  },
  {
    "label": "Type()",
    "kind": "Method",
    "detail": "Function (struct LogMetadataErr { LogMetadata meta ; LogErrorContext err_ctx ; int err ; } ; # ifdef WEBRTC_ANDROID struct LogMetadataTag { LoggingSeverity severity ; const char* tag ; } ; # endif enum class LogArgType : int8_t { kEnd = 0,kInt,kLong,kLongLong,kUInt,kULong,kULongLong,kDouble,kLongDouble,kCharP,kStdString,kStringView,kVoidP,kLogMetadata,kLogMetadataErr,# ifdef WEBRTC_ANDROID kLogMetadataTag,# endif } ; template<LogArgType N,T> struct Val { LogArgType)",
    "insertText": "Type()"
  },
  {
    "label": "MakeVal()",
    "kind": "Method",
    "detail": "Function (} # ifdef WEBRTC_ANDROID Val<LogArgType::kLogMetadataTag,LogMetadataTag>)",
    "insertText": "MakeVal(const LogMetadataTag& x)"
  },
  {
    "label": "MakeVal()",
    "kind": "Method",
    "detail": "Function (} ; template<T,absl::enable_if_t<has_to_log_string<T>::value>* = nullptr> ToStringVal)",
    "insertText": "MakeVal(const T& x)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (std::ostringstream os ; os<<x ; return { os .)",
    "insertText": "str()"
  },
  {
    "label": "RTC_LOG_ENABLED()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "RTC_LOG_ENABLED() void Log(const LogArgType* fmt, ...)"
  },
  {
    "label": "Log()",
    "kind": "Method",
    "detail": "Function (# else void)",
    "insertText": "Log(const LogArgType* fmt, ...)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} # endif template<. . . Ts> class LogStreamer ; template<> class LogStreamer<> final { public : template<U,V =)",
    "insertText": "decltype(MakeVal(std::declval<U>())), absl::enable_if_t<std::is_arithmetic<U>::value || std::is_enum<U>::value>* = nullptr> RTC_FORCE_INLINE LogStreamer<V> operator<<(U arg)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<U,V =)",
    "insertText": "decltype(MakeVal(std::declval<U>())), absl::enable_if_t<!std::is_arithmetic<U>::value && !std::is_enum<U>::value>* = nullptr> RTC_FORCE_INLINE LogStreamer<V> operator<<(const U& arg)"
  },
  {
    "label": "Call()",
    "kind": "Method",
    "detail": "Function (} template<. . . Us> RTC_FORCE_INLINE void)",
    "insertText": "Call(const Us&... args)"
  },
  {
    "label": "Log()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Log(t, args.GetVal()...)"
  },
  {
    "label": "LogStreamer()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,. . . Ts> class LogStreamer<T,Ts . . .> final { public : RTC_FORCE_INLINE)",
    "insertText": "LogStreamer(T arg, const LogStreamer<Ts...>* prior) : arg_(arg), prior_(prior)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<U,V =)",
    "insertText": "decltype(MakeVal(std::declval<U>())), absl::enable_if_t<std::is_arithmetic<U>::value || std::is_enum<U>::value>* = nullptr> RTC_FORCE_INLINE LogStreamer<V, T, Ts...> operator<<(U arg)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<U,V =)",
    "insertText": "decltype(MakeVal(std::declval<U>())), absl::enable_if_t<!std::is_arithmetic<U>::value && !std::is_enum<U>::value>* = nullptr> RTC_FORCE_INLINE LogStreamer<V, T, Ts...> operator<<(const U& arg)"
  },
  {
    "label": "Call()",
    "kind": "Method",
    "detail": "Function (prior_ ->)",
    "insertText": "Call(arg_, args...)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : T arg_ ; const LogStreamer<Ts . . .>* prior_ ; } ; class LogCall final { public : template<. . . Ts> RTC_FORCE_INLINE bool)",
    "insertText": "operator(const LogStreamer<Ts...>& streamer)"
  },
  {
    "label": "Call()",
    "kind": "Method",
    "detail": "Function (streamer .)",
    "insertText": "Call()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<. . . Ts> void)",
    "insertText": "operator(LogStreamer<Ts...>&& streamer)"
  },
  {
    "label": "LogMessage()",
    "kind": "Method",
    "detail": "Function (} } ; } class LogMessage { public : template<LoggingSeverity S> RTC_NO_INLINE)",
    "insertText": "LogMessage(const char* file, int line, std::integral_constant<LoggingSeverity, S>) : LogMessage(file, line, S)"
  },
  {
    "label": "RTC_LOG_ENABLED()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "RTC_LOG_ENABLED() LogMessage(const char* file, int line, LoggingSeverity sev)"
  },
  {
    "label": "LogMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LogMessage(const char* file, int line, LoggingSeverity sev, LogErrorContext err_ctx, int err)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(WEBRTC_ANDROID) LogMessage(const char* file, int line, LoggingSeverity sev, const char* tag)"
  },
  {
    "label": "LogMessage()",
    "kind": "Method",
    "detail": "Function (# endif ~)",
    "insertText": "LogMessage()"
  },
  {
    "label": "LogMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LogMessage(const LogMessage&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (LogMessage&)",
    "insertText": "operator(const LogMessage&)"
  },
  {
    "label": "AddTag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTag(const char* tag)"
  },
  {
    "label": "stream()",
    "kind": "Method",
    "detail": "Function (rtc::StringBuilder&)",
    "insertText": "stream()"
  },
  {
    "label": "LogStartTime()",
    "kind": "Method",
    "detail": "Function (int64_t)",
    "insertText": "LogStartTime()"
  },
  {
    "label": "WallClockStartTime()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "WallClockStartTime()"
  },
  {
    "label": "LogThreads()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LogThreads(bool on = true)"
  },
  {
    "label": "LogTimestamps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LogTimestamps(bool on = true)"
  },
  {
    "label": "LogToDebug()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LogToDebug(LoggingSeverity min_sev)"
  },
  {
    "label": "GetLogToDebug()",
    "kind": "Method",
    "detail": "Function (LoggingSeverity)",
    "insertText": "GetLogToDebug()"
  },
  {
    "label": "SetLogToStderr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLogToStderr(bool log_to_stderr)"
  },
  {
    "label": "AddLogToStream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddLogToStream(LogSink* stream, LoggingSeverity min_sev)"
  },
  {
    "label": "RemoveLogToStream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveLogToStream(LogSink* stream)"
  },
  {
    "label": "GetLogToStream()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetLogToStream(LogSink* stream = nullptr)"
  },
  {
    "label": "GetMinLogSeverity()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetMinLogSeverity()"
  },
  {
    "label": "ConfigureLogging()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConfigureLogging(absl::string_view params)"
  },
  {
    "label": "IsNoop()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsNoop(LoggingSeverity severity)"
  },
  {
    "label": "IsNoop()",
    "kind": "Method",
    "detail": "Function (template<LoggingSeverity S> RTC_NO_INLINE bool)",
    "insertText": "IsNoop()"
  },
  {
    "label": "LogMessage()",
    "kind": "Method",
    "detail": "Function (} # else)",
    "insertText": "LogMessage(const char* file, int line, LoggingSeverity sev)"
  },
  {
    "label": "RTC_LOG_ENABLED()",
    "kind": "Method",
    "detail": "Function (} # endif private : class LogMessageForTesting ; # if)",
    "insertText": "RTC_LOG_ENABLED() static void UpdateMinLogSeverity()"
  },
  {
    "label": "OutputToDebug()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutputToDebug(const LogLineRef& log_line_ref)"
  },
  {
    "label": "FinishPrintStream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FinishPrintStream()"
  },
  {
    "label": "UpdateMinLogSeverity()",
    "kind": "Method",
    "detail": "Function (LogLineRef log_line_ ; std::string extra_ ; LogSink* streams_ ; std::atomic<bool> streams_empty_ ; bool log_thread_ ; bool log_timestamp_ ; bool log_to_stderr_ ; # else void)",
    "insertText": "UpdateMinLogSeverity()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(WEBRTC_ANDROID) inline static void OutputToDebug(absl::string_view filename, int line, absl::string_view msg, LoggingSeverity severity, const char* tag)"
  },
  {
    "label": "OutputToDebug()",
    "kind": "Method",
    "detail": "Function (} # else void)",
    "insertText": "OutputToDebug(absl::string_view filename, int line, absl::string_view msg, LoggingSeverity severity)"
  },
  {
    "label": "RTC_LOG_FILE_LINE()",
    "kind": "Method",
    "detail": "Function (} # endif rtc::StringBuilder print_stream_ ; } ; # define)",
    "insertText": "RTC_LOG_FILE_LINE(sev, file, line) \\ ::rtc::webrtc_logging_impl::LogCall() & \\ ::rtc::webrtc_logging_impl::LogStreamer<>() \\ << ::rtc::webrtc_logging_impl::LogMetadata(file, line, sev) #define RTC_LOG(sev) \\ !rtc::LogMessage::IsNoop<::rtc::sev>() && \\ RTC_LOG_FILE_LINE(::rtc::sev, __FILE__, __LINE__) #define RTC_LOG_IF(sev, condition) \\ !rtc::LogMessage::IsNoop<::rtc::sev>() && (condition) && \\ RTC_LOG_FILE_LINE(::rtc::sev, __FILE__, __LINE__) #define RTC_LOG_V(sev) \\ !rtc::LogMessage::IsNoop(sev) && RTC_LOG_FILE_LINE(sev, __FILE__, __LINE__) #if (defined(__GNUC__) && !defined(NDEBUG)) || defined(WANT_PRETTY_LOG_F) #define RTC_LOG_F(sev) RTC_LOG(sev) << __PRETTY_FUNCTION__ << \": \" #define RTC_LOG_IF_F(sev, condition) \\ RTC_LOG_IF(sev, condition) << __PRETTY_FUNCTION__ << \": \" #define RTC_LOG_T_F(sev) \\ RTC_LOG(sev) << this << \": \" << __PRETTY_FUNCTION__ << \": \" #else #define RTC_LOG_F(sev) RTC_LOG(sev) << __FUNCTION__ << \": \" #define RTC_LOG_IF_F(sev, condition) \\ RTC_LOG_IF(sev, condition) << __FUNCTION__ << \": \" #define RTC_LOG_T_F(sev) RTC_LOG(sev) << this << \": \" << __FUNCTION__ << \": \" #endif #define RTC_LOG_CHECK_LEVEL(sev) ::rtc::LogCheckLevel(::rtc::sev) #define RTC_LOG_CHECK_LEVEL_V(sev) ::rtc::LogCheckLevel(sev) inline bool LogCheckLevel(LoggingSeverity sev)"
  },
  {
    "label": "RTC_LOG_E()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "RTC_LOG_E(sev, ctx, err) \\ !rtc::LogMessage::IsNoop<::rtc::sev>() && \\ ::rtc::webrtc_logging_impl::LogCall() & \\ ::rtc::webrtc_logging_impl::LogStreamer<>()"
  },
  {
    "label": "ctx()",
    "kind": "Method",
    "detail": "Function (\\ { __FILE__,__LINE__,::rtc::sev },::rtc::ERRCTX_ # #)",
    "insertText": "ctx(err) \\ } #define RTC_LOG_T(sev) RTC_LOG(sev) << this << \": \" #define RTC_LOG_ERRNO_EX(sev, err) RTC_LOG_E(sev, ERRNO, err) #define RTC_LOG_ERRNO(sev) RTC_LOG_ERRNO_EX(sev, errno) #if defined(WEBRTC_WIN) #define RTC_LOG_GLE_EX(sev, err) RTC_LOG_E(sev, HRESULT, err) #define RTC_LOG_GLE(sev) RTC_LOG_GLE_EX(sev, static_cast<int>(GetLastError())) #define RTC_LOG_ERR_EX(sev, err) RTC_LOG_GLE_EX(sev, err) #define RTC_LOG_ERR(sev) RTC_LOG_GLE(sev) #elif defined(__native_client__) && __native_client__ #define RTC_LOG_ERR_EX(sev, err) RTC_LOG(sev) #define RTC_LOG_ERR(sev) RTC_LOG(sev) #elif defined(WEBRTC_POSIX) #define RTC_LOG_ERR_EX(sev, err) RTC_LOG_ERRNO_EX(sev, err) #define RTC_LOG_ERR(sev) RTC_LOG_ERRNO(sev)"
  },
  {
    "label": "AdaptString()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "AdaptString(const char* str)"
  },
  {
    "label": "RTC_LOG_TAG()",
    "kind": "Method",
    "detail": "Function (} } # define)",
    "insertText": "RTC_LOG_TAG(sev, tag) \\ !rtc::LogMessage::IsNoop(sev) && \\ ::rtc::webrtc_logging_impl::LogCall() & \\ ::rtc::webrtc_logging_impl::LogStreamer<>()"
  }
]