[
  {
    "label": "NSVGrasterizer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NSVGrasterizer"
  },
  {
    "label": "NSVGedge",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NSVGedge"
  },
  {
    "label": "NSVGpoint",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NSVGpoint"
  },
  {
    "label": "NSVGactiveEdge",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NSVGactiveEdge"
  },
  {
    "label": "NSVGmemPage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NSVGmemPage"
  },
  {
    "label": "NSVGcachedPaint",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NSVGcachedPaint"
  },
  {
    "label": "NSVGpointFlags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "NSVGpointFlags"
  },
  {
    "label": "__declspec()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" HAL / Platform . h \" # if PLATFORM_WINDOWS # define NSVG_EXPORT)",
    "insertText": "__declspec(dllexport) #elif PLATFORM_MAC #define NSVG_EXPORT __attribute__((visibility(\"default\"))) #elif PLATFORM_LINUX #define NSVG_EXPORT __attribute__((visibility(\"default\"))) #elif PLATFORM_CONSOLE_DYNAMIC_LINK #define NSVG_EXPORT __declspec(dllexport)"
  },
  {
    "label": "nsvgCreateRasterizer()",
    "kind": "Method",
    "detail": "Function (# endif typedef struct NSVGrasterizer NSVGrasterizer ; NSVG_EXPORT NSVGrasterizer*)",
    "insertText": "nsvgCreateRasterizer()"
  },
  {
    "label": "nsvgRasterize()",
    "kind": "Method",
    "detail": "Function (NSVG_EXPORT void)",
    "insertText": "nsvgRasterize(NSVGrasterizer* r, NSVGimage* image, float tx, float ty, float scale, unsigned char* dst, int w, int h, int stride)"
  },
  {
    "label": "nsvgRasterizeFull()",
    "kind": "Method",
    "detail": "Function (NSVG_EXPORT void)",
    "insertText": "nsvgRasterizeFull(NSVGrasterizer* r, NSVGimage* image, float tx, float ty, float scalex, float scaley, unsigned char* dst, int w, int h, int stride)"
  },
  {
    "label": "nsvgDeleteRasterizer()",
    "kind": "Method",
    "detail": "Function (NSVG_EXPORT void)",
    "insertText": "nsvgDeleteRasterizer(NSVGrasterizer*)"
  },
  {
    "label": "NSVG__FIX()",
    "kind": "Method",
    "detail": "Function (# ifdef __cplusplus } # endif # endif # ifdef NANOSVGRAST_IMPLEMENTATION # include<math . h> # define NSVG__SUBSAMPLES 5 # define NSVG__FIXSHIFT 1 0 # define)",
    "insertText": "NSVG__FIX(1 << NSVG__FIXSHIFT) #define NSVG__FIXMASK (NSVG__FIX-1)"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (NSVGrasterizer*)",
    "insertText": "r(NSVGrasterizer*)malloc(sizeof(NSVGrasterizer))"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(r, 0, sizeof(NSVGrasterizer))"
  },
  {
    "label": "nsvgDeleteRasterizer()",
    "kind": "Method",
    "detail": "Function (r -> tessTol = 0 . 2 5 f ; r -> distTol = 0 . 0 1 f ; return r ; error :)",
    "insertText": "nsvgDeleteRasterizer(r)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NSVGmemPage* p ;)",
    "insertText": "if(r == NULL)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (p = r -> pages ;)",
    "insertText": "while(p != NULL)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (NSVGmemPage* next = p -> next ;)",
    "insertText": "free(p)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (p = next ; })",
    "insertText": "if(r->edges) free(r->edges)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(r)"
  },
  {
    "label": "nsvg__nextPage()",
    "kind": "Method",
    "detail": "Function (} NSVGmemPage*)",
    "insertText": "nsvg__nextPage(NSVGrasterizer* r, NSVGmemPage* cur)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NSVGmemPage* newp ;)",
    "insertText": "if(cur != NULL && cur->next != NULL)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(newp, 0, sizeof(NSVGmemPage))"
  },
  {
    "label": "nsvg__alloc()",
    "kind": "Method",
    "detail": "Function (p -> size = 0 ; p = p -> next ; } r -> curpage = r -> pages ; } unsigned char*)",
    "insertText": "nsvg__alloc(NSVGrasterizer* r, int size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned char* buf ;)",
    "insertText": "if(size > NSVG__MEMPAGE_SIZE)"
  },
  {
    "label": "nsvg__nextPage()",
    "kind": "Method",
    "detail": "Function (r -> curpage =)",
    "insertText": "nsvg__nextPage(r, r->curpage)"
  },
  {
    "label": "nsvg__ptEquals()",
    "kind": "Method",
    "detail": "Function (} buf =& r -> curpage -> mem [ r -> curpage -> size ] ; r -> curpage -> size + = size ; return buf ; } int)",
    "insertText": "nsvg__ptEquals(float x1, float y1, float x2, float y2, float tol)"
  },
  {
    "label": "nsvg__addPathPoint()",
    "kind": "Method",
    "detail": "Function (float dx = x2 - x1 ; float dy = y2 - y1 ; return dx* dx + dy* dy<tol* tol ; } void)",
    "insertText": "nsvg__addPathPoint(NSVGrasterizer* r, float x, float y, int flags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NSVGpoint* pt ;)",
    "insertText": "if(r->npoints > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pt =& r -> points [ r -> npoints - 1 ] ;)",
    "insertText": "if(nsvg__ptEquals(pt->x, pt->y, x, y, r->distTol))"
  },
  {
    "label": "flags()",
    "kind": "Method",
    "detail": "Function (pt ->)",
    "insertText": "flags(unsigned char)(pt->flags | flags)"
  },
  {
    "label": "points()",
    "kind": "Method",
    "detail": "Function (r -> cpoints = r -> cpoints> 0 ? r -> cpoints* 2 : 6 4 ; r ->)",
    "insertText": "points(NSVGpoint*)realloc(r->points, sizeof(NSVGpoint) * r->cpoints)"
  },
  {
    "label": "flags()",
    "kind": "Method",
    "detail": "Function (} pt =& r -> points [ r -> npoints ] ; pt -> x = x ; pt -> y = y ; pt ->)",
    "insertText": "flags(unsigned char)"
  },
  {
    "label": "nsvg__appendPathPoint()",
    "kind": "Method",
    "detail": "Function (r -> npoints + + ; } void)",
    "insertText": "nsvg__appendPathPoint(NSVGrasterizer* r, NSVGpoint pt)"
  },
  {
    "label": "nsvg__duplicatePoints()",
    "kind": "Method",
    "detail": "Function (} r -> points [ r -> npoints ] = pt ; r -> npoints + + ; } void)",
    "insertText": "nsvg__duplicatePoints(NSVGrasterizer* r)"
  },
  {
    "label": "points2()",
    "kind": "Method",
    "detail": "Function (r -> cpoints2 = r -> npoints ; r ->)",
    "insertText": "points2(NSVGpoint*)realloc(r->points2, sizeof(NSVGpoint) * r->cpoints2)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "memcpy(r->points2, r->points, sizeof(NSVGpoint) * r->npoints)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (r -> npoints2 = r -> npoints ; } void)",
    "insertText": "nsvg__addEdge(NSVGrasterizer* r, float x0, float y0, float x1, float y1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NSVGedge* e ;)",
    "insertText": "if(y0 == y1)"
  },
  {
    "label": "edges()",
    "kind": "Method",
    "detail": "Function (r -> cedges = r -> cedges> 0 ? r -> cedges* 2 : 6 4 ; r ->)",
    "insertText": "edges(NSVGedge*)realloc(r->edges, sizeof(NSVGedge) * r->cedges)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} e =& r -> edges [ r -> nedges ] ; r -> nedges + + ;)",
    "insertText": "if(y0 < y1)"
  },
  {
    "label": "nsvg__normalize()",
    "kind": "Method",
    "detail": "Function (e -> x0 = x0 ; e -> y0 = y0 ; e -> x1 = x1 ; e -> y1 = y1 ; e -> dir = 1 ; } else { e -> x0 = x1 ; e -> y0 = y1 ; e -> x1 = x0 ; e -> y1 = y0 ; e -> dir = - 1 ; } } float)",
    "insertText": "nsvg__normalize(float* x, float* y)"
  },
  {
    "label": "sqrtf()",
    "kind": "Method",
    "detail": "Function (float d =)",
    "insertText": "sqrtf((*x) * (*x) + (*y) * (*y))"
  },
  {
    "label": "nsvg__absf()",
    "kind": "Method",
    "detail": "Function (float id = 1 . 0 f / d ;* x* = id ;* y* = id ; } return d ; } float)",
    "insertText": "nsvg__absf(float x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float x12,y12,x23,y23,x34,y34,x123,y123,x234,y234,x1234,y1234 ; float dx,dy,d2,d3 ;)",
    "insertText": "if(level > 10)"
  },
  {
    "label": "x12()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "x12(x1 + x2)"
  },
  {
    "label": "y12()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "y12(y1 + y2)"
  },
  {
    "label": "x23()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "x23(x2 + x3)"
  },
  {
    "label": "y23()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "y23(y2 + y3)"
  },
  {
    "label": "x34()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "x34(x3 + x4)"
  },
  {
    "label": "y34()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "y34(y3 + y4)"
  },
  {
    "label": "x123()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "x123(x12 + x23)"
  },
  {
    "label": "y123()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "y123(y12 + y23)"
  },
  {
    "label": "nsvg__absf()",
    "kind": "Method",
    "detail": "Function (dx = x4 - x1 ; dy = y4 - y1 ; d2 =)",
    "insertText": "nsvg__absf(((x2 - x4) * dy - (y2 - y4) * dx))"
  },
  {
    "label": "nsvg__absf()",
    "kind": "Method",
    "detail": "Function (d3 =)",
    "insertText": "nsvg__absf(((x3 - x4) * dy - (y3 - y4) * dx))"
  },
  {
    "label": "nsvg__addPathPoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addPathPoint(r, x4, y4, type)"
  },
  {
    "label": "y234()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "y234(y23 + y34)"
  },
  {
    "label": "x1234()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "x1234(x123 + x234)"
  },
  {
    "label": "y1234()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "y1234(y123 + y234)"
  },
  {
    "label": "nsvg__flattenCubicBez()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__flattenCubicBez(r, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0)"
  },
  {
    "label": "nsvg__flattenCubicBez()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__flattenCubicBez(r, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type)"
  },
  {
    "label": "nsvg__flattenShape()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "nsvg__flattenShape(NSVGrasterizer* r, NSVGshape* shape, float scalex, float scaley)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int i,j ; NSVGpath* path ;)",
    "insertText": "for(path = shape->paths; path != NULL; path = path->next)"
  },
  {
    "label": "nsvg__addPathPoint()",
    "kind": "Method",
    "detail": "Function (r -> npoints = 0 ;)",
    "insertText": "nsvg__addPathPoint(r, path->pts[0] * scalex, path->pts[1] * scaley, 0)"
  },
  {
    "label": "nsvg__flattenCubicBez()",
    "kind": "Method",
    "detail": "Function (float* p =& path -> pts [ i* 2 ] ;)",
    "insertText": "nsvg__flattenCubicBez(r, p[0] * scalex, p[1] * scaley, p[2] * scalex, p[3] * scaley, p[4] * scalex, p[5] * scaley, p[6] * scalex, p[7] * scaley, 0, 0)"
  },
  {
    "label": "nsvg__initClosed()",
    "kind": "Method",
    "detail": "Function (} } enum NSVGpointFlags { NSVG_PT_CORNER = 0 x01,NSVG_PT_BEVEL = 0 x02,NSVG_PT_LEFT = 0 x04 } ; void)",
    "insertText": "nsvg__initClosed(NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)"
  },
  {
    "label": "nsvg__normalize()",
    "kind": "Method",
    "detail": "Function (float w = lineWidth* 0 . 5 f ; float dx = p1 -> x - p0 -> x ; float dy = p1 -> y - p0 -> y ; float len =)",
    "insertText": "nsvg__normalize(&dx, &dy)"
  },
  {
    "label": "nsvg__buttCap()",
    "kind": "Method",
    "detail": "Function (float px = p0 -> x + dx* len* 0 . 5 f,py = p0 -> y + dy* len* 0 . 5 f ; float dlx = dy,dly = - dx ; float lx = px - dlx* w,ly = py - dly* w ; float rx = px + dlx* w,ry = py + dly* w ; left -> x = lx ; left -> y = ly ; right -> x = rx ; right -> y = ry ; } void)",
    "insertText": "nsvg__buttCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int connect)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (float w = lineWidth* 0 . 5 f ; float px = p -> x,py = p -> y ; float dlx = dy,dly = - dx ; float lx = px - dlx* w,ly = py - dly* w ; float rx = px + dlx* w,ry = py + dly* w ;)",
    "insertText": "nsvg__addEdge(r, lx, ly, rx, ry)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addEdge(r, left->x, left->y, lx, ly)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addEdge(r, rx, ry, right->x, right->y)"
  },
  {
    "label": "nsvg__squareCap()",
    "kind": "Method",
    "detail": "Function (} left -> x = lx ; left -> y = ly ; right -> x = rx ; right -> y = ry ; } void)",
    "insertText": "nsvg__squareCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int connect)"
  },
  {
    "label": "NSVG_PI()",
    "kind": "Method",
    "detail": "Function (} left -> x = lx ; left -> y = ly ; right -> x = rx ; right -> y = ry ; } # ifndef NSVG_PI # define)",
    "insertText": "NSVG_PI(3.14159265358979323846264338327f) #endif static void nsvg__roundCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int ncap, int connect)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int i ; float w = lineWidth* 0 . 5 f ; float px = p -> x,py = p -> y ; float dlx = dy,dly = - dx ; float lx = 0,ly = 0,rx = 0,ry = 0,prevx = 0,prevy = 0 ;)",
    "insertText": "for(i = 0; i < ncap; i++)"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "a(float)i / (float)(ncap - 1)"
  },
  {
    "label": "cosf()",
    "kind": "Method",
    "detail": "Function (float ax =)",
    "insertText": "cosf(a) * w, ay = sinf(a)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float x = px - dlx* ax - dx* ay ; float y = py - dly* ax - dy* ay ;)",
    "insertText": "if(i > 0) nsvg__addEdge(r, prevx, prevy, x, y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (prevx = x ; prevy = y ;)",
    "insertText": "if(i == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lx = x ; ly = y ; } else)",
    "insertText": "if(i == ncap - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (rx = x ; ry = y ; } })",
    "insertText": "if(connect)"
  },
  {
    "label": "nsvg__bevelJoin()",
    "kind": "Method",
    "detail": "Function (} left -> x = lx ; left -> y = ly ; right -> x = rx ; right -> y = ry ; } void)",
    "insertText": "nsvg__bevelJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (float w = lineWidth* 0 . 5 f ; float dlx0 = p0 -> dy,dly0 = - p0 -> dx ; float dlx1 = p1 -> dy,dly1 = - p1 -> dx ; float lx0 = p1 ->)",
    "insertText": "x(dlx0 * w), ly0 = p1->y - (dly0 * w)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (float rx0 = p1 ->)",
    "insertText": "x(dlx0 * w), ry0 = p1->y + (dly0 * w)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (float lx1 = p1 ->)",
    "insertText": "x(dlx1 * w), ly1 = p1->y - (dly1 * w)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (float rx1 = p1 ->)",
    "insertText": "x(dlx1 * w), ry1 = p1->y + (dly1 * w)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addEdge(r, lx0, ly0, left->x, left->y)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addEdge(r, lx1, ly1, lx0, ly0)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addEdge(r, right->x, right->y, rx0, ry0)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addEdge(r, rx0, ry0, rx1, ry1)"
  },
  {
    "label": "nsvg__miterJoin()",
    "kind": "Method",
    "detail": "Function (left -> x = lx1 ; left -> y = ly1 ; right -> x = rx1 ; right -> y = ry1 ; } void)",
    "insertText": "nsvg__miterJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float w = lineWidth* 0 . 5 f ; float dlx0 = p0 -> dy,dly0 = - p0 -> dx ; float dlx1 = p1 -> dy,dly1 = - p1 -> dx ; float lx0,rx0,lx1,rx1 ; float ly0,ry0,ly1,ry1 ;)",
    "insertText": "if(p1->flags & NSVG_PT_LEFT)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (lx0 = lx1 = p1 -> x - p1 -> dmx* w ; ly0 = ly1 = p1 -> y - p1 -> dmy* w ;)",
    "insertText": "nsvg__addEdge(r, lx1, ly1, left->x, left->y)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (rx0 = p1 ->)",
    "insertText": "x(dlx0 * w)"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (ry0 = p1 ->)",
    "insertText": "y(dly0 * w)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (rx1 = p1 ->)",
    "insertText": "x(dlx1 * w)"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (ry1 = p1 ->)",
    "insertText": "y(dly1 * w)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (rx0 = rx1 = p1 -> x + p1 -> dmx* w ; ry0 = ry1 = p1 -> y + p1 -> dmy* w ;)",
    "insertText": "nsvg__addEdge(r, right->x, right->y, rx1, ry1)"
  },
  {
    "label": "nsvg__roundJoin()",
    "kind": "Method",
    "detail": "Function (} left -> x = lx1 ; left -> y = ly1 ; right -> x = rx1 ; right -> y = ry1 ; } void)",
    "insertText": "nsvg__roundJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth, int ncap)"
  },
  {
    "label": "atan2f()",
    "kind": "Method",
    "detail": "Function (int i,n ; float w = lineWidth* 0 . 5 f ; float dlx0 = p0 -> dy,dly0 = - p0 -> dx ; float dlx1 = p1 -> dy,dly1 = - p1 -> dx ; float a0 =)",
    "insertText": "atan2f(dly0, dlx0)"
  },
  {
    "label": "atan2f()",
    "kind": "Method",
    "detail": "Function (float a1 =)",
    "insertText": "atan2f(dly1, dlx1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float da = a1 - a0 ; float lx,ly,rx,ry ;)",
    "insertText": "if(da < NSVG_PI)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "n(int)ceilf((nsvg__absf(da) / NSVG_PI) * (float)ncap)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (lx = left -> x ; ly = left -> y ; rx = right -> x ; ry = right -> y ;)",
    "insertText": "for(i = 0; i < n; i++)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "u(float)i / (float)(n - 1)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (float lx1 = p1 -> x - ax,ly1 = p1 -> y - ay ; float rx1 = p1 -> x + ax,ry1 = p1 -> y + ay ;)",
    "insertText": "nsvg__addEdge(r, lx1, ly1, lx, ly)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addEdge(r, rx, ry, rx1, ry1)"
  },
  {
    "label": "nsvg__straightJoin()",
    "kind": "Method",
    "detail": "Function (lx = lx1 ; ly = ly1 ; rx = rx1 ; ry = ry1 ; } left -> x = lx ; left -> y = ly ; right -> x = rx ; right -> y = ry ; } void)",
    "insertText": "nsvg__straightJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p1, float lineWidth)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (float w = lineWidth* 0 . 5 f ; float lx = p1 ->)",
    "insertText": "x(p1->dmx * w), ly = p1->y - (p1->dmy * w)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (float rx = p1 ->)",
    "insertText": "x(p1->dmx * w), ry = p1->y + (p1->dmy * w)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addEdge(r, lx, ly, left->x, left->y)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addEdge(r, right->x, right->y, rx, ry)"
  },
  {
    "label": "nsvg__curveDivs()",
    "kind": "Method",
    "detail": "Function (left -> x = lx ; left -> y = ly ; right -> x = rx ; right -> y = ry ; } int)",
    "insertText": "nsvg__curveDivs(float r, float arc, float tol)"
  },
  {
    "label": "acosf()",
    "kind": "Method",
    "detail": "Function (float da =)",
    "insertText": "acosf(r / (r + tol))"
  },
  {
    "label": "divs()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "divs(int)ceilf(arc / da)"
  },
  {
    "label": "nsvg__curveDivs()",
    "kind": "Method",
    "detail": "Function (int ncap =)",
    "insertText": "nsvg__curveDivs(lineWidth * 0.5f, NSVG_PI, r->tessTol)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NSVGpoint left = { 0,0,0,0,0,0,0,0 },right = { 0,0,0,0,0,0,0,0 },firstLeft = { 0,0,0,0,0,0,0,0 },firstRight = { 0,0,0,0,0,0,0,0 } ; NSVGpoint* p0,* p1 ; int j,s,e ;)",
    "insertText": "if(closed)"
  },
  {
    "label": "nsvg__initClosed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__initClosed(&left, &right, p0, p1, lineWidth)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(j = s; j < e; ++j)"
  },
  {
    "label": "nsvg__straightJoin()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "nsvg__straightJoin(r, &left, &right, p1, lineWidth)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addEdge(r, firstLeft.x, firstLeft.y, left.x, left.y)"
  },
  {
    "label": "nsvg__addEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__addEdge(r, right.x, right.y, firstRight.x, firstRight.y)"
  },
  {
    "label": "nsvg__prepareStroke()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "nsvg__prepareStroke(NSVGrasterizer* r, float miterLimit, int lineJoin)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int i,j ; NSVGpoint* p0,* p1 ; p0 =& r -> points [ r -> npoints - 1 ] ; p1 =& r -> points [ 0 ] ;)",
    "insertText": "for(i = 0; i < r->npoints; i++)"
  },
  {
    "label": "nsvg__normalize()",
    "kind": "Method",
    "detail": "Function (p0 -> dx = p1 -> x - p0 -> x ; p0 -> dy = p1 -> y - p0 -> y ; p0 -> len =)",
    "insertText": "nsvg__normalize(&p0->dx, &p0->dy)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (p0 = p1 + + ; } p0 =& r -> points [ r -> npoints - 1 ] ; p1 =& r -> points [ 0 ] ;)",
    "insertText": "for(j = 0; j < r->npoints; j++)"
  },
  {
    "label": "dmx()",
    "kind": "Method",
    "detail": "Function (float dlx0,dly0,dlx1,dly1,dmr2,cross ; dlx0 = p0 -> dy ; dly0 = - p0 -> dx ; dlx1 = p1 -> dy ; dly1 = - p1 -> dx ; p1 ->)",
    "insertText": "dmx(dlx0 + dlx1)"
  },
  {
    "label": "dmy()",
    "kind": "Method",
    "detail": "Function (p1 ->)",
    "insertText": "dmy(dly0 + dly1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dmr2 = p1 -> dmx* p1 -> dmx + p1 -> dmy* p1 -> dmy ;)",
    "insertText": "if(dmr2 > 0.000001f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float s2 = 1 . 0 f / dmr2 ;)",
    "insertText": "if(s2 > 600.0f)"
  },
  {
    "label": "flags()",
    "kind": "Method",
    "detail": "Function (s2 = 6 0 0 . 0 f ; } p1 -> dmx* = s2 ; p1 -> dmy* = s2 ; } p1 ->)",
    "insertText": "flags(p1->flags & NSVG_PT_CORNER)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (flags |= NSVG_PT_LEFT)",
    "insertText": "if(cross > 0.0f)"
  },
  {
    "label": "nsvg__flattenShapeStroke()",
    "kind": "Method",
    "detail": "Function (p1 -> flags | = NSVG_PT_BEVEL ; } } p0 = p1 + + ; } } void)",
    "insertText": "nsvg__flattenShapeStroke(NSVGrasterizer* r, NSVGshape* shape, float scalex, float scaley)"
  },
  {
    "label": "strokeWidth()",
    "kind": "Method",
    "detail": "Function (int i,j,closed ; NSVGpath* path ; NSVGpoint* p0,* p1 ; float miterLimit = shape -> miterLimit ; int lineJoin = shape -> strokeLineJoin ; int lineCap = shape -> strokeLineCap ; float lineWidth = shape ->)",
    "insertText": "strokeWidth(scalex + scaley)"
  },
  {
    "label": "nsvg__addPathPoint()",
    "kind": "Method",
    "detail": "Function (r -> npoints = 0 ;)",
    "insertText": "nsvg__addPathPoint(r, path->pts[0] * scalex, path->pts[1] * scaley, NSVG_PT_CORNER)"
  },
  {
    "label": "nsvg__flattenCubicBez()",
    "kind": "Method",
    "detail": "Function (float* p =& path -> pts [ i* 2 ] ;)",
    "insertText": "nsvg__flattenCubicBez(r, p[0] * scalex, p[1] * scaley, p[2] * scalex, p[3] * scaley, p[4] * scalex, p[5] * scaley, p[6] * scalex, p[7] * scaley, 0, NSVG_PT_CORNER)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(r->npoints < 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (closed = path -> closed ; p0 =& r -> points [ r -> npoints - 1 ] ; p1 =& r -> points [ 0 ] ;)",
    "insertText": "if(nsvg__ptEquals(p0->x, p0->y, p1->x, p1->y, r->distTol))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (r -> npoints - - ; p0 =& r -> points [ r -> npoints - 1 ] ; closed = 1 ; })",
    "insertText": "if(shape->strokeDashCount > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int idash = 0,dashState = 1 ; float totalDist = 0,dashLen,allDashLen,dashOffset ; NSVGpoint cur ;)",
    "insertText": "if(closed) nsvg__appendPathPoint(r, r->points[0])"
  },
  {
    "label": "nsvg__duplicatePoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__duplicatePoints(r)"
  },
  {
    "label": "nsvg__appendPathPoint()",
    "kind": "Method",
    "detail": "Function (r -> npoints = 0 ; cur = r -> points2 [ 0 ] ;)",
    "insertText": "nsvg__appendPathPoint(r, cur)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (strokeDashArray[j])",
    "insertText": "for(j = 0; j < shape->strokeDashCount; j++)"
  },
  {
    "label": "fmodf()",
    "kind": "Method",
    "detail": "Function (dashOffset =)",
    "insertText": "fmodf(shape->strokeDashOffset, allDashLen)"
  },
  {
    "label": "idash()",
    "kind": "Method",
    "detail": "Function (strokeDashCount)",
    "insertText": "idash(idash + 1)"
  },
  {
    "label": "dashLen()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "dashLen(shape->strokeDashArray[idash] - dashOffset) * (scalex + scaley)"
  },
  {
    "label": "sqrtf()",
    "kind": "Method",
    "detail": "Function (float dx = r -> points2 [ j ] . x - cur . x ; float dy = r -> points2 [ j ] . y - cur . y ; float dist =)",
    "insertText": "sqrtf(dx * dx + dy * dy)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "d(dashLen - totalDist)"
  },
  {
    "label": "nsvg__addPathPoint()",
    "kind": "Method",
    "detail": "Function (float x = cur . x + dx* d ; float y = cur . y + dy* d ;)",
    "insertText": "nsvg__addPathPoint(r, x, y, NSVG_PT_CORNER)"
  },
  {
    "label": "nsvg__prepareStroke()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__prepareStroke(r, miterLimit, lineJoin)"
  },
  {
    "label": "nsvg__expandStroke()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__expandStroke(r, r->points, r->npoints, 0, lineJoin, lineCap, lineWidth)"
  },
  {
    "label": "idash()",
    "kind": "Method",
    "detail": "Function (dashLen = shape -> strokeDashArray [)",
    "insertText": "idash(scalex + scaley)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (j + + ; } })",
    "insertText": "if(r->npoints > 1 && dashState) nsvg__expandStroke(r, r->points, r->npoints, 0, lineJoin, lineCap, lineWidth)"
  },
  {
    "label": "nsvg__expandStroke()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__expandStroke(r, r->points, r->npoints, closed, lineJoin, lineCap, lineWidth)"
  },
  {
    "label": "nsvg__cmpEdge()",
    "kind": "Method",
    "detail": "Function (} } } int)",
    "insertText": "nsvg__cmpEdge(const void* p, const void* q)"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (const NSVGedge*)",
    "insertText": "a(const NSVGedge*)"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (const NSVGedge*)",
    "insertText": "b(const NSVGedge*)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NSVGactiveEdge* z ;)",
    "insertText": "if(r->freelist != NULL)"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (z = r -> freelist ; r -> freelist = z -> next ; } else {)",
    "insertText": "z(NSVGactiveEdge*)nsvg__alloc(r, sizeof(NSVGactiveEdge))"
  },
  {
    "label": "dxdy()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "dxdy(e->x1 - e->x0) / (e->y1 - e->y0)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (z ->)",
    "insertText": "x(int)floorf(NSVG__FIX * (e->x0 + dxdy * (startPoint - e->y0)))"
  },
  {
    "label": "nsvg__freeActive()",
    "kind": "Method",
    "detail": "Function (z -> ey = e -> y1 ; z -> next = 0 ; z -> dir = e -> dir ; return z ; } void)",
    "insertText": "nsvg__freeActive(NSVGrasterizer* r, NSVGactiveEdge* z)"
  },
  {
    "label": "nsvg__fillScanline()",
    "kind": "Method",
    "detail": "Function (z -> next = r -> freelist ; r -> freelist = z ; } void)",
    "insertText": "nsvg__fillScanline(unsigned char* scanline, int len, int x0, int x1, int maxWeight, int* xmin, int* xmax)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int i = x0>> NSVG__FIXSHIFT ; int j = x1>> NSVG__FIXSHIFT ;)",
    "insertText": "if(i < *xmin)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (scanline [)",
    "insertText": "i(unsigned char)(scanline[i] + ((x1 - x0) * maxWeight >> NSVG__FIXSHIFT))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(i >= 0) scanline[i] = (unsigned char)(scanline[i] + (((NSVG__FIX - (x0 & NSVG__FIXMASK)) * maxWeight) >> NSVG__FIXSHIFT))"
  },
  {
    "label": "nsvg__fillActiveEdges()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "nsvg__fillActiveEdges(unsigned char* scanline, int len, NSVGactiveEdge* e, int maxWeight, int* xmin, int* xmax, char fillRule)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int x0 = 0,w = 0 ;)",
    "insertText": "if(fillRule == NSVG_FILLRULE_NONZERO)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (x0 = e -> x ; w + = e -> dir ; } else { int x1 = e -> x ; w + = e -> dir ;)",
    "insertText": "if(w == 0) nsvg__fillScanline(scanline, len, x0, x1, maxWeight, xmin, xmax)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} e = e -> next ; } } else)",
    "insertText": "if(fillRule == NSVG_FILLRULE_EVENODD)"
  },
  {
    "label": "nsvg__fillScanline()",
    "kind": "Method",
    "detail": "Function (x0 = e -> x ; w = 1 ; } else { int x1 = e -> x ; w = 0 ;)",
    "insertText": "nsvg__fillScanline(scanline, len, x0, x1, maxWeight, xmin, xmax)"
  },
  {
    "label": "nsvg__clampf()",
    "kind": "Method",
    "detail": "Function (} e = e -> next ; } } } float)",
    "insertText": "nsvg__clampf(float a, float mn, float mx)"
  },
  {
    "label": "nsvg__RGBA()",
    "kind": "Method",
    "detail": "Function (} unsigned int)",
    "insertText": "nsvg__RGBA(unsigned char r, unsigned char g, unsigned char b, unsigned char a)"
  },
  {
    "label": "nsvg__lerpRGBA()",
    "kind": "Method",
    "detail": "Function (} unsigned int)",
    "insertText": "nsvg__lerpRGBA(unsigned int c0, unsigned int c1, float u)"
  },
  {
    "label": "iu()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "iu(int)(nsvg__clampf(u, 0.0f, 1.0f) * 256.0f)"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "r(((c0) & 0xff) * (256 - iu) + (((c1) & 0xff) * iu))"
  },
  {
    "label": "g()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "g(((c0 >> 8) & 0xff) * (256 - iu) + (((c1 >> 8) & 0xff) * iu))"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "b(((c0 >> 16) & 0xff) * (256 - iu) + (((c1 >> 16) & 0xff) * iu))"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "a(((c0 >> 24) & 0xff) * (256 - iu) + (((c1 >> 24) & 0xff) * iu))"
  },
  {
    "label": "nsvg__applyOpacity()",
    "kind": "Method",
    "detail": "Function (} unsigned int)",
    "insertText": "nsvg__applyOpacity(unsigned int c, float u)"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "r(c)"
  },
  {
    "label": "g()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "g(c >> 8)"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "b(c >> 16)"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "a(((c >> 24) & 0xff) * iu)"
  },
  {
    "label": "nsvg__div255()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "nsvg__div255(int x)"
  },
  {
    "label": "nsvg__scanlineSolid()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "nsvg__scanlineSolid(unsigned char* dst, int count, unsigned char* cover, int x, int y, float tx, float ty, float scalex, float scaley, NSVGcachedPaint* cache)"
  },
  {
    "label": "cg()",
    "kind": "Method",
    "detail": "Function (int i,cr,cg,cb,ca ; cr = cache -> colors [ 0 ]& 0 xff ;)",
    "insertText": "cg(cache->colors[0] >> 8)"
  },
  {
    "label": "cb()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cb(cache->colors[0] >> 16)"
  },
  {
    "label": "ca()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ca(cache->colors[0] >> 24)"
  },
  {
    "label": "nsvg__div255()",
    "kind": "Method",
    "detail": "Function (int r,g,b ; int a =)",
    "insertText": "nsvg__div255((int)cover[0] * ca)"
  },
  {
    "label": "nsvg__div255()",
    "kind": "Method",
    "detail": "Function (int ia = 2 5 5 - a ; r =)",
    "insertText": "nsvg__div255(cr * a)"
  },
  {
    "label": "nsvg__div255()",
    "kind": "Method",
    "detail": "Function (g =)",
    "insertText": "nsvg__div255(cg * a)"
  },
  {
    "label": "nsvg__div255()",
    "kind": "Method",
    "detail": "Function (b =)",
    "insertText": "nsvg__div255(cb * a)"
  },
  {
    "label": "nsvg__div255()",
    "kind": "Method",
    "detail": "Function (r + =)",
    "insertText": "nsvg__div255(ia * (int)dst[0])"
  },
  {
    "label": "nsvg__div255()",
    "kind": "Method",
    "detail": "Function (g + =)",
    "insertText": "nsvg__div255(ia * (int)dst[1])"
  },
  {
    "label": "nsvg__div255()",
    "kind": "Method",
    "detail": "Function (b + =)",
    "insertText": "nsvg__div255(ia * (int)dst[2])"
  },
  {
    "label": "nsvg__div255()",
    "kind": "Method",
    "detail": "Function (a + =)",
    "insertText": "nsvg__div255(ia * (int)dst[3])"
  },
  {
    "label": "dst()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dst(unsigned char)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cover + + ; dst + = 4 ; } } else)",
    "insertText": "if(cache->type == NSVG_PAINT_LINEAR_GRADIENT)"
  },
  {
    "label": "fx()",
    "kind": "Method",
    "detail": "Function (float fx,fy,dx,gy ; float* t = cache -> xform ; int i,cr,cg,cb,ca ; unsigned int c ;)",
    "insertText": "fx((float)x - tx)"
  },
  {
    "label": "fy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fy((float)y - ty)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (dx = 1 . 0 f / scalex ;)",
    "insertText": "for(i = 0; i < count; i++)"
  },
  {
    "label": "colors()",
    "kind": "Method",
    "detail": "Function (int r,g,b,a,ia ; gy = fx* t [ 1 ] + fy* t [ 3 ] + t [ 5 ] ; c = cache ->)",
    "insertText": "colors(int)nsvg__clampf(gy * 255.0f, 0, 255.0f)"
  },
  {
    "label": "cr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cr(c)"
  },
  {
    "label": "cg()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cg(c >> 8)"
  },
  {
    "label": "cb()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cb(c >> 16)"
  },
  {
    "label": "ca()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ca(c >> 24)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cover + + ; dst + = 4 ; fx + = dx ; } } else)",
    "insertText": "if(cache->type == NSVG_PAINT_RADIAL_GRADIENT)"
  },
  {
    "label": "sqrtf()",
    "kind": "Method",
    "detail": "Function (int r,g,b,a,ia ; gx = fx* t [ 0 ] + fy* t [ 2 ] + t [ 4 ] ; gy = fx* t [ 1 ] + fy* t [ 3 ] + t [ 5 ] ; gd =)",
    "insertText": "sqrtf(gx * gx + gy * gy)"
  },
  {
    "label": "colors()",
    "kind": "Method",
    "detail": "Function (c = cache ->)",
    "insertText": "colors(int)nsvg__clampf(gd * 255.0f, 0, 255.0f)"
  },
  {
    "label": "nsvg__rasterizeSortedEdges()",
    "kind": "Method",
    "detail": "Function (cover + + ; dst + = 4 ; fx + = dx ; } } } void)",
    "insertText": "nsvg__rasterizeSortedEdges(NSVGrasterizer* r, float tx, float ty, float scalex, float scaley, NSVGcachedPaint* cache, char fillRule)"
  },
  {
    "label": "maxWeight()",
    "kind": "Method",
    "detail": "Function (NSVGactiveEdge* active = NULL ; int y,s ; int e = 0 ; int)",
    "insertText": "maxWeight(255 / NSVG__SUBSAMPLES)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int xmin,xmax ;)",
    "insertText": "for(y = 0; y < r->height; y++)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(r->scanline, 0, r->width)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (xmin = r -> width ; xmax = 0 ;)",
    "insertText": "for(s = 0; s < NSVG__SUBSAMPLES; ++s)"
  },
  {
    "label": "scany()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "scany(float)(y * NSVG__SUBSAMPLES + s)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (NSVGactiveEdge** step =& active ;)",
    "insertText": "while(*step)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NSVGactiveEdge* z =* step ;)",
    "insertText": "if(z->ey <= scany)"
  },
  {
    "label": "nsvg__freeActive()",
    "kind": "Method",
    "detail": "Function (* step = z -> next ;)",
    "insertText": "nsvg__freeActive(r, z)"
  },
  {
    "label": "step()",
    "kind": "Method",
    "detail": "Function (} else { z -> x + = z -> dx ;)",
    "insertText": "step((*step)->next)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(;;)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int changed = 0 ; step =& active ;)",
    "insertText": "while(*step && (*step)->next)"
  },
  {
    "label": "step()",
    "kind": "Method",
    "detail": "Function (next)",
    "insertText": "step(*step)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!changed)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(e < r->nedges && r->edges[e].y0 <= scany)"
  },
  {
    "label": "nsvg__addActive()",
    "kind": "Method",
    "detail": "Function (NSVGactiveEdge* z =)",
    "insertText": "nsvg__addActive(r, &r->edges[e], scany)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (active = z ; } else)",
    "insertText": "if(z->x < active->x)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (next)",
    "insertText": "while(p->next && p->next->x < z->x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (z -> next = p -> next ; p -> next = z ; } } e + + ; })",
    "insertText": "if(active != NULL) nsvg__fillActiveEdges(r->scanline, r->width, active, maxWeight, &xmin, &xmax, fillRule)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(xmin < 0)"
  },
  {
    "label": "nsvg__scanlineSolid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__scanlineSolid(&r->bitmap[y * r->stride] + xmin * 4, xmax - xmin + 1, &r->scanline[xmin], xmin, y, tx, ty, scalex, scaley, cache)"
  },
  {
    "label": "nsvg__unpremultiplyAlpha()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "nsvg__unpremultiplyAlpha(unsigned char* image, int w, int h, int stride)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int x,y ;)",
    "insertText": "for(y = 0; y < h; y++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (unsigned char* row =& image [ y* stride ] ;)",
    "insertText": "for(x = 0; x < w; x++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int r = row [ 0 ],g = row [ 1 ],b = row [ 2 ],a = row [ 3 ] ;)",
    "insertText": "if(a != 0)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "row(unsigned char)(r * 255 / a)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "row(unsigned char)(g * 255 / a)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "row(unsigned char)(b * 255 / a)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int r = 0,g = 0,b = 0,a = row [ 3 ],n = 0 ;)",
    "insertText": "if(a == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (r + = row [ - 4 ] ; g + = row [ - 3 ] ; b + = row [ - 2 ] ; n + + ; })",
    "insertText": "if(x + 1 < w && row[7] != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (r + = row [ 4 ] ; g + = row [ 5 ] ; b + = row [ 6 ] ; n + + ; })",
    "insertText": "if(y - 1 > 0 && row[-stride + 3] != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (r + = row [ - stride ] ; g + = row [ - stride + 1 ] ; b + = row [ - stride + 2 ] ; n + + ; })",
    "insertText": "if(y + 1 < h && row[stride + 3] != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (r + = row [ stride ] ; g + = row [ stride + 1 ] ; b + = row [ stride + 2 ] ; n + + ; })",
    "insertText": "if(n > 0)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "row(unsigned char)(r / n)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "row(unsigned char)(g / n)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "row(unsigned char)(b / n)"
  },
  {
    "label": "nsvg__initPaint()",
    "kind": "Method",
    "detail": "Function (} } row + = 4 ; } } } void)",
    "insertText": "nsvg__initPaint(NSVGcachedPaint* cache, NSVGpaint* paint, float opacity)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int i,j ; NSVGgradient* grad ; cache -> type = paint -> type ;)",
    "insertText": "if(paint->type == NSVG_PAINT_COLOR)"
  },
  {
    "label": "nsvg__applyOpacity()",
    "kind": "Method",
    "detail": "Function (cache -> colors [ 0 ] =)",
    "insertText": "nsvg__applyOpacity(paint->color, opacity)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(grad->nstops == 1)"
  },
  {
    "label": "nsvg__applyOpacity()",
    "kind": "Method",
    "detail": "Function (} else { unsigned int ca,cb = 0 ; float ua,ub,du,u ; int ia,ib,count ; ca =)",
    "insertText": "nsvg__applyOpacity(grad->stops[0].color, opacity)"
  },
  {
    "label": "nsvg__clampf()",
    "kind": "Method",
    "detail": "Function (ua =)",
    "insertText": "nsvg__clampf(grad->stops[0].offset, 0, 1)"
  },
  {
    "label": "nsvg__clampf()",
    "kind": "Method",
    "detail": "Function (ub =)",
    "insertText": "nsvg__clampf(grad->stops[grad->nstops - 1].offset, ua, 1)"
  },
  {
    "label": "ia()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ia(int)(ua * 255.0f)"
  },
  {
    "label": "ib()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ib(int)(ub * 255.0f)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (cache -> colors [ i ] = ca ; })",
    "insertText": "for(i = 0; i < grad->nstops - 1; i++)"
  },
  {
    "label": "nsvg__applyOpacity()",
    "kind": "Method",
    "detail": "Function (ca =)",
    "insertText": "nsvg__applyOpacity(grad->stops[i].color, opacity)"
  },
  {
    "label": "nsvg__applyOpacity()",
    "kind": "Method",
    "detail": "Function (cb =)",
    "insertText": "nsvg__applyOpacity(grad->stops[i + 1].color, opacity)"
  },
  {
    "label": "nsvg__clampf()",
    "kind": "Method",
    "detail": "Function (ua =)",
    "insertText": "nsvg__clampf(grad->stops[i].offset, 0, 1)"
  },
  {
    "label": "nsvg__clampf()",
    "kind": "Method",
    "detail": "Function (ub =)",
    "insertText": "nsvg__clampf(grad->stops[i + 1].offset, 0, 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (count = ib - ia ;)",
    "insertText": "if(count <= 0)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (u = 0 ; du = 1 . 0)",
    "insertText": "f(float)"
  },
  {
    "label": "nsvg__lerpRGBA()",
    "kind": "Method",
    "detail": "Function (cache -> colors [ ia + j ] =)",
    "insertText": "nsvg__lerpRGBA(ca, cb, u)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (colors[i] = cb)",
    "insertText": "for(i = ib; i < 256; i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NSVGshape* shape = NULL ; NSVGedge* e = NULL ; NSVGcachedPaint cache ; int i ; r -> bitmap = dst ; r -> width = w ; r -> height = h ; r -> stride = stride ;)",
    "insertText": "if(w > r->cscanline)"
  },
  {
    "label": "scanline()",
    "kind": "Method",
    "detail": "Function (r -> cscanline = w ; r ->)",
    "insertText": "scanline(unsigned char*)realloc(r->scanline, w)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = 0; i < h; i++) memset(&dst[i * stride], 0, w * 4)"
  },
  {
    "label": "nsvg__resetPool()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__resetPool(r)"
  },
  {
    "label": "nsvg__flattenShape()",
    "kind": "Method",
    "detail": "Function (r -> freelist = NULL ; r -> nedges = 0 ;)",
    "insertText": "nsvg__flattenShape(r, shape, scalex, scaley)"
  },
  {
    "label": "y0()",
    "kind": "Method",
    "detail": "Function (e =& r -> edges [ i ] ; e -> x0 = tx + e -> x0 ; e ->)",
    "insertText": "y0(ty + e->y0)"
  },
  {
    "label": "y1()",
    "kind": "Method",
    "detail": "Function (e -> x1 = tx + e -> x1 ; e ->)",
    "insertText": "y1(ty + e->y1)"
  },
  {
    "label": "qsort()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "qsort(r->edges, r->nedges, sizeof(NSVGedge), nsvg__cmpEdge)"
  },
  {
    "label": "nsvg__initPaint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__initPaint(&cache, &shape->fill, shape->opacity)"
  },
  {
    "label": "nsvg__rasterizeSortedEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__rasterizeSortedEdges(r, tx, ty, scalex, scaley, &cache, shape->fillRule)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(shape->stroke.type != NSVG_PAINT_NONE && (shape->strokeWidth * (scalex + scaley) * 0.5f) > 0.01f)"
  },
  {
    "label": "nsvg__flattenShapeStroke()",
    "kind": "Method",
    "detail": "Function (r -> freelist = NULL ; r -> nedges = 0 ;)",
    "insertText": "nsvg__flattenShapeStroke(r, shape, scalex, scaley)"
  },
  {
    "label": "nsvg__initPaint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__initPaint(&cache, &shape->stroke, shape->opacity)"
  },
  {
    "label": "nsvg__rasterizeSortedEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nsvg__rasterizeSortedEdges(r, tx, ty, scalex, scaley, &cache, NSVG_FILLRULE_NONZERO)"
  },
  {
    "label": "nsvg__unpremultiplyAlpha()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "nsvg__unpremultiplyAlpha(dst, w, h, stride)"
  }
]