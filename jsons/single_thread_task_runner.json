[
  {
    "label": "MainThreadSchedulerImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MainThreadSchedulerImpl"
  },
  {
    "label": "ScopedDisallowRunningRunLoop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScopedDisallowRunningRunLoop"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "CurrentHandleOverride",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CurrentHandleOverride"
  },
  {
    "label": "CurrentHandleOverrideForTesting",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CurrentHandleOverrideForTesting"
  },
  {
    "label": "SingleThreadTaskRunner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SingleThreadTaskRunner"
  },
  {
    "label": "ThreadTaskRunnerHandleOverride",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadTaskRunnerHandleOverride"
  },
  {
    "label": "blink",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "blink"
  },
  {
    "label": "BelongsToCurrentThread()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TASK_SINGLE_THREAD_TASK_RUNNER_H_ # define BASE_TASK_SINGLE_THREAD_TASK_RUNNER_H_ # include \" base / base_export . h \" # include \" base / dcheck_is_on . h \" # include \" base / task / sequenced_task_runner . h \" # include \" third_party / abseil - cpp / absl / types / optional . h \" namespace blink::scheduler { class MainThreadSchedulerImpl ; } namespace base { class ScopedDisallowRunningRunLoop ; class BASE_EXPORT SingleThreadTaskRunner : public SequencedTaskRunner { public : bool)",
    "insertText": "BelongsToCurrentThread()"
  },
  {
    "label": "GetCurrentDefault()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] const scoped_refptr<SingleThreadTaskRunner>&)",
    "insertText": "GetCurrentDefault()"
  },
  {
    "label": "HasCurrentDefault()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "HasCurrentDefault()"
  },
  {
    "label": "CurrentDefaultHandle()",
    "kind": "Method",
    "detail": "Function (class CurrentHandleOverride ; class CurrentHandleOverrideForTesting ; class BASE_EXPORT CurrentDefaultHandle { public :)",
    "insertText": "CurrentDefaultHandle(scoped_refptr<SingleThreadTaskRunner> task_runner)"
  },
  {
    "label": "CurrentDefaultHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CurrentDefaultHandle(const CurrentDefaultHandle&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CurrentDefaultHandle&)",
    "insertText": "operator(const CurrentDefaultHandle&)"
  },
  {
    "label": "CurrentDefaultHandle()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CurrentDefaultHandle()"
  },
  {
    "label": "CurrentHandleOverride()",
    "kind": "Method",
    "detail": "Function (private : class SingleThreadTaskRunner ; class CurrentHandleOverride ; scoped_refptr<SingleThreadTaskRunner> task_runner_ ; SequencedTaskRunner::CurrentDefaultHandle sequenced_task_runner_current_default_ ; } ; class BASE_EXPORT CurrentHandleOverride { public :)",
    "insertText": "CurrentHandleOverride(const CurrentHandleOverride&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CurrentHandleOverride&)",
    "insertText": "operator(const CurrentHandleOverride&)"
  },
  {
    "label": "CurrentHandleOverride()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CurrentHandleOverride()"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (private : class CurrentHandleOverrideForTesting ;)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(SingleThreadTaskRunnerCurrentDefaultHandleTest, NestedRunLoop)"
  },
  {
    "label": "CurrentHandleOverride()",
    "kind": "Method",
    "detail": "Function (class ThreadTaskRunnerHandleOverride ; class blink::scheduler::MainThreadSchedulerImpl ;)",
    "insertText": "CurrentHandleOverride(scoped_refptr<SingleThreadTaskRunner> overriding_task_runner, bool allow_nested_runloop = false)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (absl::optional<SingleThreadTaskRunner::CurrentDefaultHandle> top_level_thread_task_runner_current_default_ ; scoped_refptr<SingleThreadTaskRunner> task_runner_to_restore_ ; # if)",
    "insertText": "DCHECK_IS_ON()"
  },
  {
    "label": "CurrentHandleOverrideForTesting()",
    "kind": "Method",
    "detail": "Function (nullptr } ; # endif std::unique_ptr<ScopedDisallowRunningRunLoop> no_running_during_override_ ; } ; class BASE_EXPORT CurrentHandleOverrideForTesting { public :)",
    "insertText": "CurrentHandleOverrideForTesting(scoped_refptr<SingleThreadTaskRunner> overriding_task_runner) : thread_task_runner_current_override_( std::move(overriding_task_runner))"
  },
  {
    "label": "SingleThreadTaskRunner()",
    "kind": "Method",
    "detail": "Function (} private : CurrentHandleOverride thread_task_runner_current_override_ ; } ; protected : ~)",
    "insertText": "SingleThreadTaskRunner()"
  }
]