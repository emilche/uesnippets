[
  {
    "label": "TResizableCircularQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TResizableCircularQueue"
  },
  {
    "label": "FResizableCircularQueueTestUtil",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FResizableCircularQueueTestUtil"
  },
  {
    "label": "TResizableCircularQueue()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / AssertionMacros . h \" # include \" Containers / Array . h \" # include \" Templates / IsPODType . h \" # include \" Templates / MemoryOps . h \" # include<type_traits> template<T,AllocatorT = FDefaultAllocator> class TResizableCircularQueue { public : typedef T ElementT ;)",
    "insertText": "TResizableCircularQueue(SIZE_T InitialCapacity)"
  },
  {
    "label": "TResizableCircularQueue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TResizableCircularQueue() : TResizableCircularQueue(0U)"
  },
  {
    "label": "TResizableCircularQueue()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TResizableCircularQueue()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Enqueue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Enqueue(const ElementT& SrcData)"
  },
  {
    "label": "EnqueueDefaulted_GetRef()",
    "kind": "Method",
    "detail": "Function (ElementT&)",
    "insertText": "EnqueueDefaulted_GetRef()"
  },
  {
    "label": "Enqueue_GetRef()",
    "kind": "Method",
    "detail": "Function (ElementT&)",
    "insertText": "Enqueue_GetRef()"
  },
  {
    "label": "Enqueue()",
    "kind": "Method",
    "detail": "Function (ElementT&)",
    "insertText": "Enqueue()"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Pop()"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Pop(SIZE_T Count)"
  },
  {
    "label": "PopNoCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopNoCheck()"
  },
  {
    "label": "PopNoCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopNoCheck(SIZE_T Count)"
  },
  {
    "label": "PeekAtOffset()",
    "kind": "Method",
    "detail": "Function (const ElementT&)",
    "insertText": "PeekAtOffset(SIZE_T Offset = 0)"
  },
  {
    "label": "PokeAtOffset()",
    "kind": "Method",
    "detail": "Function (} ElementT&)",
    "insertText": "PokeAtOffset(SIZE_T Offset = 0)"
  },
  {
    "label": "Peek()",
    "kind": "Method",
    "detail": "Function (} const ElementT&)",
    "insertText": "Peek()"
  },
  {
    "label": "Poke()",
    "kind": "Method",
    "detail": "Function (} ElementT&)",
    "insertText": "Poke()"
  },
  {
    "label": "PeekAtOffsetNoCheck()",
    "kind": "Method",
    "detail": "Function (} const ElementT&)",
    "insertText": "PeekAtOffsetNoCheck(SIZE_T Offset = 0)"
  },
  {
    "label": "PokeAtOffsetNoCheck()",
    "kind": "Method",
    "detail": "Function (} ElementT&)",
    "insertText": "PokeAtOffsetNoCheck(SIZE_T Offset = 0)"
  },
  {
    "label": "PeekNoCheck()",
    "kind": "Method",
    "detail": "Function (} const ElementT&)",
    "insertText": "PeekNoCheck()"
  },
  {
    "label": "Trim()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Trim()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "bConstructElements()",
    "kind": "Method",
    "detail": "Function (private : enum : uint32 {)",
    "insertText": "bConstructElements(TIsPODType<T>::Value ? 0U : 1U), bDestructElements = (std::is_trivially_destructible_v<T> ? 0U : 1U)"
  },
  {
    "label": "SetCapacity()",
    "kind": "Method",
    "detail": "Function (# if WITH_DEV_AUTOMATION_TESTS struct FResizableCircularQueueTestUtil ; # endif void)",
    "insertText": "SetCapacity(SIZE_T NewCapacity)"
  },
  {
    "label": "TResizableCircularQueue()",
    "kind": "Method",
    "detail": "Function (typedef uint32 IndexT ; typedef TArray<ElementT,AllocatorT> StorageT ; IndexT Head ; IndexT Tail ; IndexT IndexMask ; StorageT Storage ; } ; template<T,AllocatorT> TResizableCircularQueue<T,AllocatorT)",
    "insertText": "TResizableCircularQueue(SIZE_T InitialCapacity) : Head(0u) , Tail(0u) , IndexMask(0u)"
  },
  {
    "label": "SetCapacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCapacity(InitialCapacity)"
  },
  {
    "label": "PopNoCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopNoCheck(Count())"
  },
  {
    "label": "SetNumUnsafeInternal()",
    "kind": "Method",
    "detail": "Function (Storage .)",
    "insertText": "SetNumUnsafeInternal(0)"
  },
  {
    "label": "Count()",
    "kind": "Method",
    "detail": "Function (const SIZE_T RequiredCapacity =)",
    "insertText": "Count()"
  },
  {
    "label": "SetCapacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCapacity(RequiredCapacity)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} const IndexT MaskedIndex = Head + +& IndexMask ; T* DstData = Storage .)",
    "insertText": "GetData()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(DstData) T(SrcData)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(DstData) T()"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (} template<T,AllocatorT> void TResizableCircularQueue<T,AllocatorT)",
    "insertText": "Pop(SIZE_T PopCount)"
  },
  {
    "label": "PopNoCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopNoCheck(PopCount)"
  },
  {
    "label": "DestructItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItem(Data)"
  },
  {
    "label": "MaskedTailEnd()",
    "kind": "Method",
    "detail": "Function (const IndexT MaskedTailStart = Tail& IndexMask ; const IndexT)",
    "insertText": "MaskedTailEnd(Tail + Count)"
  },
  {
    "label": "FirstDestructCount()",
    "kind": "Method",
    "detail": "Function (const SIZE_T)",
    "insertText": "FirstDestructCount(Storage.Num() - MaskedTailStart)"
  },
  {
    "label": "DestructItems()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItems(Data + MaskedTailStart, FirstDestructCount)"
  },
  {
    "label": "DestructItems()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItems(Data, MaskedTailEnd)"
  },
  {
    "label": "DestructItems()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItems(Data, Count)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "check(SIZE_T(Tail) + Count <= TNumericLimits<IndexT>::Max())"
  },
  {
    "label": "Tail()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Tail(IndexT)"
  },
  {
    "label": "SetCapacity()",
    "kind": "Method",
    "detail": "Function (} template<T,AllocatorT> void TResizableCircularQueue<T,AllocatorT)",
    "insertText": "SetCapacity(SIZE_T RequiredCapacity)"
  },
  {
    "label": "RoundUpToPowerOfTwo64()",
    "kind": "Method",
    "detail": "Function (using SizeType = StorageT::SizeType ; SIZE_T NewCapacity =)",
    "insertText": "RoundUpToPowerOfTwo64(RequiredCapacity)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (StorageT NewStorage ; NewStorage .)",
    "insertText": "Empty(static_cast<SizeType>(NewCapacity))"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const SIZE_T SrcCapacity = Storage .)",
    "insertText": "Num()"
  },
  {
    "label": "CopyCount()",
    "kind": "Method",
    "detail": "Function (const SIZE_T)",
    "insertText": "CopyCount(SrcCapacity - MaskedTail)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (NewStorage .)",
    "insertText": "Append(SrcData + MaskedTail, static_cast<SizeType>(CopyCount))"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (NewStorage .)",
    "insertText": "Append(SrcData, MaskedHead)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (} else { NewStorage .)",
    "insertText": "Append(SrcData + MaskedTail, static_cast<SizeType>(SrcSize))"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (} NewStorage .)",
    "insertText": "AddUninitialized(static_cast<SizeType>(NewCapacity - SrcSize))"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (this -> Storage =)",
    "insertText": "MoveTemp(NewStorage)"
  },
  {
    "label": "IndexT()",
    "kind": "Method",
    "detail": "Function (IndexMask = static_cast<)",
    "insertText": "IndexT(NewCapacity - 1)"
  },
  {
    "label": "IndexT()",
    "kind": "Method",
    "detail": "Function (Tail = 0 u ; Head = static_cast<)",
    "insertText": "IndexT(SrcSize)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (Storage .)",
    "insertText": "AddUninitialized(static_cast<SizeType>(NewCapacity))"
  },
  {
    "label": "SetCapacity()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "SetCapacity(Count())"
  },
  {
    "label": "IndexT()",
    "kind": "Method",
    "detail": "Function (Head = 0 ; Tail = 0 ; IndexMask =)",
    "insertText": "IndexT(-1)"
  }
]