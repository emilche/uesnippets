[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "IMATH_EXPORT_TEMPLATE_TYPE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMATH_EXPORT_TEMPLATE_TYPE"
  },
  {
    "label": "IMATH_EXPORT_ENUM",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "IMATH_EXPORT_ENUM"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHEULER_H # define INCLUDED_IMATHEULER_H # include \" ImathExport . h \" # include \" ImathNamespace . h \" # include \" ImathMath . h \" # include \" ImathMatrix . h \" # include \" ImathQuat . h \" # include \" ImathVec . h \" # include<iostream> IMATH_INTERNAL_NAMESPACE_HEADER_ENTER #)",
    "insertText": "if(defined _WIN32 || defined _WIN64) && defined _MSC_VER # pragma warning(push) # pragma warning(disable : 4244)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (public : using Vec3<T>::x ; using Vec3<T>::y ; using Vec3<T>::z ; enum IMATH_EXPORT_ENUM Order { XYZ = 0 x0101,XZY = 0 x0001,YZX = 0 x1101,YXZ = 0 x1001,ZXY = 0 x2101,ZYX = 0 x2001,XZX = 0 x0011,XYX = 0 x0111,YXY = 0 x1011,YZY = 0 x1111,ZYZ = 0 x2011,ZXZ = 0 x2111,XYZr = 0 x2000,XZYr = 0 x2100,YZXr = 0 x1000,YXZr = 0 x1100,ZXYr = 0 x0000,ZYXr = 0 x0100,XZXr = 0 x2110,XYXr = 0 x2010,YXYr = 0 x1110,YZYr = 0 x1010,ZYZr = 0 x0110,ZXZr = 0 x0010,Legal = XYZ | XZY | YZX | YXZ | ZXY | ZYX | XZX | XYX | YXY | YZY | ZYZ | ZXZ | XYZr | XZYr | YZXr | YXZr | ZXYr | ZYXr | XZXr | XYXr | YXYr | YZYr | ZYZr | ZXZr,Min = 0 x0000,Max = 0 x2111,Default = XYZ } ; enum IMATH_EXPORT_ENUM Axis { X = 0,Y = 1,Z = 2 } ; enum IMATH_EXPORT_ENUM InputLayout { XYZLayout,IJKLayout } ; IMATH_HOSTDEVICE)",
    "insertText": "Euler()"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Euler(const Euler&)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Euler(Order p)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Euler(const Vec3<T>& v, Order o = Default, InputLayout l = IJKLayout)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Euler(T i, T j, T k, Order o = Default, InputLayout l = IJKLayout)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Euler(const Euler<T>& euler, Order newp)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Euler(const Matrix33<T>&, Order o = Default)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Euler(const Matrix44<T>&, Order o = Default)"
  },
  {
    "label": "legal()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE bool)",
    "insertText": "legal(Order)"
  },
  {
    "label": "order()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Order)",
    "insertText": "order()"
  },
  {
    "label": "frameStatic()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE bool)",
    "insertText": "frameStatic()"
  },
  {
    "label": "angleMapping()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "angleMapping(int& i, int& j, int& k)"
  },
  {
    "label": "setOrder()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "setOrder(Order)"
  },
  {
    "label": "setXYZVector()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "setXYZVector(const Vec3<T>&)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "set(Axis initial, bool relative, bool parityEven, bool firstRepeats)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Euler<T>&)",
    "insertText": "operator(const Euler<T>&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Euler<T>&)",
    "insertText": "operator(const Vec3<T>&)"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "extract(const Matrix33<T>&)"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "extract(const Matrix44<T>&)"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "extract(const Quat<T>&)"
  },
  {
    "label": "toMatrix33()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Matrix33<T>)",
    "insertText": "toMatrix33()"
  },
  {
    "label": "toMatrix44()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Matrix44<T>)",
    "insertText": "toMatrix44()"
  },
  {
    "label": "toQuat()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Quat<T>)",
    "insertText": "toQuat()"
  },
  {
    "label": "toXYZVector()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Vec3<T>)",
    "insertText": "toXYZVector()"
  },
  {
    "label": "angleMod()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 float)",
    "insertText": "angleMod(T angle)"
  },
  {
    "label": "simpleXYZRotation()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "simpleXYZRotation(Vec3<T>& xyzRot, const Vec3<T>& targetXyzRot)"
  },
  {
    "label": "nearestRotation()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "nearestRotation(Vec3<T>& xyzRot, const Vec3<T>& targetXyzRot, Order order = XYZ)"
  },
  {
    "label": "makeNear()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "makeNear(const Euler<T>& target)"
  },
  {
    "label": "angleOrder()",
    "kind": "Method",
    "detail": "Function (protected : bool _frameStatic : 1 ; bool _initialRepeated : 1 ; bool _parityEven : 1 ; # if defined _WIN32 | | defined _WIN64 Axis _initialAxis ; # else Axis _initialAxis : 2 ; # endif } ; typedef Euler<float> Eulerf ; typedef Euler<double> Eulerd ; template<class T> IMATH_HOSTDEVICE void Euler<T)",
    "insertText": "angleOrder(int& i, int& j, int& k)"
  },
  {
    "label": "_parityEven()",
    "kind": "Method",
    "detail": "Function (i = _initialAxis ; j =)",
    "insertText": "_parityEven(i + 1) % 3 : (i > 0 ? i - 1 : 2)"
  },
  {
    "label": "_parityEven()",
    "kind": "Method",
    "detail": "Function (k =)",
    "insertText": "_parityEven(i > 0 ? i - 1 : 2) : (i + 1)"
  },
  {
    "label": "m()",
    "kind": "Method",
    "detail": "Function (int m [ 3 ] ; m [ _initialAxis ] = 0 ;)",
    "insertText": "m(_initialAxis + 1)"
  },
  {
    "label": "m()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m(_initialAxis + 2)"
  },
  {
    "label": "setXYZVector()",
    "kind": "Method",
    "detail": "Function (i = m [ 0 ] ; j = m [ 1 ] ; k = m [ 2 ] ; } template<class T> IMATH_HOSTDEVICE void Euler<T)",
    "insertText": "setXYZVector(const Vec3<T>& v)"
  },
  {
    "label": "angleMapping()",
    "kind": "Method",
    "detail": "Function (int i,j,k ;)",
    "insertText": "angleMapping(i, j, k)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Euler<T)",
    "insertText": "Euler() IMATH_NOEXCEPT : Vec3<T> (0, 0, 0), _frameStatic (true), _initialRepeated (false), _parityEven (true), _initialAxis (X)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Euler<T)",
    "insertText": "Euler(typename Euler<T>::Order p) IMATH_NOEXCEPT : Vec3<T> (0, 0, 0), _frameStatic (true), _initialRepeated (false), _parityEven (true), _initialAxis (X)"
  },
  {
    "label": "setOrder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOrder(p)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Euler<T)",
    "insertText": "Euler(const Vec3<T>& v, typename Euler<T>::Order p, typename Euler<T>::InputLayout l)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(euler)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Euler<T)",
    "insertText": "Euler(const Euler<T>& euler, Order p)"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "extract(M)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Euler<T)",
    "insertText": "Euler(T xi, T yi, T zi, typename Euler<T>::Order p, typename Euler<T>::InputLayout l)"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Euler<T)",
    "insertText": "Euler(const Matrix44<T>& M, typename Euler::Order p)"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE void Euler<T)",
    "insertText": "extract(const Quat<T>& q)"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "extract(q.toMatrix33())"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE void Euler<T)",
    "insertText": "extract(const Matrix33<T>& M)"
  },
  {
    "label": "angleOrder()",
    "kind": "Method",
    "detail": "Function (int i,j,k ;)",
    "insertText": "angleOrder(i, j, k)"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (x =)",
    "insertText": "atan2(M[j][i], M[k][i])"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "r(0, 0, 0)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (r [)",
    "insertText": "i(_parityEven ? -x : x)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (Matrix44<T> N ; N .)",
    "insertText": "rotate(r)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (N = N* Matrix44<)",
    "insertText": "T(M[0][0], M[0][1], M[0][2], 0, M[1][0], M[1][1], M[1][2], 0, M[2][0], M[2][1], M[2][2], 0, 0, 0, 0, 1)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (T sy =)",
    "insertText": "sqrt(N[j][i] * N[j][i] + N[k][i] * N[k][i])"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (y =)",
    "insertText": "atan2(sy, N[i][i])"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (z =)",
    "insertText": "atan2(N[j][k], N[j][j])"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (} else { x =)",
    "insertText": "atan2(M[j][k], M[k][k])"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (T cy =)",
    "insertText": "sqrt(N[i][i] * N[i][i] + N[i][j] * N[i][j])"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (y =)",
    "insertText": "atan2(-N[i][k], cy)"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (z =)",
    "insertText": "atan2(-N[j][i], N[j][j])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!_parityEven)"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (T t = x ; x = z ; z = t ; } } template<class T> IMATH_HOSTDEVICE void Euler<T)",
    "insertText": "extract(const Matrix44<T>& M)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3<T> angles ;)",
    "insertText": "if(_frameStatic) angles = (*this)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (T ci =)",
    "insertText": "cos(angles.x)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (T cj =)",
    "insertText": "cos(angles.y)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (T ch =)",
    "insertText": "cos(angles.z)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (T si =)",
    "insertText": "sin(angles.x)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (T sj =)",
    "insertText": "sin(angles.y)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (T sh =)",
    "insertText": "sin(angles.z)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T cc = ci* ch ; T cs = ci* sh ; T sc = si* ch ; T ss = si* sh ; Matrix33<T> M ;)",
    "insertText": "if(_initialRepeated)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (T ti = angles . x* 0 . 5 ; T tj = angles . y* 0 . 5 ; T th = angles . z* 0 . 5 ; T ci =)",
    "insertText": "cos(ti)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (T cj =)",
    "insertText": "cos(tj)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (T ch =)",
    "insertText": "cos(th)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (T si =)",
    "insertText": "sin(ti)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (T sj =)",
    "insertText": "sin(tj)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (T sh =)",
    "insertText": "sin(th)"
  },
  {
    "label": "cj()",
    "kind": "Method",
    "detail": "Function (a [ i ] =)",
    "insertText": "cj(cs + sc)"
  },
  {
    "label": "sj()",
    "kind": "Method",
    "detail": "Function (a [ j ] =)",
    "insertText": "sj(cc + ss) * parity, a[k] = sj * (cs - sc)"
  },
  {
    "label": "cj()",
    "kind": "Method",
    "detail": "Function (q . r =)",
    "insertText": "cj(cc - ss)"
  },
  {
    "label": "j()",
    "kind": "Method",
    "detail": "Function (} else { a [ i ] = cj* sc - sj* cs,a [)",
    "insertText": "j(cj * ss + sj * cc)"
  },
  {
    "label": "legal()",
    "kind": "Method",
    "detail": "Function (q . r = cj* cc + sj* ss ; } q . v = a ; return q ; } template<class T> IMATH_HOSTDEVICE bool Euler<T)",
    "insertText": "legal(typename Euler<T>::Order order)"
  },
  {
    "label": "foo()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "foo(_initialAxis == Z ? 0x2000 : (_initialAxis == Y ? 0x1000 : 0))"
  },
  {
    "label": "setOrder()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE void Euler<T)",
    "insertText": "setOrder(typename Euler<T>::Order p)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(p & 0x2000 ? Z : (p & 0x1000 ? Y : X), !(p & 0x1), !!(p & 0x100), !!(p & 0x10))"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE void Euler<T)",
    "insertText": "set(typename Euler<T>::Axis axis, bool relative, bool parityEven, bool firstRepeats)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (_initialAxis = axis ; _frameStatic = ! relative ; _parityEven = parityEven ; _initialRepeated = firstRepeats ; } template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Euler<T>& Euler<T)",
    "insertText": "operator(const Euler<T>& euler)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (x = euler . x ; y = euler . y ; z = euler . z ; _initialAxis = euler . _initialAxis ; _frameStatic = euler . _frameStatic ; _parityEven = euler . _parityEven ; _initialRepeated = euler . _initialRepeated ; return* this ; } template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Euler<T>& Euler<T)",
    "insertText": "operator(const Vec3<T>& v)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T pi = static_cast<)",
    "insertText": "T(M_PI)"
  },
  {
    "label": "fmod()",
    "kind": "Method",
    "detail": "Function (angle =)",
    "insertText": "fmod(T (angle), T (2 * pi))"
  },
  {
    "label": "angleMod()",
    "kind": "Method",
    "detail": "Function (Vec3<T> d = xyzRot - targetXyzRot ; xyzRot [ 0 ] = targetXyzRot [ 0 ] +)",
    "insertText": "angleMod(d[0])"
  },
  {
    "label": "angleMod()",
    "kind": "Method",
    "detail": "Function (xyzRot [ 1 ] = targetXyzRot [ 1 ] +)",
    "insertText": "angleMod(d[1])"
  },
  {
    "label": "angleMod()",
    "kind": "Method",
    "detail": "Function (xyzRot [ 2 ] = targetXyzRot [ 2 ] +)",
    "insertText": "angleMod(d[2])"
  },
  {
    "label": "nearestRotation()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE void Euler<T)",
    "insertText": "nearestRotation(Vec3<T>& xyzRot, const Vec3<T>& targetXyzRot, Order order)"
  },
  {
    "label": "e()",
    "kind": "Method",
    "detail": "Function (int i,j,k ; Euler<T>)",
    "insertText": "e(0, 0, 0, order)"
  },
  {
    "label": "simpleXYZRotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "simpleXYZRotation(xyzRot, targetXyzRot)"
  },
  {
    "label": "simpleXYZRotation()",
    "kind": "Method",
    "detail": "Function (Vec3<T> otherXyzRot ; otherXyzRot [ i ] = M_PI + xyzRot [ i ] ; otherXyzRot [ j ] = M_PI - xyzRot [ j ] ; otherXyzRot [ k ] = M_PI + xyzRot [ k ] ;)",
    "insertText": "simpleXYZRotation(otherXyzRot, targetXyzRot)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (Vec3<T> d = xyzRot - targetXyzRot ; Vec3<T> od = otherXyzRot - targetXyzRot ; T dMag = d .)",
    "insertText": "dot(d)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (T odMag = od .)",
    "insertText": "dot(od)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3<T> targetXyz ;)",
    "insertText": "if(order() != target.order())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Euler<T> targetSameOrder = Euler<)",
    "insertText": "T(target, order())"
  },
  {
    "label": "nearestRotation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "nearestRotation(xyzRot, targetXyz, order())"
  },
  {
    "label": "setXYZVector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setXYZVector(xyzRot)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& o, const Euler<T>& euler)"
  }
]