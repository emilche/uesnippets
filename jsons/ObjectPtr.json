[
  {
    "label": "UClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UClass"
  },
  {
    "label": "TObjectPtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TObjectPtr"
  },
  {
    "label": "FObjectPtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FObjectPtr"
  },
  {
    "label": "TPrivateObjectPtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPrivateObjectPtr"
  },
  {
    "label": "Friend",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Friend"
  },
  {
    "label": "TRemoveObjectPointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TRemoveObjectPointer"
  },
  {
    "label": "TRawPointerType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TRawPointerType"
  },
  {
    "label": "TNonAccessTrackedObjectPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TNonAccessTrackedObjectPtr"
  },
  {
    "label": "TContainerElementTypeCompatibility",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TContainerElementTypeCompatibility"
  },
  {
    "label": "TIsZeroConstructType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsZeroConstructType"
  },
  {
    "label": "TIsBitwiseConstructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsBitwiseConstructible"
  },
  {
    "label": "PREDICATE_CLASS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PREDICATE_CLASS"
  },
  {
    "label": "TDereferenceWrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TDereferenceWrapper"
  },
  {
    "label": "TCallTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCallTraits"
  },
  {
    "label": "TIsPointerOrObjectPtrToBaseOfImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPointerOrObjectPtrToBaseOfImpl"
  },
  {
    "label": "TIsPointerOrObjectPtrToBaseOf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPointerOrObjectPtrToBaseOf"
  },
  {
    "label": "TPointedToTypeImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPointedToTypeImpl"
  },
  {
    "label": "TObjectPtrDecayTypeOf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TObjectPtrDecayTypeOf"
  },
  {
    "label": "TObjectPtrWrapTypeOf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TObjectPtrWrapTypeOf"
  },
  {
    "label": "TMutableViewTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TMutableViewTraits"
  },
  {
    "label": "TMutableView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMutableView"
  },
  {
    "label": "TMaybeObjectPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMaybeObjectPtr"
  },
  {
    "label": "TNonNullPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TNonNullPtr"
  },
  {
    "label": "UE_OBJPTR_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" HAL / Platform . h \" # include \" Serialization / StructuredArchive . h \" # include \" Templates / IsTObjectPtr . h \" # include \" UObject / GarbageCollectionGlobals . h \" # include \" UObject / ObjectHandle . h \" # include \" UObject / UObjectGlobals . h \" # include \" Templates / NonNullPointer . h \" # include<type_traits> # define UE_WITH_OBJECT_PTR_DEPRECATIONS 0 # if UE_WITH_OBJECT_PTR_DEPRECATIONS # define)",
    "insertText": "UE_OBJPTR_DEPRECATED(Version, Message) UE_DEPRECATED(Version, Message) #else #define UE_OBJPTR_DEPRECATED(Version, Message) #endif #ifndef UE_OBJECT_PTR_GC_BARRIER #define UE_OBJECT_PTR_GC_BARRIER 1 #endif #define UE_TRANSITIONAL_OBJECT_PTR(Type) auto #define UE_TRANSITIONAL_OBJECT_PTR_TEMPLATE(Templ, Type) auto #define UE_TRANSITIONAL_OBJECT_PTR_TEMPLATE_SUFFIXED(Templ, Type, Suffix) auto #define UE_TRANSITIONAL_OBJECT_PTR_TEMPLATE2_ARG1(Templ, Type1, Type2) auto #define UE_TRANSITIONAL_OBJECT_PTR_TEMPLATE2_ARG1_SUFFIXED(Templ, Type1, Type2, Suffix) auto #define UE_TRANSITIONAL_OBJECT_PTR_TEMPLATE2_ARG2(Templ, Type1, Type2) auto #define UE_TRANSITIONAL_OBJECT_PTR_TEMPLATE2_ARG2_SUFFIXED(Templ, Type1, Type2, Suffix) auto #define UE_TRANSITIONAL_OBJECT_PTR_TEMPLATE2_ARG_BOTH(Templ, Type1, Type2) auto #define UE_TRANSITIONAL_OBJECT_PTR_TEMPLATE2_ARG_BOTH_SUFFIXED(Templ, Type1, Type2, Suffix) auto #if PLATFORM_MICROSOFT && defined(_MSC_EXTENSIONS)"
  },
  {
    "label": "FObjectPtr()",
    "kind": "Method",
    "detail": "Function (template<T> struct TObjectPtr ; struct FObjectPtr { public :)",
    "insertText": "FObjectPtr() : Handle(UE::CoreUObject::Private::MakeObjectHandle(nullptr))"
  },
  {
    "label": "FObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FObjectPtr(ENoInit)"
  },
  {
    "label": "FObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FObjectPtr(TYPE_OF_NULLPTR) : Handle(UE::CoreUObject::Private::MakeObjectHandle(nullptr))"
  },
  {
    "label": "FObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FObjectPtr(UObject* Object) : Handle(UE::CoreUObject::Private::MakeObjectHandle(Object))"
  },
  {
    "label": "ConditionallyMarkAsReachable()",
    "kind": "Method",
    "detail": "Function (# if UE_OBJECT_PTR_GC_BARRIER)",
    "insertText": "ConditionallyMarkAsReachable(Object)"
  },
  {
    "label": "UE_OBJPTR_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (# endif })",
    "insertText": "UE_OBJPTR_DEPRECATED(5.0, \"Construction with incomplete type pointer is deprecated. Please update this code to use MakeObjectPtrUnsafe.\") explicit FORCEINLINE FObjectPtr(void* IncompleteObject) : Handle(UE::CoreUObject::Private::MakeObjectHandle(reinterpret_cast<UObject*>(IncompleteObject)))"
  },
  {
    "label": "FObjectPtr()",
    "kind": "Method",
    "detail": "Function (} # if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE)",
    "insertText": "FObjectPtr(FObjectHandle Handle) : Handle(Handle)"
  },
  {
    "label": "ConditionallyMarkAsReachable()",
    "kind": "Method",
    "detail": "Function (# if UE_OBJECT_PTR_GC_BARRIER)",
    "insertText": "ConditionallyMarkAsReachable(*this)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (# endif } # endif UObject*)",
    "insertText": "Get()"
  },
  {
    "label": "GetClass()",
    "kind": "Method",
    "detail": "Function (} UClass*)",
    "insertText": "GetClass()"
  },
  {
    "label": "FObjectPtr()",
    "kind": "Method",
    "detail": "Function (} # if UE_OBJECT_PTR_GC_BARRIER)",
    "insertText": "FObjectPtr(FObjectPtr&& InOther) : Handle(MoveTemp(InOther.Handle))"
  },
  {
    "label": "FObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FObjectPtr(const FObjectPtr& InOther) : Handle(InOther.Handle)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FObjectPtr&)",
    "insertText": "operator(FObjectPtr&& InOther)"
  },
  {
    "label": "ConditionallyMarkAsReachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConditionallyMarkAsReachable(InOther)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Handle =)",
    "insertText": "MoveTemp(InOther.Handle)"
  },
  {
    "label": "FObjectPtr()",
    "kind": "Method",
    "detail": "Function (Handle = InOther . Handle ; return* this ; } # else)",
    "insertText": "FObjectPtr(FObjectPtr&&)"
  },
  {
    "label": "FObjectPtr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FObjectPtr(const FObjectPtr&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FObjectPtr&)",
    "insertText": "operator(FObjectPtr&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FObjectPtr&)",
    "insertText": "operator(const FObjectPtr&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif FObjectPtr&)",
    "insertText": "operator(UObject* Other)"
  },
  {
    "label": "ConditionallyMarkAsReachable()",
    "kind": "Method",
    "detail": "Function (# if UE_OBJECT_PTR_GC_BARRIER)",
    "insertText": "ConditionallyMarkAsReachable(Other)"
  },
  {
    "label": "MakeObjectHandle()",
    "kind": "Method",
    "detail": "Function (# endif Handle = UE::CoreUObject::)",
    "insertText": "MakeObjectHandle(Other)"
  },
  {
    "label": "MakeObjectHandle()",
    "kind": "Method",
    "detail": "Function (Handle = UE::CoreUObject::)",
    "insertText": "MakeObjectHandle(reinterpret_cast<UObject*>(IncompleteOther))"
  },
  {
    "label": "MakeObjectHandle()",
    "kind": "Method",
    "detail": "Function (Handle = UE::CoreUObject::)",
    "insertText": "MakeObjectHandle(nullptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(FObjectPtr Other)"
  },
  {
    "label": "UE_OBJPTR_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UE_OBJPTR_DEPRECATED(5.0, \"Use of ToTObjectPtr is unsafe and is deprecated.\") FORCEINLINE TObjectPtr<UObject>& ToTObjectPtr()"
  },
  {
    "label": "UE_OBJPTR_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_OBJPTR_DEPRECATED(5.0, \"Use of ToTObjectPtr is unsafe and is deprecated.\") FORCEINLINE const TObjectPtr<UObject>& ToTObjectPtr()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} UObject&)",
    "insertText": "operator()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "IsResolved()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsResolved()"
  },
  {
    "label": "GetPath()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "GetPath()"
  },
  {
    "label": "GetPathName()",
    "kind": "Method",
    "detail": "Function (} # if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE FString)",
    "insertText": "GetPathName()"
  },
  {
    "label": "GetFName()",
    "kind": "Method",
    "detail": "Function (FName)",
    "insertText": "GetFName()"
  },
  {
    "label": "GetOuter()",
    "kind": "Method",
    "detail": "Function (} FObjectPtr)",
    "insertText": "GetOuter()"
  },
  {
    "label": "GetPackage()",
    "kind": "Method",
    "detail": "Function (FObjectPtr)",
    "insertText": "GetPackage()"
  },
  {
    "label": "GetFullName()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "GetFullName(EObjectFullNameFlags Flags = EObjectFullNameFlags::None)"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "GetName()"
  },
  {
    "label": "GetHandle()",
    "kind": "Method",
    "detail": "Function (} # endif FObjectHandle)",
    "insertText": "GetHandle()"
  },
  {
    "label": "IsA()",
    "kind": "Method",
    "detail": "Function (template<T> bool)",
    "insertText": "IsA()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} private : uint32)",
    "insertText": "GetTypeHash(const FObjectPtr& Object)"
  },
  {
    "label": "ConditionallyMarkAsReachable()",
    "kind": "Method",
    "detail": "Function (} union { FObjectHandle Handle ; UObject* DebugPtr ; } ; # if UE_OBJECT_PTR_GC_BARRIER void)",
    "insertText": "ConditionallyMarkAsReachable(const FObjectPtr& InPtr)"
  },
  {
    "label": "MarkAsReachable()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "MarkAsReachable(Obj)"
  },
  {
    "label": "ConditionallyMarkAsReachable()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "ConditionallyMarkAsReachable(const UObject* InObj)"
  },
  {
    "label": "MarkAsReachable()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "MarkAsReachable(InObj)"
  },
  {
    "label": "CoerceToPointer()",
    "kind": "Method",
    "detail": "Function (} } # endif } ; template<T> struct TPrivateObjectPtr ; namespace ObjectPtr_Private { template<T> const T*)",
    "insertText": "CoerceToPointer(const T* Other)"
  },
  {
    "label": "IsObjectPtrEqualToRawPtrOfRelatedType()",
    "kind": "Method",
    "detail": "Function (} template<T,U> bool)",
    "insertText": "IsObjectPtrEqualToRawPtrOfRelatedType(const TObjectPtr<T>& Ptr, const U* Other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!Other)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<T,U,)",
    "insertText": "decltype(CoerceToPointer<T>(std::declval<U>()) == std::declval<const T*>())* = nullptr UE_REQUIRES(!TIsTObjectPtr_V<U>) > bool IsObjectPtrEqual(const TObjectPtr<T>& Ptr, const U& Other)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T # if UE_WITH_OBJECT_HANDLE_TYPE_SAFETY)",
    "insertText": "UE_REQUIRES(std::is_same_v<std::remove_const_t<T>, UObject>) #endif > FORCEINLINE bool IsObjectPtrNull(const FObjectPtr& ObjectPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T # if UE_WITH_OBJECT_HANDLE_TYPE_SAFETY)",
    "insertText": "UE_REQUIRES(std::is_same_v<std::remove_const_t<T>, UObject>) #endif > FORCEINLINE T* Get(const FObjectPtr& ObjectPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} # if UE_WITH_OBJECT_HANDLE_TYPE_SAFETY template<T)",
    "insertText": "UE_REQUIRES(!std::is_same_v<std::remove_const_t<T>, UObject>) > FORCEINLINE bool IsObjectPtrNull(const FObjectPtr& ObjectPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T)",
    "insertText": "UE_REQUIRES(!std::is_same_v<std::remove_const_t<T>, UObject>) > FORCEINLINE T* Get(const FObjectPtr& ObjectPtr)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} # endif template<T,int =)",
    "insertText": "sizeof(T)> char (&ResolveTypeIsComplete(int))"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (template<T>)",
    "insertText": "char(&ResolveTypeIsComplete(...))"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (struct ; } ; template<T> struct TObjectPtr { # ifndef PLATFORM_COMPILER_IWYU)",
    "insertText": "static_assert(std::disjunction<std::bool_constant<sizeof(ObjectPtr_Private::ResolveTypeIsComplete<T>(1)) != 2>, std::is_base_of<UObject, T>>::value, \"TObjectPtr<T> can only be used with types derived from UObject\")"
  },
  {
    "label": "TObjectPtr()",
    "kind": "Method",
    "detail": "Function (# endif public : using ElementType = T ;)",
    "insertText": "TObjectPtr() : ObjectPtr()"
  },
  {
    "label": "TObjectPtr()",
    "kind": "Method",
    "detail": "Function (} # if UE_OBJECT_PTR_GC_BARRIER)",
    "insertText": "TObjectPtr(TObjectPtr<T>&& Other) : ObjectPtr(MoveTemp(Other.ObjectPtr))"
  },
  {
    "label": "TObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TObjectPtr(const TObjectPtr<T>& Other) : ObjectPtr(Other.ObjectPtr)"
  },
  {
    "label": "TObjectPtr()",
    "kind": "Method",
    "detail": "Function (} # else)",
    "insertText": "TObjectPtr(TObjectPtr<T>&& Other)"
  },
  {
    "label": "TObjectPtr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TObjectPtr(const TObjectPtr<T>& Other)"
  },
  {
    "label": "TObjectPtr()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "TObjectPtr(ENoInit) : ObjectPtr(NoInit)"
  },
  {
    "label": "TObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TObjectPtr(TYPE_OF_NULLPTR) : ObjectPtr(nullptr)"
  },
  {
    "label": "TObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TObjectPtr(FObjectPtr ObjPtr) : ObjectPtr(ObjPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > FORCEINLINE TObjectPtr(const TObjectPtr<U>& Other) : ObjectPtr(Other.ObjectPtr)"
  },
  {
    "label": "IWYU_MARKUP_IMPLICIT_CAST()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IWYU_MARKUP_IMPLICIT_CAST(U, T)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(!TIsTObjectPtr_V<std::decay_t<U>> && std::is_convertible_v<U, T*>) > FORCEINLINE TObjectPtr(const U& Object) : ObjectPtr(const_cast<std::remove_const_t<T>*>(ImplicitConv<T*>(Object)))"
  },
  {
    "label": "TObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TObjectPtr(T& Object) : ObjectPtr(const_cast<std::remove_const_t<T>*>(&Object))"
  },
  {
    "label": "TObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TObjectPtr(TPrivateObjectPtr<T>&& PrivatePtr) : ObjectPtr(const_cast<UObject*>(PrivatePtr.Pointer))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # if UE_OBJECT_PTR_GC_BARRIER TObjectPtr<T>&)",
    "insertText": "operator(TObjectPtr<T>&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (ObjectPtr =)",
    "insertText": "MoveTemp(Other.ObjectPtr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ObjectPtr = Other . ObjectPtr ; return* this ; } # else TObjectPtr<T>&)",
    "insertText": "operator(TObjectPtr<T>&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TObjectPtr<T>&)",
    "insertText": "operator(const TObjectPtr<T>&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif TObjectPtr<T>&)",
    "insertText": "operator(TYPE_OF_NULLPTR)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (ObjectPtr = nullptr ; return* this ; } template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > FORCEINLINE TObjectPtr<T>& operator=(const TObjectPtr<U>& Other)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (ObjectPtr = Other . ObjectPtr ; return* this ; } template<U)",
    "insertText": "UE_REQUIRES(!TIsTObjectPtr_V<std::decay_t<U>> && std::is_convertible_v<U, T*>) > FORCEINLINE TObjectPtr<T>& operator=(U&& Object)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (ObjectPtr = const_cast<std::remove_const_t<)",
    "insertText": "T(ImplicitConv<T*>(Object))"
  },
  {
    "label": "UObject()",
    "kind": "Method",
    "detail": "Function (ObjectPtr = const_cast<)",
    "insertText": "UObject(PrivatePtr.Pointer)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_TYPE_SAFETY)",
    "insertText": "if(ObjectPtr_Private::IsObjectPtrNull<T>(ObjectPtr))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ObjectPtr_Private::IsObjectPtrNull<U>(Other.ObjectPtr))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<U,=)",
    "insertText": "decltype(ObjectPtr_Private::IsObjectPtrEqual(std::declval<const TObjectPtr<T>&>(), std::declval<const U&>())) > FORCEINLINE bool operator==(const U& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # if __cplusplus<2 0 2 0 0 2 L template<U> auto)",
    "insertText": "operator(const U& Other) const -> decltype(!(*this == Other))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "T()"
  },
  {
    "label": "UE_OBJPTR_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "UE_OBJPTR_DEPRECATED(5.0, \"Explicit cast to other raw pointer types is deprecated. Please use the Cast API or get the raw pointer with ToRawPtr and cast that instead.\") explicit FORCEINLINE operator U* ()"
  },
  {
    "label": "UPTRINT()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "UPTRINT()"
  },
  {
    "label": "UE_OBJPTR_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UE_OBJPTR_DEPRECATED(5.0, \"Conversion to a mutable pointer is deprecated. Please pass a TObjectPtr<T>& instead so that assignment can be tracked accurately.\") explicit FORCEINLINE operator T*& ()"
  },
  {
    "label": "IsA()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsA(const UClass* SomeBase)"
  },
  {
    "label": "GetPtrTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetPtrTypeHash()"
  },
  {
    "label": "SerializePtrStructured()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SerializePtrStructured(FStructuredArchiveSlot Slot)"
  },
  {
    "label": "IsObjectPtrEqualToRawPtrOfRelatedType()",
    "kind": "Method",
    "detail": "Function (Slot<<ObjectPtr ; } ObjectPtr_Private::; struct FObjectPtr ; template<U> struct TObjectPtr ; template<U,V> bool)",
    "insertText": "IsObjectPtrEqualToRawPtrOfRelatedType(const TObjectPtr<U>& Ptr, const V* Other)"
  },
  {
    "label": "GetNoReadNoCheck()",
    "kind": "Method",
    "detail": "Function (private : T*)",
    "insertText": "GetNoReadNoCheck()"
  },
  {
    "label": "GetNoResolveNoCheck()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "GetNoResolveNoCheck()"
  },
  {
    "label": "GetInternalRef()",
    "kind": "Method",
    "detail": "Function (} T*&)",
    "insertText": "GetInternalRef()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (ObjectPtr_Private::Get<)",
    "insertText": "T(ObjectPtr)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE | | UE_WITH_OBJECT_HANDLE_TRACKING)",
    "insertText": "check(ObjectPtr.IsResolved())"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "return(T*&)ObjectPtr.GetHandleRef()"
  },
  {
    "label": "GetPtrTypeHash()",
    "kind": "Method",
    "detail": "Function (} union { FObjectPtr ObjectPtr ; T* DebugPtr ; } ; } ; template<T> struct TRemoveObjectPointer { typedef T Type ; } ; template<T> struct TRemoveObjectPointer<TObjectPtr<T>> { typedef T Type ; } ; namespace ObjectPtr_Private { template<T> struct TRawPointerType { using Type = T ; } ; template<T> struct TRawPointerType<TObjectPtr<T>> { using Type = T* ; } ; template<T> struct TRawPointerType<const TObjectPtr<T>> { using Type = T* ; } ; template<T> struct TRawPointerType<volatile TObjectPtr<T>> { using Type = T* ; } ; template<T> struct TRawPointerType<const volatile TObjectPtr<T>> { using Type = T* ; } ; struct { template<T> uint32)",
    "insertText": "GetPtrTypeHash(const TObjectPtr<T>& InObjectPtr)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} template<T> FArchive&)",
    "insertText": "Serialize(FArchive& Ar, TObjectPtr<T>& InObjectPtr)"
  },
  {
    "label": "SerializePtrStructured()",
    "kind": "Method",
    "detail": "Function (Ar<<InObjectPtr . ObjectPtr ; return Ar ; } template<T> void)",
    "insertText": "SerializePtrStructured(FStructuredArchiveSlot Slot, TObjectPtr<T>& InObjectPtr)"
  },
  {
    "label": "NoAccessTrackingGet()",
    "kind": "Method",
    "detail": "Function (Slot<<InObjectPtr . ObjectPtr ; } template<T> T*)",
    "insertText": "NoAccessTrackingGet(const TObjectPtr<T>& Ptr)"
  },
  {
    "label": "TNonAccessTrackedObjectPtr()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> class TNonAccessTrackedObjectPtr { public :)",
    "insertText": "TNonAccessTrackedObjectPtr()"
  },
  {
    "label": "TNonAccessTrackedObjectPtr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TNonAccessTrackedObjectPtr(ENoInit)"
  },
  {
    "label": "TNonAccessTrackedObjectPtr()",
    "kind": "Method",
    "detail": "Function (NoInit } { })",
    "insertText": "TNonAccessTrackedObjectPtr(T* Ptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ptr } { } TNonAccessTrackedObjectPtr&)",
    "insertText": "operator(T* Value)"
  },
  {
    "label": "GetAccessTrackedObjectPtr()",
    "kind": "Method",
    "detail": "Function (} TObjectPtr<T>&)",
    "insertText": "GetAccessTrackedObjectPtr()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} private : TObjectPtr<T> ObjectPtr ; } ; } template<T> uint32)",
    "insertText": "GetTypeHash(const TObjectPtr<T>& InObjectPtr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> FArchive&)",
    "insertText": "operator(FArchive& Ar, TObjectPtr<T>& InObjectPtr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "operator(FStructuredArchiveSlot Slot, TObjectPtr<T>& InObjectPtr)"
  },
  {
    "label": "SerializePtrStructured()",
    "kind": "Method",
    "detail": "Function (ObjectPtr_Private::)",
    "insertText": "SerializePtrStructured(Slot, InObjectPtr)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} # if ! PLATFORM_COMPILER_HAS_GENERATED_COMPARISON_OPERATORS template<T,U,)",
    "insertText": "decltype(ObjectPtr_Private::IsObjectPtrEqual(std::declval<const TObjectPtr<T>&>(), std::declval<const U&>()))* = nullptr > FORCEINLINE bool operator==(const U& Other, const TObjectPtr<T>& Ptr)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<T,U,)",
    "insertText": "decltype(ObjectPtr_Private::IsObjectPtrEqual(std::declval<const TObjectPtr<T>&>(), std::declval<const U&>()))* = nullptr > FORCEINLINE bool operator!=(const U& Other, const TObjectPtr<T>& Ptr)"
  },
  {
    "label": "MakeObjectPtrUnsafe()",
    "kind": "Method",
    "detail": "Function (} # endif template<T> TPrivateObjectPtr<T>)",
    "insertText": "MakeObjectPtrUnsafe(const UObject* Obj)"
  },
  {
    "label": "TPrivateObjectPtr()",
    "kind": "Method",
    "detail": "Function (template<T> struct TPrivateObjectPtr { public :)",
    "insertText": "TPrivateObjectPtr(const TPrivateObjectPtr<T>& Other)"
  },
  {
    "label": "TPrivateObjectPtr()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "TPrivateObjectPtr(const UObject* InPointer) : Pointer(InPointer)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} const UObject* Pointer ; struct TObjectPtr<T> ; TPrivateObjectPtr MakeObjectPtrUnsafe<)",
    "insertText": "T(const UObject* Obj)"
  },
  {
    "label": "ToRawPtr()",
    "kind": "Method",
    "detail": "Function (} template<T> T*)",
    "insertText": "ToRawPtr(T* Ptr)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE | | UE_WITH_OBJECT_HANDLE_TRACKING)",
    "insertText": "for(TObjectPtr<T>& Item : ArrayOfPtr)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} # endif return reinterpret_cast<)",
    "insertText": "T(ArrayOfPtr)"
  },
  {
    "label": "ToRawPtrArray()",
    "kind": "Method",
    "detail": "Function (} # endif template<T,SIZE_T Size> const T* const*)",
    "insertText": "ToRawPtrArray(const TObjectPtr<T>(&ArrayOfPtr)[Size])"
  },
  {
    "label": "ReinterpretRangeContiguous()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE | | UE_WITH_OBJECT_HANDLE_TRACKING using TypeCompat = TContainerElementTypeCompatibility<const TObjectPtr<T>> ;)",
    "insertText": "ReinterpretRangeContiguous(&ArrayOfPtr[0], &ArrayOfPtr[Size], Size)"
  },
  {
    "label": "const()",
    "kind": "Method",
    "detail": "Function (# endif return reinterpret_cast<const T*)",
    "insertText": "const(ArrayOfPtr)"
  },
  {
    "label": "ToRawPtrArrayUnsafe()",
    "kind": "Method",
    "detail": "Function (} template<T> T**)",
    "insertText": "ToRawPtrArrayUnsafe(T** ArrayOfPtr)"
  },
  {
    "label": "ReinterpretRange()",
    "kind": "Method",
    "detail": "Function (using ArrayElementType = ArrayTypeNoRef::ElementType ; using ArrayAllocatorType = ArrayTypeNoRef::AllocatorType ; using RawPointerType = ObjectPtr_Private::TRawPointerType<ArrayElementType>::Type ; using QualifiedRawPointerType = TCopyQualifiersFromTo<ArrayElementType,RawPointerType>::Type ; using NewArrayType = TArray<QualifiedRawPointerType,ArrayAllocatorType> ; using RefQualifiedNewArrayType = TCopyQualifiersAndRefsFromTo<ArrayType,NewArrayType>::Type ; # if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE | | UE_WITH_OBJECT_HANDLE_TRACKING using TypeCompat = TContainerElementTypeCompatibility<ArrayElementType> ;)",
    "insertText": "ReinterpretRange(Array.begin(), Array.end())"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "return(RefQualifiedNewArrayType&)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} PRAGMA_ENABLE_DEPRECATION_WARNINGS template<T> struct TContainerElementTypeCompatibility<TObjectPtr<T>> { typedef T* ReinterpretType ; typedef T* CopyFromOtherType ; template<IterBeginType,IterEndType,OperatorType = std::remove_reference_t<)",
    "insertText": "decltype(*std::declval<IterBeginType>())>& (*)(IterBeginType&)> UE_OBJPTR_DEPRECATED(5.0, \"Reinterpretation between ranges of one type to another type is deprecated.\") static void ReinterpretRange(IterBeginType Iter, IterEndType IterEnd, OperatorType Operator = [](IterBeginType& InIt) -> decltype(auto) { return *InIt; })"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE | | UE_WITH_OBJECT_HANDLE_TRACKING)",
    "insertText": "while(Iter != IterEnd)"
  },
  {
    "label": "Operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Operator(Iter).Get()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (+ + Iter ; } # endif } template<IterBeginType,IterEndType,SizeType,OperatorType = std::remove_reference_t<)",
    "insertText": "decltype(*std::declval<IterBeginType>())>& (*)(IterBeginType&)> UE_OBJPTR_DEPRECATED(5.0, \"Reinterpretation between ranges of one type to another type is deprecated.\") static void ReinterpretRangeContiguous(IterBeginType Iter, IterEndType IterEnd, SizeType Size, OperatorType Operator = [](IterBeginType& InIt) -> decltype(auto) { return *InIt; })"
  },
  {
    "label": "Operator()",
    "kind": "Method",
    "detail": "Function (auto& Ptr =)",
    "insertText": "Operator(Iter)"
  },
  {
    "label": "FObjectPtr()",
    "kind": "Method",
    "detail": "Function (const FObjectPtr& ObjPtr = reinterpret_cast<const)",
    "insertText": "FObjectPtr(Ptr)"
  },
  {
    "label": "ResolveObjectHandleNoRead()",
    "kind": "Method",
    "detail": "Function (UE::CoreUObject::)",
    "insertText": "ResolveObjectHandleNoRead(ObjPtr.GetHandleRef())"
  },
  {
    "label": "const()",
    "kind": "Method",
    "detail": "Function (+ + Iter ; } const UObject* const* ObjPtr = reinterpret_cast<const UObject*)",
    "insertText": "const(Begin)"
  },
  {
    "label": "OnHandleRead()",
    "kind": "Method",
    "detail": "Function (UE::CoreUObject::)",
    "insertText": "OnHandleRead(TArrayView<const UObject* const>(ObjPtr, Size))"
  },
  {
    "label": "UE_OBJPTR_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (# endif })",
    "insertText": "UE_OBJPTR_DEPRECATED(5.0, \"Copying ranges of one type to another type is deprecated.\") static constexpr void CopyingFromOtherType()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct TContainerElementTypeCompatibility<const TObjectPtr<T>> { typedef T* const ReinterpretType ; typedef T* const CopyFromOtherType ; template<IterBeginType,IterEndType,OperatorType = const std::remove_cv_t<std::remove_reference_t<)",
    "insertText": "decltype(*std::declval<IterBeginType>())>>&(*)(IterBeginType&)> UE_OBJPTR_DEPRECATED(5.0, \"Reinterpretation between ranges of one type to another type is deprecated.\") static void ReinterpretRange(IterBeginType Iter, IterEndType IterEnd, OperatorType Operator = [](IterBeginType& InIt) -> decltype(auto) { return *InIt; })"
  },
  {
    "label": "TDereferenceWrapper()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct TIsZeroConstructType<TObjectPtr<T>> { enum { Value = true } ; } ; template<T> struct TIsBitwiseConstructible<TObjectPtr<T>,T*> { enum { Value = ! UE_OBJECT_PTR_GC_BARRIER } ; } ; template<T,class PREDICATE_CLASS> struct TDereferenceWrapper<TObjectPtr<T>,PREDICATE_CLASS> { const PREDICATE_CLASS& Predicate ;)",
    "insertText": "TDereferenceWrapper(const PREDICATE_CLASS& InPredicate) : Predicate(InPredicate)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator()(const TObjectPtr<T>& A, const TObjectPtr<T>& B)"
  },
  {
    "label": "MakeWeakObjectPtr()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct TCallTraits<TObjectPtr<T>> : public TCallTraitsBase<TObjectPtr<T>> { using ConstPointerType = TCallTraitsParamTypeHelper<const TObjectPtr<const T>,true>::ConstParamType ; } ; template<T> TWeakObjectPtr<T>)",
    "insertText": "MakeWeakObjectPtr(TObjectPtr<T> Ptr)"
  },
  {
    "label": "ToTObjectPtr()",
    "kind": "Method",
    "detail": "Function (} TObjectPtr<UObject>&)",
    "insertText": "ToTObjectPtr()"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "Swap(TObjectPtr<T>& A, T*& B)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(static_cast<T*&>(MutableView(A)), B)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "Swap(T*& A, TObjectPtr<T>& B)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(A, static_cast<T*&>(MutableView(B)))"
  },
  {
    "label": "UE_OBJPTR_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (} # if ! UE_DEPRECATE_MUTABLE_TOBJECTPTR)",
    "insertText": "UE_OBJPTR_DEPRECATED(5.3, \"Swap between TObjectPtr arrays and raw pointer arrays is deprecated. Swap TArray<TObjectPtr<...>> values instead.\") template <typename T> inline void Swap(TArray<TObjectPtr<T>>& A, TArray<T*>& B)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(ToRawPtrTArrayUnsafe(A), B)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "Swap(TArray<T*>& A, TArray<TObjectPtr<T>>& B)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(A, ToRawPtrTArrayUnsafe(B))"
  },
  {
    "label": "Exchange()",
    "kind": "Method",
    "detail": "Function (} # endif template<T> void)",
    "insertText": "Exchange(TObjectPtr<T>& A, T*& B)"
  },
  {
    "label": "Exchange()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "Exchange(T*& A, TObjectPtr<T>& B)"
  },
  {
    "label": "UE_OBJPTR_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (} # if ! UE_DEPRECATE_MUTABLE_TOBJECTPTR)",
    "insertText": "UE_OBJPTR_DEPRECATED(5.3, \"Exchange between TObjectPtr arrays and raw pointer arrays is deprecated. Exchange TArray<TObjectPtr<...>> values instead.\") template <typename T> inline void Exchange(TArray<TObjectPtr<T>>& A, TArray<T*>& B)"
  },
  {
    "label": "Exchange()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "Exchange(TArray<T*>& A, TArray<TObjectPtr<T>>& B)"
  },
  {
    "label": "GetValid()",
    "kind": "Method",
    "detail": "Function (} # endif template<T> T*)",
    "insertText": "GetValid(const TObjectPtr<T>& Test)"
  },
  {
    "label": "ToRawPtr()",
    "kind": "Method",
    "detail": "Function (T* TestPtr =)",
    "insertText": "ToRawPtr(Test)"
  },
  {
    "label": "PerformDecayActions()",
    "kind": "Method",
    "detail": "Function (} template<T,DerivedType> struct TIsPointerOrObjectPtrToBaseOfImpl { enum { Value = false } ; } ; template<T,DerivedType> struct TIsPointerOrObjectPtrToBaseOfImpl<T*,DerivedType> { enum { Value = std::is_base_of_v<DerivedType,T> } ; } ; template<T,DerivedType> struct TIsPointerOrObjectPtrToBaseOfImpl<TObjectPtr<T>,DerivedType> { enum { Value = std::is_base_of_v<DerivedType,T> } ; } ; template<T,DerivedType> struct TIsPointerOrObjectPtrToBaseOf { enum { Value = TIsPointerOrObjectPtrToBaseOfImpl<std::remove_cv_t<T>,DerivedType>::Value } ; } ; template<T> struct TPointedToTypeImpl ; template<T> struct TPointedToTypeImpl<T*> { using Type = T ; } ; template<T> struct TPointedToTypeImpl<TObjectPtr<T>> { using Type = T ; } ; template<T> using TPointedToType = TPointedToTypeImpl<T>::Type ; namespace UE::Core::Private { template<T> struct TObjectPtrDecayTypeOf { using Type = T ; void)",
    "insertText": "PerformDecayActions(const T&)"
  },
  {
    "label": "PerformDecayActions()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct TObjectPtrDecayTypeOf<TObjectPtr<T>> { using Type = T* ; void)",
    "insertText": "PerformDecayActions(const TObjectPtr<T>& Value)"
  },
  {
    "label": "PerformDecayActions()",
    "kind": "Method",
    "detail": "Function (# endif } } ; template<T> struct TObjectPtrDecayTypeOf<TSet<T>> { using Type = TSet<TObjectPtrDecayTypeOf<T>::Type> ; void)",
    "insertText": "PerformDecayActions(const TSet<T>& Value)"
  },
  {
    "label": "PerformDecayActions()",
    "kind": "Method",
    "detail": "Function (TObjectPtrDecayTypeOf<T)",
    "insertText": "PerformDecayActions(V)"
  },
  {
    "label": "PerformDecayActions()",
    "kind": "Method",
    "detail": "Function (} } } ; template<K,V> struct TObjectPtrDecayTypeOf<TMap<K,V>> { using Type = TMap<TObjectPtrDecayTypeOf<K>::Type,TObjectPtrDecayTypeOf<V>::Type> ; void)",
    "insertText": "PerformDecayActions(const TMap<K, V>& Value)"
  },
  {
    "label": "PerformDecayActions()",
    "kind": "Method",
    "detail": "Function (TObjectPtrDecayTypeOf<K)",
    "insertText": "PerformDecayActions(KV.Key)"
  },
  {
    "label": "PerformDecayActions()",
    "kind": "Method",
    "detail": "Function (TObjectPtrDecayTypeOf<V)",
    "insertText": "PerformDecayActions(KV.Value)"
  },
  {
    "label": "PerformDecayActions()",
    "kind": "Method",
    "detail": "Function (} } } ; template<T> struct TObjectPtrDecayTypeOf<TArray<T>> { using Type = TArray<TObjectPtrDecayTypeOf<T>::Type> ; void)",
    "insertText": "PerformDecayActions(const TArray<T>& Value)"
  },
  {
    "label": "PerformDecayActions()",
    "kind": "Method",
    "detail": "Function (} } } ; template<T> struct TObjectPtrDecayTypeOf<TNonNullPtr<TObjectPtr<T>>> { using Type = TNonNullPtr<T> ; void)",
    "insertText": "PerformDecayActions(const TNonNullPtr<TObjectPtr<T>>& Value)"
  },
  {
    "label": "GetRef()",
    "kind": "Method",
    "detail": "Function (# if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE | | UE_WITH_OBJECT_HANDLE_TRACKING Value .)",
    "insertText": "GetRef().Get()"
  },
  {
    "label": "Decay()",
    "kind": "Method",
    "detail": "Function (# endif } } ; template<T> struct TObjectPtrWrapTypeOf { using Type = T ; } ; template<T> struct TObjectPtrWrapTypeOf<T*> { using Type = TObjectPtr<T> ; } ; template<T> struct TObjectPtrWrapTypeOf<TArrayView<T>> { using Type = TArrayView<TObjectPtrWrapTypeOf<T>::Type> ; } ; template<T> struct TObjectPtrWrapTypeOf<TArray<T>> { using Type = TArray<TObjectPtrWrapTypeOf<T>::Type> ; } ; template<T> struct TObjectPtrWrapTypeOf<TSet<T>> { using Type = TSet<TObjectPtrWrapTypeOf<T>::Type> ; } ; template<K,V> struct TObjectPtrWrapTypeOf<TMap<K,V>> { using Type = TMap<TObjectPtrWrapTypeOf<K>::Type,TObjectPtrWrapTypeOf<V>::Type> ; } ; namespace Unsafe { template<T,DecayTraits = UE::Core::Private::TObjectPtrDecayTypeOf<T>,U = DecayTraits::Type> [ [ nodiscard ] ] U&)",
    "insertText": "Decay(T& A)"
  },
  {
    "label": "PerformDecayActions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PerformDecayActions(A)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } template<T,ViewType> struct TMutableViewTraits {)",
    "insertText": "static_assert(sizeof(T) == 0, \"TMutableView not supported for this type. (Should it be?)\")"
  },
  {
    "label": "Close()",
    "kind": "Method",
    "detail": "Function (} ; template<T,ViewType> struct TMutableViewTraits<TObjectPtr<T>,ViewType> { void)",
    "insertText": "Close(ViewType& View)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if UE_OBJECT_PTR_GC_BARRIER)",
    "insertText": "if(UE::GC::GIsIncrementalReachabilityPending && View)"
  },
  {
    "label": "MarkAsReachable()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "MarkAsReachable(View)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if UE_OBJECT_PTR_GC_BARRIER)",
    "insertText": "if(UE::GC::GIsIncrementalReachabilityPending)"
  },
  {
    "label": "const()",
    "kind": "Method",
    "detail": "Function (const UObject* const* Data = reinterpret_cast<const UObject*)",
    "insertText": "const(View.GetData())"
  },
  {
    "label": "MarkAsReachable()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "MarkAsReachable(Data[Index])"
  },
  {
    "label": "MarkAsReachable()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "MarkAsReachable(Element)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# if UE_OBJECT_PTR_GC_BARRIER bool bKeyReference = TIsTObjectPtr_V<K> ; bool bValueReference = TIsTObjectPtr_V<V> ;)",
    "insertText": "static_assert(bKeyReference || bValueReference)"
  },
  {
    "label": "MarkAsReachable()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "MarkAsReachable(Pair.Key)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} } if)",
    "insertText": "constexpr(bValueReference)"
  },
  {
    "label": "MarkAsReachable()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "MarkAsReachable(Pair.Value)"
  },
  {
    "label": "TMutableView()",
    "kind": "Method",
    "detail": "Function (} } } } # endif } } ; template<T> class TMutableView { public : using ViewType = TObjectPtrDecayTypeOf<T>::Type ; using TraitType = UE::Core::Private::TMutableViewTraits<T,ViewType> ;)",
    "insertText": "TMutableView(T& Value)"
  },
  {
    "label": "Decay()",
    "kind": "Method",
    "detail": "Function (&)",
    "insertText": "Decay(Value)"
  },
  {
    "label": "TMutableView()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TMutableView()"
  },
  {
    "label": "Close()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Close(*View)"
  },
  {
    "label": "TMutableView()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TMutableView(const TMutableView&)"
  },
  {
    "label": "TMutableView()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TMutableView(TMutableView&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TMutableView&)",
    "insertText": "operator(const TMutableView&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TMutableView&)",
    "insertText": "operator(TMutableView&&)"
  },
  {
    "label": "ViewType()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "ViewType()"
  },
  {
    "label": "TMaybeObjectPtr()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TMaybeObjectPtr()"
  },
  {
    "label": "TMaybeObjectPtr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TMaybeObjectPtr(T* P)"
  },
  {
    "label": "ConditionallyMarkAsReachable()",
    "kind": "Method",
    "detail": "Function (P } {)",
    "insertText": "ConditionallyMarkAsReachable()"
  },
  {
    "label": "TMaybeObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TMaybeObjectPtr(const TMaybeObjectPtr& Other)"
  },
  {
    "label": "TMaybeObjectPtr()",
    "kind": "Method",
    "detail": "Function (Other . Ptr } { })",
    "insertText": "TMaybeObjectPtr(TMaybeObjectPtr&& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Other . Ptr } { } TMaybeObjectPtr&)",
    "insertText": "operator(const TMaybeObjectPtr& Other)"
  },
  {
    "label": "UObject()",
    "kind": "Method",
    "detail": "Function (TObjectPtr<UObject> ObjectPtr { const_cast<)",
    "insertText": "UObject(Obj)"
  },
  {
    "label": "AddReferencedObject()",
    "kind": "Method",
    "detail": "Function (Collector .)",
    "insertText": "AddReferencedObject(ObjectPtr, ReferencingObject)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} } T* Ptr { } ; } ; } template<T> [ [ nodiscard ] ])",
    "insertText": "decltype(auto) MutableView(T& A)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (std::remove_reference_t<)",
    "insertText": "decltype(X)"
  },
  {
    "label": "PerformDecayActions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PerformDecayActions(Value)"
  },
  {
    "label": "ObjectPtrWrap()",
    "kind": "Method",
    "detail": "Function (} template<T,U = UE::Core::Private::TObjectPtrWrapTypeOf<T>::Type> [ [ nodiscard ] ] U&)",
    "insertText": "ObjectPtrWrap(T& Value)"
  },
  {
    "label": "ObjectPtrWrap()",
    "kind": "Method",
    "detail": "Function (} template<T> using TObjectPtrWrapTypeOf = UE::Core::Private::TObjectPtrWrapTypeOf<T>::Type ; template<T,U = UE::Core::Private::TObjectPtrWrapTypeOf<T>::Type> [ [ nodiscard ] ] const U&)",
    "insertText": "ObjectPtrWrap(const T& Value)"
  },
  {
    "label": "StaticCastPtr()",
    "kind": "Method",
    "detail": "Function (} template<To,From> To*)",
    "insertText": "StaticCastPtr(const TObjectPtr<From>& P)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<T>)",
    "insertText": "decltype(auto) ConstCast(const TObjectPtr<T>& P)"
  },
  {
    "label": "TNonNullPtr()",
    "kind": "Method",
    "detail": "Function (} template<ObjectType> class TNonNullPtr<TObjectPtr<ObjectType>> { public :)",
    "insertText": "TNonNullPtr(EDefaultConstructNonNullPtr) : Object(nullptr)"
  },
  {
    "label": "TNonNullPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TNonNullPtr(TYPE_OF_NULLPTR)"
  },
  {
    "label": "TNonNullPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TNonNullPtr(TObjectPtr<ObjectType> InObject) : Object(InObject)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<OtherObjectType)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<OtherObjectType*, ObjectType*>) > FORCEINLINE TNonNullPtr(const TNonNullPtr<OtherObjectType>& Other) : Object(Other.Object)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (Object = InObject ; return* this ; } template<OtherObjectType)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<OtherObjectType*, ObjectType*>) > FORCEINLINE TNonNullPtr& operator=(const TNonNullPtr<OtherObjectType>& Other)"
  },
  {
    "label": "ObjectType()",
    "kind": "Method",
    "detail": "Function (Object = Other . Object ; return* this ; } operator)",
    "insertText": "ObjectType()"
  }
]