[
  {
    "label": "LanguageBreakEngine",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LanguageBreakEngine"
  },
  {
    "label": "RBBIDataHeader",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RBBIDataHeader"
  },
  {
    "label": "RBBIDataWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RBBIDataWrapper"
  },
  {
    "label": "UnhandledEngine",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnhandledEngine"
  },
  {
    "label": "UStack",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UStack"
  },
  {
    "label": "U_COMMON_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U_COMMON_API"
  },
  {
    "label": "BreakCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BreakCache"
  },
  {
    "label": "DictionaryCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DictionaryCache"
  },
  {
    "label": "RBBIRuleBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RBBIRuleBuilder"
  },
  {
    "label": "BreakIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BreakIterator"
  },
  {
    "label": "RuleBasedBreakIterator()",
    "kind": "Method",
    "detail": "Function (# ifndef RBBI_H # define RBBI_H # include \" unicode / utypes . h \" # if ! UCONFIG_NO_BREAK_ITERATION # include \" unicode / brkiter . h \" # include \" unicode / udata . h \" # include \" unicode / parseerr . h \" # include \" unicode / schriter . h \" U_NAMESPACE_BEGIN class LanguageBreakEngine ; struct RBBIDataHeader ; class RBBIDataWrapper ; class UnhandledEngine ; class UStack ; class RuleBasedBreakIterator : public BreakIterator { private : UText fText ; # ifndef public : # endif RBBIDataWrapper* fData ; private : int32_t fPosition ; int32_t fRuleStatusIndex ; class BreakCache ; BreakCache* fBreakCache ; class DictionaryCache ; DictionaryCache* fDictionaryCache ; UStack* fLanguageBreakEngines ; UnhandledEngine* fUnhandledBreakEngine ; uint32_t fDictionaryCharCount ; CharacterIterator* fCharIter ; StringCharacterIterator fSCharIter ; UBool fDone ;)",
    "insertText": "RuleBasedBreakIterator(RBBIDataHeader* data, UErrorCode &status)"
  },
  {
    "label": "RuleBasedBreakIterator()",
    "kind": "Method",
    "detail": "Function (class RBBIRuleBuilder ; class BreakIterator ; public :)",
    "insertText": "RuleBasedBreakIterator()"
  },
  {
    "label": "RuleBasedBreakIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RuleBasedBreakIterator(const RuleBasedBreakIterator& that)"
  },
  {
    "label": "RuleBasedBreakIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RuleBasedBreakIterator(const UnicodeString &rules, UParseError &parseError, UErrorCode &status)"
  },
  {
    "label": "RuleBasedBreakIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RuleBasedBreakIterator(const uint8_t *compiledRules, uint32_t ruleLength, UErrorCode &status)"
  },
  {
    "label": "RuleBasedBreakIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RuleBasedBreakIterator(UDataMemory* image, UErrorCode &status)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RuleBasedBreakIterator&)",
    "insertText": "operator(const RuleBasedBreakIterator& that)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "operator(const BreakIterator& that)"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (BreakIterator*)",
    "insertText": "clone()"
  },
  {
    "label": "hashCode()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "hashCode(void)"
  },
  {
    "label": "getRules()",
    "kind": "Method",
    "detail": "Function (const UnicodeString&)",
    "insertText": "getRules(void)"
  },
  {
    "label": "getText()",
    "kind": "Method",
    "detail": "Function (CharacterIterator&)",
    "insertText": "getText(void)"
  },
  {
    "label": "getUText()",
    "kind": "Method",
    "detail": "Function (UText*)",
    "insertText": "getUText(UText *fillIn, UErrorCode &status)"
  },
  {
    "label": "adoptText()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "adoptText(CharacterIterator* newText)"
  },
  {
    "label": "setText()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setText(const UnicodeString& newText)"
  },
  {
    "label": "setText()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setText(UText *text, UErrorCode &status)"
  },
  {
    "label": "first()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "first(void)"
  },
  {
    "label": "last()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "last(void)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "next(int32_t n)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "next(void)"
  },
  {
    "label": "previous()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "previous(void)"
  },
  {
    "label": "following()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "following(int32_t offset)"
  },
  {
    "label": "preceding()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "preceding(int32_t offset)"
  },
  {
    "label": "isBoundary()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "isBoundary(int32_t offset)"
  },
  {
    "label": "current()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "current(void)"
  },
  {
    "label": "getRuleStatus()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getRuleStatus()"
  },
  {
    "label": "getRuleStatusVec()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getRuleStatusVec(int32_t *fillInVec, int32_t capacity, UErrorCode &status)"
  },
  {
    "label": "getDynamicClassID()",
    "kind": "Method",
    "detail": "Function (UClassID)",
    "insertText": "getDynamicClassID(void)"
  },
  {
    "label": "getStaticClassID()",
    "kind": "Method",
    "detail": "Function (UClassID U_EXPORT2)",
    "insertText": "getStaticClassID(void)"
  },
  {
    "label": "createBufferClone()",
    "kind": "Method",
    "detail": "Function (BreakIterator*)",
    "insertText": "createBufferClone(void *stackBuffer, int32_t &BufferSize, UErrorCode &status)"
  },
  {
    "label": "getBinaryRules()",
    "kind": "Method",
    "detail": "Function (const uint8_t*)",
    "insertText": "getBinaryRules(uint32_t &length)"
  },
  {
    "label": "refreshInputText()",
    "kind": "Method",
    "detail": "Function (RuleBasedBreakIterator&)",
    "insertText": "refreshInputText(UText *input, UErrorCode &status)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "reset(void)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init(UErrorCode &status)"
  },
  {
    "label": "handleSafePrevious()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "handleSafePrevious(int32_t fromPosition)"
  },
  {
    "label": "handleNext()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "handleNext()"
  },
  {
    "label": "getLanguageBreakEngine()",
    "kind": "Method",
    "detail": "Function (const LanguageBreakEngine*)",
    "insertText": "getLanguageBreakEngine(UChar32 c)"
  },
  {
    "label": "dumpCache()",
    "kind": "Method",
    "detail": "Function (public : # ifndef void)",
    "insertText": "dumpCache()"
  },
  {
    "label": "dumpTables()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dumpTables()"
  }
]