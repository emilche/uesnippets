[
  {
    "label": "FTriangleMesh",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTriangleMesh"
  },
  {
    "label": "FPBDCollisionSpringConstraintsBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDCollisionSpringConstraintsBase"
  },
  {
    "label": "struct",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "struct"
  },
  {
    "label": "BackCompatThickness()",
    "kind": "Method",
    "detail": "Function (# pragma once # if ! COMPILE_WITHOUT_UNREAL_SUPPORT # include \" Chaos / Core . h \" # include \" Chaos / PBDFlatWeightMap . h \" # include \" Chaos / PBDSoftsEvolutionFwd . h \" # include \" Chaos / PBDSoftsSolverParticles . h \" # include \" Chaos / PBDTriangleMeshCollisions . h \" # include \" Containers / Set . h \" namespace Chaos { class FTriangleMesh ; } namespace Chaos::Softs { class FPBDCollisionSpringConstraintsBase { public : FSolverReal)",
    "insertText": "BackCompatThickness(FSolverReal)"
  },
  {
    "label": "BackCompatStiffness()",
    "kind": "Method",
    "detail": "Function (FSolverReal)",
    "insertText": "BackCompatStiffness(FSolverReal)"
  },
  {
    "label": "BackCompatFrictionCoefficient()",
    "kind": "Method",
    "detail": "Function (FSolverReal)",
    "insertText": "BackCompatFrictionCoefficient(FSolverReal)"
  },
  {
    "label": "DefaultKinematicColliderThickness()",
    "kind": "Method",
    "detail": "Function (FSolverReal)",
    "insertText": "DefaultKinematicColliderThickness(FSolverReal)"
  },
  {
    "label": "DefaultKinematicColliderStiffness()",
    "kind": "Method",
    "detail": "Function (FSolverReal)",
    "insertText": "DefaultKinematicColliderStiffness(FSolverReal)"
  },
  {
    "label": "DefaultKinematicColliderFrictionCoefficient()",
    "kind": "Method",
    "detail": "Function (FSolverReal)",
    "insertText": "DefaultKinematicColliderFrictionCoefficient(FSolverReal)"
  },
  {
    "label": "DefaultProximityStiffness()",
    "kind": "Method",
    "detail": "Function (FSolverReal)",
    "insertText": "DefaultProximityStiffness(FSolverReal)"
  },
  {
    "label": "FPBDCollisionSpringConstraintsBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPBDCollisionSpringConstraintsBase(const int32 InOffset, const int32 InNumParticles, const FTriangleMesh& InTriangleMesh, const TArray<FSolverVec3>* InReferencePositions, TSet<TVec2<int32>>&& InDisabledCollisionElements, const TConstArrayView<FRealSingle>& InThicknessMultipliers, const TConstArrayView<FRealSingle>& InKinematicColliderFrictionMultipliers, const TConstArrayView<int32>& InSelfCollisionLayers, const FSolverVec2 InThickness = FSolverVec2(BackCompatThickness), const FSolverReal InStiffness = BackCompatStiffness, const FSolverReal InFrictionCoefficient = BackCompatFrictionCoefficient, const bool bInOnlyCollideKinematics = false, const FSolverReal InKinematicColliderThickness = DefaultKinematicColliderThickness, const FSolverReal InKinematicColliderStiffness = DefaultKinematicColliderStiffness, const FSolverVec2 InKinematicColliderFrictionCoefficient = FSolverVec2(DefaultKinematicColliderFrictionCoefficient), const FSolverReal InProximityStiffness = DefaultProximityStiffness)"
  },
  {
    "label": "FPBDCollisionSpringConstraintsBase()",
    "kind": "Method",
    "detail": "Function (} PRAGMA_DISABLE_DEPRECATION_WARNINGS ~)",
    "insertText": "FPBDCollisionSpringConstraintsBase()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (template<SpatialAccelerator,SolverParticlesOrRange> void)",
    "insertText": "Init(const SolverParticlesOrRange& Particles, const FSolverReal Dt, const FPBDTriangleMeshCollisions::FTriangleSubMesh& CollidableSubMesh, const SpatialAccelerator& DynamicSpatial, const SpatialAccelerator& KinematicColliderSpatial, const TConstArrayView<FPBDTriangleMeshCollisions::FGIAColor>& VertexGIAColors, const TArray<FPBDTriangleMeshCollisions::FGIAColor>& TriangleGIAColors)"
  },
  {
    "label": "GetDelta()",
    "kind": "Method",
    "detail": "Function (template<SolverParticlesOrRange> FSolverVec3)",
    "insertText": "GetDelta(const SolverParticlesOrRange& InParticles, const int32 i)"
  },
  {
    "label": "GetConstraints()",
    "kind": "Method",
    "detail": "Function (const TArray<TVec4<int32>>&)",
    "insertText": "GetConstraints()"
  },
  {
    "label": "GetBarys()",
    "kind": "Method",
    "detail": "Function (PRAGMA_DISABLE_DEPRECATION_WARNINGS return Constraints ; PRAGMA_ENABLE_DEPRECATION_WARNINGS } const TArray<FSolverVec3>&)",
    "insertText": "GetBarys()"
  },
  {
    "label": "GetMaxThickness()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "GetMaxThickness()"
  },
  {
    "label": "GetParticleThickness()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "GetParticleThickness(int32 ParticleIndex)"
  },
  {
    "label": "GetThicknessWeighted()",
    "kind": "Method",
    "detail": "Function (} const FPBDFlatWeightMap&)",
    "insertText": "GetThicknessWeighted()"
  },
  {
    "label": "GetKinematicCollidingParticles()",
    "kind": "Method",
    "detail": "Function (PRAGMA_DISABLE_DEPRECATION_WARNINGS return FlipNormal ; PRAGMA_ENABLE_DEPRECATION_WARNINGS } const TArray<int32>&)",
    "insertText": "GetKinematicCollidingParticles()"
  },
  {
    "label": "SetThicknessWeighted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetThicknessWeighted(FSolverVec2(InThickness))"
  },
  {
    "label": "SetThicknessWeighted()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetThicknessWeighted(const FSolverVec2 InThickness)"
  },
  {
    "label": "SetWeightedValue()",
    "kind": "Method",
    "detail": "Function (ThicknessWeighted .)",
    "insertText": "SetWeightedValue(FSolverVec2::Max(InThickness, FSolverVec2(0.f)))"
  },
  {
    "label": "SetFrictionCoefficient()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetFrictionCoefficient(FSolverReal InFrictionCoefficient)"
  },
  {
    "label": "Apply()",
    "kind": "Method",
    "detail": "Function (FrictionCoefficient = InFrictionCoefficient ; } template<SolverParticlesOrRange> void)",
    "insertText": "Apply(SolverParticlesOrRange& Particles, const FSolverReal Dt, const int32 ConstraintIndex)"
  },
  {
    "label": "GetDelta()",
    "kind": "Method",
    "detail": "Function (PRAGMA_DISABLE_DEPRECATION_WARNINGS const TVector<int32,4>& Constraint = Constraints [ ConstraintIndex ] ; const int32 Index1 = Constraint [ 0 ] ; const int32 Index2 = Constraint [ 1 ] ; const int32 Index3 = Constraint [ 2 ] ; const int32 Index4 = Constraint [ 3 ] ; const FSolverVec3 Delta =)",
    "insertText": "GetDelta(Particles, ConstraintIndex)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (Particles .)",
    "insertText": "P(Index1) += Particles.InvM(Index1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Particles.InvM(Index2) > (FSolverReal)0.)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (Particles .)",
    "insertText": "P(Index2) -= Particles.InvM(Index2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Particles.InvM(Index3) > (FSolverReal)0.)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (Particles .)",
    "insertText": "P(Index3) -= Particles.InvM(Index3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Particles.InvM(Index4) > (FSolverReal)0.)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (Particles .)",
    "insertText": "P(Index4) -= Particles.InvM(Index4)"
  },
  {
    "label": "Apply()",
    "kind": "Method",
    "detail": "Function (} PRAGMA_ENABLE_DEPRECATION_WARNINGS } template<SolverParticlesOrRange> void)",
    "insertText": "Apply(SolverParticlesOrRange& InParticles, const FSolverReal Dt)"
  },
  {
    "label": "Apply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Apply(FSolverParticles& InParticles, const FSolverReal Dt, const TArray<int32>& InConstraintIndices)"
  },
  {
    "label": "Apply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Apply(InParticles, Dt, ConstraintIndex)"
  },
  {
    "label": "UpdateLinearSystem()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "UpdateLinearSystem(const FSolverParticlesRange& Particles, const FSolverReal Dt, FEvolutionLinearSystem& LinearSystem)"
  },
  {
    "label": "GetFaceCollisionLayers()",
    "kind": "Method",
    "detail": "Function (TConstArrayView<int32>)",
    "insertText": "GetFaceCollisionLayers()"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (} PRAGMA_DISABLE_DEPRECATION_WARNINGS const TVec4<int32>& Constraint = Constraints [ ConstraintIndex ] ; const FSolverVec3& Bary = Barys [ ConstraintIndex ] ; PRAGMA_ENABLE_DEPRECATION_WARNINGS const int32 Index1 = Constraint [ 0 ] - Offset ; const int32 Index2 = Constraint [ 1 ] - Offset ; const int32 Index3 = Constraint [ 2 ] - Offset ; const int32 Index4 = Constraint [ 3 ] - Offset ; return ThicknessWeighted .)",
    "insertText": "GetValue(Index1) + Bary[0] * ThicknessWeighted.GetValue(Index2) + Bary[1] * ThicknessWeighted.GetValue(Index3) + Bary[2] * ThicknessWeighted.GetValue(Index4)"
  },
  {
    "label": "GetConstraintFrictionCoefficient()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "GetConstraintFrictionCoefficient(const int32 ConstraintIndex)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (default : case EConstraintType::Default : return FrictionCoefficient ; case EConstraintType::GIAFlipped :)",
    "insertText": "return(FSolverReal)"
  },
  {
    "label": "UpdateCollisionLayers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateCollisionLayers(const TConstArrayView<int32>& InFaceCollisionLayers)"
  },
  {
    "label": "GetNumParticles()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumParticles()"
  },
  {
    "label": "ApplyKinematicConstraints()",
    "kind": "Method",
    "detail": "Function (template<SolverParticlesOrRange> void)",
    "insertText": "ApplyKinematicConstraints(SolverParticlesOrRange& InParticles, const FSolverReal Dt)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (const FTriangleMesh& TriangleMesh ; const TArray<FSolverVec3>* ReferencePositions ; const TSet<TVec2<int32>> DisabledCollisionElements ; TConstArrayView<int32> FaceCollisionLayers ; TArray<TVector<int32,2>> VertexCollisionLayers ; enum struct EConstraintType : uint8 { Default,GIAFlipped,} ; TArray<EConstraintType> ConstraintTypes ; int32 MaxKinematicConnectionsPerPoint = 3 ; TArray<int32> KinematicCollidingParticles ; TArray<TVector<int32,MaxKinematicConnectionsPerPoint>> KinematicColliderElements ; TArray<TMap<int32,FSolverReal>> KinematicColliderTimers ; int32 Offset ; int32 NumParticles ; bool bGlobalIntersectionAnalysis ; } ; } # if !)",
    "insertText": "defined(CHAOS_COLLISION_SPRING_ISPC_ENABLED_DEFAULT)"
  }
]