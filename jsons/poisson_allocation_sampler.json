[
  {
    "label": "HeapProfilerControllerTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HeapProfilerControllerTest"
  },
  {
    "label": "SamplingHeapProfilerTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SamplingHeapProfilerTest"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "AllocatorType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "AllocatorType"
  },
  {
    "label": "SamplesObserver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SamplesObserver"
  },
  {
    "label": "heap_profiling",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "heap_profiling"
  },
  {
    "label": "NoDestructor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NoDestructor"
  },
  {
    "label": "SamplesObserver()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_SAMPLING_HEAP_PROFILER_POISSON_ALLOCATION_SAMPLER_H_ # define BASE_SAMPLING_HEAP_PROFILER_POISSON_ALLOCATION_SAMPLER_H_ # include<vector> # include \" base / base_export . h \" # include \" base / compiler_specific . h \" # include \" base / gtest_prod_util . h \" # include \" base / no_destructor . h \" # include \" base / sampling_heap_profiler / lock_free_address_hash_set . h \" # include \" base / synchronization / lock . h \" # include \" base / thread_annotations . h \" namespace heap_profiling { class HeapProfilerControllerTest ; } namespace base { class SamplingHeapProfilerTest ; class BASE_EXPORT PoissonAllocationSampler { public : enum AllocatorType : uint32_t { kMalloc,kPartitionAlloc,kManualForTesting } ; class SamplesObserver { public : ~)",
    "insertText": "SamplesObserver()"
  },
  {
    "label": "SampleAdded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SampleAdded(void* address, size_t size, size_t total, AllocatorType type, const char* context)"
  },
  {
    "label": "SampleRemoved()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SampleRemoved(void* address)"
  },
  {
    "label": "ScopedMuteThreadSamples()",
    "kind": "Method",
    "detail": "Function (} ; class BASE_EXPORT ScopedMuteThreadSamples { public :)",
    "insertText": "ScopedMuteThreadSamples()"
  },
  {
    "label": "ScopedMuteThreadSamples()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScopedMuteThreadSamples(const ScopedMuteThreadSamples&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ScopedMuteThreadSamples&)",
    "insertText": "operator(const ScopedMuteThreadSamples&)"
  },
  {
    "label": "IsMuted()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsMuted()"
  },
  {
    "label": "ScopedSuppressRandomnessForTesting()",
    "kind": "Method",
    "detail": "Function (} ; class BASE_EXPORT ScopedSuppressRandomnessForTesting { public :)",
    "insertText": "ScopedSuppressRandomnessForTesting()"
  },
  {
    "label": "ScopedSuppressRandomnessForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScopedSuppressRandomnessForTesting(const ScopedSuppressRandomnessForTesting&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ScopedSuppressRandomnessForTesting&)",
    "insertText": "operator(const ScopedSuppressRandomnessForTesting&)"
  },
  {
    "label": "IsSuppressed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSuppressed()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "Init()"
  },
  {
    "label": "SetHooksInstallCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetHooksInstallCallback(void (*hooks_install_callback)())"
  },
  {
    "label": "AddSamplesObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddSamplesObserver(SamplesObserver*)"
  },
  {
    "label": "RemoveSamplesObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveSamplesObserver(SamplesObserver*)"
  },
  {
    "label": "SetSamplingInterval()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSamplingInterval(size_t sampling_interval_bytes)"
  },
  {
    "label": "SamplingInterval()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "SamplingInterval()"
  },
  {
    "label": "RecordAlloc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecordAlloc(void* address, size_t, AllocatorType, const char* context)"
  },
  {
    "label": "RecordFree()",
    "kind": "Method",
    "detail": "Function (ALWAYS_INLINE void)",
    "insertText": "RecordFree(void* address)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (PoissonAllocationSampler*)",
    "insertText": "Get()"
  },
  {
    "label": "PoissonAllocationSampler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PoissonAllocationSampler(const PoissonAllocationSampler&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (PoissonAllocationSampler&)",
    "insertText": "operator(const PoissonAllocationSampler&)"
  },
  {
    "label": "AreHookedSamplesMuted()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AreHookedSamplesMuted()"
  },
  {
    "label": "ScopedMuteHookedSamplesForTesting()",
    "kind": "Method",
    "detail": "Function (private : class BASE_EXPORT ScopedMuteHookedSamplesForTesting { public :)",
    "insertText": "ScopedMuteHookedSamplesForTesting()"
  },
  {
    "label": "ScopedMuteHookedSamplesForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScopedMuteHookedSamplesForTesting(const ScopedMuteHookedSamplesForTesting&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ScopedMuteHookedSamplesForTesting&)",
    "insertText": "operator(const ScopedMuteHookedSamplesForTesting&)"
  },
  {
    "label": "PoissonAllocationSampler()",
    "kind": "Method",
    "detail": "Function (private : intptr_t accumulated_bytes_snapshot_ ; } ;)",
    "insertText": "PoissonAllocationSampler()"
  },
  {
    "label": "InstallAllocatorHooksOnce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InstallAllocatorHooksOnce()"
  },
  {
    "label": "GetNextSampleInterval()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetNextSampleInterval(size_t base_interval)"
  },
  {
    "label": "sampled_addresses_set()",
    "kind": "Method",
    "detail": "Function (LockFreeAddressHashSet&)",
    "insertText": "sampled_addresses_set()"
  },
  {
    "label": "DoRecordAlloc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DoRecordAlloc(intptr_t accumulated_bytes, size_t size, void* address, AllocatorType type, const char* context)"
  },
  {
    "label": "DoRecordFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DoRecordFree(void* address)"
  },
  {
    "label": "BalanceAddressesHashSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BalanceAddressesHashSet()"
  },
  {
    "label": "GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (Lock mutex_ ; std::vector<SamplesObserver*> observers_)",
    "insertText": "GUARDED_BY(mutex_)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (PoissonAllocationSampler* instance_ ; class heap_profiling::HeapProfilerControllerTest ; class NoDestructor<PoissonAllocationSampler> ; class SamplingHeapProfilerTest ;)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(PoissonAllocationSamplerTest, MuteHooksWithoutInit)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(SamplingHeapProfilerTest, HookedAllocatorMuted)"
  }
]