[
  {
    "label": "NVCORE_CLASS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NVCORE_CLASS"
  },
  {
    "label": "TokenizerException",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TokenizerException"
  },
  {
    "label": "Token()",
    "kind": "Method",
    "detail": "Function (# ifndef NV_CORE_TOKENIZER_H # define NV_CORE_TOKENIZER_H # include<nvcore / nvcore . h> # include<nvcore / Stream . h> # include<nvcore / TextReader . h> # include<nvcore / StrLib . h> namespace nv { class NVCORE_CLASS Token { public :)",
    "insertText": "Token()"
  },
  {
    "label": "Token()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Token(const Token & token)"
  },
  {
    "label": "Token()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Token(const char * str, int len)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const char * str)"
  },
  {
    "label": "isNull()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isNull()"
  },
  {
    "label": "toFloat()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "toFloat()"
  },
  {
    "label": "toInt()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "toInt()"
  },
  {
    "label": "toUnsignedInt()",
    "kind": "Method",
    "detail": "Function (uint)",
    "insertText": "toUnsignedInt()"
  },
  {
    "label": "toString()",
    "kind": "Method",
    "detail": "Function (String)",
    "insertText": "toString()"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "parse(const char * format, int count, ...) const __attribute__((format (scanf, 2, 4)))"
  },
  {
    "label": "TokenizerException()",
    "kind": "Method",
    "detail": "Function (private : const char* m_str ; int m_len ; } ; class TokenizerException { public :)",
    "insertText": "TokenizerException(int line, int column) : m_line(line), m_column(column)"
  },
  {
    "label": "line()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "line()"
  },
  {
    "label": "nextLine()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "nextLine(bool skipEmptyLines = true)"
  },
  {
    "label": "nextToken()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "nextToken(bool skipEndOfLine = false)"
  },
  {
    "label": "token()",
    "kind": "Method",
    "detail": "Function (const Token&)",
    "insertText": "token()"
  },
  {
    "label": "delimiters()",
    "kind": "Method",
    "detail": "Function (m_delimiters = str ; } const char*)",
    "insertText": "delimiters()"
  },
  {
    "label": "spaces()",
    "kind": "Method",
    "detail": "Function (m_spaces = str ; } const char*)",
    "insertText": "spaces()"
  },
  {
    "label": "readLine()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "readLine()"
  },
  {
    "label": "readToken()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "readToken()"
  },
  {
    "label": "skipSpaces()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "skipSpaces()"
  },
  {
    "label": "isSpace()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isSpace(char c)"
  },
  {
    "label": "isDelimiter()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isDelimiter(char c)"
  }
]