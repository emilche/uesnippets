[
  {
    "label": "ir_node_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ir_node_type"
  },
  {
    "label": "ir_instruction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_instruction"
  },
  {
    "label": "hash_table",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "hash_table"
  },
  {
    "label": "ir_variable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_variable"
  },
  {
    "label": "ir_function",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_function"
  },
  {
    "label": "ir_dereference",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_dereference"
  },
  {
    "label": "ir_dereference_array",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_dereference_array"
  },
  {
    "label": "ir_dereference_image",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_dereference_image"
  },
  {
    "label": "ir_dereference_record",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_dereference_record"
  },
  {
    "label": "ir_dereference_variable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_dereference_variable"
  },
  {
    "label": "ir_expression",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_expression"
  },
  {
    "label": "ir_rvalue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_rvalue"
  },
  {
    "label": "ir_loop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_loop"
  },
  {
    "label": "ir_assignment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_assignment"
  },
  {
    "label": "ir_call",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_call"
  },
  {
    "label": "ir_return",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_return"
  },
  {
    "label": "ir_if",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_if"
  },
  {
    "label": "ir_swizzle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_swizzle"
  },
  {
    "label": "ir_constant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_constant"
  },
  {
    "label": "ir_discard",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_discard"
  },
  {
    "label": "ir_atomic",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_atomic"
  },
  {
    "label": "ir_texture",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_texture"
  },
  {
    "label": "glsl_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "glsl_type"
  },
  {
    "label": "ir_variable_mode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ir_variable_mode"
  },
  {
    "label": "ir_variable_interpolation",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ir_variable_interpolation"
  },
  {
    "label": "ir_depth_layout",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ir_depth_layout"
  },
  {
    "label": "ir_geometry_input",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ir_geometry_input"
  },
  {
    "label": "ir_state_slot",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ir_state_slot"
  },
  {
    "label": "ir_function_signature",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_function_signature"
  },
  {
    "label": "exec_list",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "exec_list"
  },
  {
    "label": "if_mode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "if_mode"
  },
  {
    "label": "loop_mode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "loop_mode"
  },
  {
    "label": "ir_expression_operation",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ir_expression_operation"
  },
  {
    "label": "ir_jump",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_jump"
  },
  {
    "label": "ir_loop_jump",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_loop_jump"
  },
  {
    "label": "jump_mode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "jump_mode"
  },
  {
    "label": "ir_texture_opcode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ir_texture_opcode"
  },
  {
    "label": "ir_texture_channel",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ir_texture_channel"
  },
  {
    "label": "ir_swizzle_mask",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ir_swizzle_mask"
  },
  {
    "label": "ir_image_op",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ir_image_op"
  },
  {
    "label": "ir_atomic_op",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ir_atomic_op"
  },
  {
    "label": "_mesa_glsl_parse_state",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_mesa_glsl_parse_state"
  },
  {
    "label": "gl_shader_program",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gl_shader_program"
  },
  {
    "label": "glsl_symbol_table",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "glsl_symbol_table"
  },
  {
    "label": "ast_expression",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_expression"
  },
  {
    "label": "YYLTYPE",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "YYLTYPE"
  },
  {
    "label": "AreEquivalent()",
    "kind": "Method",
    "detail": "Function (# pragma once # ifndef IR_H # define IR_H # include \" ralloc . h \" # include \" glsl_types . h \" # include \" cclist . h \" # include \" ir_visitor . h \" # include \" ir_hierarchical_visitor . h \" # include \" glsl_parser_extras . h \" enum ir_node_type { ir_type_unset,ir_type_variable,ir_type_assignment,ir_type_call,ir_type_constant,ir_type_dereference_array,ir_type_dereference_image,ir_type_dereference_record,ir_type_dereference_variable,ir_type_discard,ir_type_expression,ir_type_function,ir_type_function_signature,ir_type_if,ir_type_loop,ir_type_loop_jump,ir_type_return,ir_type_swizzle,ir_type_texture,ir_type_atomic,ir_type_max } ; bool)",
    "insertText": "AreEquivalent(class ir_instruction* A, class ir_instruction* B)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (class ir_instruction : public exec_node { public : enum ir_node_type ir_type ; void)",
    "insertText": "print(void)"
  },
  {
    "label": "accept()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "accept(ir_visitor*)"
  },
  {
    "label": "accept()",
    "kind": "Method",
    "detail": "Function (ir_visitor_status)",
    "insertText": "accept(ir_hierarchical_visitor*)"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (ir_instruction*)",
    "insertText": "clone(void *mem_ctx, struct hash_table* ht)"
  },
  {
    "label": "as_variable()",
    "kind": "Method",
    "detail": "Function (class ir_variable*)",
    "insertText": "as_variable()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ir_type = ir_type_unset ;)",
    "insertText": "if(id == BREAK_ON_ID)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(WIN32) && defined(DEBUG) __debugbreak()"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (# endif } } int ID ; int BREAK_ON_ID ; } ; class ir_rvalue : public ir_instruction { public : const struct glsl_type* type ; ir_rvalue*)",
    "insertText": "clone(void *mem_ctx, struct hash_table *)"
  },
  {
    "label": "accept()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "accept(ir_visitor *v)"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (v ->)",
    "insertText": "visit(this)"
  },
  {
    "label": "accept()",
    "kind": "Method",
    "detail": "Function (} ir_visitor_status)",
    "insertText": "accept(ir_hierarchical_visitor *)"
  },
  {
    "label": "constant_expression_value()",
    "kind": "Method",
    "detail": "Function (ir_constant*)",
    "insertText": "constant_expression_value()"
  },
  {
    "label": "as_rvalue()",
    "kind": "Method",
    "detail": "Function (ir_rvalue*)",
    "insertText": "as_rvalue()"
  },
  {
    "label": "is_lvalue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_lvalue()"
  },
  {
    "label": "is_one()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_one()"
  },
  {
    "label": "is_negative_one()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_negative_one()"
  },
  {
    "label": "error_value()",
    "kind": "Method",
    "detail": "Function (ir_rvalue*)",
    "insertText": "error_value(void *mem_ctx)"
  },
  {
    "label": "void_value()",
    "kind": "Method",
    "detail": "Function (ir_rvalue*)",
    "insertText": "void_value(void *mem_ctx)"
  },
  {
    "label": "ir_rvalue()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "ir_rvalue()"
  },
  {
    "label": "depth_layout_string()",
    "kind": "Method",
    "detail": "Function (} ; enum ir_variable_mode { ir_var_auto = 0,ir_var_uniform,ir_var_in,ir_var_out,ir_var_inout,ir_var_const_in,ir_var_temporary,ir_var_shared,ir_var_ref,ir_var_ref_image } ; enum ir_variable_interpolation { ir_interp_qualifier_none = 0,ir_interp_qualifier_smooth,ir_interp_qualifier_flat,ir_interp_qualifier_noperspective } ; enum ir_depth_layout { ir_depth_layout_none,ir_depth_layout_any,ir_depth_layout_greater,ir_depth_layout_less,ir_depth_layout_unchanged } ; enum ir_geometry_input { ir_geometry_input_none,ir_geometry_input_points,ir_geometry_input_lines,ir_geometry_input_lines_adjacent,ir_geometry_input_triangles,ir_geometry_input_triangles_adjacent } ; const char*)",
    "insertText": "depth_layout_string(ir_depth_layout layout)"
  },
  {
    "label": "ir_variable()",
    "kind": "Method",
    "detail": "Function (struct ir_state_slot { int tokens [ 5 ] ; int swizzle ; } ; class ir_variable : public ir_instruction { public :)",
    "insertText": "ir_variable(const struct glsl_type *, const char *, ir_variable_mode)"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (ir_variable*)",
    "insertText": "clone(void *mem_ctx, struct hash_table *ht)"
  },
  {
    "label": "interpolation_string()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "interpolation_string()"
  },
  {
    "label": "ir_function_signature()",
    "kind": "Method",
    "detail": "Function (const struct glsl_type* type ; const char* name ; const char* semantic ; unsigned max_array_access ; unsigned read_only : 1 ; unsigned centroid : 1 ; unsigned invariant : 1 ; unsigned used : 1 ; ir_variable_mode mode ; unsigned precise : 1 ; unsigned interpolation : 2 ; unsigned geometryinput : 3 ; unsigned is_interface_block : 1 ; unsigned origin_upper_left : 1 ; unsigned pixel_center_integer : 1 ; unsigned explicit_location : 1 ; unsigned has_initializer : 1 ; unsigned has_been_sampled : 1 ; unsigned image_read : 1 ; unsigned image_write : 1 ; unsigned coherent : 1 ; unsigned is_patch_constant : 1 ; ir_depth_layout depth_layout ; int location ; unsigned num_state_slots ; ir_state_slot* state_slots ; const char* warn_extension ; ir_constant* constant_value ; ir_constant* constant_initializer ; } ; class ir_function_signature : public ir_instruction { public :)",
    "insertText": "ir_function_signature(const glsl_type *return_type)"
  },
  {
    "label": "clone_prototype()",
    "kind": "Method",
    "detail": "Function (ir_function_signature*)",
    "insertText": "clone_prototype(void *mem_ctx, struct hash_table *ht)"
  },
  {
    "label": "constant_expression_value()",
    "kind": "Method",
    "detail": "Function (ir_constant*)",
    "insertText": "constant_expression_value(exec_list *actual_parameters)"
  },
  {
    "label": "function_name()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "function_name()"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (const class ir_function*)",
    "insertText": "function()"
  },
  {
    "label": "replace_parameters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replace_parameters(exec_list *new_params)"
  },
  {
    "label": "ir_function()",
    "kind": "Method",
    "detail": "Function (const struct glsl_type* return_type ; const char* return_semantic ; struct exec_list parameters ; unsigned is_defined : 1 ; unsigned is_builtin : 1 ; unsigned has_output_parameters : 1 ; unsigned is_main : 1 ; unsigned maxvertexcount ; unsigned is_early_depth_stencil : 1 ; int wg_size_x ; int wg_size_y ; int wg_size_z ; glsl_tessellation_info tessellation ; struct exec_list body ; private : class ir_function* _function ; class ir_function ; } ; class ir_function : public ir_instruction { public :)",
    "insertText": "ir_function(const char *name)"
  },
  {
    "label": "as_function()",
    "kind": "Method",
    "detail": "Function (ir_function*)",
    "insertText": "as_function()"
  },
  {
    "label": "add_signature()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add_signature(ir_function_signature *sig)"
  },
  {
    "label": "foreach_list_const()",
    "kind": "Method",
    "detail": "Function (sig -> _function = this ; bool bHasOut = false ;)",
    "insertText": "foreach_list_const(Node, &sig->parameters)"
  },
  {
    "label": "Parameter()",
    "kind": "Method",
    "detail": "Function (ir_variable*)",
    "insertText": "Parameter(ir_variable*)"
  },
  {
    "label": "push_tail()",
    "kind": "Method",
    "detail": "Function (bHasOut = true ; break ; } } sig -> has_output_parameters | = bHasOut ; this -> signatures .)",
    "insertText": "push_tail(sig)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} exec_list_iterator)",
    "insertText": "iterator()"
  },
  {
    "label": "matching_signature()",
    "kind": "Method",
    "detail": "Function (} ir_function_signature*)",
    "insertText": "matching_signature(const exec_list *actual_param, bool *match_is_exact)"
  },
  {
    "label": "matching_signature()",
    "kind": "Method",
    "detail": "Function (ir_function_signature*)",
    "insertText": "matching_signature(const exec_list *actual_param)"
  },
  {
    "label": "exact_matching_signature()",
    "kind": "Method",
    "detail": "Function (ir_function_signature*)",
    "insertText": "exact_matching_signature(const exec_list *actual_ps)"
  },
  {
    "label": "has_user_signature()",
    "kind": "Method",
    "detail": "Function (const char* name ; bool)",
    "insertText": "has_user_signature()"
  },
  {
    "label": "as_if()",
    "kind": "Method",
    "detail": "Function (ir_if*)",
    "insertText": "as_if()"
  },
  {
    "label": "ir_loop()",
    "kind": "Method",
    "detail": "Function (ir_rvalue* condition ; exec_list then_instructions ; exec_list else_instructions ; if_mode mode ; } ; class ir_loop : public ir_instruction { public : enum loop_mode { loop_loop,loop_unroll,loop_dont_care } ;)",
    "insertText": "ir_loop()"
  },
  {
    "label": "as_loop()",
    "kind": "Method",
    "detail": "Function (ir_loop*)",
    "insertText": "as_loop()"
  },
  {
    "label": "ir_assignment()",
    "kind": "Method",
    "detail": "Function (} exec_list body_instructions ; ir_rvalue* from ; ir_rvalue* to ; ir_rvalue* increment ; ir_variable* counter ; int cmp ; loop_mode mode ; unsigned int fastopt : 1 ; int unroll_size ; } ; class ir_assignment : public ir_instruction { public :)",
    "insertText": "ir_assignment(ir_rvalue *lhs, ir_rvalue *rhs, ir_rvalue *condition = NULL)"
  },
  {
    "label": "ir_assignment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_assignment(ir_dereference *lhs, ir_rvalue *rhs, ir_rvalue *condition, unsigned write_mask)"
  },
  {
    "label": "as_assignment()",
    "kind": "Method",
    "detail": "Function (ir_assignment*)",
    "insertText": "as_assignment()"
  },
  {
    "label": "whole_variable_written()",
    "kind": "Method",
    "detail": "Function (ir_variable*)",
    "insertText": "whole_variable_written()"
  },
  {
    "label": "set_lhs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_lhs(ir_rvalue *lhs)"
  },
  {
    "label": "ir_expression()",
    "kind": "Method",
    "detail": "Function (ir_dereference* lhs ; ir_rvalue* rhs ; ir_rvalue* condition ; unsigned write_mask ; } ; enum ir_expression_operation { ir_unop_bit_not,ir_unop_logic_not,ir_unop_neg,ir_unop_abs,ir_unop_sign,ir_unop_rcp,ir_unop_rsq,ir_unop_sqrt,ir_unop_exp,ir_unop_log,ir_unop_exp2,ir_unop_log2,ir_unop_first_conversion,ir_unop_f2i = ir_unop_first_conversion,ir_unop_i2f,ir_unop_f2b,ir_unop_b2f,ir_unop_i2b,ir_unop_b2i,ir_unop_b2u,ir_unop_u2b,ir_unop_f2u,ir_unop_u2f,ir_unop_i2u,ir_unop_u2i,ir_unop_h2i,ir_unop_i2h,ir_unop_h2f,ir_unop_f2h,ir_unop_h2b,ir_unop_b2h,ir_unop_h2u,ir_unop_u2h,ir_unop_last_conversion = ir_unop_u2h,ir_unop_transpose,ir_unop_any,ir_unop_all,ir_unop_trunc,ir_unop_ceil,ir_unop_floor,ir_unop_fract,ir_unop_round,ir_unop_sin,ir_unop_cos,ir_unop_tan,ir_unop_asin,ir_unop_acos,ir_unop_atan,ir_unop_sinh,ir_unop_cosh,ir_unop_tanh,ir_unop_normalize,ir_unop_dFdx,ir_unop_dFdy,ir_unop_dFdxFine,ir_unop_dFdyFine,ir_unop_dFdxCoarse,ir_unop_dFdyCoarse,ir_unop_isnan,ir_unop_isinf,ir_unop_fasu,ir_unop_fasi,ir_unop_iasf,ir_unop_uasf,ir_unop_bitreverse,ir_unop_bitcount,ir_unop_msb,ir_unop_lsb,ir_unop_saturate,ir_unop_noise,ir_last_unop = ir_unop_noise,ir_binop_add,ir_binop_sub,ir_binop_mul,ir_binop_div,ir_binop_mod,ir_binop_modf,ir_binop_step,ir_binop_less,ir_binop_greater,ir_binop_lequal,ir_binop_gequal,ir_binop_equal,ir_binop_nequal,ir_binop_first_comparison = ir_binop_less,ir_binop_last_comparison = ir_binop_nequal,ir_binop_all_equal,ir_binop_any_nequal,ir_binop_lshift,ir_binop_rshift,ir_binop_bit_and,ir_binop_bit_xor,ir_binop_bit_or,ir_binop_logic_and,ir_binop_logic_xor,ir_binop_logic_or,ir_binop_first_logic = ir_binop_logic_and,ir_binop_last_logic = ir_binop_logic_or,ir_binop_dot,ir_binop_cross,ir_binop_min,ir_binop_max,ir_binop_atan2,ir_binop_pow,ir_last_binop = ir_binop_pow,ir_ternop_lerp,ir_ternop_smoothstep,ir_ternop_clamp,ir_ternop_fma,ir_last_ternop = ir_ternop_fma,ir_quadop_vector,ir_opcode_count,ir_last_opcode = ir_last_ternop,ir_invalid_opcode = - 1 } ; class ir_expression : public ir_rvalue { public :)",
    "insertText": "ir_expression(int op, const struct glsl_type *type, ir_rvalue *)"
  },
  {
    "label": "ir_expression()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_expression(int op, ir_rvalue *)"
  },
  {
    "label": "ir_expression()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_expression(int op, const struct glsl_type *type, ir_rvalue *, ir_rvalue *)"
  },
  {
    "label": "ir_expression()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_expression(int op, ir_rvalue *op0, ir_rvalue *op1)"
  },
  {
    "label": "ir_expression()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_expression(int op, const struct glsl_type *type, ir_rvalue *, ir_rvalue *, ir_rvalue *, ir_rvalue *)"
  },
  {
    "label": "as_expression()",
    "kind": "Method",
    "detail": "Function (ir_expression*)",
    "insertText": "as_expression()"
  },
  {
    "label": "get_num_operands()",
    "kind": "Method",
    "detail": "Function (unsigned int)",
    "insertText": "get_num_operands(ir_expression_operation)"
  },
  {
    "label": "get_num_operands()",
    "kind": "Method",
    "detail": "Function (unsigned int)",
    "insertText": "get_num_operands()"
  },
  {
    "label": "operator_string()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "operator_string()"
  },
  {
    "label": "operator_string()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "operator_string(ir_expression_operation)"
  },
  {
    "label": "get_operator()",
    "kind": "Method",
    "detail": "Function (ir_expression_operation)",
    "insertText": "get_operator(const char *)"
  },
  {
    "label": "ir_call()",
    "kind": "Method",
    "detail": "Function (ir_expression_operation operation ; ir_rvalue* operands [ 4 ] ; } ; class ir_call : public ir_instruction { public :)",
    "insertText": "ir_call(ir_function_signature* InCallee, ir_dereference_variable* InReturnDeref, exec_list* InActualParameters) : return_deref(InReturnDeref), callee(InCallee)"
  },
  {
    "label": "move_nodes_to()",
    "kind": "Method",
    "detail": "Function (ir_type = ir_type_call ; InActualParameters ->)",
    "insertText": "move_nodes_to(&this->actual_parameters)"
  },
  {
    "label": "as_call()",
    "kind": "Method",
    "detail": "Function (ir_call*)",
    "insertText": "as_call()"
  },
  {
    "label": "callee_name()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "callee_name()"
  },
  {
    "label": "generate_inline()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "generate_inline(ir_instruction *ir)"
  },
  {
    "label": "ir_jump()",
    "kind": "Method",
    "detail": "Function (ir_dereference_variable* return_deref ; ir_function_signature* callee ; exec_list actual_parameters ; bool use_builtin ; } ; class ir_jump : public ir_instruction { protected :)",
    "insertText": "ir_jump()"
  },
  {
    "label": "ir_return()",
    "kind": "Method",
    "detail": "Function (ir_type = ir_type_unset ; } } ; class ir_return : public ir_jump { public :)",
    "insertText": "ir_return() : value(NULL)"
  },
  {
    "label": "ir_return()",
    "kind": "Method",
    "detail": "Function (this -> ir_type = ir_type_return ; })",
    "insertText": "ir_return(ir_rvalue* InValue) : value(InValue)"
  },
  {
    "label": "as_return()",
    "kind": "Method",
    "detail": "Function (ir_return*)",
    "insertText": "as_return()"
  },
  {
    "label": "get_value()",
    "kind": "Method",
    "detail": "Function (} ir_rvalue*)",
    "insertText": "get_value()"
  },
  {
    "label": "ir_loop_jump()",
    "kind": "Method",
    "detail": "Function (ir_rvalue* value ; } ; class ir_loop_jump : public ir_jump { public : enum jump_mode { jump_break,jump_continue } ;)",
    "insertText": "ir_loop_jump(jump_mode InMode)"
  },
  {
    "label": "is_break()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_break()"
  },
  {
    "label": "ir_discard()",
    "kind": "Method",
    "detail": "Function (this -> ir_type = ir_type_discard ; this -> condition = NULL ; })",
    "insertText": "ir_discard(ir_rvalue *cond)"
  },
  {
    "label": "as_discard()",
    "kind": "Method",
    "detail": "Function (ir_discard*)",
    "insertText": "as_discard()"
  },
  {
    "label": "ir_texture()",
    "kind": "Method",
    "detail": "Function (} ir_rvalue* condition ; } ; enum ir_texture_opcode { ir_tex,ir_txb,ir_txl,ir_txd,ir_txf,ir_txs,ir_txg,ir_txm } ; enum ir_texture_channel { ir_channel_none,ir_channel_red,ir_channel_green,ir_channel_blue,ir_channel_alpha,ir_channel_unknown } ; class ir_texture : public ir_rvalue { public :)",
    "insertText": "ir_texture(enum ir_texture_opcode InOp, const SSourceLocation& InSourceLocation) : op(InOp), sampler(nullptr), coordinate(nullptr), projector(nullptr), shadow_comparitor(nullptr), offset(nullptr), channel(ir_channel_none), SamplerStateName(\"\"), SamplerState(nullptr)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (SourceLocation = InSourceLocation ; this -> ir_type = ir_type_texture ;)",
    "insertText": "memset(&lod_info, 0, sizeof(lod_info))"
  },
  {
    "label": "as_texture()",
    "kind": "Method",
    "detail": "Function (class ir_texture*)",
    "insertText": "as_texture()"
  },
  {
    "label": "opcode_string()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "opcode_string()"
  },
  {
    "label": "set_sampler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_sampler(ir_dereference *sampler, const glsl_type *type)"
  },
  {
    "label": "get_opcode()",
    "kind": "Method",
    "detail": "Function (ir_texture_opcode)",
    "insertText": "get_opcode(const char *)"
  },
  {
    "label": "ir_swizzle()",
    "kind": "Method",
    "detail": "Function (enum ir_texture_opcode op ; ir_dereference* sampler ; ir_rvalue* coordinate ; ir_rvalue* projector ; ir_rvalue* shadow_comparitor ; ir_rvalue* offset ; union { ir_rvalue* lod ; ir_rvalue* bias ; ir_rvalue* sample_index ; struct { ir_rvalue* dPdx ; ir_rvalue* dPdy ; } grad ; } lod_info ; ir_texture_channel channel ; const char* SamplerStateName ; ir_rvalue* SamplerState ; } ; struct ir_swizzle_mask { unsigned x : 4 ; unsigned y : 4 ; unsigned z : 4 ; unsigned w : 4 ; unsigned num_components : 3 ; unsigned has_duplicates : 1 ; } ; class ir_swizzle : public ir_rvalue { public :)",
    "insertText": "ir_swizzle(ir_rvalue *, unsigned x, unsigned y, unsigned z, unsigned w, unsigned count)"
  },
  {
    "label": "ir_swizzle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_swizzle(ir_rvalue *val, const unsigned *components, unsigned count)"
  },
  {
    "label": "ir_swizzle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_swizzle(ir_rvalue *val, ir_swizzle_mask mask)"
  },
  {
    "label": "as_swizzle()",
    "kind": "Method",
    "detail": "Function (ir_swizzle*)",
    "insertText": "as_swizzle()"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (ir_swizzle*)",
    "insertText": "create(ir_rvalue *, const char *, unsigned vector_length)"
  },
  {
    "label": "variable_referenced()",
    "kind": "Method",
    "detail": "Function (} ir_variable*)",
    "insertText": "variable_referenced()"
  },
  {
    "label": "init_mask()",
    "kind": "Method",
    "detail": "Function (ir_rvalue* val ; ir_swizzle_mask mask ; private : void)",
    "insertText": "init_mask(const unsigned *components, unsigned count)"
  },
  {
    "label": "as_dereference()",
    "kind": "Method",
    "detail": "Function (ir_dereference*)",
    "insertText": "as_dereference()"
  },
  {
    "label": "ir_dereference_variable()",
    "kind": "Method",
    "detail": "Function (} ; class ir_dereference_variable : public ir_dereference { public :)",
    "insertText": "ir_dereference_variable(ir_variable *var)"
  },
  {
    "label": "as_dereference_variable()",
    "kind": "Method",
    "detail": "Function (ir_dereference_variable*)",
    "insertText": "as_dereference_variable()"
  },
  {
    "label": "ir_dereference_array()",
    "kind": "Method",
    "detail": "Function (ir_variable* var ; } ; class ir_dereference_array : public ir_dereference { public :)",
    "insertText": "ir_dereference_array(ir_rvalue *value, ir_rvalue *array_index)"
  },
  {
    "label": "ir_dereference_array()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_dereference_array(ir_variable *var, ir_rvalue *array_index)"
  },
  {
    "label": "as_dereference_array()",
    "kind": "Method",
    "detail": "Function (ir_dereference_array*)",
    "insertText": "as_dereference_array()"
  },
  {
    "label": "set_array()",
    "kind": "Method",
    "detail": "Function (ir_rvalue* array ; ir_rvalue* array_index ; private : void)",
    "insertText": "set_array(ir_rvalue *value)"
  },
  {
    "label": "ir_dereference_image()",
    "kind": "Method",
    "detail": "Function (} ; enum ir_image_op { ir_image_access,ir_image_dimensions } ; class ir_dereference_image : public ir_dereference { public :)",
    "insertText": "ir_dereference_image(ir_rvalue *value, ir_rvalue *array_index)"
  },
  {
    "label": "ir_dereference_image()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_dereference_image(ir_variable *var, ir_rvalue *array_index)"
  },
  {
    "label": "ir_dereference_image()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_dereference_image(ir_rvalue *value, ir_rvalue *array_index, ir_image_op op)"
  },
  {
    "label": "ir_dereference_image()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_dereference_image(ir_variable *var, ir_rvalue *array_index, ir_image_op op)"
  },
  {
    "label": "as_dereference_image()",
    "kind": "Method",
    "detail": "Function (ir_dereference_image*)",
    "insertText": "as_dereference_image()"
  },
  {
    "label": "ir_dereference_record()",
    "kind": "Method",
    "detail": "Function (ir_rvalue* image ; ir_rvalue* image_index ; ir_image_op op ; private : } ; class ir_dereference_record : public ir_dereference { public :)",
    "insertText": "ir_dereference_record(ir_rvalue *value, const char *field)"
  },
  {
    "label": "ir_dereference_record()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_dereference_record(ir_variable *var, const char *field)"
  },
  {
    "label": "as_dereference_record()",
    "kind": "Method",
    "detail": "Function (ir_dereference_record*)",
    "insertText": "as_dereference_record()"
  },
  {
    "label": "ir_constant()",
    "kind": "Method",
    "detail": "Function (ir_rvalue* record ; const char* field ; } ; union ir_constant_data { unsigned u [ 1 6 ] ; int i [ 1 6 ] ; float f [ 1 6 ] ; bool b [ 1 6 ] ; } ; class ir_constant : public ir_rvalue { public :)",
    "insertText": "ir_constant(const struct glsl_type *type, const ir_constant_data *data)"
  },
  {
    "label": "ir_constant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_constant(bool b)"
  },
  {
    "label": "ir_constant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_constant(unsigned int u)"
  },
  {
    "label": "ir_constant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_constant(int i)"
  },
  {
    "label": "ir_constant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_constant(float f)"
  },
  {
    "label": "ir_constant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_constant(const struct glsl_type *type, exec_list *values)"
  },
  {
    "label": "ir_constant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ir_constant(const ir_constant *c, unsigned i)"
  },
  {
    "label": "zero()",
    "kind": "Method",
    "detail": "Function (ir_constant*)",
    "insertText": "zero(void *mem_ctx, const glsl_type *type)"
  },
  {
    "label": "as_constant()",
    "kind": "Method",
    "detail": "Function (ir_constant*)",
    "insertText": "as_constant()"
  },
  {
    "label": "get_bool_component()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "get_bool_component(unsigned i)"
  },
  {
    "label": "get_float_component()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "get_float_component(unsigned i)"
  },
  {
    "label": "get_int_component()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "get_int_component(unsigned i)"
  },
  {
    "label": "get_uint_component()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "get_uint_component(unsigned i)"
  },
  {
    "label": "get_component()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "get_component(bool& result, unsigned i)"
  },
  {
    "label": "get_bool_component()",
    "kind": "Method",
    "detail": "Function (result =)",
    "insertText": "get_bool_component(i)"
  },
  {
    "label": "get_component()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "get_component(float& result, unsigned i)"
  },
  {
    "label": "get_float_component()",
    "kind": "Method",
    "detail": "Function (result =)",
    "insertText": "get_float_component(i)"
  },
  {
    "label": "get_component()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "get_component(int& result, unsigned i)"
  },
  {
    "label": "get_int_component()",
    "kind": "Method",
    "detail": "Function (result =)",
    "insertText": "get_int_component(i)"
  },
  {
    "label": "get_component()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "get_component(unsigned& result, unsigned i)"
  },
  {
    "label": "get_uint_component()",
    "kind": "Method",
    "detail": "Function (result =)",
    "insertText": "get_uint_component(i)"
  },
  {
    "label": "get_array_element()",
    "kind": "Method",
    "detail": "Function (} ir_constant*)",
    "insertText": "get_array_element(unsigned i)"
  },
  {
    "label": "get_record_field()",
    "kind": "Method",
    "detail": "Function (ir_constant*)",
    "insertText": "get_record_field(const char *name)"
  },
  {
    "label": "has_value()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "has_value(const ir_constant *)"
  },
  {
    "label": "is_zero()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_zero()"
  },
  {
    "label": "is_finite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_finite()"
  },
  {
    "label": "is_component_finite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_component_finite(unsigned i)"
  },
  {
    "label": "are_any_zero()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "are_any_zero()"
  },
  {
    "label": "ir_constant()",
    "kind": "Method",
    "detail": "Function (union ir_constant_data value ; ir_constant** array_elements ; exec_list components ; private :)",
    "insertText": "ir_constant(void)"
  },
  {
    "label": "ir_atomic()",
    "kind": "Method",
    "detail": "Function (} ; enum ir_atomic_op { ir_atomic_add,ir_atomic_and,ir_atomic_min,ir_atomic_max,ir_atomic_or,ir_atomic_xor,ir_atomic_swap,ir_atomic_cmp_swap,ir_atomic_load,ir_atomic_store,ir_atomic_count } ; class ir_atomic : public ir_instruction { public :)",
    "insertText": "ir_atomic(ir_atomic_op op, ir_dereference *result, ir_dereference *target, ir_rvalue *arg0, ir_rvalue *arg1 ) : memory_ref(target), lhs(result), operation(op)"
  },
  {
    "label": "visit_exec_list()",
    "kind": "Method",
    "detail": "Function (ir_dereference* memory_ref ; ir_dereference* lhs ; ir_rvalue* operands [ 2 ] ; ir_atomic_op operation ; } ; void)",
    "insertText": "visit_exec_list(exec_list *list, ir_visitor *visitor)"
  },
  {
    "label": "validate_ir_tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "validate_ir_tree(exec_list *instructions, struct _mesa_glsl_parse_state *state)"
  },
  {
    "label": "detect_recursion_unlinked()",
    "kind": "Method",
    "detail": "Function (struct _mesa_glsl_parse_state ; struct gl_shader_program ; void)",
    "insertText": "detect_recursion_unlinked(struct _mesa_glsl_parse_state *state, exec_list *instructions)"
  },
  {
    "label": "clone_ir_list()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clone_ir_list(void *mem_ctx, exec_list *out, const exec_list *in)"
  },
  {
    "label": "_mesa_glsl_initialize_functions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mesa_glsl_initialize_functions(exec_list *instructions, _mesa_glsl_parse_state *state)"
  },
  {
    "label": "import_prototypes()",
    "kind": "Method",
    "detail": "Function (struct glsl_symbol_table ; void)",
    "insertText": "import_prototypes(const exec_list *source, exec_list *dest, struct glsl_symbol_table *symbols, void *mem_ctx)"
  },
  {
    "label": "prototype_string()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "prototype_string(const glsl_type *return_type, const char *name, exec_list *parameters)"
  },
  {
    "label": "gen_texture_op()",
    "kind": "Method",
    "detail": "Function (ir_rvalue*)",
    "insertText": "gen_texture_op(const class ast_expression *expr, ir_dereference *sampler, exec_list *instructions, struct _mesa_glsl_parse_state *state)"
  },
  {
    "label": "gen_image_op()",
    "kind": "Method",
    "detail": "Function (ir_rvalue*)",
    "insertText": "gen_image_op(const class ast_expression *expr, ir_dereference *image, exec_list *instructions, struct _mesa_glsl_parse_state *state)"
  },
  {
    "label": "apply_type_conversion()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "apply_type_conversion(const struct glsl_type *to, ir_rvalue * &from, exec_list* instructions, struct _mesa_glsl_parse_state *state, bool is_explicit, const struct YYLTYPE *loc)"
  },
  {
    "label": "validate_assignment()",
    "kind": "Method",
    "detail": "Function (ir_rvalue*)",
    "insertText": "validate_assignment(struct _mesa_glsl_parse_state *state, exec_list *instructions, const glsl_type *lhs_type, ir_rvalue *rhs, bool is_initializer, const YYLTYPE *loc)"
  },
  {
    "label": "arithmetic_result_type()",
    "kind": "Method",
    "detail": "Function (const struct glsl_type*)",
    "insertText": "arithmetic_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b, exec_list *instructions, _mesa_glsl_parse_state *state, YYLTYPE *loc, bool bAIsLHS)"
  },
  {
    "label": "ir_hash_table_pointer_hash()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "ir_hash_table_pointer_hash(const void *key)"
  },
  {
    "label": "ir_hash_table_pointer_compare()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ir_hash_table_pointer_compare(const void *key1, const void *key2)"
  }
]