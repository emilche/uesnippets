[
  {
    "label": "UPhysicalMaterial",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPhysicalMaterial"
  },
  {
    "label": "FCapsule",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCapsule"
  },
  {
    "label": "FImplicitObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImplicitObject"
  },
  {
    "label": "FDummyPhysType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDummyPhysType"
  },
  {
    "label": "FDummyPhysActor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDummyPhysActor"
  },
  {
    "label": "FDummyCallback",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDummyCallback"
  },
  {
    "label": "FPhysicsRaycastInputAdapater",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPhysicsRaycastInputAdapater"
  },
  {
    "label": "FPhysicsSweepInputAdapater",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPhysicsSweepInputAdapater"
  },
  {
    "label": "FPhysicsOverlapInputAdapater",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPhysicsOverlapInputAdapater"
  },
  {
    "label": "FQueryDebugParams",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQueryDebugParams"
  },
  {
    "label": "FPhysicsRaycastInputAdapater()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / CollisionFilterData . h \" # include \" Chaos / Declares . h \" # if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_2 # include \" Chaos / GeometryParticles . h \" # endif # include \" Chaos / ParticleHandleFwd . h \" # include \" Chaos / Real . h \" # include \" ChaosSQTypes . h \" # include \" Math / Transform . h \" # include \" Math / UnrealMathSSE . h \" # include \" Math / Vector . h \" # include \" PhysXPublicCore . h \" # include \" PhysicsInterfaceDeclaresCore . h \" # include \" PhysicsInterfaceTypesCore . h \" # include \" PhysicsInterfaceWrapperShared . h \" class UPhysicalMaterial ; namespace Chaos { class FCapsule ; class FImplicitObject ; } namespace ChaosInterface { struct FDummyPhysType { } ; struct FDummyPhysActor { } ; template<DummyT> struct FDummyCallback { } ; using FQueryFilterData = FChaosQueryFilterData ; struct FPhysicsRaycastInputAdapater {)",
    "insertText": "FPhysicsRaycastInputAdapater(const FVector& InStart, const FVector& InDir, const EHitFlags InFlags) : Start(InStart) , Dir(InDir) , OutputFlags(InFlags)"
  },
  {
    "label": "FPhysicsSweepInputAdapater()",
    "kind": "Method",
    "detail": "Function (} FVector Start ; FVector Dir ; EHitFlags OutputFlags ; } ; struct FPhysicsSweepInputAdapater {)",
    "insertText": "FPhysicsSweepInputAdapater(const FTransform& InStartTM, const FVector& InDir, const EHitFlags InFlags) : StartTM(InStartTM) , Dir(InDir) , OutputFlags(InFlags)"
  },
  {
    "label": "FPhysicsOverlapInputAdapater()",
    "kind": "Method",
    "detail": "Function (} FTransform StartTM ; FVector Dir ; EHitFlags OutputFlags ; } ; struct FPhysicsOverlapInputAdapater {)",
    "insertText": "FPhysicsOverlapInputAdapater(const FTransform& InPose) : GeomPose(InPose)"
  },
  {
    "label": "FQueryDebugParams()",
    "kind": "Method",
    "detail": "Function (} FTransform GeomPose ; } ; struct FQueryDebugParams { # if CHAOS_DEBUG_DRAW)",
    "insertText": "FQueryDebugParams() : bDebugQuery(false) , bExternalQuery(true)"
  },
  {
    "label": "IsDebugQuery()",
    "kind": "Method",
    "detail": "Function (} bool bDebugQuery ; bool bExternalQuery ; bool)",
    "insertText": "IsDebugQuery()"
  },
  {
    "label": "GetSimulationFilterData()",
    "kind": "Method",
    "detail": "Function (FCollisionFilterData)",
    "insertText": "GetSimulationFilterData(const Chaos::FPerShapeData& Shape)"
  },
  {
    "label": "GetImplicitType()",
    "kind": "Method",
    "detail": "Function (ECollisionShapeType)",
    "insertText": "GetImplicitType(const Chaos::FImplicitObject& InGeometry)"
  },
  {
    "label": "GetRadius()",
    "kind": "Method",
    "detail": "Function (} Chaos::FReal)",
    "insertText": "GetRadius(const Chaos::FCapsule& InCapsule)"
  },
  {
    "label": "GetHalfHeight()",
    "kind": "Method",
    "detail": "Function (Chaos::FReal)",
    "insertText": "GetHalfHeight(const Chaos::FCapsule& InCapsule)"
  },
  {
    "label": "HadInitialOverlap()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HadInitialOverlap(const FLocationHit& Hit)"
  },
  {
    "label": "SetFlags()",
    "kind": "Method",
    "detail": "Function (Hit . Flags = Flags ; } void)",
    "insertText": "SetFlags(FPTLocationHit& Hit, FHitFlags Flags)"
  },
  {
    "label": "GetInternalFaceIndex()",
    "kind": "Method",
    "detail": "Function (Hit . Flags = Flags ; } uint32)",
    "insertText": "GetInternalFaceIndex(const FQueryHit& Hit)"
  },
  {
    "label": "SetInternalFaceIndex()",
    "kind": "Method",
    "detail": "Function (Hit . FaceIndex = FaceIndex ; } void)",
    "insertText": "SetInternalFaceIndex(FPTQueryHit& Hit, uint32 FaceIndex)"
  },
  {
    "label": "GetInvalidPhysicsFaceIndex()",
    "kind": "Method",
    "detail": "Function (Hit . FaceIndex = FaceIndex ; } uint32)",
    "insertText": "GetInvalidPhysicsFaceIndex()"
  },
  {
    "label": "GetGlobalPose()",
    "kind": "Method",
    "detail": "Function (} FTransform)",
    "insertText": "GetGlobalPose(const FDummyPhysActor& RigidActor)"
  },
  {
    "label": "SetActor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetActor(FDummyPhysType& Hit, FDummyPhysActor* Actor)"
  },
  {
    "label": "SetShape()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetShape(FDummyPhysType& Hit, Chaos::FImplicitObject* Shape)"
  },
  {
    "label": "GetBlock()",
    "kind": "Method",
    "detail": "Function (} template<HitType> HitType*)",
    "insertText": "GetBlock(FSQHitBuffer<HitType>& Callback)"
  },
  {
    "label": "GetHasBlock()",
    "kind": "Method",
    "detail": "Function (} template<HitType> bool)",
    "insertText": "GetHasBlock(const FSQHitBuffer<HitType>& Callback)"
  }
]