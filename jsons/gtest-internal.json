[
  {
    "label": "MessageLite",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MessageLite"
  },
  {
    "label": "AssertionResult",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AssertionResult"
  },
  {
    "label": "Message",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Message"
  },
  {
    "label": "Test",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Test"
  },
  {
    "label": "TestInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestInfo"
  },
  {
    "label": "TestPartResult",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestPartResult"
  },
  {
    "label": "UnitTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnitTest"
  },
  {
    "label": "TraceInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TraceInfo"
  },
  {
    "label": "TestInfoImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestInfoImpl"
  },
  {
    "label": "UnitTestImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnitTestImpl"
  },
  {
    "label": "IgnoredValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IgnoredValue"
  },
  {
    "label": "Sink",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Sink"
  },
  {
    "label": "GTEST_API_",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GTEST_API_"
  },
  {
    "label": "EditType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EditType"
  },
  {
    "label": "FloatingPoint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FloatingPoint"
  },
  {
    "label": "TypeIdHelper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypeIdHelper"
  },
  {
    "label": "TestFactoryBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestFactoryBase"
  },
  {
    "label": "TestClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestClass"
  },
  {
    "label": "TestFactoryImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestFactoryImpl"
  },
  {
    "label": "CodeLocation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CodeLocation"
  },
  {
    "label": "SuiteApiResolver",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SuiteApiResolver"
  },
  {
    "label": "DefaultNameGenerator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DefaultNameGenerator"
  },
  {
    "label": "NameGeneratorSelector",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NameGeneratorSelector"
  },
  {
    "label": "TestSel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestSel"
  },
  {
    "label": "TypeParameterizedTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypeParameterizedTest"
  },
  {
    "label": "TypeParameterizedTestSuite",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypeParameterizedTestSuite"
  },
  {
    "label": "TrueWithString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TrueWithString"
  },
  {
    "label": "HasDebugStringAndShortDebugString",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HasDebugStringAndShortDebugString"
  },
  {
    "label": "C",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "C"
  },
  {
    "label": "Iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Iterator"
  },
  {
    "label": "IsHashTable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsHashTable"
  },
  {
    "label": "IsRecursiveContainerImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsRecursiveContainerImpl"
  },
  {
    "label": "IsRecursiveContainer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsRecursiveContainer"
  },
  {
    "label": "RelationToSourceReference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RelationToSourceReference"
  },
  {
    "label": "RelationToSourceCopy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RelationToSourceCopy"
  },
  {
    "label": "NativeArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NativeArray"
  },
  {
    "label": "IndexSequence",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IndexSequence"
  },
  {
    "label": "DoubleSequence",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DoubleSequence"
  },
  {
    "label": "MakeIndexSequenceImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MakeIndexSequenceImpl"
  },
  {
    "label": "Ignore",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Ignore"
  },
  {
    "label": "ElemFromListImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ElemFromListImpl"
  },
  {
    "label": "ElemFromList",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ElemFromList"
  },
  {
    "label": "FlatTupleConstructTag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FlatTupleConstructTag"
  },
  {
    "label": "FlatTuple",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FlatTuple"
  },
  {
    "label": "FlatTupleElemBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FlatTupleElemBase"
  },
  {
    "label": "FlatTupleBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FlatTupleBase"
  },
  {
    "label": "tuple_size",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "tuple_size"
  },
  {
    "label": "NeverThrown",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NeverThrown"
  },
  {
    "label": "GTEST_TEST_CLASS_NAME_",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GTEST_TEST_CLASS_NAME_"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (# ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_ # define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_ # include \" gtest / internal / gtest - port . h \" # if GTEST_OS_LINUX # include<stdlib . h> # include<sys / types . h> # include<sys / wait . h> # include<unistd . h> # endif # if GTEST_HAS_EXCEPTIONS # include<stdexcept> # endif # include<ctype . h> # include<float . h> # include<string . h> # include<cstdint> # include<iomanip> # include<limits> # include<map> # include<set> # include<string> # include<type_traits> # include<vector> # include \" gtest / gtest - message . h \" # include \" gtest / internal / gtest - filepath . h \" # include \" gtest / internal / gtest - string . h \" # include \" gtest / internal / gtest - type - util . h \" # define)",
    "insertText": "GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar) #define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo##bar #define GTEST_STRINGIFY_HELPER_(name, ...) #name #define GTEST_STRINGIFY_(...) GTEST_STRINGIFY_HELPER_(__VA_ARGS__,)"
  },
  {
    "label": "PrintToString()",
    "kind": "Method",
    "detail": "Function (class MessageLite ; } namespace testing { class AssertionResult ; class Message ; class Test ; class TestInfo ; class TestPartResult ; class UnitTest ; template<T>::std::string)",
    "insertText": "PrintToString(const T& value)"
  },
  {
    "label": "IgnoredValue()",
    "kind": "Method",
    "detail": "Function (namespace internal { struct TraceInfo ; class TestInfoImpl ; class UnitTestImpl ; GTEST_API_ const char kStackTraceMarker [ ] ; class IgnoredValue { struct Sink { } ; public : template<T,std::enable_if<! std::is_convertible<T,Sink>::value,int>::type = 0>)",
    "insertText": "IgnoredValue(const T&)"
  },
  {
    "label": "AppendUserMessage()",
    "kind": "Method",
    "detail": "Function (} } ; GTEST_API_ std::string)",
    "insertText": "AppendUserMessage(const std::string& gtest_msg, const Message& user_msg)"
  },
  {
    "label": "GTEST_DISABLE_MSC_WARNINGS_PUSH_()",
    "kind": "Method",
    "detail": "Function (# if GTEST_HAS_EXCEPTIONS)",
    "insertText": "GTEST_DISABLE_MSC_WARNINGS_PUSH_(4275)"
  },
  {
    "label": "GoogleTestFailureException()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "GoogleTestFailureException(const TestPartResult& failure)"
  },
  {
    "label": "GTEST_DISABLE_MSC_WARNINGS_POP_()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "GTEST_DISABLE_MSC_WARNINGS_POP_()"
  },
  {
    "label": "CalculateOptimalEdits()",
    "kind": "Method",
    "detail": "Function (enum EditType { kMatch,kAdd,kRemove,kReplace } ; GTEST_API_ std::vector<EditType>)",
    "insertText": "CalculateOptimalEdits(const std::vector<size_t>& left, const std::vector<size_t>& right)"
  },
  {
    "label": "CalculateOptimalEdits()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ std::vector<EditType>)",
    "insertText": "CalculateOptimalEdits(const std::vector<std::string>& left, const std::vector<std::string>& right)"
  },
  {
    "label": "CreateUnifiedDiff()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ std::string)",
    "insertText": "CreateUnifiedDiff(const std::vector<std::string>& left, const std::vector<std::string>& right, size_t context = 2)"
  },
  {
    "label": "EqFailure()",
    "kind": "Method",
    "detail": "Function (} GTEST_API_ AssertionResult)",
    "insertText": "EqFailure(const char* expected_expression, const char* actual_expression, const std::string& expected_value, const std::string& actual_value, bool ignoring_case)"
  },
  {
    "label": "GetBoolAssertionFailureMessage()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ std::string)",
    "insertText": "GetBoolAssertionFailureMessage(const AssertionResult& assertion_result, const char* expression_text, const char* actual_predicate_value, const char* expected_predicate_value)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (template<RawType> class FloatingPoint { public : typedef TypeWithSize<)",
    "insertText": "sizeof(RawType)"
  },
  {
    "label": "Bits()",
    "kind": "Method",
    "detail": "Function (const size_t kFractionBitCount = std::numeric_limits<RawType>::digits - 1 ; const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount ; const Bits kSignBitMask = static_cast<)",
    "insertText": "Bits(1) << (kBitCount - 1)"
  },
  {
    "label": "Bits()",
    "kind": "Method",
    "detail": "Function (const Bits kFractionBitMask = ~ static_cast<)",
    "insertText": "Bits(0) >> (kExponentBitCount + 1)"
  },
  {
    "label": "kExponentBitMask()",
    "kind": "Method",
    "detail": "Function (const Bits)",
    "insertText": "kExponentBitMask(kSignBitMask | kFractionBitMask)"
  },
  {
    "label": "FloatingPoint()",
    "kind": "Method",
    "detail": "Function (const uint32_t kMaxUlps = 4 ;)",
    "insertText": "FloatingPoint(const RawType& x)"
  },
  {
    "label": "ReinterpretBits()",
    "kind": "Method",
    "detail": "Function (u_ . value_ = x ; } RawType)",
    "insertText": "ReinterpretBits(const Bits bits)"
  },
  {
    "label": "fp()",
    "kind": "Method",
    "detail": "Function (FloatingPoint)",
    "insertText": "fp(0)"
  },
  {
    "label": "Infinity()",
    "kind": "Method",
    "detail": "Function (fp . u_ . bits_ = bits ; return fp . u_ . value_ ; } RawType)",
    "insertText": "Infinity()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} RawType)",
    "insertText": "Max()"
  },
  {
    "label": "bits()",
    "kind": "Method",
    "detail": "Function (const Bits&)",
    "insertText": "bits()"
  },
  {
    "label": "AlmostEquals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "AlmostEquals(const FloatingPoint& rhs)"
  },
  {
    "label": "SignAndMagnitudeToBiased()",
    "kind": "Method",
    "detail": "Function (} private : union FloatingPointUnion { RawType value_ ; Bits bits_ ; } ; Bits)",
    "insertText": "SignAndMagnitudeToBiased(const Bits& sam)"
  },
  {
    "label": "SignAndMagnitudeToBiased()",
    "kind": "Method",
    "detail": "Function (const Bits biased1 =)",
    "insertText": "SignAndMagnitudeToBiased(sam1)"
  },
  {
    "label": "SignAndMagnitudeToBiased()",
    "kind": "Method",
    "detail": "Function (const Bits biased2 =)",
    "insertText": "SignAndMagnitudeToBiased(sam2)"
  },
  {
    "label": "GetTestTypeId()",
    "kind": "Method",
    "detail": "Function (} GTEST_API_ TypeId)",
    "insertText": "GetTestTypeId()"
  },
  {
    "label": "TestFactoryBase()",
    "kind": "Method",
    "detail": "Function (class TestFactoryBase { public : ~)",
    "insertText": "TestFactoryBase()"
  },
  {
    "label": "CreateTest()",
    "kind": "Method",
    "detail": "Function (} Test*)",
    "insertText": "CreateTest()"
  },
  {
    "label": "TestFactoryBase()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "TestFactoryBase(const TestFactoryBase&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TestFactoryBase&)",
    "insertText": "operator(const TestFactoryBase&)"
  },
  {
    "label": "IsHRESULTFailure()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ AssertionResult)",
    "insertText": "IsHRESULTFailure(const char* expr, long hr)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (# endif using SetUpTestSuiteFunc =)",
    "insertText": "void(*)()"
  },
  {
    "label": "CodeLocation()",
    "kind": "Method",
    "detail": "Function (struct CodeLocation {)",
    "insertText": "CodeLocation(const std::string& a_file, int a_line) : file(a_file), line(a_line)"
  },
  {
    "label": "GetNotDefaultOrNull()",
    "kind": "Method",
    "detail": "Function (SetUpTearDownSuiteFuncType)",
    "insertText": "GetNotDefaultOrNull(SetUpTearDownSuiteFuncType a, SetUpTearDownSuiteFuncType def)"
  },
  {
    "label": "GetSetUpCaseOrSuite()",
    "kind": "Method",
    "detail": "Function (SetUpTearDownSuiteFuncType)",
    "insertText": "GetSetUpCaseOrSuite(const char* filename, int line_num)"
  },
  {
    "label": "GetNotDefaultOrNull()",
    "kind": "Method",
    "detail": "Function (# ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_ SetUpTearDownSuiteFuncType test_case_fp =)",
    "insertText": "GetNotDefaultOrNull(&T::SetUpTestCase, &Test::SetUpTestCase)"
  },
  {
    "label": "GetNotDefaultOrNull()",
    "kind": "Method",
    "detail": "Function (SetUpTearDownSuiteFuncType test_suite_fp =)",
    "insertText": "GetNotDefaultOrNull(&T::SetUpTestSuite, &Test::SetUpTestSuite)"
  },
  {
    "label": "GTEST_CHECK_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTEST_CHECK_(!test_case_fp || !test_suite_fp)"
  },
  {
    "label": "GetNotDefaultOrNull()",
    "kind": "Method",
    "detail": "Function (# ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_ SetUpTearDownSuiteFuncType test_case_fp =)",
    "insertText": "GetNotDefaultOrNull(&T::TearDownTestCase, &Test::TearDownTestCase)"
  },
  {
    "label": "GetNotDefaultOrNull()",
    "kind": "Method",
    "detail": "Function (SetUpTearDownSuiteFuncType test_suite_fp =)",
    "insertText": "GetNotDefaultOrNull(&T::TearDownTestSuite, &Test::TearDownTestSuite)"
  },
  {
    "label": "SkipPrefix()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ bool)",
    "insertText": "SkipPrefix(const char* prefix, const char** pstr)"
  },
  {
    "label": "GTEST_DISABLE_MSC_WARNINGS_PUSH_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\)"
  },
  {
    "label": "TypedTestSuitePState()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TypedTestSuitePState() : registered_(false)"
  },
  {
    "label": "AddTestName()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "AddTestName(const char* file, int line, const char* case_name, const char* test_name)"
  },
  {
    "label": "fprintf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fprintf(stderr, \"%s Test %s must be defined before \" \"REGISTER_TYPED_TEST_SUITE_P(%s, ...).\\n\", FormatFileLocation(file, line).c_str(), test_name, case_name)"
  },
  {
    "label": "fflush()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fflush(stderr)"
  },
  {
    "label": "Abort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Abort()"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} registered_tests_ .)",
    "insertText": "insert(::std::make_pair(test_name, CodeLocation(file, line)))"
  },
  {
    "label": "GetCodeLocation()",
    "kind": "Method",
    "detail": "Function (} const CodeLocation&)",
    "insertText": "GetCodeLocation(const std::string& test_name)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (RegisteredTestsMap::const_iterator it = registered_tests_ .)",
    "insertText": "find(test_name)"
  },
  {
    "label": "GTEST_CHECK_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GTEST_CHECK_(it != registered_tests_.end())"
  },
  {
    "label": "GTEST_DISABLE_MSC_WARNINGS_POP_()",
    "kind": "Method",
    "detail": "Function (private : typedef::std::map<std::string,CodeLocation> RegisteredTestsMap ; bool registered_ ; RegisteredTestsMap registered_tests_ ; } ; # ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_ using TypedTestCasePState = TypedTestSuitePState ; # endif)",
    "insertText": "GTEST_DISABLE_MSC_WARNINGS_POP_() inline const char* SkipComma(const char* str)"
  },
  {
    "label": "strchr()",
    "kind": "Method",
    "detail": "Function (const char* comma =)",
    "insertText": "strchr(str, ',')"
  },
  {
    "label": "GetPrefixUntilComma()",
    "kind": "Method",
    "detail": "Function (} return comma ; } std::string)",
    "insertText": "GetPrefixUntilComma(const char* str)"
  },
  {
    "label": "SplitString()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SplitString(const ::std::string& str, char delimiter, ::std::vector<::std::string>* dest)"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (struct DefaultNameGenerator { template<T> std::string)",
    "insertText": "GetName(int i)"
  },
  {
    "label": "GenerateNamesRecursively()",
    "kind": "Method",
    "detail": "Function (} } ; template<Provided = DefaultNameGenerator> struct NameGeneratorSelector { typedef Provided type ; } ; template<NameGenerator> void)",
    "insertText": "GenerateNamesRecursively(internal::None, std::vector<std::string>*, int)"
  },
  {
    "label": "GenerateNamesRecursively()",
    "kind": "Method",
    "detail": "Function (} template<NameGenerator,Types> void)",
    "insertText": "GenerateNamesRecursively(Types, std::vector<std::string>* result, int i)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (result ->)",
    "insertText": "push_back(NameGenerator::template GetName<typename Types::Head>(i))"
  },
  {
    "label": "NameGenerator()",
    "kind": "Method",
    "detail": "Function (GenerateNamesRecursively<)",
    "insertText": "NameGenerator(typename Types::Tail(), result, i + 1)"
  },
  {
    "label": "GenerateNames()",
    "kind": "Method",
    "detail": "Function (} template<NameGenerator,Types> std::vector<std::string>)",
    "insertText": "GenerateNames()"
  },
  {
    "label": "NameGenerator()",
    "kind": "Method",
    "detail": "Function (std::vector<std::string> result ; GenerateNamesRecursively<)",
    "insertText": "NameGenerator(Types(), &result, 0)"
  },
  {
    "label": "GTEST_BIND_()",
    "kind": "Method",
    "detail": "Function (typedef Types::Head Type ; typedef Fixture<Type> FixtureClass ; typedef)",
    "insertText": "GTEST_BIND_(TestSel, Type)"
  },
  {
    "label": "MakeAndRegisterTestInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MakeAndRegisterTestInfo((std::string(prefix) + (prefix[0] == '\\0' ? \"\" : \"/\") + case_name + \"/\" + type_names[static_cast<size_t>(index)]) .c_str(), StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(), GetTypeName<Type>().c_str(), nullptr, code_location, GetTypeId<FixtureClass>(), SuiteApiResolver<TestClass>::GetSetUpCaseOrSuite( code_location.file.c_str(), code_location.line), SuiteApiResolver<TestClass>::GetTearDownCaseOrSuite( code_location.file.c_str(), code_location.line), new TestFactoryImpl<TestClass>)"
  },
  {
    "label": "Register()",
    "kind": "Method",
    "detail": "Function (} } ; template<GTEST_TEMPLATE_ Fixture,class TestSel> class TypeParameterizedTest<Fixture,TestSel,internal::None> { public : bool)",
    "insertText": "Register(const char* , const CodeLocation&, const char* , const char* , int , const std::vector<std::string>& = std::vector<std::string>())"
  },
  {
    "label": "RegisterTypeParameterizedTestSuiteInstantiation()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ void)",
    "insertText": "RegisterTypeParameterizedTestSuiteInstantiation(const char* case_name)"
  },
  {
    "label": "Register()",
    "kind": "Method",
    "detail": "Function (template<GTEST_TEMPLATE_ Fixture,Tests,Types> class TypeParameterizedTestSuite { public : bool)",
    "insertText": "Register(const char* prefix, CodeLocation code_location, const TypedTestSuitePState* state, const char* case_name, const char* test_names, const std::vector<std::string>& type_names = GenerateNames<DefaultNameGenerator, Types>())"
  },
  {
    "label": "RegisterTypeParameterizedTestSuiteInstantiation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterTypeParameterizedTestSuiteInstantiation(case_name)"
  },
  {
    "label": "StripTrailingSpaces()",
    "kind": "Method",
    "detail": "Function (std::string test_name =)",
    "insertText": "StripTrailingSpaces(GetPrefixUntilComma(test_names))"
  },
  {
    "label": "fprintf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fprintf(stderr, \"Failed to get code location for test %s.%s at %s.\", case_name, test_name.c_str(), FormatFileLocation(code_location.file.c_str(), code_location.line) .c_str())"
  },
  {
    "label": "GetCodeLocation()",
    "kind": "Method",
    "detail": "Function (} const CodeLocation& test_location = state ->)",
    "insertText": "GetCodeLocation(test_name)"
  },
  {
    "label": "Register()",
    "kind": "Method",
    "detail": "Function (typedef Tests::Head Head ; TypeParameterizedTest<Fixture,Head,Types)",
    "insertText": "Register(prefix, test_location, case_name, test_names, 0, type_names)"
  },
  {
    "label": "Register()",
    "kind": "Method",
    "detail": "Function (} } ; template<GTEST_TEMPLATE_ Fixture,Types> class TypeParameterizedTestSuite<Fixture,internal::None,Types> { public : bool)",
    "insertText": "Register(const char* , const CodeLocation&, const TypedTestSuitePState* , const char* , const char* , const std::vector<std::string>& = std::vector<std::string>())"
  },
  {
    "label": "AlwaysTrue()",
    "kind": "Method",
    "detail": "Function (GTEST_API_ bool)",
    "insertText": "AlwaysTrue()"
  },
  {
    "label": "AlwaysFalse()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AlwaysFalse()"
  },
  {
    "label": "ConstCharPtr()",
    "kind": "Method",
    "detail": "Function (} struct GTEST_API_ ConstCharPtr {)",
    "insertText": "ConstCharPtr(const char* str) : value(str)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "TrueWithString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TrueWithString(const char* str) : value(str)"
  },
  {
    "label": "TrueWithString()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TrueWithString(const std::string& str) : value(str)"
  },
  {
    "label": "Reseed()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reseed(uint32_t seed)"
  },
  {
    "label": "Generate()",
    "kind": "Method",
    "detail": "Function (state_ = seed ; } uint32_t)",
    "insertText": "Generate(uint32_t range)"
  },
  {
    "label": "Random()",
    "kind": "Method",
    "detail": "Function (private : uint32_t state_ ;)",
    "insertText": "Random(const Random&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Random&)",
    "insertText": "operator(const Random&)"
  },
  {
    "label": "GTEST_REMOVE_REFERENCE_AND_CONST_()",
    "kind": "Method",
    "detail": "Function (} ; # define)",
    "insertText": "GTEST_REMOVE_REFERENCE_AND_CONST_(T)"
  },
  {
    "label": "CheckDebugString()",
    "kind": "Method",
    "detail": "Function (private : template<C> auto)",
    "insertText": "CheckDebugString(C*) -> typename std::is_same< std::string, decltype(std::declval<const C>().DebugString())"
  },
  {
    "label": "CheckDebugString()",
    "kind": "Method",
    "detail": "Function (template<> std::false_type)",
    "insertText": "CheckDebugString(...)"
  },
  {
    "label": "CheckShortDebugString()",
    "kind": "Method",
    "detail": "Function (template<C> auto)",
    "insertText": "CheckShortDebugString(C*) -> typename std::is_same< std::string, decltype(std::declval<const C>().ShortDebugString())"
  },
  {
    "label": "CheckShortDebugString()",
    "kind": "Method",
    "detail": "Function (template<> std::false_type)",
    "insertText": "CheckShortDebugString(...)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using HasDebugStringType =)",
    "insertText": "decltype(CheckDebugString<T>(nullptr))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using HasShortDebugStringType =)",
    "insertText": "decltype(CheckShortDebugString<T>(nullptr))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (public : bool value = HasDebugStringType::value&& HasShortDebugStringType::value ; } ; template<T> bool HasDebugStringAndShortDebugString<T>::value ; typedef int IsContainer ; template<class C,class Iterator =)",
    "insertText": "decltype(::std::declval<const C&>().begin()), class = decltype(::std::declval<const C&>().end()), class = decltype(++::std::declval<Iterator&>()), class = decltype(*::std::declval<Iterator>()), class = typename C::const_iterator> IsContainer IsContainerTest(int)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (template<U> int)",
    "insertText": "test(typename U::hasher*, ...)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (template<U> char)",
    "insertText": "test(...)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (public : const bool value =)",
    "insertText": "sizeof(test<T>(nullptr, nullptr)) == sizeof(int)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} ; template<T> const bool IsHashTable<T>::value ; template<C,bool =)",
    "insertText": "sizeof(IsContainerTest<C>(0)) == sizeof(IsContainer)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<C> struct IsRecursiveContainerImpl<C,false> : public std::false_type { } ; template<C> struct IsRecursiveContainerImpl<C,true> { using value_type =)",
    "insertText": "decltype(*std::declval<typename C::const_iterator>())"
  },
  {
    "label": "ArrayEq()",
    "kind": "Method",
    "detail": "Function (using type = std::is_same<std::remove_const<std::remove_reference<value_type>::type>::type,C> ; } ; template<C> struct IsRecursiveContainer : public IsRecursiveContainerImpl<C>::type { } ; template<T,U> bool)",
    "insertText": "ArrayEq(const T* lhs, size_t size, const U* rhs)"
  },
  {
    "label": "ArrayEq()",
    "kind": "Method",
    "detail": "Function (template<T,U> bool)",
    "insertText": "ArrayEq(const T& lhs, const U& rhs)"
  },
  {
    "label": "ArrayAwareFind()",
    "kind": "Method",
    "detail": "Function (} return true ; } template<Iter,Element> Iter)",
    "insertText": "ArrayAwareFind(Iter begin, Iter end, const Element& elem)"
  },
  {
    "label": "CopyArray()",
    "kind": "Method",
    "detail": "Function (} return end ; } template<T,U> void)",
    "insertText": "CopyArray(const T* from, size_t size, U* to)"
  },
  {
    "label": "CopyArray()",
    "kind": "Method",
    "detail": "Function (template<T,U> void)",
    "insertText": "CopyArray(const T& from, U* to)"
  },
  {
    "label": "CopyArray()",
    "kind": "Method",
    "detail": "Function (* to = from ; } template<T,U,size_t N> void)",
    "insertText": "CopyArray(const T (&from)[N], U (*to)[N])"
  },
  {
    "label": "CopyArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyArray(from, N, *to)"
  },
  {
    "label": "CopyArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyArray(from[i], to + i)"
  },
  {
    "label": "NativeArray()",
    "kind": "Method",
    "detail": "Function (} } struct RelationToSourceReference { } ; struct RelationToSourceCopy { } ; template<Element> class NativeArray { public : typedef Element value_type ; typedef Element* iterator ; typedef const Element* const_iterator ;)",
    "insertText": "NativeArray(const Element* array, size_t count, RelationToSourceReference)"
  },
  {
    "label": "InitRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitRef(array, count)"
  },
  {
    "label": "NativeArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NativeArray(const Element* array, size_t count, RelationToSourceCopy)"
  },
  {
    "label": "InitCopy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitCopy(array, count)"
  },
  {
    "label": "NativeArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NativeArray(const NativeArray& rhs)"
  },
  {
    "label": "NativeArray()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "NativeArray()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "size()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "static_assert(!std::is_const<Element>::value, \"Type must not be const\")"
  },
  {
    "label": "InitCopy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitCopy(const Element* array, size_t a_size)"
  },
  {
    "label": "CopyArray()",
    "kind": "Method",
    "detail": "Function (Element* const copy = new Element [ a_size ] ;)",
    "insertText": "CopyArray(array, a_size, copy)"
  },
  {
    "label": "InitRef()",
    "kind": "Method",
    "detail": "Function (array_ = copy ; size_ = a_size ; clone_ =& NativeArray::InitCopy ; } void)",
    "insertText": "InitRef(const Element* array, size_t a_size)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (array_ = array ; size_ = a_size ; clone_ =& NativeArray::InitRef ; } const Element* array_ ; size_t size_ ;)",
    "insertText": "void(NativeArray::*clone_)(const Element*, size_t)"
  },
  {
    "label": "I()",
    "kind": "Method",
    "detail": "Function (} ; template<size_t . . . Is> struct IndexSequence { using type = IndexSequence ; } ; template<bool plus_one,T,size_t sizeofT> struct DoubleSequence ; template<size_t . . . I,size_t sizeofT> struct DoubleSequence<true,IndexSequence<I . . .>,sizeofT> { using type = IndexSequence<)",
    "insertText": "I(sizeofT + I)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} ; template<size_t N> struct MakeIndexSequenceImpl : DoubleSequence<N % 2 = = 1,MakeIndexSequenceImpl<N / 2>::type,N / 2>::type { } ; template<> struct MakeIndexSequenceImpl<0> : IndexSequence<> { } ; template<size_t N> using MakeIndexSequence = MakeIndexSequenceImpl<N>::type ; template<. . . T> using IndexSequenceFor = MakeIndexSequence<)",
    "insertText": "sizeof(T)"
  },
  {
    "label": "Ignore()",
    "kind": "Method",
    "detail": "Function (template<size_t> struct Ignore {)",
    "insertText": "Ignore(...)"
  },
  {
    "label": "Apply()",
    "kind": "Method",
    "detail": "Function (} ; template<> struct ElemFromListImpl ; template<size_t . . . I> struct ElemFromListImpl<IndexSequence<I . . .>> { template<R> R)",
    "insertText": "Apply(Ignore<0 * I>..., R (*)(), ...)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<size_t N,. . . T> struct ElemFromList { using type =)",
    "insertText": "decltype(ElemFromListImpl<typename MakeIndexSequence<N>::type>::Apply( static_cast<T (*)()>(nullptr)...))"
  },
  {
    "label": "FlatTupleElemBase()",
    "kind": "Method",
    "detail": "Function (} ; struct FlatTupleConstructTag { } ; template<. . . T> class FlatTuple ; template<Derived,size_t I> struct FlatTupleElemBase ; template<. . . T,size_t I> struct FlatTupleElemBase<FlatTuple<T . . .>,I> { using value_type = ElemFromList<I,T . . .>::type ;)",
    "insertText": "FlatTupleElemBase()"
  },
  {
    "label": "FlatTupleElemBase()",
    "kind": "Method",
    "detail": "Function (template<Arg>)",
    "insertText": "FlatTupleElemBase(FlatTupleConstructTag, Arg&& t) : value(std::forward<Arg>(t))"
  },
  {
    "label": "FlatTupleBase()",
    "kind": "Method",
    "detail": "Function (} value_type value ; } ; template<Derived,Idx> struct FlatTupleBase ; template<size_t . . . Idx,. . . T> struct FlatTupleBase<FlatTuple<T . . .>,IndexSequence<Idx . . .>> : FlatTupleElemBase<FlatTuple<T . . .>,Idx> . . . { using Indices = IndexSequence<Idx . . .> ;)",
    "insertText": "FlatTupleBase()"
  },
  {
    "label": "FlatTupleBase()",
    "kind": "Method",
    "detail": "Function (template<. . . Args>)",
    "insertText": "FlatTupleBase(FlatTupleConstructTag, Args&&... args) : FlatTupleElemBase<FlatTuple<T...>, Idx>(FlatTupleConstructTag{}, std::forward<Args>(args))"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} template<size_t I> const ElemFromList<I,T . . .>::type&)",
    "insertText": "Get()"
  },
  {
    "label": "Apply()",
    "kind": "Method",
    "detail": "Function (} template<F> auto)",
    "insertText": "Apply(F&& f) const -> decltype(std::forward<F>(f)(this->Get<Idx>()...))"
  },
  {
    "label": "FlatTuple()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FlatTuple()"
  },
  {
    "label": "FlatTuple()",
    "kind": "Method",
    "detail": "Function (template<. . . Args>)",
    "insertText": "FlatTuple(FlatTupleConstructTag tag, Args&&... args) : FlatTuple::FlatTupleBase(tag, std::forward<Args>(args)...)"
  },
  {
    "label": "GTEST_INTERNAL_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (} using FlatTuple::FlatTupleBase::Apply ; using FlatTuple::FlatTupleBase::Get ; } ;)",
    "insertText": "GTEST_INTERNAL_DEPRECATED(\"INSTANTIATE_TEST_CASE_P is deprecated, please use \" \"INSTANTIATE_TEST_SUITE_P\") constexpr bool InstantiateTestCase_P_IsDeprecated()"
  },
  {
    "label": "GTEST_MESSAGE_AT_()",
    "kind": "Method",
    "detail": "Function (} ; # ifdef __clang__ # pragma clang diagnostic pop # endif } # define)",
    "insertText": "GTEST_MESSAGE_AT_(file, line, message, result_type) \\ ::testing::internal::AssertHelper(result_type, file, line, message) = \\ ::testing::Message() #define GTEST_MESSAGE_(message, result_type) \\ GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type) #define GTEST_FATAL_FAILURE_(message) \\ return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure) #define GTEST_NONFATAL_FAILURE_(message) \\ GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure) #define GTEST_SUCCESS_(message) \\ GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess) #define GTEST_SKIP_(message) \\ return GTEST_MESSAGE_(message, ::testing::TestPartResult::kSkip) #define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\ if (::testing::internal::AlwaysTrue())"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (\\ statement ; \\ } else \\)",
    "insertText": "static_assert(true, \"\")"
  },
  {
    "label": "what()",
    "kind": "Method",
    "detail": "Function (namespace internal { class NeverThrown { public : const char*)",
    "insertText": "what()"
  },
  {
    "label": "GTEST_TEST_THROW_CATCH_STD_EXCEPTION_()",
    "kind": "Method",
    "detail": "Function (\" an std::exception - derived error \" } # endif # define)",
    "insertText": "GTEST_TEST_THROW_CATCH_STD_EXCEPTION_(statement, expected_exception) \\ catch (typename std::conditional< \\ std::is_same<typename std::remove_cv<typename std::remove_reference< \\ expected_exception>::type>::type, \\ std::exception>::value, \\ const ::testing::internal::NeverThrown&, const std::exception&>::type \\ e)"
  },
  {
    "label": "GTEST_EXCEPTION_TYPE_()",
    "kind": "Method",
    "detail": "Function (\\ gtest_msg . value = \" Expected : \" # statement \\ \" throws an exception of type \" # expected_exception \\ \" . \\ n Actual : it throws \" ; \\ gtest_msg . value + =)",
    "insertText": "GTEST_EXCEPTION_TYPE_(e)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ gtest_msg . value + = \" \\ \" . \" ; \\ goto)",
    "insertText": "GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__)"
  },
  {
    "label": "GTEST_TEST_THROW_CATCH_STD_EXCEPTION_()",
    "kind": "Method",
    "detail": "Function (\\ } # else # define)",
    "insertText": "GTEST_TEST_THROW_CATCH_STD_EXCEPTION_(statement, expected_exception) #endif #define GTEST_TEST_THROW_(statement, expected_exception, fail) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (::testing::internal::TrueWithString gtest_msg{})"
  },
  {
    "label": "GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_()",
    "kind": "Method",
    "detail": "Function (\\ bool gtest_caught_expected = false ; \\ try { \\)",
    "insertText": "GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement)"
  },
  {
    "label": "catch()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "catch(expected_exception const&)"
  },
  {
    "label": "GTEST_TEST_THROW_CATCH_STD_EXCEPTION_()",
    "kind": "Method",
    "detail": "Function (\\ gtest_caught_expected = true ; \\ } \\)",
    "insertText": "GTEST_TEST_THROW_CATCH_STD_EXCEPTION_(statement, expected_exception) \\ catch (...)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ } \\)",
    "insertText": "if(!gtest_caught_expected)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__) \\ : fail(gtest_msg.value.c_str()) #if GTEST_HAS_EXCEPTIONS #define GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_() \\ catch (std::exception const& e)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ gtest_msg . value + = \" \\ \" . \" ; \\ goto)",
    "insertText": "GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__)"
  },
  {
    "label": "GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_()",
    "kind": "Method",
    "detail": "Function (\\ } # else # define)",
    "insertText": "GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_() #endif #define GTEST_TEST_NO_THROW_(statement, fail) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (::testing::internal::TrueWithString gtest_msg{})"
  },
  {
    "label": "GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_()",
    "kind": "Method",
    "detail": "Function (\\ } \\)",
    "insertText": "GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_() \\ catch (...)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__) \\ : fail((\"Expected: \" #statement \" doesn't throw an exception.\\n\" \\ \" Actual: \" + \\ gtest_msg.value) \\ .c_str()) #define GTEST_TEST_ANY_THROW_(statement, fail) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (::testing::internal::AlwaysTrue())"
  },
  {
    "label": "catch()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "catch(...)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ gtest_caught_any = true ; \\ } \\)",
    "insertText": "if(!gtest_caught_any)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ goto)",
    "insertText": "GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__) \\ : fail(\"Expected: \" #statement \\ \" throws an exception.\\n\" \\ \" Actual: it doesn't.\") #define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (const ::testing::AssertionResult gtest_ar_ = \\ ::testing::AssertionResult(expression))"
  },
  {
    "label": "fail()",
    "kind": "Method",
    "detail": "Function (\\ else \\)",
    "insertText": "fail(::testing::internal::GetBoolAssertionFailureMessage( \\ gtest_ar_, text, #actual, #expected) \\ .c_str()) #define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (::testing::internal::AlwaysTrue())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(gtest_fatal_failure_checker.has_new_fatal_failure())"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ goto)",
    "insertText": "GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__) \\ : fail(\"Expected: \" #statement \\ \" doesn't generate new fatal \" \\ \"failures in the current thread.\\n\" \\ \" Actual: it does.\") #define GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) \\ test_suite_name##_##test_name##_Test #define GTEST_TEST_(test_suite_name, test_name, parent_class, parent_id) \\ static_assert(sizeof(GTEST_STRINGIFY_(test_suite_name)) > 1, \\ \"test_suite_name must not be empty\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "static_assert(sizeof(GTEST_STRINGIFY_(test_name)) > 1, \\ \"test_name must not be empty\")"
  },
  {
    "label": "GTEST_TEST_CLASS_NAME_()",
    "kind": "Method",
    "detail": "Function (\\ class)",
    "insertText": "GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)"
  },
  {
    "label": "GTEST_TEST_CLASS_NAME_()",
    "kind": "Method",
    "detail": "Function (\\ public : \\)",
    "insertText": "GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)()"
  },
  {
    "label": "GTEST_TEST_CLASS_NAME_()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) \\ (const GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &)"
  },
  {
    "label": "GTEST_TEST_CLASS_NAME_()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) & operator=( \\ const GTEST_TEST_CLASS_NAME_(test_suite_name, \\ test_name) &)"
  },
  {
    "label": "GTEST_TEST_CLASS_NAME_()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) \\ (GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &&)"
  },
  {
    "label": "GTEST_TEST_CLASS_NAME_()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) & operator=( \\ GTEST_TEST_CLASS_NAME_(test_suite_name, \\ test_name) &&)"
  },
  {
    "label": "TestBody()",
    "kind": "Method",
    "detail": "Function (\\ \\ private : \\ void)",
    "insertText": "TestBody()"
  },
  {
    "label": "GTEST_TEST_CLASS_NAME_()",
    "kind": "Method",
    "detail": "Function (\\::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_ ; \\ } ; \\ \\::testing::TestInfo* const)",
    "insertText": "GTEST_TEST_CLASS_NAME_(test_suite_name, \\ test_name)::test_info_ = \\ ::testing::internal::MakeAndRegisterTestInfo( \\ #test_suite_name, #test_name, nullptr, nullptr, \\ ::testing::internal::CodeLocation(__FILE__, __LINE__), (parent_id), \\ ::testing::internal::SuiteApiResolver< \\ parent_class>::GetSetUpCaseOrSuite(__FILE__, __LINE__), \\ ::testing::internal::SuiteApiResolver< \\ parent_class>::GetTearDownCaseOrSuite(__FILE__, __LINE__), \\ new ::testing::internal::TestFactoryImpl<GTEST_TEST_CLASS_NAME_( \\ test_suite_name, test_name)>)"
  }
]