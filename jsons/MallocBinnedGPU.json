[
  {
    "label": "FArenaParams",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FArenaParams"
  },
  {
    "label": "CORE_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CORE_API"
  },
  {
    "label": "FGlobalRecycler",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGlobalRecycler"
  },
  {
    "label": "FPoolInfoLarge",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPoolInfoLarge"
  },
  {
    "label": "FPoolInfoSmall",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPoolInfoSmall"
  },
  {
    "label": "FPoolTable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPoolTable"
  },
  {
    "label": "PoolHashBucket",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PoolHashBucket"
  },
  {
    "label": "Private",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Private"
  },
  {
    "label": "FGPUMemoryBlockProxy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGPUMemoryBlockProxy"
  },
  {
    "label": "FFreeBlock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFreeBlock"
  },
  {
    "label": "FPtrToPoolMapping",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPtrToPoolMapping"
  },
  {
    "label": "FBundleNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBundleNode"
  },
  {
    "label": "FBundle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBundle"
  },
  {
    "label": "FFreeBlockList",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFreeBlockList"
  },
  {
    "label": "FPerThreadFreeBlockLists",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPerThreadFreeBlockLists"
  },
  {
    "label": "FPaddedBundlePointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPaddedBundlePointer"
  },
  {
    "label": "FOutputDevice",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOutputDevice"
  },
  {
    "label": "BINNEDGPU_MAX_GMallocBinnedGPUMaxBundlesBeforeRecycle()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" CoreTypes . h \" # include \" HAL / PlatformAtomics . h \" # include \" HAL / PlatformMemory . h \" # include \" Math / UnrealMathUtility . h \" # include \" Templates / Atomic . h \" # include \" Templates / MemoryOps . h \" # if PLATFORM_64BITS&& PLATFORM_HAS_FPlatformVirtualMemoryBlock # include \" HAL / Allocators / CachedOSPageAllocator . h \" # include \" HAL / Allocators / PooledVirtualMemoryAllocator . h \" # include \" HAL / CriticalSection . h \" # include \" HAL / LowLevelMemTracker . h \" # include \" HAL / MallocBinnedCommon . h \" # include \" HAL / MemoryBase . h \" # include \" HAL / PlatformMath . h \" # include \" HAL / PlatformTLS . h \" # include \" HAL / UnrealMemory . h \" # include \" Math / NumericLimits . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / ScopeLock . h \" # include \" Misc / ScopeLock . h \" # include \" Templates / AlignmentTemplates . h \" # include \" Templates / Function . h \" # define)",
    "insertText": "BINNEDGPU_MAX_GMallocBinnedGPUMaxBundlesBeforeRecycle(8) #define COLLECT_BINNEDGPU_STATS (!UE_BUILD_SHIPPING) #if COLLECT_BINNEDGPU_STATS #define MBG_STAT(x) x #else #define MBG_STAT(x)"
  },
  {
    "label": "bUseSeparateVMPerPool()",
    "kind": "Method",
    "detail": "Function (uint64 AddressLimit = 1 0 2 4* 1 0 2 4* 1 0 2 4 ; uint32 BasePageSize = 4 0 9 6 ; uint32 AllocationGranularity = 4 0 9 6 ; uint32 MaxSizePerBundle = 8 1 9 2 ; uint32 MaxStandardPoolSize = 1 2 8* 1 0 2 4 ; uint16 MaxBlocksPerBundle = 6 4 ; uint8 MaxMemoryPerBlockSizeShift = 2 9 ; uint8 EmptyCacheAllocExtra = 3 2 ; uint8 MaxGlobalBundles = 3 2 ; uint8 MinimumAlignmentShift = 4 ; uint8 PoolCount ; bool)",
    "insertText": "bUseSeparateVMPerPool(BINNEDCOMMON_USE_SEPARATE_VM_PER_POOL)"
  },
  {
    "label": "FPlatformVirtualMemoryBlock()",
    "kind": "Method",
    "detail": "Function (bool bPerThreadCaches = true ; bool bUseStandardSmallPoolSizes = true ; bool bAttemptToAlignSmallBocks = true ; TArray<uint32> AdditionalBlockSizes ; TFunction<)",
    "insertText": "FPlatformVirtualMemoryBlock(SIZE_T)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (TFunction<)",
    "insertText": "void(SIZE_T, SIZE_T, SIZE_T&, uint32&)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (TFunction<)",
    "insertText": "void(void*, uint32)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (uint64 MaxMemoryPerBlockSize ; uint32 MaxPoolSize ; uint32 MinimumAlignment ; uint32 MaximumAlignmentForSmallBlock ; } ; class FMallocBinnedGPU final : public FMalloc { struct FGlobalRecycler ; struct FPoolInfoLarge ; struct FPoolInfoSmall ; struct FPoolTable ; struct PoolHashBucket ; struct Private ; struct FGPUMemoryBlockProxy { uint8 MemoryModifiedByCPU [ 3 2 -)",
    "insertText": "sizeof(void*)"
  },
  {
    "label": "FGPUMemoryBlockProxy()",
    "kind": "Method",
    "detail": "Function (void* GPUMemory ;)",
    "insertText": "FGPUMemoryBlockProxy(void *InGPUMemory) : GPUMemory(InGPUMemory)"
  },
  {
    "label": "FFreeBlock()",
    "kind": "Method",
    "detail": "Function (} } ; struct FFreeBlock { enum { CANARY_VALUE = 0 xc3 } ;)",
    "insertText": "FFreeBlock(uint32 InPageSize, uint32 InBlockSize, uint32 InPoolIndex, uint8 MinimumAlignmentShift) : BlockSizeShifted(InBlockSize >> MinimumAlignmentShift) , PoolIndex(InPoolIndex) , Canary(CANARY_VALUE) , NextFreeBlock(nullptr)"
  },
  {
    "label": "GetNumFreeRegularBlocks()",
    "kind": "Method",
    "detail": "Function (NumFreeBlocks = InPageSize / InBlockSize ; } uint32)",
    "insertText": "GetNumFreeRegularBlocks()"
  },
  {
    "label": "CanaryFail()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CanaryFail()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (- - NumFreeBlocks ;)",
    "insertText": "return(uint8*)(((FGPUMemoryBlockProxy*)this)->GPUMemory) + NumFreeBlocks * (uint32(BlockSizeShifted) << MinimumAlignmentShift)"
  },
  {
    "label": "FPtrToPoolMapping()",
    "kind": "Method",
    "detail": "Function (} uint16 BlockSizeShifted ; uint8 PoolIndex ; uint8 Canary ; uint32 NumFreeBlocks ; FFreeBlock* NextFreeBlock ; } ; struct FPoolTable { uint32 BlockSize ; uint16 BlocksPerBlockOfBlocks ; uint8 PagesPlatformForBlockOfBlocks ; FBitTree BlockOfBlockAllocationBits ; FBitTree BlockOfBlockIsExhausted ; uint32 NumEverUsedBlockOfBlocks ; FPoolInfoSmall** PoolInfos ; uint64 UnusedAreaOffsetLow ; } ; struct FPtrToPoolMapping {)",
    "insertText": "FPtrToPoolMapping() : PtrToPoolPageBitShift(0) , HashKeyShift(0) , PoolMask(0) , MaxHashBuckets(0)"
  },
  {
    "label": "FPtrToPoolMapping()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FPtrToPoolMapping(uint32 InPageSize, uint64 InNumPoolsPerPage, uint64 AddressLimit)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(InPageSize, InNumPoolsPerPage, AddressLimit)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Init(uint32 InPageSize, uint64 InNumPoolsPerPage, uint64 AddressLimit)"
  },
  {
    "label": "CeilLogTwo()",
    "kind": "Method",
    "detail": "Function (uint64 PoolPageToPoolBitShift =)",
    "insertText": "CeilLogTwo(InNumPoolsPerPage)"
  },
  {
    "label": "CeilLogTwo()",
    "kind": "Method",
    "detail": "Function (PtrToPoolPageBitShift =)",
    "insertText": "CeilLogTwo(InPageSize)"
  },
  {
    "label": "PoolMask()",
    "kind": "Method",
    "detail": "Function (HashKeyShift = PtrToPoolPageBitShift + PoolPageToPoolBitShift ;)",
    "insertText": "PoolMask(1ull << PoolPageToPoolBitShift)"
  },
  {
    "label": "GetHashBucketAndPoolIndices()",
    "kind": "Method",
    "detail": "Function (MaxHashBuckets = AddressLimit>> HashKeyShift ; } void)",
    "insertText": "GetHashBucketAndPoolIndices(const void* InPtr, uint32& OutBucketIndex, UPTRINT& OutBucketCollision, uint32& OutPoolIndex)"
  },
  {
    "label": "OutBucketCollision()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutBucketCollision(UPTRINT)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (OutBucketIndex =)",
    "insertText": "uint32(OutBucketCollision & (MaxHashBuckets - 1))"
  },
  {
    "label": "OutPoolIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutPoolIndex((UPTRINT)InPtr >> PtrToPoolPageBitShift)"
  },
  {
    "label": "GetMaxHashBuckets()",
    "kind": "Method",
    "detail": "Function (} uint64)",
    "insertText": "GetMaxHashBuckets()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "PushHead()",
    "kind": "Method",
    "detail": "Function (Head = nullptr ; Count = 0 ; } void)",
    "insertText": "PushHead(FBundleNode* Node)"
  },
  {
    "label": "PopHead()",
    "kind": "Method",
    "detail": "Function (Node -> NextNodeInCurrentBundle = Head ; Node -> NextBundle = nullptr ; Head = Node ; Count + + ; } FBundleNode*)",
    "insertText": "PopHead()"
  },
  {
    "label": "PushToFront()",
    "kind": "Method",
    "detail": "Function (FBundleNode* Result = Head ; Count - - ; Head = Head -> NextNodeInCurrentBundle ; return Result ; } FBundleNode* Head ; uint32 Count ; } ; struct FFreeBlockList { bool)",
    "insertText": "PushToFront(FMallocBinnedGPU& Allocator, void* InPtr, uint32 InPoolIndex, uint32 InBlockSize, const FArenaParams& LocalArenaParams)"
  },
  {
    "label": "PushHead()",
    "kind": "Method",
    "detail": "Function (} PartialBundle .)",
    "insertText": "PushHead((FBundleNode*)new FGPUMemoryBlockProxy(InPtr))"
  },
  {
    "label": "MBG_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MBG_STAT(Allocator.GPUProxyMemory += sizeof(FGPUMemoryBlockProxy);)"
  },
  {
    "label": "CanPushToFront()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CanPushToFront(uint32 InPoolIndex, uint32 InBlockSize, const FArenaParams& LocalArenaParams)"
  },
  {
    "label": "PopFromFront()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "PopFromFront(FMallocBinnedGPU& Allocator, uint32 InPoolIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} void* Result = nullptr ;)",
    "insertText": "if(PartialBundle.Head)"
  },
  {
    "label": "Proxy()",
    "kind": "Method",
    "detail": "Function (FGPUMemoryBlockProxy*)",
    "insertText": "Proxy(FGPUMemoryBlockProxy*)PartialBundle.PopHead()"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (Result = Proxy -> GPUMemory ;)",
    "insertText": "check(Result)"
  },
  {
    "label": "MBG_STAT()",
    "kind": "Method",
    "detail": "Function (delete Proxy ;)",
    "insertText": "MBG_STAT(Allocator.GPUProxyMemory -= sizeof(FGPUMemoryBlockProxy);)"
  },
  {
    "label": "RecyleFull()",
    "kind": "Method",
    "detail": "Function (} FBundleNode*)",
    "insertText": "RecyleFull(FArenaParams& LocalArenaParams, FGlobalRecycler& GGlobalRecycler, uint32 InPoolIndex)"
  },
  {
    "label": "ObtainPartial()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ObtainPartial(FArenaParams& LocalArenaParams, FGlobalRecycler& GGlobalRecycler, uint32 InPoolIndex)"
  },
  {
    "label": "PopBundles()",
    "kind": "Method",
    "detail": "Function (FBundleNode*)",
    "insertText": "PopBundles(uint32 InPoolIndex)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (private : FBundle PartialBundle ; FBundle FullBundle ; } ; struct FPerThreadFreeBlockLists { FPerThreadFreeBlockLists*)",
    "insertText": "Get(uint32 BinnedGPUTlsSlot)"
  },
  {
    "label": "SetTLS()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetTLS(FMallocBinnedGPU& Allocator)"
  },
  {
    "label": "ClearTLS()",
    "kind": "Method",
    "detail": "Function (int64)",
    "insertText": "ClearTLS(FMallocBinnedGPU& Allocator)"
  },
  {
    "label": "FPerThreadFreeBlockLists()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPerThreadFreeBlockLists(uint32 PoolCount) : AllocatedMemory(0)"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (FreeLists .)",
    "insertText": "AddDefaulted(PoolCount)"
  },
  {
    "label": "Malloc()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "Malloc(FMallocBinnedGPU& Allocator, uint32 InPoolIndex)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Free(FMallocBinnedGPU& Allocator, void* InPtr, uint32 InPoolIndex, uint32 InBlockSize, const FArenaParams& LocalArenaParams)"
  },
  {
    "label": "CanFree()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CanFree(uint32 InPoolIndex, uint32 InBlockSize, const FArenaParams& LocalArenaParams)"
  },
  {
    "label": "RecycleFullBundle()",
    "kind": "Method",
    "detail": "Function (} FBundleNode*)",
    "insertText": "RecycleFullBundle(FArenaParams& LocalArenaParams, FGlobalRecycler& GlobalRecycler, uint32 InPoolIndex)"
  },
  {
    "label": "ObtainRecycledPartial()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ObtainRecycledPartial(FArenaParams& LocalArenaParams, FGlobalRecycler& GlobalRecycler, uint32 InPoolIndex)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} int64 AllocatedMemory ; TArray<FFreeBlockList> FreeLists ; } ; struct FGlobalRecycler { void)",
    "insertText": "Init(uint32 PoolCount)"
  },
  {
    "label": "PushBundle()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "PushBundle(uint32 NumCachedBundles, uint32 InPoolIndex, FBundleNode* InBundle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FBundleNode* Result = Bundles [ InPoolIndex ] . FreeBundles [ Slot ] ;)",
    "insertText": "if(Result)"
  },
  {
    "label": "FBundleNode()",
    "kind": "Method",
    "detail": "Function (DefaultConstructItems<)",
    "insertText": "FBundleNode(FreeBundles, BINNEDGPU_MAX_GMallocBinnedGPUMaxBundlesBeforeRecycle)"
  },
  {
    "label": "PoolIndexFromPtr()",
    "kind": "Method",
    "detail": "Function (} } ; TArray<FPaddedBundlePointer> Bundles ; } ; uint64)",
    "insertText": "PoolIndexFromPtr(const void* Ptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} uint64 PoolIndex = ArenaParams . PoolCount ;)",
    "insertText": "if(((uint8*)Ptr >= PoolBaseVMPtr[0]) & ((uint8*)Ptr < HighestPoolBaseVMPtr + ArenaParams.MaxMemoryPerBlockSize))"
  },
  {
    "label": "uint64()",
    "kind": "Method",
    "detail": "Function (PoolIndex =)",
    "insertText": "uint64((uint8*)Ptr - PoolBaseVMPtr[0])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (PoolIndex = ArenaParams . PoolCount - 1 ; })",
    "insertText": "if((uint8*)Ptr < PoolBaseVMPtr[(int32)PoolIndex])"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while((uint8*)Ptr < PoolBaseVMPtr[(int32)PoolIndex])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (PoolIndex = ArenaParams . PoolCount ; } } else)",
    "insertText": "if((uint8*)Ptr >= PoolBaseVMPtr[(int32)PoolIndex] + ArenaParams.MaxMemoryPerBlockSize)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while((uint8*)Ptr >= PoolBaseVMPtr[(int32)PoolIndex] + ArenaParams.MaxMemoryPerBlockSize)"
  },
  {
    "label": "PoolBasePtr()",
    "kind": "Method",
    "detail": "Function (PoolIndex = ArenaParams . PoolCount ; } } } return PoolIndex ; } uint8*)",
    "insertText": "PoolBasePtr(uint32 InPoolIndex)"
  },
  {
    "label": "PoolIndexFromPtr()",
    "kind": "Method",
    "detail": "Function (uint64 Result =)",
    "insertText": "PoolIndexFromPtr(Ptr)"
  },
  {
    "label": "BlockOfBlocksPointerFromContainedPtr()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "BlockOfBlocksPointerFromContainedPtr(const void* Ptr, uint8 PagesPlatformForBlockOfBlocks, uint32& OutBlockOfBlocksIndex)"
  },
  {
    "label": "PoolIndexFromPtrChecked()",
    "kind": "Method",
    "detail": "Function (uint32 PoolIndex =)",
    "insertText": "PoolIndexFromPtrChecked(Ptr)"
  },
  {
    "label": "PoolBasePtr()",
    "kind": "Method",
    "detail": "Function (uint8* PoolStart =)",
    "insertText": "PoolBasePtr(PoolIndex)"
  },
  {
    "label": "BlockOfBlocksIndex()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "BlockOfBlocksIndex(UPTRINT(Ptr) - UPTRINT(PoolStart)) / (UPTRINT(PagesPlatformForBlockOfBlocks) * UPTRINT(ArenaParams.AllocationGranularity))"
  },
  {
    "label": "UPTRINT()",
    "kind": "Method",
    "detail": "Function (OutBlockOfBlocksIndex = BlockOfBlocksIndex ; uint8* Result = PoolStart + BlockOfBlocksIndex*)",
    "insertText": "UPTRINT(PagesPlatformForBlockOfBlocks) * UPTRINT(ArenaParams.AllocationGranularity)"
  },
  {
    "label": "PoolBasePtr()",
    "kind": "Method",
    "detail": "Function (uint8* PoolStart =)",
    "insertText": "PoolBasePtr(InPoolIndex)"
  },
  {
    "label": "uint64()",
    "kind": "Method",
    "detail": "Function (uint8* Ptr = PoolStart + BlockOfBlocksIndex*)",
    "insertText": "uint64(BlockOfBlocksSize)"
  },
  {
    "label": "GetFrontPool()",
    "kind": "Method",
    "detail": "Function (FPoolInfoSmall*)",
    "insertText": "GetFrontPool(FPoolTable& Table, uint32 InPoolIndex, uint32& OutBlockOfBlocksIndex)"
  },
  {
    "label": "BoundSizeToPoolIndex()",
    "kind": "Method",
    "detail": "Function (uint32 PoolIndex =)",
    "insertText": "BoundSizeToPoolIndex(AlignedSize)"
  },
  {
    "label": "PoolIndexToBlockSize()",
    "kind": "Method",
    "detail": "Function (uint32 BlockSize =)",
    "insertText": "PoolIndexToBlockSize(PoolIndex)"
  },
  {
    "label": "SIZE_T()",
    "kind": "Method",
    "detail": "Function (InOutSize =)",
    "insertText": "SIZE_T(BlockSize)"
  },
  {
    "label": "FMallocBinnedGPU()",
    "kind": "Method",
    "detail": "Function (} } return false ; } public :)",
    "insertText": "FMallocBinnedGPU()"
  },
  {
    "label": "GetParams()",
    "kind": "Method",
    "detail": "Function (FArenaParams&)",
    "insertText": "GetParams()"
  },
  {
    "label": "IsInternallyThreadSafe()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsInternallyThreadSafe()"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (Alignment = FMath::Max<)",
    "insertText": "uint32(Alignment, ArenaParams.MinimumAlignment)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (void* Result = nullptr ;)",
    "insertText": "if(AdjustSmallBlockSizeForAlignment(Size, Alignment))"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (FPerThreadFreeBlockLists* Lists = ArenaParams . bPerThreadCaches ?)",
    "insertText": "Get(BinnedGPUTlsSlot)"
  },
  {
    "label": "BoundSizeToPoolIndex()",
    "kind": "Method",
    "detail": "Function (uint32 PoolIndex =)",
    "insertText": "BoundSizeToPoolIndex(Size)"
  },
  {
    "label": "Malloc()",
    "kind": "Method",
    "detail": "Function (Result = Lists ->)",
    "insertText": "Malloc(*this, PoolIndex)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (Lists -> AllocatedMemory + = BlockSize ;)",
    "insertText": "checkSlow(IsAligned(Result, Alignment))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(Result == nullptr)"
  },
  {
    "label": "MallocExternal()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "MallocExternal(Size, Alignment)"
  },
  {
    "label": "Realloc()",
    "kind": "Method",
    "detail": "Function (} return Result ; } void*)",
    "insertText": "Realloc(void* Ptr, SIZE_T NewSize, uint32 Alignment)"
  },
  {
    "label": "FreeExternal()",
    "kind": "Method",
    "detail": "Function (Lists -> AllocatedMemory - = BlockSize ; return ; } } })",
    "insertText": "FreeExternal(Ptr)"
  },
  {
    "label": "GetAllocationSize()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetAllocationSize(void *Ptr, SIZE_T &SizeOut)"
  },
  {
    "label": "QuantizeSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "QuantizeSize(SIZE_T Count, uint32 Alignment)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SIZE_T SizeOut ;)",
    "insertText": "if((Count <= ArenaParams.MaxPoolSize) & (Alignment <= ArenaParams.MinimumAlignment))"
  },
  {
    "label": "PoolIndexToBlockSize()",
    "kind": "Method",
    "detail": "Function (SizeOut =)",
    "insertText": "PoolIndexToBlockSize(BoundSizeToPoolIndex(Count))"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (} else { Alignment = FPlatformMath::Max<)",
    "insertText": "uint32(Alignment, ArenaParams.AllocationGranularity)"
  },
  {
    "label": "Align()",
    "kind": "Method",
    "detail": "Function (SizeOut =)",
    "insertText": "Align(Count, Alignment)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(SizeOut >= Count)"
  },
  {
    "label": "Trim()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Trim(bool bTrimThreadCaches)"
  },
  {
    "label": "SetupTLSCachesOnCurrentThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetupTLSCachesOnCurrentThread()"
  },
  {
    "label": "ClearAndDisableTLSCachesOnCurrentThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearAndDisableTLSCachesOnCurrentThread()"
  },
  {
    "label": "GetDescriptiveName()",
    "kind": "Method",
    "detail": "Function (const TCHAR*)",
    "insertText": "GetDescriptiveName()"
  },
  {
    "label": "FlushCurrentThreadCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushCurrentThreadCache()"
  },
  {
    "label": "MallocExternal()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "MallocExternal(SIZE_T Size, uint32 Alignment)"
  },
  {
    "label": "FreeExternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeExternal(void *Ptr)"
  },
  {
    "label": "GetAllocationSizeExternal()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetAllocationSizeExternal(void* Ptr, SIZE_T& SizeOut)"
  },
  {
    "label": "MBG_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MBG_STAT(int64 GetTotalAllocatedSmallPoolMemory();) virtual void GetAllocatorStats(FGenericMemoryStats& out_Stats)"
  },
  {
    "label": "DumpAllocatorStats()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DumpAllocatorStats(class FOutputDevice& Ar)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "Index((Size + ArenaParams.MinimumAlignment - 1) >> ArenaParams.MinimumAlignmentShift)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (uint32 PoolIndex =)",
    "insertText": "uint32(MemSizeToIndex[Index])"
  },
  {
    "label": "Commit()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Commit(uint32 InPoolIndex, void *Ptr, SIZE_T Size)"
  },
  {
    "label": "Decommit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Decommit(uint32 InPoolIndex, void *Ptr, SIZE_T Size)"
  },
  {
    "label": "MBG_STAT()",
    "kind": "Method",
    "detail": "Function (TArray<FPoolTable> SmallPoolTables ; uint32 SmallPoolInfosPerPlatformPage ; PoolHashBucket* HashBuckets ; PoolHashBucket* HashBucketFreeList ; uint64 NumLargePoolsPerPage ; FCriticalSection Mutex ; FGlobalRecycler GGlobalRecycler ; FPtrToPoolMapping PtrToPoolMapping ; FArenaParams ArenaParams ; TArray<uint16> SmallBlockSizesReversedShifted ; uint32 BinnedGPUTlsSlot = FPlatformTLS::InvalidTlsSlot ; uint64 PoolSearchDiv ; uint8* HighestPoolBaseVMPtr ; FPlatformMemory::FPlatformVirtualMemoryBlock PoolBaseVMBlock ; TArray<uint8*> PoolBaseVMPtr ; TArray<FPlatformMemory::FPlatformVirtualMemoryBlock> PoolBaseVMBlocks ; TArray<uint8> MemSizeToIndex ;)",
    "insertText": "MBG_STAT(int64 BinnedGPUAllocatedSmallPoolMemory = 0; int64 BinnedGPUAllocatedOSSmallPoolMemory = 0; int64 BinnedGPUAllocatedLargePoolMemory = 0; int64 BinnedGPUAllocatedLargePoolMemoryWAlignment = 0; int64 BinnedGPUPoolInfoMemory = 0; int64 BinnedGPUHashMemory = 0; int64 BinnedGPUFreeBitsMemory = 0; int64 BinnedGPUTLSMemory = 0; TAtomic<int64> ConsolidatedMemory; TAtomic<int64> GPUProxyMemory;)"
  },
  {
    "label": "GetFreeBlockListsRegistrationMutex()",
    "kind": "Method",
    "detail": "Function (FCriticalSection&)",
    "insertText": "GetFreeBlockListsRegistrationMutex()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "Lock(&GetFreeBlockListsRegistrationMutex())"
  },
  {
    "label": "GetRegisteredFreeBlockLists()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetRegisteredFreeBlockLists().Add(FreeBlockLists)"
  },
  {
    "label": "UnregisterThreadFreeBlockLists()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "UnregisterThreadFreeBlockLists(FPerThreadFreeBlockLists* FreeBlockLists)"
  },
  {
    "label": "GetRegisteredFreeBlockLists()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetRegisteredFreeBlockLists().Remove(FreeBlockLists)"
  }
]