[
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "__fn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__fn"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___RANGES_RBEGIN_H # define _LIBCPP___RANGES_RBEGIN_H # include<__concepts / class_or_enum . h> # include<__concepts / same_as . h> # include<__config> # include<__iterator / concepts . h> # include<__iterator / readable_traits . h> # include<__iterator / reverse_iterator . h> # include<__ranges / access . h> # include<__utility / auto_cast . h> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER) # pragma GCC system_header #endif _LIBCPP_BEGIN_NAMESPACE_STD #if _LIBCPP_STD_VER > 17 && !defined(_LIBCPP_HAS_NO_INCOMPLETE_RANGES)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (namespace __rbegin { template<class _Tp> concept __member_rbegin = __can_borrow<_Tp>&& __workaround_52970<_Tp>&&)",
    "insertText": "requires(_Tp&& __t)"
  },
  {
    "label": "_LIBCPP_AUTO_CAST()",
    "kind": "Method",
    "detail": "Function (input_or_output_iterator)",
    "insertText": "_LIBCPP_AUTO_CAST(__t.rbegin())"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "rbegin(auto&)"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rbegin(const auto&)"
  },
  {
    "label": "_LIBCPP_AUTO_CAST()",
    "kind": "Method",
    "detail": "Function (input_or_output_iterator)",
    "insertText": "_LIBCPP_AUTO_CAST(rbegin(__t))"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "begin(__t) } -> same_as<decltype(ranges::end(__t))"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (bidirectional_iterator)",
    "insertText": "begin(__t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; struct __fn { template<class _Tp> requires __member_rbegin<_Tp> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t) const noexcept(noexcept(_LIBCPP_AUTO_CAST(__t.rbegin())))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp> requires __unqualified_rbegin<_Tp> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t) const noexcept(noexcept(_LIBCPP_AUTO_CAST(rbegin(__t))))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp> requires __can_reverse<_Tp> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t) const noexcept(noexcept(ranges::end(__t)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(auto&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; } namespace __cpo { auto rbegin = __rbegin::__fn { } ; } } namespace ranges { namespace __crbegin { struct __fn { template<class _Tp> requires is_lvalue_reference_v<_Tp&&> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t) const noexcept(noexcept(ranges::rbegin(static_cast<const remove_reference_t<_Tp>&>(__t)))) -> decltype( ranges::rbegin(static_cast<const remove_reference_t<_Tp>&>(__t)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp> requires is_rvalue_reference_v<_Tp&&> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t) const noexcept(noexcept(ranges::rbegin(static_cast<const _Tp&&>(__t)))) -> decltype( ranges::rbegin(static_cast<const _Tp&&>(__t)))"
  }
]