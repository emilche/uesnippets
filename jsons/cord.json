[
  {
    "label": "Cord",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Cord"
  },
  {
    "label": "CordTestPeer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CordTestPeer"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "CharIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CharIterator"
  },
  {
    "label": "ChunkIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ChunkIterator"
  },
  {
    "label": "ChunkRange",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ChunkRange"
  },
  {
    "label": "CharRange",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CharRange"
  },
  {
    "label": "InlineRep",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InlineRep"
  },
  {
    "label": "CordTestAccess",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CordTestAccess"
  },
  {
    "label": "MakeCordFromExternal()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_STRINGS_CORD_H_ # define ABSL_STRINGS_CORD_H_ # include<algorithm> # include<cstddef> # include<cstdint> # include<cstring> # include<iosfwd> # include<iterator> # include<string> # include<type_traits> # include \" absl / base / attributes . h \" # include \" absl / base / config . h \" # include \" absl / base / internal / endian . h \" # include \" absl / base / internal / per_thread_tls . h \" # include \" absl / base / macros . h \" # include \" absl / base / port . h \" # include \" absl / container / inlined_vector . h \" # include \" absl / functional / function_ref . h \" # include \" absl / meta / type_traits . h \" # include \" absl / strings / cord_analysis . h \" # include \" absl / strings / cord_buffer . h \" # include \" absl / strings / internal / cord_data_edge . h \" # include \" absl / strings / internal / cord_internal . h \" # include \" absl / strings / internal / cord_rep_btree . h \" # include \" absl / strings / internal / cord_rep_btree_reader . h \" # include \" absl / strings / internal / cord_rep_crc . h \" # include \" absl / strings / internal / cord_rep_ring . h \" # include \" absl / strings / internal / cordz_functions . h \" # include \" absl / strings / internal / cordz_info . h \" # include \" absl / strings / internal / cordz_statistics . h \" # include \" absl / strings / internal / cordz_update_scope . h \" # include \" absl / strings / internal / cordz_update_tracker . h \" # include \" absl / strings / internal / resize_uninitialized . h \" # include \" absl / strings / internal / string_constant . h \" # include \" absl / strings / string_view . h \" # include \" absl / types / optional . h \" namespace absl { ABSL_NAMESPACE_BEGIN class Cord ; class CordTestPeer ; template<Releaser> Cord)",
    "insertText": "MakeCordFromExternal(absl::string_view, Releaser&&)"
  },
  {
    "label": "CopyCordToString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyCordToString(const Cord& src, std::string* dst)"
  },
  {
    "label": "Cord()",
    "kind": "Method",
    "detail": "Function (enum class CordMemoryAccounting { kTotal,kFairShare,} ; class Cord { private : template<T> using EnableIfString = absl::enable_if_t<std::is_same<T,std::string>::value,int> ; public :)",
    "insertText": "Cord()"
  },
  {
    "label": "Cord()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Cord(const Cord& src)"
  },
  {
    "label": "Cord()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Cord(Cord&& src)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Cord&)",
    "insertText": "operator(const Cord& x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Cord&)",
    "insertText": "operator(Cord&& x)"
  },
  {
    "label": "Cord()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Cord(absl::string_view src)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Cord&)",
    "insertText": "operator(absl::string_view src)"
  },
  {
    "label": "Cord()",
    "kind": "Method",
    "detail": "Function (template<T,EnableIfString<T> = 0>)",
    "insertText": "Cord(T&& src)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<T,EnableIfString<T> = 0> Cord&)",
    "insertText": "operator(T&& src)"
  },
  {
    "label": "MakeCordFromExternal()",
    "kind": "Method",
    "detail": "Function (} template<Releaser> Cord)",
    "insertText": "MakeCordFromExternal(absl::string_view data, Releaser&& releaser)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (ABSL_ATTRIBUTE_REINITIALIZES void)",
    "insertText": "Clear()"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(const Cord& src)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(Cord&& src)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(absl::string_view src)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (template<T,EnableIfString<T> = 0> void)",
    "insertText": "Append(T&& src)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(CordBuffer buffer)"
  },
  {
    "label": "GetAppendBuffer()",
    "kind": "Method",
    "detail": "Function (CordBuffer)",
    "insertText": "GetAppendBuffer(size_t capacity, size_t min_capacity = 16)"
  },
  {
    "label": "GetCustomAppendBuffer()",
    "kind": "Method",
    "detail": "Function (CordBuffer)",
    "insertText": "GetCustomAppendBuffer(size_t block_size, size_t capacity, size_t min_capacity = 16)"
  },
  {
    "label": "Prepend()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Prepend(const Cord& src)"
  },
  {
    "label": "Prepend()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Prepend(absl::string_view src)"
  },
  {
    "label": "Prepend()",
    "kind": "Method",
    "detail": "Function (template<T,EnableIfString<T> = 0> void)",
    "insertText": "Prepend(T&& src)"
  },
  {
    "label": "Prepend()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Prepend(CordBuffer buffer)"
  },
  {
    "label": "RemovePrefix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemovePrefix(size_t n)"
  },
  {
    "label": "RemoveSuffix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveSuffix(size_t n)"
  },
  {
    "label": "Subcord()",
    "kind": "Method",
    "detail": "Function (Cord)",
    "insertText": "Subcord(size_t pos, size_t new_size)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(Cord& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(Cord& x, Cord& y)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (x .)",
    "insertText": "swap(y)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "size()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "empty()"
  },
  {
    "label": "EstimatedMemoryUsage()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "EstimatedMemoryUsage(CordMemoryAccounting accounting_method = CordMemoryAccounting::kTotal)"
  },
  {
    "label": "Compare()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "Compare(absl::string_view rhs)"
  },
  {
    "label": "Compare()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "Compare(const Cord& rhs)"
  },
  {
    "label": "StartsWith()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "StartsWith(const Cord& rhs)"
  },
  {
    "label": "StartsWith()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "StartsWith(absl::string_view rhs)"
  },
  {
    "label": "EndsWith()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EndsWith(absl::string_view rhs)"
  },
  {
    "label": "EndsWith()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EndsWith(const Cord& rhs)"
  },
  {
    "label": "string()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "string()"
  },
  {
    "label": "ChunkIterator()",
    "kind": "Method",
    "detail": "Function (class CharIterator ; class ChunkIterator { public : using iterator_category = std::input_iterator_tag ; using value_type = absl::string_view ; using difference_type = ptrdiff_t ; using pointer = const value_type* ; using reference = value_type ;)",
    "insertText": "ChunkIterator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ChunkIterator&)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ChunkIterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const ChunkIterator& other)"
  },
  {
    "label": "ChunkIterator()",
    "kind": "Method",
    "detail": "Function (class Cord ; class CharIterator ; private : using CordRep = absl::cord_internal::CordRep ; using CordRepBtree = absl::cord_internal::CordRepBtree ; using CordRepBtreeReader = absl::cord_internal::CordRepBtreeReader ;)",
    "insertText": "ChunkIterator(cord_internal::CordRep* tree)"
  },
  {
    "label": "ChunkIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChunkIterator(const Cord* cord)"
  },
  {
    "label": "InitTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitTree(cord_internal::CordRep* tree)"
  },
  {
    "label": "RemoveChunkPrefix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveChunkPrefix(size_t n)"
  },
  {
    "label": "AdvanceAndReadBytes()",
    "kind": "Method",
    "detail": "Function (Cord)",
    "insertText": "AdvanceAndReadBytes(size_t n)"
  },
  {
    "label": "AdvanceBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AdvanceBytes(size_t n)"
  },
  {
    "label": "AdvanceBtree()",
    "kind": "Method",
    "detail": "Function (ChunkIterator&)",
    "insertText": "AdvanceBtree()"
  },
  {
    "label": "AdvanceBytesBtree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AdvanceBytesBtree(size_t n)"
  },
  {
    "label": "chunk_begin()",
    "kind": "Method",
    "detail": "Function (absl::string_view current_chunk_ ; absl::cord_internal::CordRep* current_leaf_ = nullptr ; size_t bytes_remaining_ = 0 ; CordRepBtreeReader btree_reader_ ; } ; ChunkIterator)",
    "insertText": "chunk_begin()"
  },
  {
    "label": "chunk_end()",
    "kind": "Method",
    "detail": "Function (ChunkIterator)",
    "insertText": "chunk_end()"
  },
  {
    "label": "ChunkRange()",
    "kind": "Method",
    "detail": "Function (class ChunkRange { public : using value_type = absl::string_view ; using reference = value_type& ; using const_reference = const value_type& ; using iterator = ChunkIterator ; using const_iterator = ChunkIterator ;)",
    "insertText": "ChunkRange(const Cord* cord) : cord_(cord)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} ChunkIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (ChunkIterator)",
    "insertText": "end()"
  },
  {
    "label": "Chunks()",
    "kind": "Method",
    "detail": "Function (private : const Cord* cord_ ; } ; ChunkRange)",
    "insertText": "Chunks()"
  },
  {
    "label": "CharIterator()",
    "kind": "Method",
    "detail": "Function (class CharIterator { public : using iterator_category = std::input_iterator_tag ; using value_type = char ; using difference_type = ptrdiff_t ; using pointer = const char* ; using reference = const char& ;)",
    "insertText": "CharIterator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const CharIterator& other)"
  },
  {
    "label": "CharIterator()",
    "kind": "Method",
    "detail": "Function (Cord ; private :)",
    "insertText": "CharIterator(const Cord* cord) : chunk_iterator_(cord)"
  },
  {
    "label": "AdvanceAndRead()",
    "kind": "Method",
    "detail": "Function (} ChunkIterator chunk_iterator_ ; } ; Cord)",
    "insertText": "AdvanceAndRead(CharIterator* it, size_t n_bytes)"
  },
  {
    "label": "Advance()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Advance(CharIterator* it, size_t n_bytes)"
  },
  {
    "label": "ChunkRemaining()",
    "kind": "Method",
    "detail": "Function (absl::string_view)",
    "insertText": "ChunkRemaining(const CharIterator& it)"
  },
  {
    "label": "char_begin()",
    "kind": "Method",
    "detail": "Function (CharIterator)",
    "insertText": "char_begin()"
  },
  {
    "label": "char_end()",
    "kind": "Method",
    "detail": "Function (CharIterator)",
    "insertText": "char_end()"
  },
  {
    "label": "CharRange()",
    "kind": "Method",
    "detail": "Function (class CharRange { public : using value_type = char ; using reference = value_type& ; using const_reference = const value_type& ; using iterator = CharIterator ; using const_iterator = CharIterator ;)",
    "insertText": "CharRange(const Cord* cord) : cord_(cord)"
  },
  {
    "label": "Chars()",
    "kind": "Method",
    "detail": "Function (private : const Cord* cord_ ; } ; CharRange)",
    "insertText": "Chars()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (char)",
    "insertText": "operator(size_t i)"
  },
  {
    "label": "TryFlat()",
    "kind": "Method",
    "detail": "Function (absl::optional<absl::string_view>)",
    "insertText": "TryFlat()"
  },
  {
    "label": "Flatten()",
    "kind": "Method",
    "detail": "Function (absl::string_view)",
    "insertText": "Flatten()"
  },
  {
    "label": "AbslFormatFlush()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AbslFormatFlush(absl::Cord* cord, absl::string_view part)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (cord ->)",
    "insertText": "Append(part)"
  },
  {
    "label": "SetExpectedChecksum()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetExpectedChecksum(uint32_t crc)"
  },
  {
    "label": "ExpectedChecksum()",
    "kind": "Method",
    "detail": "Function (absl::optional<uint32_t>)",
    "insertText": "ExpectedChecksum()"
  },
  {
    "label": "AbslHashValue()",
    "kind": "Method",
    "detail": "Function (template<H> H)",
    "insertText": "AbslHashValue(H hash_state, const absl::Cord& c)"
  },
  {
    "label": "HashFragmented()",
    "kind": "Method",
    "detail": "Function (} return c .)",
    "insertText": "HashFragmented(std::move(hash_state))"
  },
  {
    "label": "Cord()",
    "kind": "Method",
    "detail": "Function (} template<T>)",
    "insertText": "Cord(strings_internal::StringConstant<T>)"
  },
  {
    "label": "Cord()",
    "kind": "Method",
    "detail": "Function (private : using CordRep = absl::cord_internal::CordRep ; using CordRepFlat = absl::cord_internal::CordRepFlat ; using CordzInfo = cord_internal::CordzInfo ; using CordzUpdateScope = cord_internal::CordzUpdateScope ; using CordzUpdateTracker = cord_internal::CordzUpdateTracker ; using InlineData = cord_internal::InlineData ; using MethodIdentifier = CordzUpdateTracker::MethodIdentifier ;)",
    "insertText": "Cord(absl::string_view src, MethodIdentifier method)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (class CordTestPeer ; bool)",
    "insertText": "operator(const Cord& lhs, const Cord& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const Cord& lhs, absl::string_view rhs)"
  },
  {
    "label": "GetCordzInfoForTesting()",
    "kind": "Method",
    "detail": "Function (const CordzInfo*)",
    "insertText": "GetCordzInfoForTesting(const Cord& cord)"
  },
  {
    "label": "ForEachChunk()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForEachChunk(absl::FunctionRef<void(absl::string_view)>)"
  },
  {
    "label": "FlattenSlowPath()",
    "kind": "Method",
    "detail": "Function (absl::string_view)",
    "insertText": "FlattenSlowPath()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (class InlineRep { public : unsigned char kMaxInline = cord_internal::kMaxInline ;)",
    "insertText": "static_assert(kMaxInline >= sizeof(absl::cord_internal::CordRep*), \"\")"
  },
  {
    "label": "InlineRep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InlineRep() : data_()"
  },
  {
    "label": "InlineRep()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "InlineRep(InlineData::DefaultInitType init) : data_(init)"
  },
  {
    "label": "InlineRep()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "InlineRep(const InlineRep& src)"
  },
  {
    "label": "InlineRep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InlineRep(InlineRep&& src)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (InlineRep&)",
    "insertText": "operator(const InlineRep& src)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (InlineRep&)",
    "insertText": "operator(InlineRep&& src)"
  },
  {
    "label": "InlineRep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InlineRep(cord_internal::InlineData data)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(InlineRep* rhs)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "data()"
  },
  {
    "label": "set_data()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_data(const char* data, size_t n)"
  },
  {
    "label": "set_data()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "set_data(size_t n)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (absl::cord_internal::CordRep*)",
    "insertText": "tree()"
  },
  {
    "label": "as_tree()",
    "kind": "Method",
    "detail": "Function (absl::cord_internal::CordRep*)",
    "insertText": "as_tree()"
  },
  {
    "label": "as_chars()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "as_chars()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (absl::cord_internal::CordRep*)",
    "insertText": "clear()"
  },
  {
    "label": "reduce_size()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reduce_size(size_t n)"
  },
  {
    "label": "remove_prefix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove_prefix(size_t n)"
  },
  {
    "label": "AppendArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendArray(absl::string_view src, MethodIdentifier method)"
  },
  {
    "label": "FindFlatStartPiece()",
    "kind": "Method",
    "detail": "Function (absl::string_view)",
    "insertText": "FindFlatStartPiece()"
  },
  {
    "label": "MakeFlatWithExtraCapacity()",
    "kind": "Method",
    "detail": "Function (CordRepFlat*)",
    "insertText": "MakeFlatWithExtraCapacity(size_t extra)"
  },
  {
    "label": "SetTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTree(CordRep* rep, const CordzUpdateScope& scope)"
  },
  {
    "label": "SetTreeOrEmpty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTreeOrEmpty(CordRep* rep, const CordzUpdateScope& scope)"
  },
  {
    "label": "EmplaceTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmplaceTree(CordRep* rep, MethodIdentifier method)"
  },
  {
    "label": "EmplaceTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmplaceTree(CordRep* rep, const InlineData& parent, MethodIdentifier method)"
  },
  {
    "label": "CommitTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CommitTree(const CordRep* old_rep, CordRep* rep, const CordzUpdateScope& scope, MethodIdentifier method)"
  },
  {
    "label": "AppendTreeToInlined()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendTreeToInlined(CordRep* tree, MethodIdentifier method)"
  },
  {
    "label": "AppendTreeToTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendTreeToTree(CordRep* tree, MethodIdentifier method)"
  },
  {
    "label": "AppendTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendTree(CordRep* tree, MethodIdentifier method)"
  },
  {
    "label": "PrependTreeToInlined()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrependTreeToInlined(CordRep* tree, MethodIdentifier method)"
  },
  {
    "label": "PrependTreeToTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrependTreeToTree(CordRep* tree, MethodIdentifier method)"
  },
  {
    "label": "PrependTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrependTree(CordRep* tree, MethodIdentifier method)"
  },
  {
    "label": "IsSame()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSame(const InlineRep& other)"
  },
  {
    "label": "CopyTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CopyTo(std::string* dst)"
  },
  {
    "label": "STLStringResizeUninitialized()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "STLStringResizeUninitialized(dst, kMaxInline)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&(*dst)[0], data_.as_chars(), kMaxInline)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (dst ->)",
    "insertText": "erase(inline_size())"
  },
  {
    "label": "CopyToArray()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CopyToArray(char* dst)"
  },
  {
    "label": "is_tree()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_tree()"
  },
  {
    "label": "is_profiled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_profiled()"
  },
  {
    "label": "remaining_inline_capacity()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "remaining_inline_capacity()"
  },
  {
    "label": "cordz_info()",
    "kind": "Method",
    "detail": "Function (} absl::cord_internal::CordzInfo*)",
    "insertText": "cordz_info()"
  },
  {
    "label": "set_cordz_info()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_cordz_info(cord_internal::CordzInfo* cordz_info)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(cordz_info != nullptr)"
  },
  {
    "label": "set_cordz_info()",
    "kind": "Method",
    "detail": "Function (data_ .)",
    "insertText": "set_cordz_info(cordz_info)"
  },
  {
    "label": "clear_cordz_info()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear_cordz_info()"
  },
  {
    "label": "AssignSlow()",
    "kind": "Method",
    "detail": "Function (} private : class Cord ; void)",
    "insertText": "AssignSlow(const InlineRep& src)"
  },
  {
    "label": "UnrefTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnrefTree()"
  },
  {
    "label": "ResetToEmpty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetToEmpty()"
  },
  {
    "label": "set_inline_size()",
    "kind": "Method",
    "detail": "Function (data_ = { } ; } void)",
    "insertText": "set_inline_size(size_t size)"
  },
  {
    "label": "set_inline_size()",
    "kind": "Method",
    "detail": "Function (data_ .)",
    "insertText": "set_inline_size(size)"
  },
  {
    "label": "inline_size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "inline_size()"
  },
  {
    "label": "MaybeRemoveEmptyCrcNode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MaybeRemoveEmptyCrcNode()"
  },
  {
    "label": "GetFlatAux()",
    "kind": "Method",
    "detail": "Function (cord_internal::InlineData data_ ; } ; InlineRep contents_ ; bool)",
    "insertText": "GetFlatAux(absl::cord_internal::CordRep* rep, absl::string_view* fragment)"
  },
  {
    "label": "ForEachChunkAux()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForEachChunkAux(absl::cord_internal::CordRep* rep, absl::FunctionRef<void(absl::string_view)> callback)"
  },
  {
    "label": "DestroyCordSlow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroyCordSlow()"
  },
  {
    "label": "CopyToArraySlowPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyToArraySlowPath(char* dst)"
  },
  {
    "label": "CompareSlowPath()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "CompareSlowPath(absl::string_view rhs, size_t compared_size, size_t size_to_compare)"
  },
  {
    "label": "CompareSlowPath()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "CompareSlowPath(const Cord& rhs, size_t compared_size, size_t size_to_compare)"
  },
  {
    "label": "EqualsImpl()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EqualsImpl(absl::string_view rhs, size_t size_to_compare)"
  },
  {
    "label": "EqualsImpl()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EqualsImpl(const Cord& rhs, size_t size_to_compare)"
  },
  {
    "label": "CompareImpl()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "CompareImpl(const Cord& rhs)"
  },
  {
    "label": "GenericCompare()",
    "kind": "Method",
    "detail": "Function (template<ResultType,RHS> ResultType)",
    "insertText": "GenericCompare(const Cord& lhs, const RHS& rhs, size_t size_to_compare)"
  },
  {
    "label": "GetFirstChunk()",
    "kind": "Method",
    "detail": "Function (absl::string_view)",
    "insertText": "GetFirstChunk(const Cord& c)"
  },
  {
    "label": "GetFirstChunk()",
    "kind": "Method",
    "detail": "Function (absl::string_view)",
    "insertText": "GetFirstChunk(absl::string_view sv)"
  },
  {
    "label": "TakeRep()",
    "kind": "Method",
    "detail": "Function (absl::cord_internal::CordRep*)",
    "insertText": "TakeRep()"
  },
  {
    "label": "AppendImpl()",
    "kind": "Method",
    "detail": "Function (template<C> void)",
    "insertText": "AppendImpl(C&& src)"
  },
  {
    "label": "AppendPrecise()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendPrecise(absl::string_view src, MethodIdentifier method)"
  },
  {
    "label": "PrependPrecise()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrependPrecise(absl::string_view src, MethodIdentifier method)"
  },
  {
    "label": "GetAppendBufferSlowPath()",
    "kind": "Method",
    "detail": "Function (CordBuffer)",
    "insertText": "GetAppendBufferSlowPath(size_t block_size, size_t capacity, size_t min_capacity)"
  },
  {
    "label": "PrependArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrependArray(absl::string_view src, MethodIdentifier method)"
  },
  {
    "label": "AssignLargeString()",
    "kind": "Method",
    "detail": "Function (Cord&)",
    "insertText": "AssignLargeString(std::string&& src)"
  },
  {
    "label": "HashFragmented()",
    "kind": "Method",
    "detail": "Function (template<H> H)",
    "insertText": "HashFragmented(H hash_state)"
  },
  {
    "label": "ForEachChunk()",
    "kind": "Method",
    "detail": "Function (H::AbslInternalPiecewiseCombiner combiner ;)",
    "insertText": "ForEachChunk([&combiner, &hash_state](absl::string_view chunk) { hash_state = combiner.add_buffer(std::move(hash_state), chunk.data(), chunk.size()); })"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; ABSL_NAMESPACE_END } namespace absl { ABSL_NAMESPACE_BEGIN std::ostream&)",
    "insertText": "operator(std::ostream& out, const Cord& cord)"
  },
  {
    "label": "SmallMemmove()",
    "kind": "Method",
    "detail": "Function (namespace cord_internal { template<bool nullify_tail = false> void)",
    "insertText": "SmallMemmove(char* dst, const char* src, size_t n)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(n <= 15)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (uint64_t buf1 ; uint64_t buf2 ;)",
    "insertText": "memcpy(&buf1, src, 8)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&buf2, src + n - 8, 8)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(dst + 7, 0, 8)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "memcpy(dst, &buf1, 8)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(dst + n - 8, &buf2, 8)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(n >= 4)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (uint32_t buf1 ; uint32_t buf2 ;)",
    "insertText": "memcpy(&buf1, src, 4)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&buf2, src + n - 4, 4)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(dst + 4, 0, 4)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "memcpy(dst, &buf1, 4)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(dst + n - 4, &buf2, 4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(n != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dst [ 0 ] = src [ 0 ] ; dst [ n / 2 ] = src [ n / 2 ] ; dst [ n - 1 ] = src [ n - 1 ] ; })",
    "insertText": "if(nullify_tail)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(dst + n, 0, 8)"
  },
  {
    "label": "InitializeCordRepExternal()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "InitializeCordRepExternal(absl::string_view data, CordRepExternal* rep)"
  },
  {
    "label": "NewExternalRep()",
    "kind": "Method",
    "detail": "Function (template<Releaser> CordRep*)",
    "insertText": "NewExternalRep(absl::string_view data, Releaser&& releaser)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!data.empty())"
  },
  {
    "label": "ReleaserType()",
    "kind": "Method",
    "detail": "Function (using ReleaserType = absl::decay_t<Releaser> ; CordRepExternal* rep = new CordRepExternalImpl<)",
    "insertText": "ReleaserType(std::forward<Releaser>(releaser), 0)"
  },
  {
    "label": "InitializeCordRepExternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeCordRepExternal(data, rep)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Cord cord ;)",
    "insertText": "if(ABSL_PREDICT_TRUE(!data.empty()))"
  },
  {
    "label": "EmplaceTree()",
    "kind": "Method",
    "detail": "Function (cord . contents_ .)",
    "insertText": "EmplaceTree(::absl::cord_internal::NewExternalRep( data, std::forward<Releaser>(releaser)), Cord::MethodIdentifier::kMakeCordFromExternal)"
  },
  {
    "label": "InvokeReleaser()",
    "kind": "Method",
    "detail": "Function (} else { using ReleaserType = absl::decay_t<Releaser> ;)",
    "insertText": "InvokeReleaser(cord_internal::Rank0{}, ReleaserType(std::forward<Releaser>(releaser)), data)"
  },
  {
    "label": "InlineRep()",
    "kind": "Method",
    "detail": "Function (} return cord ; } Cord::)",
    "insertText": "InlineRep(cord_internal::InlineData data) : data_(data)"
  },
  {
    "label": "InlineRep()",
    "kind": "Method",
    "detail": "Function (} Cord::)",
    "insertText": "InlineRep(const Cord::InlineRep& src) : data_(InlineData::kDefaultInit)"
  },
  {
    "label": "EmplaceTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmplaceTree(CordRep::Ref(tree), src.data_, CordzUpdateTracker::kConstructorCord)"
  },
  {
    "label": "InlineRep()",
    "kind": "Method",
    "detail": "Function (} else { data_ = src . data_ ; } } Cord::)",
    "insertText": "InlineRep(Cord::InlineRep&& src) : data_(src.data_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Cord::InlineRep& Cord::)",
    "insertText": "operator(const Cord::InlineRep& src)"
  },
  {
    "label": "AssignSlow()",
    "kind": "Method",
    "detail": "Function (data_ = src . data_ ; return* this ; })",
    "insertText": "AssignSlow(src)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!data_.is_tree())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(data_.is_tree())"
  },
  {
    "label": "New()",
    "kind": "Method",
    "detail": "Function (auto* result =)",
    "insertText": "New(len + extra)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (result -> length = len ;)",
    "insertText": "memcpy(result->Data(), data_.as_chars(), InlineRep::kMaxInline)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(rep)"
  },
  {
    "label": "make_tree()",
    "kind": "Method",
    "detail": "Function (data_ .)",
    "insertText": "make_tree(rep)"
  },
  {
    "label": "MaybeTrackCord()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeTrackCord(data_, method)"
  },
  {
    "label": "MaybeTrackCord()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeTrackCord(data_, parent, method)"
  },
  {
    "label": "set_tree()",
    "kind": "Method",
    "detail": "Function (data_ .)",
    "insertText": "set_tree(rep)"
  },
  {
    "label": "SetCordRep()",
    "kind": "Method",
    "detail": "Function (scope .)",
    "insertText": "SetCordRep(rep)"
  },
  {
    "label": "SetTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTree(rep, scope)"
  },
  {
    "label": "EmplaceTree()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "EmplaceTree(rep, method)"
  },
  {
    "label": "MaybeUntrackCord()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeUntrackCord(cordz_info())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!is_tree())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(n != 0)"
  },
  {
    "label": "SmallMemmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SmallMemmove(dst, data_.as_chars(), n)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(rep->crc()->child == nullptr)"
  },
  {
    "label": "Unref()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unref(rep)"
  },
  {
    "label": "Cord()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Cord(absl::string_view src) : Cord(src, CordzUpdateTracker::kConstructorString)"
  },
  {
    "label": "Cord()",
    "kind": "Method",
    "detail": "Function (} template<T>)",
    "insertText": "Cord(strings_internal::StringConstant<T>) : contents_(strings_internal::StringConstant<T>::value.size() <= cord_internal::kMaxInline ? cord_internal::InlineData( strings_internal::StringConstant<T>::value) : cord_internal::InlineData( &cord_internal::ConstInitExternalStorage< strings_internal::StringConstant<T>>::value))"
  },
  {
    "label": "AssignLargeString()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "AssignLargeString(std::forward<T>(src))"
  },
  {
    "label": "Cord()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "Cord(const Cord& src) : contents_(src.contents_)"
  },
  {
    "label": "Cord()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Cord(Cord&& src) noexcept : contents_(std::move(src.contents_))"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (contents_ .)",
    "insertText": "Swap(&other.contents_)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (contents_ =)",
    "insertText": "move(x.contents_)"
  },
  {
    "label": "EstimatedMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "EstimatedMemoryUsage(CordMemoryAccounting accounting_method)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (size_t result =)",
    "insertText": "sizeof(Cord)"
  },
  {
    "label": "GetEstimatedFairShareMemoryUsage()",
    "kind": "Method",
    "detail": "Function (result + =)",
    "insertText": "GetEstimatedFairShareMemoryUsage(rep)"
  },
  {
    "label": "GetEstimatedMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} else { result + =)",
    "insertText": "GetEstimatedMemoryUsage(rep)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} absl::string_view fragment ;)",
    "insertText": "if(GetFlatAux(rep, &fragment))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { absl::string_view already_flat_contents ;)",
    "insertText": "if(GetFlatAux(rep, &already_flat_contents))"
  },
  {
    "label": "AppendArray()",
    "kind": "Method",
    "detail": "Function (contents_ .)",
    "insertText": "AppendArray(src, CordzUpdateTracker::kAppendString)"
  },
  {
    "label": "PrependArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrependArray(src, CordzUpdateTracker::kPrependString)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (absl::string_view short_value ;)",
    "insertText": "if(CordRep* rep = buffer.ConsumeValue(short_value))"
  },
  {
    "label": "AppendTree()",
    "kind": "Method",
    "detail": "Function (contents_ .)",
    "insertText": "AppendTree(rep, CordzUpdateTracker::kAppendCordBuffer)"
  },
  {
    "label": "AppendPrecise()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "AppendPrecise(short_value, CordzUpdateTracker::kAppendCordBuffer)"
  },
  {
    "label": "PrependTree()",
    "kind": "Method",
    "detail": "Function (contents_ .)",
    "insertText": "PrependTree(rep, CordzUpdateTracker::kPrependCordBuffer)"
  },
  {
    "label": "PrependPrecise()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "PrependPrecise(short_value, CordzUpdateTracker::kPrependCordBuffer)"
  },
  {
    "label": "GetAppendBuffer()",
    "kind": "Method",
    "detail": "Function (} } CordBuffer)",
    "insertText": "GetAppendBuffer(size_t capacity, size_t min_capacity)"
  },
  {
    "label": "GetCustomAppendBuffer()",
    "kind": "Method",
    "detail": "Function (} CordBuffer)",
    "insertText": "GetCustomAppendBuffer(size_t block_size, size_t capacity, size_t min_capacity)"
  },
  {
    "label": "GetAppendBufferSlowPath()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "GetAppendBufferSlowPath(block_size, capacity, min_capacity)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (} template void)",
    "insertText": "Append(std::string&& src)"
  },
  {
    "label": "Prepend()",
    "kind": "Method",
    "detail": "Function (template void)",
    "insertText": "Prepend(std::string&& src)"
  },
  {
    "label": "CompareImpl()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "CompareImpl(rhs)"
  },
  {
    "label": "SkipCrcNode()",
    "kind": "Method",
    "detail": "Function (tree =)",
    "insertText": "SkipCrcNode(tree)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (current_chunk_ = btree_reader_ .)",
    "insertText": "Init(tree->btree())"
  },
  {
    "label": "EdgeData()",
    "kind": "Method",
    "detail": "Function (} else { current_leaf_ = tree ; current_chunk_ =)",
    "insertText": "EdgeData(tree)"
  },
  {
    "label": "InitTree()",
    "kind": "Method",
    "detail": "Function (bytes_remaining_ = tree -> length ;)",
    "insertText": "InitTree(tree)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bytes_remaining_ = tree -> length ;)",
    "insertText": "if(ABSL_PREDICT_TRUE(bytes_remaining_ != 0))"
  },
  {
    "label": "Next()",
    "kind": "Method",
    "detail": "Function (current_chunk_ = btree_reader_ .)",
    "insertText": "Next()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(n >= current_chunk_.size())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bytes_remaining_ - = n ;)",
    "insertText": "if(bytes_remaining_)"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (} else { size_t offset = btree_reader_ .)",
    "insertText": "length()"
  },
  {
    "label": "Seek()",
    "kind": "Method",
    "detail": "Function (current_chunk_ = btree_reader_ .)",
    "insertText": "Seek(offset)"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(bytes_remaining_ > 0 && \"Attempted to iterate past `end()`\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(bytes_remaining_ >= current_chunk_.size())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "assert(!current_chunk_.empty())"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (ChunkIterator)",
    "insertText": "tmp(*this)"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(bytes_remaining_ != 0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(n < current_chunk_.size())"
  },
  {
    "label": "remove_prefix()",
    "kind": "Method",
    "detail": "Function (current_chunk_ .)",
    "insertText": "remove_prefix(n)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(bytes_remaining_ >= n)"
  },
  {
    "label": "RemoveChunkPrefix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveChunkPrefix(n)"
  },
  {
    "label": "AdvanceBytesBtree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AdvanceBytesBtree(n)"
  },
  {
    "label": "RemoveChunkPrefix()",
    "kind": "Method",
    "detail": "Function (chunk_iterator_ .)",
    "insertText": "RemoveChunkPrefix(1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(it != nullptr)"
  },
  {
    "label": "AdvanceBytes()",
    "kind": "Method",
    "detail": "Function (it -> chunk_iterator_ .)",
    "insertText": "AdvanceBytes(n_bytes)"
  },
  {
    "label": "ForEachChunk()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ForEachChunk(absl::FunctionRef<void(absl::string_view)> callback)"
  },
  {
    "label": "callback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "callback(absl::string_view(contents_.data(), contents_.size()))"
  },
  {
    "label": "ForEachChunkAux()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "ForEachChunkAux(rep, callback)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const Cord& x, const Cord& y)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(absl::string_view x, const Cord& y)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const Cord& x, absl::string_view y)"
  },
  {
    "label": "FlatOverhead()",
    "kind": "Method",
    "detail": "Function (} namespace strings_internal { class CordTestAccess { public : size_t)",
    "insertText": "FlatOverhead()"
  },
  {
    "label": "MaxFlatLength()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "MaxFlatLength()"
  },
  {
    "label": "SizeofCordRepExternal()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "SizeofCordRepExternal()"
  },
  {
    "label": "SizeofCordRepSubstring()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "SizeofCordRepSubstring()"
  },
  {
    "label": "FlatTagToLength()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "FlatTagToLength(uint8_t tag)"
  },
  {
    "label": "LengthToTag()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "LengthToTag(size_t s)"
  }
]