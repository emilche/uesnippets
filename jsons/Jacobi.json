[
  {
    "label": "JacobiRotation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "JacobiRotation"
  },
  {
    "label": "apply_rotation_in_the_plane_selector",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "apply_rotation_in_the_plane_selector"
  },
  {
    "label": "JacobiRotation()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_JACOBI_H # define EIGEN_JACOBI_H namespace Eigen { template<Scalar> class JacobiRotation { public : typedef NumTraits<Scalar>::Real RealScalar ; EIGEN_DEVICE_FUNC)",
    "insertText": "JacobiRotation()"
  },
  {
    "label": "JacobiRotation()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC Scalar&)",
    "insertText": "c()"
  },
  {
    "label": "JacobiRotation()",
    "kind": "Method",
    "detail": "Function (using numext::conj ; return)",
    "insertText": "JacobiRotation(m_c * other.m_c - conj(m_s) * other.m_s, conj(m_c * conj(other.m_s) + conj(m_s) * conj(other.m_c)))"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC JacobiRotation)",
    "insertText": "transpose()"
  },
  {
    "label": "JacobiRotation()",
    "kind": "Method",
    "detail": "Function (using numext::conj ; return)",
    "insertText": "JacobiRotation(m_c, -conj(m_s))"
  },
  {
    "label": "adjoint()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC JacobiRotation)",
    "insertText": "adjoint()"
  },
  {
    "label": "JacobiRotation()",
    "kind": "Method",
    "detail": "Function (using numext::conj ; return)",
    "insertText": "JacobiRotation(conj(m_c), -m_s)"
  },
  {
    "label": "makeJacobi()",
    "kind": "Method",
    "detail": "Function (} template<Derived> EIGEN_DEVICE_FUNC bool)",
    "insertText": "makeJacobi(const MatrixBase<Derived>&, Index p, Index q)"
  },
  {
    "label": "makeJacobi()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC bool)",
    "insertText": "makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z)"
  },
  {
    "label": "makeGivens()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC void)",
    "insertText": "makeGivens(const Scalar& p, const Scalar& q, Scalar* r=0)"
  },
  {
    "label": "makeGivens()",
    "kind": "Method",
    "detail": "Function (protected : EIGEN_DEVICE_FUNC void)",
    "insertText": "makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)"
  },
  {
    "label": "makeGivens()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC void)",
    "insertText": "makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (using std::sqrt ; using std::abs ; RealScalar deno =)",
    "insertText": "RealScalar(2)*abs(y)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (m_c =)",
    "insertText": "Scalar(1)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (m_s =)",
    "insertText": "Scalar(0)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (RealScalar w =)",
    "insertText": "sqrt(numext::abs2(tau) + RealScalar(1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RealScalar t ;)",
    "insertText": "if(tau>RealScalar(0))"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (t =)",
    "insertText": "RealScalar(1) / (tau + w)"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (} else { t =)",
    "insertText": "RealScalar(1) / (tau - w)"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (} RealScalar sign_t = t>)",
    "insertText": "RealScalar(0) ? RealScalar(1) : RealScalar(-1)"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (RealScalar n =)",
    "insertText": "RealScalar(1) / sqrt(numext::abs2(t)+RealScalar(1))"
  },
  {
    "label": "sign_t()",
    "kind": "Method",
    "detail": "Function (m_s = -)",
    "insertText": "sign_t(numext::conj(y) / abs(y)) * abs(t)"
  },
  {
    "label": "makeJacobi()",
    "kind": "Method",
    "detail": "Function (m_c = n ; return true ; } } template<Scalar> template<Derived> EIGEN_DEVICE_FUNC bool JacobiRotation<Scalar)",
    "insertText": "makeJacobi(const MatrixBase<Derived>& m, Index p, Index q)"
  },
  {
    "label": "makeGivens()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> EIGEN_DEVICE_FUNC void JacobiRotation<Scalar)",
    "insertText": "makeGivens(const Scalar& p, const Scalar& q, Scalar* r)"
  },
  {
    "label": "makeGivens()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "makeGivens(p, q, r, typename internal::conditional<NumTraits<Scalar>::IsComplex, internal::true_type, internal::false_type>::type())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using std::sqrt ; using std::abs ; using numext::conj ;)",
    "insertText": "if(q==Scalar(0))"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (m_c =)",
    "insertText": "real(p)<0 ? Scalar(-1) : Scalar(1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_s = 0 ;)",
    "insertText": "if(r)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(p==Scalar(0))"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (m_c = 0 ; m_s = - q /)",
    "insertText": "abs(q)"
  },
  {
    "label": "norm1()",
    "kind": "Method",
    "detail": "Function (} else { RealScalar p1 =)",
    "insertText": "norm1(p)"
  },
  {
    "label": "norm1()",
    "kind": "Method",
    "detail": "Function (RealScalar q1 =)",
    "insertText": "norm1(q)"
  },
  {
    "label": "abs2()",
    "kind": "Method",
    "detail": "Function (Scalar ps = p / p1 ; RealScalar p2 =)",
    "insertText": "abs2(ps)"
  },
  {
    "label": "abs2()",
    "kind": "Method",
    "detail": "Function (Scalar qs = q / p1 ; RealScalar q2 =)",
    "insertText": "abs2(qs)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (RealScalar u =)",
    "insertText": "sqrt(RealScalar(1) + q2/p2)"
  },
  {
    "label": "conj()",
    "kind": "Method",
    "detail": "Function (m_s = - qs*)",
    "insertText": "conj(ps)*(m_c/p2)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (RealScalar u = q1*)",
    "insertText": "sqrt(p2 + q2)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (p1 =)",
    "insertText": "abs(p)"
  },
  {
    "label": "conj()",
    "kind": "Method",
    "detail": "Function (ps = p / p1 ; m_c = p1 / u ; m_s = -)",
    "insertText": "conj(ps) * (q/u)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (m_c = p<)",
    "insertText": "Scalar(0) ? Scalar(-1) : Scalar(1)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (m_s = q<)",
    "insertText": "Scalar(0) ? Scalar(1) : Scalar(-1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(abs(p) > abs(q))"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (Scalar t = q / p ; Scalar u =)",
    "insertText": "sqrt(Scalar(1) + numext::abs2(t))"
  },
  {
    "label": "apply_rotation_in_the_plane()",
    "kind": "Method",
    "detail": "Function (} } namespace internal { template<VectorX,VectorY,OtherScalar> EIGEN_DEVICE_FUNC void)",
    "insertText": "apply_rotation_in_the_plane(DenseBase<VectorX>& xpr_x, DenseBase<VectorY>& xpr_y, const JacobiRotation<OtherScalar>& j)"
  },
  {
    "label": "applyOnTheLeft()",
    "kind": "Method",
    "detail": "Function (} template<Derived> template<OtherScalar> EIGEN_DEVICE_FUNC void MatrixBase<Derived)",
    "insertText": "applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (RowXpr)",
    "insertText": "x(this->row(p))"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (RowXpr)",
    "insertText": "y(this->row(q))"
  },
  {
    "label": "apply_rotation_in_the_plane()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "apply_rotation_in_the_plane(x, y, j)"
  },
  {
    "label": "applyOnTheRight()",
    "kind": "Method",
    "detail": "Function (} template<Derived> template<OtherScalar> EIGEN_DEVICE_FUNC void MatrixBase<Derived)",
    "insertText": "applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (ColXpr)",
    "insertText": "x(this->col(p))"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (ColXpr)",
    "insertText": "y(this->col(q))"
  },
  {
    "label": "apply_rotation_in_the_plane()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "apply_rotation_in_the_plane(x, y, j.transpose())"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} namespace internal { template<Scalar,OtherScalar,int SizeAtCompileTime,int MinAlignment,bool Vectorizable> struct apply_rotation_in_the_plane_selector { EIGEN_DEVICE_FUNC void)",
    "insertText": "run(Scalar *x, Index incrx, Scalar *y, Index incry, Index size, OtherScalar c, OtherScalar s)"
  },
  {
    "label": "conj()",
    "kind": "Method",
    "detail": "Function (Scalar xi =* x ; Scalar yi =* y ;* x = c* xi +)",
    "insertText": "conj(s)"
  },
  {
    "label": "conj()",
    "kind": "Method",
    "detail": "Function (* y = - s* xi +)",
    "insertText": "conj(c)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (enum { PacketSize = packet_traits<Scalar>::size,OtherPacketSize = packet_traits<OtherScalar>::size } ; typedef packet_traits<Scalar>::type Packet ; typedef packet_traits<OtherScalar>::type OtherPacket ;)",
    "insertText": "if(SizeAtCompileTime == Dynamic && ((incrx==1 && incry==1) || PacketSize == 1))"
  },
  {
    "label": "first_default_aligned()",
    "kind": "Method",
    "detail": "Function (enum { Peeling = 2 } ; Index alignedStart =)",
    "insertText": "first_default_aligned(y, size)"
  },
  {
    "label": "alignedStart()",
    "kind": "Method",
    "detail": "Function (Index alignedEnd =)",
    "insertText": "alignedStart((size-alignedStart)/PacketSize)"
  },
  {
    "label": "OtherPacket()",
    "kind": "Method",
    "detail": "Function (const OtherPacket pc = pset1<)",
    "insertText": "OtherPacket(c)"
  },
  {
    "label": "OtherPacket()",
    "kind": "Method",
    "detail": "Function (const OtherPacket ps = pset1<)",
    "insertText": "OtherPacket(s)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (conj_helper<OtherPacket,Packet,NumTraits<OtherScalar>::IsComplex,false> pcj ; conj_helper<OtherPacket,Packet,false,false> pm ;)",
    "insertText": "for(Index i=0; i<alignedStart; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} Scalar* EIGEN_RESTRICT px = x + alignedStart ; Scalar* EIGEN_RESTRICT py = y + alignedStart ;)",
    "insertText": "if(internal::first_default_aligned(x, size)==alignedStart)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet xi = pload<)",
    "insertText": "Packet(px)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet yi = pload<)",
    "insertText": "Packet(py)"
  },
  {
    "label": "pstore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstore(px, padd(pm.pmul(pc,xi),pcj.pmul(ps,yi)))"
  },
  {
    "label": "pstore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstore(py, psub(pcj.pmul(pc,yi),pm.pmul(ps,xi)))"
  },
  {
    "label": "alignedStart()",
    "kind": "Method",
    "detail": "Function (px + = PacketSize ; py + = PacketSize ; } } else { Index peelingEnd =)",
    "insertText": "alignedStart((size-alignedStart)/(Peeling*PacketSize))*(Peeling*PacketSize)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet xi1 = ploadu<)",
    "insertText": "Packet(px+PacketSize)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet yi1 = pload<)",
    "insertText": "Packet(py+PacketSize)"
  },
  {
    "label": "pstoreu()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstoreu(px, padd(pm.pmul(pc,xi),pcj.pmul(ps,yi)))"
  },
  {
    "label": "pstoreu()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstoreu(px+PacketSize, padd(pm.pmul(pc,xi1),pcj.pmul(ps,yi1)))"
  },
  {
    "label": "pstore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstore(py+PacketSize, psub(pcj.pmul(pc,yi1),pm.pmul(ps,xi1)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (px + = Peeling* PacketSize ; py + = Peeling* PacketSize ; })",
    "insertText": "if(alignedEnd!=peelingEnd)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet xi = ploadu<)",
    "insertText": "Packet(x+peelingEnd)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet yi = pload<)",
    "insertText": "Packet(y+peelingEnd)"
  },
  {
    "label": "pstoreu()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstoreu(x+peelingEnd, padd(pm.pmul(pc,xi),pcj.pmul(ps,yi)))"
  },
  {
    "label": "pstore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstore(y+peelingEnd, psub(pcj.pmul(pc,yi),pm.pmul(ps,xi)))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(Index i=alignedEnd; i<size; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(SizeAtCompileTime != Dynamic && MinAlignment>0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (conj_helper<OtherPacket,Packet,NumTraits<OtherPacket>::IsComplex,false> pcj ; conj_helper<OtherPacket,Packet,false,false> pm ; Scalar* EIGEN_RESTRICT px = x ; Scalar* EIGEN_RESTRICT py = y ;)",
    "insertText": "for(Index i=0; i<size; i+=PacketSize)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (px + = PacketSize ; py + = PacketSize ; } } else { apply_rotation_in_the_plane_selector<Scalar,OtherScalar,SizeAtCompileTime,MinAlignment,false)",
    "insertText": "run(x,incrx,y,incry,size,c,s)"
  },
  {
    "label": "Vectorizable()",
    "kind": "Method",
    "detail": "Function (typedef VectorX::Scalar Scalar ; const bool)",
    "insertText": "Vectorizable(int(VectorX::Flags) & int(VectorY::Flags) & PacketAccessBit) && (int(packet_traits<Scalar>::size) == int(packet_traits<OtherScalar>::size))"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(xpr_x.size() == xpr_y.size())"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (Index size = xpr_x .)",
    "insertText": "size()"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (Index incrx = xpr_x .)",
    "insertText": "derived().innerStride()"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (Scalar* EIGEN_RESTRICT x =& xpr_x .)",
    "insertText": "derived().coeffRef(0)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (OtherScalar s = j .)",
    "insertText": "s()"
  },
  {
    "label": "EIGEN_PLAIN_ENUM_MIN()",
    "kind": "Method",
    "detail": "Function (apply_rotation_in_the_plane_selector<Scalar,OtherScalar,VectorX::SizeAtCompileTime,)",
    "insertText": "EIGEN_PLAIN_ENUM_MIN(evaluator<VectorX>::Alignment, evaluator<VectorY>::Alignment), Vectorizable>::run(x,incrx,y,incry,size,c,s)"
  }
]