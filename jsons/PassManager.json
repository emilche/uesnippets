[
  {
    "label": "Module",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Module"
  },
  {
    "label": "Function",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Function"
  },
  {
    "label": "PreservedAnalyses",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PreservedAnalyses"
  },
  {
    "label": "AnalysisManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AnalysisManager"
  },
  {
    "label": "PassManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PassManager"
  },
  {
    "label": "AnalysisManagerBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AnalysisManagerBase"
  },
  {
    "label": "detail",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "detail"
  },
  {
    "label": "FunctionAnalysisManagerModuleProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FunctionAnalysisManagerModuleProxy"
  },
  {
    "label": "Result",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Result"
  },
  {
    "label": "ModuleAnalysisManagerFunctionProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ModuleAnalysisManagerFunctionProxy"
  },
  {
    "label": "ModuleToFunctionPassAdaptor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ModuleToFunctionPassAdaptor"
  },
  {
    "label": "RequireAnalysisPass",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RequireAnalysisPass"
  },
  {
    "label": "InvalidateAnalysisPass",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InvalidateAnalysisPass"
  },
  {
    "label": "InvalidateAllAnalysesPass",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InvalidateAllAnalysesPass"
  },
  {
    "label": "PreservedAnalyses()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_IR_PASSMANAGER_H # define LLVM_IR_PASSMANAGER_H # include \" llvm / ADT / DenseMap . h \" # include \" llvm / ADT / STLExtras . h \" # include \" llvm / ADT / SmallPtrSet . h \" # include \" llvm / IR / Function . h \" # include \" llvm / IR / Module . h \" # include \" llvm / IR / PassManagerInternal . h \" # include \" llvm / Support / CommandLine . h \" # include \" llvm / Support / Debug . h \" # include \" llvm / Support / raw_ostream . h \" # include \" llvm / Support / type_traits . h \" # include<list> # include<memory> # include<vector> namespace llvm { class Module ; class Function ; class PreservedAnalyses { public :)",
    "insertText": "PreservedAnalyses()"
  },
  {
    "label": "PreservedAnalyses()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PreservedAnalyses(const PreservedAnalyses &Arg) : PreservedPassIDs(Arg.PreservedPassIDs)"
  },
  {
    "label": "PreservedAnalyses()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PreservedAnalyses(PreservedAnalyses &&Arg) : PreservedPassIDs(std::move(Arg.PreservedPassIDs))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(PreservedAnalyses &LHS, PreservedAnalyses &RHS)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "swap(LHS.PreservedPassIDs, RHS.PreservedPassIDs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} PreservedAnalyses&)",
    "insertText": "operator(PreservedAnalyses RHS)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(*this, RHS)"
  },
  {
    "label": "all()",
    "kind": "Method",
    "detail": "Function (} PreservedAnalyses)",
    "insertText": "all()"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (PreservedAnalyses PA ; PA . PreservedPassIDs .)",
    "insertText": "insert((void *)AllPassesID)"
  },
  {
    "label": "preserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "preserve(PassT::ID())"
  },
  {
    "label": "preserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "preserve(void *PassID)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "intersect(const PreservedAnalyses &Arg)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (PreservedPassIDs = Arg . PreservedPassIDs ; return ; })",
    "insertText": "for(void *P : PreservedPassIDs) if (!Arg.PreservedPassIDs.count(P)) PreservedPassIDs.erase(P)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "intersect(PreservedAnalyses &&Arg)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (PreservedPassIDs =)",
    "insertText": "move(Arg.PreservedPassIDs)"
  },
  {
    "label": "preserved()",
    "kind": "Method",
    "detail": "Function (} template<PassT> bool)",
    "insertText": "preserved()"
  },
  {
    "label": "preserved()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "preserved(void *PassID)"
  },
  {
    "label": "areAllPreserved()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "areAllPreserved()"
  },
  {
    "label": "AllPassesID()",
    "kind": "Method",
    "detail": "Function (} private : const uintptr_t)",
    "insertText": "AllPassesID(intptr_t)(-3)"
  },
  {
    "label": "PassManager()",
    "kind": "Method",
    "detail": "Function (SmallPtrSet<void*,2> PreservedPassIDs ; } ; template<IRUnitT> class AnalysisManager ; template<IRUnitT> class PassManager { public :)",
    "insertText": "PassManager(bool DebugLogging = false) : DebugLogging(DebugLogging)"
  },
  {
    "label": "PassManager()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PassManager(PassManager &&Arg) : Passes(std::move(Arg.Passes)), DebugLogging(std::move(Arg.DebugLogging))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} PassManager&)",
    "insertText": "operator(PassManager &&RHS)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (Passes =)",
    "insertText": "move(RHS.Passes)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (DebugLogging =)",
    "insertText": "move(RHS.DebugLogging)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (PreservedAnalyses PassPA = Passes [ Idx ] ->)",
    "insertText": "run(IR, AM)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (PA .)",
    "insertText": "intersect(std::move(PassPA))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(DebugLogging) dbgs()"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (typedef detail::PassModel<IRUnitT,PassT> PassModelT ; Passes .)",
    "insertText": "emplace_back(new PassModelT(std::move(Pass)))"
  },
  {
    "label": "name()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "name()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (PassManager&)",
    "insertText": "operator(const PassManager &)"
  },
  {
    "label": "derived_this()",
    "kind": "Method",
    "detail": "Function (std::vector<std::unique_ptr<PassConceptT>> Passes ; bool DebugLogging ; } ; typedef PassManager<Module> ModulePassManager ; typedef PassManager<Function> FunctionPassManager ; namespace detail { template<DerivedT,IRUnitT> class AnalysisManagerBase { DerivedT*)",
    "insertText": "derived_this()"
  },
  {
    "label": "AnalysisManagerBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AnalysisManagerBase(const AnalysisManagerBase &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (AnalysisManagerBase&)",
    "insertText": "operator(const AnalysisManagerBase &)"
  },
  {
    "label": "AnalysisManagerBase()",
    "kind": "Method",
    "detail": "Function (protected : typedef detail::AnalysisResultConcept<IRUnitT> ResultConceptT ; typedef detail::AnalysisPassConcept<IRUnitT> PassConceptT ;)",
    "insertText": "AnalysisManagerBase()"
  },
  {
    "label": "AnalysisManagerBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AnalysisManagerBase(AnalysisManagerBase &&Arg) : AnalysisPasses(std::move(Arg.AnalysisPasses))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} AnalysisManagerBase&)",
    "insertText": "operator(AnalysisManagerBase &&RHS)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (AnalysisPasses =)",
    "insertText": "move(RHS.AnalysisPasses)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(AnalysisPasses.count(PassT::ID()) && \"This analysis pass was not registered prior to being queried\")"
  },
  {
    "label": "derived_this()",
    "kind": "Method",
    "detail": "Function (ResultConceptT& ResultConcept =)",
    "insertText": "derived_this()->getResultImpl(PassT::ID(), IR)"
  },
  {
    "label": "ResultModelT()",
    "kind": "Method",
    "detail": "Function (typedef detail::AnalysisResultModel<IRUnitT,PassT,PassT::Result> ResultModelT ; return static_cast<)",
    "insertText": "ResultModelT(ResultConcept)"
  },
  {
    "label": "getCachedResult()",
    "kind": "Method",
    "detail": "Function (} template<PassT> PassT::Result*)",
    "insertText": "getCachedResult(IRUnitT &IR)"
  },
  {
    "label": "derived_this()",
    "kind": "Method",
    "detail": "Function (ResultConceptT* ResultConcept =)",
    "insertText": "derived_this()->getCachedResultImpl(PassT::ID(), IR)"
  },
  {
    "label": "registerPass()",
    "kind": "Method",
    "detail": "Function (} template<PassT> void)",
    "insertText": "registerPass(PassT Pass)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!AnalysisPasses.count(PassT::ID()) && \"Registered the same analysis pass twice!\")"
  },
  {
    "label": "ID()",
    "kind": "Method",
    "detail": "Function (typedef detail::AnalysisPassModel<IRUnitT,PassT> PassModelT ; AnalysisPasses [)",
    "insertText": "ID()].reset(new PassModelT(std::move(Pass)))"
  },
  {
    "label": "invalidate()",
    "kind": "Method",
    "detail": "Function (} template<PassT> void)",
    "insertText": "invalidate(IRUnitT &IR)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(AnalysisPasses.count(PassT::ID()) && \"This analysis pass was not registered prior to being invalidated\")"
  },
  {
    "label": "derived_this()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "derived_this()->invalidateImpl(PassT::ID(), IR)"
  },
  {
    "label": "invalidate()",
    "kind": "Method",
    "detail": "Function (} PreservedAnalyses)",
    "insertText": "invalidate(IRUnitT &IR, PreservedAnalyses PA)"
  },
  {
    "label": "lookupPass()",
    "kind": "Method",
    "detail": "Function (} protected : PassConceptT&)",
    "insertText": "lookupPass(void *PassID)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (AnalysisPassMapT::iterator PI = AnalysisPasses .)",
    "insertText": "find(PassID)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(PI != AnalysisPasses.end() && \"Analysis passes must be registered prior to being queried!\")"
  },
  {
    "label": "AnalysisManager()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AnalysisManager(AnalysisManager &&Arg) : BaseT(std::move(static_cast<BaseT &>(Arg))), AnalysisResults(std::move(Arg.AnalysisResults)), DebugLogging(std::move(Arg.DebugLogging))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} AnalysisManager&)",
    "insertText": "operator(AnalysisManager &&RHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(std::move(static_cast<BaseT &>(RHS)))"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (AnalysisResults =)",
    "insertText": "move(RHS.AnalysisResults)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(AnalysisResults.empty() == AnalysisResultLists.empty() && \"The storage and index of analysis results disagree on how many \" \"there are!\")"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear()"
  },
  {
    "label": "AnalysisManager()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "AnalysisManager(const AnalysisManager &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (AnalysisManager&)",
    "insertText": "operator(const AnalysisManager &)"
  },
  {
    "label": "getResultImpl()",
    "kind": "Method",
    "detail": "Function (ResultConceptT&)",
    "insertText": "getResultImpl(void *PassID, IRUnitT &IR)"
  },
  {
    "label": "tie()",
    "kind": "Method",
    "detail": "Function (AnalysisResultMapT::iterator RI ; bool Inserted ;)",
    "insertText": "tie(RI, Inserted) = AnalysisResults.insert(std::make_pair( std::make_pair(PassID, &IR), typename AnalysisResultListT::iterator()))"
  },
  {
    "label": "lookupPass()",
    "kind": "Method",
    "detail": "Function (auto& P = this ->)",
    "insertText": "lookupPass(PassID)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (AnalysisResultListT& ResultList = AnalysisResultLists [& IR ] ; ResultList .)",
    "insertText": "emplace_back(PassID, P.run(IR, this))"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (RI = AnalysisResults .)",
    "insertText": "find(std::make_pair(PassID, &IR))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(RI != AnalysisResults.end() && \"we just inserted it!\")"
  },
  {
    "label": "prev()",
    "kind": "Method",
    "detail": "Function (RI -> second =)",
    "insertText": "prev(ResultList.end())"
  },
  {
    "label": "getCachedResultImpl()",
    "kind": "Method",
    "detail": "Function (} return* RI -> second -> second ; } ResultConceptT*)",
    "insertText": "getCachedResultImpl(void *PassID, IRUnitT &IR)"
  },
  {
    "label": "invalidateImpl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "invalidateImpl(void *PassID, IRUnitT &IR)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (AnalysisResultLists [& IR ] .)",
    "insertText": "erase(RI->second)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (AnalysisResults .)",
    "insertText": "erase(RI)"
  },
  {
    "label": "invalidateImpl()",
    "kind": "Method",
    "detail": "Function (} PreservedAnalyses)",
    "insertText": "invalidateImpl(IRUnitT &IR, PreservedAnalyses PA)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (SmallVector<void*,8> InvalidatedPassIDs ; AnalysisResultListT& ResultsList = AnalysisResultLists [& IR ] ;)",
    "insertText": "for(typename AnalysisResultListT::iterator I = ResultsList.begin(), E = ResultsList.end(); I != E;)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (void* PassID = I -> first ;)",
    "insertText": "if(I->second->invalidate(IR, PA))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (InvalidatedPassIDs .)",
    "insertText": "push_back(I->first)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (I = ResultsList .)",
    "insertText": "erase(I)"
  },
  {
    "label": "preserve()",
    "kind": "Method",
    "detail": "Function (} else { + + I ; } PA .)",
    "insertText": "preserve(PassID)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(!InvalidatedPassIDs.empty()) AnalysisResults.erase( std::make_pair(InvalidatedPassIDs.pop_back_val(), &IR))"
  },
  {
    "label": "FunctionAnalysisManagerModuleProxy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FunctionAnalysisManagerModuleProxy(const FunctionAnalysisManagerModuleProxy &Arg) : FAM(Arg.FAM)"
  },
  {
    "label": "FunctionAnalysisManagerModuleProxy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FunctionAnalysisManagerModuleProxy(FunctionAnalysisManagerModuleProxy &&Arg) : FAM(std::move(Arg.FAM))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FunctionAnalysisManagerModuleProxy&)",
    "insertText": "operator(FunctionAnalysisManagerModuleProxy RHS)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(FAM, RHS.FAM)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (private : char PassID ; FunctionAnalysisManager* FAM ; } ; class FunctionAnalysisManagerModuleProxy::Result { public :)",
    "insertText": "Result(FunctionAnalysisManager &FAM) : FAM(&FAM)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Result(const Result &Arg) : FAM(Arg.FAM)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Result(Result &&Arg) : FAM(std::move(Arg.FAM))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Result&)",
    "insertText": "operator(Result RHS)"
  },
  {
    "label": "getManager()",
    "kind": "Method",
    "detail": "Function (FunctionAnalysisManager&)",
    "insertText": "getManager()"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (private : FunctionAnalysisManager* FAM ; } ; class ModuleAnalysisManagerFunctionProxy { public : class Result { public :)",
    "insertText": "Result(const ModuleAnalysisManager &MAM) : MAM(&MAM)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Result(const Result &Arg) : MAM(Arg.MAM)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Result(Result &&Arg) : MAM(std::move(Arg.MAM))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(MAM, RHS.MAM)"
  },
  {
    "label": "ModuleAnalysisManagerFunctionProxy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ModuleAnalysisManagerFunctionProxy(const ModuleAnalysisManagerFunctionProxy &Arg) : MAM(Arg.MAM)"
  },
  {
    "label": "ModuleAnalysisManagerFunctionProxy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ModuleAnalysisManagerFunctionProxy(ModuleAnalysisManagerFunctionProxy &&Arg) : MAM(std::move(Arg.MAM))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ModuleAnalysisManagerFunctionProxy&)",
    "insertText": "operator(ModuleAnalysisManagerFunctionProxy RHS)"
  },
  {
    "label": "ModuleToFunctionPassAdaptor()",
    "kind": "Method",
    "detail": "Function (} private : char PassID ; const ModuleAnalysisManager* MAM ; } ; template<FunctionPassT> class ModuleToFunctionPassAdaptor { public :)",
    "insertText": "ModuleToFunctionPassAdaptor(FunctionPassT Pass) : Pass(std::move(Pass))"
  },
  {
    "label": "ModuleToFunctionPassAdaptor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ModuleToFunctionPassAdaptor(const ModuleToFunctionPassAdaptor &Arg) : Pass(Arg.Pass)"
  },
  {
    "label": "ModuleToFunctionPassAdaptor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ModuleToFunctionPassAdaptor(ModuleToFunctionPassAdaptor &&Arg) : Pass(std::move(Arg.Pass))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(ModuleToFunctionPassAdaptor &LHS, ModuleToFunctionPassAdaptor &RHS)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "swap(LHS.Pass, RHS.Pass)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ModuleToFunctionPassAdaptor&)",
    "insertText": "operator(ModuleToFunctionPassAdaptor RHS)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FunctionAnalysisManager* FAM = nullptr ;)",
    "insertText": "if(AM) FAM = &AM->getResult<FunctionAnalysisManagerModuleProxy>(M).getManager()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (PreservedAnalyses PassPA = Pass .)",
    "insertText": "run(F, FAM)"
  },
  {
    "label": "FunctionAnalysisManagerModuleProxy()",
    "kind": "Method",
    "detail": "Function (} PA . preserve<)",
    "insertText": "FunctionAnalysisManagerModuleProxy()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} template<AnalysisT> struct RequireAnalysisPass { template<IRUnitT> PreservedAnalyses)",
    "insertText": "run(IRUnitT &Arg, AnalysisManager<IRUnitT> *AM)"
  }
]