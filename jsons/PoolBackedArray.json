[
  {
    "label": "TPoolBackedItemAdapter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPoolBackedItemAdapter"
  },
  {
    "label": "TPoolBackedArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPoolBackedArray"
  },
  {
    "label": "GetArrayIndex()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" # include \" Chaos / ObjectPool . h \" namespace Chaos::Private { template<T> struct TPoolBackedItemAdapter { int32)",
    "insertText": "GetArrayIndex(const T& Item)"
  },
  {
    "label": "SetArrayIndex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetArrayIndex(T& Item, const int32 Index)"
  },
  {
    "label": "TrashItem()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TrashItem(T& Item)"
  },
  {
    "label": "Trash()",
    "kind": "Method",
    "detail": "Function (Item .)",
    "insertText": "Trash()"
  },
  {
    "label": "ReuseItem()",
    "kind": "Method",
    "detail": "Function (} template<. . . TArgs> void)",
    "insertText": "ReuseItem(T& Item, TArgs&&... Args)"
  },
  {
    "label": "Reuse()",
    "kind": "Method",
    "detail": "Function (Item .)",
    "insertText": "Reuse(Forward<TArgs>(Args)...)"
  },
  {
    "label": "TPoolBackedArray()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,TItemAdapter = TPoolBackedItemAdapter<T>> class TPoolBackedArray { public : using FItem = T ; using FItemPtr = FItem* ; using FConstItemPtr = const FItem* ; using FItemAdapter = TItemAdapter ; using FRangedForIterator = TArray<FItemPtr>::RangedForIteratorType ; using FRangedForConstIterator = TArray<FItemPtr>::RangedForConstIteratorType ;)",
    "insertText": "TPoolBackedArray(const int32 NumItemsPerBlock) : Pool(NumItemsPerBlock)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (} template<. . . TArgs> FItemPtr)",
    "insertText": "Alloc(TArgs&&... Args)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FItemPtr Item = nullptr ;)",
    "insertText": "if(!FreeItems.IsEmpty())"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (Item = FreeItems .)",
    "insertText": "Pop(EAllowShrinking::No)"
  },
  {
    "label": "ReuseItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReuseItem(*Item, Forward<TArgs>(Args)...)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (} else { Item = Pool .)",
    "insertText": "Alloc(Forward<TArgs>(Args)...)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} const int32 Index = Items .)",
    "insertText": "Add(Item)"
  },
  {
    "label": "SetArrayIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetArrayIndex(*Item, Index)"
  },
  {
    "label": "GetArrayIndex()",
    "kind": "Method",
    "detail": "Function (const int32 Index =)",
    "insertText": "GetArrayIndex(*Item)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (Items .)",
    "insertText": "RemoveAtSwap(Index, EAllowShrinking::No)"
  },
  {
    "label": "SetArrayIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetArrayIndex(*Item, INDEX_NONE)"
  },
  {
    "label": "SetArrayIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetArrayIndex(*Items[Index], Index)"
  },
  {
    "label": "TrashItem()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TrashItem(*Item)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Reset()"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(Items[Index])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(FItemPtr Item : FreeItems)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (Pool .)",
    "insertText": "Free(Item)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Num()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reserve(const int32 Size)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Items .)",
    "insertText": "Reserve(Size)"
  },
  {
    "label": "ReserveItems()",
    "kind": "Method",
    "detail": "Function (Pool .)",
    "insertText": "ReserveItems(Size)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FItemPtr)",
    "insertText": "operator(const int32 Index)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} FRangedForIterator)",
    "insertText": "end()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} FRangedForConstIterator)",
    "insertText": "begin()"
  },
  {
    "label": "SortFreeLists()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SortFreeLists()"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (FreeItems .)",
    "insertText": "Sort([](const FItem& L, const FItem& R) { return &L < &R; })"
  }
]