[
  {
    "label": "split_ordered_list",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "split_ordered_list"
  },
  {
    "label": "concurrent_unordered_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "concurrent_unordered_base"
  },
  {
    "label": "Solist",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Solist"
  },
  {
    "label": "flist_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "flist_iterator"
  },
  {
    "label": "M",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "M"
  },
  {
    "label": "solist_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "solist_iterator"
  },
  {
    "label": "node",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "node"
  },
  {
    "label": "call_internal_clear_on_exit",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "call_internal_clear_on_exit"
  },
  {
    "label": "const_range_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "const_range_type"
  },
  {
    "label": "range_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "range_type"
  },
  {
    "label": "Iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Iterator"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB__concurrent_unordered_impl_H # define __TBB__concurrent_unordered_impl_H # if !)",
    "insertText": "defined(__TBB_concurrent_unordered_map_H) && !defined(__TBB_concurrent_unordered_set_H) && !defined(__TBB_concurrent_hash_map_H)"
  },
  {
    "label": "flist_iterator()",
    "kind": "Method",
    "detail": "Function (use public TBB headers instead . # endif # include \" . . / tbb_stddef . h \" # include<iterator> # include<utility> # include<functional> # include<string> # include<cstring> # include __TBB_STD_SWAP_HEADER # include \" . . / atomic . h \" # include \" . . / tbb_exception . h \" # include \" . . / tbb_allocator . h \" # if __TBB_INITIALIZER_LISTS_PRESENT # include<initializer_list> # endif # if __TBB_CPP11_RVALUE_REF_PRESENT&& ! __TBB_IMPLICIT_COPY_DELETION_BROKEN # define __TBB_UNORDERED_NODE_HANDLE_PRESENT 1 # endif # include \" _allocator_traits . h \" # include \" _tbb_hash_compare_impl . h \" # include \" _template_helpers . h \" # if __TBB_UNORDERED_NODE_HANDLE_PRESENT # include \" _node_handle_impl . h \" # endif namespace tbb { namespace interface5 { namespace internal { template<T,Allocator> class split_ordered_list ; template<Traits> class concurrent_unordered_base ; template<class Solist,Value> class flist_iterator : public std::iterator<std::forward_iterator_tag,Value> { template<T,Allocator> class split_ordered_list ; template<Traits> class concurrent_unordered_base ; template<class M,V> class flist_iterator ; typedef Solist::nodeptr_t nodeptr_t ; public : typedef Solist::value_type value_type ; typedef Solist::difference_type difference_type ; typedef Solist::pointer pointer ; typedef Solist::reference reference ;)",
    "insertText": "flist_iterator() : my_node_ptr(0)"
  },
  {
    "label": "flist_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "flist_iterator(const flist_iterator<Solist, typename Solist::value_type> &other ) : my_node_ptr(other.my_node_ptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (my_node_ptr = my_node_ptr -> my_next ; return* this ; } flist_iterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "flist_iterator()",
    "kind": "Method",
    "detail": "Function (flist_iterator tmp =* this ; + +* this ; return tmp ; } protected :)",
    "insertText": "flist_iterator(nodeptr_t pnode) : my_node_ptr(pnode)"
  },
  {
    "label": "get_node_ptr()",
    "kind": "Method",
    "detail": "Function (} nodeptr_t)",
    "insertText": "get_node_ptr()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<M,T,U> bool)",
    "insertText": "operator(const flist_iterator<M,T>& i, const flist_iterator<M,U>& j)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Solist,T,U> bool)",
    "insertText": "operator(const flist_iterator<Solist,T> &i, const flist_iterator<Solist,U> &j)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<M,T,U> bool)",
    "insertText": "operator(const solist_iterator<M,T>& i, const solist_iterator<M,U>& j)"
  },
  {
    "label": "solist_iterator()",
    "kind": "Method",
    "detail": "Function (const Solist* my_list_ptr ;)",
    "insertText": "solist_iterator(nodeptr_t pnode, const Solist *plist) : base_type(pnode), my_list_ptr(plist)"
  },
  {
    "label": "solist_iterator()",
    "kind": "Method",
    "detail": "Function (} public : typedef Solist::value_type value_type ; typedef Solist::difference_type difference_type ; typedef Solist::pointer pointer ; typedef Solist::reference reference ;)",
    "insertText": "solist_iterator()"
  },
  {
    "label": "solist_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "solist_iterator(const solist_iterator<Solist, typename Solist::value_type> &other ) : base_type(other), my_list_ptr(other.my_list_ptr)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (solist_iterator tmp =* this ; do + +* this ;)",
    "insertText": "while(get_node_ptr() != NULL && get_node_ptr()->is_dummy())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Solist,T,U> bool)",
    "insertText": "operator(const solist_iterator<Solist,T> &i, const solist_iterator<Solist,U> &j)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "init(sokey_t order_key)"
  },
  {
    "label": "get_order_key()",
    "kind": "Method",
    "detail": "Function (my_order_key = order_key ; my_next = NULL ; } sokey_t)",
    "insertText": "get_order_key()"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} value_type&)",
    "insertText": "value()"
  },
  {
    "label": "atomic_set_next()",
    "kind": "Method",
    "detail": "Function (} nodeptr_t)",
    "insertText": "atomic_set_next(nodeptr_t new_node, nodeptr_t current_node)"
  },
  {
    "label": "as_atomic()",
    "kind": "Method",
    "detail": "Function (nodeptr_t exchange_node = tbb::)",
    "insertText": "as_atomic(my_next).compare_and_swap(new_node, current_node)"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (} nodeptr_t my_next ; value_type my_element ; sokey_t my_order_key ; } ; nodeptr_t)",
    "insertText": "create_node(sokey_t order_key)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (nodeptr_t pnode = my_node_allocator .)",
    "insertText": "allocate(1)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (pnode ->)",
    "insertText": "init(order_key)"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (} template<Arg> nodeptr_t)",
    "insertText": "create_node(sokey_t order_key, __TBB_FORWARDING_REF(Arg) t, tbb::internal::true_type=tbb::internal::true_type())"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (__TBB_TRY {)",
    "insertText": "new(static_cast<void*>(&pnode->my_element)) T(tbb::internal::forward<Arg>(t))"
  },
  {
    "label": "__TBB_CATCH()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "__TBB_CATCH(...)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (my_node_allocator .)",
    "insertText": "deallocate(pnode, 1)"
  },
  {
    "label": "__TBB_RETHROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_RETHROW()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(pnode)"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (} template<Arg> nodeptr_t)",
    "insertText": "create_node(sokey_t, __TBB_FORWARDING_REF(Arg), tbb::internal::false_type)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(false, \"This compile-time helper should never get called\")"
  },
  {
    "label": "create_node_v()",
    "kind": "Method",
    "detail": "Function (} template<__TBB_PARAMETER_PACK Args> nodeptr_t)",
    "insertText": "create_node_v(__TBB_FORWARDING_REF(Args) __TBB_PARAMETER_PACK args)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (__TBB_TRY {)",
    "insertText": "new(static_cast<void*>(&pnode->my_element)) T(__TBB_PACK_EXPANSION(tbb::internal::forward<Args>(args)))"
  },
  {
    "label": "split_ordered_list()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "split_ordered_list(allocator_type a = allocator_type()) : my_node_allocator(a), my_element_count(0)"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (my_head =)",
    "insertText": "create_node(sokey_t(0))"
  },
  {
    "label": "split_ordered_list()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "split_ordered_list()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (nodeptr_t pnode = my_head ; my_head = NULL ;)",
    "insertText": "__TBB_ASSERT(pnode != NULL && pnode->my_next == NULL, \"Invalid head list node\")"
  },
  {
    "label": "destroy_node()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy_node(pnode)"
  },
  {
    "label": "get_allocator()",
    "kind": "Method",
    "detail": "Function (} allocator_type)",
    "insertText": "get_allocator()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (nodeptr_t pnext ; nodeptr_t pnode = my_head ;)",
    "insertText": "__TBB_ASSERT(my_head != NULL, \"Invalid head list node\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (pnext = pnode -> my_next ; pnode -> my_next = NULL ; pnode = pnext ;)",
    "insertText": "while(pnode != NULL)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (pnode = pnext ; } my_element_count = 0 ; } iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "cbegin()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "cbegin()"
  },
  {
    "label": "cend()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "cend()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "size()"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(self_type& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(my_head, other.my_head)"
  },
  {
    "label": "raw_begin()",
    "kind": "Method",
    "detail": "Function (} raw_iterator)",
    "insertText": "raw_begin()"
  },
  {
    "label": "raw_end()",
    "kind": "Method",
    "detail": "Function (} raw_iterator)",
    "insertText": "raw_end()"
  },
  {
    "label": "get_order_key()",
    "kind": "Method",
    "detail": "Function (} sokey_t)",
    "insertText": "get_order_key(const raw_const_iterator& it)"
  },
  {
    "label": "get_safe_order_key()",
    "kind": "Method",
    "detail": "Function (} sokey_t)",
    "insertText": "get_safe_order_key(const raw_const_iterator& it)"
  },
  {
    "label": "get_iterator()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "get_iterator(raw_iterator it)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(it.get_node_ptr() == NULL || !it.get_node_ptr()->is_dummy(), \"Invalid user node (dummy)\")"
  },
  {
    "label": "get_iterator()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "get_iterator(raw_const_iterator it)"
  },
  {
    "label": "get_iterator()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "get_iterator(const_iterator it)"
  },
  {
    "label": "first_real_iterator()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "first_real_iterator(raw_iterator it)"
  },
  {
    "label": "first_real_iterator()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "first_real_iterator(raw_const_iterator it)"
  },
  {
    "label": "destroy_node()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "destroy_node(nodeptr_t pnode)"
  },
  {
    "label": "try_insert_atomic()",
    "kind": "Method",
    "detail": "Function (} nodeptr_t)",
    "insertText": "try_insert_atomic(nodeptr_t previous, nodeptr_t new_node, nodeptr_t current_node)"
  },
  {
    "label": "atomic_set_next()",
    "kind": "Method",
    "detail": "Function (new_node -> my_next = current_node ; return previous ->)",
    "insertText": "atomic_set_next(new_node, current_node)"
  },
  {
    "label": "try_insert()",
    "kind": "Method",
    "detail": "Function (} std::pair<iterator,bool>)",
    "insertText": "try_insert(raw_iterator it, raw_iterator next, nodeptr_t pnode, size_type *new_count)"
  },
  {
    "label": "try_insert_atomic()",
    "kind": "Method",
    "detail": "Function (nodeptr_t inserted_node =)",
    "insertText": "try_insert_atomic(it.get_node_ptr(), pnode, next.get_node_ptr())"
  },
  {
    "label": "as_atomic()",
    "kind": "Method",
    "detail": "Function (* new_count = tbb::)",
    "insertText": "as_atomic(my_element_count).fetch_and_increment()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} else { return std::pair<iterator,)",
    "insertText": "bool(end(), false)"
  },
  {
    "label": "insert_dummy()",
    "kind": "Method",
    "detail": "Function (} } raw_iterator)",
    "insertText": "insert_dummy(raw_iterator it, sokey_t order_key)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (raw_iterator where = it ;)",
    "insertText": "__TBB_ASSERT(where != last, \"Invalid head node\")"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (+ + where ; nodeptr_t dummy_node =)",
    "insertText": "create_node(order_key)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(it != last, \"Invalid head list node\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(get_order_key(it) < order_key, \"Invalid node order in the list\")"
  },
  {
    "label": "try_insert_atomic()",
    "kind": "Method",
    "detail": "Function (nodeptr_t inserted_node =)",
    "insertText": "try_insert_atomic(it.get_node_ptr(), dummy_node, where.get_node_ptr())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { where = it ; + + where ; continue ; } } else)",
    "insertText": "if(get_order_key(where) == order_key)"
  },
  {
    "label": "destroy_node()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy_node(dummy_node)"
  },
  {
    "label": "pnode()",
    "kind": "Method",
    "detail": "Function (nodeptr_t)",
    "insertText": "pnode(where++).get_node_ptr()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(prevnode->my_next == pnode, \"Erase must take consecutive iterators\")"
  },
  {
    "label": "erase_node()",
    "kind": "Method",
    "detail": "Function (prevnode -> my_next = pnode -> my_next ; return pnode ; } void)",
    "insertText": "erase_node(raw_iterator previous, raw_const_iterator& where, tbb::internal::true_type)"
  },
  {
    "label": "erase_node_impl()",
    "kind": "Method",
    "detail": "Function (nodeptr_t pnode =)",
    "insertText": "erase_node_impl(previous, where)"
  },
  {
    "label": "erase_node()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "erase_node(raw_iterator previous, raw_const_iterator& where, tbb::internal::false_type)"
  },
  {
    "label": "erase_node()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "erase_node(raw_iterator previous, raw_const_iterator& where)"
  },
  {
    "label": "erase_node()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase_node(previous, where, tbb::internal::true_type())"
  },
  {
    "label": "erase_node()",
    "kind": "Method",
    "detail": "Function (} template<AllowDestroy> iterator)",
    "insertText": "erase_node(raw_iterator previous, const_iterator where, AllowDestroy)"
  },
  {
    "label": "erase_node()",
    "kind": "Method",
    "detail": "Function (raw_const_iterator it = where ;)",
    "insertText": "erase_node(previous, it, AllowDestroy())"
  },
  {
    "label": "get_iterator()",
    "kind": "Method",
    "detail": "Function (my_element_count - - ; return)",
    "insertText": "get_iterator(first_real_iterator(it))"
  },
  {
    "label": "erase_node()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "erase_node(raw_iterator previous, const_iterator& where)"
  },
  {
    "label": "move_all()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "move_all(self_type& source)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (nodeptr_t previous_node = my_head ; raw_const_iterator begin_iterator = first + + ;)",
    "insertText": "for(raw_const_iterator it = first; it != last;)"
  },
  {
    "label": "is_dummy()",
    "kind": "Method",
    "detail": "Function (nodeptr_t dummy_node = pnode ->)",
    "insertText": "is_dummy() ? create_node(pnode->get_order_key()) : create_node(pnode->get_order_key(), pnode->my_element)"
  },
  {
    "label": "try_insert_atomic()",
    "kind": "Method",
    "detail": "Function (previous_node =)",
    "insertText": "try_insert_atomic(previous_node, dummy_node, NULL)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(previous_node != NULL, \"Insertion must succeed\")"
  },
  {
    "label": "erase_node()",
    "kind": "Method",
    "detail": "Function (raw_const_iterator where = it + + ; source .)",
    "insertText": "erase_node(get_iterator(begin_iterator), where)"
  },
  {
    "label": "check_range()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check_range()"
  },
  {
    "label": "check_range()",
    "kind": "Method",
    "detail": "Function (} private : template<Traits> class concurrent_unordered_base ; void)",
    "insertText": "check_range(raw_iterator first, raw_iterator last)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# if TBB_USE_ASSERT)",
    "insertText": "for(raw_iterator it = first; it != last; ++it)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (raw_iterator next = it ; + + next ;)",
    "insertText": "__TBB_ASSERT(next == raw_end() || get_order_key(next) >= get_order_key(it), \"!!! List order inconsistency !!!\")"
  },
  {
    "label": "suppress_unused_warning()",
    "kind": "Method",
    "detail": "Function (} # else tbb::)",
    "insertText": "suppress_unused_warning(first, last)"
  },
  {
    "label": "check_range()",
    "kind": "Method",
    "detail": "Function (# if TBB_USE_ASSERT)",
    "insertText": "check_range(raw_begin(), raw_end())"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif } tbb::internal::allocator_rebind<allocator_type,node>::type my_node_allocator ; size_type my_element_count ; nodeptr_t my_head ; } ; # if)",
    "insertText": "defined(_MSC_VER) && !defined(__INTEL_COMPILER) #pragma warning(push) #pragma warning(disable: 4127)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (protected : typedef concurrent_unordered_base<Traits> self_type ; typedef Traits::value_type value_type ; typedef Traits::key_type key_type ; typedef Traits::hash_compare hash_compare ; typedef Traits::allocator_type allocator_type ; typedef hash_compare::hasher hasher ; typedef hash_compare::key_equal key_equal ; typedef tbb::internal::allocator_traits<allocator_type>::size_type size_type ; typedef tbb::internal::allocator_traits<allocator_type>::difference_type difference_type ; typedef tbb::internal::allocator_traits<allocator_type>::pointer pointer ; typedef tbb::internal::allocator_traits<allocator_type>::const_pointer const_pointer ; typedef allocator_type::value_type& reference ; typedef const allocator_type::value_type& const_reference ; typedef split_ordered_list<value_type,Traits::allocator_type> solist_t ; typedef solist_t::nodeptr_t nodeptr_t ; typedef solist_t::raw_iterator raw_iterator ; typedef solist_t::raw_const_iterator raw_const_iterator ; typedef solist_t::iterator iterator ; typedef solist_t::const_iterator const_iterator ; typedef iterator local_iterator ; typedef const_iterator const_local_iterator ; # if __TBB_UNORDERED_NODE_HANDLE_PRESENT typedef Traits::node_type node_type ; # endif using Traits::my_hash_compare ; using Traits::get_key ; using Traits::allow_multimapping ; const size_type initial_bucket_number = 8 ; private : template<OtherTraits> class concurrent_unordered_base ; typedef std::pair<iterator,iterator> pairii_t ; typedef std::pair<const_iterator,const_iterator> paircc_t ; size_type const pointers_per_table =)",
    "insertText": "sizeof(size_type)"
  },
  {
    "label": "call_internal_clear_on_exit()",
    "kind": "Method",
    "detail": "Function (const size_type initial_bucket_load = 4 ; struct call_internal_clear_on_exit { concurrent_unordered_base* my_instance ;)",
    "insertText": "call_internal_clear_on_exit(concurrent_unordered_base* instance) : my_instance(instance)"
  },
  {
    "label": "dismiss()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "dismiss()"
  },
  {
    "label": "call_internal_clear_on_exit()",
    "kind": "Method",
    "detail": "Function (my_instance = NULL ; } ~)",
    "insertText": "call_internal_clear_on_exit()"
  },
  {
    "label": "internal_clear()",
    "kind": "Method",
    "detail": "Function (my_instance ->)",
    "insertText": "internal_clear()"
  },
  {
    "label": "concurrent_unordered_base()",
    "kind": "Method",
    "detail": "Function (} } } ; protected :)",
    "insertText": "concurrent_unordered_base(size_type n_of_buckets = initial_bucket_number, const hash_compare& hc = hash_compare(), const allocator_type& a = allocator_type()) : Traits(hc), my_solist(a), my_allocator(a), my_maximum_bucket_size((float) initial_bucket_load)"
  },
  {
    "label": "size_type()",
    "kind": "Method",
    "detail": "Function (my_number_of_buckets =)",
    "insertText": "size_type(1)<<__TBB_Log2((uintptr_t)n_of_buckets*2-1)"
  },
  {
    "label": "internal_init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_init()"
  },
  {
    "label": "concurrent_unordered_base()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "concurrent_unordered_base(const concurrent_unordered_base& right, const allocator_type& a) : Traits(right.my_hash_compare), my_solist(a), my_allocator(a)"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_copy(right)"
  },
  {
    "label": "concurrent_unordered_base()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "concurrent_unordered_base(const concurrent_unordered_base& right) : Traits(right.my_hash_compare), my_solist(right.get_allocator()), my_allocator(right.get_allocator())"
  },
  {
    "label": "concurrent_unordered_base()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT)",
    "insertText": "concurrent_unordered_base(concurrent_unordered_base&& right) : Traits(right.my_hash_compare), my_solist(right.get_allocator()), my_allocator(right.get_allocator()), my_maximum_bucket_size(float(initial_bucket_load))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(right)"
  },
  {
    "label": "concurrent_unordered_base()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "concurrent_unordered_base(concurrent_unordered_base&& right, const allocator_type& a) : Traits(right.my_hash_compare), my_solist(a), my_allocator(a)"
  },
  {
    "label": "clear_buckets_on_exception()",
    "kind": "Method",
    "detail": "Function (call_internal_clear_on_exit)",
    "insertText": "clear_buckets_on_exception(this)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (my_number_of_buckets = initial_bucket_number ; my_maximum_bucket_size =)",
    "insertText": "float(initial_bucket_load)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { my_maximum_bucket_size = right . my_maximum_bucket_size ; my_number_of_buckets = right . my_number_of_buckets ; my_solist . my_element_count = right . my_solist . my_element_count ;)",
    "insertText": "if(! right.my_solist.empty())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (nodeptr_t previous_node = my_solist . my_head ;)",
    "insertText": "for(raw_const_iterator it = ++(right.my_solist.raw_begin()), last = right.my_solist.raw_end(); it != last; ++it)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (nodeptr_t node ;)",
    "insertText": "if(pnode->is_dummy())"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (node = my_solist .)",
    "insertText": "create_node(pnode->get_order_key())"
  },
  {
    "label": "__TBB_ReverseBits()",
    "kind": "Method",
    "detail": "Function (size_type bucket =)",
    "insertText": "__TBB_ReverseBits(pnode->get_order_key())"
  },
  {
    "label": "set_bucket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_bucket(bucket, node)"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (} else { node = my_solist .)",
    "insertText": "create_node(pnode->get_order_key(), std::move(pnode->my_element))"
  },
  {
    "label": "try_insert_atomic()",
    "kind": "Method",
    "detail": "Function (} previous_node = my_solist .)",
    "insertText": "try_insert_atomic(previous_node, node, NULL)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(previous_node != NULL, \"Insertion of node failed. Concurrent inserts in constructor ?\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif concurrent_unordered_base&)",
    "insertText": "operator(const concurrent_unordered_base& right)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT concurrent_unordered_base&)",
    "insertText": "operator(concurrent_unordered_base&& other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (typedef tbb::internal::allocator_traits<allocator_type>::propagate_on_container_move_assignment pocma_t ;)",
    "insertText": "if(pocma_t::value || this->my_allocator == other.my_allocator)"
  },
  {
    "label": "trash()",
    "kind": "Method",
    "detail": "Function (concurrent_unordered_base)",
    "insertText": "trash(std::move(*this))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "swap(this->my_solist.my_node_allocator, other.my_solist.my_node_allocator)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(this->my_allocator, other.my_allocator)"
  },
  {
    "label": "moved_copy()",
    "kind": "Method",
    "detail": "Function (} } else { concurrent_unordered_base)",
    "insertText": "moved_copy(std::move(other),this->my_allocator)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "swap(moved_copy)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } return* this ; } # endif # if __TBB_INITIALIZER_LISTS_PRESENT concurrent_unordered_base&)",
    "insertText": "operator(std::initializer_list<value_type> il)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "insert(il.begin(),il.end())"
  },
  {
    "label": "concurrent_unordered_base()",
    "kind": "Method",
    "detail": "Function (} # endif ~)",
    "insertText": "concurrent_unordered_base()"
  },
  {
    "label": "internal_merge()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_UNORDERED_NODE_HANDLE_PRESENT template<SourceType> void)",
    "insertText": "internal_merge(SourceType& source)"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (typedef SourceType::iterator source_iterator ;)",
    "insertText": "__TBB_STATIC_ASSERT((tbb::internal::is_same_type<node_type, typename SourceType::node_type>::value), \"Incompatible containers cannot be merged\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (source_iterator where = it + + ;)",
    "insertText": "if(allow_multimapping || find(get_key(*where)) == end())"
  },
  {
    "label": "internal_extract()",
    "kind": "Method",
    "detail": "Function (std::pair<node_type,raw_iterator> extract_result = source .)",
    "insertText": "internal_extract(where)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (raw_iterator next = extract_result . second ; raw_iterator current = next + + ;)",
    "insertText": "__TBB_ASSERT(extract_result.first.my_node->get_order_key() >= current.get_node_ptr()->get_order_key(), \"Wrong nodes order in source container\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(next==source.my_solist.raw_end() || extract_result.first.my_node->get_order_key() <= next.get_node_ptr()->get_order_key(), \"Wrong nodes order in source container\")"
  },
  {
    "label": "try_insert()",
    "kind": "Method",
    "detail": "Function (size_t new_count = 0 ; bool insert_result = source . my_solist .)",
    "insertText": "try_insert(current, next, extract_result.first.my_node, &new_count)"
  },
  {
    "label": "__TBB_ASSERT_EX()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT_EX(insert_result, \"Return to source must be successful. \" \"Changing source container while merging is unsafe.\")"
  },
  {
    "label": "deactivate()",
    "kind": "Method",
    "detail": "Function (} extract_result . first .)",
    "insertText": "deactivate()"
  },
  {
    "label": "max_size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "max_size()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (r . my_end_node = my_begin_node = r . my_midpoint_node ;)",
    "insertText": "__TBB_ASSERT(!empty(), \"Splitting despite the range is not divisible\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!r.empty(), \"Splitting despite the range is not divisible\")"
  },
  {
    "label": "set_midpoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_midpoint()"
  },
  {
    "label": "const_range_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "const_range_type(const concurrent_unordered_base &a_table ) : my_table(a_table), my_begin_node(a_table.my_solist.begin()), my_end_node(a_table.my_solist.end())"
  },
  {
    "label": "grainsize()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "grainsize()"
  },
  {
    "label": "get_safe_order_key()",
    "kind": "Method",
    "detail": "Function (sokey_t end_key =)",
    "insertText": "get_safe_order_key(my_end_node)"
  },
  {
    "label": "__TBB_ReverseBits()",
    "kind": "Method",
    "detail": "Function (size_t mid_bucket =)",
    "insertText": "__TBB_ReverseBits(begin_key + (end_key-begin_key)/2)"
  },
  {
    "label": "first_real_iterator()",
    "kind": "Method",
    "detail": "Function (my_midpoint_node = my_table . my_solist .)",
    "insertText": "first_real_iterator(my_table.get_bucket( mid_bucket ))"
  },
  {
    "label": "get_safe_order_key()",
    "kind": "Method",
    "detail": "Function (} else { my_midpoint_node = my_end_node ; } # if TBB_USE_ASSERT { sokey_t mid_key =)",
    "insertText": "get_safe_order_key(my_midpoint_node)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(begin_key < mid_key, \"my_begin_node is after my_midpoint_node\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(mid_key <= end_key, \"my_midpoint_node is after my_end_node\")"
  },
  {
    "label": "range_type()",
    "kind": "Method",
    "detail": "Function (} # endif } } } ; class range_type : public const_range_type { public : typedef concurrent_unordered_base::iterator iterator ;)",
    "insertText": "range_type(range_type &r, split ) : const_range_type( r, split())"
  },
  {
    "label": "range_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "range_type(const concurrent_unordered_base &a_table ) : const_range_type(a_table)"
  },
  {
    "label": "range()",
    "kind": "Method",
    "detail": "Function (} } ; range_type)",
    "insertText": "range()"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} std::pair<iterator,bool>)",
    "insertText": "insert(const value_type& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(const_iterator, const value_type& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT std::pair<iterator,bool>)",
    "insertText": "insert(value_type&& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(const_iterator, value_type&& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} # endif # if __TBB_UNORDERED_NODE_HANDLE_PRESENT std::pair<iterator,bool>)",
    "insertText": "insert(node_type&& nh)"
  },
  {
    "label": "false_type()",
    "kind": "Method",
    "detail": "Function (nodeptr_t handled_node = nh . my_node ; std::pair<iterator,bool> insert_result = internal_insert<tbb::internal::false_type,tbb::)",
    "insertText": "false_type(handled_node->my_element, handled_node)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(const_iterator, node_type&& nh)"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (} # endif # if __TBB_CPP11_VARIADIC_TEMPLATES_PRESENT&& __TBB_CPP11_RVALUE_REF_PRESENT template<. . . Args> std::pair<iterator,bool>)",
    "insertText": "emplace(Args&&... args)"
  },
  {
    "label": "create_node_v()",
    "kind": "Method",
    "detail": "Function (nodeptr_t pnode = my_solist .)",
    "insertText": "create_node_v(tbb::internal::forward<Args>(args)...)"
  },
  {
    "label": "emplace_hint()",
    "kind": "Method",
    "detail": "Function (} template<. . . Args> iterator)",
    "insertText": "emplace_hint(const_iterator, Args&&... args)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} # endif template<class Iterator> void)",
    "insertText": "insert(Iterator first, Iterator last)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_INITIALIZER_LISTS_PRESENT void)",
    "insertText": "insert(std::initializer_list<value_type> il)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(il.begin(), il.end())"
  },
  {
    "label": "unsafe_erase()",
    "kind": "Method",
    "detail": "Function (} # endif iterator)",
    "insertText": "unsafe_erase(const_iterator where)"
  },
  {
    "label": "unsafe_erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "unsafe_erase(const_iterator first, const_iterator last)"
  },
  {
    "label": "unsafe_erase()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "unsafe_erase(const key_type& key)"
  },
  {
    "label": "equal_range()",
    "kind": "Method",
    "detail": "Function (pairii_t where =)",
    "insertText": "equal_range(key)"
  },
  {
    "label": "internal_distance()",
    "kind": "Method",
    "detail": "Function (size_type item_count =)",
    "insertText": "internal_distance(where.first, where.second)"
  },
  {
    "label": "unsafe_erase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unsafe_erase(where.first, where.second)"
  },
  {
    "label": "unsafe_extract()",
    "kind": "Method",
    "detail": "Function (} node_type)",
    "insertText": "unsafe_extract(const key_type& key)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "swap(concurrent_unordered_base& right)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(my_hash_compare, right.my_hash_compare)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (my_solist .)",
    "insertText": "swap(right.my_solist)"
  },
  {
    "label": "internal_swap_buckets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_swap_buckets(right)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(my_number_of_buckets, right.my_number_of_buckets)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(my_maximum_bucket_size, right.my_maximum_bucket_size)"
  },
  {
    "label": "hash_function()",
    "kind": "Method",
    "detail": "Function (} } hasher)",
    "insertText": "hash_function()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_buckets[0] == NULL, NULL)"
  },
  {
    "label": "set_bucket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_bucket(0, dummy_node)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "find(const key_type& key)"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "count(const key_type& key)"
  },
  {
    "label": "internal_distance()",
    "kind": "Method",
    "detail": "Function (size_type item_count =)",
    "insertText": "internal_distance(answer.first, answer.second)"
  },
  {
    "label": "equal_range()",
    "kind": "Method",
    "detail": "Function (} } std::pair<iterator,iterator>)",
    "insertText": "equal_range(const key_type& key)"
  },
  {
    "label": "unsafe_bucket_count()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "unsafe_bucket_count()"
  },
  {
    "label": "unsafe_bucket_size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "unsafe_bucket_size(size_type bucket)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_type item_count = 0 ;)",
    "insertText": "if(is_initialized(bucket))"
  },
  {
    "label": "get_bucket()",
    "kind": "Method",
    "detail": "Function (raw_iterator it =)",
    "insertText": "get_bucket(bucket)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (+ + it ;)",
    "insertText": "for(; it != my_solist.raw_end() && !it.get_node_ptr()->is_dummy(); ++it)"
  },
  {
    "label": "unsafe_bucket()",
    "kind": "Method",
    "detail": "Function (} return item_count ; } size_type)",
    "insertText": "unsafe_bucket(const key_type& key)"
  },
  {
    "label": "order_key()",
    "kind": "Method",
    "detail": "Function (sokey_t)",
    "insertText": "order_key(sokey_t) my_hash_compare(key)"
  },
  {
    "label": "unsafe_begin()",
    "kind": "Method",
    "detail": "Function (size_type bucket = order_key % my_number_of_buckets ; return bucket ; } local_iterator)",
    "insertText": "unsafe_begin(size_type bucket)"
  },
  {
    "label": "unsafe_end()",
    "kind": "Method",
    "detail": "Function (} local_iterator)",
    "insertText": "unsafe_end(size_type bucket)"
  },
  {
    "label": "unsafe_cbegin()",
    "kind": "Method",
    "detail": "Function (} const_local_iterator)",
    "insertText": "unsafe_cbegin(size_type bucket)"
  },
  {
    "label": "unsafe_cend()",
    "kind": "Method",
    "detail": "Function (} const_local_iterator)",
    "insertText": "unsafe_cend(size_type bucket)"
  },
  {
    "label": "load_factor()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "load_factor()"
  },
  {
    "label": "max_load_factor()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "max_load_factor()"
  },
  {
    "label": "rehash()",
    "kind": "Method",
    "detail": "Function (my_maximum_bucket_size = newmax ; } void)",
    "insertText": "rehash(size_type buckets)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_type current_buckets = my_number_of_buckets ;)",
    "insertText": "if(current_buckets >= buckets)"
  },
  {
    "label": "size_type()",
    "kind": "Method",
    "detail": "Function (my_number_of_buckets =)",
    "insertText": "size_type(1)<<__TBB_Log2((uintptr_t)buckets*2-1)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(my_buckets, 0, sizeof(my_buckets))"
  },
  {
    "label": "segment_size()",
    "kind": "Method",
    "detail": "Function (size_type sz =)",
    "insertText": "segment_size(index)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (my_allocator .)",
    "insertText": "deallocate(my_buckets[index], sz)"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (my_buckets [ index ] = 0 ; } } } void)",
    "insertText": "internal_copy(const self_type& right)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (my_maximum_bucket_size = right . my_maximum_bucket_size ; my_number_of_buckets = right . my_number_of_buckets ; __TBB_TRY {)",
    "insertText": "insert(right.begin(), right.end())"
  },
  {
    "label": "internal_swap_buckets()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "internal_swap_buckets(concurrent_unordered_base& right)"
  },
  {
    "label": "internal_distance()",
    "kind": "Method",
    "detail": "Function (raw_iterator* iterator_pointer = my_buckets [ index ] ; my_buckets [ index ] = right . my_buckets [ index ] ; right . my_buckets [ index ] = iterator_pointer ; } } size_type)",
    "insertText": "internal_distance(const_iterator first, const_iterator last)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_type num = 0 ;)",
    "insertText": "for(const_iterator it = first; it != last; ++it)"
  },
  {
    "label": "get_key()",
    "kind": "Method",
    "detail": "Function (const key_type* pkey =&)",
    "insertText": "get_key(value)"
  },
  {
    "label": "hash_key()",
    "kind": "Method",
    "detail": "Function (sokey_t)",
    "insertText": "hash_key(sokey_t) my_hash_compare(*pkey)"
  },
  {
    "label": "split_order_key_regular()",
    "kind": "Method",
    "detail": "Function (size_type new_count = 0 ; sokey_t order_key =)",
    "insertText": "split_order_key_regular(hash_key)"
  },
  {
    "label": "prepare_bucket()",
    "kind": "Method",
    "detail": "Function (raw_iterator previous =)",
    "insertText": "prepare_bucket(hash_key)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(previous != last, \"Invalid head node\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + where ;)",
    "insertText": "if(where == last || solist_t::get_order_key(where) > order_key || (allow_multimapping && solist_t::get_order_key(where) == order_key && !my_hash_compare(get_key(*where), *pkey)))"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (pnode = my_solist .)",
    "insertText": "create_node(order_key, tbb::internal::forward<ValueType>(value), AllowCreate())"
  },
  {
    "label": "get_key()",
    "kind": "Method",
    "detail": "Function (pkey =&)",
    "insertText": "get_key(pnode->my_element)"
  },
  {
    "label": "try_insert()",
    "kind": "Method",
    "detail": "Function (} std::pair<iterator,bool> result = my_solist .)",
    "insertText": "try_insert(previous, where, pnode, &new_count)"
  },
  {
    "label": "adjust_table_size()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "adjust_table_size(new_count, my_number_of_buckets)"
  },
  {
    "label": "internal_find()",
    "kind": "Method",
    "detail": "Function (} previous = where ; } } iterator)",
    "insertText": "internal_find(const key_type& key)"
  },
  {
    "label": "hash_key()",
    "kind": "Method",
    "detail": "Function (sokey_t)",
    "insertText": "hash_key(sokey_t) my_hash_compare(key)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(solist_t::get_order_key(it) == order_key)"
  },
  {
    "label": "internal_erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "internal_erase(const_iterator it)"
  },
  {
    "label": "hash_key()",
    "kind": "Method",
    "detail": "Function (sokey_t)",
    "insertText": "hash_key(sokey_t) my_hash_compare(get_key(*it))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + where ;)",
    "insertText": "if(my_solist.get_iterator(where) == it) return my_solist.erase_node(previous, it)"
  },
  {
    "label": "internal_extract()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_UNORDERED_NODE_HANDLE_PRESENT std::pair<node_type,raw_iterator>)",
    "insertText": "internal_extract(const_iterator it)"
  },
  {
    "label": "sokey_t()",
    "kind": "Method",
    "detail": "Function (sokey_t hash_key =)",
    "insertText": "sokey_t(my_hash_compare(get_key(*it)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + where ;)",
    "insertText": "if(my_solist.get_iterator(where) == it)"
  },
  {
    "label": "erase_node()",
    "kind": "Method",
    "detail": "Function (const_iterator result = it ; my_solist .)",
    "insertText": "erase_node(previous, it, tbb::internal::false_type())"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} } return std::pair<node_type,)",
    "insertText": "iterator(node_type(), end())"
  },
  {
    "label": "internal_equal_range()",
    "kind": "Method",
    "detail": "Function (} # endif pairii_t)",
    "insertText": "internal_equal_range(const key_type& key)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(solist_t::get_order_key(it) == order_key && !my_hash_compare(get_key(*it), key))"
  },
  {
    "label": "get_iterator()",
    "kind": "Method",
    "detail": "Function (iterator first = my_solist .)",
    "insertText": "get_iterator(it)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (iterator last = first ; do + + last ;)",
    "insertText": "while(allow_multimapping && last != end() && !my_hash_compare(get_key(*last), key))"
  },
  {
    "label": "pairii_t()",
    "kind": "Method",
    "detail": "Function (} } return)",
    "insertText": "pairii_t(end(), end())"
  },
  {
    "label": "init_bucket()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "init_bucket(size_type bucket)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(bucket != 0, \"The first bucket must always be initialized\")"
  },
  {
    "label": "get_parent()",
    "kind": "Method",
    "detail": "Function (size_type parent_bucket =)",
    "insertText": "get_parent(bucket)"
  },
  {
    "label": "get_bucket()",
    "kind": "Method",
    "detail": "Function (raw_iterator parent =)",
    "insertText": "get_bucket(parent_bucket)"
  },
  {
    "label": "insert_dummy()",
    "kind": "Method",
    "detail": "Function (raw_iterator dummy_node = my_solist .)",
    "insertText": "insert_dummy(parent, split_order_key_dummy(bucket))"
  },
  {
    "label": "set_bucket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_bucket(bucket, dummy_node)"
  },
  {
    "label": "adjust_table_size()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "adjust_table_size(size_type total_elements, size_type current_size)"
  },
  {
    "label": "compare_and_swap()",
    "kind": "Method",
    "detail": "Function (my_number_of_buckets .)",
    "insertText": "compare_and_swap(2u*current_size, current_size)"
  },
  {
    "label": "get_parent()",
    "kind": "Method",
    "detail": "Function (} } size_type)",
    "insertText": "get_parent(size_type bucket)"
  },
  {
    "label": "__TBB_Log2()",
    "kind": "Method",
    "detail": "Function (size_type msb =)",
    "insertText": "__TBB_Log2((uintptr_t)bucket)"
  },
  {
    "label": "segment_index_of()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "segment_index_of(size_type index)"
  },
  {
    "label": "segment_base()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "segment_base(size_type k)"
  },
  {
    "label": "segment_size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "segment_size(size_type k)"
  },
  {
    "label": "get_bucket()",
    "kind": "Method",
    "detail": "Function (} raw_iterator)",
    "insertText": "get_bucket(size_type bucket)"
  },
  {
    "label": "segment_index_of()",
    "kind": "Method",
    "detail": "Function (size_type segment =)",
    "insertText": "segment_index_of(bucket)"
  },
  {
    "label": "segment_base()",
    "kind": "Method",
    "detail": "Function (bucket - =)",
    "insertText": "segment_base(segment)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_buckets[segment], \"bucket must be in an allocated segment\")"
  },
  {
    "label": "segment_size()",
    "kind": "Method",
    "detail": "Function (size_type sz =)",
    "insertText": "segment_size(segment)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (raw_iterator* new_segment = my_allocator .)",
    "insertText": "allocate(sz)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(static_cast<void*>(new_segment), 0, sz*sizeof(raw_iterator))"
  },
  {
    "label": "is_initialized()",
    "kind": "Method",
    "detail": "Function (} my_buckets [ segment ] [ bucket ] = dummy_head ; } bool)",
    "insertText": "is_initialized(size_type bucket)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (raw_iterator it = my_buckets [ segment ] [ bucket ] ;)",
    "insertText": "return(it.get_node_ptr() != NULL)"
  },
  {
    "label": "split_order_key_regular()",
    "kind": "Method",
    "detail": "Function (} sokey_t)",
    "insertText": "split_order_key_regular(sokey_t order_key)"
  },
  {
    "label": "split_order_key_dummy()",
    "kind": "Method",
    "detail": "Function (} sokey_t)",
    "insertText": "split_order_key_dummy(sokey_t order_key)"
  }
]