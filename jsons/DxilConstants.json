[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "needs",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "needs"
  },
  {
    "label": "MakeDxilVersion()",
    "kind": "Method",
    "detail": "Function (# pragma once # include<stdint . h> namespace hlsl { namespace DXIL { const unsigned kDxilMajor = 1 ; const unsigned kDxilMinor = 8 ; unsigned)",
    "insertText": "MakeDxilVersion(unsigned DxilMajor, unsigned DxilMinor)"
  },
  {
    "label": "GetCurrentDxilVersion()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "GetCurrentDxilVersion()"
  },
  {
    "label": "GetDxilVersionMajor()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "GetDxilVersionMajor(unsigned DxilVersion)"
  },
  {
    "label": "GetDxilVersionMinor()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "GetDxilVersionMinor(unsigned DxilVersion)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (major = newMajor ; minor = newMinor ; return true ; } else)",
    "insertText": "if(newMajor == major)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (minor = newMinor ; return true ; } } return false ; } const unsigned kDisableOptimizations = 0 x00000001 ; const unsigned kDisableMathRefactoring = 0 x00000002 ; const unsigned kEnableDoublePrecision = 0 x00000004 ; const unsigned kForceEarlyDepthStencil = 0 x00000008 ; const unsigned kEnableRawAndStructuredBuffers = 0 x00000010 ; const unsigned kEnableMinPrecision = 0 x00000020 ; const unsigned kEnableDoubleExtensions = 0 x00000040 ; const unsigned kEnableMSAD = 0 x00000080 ; const unsigned kAllResourcesBound = 0 x00000100 ; const unsigned kNumOutputStreams = 4 ; const unsigned kNumClipPlanes = 6 ; const unsigned kMaxTempRegCount = 4 0 9 6 ; const unsigned kMaxCBufferSize = 4 0 9 6 ; const unsigned kMaxStructBufferStride = 2 0 4 8 ; const unsigned kMaxHSOutputControlPointsTotalScalars = 3 9 6 8 ; const unsigned kMaxHSOutputPatchConstantTotalScalars = 3 2* 4 ; const unsigned kMaxSignatureTotalVectors = 3 2 ; const unsigned kMaxOutputTotalScalars = kMaxSignatureTotalVectors* 4 ; const unsigned kMaxInputTotalScalars = kMaxSignatureTotalVectors* 4 ; const unsigned kMaxClipOrCullDistanceElementCount = 2 ; const unsigned kMaxClipOrCullDistanceCount = 2* 4 ; const unsigned kMaxGSOutputVertexCount = 1 0 2 4 ; const unsigned kMaxGSInstanceCount = 3 2 ; const unsigned kMaxIAPatchControlPointCount = 3 2 ; const float kHSMaxTessFactorLowerBound = 1 . 0 f ; const float kHSMaxTessFactorUpperBound = 6 4 . 0 f ; const unsigned kHSDefaultInputControlPointCount = 1 ; const unsigned kMaxCSThreadsPerGroup = 1 0 2 4 ; const unsigned kMaxCSThreadGroupX = 1 0 2 4 ; const unsigned kMaxCSThreadGroupY = 1 0 2 4 ; const unsigned kMaxCSThreadGroupZ = 6 4 ; const unsigned kMinCSThreadGroupX = 1 ; const unsigned kMinCSThreadGroupY = 1 ; const unsigned kMinCSThreadGroupZ = 1 ; const unsigned kMaxCS4XThreadsPerGroup = 7 6 8 ; const unsigned kMaxCS4XThreadGroupX = 7 6 8 ; const unsigned kMaxCS4XThreadGroupY = 7 6 8 ; const unsigned kMaxTGSMSize = 8 1 9 2* 4 ; const unsigned kMaxGSOutputTotalScalars = 1 0 2 4 ; const unsigned kMaxMSASThreadsPerGroup = 1 2 8 ; const unsigned kMaxMSASThreadGroupX = 1 2 8 ; const unsigned kMaxMSASThreadGroupY = 1 2 8 ; const unsigned kMaxMSASThreadGroupZ = 1 2 8 ; const unsigned kMinMSASThreadGroupX = 1 ; const unsigned kMinMSASThreadGroupY = 1 ; const unsigned kMinMSASThreadGroupZ = 1 ; const unsigned kMaxMSASPayloadBytes = 1 0 2 4* 1 6 ; const unsigned kMaxMSOutputPrimitiveCount = 2 5 6 ; const unsigned kMaxMSOutputVertexCount = 2 5 6 ; const unsigned kMaxMSOutputTotalBytes = 1 0 2 4* 3 2 ; const unsigned kMaxMSInputOutputTotalBytes = 1 0 2 4* 4 7 ; const unsigned kMaxMSVSigRows = 3 2 ; const unsigned kMaxMSPSigRows = 3 2 ; const unsigned kMaxMSTotalSigRows = 3 2 ; const unsigned kMaxMSSMSize = 1 0 2 4* 2 8 ; const unsigned kMinWaveSize = 4 ; const unsigned kMaxWaveSize = 1 2 8 ; const float kMaxMipLodBias = 1 5 . 9 9 f ; const float kMinMipLodBias = - 1 6 . 0 f ; const unsigned kResRetStatusIndex = 4 ; enum class ComponentType : uint32_t { Invalid = 0,I1,I16,U16,I32,U32,I64,U64,F16,F32,F64,SNormF16,UNormF16,SNormF32,UNormF32,SNormF64,UNormF64,PackedS8x32,PackedU8x32,LastEntry } ; enum class InterpolationMode : uint8_t { Undefined = 0,Constant = 1,Linear = 2,LinearCentroid = 3,LinearNoperspective = 4,LinearNoperspectiveCentroid = 5,LinearSample = 6,LinearNoperspectiveSample = 7,Invalid = 8 } ; enum class SignatureDataWidth : uint8_t { Undefined = 0,Bits16 = 1 6,Bits32 = 3 2,} ; enum class SignatureKind { Invalid = 0,Input,Output,PatchConstOrPrim,} ; enum class ShaderKind { Pixel = 0,Vertex,Geometry,Hull,Domain,Compute,Library,RayGeneration,Intersection,AnyHit,ClosestHit,Miss,Callable,Mesh,Amplification,Node,Invalid,Last_1_2 = Compute,Last_1_4 = Callable,Last_1_7 = Amplification,Last_1_8 = Node,LastValid = Last_1_8,} ;)",
    "insertText": "static_assert((unsigned)DXIL::ShaderKind::LastValid + 1 == (unsigned)DXIL::ShaderKind::Invalid, \"otherwise, enum needs updating.\")"
  },
  {
    "label": "IsAnyTexture()",
    "kind": "Method",
    "detail": "Function (enum class SemanticKind : unsigned { Arbitrary,VertexID,InstanceID,Position,RenderTargetArrayIndex,ViewPortArrayIndex,ClipDistance,CullDistance,OutputControlPointID,DomainLocation,PrimitiveID,GSInstanceID,SampleIndex,IsFrontFace,Coverage,InnerCoverage,Target,Depth,DepthLessEqual,DepthGreaterEqual,StencilRef,DispatchThreadID,GroupID,GroupIndex,GroupThreadID,TessFactor,InsideTessFactor,ViewID,Barycentrics,ShadingRate,CullPrimitive,StartVertexLocation,StartInstanceLocation,Invalid,} ; enum class SigPointKind : unsigned { VSIn,VSOut,PCIn,HSIn,HSCPIn,HSCPOut,PCOut,DSIn,DSCPIn,DSOut,GSVIn,GSIn,GSOut,PSIn,PSOut,CSIn,MSIn,MSOut,MSPOut,ASIn,Invalid,} ; enum class SemanticInterpretationKind : unsigned { NA,SV,SGV,Arb,NotInSig,NotPacked,Target,TessFactor,Shadow,ClipCull,Invalid,} ; enum class PackingKind : unsigned { None,InputAssembler,Vertex,PatchConstant,Target,Invalid,} ; enum class Float32DenormMode : unsigned { Any = 0,Preserve = 1,FTZ = 2,Reserve3 = 3,Reserve4 = 4,Reserve5 = 5,Reserve6 = 6,Reserve7 = 7,} ; enum class PackingStrategy : unsigned { Default = 0,PrefixStable,Optimized,Invalid,} ; enum class DefaultLinkage : unsigned { Default = 0,Internal = 1,External = 2,} ; enum class SamplerKind : unsigned { Default = 0,Comparison,Mono,Invalid,} ; enum class ResourceClass { SRV = 0,UAV,CBuffer,Sampler,Invalid } ; enum class ResourceKind : unsigned { Invalid = 0,Texture1D,Texture2D,Texture2DMS,Texture3D,TextureCube,Texture1DArray,Texture2DArray,Texture2DMSArray,TextureCubeArray,TypedBuffer,RawBuffer,StructuredBuffer,CBuffer,Sampler,TBuffer,RTAccelerationStructure,FeedbackTexture2D,FeedbackTexture2DArray,NumEntries,} ; bool)",
    "insertText": "IsAnyTexture(DXIL::ResourceKind ResourceKind)"
  },
  {
    "label": "IsAnyTextureCube()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsAnyTextureCube(DXIL::ResourceKind ResourceKind)"
  },
  {
    "label": "IsRawBuffer()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsRawBuffer(DXIL::ResourceKind ResourceKind)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum class QuadOpKind { ReadAcrossX = 0,ReadAcrossY = 1,ReadAcrossDiagonal = 2,} ; enum class WaveBitOpKind : unsigned { And = 0,Or = 1,Xor = 2,} ; enum class WaveOpKind : unsigned { Max = 3,Min = 2,Product = 1,Sum = 0,} ; enum class WaveMultiPrefixOpKind : unsigned { And = 1,Or = 2,Product = 4,Sum = 0,Xor = 3,} ; enum class SignedOpKind : unsigned { Signed = 0,Unsigned = 1,} ; enum class QuadVoteOpKind : unsigned { All = 1,Any = 0,} ; enum class ControlFlowHint : unsigned { Undefined = 0,Branch = 1,Flatten = 2,FastOpt = 3,AllowUavCondition = 4,ForceCase = 5,Call = 6,LastEntry,} ; const uint8_t kCompMask_X = 0 x1 ; const uint8_t kCompMask_Y = 0 x2 ; const uint8_t kCompMask_Z = 0 x4 ; const uint8_t kCompMask_W = 0 x8 ; const uint8_t kCompMask_All = 0 xF ; enum class LowPrecisionMode { Undefined = 0,UseMinPrecision,UseNativeLowPrecision } ; enum class RayFlag : uint32_t { None = 0 x00,ForceOpaque = 0 x01,ForceNonOpaque = 0 x02,AcceptFirstHitAndEndSearch = 0 x04,SkipClosestHitShader = 0 x08,CullBackFacingTriangles = 0 x10,CullFrontFacingTriangles = 0 x20,CullOpaque = 0 x40,CullNonOpaque = 0 x80,SkipTriangles = 0 x100,SkipProceduralPrimitives = 0 x200,} ; enum class UnpackMode : uint8_t { Unsigned = 0,Signed = 1,} ; enum class PackMode : uint8_t { Trunc = 0,UClamp = 1,SClamp = 2,} ; enum class HitKind : uint8_t { None = 0 x00,TriangleFrontFace = 0 xFE,TriangleBackFace = 0 xFF,} ; enum class SamplerFeedbackType : uint8_t { MinMip = 0,MipRegionUsed = 1,LastEntry = 2 } ; enum class WaveMatrixKind : uint8_t { Left = 0,Right = 1,LeftColAcc = 2,RightRowAcc = 3,Accumulator = 4,NumKinds = 5,MaskSide = 1,MaskClass = 6,} ; enum class WaveMatrixScalarOpCode : unsigned { Add = 0,Divide = 3,Invalid = 4,Multiply = 2,Subtract = 1,} ; enum class MemoryTypeFlag : uint32_t { UavMemory = 0 x00000001,GroupSharedMemory = 0 x00000002,NodeInputMemory = 0 x00000004,NodeOutputMemory = 0 x00000008,AllMemory = 0 x0000000F,ValidMask = 0 x0000000F,NodeFlags = NodeInputMemory | NodeOutputMemory,LegacyFlags = UavMemory | GroupSharedMemory,GroupFlags = GroupSharedMemory,} ; enum class BarrierSemanticFlag : uint32_t { GroupSync = 0 x00000001,GroupScope = 0 x00000002,DeviceScope = 0 x00000004,ValidMask = 0 x00000007,GroupFlags = GroupSync | GroupScope,} ; const uint8_t DxilProgramSigMaskX = 1 ; const uint8_t DxilProgramSigMaskY = 2 ; const uint8_t DxilProgramSigMaskZ = 4 ; const uint8_t DxilProgramSigMaskW = 8 ; const uint64_t ShaderFeatureInfo_Doubles = 0 x0001 ; const uint64_t ShaderFeatureInfo_ComputeShadersPlusRawAndStructuredBuffersViaShader4X = 0 x0002 ; const uint64_t ShaderFeatureInfo_UAVsAtEveryStage = 0 x0004 ; const uint64_t ShaderFeatureInfo_64UAVs = 0 x0008 ; const uint64_t ShaderFeatureInfo_MinimumPrecision = 0 x0010 ; const uint64_t ShaderFeatureInfo_11_1_DoubleExtensions = 0 x0020 ; const uint64_t ShaderFeatureInfo_11_1_ShaderExtensions = 0 x0040 ; const uint64_t ShaderFeatureInfo_LEVEL9ComparisonFiltering = 0 x0080 ; const uint64_t ShaderFeatureInfo_TiledResources = 0 x0100 ; const uint64_t ShaderFeatureInfo_StencilRef = 0 x0200 ; const uint64_t ShaderFeatureInfo_InnerCoverage = 0 x0400 ; const uint64_t ShaderFeatureInfo_TypedUAVLoadAdditionalFormats = 0 x0800 ; const uint64_t ShaderFeatureInfo_ROVs = 0 x1000 ; const uint64_t ShaderFeatureInfo_ViewportAndRTArrayIndexFromAnyShaderFeedingRasterizer = 0 x2000 ; const uint64_t ShaderFeatureInfo_WaveOps = 0 x4000 ; const uint64_t ShaderFeatureInfo_Int64Ops = 0 x8000 ; const uint64_t ShaderFeatureInfo_ViewID = 0 x10000 ; const uint64_t ShaderFeatureInfo_Barycentrics = 0 x20000 ; const uint64_t ShaderFeatureInfo_NativeLowPrecision = 0 x40000 ; const uint64_t ShaderFeatureInfo_ShadingRate = 0 x80000 ; const uint64_t ShaderFeatureInfo_Raytracing_Tier_1_1 = 0 x100000 ; const uint64_t ShaderFeatureInfo_SamplerFeedback = 0 x200000 ; const uint64_t ShaderFeatureInfo_AtomicInt64OnTypedResource = 0 x400000 ; const uint64_t ShaderFeatureInfo_AtomicInt64OnGroupShared = 0 x800000 ; const uint64_t ShaderFeatureInfo_DerivativesInMeshAndAmpShaders = 0 x1000000 ; const uint64_t ShaderFeatureInfo_ResourceDescriptorHeapIndexing = 0 x2000000 ; const uint64_t ShaderFeatureInfo_SamplerDescriptorHeapIndexing = 0 x4000000 ; const uint64_t ShaderFeatureInfo_AtomicInt64OnHeapResource = 0 x10000000 ; const uint64_t ShaderFeatureInfo_AdvancedTextureOps = 0 x20000000 ; const uint64_t ShaderFeatureInfo_WriteableMSAATextures = 0 x40000000 ; const uint64_t ShaderFeatureInfo_SampleCmpGradientOrBias = 0 x80000000 ; const uint64_t ShaderFeatureInfo_ExtendedCommandInfo = 0 x100000000 ; const uint64_t ShaderFeatureInfo_WaveMMA = 0 x8000000 ; const unsigned ShaderFeatureInfoCount = 3 3 ;)",
    "insertText": "static_assert(ShaderFeatureInfoCount <= 40, \"ShaderFeatureInfo flags must fit within the first 40 bits; \" \"after that we need to expand the FeatureInfo blob part and \" \"start defining a new set of flags for ShaderFeatureInfo2.\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (const uint64_t OptFeatureInfo_UsesDerivatives = 0 x0000010000000000ULL ; const uint64_t OptFeatureInfo_RequiresGroup = 0 x0000020000000000ULL ; const uint64_t OptFeatureInfoShift = 4 0 ; const unsigned OptFeatureInfoCount = 2 ;)",
    "insertText": "static_assert(OptFeatureInfoCount <= 23, \"OptFeatureInfo flags must fit in 23 bits; after that we need to \" \"expand the FeatureInfo blob part and start defining a new set \" \"of flags for OptFeatureInfo2.\")"
  },
  {
    "label": "IsValidSubobjectKind()",
    "kind": "Method",
    "detail": "Function (enum class SubobjectKind : uint32_t { StateObjectConfig = 0,GlobalRootSignature = 1,LocalRootSignature = 2,SubobjectToExportsAssociation = 8,RaytracingShaderConfig = 9,RaytracingPipelineConfig = 1 0,HitGroup = 1 1,RaytracingPipelineConfig1 = 1 2,NumKinds } ; bool)",
    "insertText": "IsValidSubobjectKind(SubobjectKind kind)"
  },
  {
    "label": "IsValidHitGroupType()",
    "kind": "Method",
    "detail": "Function (} enum class StateObjectFlags : uint32_t { AllowLocalDependenciesOnExternalDefinitions = 0 x1,AllowExternalDependenciesOnLocalDefinitions = 0 x2,AllowStateObjectAdditions = 0 x4,ValidMask_1_4 = 0 x3,ValidMask = 0 x7,} ; enum class HitGroupType : uint32_t { Triangle = 0 x0,ProceduralPrimitive = 0 x1,LastEntry,} ; enum class RaytracingPipelineFlags : uint32_t { None = 0 x0,SkipTriangles = 0 x100,SkipProceduralPrimitives = 0 x200,ValidMask = 0 x300,} ; enum class CommittedStatus : uint32_t { CommittedNothing = 0,CommittedTriangleHit = 1,CommittedProceduralPrimitiveHit = 2,} ; enum class CandidateType : uint32_t { CandidateNonOpaqueTriangle = 0,CandidateProceduralPrimitive = 1,} ; enum class PayloadAccessQualifier : uint32_t { NoAccess = 0,Read = 1,Write = 2,ReadWrite = 3 } ; enum class PayloadAccessShaderStage : uint32_t { Caller = 0,Closesthit = 1,Miss = 2,Anyhit = 3,Invalid = 0 xffffffffu } ; const uint32_t PayloadAccessQualifierBitsPerStage = 4 ; const uint32_t PayloadAccessQualifierValidMaskPerStage = 3 ; const uint32_t PayloadAccessQualifierValidMask = 0 x00003333 ; bool)",
    "insertText": "IsValidHitGroupType(HitGroupType type)"
  }
]