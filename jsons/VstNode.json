[
  {
    "label": "Node",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Node"
  },
  {
    "label": "CAstNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CAstNode"
  },
  {
    "label": "LocusDistanceResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LocusDistanceResult"
  },
  {
    "label": "FTile",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTile"
  },
  {
    "label": "Clause",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Clause"
  },
  {
    "label": "Snippet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Snippet"
  },
  {
    "label": "Identifier",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Identifier"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "NodeInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NodeInfo"
  },
  {
    "label": "VERSECOMPILER_API",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VERSECOMPILER_API"
  },
  {
    "label": "VisitPolicy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VisitPolicy"
  },
  {
    "label": "Type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Type"
  },
  {
    "label": "FVstContains_Visitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVstContains_Visitor"
  },
  {
    "label": "uLang",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "uLang"
  },
  {
    "label": "SChildParent",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SChildParent"
  },
  {
    "label": "CAtom",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CAtom"
  },
  {
    "label": "Comment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Comment"
  },
  {
    "label": "Module",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Module"
  },
  {
    "label": "Package",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Package"
  },
  {
    "label": "Project",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Project"
  },
  {
    "label": "Definition",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Definition"
  },
  {
    "label": "Assignment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Assignment"
  },
  {
    "label": "FlowIf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FlowIf"
  },
  {
    "label": "BinaryOpLogicalOr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BinaryOpLogicalOr"
  },
  {
    "label": "BinaryOpLogicalAnd",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BinaryOpLogicalAnd"
  },
  {
    "label": "PrefixOpLogicalNot",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PrefixOpLogicalNot"
  },
  {
    "label": "BinaryOpCompare",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BinaryOpCompare"
  },
  {
    "label": "Where",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Where"
  },
  {
    "label": "Mutation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Mutation"
  },
  {
    "label": "TypeSpec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TypeSpec"
  },
  {
    "label": "Operator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Operator"
  },
  {
    "label": "BinaryOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BinaryOp"
  },
  {
    "label": "BinaryOpAddSub",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BinaryOpAddSub"
  },
  {
    "label": "BinaryOpMulDivInfix",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BinaryOpMulDivInfix"
  },
  {
    "label": "BinaryOpRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BinaryOpRange"
  },
  {
    "label": "BinaryOpArrow",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BinaryOpArrow"
  },
  {
    "label": "PrePostCall",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PrePostCall"
  },
  {
    "label": "Op",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Op"
  },
  {
    "label": "IntLiteral",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IntLiteral"
  },
  {
    "label": "FloatLiteral",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FloatLiteral"
  },
  {
    "label": "CharLiteral",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CharLiteral"
  },
  {
    "label": "StringLiteral",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StringLiteral"
  },
  {
    "label": "PathLiteral",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PathLiteral"
  },
  {
    "label": "InterpolatedString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InterpolatedString"
  },
  {
    "label": "Lambda",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Lambda"
  },
  {
    "label": "Control",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Control"
  },
  {
    "label": "Macro",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Macro"
  },
  {
    "label": "Parens",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Parens"
  },
  {
    "label": "Commas",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Commas"
  },
  {
    "label": "Placeholder",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Placeholder"
  },
  {
    "label": "ParseError",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ParseError"
  },
  {
    "label": "Escape",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Escape"
  },
  {
    "label": "SPathToNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SPathToNode"
  },
  {
    "label": "NullWhence()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" uLang / Common / Algo / Cases . h \" # include \" uLang / Common / Containers / Array . h \" # include \" uLang / Common / Containers / RangeView . h \" # include \" uLang / Common / Containers / SharedPointer . h \" # include \" uLang / Common / Containers / SharedPointerArray . h \" # include \" uLang / Common / Misc / EnumUtils . h \" # include \" uLang / Common / Misc / Optional . h \" # include \" uLang / Common / Text / TextRange . h \" # include \" uLang / Common / Text / UTF8String . h \" # include \" uLang / Common / Text / UTF8StringBuilder . h \" # include \" uLang / Common / Text / UTF8StringView . h \" # include \" uLang / SourceProject / PackageRole . h \" # include \" uLang / SourceProject / UploadedAtFNVersion . h \" # include \" uLang / SourceProject / VerseScope . h \" # include \" uLang / Syntax / NodeDecls . inl \" namespace Verse { namespace Vst { struct Node ; } } namespace uLang { class CAstNode ; struct LocusDistanceResult { TSRef<Verse::Vst::Node> Node ; int32_t Distance ; } ; } namespace Verse { class FTile ; using string = uLang::CUTF8String ; using CUTF8String = uLang::CUTF8String ; using CUTF8StringView = uLang::CUTF8StringView ; using CUTF8StringBuilder = uLang::CUTF8StringBuilder ; using ChType = uLang::UTF8Char ; template<T> using TSPtr = uLang::TSPtr<T> ; template<T> using TSRef = uLang::TSRef<T> ; template<T> using LArray = uLang::TArray<T> ; using EResult = uLang::EResult ; using CSharedMix = uLang::CSharedMix ; using SLocus = uLang::STextRange ; using SPosition = uLang::STextPosition ; using EVerseScope = uLang::EVerseScope ; ULANG_FORCEINLINE SLocus)",
    "insertText": "NullWhence()"
  },
  {
    "label": "VISIT_VSTNODE()",
    "kind": "Method",
    "detail": "Function (} namespace Vst { struct Clause ; struct Snippet ; struct Identifier ; enum class EChildDeletionBehavior : uint8_t { CreatePlaceholder,Delete,Default } ; enum class ESupportsManyChildren : uint8_t { Anywhere,TrailingOnly,Nowhere } ; # define)",
    "insertText": "VISIT_VSTNODE(NodeName, RequiredChildren, SupportsManyChildren, Precedence, ChildDeletionBehavior)"
  },
  {
    "label": "VERSE_ENUM_VSTNODES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VERSE_ENUM_VSTNODES(VISIT_VSTNODE)"
  },
  {
    "label": "VISIT_VSTNODE()",
    "kind": "Method",
    "detail": "Function (# undef VISIT_VSTNODE # define)",
    "insertText": "VISIT_VSTNODE(NodeName, RequiredChildren, Precedence, SupportsManyChildren, ChildDeletionBehavior)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (# undef VISIT_VSTNODE uint8_t NumNodeTypes = static_cast<)",
    "insertText": "uint8_t(ULANG_COUNTOF(NodeInfos))"
  },
  {
    "label": "GetNodeTypeName()",
    "kind": "Method",
    "detail": "Function (const uint8_t TagNone = 2 5 5 ; ULANG_FORCEINLINE const char*)",
    "insertText": "GetNodeTypeName(const NodeType TypeOfNode)"
  },
  {
    "label": "GetNumRequiredChildren()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE int32_t)",
    "insertText": "GetNumRequiredChildren(const NodeType TypeOfNode)"
  },
  {
    "label": "GetOperatorPrecedence()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE int32_t)",
    "insertText": "GetOperatorPrecedence(const NodeType TypeOfNode)"
  },
  {
    "label": "GetSupportsManyChildren()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE ESupportsManyChildren)",
    "insertText": "GetSupportsManyChildren(const NodeType TypeOfNode)"
  },
  {
    "label": "GetChildDeletionBehavior()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE EChildDeletionBehavior)",
    "insertText": "GetChildDeletionBehavior(const NodeType TypeOfNode)"
  },
  {
    "label": "Node()",
    "kind": "Method",
    "detail": "Function (} struct Node : public CSharedMix { using NodeArray = LArray<TSRef<Node>> ;)",
    "insertText": "Node() : _Children() , _Parent(nullptr) , _Aux() , _PreComments() , _PostComments() , _NumNewLinesBefore(0) , _NumNewLinesAfter(0) , _Tag(0) , _Type(static_cast<NodeType>(0)) , _MappedAstNode(nullptr) , _Tile(nullptr)"
  },
  {
    "label": "Node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Node(NodeType in_type) : Node()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (_Type = in_type ;)",
    "insertText": "ULANG_ASSERTF(in_type == NodeType::Project || in_type == NodeType::Package || in_type == NodeType::Module || in_type == NodeType::Snippet, \"Invalid use of locus-free Node constructor for node type that requires a locus\")"
  },
  {
    "label": "Node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Node(NodeType in_type, const SLocus& whence) : Node()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (_Type = in_type ; _Whence = whence ;)",
    "insertText": "ULANG_ASSERTF(_Whence.IsValid(), \"Node created with invalid locus\")"
  },
  {
    "label": "Node()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "Node()"
  },
  {
    "label": "CombineLocii()",
    "kind": "Method",
    "detail": "Function (SLocus)",
    "insertText": "CombineLocii(const NodeArray& Nodes)"
  },
  {
    "label": "Whence()",
    "kind": "Method",
    "detail": "Function (SLocus Whence = Nodes [ 0 ] ->)",
    "insertText": "Whence()"
  },
  {
    "label": "SLocus()",
    "kind": "Method",
    "detail": "Function (} return Whence ; } return)",
    "insertText": "SLocus()"
  },
  {
    "label": "AsShared()",
    "kind": "Method",
    "detail": "Function (} TSRef<Node>)",
    "insertText": "AsShared()"
  },
  {
    "label": "As()",
    "kind": "Method",
    "detail": "Function (} template<TNodeType> TNodeType&)",
    "insertText": "As()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(IsA<TNodeType>(), \"Vst Node is type `%s` not of expected type `%s` so cannot cast!\", NodeInfos[GetElementTypeInt()].FormalName, NodeInfos[static_cast<int32_t>(TNodeType::StaticType)].FormalName)"
  },
  {
    "label": "AsNullable()",
    "kind": "Method",
    "detail": "Function (} template<TNodeType> TNodeType*)",
    "insertText": "AsNullable()"
  },
  {
    "label": "IsA()",
    "kind": "Method",
    "detail": "Function (} template<TNodeType> bool)",
    "insertText": "IsA()"
  },
  {
    "label": "GetChildCount()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetChildCount()"
  },
  {
    "label": "GetElementType()",
    "kind": "Method",
    "detail": "Function (} NodeType)",
    "insertText": "GetElementType()"
  },
  {
    "label": "GetTag()",
    "kind": "Method",
    "detail": "Function (} template<OpType> OpType)",
    "insertText": "GetTag()"
  },
  {
    "label": "SetTag()",
    "kind": "Method",
    "detail": "Function (} template<OpType = uint8_t> void)",
    "insertText": "SetTag(OpType in_op)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (_Tag = static_cast<)",
    "insertText": "uint8_t(in_op)"
  },
  {
    "label": "HasAttributes()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasAttributes()"
  },
  {
    "label": "GetAttributeIdentifier()",
    "kind": "Method",
    "detail": "Function (const Identifier*)",
    "insertText": "GetAttributeIdentifier(const CUTF8StringView& AttributeName)"
  },
  {
    "label": "IsAttributePresent()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAttributePresent(const CUTF8StringView& AttributeName)"
  },
  {
    "label": "TryGetFirstAttributeOfType()",
    "kind": "Method",
    "detail": "Function (const Node*)",
    "insertText": "TryGetFirstAttributeOfType(NodeType Type)"
  },
  {
    "label": "TryGetFirstAttributeOfType()",
    "kind": "Method",
    "detail": "Function (template<TNodeType> const TNodeType*)",
    "insertText": "TryGetFirstAttributeOfType()"
  },
  {
    "label": "TryGetFirstAttributeOfType()",
    "kind": "Method",
    "detail": "Function (const Node* Result =)",
    "insertText": "TryGetFirstAttributeOfType(TNodeType::StaticType)"
  },
  {
    "label": "PrependAux()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } void)",
    "insertText": "PrependAux(const TSRef<Node>& AuxChild)"
  },
  {
    "label": "PrependAux()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrependAux(const NodeArray& AuxChildren)"
  },
  {
    "label": "AppendAux()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendAux(const TSRef<Node>& AuxChild)"
  },
  {
    "label": "AppendAux()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendAux(const NodeArray& AuxChildren)"
  },
  {
    "label": "AppendAuxAt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendAuxAt(const TSRef<Node>& AuxChild, int32_t Idx)"
  },
  {
    "label": "GetAux()",
    "kind": "Method",
    "detail": "Function (const TSPtr<Clause>&)",
    "insertText": "GetAux()"
  },
  {
    "label": "RemoveAux()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAux()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (_Aux .)",
    "insertText": "Reset()"
  },
  {
    "label": "AppendPrefixComment()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendPrefixComment(const TSRef<Node>& CommentNode)"
  },
  {
    "label": "AppendPrefixComments()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendPrefixComments(const NodeArray& CommentNodes)"
  },
  {
    "label": "AppendPostfixComment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendPostfixComment(const TSRef<Node>& CommentNode)"
  },
  {
    "label": "AppendPostfixComments()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendPostfixComments(const NodeArray& CommentNodes)"
  },
  {
    "label": "GetPrefixComments()",
    "kind": "Method",
    "detail": "Function (const NodeArray&)",
    "insertText": "GetPrefixComments()"
  },
  {
    "label": "CombineWhenceWith()",
    "kind": "Method",
    "detail": "Function (_Whence = Whence ; } void)",
    "insertText": "CombineWhenceWith(const SLocus& Whence)"
  },
  {
    "label": "FindSnippetByFilePath()",
    "kind": "Method",
    "detail": "Function (const Snippet*)",
    "insertText": "FindSnippetByFilePath(const CUTF8StringView& FilePath)"
  },
  {
    "label": "FindChildByPosition()",
    "kind": "Method",
    "detail": "Function (const Node*)",
    "insertText": "FindChildByPosition(const SPosition& TextPosition)"
  },
  {
    "label": "FindChildClosestToPosition()",
    "kind": "Method",
    "detail": "Function (const TSRef<Node>)",
    "insertText": "FindChildClosestToPosition(const SPosition& TextPosition, const CUTF8StringView& SourceText)"
  },
  {
    "label": "VisitWith()",
    "kind": "Method",
    "detail": "Function (template<class VisitPolicy,ReturnType = void> void)",
    "insertText": "VisitWith(const TSRef<Vst::Node>& node, VisitPolicy& visit_policy)"
  },
  {
    "label": "GetElementInfo()",
    "kind": "Method",
    "detail": "Function (const NodeInfo&)",
    "insertText": "GetElementInfo()"
  },
  {
    "label": "GetElementName()",
    "kind": "Method",
    "detail": "Function (} const ChType*)",
    "insertText": "GetElementName()"
  },
  {
    "label": "GetPrecedence()",
    "kind": "Method",
    "detail": "Function (} int32_t)",
    "insertText": "GetPrecedence()"
  },
  {
    "label": "NumRequiredChildren()",
    "kind": "Method",
    "detail": "Function (} int32_t)",
    "insertText": "NumRequiredChildren()"
  },
  {
    "label": "IsManyChildrenSupported()",
    "kind": "Method",
    "detail": "Function (} ESupportsManyChildren)",
    "insertText": "IsManyChildrenSupported()"
  },
  {
    "label": "NumNewLinesBefore()",
    "kind": "Method",
    "detail": "Function (} int32_t)",
    "insertText": "NumNewLinesBefore()"
  },
  {
    "label": "NumNewLinesAfter()",
    "kind": "Method",
    "detail": "Function (_NumNewLinesBefore = Num ; } int32_t)",
    "insertText": "NumNewLinesAfter()"
  },
  {
    "label": "SetNewLineAfter()",
    "kind": "Method",
    "detail": "Function (_NumNewLinesAfter = Num ; } void)",
    "insertText": "SetNewLineAfter(const bool bNewLineAfter)"
  },
  {
    "label": "SetNumNewLinesAfter()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "SetNumNewLinesAfter(0)"
  },
  {
    "label": "HasNewLineAfter()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "HasNewLineAfter()"
  },
  {
    "label": "GetChildren()",
    "kind": "Method",
    "detail": "Function (} const NodeArray&)",
    "insertText": "GetChildren()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (Child -> _Parent = nullptr ; } return)",
    "insertText": "Move(_Children)"
  },
  {
    "label": "GetRightmostChild()",
    "kind": "Method",
    "detail": "Function (} TSPtr<Node>)",
    "insertText": "GetRightmostChild()"
  },
  {
    "label": "AccessParent()",
    "kind": "Method",
    "detail": "Function (} Node*)",
    "insertText": "AccessParent()"
  },
  {
    "label": "GetSharedSelf()",
    "kind": "Method",
    "detail": "Function (} TSRef<Node>)",
    "insertText": "GetSharedSelf()"
  },
  {
    "label": "GetParent()",
    "kind": "Method",
    "detail": "Function (} const Node*)",
    "insertText": "GetParent()"
  },
  {
    "label": "GetParentOfType()",
    "kind": "Method",
    "detail": "Function (} template<class Type> const Type*)",
    "insertText": "GetParentOfType()"
  },
  {
    "label": "IsElementType()",
    "kind": "Method",
    "detail": "Function (} } return nullptr ; } bool)",
    "insertText": "IsElementType(NodeType InType)"
  },
  {
    "label": "IsError()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsError()"
  },
  {
    "label": "DebugOrphanCheck()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DebugOrphanCheck()"
  },
  {
    "label": "FindOrphanedNode()",
    "kind": "Method",
    "detail": "Function (# ifdef _DEBUG const Node* OrphanedNode =)",
    "insertText": "FindOrphanedNode(*this)"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(!OrphanedNode, \"An orphaned node was encountered!\")"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (# endif } bool)",
    "insertText": "Contains(const Node& Target, const bool bRecursive = true)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (struct FVstContains_Visitor { bool)",
    "insertText": "Contains(const TSRef<Node>& Root, const Node& RecursiveTarget)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bRecursiveContains = false ;)",
    "insertText": "for(const TSPtr<Node> Child : Root->AccessChildren())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bRecursiveContains = true ; } else)",
    "insertText": "if(Child.IsValid())"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (bRecursiveContains =)",
    "insertText": "Contains(Child.AsRef(), RecursiveTarget)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bRecursiveContains)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (break ; } } return bRecursiveContains ; } } ; bool bContains = false ;)",
    "insertText": "for(const TSRef<Node>& Child : _Children)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bContains = true ; } else)",
    "insertText": "if(bRecursive)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (bContains =)",
    "insertText": "Contains(Child, Target)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bContains)"
  },
  {
    "label": "FindPreviousSibling()",
    "kind": "Method",
    "detail": "Function (break ; } } return bContains ; } int32_t)",
    "insertText": "FindPreviousSibling()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const TSRef<Node>& CurNode = Children [ Index ] ;)",
    "insertText": "if(CurNode == this)"
  },
  {
    "label": "DropParent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DropParent(child)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (child -> _Parent = this ; _Children .)",
    "insertText": "Push(child)"
  },
  {
    "label": "AppendChildAt()",
    "kind": "Method",
    "detail": "Function (} const TSRef<Node>&)",
    "insertText": "AppendChildAt(const TSRef<Node>& child, int32_t idx)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (child -> _Parent = this ; _Children .)",
    "insertText": "Insert(child, idx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const auto ChildAtIdx = _Children [ idx ] ;)",
    "insertText": "if(Replacement.IsValid())"
  },
  {
    "label": "AsRef()",
    "kind": "Method",
    "detail": "Function (Replacement -> _Parent = this ; _Children [ idx ] = Replacement .)",
    "insertText": "AsRef()"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (} else { _Children .)",
    "insertText": "RemoveAt(idx)"
  },
  {
    "label": "AppendChildren()",
    "kind": "Method",
    "detail": "Function (} ChildAtIdx -> _Parent = nullptr ; return ChildAtIdx ; } void)",
    "insertText": "AppendChildren(const uLang::TArray<TSRef<Node>>& Children, int32_t NumToAppend = -1)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (NumToAppend = NumToAppend = = - 1 ? Children .)",
    "insertText": "Num()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (_Children .)",
    "insertText": "Reserve(_Children.Num() + NumToAppend)"
  },
  {
    "label": "AppendChild()",
    "kind": "Method",
    "detail": "Function (const auto& Expr = Children [ i ] ;)",
    "insertText": "AppendChild(Expr)"
  },
  {
    "label": "AppendChildren()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "AppendChildren(const uLang::TSRefArray<Node>& Children, int32_t NumToAppend = -1)"
  },
  {
    "label": "PrependChildren()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "PrependChildren(const uLang::TArray<TSRef<Node>>& Children, int32_t NumToAppend = -1)"
  },
  {
    "label": "AppendChildAt()",
    "kind": "Method",
    "detail": "Function (const auto& Expr = Children [ i ] ;)",
    "insertText": "AppendChildAt(Expr, 0)"
  },
  {
    "label": "ReplaceSelfWith()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ReplaceSelfWith(const TSRef<Node>& replacement)"
  },
  {
    "label": "RemoveFromParent()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemoveFromParent(int32_t idx = uLang::IndexNone)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "FindSnippet()",
    "kind": "Method",
    "detail": "Function (} const Snippet*)",
    "insertText": "FindSnippet()"
  },
  {
    "label": "FindRoot()",
    "kind": "Method",
    "detail": "Function (} Node*)",
    "insertText": "FindRoot()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Node* root = this ;)",
    "insertText": "while(root->_Parent != nullptr && root->_Parent->GetElementType() != NodeType::Snippet)"
  },
  {
    "label": "TransferChildren()",
    "kind": "Method",
    "detail": "Function (} return root ; } void)",
    "insertText": "TransferChildren(const TSRef<Node>& From, const TSRef<Node>& To, int32_t First, int32_t Last)"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(Last <= From->GetChildCount() - 1, \"Not enough elements in source array\")"
  },
  {
    "label": "AccessChildren()",
    "kind": "Method",
    "detail": "Function (To ->)",
    "insertText": "AccessChildren().Reserve(To->GetChildCount() + Last - First + 1)"
  },
  {
    "label": "AppendChild()",
    "kind": "Method",
    "detail": "Function (CurChild -> _Parent = nullptr ; To ->)",
    "insertText": "AppendChild(CurChild)"
  },
  {
    "label": "AccessChildren()",
    "kind": "Method",
    "detail": "Function (} From ->)",
    "insertText": "AccessChildren().RemoveAt(First, Last - First + 1)"
  },
  {
    "label": "TransferChildren()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TransferChildren(const TSRef<Node>& From, const TSRef<Node>& To)"
  },
  {
    "label": "TransferChildren()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TransferChildren(From, To, 0, From->GetChildCount() - 1)"
  },
  {
    "label": "TransferPrefixComments()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TransferPrefixComments(const TSRef<Node>& From, const TSRef<Node>& To)"
  },
  {
    "label": "AccessPrefixComments()",
    "kind": "Method",
    "detail": "Function (NodeArray& ToPrefixComments = To ->)",
    "insertText": "AccessPrefixComments()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (ToPrefixComments .)",
    "insertText": "Reserve(ToPrefixComments.Num() + FromPrefixComments.Num())"
  },
  {
    "label": "AppendPrefixComment()",
    "kind": "Method",
    "detail": "Function (FromPrefixComment -> _Parent = nullptr ; To ->)",
    "insertText": "AppendPrefixComment(FromPrefixComment)"
  },
  {
    "label": "TransferPostfixComments()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TransferPostfixComments(const TSRef<Node>& From, const TSRef<Node>& To)"
  },
  {
    "label": "AccessPostfixComments()",
    "kind": "Method",
    "detail": "Function (NodeArray& ToPostfixComments = To ->)",
    "insertText": "AccessPostfixComments()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (ToPostfixComments .)",
    "insertText": "Reserve(ToPostfixComments.Num() + FromPostfixComments.Num())"
  },
  {
    "label": "AppendPostfixComment()",
    "kind": "Method",
    "detail": "Function (FromPostfixComment -> _Parent = nullptr ; To ->)",
    "insertText": "AppendPostfixComment(FromPostfixComment)"
  },
  {
    "label": "GetMappedAstNode()",
    "kind": "Method",
    "detail": "Function (} const uLang::CAstNode*)",
    "insertText": "GetMappedAstNode()"
  },
  {
    "label": "RemoveMapping()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveMapping(uLang::CAstNode* AstNode)"
  },
  {
    "label": "EnsureAuxAllocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnsureAuxAllocated()"
  },
  {
    "label": "SetTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTile(FTile* Tile)"
  },
  {
    "label": "GetTile()",
    "kind": "Method",
    "detail": "Function (_Tile = Tile ; } FTile*)",
    "insertText": "GetTile()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (struct SChildParent { const Node* _Child ; const Node* _Parent ; } ; LArray<SChildParent> Stack ; Stack .)",
    "insertText": "Reserve(256)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Stack .)",
    "insertText": "Add({CurChild.Get(), &InNode})"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(!Stack.IsEmpty())"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (const SChildParent& CurPair = Stack .)",
    "insertText": "Pop()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Stack .)",
    "insertText": "Add({CurChild, CurPair._Child})"
  },
  {
    "label": "DropParent()",
    "kind": "Method",
    "detail": "Function (} } return nullptr ; } ; void)",
    "insertText": "DropParent(const TSRef<Node>& Child)"
  },
  {
    "label": "AccessParent()",
    "kind": "Method",
    "detail": "Function (} else { Child ->)",
    "insertText": "AccessParent()->AccessChildren().Remove(Child)"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (Child -> _Parent = nullptr ; } } void)",
    "insertText": "AppendChildInternal(const TSRef<Node>& child)"
  },
  {
    "label": "ULANG_VERIFYF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_VERIFYF(FindOrphanedNode(*this) == nullptr, \"Found orphaned child!\")"
  },
  {
    "label": "Clause()",
    "kind": "Method",
    "detail": "Function (} NodeArray _Children ; Node* _Parent ; TSPtr<Clause> _Aux ; NodeArray _PreComments ; NodeArray _PostComments ; SLocus _Whence ; int32_t _NumNewLinesBefore ; int32_t _NumNewLinesAfter ; uint8_t _Tag ; NodeType _Type ; const uLang::CAstNode* _MappedAstNode ; FTile* _Tile ; } ; using NodeArray = Node::NodeArray ; struct Clause : public Node { const Vst::NodeType StaticType = NodeType::Clause ; enum class EForm : int8_t { Synthetic,NoSemicolonOrNewline,HasSemicolonOrNewline,IsPrependAttributeHolder,IsAppendAttributeHolder } ; enum class EPunctuation : int8_t { Unknown,Braces,Colon,Indentation } ;)",
    "insertText": "Clause(const SLocus& Whence, const EForm Form, const EPunctuation Punctuation) : Node(StaticType, Whence), _Form(Form), _Punctuation(Punctuation)"
  },
  {
    "label": "Clause()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Clause(const SLocus& Whence, const EForm Form) : Node(StaticType, Whence), _Form(Form), _Punctuation(EPunctuation::Unknown)"
  },
  {
    "label": "Clause()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Clause(uint8_t ClauseType, const SLocus& Whence, EForm Form) : Node(StaticType, Whence), _Form(Form), _Punctuation(EPunctuation::Unknown)"
  },
  {
    "label": "Clause()",
    "kind": "Method",
    "detail": "Function (_Tag = ClauseType ; })",
    "insertText": "Clause(const TSRef<Node>& Child, const SLocus& Whence, EForm Form) : Clause(0, Whence, Form)"
  },
  {
    "label": "AppendChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChild(Child)"
  },
  {
    "label": "Clause()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Clause(const NodeArray& Children, const SLocus& Whence, EForm Form) : Clause(0, Whence, Form)"
  },
  {
    "label": "AppendChildren()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildren(Children)"
  },
  {
    "label": "Clause()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Clause(const uLang::TSRefArray<Node>& Children, const SLocus& Whence, EForm Form) : Clause(0, Whence, Form)"
  },
  {
    "label": "Clause()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Clause(const NodeArray& Children, int32_t NumToAdd, const SLocus& Whence, EForm Form) : Clause(0, Whence, Form)"
  },
  {
    "label": "AppendChildren()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildren(Children, NumToAdd)"
  },
  {
    "label": "Clause()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Clause(const uLang::TSRefArray<Node>& Children, int32_t NumToAdd, const SLocus& Whence, EForm Form) : Clause(0, Whence, Form)"
  },
  {
    "label": "GetForm()",
    "kind": "Method",
    "detail": "Function (} EForm)",
    "insertText": "GetForm()"
  },
  {
    "label": "GetPunctuation()",
    "kind": "Method",
    "detail": "Function (this -> _Form = InForm ; } EPunctuation)",
    "insertText": "GetPunctuation()"
  },
  {
    "label": "MakeStub()",
    "kind": "Method",
    "detail": "Function (this -> _Punctuation = InPunctuation ; } private : EForm _Form ; EPunctuation _Punctuation ; } ; const TSRef<Node>)",
    "insertText": "MakeStub(const SLocus& Whence)"
  },
  {
    "label": "CAtom()",
    "kind": "Method",
    "detail": "Function (class CAtom : public Node { public : CUTF8String _OriginalCode ;)",
    "insertText": "CAtom(const uLang::CUTF8StringView& CodeStr, NodeType InType, const SLocus& Whence) : Node(InType, Whence), _OriginalCode(CodeStr)"
  },
  {
    "label": "GetStringValue()",
    "kind": "Method",
    "detail": "Function (} const string&)",
    "insertText": "GetStringValue()"
  },
  {
    "label": "Comment()",
    "kind": "Method",
    "detail": "Function (} } ; struct Comment : public CAtom { enum class EType : uint8_t { block,line,ind,frag } ; const Vst::NodeType StaticType = NodeType::Comment ;)",
    "insertText": "Comment(EType Type, const CUTF8StringView& InText, const SLocus& Whence) : CAtom(InText, StaticType, Whence), _Type(Type)"
  },
  {
    "label": "CommentTypeToString()",
    "kind": "Method",
    "detail": "Function (} EType _Type ; } ; const char*)",
    "insertText": "CommentTypeToString(Comment::EType Type)"
  },
  {
    "label": "Snippet()",
    "kind": "Method",
    "detail": "Function (struct Snippet : public Node { const Vst::NodeType StaticType = NodeType::Snippet ;)",
    "insertText": "Snippet() : Node(StaticType)"
  },
  {
    "label": "Snippet()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Snippet(const CUTF8StringView& Path) : Node(StaticType), _Path(Path)"
  },
  {
    "label": "Snippet()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Snippet(const CUTF8StringView& Path, const TSRef<Vst::Node>& FirstChild) : Node(StaticType, FirstChild->Whence()), _Path(Path)"
  },
  {
    "label": "AppendChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChild(FirstChild)"
  },
  {
    "label": "Snippet()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Snippet(const TSRef<Vst::Node>& FirstChild) : Node(StaticType, FirstChild->Whence())"
  },
  {
    "label": "HasErrors()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasErrors()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bHasErrors = false ;)",
    "insertText": "for(const TSRef<Node>& Node : _Children)"
  },
  {
    "label": "Module()",
    "kind": "Method",
    "detail": "Function (_Form = Form ; } CUTF8String _Path ; private : Clause::EForm _Form { Clause::EForm::Synthetic } ; } ; struct Module : public Node { const Vst::NodeType StaticType = NodeType::Module ;)",
    "insertText": "Module(const CUTF8StringView& Name) : Node(StaticType), _Name(Name)"
  },
  {
    "label": "Package()",
    "kind": "Method",
    "detail": "Function (} CUTF8String _Name ; CUTF8String _FilePath ; } ; struct Package : public Node { const Vst::NodeType StaticType = NodeType::Package ;)",
    "insertText": "Package(const CUTF8StringView& Name) : Node(StaticType), _Name(Name)"
  },
  {
    "label": "FindOrAddModule()",
    "kind": "Method",
    "detail": "Function (} CUTF8String _Name ; CUTF8String _DirPath ; CUTF8String _FilePath ; CUTF8String _VersePath ; LArray<CUTF8String> _DependencyPackages ; uLang::TOptional<CUTF8String> _VniDestDir ; uLang::EPackageRole _Role = uLang::EPackageRole::Source ; EVerseScope _VerseScope = EVerseScope::PublicUser ; uLang::TOptional<uint32_t> _VerseVersion ; uint32_t _UploadedAtFNVersion = VerseFN::UploadedAtFNVersion::Latest ; bool _bTreatModulesAsImplicit = false ; bool _bAllowExperimental = false ; TSRef<Module>)",
    "insertText": "FindOrAddModule(const CUTF8StringView& ModuleName, const CUTF8StringView& ParentModuleName = CUTF8StringView())"
  },
  {
    "label": "FindModule()",
    "kind": "Method",
    "detail": "Function (uLang::TOptional<TSRef<Module>>)",
    "insertText": "FindModule(const Node& ModuleContainer, const CUTF8StringView& ModuleName)"
  },
  {
    "label": "Project()",
    "kind": "Method",
    "detail": "Function (} ; struct Project : public Node { const Vst::NodeType StaticType = NodeType::Project ;)",
    "insertText": "Project(const CUTF8StringView& Name) : Node(StaticType), _Name(Name)"
  },
  {
    "label": "FindOrAddModule()",
    "kind": "Method",
    "detail": "Function (} CUTF8String _Name ; CUTF8String _FilePath ; const TSRef<Module>&)",
    "insertText": "FindOrAddModule(const CUTF8StringView& ModuleName, const CUTF8StringView& FilePath, const CUTF8StringView& ParentModuleName = CUTF8StringView())"
  },
  {
    "label": "RemovePackagesWithName()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemovePackagesWithName(const CUTF8StringView& PackageName)"
  },
  {
    "label": "AccessChildren()",
    "kind": "Method",
    "detail": "Function (NodeArray& Children = this ->)",
    "insertText": "AccessChildren()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TSRef<Node> CurChild = Children [ Index ] ;)",
    "insertText": "if(!CurChild->IsA<Package>())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(CurChild->As<Package>()._Name == PackageName)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "RemoveAt(Index)"
  },
  {
    "label": "ReplaceSnippet()",
    "kind": "Method",
    "detail": "Function (+ + NumPackagesRemoved ; } } return NumPackagesRemoved> 0 ; } bool)",
    "insertText": "ReplaceSnippet(const CUTF8StringView& PathOfOldSnippetToReplace, TSRef<Snippet> NewSnippet, TSPtr<Snippet>* OutOldSnippet = nullptr)"
  },
  {
    "label": "Package()",
    "kind": "Method",
    "detail": "Function (Package& CurPackage = CurChild -> As<)",
    "insertText": "Package()"
  },
  {
    "label": "Module()",
    "kind": "Method",
    "detail": "Function (Module& CurModule = CurPkgChild -> As<)",
    "insertText": "Module()"
  },
  {
    "label": "Snippet()",
    "kind": "Method",
    "detail": "Function (Snippet& CurSnippet = CurModuleChild -> As<)",
    "insertText": "Snippet()"
  },
  {
    "label": "ReplaceSelfWith()",
    "kind": "Method",
    "detail": "Function (} CurSnippet .)",
    "insertText": "ReplaceSelfWith(NewSnippet)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (_Children .)",
    "insertText": "Reserve(2)"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildInternal(Lhs)"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildInternal(Rhs)"
  },
  {
    "label": "GetOperandLeft()",
    "kind": "Method",
    "detail": "Function (} const TSRef<Vst::Node>&)",
    "insertText": "GetOperandLeft()"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildInternal(lhs)"
  },
  {
    "label": "SetTag()",
    "kind": "Method",
    "detail": "Function (rhs ->)",
    "insertText": "SetTag(static_cast<uint8_t>(InOp))"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildInternal(rhs)"
  },
  {
    "label": "FlowIf()",
    "kind": "Method",
    "detail": "Function (} ; } struct FlowIf : public Node { const Vst::NodeType StaticType = NodeType::FlowIf ; enum class ClauseTag : uint8_t { if_identifier,condition,then_body,else_body } ;)",
    "insertText": "FlowIf(const SLocus& Whence) : Node(StaticType, Whence)"
  },
  {
    "label": "AddIfIdentifier()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddIfIdentifier(const TSRef<Node>& Child)"
  },
  {
    "label": "SetTag()",
    "kind": "Method",
    "detail": "Function (Child ->)",
    "insertText": "SetTag(static_cast<uint8_t>(ClauseTag::if_identifier))"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildInternal(Child)"
  },
  {
    "label": "AddCondition()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddCondition(const TSRef<Node>& Child)"
  },
  {
    "label": "SetTag()",
    "kind": "Method",
    "detail": "Function (Child ->)",
    "insertText": "SetTag(static_cast<uint8_t>(ClauseTag::condition))"
  },
  {
    "label": "AddBody()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddBody(const TSRef<Node>& Child)"
  },
  {
    "label": "SetTag()",
    "kind": "Method",
    "detail": "Function (Child ->)",
    "insertText": "SetTag(static_cast<uint8_t>(ClauseTag::then_body))"
  },
  {
    "label": "AddElseBody()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddElseBody(const TSRef<Node>& Child)"
  },
  {
    "label": "SetTag()",
    "kind": "Method",
    "detail": "Function (Child ->)",
    "insertText": "SetTag(static_cast<uint8_t>(ClauseTag::else_body))"
  },
  {
    "label": "BinaryOpLogicalOr()",
    "kind": "Method",
    "detail": "Function (} } ; struct BinaryOpLogicalOr : public Node { const Vst::NodeType StaticType = NodeType::BinaryOpLogicalOr ;)",
    "insertText": "BinaryOpLogicalOr(const SLocus& Whence, const TSRef<Vst::Node>& Lhs, const TSRef<Vst::Node>& Rhs) : Node(StaticType, Whence)"
  },
  {
    "label": "AppendChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChild(Lhs)"
  },
  {
    "label": "AppendChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChild(Rhs)"
  },
  {
    "label": "AppendChild()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendChild(const TSRef<Vst::Node>& Rhs)"
  },
  {
    "label": "BinaryOpLogicalAnd()",
    "kind": "Method",
    "detail": "Function (} } ; struct BinaryOpLogicalAnd : public Node { const Vst::NodeType StaticType = NodeType::BinaryOpLogicalAnd ;)",
    "insertText": "BinaryOpLogicalAnd(const SLocus& Whence, const TSRef<Node>& Lhs, const TSRef<Node>& Rhs) : Node(StaticType, Whence)"
  },
  {
    "label": "PrefixOpLogicalNot()",
    "kind": "Method",
    "detail": "Function (} } ; struct PrefixOpLogicalNot : public Node { const Vst::NodeType StaticType = NodeType::PrefixOpLogicalNot ;)",
    "insertText": "PrefixOpLogicalNot(const SLocus& Whence, const TSRef<Node>& Rhs) : Node(StaticType, Whence)"
  },
  {
    "label": "GetInnerNode()",
    "kind": "Method",
    "detail": "Function (} const TSRef<Vst::Node>&)",
    "insertText": "GetInnerNode()"
  },
  {
    "label": "SetTag()",
    "kind": "Method",
    "detail": "Function (rhs ->)",
    "insertText": "SetTag(static_cast<uint8_t>(in_op))"
  },
  {
    "label": "BinaryCompareOpAsCString()",
    "kind": "Method",
    "detail": "Function (} } ; const char*)",
    "insertText": "BinaryCompareOpAsCString(BinaryOpCompare::op Op)"
  },
  {
    "label": "BinaryCompareOpFlip()",
    "kind": "Method",
    "detail": "Function (} ; } BinaryOpCompare::op)",
    "insertText": "BinaryCompareOpFlip(BinaryOpCompare::op Op)"
  },
  {
    "label": "Where()",
    "kind": "Method",
    "detail": "Function (} } struct Where : Node { const NodeType StaticType = NodeType::Where ; using RhsView = uLang::TRangeView<const TSRef<Node>*,const TSRef<Node>*> ;)",
    "insertText": "Where(const SLocus& Whence, const TSRef<Node>& Lhs, const uLang::TArray<TSRef<Node>>& RhsArray) : Node(StaticType, Whence)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (_Children .)",
    "insertText": "Reserve(1 + RhsArray.Num())"
  },
  {
    "label": "Where()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "Where(const SLocus& Whence, const TSRef<Node>& Lhs, const uLang::TSRefArray<Node>& RhsArray) : Node(StaticType, Whence)"
  },
  {
    "label": "GetLhs()",
    "kind": "Method",
    "detail": "Function (} } TSRef<Node>)",
    "insertText": "GetLhs()"
  },
  {
    "label": "Mutation()",
    "kind": "Method",
    "detail": "Function (} } ; struct Mutation : Node { const NodeType StaticType = NodeType::Mutation ; enum class EKeyword : uint8_t { Var,Set } ;)",
    "insertText": "Mutation(const SLocus& Whence, const TSRef<Node>& Child, EKeyword Keyword) : Node(StaticType, Whence) , _Keyword(Keyword)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (_Children .)",
    "insertText": "Reserve(1)"
  },
  {
    "label": "Child()",
    "kind": "Method",
    "detail": "Function (} TSRef<Node>)",
    "insertText": "Child()"
  },
  {
    "label": "TypeSpec()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TypeSpec(const SLocus& Whence, const TSRef<Node>& Rhs) :Node(NodeType::TypeSpec, Whence)"
  },
  {
    "label": "HasLhs()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasLhs()"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(HasLhs(), \"Lhs assumes we have at least two children.\")"
  },
  {
    "label": "GetRhs()",
    "kind": "Method",
    "detail": "Function (} TSRef<Vst::Node>)",
    "insertText": "GetRhs()"
  },
  {
    "label": "TakeRhs()",
    "kind": "Method",
    "detail": "Function (} TSRef<Vst::Node>)",
    "insertText": "TakeRhs()"
  },
  {
    "label": "Identifier()",
    "kind": "Method",
    "detail": "Function (} } ; struct Identifier : public CAtom { const Vst::NodeType StaticType = NodeType::Identifier ; NodeArray _QualifierPostComments ; NodeArray _QualifierPreComments ;)",
    "insertText": "Identifier(const CUTF8StringView& InName, const SLocus& Whence) : CAtom(InName, StaticType, Whence)"
  },
  {
    "label": "IsQualified()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsQualified()"
  },
  {
    "label": "GetQualification()",
    "kind": "Method",
    "detail": "Function (} const TSRef<Node>&)",
    "insertText": "GetQualification()"
  },
  {
    "label": "BinaryOp()",
    "kind": "Method",
    "detail": "Function (} } ; struct BinaryOp : public Node { enum class op : uint8_t { Operator,Operand } ;)",
    "insertText": "BinaryOp(const SLocus& Whence, Vst::NodeType NodeType) : Node(NodeType, Whence)"
  },
  {
    "label": "BinaryOp()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BinaryOp(const SLocus& Whence, const TSRef<Node>& LhsOperand, Vst::NodeType NodeType) : Node(NodeType, Whence)"
  },
  {
    "label": "SetTag()",
    "kind": "Method",
    "detail": "Function (LhsOperand ->)",
    "insertText": "SetTag((uint8_t)op::Operand)"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildInternal(LhsOperand)"
  },
  {
    "label": "AppendChild()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendChild(op in_op, const TSRef<Node> in_child)"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildInternal(in_child)"
  },
  {
    "label": "AppendOperation_Internal()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "AppendOperation_Internal(const TSRef<Node>& InOperator, const TSRef<Node>& Operand)"
  },
  {
    "label": "SetTag()",
    "kind": "Method",
    "detail": "Function (InOperator ->)",
    "insertText": "SetTag((uint8_t)op::Operator)"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildInternal(InOperator)"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildInternal(Operand)"
  },
  {
    "label": "BinaryOpAddSub()",
    "kind": "Method",
    "detail": "Function (} } ; struct BinaryOpAddSub : public BinaryOp { const Vst::NodeType StaticType = NodeType::BinaryOpAddSub ;)",
    "insertText": "BinaryOpAddSub(const SLocus& Whence) : BinaryOp(Whence, StaticType)"
  },
  {
    "label": "BinaryOpAddSub()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BinaryOpAddSub(const SLocus& Whence, const TSRef<Node>& LhsOperand) : BinaryOp(Whence, LhsOperand, StaticType)"
  },
  {
    "label": "AppendAddOperation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendAddOperation(const SLocus& AddWhence, const TSRef<Node>& RhsOperand)"
  },
  {
    "label": "AppendSubOperation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendSubOperation(const SLocus& SubWhence, const TSRef<Node>& RhsOperand)"
  },
  {
    "label": "BinaryOpMulDivInfix()",
    "kind": "Method",
    "detail": "Function (} ; struct BinaryOpMulDivInfix : public BinaryOp { const Vst::NodeType StaticType = NodeType::BinaryOpMulDivInfix ;)",
    "insertText": "BinaryOpMulDivInfix(const SLocus& Whence) : BinaryOp(Whence, StaticType)"
  },
  {
    "label": "BinaryOpMulDivInfix()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BinaryOpMulDivInfix(const SLocus& Whence, const TSRef<Node>& LhsOperand) : BinaryOp(Whence, LhsOperand, StaticType)"
  },
  {
    "label": "AppendInfixOperation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendInfixOperation(const TSRef<Identifier>& OpIdentifier, const TSRef<Node>& RhsOperand)"
  },
  {
    "label": "AppendOperation_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendOperation_Internal(OpIdentifier, RhsOperand)"
  },
  {
    "label": "AppendMulOperation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendMulOperation(const SLocus& MulWhence, const TSRef<Node>& RhsOperand)"
  },
  {
    "label": "AppendDivOperation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendDivOperation(const SLocus& DivWhence, const TSRef<Node>& RhsOperand)"
  },
  {
    "label": "BinaryOpRange()",
    "kind": "Method",
    "detail": "Function (} ; struct BinaryOpRange : public Node { const Vst::NodeType StaticType = NodeType::BinaryOpRange ;)",
    "insertText": "BinaryOpRange(const SLocus& Whence, const TSRef<Node>& Lhs, const TSRef<Node>& Rhs) : Node(StaticType, Whence)"
  },
  {
    "label": "BinaryOpArrow()",
    "kind": "Method",
    "detail": "Function (} } ; struct BinaryOpArrow : public Node { const Vst::NodeType StaticType = NodeType::BinaryOpArrow ;)",
    "insertText": "BinaryOpArrow(const SLocus& Whence, const TSRef<Node>& Lhs, const TSRef<Node>& Rhs) : Node(StaticType, Whence)"
  },
  {
    "label": "PrePostCall()",
    "kind": "Method",
    "detail": "Function (} } ; struct PrePostCall : public Node { const Vst::NodeType StaticType = NodeType::PrePostCall ; enum Op { Expression,Option,Pointer,DotIdentifier,SureCall,FailCall } ;)",
    "insertText": "PrePostCall(const TSRef<Node>& FirstChild, const SLocus& Whence) : Node(StaticType, Whence)"
  },
  {
    "label": "PrePostCall()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PrePostCall(const SLocus& Whence) : Node(StaticType, Whence)"
  },
  {
    "label": "IsSimpleCall()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSimpleCall()"
  },
  {
    "label": "IsPostHat()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsPostHat()"
  },
  {
    "label": "PrependQMark()",
    "kind": "Method",
    "detail": "Function (} TSRef<Clause>)",
    "insertText": "PrependQMark(const SLocus& Whence)"
  },
  {
    "label": "PrependHat()",
    "kind": "Method",
    "detail": "Function (TSRef<Clause>)",
    "insertText": "PrependHat(const SLocus& Whence)"
  },
  {
    "label": "PrependCallArgs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrependCallArgs(bool bCanFail, const TSRef<Clause>& Args)"
  },
  {
    "label": "AppendQMark()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendQMark(const SLocus& Whence)"
  },
  {
    "label": "AppendHat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendHat(const SLocus& Whence)"
  },
  {
    "label": "AppendCallArgs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendCallArgs(bool bCanFail, const TSRef<Clause>& Args)"
  },
  {
    "label": "AppendDotIdent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendDotIdent(const SLocus& Whence, const TSRef<Identifier>& Ident)"
  },
  {
    "label": "TakeLastArgs()",
    "kind": "Method",
    "detail": "Function (TSPtr<Clause>)",
    "insertText": "TakeLastArgs()"
  },
  {
    "label": "IntLiteral()",
    "kind": "Method",
    "detail": "Function (} ; struct IntLiteral : public CAtom { const Vst::NodeType StaticType = NodeType::IntLiteral ;)",
    "insertText": "IntLiteral(const CUTF8StringView& InSourceText, const SLocus& Whence) : CAtom(InSourceText, StaticType, Whence)"
  },
  {
    "label": "FloatLiteral()",
    "kind": "Method",
    "detail": "Function (} } ; struct FloatLiteral : public CAtom { const Vst::NodeType StaticType = NodeType::FloatLiteral ; enum class EFormat { Unspecified,F16,F32,F64 } ; EFormat _Format ;)",
    "insertText": "FloatLiteral(const CUTF8StringView& InSourceText, EFormat Format, const SLocus& Whence) : CAtom(InSourceText, StaticType, Whence) , _Format(Format)"
  },
  {
    "label": "CharLiteral()",
    "kind": "Method",
    "detail": "Function (} } ; struct CharLiteral : public CAtom { const Vst::NodeType StaticType = NodeType::CharLiteral ; enum class EFormat { UTF8CodeUnit,UnicodeCodePoint } ; EFormat _Format ;)",
    "insertText": "CharLiteral(const CUTF8StringView& InSourceText, EFormat Format, const SLocus& Whence) : CAtom(InSourceText, StaticType, Whence) , _Format(Format)"
  },
  {
    "label": "StringLiteral()",
    "kind": "Method",
    "detail": "Function (} } ; struct StringLiteral : public CAtom { const Vst::NodeType StaticType = NodeType::StringLiteral ;)",
    "insertText": "StringLiteral(const SLocus& Whence, const CUTF8StringView& SyntaxSource) : CAtom(SyntaxSource, StaticType, Whence)"
  },
  {
    "label": "PathLiteral()",
    "kind": "Method",
    "detail": "Function (} } ; struct PathLiteral : public CAtom { const Vst::NodeType StaticType = NodeType::PathLiteral ;)",
    "insertText": "PathLiteral(const CUTF8StringView& InPath, const SLocus& Whence) : CAtom(InPath, StaticType, Whence)"
  },
  {
    "label": "InterpolatedString()",
    "kind": "Method",
    "detail": "Function (} } ; struct InterpolatedString : public CAtom { const Vst::NodeType StaticType = NodeType::InterpolatedString ;)",
    "insertText": "InterpolatedString(const SLocus& Whence, const CUTF8StringView& SyntaxSource) : CAtom(SyntaxSource, StaticType, Whence)"
  },
  {
    "label": "Lambda()",
    "kind": "Method",
    "detail": "Function (} } ; struct Lambda : public Node { const Vst::NodeType StaticType = NodeType::Lambda ;)",
    "insertText": "Lambda(const SLocus& Whence, const TSRef<Node>& Domain, const TSRef<Node>& Range) : Node(StaticType, Whence)"
  },
  {
    "label": "AppendChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChild(Domain)"
  },
  {
    "label": "AppendChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChild(Range)"
  },
  {
    "label": "GetDomain()",
    "kind": "Method",
    "detail": "Function (} const TSRef<Node>&)",
    "insertText": "GetDomain()"
  },
  {
    "label": "Control()",
    "kind": "Method",
    "detail": "Function (} } ; struct Control : public Node { const Vst::NodeType StaticType = NodeType::Control ; enum class EKeyword : uint8_t { Return,Break,Yield,Continue } ;)",
    "insertText": "Control(const SLocus& Whence, Control::EKeyword Keyword) : Node(StaticType, Whence), _Keyword(Keyword)"
  },
  {
    "label": "Control()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Control(const TSRef<Node>& Child, const SLocus& Whence, EKeyword Keyword) : Control(Whence, Keyword)"
  },
  {
    "label": "GetReturnExpression()",
    "kind": "Method",
    "detail": "Function (} const TSRef<Vst::Node>&)",
    "insertText": "GetReturnExpression()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (_Children .)",
    "insertText": "Empty(InChildren.Num() + 1)"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildInternal(MacroName)"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (} } const TSRef<Vst::Node>&)",
    "insertText": "GetName()"
  },
  {
    "label": "GetClause()",
    "kind": "Method",
    "detail": "Function (} const TSRef<Vst::Clause>&)",
    "insertText": "GetClause(int32_t ClauseIndex)"
  },
  {
    "label": "TakeClause()",
    "kind": "Method",
    "detail": "Function (} TSRef<Clause>)",
    "insertText": "TakeClause(int32_t ClauseIndex, const TSPtr<Node> Replacement = TSPtr<Clause>())"
  },
  {
    "label": "Parens()",
    "kind": "Method",
    "detail": "Function (} } ; struct Parens : public Node { const Vst::NodeType StaticType = NodeType::Parens ;)",
    "insertText": "Parens(SLocus Whence, Clause::EForm Form, const NodeArray& InChildren = {}) : Node(StaticType, Whence), _Form(Form)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (_Children .)",
    "insertText": "Reserve(InChildren.Num())"
  },
  {
    "label": "Parens()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "Parens(SLocus Whence, Clause::EForm Form, const uLang::TSRefArray<Node>& InChildren) : Node(StaticType, Whence), _Form(Form)"
  },
  {
    "label": "AppendChildren()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildren(InChildren)"
  },
  {
    "label": "Placeholder()",
    "kind": "Method",
    "detail": "Function (} } ; struct Placeholder : public CAtom { const Vst::NodeType StaticType = NodeType::Placeholder ;)",
    "insertText": "Placeholder(const SLocus& Whence) : CAtom(\"\", StaticType, Whence)"
  },
  {
    "label": "Placeholder()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "Placeholder(const uLang::CUTF8StringView& CodeStr, const SLocus& Whence) : CAtom(CodeStr, StaticType, Whence)"
  },
  {
    "label": "ParseError()",
    "kind": "Method",
    "detail": "Function (} ; } ; struct ParseError : public Node { public : const Vst::NodeType StaticType = NodeType::ParseError ;)",
    "insertText": "ParseError(const char* Error, const SLocus& Whence) : Node(NodeType::ParseError, Whence) , _Error(Error)"
  },
  {
    "label": "GetError()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "GetError()"
  },
  {
    "label": "AppendChildInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendChildInternal(InnerError)"
  },
  {
    "label": "Escape()",
    "kind": "Method",
    "detail": "Function (} private : const char* _Error ; } ; struct Escape : public Node { const Vst::NodeType StaticType = NodeType::Escape ;)",
    "insertText": "Escape(const SLocus& Whence, const TSRef<Node>& Child) : Node(StaticType, Whence)"
  },
  {
    "label": "VISIT_VSTNODE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "VISIT_VSTNODE(NodeName, RequiredChildren, SupportsManyChildren, Precedence, ChildDeletionBehavior) \\ case Vst::NodeType::NodeName: \\ return visit_policy.visit(node->As<Vst::NodeName>())"
  },
  {
    "label": "VERSE_ENUM_VSTNODES()",
    "kind": "Method",
    "detail": "Function (\\ break ;)",
    "insertText": "VERSE_ENUM_VSTNODES(VISIT_VSTNODE) #undef VISIT_VSTNODE default: return ReturnType()"
  },
  {
    "label": "VISIT_VSTNODE()",
    "kind": "Method",
    "detail": "Function (break ; } } # define)",
    "insertText": "VISIT_VSTNODE(NodeName, RequiredChildren, SupportsManyChildren, Precedence, ChildDeletionBehavior) static_assert(NodeName::StaticType == NodeType::NodeName, #NodeName \"::StaticType must be Vst::NodeType::\" #NodeName)"
  },
  {
    "label": "ULANG_ENUM_BIT_FLAGS()",
    "kind": "Method",
    "detail": "Function (LArray<int32_t> Path ; LArray<int32_t> AuxPath ; int32_t PreCommentIndex ; int32_t PostCommentIndex ; } ; enum class EPrettyPrintBehaviour : uint32_t { Default = 0,NewlinesAfterDefinitions = 1<<0,NewlinesAfterAttributes = 1<<1,NewlinesBetweenModuleMembers = 1<<2,UseVerticalFormForEnumerations = 1<<3 } ;)",
    "insertText": "ULANG_ENUM_BIT_FLAGS(EPrettyPrintBehaviour, inline)"
  },
  {
    "label": "VstAsCodeSourceAppend()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VstAsCodeSourceAppend(const TSRef<Vst::Node>& VstNode, CUTF8StringBuilder& Source)"
  },
  {
    "label": "VstAsCodeSourceAppend()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VstAsCodeSourceAppend(const TSRef<Vst::Node>& VstNode, const EPrettyPrintBehaviour Flags, CUTF8StringBuilder& Source)"
  },
  {
    "label": "VstAsCodeSourceAppend()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VstAsCodeSourceAppend(const TSRef<Vst::PrePostCall>& VstNode, CUTF8StringBuilder& OutSource, int32_t FirstChildIndex, int32_t LastChildIndex)"
  },
  {
    "label": "VstAsCodeSourceAppend()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VstAsCodeSourceAppend(const TSRef<Vst::Clause>& VstClause, CUTF8StringBuilder& OutSource, int32_t InitialIndent, CUTF8String const& Separator)"
  },
  {
    "label": "PrettyPrintVst()",
    "kind": "Method",
    "detail": "Function (ULANG_FORCEINLINE CUTF8String)",
    "insertText": "PrettyPrintVst(const TSRef<Vst::Node>& VstNode)"
  },
  {
    "label": "VstAsCodeSourceAppend()",
    "kind": "Method",
    "detail": "Function (CUTF8StringBuilder Source ;)",
    "insertText": "VstAsCodeSourceAppend(VstNode, Source)"
  },
  {
    "label": "PrettyPrintVst()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE CUTF8String)",
    "insertText": "PrettyPrintVst(const TSRef<Vst::Node>& VstNode, const EPrettyPrintBehaviour Flags)"
  },
  {
    "label": "VstAsCodeSourceAppend()",
    "kind": "Method",
    "detail": "Function (CUTF8StringBuilder Source ;)",
    "insertText": "VstAsCodeSourceAppend(VstNode, Flags, Source)"
  },
  {
    "label": "PrettyPrintVst()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE CUTF8String)",
    "insertText": "PrettyPrintVst(const TSRef<Vst::PrePostCall>& VstNode, int32_t FirstChildIndex, int32_t LastChildIndex)"
  },
  {
    "label": "VstAsCodeSourceAppend()",
    "kind": "Method",
    "detail": "Function (CUTF8StringBuilder Source ;)",
    "insertText": "VstAsCodeSourceAppend(VstNode, Source, FirstChildIndex, LastChildIndex)"
  },
  {
    "label": "PrettyPrintClause()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE CUTF8String)",
    "insertText": "PrettyPrintClause(const TSRef<Vst::Clause>& VstClause, int32_t InitialIndent, CUTF8String const& Separator)"
  },
  {
    "label": "VstAsCodeSourceAppend()",
    "kind": "Method",
    "detail": "Function (CUTF8StringBuilder OutSource ;)",
    "insertText": "VstAsCodeSourceAppend(VstClause, OutSource, InitialIndent, Separator)"
  },
  {
    "label": "GeneratePathToNode()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GeneratePathToNode(const TSRef<Vst::Node>& Node, const TSRef<Vst::Snippet>& VstSnippet, SPathToNode& PathToNode)"
  },
  {
    "label": "GetNodeFromPath()",
    "kind": "Method",
    "detail": "Function (TSPtr<Vst::Node>)",
    "insertText": "GetNodeFromPath(const TSRef<Vst::Snippet>& VstSnippet, const SPathToNode& Path, bool bReturnParent=false)"
  },
  {
    "label": "GetSignedDistanceBetweenPositionAndLocus()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "GetSignedDistanceBetweenPositionAndLocus(const SLocus& A, const SPosition& B, const CUTF8StringView& SourceText)"
  }
]