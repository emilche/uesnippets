[
  {
    "label": "DecisionLogic",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DecisionLogic"
  },
  {
    "label": "CngState",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "CngState"
  },
  {
    "label": "Config",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Config"
  },
  {
    "label": "DecisionLogic()",
    "kind": "Method",
    "detail": "Function (# ifndef MODULES_AUDIO_CODING_NETEQ_DECISION_LOGIC_H_ # define MODULES_AUDIO_CODING_NETEQ_DECISION_LOGIC_H_ # include<memory> # include \" api / neteq / neteq . h \" # include \" api / neteq / neteq_controller . h \" # include \" api / neteq / tick_timer . h \" # include \" modules / audio_coding / neteq / buffer_level_filter . h \" # include \" modules / audio_coding / neteq / delay_manager . h \" # include \" modules / audio_coding / neteq / packet_arrival_history . h \" # include \" rtc_base / experiments / field_trial_parser . h \" namespace webrtc { class DecisionLogic : public NetEqController { public :)",
    "insertText": "DecisionLogic(NetEqController::Config config)"
  },
  {
    "label": "DecisionLogic()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecisionLogic(NetEqController::Config config, std::unique_ptr<DelayManager> delay_manager, std::unique_ptr<BufferLevelFilter> buffer_level_filter)"
  },
  {
    "label": "DecisionLogic()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "DecisionLogic()"
  },
  {
    "label": "DecisionLogic()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecisionLogic(const DecisionLogic&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (DecisionLogic&)",
    "insertText": "operator(const DecisionLogic&)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "SoftReset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SoftReset()"
  },
  {
    "label": "SetSampleRate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSampleRate(int fs_hz, size_t output_size_samples)"
  },
  {
    "label": "GetDecision()",
    "kind": "Method",
    "detail": "Function (NetEq::Operation)",
    "insertText": "GetDecision(const NetEqController::NetEqStatus& status, bool* reset_decoder)"
  },
  {
    "label": "CngRfc3389On()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CngRfc3389On()"
  },
  {
    "label": "ExpandDecision()",
    "kind": "Method",
    "detail": "Function (cng_state_ = kCngOff ; } void)",
    "insertText": "ExpandDecision(NetEq::Operation operation)"
  },
  {
    "label": "AddSampleMemory()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddSampleMemory(int32_t value)"
  },
  {
    "label": "TargetLevelMs()",
    "kind": "Method",
    "detail": "Function (sample_memory_ + = value ; } int)",
    "insertText": "TargetLevelMs()"
  },
  {
    "label": "UnlimitedTargetLevelMs()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "UnlimitedTargetLevelMs()"
  },
  {
    "label": "PacketArrived()",
    "kind": "Method",
    "detail": "Function (absl::optional<int>)",
    "insertText": "PacketArrived(int fs_hz, bool should_update_stats, const PacketArrivedInfo& info)"
  },
  {
    "label": "RegisterEmptyPacket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterEmptyPacket()"
  },
  {
    "label": "NotifyMutedState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "NotifyMutedState()"
  },
  {
    "label": "SetMaximumDelay()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SetMaximumDelay(int delay_ms)"
  },
  {
    "label": "SetMinimumDelay()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "SetMinimumDelay(int delay_ms)"
  },
  {
    "label": "SetBaseMinimumDelay()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "SetBaseMinimumDelay(int delay_ms)"
  },
  {
    "label": "GetBaseMinimumDelay()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetBaseMinimumDelay()"
  },
  {
    "label": "PeakFound()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "PeakFound()"
  },
  {
    "label": "set_sample_memory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_sample_memory(int32_t value)"
  },
  {
    "label": "noise_fast_forward()",
    "kind": "Method",
    "detail": "Function (sample_memory_ = value ; } size_t)",
    "insertText": "noise_fast_forward()"
  },
  {
    "label": "set_prev_time_scale()",
    "kind": "Method",
    "detail": "Function (packet_length_samples_ = value ; } void)",
    "insertText": "set_prev_time_scale(bool value)"
  },
  {
    "label": "FilterBufferLevel()",
    "kind": "Method",
    "detail": "Function (prev_time_scale_ = value ; } private : const int kMinTimescaleInterval = 5 ; enum CngState { kCngOff,kCngRfc3389On,kCngInternalOn } ; void)",
    "insertText": "FilterBufferLevel(size_t buffer_size_samples)"
  },
  {
    "label": "CngOperation()",
    "kind": "Method",
    "detail": "Function (NetEq::Operation)",
    "insertText": "CngOperation(NetEqController::NetEqStatus status)"
  },
  {
    "label": "NoPacket()",
    "kind": "Method",
    "detail": "Function (NetEq::Operation)",
    "insertText": "NoPacket(NetEqController::NetEqStatus status)"
  },
  {
    "label": "ExpectedPacketAvailable()",
    "kind": "Method",
    "detail": "Function (NetEq::Operation)",
    "insertText": "ExpectedPacketAvailable(NetEqController::NetEqStatus status)"
  },
  {
    "label": "FuturePacketAvailable()",
    "kind": "Method",
    "detail": "Function (NetEq::Operation)",
    "insertText": "FuturePacketAvailable(NetEqController::NetEqStatus status)"
  },
  {
    "label": "TimescaleAllowed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TimescaleAllowed()"
  },
  {
    "label": "UnderTargetLevel()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "UnderTargetLevel()"
  },
  {
    "label": "ReinitAfterExpands()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReinitAfterExpands(uint32_t timestamp_leap)"
  },
  {
    "label": "PacketTooEarly()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PacketTooEarly(uint32_t timestamp_leap)"
  },
  {
    "label": "MaxWaitForPacket()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MaxWaitForPacket()"
  },
  {
    "label": "ShouldContinueExpand()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldContinueExpand(NetEqController::NetEqStatus status)"
  },
  {
    "label": "GetNextPacketDelayMs()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetNextPacketDelayMs(NetEqController::NetEqStatus status)"
  },
  {
    "label": "GetPlayoutDelayMs()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetPlayoutDelayMs(NetEqController::NetEqStatus status)"
  },
  {
    "label": "LowThreshold()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "LowThreshold()"
  },
  {
    "label": "HighThreshold()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "HighThreshold()"
  },
  {
    "label": "LowThresholdCng()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "LowThresholdCng()"
  },
  {
    "label": "HighThresholdCng()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "HighThresholdCng()"
  },
  {
    "label": "Config()",
    "kind": "Method",
    "detail": "Function (struct Config {)",
    "insertText": "Config()"
  }
]