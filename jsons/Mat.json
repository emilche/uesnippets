[
  {
    "label": "Mat",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mat"
  },
  {
    "label": "SIZE_",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "SIZE_"
  },
  {
    "label": "Quat",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Quat"
  },
  {
    "label": "Vec3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Vec3"
  },
  {
    "label": "MatType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MatType"
  },
  {
    "label": "Mat()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_MAT_HAS_BEEN_INCLUDED # define OPENVDB_MATH_MAT_HAS_BEEN_INCLUDED # include \" Math . h \" # include<openvdb / Exceptions . h> # include<algorithm> # include<cmath> # include<iostream> # include<string> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { template<unsigned SIZE,T> class Mat { public : using value_type = T ; using ValueType = T ; enum SIZE_ { size = SIZE } ; # if OPENVDB_ABI_VERSION_NUMBER> = 8)",
    "insertText": "Mat()"
  },
  {
    "label": "Mat()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Mat(Mat const &src)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (mm [ i ] = src . mm [ i ] ; } } Mat&)",
    "insertText": "operator(Mat const& src)"
  },
  {
    "label": "numRows()",
    "kind": "Method",
    "detail": "Function (mm [ i ] = src . mm [ i ] ; } } return* this ; } # endif unsigned)",
    "insertText": "numRows()"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (std::string ret ; std::string indent ; indent .)",
    "insertText": "append(indentation+1, ' ')"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (ret .)",
    "insertText": "append(\"[\")"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (ret .)",
    "insertText": "append(std::to_string(mm[(i*SIZE)+j]))"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (} ret .)",
    "insertText": "append(\"]\")"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (ret .)",
    "insertText": "append(\",\\n\")"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (ret .)",
    "insertText": "append(indent)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (ostr<<m .)",
    "insertText": "str()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const T*)",
    "insertText": "operator(int i)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "write(std::ostream& os)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&mm), sizeof(T)*SIZE*SIZE)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "read(std::istream& is)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&mm), sizeof(T)*SIZE*SIZE)"
  },
  {
    "label": "absMax()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "absMax()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T x = static_cast<)",
    "insertText": "T(std::fabs(mm[0]))"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (x =)",
    "insertText": "max(x, static_cast<T>(std::fabs(mm[i])))"
  },
  {
    "label": "isNan()",
    "kind": "Method",
    "detail": "Function (} return x ; } bool)",
    "insertText": "isNan()"
  },
  {
    "label": "isInfinite()",
    "kind": "Method",
    "detail": "Function (} return false ; } bool)",
    "insertText": "isInfinite()"
  },
  {
    "label": "isFinite()",
    "kind": "Method",
    "detail": "Function (} return false ; } bool)",
    "insertText": "isFinite()"
  },
  {
    "label": "isZero()",
    "kind": "Method",
    "detail": "Function (} return true ; } bool)",
    "insertText": "isZero()"
  },
  {
    "label": "rotation()",
    "kind": "Method",
    "detail": "Function (} return true ; } protected : T mm [ SIZE* SIZE ] ; } ; template<T> class Quat ; template<T> class Vec3 ; template<class MatType> MatType)",
    "insertText": "rotation(const Quat<typename MatType::value_type> &q, typename MatType::value_type eps = static_cast<typename MatType::value_type>(1.0e-8))"
  },
  {
    "label": "qdot()",
    "kind": "Method",
    "detail": "Function (using T = MatType::value_type ; T)",
    "insertText": "qdot(q.dot(q))"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "s(0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (s =)",
    "insertText": "T(2.0 / qdot)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (} T x = s* q .)",
    "insertText": "x()"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (T y = s* q .)",
    "insertText": "y()"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (T z = s* q .)",
    "insertText": "z()"
  },
  {
    "label": "w()",
    "kind": "Method",
    "detail": "Function (T wx = x* q .)",
    "insertText": "w()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MatType r ; r [ 0 ] [ 0 ] =)",
    "insertText": "T(1) - (yy+zz)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (r [ 0 ] [ 1 ] = xy + wz ; r [ 0 ] [ 2 ] = xz - wy ; r [ 1 ] [ 0 ] = xy - wz ; r [ 1 ] [ 1 ] =)",
    "insertText": "T(1) - (xx+zz)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (r [ 1 ] [ 2 ] = yz + wx ; r [ 2 ] [ 0 ] = xz + wy ; r [ 2 ] [ 1 ] = yz - wx ; r [ 2 ] [ 2 ] =)",
    "insertText": "T(1) - (xx+yy)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (using T = MatType::value_type ; T c = static_cast<)",
    "insertText": "T(cos(angle))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T s = static_cast<)",
    "insertText": "T(sin(angle))"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (MatType result ; result .)",
    "insertText": "setIdentity()"
  },
  {
    "label": "rotation()",
    "kind": "Method",
    "detail": "Function (} } template<class MatType> MatType)",
    "insertText": "rotation(const Vec3<typename MatType::value_type> &_axis, typename MatType::value_type angle)"
  },
  {
    "label": "axis()",
    "kind": "Method",
    "detail": "Function (using T = MatType::value_type ; T txy,txz,tyz,sx,sy,sz ; Vec3<T>)",
    "insertText": "axis(_axis.unit())"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "c(cos(double(angle)))"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "s(sin(double(angle)))"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "t(1 - c)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MatType result ; result [ 0 ] [ 0 ] = axis [ 0 ]* axis [ 0 ]* t + c ; result [ 1 ] [ 1 ] = axis [ 1 ]* axis [ 1 ]* t + c ; result [ 2 ] [ 2 ] = axis [ 2 ]* axis [ 2 ]* t + c ; txy = axis [ 0 ]* axis [ 1 ]* t ; sz = axis [ 2 ]* s ; txz = axis [ 0 ]* axis [ 2 ]* t ; sy = axis [ 1 ]* s ; tyz = axis [ 1 ]* axis [ 2 ]* t ; sx = axis [ 0 ]* s ; result [ 0 ] [ 1 ] = txy + sz ; result [ 1 ] [ 0 ] = txy - sz ; result [ 0 ] [ 2 ] = txz - sy ; result [ 2 ] [ 0 ] = txz + sy ; result [ 1 ] [ 2 ] = tyz + sx ; result [ 2 ] [ 1 ] = tyz - sx ;)",
    "insertText": "if(MatType::numColumns() == 4) padMat4(result)"
  },
  {
    "label": "eulerAngles()",
    "kind": "Method",
    "detail": "Function (} template<class MatType> Vec3<MatType::value_type>)",
    "insertText": "eulerAngles(const MatType& mat, RotationOrder rotationOrder, typename MatType::value_type eps = static_cast<typename MatType::value_type>(1.0e-8))"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (using ValueType = MatType::value_type ; using V = Vec3<ValueType> ; ValueType phi,theta,psi ;)",
    "insertText": "switch(rotationOrder)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(M_PI_2)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(0.5 * atan2(mat[1][2], mat[1][1]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (psi = phi ; } else)",
    "insertText": "if(isApproxEqual(mat[2][0], ValueType(-1.0), eps))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(-M_PI_2)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (psi = - phi ; } else { psi =)",
    "insertText": "ValueType(atan2(-mat[1][0],mat[0][0]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(atan2(-mat[2][1],mat[2][2]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(atan2(mat[2][0], sqrt( mat[2][1]*mat[2][1] + mat[2][2]*mat[2][2])))"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "V(phi, theta, psi)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(0.5 * atan2(mat[0][1], mat[0][0]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (psi = phi ; } else)",
    "insertText": "if(isApproxEqual(mat[1][2], ValueType(-1.0), eps))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(-M_PI/2)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(0.5 * atan2(mat[0][1],mat[2][1]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (psi = - phi ; } else { psi =)",
    "insertText": "ValueType(atan2(-mat[0][2], mat[2][2]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(atan2(-mat[1][0], mat[1][1]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(atan2(mat[1][2], sqrt(mat[0][2] * mat[0][2] + mat[2][2] * mat[2][2])))"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "V(theta, psi, phi)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(0.5 * atan2(mat[2][0], mat[2][2]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (psi = phi ; } else)",
    "insertText": "if(isApproxEqual(mat[0][1], ValueType(-1.0), eps))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(0.5 * atan2(mat[2][0], mat[1][0]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (psi = - phi ; } else { psi =)",
    "insertText": "ValueType(atan2(-mat[2][1], mat[1][1]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(atan2(-mat[0][2], mat[0][0]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(atan2(mat[0][1], sqrt(mat[0][0] * mat[0][0] + mat[0][2] * mat[0][2])))"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "V(psi, phi, theta)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(0.0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (psi = phi ; } else)",
    "insertText": "if(isApproxEqual(mat[0][0], ValueType(-1.0), eps))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(M_PI)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (psi =)",
    "insertText": "ValueType(0.5 * atan2(mat[2][1], -mat[1][1]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi = - psi ; } else { psi =)",
    "insertText": "ValueType(atan2(mat[2][0], -mat[1][0]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(atan2(mat[0][2], mat[0][1]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(atan2(sqrt(mat[0][1] * mat[0][1] + mat[0][2] * mat[0][2]), mat[0][0]))"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "V(phi, psi, theta)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (psi = phi ; } else)",
    "insertText": "if(isApproxEqual(mat[2][2], ValueType(-1.0), eps))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (psi = - phi ; } else { psi =)",
    "insertText": "ValueType(atan2(mat[0][2], mat[1][2]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(atan2(mat[2][0], -mat[2][1]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(atan2(sqrt(mat[0][2] * mat[0][2] + mat[1][2] * mat[1][2]), mat[2][2]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(0.5 * atan2(-mat[1][0], mat[0][0]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (psi = phi ; } else)",
    "insertText": "if(isApproxEqual(mat[2][1], ValueType(-1.0), eps))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(0.5 * atan2(mat[1][0], mat[0][0]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (psi = - phi ; } else { psi =)",
    "insertText": "ValueType(atan2(mat[0][1], mat[1][1]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(atan2(mat[2][0], mat[2][2]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(atan2(-mat[2][1], sqrt(mat[0][1] * mat[0][1] + mat[1][1] * mat[1][1])))"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "V(theta, phi, psi)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(0.5 * atan2(-mat[1][0], mat[1][1]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (psi = phi ; } else)",
    "insertText": "if(isApproxEqual(mat[0][2], ValueType(-1.0), eps))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(0.5 * atan2(mat[2][1], mat[2][0]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (psi = - phi ; } else { psi =)",
    "insertText": "ValueType(atan2(mat[1][2], mat[2][2]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(atan2(mat[0][1], mat[0][0]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(atan2(-mat[0][2], sqrt(mat[0][1] * mat[0][1] + mat[0][0] * mat[0][0])))"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "V(psi, theta, phi)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (psi =)",
    "insertText": "ValueType(0.5 * atan2(mat[2][1], mat[2][2]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (phi = - psi ; } else)",
    "insertText": "if(isApproxEqual(mat[1][0], ValueType(1.0), eps))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (psi =)",
    "insertText": "ValueType(0.5 * atan2(- mat[2][1], mat[2][2]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi = psi ; } else { psi =)",
    "insertText": "ValueType(atan2(mat[2][0], mat[0][0]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (phi =)",
    "insertText": "ValueType(atan2(mat[1][2], mat[1][1]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (theta =)",
    "insertText": "ValueType(atan2(- mat[1][0], sqrt(mat[1][1] * mat[1][1] + mat[1][2] * mat[1][2])))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "OPENVDB_THROW(NotImplementedError, \"Euler extraction sequence not implemented\")"
  },
  {
    "label": "rotation()",
    "kind": "Method",
    "detail": "Function (} template<MatType,ValueType1,ValueType2> MatType)",
    "insertText": "rotation(const Vec3<ValueType1>& _v1, const Vec3<ValueType2>& _v2, typename MatType::value_type eps = static_cast<typename MatType::value_type>(1.0e-8))"
  },
  {
    "label": "v1()",
    "kind": "Method",
    "detail": "Function (using T = MatType::value_type ; Vec3<T>)",
    "insertText": "v1(_v1)"
  },
  {
    "label": "v2()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "v2(_v2)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (v1 .)",
    "insertText": "normalize()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!isApproxEqual(T(1), v2.dot(v2), eps))"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (} Vec3<T> cross ; cross .)",
    "insertText": "cross(v1, v2)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (Vec3<T> u,v,)",
    "insertText": "p(0.0, 0.0, 0.0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (p [ 2 ] = 1 ; } else { p [ 0 ] = 1 ; } } else {)",
    "insertText": "if(z < y)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (p [ 2 ] = 1 ; } else { p [ 1 ] = 1 ; } } u = p - v1 ; v = p - v2 ; double udot = u .)",
    "insertText": "dot(u)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (r [ 0 ] [ 1 ] = static_cast<)",
    "insertText": "T(a01 + cross[2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (r [ 0 ] [ 2 ] = static_cast<)",
    "insertText": "T(a02 - cross[1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (r [ 1 ] [ 0 ] = static_cast<)",
    "insertText": "T(a01 - cross[2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (r [ 1 ] [ 1 ] = static_cast<)",
    "insertText": "T(c + a1 * cross[1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (r [ 1 ] [ 2 ] = static_cast<)",
    "insertText": "T(a12 + cross[0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (r [ 2 ] [ 0 ] = static_cast<)",
    "insertText": "T(a02 + cross[1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (r [ 2 ] [ 1 ] = static_cast<)",
    "insertText": "T(a12 - cross[0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (r [ 2 ] [ 2 ] = static_cast<)",
    "insertText": "T(c + a2 * cross[2])"
  },
  {
    "label": "getScale()",
    "kind": "Method",
    "detail": "Function (result [ 0 ] [ 0 ] = s [ 0 ] ; result [ 1 ] [ 1 ] = s [ 1 ] ; result [ 2 ] [ 2 ] = s [ 2 ] ; return result ; } template<class MatType> Vec3<MatType::value_type>)",
    "insertText": "getScale(const MatType &mat)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (using V = Vec3<MatType::value_type> ; return)",
    "insertText": "V(V(mat[0][0], mat[0][1], mat[0][2]).length(), V(mat[1][0], mat[1][1], mat[1][2]).length(), V(mat[2][0], mat[2][1], mat[2][2]).length())"
  },
  {
    "label": "unit()",
    "kind": "Method",
    "detail": "Function (} template<class MatType> MatType)",
    "insertText": "unit(const MatType &mat, typename MatType::value_type eps = 1.0e-8)"
  },
  {
    "label": "unit()",
    "kind": "Method",
    "detail": "Function (Vec3<MatType::value_type> dud ; return)",
    "insertText": "unit(mat, eps, dud)"
  },
  {
    "label": "unit()",
    "kind": "Method",
    "detail": "Function (} template<class MatType> MatType)",
    "insertText": "unit(const MatType &in, typename MatType::value_type eps, Vec3<typename MatType::value_type>& scaling)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using T = MatType::value_type ; MatType)",
    "insertText": "result(in)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (try { const Vec3<T>)",
    "insertText": "u(Vec3<T>(in[i][0], in[i][1], in[i][2]).unit(eps, scaling[i]))"
  },
  {
    "label": "catch()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "catch(ArithmeticError&)"
  },
  {
    "label": "shear()",
    "kind": "Method",
    "detail": "Function (} } return result ; } template<class MatType> MatType)",
    "insertText": "shear(Axis axis0, Axis axis1, typename MatType::value_type shear)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int index0 = static_cast<)",
    "insertText": "int(axis0)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int index1 = static_cast<)",
    "insertText": "int(axis1)"
  },
  {
    "label": "skew()",
    "kind": "Method",
    "detail": "Function (result [ index1 ] [ index0 ] = shear + 1 ; } else { result [ index1 ] [ index0 ] = shear ; } return result ; } template<class MatType> MatType)",
    "insertText": "skew(const Vec3<typename MatType::value_type> &skew)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (using T = MatType::value_type ; MatType r ; r [ 0 ] [ 0 ] =)",
    "insertText": "T(0)"
  },
  {
    "label": "forward()",
    "kind": "Method",
    "detail": "Function (using T = MatType::value_type ; Vec3<T>)",
    "insertText": "forward(direction.unit())"
  },
  {
    "label": "horizontal()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "horizontal(vertical.unit().cross(forward).unit())"
  },
  {
    "label": "up()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "up(forward.cross(horizontal).unit())"
  },
  {
    "label": "unitDir()",
    "kind": "Method",
    "detail": "Function (using T = MatType::value_type ; Vec3<T>)",
    "insertText": "unitDir(direction.unit())"
  },
  {
    "label": "ourUnitAxis()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "ourUnitAxis(source.row(axis).unit())"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (T parallel = unitDir .)",
    "insertText": "dot(ourUnitAxis)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ValueError, \"Cannot snap to inverse axis\")"
  },
  {
    "label": "angleBetween()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "angleBetween(angle(unitDir, ourUnitAxis))"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (Vec3<T> rotationAxis = unitDir .)",
    "insertText": "cross(ourUnitAxis)"
  },
  {
    "label": "setToRotation()",
    "kind": "Method",
    "detail": "Function (MatType rotation ; rotation .)",
    "insertText": "setToRotation(rotationAxis, angleBetween)"
  },
  {
    "label": "sqrtSolve()",
    "kind": "Method",
    "detail": "Function (dest [ 0 ] [ 3 ] = dest [ 1 ] [ 3 ] = dest [ 2 ] [ 3 ] = 0 ; dest [ 3 ] [ 2 ] = dest [ 3 ] [ 1 ] = dest [ 3 ] [ 0 ] = 0 ; dest [ 3 ] [ 3 ] = 1 ; return dest ; } template<MatType> void)",
    "insertText": "sqrtSolve(const MatType& aA, MatType& aB, double aTol=0.01)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (unsigned int iterations = static_cast<unsigned)",
    "insertText": "int(log(aTol)/log(0.5))"
  },
  {
    "label": "identity()",
    "kind": "Method",
    "detail": "Function (MatType Y [ 2 ],Z [ 2 ] ; Y [ 0 ] = aA ; Z [ 0 ] =)",
    "insertText": "identity()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (unsigned int current = 0 ;)",
    "insertText": "for(unsigned int iteration=0; iteration < iterations; iteration++)"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (unsigned int last = current ; current = ! current ; MatType invY = Y [ last ] .)",
    "insertText": "inverse()"
  },
  {
    "label": "current()",
    "kind": "Method",
    "detail": "Function (Y [)",
    "insertText": "current(Y[last] + invZ)"
  },
  {
    "label": "current()",
    "kind": "Method",
    "detail": "Function (Z [)",
    "insertText": "current(Z[last] + invY)"
  },
  {
    "label": "powSolve()",
    "kind": "Method",
    "detail": "Function (} aB = Y [ current ] ; } template<MatType> void)",
    "insertText": "powSolve(const MatType& aA, MatType& aB, double aPower, double aTol=0.01)"
  },
  {
    "label": "inverted()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "inverted(aPower < 0.0)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (aPower = - aPower ; } unsigned int whole = static_cast<unsigned)",
    "insertText": "int(aPower)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (MatType partial = aA ; double contribution = 1 . 0 ;)",
    "insertText": "for(unsigned int iteration = 0; iteration < iterations; iteration++)"
  },
  {
    "label": "sqrtSolve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sqrtSolve(partial, partial, aTol)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (contribution* = 0 . 5 ;)",
    "insertText": "if(fraction >= contribution)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (R* = partial ; fraction - = contribution ; } } partial = aA ;)",
    "insertText": "while(whole)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (R* = partial ; } whole>> = 1 ;)",
    "insertText": "if(whole)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (partial* = partial ; } })",
    "insertText": "if(inverted)"
  },
  {
    "label": "isIdentity()",
    "kind": "Method",
    "detail": "Function (} else { aB = R ; } } template<MatType> bool)",
    "insertText": "isIdentity(const MatType& m)"
  },
  {
    "label": "isInvertible()",
    "kind": "Method",
    "detail": "Function (} template<MatType> bool)",
    "insertText": "isInvertible(const MatType& m)"
  },
  {
    "label": "isApproxEqual()",
    "kind": "Method",
    "detail": "Function (using ValueType = MatType::ValueType ; return !)",
    "insertText": "isApproxEqual(m.det(), ValueType(0))"
  },
  {
    "label": "isSymmetric()",
    "kind": "Method",
    "detail": "Function (} template<MatType> bool)",
    "insertText": "isSymmetric(const MatType& m)"
  },
  {
    "label": "isUnitary()",
    "kind": "Method",
    "detail": "Function (} template<MatType> bool)",
    "insertText": "isUnitary(const MatType& m)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using ValueType = MatType::ValueType ;)",
    "insertText": "if(!isApproxEqual(std::abs(m.det()), ValueType(1.0)))"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (MatType temp = m* m .)",
    "insertText": "transpose()"
  },
  {
    "label": "isDiagonal()",
    "kind": "Method",
    "detail": "Function (} template<MatType> bool)",
    "insertText": "isDiagonal(const MatType& mat)"
  },
  {
    "label": "temp()",
    "kind": "Method",
    "detail": "Function (int n = MatType::size ; MatType::ValueType)",
    "insertText": "temp(0)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (temp + =)",
    "insertText": "abs(mat(i,j))"
  },
  {
    "label": "isApproxEqual()",
    "kind": "Method",
    "detail": "Function (} } } return)",
    "insertText": "isApproxEqual(temp, typename MatType::ValueType(0.0))"
  },
  {
    "label": "lInfinityNorm()",
    "kind": "Method",
    "detail": "Function (} template<MatType> MatType::ValueType)",
    "insertText": "lInfinityNorm(const MatType& matrix)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int n = MatType::size ; MatType::ValueType norm = 0 ;)",
    "insertText": "for(int j = 0; j<n; ++j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (MatType::ValueType column_sum = 0 ;)",
    "insertText": "for(int i = 0; i<n; ++i)"
  },
  {
    "label": "fabs()",
    "kind": "Method",
    "detail": "Function (column_sum + =)",
    "insertText": "fabs(matrix(i,j))"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (} norm =)",
    "insertText": "max(norm, column_sum)"
  },
  {
    "label": "lOneNorm()",
    "kind": "Method",
    "detail": "Function (} return norm ; } template<MatType> MatType::ValueType)",
    "insertText": "lOneNorm(const MatType& matrix)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (} norm =)",
    "insertText": "max(norm, row_sum)"
  },
  {
    "label": "polarDecomposition()",
    "kind": "Method",
    "detail": "Function (} return norm ; } template<MatType> bool)",
    "insertText": "polarDecomposition(const MatType& input, MatType& unitary, MatType& positive_hermitian, unsigned int MAX_ITERATIONS=100)"
  },
  {
    "label": "new_unitary()",
    "kind": "Method",
    "detail": "Function (unitary = input ; MatType)",
    "insertText": "new_unitary(input)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MatType unitary_inv ;)",
    "insertText": "if(fabs(unitary.det()) < math::Tolerance<typename MatType::ValueType>::value())"
  },
  {
    "label": "iteration()",
    "kind": "Method",
    "detail": "Function (unsigned int)",
    "insertText": "iteration(0)"
  },
  {
    "label": "lInfinityNorm()",
    "kind": "Method",
    "detail": "Function (linf_of_u =)",
    "insertText": "lInfinityNorm(unitary)"
  },
  {
    "label": "lOneNorm()",
    "kind": "Method",
    "detail": "Function (l1nm_of_u =)",
    "insertText": "lOneNorm(unitary)"
  },
  {
    "label": "lInfinityNorm()",
    "kind": "Method",
    "detail": "Function (linf_of_u_inv =)",
    "insertText": "lInfinityNorm(unitary_inv)"
  },
  {
    "label": "lOneNorm()",
    "kind": "Method",
    "detail": "Function (l1nm_of_u_inv =)",
    "insertText": "lOneNorm(unitary_inv)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (gamma =)",
    "insertText": "sqrt(sqrt( (l1nm_of_u_inv * linf_of_u_inv ) / (l1nm_of_u * linf_of_u) ))"
  },
  {
    "label": "new_unitary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new_unitary(gamma * unitary + (1./gamma) * unitary_inv.transpose())"
  },
  {
    "label": "lInfinityNorm()",
    "kind": "Method",
    "detail": "Function (l1_error =)",
    "insertText": "lInfinityNorm(unitary - new_unitary)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unitary = new_unitary ;)",
    "insertText": "if(iteration > MAX_ITERATIONS)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (iteration + + ; })",
    "insertText": "while(l1_error > math::Tolerance<typename MatType::ValueType>::value())"
  },
  {
    "label": "asPointer()",
    "kind": "Method",
    "detail": "Function (const T* m0p = m0 .)",
    "insertText": "asPointer()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (unsigned size = SIZE* SIZE ;)",
    "insertText": "for(unsigned i = 0; i < size-1; ++i, ++m0p, ++m1p)"
  },
  {
    "label": "cwiseGreaterThan()",
    "kind": "Method",
    "detail": "Function (} return* m0p<* m1p ; } template<unsigned SIZE,T> bool)",
    "insertText": "cwiseGreaterThan(const Mat<SIZE, T>& m0, const Mat<SIZE, T>& m1)"
  }
]