[
  {
    "label": "ConditionVariable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConditionVariable"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "RegisteredTaskSource",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RegisteredTaskSource"
  },
  {
    "label": "State",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "State"
  },
  {
    "label": "TaskTracker()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TASK_THREAD_POOL_TASK_TRACKER_H_ # define BASE_TASK_THREAD_POOL_TASK_TRACKER_H_ # include<atomic> # include<functional> # include<limits> # include<memory> # include<queue> # include<string> # include \" base / atomicops . h \" # include \" base / base_export . h \" # include \" base / callback_forward . h \" # include \" base / containers / circular_deque . h \" # include \" base / sequence_checker . h \" # include \" base / strings / string_piece . h \" # include \" base / synchronization / waitable_event . h \" # include \" base / task / common / checked_lock . h \" # include \" base / task / common / task_annotator . h \" # include \" base / task / task_traits . h \" # include \" base / task / thread_pool / task . h \" # include \" base / task / thread_pool / task_source . h \" # include \" base / task / thread_pool / tracked_ref . h \" # include \" base / thread_annotations . h \" namespace base { class ConditionVariable ; namespace internal { enum class CanRunPolicy { kAll,kForegroundOnly,kNone,} ; class BASE_EXPORT TaskTracker { public :)",
    "insertText": "TaskTracker()"
  },
  {
    "label": "TaskTracker()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TaskTracker(const TaskTracker&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TaskTracker&)",
    "insertText": "operator(const TaskTracker&)"
  },
  {
    "label": "StartShutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartShutdown()"
  },
  {
    "label": "CompleteShutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CompleteShutdown()"
  },
  {
    "label": "FlushForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushForTesting()"
  },
  {
    "label": "FlushAsyncForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushAsyncForTesting(OnceClosure flush_callback)"
  },
  {
    "label": "SetCanRunPolicy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCanRunPolicy(CanRunPolicy can_run_policy)"
  },
  {
    "label": "WillPostTask()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WillPostTask(Task* task, TaskShutdownBehavior shutdown_behavior)"
  },
  {
    "label": "WillPostTaskNow()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "WillPostTaskNow(const Task& task, TaskPriority priority)"
  },
  {
    "label": "RegisterTaskSource()",
    "kind": "Method",
    "detail": "Function (RegisteredTaskSource)",
    "insertText": "RegisterTaskSource(scoped_refptr<TaskSource> task_source)"
  },
  {
    "label": "CanRunPriority()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanRunPriority(TaskPriority priority)"
  },
  {
    "label": "RunAndPopNextTask()",
    "kind": "Method",
    "detail": "Function (RegisteredTaskSource)",
    "insertText": "RunAndPopNextTask(RegisteredTaskSource task_source)"
  },
  {
    "label": "HasShutdownStarted()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasShutdownStarted()"
  },
  {
    "label": "IsShutdownComplete()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsShutdownComplete()"
  },
  {
    "label": "GetTrackedRef()",
    "kind": "Method",
    "detail": "Function (TrackedRef<TaskTracker>)",
    "insertText": "GetTrackedRef()"
  },
  {
    "label": "HasIncompleteTaskSourcesForTesting()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasIncompleteTaskSourcesForTesting()"
  },
  {
    "label": "RunTask()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "RunTask(Task task, TaskSource* task_source, const TaskTraits& traits)"
  },
  {
    "label": "BeginCompleteShutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginCompleteShutdown(base::WaitableEvent& shutdown_event)"
  },
  {
    "label": "AssertFlushForTestingAllowed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertFlushForTestingAllowed()"
  },
  {
    "label": "PerformShutdown()",
    "kind": "Method",
    "detail": "Function (} private : class RegisteredTaskSource ; class State ; void)",
    "insertText": "PerformShutdown()"
  },
  {
    "label": "BeforeQueueTaskSource()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "BeforeQueueTaskSource(TaskShutdownBehavior shutdown_behavior)"
  },
  {
    "label": "BeforeRunTask()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "BeforeRunTask(TaskShutdownBehavior shutdown_behavior)"
  },
  {
    "label": "AfterRunTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AfterRunTask(TaskShutdownBehavior shutdown_behavior)"
  },
  {
    "label": "UnregisterTaskSource()",
    "kind": "Method",
    "detail": "Function (scoped_refptr<TaskSource>)",
    "insertText": "UnregisterTaskSource(scoped_refptr<TaskSource> task_source)"
  },
  {
    "label": "DecrementNumItemsBlockingShutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecrementNumItemsBlockingShutdown()"
  },
  {
    "label": "DecrementNumIncompleteTaskSources()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecrementNumIncompleteTaskSources()"
  },
  {
    "label": "InvokeFlushCallbacksForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InvokeFlushCallbacksForTesting()"
  },
  {
    "label": "RunContinueOnShutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RunContinueOnShutdown(Task& task, const TaskTraits& traits, TaskSource* task_source, const SequenceToken& token)"
  },
  {
    "label": "RunSkipOnShutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RunSkipOnShutdown(Task& task, const TaskTraits& traits, TaskSource* task_source, const SequenceToken& token)"
  },
  {
    "label": "RunBlockShutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RunBlockShutdown(Task& task, const TaskTraits& traits, TaskSource* task_source, const SequenceToken& token)"
  },
  {
    "label": "RunTaskWithShutdownBehavior()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RunTaskWithShutdownBehavior(Task& task, const TaskTraits& traits, TaskSource* task_source, const SequenceToken& token)"
  },
  {
    "label": "RunTaskImpl()",
    "kind": "Method",
    "detail": "Function (void NOT_TAIL_CALLED)",
    "insertText": "RunTaskImpl(Task& task, const TaskTraits& traits, TaskSource* task_source, const SequenceToken& token)"
  },
  {
    "label": "GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (TaskAnnotator task_annotator_ ; const std::string histogram_label_ ; const bool has_log_best_effort_tasks_switch_ ; const std::unique_ptr<State> state_ ; std::atomic_int num_incomplete_task_sources_ { 0 } ; std::atomic<CanRunPolicy> can_run_policy_ ; CheckedLock flush_lock_ ; const std::unique_ptr<ConditionVariable> flush_cv_ ; base::circular_deque<OnceClosure> flush_callbacks_for_testing_)",
    "insertText": "GUARDED_BY(flush_lock_)"
  },
  {
    "label": "GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (CheckedLock shutdown_lock_ ; std::unique_ptr<WaitableEvent> shutdown_event_)",
    "insertText": "GUARDED_BY(shutdown_lock_)"
  }
]