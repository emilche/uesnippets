[
  {
    "label": "drop_view",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "drop_view"
  },
  {
    "label": "_Range",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Range"
  },
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "_CharT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_CharT"
  },
  {
    "label": "_Traits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Traits"
  },
  {
    "label": "_Np",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Np"
  },
  {
    "label": "_Bound",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Bound"
  },
  {
    "label": "_Iter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Iter"
  },
  {
    "label": "_Sent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Sent"
  },
  {
    "label": "__passthrough_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__passthrough_type"
  },
  {
    "label": "__fn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__fn"
  },
  {
    "label": "_RawRange",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_RawRange"
  },
  {
    "label": "_Dist",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Dist"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___RANGES_DROP_VIEW_H # define _LIBCPP___RANGES_DROP_VIEW_H # include<__algorithm / min . h> # include<__assert> # include<__config> # include<__functional / bind_back . h> # include<__fwd / span . h> # include<__fwd / string_view . h> # include<__iterator / concepts . h> # include<__iterator / distance . h> # include<__iterator / iterator_traits . h> # include<__iterator / next . h> # include<__ranges / access . h> # include<__ranges / all . h> # include<__ranges / concepts . h> # include<__ranges / empty_view . h> # include<__ranges / enable_borrowed_range . h> # include<__ranges / iota_view . h> # include<__ranges / non_propagating_cache . h> # include<__ranges / range_adaptor . h> # include<__ranges / size . h> # include<__ranges / subrange . h> # include<__ranges / view_interface . h> # include<__utility / auto_cast . h> # include<__utility / forward . h> # include<__utility / move . h> # include<concepts> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER) # pragma GCC system_header #endif _LIBCPP_PUSH_MACROS #include <__undef_macros> _LIBCPP_BEGIN_NAMESPACE_STD #if _LIBCPP_STD_VER > 17 && !defined(_LIBCPP_HAS_NO_INCOMPLETE_RANGES)"
  },
  {
    "label": "_View()",
    "kind": "Method",
    "detail": "Function (template<view _View> class drop_view : public view_interface<drop_view<_View>> { bool _UseCache = forward_range<)",
    "insertText": "_View(random_access_range<_View> && sized_range<_View>)"
  },
  {
    "label": "_Cache()",
    "kind": "Method",
    "detail": "Function (using _Cache = _If<_UseCache,__non_propagating_cache<iterator_t<_View>>,__empty_cache> ; _LIBCPP_NO_UNIQUE_ADDRESS _Cache __cached_begin_ =)",
    "insertText": "_Cache()"
  },
  {
    "label": "_View()",
    "kind": "Method",
    "detail": "Function (range_difference_t<_View> __count_ = 0 ; _View __base_ =)",
    "insertText": "_View()"
  },
  {
    "label": "drop_view()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "drop_view()"
  },
  {
    "label": "drop_view()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "drop_view(_View __base, range_difference_t<_View> __count) : __count_(__count) , __base_(std::move(__base))"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_LIBCPP_ASSERT(__count_ >= 0, \"count must be greater than or equal to zero.\")"
  },
  {
    "label": "base()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI _View)",
    "insertText": "base()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "begin() requires (!(__simple_view<_View> && random_access_range<const _View> && sized_range<const _View>))"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (auto __tmp =)",
    "insertText": "next(ranges::begin(__base_), __count_, ranges::end(__base_))"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "end() requires (!__simple_view<_View>)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "end()"
  },
  {
    "label": "__size()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "__size(auto& __self)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (const auto __s =)",
    "insertText": "size(__self.__base_)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (const auto __c = static_cast<)",
    "insertText": "decltype(__s)>(__self.__count_)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "size()"
  },
  {
    "label": "drop_view()",
    "kind": "Method",
    "detail": "Function (drop_view<views::all_t<_Range>>)",
    "insertText": "drop_view(_Range&&, range_difference_t<_Range>)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class _Tp> bool enable_borrowed_range<drop_view<_Tp>> = enable_borrowed_range<_Tp> ; namespace views { namespace __drop { template<class _Tp> bool __is_empty_view = false ; template<class _Tp> bool __is_empty_view<empty_view<_Tp>> = true ; template<class _Tp> bool __is_passthrough_specialization = false ; template<class _Tp,size_t _Extent> bool __is_passthrough_specialization<span<_Tp,_Extent>> = true ; template<class _CharT,class _Traits> bool __is_passthrough_specialization<basic_string_view<_CharT,_Traits>> = true ; template<class _Np,class _Bound> bool __is_passthrough_specialization<iota_view<_Np,_Bound>> = true ; template<class _Iter,class _Sent,subrange_kind _Kind> bool __is_passthrough_specialization<subrange<_Iter,_Sent,_Kind>> = ! subrange<_Iter,_Sent,_Kind>::_StoreSize ; template<class _Tp> bool __is_subrange_specialization_with_store_size = false ; template<class _Iter,class _Sent,subrange_kind _Kind> bool __is_subrange_specialization_with_store_size<subrange<_Iter,_Sent,_Kind>> = subrange<_Iter,_Sent,_Kind>::_StoreSize ; template<class _Tp> struct __passthrough_type ; template<class _Tp,size_t _Extent> struct __passthrough_type<span<_Tp,_Extent>> { using type = span<_Tp> ; } ; template<class _CharT,class _Traits> struct __passthrough_type<basic_string_view<_CharT,_Traits>> { using type = basic_string_view<_CharT,_Traits> ; } ; template<class _Np,class _Bound> struct __passthrough_type<iota_view<_Np,_Bound>> { using type = iota_view<_Np,_Bound> ; } ; template<class _Iter,class _Sent,subrange_kind _Kind> struct __passthrough_type<subrange<_Iter,_Sent,_Kind>> { using type = subrange<_Iter,_Sent,_Kind> ; } ; template<class _Tp> using __passthrough_type_t = __passthrough_type<_Tp>::type ; struct __fn { template<class _Range,convertible_to<range_difference_t<_Range>> _Np> requires __is_empty_view<remove_cvref_t<_Range>> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Range&& __range, _Np&&) const noexcept(noexcept(_LIBCPP_AUTO_CAST(std::forward<_Range>(__range)))) -> decltype( _LIBCPP_AUTO_CAST(std::forward<_Range>(__range)))"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} template<class _Range,convertible_to<range_difference_t<_Range>> _Np,class _RawRange = remove_cvref_t<_Range>,class _Dist = range_difference_t<_Range>>)",
    "insertText": "requires(!__is_empty_view<_RawRange> && random_access_range<_RawRange> && sized_range<_RawRange> && __is_passthrough_specialization<_RawRange>) [[nodiscard]] _LIBCPP_HIDE_FROM_ABI constexpr auto operator()(_Range&& __rng, _Np&& __n) const noexcept(noexcept(__passthrough_type_t<_RawRange>( ranges::begin(__rng) + std::min<_Dist>(ranges::distance(__rng), std::forward<_Np>(__n)), ranges::end(__rng) ))) -> decltype( __passthrough_type_t<_RawRange>( ranges::begin(__rng) + std::min<_Dist>(ranges::distance(__rng), std::forward<_Np>(__n)), ranges::end(__rng) ))"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} template<class _Range,convertible_to<range_difference_t<_Range>> _Np,class _RawRange = remove_cvref_t<_Range>,class _Dist = range_difference_t<_Range>>)",
    "insertText": "requires(!__is_empty_view<_RawRange> && random_access_range<_RawRange> && sized_range<_RawRange> && __is_subrange_specialization_with_store_size<_RawRange>) [[nodiscard]] _LIBCPP_HIDE_FROM_ABI constexpr auto operator()(_Range&& __rng, _Np&& __n) const noexcept(noexcept(_RawRange( ranges::begin(__rng) + std::min<_Dist>(ranges::distance(__rng), std::forward<_Np>(__n)), ranges::end(__rng), std::__to_unsigned_like(ranges::distance(__rng) - std::min<_Dist>(ranges::distance(__rng), std::forward<_Np>(__n))) ))) -> decltype( _RawRange( ranges::begin(__rng) + std::min<_Dist>(ranges::distance(__rng), std::forward<_Np>(__n)), ranges::end(__rng), std::__to_unsigned_like(ranges::distance(__rng) - std::min<_Dist>(ranges::distance(__rng), std::forward<_Np>(__n))) ))"
  },
  {
    "label": "distance()",
    "kind": "Method",
    "detail": "Function (auto dist =)",
    "insertText": "distance(__rng)"
  },
  {
    "label": "_Dist()",
    "kind": "Method",
    "detail": "Function (auto clamped = std::min<)",
    "insertText": "_Dist(dist, std::forward<_Np>(__n))"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} template<class _Range,convertible_to<range_difference_t<_Range>> _Np,class _RawRange = remove_cvref_t<_Range>>)",
    "insertText": "requires(!(__is_empty_view<_RawRange> || (__is_subrange_specialization_with_store_size<_RawRange> && sized_range<_RawRange> && random_access_range<_RawRange>) || (__is_passthrough_specialization<_RawRange> && sized_range<_RawRange> && random_access_range<_RawRange>) )) [[nodiscard]] _LIBCPP_HIDE_FROM_ABI constexpr auto operator()(_Range&& __range, _Np&& __n) const noexcept(noexcept(drop_view(std::forward<_Range>(__range), std::forward<_Np>(__n)))) -> decltype( drop_view(std::forward<_Range>(__range), std::forward<_Np>(__n)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Np> requires constructible_from<decay_t<_Np>,_Np> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Np&& __n) const noexcept(is_nothrow_constructible_v<decay_t<_Np>, _Np>)"
  }
]