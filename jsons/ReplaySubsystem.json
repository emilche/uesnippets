[
  {
    "label": "UReplayNetConnection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UReplayNetConnection"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "UReplaySubsystem",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UReplaySubsystem"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Subsystems / GameInstanceSubsystem . h \" # include \" Interfaces / IAnalyticsProvider . h \" # include \" ReplaySubsystem . generated . h \" class UReplayNetConnection ; namespace UE::ReplaySubsystem { enum class EStopReplayFlags : uint32 { None = 0 x0,Flush = 0 x1,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(EStopReplayFlags)"
  },
  {
    "label": "UCLASS()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "UCLASS(DisplayName = \"Replay Subsystem\", MinimalAPI)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() public: ENGINE_API virtual void Initialize(FSubsystemCollectionBase& Collection)"
  },
  {
    "label": "Deinitialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deinitialize()"
  },
  {
    "label": "RecordReplay()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecordReplay(const FString& Name, const FString& FriendlyName, const TArray<FString>& AdditionalOptions, TSharedPtr<IAnalyticsProvider> AnalyticsProvider)"
  },
  {
    "label": "PlayReplay()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PlayReplay(const FString& Name, UWorld* WorldOverride, const TArray<FString>& AdditionalOptions)"
  },
  {
    "label": "StopReplay()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StopReplay()"
  },
  {
    "label": "AddUserToReplay()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddUserToReplay(const FString& UserString)"
  },
  {
    "label": "IsSavingCheckpoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSavingCheckpoint()"
  },
  {
    "label": "AddEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddEvent(const FString& Group, const FString& Meta, const TArray<uint8>& Data)"
  },
  {
    "label": "AddOrUpdateEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOrUpdateEvent(const FString& EventName, const FString& Group, const FString& Meta, const TArray<uint8>& Data)"
  },
  {
    "label": "SetCheckpointSaveMaxMSPerFrame()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCheckpointSaveMaxMSPerFrame(const float InCheckpointSaveMaxMSPerFrame)"
  },
  {
    "label": "SetExternalDataForObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetExternalDataForObject(UObject* OwningObject, const uint8* Src, const int32 NumBits)"
  },
  {
    "label": "StopExistingReplays()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "StopExistingReplays(UWorld* InWorld, UE::ReplaySubsystem::EStopReplayFlags Flags = UE::ReplaySubsystem::EStopReplayFlags::None)"
  },
  {
    "label": "OnSeamlessTravelStart()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnSeamlessTravelStart(UWorld* CurrentWorld, const FString& LevelName)"
  },
  {
    "label": "OnSeamlessLevelTransition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnSeamlessLevelTransition(UWorld* CurrentWorld)"
  },
  {
    "label": "OnCopyWorldData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnCopyWorldData(UWorld* CurrentWorld, UWorld* LoadedWorld)"
  }
]