[
  {
    "label": "TBasicArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBasicArray"
  },
  {
    "label": "FData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FData"
  },
  {
    "label": "TIsContiguousContainer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsContiguousContainer"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Templates / MemoryOps . h \" # include \" Traits / IsContiguousContainer . h \" # if _MSC_VER # pragma)",
    "insertText": "warning(push) #pragma warning(disable : 4200)"
  },
  {
    "label": "TBasicArray()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TBasicArray() : Data(nullptr)"
  },
  {
    "label": "TBasicArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TBasicArray(const TBasicArray&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TBasicArray&)",
    "insertText": "operator(const TBasicArray&)"
  },
  {
    "label": "TBasicArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TBasicArray(TBasicArray&& Other) : Data(Other.Data)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Other . Data = nullptr ; } TBasicArray&)",
    "insertText": "operator(TBasicArray&& Other)"
  },
  {
    "label": "Temp()",
    "kind": "Method",
    "detail": "Function (TBasicArray)",
    "insertText": "Temp(MoveTemp(Other))"
  },
  {
    "label": "TBasicArray()",
    "kind": "Method",
    "detail": "Function (FData* TempData = Temp . Data ; Temp . Data = this -> Data ; this -> Data = TempData ; return* this ; } ~)",
    "insertText": "TBasicArray()"
  },
  {
    "label": "DestructItems()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItems(LocalData->Data, LocalData->Num)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(LocalData)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (} } template<. . . ArgTypes> int32)",
    "insertText": "Emplace(ArgTypes&&... Args)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32 Result =)",
    "insertText": "Num()"
  },
  {
    "label": "InsertUninitialized()",
    "kind": "Method",
    "detail": "Function (void* LocationToAdd =)",
    "insertText": "InsertUninitialized(Result)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(LocationToAdd) T(Forward<ArgTypes>(Args)...)"
  },
  {
    "label": "InsertUninitialized()",
    "kind": "Method",
    "detail": "Function (void* LocationToAdd =)",
    "insertText": "InsertUninitialized(Index)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveAt(int32 Index, int32 NumToRemove = 1)"
  },
  {
    "label": "DestructItems()",
    "kind": "Method",
    "detail": "Function (FData* LocalData = this -> Data ; int32 LocalNum = LocalData -> Num ; T* StartToRemove =& LocalData -> Data [ Index ] ;)",
    "insertText": "DestructItems(StartToRemove, NumToRemove)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (RelocateConstructItems<)",
    "insertText": "T(StartToRemove, StartToRemove + NumToRemove, LocalNum - NumToRemove)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (LocalData -> Num - = NumToRemove ; } } bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (FData* LocalData = Data ; return LocalData ? LocalData -> Num : 0 ; } T*)",
    "insertText": "GetData()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "ApplyGrowthFactor()",
    "kind": "Method",
    "detail": "Function (} private : int32 InitialReservationSize = 1 6 ; int32)",
    "insertText": "ApplyGrowthFactor(int32 CurrentNum)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FData* LocalData = this -> Data ; T* LocationToAdd = nullptr ;)",
    "insertText": "if(!LocalData)"
  },
  {
    "label": "LocalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LocalData(FData*)FMemory::Malloc(sizeof(FData) + InitialReservationSize * sizeof(T))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (LocalData -> Num = 1 ; LocalData -> Max = InitialReservationSize ; Data = LocalData ; LocationToAdd = LocalData -> Data ; } else { int32 LocalNum = LocalData -> Num ; int32 LocalMax = LocalData -> Max ;)",
    "insertText": "if(LocalNum == LocalMax)"
  },
  {
    "label": "ApplyGrowthFactor()",
    "kind": "Method",
    "detail": "Function (LocalMax =)",
    "insertText": "ApplyGrowthFactor(LocalMax)"
  },
  {
    "label": "LocalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LocalData(FData*)FMemory::Realloc(LocalData, sizeof(FData) + LocalMax * sizeof(T))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (LocalData -> Max = LocalMax ; this -> Data = LocalData ; } LocationToAdd = LocalData -> Data + IndexToAdd ; RelocateConstructItems<)",
    "insertText": "T(LocationToAdd + 1, LocationToAdd, LocalNum - IndexToAdd)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (+ + LocalData -> Num ; } return LocationToAdd ; } struct FData { int32 Num ; int32 Max ; T Data [ 0 ] ; } ; FData* Data ; T*)",
    "insertText": "begin(TBasicArray& Arr)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} const T*)",
    "insertText": "begin(const TBasicArray& Arr)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "end(TBasicArray& Arr)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} const T*)",
    "insertText": "end(const TBasicArray& Arr)"
  }
]