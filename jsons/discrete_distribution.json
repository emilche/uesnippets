[
  {
    "label": "discrete_distribution",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "discrete_distribution"
  },
  {
    "label": "param_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "param_type"
  },
  {
    "label": "UnaryOperation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnaryOperation"
  },
  {
    "label": "param_type()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_RANDOM_DISCRETE_DISTRIBUTION_H_ # define ABSL_RANDOM_DISCRETE_DISTRIBUTION_H_ # include<cassert> # include<cmath> # include<istream> # include<limits> # include<numeric> # include<type_traits> # include<utility> # include<vector> # include \" absl / random / bernoulli_distribution . h \" # include \" absl / random / internal / iostream_state_saver . h \" # include \" absl / random / uniform_int_distribution . h \" namespace absl { ABSL_NAMESPACE_BEGIN template<IntType = int> class discrete_distribution { public : using result_type = IntType ; class param_type { public : using distribution_type = discrete_distribution ;)",
    "insertText": "param_type()"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init()"
  },
  {
    "label": "param_type()",
    "kind": "Method",
    "detail": "Function (} template<InputIterator>)",
    "insertText": "param_type(InputIterator begin, InputIterator end) : p_(begin, end)"
  },
  {
    "label": "param_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "param_type(std::initializer_list<double> weights) : p_(weights)"
  },
  {
    "label": "param_type()",
    "kind": "Method",
    "detail": "Function (} template<class UnaryOperation>)",
    "insertText": "param_type(size_t nw, double xmin, double xmax, UnaryOperation fw)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (p_ .)",
    "insertText": "reserve(nw)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(delta > 0)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (p_ .)",
    "insertText": "push_back(fw(xmin + i * delta + t))"
  },
  {
    "label": "probabilities()",
    "kind": "Method",
    "detail": "Function (} const std::vector<double>&)",
    "insertText": "probabilities()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const param_type& a, const param_type& b)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (std::vector<double> p_ ; std::vector<std::pair<double,size_t>> q_ ;)",
    "insertText": "static_assert(std::is_integral<result_type>::value, \"Class-template absl::discrete_distribution<> must be \" \"parameterized using an integral type.\")"
  },
  {
    "label": "discrete_distribution()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "discrete_distribution() : param_()"
  },
  {
    "label": "discrete_distribution()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "discrete_distribution(const param_type& p) : param_(p)"
  },
  {
    "label": "discrete_distribution()",
    "kind": "Method",
    "detail": "Function (} template<InputIterator>)",
    "insertText": "discrete_distribution(InputIterator begin, InputIterator end) : param_(begin, end)"
  },
  {
    "label": "discrete_distribution()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "discrete_distribution(std::initializer_list<double> weights) : param_(weights)"
  },
  {
    "label": "discrete_distribution()",
    "kind": "Method",
    "detail": "Function (} template<class UnaryOperation>)",
    "insertText": "discrete_distribution(size_t nw, double xmin, double xmax, UnaryOperation fw) : param_(nw, xmin, xmax, std::move(fw))"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reset()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<URBG> result_type)",
    "insertText": "operator()(URBG& g)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<URBG> result_type)",
    "insertText": "operator()(URBG& g, const param_type& p)"
  },
  {
    "label": "param()",
    "kind": "Method",
    "detail": "Function (const param_type&)",
    "insertText": "param()"
  },
  {
    "label": "result_type()",
    "kind": "Method",
    "detail": "Function (param_ = p ; })",
    "insertText": "result_type(min)()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const discrete_distribution& a, const discrete_distribution& b)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (p_ .)",
    "insertText": "push_back(1.0)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (q_ .)",
    "insertText": "emplace_back(1.0, 0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "assert(n() <= (std::numeric_limits<IntType>::max)())"
  },
  {
    "label": "InitDiscreteDistribution()",
    "kind": "Method",
    "detail": "Function (q_ =)",
    "insertText": "InitDiscreteDistribution(&p_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } template<IntType> template<URBG> discrete_distribution<IntType>::result_type discrete_distribution<IntType)",
    "insertText": "operator()( URBG& g, const param_type& p)"
  },
  {
    "label": "result_type()",
    "kind": "Method",
    "detail": "Function (const auto idx = absl::uniform_int_distribution<)",
    "insertText": "result_type(0, p.n())(g)"
  },
  {
    "label": "bernoulli_distribution()",
    "kind": "Method",
    "detail": "Function (const auto& q = p . q_ [ idx ] ; const bool selected =)",
    "insertText": "bernoulli_distribution(q.first)(g)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<CharT,Traits,IntType> std::basic_ostream<CharT,Traits>&)",
    "insertText": "operator(std::basic_ostream<CharT, Traits>& os, const discrete_distribution<IntType>& x)"
  },
  {
    "label": "make_ostream_state_saver()",
    "kind": "Method",
    "detail": "Function (auto saver =)",
    "insertText": "make_ostream_state_saver(os)"
  },
  {
    "label": "param()",
    "kind": "Method",
    "detail": "Function (const auto& probabilities = x .)",
    "insertText": "param().probabilities()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (os<<probabilities .)",
    "insertText": "size()"
  },
  {
    "label": "precision()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "precision(random_internal::stream_precision_helper<double>::kPrecision)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (os<<os .)",
    "insertText": "fill()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return os ; } template<CharT,Traits,IntType> std::basic_istream<CharT,Traits>&)",
    "insertText": "operator(std::basic_istream<CharT, Traits>& is, discrete_distribution<IntType>& x)"
  },
  {
    "label": "make_istream_state_saver()",
    "kind": "Method",
    "detail": "Function (using param_type = discrete_distribution<IntType>::param_type ; auto saver =)",
    "insertText": "make_istream_state_saver(is)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t n ; std::vector<double> p ; is>> n ;)",
    "insertText": "if(is.fail())"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (p .)",
    "insertText": "reserve(n)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (auto tmp = random_internal::read_floating_point<)",
    "insertText": "double(is)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (p .)",
    "insertText": "push_back(tmp)"
  },
  {
    "label": "param()",
    "kind": "Method",
    "detail": "Function (} } x .)",
    "insertText": "param(param_type(p.begin(), p.end()))"
  }
]