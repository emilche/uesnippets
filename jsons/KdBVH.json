[
  {
    "label": "vector_int_pair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "vector_int_pair"
  },
  {
    "label": "get_boxes_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "get_boxes_helper"
  },
  {
    "label": "KdBVH",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "KdBVH"
  },
  {
    "label": "VectorComparator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VectorComparator"
  },
  {
    "label": "EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE()",
    "kind": "Method",
    "detail": "Function (# ifndef KDBVH_H_INCLUDED # define KDBVH_H_INCLUDED namespace Eigen { namespace internal { template<Scalar,int Dim> struct vector_int_pair {)",
    "insertText": "EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE(Scalar, Dim)"
  },
  {
    "label": "vector_int_pair()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vector_int_pair(const VectorType &v, int i) : first(v), second(i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} VectorType first ; int second ; } ; template<ObjectList,VolumeList,BoxIter> struct get_boxes_helper { void)",
    "insertText": "operator()(const ObjectList &objects, BoxIter boxBegin, BoxIter boxEnd, VolumeList &outBoxes)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (outBoxes .)",
    "insertText": "insert(outBoxes.end(), boxBegin, boxEnd)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(outBoxes.size() == objects.size())"
  },
  {
    "label": "EIGEN_ONLY_USED_FOR_DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ONLY_USED_FOR_DEBUG(objects)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<ObjectList,VolumeList> struct get_boxes_helper<ObjectList,VolumeList,int> { void)",
    "insertText": "operator()(const ObjectList &objects, int, int, VolumeList &outBoxes)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (outBoxes .)",
    "insertText": "reserve(objects.size())"
  },
  {
    "label": "KdBVH()",
    "kind": "Method",
    "detail": "Function (} } ; } template<_Scalar,int _Dim,_Object> class KdBVH { public : enum { Dim = _Dim } ; typedef _Object Object ; typedef std::vector<Object,aligned_allocator<Object>> ObjectList ; typedef _Scalar Scalar ; typedef AlignedBox<Scalar,Dim> Volume ; typedef std::vector<Volume,aligned_allocator<Volume>> VolumeList ; typedef int Index ; typedef const int* VolumeIterator ; typedef const Object* ObjectIterator ;)",
    "insertText": "KdBVH()"
  },
  {
    "label": "KdBVH()",
    "kind": "Method",
    "detail": "Function (} template<Iter>)",
    "insertText": "KdBVH(Iter begin, Iter end)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init(begin, end, 0, 0)"
  },
  {
    "label": "KdBVH()",
    "kind": "Method",
    "detail": "Function (} template<OIter,BIter>)",
    "insertText": "KdBVH(OIter begin, OIter end, BIter boxBegin, BIter boxEnd)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init(begin, end, boxBegin, boxEnd)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} template<Iter> void)",
    "insertText": "init(Iter begin, Iter end)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} template<OIter,BIter> void)",
    "insertText": "init(OIter begin, OIter end, BIter boxBegin, BIter boxEnd)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (objects .)",
    "insertText": "clear()"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (objects .)",
    "insertText": "insert(objects.end(), begin, end)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int n = static_cast<)",
    "insertText": "int(objects.size())"
  },
  {
    "label": "BIter()",
    "kind": "Method",
    "detail": "Function (VolumeList objBoxes ; VIPairList objCenters ; internal::get_boxes_helper<ObjectList,VolumeList,)",
    "insertText": "BIter()(objects, boxBegin, boxEnd, objBoxes)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (objCenters .)",
    "insertText": "reserve(n)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (boxes .)",
    "insertText": "reserve(n - 1)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (children .)",
    "insertText": "reserve(2 * n - 2)"
  },
  {
    "label": "build()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "build(objCenters, 0, n, objBoxes, 0)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (ObjectList)",
    "insertText": "tmp(n)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (tmp .)",
    "insertText": "swap(objects)"
  },
  {
    "label": "getRootIndex()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "getRootIndex()"
  },
  {
    "label": "getChildren()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "getChildren(Index index, VolumeIterator &outVBegin, VolumeIterator &outVEnd, ObjectIterator &outOBegin, ObjectIterator &outOEnd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (outVBegin = outVEnd ;)",
    "insertText": "if(!objects.empty()) outOBegin = &(objects[0])"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (outOEnd = outOBegin + objects .)",
    "insertText": "size()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int idx = index* 2 ;)",
    "insertText": "if(children[idx + 1] < numBoxes)"
  },
  {
    "label": "outVBegin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outVBegin(children[idx])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (outVEnd = outVBegin + 2 ; outOBegin = outOEnd ; } else)",
    "insertText": "if(children[idx] >= numBoxes)"
  },
  {
    "label": "outOBegin()",
    "kind": "Method",
    "detail": "Function (outVBegin = outVEnd ;)",
    "insertText": "outOBegin(objects[children[idx] - numBoxes])"
  },
  {
    "label": "outOBegin()",
    "kind": "Method",
    "detail": "Function (outVEnd = outVBegin + 1 ;)",
    "insertText": "outOBegin(objects[children[idx + 1] - numBoxes])"
  },
  {
    "label": "getVolume()",
    "kind": "Method",
    "detail": "Function (outOEnd = outOBegin + 1 ; } } const Volume&)",
    "insertText": "getVolume(Index index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator()(const VIPair &v1, const VIPair &v2)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(to - from > 1)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (boxes .)",
    "insertText": "push_back(objBoxes[objCenters[from].second].merged(objBoxes[objCenters[from + 1].second]))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (children .)",
    "insertText": "push_back(from + (int)objects.size() - 1)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (children .)",
    "insertText": "push_back(from + (int)objects.size())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(to - from == 3)"
  },
  {
    "label": "nth_element()",
    "kind": "Method",
    "detail": "Function (int mid = from + 2 ;)",
    "insertText": "nth_element(objCenters.begin() + from, objCenters.begin() + mid, objCenters.begin() + to, VectorComparator(dim))"
  },
  {
    "label": "build()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "build(objCenters, from, mid, objBoxes, (dim + 1) % Dim)"
  },
  {
    "label": "idx1()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "idx1(int)boxes.size()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (boxes .)",
    "insertText": "push_back(boxes[idx1].merged(objBoxes[objCenters[mid].second]))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (children .)",
    "insertText": "push_back(idx1)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (children .)",
    "insertText": "push_back(mid + (int)objects.size() - 1)"
  },
  {
    "label": "from()",
    "kind": "Method",
    "detail": "Function (} else { int mid =)",
    "insertText": "from(to - from)"
  },
  {
    "label": "build()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "build(objCenters, mid, to, objBoxes, (dim + 1) % Dim)"
  },
  {
    "label": "idx2()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "idx2(int)boxes.size()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (boxes .)",
    "insertText": "push_back(boxes[idx1].merged(boxes[idx2]))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (children .)",
    "insertText": "push_back(idx2)"
  }
]