[
  {
    "label": "FManagedStorageDefaultExternalHandleTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FManagedStorageDefaultExternalHandleTraits"
  },
  {
    "label": "FManagedStorageTraitsBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FManagedStorageTraitsBase"
  },
  {
    "label": "FManagedStorageDefaultTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FManagedStorageDefaultTraits"
  },
  {
    "label": "TManagedStorage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TManagedStorage"
  },
  {
    "label": "TManagedStorageInternalHandle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TManagedStorageInternalHandle"
  },
  {
    "label": "EGenerateNewHandleType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EGenerateNewHandleType"
  },
  {
    "label": "FAddRequest",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAddRequest"
  },
  {
    "label": "FRemoveRequest",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRemoveRequest"
  },
  {
    "label": "FStorageEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStorageEntry"
  },
  {
    "label": "TBaseRangeForIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBaseRangeForIterator"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Containers / Map . h \" # include \" Containers / SparseArray . h \" # include \" Containers / Queue . h \" # include \" EventLoop / EventLoopHandle . h \" # include \" HAL / PlatformTLS . h \" # include \" Misc / CoreMiscDefines . h \" # include \" Misc / Optional . h \" # include \" Stats / Stats . h \" # include \" Templates / Function . h \" namespace UE::EventLoop { using FManagedStorageOnRemoveComplete = TUniqueFunction<)",
    "insertText": "void()"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (struct FManagedStorageDefaultExternalHandleTraits { TCHAR Name [ ] =)",
    "insertText": "TEXT(\"ManagedStorageDefault\")"
  },
  {
    "label": "GetCurrentThreadId()",
    "kind": "Method",
    "detail": "Function (} ; struct FManagedStorageTraitsBase { uint32)",
    "insertText": "GetCurrentThreadId()"
  },
  {
    "label": "IsManagerThread()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsManagerThread(uint32 ManagerThreadId)"
  },
  {
    "label": "CheckNotInitialized()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CheckNotInitialized(uint32 ManagerThreadId)"
  },
  {
    "label": "CheckIsManagerThread()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CheckIsManagerThread(uint32 ManagerThreadId)"
  },
  {
    "label": "TManagedStorageInternalHandle()",
    "kind": "Method",
    "detail": "Function (} } ; struct FManagedStorageDefaultTraits : public FManagedStorageTraitsBase { EQueueMode QueueMode = EQueueMode::Mpsc ; using InternalHandleArryAllocatorType = TInlineAllocator<3 2> ; bool bStorageAccessThreadChecksEnabled = false ; using FExternalHandle = TResourceHandle<FManagedStorageDefaultExternalHandleTraits> ; } ; template<ElementType,Traits = FManagedStorageDefaultTraits> class TManagedStorage final : public FNoncopyable { public : template<ExternalHandleType> struct TManagedStorageInternalHandle { enum EGenerateNewHandleType { GenerateNewHandle } ;)",
    "insertText": "TManagedStorageInternalHandle() : ExternalHandle() , InternalIndex(INDEX_NONE)"
  },
  {
    "label": "TManagedStorageInternalHandle()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TManagedStorageInternalHandle(EGenerateNewHandleType, ExternalHandleType InExternalHandle, int32 InInternalIndex) : ExternalHandle(InExternalHandle) , InternalIndex(InInternalIndex)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "Invalidate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Invalidate()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TManagedStorageInternalHandle& Other)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ToString()"
  },
  {
    "label": "GetExternalHandle()",
    "kind": "Method",
    "detail": "Function (} ExternalHandleType)",
    "insertText": "GetExternalHandle()"
  },
  {
    "label": "TManagedStorage()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TManagedStorage()"
  },
  {
    "label": "IsManagerThread()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsManagerThread()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Init()"
  },
  {
    "label": "CheckNotInitialized()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckNotInitialized(ManagerThreadId)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "Update(FInternalHandleArryType* OutAddedHandles = nullptr, FInternalHandleArryType* OutRemovedHandles = nullptr)"
  },
  {
    "label": "QUICK_SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "QUICK_SCOPE_CYCLE_COUNTER(STAT_EventLoop_TManagedStorage_Update)"
  },
  {
    "label": "CheckIsManagerThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckIsManagerThread(ManagerThreadId)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32 NumChanges = 0 ;)",
    "insertText": "if(OutAddedHandles)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (FAddRequest AddRequest ;)",
    "insertText": "while(AddRequests.Dequeue(AddRequest))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutAddedHandles ->)",
    "insertText": "Add(AddImpl(AddRequest.Handle, MoveTemp(AddRequest.Data)))"
  },
  {
    "label": "AddImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddImpl(AddRequest.Handle, MoveTemp(AddRequest.Data))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + NumChanges ; } })",
    "insertText": "if(OutRemovedHandles)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (FRemoveRequest RemoveRequest ;)",
    "insertText": "while(RemoveRequests.Dequeue(RemoveRequest))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutRemovedHandles ->)",
    "insertText": "Add(RemoveImpl(RemoveRequest.Handle, RemoveRequest.OnComplete))"
  },
  {
    "label": "RemoveImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveImpl(RemoveRequest.Handle, RemoveRequest.OnComplete)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (+ + NumChanges ; } } return NumChanges ; } FExternalHandle)",
    "insertText": "Add(ElementType&& Data)"
  },
  {
    "label": "Handle()",
    "kind": "Method",
    "detail": "Function (FExternalHandle)",
    "insertText": "Handle(FExternalHandle::GenerateNewHandle)"
  },
  {
    "label": "Enqueue()",
    "kind": "Method",
    "detail": "Function (AddRequests .)",
    "insertText": "Enqueue({Handle, MoveTemp(Data)})"
  },
  {
    "label": "Enqueue()",
    "kind": "Method",
    "detail": "Function (RemoveRequests .)",
    "insertText": "Enqueue({Handle, MoveTemp(OnRemoveComplete)})"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Remove(const FInternalHandle Handle)"
  },
  {
    "label": "RemoveImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveImpl(Handle.GetExternalHandle(), nullptr)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} public : int32)",
    "insertText": "Num()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} ElementType*)",
    "insertText": "Find(FExternalHandle Handle)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} ElementType*)",
    "insertText": "Find(FInternalHandle Handle)"
  },
  {
    "label": "GetInternalIndex()",
    "kind": "Method",
    "detail": "Function (const int32 InternalIndex = Handle .)",
    "insertText": "GetInternalIndex()"
  },
  {
    "label": "TBaseRangeForIterator()",
    "kind": "Method",
    "detail": "Function (} template<bool bConst> class TBaseRangeForIterator { private : using TInternalIterator = FStorageType::TRangedForIterator ; using StorageIteratorType = std::conditional_t<bConst,FStorageType::TRangedForConstIterator,FStorageType::TRangedForIterator> ; using InternalElementType = std::conditional_t<bConst,const ElementType,ElementType> ; using ItElementType = TPair<FInternalHandle,InternalElementType&> ; public :)",
    "insertText": "TBaseRangeForIterator(StorageIteratorType InStorageIterator) : StorageIterator(InStorageIterator)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (ElementAccess .)",
    "insertText": "Emplace(ItElementType{StorageIterator->InternalHandle, StorageIterator->Data})"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } TBaseRangeForIterator&)",
    "insertText": "operator()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + StorageIterator ;)",
    "insertText": "if(StorageIterator)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } bool)",
    "insertText": "operator(const TBaseRangeForIterator& Rhs)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} TRangedForConstIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} TRangedForIterator)",
    "insertText": "end()"
  },
  {
    "label": "CheckThreadForStorageAccess()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "CheckThreadForStorageAccess()"
  },
  {
    "label": "AddImpl()",
    "kind": "Method",
    "detail": "Function (} } FInternalHandle)",
    "insertText": "AddImpl(const FExternalHandle Handle, ElementType&& Data)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (FSparseArrayAllocationInfo Allocation = Storage .)",
    "insertText": "AddUninitialized()"
  },
  {
    "label": "InternalHandle()",
    "kind": "Method",
    "detail": "Function (FInternalHandle)",
    "insertText": "InternalHandle(FInternalHandle::GenerateNewHandle, Handle, Allocation.Index)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(Allocation)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (InternalHandle,)",
    "insertText": "MoveTemp(Data)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (StorageHandleIndex .)",
    "insertText": "Add(Handle, Allocation.Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 FoundIndex = INDEX_NONE ; FInternalHandle InternalHandle ;)",
    "insertText": "if(StorageHandleIndex.RemoveAndCopyValue(Handle, FoundIndex) && Storage.IsValidIndex(FoundIndex))"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (InternalHandle = Storage [ FoundIndex ] . InternalHandle ; Storage .)",
    "insertText": "RemoveAt(FoundIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(OnComplete)"
  },
  {
    "label": "OnComplete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnComplete()"
  }
]