[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "ObjectType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ObjectType"
  },
  {
    "label": "TSharedRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSharedRef"
  },
  {
    "label": "TSharedPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSharedPtr"
  },
  {
    "label": "TestName",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TestName"
  },
  {
    "label": "TTuple",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TTuple"
  },
  {
    "label": "Catch",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Catch"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# pragma once # ifndef UE_ENABLE_TESTHARNESS_ENGINE_SUPPORT # define UE_ENABLE_TESTHARNESS_ENGINE_SUPPORT 1 # endif # if UE_ENABLE_TESTHARNESS_ENGINE_SUPPORT # include \" CoreTypes . h \" # include \" Containers / ContainersFwd . h \" # include \" Containers / StringFwd . h \" # if PLATFORM_MAC # include \" HAL / PlatformMath . h \" # endif # include<ostream> std::ostream&)",
    "insertText": "operator(std::ostream& Stream, const TCHAR* Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (std::ostream&)",
    "insertText": "operator(std::ostream& Stream, const FString& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (std::ostream&)",
    "insertText": "operator(std::ostream& Stream, const FAnsiStringView& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (std::ostream&)",
    "insertText": "operator(std::ostream& Stream, const FWideStringView& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (std::ostream&)",
    "insertText": "operator(std::ostream& Stream, const FUtf8StringView& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (std::ostream&)",
    "insertText": "operator(std::ostream& Stream, const FAnsiStringBuilderBase& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (std::ostream&)",
    "insertText": "operator(std::ostream& Stream, const FWideStringBuilderBase& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (std::ostream&)",
    "insertText": "operator(std::ostream& Stream, const FUtf8StringBuilderBase& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (enum class ESPMode : uint8 ; template<class ObjectType,ESPMode InMode> class TSharedRef ; template<class ObjectType,ESPMode InMode> class TSharedPtr ; template<ObjectType,ESPMode Mode> std::ostream&)",
    "insertText": "operator(std::ostream& Stream, const TSharedRef<ObjectType, Mode>& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<ObjectType,ESPMode Mode> std::ostream&)",
    "insertText": "operator(std::ostream& Stream, const TSharedPtr<ObjectType, Mode>& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<KeyT,ValueT> bool)",
    "insertText": "operator(const TMap<KeyT, ValueT>& Left, const TMap<KeyT, ValueT>& Right)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (bool bIsEqual = Left .)",
    "insertText": "Num() == Right.Num()"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (const ValueT* RightValue = Right .)",
    "insertText": "Find(Pair.Key)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (bIsEqual = bIsEqual&& RightValue ! = nullptr&& Pair . Value = =* RightValue ; } } return bIsEqual ; } # if)",
    "insertText": "defined(THIRD_PARTY_INCLUDES_START) && defined(THIRD_PARTY_INCLUDES_END) THIRD_PARTY_INCLUDES_START #endif #ifdef _MSC_VER #pragma pack(push, 8) #pragma warning(push) #pragma warning(disable: 4005) #pragma warning(disable: 4582) #pragma warning(disable: 4583) #endif #include <catch2/catch_test_macros.hpp> #ifdef _MSC_VER #pragma warning(pop) #pragma pack(pop) #endif #if defined(THIRD_PARTY_INCLUDES_START) && defined(THIRD_PARTY_INCLUDES_END) THIRD_PARTY_INCLUDES_END #endif #define LLT_CONCAT_(x, y) x##y #define LLT_CONCAT(x, y) LLT_CONCAT_(x,y) #define DISABLED_TEST_CASE_METHOD_INTERNAL(TestName, ClassName, ...)"
  },
  {
    "label": "INTERNAL_CATCH_REMOVE_PARENS()",
    "kind": "Method",
    "detail": "Function (\\ struct TestName :)",
    "insertText": "INTERNAL_CATCH_REMOVE_PARENS(ClassName)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (\\ void)",
    "insertText": "test()"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (\\ } ; \\ } \\ CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\ void)",
    "insertText": "test() #define DISABLED_TEST_CASE(...) static void LLT_CONCAT(disabled_test_,__LINE__)() #define DISABLED_TEST_CASE_METHOD(ClassName, ...) \\ DISABLED_TEST_CASE_METHOD_INTERNAL(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), ClassName, __VA_ARGS__) #define DISABLED_SCENARIO(...) static void LLT_CONCAT(disabled_scenario_,__LINE__)() #define DISABLED_SECTION(...) auto LLT_CONCAT(disabled_section_,__LINE__) = []()"
  },
  {
    "label": "convert()",
    "kind": "Method",
    "detail": "Function (template<KeyType,ValueType> struct Catch::StringMaker<TTuple<KeyType,ValueType>> { std::string)",
    "insertText": "convert(const TTuple<KeyType, ValueType>& Value)"
  },
  {
    "label": "TEST_CASE_NAMED()",
    "kind": "Method",
    "detail": "Function (} } ; # define)",
    "insertText": "TEST_CASE_NAMED(ClassName, ...) TEST_CASE(__VA_ARGS__) #define VERIFY(What, Actual)\\ CAPTURE(What)"
  },
  {
    "label": "CHECK()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CHECK(Actual == true) #define ADD_WARNING(What)\\ WARN(What) #define ADD_ERROR(What)\\ FAIL(What) #define FAIL_ON_MESSAGE(What) #define CHECK_EQUAL(Actual, Expected)\\ CHECK(Actual == Expected) #define CHECK_NOT_EQUAL(Actual, Expected)\\ CHECK(Actual != Expected) #define CHECK_MESSAGE(What, Value)"
  },
  {
    "label": "INFO()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "INFO(What)"
  },
  {
    "label": "CHECK()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CHECK((Value)==true)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(false) #define CHECK_FALSE_MESSAGE(What, Value)"
  },
  {
    "label": "CHECK_FALSE()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CHECK_FALSE(Value)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(false) #define REQUIRE_EQUAL(Actual, Expected)\\ REQUIRE(Actual == Expected) #define REQUIRE_NOT_EQUAL(Actual, Expected)\\ REQUIRE(Actual != Expected) #define REQUIRE_MESSAGE(What, Value)"
  },
  {
    "label": "REQUIRE()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "REQUIRE((Value)==true)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(false) #define TEST_TRUE(What, Value)\\ INFO(What)"
  },
  {
    "label": "CHECK()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CHECK((Value)==true) #define TEST_FALSE(What, Value)\\ INFO(What)"
  },
  {
    "label": "CHECK()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CHECK((Value)==false) #define TEST_EQUAL(What, Actual, Expected)\\ INFO(What)"
  },
  {
    "label": "CHECK()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CHECK((Actual) == (Expected)) #define TEST_EQUAL_STR(What, Expected, Actual)\\ INFO(What)"
  },
  {
    "label": "CAPTURE()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CAPTURE(Actual)"
  },
  {
    "label": "CHECK()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CHECK(FCString::Strcmp(ToCStr((Expected)), ToCStr((Actual))) == 0) #define TEST_NOT_EQUAL(What, Actual, Expected)\\ INFO(What)"
  },
  {
    "label": "CHECK()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CHECK((Actual) != (Expected)) #define TEST_NULL(What, Value)\\ INFO(What)"
  },
  {
    "label": "CHECK()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CHECK((Value)==nullptr) #define TEST_NOT_NULL(What, Value)\\ INFO(What)"
  },
  {
    "label": "CHECK()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CHECK((Value)!=nullptr) #define TEST_VALID(What, Value)\\ INFO(What)"
  },
  {
    "label": "CHECK()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "CHECK(Value.IsValid()==true) #define TEST_INVALID(What, Value)\\ INFO(What)"
  }
]