[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "padded_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "padded_base"
  },
  {
    "label": "padded",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "padded"
  },
  {
    "label": "no_assign",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "no_assign"
  },
  {
    "label": "no_copy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "no_copy"
  },
  {
    "label": "mutex_copy_deprecated_and_disabled",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "mutex_copy_deprecated_and_disabled"
  },
  {
    "label": "version_tag_v3",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "version_tag_v3"
  },
  {
    "label": "split",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "split"
  },
  {
    "label": "proportional_split",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "proportional_split"
  },
  {
    "label": "allocator_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "allocator_type"
  },
  {
    "label": "bool_constant",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "bool_constant"
  },
  {
    "label": "select_size_t_constant",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "select_size_t_constant"
  },
  {
    "label": "STATIC_ASSERTION_FAILED",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "STATIC_ASSERTION_FAILED"
  },
  {
    "label": "__TBB_STRING_AUX()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_tbb_stddef_H # define __TBB_tbb_stddef_H # define TBB_VERSION_MAJOR 2 0 1 9 # define TBB_VERSION_MINOR 0 # define TBB_INTERFACE_VERSION 1 1 0 0 8 # define TBB_INTERFACE_VERSION_MAJOR TBB_INTERFACE_VERSION / 1 0 0 0 # define TBB_COMPATIBLE_INTERFACE_VERSION 2 # define)",
    "insertText": "__TBB_STRING_AUX(x) #x #define __TBB_STRING(x) __TBB_STRING_AUX(x) #if !defined RC_INVOKED #include \"tbb_config.h\" #if _MSC_VER >=1400 #define __TBB_EXPORTED_FUNC __cdecl #define __TBB_EXPORTED_METHOD __thiscall #else #define __TBB_EXPORTED_FUNC #define __TBB_EXPORTED_METHOD #endif #if __INTEL_COMPILER || _MSC_VER #define __TBB_NOINLINE(decl) __declspec(noinline) decl #elif __GNUC__ #define __TBB_NOINLINE(decl) decl __attribute__ ((noinline)) #else #define __TBB_NOINLINE(decl) decl #endif #if __TBB_NOEXCEPT_PRESENT #define __TBB_NOEXCEPT(expression) noexcept(expression) #else #define __TBB_NOEXCEPT(expression) #endif #include <cstddef> #if _MSC_VER #define __TBB_tbb_windef_H #include \"internal/_tbb_windef.h\" #undef __TBB_tbb_windef_H #endif #if !defined(_MSC_VER) || _MSC_VER>=1600 #include <stdint.h> #endif typedef void(*assertion_handler_type)( const char* filename, int line, const char* expression, const char * comment)"
  },
  {
    "label": "__TBB_ASSERT_RELEASE()",
    "kind": "Method",
    "detail": "Function (# if __TBBMALLOC_BUILD namespace rml { namespace internal { # define)",
    "insertText": "__TBB_ASSERT_RELEASE(predicate,message) ((predicate)?((void)0) : rml::internal::assertion_failure(__FILE__,__LINE__,#predicate,message))"
  },
  {
    "label": "__TBB_ASSERT_RELEASE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "__TBB_ASSERT_RELEASE(predicate,message) ((predicate)?((void)0) : tbb::assertion_failure(__FILE__,__LINE__,#predicate,message)) #endif assertion_handler_type __TBB_EXPORTED_FUNC set_assertion_handler( assertion_handler_type new_handler)"
  },
  {
    "label": "assertion_failure()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "assertion_failure(const char* filename, int line, const char* expression, const char* comment)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (# if __TBBMALLOC_BUILD } } # else } # endif # if TBB_USE_ASSERT # define)",
    "insertText": "__TBB_ASSERT(predicate,message) __TBB_ASSERT_RELEASE(predicate,message) #define __TBB_ASSERT_EX __TBB_ASSERT #else #define __TBB_ASSERT(predicate,comment) ((void)0) #define __TBB_ASSERT_EX(predicate,comment) ((void)(1 && (predicate)))"
  },
  {
    "label": "TBB_runtime_interface_version()",
    "kind": "Method",
    "detail": "Function (namespace internal { # if _MSC_VER&& _MSC_VER<1 6 0 0 typedef __int8 int8_t ; typedef __int16 int16_t ; typedef __int32 int32_t ; typedef __int64 int64_t ; typedef unsigned __int8 uint8_t ; typedef unsigned __int16 uint16_t ; typedef unsigned __int32 uint32_t ; typedef unsigned __int64 uint64_t ; # else using::int8_t ; using::int16_t ; using::int32_t ; using::int64_t ; using::uint8_t ; using::uint16_t ; using::uint32_t ; using::uint64_t ; # endif } using std::size_t ; using std::ptrdiff_t ; \" C \" int __TBB_EXPORTED_FUNC)",
    "insertText": "TBB_runtime_interface_version()"
  },
  {
    "label": "__attribute__()",
    "kind": "Method",
    "detail": "Function (namespace internal { const size_t NFS_MaxLineSize = 1 2 8 ; # define __TBB_atomic # if __TBB_OVERRIDE_PRESENT # define __TBB_override override # else # define __TBB_override # endif # if __TBB_CPP17_FALLTHROUGH_PRESENT # define __TBB_fallthrough [ [ fallthrough ] ] # elif __TBB_FALLTHROUGH_PRESENT # define __TBB_fallthrough)",
    "insertText": "__attribute__((fallthrough))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (char pad [ S - R ] ; } ; template<class T,size_t S> struct padded_base<T,S,0> : T { } ; template<class T,size_t S = NFS_MaxLineSize> struct padded : padded_base<T,S,)",
    "insertText": "sizeof(T)"
  },
  {
    "label": "__TBB_offsetof()",
    "kind": "Method",
    "detail": "Function (} ; # define)",
    "insertText": "__TBB_offsetof(class_name, member_name) \\ ((ptrdiff_t)&(reinterpret_cast<class_name*>(0x1000)->member_name) - 0x1000) #define __TBB_get_object_ref(class_name, member_name, member_addr) \\ (*reinterpret_cast<class_name*>((char*)member_addr - __TBB_offsetof(class_name, member_name))) void __TBB_EXPORTED_FUNC handle_perror( int error_code, const char* aux_info)"
  },
  {
    "label": "__TBB_CATCH()",
    "kind": "Method",
    "detail": "Function (# if TBB_USE_EXCEPTIONS # define __TBB_TRY try # define)",
    "insertText": "__TBB_CATCH(e) catch(e) #define __TBB_THROW(e) throw e #define __TBB_RETHROW() throw #else inline bool __TBB_false()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (# if TBB_USE_ASSERT void* const poisoned_ptr = reinterpret_cast<)",
    "insertText": "void(-1)"
  },
  {
    "label": "poison_pointer()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "poison_pointer(T* __TBB_atomic & p)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (p = reinterpret_cast<)",
    "insertText": "T(poisoned_ptr)"
  },
  {
    "label": "is_poisoned()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "is_poisoned(T* p)"
  },
  {
    "label": "poison_pointer()",
    "kind": "Method",
    "detail": "Function (} # else template<T> void)",
    "insertText": "poison_pointer(T* __TBB_atomic &)"
  },
  {
    "label": "punned_cast()",
    "kind": "Method",
    "detail": "Function (} # endif template<T,U> T)",
    "insertText": "punned_cast(U* ptr)"
  },
  {
    "label": "uintptr_t()",
    "kind": "Method",
    "detail": "Function (uintptr_t x = reinterpret_cast<)",
    "insertText": "uintptr_t(ptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} class no_assign { void)",
    "insertText": "operator(const no_assign&)"
  },
  {
    "label": "no_assign()",
    "kind": "Method",
    "detail": "Function (public : # if __GNUC__)",
    "insertText": "no_assign()"
  },
  {
    "label": "no_copy()",
    "kind": "Method",
    "detail": "Function (} # endif } ; class no_copy : no_assign {)",
    "insertText": "no_copy(const no_copy&)"
  },
  {
    "label": "no_copy()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "no_copy()"
  },
  {
    "label": "is_aligned()",
    "kind": "Method",
    "detail": "Function (} } ; # if TBB_DEPRECATED_MUTEX_COPYING class mutex_copy_deprecated_and_disabled { } ; # else class mutex_copy_deprecated_and_disabled : no_copy { } ; # endif template<T> bool)",
    "insertText": "is_aligned(T* pointer, uintptr_t alignment)"
  },
  {
    "label": "is_power_of_two()",
    "kind": "Method",
    "detail": "Function (} template<integer_type> bool)",
    "insertText": "is_power_of_two(integer_type arg)"
  },
  {
    "label": "modulo_power_of_two()",
    "kind": "Method",
    "detail": "Function (} template<argument_integer_type,divisor_integer_type> argument_integer_type)",
    "insertText": "modulo_power_of_two(argument_integer_type arg, divisor_integer_type divisor)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(is_power_of_two(divisor), \"Divisor should be a power of two\")"
  },
  {
    "label": "is_power_of_two_at_least()",
    "kind": "Method",
    "detail": "Function (} template<argument_integer_type,power2_integer_type> bool)",
    "insertText": "is_power_of_two_at_least(argument_integer_type arg, power2_integer_type power2)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(is_power_of_two(power2), \"Divisor should be a power of two\")"
  },
  {
    "label": "suppress_unused_warning()",
    "kind": "Method",
    "detail": "Function (} template<T1> void)",
    "insertText": "suppress_unused_warning(const T1&)"
  },
  {
    "label": "suppress_unused_warning()",
    "kind": "Method",
    "detail": "Function (} template<T1,T2> void)",
    "insertText": "suppress_unused_warning(const T1&, const T2&)"
  },
  {
    "label": "suppress_unused_warning()",
    "kind": "Method",
    "detail": "Function (} template<T1,T2,T3> void)",
    "insertText": "suppress_unused_warning(const T1&, const T2&, const T3&)"
  },
  {
    "label": "proportional_split()",
    "kind": "Method",
    "detail": "Function (} struct version_tag_v3 { } ; typedef version_tag_v3 version_tag ; } class split { } ; class proportional_split : internal::no_assign { public :)",
    "insertText": "proportional_split(size_t _left = 1, size_t _right = 1) : my_left(_left), my_right(_right)"
  },
  {
    "label": "left()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "left()"
  },
  {
    "label": "set_proportion()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_ENABLE_RANGE_FEEDBACK void)",
    "insertText": "set_proportion(size_t _left, size_t _right)"
  },
  {
    "label": "make_unique()",
    "kind": "Method",
    "detail": "Function (my_left = _left ; my_right = _right ; } # endif private : size_t my_left,my_right ; } ; } # if __TBB_CPP11_SMART_POINTERS_PRESENT # include<memory> # endif # if __TBB_CPP11_RVALUE_REF_PRESENT | | __TBB_CPP11_DECLTYPE_PRESENT | | _LIBCPP_VERSION # include<utility> # endif namespace tbb { namespace internal { # if __TBB_CPP11_SMART_POINTERS_PRESENT&& __TBB_CPP11_RVALUE_REF_PRESENT&& __TBB_CPP11_VARIADIC_TEMPLATES_PRESENT template<T,. . . Args> std::unique_ptr<T>)",
    "insertText": "make_unique(Args&&... args)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} # endif template<T> struct allocator_type { typedef T value_type ; } ; # if _MSC_VER template<T> struct allocator_type<const T> { typedef T value_type ; } ; # endif template<bool v> struct bool_constant { const bool value = v ; } ; typedef bool_constant<true> true_type ; typedef bool_constant<false> false_type ; template<unsigned u,unsigned long long ull> struct select_size_t_constant { const size_t)",
    "insertText": "value(size_t)((sizeof(size_t)==sizeof(u)) ? u : ull)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} ; # if __TBB_CPP11_RVALUE_REF_PRESENT using std::move ; using std::forward ; # elif)",
    "insertText": "defined(_LIBCPP_NAMESPACE)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (using std::_LIBCPP_NAMESPACE::forward ; # else template<T> T&)",
    "insertText": "move(T& x)"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (# else using std::declval ; # endif # endif template<bool condition> struct STATIC_ASSERTION_FAILED ; template<> struct STATIC_ASSERTION_FAILED<false> { enum { value = 1 } ; } ; template<> struct STATIC_ASSERTION_FAILED<true> ; } } # if __TBB_STATIC_ASSERT_PRESENT # define)",
    "insertText": "__TBB_STATIC_ASSERT(condition,msg) static_assert(condition,msg) #else #define __TBB_STATIC_ASSERT_IMPL1(condition,msg,line)"
  }
]