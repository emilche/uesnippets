[
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "DefaultHierarchicalTimingWheelHandleAccessor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DefaultHierarchicalTimingWheelHandleAccessor"
  },
  {
    "label": "GetDelayedRunTime",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GetDelayedRunTime"
  },
  {
    "label": "Compare",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Compare"
  },
  {
    "label": "HierarchicalTimingWheel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HierarchicalTimingWheel"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TASK_SEQUENCE_MANAGER_HIERARCHICAL_TIMING_WHEEL_H_ # define BASE_TASK_SEQUENCE_MANAGER_HIERARCHICAL_TIMING_WHEEL_H_ # include<algorithm> # include<array> # include<numeric> # include<vector> # include \" base / containers / intrusive_heap . h \" # include \" base / task / sequence_manager / timing_wheel . h \" # include \" base / time / time . h \" # include \" third_party / abseil - cpp / absl / types / optional . h \" namespace base::sequence_manager { class BASE_EXPORT HierarchicalTimingWheelHandle { public : enum : size_t { kInvalidIndex = std::numeric_limits<size_t)",
    "insertText": "max()"
  },
  {
    "label": "HierarchicalTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HierarchicalTimingWheelHandle()"
  },
  {
    "label": "HierarchicalTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HierarchicalTimingWheelHandle(const HierarchicalTimingWheelHandle& other)"
  },
  {
    "label": "HierarchicalTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HierarchicalTimingWheelHandle(HierarchicalTimingWheelHandle&& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (HierarchicalTimingWheelHandle&)",
    "insertText": "operator(const HierarchicalTimingWheelHandle& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (HierarchicalTimingWheelHandle&)",
    "insertText": "operator(HierarchicalTimingWheelHandle&& other)"
  },
  {
    "label": "GetTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (internal::TimingWheelHandle)",
    "insertText": "GetTimingWheelHandle()"
  },
  {
    "label": "SetTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTimingWheelHandle(internal::TimingWheelHandle timing_wheel_handle)"
  },
  {
    "label": "ClearTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearTimingWheelHandle()"
  },
  {
    "label": "GetHeapHandle()",
    "kind": "Method",
    "detail": "Function (HeapHandle)",
    "insertText": "GetHeapHandle()"
  },
  {
    "label": "SetHeapHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetHeapHandle(HeapHandle handle)"
  },
  {
    "label": "ClearHeapHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearHeapHandle()"
  },
  {
    "label": "GetHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetHierarchyIndex()"
  },
  {
    "label": "SetHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetHierarchyIndex(size_t hierarchy_index)"
  },
  {
    "label": "ClearHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearHierarchyIndex()"
  },
  {
    "label": "Invalid()",
    "kind": "Method",
    "detail": "Function (HierarchicalTimingWheelHandle)",
    "insertText": "Invalid()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "SetTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (private : internal::TimingWheelHandle timing_wheel_handle_ ; HeapHandle heap_handle_ ; size_t hierarchy_index_ = kInvalidIndex ; } ; template<T> struct DefaultHierarchicalTimingWheelHandleAccessor { void)",
    "insertText": "SetTimingWheelHandle(T* element, internal::TimingWheelHandle handle)"
  },
  {
    "label": "handle()",
    "kind": "Method",
    "detail": "Function (HierarchicalTimingWheelHandle* htw_handle = element ->)",
    "insertText": "handle()"
  },
  {
    "label": "SetTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (htw_handle ->)",
    "insertText": "SetTimingWheelHandle(handle)"
  },
  {
    "label": "ClearTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearTimingWheelHandle(T* element)"
  },
  {
    "label": "GetHeapHandle()",
    "kind": "Method",
    "detail": "Function (} HeapHandle)",
    "insertText": "GetHeapHandle(const T* element)"
  },
  {
    "label": "SetHeapHandle()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetHeapHandle(T* element, HeapHandle handle)"
  },
  {
    "label": "SetHeapHandle()",
    "kind": "Method",
    "detail": "Function (htw_handle ->)",
    "insertText": "SetHeapHandle(handle)"
  },
  {
    "label": "ClearHeapHandle()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearHeapHandle(T* element)"
  },
  {
    "label": "SetHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetHierarchyIndex(T* element, size_t hierarchy_index)"
  },
  {
    "label": "SetHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (htw_handle ->)",
    "insertText": "SetHierarchyIndex(hierarchy_index)"
  },
  {
    "label": "ClearHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearHierarchyIndex(T* element)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct GetDelayedRunTime { TimeTicks)",
    "insertText": "operator()(const T& element)"
  },
  {
    "label": "HierarchicalTimingWheel()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "HierarchicalTimingWheel(HierarchicalTimingWheel&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (HierarchicalTimingWheel&)",
    "insertText": "operator(HierarchicalTimingWheel&&)"
  },
  {
    "label": "HierarchicalTimingWheel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HierarchicalTimingWheel(const HierarchicalTimingWheel&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (HierarchicalTimingWheel&)",
    "insertText": "operator(const HierarchicalTimingWheel&)"
  },
  {
    "label": "HierarchicalTimingWheel()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "HierarchicalTimingWheel()"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "Size()"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (} std::vector<T>::const_iterator)",
    "insertText": "Insert(T element)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(get_delayed_run_time_(element) > last_wakeup_)"
  },
  {
    "label": "get_delayed_run_time_()",
    "kind": "Method",
    "detail": "Function (const TimeDelta delay =)",
    "insertText": "get_delayed_run_time_(element)"
  },
  {
    "label": "FindHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (const size_t hierarchy_index =)",
    "insertText": "FindHierarchyIndex(delay)"
  },
  {
    "label": "GetHeapForHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (auto& heap =)",
    "insertText": "GetHeapForHierarchyIndex(hierarchy_index)"
  },
  {
    "label": "SetHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (hierarchical_timing_wheel_handle_accessor_ .)",
    "insertText": "SetHierarchyIndex(&element, hierarchy_index)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (auto it = heap .)",
    "insertText": "insert(std::move(element))"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (auto it = wheel .)",
    "insertText": "Insert(std::move(element), delay)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(now >= last_wakeup_)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (std::vector<T> expired_elements ;)",
    "insertText": "while(!small_delay_heap_.empty() && get_delayed_run_time_(small_delay_heap_.top()) <= now)"
  },
  {
    "label": "take_top()",
    "kind": "Method",
    "detail": "Function (T element = small_delay_heap_ .)",
    "insertText": "take_top()"
  },
  {
    "label": "ClearHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (hierarchical_timing_wheel_handle_accessor_ .)",
    "insertText": "ClearHierarchyIndex(&element)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (expired_elements .)",
    "insertText": "push_back(std::move(element))"
  },
  {
    "label": "Pow()",
    "kind": "Method",
    "detail": "Function (} std::vector<T> elements ; const TimeDelta time_delta = now - last_wakeup_ ; const size_t timing_wheels_delay_upperbound = SmallestBucketDeltaInMicroseconds*)",
    "insertText": "Pow(WheelSize, TotalWheels)"
  },
  {
    "label": "Milliseconds()",
    "kind": "Method",
    "detail": "Function (const TimeTicks timing_wheels_maximum_delayed_run_time = now +)",
    "insertText": "Milliseconds(timing_wheels_delay_upperbound)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (last_wakeup_ = now ;)",
    "insertText": "for(size_t wheel_index = 0; wheel_index < TotalWheels; wheel_index++)"
  },
  {
    "label": "AdvanceTimeAndRemoveExpiredElements()",
    "kind": "Method",
    "detail": "Function (wheels_ [ wheel_index ] .)",
    "insertText": "AdvanceTimeAndRemoveExpiredElements(time_delta, elements)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(!large_delay_heap_.empty() && get_delayed_run_time_(large_delay_heap_.top()) < timing_wheels_maximum_delayed_run_time)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (elements .)",
    "insertText": "push_back(std::move(large_delay_heap_.take_top()))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(auto& element : elements)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (expired_elements .)",
    "insertText": "emplace_back(std::move(element))"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "Insert(std::move(element))"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} } return expired_elements ; } void)",
    "insertText": "Remove(HierarchicalTimingWheelHandle& handle)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(handle.IsValid())"
  },
  {
    "label": "GetTimingWheelForHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (auto& wheel =)",
    "insertText": "GetTimingWheelForHierarchyIndex(handle.GetHierarchyIndex())"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (wheel .)",
    "insertText": "Remove(handle.GetTimingWheelHandle())"
  },
  {
    "label": "GetHeapForHierarchyIndex()",
    "kind": "Method",
    "detail": "Function (} else { auto& heap =)",
    "insertText": "GetHeapForHierarchyIndex(handle.GetHierarchyIndex())"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (heap .)",
    "insertText": "erase(handle.GetHeapHandle())"
  },
  {
    "label": "Top()",
    "kind": "Method",
    "detail": "Function (} } std::vector<T>::const_reference)",
    "insertText": "Top()"
  },
  {
    "label": "DCHECK_NE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_NE(Size(), 0u)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(size_t i = 0; i < TotalWheels; i++)"
  },
  {
    "label": "top()",
    "kind": "Method",
    "detail": "Function (} } return large_delay_heap_ .)",
    "insertText": "top()"
  },
  {
    "label": "IsHeap()",
    "kind": "Method",
    "detail": "Function (} private : bool)",
    "insertText": "IsHeap(size_t hierarchy_index)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(hierarchy_index == 0 || hierarchy_index == TotalWheels + 1)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(hierarchy_index > 0)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(hierarchy_index < TotalWheels + 1)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!delay.is_zero())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t res = 1 ;)",
    "insertText": "for(size_t i = 0; i < b; i++)"
  },
  {
    "label": "MakeWheels()",
    "kind": "Method",
    "detail": "Function (res* = a ; } return res ; } using Wheel = internal::TimingWheel<T,WheelSize,HierarchicalTimingWheelHandleAccessor,GetDelayedRunTime> ; template<size_t . . . I> std::array<Wheel,TotalWheels>)",
    "insertText": "MakeWheels(std::index_sequence<I...>)"
  },
  {
    "label": "MakeWheels()",
    "kind": "Method",
    "detail": "Function (} std::array<Wheel,TotalWheels> wheels_ =)",
    "insertText": "MakeWheels(std::make_index_sequence<TotalWheels>{})"
  }
]