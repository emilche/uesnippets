[
  {
    "label": "TTwoWayMap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TTwoWayMap"
  },
  {
    "label": "TBijectionMaps",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TBijectionMaps"
  },
  {
    "label": "FPairValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPairValue"
  },
  {
    "label": "GetFirstToSecond()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Map . h \" template<ClassT,FirstType,SecondType> struct TTwoWayMap { typedef TArray<TPair<FirstType,SecondType>> InitListType ; const TMap<FirstType,SecondType>&)",
    "insertText": "GetFirstToSecond()"
  },
  {
    "label": "InitIfNeeded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitIfNeeded()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (FirstToSecond .)",
    "insertText": "Reserve(ClassT::PairDefinitions.Num())"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (FirstToSecond .)",
    "insertText": "Emplace(Pair.Key, Pair.Value)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (SecondToFirst .)",
    "insertText": "Emplace(Pair.Value, Pair.Key)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} ClassT::PairDefinitions .)",
    "insertText": "Reset()"
  },
  {
    "label": "SecondType()",
    "kind": "Method",
    "detail": "Function (} } protected : TMap<FirstType,SecondType> FirstToSecond = TMap<FirstType,)",
    "insertText": "SecondType()"
  },
  {
    "label": "FirstType()",
    "kind": "Method",
    "detail": "Function (TMap<SecondType,FirstType> SecondToFirst = TMap<SecondType,)",
    "insertText": "FirstType()"
  },
  {
    "label": "TBijectionMaps()",
    "kind": "Method",
    "detail": "Function (} ; template<DomainType,RangeType> struct TBijectionMaps { protected : struct FPairValue { const DomainType X ; const RangeType Y ; } ; public :)",
    "insertText": "TBijectionMaps()"
  },
  {
    "label": "TBijectionMaps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TBijectionMaps(const std::initializer_list<FPairValue>& InitList)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (Image .)",
    "insertText": "Emplace(Pair.X, Pair.Y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ensureAlwaysMsgf(!PreImage.Contains(Pair.Y), TEXT(\"This cannot be a bijection if there is a duplicate range entry\")))"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (PreImage .)",
    "insertText": "Emplace(Pair.Y, Pair.X)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} } } const DomainType*)",
    "insertText": "Find(const RangeType& InValue)"
  },
  {
    "label": "FindChecked()",
    "kind": "Method",
    "detail": "Function (} const DomainType&)",
    "insertText": "FindChecked(const RangeType& InValue)"
  },
  {
    "label": "FindChecked()",
    "kind": "Method",
    "detail": "Function (} const RangeType&)",
    "insertText": "FindChecked(const DomainType& InValue)"
  },
  {
    "label": "DomainType()",
    "kind": "Method",
    "detail": "Function (TMap<RangeType,DomainType> PreImage = TMap<RangeType,)",
    "insertText": "DomainType()"
  }
]