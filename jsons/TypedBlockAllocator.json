[
  {
    "label": "TTypedBlockAllocatorBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TTypedBlockAllocatorBase"
  },
  {
    "label": "FAllocationBlock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAllocationBlock"
  },
  {
    "label": "TTypedBlockAllocatorFreeList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TTypedBlockAllocatorFreeList"
  },
  {
    "label": "TTypedBlockAllocatorResetList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TTypedBlockAllocatorResetList"
  },
  {
    "label": "SetMinBlockSize()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / ArrayView . h \" # include \" HAL / Platform . h \" # include \" HAL / PlatformMath . h \" # include \" Templates / TypeCompatibleBytes . h \" # include \" Templates / UniquePtr . h \" # include \" Templates / UnrealTemplate . h \" template<ElementType> class TTypedBlockAllocatorBase { public : void)",
    "insertText": "SetMinBlockSize(int32 BlockSize)"
  },
  {
    "label": "GetMinBlockSize()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetMinBlockSize()"
  },
  {
    "label": "SetMaxBlockSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaxBlockSize(int32 BlockSize)"
  },
  {
    "label": "GetMaxBlockSize()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetMaxBlockSize()"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (ElementType*)",
    "insertText": "Alloc()"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(ElementType* Element)"
  },
  {
    "label": "NewElement()",
    "kind": "Method",
    "detail": "Function (template<. . . ArgsType> ElementType*)",
    "insertText": "NewElement(ArgsType&&... Args)"
  },
  {
    "label": "DeleteElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeleteElement(ElementType* Element)"
  },
  {
    "label": "EnumerateAllocations()",
    "kind": "Method",
    "detail": "Function (template<CallbackType> void)",
    "insertText": "EnumerateAllocations(CallbackType&& Callback)"
  },
  {
    "label": "ReserveDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReserveDelta(int32 AllocationCount, int32 InMaxBlockSize = 0)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "FAllocationBlock()",
    "kind": "Method",
    "detail": "Function (protected : struct FAllocationBlock {)",
    "insertText": "FAllocationBlock(int32 InCapacity)"
  },
  {
    "label": "BaseAlloc()",
    "kind": "Method",
    "detail": "Function (TUniquePtr<TTypeCompatibleBytes<ElementType> [ ]> Elements ; int32 NextIndex ; int32 Capacity ; } ; ElementType*)",
    "insertText": "BaseAlloc()"
  },
  {
    "label": "BaseEnumerateAllocations()",
    "kind": "Method",
    "detail": "Function (template<CallbackType> void)",
    "insertText": "BaseEnumerateAllocations(CallbackType&& Callback)"
  },
  {
    "label": "BaseReserveDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BaseReserveDelta(int32 AllocationCount, int32 InMaxBlockSize, int32 NumAvailableOnFreeList)"
  },
  {
    "label": "BaseEmpty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BaseEmpty()"
  },
  {
    "label": "CallDestructorInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CallDestructorInternal(ElementType* Element)"
  },
  {
    "label": "TTypedBlockAllocatorResetList()",
    "kind": "Method",
    "detail": "Function (protected : using TTypedBlockAllocatorBase<ElementType>::BaseAlloc ; using TTypedBlockAllocatorBase<ElementType>::BaseEnumerateAllocations ; using TTypedBlockAllocatorBase<ElementType>::BaseReserveDelta ; using TTypedBlockAllocatorBase<ElementType>::BaseEmpty ; using TTypedBlockAllocatorBase<ElementType>::CallDestructorInternal ; using TTypedBlockAllocatorBase<ElementType>::NumAllocations ; using TTypedBlockAllocatorBase<ElementType>::NumFreed ; protected : ElementType* FreeList = nullptr ; } ; template<ElementType> class TTypedBlockAllocatorResetList : public TTypedBlockAllocatorBase<ElementType> { public : ~)",
    "insertText": "TTypedBlockAllocatorResetList()"
  },
  {
    "label": "ReallocFreeList()",
    "kind": "Method",
    "detail": "Function (using TTypedBlockAllocatorBase<ElementType>::DeleteElement ; void)",
    "insertText": "ReallocFreeList(int32 NewCapacity)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MinBlockSize =)",
    "insertText": "Max(BlockSize, 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (ElementType* Result = nullptr ; FAllocationBlock* Block = nullptr ;)",
    "insertText": "for(; NextBlock < Blocks.Num(); ++NextBlock)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Block =& Blocks [ NextBlock ] ; break ; } })",
    "insertText": "if(!Block)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (int32 BlockCapacity =)",
    "insertText": "Max(NumAllocations, MinBlockSize)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (BlockCapacity =)",
    "insertText": "Min(BlockCapacity, MaxBlockSize)"
  },
  {
    "label": "Emplace_GetRef()",
    "kind": "Method",
    "detail": "Function (} Block =& Blocks .)",
    "insertText": "Emplace_GetRef(BlockCapacity)"
  },
  {
    "label": "GetTypedPtr()",
    "kind": "Method",
    "detail": "Function (} Result = Block -> Elements [ Block -> NextIndex ] .)",
    "insertText": "GetTypedPtr()"
  },
  {
    "label": "CallDestructorInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CallDestructorInternal(Element)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(Element)"
  },
  {
    "label": "TTypedBlockAllocatorDestructElementType()",
    "kind": "Method",
    "detail": "Function (typedef ElementType)",
    "insertText": "TTypedBlockAllocatorDestructElementType((TTypedBlockAllocatorDestructElementType*)Element)-> TTypedBlockAllocatorDestructElementType::~TTypedBlockAllocatorDestructElementType()"
  },
  {
    "label": "BaseEnumerateAllocations()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BaseEnumerateAllocations(Forward<CallbackType>(Callback))"
  },
  {
    "label": "Callback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Callback(Element)"
  },
  {
    "label": "ReserveDelta()",
    "kind": "Method",
    "detail": "Function (} } } template<ElementType> void TTypedBlockAllocatorBase<ElementType)",
    "insertText": "ReserveDelta(int32 AllocationCount, int32 InMaxBlockSize)"
  },
  {
    "label": "BaseReserveDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BaseReserveDelta(AllocationCount, InMaxBlockSize, 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 DeltaAllocationCount = AllocationCount - NumAvailableOnFreeList ;)",
    "insertText": "for(const FAllocationBlock& Block : TConstArrayView<FAllocationBlock>(Blocks).RightChop(NextBlock))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (DeltaAllocationCount - = Block . Capacity - Block . NextIndex ; })",
    "insertText": "if(InMaxBlockSize == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (InMaxBlockSize = MaxBlockSize ; })",
    "insertText": "if(DeltaAllocationCount <= 0)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (BlockCapacity =)",
    "insertText": "Max(BlockCapacity, MinBlockSize)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (BlockCapacity =)",
    "insertText": "Min(BlockCapacity, InMaxBlockSize)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (} Blocks .)",
    "insertText": "Emplace(BlockCapacity)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (DeltaAllocationCount - = BlockCapacity ;)",
    "insertText": "if(DeltaAllocationCount > 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (BlockCapacity = InMaxBlockSize ;)",
    "insertText": "while(DeltaAllocationCount > 0)"
  },
  {
    "label": "FAllocationBlock()",
    "kind": "Method",
    "detail": "Function (NextBlock = 0 ; NumAllocations = 0 ; NumFreed = 0 ; } template<ElementType> TTypedBlockAllocatorBase<ElementType>::)",
    "insertText": "FAllocationBlock(int32 InCapacity) : Elements(InCapacity > 0 ? new TTypeCompatibleBytes<ElementType>[InCapacity] : nullptr) , NextIndex(0) , Capacity(InCapacity)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ElementType* Result = nullptr ;)",
    "insertText": "if(NumFreed > 0)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (Result = FreeList ; FreeList =* reinterpret_cast<)",
    "insertText": "ElementType(FreeList)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(NumAllocations > 0)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (* reinterpret_cast<)",
    "insertText": "ElementType(Element)"
  },
  {
    "label": "BaseReserveDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BaseReserveDelta(AllocationCount, InMaxBlockSize, NumFreed)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Result = FreeList [ - - NumFreed ] ;)",
    "insertText": "if(8 < NumFreed && NumFreed*2 < CapacityFreed)"
  },
  {
    "label": "ReallocFreeList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReallocFreeList(NumFreed * 3 / 2)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (TUniquePtr<ElementType* [ ]> Copy = MakeUnique<)",
    "insertText": "ElementType(NewCapacity)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(Copy.Get(), FreeList.Get(), NumFreed * sizeof(ElementType*))"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (FreeList =)",
    "insertText": "MoveTemp(Copy)"
  },
  {
    "label": "ReallocFreeList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReallocFreeList(NumFreed < 8 ? 8 : NumFreed * 3 / 2)"
  },
  {
    "label": "BaseEnumerateAllocations()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BaseEnumerateAllocations([this](ElementType* Element) { CallDestructorInternal(Element); })"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (FreeList .)",
    "insertText": "Reset()"
  }
]