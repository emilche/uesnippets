[
  {
    "label": "TSingleThreadedSlabAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSingleThreadedSlabAllocator"
  },
  {
    "label": "FSlab",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSlab"
  },
  {
    "label": "FElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FElement"
  },
  {
    "label": "TSingleThreadedSlabAllocator()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Templates / TypeCompatibleBytes . h \" # include \" Templates / UnrealTemplate . h \" template<T,uint16 SlabSize = 4 0 9 6> class TSingleThreadedSlabAllocator { public :)",
    "insertText": "TSingleThreadedSlabAllocator()"
  },
  {
    "label": "FSlab()",
    "kind": "Method",
    "detail": "Function (CurrentSlab = new)",
    "insertText": "FSlab()"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (delete CurrentSlab ; } template<. . . ArgsType> T*)",
    "insertText": "Construct(ArgsType&&... Args)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Destroy(T* Ptr)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Ptr -> ~)",
    "insertText": "T()"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(Ptr)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (} private : struct FSlab ; struct FElement { TTypeCompatibleBytes<T> Data ; FSlab* Slab = nullptr ; } ; struct FSlab { uint16 Allocated = 0 ; uint16 Freed = 0 ; FElement Elements [ SlabSize ] ; } ; T*)",
    "insertText": "Alloc()"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (uint16 ElementIndex = CurrentSlab -> Allocated + + ;)",
    "insertText": "check(ElementIndex < SlabSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FElement* Element = CurrentSlab -> Elements + ElementIndex ; Element -> Slab = CurrentSlab ;)",
    "insertText": "if(CurrentSlab->Allocated == SlabSize)"
  },
  {
    "label": "GetTypedPtr()",
    "kind": "Method",
    "detail": "Function (} return Element -> Data .)",
    "insertText": "GetTypedPtr()"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Free(T* Ptr)"
  },
  {
    "label": "FElement()",
    "kind": "Method",
    "detail": "Function (FElement* Element = reinterpret_cast<)",
    "insertText": "FElement(Ptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FSlab* Slab = Element -> Slab ;)",
    "insertText": "if(++Slab->Freed == SlabSize)"
  }
]