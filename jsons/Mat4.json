[
  {
    "label": "Vec4",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Vec4"
  },
  {
    "label": "Mat4",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mat4"
  },
  {
    "label": "Mat4()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_MAT4_H_HAS_BEEN_INCLUDED # define OPENVDB_MATH_MAT4_H_HAS_BEEN_INCLUDED # include<openvdb / Exceptions . h> # include<openvdb / Platform . h> # include \" Math . h \" # include \" Mat3 . h \" # include \" Vec3 . h \" # include \" Vec4 . h \" # include<algorithm> # include<cassert> # include<iomanip> # include<cmath> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { template<T> class Vec4 ; template<T> class Mat4 : public Mat<4,T> { public : using value_type = T ; using ValueType = T ; using MyBase = Mat<4,T> ; # if OPENVDB_ABI_VERSION_NUMBER> = 8)",
    "insertText": "Mat4()"
  },
  {
    "label": "Mat4()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Mat4(const Mat<4, T> &m)"
  },
  {
    "label": "Mat4()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ i* 4 + j ] = m [ i ] [ j ] ; } } } # endif template<Source>)",
    "insertText": "Mat4(Source *a)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ i ] = static_cast<)",
    "insertText": "T(a[i])"
  },
  {
    "label": "Mat4()",
    "kind": "Method",
    "detail": "Function (} } template<Source>)",
    "insertText": "Mat4(Source a, Source b, Source c, Source d, Source e, Source f, Source g, Source h, Source i, Source j, Source k, Source l, Source m, Source n, Source o, Source p)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = static_cast<)",
    "insertText": "T(a)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 ] = static_cast<)",
    "insertText": "T(b)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 2 ] = static_cast<)",
    "insertText": "T(c)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 3 ] = static_cast<)",
    "insertText": "T(d)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 4 ] = static_cast<)",
    "insertText": "T(e)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 5 ] = static_cast<)",
    "insertText": "T(f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 6 ] = static_cast<)",
    "insertText": "T(g)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 7 ] = static_cast<)",
    "insertText": "T(h)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 8 ] = static_cast<)",
    "insertText": "T(i)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 9 ] = static_cast<)",
    "insertText": "T(j)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 0 ] = static_cast<)",
    "insertText": "T(k)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 1 ] = static_cast<)",
    "insertText": "T(l)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 2 ] = static_cast<)",
    "insertText": "T(m)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 3 ] = static_cast<)",
    "insertText": "T(n)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 4 ] = static_cast<)",
    "insertText": "T(o)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 5 ] = static_cast<)",
    "insertText": "T(p)"
  },
  {
    "label": "Mat4()",
    "kind": "Method",
    "detail": "Function (} template<Source>)",
    "insertText": "Mat4(const Vec4<Source> &v1, const Vec4<Source> &v2, const Vec4<Source> &v3, const Vec4<Source> &v4, bool rows = true)"
  },
  {
    "label": "setRows()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setRows(v1, v2, v3, v4)"
  },
  {
    "label": "setColumns()",
    "kind": "Method",
    "detail": "Function (} else { this ->)",
    "insertText": "setColumns(v1, v2, v3, v4)"
  },
  {
    "label": "Mat4()",
    "kind": "Method",
    "detail": "Function (} } template<Source>)",
    "insertText": "Mat4(const Mat4<Source> &m)"
  },
  {
    "label": "asPointer()",
    "kind": "Method",
    "detail": "Function (const Source* src = m .)",
    "insertText": "asPointer()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ i ] = static_cast<)",
    "insertText": "T(src[i])"
  },
  {
    "label": "identity()",
    "kind": "Method",
    "detail": "Function (} } const Mat4<T>&)",
    "insertText": "identity()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const Mat4<T> sIdentity = Mat4<)",
    "insertText": "T(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const Mat4<T> sZero = Mat4<)",
    "insertText": "T(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (int i4 = i* 4 ; MyBase::mm [ i4 + 0 ] = v [ 0 ] ; MyBase::mm [ i4 + 1 ] = v [ 1 ] ; MyBase::mm [ i4 + 2 ] = v [ 2 ] ; MyBase::mm [ i4 + 3 ] = v [ 3 ] ; } Vec4<T>)",
    "insertText": "row(int i)"
  },
  {
    "label": "setCol()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setCol(int j, const Vec4<T>& v)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 + j ] = v [ 0 ] ; MyBase::mm [ 4 + j ] = v [ 1 ] ; MyBase::mm [ 8 + j ] = v [ 2 ] ; MyBase::mm [ 1 2 + j ] = v [ 3 ] ; } Vec4<T>)",
    "insertText": "col(int j)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "operator()(int i, int j)"
  },
  {
    "label": "setColumns()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = v1 [ 0 ] ; MyBase::mm [ 1 ] = v1 [ 1 ] ; MyBase::mm [ 2 ] = v1 [ 2 ] ; MyBase::mm [ 3 ] = v1 [ 3 ] ; MyBase::mm [ 4 ] = v2 [ 0 ] ; MyBase::mm [ 5 ] = v2 [ 1 ] ; MyBase::mm [ 6 ] = v2 [ 2 ] ; MyBase::mm [ 7 ] = v2 [ 3 ] ; MyBase::mm [ 8 ] = v3 [ 0 ] ; MyBase::mm [ 9 ] = v3 [ 1 ] ; MyBase::mm [ 1 0 ] = v3 [ 2 ] ; MyBase::mm [ 1 1 ] = v3 [ 3 ] ; MyBase::mm [ 1 2 ] = v4 [ 0 ] ; MyBase::mm [ 1 3 ] = v4 [ 1 ] ; MyBase::mm [ 1 4 ] = v4 [ 2 ] ; MyBase::mm [ 1 5 ] = v4 [ 3 ] ; } void)",
    "insertText": "setColumns(const Vec4<T> &v1, const Vec4<T> &v2, const Vec4<T> &v3, const Vec4<T> &v4)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = v1 [ 0 ] ; MyBase::mm [ 1 ] = v2 [ 0 ] ; MyBase::mm [ 2 ] = v3 [ 0 ] ; MyBase::mm [ 3 ] = v4 [ 0 ] ; MyBase::mm [ 4 ] = v1 [ 1 ] ; MyBase::mm [ 5 ] = v2 [ 1 ] ; MyBase::mm [ 6 ] = v3 [ 1 ] ; MyBase::mm [ 7 ] = v4 [ 1 ] ; MyBase::mm [ 8 ] = v1 [ 2 ] ; MyBase::mm [ 9 ] = v2 [ 2 ] ; MyBase::mm [ 1 0 ] = v3 [ 2 ] ; MyBase::mm [ 1 1 ] = v4 [ 2 ] ; MyBase::mm [ 1 2 ] = v1 [ 3 ] ; MyBase::mm [ 1 3 ] = v2 [ 3 ] ; MyBase::mm [ 1 4 ] = v3 [ 3 ] ; MyBase::mm [ 1 5 ] = v4 [ 3 ] ; } void)",
    "insertText": "setZero()"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = 0 ; MyBase::mm [ 1 ] = 0 ; MyBase::mm [ 2 ] = 0 ; MyBase::mm [ 3 ] = 0 ; MyBase::mm [ 4 ] = 0 ; MyBase::mm [ 5 ] = 0 ; MyBase::mm [ 6 ] = 0 ; MyBase::mm [ 7 ] = 0 ; MyBase::mm [ 8 ] = 0 ; MyBase::mm [ 9 ] = 0 ; MyBase::mm [ 1 0 ] = 0 ; MyBase::mm [ 1 1 ] = 0 ; MyBase::mm [ 1 2 ] = 0 ; MyBase::mm [ 1 3 ] = 0 ; MyBase::mm [ 1 4 ] = 0 ; MyBase::mm [ 1 5 ] = 0 ; } void)",
    "insertText": "setIdentity()"
  },
  {
    "label": "setMat3()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = 1 ; MyBase::mm [ 1 ] = 0 ; MyBase::mm [ 2 ] = 0 ; MyBase::mm [ 3 ] = 0 ; MyBase::mm [ 4 ] = 0 ; MyBase::mm [ 5 ] = 1 ; MyBase::mm [ 6 ] = 0 ; MyBase::mm [ 7 ] = 0 ; MyBase::mm [ 8 ] = 0 ; MyBase::mm [ 9 ] = 0 ; MyBase::mm [ 1 0 ] = 1 ; MyBase::mm [ 1 1 ] = 0 ; MyBase::mm [ 1 2 ] = 0 ; MyBase::mm [ 1 3 ] = 0 ; MyBase::mm [ 1 4 ] = 0 ; MyBase::mm [ 1 5 ] = 1 ; } void)",
    "insertText": "setMat3(const Mat3<T> &m)"
  },
  {
    "label": "getMat3()",
    "kind": "Method",
    "detail": "Function (} Mat3<T>)",
    "insertText": "getMat3()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Mat3<T> m ;)",
    "insertText": "for(int i = 0; i < 3; i++) for (int j = 0; j < 3; j++)"
  },
  {
    "label": "setTranslation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setTranslation(const Vec3<T> &t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 2 ] = t [ 0 ] ; MyBase::mm [ 1 3 ] = t [ 1 ] ; MyBase::mm [ 1 4 ] = t [ 2 ] ; } template<Source> const Mat4&)",
    "insertText": "operator(const Mat4<Source> &m)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(src, (src + this->numElements()), MyBase::mm)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return true ; } Mat4<T>)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<S> const Mat4<T>&)",
    "insertText": "operator(S scalar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ]* = scalar ; MyBase::mm [ 1 ]* = scalar ; MyBase::mm [ 2 ]* = scalar ; MyBase::mm [ 3 ]* = scalar ; MyBase::mm [ 4 ]* = scalar ; MyBase::mm [ 5 ]* = scalar ; MyBase::mm [ 6 ]* = scalar ; MyBase::mm [ 7 ]* = scalar ; MyBase::mm [ 8 ]* = scalar ; MyBase::mm [ 9 ]* = scalar ; MyBase::mm [ 1 0 ]* = scalar ; MyBase::mm [ 1 1 ]* = scalar ; MyBase::mm [ 1 2 ]* = scalar ; MyBase::mm [ 1 3 ]* = scalar ; MyBase::mm [ 1 4 ]* = scalar ; MyBase::mm [ 1 5 ]* = scalar ; return* this ; } template<S> const Mat4<T>&)",
    "insertText": "operator(const Mat4<S> &m1)"
  },
  {
    "label": "m0()",
    "kind": "Method",
    "detail": "Function (Mat4<T>)",
    "insertText": "m0(*this)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (int i4 = 4* i ; MyBase::mm [ i4 + 0 ] = static_cast<)",
    "insertText": "T(s0[i4+0] * s1[ 0] + s0[i4+1] * s1[ 4] + s0[i4+2] * s1[ 8] + s0[i4+3] * s1[12])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ i4 + 1 ] = static_cast<)",
    "insertText": "T(s0[i4+0] * s1[ 1] + s0[i4+1] * s1[ 5] + s0[i4+2] * s1[ 9] + s0[i4+3] * s1[13])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ i4 + 2 ] = static_cast<)",
    "insertText": "T(s0[i4+0] * s1[ 2] + s0[i4+1] * s1[ 6] + s0[i4+2] * s1[10] + s0[i4+3] * s1[14])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ i4 + 3 ] = static_cast<)",
    "insertText": "T(s0[i4+0] * s1[ 3] + s0[i4+1] * s1[ 7] + s0[i4+2] * s1[11] + s0[i4+3] * s1[15])"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (} return* this ; } Mat4)",
    "insertText": "transpose()"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (} Mat4)",
    "insertText": "inverse(T tolerance = 0)"
  },
  {
    "label": "m()",
    "kind": "Method",
    "detail": "Function (const Mat4<T>&)",
    "insertText": "m(*this)"
  },
  {
    "label": "hasPerspective()",
    "kind": "Method",
    "detail": "Function (T m0011 = m [ 0 ] [ 0 ]* m [ 1 ] [ 1 ] ; T m0012 = m [ 0 ] [ 0 ]* m [ 1 ] [ 2 ] ; T m0110 = m [ 0 ] [ 1 ]* m [ 1 ] [ 0 ] ; T m0210 = m [ 0 ] [ 2 ]* m [ 1 ] [ 0 ] ; T m0120 = m [ 0 ] [ 1 ]* m [ 2 ] [ 0 ] ; T m0220 = m [ 0 ] [ 2 ]* m [ 2 ] [ 0 ] ; T detA = m0011* m [ 2 ] [ 2 ] - m0012* m [ 2 ] [ 1 ] - m0110* m [ 2 ] [ 2 ] + m0210* m [ 2 ] [ 1 ] + m0120* m [ 1 ] [ 2 ] - m0220* m [ 1 ] [ 1 ] ; bool)",
    "insertText": "hasPerspective(!isExactlyEqual(m[0][3], T(0.0)) || !isExactlyEqual(m[1][3], T(0.0)) || !isExactlyEqual(m[2][3], T(0.0)) || !isExactlyEqual(m[3][3], T(1.0)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T det ;)",
    "insertText": "if(hasPerspective)"
  },
  {
    "label": "det3()",
    "kind": "Method",
    "detail": "Function (det = m [ 0 ] [ 3 ]*)",
    "insertText": "det3(m, 1,2,3, 0,2,1) + m[1][3] * det3(m, 2,0,3, 0,2,1) + m[2][3] * det3(m, 3,0,1, 0,2,1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { det = detA* m [ 3 ] [ 3 ] ; } Mat4<T> inv ; bool invertible ;)",
    "insertText": "if(isApproxEqual(det,T(0.0),tolerance))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (invertible = false ; } else)",
    "insertText": "if(isApproxEqual(detA,T(0.0),T(1e-8)))"
  },
  {
    "label": "invert()",
    "kind": "Method",
    "detail": "Function (invertible = m .)",
    "insertText": "invert(inv, tolerance)"
  },
  {
    "label": "detA()",
    "kind": "Method",
    "detail": "Function (} else { invertible = true ; detA = 1 . 0 / detA ; inv [ 0 ] [ 0 ] =)",
    "insertText": "detA(m[1][1] * m[2][2] - m[1][2] * m[2][1])"
  },
  {
    "label": "detA()",
    "kind": "Method",
    "detail": "Function (inv [ 0 ] [ 1 ] =)",
    "insertText": "detA(-m[0][1] * m[2][2] + m[0][2] * m[2][1])"
  },
  {
    "label": "detA()",
    "kind": "Method",
    "detail": "Function (inv [ 0 ] [ 2 ] =)",
    "insertText": "detA(m[0][1] * m[1][2] - m[0][2] * m[1][1])"
  },
  {
    "label": "detA()",
    "kind": "Method",
    "detail": "Function (inv [ 1 ] [ 0 ] =)",
    "insertText": "detA(-m[1][0] * m[2][2] + m[1][2] * m[2][0])"
  },
  {
    "label": "detA()",
    "kind": "Method",
    "detail": "Function (inv [ 1 ] [ 1 ] =)",
    "insertText": "detA(m[0][0] * m[2][2] - m0220)"
  },
  {
    "label": "detA()",
    "kind": "Method",
    "detail": "Function (inv [ 1 ] [ 2 ] =)",
    "insertText": "detA(m0210 - m0012)"
  },
  {
    "label": "detA()",
    "kind": "Method",
    "detail": "Function (inv [ 2 ] [ 0 ] =)",
    "insertText": "detA(m[1][0] * m[2][1] - m[1][1] * m[2][0])"
  },
  {
    "label": "detA()",
    "kind": "Method",
    "detail": "Function (inv [ 2 ] [ 1 ] =)",
    "insertText": "detA(m0120 - m[0][0] * m[2][1])"
  },
  {
    "label": "detA()",
    "kind": "Method",
    "detail": "Function (inv [ 2 ] [ 2 ] =)",
    "insertText": "detA(m0011 - m0110)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (Vec3<T> r ; r [ 0 ] = m [ 3 ] [ 0 ]* inv [ 0 ] [ 0 ] + m [ 3 ] [ 1 ]* inv [ 1 ] [ 0 ] + m [ 3 ] [ 2 ]* inv [ 2 ] [ 0 ] ; r [ 1 ] = m [ 3 ] [ 0 ]* inv [ 0 ] [ 1 ] + m [ 3 ] [ 1 ]* inv [ 1 ] [ 1 ] + m [ 3 ] [ 2 ]* inv [ 2 ] [ 1 ] ; r [ 2 ] = m [ 3 ] [ 0 ]* inv [ 0 ] [ 2 ] + m [ 3 ] [ 1 ]* inv [ 1 ] [ 2 ] + m [ 3 ] [ 2 ]* inv [ 2 ] [ 2 ] ; Vec3<T> p ; p [ 0 ] = inv [ 0 ] [ 0 ]* m [ 0 ] [ 3 ] + inv [ 0 ] [ 1 ]* m [ 1 ] [ 3 ] + inv [ 0 ] [ 2 ]* m [ 2 ] [ 3 ] ; p [ 1 ] = inv [ 1 ] [ 0 ]* m [ 0 ] [ 3 ] + inv [ 1 ] [ 1 ]* m [ 1 ] [ 3 ] + inv [ 1 ] [ 2 ]* m [ 2 ] [ 3 ] ; p [ 2 ] = inv [ 2 ] [ 0 ]* m [ 0 ] [ 3 ] + inv [ 2 ] [ 1 ]* m [ 1 ] [ 3 ] + inv [ 2 ] [ 2 ]* m [ 2 ] [ 3 ] ; T h = m [ 3 ] [ 3 ] - p .)",
    "insertText": "dot(Vec3<T>(m[3][0],m[3][1],m[3][2]))"
  },
  {
    "label": "inv()",
    "kind": "Method",
    "detail": "Function (invertible = false ; } else { h = 1 . 0 / h ; inv [ 3 ] [ 3 ] = h ; inv [ 3 ] [ 0 ] = - h* r [ 0 ] ; inv [ 3 ] [ 1 ] = - h* r [ 1 ] ; inv [ 3 ] [ 2 ] = - h* r [ 2 ] ; inv [ 0 ] [ 3 ] = - h* p [ 0 ] ; inv [ 1 ] [ 3 ] = - h* p [ 1 ] ; inv [ 2 ] [ 3 ] = - h* p [ 2 ] ; p* = h ; inv [ 0 ] [ 0 ] + = p [ 0 ]* r [ 0 ] ; inv [ 0 ] [ 1 ] + = p [ 0 ]* r [ 1 ] ; inv [ 0 ] [ 2 ] + = p [ 0 ]* r [ 2 ] ; inv [ 1 ] [ 0 ] + = p [ 1 ]* r [ 0 ] ; inv [ 1 ] [ 1 ] + = p [ 1 ]* r [ 1 ] ; inv [ 1 ] [ 2 ] + = p [ 1 ]* r [ 2 ] ; inv [ 2 ] [ 0 ] + = p [ 2 ]* r [ 0 ] ; inv [ 2 ] [ 1 ] + = p [ 2 ]* r [ 1 ] ; inv [ 2 ] [ 2 ] + = p [ 2 ]* r [ 2 ] ; } } else {)",
    "insertText": "inv(m[3][0] * inv[0][0] + m[3][1] * inv[1][0] + m[3][2] * inv[2][0])"
  },
  {
    "label": "inv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "inv(m[3][0] * inv[0][1] + m[3][1] * inv[1][1] + m[3][2] * inv[2][1])"
  },
  {
    "label": "inv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "inv(m[3][0] * inv[0][2] + m[3][1] * inv[1][2] + m[3][2] * inv[2][2])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (inv [ 0 ] [ 3 ] = 0 . 0 ; inv [ 1 ] [ 3 ] = 0 . 0 ; inv [ 2 ] [ 3 ] = 0 . 0 ; inv [ 3 ] [ 3 ] = 1 . 0 ; } })",
    "insertText": "if(!invertible) OPENVDB_THROW(ArithmeticError, \"Inversion of singular 4x4 matrix\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const T* ap ; Mat3<T> submat ; T det ; T* sp ; int i,j,k,sign ; det = 0 ; sign = 1 ;)",
    "insertText": "for(i = 0; i < 4; i++)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (* sp + + =* ap ; } ap + + ; } } det + =)",
    "insertText": "T(sign) * MyBase::mm[i] * submat.det()"
  },
  {
    "label": "translation()",
    "kind": "Method",
    "detail": "Function (sign = - sign ; } return det ; } Mat4)",
    "insertText": "translation(const Vec3d& v)"
  },
  {
    "label": "setToTranslation()",
    "kind": "Method",
    "detail": "Function (} template<T0> void)",
    "insertText": "setToTranslation(const Vec3<T0>& v)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = 1 ; MyBase::mm [ 1 ] = 0 ; MyBase::mm [ 2 ] = 0 ; MyBase::mm [ 3 ] = 0 ; MyBase::mm [ 4 ] = 0 ; MyBase::mm [ 5 ] = 1 ; MyBase::mm [ 6 ] = 0 ; MyBase::mm [ 7 ] = 0 ; MyBase::mm [ 8 ] = 0 ; MyBase::mm [ 9 ] = 0 ; MyBase::mm [ 1 0 ] = 1 ; MyBase::mm [ 1 1 ] = 0 ; MyBase::mm [ 1 2 ] = v .)",
    "insertText": "x()"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 3 ] = v .)",
    "insertText": "y()"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 4 ] = v .)",
    "insertText": "z()"
  },
  {
    "label": "preTranslate()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 5 ] = 1 ; } template<T0> void)",
    "insertText": "preTranslate(const Vec3<T0>& tr)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "tmp(tr.x(), tr.y(), tr.z())"
  },
  {
    "label": "translation()",
    "kind": "Method",
    "detail": "Function (Mat4<T> Tr = Mat4<T)",
    "insertText": "translation(tmp)"
  },
  {
    "label": "Tr()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "Tr(*this)"
  },
  {
    "label": "postTranslate()",
    "kind": "Method",
    "detail": "Function (} template<T0> void)",
    "insertText": "postTranslate(const Vec3<T0>& tr)"
  },
  {
    "label": "this()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "this(*this)"
  },
  {
    "label": "setToScale()",
    "kind": "Method",
    "detail": "Function (} template<T0> void)",
    "insertText": "setToScale(const Vec3<T0>& v)"
  },
  {
    "label": "preScale()",
    "kind": "Method",
    "detail": "Function (} template<T0> void)",
    "insertText": "preScale(const Vec3<T0>& v)"
  },
  {
    "label": "postScale()",
    "kind": "Method",
    "detail": "Function (} template<T0> void)",
    "insertText": "postScale(const Vec3<T0>& v)"
  },
  {
    "label": "setToRotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setToRotation(Axis axis, T angle)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (* this = rotation<Mat4<)",
    "insertText": "T(axis, angle)"
  },
  {
    "label": "setToRotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setToRotation(const Vec3<T>& axis, T angle)"
  },
  {
    "label": "setToRotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setToRotation(const Vec3<T>& v1, const Vec3<T>& v2)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (* this = rotation<Mat4<)",
    "insertText": "T(v1, v2)"
  },
  {
    "label": "preRotate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "preRotate(Axis axis, T angle)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T c = static_cast<)",
    "insertText": "T(cos(angle))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T s = - static_cast<)",
    "insertText": "T(sin(angle))"
  },
  {
    "label": "postRotate()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "postRotate(Axis axis, T angle)"
  },
  {
    "label": "setToShear()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "setToShear(Axis axis0, Axis axis1, T shearby)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (* this = shear<Mat4<)",
    "insertText": "T(axis0, axis1, shearby)"
  },
  {
    "label": "preShear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "preShear(Axis axis0, Axis axis1, T shear)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int index0 = static_cast<)",
    "insertText": "int(axis0)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int index1 = static_cast<)",
    "insertText": "int(axis1)"
  },
  {
    "label": "postShear()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ index1* 4 + 0 ] + = shear* MyBase::mm [ index0* 4 + 0 ] ; MyBase::mm [ index1* 4 + 1 ] + = shear* MyBase::mm [ index0* 4 + 1 ] ; MyBase::mm [ index1* 4 + 2 ] + = shear* MyBase::mm [ index0* 4 + 2 ] ; MyBase::mm [ index1* 4 + 3 ] + = shear* MyBase::mm [ index0* 4 + 3 ] ; } void)",
    "insertText": "postShear(Axis axis0, Axis axis1, T shear)"
  },
  {
    "label": "transform()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ index0 + 0 ] + = shear* MyBase::mm [ index1 + 0 ] ; MyBase::mm [ index0 + 4 ] + = shear* MyBase::mm [ index1 + 4 ] ; MyBase::mm [ index0 + 8 ] + = shear* MyBase::mm [ index1 + 8 ] ; MyBase::mm [ index0 + 1 2 ] + = shear* MyBase::mm [ index1 + 1 2 ] ; } template<T0> Vec4<T0>)",
    "insertText": "transform(const Vec4<T0> &v)"
  },
  {
    "label": "transform()",
    "kind": "Method",
    "detail": "Function (} template<T0> Vec3<T0>)",
    "insertText": "transform(const Vec3<T0> &v)"
  },
  {
    "label": "pretransform()",
    "kind": "Method",
    "detail": "Function (} template<T0> Vec4<T0>)",
    "insertText": "pretransform(const Vec4<T0> &v)"
  },
  {
    "label": "pretransform()",
    "kind": "Method",
    "detail": "Function (} template<T0> Vec3<T0>)",
    "insertText": "pretransform(const Vec3<T0> &v)"
  },
  {
    "label": "transformH()",
    "kind": "Method",
    "detail": "Function (} template<T0> Vec3<T0>)",
    "insertText": "transformH(const Vec3<T0> &p)"
  },
  {
    "label": "T0()",
    "kind": "Method",
    "detail": "Function (T0 w ; w = static_cast<)",
    "insertText": "T0(p[0] * MyBase::mm[ 3] + p[1] * MyBase::mm[ 7] + p[2] * MyBase::mm[11] + MyBase::mm[15])"
  },
  {
    "label": "T0()",
    "kind": "Method",
    "detail": "Function (} return Vec3<)",
    "insertText": "T0(0, 0, 0)"
  },
  {
    "label": "pretransformH()",
    "kind": "Method",
    "detail": "Function (} template<T0> Vec3<T0>)",
    "insertText": "pretransformH(const Vec3<T0> &p)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T0 w ; w = p [ 0 ]* MyBase::mm [ 1 2 ] + p [ 1 ]* MyBase::mm [ 1 3 ] + p [ 2 ]* MyBase::mm [ 1 4 ] + MyBase::mm [ 1 5 ] ;)",
    "insertText": "if(!isExactlyEqual(w , 0.0))"
  },
  {
    "label": "transform3x3()",
    "kind": "Method",
    "detail": "Function (} template<T0> Vec3<T0>)",
    "insertText": "transform3x3(const Vec3<T0> &v)"
  },
  {
    "label": "invert()",
    "kind": "Method",
    "detail": "Function (} private : bool)",
    "insertText": "invert(Mat4<T> &inverse, T tolerance)"
  },
  {
    "label": "det2()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "det2(const Mat4<T> &a, int i0, int i1, int j0, int j1)"
  },
  {
    "label": "det3()",
    "kind": "Method",
    "detail": "Function (int i0row = i0* 4 ; int i1row = i1* 4 ; return a . mm [ i0row + j0 ]* a . mm [ i1row + j1 ] - a . mm [ i0row + j1 ]* a . mm [ i1row + j0 ] ; } T)",
    "insertText": "det3(const Mat4<T> &a, int i0, int i1, int i2, int j0, int j1, int j2)"
  },
  {
    "label": "det2()",
    "kind": "Method",
    "detail": "Function (int i0row = i0* 4 ; return a . mm [ i0row + j0 ]*)",
    "insertText": "det2(a, i1,i2, j1,j2) + a.mm[i0row+j1]*det2(a, i1,i2, j2,j0) + a.mm[i0row+j2]*det2(a, i1,i2, j0,j1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<T0,T1> bool)",
    "insertText": "operator(const Mat4<T0> &m0, const Mat4<T1> &m1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<S,T> Mat4<promote<S,T>::type>)",
    "insertText": "operator(S scalar, const Mat4<T> &m)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Mat4<promote<S,T>::type>)",
    "insertText": "result(m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (result* = scalar ; return result ; } template<T,MT> Vec4<promote<T,MT>::type>)",
    "insertText": "operator(const Mat4<MT> &_m, const Vec4<T> &_v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,MT> Vec4<promote<T,MT>::type>)",
    "insertText": "operator(const Vec4<T> &_v, const Mat4<MT> &_m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,MT> Vec3<promote<T,MT>::type>)",
    "insertText": "operator(const Mat4<MT> &_m, const Vec3<T> &_v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,MT> Vec3<promote<T,MT>::type>)",
    "insertText": "operator(const Vec3<T> &_v, const Mat4<MT> &_m)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Mat4<promote<T0,T1>::type>)",
    "insertText": "result(m0)"
  },
  {
    "label": "transformNormal()",
    "kind": "Method",
    "detail": "Function (result* = m1 ; return result ; } template<T0,T1> Vec3<T1>)",
    "insertText": "transformNormal(const Mat4<T0> &m, const Vec3<T1> &n)"
  },
  {
    "label": "temp()",
    "kind": "Method",
    "detail": "Function (Mat4<T>)",
    "insertText": "temp(*this)"
  },
  {
    "label": "fabs()",
    "kind": "Method",
    "detail": "Function (int row = i ; double max =)",
    "insertText": "fabs(temp[i][i])"
  },
  {
    "label": "fabs()",
    "kind": "Method",
    "detail": "Function (row = k ; max =)",
    "insertText": "fabs(temp[k][i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(isExactlyEqual(max, 0.0))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (det = - det ;)",
    "insertText": "for(int k = 0; k < 4; ++k)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(temp[row][k], temp[i][k])"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(inverse[row][k], inverse[i][k])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (temp [ i ] [ k ] / = pivot ; inverse [ i ] [ k ] / = pivot ; })",
    "insertText": "for(int j = i+1; j < 4; ++j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (temp [ j ] [ k ] - = temp [ i ] [ k ]* t ; inverse [ j ] [ k ] - = inverse [ i ] [ k ]* t ; } } } })",
    "insertText": "for(int i = 3; i > 0; --i)"
  },
  {
    "label": "isAffine()",
    "kind": "Method",
    "detail": "Function (inverse [ j ] [ k ] - = inverse [ i ] [ k ]* t ; } } } } return det* det> = tolerance* tolerance ; } template<T> bool)",
    "insertText": "isAffine(const Mat4<T>& m)"
  },
  {
    "label": "hasTranslation()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "hasTranslation(const Mat4<T>& m)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (} template<T> Mat4<T>)",
    "insertText": "Abs(const Mat4<T>& m)"
  },
  {
    "label": "cwiseLessThan()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN* op =* ip + s ; OPENVDB_NO_TYPE_CONVERSION_WARNING_END } return out ; } template<T> bool)",
    "insertText": "cwiseLessThan(const Mat4<T>& m0, const Mat4<T>& m1)"
  },
  {
    "label": "cwiseGreaterThan()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "cwiseGreaterThan(const Mat4<T>& m0, const Mat4<T>& m1)"
  },
  {
    "label": "OPENVDB_IS_POD()",
    "kind": "Method",
    "detail": "Function (} using Mat4s = Mat4<float> ; using Mat4d = Mat4<double> ; using Mat4f = Mat4d ; # if OPENVDB_ABI_VERSION_NUMBER> = 8)",
    "insertText": "OPENVDB_IS_POD(Mat4s) OPENVDB_IS_POD(Mat4d) #endif } template<> inline math::Mat4s zeroVal<math::Mat4s>()"
  },
  {
    "label": "Mat4d()",
    "kind": "Method",
    "detail": "Function (} template<> math::Mat4d zeroVal<)",
    "insertText": "Mat4d()"
  }
]