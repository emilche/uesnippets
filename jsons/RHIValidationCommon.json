[
  {
    "label": "FRHIShader",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRHIShader"
  },
  {
    "label": "FRHIShaderResourceView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRHIShaderResourceView"
  },
  {
    "label": "FRHIUniformBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRHIUniformBuffer"
  },
  {
    "label": "FRHIViewableResource",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRHIViewableResource"
  },
  {
    "label": "FRHIUnorderedAccessView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRHIUnorderedAccessView"
  },
  {
    "label": "FRHITexture",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRHITexture"
  },
  {
    "label": "FValidationCommandList",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FValidationCommandList"
  },
  {
    "label": "FValidationComputeContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FValidationComputeContext"
  },
  {
    "label": "FValidationContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FValidationContext"
  },
  {
    "label": "FValidationRHI",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FValidationRHI"
  },
  {
    "label": "FRHITextureCreateDesc",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRHITextureCreateDesc"
  },
  {
    "label": "FRHITransitionInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRHITransitionInfo"
  },
  {
    "label": "FRHIViewDesc",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRHIViewDesc"
  },
  {
    "label": "FStaticUniformBuffers",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStaticUniformBuffers"
  },
  {
    "label": "FStageBoundUniformBuffers",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStageBoundUniformBuffers"
  },
  {
    "label": "FBoundUniformBuffers",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBoundUniformBuffers"
  },
  {
    "label": "FTracker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTracker"
  },
  {
    "label": "FResource",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FResource"
  },
  {
    "label": "FTextureResource",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTextureResource"
  },
  {
    "label": "FOperation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOperation"
  },
  {
    "label": "FSubresourceState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSubresourceState"
  },
  {
    "label": "FSubresourceRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSubresourceRange"
  },
  {
    "label": "FResourceIdentity",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FResourceIdentity"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FSubresourceIndex",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSubresourceIndex"
  },
  {
    "label": "FState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FState"
  },
  {
    "label": "FPipelineState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPipelineState"
  },
  {
    "label": "FViewIdentity",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FViewIdentity"
  },
  {
    "label": "FTransientState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTransientState"
  },
  {
    "label": "FBufferResource",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBufferResource"
  },
  {
    "label": "FAccelerationStructureResource",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAccelerationStructureResource"
  },
  {
    "label": "FRayTracingShaderBindingTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRayTracingShaderBindingTable"
  },
  {
    "label": "FFence",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFence"
  },
  {
    "label": "FUniformBufferResource",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUniformBufferResource"
  },
  {
    "label": "FOpQueueState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpQueueState"
  },
  {
    "label": "FTransitionResource",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTransitionResource"
  },
  {
    "label": "FOpsList",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOpsList"
  },
  {
    "label": "FUAVTracker",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUAVTracker"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Experimental / ConcurrentLinearAllocator . h \" # include \" PixelFormat . h \" # include \" RHIPipeline . h \" # include \" RHIStrings . h \" # include \" RHIAccess . h \" # include \" RHIBreadcrumbs . h \" # if ENABLE_RHI_VALIDATION bool GRHIValidationEnabled ; # else const bool GRHIValidationEnabled = false ; # endif # if ENABLE_RHI_VALIDATION class FRHIShader ; class FRHIShaderResourceView ; class FRHIUniformBuffer ; class FRHIViewableResource ; class FRHIUnorderedAccessView ; class FRHITexture ; struct FValidationCommandList ; class FValidationComputeContext ; class FValidationContext ; class FValidationRHI ; struct FRHITextureCreateDesc ; struct FRHITransitionInfo ; struct FRHIViewDesc ; namespace RHIValidation { struct FStaticUniformBuffers { TArray<FRHIUniformBuffer*> Bindings ; bool bInSetPipelineStateCall { } ; void)",
    "insertText": "Reset()"
  },
  {
    "label": "ValidateSetShaderUniformBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateSetShaderUniformBuffer(FRHIUniformBuffer* UniformBuffer)"
  },
  {
    "label": "FStageBoundUniformBuffers()",
    "kind": "Method",
    "detail": "Function (} ; struct FStageBoundUniformBuffers {)",
    "insertText": "FStageBoundUniformBuffers()"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Bind(uint32 Index, FRHIUniformBuffer* UniformBuffer)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (FStageBoundUniformBuffers&)",
    "insertText": "Get(EShaderFrequency Stage)"
  },
  {
    "label": "FSubresourceIndex()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSubresourceIndex(int32 InMipIndex, int32 InArraySlice, int32 InPlaneIndex) : MipIndex(InMipIndex) , ArraySlice(InArraySlice) , PlaneIndex(InPlaneIndex)"
  },
  {
    "label": "IsWholeResource()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsWholeResource()"
  },
  {
    "label": "FState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FState(ERHIAccess InAccess, ERHIPipeline InPipelines) : Access(InAccess) , Pipelines(InPipelines)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FState& RHS)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ToString()"
  },
  {
    "label": "FPipelineState()",
    "kind": "Method",
    "detail": "Function (} } ; struct FSubresourceState { struct FPipelineState {)",
    "insertText": "FPipelineState()"
  },
  {
    "label": "BeginTransition()",
    "kind": "Method",
    "detail": "Function (Current . Access = ERHIAccess::Unknown ; Current . Pipelines = ERHIPipeline::Graphics ; Previous = Current ; } FState Previous ; FState Current ; EResourceTransitionFlags Flags = EResourceTransitionFlags::None ; bool bTransitioning = false ; bool bUsedWithAllUAVsOverlap = false ; bool bExplicitAllowUAVOverlap = false ; bool bUsedWithExplicitUAVsOverlap = false ; void* CreateTransitionBacktrace = nullptr ; void* BeginTransitionBacktrace = nullptr ; } ; TRHIPipelineArray<uint64> LastTransitionFences { InPlace,0 } ; TRHIPipelineArray<FPipelineState> States ; void)",
    "insertText": "BeginTransition(FResource* Resource, FSubresourceIndex const& SubresourceIndex, const FState& CurrentStateFromRHI, const FState& TargetState, EResourceTransitionFlags NewFlags, ERHITransitionCreateFlags CreateFlags, ERHIPipeline Pipeline, const TRHIPipelineArray<uint64>& PipelineMaxAwaitedFenceValues, void* CreateTrace)"
  },
  {
    "label": "EndTransition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndTransition(FResource* Resource, FSubresourceIndex const& SubresourceIndex, const FState& CurrentStateFromRHI, const FState& TargetState, ERHIPipeline Pipeline, uint64 PipelineFenceValue, void* CreateTrace)"
  },
  {
    "label": "Assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Assert(FResource* Resource, FSubresourceIndex const& SubresourceIndex, const FState& RequiredState, bool bAllowAllUAVsOverlap)"
  },
  {
    "label": "AssertTracked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertTracked(FResource* Resource, FSubresourceIndex const& SubresourceIndex, const FState& TrackedState)"
  },
  {
    "label": "SpecificUAVOverlap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SpecificUAVOverlap(FResource* Resource, FSubresourceIndex const& SubresourceIndex, ERHIPipeline Pipeline, bool bAllow)"
  },
  {
    "label": "FSubresourceRange()",
    "kind": "Method",
    "detail": "Function (} ; struct FSubresourceRange { uint32 MipIndex,NumMips ; uint32 ArraySlice,NumArraySlices ; uint32 PlaneIndex,NumPlanes ;)",
    "insertText": "FSubresourceRange()"
  },
  {
    "label": "FSubresourceRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSubresourceRange(uint32 InMipIndex, uint32 InNumMips, uint32 InArraySlice, uint32 InNumArraySlices, uint32 InPlaneIndex, uint32 InNumPlanes) : MipIndex(InMipIndex) , NumMips(InNumMips) , ArraySlice(InArraySlice) , NumArraySlices(InNumArraySlices) , PlaneIndex(InPlaneIndex) , NumPlanes(InNumPlanes)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(FSubresourceRange const& RHS)"
  },
  {
    "label": "IsWholeResource()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsWholeResource(FResource& Resource)"
  },
  {
    "label": "FResourceIdentity()",
    "kind": "Method",
    "detail": "Function (} ; struct FResourceIdentity { FResource* Resource ; FSubresourceRange SubresourceRange ;)",
    "insertText": "FResourceIdentity()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(FResourceIdentity const& RHS)"
  },
  {
    "label": "FViewIdentity()",
    "kind": "Method",
    "detail": "Function (} } ; struct FViewIdentity : public FResourceIdentity { uint32 Stride = 0 ;)",
    "insertText": "FViewIdentity(FRHIViewableResource* Resource, FRHIViewDesc const& ViewDesc)"
  },
  {
    "label": "FTransientState()",
    "kind": "Method",
    "detail": "Function (} ; struct FTransientState {)",
    "insertText": "FTransientState()"
  },
  {
    "label": "FTransientState()",
    "kind": "Method",
    "detail": "Function (enum class EStatus : uint8 { None,Acquired,Discarded } ;)",
    "insertText": "FTransientState(ERHIAccess InitialAccess) : bTransient(InitialAccess == ERHIAccess::Discard)"
  },
  {
    "label": "IsAcquired()",
    "kind": "Method",
    "detail": "Function (} void* AcquireBacktrace = nullptr ; int32 NumAcquiredSubresources = 0 ; bool bTransient = false ; EStatus Status = EStatus::None ; bool)",
    "insertText": "IsAcquired()"
  },
  {
    "label": "Discard()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Discard(FResource* Resource, void* CreateTrace, ERHIPipeline DiscardPipelines)"
  },
  {
    "label": "AliasingOverlap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AliasingOverlap(FResource* ResourceBefore, FResource* ResourceAfter, void* CreateTrace)"
  },
  {
    "label": "EnumerateSubresources()",
    "kind": "Method",
    "detail": "Function (} ; class FResource { FTracker ; FTextureResource ; FOperation ; FSubresourceState ; FSubresourceRange ; FTransientState ; FValidationRHI ; protected : uint32 NumMips = 0 ; uint32 NumArraySlices = 0 ; uint32 NumPlanes = 0 ; FTransientState TransientState ; ERHIAccess TrackedAccess = ERHIAccess::Unknown ; private : FString DebugName ; FSubresourceState WholeResourceState ; TArray<FSubresourceState> SubresourceStates ; FThreadSafeCounter NumOpRefs ; void)",
    "insertText": "EnumerateSubresources(FSubresourceRange const& SubresourceRange, TFunctionRef<void(FSubresourceState&, FSubresourceIndex const&)> Callback, bool bBeginTransition = false)"
  },
  {
    "label": "FResource()",
    "kind": "Method",
    "detail": "Function (public : ~)",
    "insertText": "FResource()"
  },
  {
    "label": "SetDebugName()",
    "kind": "Method",
    "detail": "Function (} ELoggingMode LoggingMode = ELoggingMode::None ; void)",
    "insertText": "SetDebugName(const TCHAR* Name, const TCHAR* Suffix = nullptr)"
  },
  {
    "label": "GetDebugName()",
    "kind": "Method",
    "detail": "Function (const TCHAR*)",
    "insertText": "GetDebugName()"
  },
  {
    "label": "IsBarrierTrackingInitialized()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsBarrierTrackingInitialized()"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (NumOpRefs .)",
    "insertText": "Increment()"
  },
  {
    "label": "ReleaseOpRef()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ReleaseOpRef()"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (const int32 RefCount = NumOpRefs .)",
    "insertText": "Decrement()"
  },
  {
    "label": "GetTrackedAccess()",
    "kind": "Method",
    "detail": "Function (} ERHIAccess)",
    "insertText": "GetTrackedAccess()"
  },
  {
    "label": "GetWholeResourceIdentity()",
    "kind": "Method",
    "detail": "Function (FSubresourceRange SubresourceRange ; SubresourceRange . MipIndex = 0 ; SubresourceRange . ArraySlice = 0 ; SubresourceRange . PlaneIndex = 0 ; SubresourceRange . NumMips = NumMips ; SubresourceRange . NumArraySlices = NumArraySlices ; SubresourceRange . NumPlanes = NumPlanes ; return SubresourceRange ; } FResourceIdentity)",
    "insertText": "GetWholeResourceIdentity()"
  },
  {
    "label": "GetWholeResourceRange()",
    "kind": "Method",
    "detail": "Function (FResourceIdentity Identity ; Identity . Resource = this ; Identity . SubresourceRange =)",
    "insertText": "GetWholeResourceRange()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TransientState . Status = FTransientState::EStatus::None ; DebugName = InDebugName ; TrackedAccess = ERHIAccess::Discard ;)",
    "insertText": "for(ERHIPipeline Pipeline : MakeFlagsRange(ERHIPipeline::All))"
  },
  {
    "label": "InitBarrierTracking()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "InitBarrierTracking(int32 InNumMips, int32 InNumArraySlices, int32 InNumPlanes, ERHIAccess InResourceState, const TCHAR* InDebugName)"
  },
  {
    "label": "FTransientState()",
    "kind": "Method",
    "detail": "Function (NumMips = InNumMips ; NumArraySlices = InNumArraySlices ; NumPlanes = InNumPlanes ; TransientState =)",
    "insertText": "FTransientState(InResourceState)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (auto& State = WholeResourceState . States [ Pipeline ] ; State . Current . Access = InResourceState ; State . Current . Pipelines = Pipeline ; State . Previous = State . Current ; })",
    "insertText": "if(InDebugName != nullptr)"
  },
  {
    "label": "SetDebugName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDebugName(InDebugName)"
  },
  {
    "label": "InitBarrierTracking()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitBarrierTracking(1, 1, 1, InResourceState, InDebugName)"
  },
  {
    "label": "SetCommitted()",
    "kind": "Method",
    "detail": "Function (} } ; class FAccelerationStructureResource : public FBufferResource { public : } ; class FRayTracingShaderBindingTable { public : void)",
    "insertText": "SetCommitted(bool bInCommitted)"
  },
  {
    "label": "IsCommitted()",
    "kind": "Method",
    "detail": "Function (bCommitted = bInCommitted ; } bool)",
    "insertText": "IsCommitted()"
  },
  {
    "label": "FTextureResource()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FTextureResource()"
  },
  {
    "label": "FTextureResource()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FTextureResource(FRHITextureCreateDesc const& CreateDesc)"
  },
  {
    "label": "GetTrackerResource()",
    "kind": "Method",
    "detail": "Function (} FResource*)",
    "insertText": "GetTrackerResource()"
  },
  {
    "label": "InitBarrierTracking()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitBarrierTracking(int32 InNumMips, int32 InNumArraySlices, EPixelFormat PixelFormat, ETextureCreateFlags Flags, ERHIAccess InResourceState, const TCHAR* InDebugName)"
  },
  {
    "label": "CheckValidationLayout()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckValidationLayout(int32 InNumMips, int32 InNumArraySlices, EPixelFormat PixelFormat)"
  },
  {
    "label": "GetViewIdentity()",
    "kind": "Method",
    "detail": "Function (FResourceIdentity)",
    "insertText": "GetViewIdentity(uint32 InMipIndex, uint32 InNumMips, uint32 InArraySlice, uint32 InNumArraySlices, uint32 InPlaneIndex, uint32 InNumPlanes)"
  },
  {
    "label": "GetTransitionIdentity()",
    "kind": "Method",
    "detail": "Function (FResourceIdentity)",
    "insertText": "GetTransitionIdentity(const FRHITransitionInfo& Info)"
  },
  {
    "label": "GetWholeResourceIdentitySRV()",
    "kind": "Method",
    "detail": "Function (} FResourceIdentity)",
    "insertText": "GetWholeResourceIdentitySRV()"
  },
  {
    "label": "InitLifetimeTracking()",
    "kind": "Method",
    "detail": "Function (Identity . SubresourceRange . NumPlanes = 1 ; return Identity ; } } ; struct FFence { bool bSignaled = false ; ERHIPipeline SrcPipe = ERHIPipeline::None ; ERHIPipeline DstPipe = ERHIPipeline::None ; uint64 FenceValue = 0 ; } ; enum class EOpType { BeginTransition,EndTransition,SetTrackedAccess,AliasingOverlap,AcquireTransient,DiscardTransient,InitTransient,Assert,Rename,Signal,Wait,AllUAVsOverlap,SpecificUAVOverlap # if WITH_RHI_BREADCRUMBS,BeginBreadcrumbGPU,EndBreadcrumbGPU,SetBreadcrumbRange # endif } ; struct FUniformBufferResource { uint64 AllocatedFrameID = 0 ; bool bContainsNullContents = false ; EUniformBufferUsage UniformBufferUsage ; void* AllocatedCallstack ; void)",
    "insertText": "InitLifetimeTracking(uint64 FrameID, const void* Contents, EUniformBufferUsage Usage)"
  },
  {
    "label": "UpdateAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateAllocation(uint64 FrameID)"
  },
  {
    "label": "ValidateLifeTime()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateLifeTime()"
  },
  {
    "label": "Replay()",
    "kind": "Method",
    "detail": "Function (} ; struct FOpQueueState ; struct FOperation { EOpType Type ; union { struct { FResourceIdentity Identity ; FState PreviousState ; FState NextState ; EResourceTransitionFlags Flags ; ERHITransitionCreateFlags CreateFlags ; void* CreateBacktrace ; } Data_BeginTransition ; struct { FResourceIdentity Identity ; FState PreviousState ; FState NextState ; void* CreateBacktrace ; } Data_EndTransition ; struct { FResource* Resource ; ERHIAccess Access ; } Data_SetTrackedAccess ; struct { FResource* ResourceBefore ; FResource* ResourceAfter ; void* CreateBacktrace ; } Data_AliasingOverlap ; struct { FResource* Resource ; void* CreateBacktrace ; } Data_AcquireTransient ; struct { FResource* Resource ; TCHAR* DebugName ; } Data_InitTransient ; struct { FResourceIdentity Identity ; FState RequiredState ; } Data_Assert ; struct { FResource* Resource ; TCHAR* DebugName ; const TCHAR* Suffix ; } Data_Rename ; struct { FFence* Fence ; } Data_Signal ; struct { FFence* Fence ; } Data_Wait ; struct { bool bAllow ; } Data_AllUAVsOverlap ; struct { FResourceIdentity Identity ; bool bAllow ; } Data_SpecificUAVOverlap ; # if WITH_RHI_BREADCRUMBS struct { FRHIBreadcrumbNode* Breadcrumb ; } Data_Breadcrumb ; struct { FRHIBreadcrumbRange Range ; } Data_BreadcrumbRange ; # endif } ; bool)",
    "insertText": "Replay(FOpQueueState& Queue)"
  },
  {
    "label": "BeginTransitionResource()",
    "kind": "Method",
    "detail": "Function (FOperation)",
    "insertText": "BeginTransitionResource(FResourceIdentity Identity, FState PreviousState, FState NextState, EResourceTransitionFlags Flags, ERHITransitionCreateFlags CreateFlags, void* CreateBacktrace)"
  },
  {
    "label": "AddOpRef()",
    "kind": "Method",
    "detail": "Function (Identity . Resource ->)",
    "insertText": "AddOpRef()"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (} FOperation Op ; Op . Type = EOpType::BeginTransition ; Op . Data_BeginTransition . Identity = Identity ; Op . Data_BeginTransition . PreviousState = PreviousState ; Op . Data_BeginTransition . NextState = NextState ; Op . Data_BeginTransition . Flags = Flags ; Op . Data_BeginTransition . CreateFlags = CreateFlags ; Op . Data_BeginTransition . CreateBacktrace = CreateBacktrace ; return)",
    "insertText": "MoveTemp(Op)"
  },
  {
    "label": "EndTransitionResource()",
    "kind": "Method",
    "detail": "Function (} FOperation)",
    "insertText": "EndTransitionResource(FResourceIdentity Identity, FState PreviousState, FState NextState, void* CreateBacktrace)"
  },
  {
    "label": "SetTrackedAccess()",
    "kind": "Method",
    "detail": "Function (} FOperation)",
    "insertText": "SetTrackedAccess(FResource* Resource, ERHIAccess Access)"
  },
  {
    "label": "AliasingOverlap()",
    "kind": "Method",
    "detail": "Function (} FOperation)",
    "insertText": "AliasingOverlap(FResource* ResourceBefore, FResource* ResourceAfter, void* CreateBacktrace)"
  },
  {
    "label": "AcquireTransientResource()",
    "kind": "Method",
    "detail": "Function (FOperation Op ; Op . Type = EOpType::AliasingOverlap ; Op . Data_AliasingOverlap . ResourceBefore = ResourceBefore ; Op . Data_AliasingOverlap . ResourceAfter = ResourceAfter ; Op . Data_AliasingOverlap . CreateBacktrace = CreateBacktrace ; return Op ; } FOperation)",
    "insertText": "AcquireTransientResource(FResource* Resource, void* CreateBacktrace)"
  },
  {
    "label": "InitTransient()",
    "kind": "Method",
    "detail": "Function (} FOperation)",
    "insertText": "InitTransient(FResource* Resource, const TCHAR* DebugName)"
  },
  {
    "label": "AllocStringCopy()",
    "kind": "Method",
    "detail": "Function (FOperation Op ; Op . Type = EOpType::InitTransient ; Op . Data_InitTransient . Resource = Resource ;)",
    "insertText": "AllocStringCopy(Op.Data_InitTransient.DebugName, DebugName)"
  },
  {
    "label": "Assert()",
    "kind": "Method",
    "detail": "Function (} FOperation)",
    "insertText": "Assert(FResourceIdentity Identity, FState RequiredState)"
  },
  {
    "label": "Rename()",
    "kind": "Method",
    "detail": "Function (} FOperation)",
    "insertText": "Rename(FResource* Resource, const TCHAR* NewName, const TCHAR* Suffix = nullptr)"
  },
  {
    "label": "AllocStringCopy()",
    "kind": "Method",
    "detail": "Function (FOperation Op ; Op . Type = EOpType::Rename ; Op . Data_Rename . Resource = Resource ;)",
    "insertText": "AllocStringCopy(Op.Data_Rename.DebugName, NewName)"
  },
  {
    "label": "Signal()",
    "kind": "Method",
    "detail": "Function (} FOperation)",
    "insertText": "Signal(FFence* Fence)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (} FOperation)",
    "insertText": "Wait(FFence* Fence)"
  },
  {
    "label": "AllUAVsOverlap()",
    "kind": "Method",
    "detail": "Function (} FOperation)",
    "insertText": "AllUAVsOverlap(bool bAllow)"
  },
  {
    "label": "SpecificUAVOverlap()",
    "kind": "Method",
    "detail": "Function (} FOperation)",
    "insertText": "SpecificUAVOverlap(FResourceIdentity Identity, bool bAllow)"
  },
  {
    "label": "BeginBreadcrumbGPU()",
    "kind": "Method",
    "detail": "Function (} # if WITH_RHI_BREADCRUMBS FOperation)",
    "insertText": "BeginBreadcrumbGPU(FRHIBreadcrumbNode* Breadcrumb)"
  },
  {
    "label": "EndBreadcrumbGPU()",
    "kind": "Method",
    "detail": "Function (FOperation Op ; Op . Type = EOpType::BeginBreadcrumbGPU ; Op . Data_Breadcrumb . Breadcrumb = Breadcrumb ; return Op ; } FOperation)",
    "insertText": "EndBreadcrumbGPU(FRHIBreadcrumbNode* Breadcrumb)"
  },
  {
    "label": "SetBreadcrumbRange()",
    "kind": "Method",
    "detail": "Function (FOperation Op ; Op . Type = EOpType::EndBreadcrumbGPU ; Op . Data_Breadcrumb . Breadcrumb = Breadcrumb ; return Op ; } FOperation)",
    "insertText": "SetBreadcrumbRange(FRHIBreadcrumbRange const& BreadcrumbRange)"
  },
  {
    "label": "AllocStringCopy()",
    "kind": "Method",
    "detail": "Function (FOperation Op ; Op . Type = EOpType::SetBreadcrumbRange ; Op . Data_BreadcrumbRange . Range = BreadcrumbRange ; return Op ; } # endif private : void)",
    "insertText": "AllocStringCopy(TCHAR*& OutString, const TCHAR* InString)"
  },
  {
    "label": "Strlen()",
    "kind": "Method",
    "detail": "Function (int32 Len =)",
    "insertText": "Strlen(InString)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (OutString = new TCHAR [ Len + 1 ] ;)",
    "insertText": "Memcpy(OutString, InString, Len * sizeof(TCHAR))"
  },
  {
    "label": "FOpsList()",
    "kind": "Method",
    "detail": "Function (OutString [ Len ] = 0 ; } } ; struct FTransitionResource { TRHIPipelineArray<TArray<FOperation>> PendingSignals ; TRHIPipelineArray<TArray<FOperation>> PendingWaits ; TArray<FOperation> PendingAliases ; TArray<FOperation> PendingAliasingOverlaps ; TArray<FOperation> PendingOperationsBegin ; TArray<FOperation> PendingOperationsEnd ; } ; enum class EUAVMode { Graphics,Compute,Num } ; struct FOpQueueState { ERHIPipeline const Pipeline ; uint64 FenceValue = 0 ; TRHIPipelineArray<uint64> MaxAwaitedFenceValues { InPlace,0 } ; # if WITH_RHI_BREADCRUMBS struct { FRHIBreadcrumbRange Range { } ; FRHIBreadcrumbNode* Current = nullptr ; } Breadcrumbs ; # endif bool bAllowAllUAVsOverlap = false ; struct FOpsList : public TArray<FOperation> { int32 ReplayPos = 0 ;)",
    "insertText": "FOpsList(FOpsList&&)"
  },
  {
    "label": "FOpsList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FOpsList(TArray<FOperation>&& Other) : TArray(MoveTemp(Other))"
  },
  {
    "label": "FOpQueueState()",
    "kind": "Method",
    "detail": "Function (} } ; TArray<FOpsList> Ops ;)",
    "insertText": "FOpQueueState(ERHIPipeline Pipeline) : Pipeline(Pipeline)"
  },
  {
    "label": "AppendOps()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendOps(FValidationCommandList* CommandList)"
  },
  {
    "label": "Execute()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Execute()"
  },
  {
    "label": "FUAVTracker()",
    "kind": "Method",
    "detail": "Function (} ; class FTracker { struct FUAVTracker { private : TArray<FRHIUnorderedAccessView*> UAVs ; public :)",
    "insertText": "FUAVTracker()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (UAVs .)",
    "insertText": "Reserve(MaxSimultaneousUAVs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FRHIUnorderedAccessView*&)",
    "insertText": "operator(int32 Slot)"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (UAVs .)",
    "insertText": "SetNumZeroed(Slot + 1)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (UAVs .)",
    "insertText": "SetNum(0, EAllowShrinking::No)"
  },
  {
    "label": "DrawOrDispatch()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DrawOrDispatch(FTracker* BarrierTracker, const FState& RequiredState)"
  },
  {
    "label": "FTracker()",
    "kind": "Method",
    "detail": "Function (} ; public :)",
    "insertText": "FTracker(ERHIPipeline InPipeline) : Pipeline(InPipeline)"
  },
  {
    "label": "AddOp()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddOp(const FOperation& Op)"
  },
  {
    "label": "AddOps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOps(TArray<FOperation> const& List)"
  },
  {
    "label": "AddOp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOp(Op)"
  },
  {
    "label": "Finalize()",
    "kind": "Method",
    "detail": "Function (} } TArray<FOperation>)",
    "insertText": "Finalize()"
  },
  {
    "label": "AddOp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOp(FOperation::BeginBreadcrumbGPU(Breadcrumb))"
  },
  {
    "label": "AddOp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOp(FOperation::EndBreadcrumbGPU(Breadcrumb))"
  },
  {
    "label": "AddOp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOp(FOperation::SetTrackedAccess(Resource, Access))"
  },
  {
    "label": "AddOp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOp(FOperation::Rename(Resource, NewName, Suffix))"
  },
  {
    "label": "Assert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Assert(FResourceIdentity Identity, ERHIAccess RequiredAccess)"
  },
  {
    "label": "AddOp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOp(FOperation::Assert(Identity, FState(RequiredAccess, Pipeline)))"
  },
  {
    "label": "AssertUAV()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AssertUAV(FRHIUnorderedAccessView* UAV, EUAVMode Mode, int32 Slot)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (UAVTrackers [)",
    "insertText": "int32(Mode)"
  },
  {
    "label": "AssertUAV()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AssertUAV(FRHIUnorderedAccessView* UAV, ERHIAccess Access, int32 Slot)"
  },
  {
    "label": "AssertUAV()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertUAV(UAV, Access == ERHIAccess::UAVGraphics ? EUAVMode::Graphics : EUAVMode::Compute, Slot)"
  },
  {
    "label": "TransitionResource()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TransitionResource(FResourceIdentity Identity, FState PreviousState, FState NextState, EResourceTransitionFlags Flags)"
  },
  {
    "label": "AddOp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOp(FOperation::BeginTransitionResource(Identity, PreviousState, NextState, Flags, ERHITransitionCreateFlags::None, nullptr))"
  },
  {
    "label": "AddOp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOp(FOperation::EndTransitionResource(Identity, PreviousState, NextState, nullptr))"
  },
  {
    "label": "AddOp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOp(FOperation::AllUAVsOverlap(bAllow))"
  },
  {
    "label": "AddOp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOp(FOperation::SpecificUAVOverlap(Identity, bAllow))"
  },
  {
    "label": "Dispatch()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Dispatch()"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (UAVTrackers [)",
    "insertText": "int32(EUAVMode::Compute)].DrawOrDispatch(this, FState(ERHIAccess::UAVCompute, Pipeline))"
  },
  {
    "label": "Draw()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Draw()"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (UAVTrackers [)",
    "insertText": "int32(EUAVMode::Graphics)].DrawOrDispatch(this, FState(ERHIAccess::UAVGraphics, Pipeline))"
  },
  {
    "label": "ResetUAVState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ResetUAVState(EUAVMode Mode)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (UAVTrackers [)",
    "insertText": "int32(Mode)].Reset()"
  },
  {
    "label": "ResetAllUAVState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ResetAllUAVState()"
  },
  {
    "label": "ResetUAVState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetUAVState(EUAVMode(Index))"
  },
  {
    "label": "GetQueue()",
    "kind": "Method",
    "detail": "Function (} } FOpQueueState&)",
    "insertText": "GetQueue(ERHIPipeline Pipeline)"
  },
  {
    "label": "SubmitValidationOps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubmitValidationOps(ERHIPipeline Pipeline, TArray<RHIValidation::FOperation>&& Ops)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (private : const ERHIPipeline Pipeline ; TArray<FOperation> CurrentList ; FUAVTracker UAVTrackers [)",
    "insertText": "int32(EUAVMode::Num)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (FOperation ; FOpQueueState OpQueues [)",
    "insertText": "int32(ERHIPipeline::Num)"
  },
  {
    "label": "CaptureBacktrace()",
    "kind": "Method",
    "detail": "Function (} ; void*)",
    "insertText": "CaptureBacktrace()"
  },
  {
    "label": "ValidateShaderResourceView()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateShaderResourceView(const FRHIShader* RHIShaderBase, uint32 BindIndex, const FRHIShaderResourceView* SRV)"
  },
  {
    "label": "ValidateShaderResourceView()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateShaderResourceView(const FRHIShader* RHIShaderBase, uint32 BindIndex, const FRHITexture* Texture)"
  },
  {
    "label": "ValidateUnorderedAccessView()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateUnorderedAccessView(const FRHIShader* RHIShaderBase, uint32 BindIndex, const FRHIUnorderedAccessView* SRV)"
  },
  {
    "label": "ValidateUniformBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateUniformBuffer(const FRHIShader* RHIShaderBase, uint32 BindIndex, FRHIUniformBuffer* SRV)"
  }
]