[
  {
    "label": "FConditionVariable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConditionVariable"
  },
  {
    "label": "FConditionVariable()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Async / ParkingLot . h \" namespace UE { class FConditionVariable final { public :)",
    "insertText": "FConditionVariable()"
  },
  {
    "label": "FConditionVariable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FConditionVariable(const FConditionVariable&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FConditionVariable&)",
    "insertText": "operator(const FConditionVariable&)"
  },
  {
    "label": "NotifyOne()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NotifyOne()"
  },
  {
    "label": "WakeOne()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WakeOne(&bHasWaiters, [this] (ParkingLot::FWakeState WakeState) -> uint64 { if (!WakeState.bHasWaitingThreads) bHasWaiters = false; return 0; })"
  },
  {
    "label": "NotifyAll()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "NotifyAll()"
  },
  {
    "label": "WakeAll()",
    "kind": "Method",
    "detail": "Function (bHasWaiters = false ;)",
    "insertText": "WakeAll(&bHasWaiters)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (} } template<TLock> void)",
    "insertText": "Wait(TLock& Lock)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Wait(&bHasWaiters, [this] () -> bool { bHasWaiters = true; return true; }, [&Lock] () { Lock.Unlock(); })"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (Lock .)",
    "insertText": "Lock()"
  }
]