[
  {
    "label": "IMATH_EXPORT_ENUM",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "IMATH_EXPORT_ENUM"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "IMATH_EXPORT_TEMPLATE_TYPE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMATH_EXPORT_TEMPLATE_TYPE"
  },
  {
    "label": "S",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "S"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHMATRIX_H # define INCLUDED_IMATHMATRIX_H # include \" ImathExport . h \" # include \" ImathNamespace . h \" # include \" ImathFun . h \" # include \" ImathPlatform . h \" # include \" ImathShear . h \" # include \" ImathVec . h \" # include<cstring> # include<iomanip> # include<iostream> # include<limits> # include<string . h> #)",
    "insertText": "if(defined _WIN32 || defined _WIN64) && defined _MSC_VER # pragma warning(disable : 4290)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (UNINITIALIZED } ; template<class T> class IMATH_EXPORT_TEMPLATE_TYPE Matrix22 { public : T x [ 2 ] [ 2 ] ; IMATH_HOSTDEVICE T*)",
    "insertText": "operator(int i)"
  },
  {
    "label": "Matrix22()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Matrix22(Uninitialized)"
  },
  {
    "label": "Matrix22()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix22()"
  },
  {
    "label": "Matrix22()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix22(T a)"
  },
  {
    "label": "Matrix22()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix22(const T a[2][2])"
  },
  {
    "label": "Matrix22()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix22(T a, T b, T c, T d)"
  },
  {
    "label": "Matrix22()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix22(const Matrix22& v)"
  },
  {
    "label": "Matrix22()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix22(const Matrix22<S>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix22&)",
    "insertText": "operator(const Matrix22& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix22&)",
    "insertText": "operator(T a)"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (# if IMATH_FOREIGN_VECTOR_INTEROP template<M,)",
    "insertText": "IMATH_ENABLE_IF(has_double_subscript<M,T,2,2>::value)> IMATH_HOSTDEVICE explicit Matrix22 (const M& m) : Matrix22(T(m[0][0]), T(m[0][1]), T(m[1][0]), T(m[1][1]))"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (} template<M,)",
    "insertText": "IMATH_ENABLE_IF(has_double_subscript<M,T,2,2>::value)> IMATH_HOSTDEVICE const Matrix22& operator= (const M& m)"
  },
  {
    "label": "Matrix22()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "Matrix22(T(m[0][0]), T(m[0][1]), T(m[1][0]), T(m[1][1]))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE const T*)",
    "insertText": "getValue()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "getValue(Matrix22<S>& v)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Matrix22&)",
    "insertText": "setValue(const Matrix22<S>& v)"
  },
  {
    "label": "setTheMatrix()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Matrix22&)",
    "insertText": "setTheMatrix(const Matrix22<S>& v)"
  },
  {
    "label": "equalWithAbsError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithAbsError(const Matrix22<T>& v, T e)"
  },
  {
    "label": "equalWithRelError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithRelError(const Matrix22<T>& v, T e)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Matrix22)",
    "insertText": "operator()"
  },
  {
    "label": "negate()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix22&)",
    "insertText": "negate()"
  },
  {
    "label": "multDirMatrix()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "multDirMatrix(const Vec2<S>& src, Vec2<S>& dst)"
  },
  {
    "label": "makeIdentity()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "makeIdentity()"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix22&)",
    "insertText": "transpose()"
  },
  {
    "label": "transposed()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Matrix22)",
    "insertText": "transposed()"
  },
  {
    "label": "invert()",
    "kind": "Method",
    "detail": "Function (IMATH_CONSTEXPR14 const Matrix22&)",
    "insertText": "invert(bool singExc)"
  },
  {
    "label": "invert()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix22&)",
    "insertText": "invert()"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (IMATH_CONSTEXPR14 Matrix22<T>)",
    "insertText": "inverse(bool singExc)"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Matrix22<T>)",
    "insertText": "inverse()"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "determinant()"
  },
  {
    "label": "trace()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "trace()"
  },
  {
    "label": "setRotation()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE const Matrix22&)",
    "insertText": "setRotation(S r)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix22&)",
    "insertText": "rotate(S r)"
  },
  {
    "label": "setScale()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix22&)",
    "insertText": "setScale(T s)"
  },
  {
    "label": "setScale()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix22&)",
    "insertText": "setScale(const Vec2<S>& s)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix22&)",
    "insertText": "scale(const Vec2<S>& s)"
  },
  {
    "label": "baseTypeLowest()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "baseTypeLowest()"
  },
  {
    "label": "baseTypeMax()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE T)",
    "insertText": "baseTypeMax()"
  },
  {
    "label": "baseTypeSmallest()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE T)",
    "insertText": "baseTypeSmallest()"
  },
  {
    "label": "baseTypeEpsilon()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE T)",
    "insertText": "baseTypeEpsilon()"
  },
  {
    "label": "dimensions()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE unsigned int)",
    "insertText": "dimensions()"
  },
  {
    "label": "Matrix33()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Matrix33(Uninitialized)"
  },
  {
    "label": "Matrix33()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix33()"
  },
  {
    "label": "Matrix33()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix33(T a)"
  },
  {
    "label": "Matrix33()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix33(const T a[3][3])"
  },
  {
    "label": "Matrix33()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix33(T a, T b, T c, T d, T e, T f, T g, T h, T i)"
  },
  {
    "label": "Matrix33()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix33(const Matrix33& v)"
  },
  {
    "label": "Matrix33()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix33(const Matrix33<S>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix33&)",
    "insertText": "operator(const Matrix33& v)"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (# if IMATH_FOREIGN_VECTOR_INTEROP template<M,)",
    "insertText": "IMATH_ENABLE_IF(has_double_subscript<M,T,3,3>::value)> IMATH_HOSTDEVICE explicit Matrix33 (const M& m) : Matrix33(T(m[0][0]), T(m[0][1]), T(m[0][2]), T(m[1][0]), T(m[1][1]), T(m[1][2]), T(m[2][0]), T(m[2][1]), T(m[2][2]))"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (} template<M,)",
    "insertText": "IMATH_ENABLE_IF(has_double_subscript<M,T,3,3>::value)> IMATH_HOSTDEVICE const Matrix33& operator= (const M& m)"
  },
  {
    "label": "Matrix33()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "Matrix33(T(m[0][0]), T(m[0][1]), T(m[0][2]), T(m[1][0]), T(m[1][1]), T(m[1][2]), T(m[2][0]), T(m[2][1]), T(m[2][2]))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "getValue(Matrix33<S>& v)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Matrix33&)",
    "insertText": "setValue(const Matrix33<S>& v)"
  },
  {
    "label": "setTheMatrix()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Matrix33&)",
    "insertText": "setTheMatrix(const Matrix33<S>& v)"
  },
  {
    "label": "equalWithAbsError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithAbsError(const Matrix33<T>& v, T e)"
  },
  {
    "label": "equalWithRelError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithRelError(const Matrix33<T>& v, T e)"
  },
  {
    "label": "multVecMatrix()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "multVecMatrix(const Vec2<S>& src, Vec2<S>& dst)"
  },
  {
    "label": "gjInvert()",
    "kind": "Method",
    "detail": "Function (const Matrix33&)",
    "insertText": "gjInvert(bool singExc)"
  },
  {
    "label": "gjInvert()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE const Matrix33&)",
    "insertText": "gjInvert()"
  },
  {
    "label": "gjInverse()",
    "kind": "Method",
    "detail": "Function (Matrix33<T>)",
    "insertText": "gjInverse(bool singExc)"
  },
  {
    "label": "gjInverse()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Matrix33<T>)",
    "insertText": "gjInverse()"
  },
  {
    "label": "minorOf()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 T)",
    "insertText": "minorOf(const int r, const int c)"
  },
  {
    "label": "fastMinor()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "fastMinor(const int r0, const int r1, const int c0, const int c1)"
  },
  {
    "label": "setTranslation()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix33&)",
    "insertText": "setTranslation(const Vec2<S>& t)"
  },
  {
    "label": "translation()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Vec2<T>)",
    "insertText": "translation()"
  },
  {
    "label": "translate()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix33&)",
    "insertText": "translate(const Vec2<S>& t)"
  },
  {
    "label": "setShear()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix33&)",
    "insertText": "setShear(const S& h)"
  },
  {
    "label": "setShear()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix33&)",
    "insertText": "setShear(const Vec2<S>& h)"
  },
  {
    "label": "shear()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix33&)",
    "insertText": "shear(const S& xy)"
  },
  {
    "label": "shear()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix33&)",
    "insertText": "shear(const Vec2<S>& h)"
  },
  {
    "label": "Matrix44()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Matrix44(Uninitialized)"
  },
  {
    "label": "Matrix44()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix44()"
  },
  {
    "label": "Matrix44()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix44(T a)"
  },
  {
    "label": "Matrix44()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix44(const T a[4][4])"
  },
  {
    "label": "Matrix44()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix44(T a, T b, T c, T d, T e, T f, T g, T h, T i, T j, T k, T l, T m, T n, T o, T p)"
  },
  {
    "label": "Matrix44()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix44(Matrix33<T> r, Vec3<T> t)"
  },
  {
    "label": "Matrix44()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix44(const Matrix44& v)"
  },
  {
    "label": "Matrix44()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Matrix44(const Matrix44<S>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix44&)",
    "insertText": "operator(const Matrix44& v)"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (# if IMATH_FOREIGN_VECTOR_INTEROP template<M,)",
    "insertText": "IMATH_ENABLE_IF(has_double_subscript<M,T,4,4>::value)> IMATH_HOSTDEVICE explicit Matrix44 (const M& m) : Matrix44(T(m[0][0]), T(m[0][1]), T(m[0][2]), T(m[0][3]), T(m[1][0]), T(m[1][1]), T(m[1][2]), T(m[1][3]), T(m[2][0]), T(m[2][1]), T(m[2][2]), T(m[2][3]), T(m[3][0]), T(m[3][1]), T(m[3][2]), T(m[3][3]))"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (} template<M,)",
    "insertText": "IMATH_ENABLE_IF(has_double_subscript<M,T,4,4>::value)> IMATH_HOSTDEVICE const Matrix44& operator= (const M& m)"
  },
  {
    "label": "Matrix44()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "Matrix44(T(m[0][0]), T(m[0][1]), T(m[0][2]), T(m[0][3]), T(m[1][0]), T(m[1][1]), T(m[1][2]), T(m[1][3]), T(m[2][0]), T(m[2][1]), T(m[2][2]), T(m[2][3]), T(m[3][0]), T(m[3][1]), T(m[3][2]), T(m[3][3]))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "getValue(Matrix44<S>& v)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Matrix44&)",
    "insertText": "setValue(const Matrix44<S>& v)"
  },
  {
    "label": "setTheMatrix()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Matrix44&)",
    "insertText": "setTheMatrix(const Matrix44<S>& v)"
  },
  {
    "label": "equalWithAbsError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithAbsError(const Matrix44<T>& v, T e)"
  },
  {
    "label": "equalWithRelError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithRelError(const Matrix44<T>& v, T e)"
  },
  {
    "label": "multiply()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "multiply(const Matrix44& a, const Matrix44& b, Matrix44& c)"
  },
  {
    "label": "multiply()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Matrix44)",
    "insertText": "multiply(const Matrix44& a, const Matrix44& b)"
  },
  {
    "label": "multVecMatrix()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "multVecMatrix(const Vec3<S>& src, Vec3<S>& dst)"
  },
  {
    "label": "multDirMatrix()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "multDirMatrix(const Vec3<S>& src, Vec3<S>& dst)"
  },
  {
    "label": "fastMinor()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "fastMinor(const int r0, const int r1, const int r2, const int c0, const int c1, const int c2)"
  },
  {
    "label": "setEulerAngles()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE const Matrix44&)",
    "insertText": "setEulerAngles(const Vec3<S>& r)"
  },
  {
    "label": "setAxisAngle()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix44&)",
    "insertText": "setAxisAngle(const Vec3<S>& ax, S ang)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE const Matrix44&)",
    "insertText": "rotate(const Vec3<S>& r)"
  },
  {
    "label": "setScale()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix44&)",
    "insertText": "setScale(const Vec3<S>& s)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix44&)",
    "insertText": "scale(const Vec3<S>& s)"
  },
  {
    "label": "setTranslation()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix44&)",
    "insertText": "setTranslation(const Vec3<S>& t)"
  },
  {
    "label": "translate()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix44&)",
    "insertText": "translate(const Vec3<S>& t)"
  },
  {
    "label": "setShear()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix44&)",
    "insertText": "setShear(const Vec3<S>& h)"
  },
  {
    "label": "setShear()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix44&)",
    "insertText": "setShear(const Shear6<S>& h)"
  },
  {
    "label": "shear()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix44&)",
    "insertText": "shear(const Vec3<S>& h)"
  },
  {
    "label": "shear()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix44&)",
    "insertText": "shear(const Shear6<S>& h)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& s, const Matrix33<T>& m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& s, const Matrix44<T>& m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S,class T> IMATH_HOSTDEVICE const Vec2<S>&)",
    "insertText": "operator(Vec2<S>& v, const Matrix22<T>& m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S,class T> IMATH_HOSTDEVICE Vec2<S>)",
    "insertText": "operator(const Vec2<S>& v, const Matrix22<T>& m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S,class T> IMATH_HOSTDEVICE const Vec2<S>&)",
    "insertText": "operator(Vec2<S>& v, const Matrix33<T>& m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S,class T> IMATH_HOSTDEVICE Vec2<S>)",
    "insertText": "operator(const Vec2<S>& v, const Matrix33<T>& m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S,class T> IMATH_HOSTDEVICE const Vec3<S>&)",
    "insertText": "operator(Vec3<S>& v, const Matrix33<T>& m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S,class T> IMATH_HOSTDEVICE Vec3<S>)",
    "insertText": "operator(const Vec3<S>& v, const Matrix33<T>& m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S,class T> IMATH_HOSTDEVICE const Vec3<S>&)",
    "insertText": "operator(Vec3<S>& v, const Matrix44<T>& m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S,class T> IMATH_HOSTDEVICE Vec3<S>)",
    "insertText": "operator(const Vec3<S>& v, const Matrix44<T>& m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S,class T> IMATH_HOSTDEVICE const Vec4<S>&)",
    "insertText": "operator(Vec4<S>& v, const Matrix44<T>& m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S,class T> IMATH_HOSTDEVICE Vec4<S>)",
    "insertText": "operator(const Vec4<S>& v, const Matrix44<T>& m)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 0 ] =)",
    "insertText": "T(v.x[0][0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 1 ] =)",
    "insertText": "T(v.x[0][1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 1 ] [ 0 ] =)",
    "insertText": "T(v.x[1][0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 1 ] [ 1 ] =)",
    "insertText": "T(v.x[1][1])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 0 ] + = a ; x [ 0 ] [ 1 ] + = a ; x [ 1 ] [ 0 ] + = a ; x [ 1 ] [ 1 ] + = a ; return* this ; } template<class T> IMATH_HOSTDEVICE Matrix22<T> Matrix22<T)",
    "insertText": "operator(const Matrix22<T>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Matrix22<T>)",
    "insertText": "operator(T a, const Matrix22<T>& v)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (Matrix22)",
    "insertText": "tmp(T (0))"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (Matrix22)",
    "insertText": "tmp(x[0][0], x[1][0], x[0][1], x[1][1])"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "inverse(singExc)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (Matrix22)",
    "insertText": "s(x[1][1], -x[0][1], -x[1][0], x[0][0])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T r = x [ 0 ] [ 0 ]* x [ 1 ] [ 1 ] - x [ 1 ] [ 0 ]* x [ 0 ] [ 1 ] ;)",
    "insertText": "if(IMATH_INTERNAL_NAMESPACE::abs (r) >= 1)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (s [ i ] [ j ] / = r ; } } } else { T mr =)",
    "insertText": "abs(r) / std::numeric_limits<T>::min()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (s [ i ] [ j ] / = r ; } else {)",
    "insertText": "if(singExc) throw std::invalid_argument (\"Cannot invert \" \"singular matrix.\")"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (S cos_r,sin_r ; cos_r =)",
    "insertText": "cos((T) r)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (sin_r =)",
    "insertText": "sin((T) r)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (* this* = Matrix22<)",
    "insertText": "T().setRotation (r)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 0 ] = s ; x [ 0 ] [ 1 ] = static_cast<)",
    "insertText": "T(0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 2 ] =)",
    "insertText": "T(v.x[0][2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 1 ] [ 2 ] =)",
    "insertText": "T(v.x[1][2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 2 ] [ 0 ] =)",
    "insertText": "T(v.x[2][0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 2 ] [ 1 ] =)",
    "insertText": "T(v.x[2][1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 2 ] [ 2 ] =)",
    "insertText": "T(v.x[2][2])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 0 ] + = a ; x [ 0 ] [ 1 ] + = a ; x [ 0 ] [ 2 ] + = a ; x [ 1 ] [ 0 ] + = a ; x [ 1 ] [ 1 ] + = a ; x [ 1 ] [ 2 ] + = a ; x [ 2 ] [ 0 ] + = a ; x [ 2 ] [ 1 ] + = a ; x [ 2 ] [ 2 ] + = a ; return* this ; } template<class T> IMATH_HOSTDEVICE Matrix33<T> Matrix33<T)",
    "insertText": "operator(const Matrix33<T>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Matrix33<T>)",
    "insertText": "operator(T a, const Matrix33<T>& v)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (Matrix33)",
    "insertText": "tmp(IMATH_INTERNAL_NAMESPACE::UNINITIALIZED)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (Matrix33)",
    "insertText": "tmp(x[0][0], x[1][0], x[2][0], x[0][1], x[1][1], x[2][1], x[0][2], x[1][2], x[2][2])"
  },
  {
    "label": "gjInverse()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "gjInverse(singExc)"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (int i,j,k ; Matrix33 s ; Matrix33)",
    "insertText": "t(*this)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int pivot = i ; T pivotsize = t . x [ i ] [ i ] ;)",
    "insertText": "if(pivotsize < 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T tmp = t . x [ j ] [ i ] ;)",
    "insertText": "if(tmp < 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pivot = j ; pivotsize = tmp ; } })",
    "insertText": "if(pivotsize == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(pivot != i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T tmp ; tmp = t . x [ i ] [ j ] ; t . x [ i ] [ j ] = t . x [ pivot ] [ j ] ; t . x [ pivot ] [ j ] = tmp ; tmp = s . x [ i ] [ j ] ; s . x [ i ] [ j ] = s . x [ pivot ] [ j ] ; s . x [ pivot ] [ j ] = tmp ; } })",
    "insertText": "for(j = i + 1; j < 3; j++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T f = t . x [ j ] [ i ] / t . x [ i ] [ i ] ;)",
    "insertText": "for(k = 0; k < 3; k++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (t . x [ j ] [ k ] - = f* t . x [ i ] [ k ] ; s . x [ j ] [ k ] - = f* s . x [ i ] [ k ] ; } } })",
    "insertText": "for(i = 2; i >= 0; --i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T f ;)",
    "insertText": "if((f = t[i][i]) == 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(j = 0; j < 3; j++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (t . x [ i ] [ j ] / = f ; s . x [ i ] [ j ] / = f ; })",
    "insertText": "for(j = 0; j < i; j++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T f ;)",
    "insertText": "if((f = t.x[i][i]) == 0)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (Matrix33)",
    "insertText": "s(x[1][1] * x[2][2] - x[2][1] * x[1][2], x[2][1] * x[0][2] - x[0][1] * x[2][2], x[0][1] * x[1][2] - x[1][1] * x[0][2], x[2][0] * x[1][2] - x[1][0] * x[2][2], x[0][0] * x[2][2] - x[2][0] * x[0][2], x[1][0] * x[0][2] - x[0][0] * x[1][2], x[1][0] * x[2][1] - x[2][0] * x[1][1], x[2][0] * x[0][1] - x[0][0] * x[2][1], x[0][0] * x[1][1] - x[1][0] * x[0][1])"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (} } } } return s ; } else { Matrix33)",
    "insertText": "s(x[1][1], -x[0][1], 0, -x[1][0], x[0][0], 0, 0, 0, 1)"
  },
  {
    "label": "r0()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "r0(r < 1 ? 1 : 0)"
  },
  {
    "label": "r1()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "r1(r < 2 ? 1 : 0)"
  },
  {
    "label": "c0()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "c0(c < 1 ? 1 : 0)"
  },
  {
    "label": "c1()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "c1(c < 2 ? 1 : 0)"
  },
  {
    "label": "setShear()",
    "kind": "Method",
    "detail": "Function (x [ 2 ] [ 0 ] + = t . x* x [ 0 ] [ 0 ] + t . y* x [ 1 ] [ 0 ] ; x [ 2 ] [ 1 ] + = t . x* x [ 0 ] [ 1 ] + t . y* x [ 1 ] [ 1 ] ; x [ 2 ] [ 2 ] + = t . x* x [ 0 ] [ 2 ] + t . y* x [ 1 ] [ 2 ] ; return* this ; } template<class T> template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix33<T>& Matrix33<T)",
    "insertText": "setShear(const S& xy)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (Matrix33<T>)",
    "insertText": "P(*this)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 3 ] =)",
    "insertText": "T(v.x[0][3])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 1 ] [ 3 ] =)",
    "insertText": "T(v.x[1][3])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 2 ] [ 3 ] =)",
    "insertText": "T(v.x[2][3])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 3 ] [ 0 ] =)",
    "insertText": "T(v.x[3][0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 3 ] [ 1 ] =)",
    "insertText": "T(v.x[3][1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 3 ] [ 2 ] =)",
    "insertText": "T(v.x[3][2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x [ 3 ] [ 3 ] =)",
    "insertText": "T(v.x[3][3])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 0 ] + = a ; x [ 0 ] [ 1 ] + = a ; x [ 0 ] [ 2 ] + = a ; x [ 0 ] [ 3 ] + = a ; x [ 1 ] [ 0 ] + = a ; x [ 1 ] [ 1 ] + = a ; x [ 1 ] [ 2 ] + = a ; x [ 1 ] [ 3 ] + = a ; x [ 2 ] [ 0 ] + = a ; x [ 2 ] [ 1 ] + = a ; x [ 2 ] [ 2 ] + = a ; x [ 2 ] [ 3 ] + = a ; x [ 3 ] [ 0 ] + = a ; x [ 3 ] [ 1 ] + = a ; x [ 3 ] [ 2 ] + = a ; x [ 3 ] [ 3 ] + = a ; return* this ; } template<class T> IMATH_HOSTDEVICE Matrix44<T> Matrix44<T)",
    "insertText": "operator(const Matrix44<T>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Matrix44<T>)",
    "insertText": "operator(T a, const Matrix44<T>& v)"
  },
  {
    "label": "Matrix44()",
    "kind": "Method",
    "detail": "Function (const auto a00 = a . x [ 0 ] [ 0 ] ; const auto a01 = a . x [ 0 ] [ 1 ] ; const auto a02 = a . x [ 0 ] [ 2 ] ; const auto a03 = a . x [ 0 ] [ 3 ] ; const auto c00 = a00* b . x [ 0 ] [ 0 ] + a01* b . x [ 1 ] [ 0 ] + a02* b . x [ 2 ] [ 0 ] + a03* b . x [ 3 ] [ 0 ] ; const auto c01 = a00* b . x [ 0 ] [ 1 ] + a01* b . x [ 1 ] [ 1 ] + a02* b . x [ 2 ] [ 1 ] + a03* b . x [ 3 ] [ 1 ] ; const auto c02 = a00* b . x [ 0 ] [ 2 ] + a01* b . x [ 1 ] [ 2 ] + a02* b . x [ 2 ] [ 2 ] + a03* b . x [ 3 ] [ 2 ] ; const auto c03 = a00* b . x [ 0 ] [ 3 ] + a01* b . x [ 1 ] [ 3 ] + a02* b . x [ 2 ] [ 3 ] + a03* b . x [ 3 ] [ 3 ] ; const auto a10 = a . x [ 1 ] [ 0 ] ; const auto a11 = a . x [ 1 ] [ 1 ] ; const auto a12 = a . x [ 1 ] [ 2 ] ; const auto a13 = a . x [ 1 ] [ 3 ] ; const auto c10 = a10* b . x [ 0 ] [ 0 ] + a11* b . x [ 1 ] [ 0 ] + a12* b . x [ 2 ] [ 0 ] + a13* b . x [ 3 ] [ 0 ] ; const auto c11 = a10* b . x [ 0 ] [ 1 ] + a11* b . x [ 1 ] [ 1 ] + a12* b . x [ 2 ] [ 1 ] + a13* b . x [ 3 ] [ 1 ] ; const auto c12 = a10* b . x [ 0 ] [ 2 ] + a11* b . x [ 1 ] [ 2 ] + a12* b . x [ 2 ] [ 2 ] + a13* b . x [ 3 ] [ 2 ] ; const auto c13 = a10* b . x [ 0 ] [ 3 ] + a11* b . x [ 1 ] [ 3 ] + a12* b . x [ 2 ] [ 3 ] + a13* b . x [ 3 ] [ 3 ] ; const auto a20 = a . x [ 2 ] [ 0 ] ; const auto a21 = a . x [ 2 ] [ 1 ] ; const auto a22 = a . x [ 2 ] [ 2 ] ; const auto a23 = a . x [ 2 ] [ 3 ] ; const auto c20 = a20* b . x [ 0 ] [ 0 ] + a21* b . x [ 1 ] [ 0 ] + a22* b . x [ 2 ] [ 0 ] + a23* b . x [ 3 ] [ 0 ] ; const auto c21 = a20* b . x [ 0 ] [ 1 ] + a21* b . x [ 1 ] [ 1 ] + a22* b . x [ 2 ] [ 1 ] + a23* b . x [ 3 ] [ 1 ] ; const auto c22 = a20* b . x [ 0 ] [ 2 ] + a21* b . x [ 1 ] [ 2 ] + a22* b . x [ 2 ] [ 2 ] + a23* b . x [ 3 ] [ 2 ] ; const auto c23 = a20* b . x [ 0 ] [ 3 ] + a21* b . x [ 1 ] [ 3 ] + a22* b . x [ 2 ] [ 3 ] + a23* b . x [ 3 ] [ 3 ] ; const auto a30 = a . x [ 3 ] [ 0 ] ; const auto a31 = a . x [ 3 ] [ 1 ] ; const auto a32 = a . x [ 3 ] [ 2 ] ; const auto a33 = a . x [ 3 ] [ 3 ] ; const auto c30 = a30* b . x [ 0 ] [ 0 ] + a31* b . x [ 1 ] [ 0 ] + a32* b . x [ 2 ] [ 0 ] + a33* b . x [ 3 ] [ 0 ] ; const auto c31 = a30* b . x [ 0 ] [ 1 ] + a31* b . x [ 1 ] [ 1 ] + a32* b . x [ 2 ] [ 1 ] + a33* b . x [ 3 ] [ 1 ] ; const auto c32 = a30* b . x [ 0 ] [ 2 ] + a31* b . x [ 1 ] [ 2 ] + a32* b . x [ 2 ] [ 2 ] + a33* b . x [ 3 ] [ 2 ] ; const auto c33 = a30* b . x [ 0 ] [ 3 ] + a31* b . x [ 1 ] [ 3 ] + a32* b . x [ 2 ] [ 3 ] + a33* b . x [ 3 ] [ 3 ] ; return)",
    "insertText": "Matrix44(c00, c01, c02, c03, c10, c11, c12, c13, c20, c21, c22, c23, c30, c31, c32, c33)"
  },
  {
    "label": "multiply()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "multiply(*this, v)"
  },
  {
    "label": "multiply()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE void Matrix44<T)",
    "insertText": "multiply(const Matrix44<T>& a, const Matrix44<T>& b, Matrix44<T>& c)"
  },
  {
    "label": "multiply()",
    "kind": "Method",
    "detail": "Function (c =)",
    "insertText": "multiply(a, b)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (Matrix44)",
    "insertText": "tmp(x[0][0], x[1][0], x[2][0], x[3][0], x[0][1], x[1][1], x[2][1], x[3][1], x[0][2], x[1][2], x[2][2], x[3][2], x[0][3], x[1][3], x[2][3], x[3][3])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T tmp ; tmp = t . x [ i ] [ j ] ; t . x [ i ] [ j ] = t . x [ pivot ] [ j ] ; t . x [ pivot ] [ j ] = tmp ; tmp = s . x [ i ] [ j ] ; s . x [ i ] [ j ] = s . x [ pivot ] [ j ] ; s . x [ pivot ] [ j ] = tmp ; } })",
    "insertText": "for(j = i + 1; j < 4; j++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T f = t . x [ j ] [ i ] / t . x [ i ] [ i ] ;)",
    "insertText": "for(k = 0; k < 4; k++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (t . x [ j ] [ k ] - = f* t . x [ i ] [ k ] ; s . x [ j ] [ k ] - = f* s . x [ i ] [ k ] ; } } })",
    "insertText": "for(i = 3; i >= 0; --i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(j = 0; j < 4; j++)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (Matrix44)",
    "insertText": "s(x[1][1] * x[2][2] - x[2][1] * x[1][2], x[2][1] * x[0][2] - x[0][1] * x[2][2], x[0][1] * x[1][2] - x[1][1] * x[0][2], 0, x[2][0] * x[1][2] - x[1][0] * x[2][2], x[0][0] * x[2][2] - x[2][0] * x[0][2], x[1][0] * x[0][2] - x[0][0] * x[1][2], 0, x[1][0] * x[2][1] - x[2][0] * x[1][1], x[2][0] * x[0][1] - x[0][0] * x[2][1], x[0][0] * x[1][1] - x[1][0] * x[0][1], 0, 0, 0, 0, 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (s . x [ i ] [ j ] / = r ; } else {)",
    "insertText": "if(singExc) throw std::invalid_argument (\"Cannot invert singular matrix.\")"
  },
  {
    "label": "r2()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "r2(r < 3 ? 1 : 0)"
  },
  {
    "label": "c2()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "c2(c < 3 ? 1 : 0)"
  },
  {
    "label": "working()",
    "kind": "Method",
    "detail": "Function (Matrix33<T>)",
    "insertText": "working(x[r0][c0], x[r1][c0], x[r2][c0], x[r0][c1], x[r1][c1], x[r2][c1], x[r0][c2], x[r1][c2], x[r2][c2])"
  },
  {
    "label": "sum()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "sum(T)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (S cos_rz,sin_rz,cos_ry,sin_ry,cos_rx,sin_rx ; cos_rz =)",
    "insertText": "cos((T) r.z)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (cos_ry =)",
    "insertText": "cos((T) r.y)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (cos_rx =)",
    "insertText": "cos((T) r.x)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (sin_rz =)",
    "insertText": "sin((T) r.z)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (sin_ry =)",
    "insertText": "sin((T) r.y)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (sin_rx =)",
    "insertText": "sin((T) r.x)"
  },
  {
    "label": "setAxisAngle()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 0 ] = cos_rz* cos_ry ; x [ 0 ] [ 1 ] = sin_rz* cos_ry ; x [ 0 ] [ 2 ] = - sin_ry ; x [ 0 ] [ 3 ] = 0 ; x [ 1 ] [ 0 ] = - sin_rz* cos_rx + cos_rz* sin_ry* sin_rx ; x [ 1 ] [ 1 ] = cos_rz* cos_rx + sin_rz* sin_ry* sin_rx ; x [ 1 ] [ 2 ] = cos_ry* sin_rx ; x [ 1 ] [ 3 ] = 0 ; x [ 2 ] [ 0 ] = sin_rz* sin_rx + cos_rz* sin_ry* cos_rx ; x [ 2 ] [ 1 ] = - cos_rz* sin_rx + sin_rz* sin_ry* cos_rx ; x [ 2 ] [ 2 ] = cos_ry* cos_rx ; x [ 2 ] [ 3 ] = 0 ; x [ 3 ] [ 0 ] = 0 ; x [ 3 ] [ 1 ] = 0 ; x [ 3 ] [ 2 ] = 0 ; x [ 3 ] [ 3 ] = 1 ; return* this ; } template<class T> template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Matrix44<T>& Matrix44<T)",
    "insertText": "setAxisAngle(const Vec3<S>& axis, S angle)"
  },
  {
    "label": "unit()",
    "kind": "Method",
    "detail": "Function (Vec3<S>)",
    "insertText": "unit(axis.normalized())"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (S sine =)",
    "insertText": "sin(angle)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (S cosine =)",
    "insertText": "cos(angle)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 0 ] = unit . x* unit .)",
    "insertText": "x(1 - cosine)"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 1 ] = unit . x* unit .)",
    "insertText": "y(1 - cosine)"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ 2 ] = unit . x* unit .)",
    "insertText": "z(1 - cosine)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (S cos_rz,sin_rz,cos_ry,sin_ry,cos_rx,sin_rx ; S m00,m01,m02 ; S m10,m11,m12 ; S m20,m21,m22 ; cos_rz =)",
    "insertText": "cos((S) r.z)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (cos_ry =)",
    "insertText": "cos((S) r.y)"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (cos_rx =)",
    "insertText": "cos((S) r.x)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (sin_rz =)",
    "insertText": "sin((S) r.z)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (sin_ry =)",
    "insertText": "sin((S) r.y)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (sin_rx =)",
    "insertText": "sin((S) r.x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (x [ 0 ] [ i ] = P . x [ 0 ] [ i ] + h . yx* P . x [ 1 ] [ i ] + h . zx* P . x [ 2 ] [ i ] ; x [ 1 ] [ i ] = h . xy* P . x [ 0 ] [ i ] + P . x [ 1 ] [ i ] + h . zy* P . x [ 2 ] [ i ] ; x [ 2 ] [ i ] = h . xz* P . x [ 0 ] [ i ] + h . yz* P . x [ 1 ] [ i ] + P . x [ 2 ] [ i ] ; } return* this ; } template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& s, const Matrix22<T>& m)"
  },
  {
    "label": "flags()",
    "kind": "Method",
    "detail": "Function (std::ios_base::fmtflags oldFlags = s .)",
    "insertText": "flags()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int width ;)",
    "insertText": "if(s.flags() & std::ios_base::fixed)"
  },
  {
    "label": "setf()",
    "kind": "Method",
    "detail": "Function (s .)",
    "insertText": "setf(std::ios_base::showpoint)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (width = static_cast<)",
    "insertText": "int(s.precision())"
  },
  {
    "label": "setf()",
    "kind": "Method",
    "detail": "Function (} else { s .)",
    "insertText": "setf(std::ios_base::scientific)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "s(\" << std::setw (width) << m[0][0] << \" \" << std::setw (width) << m[0][1] << \"\\n\" << \" \" << std::setw (width) << m[1][0] << \" \" << std::setw (width) << m[1][1] << \")"
  },
  {
    "label": "flags()",
    "kind": "Method",
    "detail": "Function (s .)",
    "insertText": "flags(oldFlags)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "s(\" << std::setw (width) << m[0][0] << \" \" << std::setw (width) << m[0][1] << \" \" << std::setw (width) << m[0][2] << \"\\n\" << \" \" << std::setw (width) << m[1][0] << \" \" << std::setw (width) << m[1][1] << \" \" << std::setw (width) << m[1][2] << \"\\n\" << \" \" << std::setw (width) << m[2][0] << \" \" << std::setw (width) << m[2][1] << \" \" << std::setw (width) << m[2][2] << \")"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "s(\" << std::setw (width) << m[0][0] << \" \" << std::setw (width) << m[0][1] << \" \" << std::setw (width) << m[0][2] << \" \" << std::setw (width) << m[0][3] << \"\\n\" << \" \" << std::setw (width) << m[1][0] << \" \" << std::setw (width) << m[1][1] << \" \" << std::setw (width) << m[1][2] << \" \" << std::setw (width) << m[1][3] << \"\\n\" << \" \" << std::setw (width) << m[2][0] << \" \" << std::setw (width) << m[2][1] << \" \" << std::setw (width) << m[2][2] << \" \" << std::setw (width) << m[2][3] << \"\\n\" << \" \" << std::setw (width) << m[3][0] << \" \" << std::setw (width) << m[3][1] << \" \" << std::setw (width) << m[3][2] << \" \" << std::setw (width) << m[3][3] << \")"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S x =)",
    "insertText": "S(v.x * m.x[0][0] + v.y * m.x[1][0])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S y =)",
    "insertText": "S(v.x * m.x[0][1] + v.y * m.x[1][1])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S x =)",
    "insertText": "S(v.x * m.x[0][0] + v.y * m.x[1][0] + m.x[2][0])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S y =)",
    "insertText": "S(v.x * m.x[0][1] + v.y * m.x[1][1] + m.x[2][1])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S w =)",
    "insertText": "S(v.x * m.x[0][2] + v.y * m.x[1][2] + m.x[2][2])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S x =)",
    "insertText": "S(v.x * m.x[0][0] + v.y * m.x[1][0] + v.z * m.x[2][0])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S y =)",
    "insertText": "S(v.x * m.x[0][1] + v.y * m.x[1][1] + v.z * m.x[2][1])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S z =)",
    "insertText": "S(v.x * m.x[0][2] + v.y * m.x[1][2] + v.z * m.x[2][2])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S x =)",
    "insertText": "S(v.x * m.x[0][0] + v.y * m.x[1][0] + v.z * m.x[2][0] + m.x[3][0])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S y =)",
    "insertText": "S(v.x * m.x[0][1] + v.y * m.x[1][1] + v.z * m.x[2][1] + m.x[3][1])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S z =)",
    "insertText": "S(v.x * m.x[0][2] + v.y * m.x[1][2] + v.z * m.x[2][2] + m.x[3][2])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S w =)",
    "insertText": "S(v.x * m.x[0][3] + v.y * m.x[1][3] + v.z * m.x[2][3] + m.x[3][3])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S x =)",
    "insertText": "S(v.x * m.x[0][0] + v.y * m.x[1][0] + v.z * m.x[2][0] + v.w * m.x[3][0])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S y =)",
    "insertText": "S(v.x * m.x[0][1] + v.y * m.x[1][1] + v.z * m.x[2][1] + v.w * m.x[3][1])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S z =)",
    "insertText": "S(v.x * m.x[0][2] + v.y * m.x[1][2] + v.z * m.x[2][2] + v.w * m.x[3][2])"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (S w =)",
    "insertText": "S(v.x * m.x[0][3] + v.y * m.x[1][3] + v.z * m.x[2][3] + v.w * m.x[3][3])"
  }
]