[
  {
    "label": "FBodyInstanceCore",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBodyInstanceCore"
  },
  {
    "label": "FChaosQueryFlag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FChaosQueryFlag"
  },
  {
    "label": "FChaosScene",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosScene"
  },
  {
    "label": "FActorCreationParams",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FActorCreationParams"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FBodyCollisionFilterData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBodyCollisionFilterData"
  },
  {
    "label": "FBodyCollisionFlags",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBodyCollisionFlags"
  },
  {
    "label": "FBodyCollisionData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBodyCollisionData"
  },
  {
    "label": "UPhysicalMaterial",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPhysicalMaterial"
  },
  {
    "label": "UPrimitiveComponent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPrimitiveComponent"
  },
  {
    "label": "FBodyInstance",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBodyInstance"
  },
  {
    "label": "FConstraintInstance",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConstraintInstance"
  },
  {
    "label": "FKShapeElem",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FKShapeElem"
  },
  {
    "label": "FCustomChaosPayload",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCustomChaosPayload"
  },
  {
    "label": "FPhysicsObject",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPhysicsObject"
  },
  {
    "label": "FChaosUserEntityAppend",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FChaosUserEntityAppend"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "FChaosUserData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FChaosUserData"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "FChaosFilterData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FChaosFilterData"
  },
  {
    "label": "Enum",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Enum"
  },
  {
    "label": "ChaosFlags",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ChaosFlags"
  },
  {
    "label": "FChaosQueryFilterData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FChaosQueryFilterData"
  },
  {
    "label": "FActorCreationParams()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" PhysicsInterfaceDeclaresCore . h \" # include \" PhysicsInterfaceWrapperShared . h \" # include \" Chaos / CollisionFilterData . h \" struct FBodyInstanceCore ; struct FChaosQueryFlag ; class FChaosScene ; struct FActorCreationParams {)",
    "insertText": "FActorCreationParams() : Scene(nullptr) , InitialTM(FTransform::Identity) , bStatic(false) , bQueryOnly(false) , bEnableGravity(false) , bUpdateKinematicFromSimulation(false) , bSimulatePhysics(false) , bStartAwake(true) , DebugName(nullptr)"
  },
  {
    "label": "FBodyCollisionFlags()",
    "kind": "Method",
    "detail": "Function (} FChaosScene* Scene ; FTransform InitialTM ; bool bStatic ; bool bQueryOnly ; bool bEnableGravity ; bool bUpdateKinematicFromSimulation ; bool bSimulatePhysics ; bool bStartAwake ; char* DebugName ; } ; enum class ECollisionQuery : uint8 { ObjectQuery = 0,TraceQuery = 1 } ; enum class ECollisionShapeType : uint8 { Sphere,Plane,Box,Capsule,Convex,Trimesh,Heightfield,None } ; struct FBodyCollisionFilterData { FCollisionFilterData SimFilter ; FCollisionFilterData QuerySimpleFilter ; FCollisionFilterData QueryComplexFilter ; } ; struct FBodyCollisionFlags {)",
    "insertText": "FBodyCollisionFlags() : bEnableSimCollisionSimple(false) , bEnableSimCollisionComplex(false) , bEnableQueryCollision(false) , bEnableProbeCollision(false)"
  },
  {
    "label": "SetupNonUniformHelper()",
    "kind": "Method",
    "detail": "Function (} bool bEnableSimCollisionSimple ; bool bEnableSimCollisionComplex ; bool bEnableQueryCollision ; bool bEnableProbeCollision ; } ; struct FBodyCollisionData { FBodyCollisionFilterData CollisionFilterData ; FBodyCollisionFlags CollisionFlags ; } ; void)",
    "insertText": "SetupNonUniformHelper(FVector InScale3D, double& OutMinScale, double& OutMinScaleAbs, FVector& OutScale3DAbs)"
  },
  {
    "label": "FVector()",
    "kind": "Method",
    "detail": "Function (InScale3D =)",
    "insertText": "FVector(0.1f)"
  },
  {
    "label": "GetAbs()",
    "kind": "Method",
    "detail": "Function (} OutScale3DAbs = InScale3D .)",
    "insertText": "GetAbs()"
  },
  {
    "label": "GetMin()",
    "kind": "Method",
    "detail": "Function (OutMinScaleAbs = OutScale3DAbs .)",
    "insertText": "GetMin()"
  },
  {
    "label": "Max3()",
    "kind": "Method",
    "detail": "Function (OutMinScale =)",
    "insertText": "Max3(InScale3D.X, InScale3D.Y, InScale3D.Z)"
  },
  {
    "label": "SetupNonUniformHelper()",
    "kind": "Method",
    "detail": "Function (OutMinScale = 0 . 1 f ; OutMinScaleAbs = 0 . 1 f ; } } void)",
    "insertText": "SetupNonUniformHelper(FVector InScale3D, float& OutMinScale, float& OutMinScaleAbs, FVector& OutScale3DAbs)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (OutMinScale = static_cast<)",
    "insertText": "float(OutMinScaleD)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (OutMinScaleAbs = static_cast<)",
    "insertText": "float(OutMinScaleAbsD)"
  },
  {
    "label": "CalcMeshNegScaleCompensation()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CalcMeshNegScaleCompensation(const FVector& InScale3D, FTransform& OutTransform)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OutTransform = FTransform::Identity ;)",
    "insertText": "if(InScale3D.Y > 0.f)"
  },
  {
    "label": "SetRotation()",
    "kind": "Method",
    "detail": "Function (} else { OutTransform .)",
    "insertText": "SetRotation(FQuat(FVector(0.0f, 1.0f, 0.0f), UE_PI))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(InScale3D.Z > 0.f)"
  },
  {
    "label": "SetRotation()",
    "kind": "Method",
    "detail": "Function (OutTransform .)",
    "insertText": "SetRotation(FQuat(FVector(0.0f, 0.0f, 1.0f), UE_PI))"
  },
  {
    "label": "SetRotation()",
    "kind": "Method",
    "detail": "Function (} else { OutTransform .)",
    "insertText": "SetRotation(FQuat(FVector(1.0f, 0.0f, 0.0f), UE_PI))"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "return(InScale3D.X * InScale3D.Y * InScale3D.Z)"
  },
  {
    "label": "FChaosUserData()",
    "kind": "Method",
    "detail": "Function (} const uint32 AggregateMaxSize = 1 2 8 ; class UPhysicalMaterial ; class UPrimitiveComponent ; struct FBodyInstance ; struct FConstraintInstance ; struct FKShapeElem ; struct FKShapeElem ; struct FCustomChaosPayload ; struct FPhysicsObject ; struct FChaosUserEntityAppend ; namespace EChaosUserDataType { enum Type { Invalid,BodyInstance,PhysicalMaterial,PhysScene,ConstraintInstance,PrimitiveComponent,AggShape,PhysicsObject,ChaosUserEntity,CustomPayload,} ; } ; struct FChaosUserData { protected : EChaosUserDataType::Type Type ; void* Payload ; public :)",
    "insertText": "FChaosUserData() :Type(EChaosUserDataType::Invalid), Payload(nullptr)"
  },
  {
    "label": "FChaosUserData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FChaosUserData(FBodyInstance* InPayload) :Type(EChaosUserDataType::BodyInstance), Payload(InPayload)"
  },
  {
    "label": "FChaosUserData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FChaosUserData(UPhysicalMaterial* InPayload) :Type(EChaosUserDataType::PhysicalMaterial), Payload(InPayload)"
  },
  {
    "label": "FChaosUserData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FChaosUserData(FPhysScene* InPayload) :Type(EChaosUserDataType::PhysScene), Payload(InPayload)"
  },
  {
    "label": "FChaosUserData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FChaosUserData(FConstraintInstance* InPayload) :Type(EChaosUserDataType::ConstraintInstance), Payload(InPayload)"
  },
  {
    "label": "FChaosUserData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FChaosUserData(UPrimitiveComponent* InPayload) :Type(EChaosUserDataType::PrimitiveComponent), Payload(InPayload)"
  },
  {
    "label": "FChaosUserData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FChaosUserData(FKShapeElem* InPayload) :Type(EChaosUserDataType::AggShape), Payload(InPayload)"
  },
  {
    "label": "FChaosUserData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FChaosUserData(FPhysicsObject* InPayload) :Type(EChaosUserDataType::PhysicsObject), Payload(InPayload)"
  },
  {
    "label": "FChaosUserData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FChaosUserData(FChaosUserEntityAppend* InPayload) :Type(EChaosUserDataType::ChaosUserEntity), Payload(InPayload)"
  },
  {
    "label": "FChaosUserData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FChaosUserData(FCustomChaosPayload* InPayload) :Type(EChaosUserDataType::CustomPayload), Payload(InPayload)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} template<class T> T*)",
    "insertText": "Get(void* UserData)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (template<class T> void)",
    "insertText": "Set(void* UserData, T* Payload)"
  },
  {
    "label": "IsGarbage()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsGarbage(void* UserData)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} template<> void)",
    "insertText": "Set(void* UserData, FBodyInstance* Payload)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} template<> void)",
    "insertText": "Set(void* UserData, UPhysicalMaterial* Payload)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} template<> void)",
    "insertText": "Set(void* UserData, FPhysScene* Payload)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} template<> void)",
    "insertText": "Set(void* UserData, FConstraintInstance* Payload)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} template<> void)",
    "insertText": "Set(void* UserData, UPrimitiveComponent* Payload)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} template<> void)",
    "insertText": "Set(void* UserData, FKShapeElem* Payload)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} template<> void)",
    "insertText": "Set(void* UserData, FPhysicsObject* Payload)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} template<> void)",
    "insertText": "Set(void* UserData, FChaosUserEntityAppend* Payload)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} template<> void)",
    "insertText": "Set(void* UserData, FCustomChaosPayload* Payload)"
  },
  {
    "label": "FChaosFilterData()",
    "kind": "Method",
    "detail": "Function (} struct FChaosFilterData {)",
    "insertText": "FChaosFilterData()"
  },
  {
    "label": "FChaosFilterData()",
    "kind": "Method",
    "detail": "Function (word0 = word1 = word2 = word3 = 0 ; })",
    "insertText": "FChaosFilterData(uint32 w0, uint32 w1, uint32 w2, uint32 w3) : word0(w0), word1(w1), word2(w2), word3(w3)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FChaosFilterData& Other)"
  },
  {
    "label": "eSTATIC()",
    "kind": "Method",
    "detail": "Function (} uint32 word0 ; uint32 word1 ; uint32 word2 ; uint32 word3 ; } ; struct FChaosQueryFlag { enum Enum {)",
    "insertText": "eSTATIC(1 << 0), eDYNAMIC = (1 << 1), ePREFILTER = (1 << 2), ePOSTFILTER = (1 << 3), eANY_HIT = (1 << 4), eNO_BLOCK = (1 << 5), eSKIPNARROWPHASE = (1 << 6), eRESERVED = (1 << 15)"
  },
  {
    "label": "ChaosFlags()",
    "kind": "Method",
    "detail": "Function (} ; template<enumtype,storagetype = uint32_t> class ChaosFlags { public : typedef storagetype InternalType ;)",
    "insertText": "ChaosFlags(void)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (public : ChaosFlags<enumtype,storagetype>)",
    "insertText": "operator(enumtype a, ChaosFlags<enumtype, storagetype>& b)"
  },
  {
    "label": "U2CQueryFlags()",
    "kind": "Method",
    "detail": "Function (ChaosFlags<enumtype,storagetype> out ; out . mBits = a& b . mBits ; return out ; } private : storagetype mBits ; } ; typedef ChaosFlags<FChaosQueryFlag::Enum,uint16> FChaosQueryFlags ; FChaosQueryFlags)",
    "insertText": "U2CQueryFlags(FQueryFlags Flags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint16 Result = 0 ;)",
    "insertText": "if(Flags & EQueryFlags::PreFilter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Result | = FChaosQueryFlag::ePREFILTER ; })",
    "insertText": "if(Flags & EQueryFlags::PostFilter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Result | = FChaosQueryFlag::ePOSTFILTER ; })",
    "insertText": "if(Flags & EQueryFlags::AnyHit)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Result | = FChaosQueryFlag::eANY_HIT ; })",
    "insertText": "if(Flags & EQueryFlags::SkipNarrowPhase)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (Result | = FChaosQueryFlag::eSKIPNARROWPHASE ; })",
    "insertText": "return(FChaosQueryFlags)"
  },
  {
    "label": "FChaosQueryFilterData()",
    "kind": "Method",
    "detail": "Function (} struct FChaosQueryFilterData {)",
    "insertText": "FChaosQueryFilterData() : flags(FChaosQueryFlag::eDYNAMIC | FChaosQueryFlag::eSTATIC), clientId(0)"
  },
  {
    "label": "FChaosQueryFilterData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FChaosQueryFilterData(const FChaosFilterData& fd, FChaosQueryFlags f) : data(fd), flags(f), clientId(0)"
  },
  {
    "label": "FChaosQueryFilterData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FChaosQueryFilterData(FChaosQueryFlags f) : flags(f), clientId(0)"
  },
  {
    "label": "ChaosFlags()",
    "kind": "Method",
    "detail": "Function (mBits = 0 ; } template<enumtype,storagetype> ChaosFlags<enumtype,storagetype)",
    "insertText": "ChaosFlags(enumtype e)"
  },
  {
    "label": "storagetype()",
    "kind": "Method",
    "detail": "Function (mBits = static_cast<)",
    "insertText": "storagetype(e)"
  },
  {
    "label": "ChaosFlags()",
    "kind": "Method",
    "detail": "Function (} template<enumtype,storagetype> ChaosFlags<enumtype,storagetype)",
    "insertText": "ChaosFlags(const ChaosFlags<enumtype, storagetype>& f)"
  },
  {
    "label": "ChaosFlags()",
    "kind": "Method",
    "detail": "Function (mBits = f . mBits ; } template<enumtype,storagetype> ChaosFlags<enumtype,storagetype)",
    "insertText": "ChaosFlags(storagetype b)"
  },
  {
    "label": "isSet()",
    "kind": "Method",
    "detail": "Function (mBits = b ; } template<enumtype,storagetype> bool ChaosFlags<enumtype,storagetype)",
    "insertText": "isSet(enumtype e)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} template<enumtype,storagetype> ChaosFlags<enumtype,storagetype>& ChaosFlags<enumtype,storagetype)",
    "insertText": "set(enumtype e)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<enumtype,storagetype> bool ChaosFlags<enumtype,storagetype)",
    "insertText": "operator(const ChaosFlags<enumtype, storagetype>& f)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<enumtype,storagetype> bool ChaosFlags<enumtype,storagetype)",
    "insertText": "operator(enumtype e)"
  },
  {
    "label": "out()",
    "kind": "Method",
    "detail": "Function (ChaosFlags<enumtype,storagetype>)",
    "insertText": "out(*this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ChaosFlags<enumtype,storagetype> out =* this ; out . mBits ^ = f . mBits ; return out ; } template<enumtype,storagetype> ChaosFlags<enumtype,storagetype> ChaosFlags<enumtype,storagetype)",
    "insertText": "operator(void)"
  },
  {
    "label": "storagetype()",
    "kind": "Method",
    "detail": "Function (ChaosFlags<enumtype,storagetype> out ; out . mBits =)",
    "insertText": "storagetype(~mBits)"
  },
  {
    "label": "uint16_t()",
    "kind": "Method",
    "detail": "Function (} template<enumtype,storagetype> ChaosFlags<enumtype,storagetype>::operator)",
    "insertText": "uint16_t(void)"
  },
  {
    "label": "uint32_t()",
    "kind": "Method",
    "detail": "Function (} template<enumtype,storagetype> ChaosFlags<enumtype,storagetype>::operator)",
    "insertText": "uint32_t(void)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} template<enumtype,storagetype> void ChaosFlags<enumtype,storagetype)",
    "insertText": "clear(enumtype e)"
  }
]