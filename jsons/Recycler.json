[
  {
    "label": "RecyclerStruct",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RecyclerStruct"
  },
  {
    "label": "ilist_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ilist_traits"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "Recycler",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Recycler"
  },
  {
    "label": "AllocatorType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AllocatorType"
  },
  {
    "label": "SubClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SubClass"
  },
  {
    "label": "PrintRecyclerStats()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_SUPPORT_RECYCLER_H # define LLVM_SUPPORT_RECYCLER_H # include \" llvm / ADT / ilist . h \" # include \" llvm / Support / AlignOf . h \" # include \" llvm / Support / Allocator . h \" # include \" llvm / Support / ErrorHandling . h \" # include<cassert> namespace llvm { void)",
    "insertText": "PrintRecyclerStats(size_t Size, size_t Align, size_t FreeListSize)"
  },
  {
    "label": "getPrev()",
    "kind": "Method",
    "detail": "Function (struct RecyclerStruct { RecyclerStruct* Prev,* Next ; } ; template<> struct ilist_traits<RecyclerStruct> : public ilist_default_traits<RecyclerStruct> { RecyclerStruct*)",
    "insertText": "getPrev(const RecyclerStruct *t)"
  },
  {
    "label": "setNext()",
    "kind": "Method",
    "detail": "Function (t -> Prev = p ; } void)",
    "insertText": "setNext(RecyclerStruct *t, RecyclerStruct *n)"
  },
  {
    "label": "createSentinel()",
    "kind": "Method",
    "detail": "Function (t -> Next = n ; } RecyclerStruct Sentinel ; RecyclerStruct*)",
    "insertText": "createSentinel()"
  },
  {
    "label": "provideInitialHead()",
    "kind": "Method",
    "detail": "Function (} RecyclerStruct*)",
    "insertText": "provideInitialHead()"
  },
  {
    "label": "ensureHead()",
    "kind": "Method",
    "detail": "Function (} RecyclerStruct*)",
    "insertText": "ensureHead(RecyclerStruct*)"
  },
  {
    "label": "noteHead()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "noteHead(RecyclerStruct*, RecyclerStruct*)"
  },
  {
    "label": "deleteNode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "deleteNode(RecyclerStruct *)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Recycler's ilist_traits shouldn't see a deleteNode call!\")"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T,size_t Size =)",
    "insertText": "sizeof(T)"
  },
  {
    "label": "Recycler()",
    "kind": "Method",
    "detail": "Function (iplist<RecyclerStruct> FreeList ; public : ~)",
    "insertText": "Recycler()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(FreeList.empty() && \"Non-empty recycler deleted!\")"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} template<class AllocatorType> void)",
    "insertText": "clear(AllocatorType &Allocator)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T* t = reinterpret_cast<)",
    "insertText": "T(FreeList.remove(FreeList.begin()))"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (Allocator .)",
    "insertText": "Deallocate(t)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "clear(BumpPtrAllocator&)"
  },
  {
    "label": "clearAndLeakNodesUnsafely()",
    "kind": "Method",
    "detail": "Function (FreeList .)",
    "insertText": "clearAndLeakNodesUnsafely()"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (} template<class SubClass,class AllocatorType> SubClass*)",
    "insertText": "Allocate(AllocatorType &Allocator)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (} template<class SubClass,class AllocatorType> void)",
    "insertText": "Deallocate(AllocatorType & , SubClass* Element)"
  },
  {
    "label": "push_front()",
    "kind": "Method",
    "detail": "Function (FreeList .)",
    "insertText": "push_front(reinterpret_cast<RecyclerStruct *>(Element))"
  },
  {
    "label": "PrintStats()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PrintStats()"
  },
  {
    "label": "PrintRecyclerStats()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintRecyclerStats(Size, Align, FreeList.size())"
  }
]