[
  {
    "label": "FSizedDisjointSet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSizedDisjointSet"
  },
  {
    "label": "FVertexConnectedComponents",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVertexConnectedComponents"
  },
  {
    "label": "FSizedDisjointSet()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" BoxTypes . h \" # include \" IndexTypes . h \" # include \" Spatial / PointHashGrid3 . h \" namespace UE { namespace Geometry { struct FSizedDisjointSet { TArray<int32> Parents,Sizes ;)",
    "insertText": "FSizedDisjointSet()"
  },
  {
    "label": "FSizedDisjointSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSizedDisjointSet(int32 NumIDs)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(NumIDs)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Init(int32 NumIDs)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (Parents .)",
    "insertText": "SetNumUninitialized(NumIDs)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (Parents [ Idx ] = Idx ; Sizes [ Idx ] = 1 ; } } template<IsElementFunction> void)",
    "insertText": "Init(int32 NumIDs, IsElementFunction IsElement)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (Parents [ Idx ] = Idx ; Sizes [ Idx ] = 1 ; } else { Parents [ Idx ] = - 1 ; Sizes [ Idx ] = 0 ; } } } int32)",
    "insertText": "Union(int32 A, int32 B)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (int32 ParentA =)",
    "insertText": "Find(A)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (int32 ParentB =)",
    "insertText": "Find(B)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(ParentA, ParentB)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} Parents [ ParentA ] = ParentB ; Sizes [ ParentB ] + = Sizes [ ParentA ] ; return ParentB ; } int32)",
    "insertText": "Find(int32 Idx)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 Parent = Idx ;)",
    "insertText": "while(Parents[Parent] != Parent)"
  },
  {
    "label": "GetSize()",
    "kind": "Method",
    "detail": "Function (Parents [ Parent ] = Parents [ Parents [ Parent ] ] ; Parent = Parents [ Parent ] ; } return Parent ; } int32)",
    "insertText": "GetSize(int32 Idx)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (int32 Parent =)",
    "insertText": "Find(Idx)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MinGroupSize =)",
    "insertText": "Max(1, MinGroupSize)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32 NumIDs = Sizes .)",
    "insertText": "Num()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (CompactIdxToGroupID ->)",
    "insertText": "Reset()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(GroupIDToCompactIdx)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (GroupIDToCompactIdx ->)",
    "insertText": "Init(-1, NumIDs)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} int32 NumGroups = 0 ;)",
    "insertText": "for(int32 ID = 0; ID < NumIDs; ++ID)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (continue ; } int32 Parent =)",
    "insertText": "Find(ID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(Sizes[Parent] < MinGroupSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(CompactIdxToGroupID)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (CompactIdxToGroupID ->)",
    "insertText": "Add(Parent)"
  },
  {
    "label": "FVertexConnectedComponents()",
    "kind": "Method",
    "detail": "Function (} NumGroups + + ; } return NumGroups ; } } ; class FVertexConnectedComponents { public :)",
    "insertText": "FVertexConnectedComponents()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(0)"
  },
  {
    "label": "FVertexConnectedComponents()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FVertexConnectedComponents(int32 MaxVertexID)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(MaxVertexID)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Init(int32 MaxVertexID)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} template<TriangleMeshType> void)",
    "insertText": "Init(const TriangleMeshType& Mesh)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (DisjointSet .)",
    "insertText": "Init(Mesh.MaxVertexID(), [&Mesh](int32 VID) -> bool { return Mesh.IsVertex(VID); })"
  },
  {
    "label": "ConnectTriangles()",
    "kind": "Method",
    "detail": "Function (} template<TriangleMeshType> void)",
    "insertText": "ConnectTriangles(const TriangleMeshType& Mesh)"
  },
  {
    "label": "GetTriangle()",
    "kind": "Method",
    "detail": "Function (FIndex3i Triangle = Mesh .)",
    "insertText": "GetTriangle(TID)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (DisjointSet .)",
    "insertText": "Union(Triangle[0], Triangle[1])"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (DisjointSet .)",
    "insertText": "Union(Triangle[1], Triangle[2])"
  },
  {
    "label": "ConnectTriangles()",
    "kind": "Method",
    "detail": "Function (} } } template<TriangleType> void)",
    "insertText": "ConnectTriangles(TArrayView<const TriangleType> Triangles)"
  },
  {
    "label": "ConnectCloseVertices()",
    "kind": "Method",
    "detail": "Function (} } template<TriangleMeshType> void)",
    "insertText": "ConnectCloseVertices(const TriangleMeshType& Mesh, double CloseVertexThreshold, int32 KeepSizeThreshold = 0)"
  },
  {
    "label": "VertexHash()",
    "kind": "Method",
    "detail": "Function (TPointHashGrid3d<int32>)",
    "insertText": "VertexHash(CloseVertexThreshold * 3, -1)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (continue ; } int32 SetID = DisjointSet .)",
    "insertText": "Find(VID)"
  },
  {
    "label": "VertexCount()",
    "kind": "Method",
    "detail": "Function (continue ; } int32 MaxSetSize = Mesh .)",
    "insertText": "VertexCount()"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (FVector3d Pt = Mesh .)",
    "insertText": "GetVertex(VID)"
  },
  {
    "label": "EnumeratePointsInBall()",
    "kind": "Method",
    "detail": "Function (VertexHash .)",
    "insertText": "EnumeratePointsInBall(Pt, CloseVertexThreshold, [&Mesh, Pt](int32 OtherVID) { return DistanceSquared(Pt, Mesh.GetVertex(OtherVID)); }, [this, SetID, MaxSetSize](const int32& NbrVID, double DistSq) { int32 UnionSetID = DisjointSet.Union(SetID, NbrVID); return DisjointSet.Sizes[UnionSetID] < MaxSetSize; })"
  },
  {
    "label": "InsertPointUnsafe()",
    "kind": "Method",
    "detail": "Function (VertexHash .)",
    "insertText": "InsertPointUnsafe(VID, Pt)"
  },
  {
    "label": "ConnectOverlappingComponents()",
    "kind": "Method",
    "detail": "Function (} } template<TriangleMeshType> void)",
    "insertText": "ConnectOverlappingComponents(const TriangleMeshType& Mesh, int32 KeepSizeThreshold = 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TMap<int32,FAxisAlignedBox3d> SetIDToBounds ;)",
    "insertText": "for(int32 VID = 0; VID < Mesh.MaxVertexID(); VID++)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (FAxisAlignedBox3d& Bounds = SetIDToBounds .)",
    "insertText": "FindOrAdd(SetID, FAxisAlignedBox3d::Empty())"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Bounds .)",
    "insertText": "Contain(Pt)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(auto It = SetIDToBounds.CreateConstIterator(); It; ++It)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (auto NextIt = It ; + + NextIt ;)",
    "insertText": "for(; NextIt; ++NextIt)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (DisjointSet .)",
    "insertText": "Union(It.Key(), NextIt.Key())"
  },
  {
    "label": "HasMultipleComponents()",
    "kind": "Method",
    "detail": "Function (} } } } template<TriangleMeshType> bool)",
    "insertText": "HasMultipleComponents(const TriangleMeshType& Mesh, int32 KeepSizeThreshold = 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(FoundComponent == -1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FoundComponent = SetID ; } else)",
    "insertText": "if(FoundComponent != SetID)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 FoundComponent = - 1 ;)",
    "insertText": "for(int32 VID = 0; VID < MaxVID; VID++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(!ComponentMap.Contains(SetID))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ComponentMap .)",
    "insertText": "Add(SetID, CurrentIdx++)"
  },
  {
    "label": "MakeComponentMap()",
    "kind": "Method",
    "detail": "Function (} } return ComponentMap ; } TMap<int32,int32>)",
    "insertText": "MakeComponentMap(int32 MaxVID, int32 KeepSizeThreshold = 0)"
  },
  {
    "label": "MakeContiguousComponentsArray()",
    "kind": "Method",
    "detail": "Function (} } return ComponentMap ; } TArray<int32>)",
    "insertText": "MakeContiguousComponentsArray(int32 MaxVID)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TMap<int32,int32> ComponentLoc ; TArray<int32> Contiguous ; Contiguous .)",
    "insertText": "SetNum(MaxVID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 SetSize = DisjointSet . Sizes [ SetID ] ;)",
    "insertText": "if(SetSize == 1)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (LastSingleEntryIdx - - ; Contiguous [ LastSingleEntryIdx ] = VID ; continue ; } int32* Loc = ComponentLoc .)",
    "insertText": "Find(SetID)"
  },
  {
    "label": "Contiguous()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Contiguous(*Loc)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { Contiguous [ FirstUnusedIdx ] = VID ; ComponentLoc .)",
    "insertText": "Add(SetID, FirstUnusedIdx + 1)"
  },
  {
    "label": "EnumerateContiguousComponentsFromArray()",
    "kind": "Method",
    "detail": "Function (FirstUnusedIdx + = SetSize ; } } return Contiguous ; } bool)",
    "insertText": "EnumerateContiguousComponentsFromArray(const TArray<int32>& ContiguousComponentsArray, TFunctionRef<bool(int32, TArrayView<const int32>)> ProcessComponentFn)"
  },
  {
    "label": "GetComponent()",
    "kind": "Method",
    "detail": "Function (int32 ComponentID =)",
    "insertText": "GetComponent(ContiguousComponentsArray[ContigStart])"
  },
  {
    "label": "GetComponentSize()",
    "kind": "Method",
    "detail": "Function (int32 ComponentSize =)",
    "insertText": "GetComponentSize(ComponentID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NextStart = ContigStart + ComponentSize ;)",
    "insertText": "if(!ensure(NextStart <= ContiguousComponentsArray.Num()))"
  },
  {
    "label": "ProcessComponentFn()",
    "kind": "Method",
    "detail": "Function (bool bContinue =)",
    "insertText": "ProcessComponentFn(ComponentID, ComponentView)"
  },
  {
    "label": "GetComponentSize()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetComponentSize(int32 VertexID)"
  },
  {
    "label": "GetComponent()",
    "kind": "Method",
    "detail": "Function (} template<TriangleType> int32)",
    "insertText": "GetComponent(const TriangleType& Triangle)"
  },
  {
    "label": "ConnectVertices()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ConnectVertices(int32 VertexID0, int32 VertexID1)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (DisjointSet .)",
    "insertText": "Union(VertexID0, VertexID1)"
  }
]