[
  {
    "label": "MessageFormat",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MessageFormat"
  },
  {
    "label": "U_I18N_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U_I18N_API"
  },
  {
    "label": "ChoiceFormat()",
    "kind": "Method",
    "detail": "Function (# ifndef CHOICFMT_H # define CHOICFMT_H # include \" unicode / utypes . h \" # if ! UCONFIG_NO_FORMATTING # ifndef # include \" unicode / fieldpos . h \" # include \" unicode / format . h \" # include \" unicode / messagepattern . h \" # include \" unicode / numfmt . h \" # include \" unicode / unistr . h \" U_NAMESPACE_BEGIN class MessageFormat ; class U_I18N_API ChoiceFormat : public NumberFormat { public :)",
    "insertText": "ChoiceFormat(const UnicodeString& pattern, UErrorCode& status)"
  },
  {
    "label": "ChoiceFormat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChoiceFormat(const double* limits, const UnicodeString* formats, int32_t count)"
  },
  {
    "label": "ChoiceFormat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChoiceFormat(const double* limits, const UBool* closures, const UnicodeString* formats, int32_t count)"
  },
  {
    "label": "ChoiceFormat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChoiceFormat(const ChoiceFormat& that)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (const ChoiceFormat&)",
    "insertText": "operator(const ChoiceFormat& that)"
  },
  {
    "label": "ChoiceFormat()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ChoiceFormat()"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (Format*)",
    "insertText": "clone(void)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "operator(const Format& other)"
  },
  {
    "label": "applyPattern()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applyPattern(const UnicodeString& pattern, UErrorCode& status)"
  },
  {
    "label": "applyPattern()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applyPattern(const UnicodeString& pattern, UParseError& parseError, UErrorCode& status)"
  },
  {
    "label": "toPattern()",
    "kind": "Method",
    "detail": "Function (UnicodeString&)",
    "insertText": "toPattern(UnicodeString &pattern)"
  },
  {
    "label": "setChoices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setChoices(const double* limitsToCopy, const UnicodeString* formatsToCopy, int32_t count)"
  },
  {
    "label": "setChoices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setChoices(const double* limits, const UBool* closures, const UnicodeString* formats, int32_t count)"
  },
  {
    "label": "getLimits()",
    "kind": "Method",
    "detail": "Function (const double*)",
    "insertText": "getLimits(int32_t& count)"
  },
  {
    "label": "getClosures()",
    "kind": "Method",
    "detail": "Function (const UBool*)",
    "insertText": "getClosures(int32_t& count)"
  },
  {
    "label": "getFormats()",
    "kind": "Method",
    "detail": "Function (const UnicodeString*)",
    "insertText": "getFormats(int32_t& count)"
  },
  {
    "label": "format()",
    "kind": "Method",
    "detail": "Function (using NumberFormat::format ; UnicodeString&)",
    "insertText": "format(double number, UnicodeString& appendTo, FieldPosition& pos)"
  },
  {
    "label": "format()",
    "kind": "Method",
    "detail": "Function (UnicodeString&)",
    "insertText": "format(int32_t number, UnicodeString& appendTo, FieldPosition& pos)"
  },
  {
    "label": "format()",
    "kind": "Method",
    "detail": "Function (UnicodeString&)",
    "insertText": "format(int64_t number, UnicodeString& appendTo, FieldPosition& pos)"
  },
  {
    "label": "format()",
    "kind": "Method",
    "detail": "Function (UnicodeString&)",
    "insertText": "format(const Formattable* objs, int32_t cnt, UnicodeString& appendTo, FieldPosition& pos, UErrorCode& success)"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (using NumberFormat::parse ; void)",
    "insertText": "parse(const UnicodeString& text, Formattable& result, ParsePosition& parsePosition)"
  },
  {
    "label": "getDynamicClassID()",
    "kind": "Method",
    "detail": "Function (UClassID)",
    "insertText": "getDynamicClassID(void)"
  },
  {
    "label": "getStaticClassID()",
    "kind": "Method",
    "detail": "Function (UClassID U_EXPORT2)",
    "insertText": "getStaticClassID(void)"
  },
  {
    "label": "dtos()",
    "kind": "Method",
    "detail": "Function (private : UnicodeString&)",
    "insertText": "dtos(double value, UnicodeString& string)"
  },
  {
    "label": "ChoiceFormat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChoiceFormat(const UnicodeString& newPattern, UParseError& parseError, UErrorCode& status)"
  },
  {
    "label": "setChoices()",
    "kind": "Method",
    "detail": "Function (class MessageFormat ; void)",
    "insertText": "setChoices(const double* limits, const UBool* closures, const UnicodeString* formats, int32_t count, UErrorCode &errorCode)"
  },
  {
    "label": "findSubMessage()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "findSubMessage(const MessagePattern &pattern, int32_t partIndex, double number)"
  },
  {
    "label": "parseArgument()",
    "kind": "Method",
    "detail": "Function (double)",
    "insertText": "parseArgument(const MessagePattern &pattern, int32_t partIndex, const UnicodeString &source, ParsePosition &pos)"
  },
  {
    "label": "matchStringUntilLimitPart()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "matchStringUntilLimitPart(const MessagePattern &pattern, int32_t partIndex, int32_t limitPartIndex, const UnicodeString &source, int32_t sourceOffset)"
  }
]