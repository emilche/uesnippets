[
  {
    "label": "FIndexFlagSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FIndexFlagSet"
  },
  {
    "label": "FOptionallySparseIndexMap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOptionallySparseIndexMap"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FIndexFlagSet()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" IndexTypes . h \" # include<CoreMinimal . h> namespace UE { namespace Geometry { class FIndexFlagSet { private : TOptional<TArray<bool>> Dense ; int DenseCount ; TOptional<TSet<int>> Sparse ; public :)",
    "insertText": "FIndexFlagSet(bool bSetSparse = true, int MaxIndex = -1)"
  },
  {
    "label": "InitManual()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitManual(bSetSparse, MaxIndex)"
  },
  {
    "label": "FIndexFlagSet()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FIndexFlagSet(int MaxIndex, int SubsetCountEst)"
  },
  {
    "label": "InitAuto()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitAuto(MaxIndex, SubsetCountEst)"
  },
  {
    "label": "InitAuto()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitAuto(int MaxIndex, int SubsetCountEst)"
  },
  {
    "label": "InitManual()",
    "kind": "Method",
    "detail": "Function (bool bSmall = MaxIndex<3 2 0 0 0 ; float PercentThresh = 0 . 0 5 f ;)",
    "insertText": "InitManual(!bSmall && ((float)SubsetCountEst / (float)MaxIndex < PercentThresh), MaxIndex)"
  },
  {
    "label": "InitManual()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitManual(bool bSetSparse, int MaxIndex = -1)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (Sparse = TSet<)",
    "insertText": "int()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} else { Dense = TArray<)",
    "insertText": "bool()"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (Dense ->)",
    "insertText": "SetNumZeroed(FMath::Max(0, MaxIndex))"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} DenseCount = 0 ; } bool)",
    "insertText": "Contains(int Index)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "check(Sparse.IsSet())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Add(int Index)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (bool& Value = Dense .)",
    "insertText": "GetValue()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Sparse ->)",
    "insertText": "Add(Index)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Remove(int Index)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (Sparse ->)",
    "insertText": "Remove(Index)"
  },
  {
    "label": "Count()",
    "kind": "Method",
    "detail": "Function (} } int)",
    "insertText": "Count()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } const bool)",
    "insertText": "operator(unsigned int Index)"
  },
  {
    "label": "FOptionallySparseIndexMap()",
    "kind": "Method",
    "detail": "Function (} } ; struct FOptionallySparseIndexMap { TArray<int> Dense ; TMap<int,int> Sparse ; int DefaultOffset = - 1,DefaultScale = 0 ; int MaxIndex = - 1 ; enum class EMapType : uint8 { Dense,Sparse,ScaleAndOffset } ; EMapType MapType = EMapType::Sparse ;)",
    "insertText": "FOptionallySparseIndexMap()"
  },
  {
    "label": "FOptionallySparseIndexMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FOptionallySparseIndexMap(EMapType MapType, int MaxIndex = -1) : MaxIndex(MaxIndex), MapType(MapType)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Dense .)",
    "insertText": "SetNum(MaxIndex)"
  },
  {
    "label": "InitDefaults()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitDefaults()"
  },
  {
    "label": "FOptionallySparseIndexMap()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "FOptionallySparseIndexMap(TArray<int> Dense, int MaxIndex = -1) : Dense(Dense), MaxIndex(MaxIndex), MapType(EMapType::Dense)"
  },
  {
    "label": "FOptionallySparseIndexMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FOptionallySparseIndexMap(int MaxIndex, int SubsetCountEst)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize(MaxIndex, SubsetCountEst)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Initialize(int MaxIndexIn, int SubsetCountEst)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (Dense .)",
    "insertText": "Reset()"
  },
  {
    "label": "fPercent()",
    "kind": "Method",
    "detail": "Function (MaxIndex = MaxIndexIn ; bool bSmall = MaxIndex<3 2 0 0 0 ; float)",
    "insertText": "fPercent(float)SubsetCountEst / (float)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float fPercentThresh = 0 . 1 f ;)",
    "insertText": "if(bSmall || fPercent > fPercentThresh)"
  },
  {
    "label": "IdentityMap()",
    "kind": "Method",
    "detail": "Function (} FOptionallySparseIndexMap)",
    "insertText": "IdentityMap(int MaxIndex = -1)"
  },
  {
    "label": "ToRet()",
    "kind": "Method",
    "detail": "Function (FOptionallySparseIndexMap)",
    "insertText": "ToRet(EMapType::ScaleAndOffset, MaxIndex)"
  },
  {
    "label": "ConstantMap()",
    "kind": "Method",
    "detail": "Function (ToRet . DefaultScale = 1 ; ToRet . DefaultOffset = 0 ; return ToRet ; } FOptionallySparseIndexMap)",
    "insertText": "ConstantMap(int ConstantValue, int MaxIndex = -1)"
  },
  {
    "label": "SparseIdentityMap()",
    "kind": "Method",
    "detail": "Function (ToRet . DefaultScale = 0 ; ToRet . DefaultOffset = ConstantValue ; return ToRet ; } FOptionallySparseIndexMap)",
    "insertText": "SparseIdentityMap(int MaxIndex = -1)"
  },
  {
    "label": "ToRet()",
    "kind": "Method",
    "detail": "Function (FOptionallySparseIndexMap)",
    "insertText": "ToRet(EMapType::Sparse, MaxIndex)"
  },
  {
    "label": "BadIndex()",
    "kind": "Method",
    "detail": "Function (Dense [ i ] = i* DefaultScale + DefaultOffset ; } } } bool)",
    "insertText": "BadIndex(int Index)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} case EMapType::ScaleAndOffset : return Index* DefaultScale + DefaultOffset ; })",
    "insertText": "check(false)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Set(int Index, int Value)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (Dense [ Index ] = Value ; } else { Sparse .)",
    "insertText": "FindOrAdd(Index)"
  },
  {
    "label": "SetInvalid()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetInvalid(int Index)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(Index, IndexConstants::InvalidID)"
  }
]