[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "TDirectoryTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TDirectoryTree"
  },
  {
    "label": "FTreeNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTreeNode"
  },
  {
    "label": "FixupPathSeparator()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / StringView . h \" # include \" Containers / UnrealString . h \" # include \" HAL / Platform . h \" # include \" Misc / EnumClassFlags . h \" # include \" Misc / PathViews . h \" # include \" Misc / ScopeExit . h \" # include \" Misc / StringBuilder . h \" # include \" Templates / TypeCompatibleBytes . h \" # include \" Templates / UniquePtr . h \" namespace UE::DirectoryTree { void)",
    "insertText": "FixupPathSeparator(FStringBuilderBase& InOutPath, int32 StartIndex, TCHAR InSeparatorChar)"
  },
  {
    "label": "FindInsertionIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "FindInsertionIndex(int32 NumChildNodes, const TUniquePtr<FString[]>& RelPaths, FStringView FirstPathComponent, bool& bOutExists)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (} enum class EDirectoryTreeGetFlags { None = 0,Recursive = 0 x1,ImpliedParent = 0 x1<<1,ImpliedChildren = 0 x1<<2,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(EDirectoryTreeGetFlags)"
  },
  {
    "label": "TDirectoryTree()",
    "kind": "Method",
    "detail": "Function (template<ValueType> class TDirectoryTree { public :)",
    "insertText": "TDirectoryTree()"
  },
  {
    "label": "TDirectoryTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDirectoryTree(const TDirectoryTree& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TDirectoryTree&)",
    "insertText": "operator(const TDirectoryTree& Other)"
  },
  {
    "label": "TDirectoryTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDirectoryTree(TDirectoryTree&& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TDirectoryTree&)",
    "insertText": "operator(TDirectoryTree&& Other)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (ValueType&)",
    "insertText": "FindOrAdd(FStringView Path, bool* bOutExisted = nullptr)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Remove(FStringView Path, bool* bOutExisted = nullptr)"
  },
  {
    "label": "Shrink()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Shrink()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Num()"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Contains(FStringView Path)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (const ValueType*)",
    "insertText": "Find(FStringView Path)"
  },
  {
    "label": "ContainsPathOrParent()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ContainsPathOrParent(FStringView Path)"
  },
  {
    "label": "FindClosestValue()",
    "kind": "Method",
    "detail": "Function (const ValueType*)",
    "insertText": "FindClosestValue(FStringView Path)"
  },
  {
    "label": "TryFindClosestPath()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryFindClosestPath(FStringView Path, FStringBuilderBase& OutPath, const ValueType** OutValue = nullptr)"
  },
  {
    "label": "TryFindClosestPath()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryFindClosestPath(FStringView Path, FStringBuilderBase& OutPath, ValueType** OutValue)"
  },
  {
    "label": "TryFindClosestPath()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryFindClosestPath(FStringView Path, FString& OutPath, const ValueType** OutValue = nullptr)"
  },
  {
    "label": "TryFindClosestPath()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryFindClosestPath(FStringView Path, FString& OutPath, ValueType** OutValue)"
  },
  {
    "label": "ContainsChildPaths()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ContainsChildPaths(FStringView Path)"
  },
  {
    "label": "TryGetChildren()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryGetChildren(FStringView Path, TArray<FString>& OutRelativeChildNames, EDirectoryTreeGetFlags Flags = EDirectoryTreeGetFlags::None)"
  },
  {
    "label": "FTreeNode()",
    "kind": "Method",
    "detail": "Function (private : struct FTreeNode { public :)",
    "insertText": "FTreeNode()"
  },
  {
    "label": "FTreeNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FTreeNode(FTreeNode&& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FTreeNode&)",
    "insertText": "operator(FTreeNode&& Other)"
  },
  {
    "label": "FTreeNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FTreeNode(const FTreeNode& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FTreeNode&)",
    "insertText": "operator(const FTreeNode& Other)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "GetNumChildNodes()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumChildNodes()"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (ValueType&)",
    "insertText": "FindOrAdd(FStringView InRelPath, bool& bOutExisted)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Remove(FStringView InRelPath, bool& bOutExisted)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (ValueType*)",
    "insertText": "Find(FStringView InRelPath)"
  },
  {
    "label": "ContainsChildPaths()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ContainsChildPaths(FStringView InRelPath)"
  },
  {
    "label": "TryGetChildren()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryGetChildren(FStringBuilderBase& ReportedPathPrefix, TCHAR InPathSeparator, FStringView InRelPath, TArray<FString>& OutRelativeChildNames, EDirectoryTreeGetFlags Flags)"
  },
  {
    "label": "TryFindClosestPath()",
    "kind": "Method",
    "detail": "Function (ValueType*)",
    "insertText": "TryFindClosestPath(FStringView RelPath, FStringBuilderBase* OutPath, TCHAR SeparatorChar)"
  },
  {
    "label": "HasValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasValue()"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (ValueType&)",
    "insertText": "GetValue()"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValue(ValueType&& InValue)"
  },
  {
    "label": "SetDefaultValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDefaultValue()"
  },
  {
    "label": "RemoveValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveValue()"
  },
  {
    "label": "FixupDirectChildrenPathSeparator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FixupDirectChildrenPathSeparator(TCHAR OldSeparator, TCHAR NewSeparator)"
  },
  {
    "label": "FlagsShift()",
    "kind": "Method",
    "detail": "Function (private : const uint32 NumFlagBits = 1 ; const uint32)",
    "insertText": "FlagsShift(8 * sizeof(uint32) - NumFlagBits)"
  },
  {
    "label": "SetNumChildNodes()",
    "kind": "Method",
    "detail": "Function (const uint32 FlagsMask = 0 x1<<FlagsShift ; void)",
    "insertText": "SetNumChildNodes(int32 InNumChildNodes)"
  },
  {
    "label": "FindInsertionIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "FindInsertionIndex(FStringView FirstPathComponent, bool& bOutExists)"
  },
  {
    "label": "InsertChildNode()",
    "kind": "Method",
    "detail": "Function (FTreeNode&)",
    "insertText": "InsertChildNode(int32 InsertionIndex, FString&& RelPath, FTreeNode&& ChildNode)"
  },
  {
    "label": "RemoveChildNodeAt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveChildNodeAt(int32 RemoveIndex)"
  },
  {
    "label": "ConditionalCompactNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConditionalCompactNode(FString& RelPath, FTreeNode& ChildNode)"
  },
  {
    "label": "Realloc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Realloc(int32 NewCapacity)"
  },
  {
    "label": "NormalizePathForReading()",
    "kind": "Method",
    "detail": "Function (private : TTypeCompatibleBytes<ValueType> Value ; TUniquePtr<FString [ ]> RelPaths ; TUniquePtr<FTreeNode [ ]> ChildNodes ; uint32 NumChildNodesAndFlags = 0 ; int32 CapacityChildNodes = 0 ; } ; private : bool)",
    "insertText": "NormalizePathForReading(FStringView& Path, FStringBuilderBase& NormalizeBuffer)"
  },
  {
    "label": "NormalizePathForWriting()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "NormalizePathForWriting(FStringView& Path, FStringBuilderBase& NormalizeBuffer)"
  },
  {
    "label": "TryFindClosestPathInternal()",
    "kind": "Method",
    "detail": "Function (ValueType*)",
    "insertText": "TryFindClosestPathInternal(FStringView Path, FStringBuilderBase* OutPath)"
  },
  {
    "label": "InitializePathSeparator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializePathSeparator(TCHAR InPathSeparator)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} template<ValueType> ValueType& TDirectoryTree<ValueType)",
    "insertText": "FindOrAdd(FStringView Path, bool* bOutExisted)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!Root.HasValue())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!bPathSeparatorInitialized)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 UnusedIndex ;)",
    "insertText": "if(Path.FindChar('/', UnusedIndex))"
  },
  {
    "label": "InitializePathSeparator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializePathSeparator('/')"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Path.FindChar('\\\\', UnusedIndex))"
  },
  {
    "label": "InitializePathSeparator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializePathSeparator('\\\\')"
  },
  {
    "label": "NormalizePathForWriting()",
    "kind": "Method",
    "detail": "Function (} } TStringBuilder<1 6> NormalizeBuffer ;)",
    "insertText": "NormalizePathForWriting(Path, NormalizeBuffer)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (bool bExisted ; ValueType& Result = Root .)",
    "insertText": "FindOrAdd(Path, bExisted)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (NumPaths = 0 ; PathSeparator = ' / ' ; bPathSeparatorInitialized = false ; } template<ValueType> void TDirectoryTree<ValueType)",
    "insertText": "Remove(FStringView Path, bool* bOutExisted)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bExisted ;)",
    "insertText": "if(Path.IsEmpty())"
  },
  {
    "label": "NormalizePathForReading()",
    "kind": "Method",
    "detail": "Function (} } else { TStringBuilder<1 6> NormalizeBuffer ;)",
    "insertText": "NormalizePathForReading(Path, NormalizeBuffer)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (Root .)",
    "insertText": "Remove(Path, bExisted)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bExisted)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - NumPaths ; })",
    "insertText": "if(bOutExisted)"
  },
  {
    "label": "TryFindClosestPath()",
    "kind": "Method",
    "detail": "Function (} template<ValueType> bool TDirectoryTree<ValueType)",
    "insertText": "TryFindClosestPath(FStringView Path, FString& OutPath, const ValueType** OutValue)"
  },
  {
    "label": "TDirectoryTree()",
    "kind": "Method",
    "detail": "Function (ValueType* ResultValue ; bool bResult = const_cast<)",
    "insertText": "TDirectoryTree(this)->TryFindClosestPath(Path, OutPath, &ResultValue)"
  },
  {
    "label": "TryFindClosestPathInternal()",
    "kind": "Method",
    "detail": "Function (ValueType* Result =)",
    "insertText": "TryFindClosestPathInternal(Path, &Builder)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (OutPath .)",
    "insertText": "Append(Builder)"
  },
  {
    "label": "TryFindClosestPath()",
    "kind": "Method",
    "detail": "Function (* OutValue = Result ; } return true ; } else { return false ; } } template<ValueType> bool TDirectoryTree<ValueType)",
    "insertText": "TryFindClosestPath(FStringView Path, FStringBuilderBase& OutPath, const ValueType** OutValue)"
  },
  {
    "label": "TryFindClosestPathInternal()",
    "kind": "Method",
    "detail": "Function (ValueType* Result =)",
    "insertText": "TryFindClosestPathInternal(Path, &OutPath)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!Path.IsEmpty())"
  },
  {
    "label": "TryFindClosestPath()",
    "kind": "Method",
    "detail": "Function (ValueType* Result = Root .)",
    "insertText": "TryFindClosestPath(Path, OutPath, PathSeparator)"
  },
  {
    "label": "SplitVolumeSpecifier()",
    "kind": "Method",
    "detail": "Function (FStringView Volume ; FStringView Remainder ;)",
    "insertText": "SplitVolumeSpecifier(Path, Volume, Remainder)"
  },
  {
    "label": "ToView()",
    "kind": "Method",
    "detail": "Function (NormalizeBuffer<<Volume<<PathSeparator<<Remainder ; Path = NormalizeBuffer .)",
    "insertText": "ToView()"
  },
  {
    "label": "bNeedDriveWithoutPathFixup()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bNeedDriveWithoutPathFixup(InPathSeparator != PathSeparator)"
  },
  {
    "label": "FixupDirectChildrenPathSeparator()",
    "kind": "Method",
    "detail": "Function (Root .)",
    "insertText": "FixupDirectChildrenPathSeparator(PathSeparator, InPathSeparator)"
  },
  {
    "label": "TryGetChildren()",
    "kind": "Method",
    "detail": "Function (} template<ValueType> bool TDirectoryTree<ValueType)",
    "insertText": "TryGetChildren(FStringView Path, TArray<FString>& OutRelativeChildNames, EDirectoryTreeGetFlags Flags)"
  },
  {
    "label": "TryGetChildren()",
    "kind": "Method",
    "detail": "Function (TStringBuilder<1 0 2 4> ReportedPathPrefix ; return Root .)",
    "insertText": "TryGetChildren(ReportedPathPrefix, PathSeparator, Path, OutRelativeChildNames, Flags)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValue(CopyTemp(Other.GetValue()))"
  },
  {
    "label": "Realloc()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Realloc(Other.CapacityChildNodes)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (RelPaths [ i ] = Other . RelPaths [ i ] ; })",
    "insertText": "for(int32 i = 0; i < NumChildren; ++i)"
  },
  {
    "label": "SetNumChildNodes()",
    "kind": "Method",
    "detail": "Function (ChildNodes [ i ] = Other . ChildNodes [ i ] ; })",
    "insertText": "SetNumChildNodes(Other.GetNumChildNodes())"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "MoveTemp(Other)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValue(MoveTemp(Other.GetValue()))"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (} RelPaths =)",
    "insertText": "MoveTemp(Other.RelPaths)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (ChildNodes =)",
    "insertText": "MoveTemp(Other.ChildNodes)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (CapacityChildNodes =)",
    "insertText": "MoveTemp(Other.CapacityChildNodes)"
  },
  {
    "label": "SetNumChildNodes()",
    "kind": "Method",
    "detail": "Function (Other .)",
    "insertText": "SetNumChildNodes(0)"
  },
  {
    "label": "InNumChildNodes()",
    "kind": "Method",
    "detail": "Function (NumChildNodesAndFlags =)",
    "insertText": "InNumChildNodes(NumChildNodesAndFlags & FlagsMask)"
  },
  {
    "label": "NumChildNodesAndFlags()",
    "kind": "Method",
    "detail": "Function (uint32 FlagsValue = 0 x1 ;)",
    "insertText": "NumChildNodesAndFlags(NumChildNodesAndFlags & ~FlagsMask) | (FlagsValue << FlagsShift)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&Value) ValueType(MoveTemp(InValue))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&Value) ValueType()"
  },
  {
    "label": "FDirectoryTreeDestructValueType()",
    "kind": "Method",
    "detail": "Function (typedef ValueType)",
    "insertText": "FDirectoryTreeDestructValueType((ValueType*)&Value)->FDirectoryTreeDestructValueType::~FDirectoryTreeDestructValueType()"
  },
  {
    "label": "SplitFirstComponent()",
    "kind": "Method",
    "detail": "Function (FStringView FirstComponent ; FStringView RemainingPath ;)",
    "insertText": "SplitFirstComponent(InRelPath, FirstComponent, RemainingPath)"
  },
  {
    "label": "FindInsertionIndex()",
    "kind": "Method",
    "detail": "Function (bool bExists ; int32 InsertionIndex =)",
    "insertText": "FindInsertionIndex(FirstComponent, bExists)"
  },
  {
    "label": "InsertChildNode()",
    "kind": "Method",
    "detail": "Function (bOutExisted = false ; FTreeNode& ChildNode =)",
    "insertText": "InsertChildNode(InsertionIndex, FString(InRelPath), FTreeNode())"
  },
  {
    "label": "SplitFirstComponent()",
    "kind": "Method",
    "detail": "Function (} FTreeNode& ChildNode = ChildNodes [ InsertionIndex ] ; FString& ChildRelPath = RelPaths [ InsertionIndex ] ; FStringView ExistingFirstComponent ; FStringView ExistingRemainingPath ;)",
    "insertText": "SplitFirstComponent(ChildRelPath, ExistingFirstComponent, ExistingRemainingPath)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 NumFirstComponents = 1 ;)",
    "insertText": "for(int32 RunawayLoop = 0; RunawayLoop <= InRelPath.Len(); ++RunawayLoop)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(RemainingPath.IsEmpty())"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (bOutExisted = false ; FTreeNode OldTreeNode =)",
    "insertText": "MoveTemp(ChildNode)"
  },
  {
    "label": "OldRelPath()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "OldRelPath(ExistingRemainingPath)"
  },
  {
    "label": "InsertChildNode()",
    "kind": "Method",
    "detail": "Function (ChildRelPath = InRelPath ; ChildNode .)",
    "insertText": "InsertChildNode(0, MoveTemp(OldRelPath), MoveTemp(OldTreeNode))"
  },
  {
    "label": "SplitFirstComponent()",
    "kind": "Method",
    "detail": "Function (} else { FStringView NextFirstComponent ; FStringView NextRemainingPath ;)",
    "insertText": "SplitFirstComponent(RemainingPath, NextFirstComponent, NextRemainingPath)"
  },
  {
    "label": "SplitFirstComponent()",
    "kind": "Method",
    "detail": "Function (FStringView NextExistingFirstComponent ; FStringView NextExistingRemainingPath ;)",
    "insertText": "SplitFirstComponent(ExistingRemainingPath, NextExistingFirstComponent, NextExistingRemainingPath)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (RemainingPath = NextRemainingPath ; ExistingRemainingPath = NextExistingRemainingPath ; + + NumFirstComponents ; continue ; } else { TStringBuilder<1 0 2 4> CommonParentPath ; FStringView ParentRemaining = ChildRelPath ;)",
    "insertText": "for(int32 FirstComponentIndex = 0; FirstComponentIndex < NumFirstComponents; ++FirstComponentIndex)"
  },
  {
    "label": "SplitFirstComponent()",
    "kind": "Method",
    "detail": "Function (FStringView ParentFirstComponent ; FStringView NextParentRemaining ;)",
    "insertText": "SplitFirstComponent(ParentRemaining, ParentFirstComponent, NextParentRemaining)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(CommonParentPath, ParentFirstComponent)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "checkf(false, TEXT(\"Infinite loop trying to split path %.*s into components.\"), InRelPath.Len(), InRelPath.GetData())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bOutExisted = false ; return ; } FTreeNode& ChildNode = ChildNodes [ InsertionIndex ] ; FString& ChildRelPath = RelPaths [ InsertionIndex ] ;)",
    "insertText": "if(!FPathViews::TryMakeChildPathRelativeTo(InRelPath, ChildRelPath, RemainingPath))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bOutExisted = false ; return ; })",
    "insertText": "if(!RemainingPath.IsEmpty())"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (ChildNode .)",
    "insertText": "Remove(RemainingPath, bOutExisted)"
  },
  {
    "label": "ConditionalCompactNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConditionalCompactNode(ChildRelPath, ChildNode)"
  },
  {
    "label": "RemoveChildNodeAt()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "RemoveChildNodeAt(InsertionIndex)"
  },
  {
    "label": "HasValue()",
    "kind": "Method",
    "detail": "Function (} else { return ChildNode .)",
    "insertText": "HasValue() ? &ChildNode.GetValue()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FTreeNode& ChildNode = ChildNodes [ Index ] ; const FString& ChildRelPath = RelPaths [ Index ] ;)",
    "insertText": "if(EnumHasAnyFlags(Flags, EDirectoryTreeGetFlags::ImpliedChildren))"
  },
  {
    "label": "SplitFirstComponent()",
    "kind": "Method",
    "detail": "Function (FStringView FirstComponent ; FStringView RemainingPath ;)",
    "insertText": "SplitFirstComponent(ChildRelPath, FirstComponent, RemainingPath)"
  },
  {
    "label": "Len()",
    "kind": "Method",
    "detail": "Function (int32 SavedLen = ReportPathPrefix .)",
    "insertText": "Len()"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(ReportPathPrefix, FirstComponent)"
  },
  {
    "label": "FixupPathSeparator()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "FixupPathSeparator(ReportPathPrefix, SavedLen, InPathSeparator)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutRelativeChildNames .)",
    "insertText": "Add(*ReportPathPrefix)"
  },
  {
    "label": "SplitFirstComponent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SplitFirstComponent(RemainingPath, FirstComponent, RemainingPath)"
  },
  {
    "label": "FixupPathSeparator()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "FixupPathSeparator(ReportPathPrefix, SavedLenForSubPath, InPathSeparator)"
  },
  {
    "label": "RemoveSuffix()",
    "kind": "Method",
    "detail": "Function (} ReportPathPrefix .)",
    "insertText": "RemoveSuffix(ReportPathPrefix.Len() - SavedLen)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(ReportPathPrefix, ChildRelPath)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!ChildNode.HasValue() || EnumHasAnyFlags(Flags, EDirectoryTreeGetFlags::Recursive))"
  },
  {
    "label": "SplitFirstComponent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SplitFirstComponent(ExistingRemainingPath, ExistingFirstComponent, ExistingRemainingPath)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(ReportPathPrefix, ExistingFirstComponent)"
  },
  {
    "label": "FixupPathSeparator()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "FixupPathSeparator(ReportPathPrefix, SavedLenForSubPath , InPathSeparator)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(ChildNode.HasValue() || EnumHasAnyFlags(Flags, EDirectoryTreeGetFlags::Recursive))"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(ReportPathPrefix, ExistingRemainingPath)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(EnumHasAnyFlags(Flags, EDirectoryTreeGetFlags::Recursive))"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 SavedOutPathLen = INDEX_NONE ;)",
    "insertText": "if(OutPath)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(*OutPath, ChildRelPath)"
  },
  {
    "label": "FixupPathSeparator()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "FixupPathSeparator(*OutPath, SavedOutPathLen, InPathSeparator)"
  },
  {
    "label": "TryFindClosestPath()",
    "kind": "Method",
    "detail": "Function (} ValueType* Result = ChildNode .)",
    "insertText": "TryFindClosestPath(RemainingPath, OutPath, InPathSeparator)"
  },
  {
    "label": "RemoveSuffix()",
    "kind": "Method",
    "detail": "Function (OutPath ->)",
    "insertText": "RemoveSuffix(OutPath->Len() - SavedOutPathLen)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } else {)",
    "insertText": "if(!ChildNode.HasValue())"
  },
  {
    "label": "CapacityChildNodes()",
    "kind": "Method",
    "detail": "Function (SIZE_T Size = 0 ; Size =)",
    "insertText": "CapacityChildNodes(sizeof(FTreeNode) + sizeof(FString))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(const FTreeNode& ChildNode : TConstArrayView<FTreeNode>(ChildNodes.Get(), NumChildNodes))"
  },
  {
    "label": "Realloc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Realloc(NumChildNodes)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(FTreeNode& ChildNode : TArrayView<FTreeNode>(ChildNodes.Get(), NumChildNodes))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 NewCapacity ;)",
    "insertText": "if(CapacityChildNodes == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NewCapacity = 1 ; } else)",
    "insertText": "if(CapacityChildNodes < 8)"
  },
  {
    "label": "NewCapacity()",
    "kind": "Method",
    "detail": "Function (NewCapacity = CapacityChildNodes* 2 ; } else {)",
    "insertText": "NewCapacity(CapacityChildNodes * 3)"
  },
  {
    "label": "Realloc()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Realloc(NewCapacity)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 ShiftIndex = NumChildNodes; ShiftIndex > InsertionIndex; --ShiftIndex)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (RelPaths [ ShiftIndex ] =)",
    "insertText": "MoveTemp(RelPaths[ShiftIndex - 1])"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (ChildNodes [ ShiftIndex ] =)",
    "insertText": "MoveTemp(ChildNodes[ShiftIndex - 1])"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (} RelPaths [ InsertionIndex ] =)",
    "insertText": "MoveTemp(RelPath)"
  },
  {
    "label": "SetNumChildNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNumChildNodes(NumChildNodes + 1)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (RelPaths [ ShiftIndex ] =)",
    "insertText": "MoveTemp(RelPaths[ShiftIndex + 1])"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (ChildNodes [ ShiftIndex ] =)",
    "insertText": "MoveTemp(ChildNodes[ShiftIndex + 1])"
  },
  {
    "label": "SetNumChildNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNumChildNodes(NumChildNodes - 1)"
  },
  {
    "label": "AppendPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendPath(NewRelPath, ChildNode.RelPaths[0])"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (RelPath = NewRelPath ; FTreeNode OldGrandChild =)",
    "insertText": "MoveTemp(ChildNode.ChildNodes[0])"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (ChildNode =)",
    "insertText": "MoveTemp(OldGrandChild)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FString* NewRelPaths = new FString [ NewCapacity ] ; FTreeNode* NewChildNodes = new FTreeNode [ NewCapacity ] ;)",
    "insertText": "for(int32 Index = 0; Index < NumChildNodes; ++Index)"
  },
  {
    "label": "CA_ASSUME()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CA_ASSUME(Index < NewCapacity)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (NewRelPaths [ Index ] =)",
    "insertText": "MoveTemp(RelPaths[Index])"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (NewChildNodes [ Index ] =)",
    "insertText": "MoveTemp(ChildNodes[Index])"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} ChildNodes .)",
    "insertText": "Reset(NewChildNodes)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (RelPaths .)",
    "insertText": "Reset(NewRelPaths)"
  },
  {
    "label": "ReplaceCharInline()",
    "kind": "Method",
    "detail": "Function (RelPaths [ Index ] .)",
    "insertText": "ReplaceCharInline(OldSeparator, NewSeparator)"
  }
]