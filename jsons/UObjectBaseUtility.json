[
  {
    "label": "UClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UClass"
  },
  {
    "label": "UObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UObject"
  },
  {
    "label": "UPackage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPackage"
  },
  {
    "label": "FGuid",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGuid"
  },
  {
    "label": "UObjectBaseUtility",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UObjectBaseUtility"
  },
  {
    "label": "FInternalUObjectBaseUtilityIsValidFlagsChecker",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FInternalUObjectBaseUtilityIsValidFlagsChecker"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "FLinkerLoad",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLinkerLoad"
  },
  {
    "label": "FConfigModificationTracker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConfigModificationTracker"
  },
  {
    "label": "FScopeCycleCounterUObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FScopeCycleCounterUObject"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / StringFwd . h \" # include \" Containers / UnrealString . h \" # include \" Containers / VersePathFwd . h \" # include \" HAL / PlatformMath . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / EnumClassFlags . h \" # include \" ProfilingDebugging / CpuProfilerTrace . h \" # include \" Stats / Stats . h \" # include \" Stats / Stats2 . h \" # include \" Stats / StatsCommon . h \" # include \" Trace / Detail / Channel . h \" # include \" Trace / Detail / Channel . inl \" # include \" Trace / Trace . h \" # include \" UObject / GarbageCollectionGlobals . h \" # include \" UObject / NameTypes . h \" # include \" UObject / ObjectVersion . h \" # include \" UObject / UObjectArray . h \" # include \" UObject / UObjectBase . h \" # include \" UObject / UObjectMarks . h \" # include \" UObject / ObjectFwd . h \" # include \" AutoRTFM / AutoRTFM . h \" class UClass ; class UObject ; class UPackage ; struct FGuid ; # if)",
    "insertText": "defined(_MSC_VER)"
  },
  {
    "label": "InitGarbageElimination()",
    "kind": "Method",
    "detail": "Function (bool bGarbageEliminationEnabled ; void)",
    "insertText": "InitGarbageElimination()"
  },
  {
    "label": "UObjectBaseUtility()",
    "kind": "Method",
    "detail": "Function (struct FInternalUObjectBaseUtilityIsValidFlagsChecker ; public :)",
    "insertText": "UObjectBaseUtility()"
  },
  {
    "label": "UObjectBaseUtility()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UObjectBaseUtility(EObjectFlags InFlags ) : UObjectBase(InFlags)"
  },
  {
    "label": "SetFlags()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetFlags(EObjectFlags NewFlags)"
  },
  {
    "label": "AtomicallySetFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AtomicallySetFlags(NewFlags)"
  },
  {
    "label": "ClearFlags()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearFlags(EObjectFlags FlagsToClear)"
  },
  {
    "label": "AtomicallyClearFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AtomicallyClearFlags(FlagsToClear)"
  },
  {
    "label": "HasAnyFlags()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasAnyFlags(EObjectFlags FlagsToCheck)"
  },
  {
    "label": "HasAllFlags()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasAllFlags(EObjectFlags FlagsToCheck)"
  },
  {
    "label": "GetMaskedFlags()",
    "kind": "Method",
    "detail": "Function (} EObjectFlags)",
    "insertText": "GetMaskedFlags(EObjectFlags Mask = RF_AllFlags)"
  },
  {
    "label": "Mark()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Mark(EObjectMark Marks)"
  },
  {
    "label": "MarkObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MarkObject(this,Marks)"
  },
  {
    "label": "UnMark()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UnMark(EObjectMark Marks)"
  },
  {
    "label": "UnMarkObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnMarkObject(this,Marks)"
  },
  {
    "label": "HasAnyMarks()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasAnyMarks(EObjectMark Marks)"
  },
  {
    "label": "HasAllMarks()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasAllMarks(EObjectMark Marks)"
  },
  {
    "label": "GetAllMarks()",
    "kind": "Method",
    "detail": "Function (} EObjectMark)",
    "insertText": "GetAllMarks()"
  },
  {
    "label": "MarkAsGarbage()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MarkAsGarbage()"
  },
  {
    "label": "UE_AUTORTFM_ONCOMMIT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_AUTORTFM_ONCOMMIT(this)"
  },
  {
    "label": "AtomicallySetFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AtomicallySetFlags(RF_MirroredGarbage)"
  },
  {
    "label": "IndexToObject()",
    "kind": "Method",
    "detail": "Function (GUObjectArray .)",
    "insertText": "IndexToObject(InternalIndex)->SetGarbage()"
  },
  {
    "label": "ClearGarbage()",
    "kind": "Method",
    "detail": "Function (} ; } void)",
    "insertText": "ClearGarbage()"
  },
  {
    "label": "AtomicallyClearFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AtomicallyClearFlags(RF_MirroredGarbage)"
  },
  {
    "label": "IndexToObject()",
    "kind": "Method",
    "detail": "Function (GUObjectArray .)",
    "insertText": "IndexToObject(InternalIndex)->ClearGarbage()"
  },
  {
    "label": "AddToRoot()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddToRoot()"
  },
  {
    "label": "IndexToObject()",
    "kind": "Method",
    "detail": "Function (GUObjectArray .)",
    "insertText": "IndexToObject(InternalIndex)->SetRootSet()"
  },
  {
    "label": "RemoveFromRoot()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveFromRoot()"
  },
  {
    "label": "IndexToObject()",
    "kind": "Method",
    "detail": "Function (GUObjectArray .)",
    "insertText": "IndexToObject(InternalIndex)->ClearRootSet()"
  },
  {
    "label": "IsRooted()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsRooted()"
  },
  {
    "label": "IsNative()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsNative()"
  },
  {
    "label": "SetInternalFlags()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetInternalFlags(EInternalObjectFlags FlagsToSet)"
  },
  {
    "label": "IndexToObject()",
    "kind": "Method",
    "detail": "Function (FUObjectItem* ObjectItem = GUObjectArray .)",
    "insertText": "IndexToObject(InternalIndex)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (PRAGMA_DISABLE_DEPRECATION_WARNINGS)",
    "insertText": "checkf(!(FlagsToSet & EInternalObjectFlags::Garbage) || (FlagsToSet & EInternalObjectFlags::Garbage) == (ObjectItem->GetFlags() & EInternalObjectFlags::Garbage), TEXT(\"SetInternalFlags should not set the Garbage flag. Use MarkAsGarbage instead\"))"
  },
  {
    "label": "SetFlags()",
    "kind": "Method",
    "detail": "Function (PRAGMA_ENABLE_DEPRECATION_WARNINGS ObjectItem ->)",
    "insertText": "SetFlags(FlagsToSet)"
  },
  {
    "label": "GetInternalFlags()",
    "kind": "Method",
    "detail": "Function (} EInternalObjectFlags)",
    "insertText": "GetInternalFlags()"
  },
  {
    "label": "HasAnyInternalFlags()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasAnyInternalFlags(EInternalObjectFlags FlagsToCheck)"
  },
  {
    "label": "ClearInternalFlags()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearInternalFlags(EInternalObjectFlags FlagsToClear)"
  },
  {
    "label": "ClearFlags()",
    "kind": "Method",
    "detail": "Function (ObjectItem ->)",
    "insertText": "ClearFlags(FlagsToClear)"
  },
  {
    "label": "AtomicallyClearInternalFlags()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "AtomicallyClearInternalFlags(EInternalObjectFlags FlagsToClear)"
  },
  {
    "label": "GetFullName()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "GetFullName(const UObject* StopOuter=NULL, EObjectFullNameFlags Flags = EObjectFullNameFlags::None)"
  },
  {
    "label": "GetFullName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetFullName(const UObject* StopOuter, FString& ResultString, EObjectFullNameFlags Flags = EObjectFullNameFlags::None)"
  },
  {
    "label": "GetFullName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetFullName(FStringBuilderBase& ResultString, const UObject* StopOuter = NULL, EObjectFullNameFlags Flags = EObjectFullNameFlags::None)"
  },
  {
    "label": "GetPathName()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "GetPathName(const UObject* StopOuter=NULL)"
  },
  {
    "label": "GetPathName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPathName(const UObject* StopOuter, FString& ResultString)"
  },
  {
    "label": "GetPathName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPathName(const UObject* StopOuter, FStringBuilderBase& ResultString)"
  },
  {
    "label": "IsGarbageEliminationEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsGarbageEliminationEnabled()"
  },
  {
    "label": "SetGarbageEliminationEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetGarbageEliminationEnabled(bool bEnabled)"
  },
  {
    "label": "CanBeClusterRoot()",
    "kind": "Method",
    "detail": "Function (bGarbageEliminationEnabled = bEnabled ; } public : bool)",
    "insertText": "CanBeClusterRoot()"
  },
  {
    "label": "CreateCluster()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateCluster()"
  },
  {
    "label": "OnClusterMarkedAsPendingKill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnClusterMarkedAsPendingKill()"
  },
  {
    "label": "AddToCluster()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddToCluster(UObjectBaseUtility* ClusterRootOrObjectFromCluster, bool bAddAsMutableObject = false)"
  },
  {
    "label": "GetFullGroupName()",
    "kind": "Method",
    "detail": "Function (public : FString)",
    "insertText": "GetFullGroupName(bool bStartWithOuter)"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetName(FString &ResultString)"
  },
  {
    "label": "GetFName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetFName().ToString(ResultString)"
  },
  {
    "label": "AppendName()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendName(FString& ResultString)"
  },
  {
    "label": "GetFName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetFName().AppendString(ResultString)"
  },
  {
    "label": "IsPackageExternal()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsPackageExternal()"
  },
  {
    "label": "DetachExternalPackage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DetachExternalPackage()"
  },
  {
    "label": "ReattachExternalPackage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReattachExternalPackage()"
  },
  {
    "label": "GetOutermostObject()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "GetOutermostObject()"
  },
  {
    "label": "GetPackage()",
    "kind": "Method",
    "detail": "Function (UPackage*)",
    "insertText": "GetPackage()"
  },
  {
    "label": "GetVersePath()",
    "kind": "Method",
    "detail": "Function (UE::Core::FVersePath)",
    "insertText": "GetVersePath()"
  },
  {
    "label": "GetOutermost()",
    "kind": "Method",
    "detail": "Function (UPackage*)",
    "insertText": "GetOutermost()"
  },
  {
    "label": "MarkPackageDirty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MarkPackageDirty()"
  },
  {
    "label": "IsTemplate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsTemplate(EObjectFlags TemplateTypes = RF_ArchetypeObject|RF_ClassDefaultObject)"
  },
  {
    "label": "GetTypedOuter()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "GetTypedOuter(UClass* Target)"
  },
  {
    "label": "GetTypedOuter()",
    "kind": "Method",
    "detail": "Function (template<T> T*)",
    "insertText": "GetTypedOuter()"
  },
  {
    "label": "GetImplementingOuter()",
    "kind": "Method",
    "detail": "Function (} template<InterfaceClassType> InterfaceClassType*)",
    "insertText": "GetImplementingOuter()"
  },
  {
    "label": "StaticClass()",
    "kind": "Method",
    "detail": "Function (UClass* InterfaceClass = InterfaceClassType::)",
    "insertText": "StaticClass()"
  },
  {
    "label": "GetImplementingOuterObject()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } UObjectBaseUtility*)",
    "insertText": "GetImplementingOuterObject(const UClass* InInterfaceClass)"
  },
  {
    "label": "IsIn()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsIn(const UObject* SomeOuter)"
  },
  {
    "label": "IsIn()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsIn(const UPackage* SomePackage)"
  },
  {
    "label": "IsInOuter()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsInOuter(const UObject* SomeOuter)"
  },
  {
    "label": "IsInPackage()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsInPackage(const UPackage* SomePackage)"
  },
  {
    "label": "IsInA()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsInA(const UClass* SomeBaseClass)"
  },
  {
    "label": "RootPackageHasAnyFlags()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RootPackageHasAnyFlags(uint32 CheckFlagMask)"
  },
  {
    "label": "IsChildOfWorkaround()",
    "kind": "Method",
    "detail": "Function (private : template<ClassType> bool)",
    "insertText": "IsChildOfWorkaround(const ClassType* ObjClass, const ClassType* TestCls)"
  },
  {
    "label": "IsA()",
    "kind": "Method",
    "detail": "Function (} public : template<OtherClassType> bool)",
    "insertText": "IsA(OtherClassType SomeBase)"
  },
  {
    "label": "SomeBase()",
    "kind": "Method",
    "detail": "Function (const UClass* SomeBaseClass =)",
    "insertText": "SomeBase(void)"
  },
  {
    "label": "GetClass()",
    "kind": "Method",
    "detail": "Function (const UClass* ThisClass =)",
    "insertText": "GetClass()"
  },
  {
    "label": "UE_ASSUME()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_ASSUME(SomeBaseClass)"
  },
  {
    "label": "UE_ASSUME()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_ASSUME(ThisClass)"
  },
  {
    "label": "IsA()",
    "kind": "Method",
    "detail": "Function (} template<class T> bool)",
    "insertText": "IsA()"
  },
  {
    "label": "FindNearestCommonBaseClass()",
    "kind": "Method",
    "detail": "Function (} const UClass*)",
    "insertText": "FindNearestCommonBaseClass(const UClass* TestClass)"
  },
  {
    "label": "GetInterfaceAddress()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "GetInterfaceAddress(UClass* InterfaceClass)"
  },
  {
    "label": "GetNativeInterfaceAddress()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "GetNativeInterfaceAddress(UClass* InterfaceClass)"
  },
  {
    "label": "IsTemplateForSubobjects()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsTemplateForSubobjects(EObjectFlags TemplateTypes = RF_ClassDefaultObject|RF_DefaultSubObject|RF_InheritableComponentTemplate)"
  },
  {
    "label": "IsDefaultSubobject()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsDefaultSubobject()"
  },
  {
    "label": "GetLinker()",
    "kind": "Method",
    "detail": "Function (class FLinkerLoad*)",
    "insertText": "GetLinker()"
  },
  {
    "label": "GetLinkerIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetLinkerIndex()"
  },
  {
    "label": "GetLinkerUEVersion()",
    "kind": "Method",
    "detail": "Function (FPackageFileVersion)",
    "insertText": "GetLinkerUEVersion()"
  },
  {
    "label": "GetLinkerLicenseeUEVersion()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetLinkerLicenseeUEVersion()"
  },
  {
    "label": "GetLinkerCustomVersion()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetLinkerCustomVersion(FGuid CustomVersionKey)"
  },
  {
    "label": "ResetStatID()",
    "kind": "Method",
    "detail": "Function (} # if STATS | | ENABLE_STATNAMEDEVENTS_UOBJECT void)",
    "insertText": "ResetStatID()"
  },
  {
    "label": "IndexToObject()",
    "kind": "Method",
    "detail": "Function (GUObjectArray .)",
    "insertText": "IndexToObject(InternalIndex)->StatID = TStatId()"
  },
  {
    "label": "GetStatID()",
    "kind": "Method",
    "detail": "Function (# endif } # endif TStatId)",
    "insertText": "GetStatID(bool bForDeferredUse = false)"
  },
  {
    "label": "Open()",
    "kind": "Method",
    "detail": "Function (TStatId Result { } ;)",
    "insertText": "Open([&] { #if STATS const TStatId& StatID = GUObjectArray.IndexToObject(InternalIndex)->StatID; if (bForDeferredUse || FThreadStats::IsCollectingData(GET_STATID(STAT_UObjectsStatGroupTester))) { if (!StatID.IsValidStat()) { CreateStatID(); } Result = StatID; } else { Result = TStatId(); } #elif ENABLE_STATNAMEDEVENTS_UOBJECT const TStatId& StatID = GUObjectArray.IndexToObject(InternalIndex)->StatID; if (!StatID.IsValidStat() && (bForDeferredUse || GCycleStatsShouldEmitNamedEvents)) { CreateStatID(); } Result = StatID; #else Result = TStatId(); #endif })"
  },
  {
    "label": "IndexToObject()",
    "kind": "Method",
    "detail": "Function (GUObjectArray .)",
    "insertText": "IndexToObject(InternalIndex)->CreateStatID()"
  },
  {
    "label": "ReloadObjectsFromModifiedConfigSections()",
    "kind": "Method",
    "detail": "Function (} # endif public : void)",
    "insertText": "ReloadObjectsFromModifiedConfigSections(const class FConfigModificationTracker* ChangeTracker)"
  },
  {
    "label": "IsPossiblyAllocatedUObjectPointer()",
    "kind": "Method",
    "detail": "Function (} ; bool)",
    "insertText": "IsPossiblyAllocatedUObjectPointer(UObject* Ptr)"
  },
  {
    "label": "CountByteValues()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "CountByteValues(UPTRINT Val, UPTRINT ByteVal)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 Result = 0 ;)",
    "insertText": "for(int32 I = 0; I < sizeof(UPTRINT); ++I)"
  },
  {
    "label": "PtrVal()",
    "kind": "Method",
    "detail": "Function (+ + Result ; } Val>> = 8 ; } return Result ; } ; UPTRINT)",
    "insertText": "PtrVal(UPTRINT)"
  },
  {
    "label": "GetFNameSafe()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "GetFNameSafe(const UObjectBaseUtility* Object)"
  },
  {
    "label": "GetNameSafe()",
    "kind": "Method",
    "detail": "Function (} } FString)",
    "insertText": "GetNameSafe(const UObjectBaseUtility* Object)"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (} else { return Object ->)",
    "insertText": "GetName()"
  },
  {
    "label": "GetPathNameSafe()",
    "kind": "Method",
    "detail": "Function (} } FString)",
    "insertText": "GetPathNameSafe(const UObjectBaseUtility* Object)"
  },
  {
    "label": "GetPathName()",
    "kind": "Method",
    "detail": "Function (} else { return Object ->)",
    "insertText": "GetPathName()"
  },
  {
    "label": "GetFullNameSafe()",
    "kind": "Method",
    "detail": "Function (} } FString)",
    "insertText": "GetFullNameSafe(const UObjectBaseUtility* Object)"
  },
  {
    "label": "GetFullName()",
    "kind": "Method",
    "detail": "Function (} else { return Object ->)",
    "insertText": "GetFullName()"
  },
  {
    "label": "GetParentNativeClass()",
    "kind": "Method",
    "detail": "Function (} } UClass*)",
    "insertText": "GetParentNativeClass(UClass* Class)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(USE_LIGHTWEIGHT_UOBJECT_STATS_FOR_HITCH_DETECTION) #define USE_LIGHTWEIGHT_UOBJECT_STATS_FOR_HITCH_DETECTION (1) #endif #if CPUPROFILERTRACE_ENABLED COREUOBJECT_API FName GetClassTraceScope(const UObjectBaseUtility* Object)"
  },
  {
    "label": "FScopeCycleCounterUObject()",
    "kind": "Method",
    "detail": "Function (# endif # if STATS class FScopeCycleCounterUObject : public FCycleCounter { public : FORCEINLINE_STATS)",
    "insertText": "FScopeCycleCounterUObject(const UObjectBaseUtility *Object)"
  },
  {
    "label": "Open()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Open([&] { if (Object) { bool bStarted = false; TStatId ObjectStatId = Object->GetStatID(); if (FThreadStats::IsCollectingData(ObjectStatId)) { Start(ObjectStatId); bStarted = true; } #if CPUPROFILERTRACE_ENABLED if (!bStarted && UE_TRACE_CHANNELEXPR_IS_ENABLED(CpuChannel)) { StartObjectTrace(Object); } #endif } })"
  },
  {
    "label": "PushOnAbortHandler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PushOnAbortHandler(this, [this](){ this->Stop(); })"
  },
  {
    "label": "FScopeCycleCounterUObject()",
    "kind": "Method",
    "detail": "Function (} FORCEINLINE_STATS)",
    "insertText": "FScopeCycleCounterUObject(const UObjectBaseUtility *Object, TStatId OtherStat)"
  },
  {
    "label": "Open()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Open([&] { if (Object) { bool bStarted = false; if (FThreadStats::IsCollectingData(OtherStat)) { TStatId ObjectStatId = Object->GetStatID(); if (!ObjectStatId.IsNone()) { Start(ObjectStatId); bStarted = true; } } #if CPUPROFILERTRACE_ENABLED if (!bStarted && UE_TRACE_CHANNELEXPR_IS_ENABLED(CpuChannel)) { StartObjectTrace(Object); } #endif } })"
  },
  {
    "label": "StartObjectTrace()",
    "kind": "Method",
    "detail": "Function (} # if CPUPROFILERTRACE_ENABLED void)",
    "insertText": "StartObjectTrace(const UObjectBaseUtility* Object)"
  },
  {
    "label": "FScopeCycleCounterUObject()",
    "kind": "Method",
    "detail": "Function (# endif FORCEINLINE_STATS ~)",
    "insertText": "FScopeCycleCounterUObject()"
  },
  {
    "label": "PopOnAbortHandler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopOnAbortHandler(this)"
  },
  {
    "label": "Open()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Open([&] { Stop(); })"
  },
  {
    "label": "SCOPE_CYCLE_UOBJECT()",
    "kind": "Method",
    "detail": "Function (} } ; # define)",
    "insertText": "SCOPE_CYCLE_UOBJECT(Name, Object) \\ FScopeCycleCounterUObject ObjCycleCount_##Name(Object)"
  },
  {
    "label": "FScopeCycleCounterUObject()",
    "kind": "Method",
    "detail": "Function (# elif ENABLE_STATNAMEDEVENTS class FScopeCycleCounterUObject { public : FScopeCycleCounter ScopeCycleCounter ; # if ENABLE_STATNAMEDEVENTS_UOBJECT&& CPUPROFILERTRACE_ENABLED bool bPop ; # endif FORCEINLINE_STATS)",
    "insertText": "FScopeCycleCounterUObject(const UObjectBaseUtility *Object) : ScopeCycleCounter(Object ? Object->GetStatID().StatString : nullptr) #if ENABLE_STATNAMEDEVENTS_UOBJECT && CPUPROFILERTRACE_ENABLED , bPop(false)"
  },
  {
    "label": "Open()",
    "kind": "Method",
    "detail": "Function (# if ENABLE_STATNAMEDEVENTS_UOBJECT&& CPUPROFILERTRACE_ENABLED)",
    "insertText": "Open([&] { if (GCycleStatsShouldEmitNamedEvents && UE_TRACE_CHANNELEXPR_IS_ENABLED(CpuChannel) && Object) { const TStatId ObjectStatId = Object->GetStatID(); if (ObjectStatId.IsValidStat()) { bPop = true; FCpuProfilerTrace::OutputBeginDynamicEvent(ObjectStatId.StatString); } } })"
  },
  {
    "label": "PushOnAbortHandler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PushOnAbortHandler(this, [](){ FCpuProfilerTrace::OutputEndEvent(); })"
  },
  {
    "label": "FScopeCycleCounterUObject()",
    "kind": "Method",
    "detail": "Function (} # endif } FORCEINLINE_STATS)",
    "insertText": "FScopeCycleCounterUObject(const UObjectBaseUtility *Object, TStatId OtherStat) : FScopeCycleCounterUObject(Object)"
  },
  {
    "label": "Open()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Open([&] { if (bPop) { FCpuProfilerTrace::OutputEndEvent(); } })"
  },
  {
    "label": "TSAN_ATOMIC()",
    "kind": "Method",
    "detail": "Function (# elif USE_LIGHTWEIGHT_STATS_FOR_HITCH_DETECTION&& USE_HITCH_DETECTION&& USE_LIGHTWEIGHT_UOBJECT_STATS_FOR_HITCH_DETECTION)",
    "insertText": "TSAN_ATOMIC(bool)"
  },
  {
    "label": "FScopeCycleCounterUObject()",
    "kind": "Method",
    "detail": "Function (class FScopeCycleCounterUObject { const UObject* StatObject ; public :)",
    "insertText": "FScopeCycleCounterUObject(const UObject* InStatObject, TStatId OtherStat = TStatId())"
  },
  {
    "label": "Open()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Open([&] { ReportHitch(); })"
  },
  {
    "label": "ReportHitch()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ReportHitch()"
  }
]