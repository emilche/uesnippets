[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FSaveContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSaveContext"
  },
  {
    "label": "UObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UObject"
  },
  {
    "label": "FWeakObjectPtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FWeakObjectPtr"
  },
  {
    "label": "FLazyObjectPtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLazyObjectPtr"
  },
  {
    "label": "FSoftObjectPath",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSoftObjectPath"
  },
  {
    "label": "FPackageHarvester",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPackageHarvester"
  },
  {
    "label": "FExportWithContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FExportWithContext"
  },
  {
    "label": "FHarvestScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FHarvestScope"
  },
  {
    "label": "FExportDependencies",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FExportDependencies"
  },
  {
    "label": "FExportScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExportScope"
  },
  {
    "label": "FIgnoreDependenciesScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FIgnoreDependenciesScope"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Map . h \" # include \" Containers / Set . h \" # include \" Containers / Queue . h \" # include \" Serialization / ArchiveUObject . h \" # include \" UObject / NameTypes . h \" # include \" UObject / ObjectPtr . h \" enum class ESaveableStatus ; enum class ESaveRealm : uint32 ; enum class EIllegalRefReason : uint8 ; class FSaveContext ; class UObject ; struct FWeakObjectPtr ; struct FLazyObjectPtr ; struct FSoftObjectPath ; class FPackageHarvester : public FArchiveUObject { public : using FExportingRealmsArray = TArray<ESaveRealm,TInlineAllocator<2>> ; struct FExportWithContext { UObject* Export = nullptr ; FExportingRealmsArray HarvestedFromRealms ; operator)",
    "insertText": "bool()"
  },
  {
    "label": "FHarvestScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FHarvestScope(FHarvestScope&& Other)"
  },
  {
    "label": "FHarvestScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FHarvestScope(const FHarvestScope& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FHarvestScope&)",
    "insertText": "operator(FHarvestScope&& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FHarvestScope&)",
    "insertText": "operator(const FHarvestScope& Other)"
  },
  {
    "label": "FHarvestScope()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FHarvestScope()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "FPackageHarvester()",
    "kind": "Method",
    "detail": "Function (private : FPackageHarvester& Harvester ; FExportingRealmsArray PreviousExportHarvestingRealms ; bool bActive ; } ; public :)",
    "insertText": "FPackageHarvester(FSaveContext& InContext)"
  },
  {
    "label": "PopExportToProcess()",
    "kind": "Method",
    "detail": "Function (FExportWithContext)",
    "insertText": "PopExportToProcess()"
  },
  {
    "label": "TryHarvestExport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TryHarvestExport(UObject* InObject)"
  },
  {
    "label": "ProcessExport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessExport(const FExportWithContext& InProcessContext)"
  },
  {
    "label": "EnterRootReferencesScope()",
    "kind": "Method",
    "detail": "Function (FHarvestScope)",
    "insertText": "EnterRootReferencesScope()"
  },
  {
    "label": "HarvestExportDataName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HarvestExportDataName(FName Name)"
  },
  {
    "label": "HarvestPackageHeaderName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HarvestPackageHeaderName(FName Name)"
  },
  {
    "label": "HarvestSearchableName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HarvestSearchableName(TObjectPtr<UObject> TypeObject, FName Name)"
  },
  {
    "label": "HarvestDependency()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HarvestDependency(TObjectPtr<UObject> InObj, bool bIsNative)"
  },
  {
    "label": "CurrentExportHasDependency()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CurrentExportHasDependency(TObjectPtr<UObject> InObj, ESaveRealm HarvestingRealm)"
  },
  {
    "label": "ReleaseTransientPropertyOverrides()",
    "kind": "Method",
    "detail": "Function (TMap<UObject*,TSet<FProperty*>>)",
    "insertText": "ReleaseTransientPropertyOverrides()"
  },
  {
    "label": "GetArchiveName()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "GetArchiveName()"
  },
  {
    "label": "MarkSearchableName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MarkSearchableName(const TObjectPtr<const UObject>& TypeObject, const FName& ValueName)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(UObject*& Obj)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(struct FWeakObjectPtr& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(FLazyObjectPtr& LazyObjectPtr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(FSoftObjectPath& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(FName& Name)"
  },
  {
    "label": "ShouldSkipProperty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldSkipProperty(const FProperty* InProperty)"
  },
  {
    "label": "IsObjNative()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsObjNative(TObjectPtr<UObject> InObj)"
  },
  {
    "label": "ShouldObjectBeHarvestedInOptionalRealm()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldObjectBeHarvestedInOptionalRealm(TObjectPtr<UObject> InObj, FSaveContext& InSaveContext)"
  },
  {
    "label": "FExportScope()",
    "kind": "Method",
    "detail": "Function (private : struct FExportDependencies { UObject* CurrentExport = nullptr ; TSet<TObjectPtr<UObject>> ObjectReferences ; TSet<TObjectPtr<UObject>> NativeObjectReferences ; int32 ProcessImportDepth = 0 ; bool bIgnoreDependencies = false ; } ; class FExportScope { public :)",
    "insertText": "FExportScope(FPackageHarvester& InHarvester, const FExportWithContext& InToProcess)"
  },
  {
    "label": "FExportScope()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FExportScope()"
  },
  {
    "label": "FIgnoreDependenciesScope()",
    "kind": "Method",
    "detail": "Function (private : FPackageHarvester& Harvester ; FExportingRealmsArray PreviousExportHarvestingRealms ; bool bPreviousFilterEditorOnly ; } ; class FIgnoreDependenciesScope { public :)",
    "insertText": "FIgnoreDependenciesScope(FPackageHarvester& InHarvester)"
  },
  {
    "label": "FIgnoreDependenciesScope()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FIgnoreDependenciesScope()"
  },
  {
    "label": "ForEachExportHarvestingRealm()",
    "kind": "Method",
    "detail": "Function (private : FPackageHarvester& Harvester ; bool bPreviousValue ; } ; private : template<CallbackType> void)",
    "insertText": "ForEachExportHarvestingRealm(CallbackType&& Callback)"
  },
  {
    "label": "HasAnyExportHarvestingRealms()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasAnyExportHarvestingRealms()"
  },
  {
    "label": "ResolveOverrides()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResolveOverrides()"
  },
  {
    "label": "TryHarvestExportInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TryHarvestExportInternal(UObject* InObject)"
  },
  {
    "label": "HarvestExport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HarvestExport(UObject* InObject)"
  },
  {
    "label": "TryHarvestImport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TryHarvestImport(TObjectPtr<UObject> InObject)"
  },
  {
    "label": "HarvestImport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HarvestImport(TObjectPtr<UObject> InObject)"
  },
  {
    "label": "ProcessImport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessImport(TObjectPtr<UObject> InObject)"
  },
  {
    "label": "AppendCurrentExportDependencies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendCurrentExportDependencies()"
  },
  {
    "label": "GetUnsaveableReason()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "GetUnsaveableReason(UObject* Required, ESaveRealm RealmInWhichItIsUnsaveable)"
  },
  {
    "label": "GetSaveableStatusForRealm()",
    "kind": "Method",
    "detail": "Function (ESaveableStatus)",
    "insertText": "GetSaveableStatusForRealm(UObject* Obj, ESaveRealm RealmInWhichItIsUnsaveable, TObjectPtr<UObject>& OutCulprit, FString& OutReason)"
  },
  {
    "label": "EnterRealmsArrayScope()",
    "kind": "Method",
    "detail": "Function (FHarvestScope)",
    "insertText": "EnterRealmsArrayScope(FExportingRealmsArray& Array)"
  },
  {
    "label": "EnterConditionalEditorOnlyScope()",
    "kind": "Method",
    "detail": "Function (FHarvestScope)",
    "insertText": "EnterConditionalEditorOnlyScope(bool bIsEditorOnly)"
  },
  {
    "label": "EnterConditionalOptionalObjectScope()",
    "kind": "Method",
    "detail": "Function (FHarvestScope)",
    "insertText": "EnterConditionalOptionalObjectScope(TObjectPtr<UObject> Object)"
  },
  {
    "label": "EnterNewExportOnlyScope()",
    "kind": "Method",
    "detail": "Function (FHarvestScope)",
    "insertText": "EnterNewExportOnlyScope(UObject* Export)"
  },
  {
    "label": "EnterNotExcludedScope()",
    "kind": "Method",
    "detail": "Function (FHarvestScope)",
    "insertText": "EnterNotExcludedScope(TObjectPtr<UObject> Object)"
  },
  {
    "label": "EnterNotPreviouslyExcludedScope()",
    "kind": "Method",
    "detail": "Function (FHarvestScope)",
    "insertText": "EnterNotPreviouslyExcludedScope(TObjectPtr<UObject> Object)"
  },
  {
    "label": "EnterIncludedScope()",
    "kind": "Method",
    "detail": "Function (FHarvestScope)",
    "insertText": "EnterIncludedScope(TObjectPtr<UObject> Object)"
  },
  {
    "label": "GetPreviouslyIncludedRealms()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPreviouslyIncludedRealms(TObjectPtr<UObject> Object, FExportingRealmsArray& OutAlreadyIncluded, FExportingRealmsArray& OutNotAlreadyIncluded)"
  }
]