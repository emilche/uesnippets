[
  {
    "label": "real_2x2_jacobi_svd()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_REALSVD2X2_H # define EIGEN_REALSVD2X2_H namespace Eigen { namespace internal { template<MatrixType,RealScalar,Index> void)",
    "insertText": "real_2x2_jacobi_svd(const MatrixType& matrix, Index p, Index q, JacobiRotation<RealScalar> *j_left, JacobiRotation<RealScalar> *j_right)"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (using std::sqrt ; using std::abs ; Matrix<RealScalar,2,2> m ; m<<)",
    "insertText": "real(matrix.coeff(p,p)), numext::real(matrix.coeff(p,q)), numext::real(matrix.coeff(q,p)), numext::real(matrix.coeff(q,q))"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (JacobiRotation<RealScalar> rot1 ; RealScalar t = m .)",
    "insertText": "coeff(0,0) + m.coeff(1,1)"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (RealScalar d = m .)",
    "insertText": "coeff(1,0) - m.coeff(0,1)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (rot1 .)",
    "insertText": "s() = RealScalar(0)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (rot1 .)",
    "insertText": "c() = RealScalar(1)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (} else { RealScalar u = t / d ; RealScalar tmp =)",
    "insertText": "sqrt(RealScalar(1) + numext::abs2(u))"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (rot1 .)",
    "insertText": "s() = RealScalar(1)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (rot1 .)",
    "insertText": "c()"
  },
  {
    "label": "applyOnTheLeft()",
    "kind": "Method",
    "detail": "Function (} m .)",
    "insertText": "applyOnTheLeft(0,1,rot1)"
  },
  {
    "label": "makeJacobi()",
    "kind": "Method",
    "detail": "Function (j_right ->)",
    "insertText": "makeJacobi(m,0,1)"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (* j_left = rot1* j_right ->)",
    "insertText": "transpose()"
  }
]