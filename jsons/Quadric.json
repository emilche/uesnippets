[
  {
    "label": "TVec3",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TVec3"
  },
  {
    "label": "FEdgeQuadric",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FEdgeQuadric"
  },
  {
    "label": "FQuadric",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FQuadric"
  },
  {
    "label": "FQuadricAttr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FQuadricAttr"
  },
  {
    "label": "TQuadricAttr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TQuadricAttr"
  },
  {
    "label": "FQuadricAttrOptimizer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FQuadricAttrOptimizer"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # if)",
    "insertText": "defined(_MSC_VER) && !defined(__clang__) #pragma float_control( precise, on, push ) #pragma warning(disable:6011) #endif #define WEIGHT_BY_AREA 1 #define VOLUME_CONSTRAINT 1 #define USE_FMA 0 #define PSEUDO_INVERSE 0 #if USE_FMA template< typename T > inline T DifferenceOfProducts( T a, T b, T c, T d)"
  },
  {
    "label": "fma()",
    "kind": "Method",
    "detail": "Function (T cd = c* d ; T Error =)",
    "insertText": "fma(-c, d, cd)"
  },
  {
    "label": "fma()",
    "kind": "Method",
    "detail": "Function (T ab_cd =)",
    "insertText": "fma(a, b, -cd)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (T x = a + b ; T z = x - b ;)",
    "insertText": "return(a - (x - z) ) + (b - z)"
  },
  {
    "label": "TwoProdError()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "TwoProdError(T a, T b)"
  },
  {
    "label": "fma()",
    "kind": "Method",
    "detail": "Function (T x = a* b ; return)",
    "insertText": "fma(a, b, -x)"
  },
  {
    "label": "TVec3()",
    "kind": "Method",
    "detail": "Function (} # endif template<T> struct TVec3 { T x ; T y ; T z ;)",
    "insertText": "TVec3()"
  },
  {
    "label": "TVec3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TVec3(T Scalar ) : x( Scalar ), y( Scalar ), z( Scalar)"
  },
  {
    "label": "TVec3()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TVec3(T InX, T InY, T InZ ) : x( InX ), y( InY ), z( InZ)"
  },
  {
    "label": "TVec3()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TVec3(const FVector3f& v ) : x( v.X ), y( v.Y ), z( v.Z)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TVec3)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TVec3)",
    "insertText": "operator(T Scalar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TVec3)",
    "insertText": "operator(const TVec3& v)"
  },
  {
    "label": "TwoProdError()",
    "kind": "Method",
    "detail": "Function (# if USE_FMA T xx = x* v . x ; T yy = y* v . y ; T zz = z* v . z ; T Dot,DotError ; DotError =)",
    "insertText": "TwoProdError(x, v.x)"
  },
  {
    "label": "DifferenceOfProducts()",
    "kind": "Method",
    "detail": "Function (TVec3 Result ; # if USE_FMA Result . x =)",
    "insertText": "DifferenceOfProducts(y, v.z, z, v.y)"
  },
  {
    "label": "DifferenceOfProducts()",
    "kind": "Method",
    "detail": "Function (Result . y =)",
    "insertText": "DifferenceOfProducts(z, v.x, x, v.z)"
  },
  {
    "label": "DifferenceOfProducts()",
    "kind": "Method",
    "detail": "Function (Result . z =)",
    "insertText": "DifferenceOfProducts(x, v.y, y, v.x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# else Result . x = y* v . z - z* v . y ; Result . y = z* v . x - x* v . z ; Result . z = x* v . y - y* v . x ; # endif return Result ; } } ; template<T> TVec3<T>)",
    "insertText": "operator(T Scalar, const TVec3<T>& v)"
  },
  {
    "label": "FEdgeQuadric()",
    "kind": "Method",
    "detail": "Function (} using QScalar = double ; using QVec3 = TVec3<QScalar> ; class FEdgeQuadric { public :)",
    "insertText": "FEdgeQuadric()"
  },
  {
    "label": "FEdgeQuadric()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FEdgeQuadric(const QVec3 p0, const QVec3 p1, const float Weight)"
  },
  {
    "label": "FEdgeQuadric()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FEdgeQuadric(const QVec3 p0, const QVec3 p1, const QVec3 FaceNormal, const float Weight)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Zero()"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (const QVec3 p01 = p1 - p0 ; n = p01 ^ FaceNormal ; const QScalar Length =)",
    "insertText": "sqrt(n | n)"
  },
  {
    "label": "FQuadric()",
    "kind": "Method",
    "detail": "Function (nxx = 0 . 0 ; nyy = 0 . 0 ; nzz = 0 . 0 ; nxy = 0 . 0 ; nxz = 0 . 0 ; nyz = 0 . 0 ; n = 0 . 0 ; a = 0 . 0 ; } class FQuadric { public :)",
    "insertText": "FQuadric()"
  },
  {
    "label": "FQuadric()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FQuadric(const QVec3 p)"
  },
  {
    "label": "FQuadric()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FQuadric(const QVec3 n, const QVec3 p)"
  },
  {
    "label": "FQuadric()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FQuadric(const QVec3 p0, const QVec3 p1, const QVec3 p2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FQuadric&)",
    "insertText": "operator(const FQuadric& q)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(const FEdgeQuadric& q, const FVector3f& Point)"
  },
  {
    "label": "Evaluate()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Evaluate(const FVector3f& p)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (nxx + = q . nxx ; nyy + = q . nyy ; nzz + = q . nzz ; nxy + = q . nxy ; nxz + = q . nxz ; nyz + = q . nyz ; dn + = q . dn ; d2 + = q . d2 ; a + = q . a ; return* this ; } void)",
    "insertText": "Add(const FEdgeQuadric& RESTRICT EdgeQuadric, const FVector3f& Point)"
  },
  {
    "label": "p0()",
    "kind": "Method",
    "detail": "Function (const QVec3)",
    "insertText": "p0(Point)"
  },
  {
    "label": "Dist()",
    "kind": "Method",
    "detail": "Function (const QScalar)",
    "insertText": "Dist(EdgeQuadric.n | p0)"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (nxx + = EdgeQuadric . nxx ; nyy + = EdgeQuadric . nyy ; nzz + = EdgeQuadric . nzz ; nxy + = EdgeQuadric . nxy ; nxz + = EdgeQuadric . nxz ; nyz + = EdgeQuadric . nyz ; QScalar aDist = EdgeQuadric . a* Dist ; dn + = EdgeQuadric . a* - p0 - aDist* EdgeQuadric . n ; d2 + = EdgeQuadric .)",
    "insertText": "a(p0 | p0)"
  },
  {
    "label": "FQuadricAttr()",
    "kind": "Method",
    "detail": "Function (} class FQuadricAttr : public FQuadric { public :)",
    "insertText": "FQuadricAttr()"
  },
  {
    "label": "FQuadricAttr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FQuadricAttr(const QVec3 p0, const QVec3 p1, const QVec3 p2, const float* a0, const float* a1, const float* a2, const float* AttributeWeights, uint32 NumAttributes)"
  },
  {
    "label": "Rebase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rebase(const FVector3f& Point, const float* Attributes, const float* AttributeWeights, uint32 NumAttributes)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(const FQuadricAttr& q, const FVector3f& Point, const float* Attribute, const float* AttributeWeights, uint32 NumAttributes)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(const FQuadricAttr& q, uint32 NumAttributes)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Zero(uint32 NumAttributes)"
  },
  {
    "label": "Evaluate()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Evaluate(const FVector3f& Point, const float* Attributes, const float* AttributeWeights, uint32 NumAttributes)"
  },
  {
    "label": "CalcAttributesAndEvaluate()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "CalcAttributesAndEvaluate(const FVector3f& Point, float* Attributes, const float* AttributeWeights, uint32 NumAttributes)"
  },
  {
    "label": "TQuadricAttr()",
    "kind": "Method",
    "detail": "Function (# if VOLUME_CONSTRAINT QVec3 nv ; QScalar dv ; # endif } ; template<uint32 NumAttributes> class TQuadricAttr : public FQuadricAttr { public :)",
    "insertText": "TQuadricAttr()"
  },
  {
    "label": "TQuadricAttr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TQuadricAttr(const QVec3 p0, const QVec3 p1, const QVec3 p2, const float* a0, const float* a1, const float* a2, const float* AttributeWeights)"
  },
  {
    "label": "Rebase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rebase(const FVector3f& Point, const float* Attributes, const float* AttributeWeights)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(const TQuadricAttr< NumAttributes >& q, const FVector3f& Point, const float* Attribute, const float* AttributeWeights)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TQuadricAttr<NumAttributes>&)",
    "insertText": "operator(const TQuadricAttr< NumAttributes >& q)"
  },
  {
    "label": "Evaluate()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Evaluate(const FVector3f& Point, const float* Attributes, const float* AttributeWeights)"
  },
  {
    "label": "CalcAttributesAndEvaluate()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "CalcAttributesAndEvaluate(const FVector3f& Point, float* Attributes, const float* AttributeWeights)"
  },
  {
    "label": "TQuadricAttr()",
    "kind": "Method",
    "detail": "Function (QScalar g [ NumAttributes ] [ 3 ] ; QScalar d [ NumAttributes ] ; } ; template<uint32 NumAttributes> TQuadricAttr<NumAttributes)",
    "insertText": "TQuadricAttr(const QVec3 p0, const QVec3 p1, const QVec3 p2, const float* a0, const float* a1, const float* a2, const float* AttributeWeights ) : FQuadricAttr( p0, p1, p2, a0, a1, a2, AttributeWeights, NumAttributes)"
  },
  {
    "label": "Rebase()",
    "kind": "Method",
    "detail": "Function (} template<uint32 NumAttributes> void TQuadricAttr<NumAttributes)",
    "insertText": "Rebase(const FVector3f& Point, const float* Attribute, const float* AttributeWeights)"
  },
  {
    "label": "Rebase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rebase(Point, Attribute, AttributeWeights, NumAttributes)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Zero(NumAttributes)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<uint32 NumAttributes> TQuadricAttr<NumAttributes>& TQuadricAttr<NumAttributes)",
    "insertText": "operator(const TQuadricAttr< NumAttributes >& RESTRICT q)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (nxx + = q . nxx ; nyy + = q . nyy ; nzz + = q . nzz ; nxy + = q . nxy ; nxz + = q . nxz ; nyz + = q . nyz ; dn + = q . dn ; d2 + = q . d2 ;)",
    "insertText": "for(uint32 i = 0; i < NumAttributes; i++)"
  },
  {
    "label": "CalcAttributesAndEvaluate()",
    "kind": "Method",
    "detail": "Function (g [ i ] [ 0 ] + = q . g [ i ] [ 0 ] ; g [ i ] [ 1 ] + = q . g [ i ] [ 1 ] ; g [ i ] [ 2 ] + = q . g [ i ] [ 2 ] ; d [ i ] + = q . d [ i ] ; } a + = q . a ; # if VOLUME_CONSTRAINT nv + = q . nv ; dv + = q . dv ; # endif return* this ; } template<uint32 NumAttributes> float TQuadricAttr<NumAttributes)",
    "insertText": "CalcAttributesAndEvaluate(const FVector3f& Point, float* RESTRICT Attributes, const float* RESTRICT AttributeWeights)"
  },
  {
    "label": "FQuadricAttrOptimizer()",
    "kind": "Method",
    "detail": "Function (} class FQuadricAttrOptimizer { public :)",
    "insertText": "FQuadricAttrOptimizer()"
  },
  {
    "label": "AddQuadric()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddQuadric(const FQuadric& q)"
  },
  {
    "label": "AddQuadric()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddQuadric(const FQuadricAttr& q, uint32 NumAttributes)"
  },
  {
    "label": "Optimize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Optimize(FVector3f& Position)"
  },
  {
    "label": "OptimizeVolume()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OptimizeVolume(FVector3f& Position)"
  },
  {
    "label": "OptimizeLinear()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OptimizeLinear(const FVector3f& Position0, const FVector3f& Position1, FVector3f& Position)"
  },
  {
    "label": "AddQuadric()",
    "kind": "Method",
    "detail": "Function (nxx = 0 . 0 ; nyy = 0 . 0 ; nzz = 0 . 0 ; nxy = 0 . 0 ; nxz = 0 . 0 ; nyz = 0 . 0 ; dn = 0 . 0 ; a = 0 . 0 ; # if VOLUME_CONSTRAINT nv = 0 . 0 ; dv = 0 . 0 ; # endif BBtxx = 0 . 0 ; BBtyy = 0 . 0 ; BBtzz = 0 . 0 ; BBtxy = 0 . 0 ; BBtxz = 0 . 0 ; BBtyz = 0 . 0 ; Bd = 0 . 0 ; } void)",
    "insertText": "AddQuadric(const FQuadric& RESTRICT q)"
  },
  {
    "label": "AddQuadric()",
    "kind": "Method",
    "detail": "Function (nxx + = q . nxx ; nyy + = q . nyy ; nzz + = q . nzz ; nxy + = q . nxy ; nxz + = q . nxz ; nyz + = q . nyz ; dn + = q . dn ; } void)",
    "insertText": "AddQuadric(const FQuadricAttr& RESTRICT q, uint32 NumAttributes)"
  },
  {
    "label": "g()",
    "kind": "Method",
    "detail": "Function (nxx + = q . nxx ; nyy + = q . nyy ; nzz + = q . nzz ; nxy + = q . nxy ; nxz + = q . nxz ; nyz + = q . nyz ; dn + = q . dn ; a + = q . a ; # if VOLUME_CONSTRAINT nv + = q . nv ; dv + = q . dv ; # endif QVec3* RESTRICT)",
    "insertText": "g(QVec3*)( &q + 1)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (QScalar* RESTRICT)",
    "insertText": "d(QScalar*)( g + NumAttributes)"
  }
]