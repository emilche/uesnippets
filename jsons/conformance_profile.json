[
  {
    "label": "NoError",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NoError"
  },
  {
    "label": "ConformanceErrors",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConformanceErrors"
  },
  {
    "label": "H",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "H"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "PropertiesOfImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PropertiesOfImpl"
  },
  {
    "label": "PropertiesOf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PropertiesOf"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "Enum",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Enum"
  },
  {
    "label": "MinProf",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MinProf"
  },
  {
    "label": "MaxProf",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaxProf"
  },
  {
    "label": "Op",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Op"
  },
  {
    "label": "IsOpableImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsOpableImpl"
  },
  {
    "label": "IsOpable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsOpable"
  },
  {
    "label": "IsNothrowOpableImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsNothrowOpableImpl"
  },
  {
    "label": "IsNothrowOpable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsNothrowOpable"
  },
  {
    "label": "Result",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Result"
  },
  {
    "label": "ConformanceProfile",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConformanceProfile"
  },
  {
    "label": "conservative_hashable_support_of",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "conservative_hashable_support_of"
  },
  {
    "label": "SyntacticConformanceProfileOf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SyntacticConformanceProfileOf"
  },
  {
    "label": "N",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "N"
  },
  {
    "label": "MinimalProfiles",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MinimalProfiles"
  },
  {
    "label": "CombineProfilesImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CombineProfilesImpl"
  },
  {
    "label": "CombineProfiles",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CombineProfiles"
  },
  {
    "label": "Profile",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Profile"
  },
  {
    "label": "Tag",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Tag"
  },
  {
    "label": "StrongProfileTypedef",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StrongProfileTypedef"
  },
  {
    "label": "IsProfileImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsProfileImpl"
  },
  {
    "label": "IsProfile",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsProfile"
  },
  {
    "label": "RegularityDomain",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RegularityDomain"
  },
  {
    "label": "UnderlyingValue()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_TYPES_INTERNAL_CONFORMANCE_PROFILE_H_ # define ABSL_TYPES_INTERNAL_CONFORMANCE_PROFILE_H_ # include<set> # include<type_traits> # include<utility> # include<vector> # include \" gtest / gtest . h \" # include \" absl / algorithm / container . h \" # include \" absl / meta / type_traits . h \" # include \" absl / strings / ascii . h \" # include \" absl / strings / str_cat . h \" # include \" absl / strings / string_view . h \" # include \" absl / types / internal / conformance_testing_helpers . h \" # include \" absl / utility / utility . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace types_internal { template<Enum> absl::underlying_type_t<Enum>)",
    "insertText": "UnderlyingValue(Enum value)"
  },
  {
    "label": "ConformanceErrors()",
    "kind": "Method",
    "detail": "Function (} struct NoError { } ; class ConformanceErrors { public :)",
    "insertText": "ConformanceErrors(std::string type_name) : assertion_result_(false), type_name_(std::move(type_name))"
  },
  {
    "label": "outputDivider()",
    "kind": "Method",
    "detail": "Function (assertion_result_<<\" \\ n \\ n \" \" Assuming the following type alias : \\ n \" \" \\ n \" \" using _T = \"<<type_name_<<\" ; \\ n \\ n \" ;)",
    "insertText": "outputDivider()"
  },
  {
    "label": "addTestSuccess()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addTestSuccess(absl::string_view test_name)"
  },
  {
    "label": "AsciiStrToLower()",
    "kind": "Method",
    "detail": "Function (auto normalized_test_name =)",
    "insertText": "AsciiStrToLower(test_name)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (test_successes_ .)",
    "insertText": "insert(std::move(normalized_test_name))"
  },
  {
    "label": "addTestFailure()",
    "kind": "Method",
    "detail": "Function (} } template<class . . . P> void)",
    "insertText": "addTestFailure(absl::string_view test_name, const P&... args)"
  },
  {
    "label": "addTestFailureImpl()",
    "kind": "Method",
    "detail": "Function (assertion_result_<<\" \\ n \\ n \" \" Failed test : \"<<test_name<<\" \\ n \\ n \" ;)",
    "insertText": "addTestFailureImpl(args...)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (test_successes_ .)",
    "insertText": "erase(normalized_test_name)"
  },
  {
    "label": "assertionResult()",
    "kind": "Method",
    "detail": "Function (has_error_ = true ; }::testing::AssertionResult)",
    "insertText": "assertionResult()"
  },
  {
    "label": "expectFailedTests()",
    "kind": "Method",
    "detail": "Function (}::testing::AssertionResult)",
    "insertText": "expectFailedTests(const std::set<std::string>& test_names)"
  },
  {
    "label": "c_set_difference()",
    "kind": "Method",
    "detail": "Function (} std::vector<std::string> nonfailing_tests ;)",
    "insertText": "c_set_difference(test_names, test_failures_, std::back_inserter(nonfailing_tests))"
  },
  {
    "label": "c_set_difference()",
    "kind": "Method",
    "detail": "Function (std::vector<std::string> unrun_tests ;)",
    "insertText": "c_set_difference(nonfailing_tests, test_successes_, std::back_inserter(unrun_tests))"
  },
  {
    "label": "tests_were_run()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "tests_were_run(test_failures_.empty() && test_successes_.empty())"
  },
  {
    "label": "AssertionFailure()",
    "kind": "Method",
    "detail": "Function (::testing::AssertionResult result =::)",
    "insertText": "AssertionFailure()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (result<<\" When testing type : \\ n \"<<type_name_<<\" \\ n \\ nThe following tests were expected to fail but were not \" \" run \" ;)",
    "insertText": "if(tests_were_run) result << \" (was the test name spelled correctly?)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (result<<\" : \\ n \\ n \" ;)",
    "insertText": "for(const auto& test_name : unrun_tests)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (result<<\" \"<<test_name<<\" \\ n \" ; })",
    "insertText": "if(!tests_were_run)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (result<<\" \\ nThe tests that were run and failed are : \\ n \\ n \" ;)",
    "insertText": "for(const auto& test_name : test_failures_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (result<<\" \"<<test_name<<\" \\ n \" ; } })",
    "insertText": "if(!test_successes_.empty())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (result<<\" \\ nThe tests that were run and succeeded are : \\ n \\ n \" ;)",
    "insertText": "for(const auto& test_name : test_successes_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (result<<\" \"<<test_name<<\" \\ n \" ; } } return result ; })",
    "insertText": "if(nonfailing_tests.empty()) return ::testing::AssertionSuccess()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (unexpected_successes<<\" When testing type : \\ n \"<<type_name_<<\" \\ n \\ nThe following tests passed when they were \" \" expected to fail : \\ n \\ n \" ;)",
    "insertText": "for(const auto& test_name : nonfailing_tests)"
  },
  {
    "label": "addTestFailureImpl()",
    "kind": "Method",
    "detail": "Function (assertion_result_<<\" = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \" ; } void)",
    "insertText": "addTestFailureImpl()"
  },
  {
    "label": "addTestFailureImpl()",
    "kind": "Method",
    "detail": "Function (} template<class H,class . . . T> void)",
    "insertText": "addTestFailureImpl(const H& head, const T&... tail)"
  },
  {
    "label": "addTestFailureImpl()",
    "kind": "Method",
    "detail": "Function (assertion_result_<<head ;)",
    "insertText": "addTestFailureImpl(tail...)"
  },
  {
    "label": "PessimisticPropertyDescription()",
    "kind": "Method",
    "detail": "Function (}::testing::AssertionResult assertion_result_ ; std::set<std::string> test_failures_ ; std::set<std::string> test_successes_ ; std::string type_name_ ; bool has_error_ = false ; } ; template<class T,class = void> struct PropertiesOfImpl { } ; template<class T> struct PropertiesOfImpl<T,absl::void_t<T::properties>> { using type = T::properties ; } ; template<class T> struct PropertiesOfImpl<T,absl::void_t<T::profile_alias_of>> { using type = PropertiesOfImpl<T::profile_alias_of>::type ; } ; template<class T> struct PropertiesOf : PropertiesOfImpl<T> { } ; template<class T> using PropertiesOfT = PropertiesOf<T>::type ; enum class function_support { maybe,yes,nothrow,trivial } ; const char*)",
    "insertText": "PessimisticPropertyDescription(function_support v)"
  },
  {
    "label": "StrCat()",
    "kind": "Method",
    "detail": "Function (std::string result =)",
    "insertText": "StrCat(\"Expected:\\n \", PessimisticPropertyDescription( static_cast<function_support>(UnderlyingValue(min))), \"\\n\")"
  },
  {
    "label": "StrAppend()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StrAppend(&result, \" \", PessimisticPropertyDescription( static_cast<function_support>(curr_support)), \"\\n\")"
  },
  {
    "label": "ExpectModelOfImpl()",
    "kind": "Method",
    "detail": "Function (} return result ; } template<class Enum> void)",
    "insertText": "ExpectModelOfImpl(ConformanceErrors* errors, Enum min_support, Enum max_support, Enum kind)"
  },
  {
    "label": "UnderlyingValue()",
    "kind": "Method",
    "detail": "Function (const auto kind_value =)",
    "insertText": "UnderlyingValue(kind)"
  },
  {
    "label": "UnderlyingValue()",
    "kind": "Method",
    "detail": "Function (const auto min_support_value =)",
    "insertText": "UnderlyingValue(min_support)"
  },
  {
    "label": "UnderlyingValue()",
    "kind": "Method",
    "detail": "Function (const auto max_support_value =)",
    "insertText": "UnderlyingValue(max_support)"
  },
  {
    "label": "addTestFailure()",
    "kind": "Method",
    "detail": "Function (errors ->)",
    "insertText": "addTestFailure(PropertyName(kind), \"**Failed property expectation**\\n\\n\", ExpectedFunctionKindList( static_cast<function_support>(min_support_value), static_cast<function_support>(max_support_value)), '\\n', \"Actual:\\n \", PessimisticPropertyDescription( static_cast<function_support>(kind_value)))"
  },
  {
    "label": "addTestSuccess()",
    "kind": "Method",
    "detail": "Function (} else { errors ->)",
    "insertText": "addTestSuccess(PropertyName(kind))"
  },
  {
    "label": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (} } # define)",
    "insertText": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM(description, name)"
  },
  {
    "label": "PropertyName()",
    "kind": "Method",
    "detail": "Function (maybe,yes,nothrow,trivial } ; \\ \\ const char*)",
    "insertText": "PropertyName(name v)"
  },
  {
    "label": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM(\"support for move construction\", move_constructible)"
  },
  {
    "label": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM(\"support for copy construction\", copy_constructible)"
  },
  {
    "label": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM(\"support for move assignment\", move_assignable)"
  },
  {
    "label": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM(\"support for copy assignment\", copy_assignable)"
  },
  {
    "label": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM(\"support for destruction\", destructible)"
  },
  {
    "label": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (# undef ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM # define)",
    "insertText": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM(description, name)"
  },
  {
    "label": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM(\"support for !=\", inequality_comparable)"
  },
  {
    "label": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM(\"support for <\", less_than_comparable)"
  },
  {
    "label": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM(\"support for <=\", less_equal_comparable)"
  },
  {
    "label": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM(\"support for >=\", greater_equal_comparable)"
  },
  {
    "label": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM(\"support for >\", greater_than_comparable)"
  },
  {
    "label": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM(\"support for swap\", swappable)"
  },
  {
    "label": "PropertyName()",
    "kind": "Method",
    "detail": "Function (# undef ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM enum class hashable { maybe,yes } ; const char*)",
    "insertText": "PropertyName(hashable v)"
  },
  {
    "label": "name()",
    "kind": "Method",
    "detail": "Function (\\ return std::is_ # # property<T>::value \\ ? std::is_nothrow_ # # property<T>::value \\ ? absl::is_trivially_ # # property<T>::value \\ ? property::trivial \\ : property::nothrow \\ : property::yes \\ : property::maybe ; \\ } \\ \\ template<class T,class MinProf,class MaxProf> \\ void ExpectModelOf # #)",
    "insertText": "name(ConformanceErrors* errors)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(DefaultConstructible, default_constructible)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(MoveConstructible, move_constructible)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(CopyConstructible, copy_constructible)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(MoveAssignable, move_assignable)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(CopyAssignable, copy_assignable)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(Destructible, destructible)"
  },
  {
    "label": "BoolFunction()",
    "kind": "Method",
    "detail": "Function (# undef ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER void)",
    "insertText": "BoolFunction(bool)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON()",
    "kind": "Method",
    "detail": "Function (template<class T,template<class . . .> class Op,class = void> struct IsOpableImpl : std::false_type { } ; template<class T,template<class . . .> class Op> struct IsOpableImpl<T,Op,absl::void_t<Op<T>>> : std::true_type { } ; template<template<class . . .> class Op> struct IsOpable { template<class T> using apply = IsOpableImpl<T,Op>::type ; } ; template<class T,template<class . . .> class Op,class = void> struct IsNothrowOpableImpl : std::false_type { } ; template<class T,template<class . . .> class Op> struct IsNothrowOpableImpl<T,Op,absl::enable_if_t<Op<T>::value>> : std::true_type { } ; template<template<class . . .> class Op> struct IsNothrowOpable { template<class T> using apply = IsNothrowOpableImpl<T,Op>::type ; } ; # define)",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(name, property, op) \\ template <class T, \\ class Result = std::integral_constant< \\ bool, noexcept((BoolFunction)(std::declval<const T&>() op \\ std::declval<const T&>()))"
  },
  {
    "label": "_support_of()",
    "kind": "Method",
    "detail": "Function (\\ \\ template<class T> \\ property property # #)",
    "insertText": "_support_of()"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(EqualityComparable, equality_comparable, ==)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(InequalityComparable, inequality_comparable, !=)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(LessThanComparable, less_than_comparable, <)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(LessEqualComparable, less_equal_comparable, <=)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(GreaterEqualComparable, greater_equal_comparable, >=)"
  },
  {
    "label": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(GreaterThanComparable, greater_than_comparable, >)"
  },
  {
    "label": "swappable_support_of()",
    "kind": "Method",
    "detail": "Function (# undef ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON template<class T> swappable)",
    "insertText": "swappable_support_of()"
  },
  {
    "label": "hashable_support_of()",
    "kind": "Method",
    "detail": "Function (} template<class T> hashable)",
    "insertText": "hashable_support_of()"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (} template<default_constructible DefaultConstructibleValue = default_constructible::maybe,move_constructible MoveConstructibleValue = move_constructible::maybe,copy_constructible CopyConstructibleValue = copy_constructible::maybe,move_assignable MoveAssignableValue = move_assignable::maybe,copy_assignable CopyAssignableValue = copy_assignable::maybe,destructible DestructibleValue = destructible::maybe,equality_comparable EqualityComparableValue = equality_comparable::maybe,inequality_comparable InequalityComparableValue = inequality_comparable::maybe,less_than_comparable LessThanComparableValue = less_than_comparable::maybe,less_equal_comparable LessEqualComparableValue = less_equal_comparable::maybe,greater_equal_comparable GreaterEqualComparableValue = greater_equal_comparable::maybe,greater_than_comparable GreaterThanComparableValue = greater_than_comparable::maybe,swappable SwappableValue = swappable::maybe,hashable HashableValue = hashable::maybe> struct ConformanceProfile { using properties = ConformanceProfile ; default_constructible default_constructible_support = DefaultConstructibleValue ; move_constructible move_constructible_support = MoveConstructibleValue ; copy_constructible copy_constructible_support = CopyConstructibleValue ; move_assignable move_assignable_support = MoveAssignableValue ; copy_assignable copy_assignable_support = CopyAssignableValue ; destructible destructible_support = DestructibleValue ; equality_comparable equality_comparable_support = EqualityComparableValue ; inequality_comparable inequality_comparable_support = InequalityComparableValue ; less_than_comparable less_than_comparable_support = LessThanComparableValue ; less_equal_comparable less_equal_comparable_support = LessEqualComparableValue ; greater_equal_comparable greater_equal_comparable_support = GreaterEqualComparableValue ; greater_than_comparable greater_than_comparable_support = GreaterThanComparableValue ; swappable swappable_support = SwappableValue ; hashable hashable_support = HashableValue ; bool is_default_constructible = DefaultConstructibleValue ! = default_constructible::maybe ; bool is_move_constructible = MoveConstructibleValue ! = move_constructible::maybe ; bool is_copy_constructible = CopyConstructibleValue ! = copy_constructible::maybe ; bool is_move_assignable = MoveAssignableValue ! = move_assignable::maybe ; bool is_copy_assignable = CopyAssignableValue ! = copy_assignable::maybe ; bool is_destructible = DestructibleValue ! = destructible::maybe ; bool is_equality_comparable = EqualityComparableValue ! = equality_comparable::maybe ; bool is_inequality_comparable = InequalityComparableValue ! = inequality_comparable::maybe ; bool is_less_than_comparable = LessThanComparableValue ! = less_than_comparable::maybe ; bool is_less_equal_comparable = LessEqualComparableValue ! = less_equal_comparable::maybe ; bool is_greater_equal_comparable = GreaterEqualComparableValue ! = greater_equal_comparable::maybe ; bool is_greater_than_comparable = GreaterThanComparableValue ! = greater_than_comparable::maybe ; bool is_swappable = SwappableValue ! = swappable::maybe ; bool is_hashable = HashableValue ! = hashable::maybe ; } ; enum class CheckHashability { no,yes } ; template<class T,CheckHashability ShouldCheckHashability> struct conservative_hashable_support_of ; template<class T> struct conservative_hashable_support_of<T,CheckHashability::no> { hashable)",
    "insertText": "Invoke()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T,CheckHashability ShouldCheckHashability> struct SyntacticConformanceProfileOf { using properties = ConformanceProfile<default_constructible_support_of<)",
    "insertText": "T(), move_constructible_support_of<T>(), copy_constructible_support_of<T>(), move_assignable_support_of<T>(), copy_assignable_support_of<T>(), destructible_support_of<T>(), equality_comparable_support_of<T>(), inequality_comparable_support_of<T>(), less_than_comparable_support_of<T>(), less_equal_comparable_support_of<T>(), greater_equal_comparable_support_of<T>(), greater_than_comparable_support_of<T>(), swappable_support_of<T>(), conservative_hashable_support_of<T, ShouldCheckHashability>::Invoke()"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL()",
    "kind": "Method",
    "detail": "Function (} ; # define)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL(type, name) \\ template <default_constructible DefaultConstructibleValue, \\ move_constructible MoveConstructibleValue, \\ copy_constructible CopyConstructibleValue, \\ move_assignable MoveAssignableValue, \\ copy_assignable CopyAssignableValue, \\ destructible DestructibleValue, \\ equality_comparable EqualityComparableValue, \\ inequality_comparable InequalityComparableValue, \\ less_than_comparable LessThanComparableValue, \\ less_equal_comparable LessEqualComparableValue, \\ greater_equal_comparable GreaterEqualComparableValue, \\ greater_than_comparable GreaterThanComparableValue, \\ swappable SwappableValue, hashable HashableValue> \\ constexpr type ConformanceProfile< \\ DefaultConstructibleValue, MoveConstructibleValue, \\ CopyConstructibleValue, MoveAssignableValue, CopyAssignableValue, \\ DestructibleValue, EqualityComparableValue, InequalityComparableValue, \\ LessThanComparableValue, LessEqualComparableValue, \\ GreaterEqualComparableValue, GreaterThanComparableValue, SwappableValue, \\ HashableValue>::name #define ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(type) \\ ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL(type, \\ type##_support)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL(bool, is_##type) #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(default_constructible)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(move_constructible)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(copy_constructible)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(move_assignable)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(copy_assignable)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(destructible)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(equality_comparable)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(inequality_comparable)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(less_than_comparable)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(less_equal_comparable)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(greater_equal_comparable)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(greater_than_comparable)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(swappable)"
  },
  {
    "label": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(hashable)"
  },
  {
    "label": "MinEnum()",
    "kind": "Method",
    "detail": "Function (# endif # undef ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF # undef ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL template<class H> H)",
    "insertText": "MinEnum(H head)"
  },
  {
    "label": "default_constructible_support()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Profs> struct MinimalProfiles { default_constructible)",
    "insertText": "default_constructible_support(MinEnum)(PropertiesOfT<Profs>::default_constructible_support...)"
  },
  {
    "label": "move_constructible_support()",
    "kind": "Method",
    "detail": "Function (move_constructible)",
    "insertText": "move_constructible_support(MinEnum)(PropertiesOfT<Profs>::move_constructible_support...)"
  },
  {
    "label": "copy_constructible_support()",
    "kind": "Method",
    "detail": "Function (copy_constructible)",
    "insertText": "copy_constructible_support(MinEnum)(PropertiesOfT<Profs>::copy_constructible_support...)"
  },
  {
    "label": "move_assignable_support()",
    "kind": "Method",
    "detail": "Function (move_assignable)",
    "insertText": "move_assignable_support(MinEnum)(PropertiesOfT<Profs>::move_assignable_support...)"
  },
  {
    "label": "copy_assignable_support()",
    "kind": "Method",
    "detail": "Function (copy_assignable)",
    "insertText": "copy_assignable_support(MinEnum)(PropertiesOfT<Profs>::copy_assignable_support...)"
  },
  {
    "label": "destructible_support()",
    "kind": "Method",
    "detail": "Function (destructible)",
    "insertText": "destructible_support(MinEnum)(PropertiesOfT<Profs>::destructible_support...)"
  },
  {
    "label": "equality_comparable_support()",
    "kind": "Method",
    "detail": "Function (equality_comparable)",
    "insertText": "equality_comparable_support(MinEnum)(PropertiesOfT<Profs>::equality_comparable_support...)"
  },
  {
    "label": "inequality_comparable_support()",
    "kind": "Method",
    "detail": "Function (inequality_comparable)",
    "insertText": "inequality_comparable_support(MinEnum)(PropertiesOfT<Profs>::inequality_comparable_support...)"
  },
  {
    "label": "less_than_comparable_support()",
    "kind": "Method",
    "detail": "Function (less_than_comparable)",
    "insertText": "less_than_comparable_support(MinEnum)(PropertiesOfT<Profs>::less_than_comparable_support...)"
  },
  {
    "label": "less_equal_comparable_support()",
    "kind": "Method",
    "detail": "Function (less_equal_comparable)",
    "insertText": "less_equal_comparable_support(MinEnum)(PropertiesOfT<Profs>::less_equal_comparable_support...)"
  },
  {
    "label": "greater_equal_comparable_support()",
    "kind": "Method",
    "detail": "Function (greater_equal_comparable)",
    "insertText": "greater_equal_comparable_support(MinEnum)(PropertiesOfT<Profs>::greater_equal_comparable_support...)"
  },
  {
    "label": "greater_than_comparable_support()",
    "kind": "Method",
    "detail": "Function (greater_than_comparable)",
    "insertText": "greater_than_comparable_support(MinEnum)(PropertiesOfT<Profs>::greater_than_comparable_support...)"
  },
  {
    "label": "swappable_support()",
    "kind": "Method",
    "detail": "Function (swappable)",
    "insertText": "swappable_support(MinEnum)(PropertiesOfT<Profs>::swappable_support...)"
  },
  {
    "label": "hashable_support()",
    "kind": "Method",
    "detail": "Function (hashable)",
    "insertText": "hashable_support(MinEnum)(PropertiesOfT<Profs>::hashable_support...)"
  },
  {
    "label": "MaxEnum()",
    "kind": "Method",
    "detail": "Function (using properties = ConformanceProfile<default_constructible_support,move_constructible_support,copy_constructible_support,move_assignable_support,copy_assignable_support,destructible_support,equality_comparable_support,inequality_comparable_support,less_than_comparable_support,less_equal_comparable_support,greater_equal_comparable_support,greater_than_comparable_support,swappable_support,hashable_support> ; } ; template<class H> H)",
    "insertText": "MaxEnum(H head)"
  },
  {
    "label": "default_constructible_support()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Profs> struct CombineProfilesImpl { default_constructible)",
    "insertText": "default_constructible_support(MaxEnum)(PropertiesOfT<Profs>::default_constructible_support...)"
  },
  {
    "label": "move_constructible_support()",
    "kind": "Method",
    "detail": "Function (move_constructible)",
    "insertText": "move_constructible_support(MaxEnum)(PropertiesOfT<Profs>::move_constructible_support...)"
  },
  {
    "label": "copy_constructible_support()",
    "kind": "Method",
    "detail": "Function (copy_constructible)",
    "insertText": "copy_constructible_support(MaxEnum)(PropertiesOfT<Profs>::copy_constructible_support...)"
  },
  {
    "label": "move_assignable_support()",
    "kind": "Method",
    "detail": "Function (move_assignable)",
    "insertText": "move_assignable_support(MaxEnum)(PropertiesOfT<Profs>::move_assignable_support...)"
  },
  {
    "label": "copy_assignable_support()",
    "kind": "Method",
    "detail": "Function (copy_assignable)",
    "insertText": "copy_assignable_support(MaxEnum)(PropertiesOfT<Profs>::copy_assignable_support...)"
  },
  {
    "label": "destructible_support()",
    "kind": "Method",
    "detail": "Function (destructible)",
    "insertText": "destructible_support(MaxEnum)(PropertiesOfT<Profs>::destructible_support...)"
  },
  {
    "label": "equality_comparable_support()",
    "kind": "Method",
    "detail": "Function (equality_comparable)",
    "insertText": "equality_comparable_support(MaxEnum)(PropertiesOfT<Profs>::equality_comparable_support...)"
  },
  {
    "label": "inequality_comparable_support()",
    "kind": "Method",
    "detail": "Function (inequality_comparable)",
    "insertText": "inequality_comparable_support(MaxEnum)(PropertiesOfT<Profs>::inequality_comparable_support...)"
  },
  {
    "label": "less_than_comparable_support()",
    "kind": "Method",
    "detail": "Function (less_than_comparable)",
    "insertText": "less_than_comparable_support(MaxEnum)(PropertiesOfT<Profs>::less_than_comparable_support...)"
  },
  {
    "label": "less_equal_comparable_support()",
    "kind": "Method",
    "detail": "Function (less_equal_comparable)",
    "insertText": "less_equal_comparable_support(MaxEnum)(PropertiesOfT<Profs>::less_equal_comparable_support...)"
  },
  {
    "label": "greater_equal_comparable_support()",
    "kind": "Method",
    "detail": "Function (greater_equal_comparable)",
    "insertText": "greater_equal_comparable_support(MaxEnum)(PropertiesOfT<Profs>::greater_equal_comparable_support...)"
  },
  {
    "label": "greater_than_comparable_support()",
    "kind": "Method",
    "detail": "Function (greater_than_comparable)",
    "insertText": "greater_than_comparable_support(MaxEnum)(PropertiesOfT<Profs>::greater_than_comparable_support...)"
  },
  {
    "label": "swappable_support()",
    "kind": "Method",
    "detail": "Function (swappable)",
    "insertText": "swappable_support(MaxEnum)(PropertiesOfT<Profs>::swappable_support...)"
  },
  {
    "label": "hashable_support()",
    "kind": "Method",
    "detail": "Function (hashable)",
    "insertText": "hashable_support(MaxEnum)(PropertiesOfT<Profs>::hashable_support...)"
  }
]