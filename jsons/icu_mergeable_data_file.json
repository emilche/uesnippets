[
  {
    "label": "AshMemoryMappedFile",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AshMemoryMappedFile"
  },
  {
    "label": "BASE_I18N_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_I18N_EXPORT"
  },
  {
    "label": "Hashes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Hashes"
  },
  {
    "label": "Slice",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Slice"
  },
  {
    "label": "BASE_DECLARE_FEATURE()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_I18N_ICU_MERGEABLE_DATA_FILE_H_ # define BASE_I18N_ICU_MERGEABLE_DATA_FILE_H_ # include<stdint . h> # include<memory> # include<utility> # include<vector> # include \" base / containers / flat_map . h \" # include \" base / feature_list . h \" # include \" base / files / memory_mapped_file . h \" # include \" base / i18n / base_i18n_export . h \" # include \" base / memory / raw_ptr . h \" namespace base::i18n { BASE_I18N_EXPORT)",
    "insertText": "BASE_DECLARE_FEATURE(kLacrosMergeIcuDataFile)"
  },
  {
    "label": "IcuMergeableDataFile()",
    "kind": "Method",
    "detail": "Function (class AshMemoryMappedFile ; class BASE_I18N_EXPORT IcuMergeableDataFile { public : using HashType = uint64_t ; char kIcuDataFileHashExtension [ ] = \" hash \" ;)",
    "insertText": "IcuMergeableDataFile()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Initialize(File lacros_file, MemoryMappedFile::Region region)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (const uint8_t*)",
    "insertText": "data()"
  },
  {
    "label": "MergeWithAshVersion()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MergeWithAshVersion(const FilePath& icudtl_ash_path)"
  },
  {
    "label": "used_cached_hashes()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "used_cached_hashes()"
  },
  {
    "label": "Hashes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Hashes(HashToOffsetMap ash, std::vector<HashType> lacros)"
  },
  {
    "label": "Hashes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Hashes(Hashes&& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Hashes&)",
    "insertText": "operator(Hashes&& other)"
  },
  {
    "label": "Hashes()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "Hashes()"
  },
  {
    "label": "MmapLacrosFile()",
    "kind": "Method",
    "detail": "Function (HashToOffsetMap ash ; std::vector<HashType> lacros ; } ; struct Slice { size_t offset ; size_t length ; } ; bool)",
    "insertText": "MmapLacrosFile(bool remap)"
  },
  {
    "label": "FindOverlap()",
    "kind": "Method",
    "detail": "Function (Slice)",
    "insertText": "FindOverlap(const AshMemoryMappedFile& ash_file, const Hashes& hashes, size_t lacros_offset)"
  },
  {
    "label": "MergeArea()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MergeArea(const AshMemoryMappedFile& ash_file, const Slice& ash_overlap, size_t lacros_offset)"
  },
  {
    "label": "CountEqualPages()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "CountEqualPages(const AshMemoryMappedFile& ash_file, const uint8_t* ash_page, const uint8_t* lacros_page)"
  },
  {
    "label": "CalculateHashes()",
    "kind": "Method",
    "detail": "Function (Hashes)",
    "insertText": "CalculateHashes(const AshMemoryMappedFile& ash_file, const FilePath& ash_file_path)"
  },
  {
    "label": "MaybeLoadCachedHashes()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MaybeLoadCachedHashes(const AshMemoryMappedFile& ash_file, const FilePath& ash_file_path, Hashes& hashes)"
  },
  {
    "label": "GetLacrosFilePath()",
    "kind": "Method",
    "detail": "Function (FilePath)",
    "insertText": "GetLacrosFilePath()"
  }
]