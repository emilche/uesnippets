[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TCompare",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TCompare"
  },
  {
    "label": "CSet()",
    "kind": "Method",
    "detail": "Function (template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "CSet(size_t uiStartingPoolSize) : m_pRoot(NULL), m_uiSize(0), m_cPool(sizeof(CNode), uiStartingPoolSize)"
  },
  {
    "label": "CSet()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "CSet(const CSet& cRight) : m_pRoot(NULL), m_uiSize(0), m_cPool(sizeof(CNode), cRight.m_cPool.size( ))"
  },
  {
    "label": "CSet()",
    "kind": "Method",
    "detail": "Function (* this = cRight ; } template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::~)",
    "insertText": "CSet(void)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE void CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "clear(void)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Ptr(m_pRoot)->DeleteChildren(this)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deallocate(m_pRoot)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (m_pRoot = NULL ; } m_uiSize = 0 ; } template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE size_t CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "size(void)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE bool CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "empty(void)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>& CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "operator(const CSet<T, TCompare, bUseCustomAllocator>& cRight)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (m_pRoot =)",
    "insertText": "Allocate(cRight.Ptr(cRight.m_pRoot)->m_tData, NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_uiLevel)",
    "insertText": "Ptr(m_pRoot)->m_uiLevel = cRight.Ptr(cRight.m_pRoot)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (+ + m_uiSize ; CArray<CNodeReference> aThis ; CArray<CNodeReference> aRight ; aThis .)",
    "insertText": "push_back(m_pRoot)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (aRight .)",
    "insertText": "push_back(cRight.m_pRoot)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (CNodeReference pThis = aThis .)",
    "insertText": "back()"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (aThis .)",
    "insertText": "pop_back()"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Ptr(pThis)->m_pLeft = Allocate(cRight.Ptr(cRight.Ptr(pRight)->m_pLeft)->m_tData, pThis)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_uiLevel)",
    "insertText": "Ptr(Ptr(pThis)->m_pLeft)->m_uiLevel = cRight.Ptr(cRight.Ptr(pRight)->m_pLeft)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (aThis .)",
    "insertText": "push_back(Ptr(pThis)->m_pLeft)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (aRight .)",
    "insertText": "push_back(cRight.Ptr(pRight)->m_pLeft)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + m_uiSize ; })",
    "insertText": "if(cRight.Ptr(pRight)->m_pRight != NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Ptr(pThis)->m_pRight = Allocate(cRight.Ptr(cRight.Ptr(pRight)->m_pRight)->m_tData, pThis)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_uiLevel)",
    "insertText": "Ptr(Ptr(pThis)->m_pRight)->m_uiLevel = cRight.Ptr(cRight.Ptr(pRight)->m_pRight)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (aThis .)",
    "insertText": "push_back(Ptr(pThis)->m_pRight)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (aRight .)",
    "insertText": "push_back(cRight.Ptr(pRight)->m_pRight)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (+ + m_uiSize ; } } })",
    "insertText": "return(*this)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::iterator CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "begin(void)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (m_pLeft)",
    "insertText": "while(Ptr(pCurrent)->m_pLeft != NULL) pCurrent = Ptr(pCurrent)"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::iterator CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "rbegin(void)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (m_pRight)",
    "insertText": "while(Ptr(pCurrent)->m_pRight != NULL) pCurrent = Ptr(pCurrent)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::iterator CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "end(void)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::iterator CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "find(const T& tData)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (TCompare tCompare ; CNodeReference pCurrent = m_pRoot ;)",
    "insertText": "while(pCurrent != NULL && Ptr(pCurrent)->m_tData != tData)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "iterator(pCurrent, &m_cPool)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::iterator CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "insert(const T& tData)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (TCompare tCompare ; CNodeReference pCurrent = m_pRoot ; CNodeReference pParent = NULL ;)",
    "insertText": "while(pCurrent != NULL && tData != Ptr(pCurrent)->m_tData)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_pLeft)",
    "insertText": "if(tCompare(tData, Ptr(pCurrent)->m_tData)) pCurrent = Ptr(pCurrent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(pCurrent == NULL)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (pCurrent =)",
    "insertText": "Allocate(tData, pParent)"
  },
  {
    "label": "Rebalance()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rebalance(pParent)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::iterator CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "erase(iterator iterWhere)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# ifdef SPEEDTREE_ITERATOR_DEBUGGING)",
    "insertText": "assert(iterWhere.m_pNode != NULL)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "while(Ptr(pRoot)->m_pParent != NULL) pRoot = Ptr(pRoot)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(pRoot == m_pRoot)"
  },
  {
    "label": "bRootDelete()",
    "kind": "Method",
    "detail": "Function (# endif CNodeReference pRemove = iterWhere . m_pNode ; + + iterWhere ; bool)",
    "insertText": "bRootDelete(pRemove == m_pRoot)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CNodeReference pBalance = NULL ;)",
    "insertText": "if(Ptr(pRemove)->m_pLeft == NULL && Ptr(pRemove)->m_pRight == NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr(pRemove)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bRootDelete)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Ptr(pRemove)->m_pLeft == NULL || Ptr(pRemove)->m_pRight == NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pBalance = pChild ;)",
    "insertText": "if(Ptr(pRemove)->m_pParent != NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr(pChild)->m_pParent = Ptr(pRemove)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pRight)",
    "insertText": "Ptr(pSwitch)->m_pRight = Ptr(pRemove)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr(pSwitch)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pLeft)",
    "insertText": "Ptr(pParent)->m_pRight = Ptr(pSwitch)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pLeft)",
    "insertText": "Ptr(pSwitch)->m_pLeft = Ptr(pRemove)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent = pSwitch)",
    "insertText": "Ptr(Ptr(pSwitch)->m_pLeft)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr(pSwitch)->m_pParent = Ptr(pRemove)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_uiLevel)",
    "insertText": "Ptr(pSwitch)->m_uiLevel = Ptr(pRemove)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Deallocate(pRemove)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (CNodeReference pLower = pBalance ;)",
    "insertText": "while(pLower != NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr(pLower)"
  },
  {
    "label": "Rebalance()",
    "kind": "Method",
    "detail": "Function (} else pLower = NULL ; })",
    "insertText": "Rebalance(pBalance)"
  },
  {
    "label": "Rebalance()",
    "kind": "Method",
    "detail": "Function (} - - m_uiSize ; return iterWhere ; } template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE void CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "Rebalance(CNodeReference pCurrent)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const unsigned char c_ucTestSteps = 5 ; unsigned char ucSteps = c_ucTestSteps ;)",
    "insertText": "while(pCurrent != NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_uiLevel)",
    "insertText": "Ptr(pCurrent)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pRight)",
    "insertText": "Ptr(pCurrent)->m_pLeft = Ptr(pSave)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pRight = pCurrent)",
    "insertText": "Ptr(pSave)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr(pSave)->m_pParent = Ptr(pCurrent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pCurrent = pSave ; } ucSteps = c_ucTestSteps ; } else)",
    "insertText": "if(Ptr(pCurrent)->m_pRight != NULL && Ptr(Ptr(pCurrent)->m_pRight)->m_pRight != NULL && Ptr(Ptr(Ptr(pCurrent)->m_pRight)->m_pRight)->m_uiLevel == Ptr(pCurrent)->m_uiLevel)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pLeft)",
    "insertText": "Ptr(pCurrent)->m_pRight = Ptr(pSave)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ucSteps = c_ucTestSteps ; })",
    "insertText": "if(--ucSteps == 0)"
  },
  {
    "label": "lower()",
    "kind": "Method",
    "detail": "Function (} } template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::iterator CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "lower(const T& tData)"
  },
  {
    "label": "higher()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::iterator CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "higher(const T& tData)"
  },
  {
    "label": "lower()",
    "kind": "Method",
    "detail": "Function (TCompare tCompare ; iterator iterHigher =)",
    "insertText": "lower(tData)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (iterator iterBegin =)",
    "insertText": "begin()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(tCompare(*iterHigher, tData))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (iterHigher = iterLower ;)",
    "insertText": "if(iterHigher == end( ))"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::CNodeReference CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "Allocate(const T& tData, CNodeReference pParent)"
  },
  {
    "label": "GrabBlock()",
    "kind": "Method",
    "detail": "Function (CNodeReference cReturn = m_cPool .)",
    "insertText": "GrabBlock()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(m_cPool.ResolveBlock(cReturn)) CNode(tData, pParent)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Ptr(pData)->~CNode()"
  },
  {
    "label": "ReleaseBlock()",
    "kind": "Method",
    "detail": "Function (m_cPool .)",
    "insertText": "ReleaseBlock(pData)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::CNode* CSet<T,TCompare,bUseCustomAllocator)",
    "insertText": "Ptr(CNodeReference pNode)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::)",
    "insertText": "iterator(CNodeReference pNode, const CPool* pPool) : m_pNode(pNode), m_pPool(pPool)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE bool CSet<T,TCompare,bUseCustomAllocator>::)",
    "insertText": "operator(const iterator& cRight)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::iterator& CSet<T,TCompare,bUseCustomAllocator>::)",
    "insertText": "operator(void)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_pNode != NULL)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (CNodeReference pLastNode = NULL ;)",
    "insertText": "while(m_pNode != NULL && pLastNode == Ptr( )->m_pRight)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(this)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (CNodeReference pLastNode = NULL ;)",
    "insertText": "while(m_pNode != NULL && pLastNode == Ptr( )->m_pLeft)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::CNode* CSet<T,TCompare,bUseCustomAllocator>::)",
    "insertText": "Ptr(void)"
  },
  {
    "label": "CNode()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE CSet<T,TCompare,bUseCustomAllocator>::)",
    "insertText": "CNode(const T& tData, CNodeReference pParent) : m_tData(tData), m_pLeft(NULL), m_pRight(NULL), m_pParent(pParent), m_uiLevel(0)"
  },
  {
    "label": "DeleteChildren()",
    "kind": "Method",
    "detail": "Function (} template<class T,class TCompare,bool bUseCustomAllocator> ST_INLINE void CSet<T,TCompare,bUseCustomAllocator>::)",
    "insertText": "DeleteChildren(CSet* pSet)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (pSet ->)",
    "insertText": "Deallocate(m_pLeft)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} m_pLeft = NULL ;)",
    "insertText": "if(m_pRight != NULL)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (pSet ->)",
    "insertText": "Deallocate(m_pRight)"
  }
]