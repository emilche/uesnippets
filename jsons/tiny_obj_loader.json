[
  {
    "label": "callback_t_",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "callback_t_"
  },
  {
    "label": "MaterialReader",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaterialReader"
  },
  {
    "label": "MaterialFileReader",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaterialFileReader"
  },
  {
    "label": "MaterialStreamReader",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaterialStreamReader"
  },
  {
    "label": "vertex_index_t",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "vertex_index_t"
  },
  {
    "label": "face_t",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "face_t"
  },
  {
    "label": "line_t",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "line_t"
  },
  {
    "label": "tag_sizes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "tag_sizes"
  },
  {
    "label": "obj_shape",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "obj_shape"
  },
  {
    "label": "__has_warning()",
    "kind": "Method",
    "detail": "Function (# ifndef TINY_OBJ_LOADER_H_ # define TINY_OBJ_LOADER_H_ # include<map> # include<string> # include<vector> namespace tinyobj { # ifdef __clang__ # pragma clang diagnostic push # if)",
    "insertText": "__has_warning(\"-Wzero-as-null-pointer-constant\")"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (# else typedef float real_t ; # endif typedef enum { TEXTURE_TYPE_NONE,TEXTURE_TYPE_SPHERE,TEXTURE_TYPE_CUBE_TOP,TEXTURE_TYPE_CUBE_BOTTOM,TEXTURE_TYPE_CUBE_FRONT,TEXTURE_TYPE_CUBE_BACK,TEXTURE_TYPE_CUBE_LEFT,TEXTURE_TYPE_CUBE_RIGHT } texture_type_t ; typedef struct { texture_type_t type ; real_t sharpness ; real_t brightness ; real_t contrast ; real_t origin_offset [ 3 ] ; real_t scale [ 3 ] ; real_t turbulence [ 3 ] ; bool clamp ; char imfchan ; bool blendu ; bool blendv ; real_t bump_multiplier ; std::string colorspace ; } texture_option_t ; typedef struct { std::string name ; real_t ambient [ 3 ] ; real_t diffuse [ 3 ] ; real_t specular [ 3 ] ; real_t transmittance [ 3 ] ; real_t emission [ 3 ] ; real_t shininess ; real_t ior ; real_t dissolve ; int illum ; int dummy ; std::string ambient_texname ; std::string diffuse_texname ; std::string specular_texname ; std::string specular_highlight_texname ; std::string bump_texname ; std::string displacement_texname ; std::string alpha_texname ; std::string reflection_texname ; texture_option_t ambient_texopt ; texture_option_t diffuse_texopt ; texture_option_t specular_texopt ; texture_option_t specular_highlight_texopt ; texture_option_t bump_texopt ; texture_option_t displacement_texopt ; texture_option_t alpha_texopt ; texture_option_t reflection_texopt ; real_t roughness ; real_t metallic ; real_t sheen ; real_t clearcoat_thickness ; real_t clearcoat_roughness ; real_t anisotropy ; real_t anisotropy_rotation ; real_t pad0 ; std::string roughness_texname ; std::string metallic_texname ; std::string sheen_texname ; std::string emissive_texname ; std::string normal_texname ; texture_option_t roughness_texopt ; texture_option_t metallic_texopt ; texture_option_t sheen_texopt ; texture_option_t emissive_texopt ; texture_option_t normal_texopt ; int pad2 ; std::map<std::string,std::string> unknown_parameter ; } material_t ; typedef struct { std::string name ; std::vector<int> intValues ; std::vector<real_t> floatValues ; std::vector<std::string> stringValues ; } tag_t ; typedef struct { int vertex_index ; int normal_index ; int texcoord_index ; } index_t ; typedef struct { std::vector<index_t> indices ; std::vector<unsigned char> num_face_vertices ; std::vector<int> material_ids ; std::vector<unsigned int> smoothing_group_ids ; std::vector<tag_t> tags ; } mesh_t ; typedef struct { std::vector<int> indices ; } path_t ; typedef struct { std::string name ; mesh_t mesh ; path_t path ; } shape_t ; typedef struct { std::vector<real_t> vertices ; std::vector<real_t> normals ; std::vector<real_t> texcoords ; std::vector<real_t> colors ; } attrib_t ; typedef struct callback_t_ {)",
    "insertText": "void(*vertex_cb)(void *user_data, real_t x, real_t y, real_t z, real_t w)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*normal_cb)(void *user_data, real_t x, real_t y, real_t z)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*texcoord_cb)(void *user_data, real_t x, real_t y, real_t z)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*index_cb)(void *user_data, index_t *indices, int num_indices)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*usemtl_cb)(void *user_data, const char *name, int material_id)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*mtllib_cb)(void *user_data, const material_t *materials, int num_materials)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*group_cb)(void *user_data, const char **names, int num_names)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*object_cb)(void *user_data, const char *name)"
  },
  {
    "label": "callback_t_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "callback_t_() : vertex_cb(NULL), normal_cb(NULL), texcoord_cb(NULL), index_cb(NULL), usemtl_cb(NULL), mtllib_cb(NULL), group_cb(NULL), object_cb(NULL)"
  },
  {
    "label": "MaterialReader()",
    "kind": "Method",
    "detail": "Function (} } callback_t ; class MaterialReader { public :)",
    "insertText": "MaterialReader()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator()(const std::string &matId, std::vector<material_t> *materials, std::map<std::string, int> *matMap, std::string *warn, std::string *err)"
  },
  {
    "label": "MaterialFileReader()",
    "kind": "Method",
    "detail": "Function (} ; class MaterialFileReader : public MaterialReader { public :)",
    "insertText": "MaterialFileReader(const std::string &mtl_basedir) : m_mtlBaseDir(mtl_basedir)"
  },
  {
    "label": "MaterialFileReader()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "MaterialFileReader()"
  },
  {
    "label": "MaterialStreamReader()",
    "kind": "Method",
    "detail": "Function (private : std::string m_mtlBaseDir ; } ; class MaterialStreamReader : public MaterialReader { public :)",
    "insertText": "MaterialStreamReader(std::istream &inStream) : m_inStream(inStream)"
  },
  {
    "label": "MaterialStreamReader()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "MaterialStreamReader()"
  },
  {
    "label": "LoadObj()",
    "kind": "Method",
    "detail": "Function (private : std::istream& m_inStream ; } ; bool)",
    "insertText": "LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes, std::vector<material_t> *materials, std::string *warn, std::string *err, const char *filename, const char *mtl_basedir = NULL, bool triangulate = true, bool default_vcols_fallback = true)"
  },
  {
    "label": "LoadObjWithCallback()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "LoadObjWithCallback(std::istream &inStream, const callback_t &callback, void *user_data = NULL, MaterialReader *readMatFn = NULL, std::string *warn = NULL, std::string *err = NULL)"
  },
  {
    "label": "LoadObj()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes, std::vector<material_t> *materials, std::string *warn, std::string *err, std::istream *inStream, MaterialReader *readMatFn = NULL, bool triangulate = true, bool default_vcols_fallback = true)"
  },
  {
    "label": "LoadMtl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LoadMtl(std::map<std::string, int> *material_map, std::vector<material_t> *materials, std::istream *inStream, std::string *warning, std::string *err)"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ParseTextureNameAndOption(std::string *texname, texture_option_t *texopt, const char *linebuf, const bool is_bump)"
  },
  {
    "label": "vertex_index_t()",
    "kind": "Method",
    "detail": "Function (} struct vertex_index_t { int v_idx,vt_idx,vn_idx ;)",
    "insertText": "vertex_index_t() : v_idx(-1), vt_idx(-1), vn_idx(-1)"
  },
  {
    "label": "vertex_index_t()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "vertex_index_t(int idx) : v_idx(idx), vt_idx(idx), vn_idx(idx)"
  },
  {
    "label": "vertex_index_t()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "vertex_index_t(int vidx, int vtidx, int vnidx) : v_idx(vidx), vt_idx(vtidx), vn_idx(vnidx)"
  },
  {
    "label": "face_t()",
    "kind": "Method",
    "detail": "Function (} } ; struct face_t { unsigned int smoothing_group_id ; int pad_ ; std::vector<vertex_index_t> vertex_indices ;)",
    "insertText": "face_t() : smoothing_group_id(0)"
  },
  {
    "label": "tag_sizes()",
    "kind": "Method",
    "detail": "Function (} } ; struct line_t { int idx0 ; int idx1 ; } ; struct tag_sizes {)",
    "insertText": "tag_sizes() : num_ints(0), num_reals(0), num_strings(0)"
  },
  {
    "label": "safeGetline()",
    "kind": "Method",
    "detail": "Function (} int num_ints ; int num_reals ; int num_strings ; } ; struct obj_shape { std::vector<real_t> v ; std::vector<real_t> vn ; std::vector<real_t> vt ; } ; std::istream&)",
    "insertText": "safeGetline(std::istream &is, std::string &t)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (t .)",
    "insertText": "clear()"
  },
  {
    "label": "se()",
    "kind": "Method",
    "detail": "Function (std::istream::sentry)",
    "insertText": "se(is, true)"
  },
  {
    "label": "rdbuf()",
    "kind": "Method",
    "detail": "Function (std::streambuf* sb = is .)",
    "insertText": "rdbuf()"
  },
  {
    "label": "sbumpc()",
    "kind": "Method",
    "detail": "Function (int c = sb ->)",
    "insertText": "sbumpc()"
  },
  {
    "label": "IS_SPACE()",
    "kind": "Method",
    "detail": "Function (} } } return is ; } # define)",
    "insertText": "IS_SPACE(x) (((x) == ' ') || ((x) == '\\t')) #define IS_DIGIT(x) \\ (static_cast<unsigned int>((x) - '0') < static_cast<unsigned int>(10)) #define IS_NEW_LINE(x) (((x) == '\\r') || ((x) == '\\n') || ((x) == '\\0')) static inline bool fixIndex(int idx, int n, int *ret)"
  },
  {
    "label": "s()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "s(*token) += strspn((*token), \" \\t\")"
  },
  {
    "label": "strcspn()",
    "kind": "Method",
    "detail": "Function (size_t e =)",
    "insertText": "strcspn((*token), \" \\t\\r\")"
  },
  {
    "label": "string()",
    "kind": "Method",
    "detail": "Function (s =)",
    "insertText": "string((*token), &(*token)[e])"
  },
  {
    "label": "atoi()",
    "kind": "Method",
    "detail": "Function (int i =)",
    "insertText": "atoi((*token))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (sign =* curr ; curr + + ; } else)",
    "insertText": "if(IS_DIGIT(*curr))"
  },
  {
    "label": "end_not_reached()",
    "kind": "Method",
    "detail": "Function (} else { goto fail ; })",
    "insertText": "end_not_reached(curr != s_end)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (mantissa* = 1 0 ; mantissa + = static_cast<)",
    "insertText": "int(*curr - 0x30)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(read == 0)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (const double pow_lut [ ] = { 1 . 0,0 . 1,0 . 0 1,0 . 0 0 1,0 . 0 0 0 1,0 . 0 0 0 0 1,0 . 0 0 0 0 0 1,0 . 0 0 0 0 0 0 1,} ; const int lut_entries = sizeof pow_lut / sizeof pow_lut [ 0 ] ; mantissa + = static_cast<)",
    "insertText": "int(*curr - 0x30) * (read < lut_entries ? pow_lut[read] : std::pow(10.0, -read))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(*curr == 'e' || *curr == 'E')"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { goto assemble ; })",
    "insertText": "if(!end_not_reached)"
  },
  {
    "label": "exponent()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "exponent(exp_sign == '+' ? 1 : -1)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} assemble :*)",
    "insertText": "result(sign == '+' ? 1 : -1) * (exponent ? std::ldexp(mantissa * std::pow(5.0, exponent), exponent) : mantissa)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "end(*token) + strcspn((*token), \" \\t\\r\")"
  },
  {
    "label": "real_t()",
    "kind": "Method",
    "detail": "Function (real_t f = static_cast<)",
    "insertText": "real_t(val)"
  },
  {
    "label": "parseReal3()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "parseReal3(real_t *x, real_t *y, real_t *z, const char **token, const double default_x = 0.0, const double default_y = 0.0, const double default_z = 0.0)"
  },
  {
    "label": "parseV()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "parseV(real_t *x, real_t *y, real_t *z, real_t *w, const char **token, const double default_x = 0.0, const double default_y = 0.0, const double default_z = 0.0, const double default_w = 1.0)"
  },
  {
    "label": "parseVertexWithColor()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "parseVertexWithColor(real_t *x, real_t *y, real_t *z, real_t *r, real_t *g, real_t *b, const char **token, const double default_x = 0.0, const double default_y = 0.0, const double default_z = 0.0)"
  },
  {
    "label": "parseReal()",
    "kind": "Method",
    "detail": "Function (const bool found_color =)",
    "insertText": "parseReal(token, r) && parseReal(token, g) && parseReal(token, b)"
  },
  {
    "label": "parseOnOff()",
    "kind": "Method",
    "detail": "Function (} return found_color ; } bool)",
    "insertText": "parseOnOff(const char **token, bool default_value = true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool ret = default_value ;)",
    "insertText": "if((0 == strncmp((*token), \"on\", 2)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = true ; } else)",
    "insertText": "if((0 == strncmp((*token), \"off\", 3)))"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (ret =)",
    "insertText": "false(*token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (texture_type_t ty = default_value ;)",
    "insertText": "if((0 == strncmp((*token), \"cube_top\", strlen(\"cube_top\"))))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ty = TEXTURE_TYPE_CUBE_TOP ; } else)",
    "insertText": "if((0 == strncmp((*token), \"cube_bottom\", strlen(\"cube_bottom\"))))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ty = TEXTURE_TYPE_CUBE_BOTTOM ; } else)",
    "insertText": "if((0 == strncmp((*token), \"cube_left\", strlen(\"cube_left\"))))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ty = TEXTURE_TYPE_CUBE_LEFT ; } else)",
    "insertText": "if((0 == strncmp((*token), \"cube_right\", strlen(\"cube_right\"))))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ty = TEXTURE_TYPE_CUBE_RIGHT ; } else)",
    "insertText": "if((0 == strncmp((*token), \"cube_front\", strlen(\"cube_front\"))))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ty = TEXTURE_TYPE_CUBE_FRONT ; } else)",
    "insertText": "if((0 == strncmp((*token), \"cube_back\", strlen(\"cube_back\"))))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ty = TEXTURE_TYPE_CUBE_BACK ; } else)",
    "insertText": "if((0 == strncmp((*token), \"sphere\", strlen(\"sphere\"))))"
  },
  {
    "label": "TEXTURE_TYPE_SPHERE()",
    "kind": "Method",
    "detail": "Function (ty =)",
    "insertText": "TEXTURE_TYPE_SPHERE(*token)"
  },
  {
    "label": "ts()",
    "kind": "Method",
    "detail": "Function (tag_sizes)",
    "insertText": "ts(*token) += strspn((*token), \" \\t\")"
  },
  {
    "label": "parseInt()",
    "kind": "Method",
    "detail": "Function (ts . num_strings =)",
    "insertText": "parseInt(token)"
  },
  {
    "label": "vi()",
    "kind": "Method",
    "detail": "Function (vertex_index_t)",
    "insertText": "vi(static_cast<int>(0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool found_texname = false ; std::string texture_name ;)",
    "insertText": "if(is_bump)"
  },
  {
    "label": "real_t()",
    "kind": "Method",
    "detail": "Function (texopt -> imfchan = ' l ' ; } else { texopt -> imfchan = ' m ' ; } texopt -> bump_multiplier = static_cast<)",
    "insertText": "real_t(1.0)"
  },
  {
    "label": "real_t()",
    "kind": "Method",
    "detail": "Function (texopt -> brightness = static_cast<)",
    "insertText": "real_t(0.0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (texopt -> type = TEXTURE_TYPE_NONE ; const char* token = linebuf ;)",
    "insertText": "while(!IS_NEW_LINE((*token)))"
  },
  {
    "label": "strspn()",
    "kind": "Method",
    "detail": "Function (token + =)",
    "insertText": "strspn(token, \" \\t\")"
  },
  {
    "label": "parseOnOff()",
    "kind": "Method",
    "detail": "Function (token + = 8 ; texopt -> blendu =)",
    "insertText": "parseOnOff(&token, true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((0 == strncmp(token, \"-blendv\", 7)) && IS_SPACE((token[7])))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((0 == strncmp(token, \"-clamp\", 6)) && IS_SPACE((token[6])))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((0 == strncmp(token, \"-boost\", 6)) && IS_SPACE((token[6])))"
  },
  {
    "label": "parseReal()",
    "kind": "Method",
    "detail": "Function (token + = 7 ; texopt -> sharpness =)",
    "insertText": "parseReal(&token, 1.0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((0 == strncmp(token, \"-bm\", 3)) && IS_SPACE((token[3])))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((0 == strncmp(token, \"-o\", 2)) && IS_SPACE((token[2])))"
  },
  {
    "label": "parseReal3()",
    "kind": "Method",
    "detail": "Function (token + = 3 ;)",
    "insertText": "parseReal3(&(texopt->origin_offset[0]), &(texopt->origin_offset[1]), &(texopt->origin_offset[2]), &token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((0 == strncmp(token, \"-s\", 2)) && IS_SPACE((token[2])))"
  },
  {
    "label": "parseReal3()",
    "kind": "Method",
    "detail": "Function (token + = 3 ;)",
    "insertText": "parseReal3(&(texopt->scale[0]), &(texopt->scale[1]), &(texopt->scale[2]), &token, 1.0, 1.0, 1.0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((0 == strncmp(token, \"-t\", 2)) && IS_SPACE((token[2])))"
  },
  {
    "label": "parseReal3()",
    "kind": "Method",
    "detail": "Function (token + = 3 ;)",
    "insertText": "parseReal3(&(texopt->turbulence[0]), &(texopt->turbulence[1]), &(texopt->turbulence[2]), &token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((0 == strncmp(token, \"-type\", 5)) && IS_SPACE((token[5])))"
  },
  {
    "label": "parseTextureType()",
    "kind": "Method",
    "detail": "Function (token + = 5 ; texopt -> type =)",
    "insertText": "parseTextureType((&token), TEXTURE_TYPE_NONE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((0 == strncmp(token, \"-imfchan\", 8)) && IS_SPACE((token[8])))"
  },
  {
    "label": "strcspn()",
    "kind": "Method",
    "detail": "Function (const char* end = token +)",
    "insertText": "strcspn(token, \" \\t\\r\")"
  },
  {
    "label": "imfchan()",
    "kind": "Method",
    "detail": "Function (texopt ->)",
    "insertText": "imfchan(*token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} token = end ; } else)",
    "insertText": "if((0 == strncmp(token, \"-mm\", 3)) && IS_SPACE((token[3])))"
  },
  {
    "label": "parseReal2()",
    "kind": "Method",
    "detail": "Function (token + = 4 ;)",
    "insertText": "parseReal2(&(texopt->brightness), &(texopt->contrast), &token, 0.0, 1.0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((0 == strncmp(token, \"-colorspace\", 11)) && IS_SPACE((token[11])))"
  },
  {
    "label": "parseString()",
    "kind": "Method",
    "detail": "Function (token + = 1 2 ; texopt -> colorspace =)",
    "insertText": "parseString(&token)"
  },
  {
    "label": "string()",
    "kind": "Method",
    "detail": "Function (texture_name =)",
    "insertText": "string(token, token + len)"
  },
  {
    "label": "string()",
    "kind": "Method",
    "detail": "Function (# else texture_name =)",
    "insertText": "string(token)"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (token + = texture_name .)",
    "insertText": "length()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif found_texname = true ; } })",
    "insertText": "if(found_texname)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (material -> name = \" \" ; material -> ambient_texname = \" \" ; material -> diffuse_texname = \" \" ; material -> specular_texname = \" \" ; material -> specular_highlight_texname = \" \" ; material -> bump_texname = \" \" ; material -> displacement_texname = \" \" ; material -> reflection_texname = \" \" ; material -> alpha_texname = \" \" ;)",
    "insertText": "for(int i = 0; i < 3; i++)"
  },
  {
    "label": "pnpoly()",
    "kind": "Method",
    "detail": "Function (} template<T> int)",
    "insertText": "pnpoly(int nvert, T *vertx, T *verty, T testx, T testy)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int i,j,c = 0 ;)",
    "insertText": "for(i = 0, j = nvert - 1; i < nvert; j = i++)"
  },
  {
    "label": "exportGroupsToShape()",
    "kind": "Method",
    "detail": "Function (} return c ; } bool)",
    "insertText": "exportGroupsToShape(shape_t *shape, const std::vector<face_t> &faceGroup, std::vector<int> &lineGroup, const std::vector<tag_t> &tags, const int material_id, const std::string &name, bool triangulate, const std::vector<real_t> &v)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (const face_t& face = faceGroup [ i ] ; size_t npolys = face . vertex_indices .)",
    "insertText": "size()"
  },
  {
    "label": "i1()",
    "kind": "Method",
    "detail": "Function (continue ; } vertex_index_t i0 = face . vertex_indices [ 0 ] ; vertex_index_t)",
    "insertText": "i1(-1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (vertex_index_t i2 = face . vertex_indices [ 1 ] ;)",
    "insertText": "if(triangulate)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t axes [ 2 ] = { 1,2 } ;)",
    "insertText": "for(size_t k = 0; k < npolys; ++k)"
  },
  {
    "label": "vertex_indices()",
    "kind": "Method",
    "detail": "Function (i0 = face .)",
    "insertText": "vertex_indices(k + 0)"
  },
  {
    "label": "vertex_indices()",
    "kind": "Method",
    "detail": "Function (i1 = face .)",
    "insertText": "vertex_indices(k + 1)"
  },
  {
    "label": "vertex_indices()",
    "kind": "Method",
    "detail": "Function (i2 = face .)",
    "insertText": "vertex_indices(k + 2)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t vi0 =)",
    "insertText": "size_t(i0.v_idx)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t vi1 =)",
    "insertText": "size_t(i1.v_idx)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t vi2 =)",
    "insertText": "size_t(i2.v_idx)"
  },
  {
    "label": "fabs()",
    "kind": "Method",
    "detail": "Function (continue ; } real_t v0x = v [ vi0* 3 + 0 ] ; real_t v0y = v [ vi0* 3 + 1 ] ; real_t v0z = v [ vi0* 3 + 2 ] ; real_t v1x = v [ vi1* 3 + 0 ] ; real_t v1y = v [ vi1* 3 + 1 ] ; real_t v1z = v [ vi1* 3 + 2 ] ; real_t v2x = v [ vi2* 3 + 0 ] ; real_t v2y = v [ vi2* 3 + 1 ] ; real_t v2z = v [ vi2* 3 + 2 ] ; real_t e0x = v1x - v0x ; real_t e0y = v1y - v0y ; real_t e0z = v1z - v0z ; real_t e1x = v2x - v1x ; real_t e1y = v2y - v1y ; real_t e1z = v2z - v1z ; real_t cx =)",
    "insertText": "fabs(e0y * e1z - e0z * e1y)"
  },
  {
    "label": "fabs()",
    "kind": "Method",
    "detail": "Function (real_t cy =)",
    "insertText": "fabs(e0z * e1x - e0x * e1z)"
  },
  {
    "label": "fabs()",
    "kind": "Method",
    "detail": "Function (real_t cz =)",
    "insertText": "fabs(e0x * e1y - e0y * e1x)"
  },
  {
    "label": "epsilon()",
    "kind": "Method",
    "detail": "Function (const real_t epsilon = std::numeric_limits<real_t)",
    "insertText": "epsilon()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { axes [ 0 ] = 0 ;)",
    "insertText": "if(cz > cx && cz > cy)"
  },
  {
    "label": "area()",
    "kind": "Method",
    "detail": "Function (continue ; } real_t v0x = v [ vi0* 3 + axes [ 0 ] ] ; real_t v0y = v [ vi0* 3 + axes [ 1 ] ] ; real_t v1x = v [ vi1* 3 + axes [ 0 ] ] ; real_t v1y = v [ vi1* 3 + axes [ 1 ] ] ;)",
    "insertText": "area(v0x * v1y - v0y * v1x) * static_cast<real_t>(0.5)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} int maxRounds = 1 0 ; face_t remainingFace = face ; size_t guess_vert = 0 ; vertex_index_t ind [ 3 ] ; real_t vx [ 3 ] ; real_t vy [ 3 ] ;)",
    "insertText": "while(remainingFace.vertex_indices.size() > 3 && maxRounds > 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (maxRounds - = 1 ; guess_vert - = npolys ; })",
    "insertText": "for(size_t k = 0; k < 3; k++)"
  },
  {
    "label": "vertex_indices()",
    "kind": "Method",
    "detail": "Function (ind [ k ] = remainingFace .)",
    "insertText": "vertex_indices(guess_vert + k)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t vi =)",
    "insertText": "size_t(ind[k].v_idx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { vx [ k ] = v [ vi* 3 + axes [ 0 ] ] ; vy [ k ] = v [ vi* 3 + axes [ 1 ] ] ; } } real_t e0x = vx [ 1 ] - vx [ 0 ] ; real_t e0y = vy [ 1 ] - vy [ 0 ] ; real_t e1x = vx [ 2 ] - vx [ 1 ] ; real_t e1y = vy [ 2 ] - vy [ 1 ] ; real_t cross = e0x* e1y - e0y* e1x ;)",
    "insertText": "if(cross * area < static_cast<real_t>(0.0))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (guess_vert + = 1 ; continue ; } bool overlap = false ;)",
    "insertText": "for(size_t otherVert = 3; otherVert < npolys; ++otherVert)"
  },
  {
    "label": "idx()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "idx(guess_vert + otherVert)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (continue ; } size_t ovi =)",
    "insertText": "size_t(remainingFace.vertex_indices[idx].v_idx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } real_t tx = v [ ovi* 3 + axes [ 0 ] ] ; real_t ty = v [ ovi* 3 + axes [ 1 ] ] ;)",
    "insertText": "if(pnpoly(3, vx, vy, tx, ty))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (overlap = true ; break ; } })",
    "insertText": "if(overlap)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (guess_vert + = 1 ; continue ; } { index_t idx0,idx1,idx2 ; idx0 . vertex_index = ind [ 0 ] . v_idx ; idx0 . normal_index = ind [ 0 ] . vn_idx ; idx0 . texcoord_index = ind [ 0 ] . vt_idx ; idx1 . vertex_index = ind [ 1 ] . v_idx ; idx1 . normal_index = ind [ 1 ] . vn_idx ; idx1 . texcoord_index = ind [ 1 ] . vt_idx ; idx2 . vertex_index = ind [ 2 ] . v_idx ; idx2 . normal_index = ind [ 2 ] . vn_idx ; idx2 . texcoord_index = ind [ 2 ] . vt_idx ; shape -> mesh . indices .)",
    "insertText": "push_back(idx0)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (shape -> mesh . indices .)",
    "insertText": "push_back(idx1)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (shape -> mesh . indices .)",
    "insertText": "push_back(idx2)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (shape -> mesh . num_face_vertices .)",
    "insertText": "push_back(3)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (shape -> mesh . material_ids .)",
    "insertText": "push_back(material_id)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (shape -> mesh . smoothing_group_ids .)",
    "insertText": "push_back(face.smoothing_group_id)"
  },
  {
    "label": "removed_vert_index()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "removed_vert_index(guess_vert + 1)"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (remainingFace . vertex_indices [ removed_vert_index ] = remainingFace . vertex_indices [ removed_vert_index + 1 ] ; removed_vert_index + = 1 ; } remainingFace . vertex_indices .)",
    "insertText": "pop_back()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(remainingFace.vertex_indices.size() == 3)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "for(size_t k = 0; k < npolys; k++)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (index_t idx ; idx . vertex_index = face . vertex_indices [ k ] . v_idx ; idx . normal_index = face . vertex_indices [ k ] . vn_idx ; idx . texcoord_index = face . vertex_indices [ k ] . vt_idx ; shape -> mesh . indices .)",
    "insertText": "push_back(idx)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} shape -> mesh . num_face_vertices .)",
    "insertText": "push_back(static_cast<unsigned char>(npolys))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } shape -> name = name ; shape -> mesh . tags = tags ; })",
    "insertText": "if(!lineGroup.empty())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (shape -> path . indices .)",
    "insertText": "swap(lineGroup)"
  },
  {
    "label": "SplitString()",
    "kind": "Method",
    "detail": "Function (} return true ; } void)",
    "insertText": "SplitString(const std::string &s, char delim, std::vector<std::string> &elems)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (std::stringstream ss ; ss .)",
    "insertText": "str(s)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (std::string item ;)",
    "insertText": "while(std::getline(ss, item, delim))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (elems .)",
    "insertText": "push_back(item)"
  },
  {
    "label": "InitMaterial()",
    "kind": "Method",
    "detail": "Function (material_t material ;)",
    "insertText": "InitMaterial(&material)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bool has_d = false ; bool has_tr = false ; std::stringstream warn_ss ; size_t line_no = 0 ; std::string linebuf ;)",
    "insertText": "while(inStream->peek() != -1)"
  },
  {
    "label": "safeGetline()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "safeGetline(*inStream, linebuf)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (line_no + + ;)",
    "insertText": "if(linebuf.size() > 0)"
  },
  {
    "label": "substr()",
    "kind": "Method",
    "detail": "Function (linebuf = linebuf .)",
    "insertText": "substr(0, linebuf.find_last_not_of(\" \\t\") + 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(linebuf.empty())"
  },
  {
    "label": "c_str()",
    "kind": "Method",
    "detail": "Function (continue ; } const char* token = linebuf .)",
    "insertText": "c_str()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(token)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (material_map ->)",
    "insertText": "insert(std::pair<std::string, int>( material.name, static_cast<int>(materials->size())))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (materials ->)",
    "insertText": "push_back(material)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (has_d = false ; has_tr = false ; token + = 7 ; { std::stringstream sstr ; sstr<<token ; material . name = sstr .)",
    "insertText": "str()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} continue ; })",
    "insertText": "if(token[0] == 'K' && token[1] == 'a' && IS_SPACE((token[2])))"
  },
  {
    "label": "parseReal3()",
    "kind": "Method",
    "detail": "Function (token + = 2 ; real_t r,g,b ;)",
    "insertText": "parseReal3(&r, &g, &b, &token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (material . ambient [ 0 ] = r ; material . ambient [ 1 ] = g ; material . ambient [ 2 ] = b ; continue ; })",
    "insertText": "if(token[0] == 'K' && token[1] == 'd' && IS_SPACE((token[2])))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (material . diffuse [ 0 ] = r ; material . diffuse [ 1 ] = g ; material . diffuse [ 2 ] = b ; continue ; })",
    "insertText": "if(token[0] == 'K' && token[1] == 's' && IS_SPACE((token[2])))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (material . specular [ 0 ] = r ; material . specular [ 1 ] = g ; material . specular [ 2 ] = b ; continue ; })",
    "insertText": "if((token[0] == 'K' && token[1] == 't' && IS_SPACE((token[2]))) || (token[0] == 'T' && token[1] == 'f' && IS_SPACE((token[2]))))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (material . transmittance [ 0 ] = r ; material . transmittance [ 1 ] = g ; material . transmittance [ 2 ] = b ; continue ; })",
    "insertText": "if(token[0] == 'N' && token[1] == 'i' && IS_SPACE((token[2])))"
  },
  {
    "label": "parseReal()",
    "kind": "Method",
    "detail": "Function (token + = 2 ; material . ior =)",
    "insertText": "parseReal(&token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(token[0] == 'K' && token[1] == 'e' && IS_SPACE(token[2]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (material . emission [ 0 ] = r ; material . emission [ 1 ] = g ; material . emission [ 2 ] = b ; continue ; })",
    "insertText": "if(token[0] == 'N' && token[1] == 's' && IS_SPACE(token[2]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(0 == strncmp(token, \"illum\", 5) && IS_SPACE(token[5]))"
  },
  {
    "label": "parseInt()",
    "kind": "Method",
    "detail": "Function (token + = 6 ; material . illum =)",
    "insertText": "parseInt(&token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((token[0] == 'd' && IS_SPACE(token[1])))"
  },
  {
    "label": "dissolve()",
    "kind": "Method",
    "detail": "Function (warn_ss<<\" Both ` d ` and ` Tr ` parameters defined for \\ \" \"<<material . name<<\" \\ \" . Use the value of ` d ` for)",
    "insertText": "dissolve(line \" << line_no << \" in .mtl.)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} has_d = true ; continue ; })",
    "insertText": "if(token[0] == 'T' && token[1] == 'r' && IS_SPACE(token[2]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (token + = 2 ;)",
    "insertText": "if(has_d)"
  },
  {
    "label": "real_t()",
    "kind": "Method",
    "detail": "Function (} else { material . dissolve = static_cast<)",
    "insertText": "real_t(1.0) - parseReal(&token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} has_tr = true ; continue ; })",
    "insertText": "if(token[0] == 'P' && token[1] == 'r' && IS_SPACE(token[2]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(token[0] == 'P' && token[1] == 'm' && IS_SPACE(token[2]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(token[0] == 'P' && token[1] == 's' && IS_SPACE(token[2]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(token[0] == 'P' && token[1] == 'c' && IS_SPACE(token[2]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"Pcr\", 3)) && IS_SPACE(token[3]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"aniso\", 5)) && IS_SPACE(token[5]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"anisor\", 6)) && IS_SPACE(token[6]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"map_Ka\", 6)) && IS_SPACE(token[6]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 7 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.ambient_texname), &(material.ambient_texopt), token, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"map_Kd\", 6)) && IS_SPACE(token[6]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 7 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.diffuse_texname), &(material.diffuse_texopt), token, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"map_Ks\", 6)) && IS_SPACE(token[6]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 7 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.specular_texname), &(material.specular_texopt), token, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"map_Ns\", 6)) && IS_SPACE(token[6]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 7 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.specular_highlight_texname), &(material.specular_highlight_texopt), token, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"map_bump\", 8)) && IS_SPACE(token[8]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 9 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.bump_texname), &(material.bump_texopt), token, true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"map_Bump\", 8)) && IS_SPACE(token[8]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"bump\", 4)) && IS_SPACE(token[4]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"map_d\", 5)) && IS_SPACE(token[5]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 6 ; material . alpha_texname = token ;)",
    "insertText": "ParseTextureNameAndOption(&(material.alpha_texname), &(material.alpha_texopt), token, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"disp\", 4)) && IS_SPACE(token[4]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 5 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.displacement_texname), &(material.displacement_texopt), token, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"refl\", 4)) && IS_SPACE(token[4]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 5 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.reflection_texname), &(material.reflection_texopt), token, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"map_Pr\", 6)) && IS_SPACE(token[6]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 7 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.roughness_texname), &(material.roughness_texopt), token, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"map_Pm\", 6)) && IS_SPACE(token[6]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 7 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.metallic_texname), &(material.metallic_texopt), token, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"map_Ps\", 6)) && IS_SPACE(token[6]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 7 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.sheen_texname), &(material.sheen_texopt), token, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"map_Ke\", 6)) && IS_SPACE(token[6]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 7 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.emissive_texname), &(material.emissive_texopt), token, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"norm\", 4)) && IS_SPACE(token[4]))"
  },
  {
    "label": "ParseTextureNameAndOption()",
    "kind": "Method",
    "detail": "Function (token + = 5 ;)",
    "insertText": "ParseTextureNameAndOption(&(material.normal_texname), &(material.normal_texopt), token, false)"
  },
  {
    "label": "strchr()",
    "kind": "Method",
    "detail": "Function (continue ; } const char* _space =)",
    "insertText": "strchr(token, ' ')"
  },
  {
    "label": "strchr()",
    "kind": "Method",
    "detail": "Function (_space =)",
    "insertText": "strchr(token, '\\t')"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(_space)"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (std::ptrdiff_t len = _space - token ; std::string)",
    "insertText": "key(token, static_cast<size_t>(len))"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (std::string value = _space + 1 ; material . unknown_parameter .)",
    "insertText": "insert(std::pair<std::string, std::string>(key, value))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (std::string filepath ;)",
    "insertText": "if(!m_mtlBaseDir.empty())"
  },
  {
    "label": "string()",
    "kind": "Method",
    "detail": "Function (filepath =)",
    "insertText": "string(m_mtlBaseDir)"
  },
  {
    "label": "matIStream()",
    "kind": "Method",
    "detail": "Function (} else { filepath = matId ; } std::ifstream)",
    "insertText": "matIStream(filepath.c_str())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (std::stringstream ss ; ss<<\" Material file [ \"<<filepath<<\" ] not found . \"<<std::endl ;)",
    "insertText": "if(warn)"
  },
  {
    "label": "LoadMtl()",
    "kind": "Method",
    "detail": "Function (} return false ; })",
    "insertText": "LoadMtl(matMap, materials, &matIStream, warn, err)"
  },
  {
    "label": "LoadMtl()",
    "kind": "Method",
    "detail": "Function (} return false ; })",
    "insertText": "LoadMtl(matMap, materials, &m_inStream, warn, err)"
  },
  {
    "label": "ifs()",
    "kind": "Method",
    "detail": "Function (std::stringstream errss ; std::ifstream)",
    "insertText": "ifs(filename)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (errss<<\" Cannot open file [ \"<<filename<<\" ] \"<<std::endl ;)",
    "insertText": "if(err)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return false ; } std::string baseDir = mtl_basedir ? mtl_basedir : \" \" ;)",
    "insertText": "if(!baseDir.empty())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifndef _WIN32 const char dirsep = ' / ' ; # else const char dirsep = ' \\ \\ ' ; # endif)",
    "insertText": "if(baseDir[baseDir.length() - 1] != dirsep)"
  },
  {
    "label": "matFileReader()",
    "kind": "Method",
    "detail": "Function (} MaterialFileReader)",
    "insertText": "matFileReader(baseDir)"
  },
  {
    "label": "LoadObj()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes, std::vector<material_t> *materials, std::string *warn, std::string *err, std::istream *inStream, MaterialReader *readMatFn , bool triangulate, bool default_vcols_fallback)"
  },
  {
    "label": "parseVertexWithColor()",
    "kind": "Method",
    "detail": "Function (token + = 2 ; real_t x,y,z ; real_t r,g,b ; found_all_colors& =)",
    "insertText": "parseVertexWithColor(&x, &y, &z, &r, &g, &b, &token)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "push_back(x)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "push_back(y)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "push_back(z)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (vc .)",
    "insertText": "push_back(r)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (vc .)",
    "insertText": "push_back(g)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (vc .)",
    "insertText": "push_back(b)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} continue ; })",
    "insertText": "if(token[0] == 'v' && token[1] == 'n' && IS_SPACE((token[2])))"
  },
  {
    "label": "parseReal3()",
    "kind": "Method",
    "detail": "Function (token + = 3 ; real_t x,y,z ;)",
    "insertText": "parseReal3(&x, &y, &z, &token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(token[0] == 'v' && token[1] == 't' && IS_SPACE((token[2])))"
  },
  {
    "label": "parseReal2()",
    "kind": "Method",
    "detail": "Function (token + = 3 ; real_t x,y ;)",
    "insertText": "parseReal2(&x, &y, &token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(token[0] == 'l' && IS_SPACE((token[1])))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (token + = 2 ; line_t line_cache ; bool end_line_bit = 0 ;)",
    "insertText": "while(!IS_NEW_LINE(token[0]))"
  },
  {
    "label": "fixIndex()",
    "kind": "Method",
    "detail": "Function (int idx ;)",
    "insertText": "fixIndex(parseInt(&token), 0, &idx)"
  },
  {
    "label": "strspn()",
    "kind": "Method",
    "detail": "Function (size_t n =)",
    "insertText": "strspn(token, \" \\t\\r\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (token + = n ;)",
    "insertText": "if(!end_line_bit)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (line_cache . idx0 = idx ; } else { line_cache . idx1 = idx ; lineGroup .)",
    "insertText": "push_back(line_cache.idx0)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (lineGroup .)",
    "insertText": "push_back(line_cache.idx1)"
  },
  {
    "label": "line_t()",
    "kind": "Method",
    "detail": "Function (line_cache =)",
    "insertText": "line_t()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} end_line_bit = ! end_line_bit ; } continue ; })",
    "insertText": "if(token[0] == 'f' && IS_SPACE((token[1])))"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (face_t face ; face . smoothing_group_id = current_smoothing_id ; face . vertex_indices .)",
    "insertText": "reserve(3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (vertex_index_t vi ;)",
    "insertText": "if(!parseTriple(&token, static_cast<int>(v.size() / 3), static_cast<int>(vn.size() / 3), static_cast<int>(vt.size() / 2), &vi))"
  },
  {
    "label": "line()",
    "kind": "Method",
    "detail": "Function (std::stringstream ss ; ss<<\" Failed parse ` f ')",
    "insertText": "line(e.g. zero value for face index. line \" << line_num << \".)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} return false ; } greatest_v_idx = greatest_v_idx> vi . v_idx ? greatest_v_idx : vi . v_idx ; greatest_vn_idx = greatest_vn_idx> vi . vn_idx ? greatest_vn_idx : vi . vn_idx ; greatest_vt_idx = greatest_vt_idx> vi . vt_idx ? greatest_vt_idx : vi . vt_idx ; face . vertex_indices .)",
    "insertText": "push_back(vi)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (token + = n ; } faceGroup .)",
    "insertText": "push_back(face)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if((0 == strncmp(token, \"usemtl\", 6)) && IS_SPACE((token[6])))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int newMaterialId = - 1 ;)",
    "insertText": "if(material_map.find(namebuf) != material_map.end())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (newMaterialId = material_map [ namebuf ] ; } else { })",
    "insertText": "if(newMaterialId != material)"
  },
  {
    "label": "exportGroupsToShape()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "exportGroupsToShape(&shape, faceGroup, lineGroup, tags, material, name, triangulate, v)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (material = newMaterialId ; } continue ; })",
    "insertText": "if((0 == strncmp(token, \"mtllib\", 6)) && IS_SPACE((token[6])))"
  },
  {
    "label": "SplitString()",
    "kind": "Method",
    "detail": "Function (token + = 7 ; std::vector<std::string> filenames ;)",
    "insertText": "SplitString(std::string(token), ' ', filenames)"
  },
  {
    "label": "material()",
    "kind": "Method",
    "detail": "Function (std::stringstream ss ; ss<<\" Looks like empty filename for mtllib . Use default \" \")",
    "insertText": "material(line \" << line_num << \".)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } else { bool found = false ;)",
    "insertText": "for(size_t s = 0; s < filenames.size(); s++)"
  },
  {
    "label": "ok()",
    "kind": "Method",
    "detail": "Function (std::string warn_mtl ; std::string err_mtl ; bool)",
    "insertText": "ok(*readMatFn)(filenames[s].c_str(), materials, &material_map, &warn_mtl, &err_mtl)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(err && (!err_mtl.empty()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ok)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (found = true ; break ; } })",
    "insertText": "if(!found)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } } continue ; })",
    "insertText": "if(token[0] == 'g' && IS_SPACE((token[1])))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (shapes ->)",
    "insertText": "push_back(shape)"
  },
  {
    "label": "shape_t()",
    "kind": "Method",
    "detail": "Function (} shape =)",
    "insertText": "shape_t()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (names .)",
    "insertText": "push_back(str)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(names.size() < 2)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (std::stringstream ss ; ss<<\" Empty group name . line : \"<<line_num<<\" \\)",
    "insertText": "n(*warn) += ss.str()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (name = \" \" ; } } else { std::stringstream ss ; ss<<names [ 1 ] ;)",
    "insertText": "for(size_t i = 2; i < names.size(); i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} continue ; })",
    "insertText": "if(token[0] == 'o' && IS_SPACE((token[1])))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(token[0] == 't' && IS_SPACE(token[1]))"
  },
  {
    "label": "parseTagTriple()",
    "kind": "Method",
    "detail": "Function (tag_sizes ts =)",
    "insertText": "parseTagTriple(&token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ts . num_ints = 0 ; })",
    "insertText": "if(ts.num_ints > max_tag_nums)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ts . num_ints = max_tag_nums ; })",
    "insertText": "if(ts.num_reals < 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ts . num_reals = 0 ; })",
    "insertText": "if(ts.num_reals > max_tag_nums)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ts . num_reals = max_tag_nums ; })",
    "insertText": "if(ts.num_strings < 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ts . num_strings = 0 ; })",
    "insertText": "if(ts.num_strings > max_tag_nums)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (ts . num_strings = max_tag_nums ; } tag . intValues .)",
    "insertText": "resize(static_cast<size_t>(ts.num_ints))"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} tag . floatValues .)",
    "insertText": "resize(static_cast<size_t>(ts.num_reals))"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} tag . stringValues .)",
    "insertText": "resize(static_cast<size_t>(ts.num_strings))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} tags .)",
    "insertText": "push_back(tag)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(token[0] == 's' && IS_SPACE(token[1]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(token[0] == '\\r' || token[1] == '\\n')"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(strlen(token) >= 3)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (current_smoothing_id = 0 ; } else { current_smoothing_id = static_cast<unsigned)",
    "insertText": "int(smGroupId)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } continue ; } })",
    "insertText": "if(!found_all_colors && !default_vcols_fallback)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(greatest_v_idx >= static_cast<int>(v.size() / 3))"
  },
  {
    "label": "bounds()",
    "kind": "Method",
    "detail": "Function (std::stringstream ss ; ss<<\" Vertex indices out of)",
    "insertText": "bounds(line \" << line_num << \".)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(greatest_vn_idx >= static_cast<int>(vn.size() / 3))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(greatest_vt_idx >= static_cast<int>(vt.size() / 2))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} attrib -> vertices .)",
    "insertText": "swap(v)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (attrib -> normals .)",
    "insertText": "swap(vn)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (attrib -> texcoords .)",
    "insertText": "swap(vt)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (attrib -> colors .)",
    "insertText": "swap(vc)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::stringstream errss ; std::map<std::string,int> material_map ; int material_id = - 1 ; std::vector<index_t> indices ; std::vector<material_t> materials ; std::vector<std::string> names ; names .)",
    "insertText": "reserve(2)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (std::vector<const char*> names_out ; std::string linebuf ;)",
    "insertText": "while(inStream.peek() != -1)"
  },
  {
    "label": "safeGetline()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "safeGetline(inStream, linebuf)"
  },
  {
    "label": "parseV()",
    "kind": "Method",
    "detail": "Function (token + = 2 ; real_t x,y,z,w ;)",
    "insertText": "parseV(&x, &y, &z, &w, &token)"
  },
  {
    "label": "vertex_cb()",
    "kind": "Method",
    "detail": "Function (callback .)",
    "insertText": "vertex_cb(user_data, x, y, z, w)"
  },
  {
    "label": "normal_cb()",
    "kind": "Method",
    "detail": "Function (callback .)",
    "insertText": "normal_cb(user_data, x, y, z)"
  },
  {
    "label": "texcoord_cb()",
    "kind": "Method",
    "detail": "Function (callback .)",
    "insertText": "texcoord_cb(user_data, x, y, z)"
  },
  {
    "label": "parseRawTriple()",
    "kind": "Method",
    "detail": "Function (vertex_index_t vi =)",
    "insertText": "parseRawTriple(&token)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (token + = n ; })",
    "insertText": "if(callback.index_cb && indices.size() > 0)"
  },
  {
    "label": "index_cb()",
    "kind": "Method",
    "detail": "Function (callback .)",
    "insertText": "index_cb(user_data, &indices.at(0), static_cast<int>(indices.size()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (newMaterialId = material_map [ namebuf ] ; } else { })",
    "insertText": "if(newMaterialId != material_id)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (material_id = newMaterialId ; })",
    "insertText": "if(callback.usemtl_cb)"
  },
  {
    "label": "usemtl_cb()",
    "kind": "Method",
    "detail": "Function (callback .)",
    "insertText": "usemtl_cb(user_data, namebuf.c_str(), material_id)"
  },
  {
    "label": "ok()",
    "kind": "Method",
    "detail": "Function (std::string warn_mtl ; std::string err_mtl ; bool)",
    "insertText": "ok(*readMatFn)(filenames[s].c_str(), &materials, &material_map, &warn_mtl, &err_mtl)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(callback.mtllib_cb)"
  },
  {
    "label": "mtllib_cb()",
    "kind": "Method",
    "detail": "Function (callback .)",
    "insertText": "mtllib_cb(user_data, &materials.at(0), static_cast<int>(materials.size()))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(names.size() > 0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (names_out .)",
    "insertText": "resize(names.size() - 1)"
  },
  {
    "label": "group_cb()",
    "kind": "Method",
    "detail": "Function (} callback .)",
    "insertText": "group_cb(user_data, &names_out.at(0), static_cast<int>(names_out.size()))"
  },
  {
    "label": "group_cb()",
    "kind": "Method",
    "detail": "Function (} else { callback .)",
    "insertText": "group_cb(user_data, NULL, 0)"
  },
  {
    "label": "object_cb()",
    "kind": "Method",
    "detail": "Function (callback .)",
    "insertText": "object_cb(user_data, object_name.c_str())"
  },
  {
    "label": "atoi()",
    "kind": "Method",
    "detail": "Function (tag . intValues [ i ] =)",
    "insertText": "atoi(token)"
  },
  {
    "label": "strcspn()",
    "kind": "Method",
    "detail": "Function (token + =)",
    "insertText": "strcspn(token, \"/ \\t\\r\")"
  }
]