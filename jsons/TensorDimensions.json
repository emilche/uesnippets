[
  {
    "label": "dget",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "dget"
  },
  {
    "label": "fixed_size_tensor_index_linearization_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "fixed_size_tensor_index_linearization_helper"
  },
  {
    "label": "fixed_size_tensor_index_extraction_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "fixed_size_tensor_index_extraction_helper"
  },
  {
    "label": "Sizes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Sizes"
  },
  {
    "label": "non_zero_size",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "non_zero_size"
  },
  {
    "label": "tensor_index_linearization_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "tensor_index_linearization_helper"
  },
  {
    "label": "DSizes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DSizes"
  },
  {
    "label": "tensor_vsize_index_linearization_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "tensor_vsize_index_linearization_helper"
  },
  {
    "label": "array_size",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "array_size"
  },
  {
    "label": "sizes_match_below_dim",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "sizes_match_below_dim"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_CXX11_TENSOR_TENSOR_DIMENSIONS_H # define EIGEN_CXX11_TENSOR_TENSOR_DIMENSIONS_H namespace Eigen { namespace internal { template<std::ptrdiff_t n,Dimension> struct dget { const std::ptrdiff_t value = get<n,Dimension>::value ; } ; template<Index,std::ptrdiff_t NumIndices,std::ptrdiff_t n,bool RowMajor> struct fixed_size_tensor_index_linearization_helper { template<Dimensions> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index)",
    "insertText": "run(array<Index, NumIndices> const& indices, const Dimensions& dimensions)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Index,std::ptrdiff_t NumIndices,bool RowMajor> struct fixed_size_tensor_index_linearization_helper<Index,NumIndices,0,RowMajor> { template<Dimensions> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index)",
    "insertText": "run(array<Index, NumIndices> const&, const Dimensions&)"
  },
  {
    "label": "mult()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "mult(index == n-1)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Index> struct fixed_size_tensor_index_extraction_helper<Index,0> { template<Dimensions> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index)",
    "insertText": "run(const Index, const Dimensions&)"
  },
  {
    "label": "arg_prod()",
    "kind": "Method",
    "detail": "Function (const std::ptrdiff_t total_size =)",
    "insertText": "arg_prod(Indices...)"
  },
  {
    "label": "rank()",
    "kind": "Method",
    "detail": "Function (const ptrdiff_t count = Base::count ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::ptrdiff_t)",
    "insertText": "rank()"
  },
  {
    "label": "Sizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "Sizes()"
  },
  {
    "label": "Sizes()",
    "kind": "Method",
    "detail": "Function (} template<DenseIndex> EIGEN_DEVICE_FUNC)",
    "insertText": "Sizes(const array<DenseIndex, Base::count>&)"
  },
  {
    "label": "Sizes()",
    "kind": "Method",
    "detail": "Function (} # if EIGEN_HAS_VARIADIC_TEMPLATES template<. . . DenseIndex> EIGEN_DEVICE_FUNC)",
    "insertText": "Sizes(DenseIndex...)"
  },
  {
    "label": "Sizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "Sizes(std::initializer_list<std::ptrdiff_t>)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif template<T> Sizes&)",
    "insertText": "operator(const T&)"
  },
  {
    "label": "IndexOfColMajor()",
    "kind": "Method",
    "detail": "Function (} template<DenseIndex> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ptrdiff_t)",
    "insertText": "IndexOfColMajor(const array<DenseIndex, Base::count>& indices)"
  },
  {
    "label": "IndexOfRowMajor()",
    "kind": "Method",
    "detail": "Function (} template<DenseIndex> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ptrdiff_t)",
    "insertText": "IndexOfRowMajor(const array<DenseIndex, Base::count>& indices)"
  },
  {
    "label": "array_prod()",
    "kind": "Method",
    "detail": "Function (} } ; namespace internal { template<std::ptrdiff_t . . . Indices> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::ptrdiff_t)",
    "insertText": "array_prod(const Sizes<Indices...>&)"
  },
  {
    "label": "Sizes()",
    "kind": "Method",
    "detail": "Function (} # else EIGEN_DEVICE_FUNC)",
    "insertText": "Sizes(const DenseIndex)"
  },
  {
    "label": "Sizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "Sizes(const DenseIndex, const DenseIndex)"
  },
  {
    "label": "Sizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "Sizes(const DenseIndex, const DenseIndex, const DenseIndex)"
  },
  {
    "label": "Sizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "Sizes(const DenseIndex, const DenseIndex, const DenseIndex, const DenseIndex)"
  },
  {
    "label": "Sizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "Sizes(const DenseIndex, const DenseIndex, const DenseIndex, const DenseIndex, const DenseIndex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index)",
    "insertText": "operator(const Index index)"
  },
  {
    "label": "array_prod()",
    "kind": "Method",
    "detail": "Function (} } ; namespace internal { template<std::ptrdiff_t V1,std::ptrdiff_t V2,std::ptrdiff_t V3,std::ptrdiff_t V4,std::ptrdiff_t V5> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::ptrdiff_t)",
    "insertText": "array_prod(const Sizes<V1, V2, V3, V4, V5>&)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Index,std::ptrdiff_t NumIndices,bool RowMajor> struct tensor_index_linearization_helper<Index,NumIndices,0,RowMajor> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index)",
    "insertText": "run(array<Index, NumIndices> const& indices, array<Index, NumIndices> const&)"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "DSizes()"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} } EIGEN_DEVICE_FUNC)",
    "insertText": "DSizes(const array<DenseIndex, NumDims>& a) : Base(a)"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DSizes(const DenseIndex i0)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(NumDims == 1)"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DSizes(const DimensionList<DenseIndex, NumDims>& a)"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} } template<OtherIndex> EIGEN_DEVICE_FUNC)",
    "insertText": "DSizes(const array<OtherIndex, NumDims>& other, typename internal::enable_if< internal::is_same< DenseIndex, typename internal::promote_index_type< DenseIndex, OtherIndex >::type >::value, void*>::type = 0)"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} } # ifdef EIGEN_HAS_INDEX_LIST template<FirstType,. . . OtherTypes> EIGEN_DEVICE_FUNC)",
    "insertText": "DSizes(const Eigen::IndexList<FirstType, OtherTypes...>& dimensions)"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} } # endif # ifndef EIGEN_EMULATE_CXX11_META_H template<std::ptrdiff_t . . . Indices> EIGEN_DEVICE_FUNC)",
    "insertText": "DSizes(const Sizes<Indices...>& a)"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} } # else template<std::ptrdiff_t V1,std::ptrdiff_t V2,std::ptrdiff_t V3,std::ptrdiff_t V4,std::ptrdiff_t V5> EIGEN_DEVICE_FUNC)",
    "insertText": "DSizes(const Sizes<V1, V2, V3, V4, V5>& a)"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} } # endif # if EIGEN_HAS_VARIADIC_TEMPLATES template<. . . IndexTypes> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "DSizes(DenseIndex firstDimension, DenseIndex secondDimension, IndexTypes... otherDimensions) : Base({{firstDimension, secondDimension, otherDimensions...}})"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT(sizeof...(otherDimensions) + 2 == NumDims, YOU_MADE_A_PROGRAMMING_MISTAKE) } #else EIGEN_DEVICE_FUNC DSizes(const DenseIndex i0, const DenseIndex i1)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(NumDims == 2)"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DSizes(const DenseIndex i0, const DenseIndex i1, const DenseIndex i2)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(NumDims == 3)"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DSizes(const DenseIndex i0, const DenseIndex i1, const DenseIndex i2, const DenseIndex i3)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(NumDims == 4)"
  },
  {
    "label": "DSizes()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DSizes(const DenseIndex i0, const DenseIndex i1, const DenseIndex i2, const DenseIndex i3, const DenseIndex i4)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(NumDims == 5)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif EIGEN_DEVICE_FUNC DSizes&)",
    "insertText": "operator(const array<DenseIndex, NumDims>& other)"
  },
  {
    "label": "Base()",
    "kind": "Method",
    "detail": "Function (* static_cast<)",
    "insertText": "Base(this)"
  },
  {
    "label": "IndexOfRowMajor()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE DenseIndex)",
    "insertText": "IndexOfRowMajor(const array<DenseIndex, NumDims>& indices)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<IndexType,int NumDims> std::ostream&)",
    "insertText": "operator(std::ostream& os, const DSizes<IndexType, NumDims>& dims)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (os<<\" [ \" ;)",
    "insertText": "for(int i = 0; i < NumDims; ++i)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (os<<dims [ i ] ; } os<<\" ] \" ; return os ; } namespace internal { template<Index,std::ptrdiff_t NumIndices,std::ptrdiff_t n,bool RowMajor> struct tensor_vsize_index_linearization_helper { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index)",
    "insertText": "run(array<Index, NumIndices> const& indices, std::vector<DenseIndex> const& dimensions)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Index,std::ptrdiff_t NumIndices,bool RowMajor> struct tensor_vsize_index_linearization_helper<Index,NumIndices,0,RowMajor> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index)",
    "insertText": "run(array<Index, NumIndices> const& indices, std::vector<DenseIndex> const&)"
  },
  {
    "label": "array_get()",
    "kind": "Method",
    "detail": "Function (} } ; } namespace internal { template<DenseIndex,int NumDims> struct array_size<const DSizes<DenseIndex,NumDims>> { const ptrdiff_t value = NumDims ; } ; template<DenseIndex,int NumDims> struct array_size<DSizes<DenseIndex,NumDims>> { const ptrdiff_t value = NumDims ; } ; # ifndef EIGEN_EMULATE_CXX11_META_H template<std::ptrdiff_t . . . Indices> struct array_size<const Sizes<Indices . . .>> { const std::ptrdiff_t value = Sizes<Indices . . .>::count ; } ; template<std::ptrdiff_t . . . Indices> struct array_size<Sizes<Indices . . .>> { const std::ptrdiff_t value = Sizes<Indices . . .>::count ; } ; template<std::ptrdiff_t n,std::ptrdiff_t . . . Indices> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::ptrdiff_t)",
    "insertText": "array_get(const Sizes<Indices...>&)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(false && \"should never be called\")"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Dims1,Dims2> struct sizes_match_below_dim<Dims1,Dims2,0,0> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool)",
    "insertText": "run(Dims1&, Dims2&)"
  }
]