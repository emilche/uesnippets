[
  {
    "label": "TSortedMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSortedMap"
  },
  {
    "label": "FKeyForward",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FKeyForward"
  },
  {
    "label": "TBaseIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBaseIterator"
  },
  {
    "label": "TBaseReverseIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBaseReverseIterator"
  },
  {
    "label": "TIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TIterator"
  },
  {
    "label": "TConstIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TConstIterator"
  },
  {
    "label": "TReverseIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TReverseIterator"
  },
  {
    "label": "TConstReverseIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TConstReverseIterator"
  },
  {
    "label": "TConstKeyIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TConstKeyIterator"
  },
  {
    "label": "TKeyIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TKeyIterator"
  },
  {
    "label": "TSortedMapPrivateFriend",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TSortedMapPrivateFriend"
  },
  {
    "label": "TSortedMap()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Map . h \" # include \" Algo / BinarySearch . h \" # include \" Algo / Sort . h \" # include \" UObject / NameTypes . h \" template<InKeyType,InValueType,ArrayAllocator,SortPredicate> class TSortedMap { template<OtherKeyType,OtherValueType,OtherArrayAllocator,OtherSortPredicate> class TSortedMap ; public : typedef InKeyType KeyType ; typedef InValueType ValueType ; typedef TTypeTraits<KeyType>::ConstPointerType KeyConstPointerType ; typedef TTypeTraits<KeyType>::ConstInitType KeyInitType ; typedef TTypeTraits<ValueType>::ConstInitType ValueInitType ; typedef TPair<KeyType,ValueType> ElementType ;)",
    "insertText": "TSortedMap()"
  },
  {
    "label": "TSortedMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TSortedMap(TSortedMap&&)"
  },
  {
    "label": "TSortedMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TSortedMap(const TSortedMap&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TSortedMap&)",
    "insertText": "operator(TSortedMap&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TSortedMap&)",
    "insertText": "operator(const TSortedMap&)"
  },
  {
    "label": "TSortedMap()",
    "kind": "Method",
    "detail": "Function (template<OtherArrayAllocator>)",
    "insertText": "TSortedMap(TSortedMap<KeyType, ValueType, OtherArrayAllocator, SortPredicate>&& Other) : Pairs(MoveTemp(Other.Pairs))"
  },
  {
    "label": "TSortedMap()",
    "kind": "Method",
    "detail": "Function (} template<OtherArrayAllocator>)",
    "insertText": "TSortedMap(const TSortedMap<KeyType, ValueType, OtherArrayAllocator, SortPredicate>& Other) : Pairs(Other.Pairs)"
  },
  {
    "label": "TSortedMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSortedMap(std::initializer_list<TPairInitializer<const KeyType&, const ValueType&>> InitList)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Reserve((int32)InitList.size())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Add(Element.Key, Element.Value)"
  },
  {
    "label": "TSortedMap()",
    "kind": "Method",
    "detail": "Function (} } bool bHasIntrusiveUnsetOptionalState = true ; using IntrusiveUnsetOptionalStateType = TSortedMap ;)",
    "insertText": "TSortedMap(FIntrusiveUnsetOptionalState Tag) : Pairs(Tag)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(FIntrusiveUnsetOptionalState Tag)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Pairs =)",
    "insertText": "MoveTemp(Other.Pairs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Pairs = Other . Pairs ; return* this ; } TSortedMap&)",
    "insertText": "operator(std::initializer_list<TPairInitializer<const KeyType&, const ValueType&>> InitList)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Empty((int32)InitList.size())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } bool)",
    "insertText": "operator(const TSortedMap& Other)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (Pairs .)",
    "insertText": "Empty(ExpectedNumElements)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "Shrink()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Shrink()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reserve(int32 Number)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Pairs .)",
    "insertText": "Reserve(Number)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Num()"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "CountBytes()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CountBytes(FArchive& Ar)"
  },
  {
    "label": "CountBytes()",
    "kind": "Method",
    "detail": "Function (Pairs .)",
    "insertText": "CountBytes(Ar)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} ValueType&)",
    "insertText": "Add(const KeyType& InKey, const ValueType& InValue)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} ValueType&)",
    "insertText": "Add(const KeyType& InKey, ValueType&& InValue)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} ValueType&)",
    "insertText": "Add(KeyType&& InKey, const ValueType& InValue)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} ValueType&)",
    "insertText": "Add(KeyType&& InKey, ValueType&& InValue)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} ValueType&)",
    "insertText": "Add(const KeyType& InKey)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} ValueType&)",
    "insertText": "Add(KeyType&& InKey)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (} template<InitKeyType = KeyType,InitValueType = ValueType> ValueType&)",
    "insertText": "Emplace(InitKeyType&& InKey, InitValueType&& InValue)"
  },
  {
    "label": "AllocateMemoryForEmplace()",
    "kind": "Method",
    "detail": "Function (ElementType* DataPtr =)",
    "insertText": "AllocateMemoryForEmplace(InKey)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)DataPtr) ElementType(TPairInitializer<InitKeyType&&, InitValueType&&>(Forward<InitKeyType>(InKey), Forward<InitValueType>(InValue)))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)DataPtr) ElementType(TKeyInitializer<InitKeyType&&>(Forward<InitKeyType>(InKey)))"
  },
  {
    "label": "FindIndex()",
    "kind": "Method",
    "detail": "Function (int32 RemoveIndex =)",
    "insertText": "FindIndex(InKey)"
  },
  {
    "label": "FindIndex()",
    "kind": "Method",
    "detail": "Function (int32 FoundIndex =)",
    "insertText": "FindIndex(Key)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} ValueType&)",
    "insertText": "FindOrAdd(const KeyType& Key)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} ValueType&)",
    "insertText": "FindOrAdd(KeyType&& Key)"
  },
  {
    "label": "FindChecked()",
    "kind": "Method",
    "detail": "Function (} ValueType&)",
    "insertText": "FindChecked(KeyConstPointerType Key)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (ValueType* Value =)",
    "insertText": "Find(Key)"
  },
  {
    "label": "FindRef()",
    "kind": "Method",
    "detail": "Function (} ValueType)",
    "insertText": "FindRef(KeyConstPointerType Key, ValueType DefaultValue)"
  },
  {
    "label": "FindArbitraryElement()",
    "kind": "Method",
    "detail": "Function (} const ElementType*)",
    "insertText": "FindArbitraryElement()"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(KeyConstPointerType Key)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutKeys .)",
    "insertText": "Add(PairIt->Key)"
  },
  {
    "label": "GenerateKeyArray()",
    "kind": "Method",
    "detail": "Function (} template<Allocator> void)",
    "insertText": "GenerateKeyArray(TArray<KeyType, Allocator>& OutArray)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (OutArray .)",
    "insertText": "Empty(Pairs.Num())"
  },
  {
    "label": "GenerateValueArray()",
    "kind": "Method",
    "detail": "Function (} } template<Allocator> void)",
    "insertText": "GenerateValueArray(TArray<ValueType, Allocator>& OutArray)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutArray .)",
    "insertText": "Add(PairIt->Value)"
  },
  {
    "label": "Dump()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Dump(FOutputDevice& Ar)"
  },
  {
    "label": "Dump()",
    "kind": "Method",
    "detail": "Function (Pairs .)",
    "insertText": "Dump(Ar)"
  },
  {
    "label": "RemoveAndCopyValue()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "RemoveAndCopyValue(KeyInitType Key, ValueType& OutRemovedValue)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (Pairs .)",
    "insertText": "RemoveAt(FoundIndex)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (ValueType OutRemovedValue =)",
    "insertText": "MoveTemp(Pairs[FoundIndex].Value)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Reserve(this->Num() + OtherMap.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Add(MoveTemp(Pair.Key), MoveTemp(Pair.Value))"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (} template<OtherArrayAllocator,OtherSortPredicate> void)",
    "insertText": "Append(const TSortedMap<KeyType, ValueType, OtherArrayAllocator, OtherSortPredicate>& OtherMap)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Add(Pair.Key, Pair.Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ValueType&)",
    "insertText": "operator(KeyConstPointerType Key)"
  },
  {
    "label": "GetMaxIndex()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] int32)",
    "insertText": "GetMaxIndex()"
  },
  {
    "label": "IsValidId()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "IsValidId(FSetElementId Id)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] ElementType&)",
    "insertText": "Get(FSetElementId Id)"
  },
  {
    "label": "FindOrAddImpl()",
    "kind": "Method",
    "detail": "Function (} private : typedef TArray<ElementType,ArrayAllocator> ElementArrayType ; template<ArgType> ValueType&)",
    "insertText": "FindOrAddImpl(ArgType&& Key)"
  },
  {
    "label": "FindIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "FindIndex(KeyConstPointerType Key)"
  },
  {
    "label": "AllocateMemoryForEmplace()",
    "kind": "Method",
    "detail": "Function (} template<InitKeyType> ElementType*)",
    "insertText": "AllocateMemoryForEmplace(InitKeyType&& InKey)"
  },
  {
    "label": "LowerBoundBy()",
    "kind": "Method",
    "detail": "Function (int32 InsertIndex =)",
    "insertText": "LowerBoundBy(Pairs, InKey, FKeyForward(), SortPredicate())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ElementType* DataPtr = nullptr ;)",
    "insertText": "if(Pairs.IsValidIndex(InsertIndex) && !SortPredicate()(InKey, Pairs[InsertIndex].Key))"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (DataPtr = Pairs .)",
    "insertText": "GetData()"
  },
  {
    "label": "DestructItems()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItems(DataPtr, 1)"
  },
  {
    "label": "InsertUninitialized()",
    "kind": "Method",
    "detail": "Function (} else { Pairs .)",
    "insertText": "InsertUninitialized(InsertIndex, 1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return DataPtr ; } struct FKeyForward { const KeyType&)",
    "insertText": "operator()(const ElementType& Pair)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} public : TBaseIterator&)",
    "insertText": "operator()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (+ + PairIt ; return* this ; } operator)",
    "insertText": "bool()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TBaseReverseIterator& Rhs)"
  },
  {
    "label": "TIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TIterator(const typename TBaseIterator<false>::PairItType& InPairIt) : TBaseIterator<false>(InPairIt)"
  },
  {
    "label": "RemoveCurrent()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveCurrent()"
  },
  {
    "label": "TConstIterator()",
    "kind": "Method",
    "detail": "Function (} } ; class TConstIterator : public TBaseIterator<true> { public :)",
    "insertText": "TConstIterator(const TSortedMap& InMap) : TBaseIterator<true>(InMap.Pairs.CreateConstIterator())"
  },
  {
    "label": "TConstIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TConstIterator(const typename TBaseIterator<true>::PairItType& InPairIt) : TBaseIterator<true>(InPairIt)"
  },
  {
    "label": "TReverseIterator()",
    "kind": "Method",
    "detail": "Function (} } ; class TReverseIterator : public TBaseReverseIterator<false> { public :)",
    "insertText": "TReverseIterator(TSortedMap& InMap) : TBaseReverseIterator<false>(InMap.Pairs.GetData(), InMap.Pairs.Num())"
  },
  {
    "label": "TConstReverseIterator()",
    "kind": "Method",
    "detail": "Function (} } ; class TConstReverseIterator : public TBaseReverseIterator<true> { public :)",
    "insertText": "TConstReverseIterator(const TSortedMap& InMap) : TBaseReverseIterator<true>(InMap.Pairs.GetData(), InMap.Pairs.Num())"
  },
  {
    "label": "TConstKeyIterator()",
    "kind": "Method",
    "detail": "Function (} } ; class TConstKeyIterator : public TBaseIterator<true> { using Super = TBaseIterator<true> ; public :)",
    "insertText": "TConstKeyIterator(const TSortedMap& InMap, KeyInitType InKey) : Super(InMap.Pairs.CreateConstIterator())"
  },
  {
    "label": "SetToEnd()",
    "kind": "Method",
    "detail": "Function (Super::PairIt + = NewIndex ; } else { Super::PairIt .)",
    "insertText": "SetToEnd()"
  },
  {
    "label": "CreateIterator()",
    "kind": "Method",
    "detail": "Function (} } ; TIterator)",
    "insertText": "CreateIterator()"
  },
  {
    "label": "CreateConstIterator()",
    "kind": "Method",
    "detail": "Function (} TConstIterator)",
    "insertText": "CreateConstIterator()"
  },
  {
    "label": "CreateKeyIterator()",
    "kind": "Method",
    "detail": "Function (} TKeyIterator)",
    "insertText": "CreateKeyIterator(KeyInitType InKey)"
  },
  {
    "label": "CreateConstKeyIterator()",
    "kind": "Method",
    "detail": "Function (} TConstKeyIterator)",
    "insertText": "CreateConstKeyIterator(KeyInitType InKey)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} typedef ElementArrayType::RangedForIteratorType RangedForIteratorType ; typedef ElementArrayType::RangedForConstIteratorType RangedForConstIteratorType ; public : RangedForIteratorType)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} RangedForIteratorType)",
    "insertText": "end()"
  },
  {
    "label": "DECLARE_TEMPLATE_INTRINSIC_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (} struct TSortedMapPrivateFriend ; } ;)",
    "insertText": "DECLARE_TEMPLATE_INTRINSIC_TYPE_LAYOUT((template <typename KeyType, typename ValueType, typename ArrayAllocator, typename SortPredicate>), (TSortedMap<KeyType, ValueType, ArrayAllocator, SortPredicate>))"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (struct TSortedMapPrivateFriend { template<KeyType,ValueType,ArrayAllocator,SortPredicate> void)",
    "insertText": "Serialize(FArchive& Ar, TSortedMap<KeyType, ValueType, ArrayAllocator, SortPredicate>& Map)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<Map . Pairs ;)",
    "insertText": "if(Ar.IsLoading())"
  },
  {
    "label": "SortBy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SortBy(Map.Pairs, typename TSortedMap<KeyType, ValueType, ArrayAllocator, SortPredicate>::FKeyForward(), SortPredicate())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } } ; template<KeyType,ValueType,ArrayAllocator,SortPredicate> FArchive&)",
    "insertText": "operator(FArchive& Ar, TSortedMap<KeyType, ValueType, ArrayAllocator, SortPredicate>& Map)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Serialize(Ar, Map)"
  }
]