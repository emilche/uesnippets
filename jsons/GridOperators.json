[
  {
    "label": "VectorToScalarConverter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VectorToScalarConverter"
  },
  {
    "label": "ScalarToVectorConverter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ScalarToVectorConverter"
  },
  {
    "label": "ToMaskGrid",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ToMaskGrid"
  },
  {
    "label": "GridOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GridOperator"
  },
  {
    "label": "Cpt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Cpt"
  },
  {
    "label": "IsOpT",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsOpT"
  },
  {
    "label": "WsOpT",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "WsOpT"
  },
  {
    "label": "Functor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Functor"
  },
  {
    "label": "Curl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Curl"
  },
  {
    "label": "Divergence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Divergence"
  },
  {
    "label": "Gradient",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Gradient"
  },
  {
    "label": "Laplacian",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Laplacian"
  },
  {
    "label": "MeanCurvature",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MeanCurvature"
  },
  {
    "label": "Magnitude",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Magnitude"
  },
  {
    "label": "OpT",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OpT"
  },
  {
    "label": "Normalize",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Normalize"
  },
  {
    "label": "cpt()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TOOLS_GRID_OPERATORS_HAS_BEEN_INCLUDED # define OPENVDB_TOOLS_GRID_OPERATORS_HAS_BEEN_INCLUDED # include<openvdb / Grid . h> # include<openvdb / math / Operators . h> # include<openvdb / util / NullInterrupter . h> # include<openvdb / tree / LeafManager . h> # include<openvdb / tree / ValueAccessor . h> # include \" ValueTransformer . h \" # include<tbb / parallel_for . h> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tools { template<VectorGridType> struct VectorToScalarConverter { typedef VectorGridType::ValueType::value_type VecComponentValueT ; typedef VectorGridType::template ValueConverter<VecComponentValueT>::Type Type ; } ; template<ScalarGridType> struct ScalarToVectorConverter { typedef math::Vec3<ScalarGridType::ValueType> VectorValueT ; typedef ScalarGridType::template ValueConverter<VectorValueT>::Type Type ; } ; template<GridType,InterruptT> ScalarToVectorConverter<GridType>::Type::Ptr)",
    "insertText": "cpt(const GridType& grid, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "cpt()",
    "kind": "Method",
    "detail": "Function (template<GridType,MaskT,InterruptT> ScalarToVectorConverter<GridType>::Type::Ptr)",
    "insertText": "cpt(const GridType& grid, const MaskT& mask, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "cpt()",
    "kind": "Method",
    "detail": "Function (template<GridType> ScalarToVectorConverter<GridType>::Type::Ptr)",
    "insertText": "cpt(const GridType& grid, bool threaded = true)"
  },
  {
    "label": "cpt()",
    "kind": "Method",
    "detail": "Function (} template<GridType,MaskT> ScalarToVectorConverter<GridType>::Type::Ptr)",
    "insertText": "cpt(const GridType& grid, const MaskT& mask, bool threaded = true)"
  },
  {
    "label": "curl()",
    "kind": "Method",
    "detail": "Function (} template<GridType,InterruptT> GridType::Ptr)",
    "insertText": "curl(const GridType& grid, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "curl()",
    "kind": "Method",
    "detail": "Function (template<GridType,MaskT,InterruptT> GridType::Ptr)",
    "insertText": "curl(const GridType& grid, const MaskT& mask, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "curl()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::Ptr)",
    "insertText": "curl(const GridType& grid, bool threaded = true)"
  },
  {
    "label": "curl()",
    "kind": "Method",
    "detail": "Function (} template<GridType,MaskT> GridType::Ptr)",
    "insertText": "curl(const GridType& grid, const MaskT& mask, bool threaded = true)"
  },
  {
    "label": "divergence()",
    "kind": "Method",
    "detail": "Function (} template<GridType,InterruptT> VectorToScalarConverter<GridType>::Type::Ptr)",
    "insertText": "divergence(const GridType& grid, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "divergence()",
    "kind": "Method",
    "detail": "Function (template<GridType,MaskT,InterruptT> VectorToScalarConverter<GridType>::Type::Ptr)",
    "insertText": "divergence(const GridType& grid, const MaskT& mask, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "divergence()",
    "kind": "Method",
    "detail": "Function (template<GridType> VectorToScalarConverter<GridType>::Type::Ptr)",
    "insertText": "divergence(const GridType& grid, bool threaded = true)"
  },
  {
    "label": "divergence()",
    "kind": "Method",
    "detail": "Function (} template<GridType,MaskT> VectorToScalarConverter<GridType>::Type::Ptr)",
    "insertText": "divergence(const GridType& grid, const MaskT& mask, bool threaded = true)"
  },
  {
    "label": "gradient()",
    "kind": "Method",
    "detail": "Function (} template<GridType,InterruptT> ScalarToVectorConverter<GridType>::Type::Ptr)",
    "insertText": "gradient(const GridType& grid, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "gradient()",
    "kind": "Method",
    "detail": "Function (template<GridType,MaskT,InterruptT> ScalarToVectorConverter<GridType>::Type::Ptr)",
    "insertText": "gradient(const GridType& grid, const MaskT& mask, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "gradient()",
    "kind": "Method",
    "detail": "Function (template<GridType> ScalarToVectorConverter<GridType>::Type::Ptr)",
    "insertText": "gradient(const GridType& grid, bool threaded = true)"
  },
  {
    "label": "gradient()",
    "kind": "Method",
    "detail": "Function (} template<GridType,MaskT> ScalarToVectorConverter<GridType>::Type::Ptr)",
    "insertText": "gradient(const GridType& grid, const MaskT& mask, bool threaded = true)"
  },
  {
    "label": "laplacian()",
    "kind": "Method",
    "detail": "Function (} template<GridType,InterruptT> GridType::Ptr)",
    "insertText": "laplacian(const GridType& grid, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "laplacian()",
    "kind": "Method",
    "detail": "Function (template<GridType,MaskT,InterruptT> GridType::Ptr)",
    "insertText": "laplacian(const GridType& grid, const MaskT& mask, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "laplacian()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::Ptr)",
    "insertText": "laplacian(const GridType& grid, bool threaded = true)"
  },
  {
    "label": "laplacian()",
    "kind": "Method",
    "detail": "Function (} template<GridType,MaskT> GridType::Ptr)",
    "insertText": "laplacian(const GridType& grid, const MaskT mask, bool threaded = true)"
  },
  {
    "label": "meanCurvature()",
    "kind": "Method",
    "detail": "Function (} template<GridType,InterruptT> GridType::Ptr)",
    "insertText": "meanCurvature(const GridType& grid, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "meanCurvature()",
    "kind": "Method",
    "detail": "Function (template<GridType,MaskT,InterruptT> GridType::Ptr)",
    "insertText": "meanCurvature(const GridType& grid, const MaskT& mask, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "meanCurvature()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::Ptr)",
    "insertText": "meanCurvature(const GridType& grid, bool threaded = true)"
  },
  {
    "label": "meanCurvature()",
    "kind": "Method",
    "detail": "Function (} template<GridType,MaskT> GridType::Ptr)",
    "insertText": "meanCurvature(const GridType& grid, const MaskT& mask, bool threaded = true)"
  },
  {
    "label": "magnitude()",
    "kind": "Method",
    "detail": "Function (} template<GridType,InterruptT> VectorToScalarConverter<GridType>::Type::Ptr)",
    "insertText": "magnitude(const GridType& grid, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "magnitude()",
    "kind": "Method",
    "detail": "Function (template<GridType,MaskT,InterruptT> VectorToScalarConverter<GridType>::Type::Ptr)",
    "insertText": "magnitude(const GridType& grid, const MaskT& mask, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "magnitude()",
    "kind": "Method",
    "detail": "Function (template<GridType> VectorToScalarConverter<GridType>::Type::Ptr)",
    "insertText": "magnitude(const GridType& grid, bool threaded = true)"
  },
  {
    "label": "magnitude()",
    "kind": "Method",
    "detail": "Function (} template<GridType,MaskT> VectorToScalarConverter<GridType>::Type::Ptr)",
    "insertText": "magnitude(const GridType& grid, const MaskT& mask, bool threaded = true)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (} template<GridType,InterruptT> GridType::Ptr)",
    "insertText": "normalize(const GridType& grid, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (template<GridType,MaskT,InterruptT> GridType::Ptr)",
    "insertText": "normalize(const GridType& grid, const MaskT& mask, bool threaded, InterruptT* interrupt)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::Ptr)",
    "insertText": "normalize(const GridType& grid, bool threaded = true)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (} template<GridType,MaskT> GridType::Ptr)",
    "insertText": "normalize(const GridType& grid, const MaskT& mask, bool threaded = true)"
  },
  {
    "label": "GridOperator()",
    "kind": "Method",
    "detail": "Function (} namespace gridop { template<GridType> struct ToMaskGrid { typedef Grid<GridType::TreeType::template ValueConverter<ValueMask>::Type> Type ; } ; template<InGridT,MaskGridType,OutGridT,MapT,OperatorT,InterruptT = util::NullInterrupter> class GridOperator { public : typedef OutGridT::TreeType OutTreeT ; typedef OutTreeT::LeafNodeType OutLeafT ; typedef tree::LeafManager<OutTreeT> LeafManagerT ;)",
    "insertText": "GridOperator(const InGridT& grid, const MaskGridType* mask, const MapT& map, InterruptT* interrupt = nullptr, bool densify = true) : mAcc(grid.getConstAccessor()) , mMap(map) , mInterrupt(interrupt) , mMask(mask) , mDensify(densify)"
  },
  {
    "label": "GridOperator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "GridOperator(const GridOperator&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (GridOperator&)",
    "insertText": "operator(const GridOperator&)"
  },
  {
    "label": "GridOperator()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "GridOperator()"
  },
  {
    "label": "process()",
    "kind": "Method",
    "detail": "Function (OutGridT::Ptr)",
    "insertText": "process(bool threaded = true)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (InGridT::TreeType)",
    "insertText": "tmp(mAcc.tree().background())"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (OutGridT::ValueType backg =)",
    "insertText": "result(mMap, tmp, math::Coord(0))"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (OutTreeT::Ptr)",
    "insertText": "tree(new OutTreeT(mAcc.tree(), backg, TopologyCopy()))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (OutGridT::Ptr)",
    "insertText": "result(new OutGridT(tree))"
  },
  {
    "label": "topologyIntersection()",
    "kind": "Method",
    "detail": "Function (result ->)",
    "insertText": "topologyIntersection(*mMask)"
  },
  {
    "label": "setTransform()",
    "kind": "Method",
    "detail": "Function (} result ->)",
    "insertText": "setTransform(math::Transform::Ptr(new math::Transform( mMap.copy() )))"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (LeafManagerT)",
    "insertText": "leafManager(*tree)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(leafManager.leafRange(), *this)"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "else(*this)(leafManager.leafRange())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!mDensify)"
  },
  {
    "label": "beginValueOn()",
    "kind": "Method",
    "detail": "Function (using TileIter = OutTreeT::ValueOnIter ; TileIter tileIter = tree ->)",
    "insertText": "beginValueOn()"
  },
  {
    "label": "setMaxDepth()",
    "kind": "Method",
    "detail": "Function (tileIter .)",
    "insertText": "setMaxDepth(tileIter.getLeafDepth() - 1)"
  },
  {
    "label": "inAcc()",
    "kind": "Method",
    "detail": "Function (AccessorT inAcc = mAcc ; auto tileOp = [ this,)",
    "insertText": "inAcc(const TileIter& it)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (it .)",
    "insertText": "setValue(OperatorT::result(this->mMap, inAcc, it.getCoord()))"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "foreach(tileIter, tileOp, threaded, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(mDensify) tree->prune()"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (value .)",
    "insertText": "setValue(OperatorT::result(mMap, mAcc, value.getCoord()))"
  },
  {
    "label": "Cpt()",
    "kind": "Method",
    "detail": "Function (} } } protected : typedef InGridT::ConstAccessor AccessorT ; AccessorT mAcc ; const MapT& mMap ; InterruptT* mInterrupt ; const MaskGridType* mMask ; const bool mDensify ; } ; } template<InGridT,MaskGridType = gridop::ToMaskGrid<InGridT>::Type,InterruptT = util::NullInterrupter> class Cpt { public : typedef InGridT InGridType ; typedef ScalarToVectorConverter<InGridT>::Type OutGridType ;)",
    "insertText": "Cpt(const InGridType& grid, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)"
  },
  {
    "label": "Cpt()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Cpt(const InGridType& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)"
  },
  {
    "label": "process()",
    "kind": "Method",
    "detail": "Function (} OutGridType::Ptr)",
    "insertText": "process(bool threaded = true, bool useWorldTransform = true)"
  },
  {
    "label": "functor()",
    "kind": "Method",
    "detail": "Function (Functor)",
    "insertText": "functor(mInputGrid, mMask, threaded, useWorldTransform, mInterrupt)"
  },
  {
    "label": "processTypedMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "processTypedMap(mInputGrid.transform(), functor)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; struct WsOpT { template<MapT,AccT> OutGridType::ValueType)",
    "insertText": "result(const MapT& map, const AccT& acc, const Coord& xyz)"
  },
  {
    "label": "Functor()",
    "kind": "Method",
    "detail": "Function (} } ; struct Functor {)",
    "insertText": "Functor(const InGridType& grid, const MaskGridType* mask, bool threaded, bool worldspace, InterruptT* interrupt) : mThreaded(threaded) , mWorldSpace(worldspace) , mInputGrid(grid) , mInterrupt(interrupt) , mMask(mask)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<MapT> void)",
    "insertText": "operator()(const MapT& map)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (gridop::GridOperator<InGridType,MaskGridType,OutGridType,MapT,WsOpT,InterruptT>)",
    "insertText": "op(mInputGrid, mMask, map, mInterrupt, false)"
  },
  {
    "label": "process()",
    "kind": "Method",
    "detail": "Function (mOutputGrid = op .)",
    "insertText": "process(mThreaded)"
  },
  {
    "label": "Curl()",
    "kind": "Method",
    "detail": "Function (} } const bool mThreaded ; const bool mWorldSpace ; const InGridType& mInputGrid ; OutGridType::Ptr mOutputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; const InGridType& mInputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; template<GridT,MaskGridType = gridop::ToMaskGrid<GridT>::Type,InterruptT = util::NullInterrupter> class Curl { public : typedef GridT InGridType ; typedef GridT OutGridType ;)",
    "insertText": "Curl(const GridT& grid, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)"
  },
  {
    "label": "Curl()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Curl(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)"
  },
  {
    "label": "functor()",
    "kind": "Method",
    "detail": "Function (Functor)",
    "insertText": "functor(mInputGrid, mMask, threaded, mInterrupt)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (typedef math::Curl<MapT,math::CD_2ND> OpT ; gridop::GridOperator<GridT,MaskGridType,GridT,MapT,OpT,InterruptT>)",
    "insertText": "op(mInputGrid, mMask, map, mInterrupt)"
  },
  {
    "label": "Divergence()",
    "kind": "Method",
    "detail": "Function (} const bool mThreaded ; const GridT& mInputGrid ; GridT::Ptr mOutputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; const GridT& mInputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; template<InGridT,MaskGridType = gridop::ToMaskGrid<InGridT>::Type,InterruptT = util::NullInterrupter> class Divergence { public : typedef InGridT InGridType ; typedef VectorToScalarConverter<InGridT>::Type OutGridType ;)",
    "insertText": "Divergence(const InGridT& grid, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)"
  },
  {
    "label": "Divergence()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Divergence(const InGridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)"
  },
  {
    "label": "Gradient()",
    "kind": "Method",
    "detail": "Function (} const bool mThreaded ; const InGridType& mInputGrid ; OutGridType::Ptr mOutputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; const InGridType& mInputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; template<InGridT,MaskGridType = gridop::ToMaskGrid<InGridT>::Type,InterruptT = util::NullInterrupter> class Gradient { public : typedef InGridT InGridType ; typedef ScalarToVectorConverter<InGridT>::Type OutGridType ;)",
    "insertText": "Gradient(const InGridT& grid, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)"
  },
  {
    "label": "Gradient()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Gradient(const InGridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)"
  },
  {
    "label": "Laplacian()",
    "kind": "Method",
    "detail": "Function (} const bool mThreaded ; const InGridT& mInputGrid ; OutGridType::Ptr mOutputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; const InGridT& mInputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; template<GridT,MaskGridType = gridop::ToMaskGrid<GridT>::Type,InterruptT = util::NullInterrupter> class Laplacian { public : typedef GridT InGridType ; typedef GridT OutGridType ;)",
    "insertText": "Laplacian(const GridT& grid, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)"
  },
  {
    "label": "Laplacian()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Laplacian(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)"
  },
  {
    "label": "MeanCurvature()",
    "kind": "Method",
    "detail": "Function (} const bool mThreaded ; const GridT& mInputGrid ; GridT::Ptr mOutputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; const GridT& mInputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; template<GridT,MaskGridType = gridop::ToMaskGrid<GridT>::Type,InterruptT = util::NullInterrupter> class MeanCurvature { public : typedef GridT InGridType ; typedef GridT OutGridType ;)",
    "insertText": "MeanCurvature(const GridT& grid, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)"
  },
  {
    "label": "MeanCurvature()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MeanCurvature(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)"
  },
  {
    "label": "Magnitude()",
    "kind": "Method",
    "detail": "Function (} const bool mThreaded ; const GridT& mInputGrid ; GridT::Ptr mOutputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; const GridT& mInputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; template<InGridT,MaskGridType = gridop::ToMaskGrid<InGridT>::Type,InterruptT = util::NullInterrupter> class Magnitude { public : typedef InGridT InGridType ; typedef VectorToScalarConverter<InGridT>::Type OutGridType ;)",
    "insertText": "Magnitude(const InGridType& grid, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)"
  },
  {
    "label": "Magnitude()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Magnitude(const InGridType& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)"
  },
  {
    "label": "Functor()",
    "kind": "Method",
    "detail": "Function (} } ; struct Functor {)",
    "insertText": "Functor(const InGridT& grid, const MaskGridType* mask, bool threaded, InterruptT* interrupt): mThreaded(threaded), mInputGrid(grid), mInterrupt(interrupt), mMask(mask)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (} const bool mThreaded ; const InGridType& mInputGrid ; OutGridType::Ptr mOutputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; const InGridType& mInputGrid ; InterruptT* mInterrupt ; const MaskGridType* mMask ; } ; template<GridT,MaskGridType = gridop::ToMaskGrid<GridT>::Type,InterruptT = util::NullInterrupter> class Normalize { public : typedef GridT InGridType ; typedef GridT OutGridType ;)",
    "insertText": "Normalize(const GridT& grid, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Normalize(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr): mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)"
  },
  {
    "label": "getVectorType()",
    "kind": "Method",
    "detail": "Function (const VecType vecType = mInputGrid .)",
    "insertText": "getVectorType()"
  },
  {
    "label": "setVectorType()",
    "kind": "Method",
    "detail": "Function (outGrid ->)",
    "insertText": "setVectorType(VEC_COVARIANT_NORMALIZE)"
  },
  {
    "label": "setVectorType()",
    "kind": "Method",
    "detail": "Function (} else { outGrid ->)",
    "insertText": "setVectorType(vecType)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } return functor . mOutputGrid ; } protected : struct OpT { template<MapT,AccT> OutGridType::ValueType)",
    "insertText": "result(const MapT&, const AccT& acc, const Coord& xyz)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (OutGridType::ValueType vec = acc .)",
    "insertText": "getValue(xyz)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (Cpt<GridType,gridop::ToMaskGrid<GridType>::Type,InterruptT>)",
    "insertText": "op(grid, interrupt)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (Cpt<GridType,MaskT,InterruptT>)",
    "insertText": "op(grid, mask, interrupt)"
  }
]