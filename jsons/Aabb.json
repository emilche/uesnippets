[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TAABB",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TAABB"
  },
  {
    "label": "TAABBSpecializeSamplingHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAABBSpecializeSamplingHelper"
  },
  {
    "label": "CHAOS_API",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CHAOS_API"
  },
  {
    "label": "ComputeLocalSamplePoints()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" # include \" ChaosArchive . h \" namespace Chaos { template<class T,int d> class TAABB ; template<T,int d> struct TAABBSpecializeSamplingHelper { TArray<TVector<T,d>>)",
    "insertText": "ComputeLocalSamplePoints(const class TAABB<T, d>& AABB)"
  },
  {
    "label": "TAABB()",
    "kind": "Method",
    "detail": "Function (} } ; struct FAABBEdge { int8 VertexIndex0 ; int8 VertexIndex1 ; } ; struct FAABBFace { int8 VertexIndex [ 4 ] ; int8 EdgeIndex [ 4 ] ; } ; template<class T,int d> class TAABB { public : using TType = T ; int D = d ;)",
    "insertText": "TAABB() : MMin(TVector<T, d>(TNumericLimits<T>::Max())) , MMax(TVector<T, d>(-TNumericLimits<T>::Max()))"
  },
  {
    "label": "TAABB()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAABB(const TVector<T, d>& Min, const TVector<T, d>&Max) : MMin(Min) , MMax(Max)"
  },
  {
    "label": "TAABB()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAABB(const TAABB<T, d>& Other) : MMin(Other.MMin) , MMax(Other.MMax)"
  },
  {
    "label": "TAABB()",
    "kind": "Method",
    "detail": "Function (} template<OtherType>)",
    "insertText": "TAABB(const TAABB<OtherType, d>& Other) : MMin(TVector<T, d>(Other.Min())) , MMax(TVector<T, d>(Other.Max()))"
  },
  {
    "label": "TAABB()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAABB(TAABB<T, d>&& Other) : MMin(MoveTemp(Other.MMin)) , MMax(MoveTemp(Other.MMax))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TAABB<T,d>&)",
    "insertText": "operator(const TAABB<T, d>& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MMin = Other . MMin ; MMax = Other . MMax ; return* this ; } TAABB<T,d>&)",
    "insertText": "operator(TAABB<T, d>&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MMin =)",
    "insertText": "MoveTemp(Other.MMin)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MMax =)",
    "insertText": "MoveTemp(Other.MMax)"
  },
  {
    "label": "Center()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> Mid =)",
    "insertText": "Center()"
  },
  {
    "label": "ComputeSamplePoints()",
    "kind": "Method",
    "detail": "Function (} TArray<TVector<T,d>>)",
    "insertText": "ComputeSamplePoints()"
  },
  {
    "label": "TransformedAABB()",
    "kind": "Method",
    "detail": "Function (} TAABB<T,d>)",
    "insertText": "TransformedAABB(const FTransform&)"
  },
  {
    "label": "TransformedAABB()",
    "kind": "Method",
    "detail": "Function (TAABB<T,d>)",
    "insertText": "TransformedAABB(const Chaos::TRigidTransform<FReal, 3>&)"
  },
  {
    "label": "TransformedAABB()",
    "kind": "Method",
    "detail": "Function (TAABB<T,d>)",
    "insertText": "TransformedAABB(const FMatrix&)"
  },
  {
    "label": "TransformedAABB()",
    "kind": "Method",
    "detail": "Function (TAABB<T,d>)",
    "insertText": "TransformedAABB(const Chaos::PMatrix<FReal, 4, 4>&)"
  },
  {
    "label": "InverseTransformedAABB()",
    "kind": "Method",
    "detail": "Function (TAABB<T,d>)",
    "insertText": "InverseTransformedAABB(const Chaos::FRigidTransform3&)"
  },
  {
    "label": "Intersects()",
    "kind": "Method",
    "detail": "Function (template<TReal> bool)",
    "insertText": "Intersects(const TAABB<TReal, d>& Other)"
  },
  {
    "label": "GetIntersection()",
    "kind": "Method",
    "detail": "Function (} return true ; } TAABB<T,d>)",
    "insertText": "GetIntersection(const TAABB<T, d>& Other)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(const TVector<T, d>& Point)"
  },
  {
    "label": "PhiWithNormal()",
    "kind": "Method",
    "detail": "Function (TVector<FReal,d> Normal ; return)",
    "insertText": "PhiWithNormal(x, Normal)"
  },
  {
    "label": "PhiWithNormal()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "PhiWithNormal(const TVector<FReal, d>& X, TVector<FReal, d>& Normal)"
  },
  {
    "label": "MinAsTVecReal()",
    "kind": "Method",
    "detail": "Function (const TVector<FReal,d> MaxDists = X - MMax ; const TVector<FReal,d> MinDists = MMin - X ; const TVector<FReal,d>)",
    "insertText": "MinAsTVecReal(MMin)"
  },
  {
    "label": "MaxAsTVecReal()",
    "kind": "Method",
    "detail": "Function (const TVector<FReal,d>)",
    "insertText": "MaxAsTVecReal(MMax)"
  },
  {
    "label": "MaxAndAxis()",
    "kind": "Method",
    "detail": "Function (const Pair<FReal,int32> MaxAndAxis = TVector<FReal,d)",
    "insertText": "MaxAndAxis(MinDists, MaxDists)"
  },
  {
    "label": "AxisVector()",
    "kind": "Method",
    "detail": "Function (Normal = MaxDists [ MaxAndAxis . Second ]> MinDists [ MaxAndAxis . Second ] ? TVector<FReal,d)",
    "insertText": "AxisVector(MaxAndAxis.Second) : -TVector<FReal, d>::AxisVector(MaxAndAxis.Second)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Normal [ i ] = MaxDists [ i ] ; } else)",
    "insertText": "if(MinDists[i] > 0)"
  },
  {
    "label": "SafeNormalize()",
    "kind": "Method",
    "detail": "Function (Normal [ i ] = - MinDists [ i ] ; } else { Normal [ i ] = 0 ; } } FReal Phi = Normal .)",
    "insertText": "SafeNormalize()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Normal [ i ] = 1 ; } else)",
    "insertText": "if(Normal[i] < 0)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (Normal [ i ] = - 1 ; } } Normal .)",
    "insertText": "Normalize()"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (} return Phi ; } } bool)",
    "insertText": "Raycast(const TVector<FReal, d>& StartPoint, const TVector<FReal, d>& Dir, const FReal Length, const FReal Thickness, FReal& OutTime, TVector<FReal, d>& OutPosition, TVector<FReal, d>& OutNormal, int32& OutFaceIndex)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (const TVector<FReal,d> StartToMin = TVector<FReal,)",
    "insertText": "d(MMin)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (const TVector<FReal,d> StartToMax = TVector<FReal,)",
    "insertText": "d(MMax)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (FReal LatestStartTime = 0 ; FReal EarliestEndTime = TNumericLimits<FReal)",
    "insertText": "Max()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FReal Time1,Time2 ;)",
    "insertText": "if(bParallel[Axis])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else { Time1 = StartToMin [ Axis ]* InvDir [ Axis ] ; Time2 = StartToMax [ Axis ]* InvDir [ Axis ] ; })",
    "insertText": "if(Time1 > Time2)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(Time1, Time2)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} LatestStartTime =)",
    "insertText": "Max(LatestStartTime, Time1)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (EarliestEndTime =)",
    "insertText": "Min(EarliestEndTime, Time2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FReal RayEntryTime ; FReal RayExitTime ;)",
    "insertText": "if(RaycastFast(StartPoint, Dir, InvDir, bParallel, Length, InvLength, RayEntryTime, RayExitTime))"
  },
  {
    "label": "FindClosestPoint()",
    "kind": "Method",
    "detail": "Function (OutTime = RayEntryTime ; OutPosition = StartPoint + RayEntryTime* Dir ; return true ; } return false ; } TVector<T,d>)",
    "insertText": "FindClosestPoint(const TVector<T, d>& StartPoint, const T Thickness = (T)0)"
  },
  {
    "label": "FindClosestIntersectionImp()",
    "kind": "Method",
    "detail": "Function (Pair<TVector<FReal,d>,bool>)",
    "insertText": "FindClosestIntersectionImp(const TVector<FReal, d>& StartPoint, const TVector<FReal, d>& EndPoint, const FReal Thickness)"
  },
  {
    "label": "BestNormal()",
    "kind": "Method",
    "detail": "Function (TVector<T,d>)",
    "insertText": "BestNormal(OriginalNormal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const T TraceDotFaceNormal = DenormDir [ Axis ] ;)",
    "insertText": "if(TraceDotFaceNormal < BestOpposingDot)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (BestOpposingDot = TraceDotFaceNormal ; BestNormal = TVector<T,)",
    "insertText": "d(0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BestNormal [ Axis ] = 1 ; } } else)",
    "insertText": "if(OriginalNormal[Axis] < -UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "FVector()",
    "kind": "Method",
    "detail": "Function (BestOpposingDot = TraceDotFaceNormal ; BestNormal =)",
    "insertText": "FVector(0.f)"
  },
  {
    "label": "Support()",
    "kind": "Method",
    "detail": "Function (BestNormal [ Axis ] = - 1 . f ; } } } return BestNormal ; } TVector<T,d>)",
    "insertText": "Support(const TVector<T, d>& Direction, const T Thickness, int32& OutVertexIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TVector<T,d> ChosenPt ; FIntVector ChosenAxis ;)",
    "insertText": "for(int Axis = 0; Axis < d; ++Axis)"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (ChosenPt [ Axis ] = MMin [ Axis ] ; ChosenAxis [ Axis ] = 0 ; } else { ChosenPt [ Axis ] = MMax [ Axis ] ; ChosenAxis [ Axis ] = 1 ; } } OutVertexIndex =)",
    "insertText": "GetIndex(ChosenAxis)"
  },
  {
    "label": "SizeSquared()",
    "kind": "Method",
    "detail": "Function (T SizeSqr = Direction .)",
    "insertText": "SizeSquared()"
  },
  {
    "label": "GetSafeNormal()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> InflatedPt = ChosenPt + Normalized .)",
    "insertText": "GetSafeNormal()"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (FReal RootThreeMinusOne =)",
    "insertText": "FReal(1.7320508075688772935274463415059 - 1.0)"
  },
  {
    "label": "SupportCoreSimd()",
    "kind": "Method",
    "detail": "Function (* OutSupportDelta = RootThreeMinusOne* InMargin ; } return ChosenPt ; } VectorRegister4Float)",
    "insertText": "SupportCoreSimd(const VectorRegister4Float& Direction, const FReal InMargin)"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (FVec3 DirectionVec3 ;)",
    "insertText": "VectorStoreFloat3(Direction, &DirectionVec3)"
  },
  {
    "label": "SupportCore()",
    "kind": "Method",
    "detail": "Function (int32 VertexIndex = INDEX_NONE ; FVec3 SupportVert =)",
    "insertText": "SupportCore(DirectionVec3, InMargin, nullptr, VertexIndex)"
  },
  {
    "label": "SupportCoreScaled()",
    "kind": "Method",
    "detail": "Function (} TVector<T,d>)",
    "insertText": "SupportCoreScaled(const TVector<T, d>& Direction, const T InMargin, const TVector<T, d>& Scale, T* OutSupportDelta, int32& OutVertexIndex)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T RootThreeMinusOne =)",
    "insertText": "T(1.7320508075688772935274463415059 - 1.0)"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (* OutSupportDelta = RootThreeMinusOne* InMargin ; } return ChosenPt ; } void)",
    "insertText": "GrowToInclude(const TVector<T, d>& V)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (MMin = TVector<T,)",
    "insertText": "d(FGenericPlatformMath::Min(MMin[0], V[0]), FGenericPlatformMath::Min(MMin[1], V[1]), FGenericPlatformMath::Min(MMin[2], V[2]))"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (MMax = TVector<T,)",
    "insertText": "d(FGenericPlatformMath::Max(MMax[0], V[0]), FGenericPlatformMath::Max(MMax[1], V[1]), FGenericPlatformMath::Max(MMax[2], V[2]))"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GrowToInclude(const TAABB<T, d>& Other)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (MMin = TVector<T,)",
    "insertText": "d(FGenericPlatformMath::Min(MMin[0], Other.MMin[0]), FGenericPlatformMath::Min(MMin[1], Other.MMin[1]), FGenericPlatformMath::Min(MMin[2], Other.MMin[2]))"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (MMax = TVector<T,)",
    "insertText": "d(FGenericPlatformMath::Max(MMax[0], Other.MMax[0]), FGenericPlatformMath::Max(MMax[1], Other.MMax[1]), FGenericPlatformMath::Max(MMax[2], Other.MMax[2]))"
  },
  {
    "label": "ShrinkToInclude()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ShrinkToInclude(const TAABB<T, d>& Other)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (MMin = TVector<T,)",
    "insertText": "d(FGenericPlatformMath::Max(MMin[0], Other.MMin[0]), FGenericPlatformMath::Max(MMin[1], Other.MMin[1]), FGenericPlatformMath::Max(MMin[2], Other.MMin[2]))"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (MMax = TVector<T,)",
    "insertText": "d(FGenericPlatformMath::Min(MMax[0], Other.MMax[0]), FGenericPlatformMath::Min(MMax[1], Other.MMax[1]), FGenericPlatformMath::Min(MMax[2], Other.MMax[2]))"
  },
  {
    "label": "Thicken()",
    "kind": "Method",
    "detail": "Function (} TAABB<T,d>&)",
    "insertText": "Thicken(const T Thickness)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (MMin - = TVector<T,)",
    "insertText": "d(Thickness)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> AbsThickness = TVector<T,)",
    "insertText": "d(FGenericPlatformMath::Abs(Thickness.X), FGenericPlatformMath::Abs(Thickness.Y), FGenericPlatformMath::Abs(Thickness.Z))"
  },
  {
    "label": "ShrinkSymmetrically()",
    "kind": "Method",
    "detail": "Function (MMin - = AbsThickness ; MMax + = AbsThickness ; return* this ; } TAABB<T,d>&)",
    "insertText": "ShrinkSymmetrically(const TVector<T, d>& Thickness)"
  },
  {
    "label": "GrowByVector()",
    "kind": "Method",
    "detail": "Function (MMin + = AbsThickness ; MMax - = AbsThickness ; return* this ; } TAABB<T,d>&)",
    "insertText": "GrowByVector(const TVector<T, d>& V)"
  },
  {
    "label": "ComponentwiseMin()",
    "kind": "Method",
    "detail": "Function (MMin + = V .)",
    "insertText": "ComponentwiseMin(TVector<T, d>(0))"
  },
  {
    "label": "ComponentwiseMax()",
    "kind": "Method",
    "detail": "Function (MMax + = V .)",
    "insertText": "ComponentwiseMax(TVector<T, d>(0))"
  },
  {
    "label": "GetCenter()",
    "kind": "Method",
    "detail": "Function (} TVector<T,d>)",
    "insertText": "GetCenter()"
  },
  {
    "label": "GetCenterOfMass()",
    "kind": "Method",
    "detail": "Function (} TVector<T,d>)",
    "insertText": "GetCenterOfMass()"
  },
  {
    "label": "Extents()",
    "kind": "Method",
    "detail": "Function (} TVector<T,d>)",
    "insertText": "Extents()"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetIndex(const FIntVector& AxisSelector)"
  },
  {
    "label": "GetFace()",
    "kind": "Method",
    "detail": "Function (FAABBEdge Edges [ ] { { 0,1 },{ 0,2 },{ 0,4 },{ 1,3 },{ 1,5 },{ 2,3 },{ 2,6 },{ 3,7 },{ 4,5 },{ 4,6 },{ 5,7 },{ 6,7 } } ; return Edges [ Index ] ; } FAABBFace)",
    "insertText": "GetFace(const int32 Index)"
  },
  {
    "label": "LargestAxis()",
    "kind": "Method",
    "detail": "Function (FAABBFace Faces [ ] { { { 0,1,5,4 },{ 0,4,8,2 } },{ { 1,3,7,5 },{ 3,7,1 0,4 } },{ { 4,5,7,6 },{ 8,1 0,1 1,9 } },{ { 0,2,3,1 },{ 1,5,3,0 } },{ { 0,4,6,2 },{ 2,9,6,1 } },{ { 2,6,7,3 },{ 6,1 1,7,5 } } } ; return Faces [ Index ] ; } int)",
    "insertText": "LargestAxis()"
  },
  {
    "label": "FromPoints()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "FromPoints(MMin * InScale, MMax * InScale)"
  },
  {
    "label": "LocalScale()",
    "kind": "Method",
    "detail": "Function (MMin* = InScale ; MMax* = InScale ; return* this ; } TAABB<T,d>&)",
    "insertText": "LocalScale(const TVector<T, d>& InScale)"
  },
  {
    "label": "Extents()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> ScaledHalfExtents =)",
    "insertText": "Extents() * InScale * FReal(0.5)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (MMin = BoxCenter - ScaledHalfExtents ; MMax = BoxCenter + ScaledHalfExtents ; return* this ; } const TVector<T,d>&)",
    "insertText": "Min()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const TVector<T,d> MaxAbs = TVector<T,d)",
    "insertText": "Max(MMin.GetAbs(), MMax.GetAbs())"
  },
  {
    "label": "CenterRadius()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "CenterRadius()"
  },
  {
    "label": "GetArea()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetArea()"
  },
  {
    "label": "GetArea()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetArea(const TVector<T, d>& Dim)"
  },
  {
    "label": "GetVolume()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetVolume()"
  },
  {
    "label": "GetVolume()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetVolume(const TVector<T, 3>& Dim)"
  },
  {
    "label": "GetMargin()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetMargin()"
  },
  {
    "label": "FullAABB()",
    "kind": "Method",
    "detail": "Function (} TAABB<T,d>)",
    "insertText": "FullAABB()"
  },
  {
    "label": "ZeroAABB()",
    "kind": "Method",
    "detail": "Function (} TAABB<T,d>)",
    "insertText": "ZeroAABB()"
  },
  {
    "label": "IsFull()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsFull()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Serialize(FChaosArchive& Ar)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar<<MMin<<MMax ; } void)",
    "insertText": "Serialize(FArchive &Ar)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (Ar<<MMin<<MMax ; } uint32)",
    "insertText": "GetTypeHash()"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ToString()"
  },
  {
    "label": "GetInertiaTensor()",
    "kind": "Method",
    "detail": "Function (} PMatrix<FReal,d,d>)",
    "insertText": "GetInertiaTensor(const FReal Mass)"
  },
  {
    "label": "GetInertiaTensor()",
    "kind": "Method",
    "detail": "Function (} PMatrix<FReal,3,3>)",
    "insertText": "GetInertiaTensor(const FReal Mass, const TVector<FReal, 3>& Dim)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (const FReal M = Mass / 1 2 ; const FReal WW = Dim [ 0 ]* Dim [ 0 ] ; const FReal HH = Dim [ 1 ]* Dim [ 1 ] ; const FReal DD = Dim [ 2 ]* Dim [ 2 ] ; return PMatrix<)",
    "insertText": "FReal(M * (HH + DD), M * (WW + DD), M * (WW + HH))"
  },
  {
    "label": "GetRotationOfMass()",
    "kind": "Method",
    "detail": "Function (} TRotation<FReal,d>)",
    "insertText": "GetRotationOfMass()"
  },
  {
    "label": "IsConvex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsConvex()"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (TAABB<T,d>)",
    "insertText": "Result(P0, P0)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (AABB .)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<TVector<T,2>> SamplePoints ; SamplePoints .)",
    "insertText": "SetNum(8)"
  },
  {
    "label": "ComputeSamplePoints()",
    "kind": "Method",
    "detail": "Function (SamplePoints [ 0 ] = TVector<T,2> { Min . X,Min . Y } ; SamplePoints [ 1 ] = TVector<T,2> { Mid . X,Min . Y } ; SamplePoints [ 2 ] = TVector<T,2> { Max . X,Min . Y } ; SamplePoints [ 3 ] = TVector<T,2> { Min . X,Mid . Y } ; SamplePoints [ 4 ] = TVector<T,2> { Max . X,Mid . Y } ; SamplePoints [ 5 ] = TVector<T,2> { Min . X,Max . Y } ; SamplePoints [ 6 ] = TVector<T,2> { Mid . X,Max . Y } ; SamplePoints [ 7 ] = TVector<T,2> { Max . X,Max . Y } ; return SamplePoints ; } } ; template<T> struct TAABBSpecializeSamplingHelper<T,3> { TArray<TVector<T,3>>)",
    "insertText": "ComputeSamplePoints(const TAABB<T, 3>& AABB)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<TVector<T,3>> SamplePoints ; SamplePoints .)",
    "insertText": "SetNum(26)"
  }
]