[
  {
    "label": "BBox",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BBox"
  },
  {
    "label": "BBox()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_BBOX_HAS_BEEN_INCLUDED # define OPENVDB_MATH_BBOX_HAS_BEEN_INCLUDED # include \" Math . h \" # include \" Vec3 . h \" # include<algorithm> # include<cmath> # include<iostream> # include<limits> # include<type_traits> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { template<Vec3T> class BBox { public : using Vec3Type = Vec3T ; using ValueType = Vec3T ; using VectorType = Vec3T ; using ElementType = Vec3Type::ValueType ;)",
    "insertText": "BBox()"
  },
  {
    "label": "BBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BBox(const Vec3T& xyzMin, const Vec3T& xyzMax)"
  },
  {
    "label": "BBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BBox(const Vec3T& xyzMin, const Vec3T& xyzMax, bool sorted)"
  },
  {
    "label": "BBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BBox(const Vec3T& xyzMin, const ElementType& length)"
  },
  {
    "label": "BBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BBox(const ElementType* xyz, bool sorted = true)"
  },
  {
    "label": "BBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BBox(const BBox&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (BBox&)",
    "insertText": "operator(const BBox&)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (const Vec3T&)",
    "insertText": "min()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const BBox& rhs)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "hasVolume()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasVolume()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "isSorted()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isSorted()"
  },
  {
    "label": "getCenter()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "getCenter()"
  },
  {
    "label": "extents()",
    "kind": "Method",
    "detail": "Function (Vec3T)",
    "insertText": "extents()"
  },
  {
    "label": "maxExtent()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "maxExtent()"
  },
  {
    "label": "minExtent()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "minExtent()"
  },
  {
    "label": "volume()",
    "kind": "Method",
    "detail": "Function (} ElementType)",
    "insertText": "volume()"
  },
  {
    "label": "isInside()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isInside(const BBox&)"
  },
  {
    "label": "hasOverlap()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasOverlap(const BBox&)"
  },
  {
    "label": "intersects()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "intersects(const BBox& other)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "expand(ElementType padding)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "expand(const Vec3T& xyz)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "expand(const BBox&)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "expand(const Vec3T& xyzMin, const ElementType& length)"
  },
  {
    "label": "translate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "translate(const Vec3T& t)"
  },
  {
    "label": "applyMap()",
    "kind": "Method",
    "detail": "Function (template<MapType> BBox)",
    "insertText": "applyMap(const MapType& map)"
  },
  {
    "label": "applyInverseMap()",
    "kind": "Method",
    "detail": "Function (template<MapType> BBox)",
    "insertText": "applyInverseMap(const MapType& map)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "read(std::istream& is)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (mMin .)",
    "insertText": "read(is)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "write(std::ostream& os)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (mMin .)",
    "insertText": "write(os)"
  },
  {
    "label": "BBox()",
    "kind": "Method",
    "detail": "Function (} private : Vec3T mMin,mMax ; } ; template<Vec3T> BBox<Vec3T)",
    "insertText": "BBox(): mMin( std::numeric_limits<ElementType>::max()), mMax(-std::numeric_limits<ElementType>::max())"
  },
  {
    "label": "BBox()",
    "kind": "Method",
    "detail": "Function (} template<Vec3T> BBox<Vec3T)",
    "insertText": "BBox(const Vec3T& xyzMin, const Vec3T& xyzMax): mMin(xyzMin), mMax(xyzMax)"
  },
  {
    "label": "BBox()",
    "kind": "Method",
    "detail": "Function (} template<Vec3T> BBox<Vec3T)",
    "insertText": "BBox(const Vec3T& xyzMin, const Vec3T& xyzMax, bool sorted): mMin(xyzMin), mMax(xyzMax)"
  },
  {
    "label": "BBox()",
    "kind": "Method",
    "detail": "Function (} template<Vec3T> BBox<Vec3T)",
    "insertText": "BBox(const Vec3T& xyzMin, const ElementType& length): mMin(xyzMin), mMax(xyzMin)"
  },
  {
    "label": "BBox()",
    "kind": "Method",
    "detail": "Function (const ElementType size = std::is_integral<ElementType>::value ? length - 1 : length ; mMax [ 0 ] + = size ; mMax [ 1 ] + = size ; mMax [ 2 ] + = size ; } template<Vec3T> BBox<Vec3T)",
    "insertText": "BBox(const ElementType* xyz, bool sorted): mMin(xyz[0], xyz[1], xyz[2]), mMax(xyz[3], xyz[4], xyz[5])"
  },
  {
    "label": "isApproxEqual()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "isApproxEqual(mMin, rhs.min()) && math::isApproxEqual(mMax, rhs.max())"
  },
  {
    "label": "tMin()",
    "kind": "Method",
    "detail": "Function (Vec3T)",
    "insertText": "tMin(mMin), tMax(mMax)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (mMin [ i ] =)",
    "insertText": "min(tMin[i], tMax[i])"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (mMax [ i ] =)",
    "insertText": "max(tMin[i], tMax[i])"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} else { ElementType t = math::Tolerance<ElementType)",
    "insertText": "value()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(mMax - mMin)"
  },
  {
    "label": "isInside()",
    "kind": "Method",
    "detail": "Function (} } template<Vec3T> bool BBox<Vec3T)",
    "insertText": "isInside(const Vec3T& xyz)"
  },
  {
    "label": "isInside()",
    "kind": "Method",
    "detail": "Function (} } template<Vec3T> bool BBox<Vec3T)",
    "insertText": "isInside(const BBox& b)"
  },
  {
    "label": "hasOverlap()",
    "kind": "Method",
    "detail": "Function (} } template<Vec3T> bool BBox<Vec3T)",
    "insertText": "hasOverlap(const BBox& b)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} } template<Vec3T> void BBox<Vec3T)",
    "insertText": "expand(ElementType dx)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (dx =)",
    "insertText": "abs(dx)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (mMin [ i ] =)",
    "insertText": "min(mMin[i], xyz[i])"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (mMax [ i ] =)",
    "insertText": "max(mMax[i], xyz[i])"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} } template<Vec3T> void BBox<Vec3T)",
    "insertText": "expand(const BBox& b)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (mMin [ i ] =)",
    "insertText": "min(mMin[i], b.min()[i])"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (mMax [ i ] =)",
    "insertText": "max(mMax[i], b.max()[i])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const ElementType size = std::is_integral<ElementType>::value ? length - 1 : length ;)",
    "insertText": "for(int i = 0; i < 3; ++i)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (mMin [ i ] =)",
    "insertText": "min(mMin[i], xyzMin[i])"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (mMax [ i ] =)",
    "insertText": "max(mMax[i], xyzMin[i] + size)"
  },
  {
    "label": "translate()",
    "kind": "Method",
    "detail": "Function (} } template<Vec3T> void BBox<Vec3T)",
    "insertText": "translate(const Vec3T& dx)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (using Vec3R = Vec3<double> ; BBox<Vec3T> bbox ; bbox .)",
    "insertText": "expand(map.applyMap(Vec3R(mMin[0], mMin[1], mMin[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyMap(Vec3R(mMin[0], mMin[1], mMax[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyMap(Vec3R(mMin[0], mMax[1], mMin[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyMap(Vec3R(mMax[0], mMin[1], mMin[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyMap(Vec3R(mMax[0], mMax[1], mMin[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyMap(Vec3R(mMax[0], mMin[1], mMax[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyMap(Vec3R(mMin[0], mMax[1], mMax[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyMap(Vec3R(mMax[0], mMax[1], mMax[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (using Vec3R = Vec3<double> ; BBox<Vec3T> bbox ; bbox .)",
    "insertText": "expand(map.applyInverseMap(Vec3R(mMin[0], mMin[1], mMin[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyInverseMap(Vec3R(mMin[0], mMin[1], mMax[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyInverseMap(Vec3R(mMin[0], mMax[1], mMin[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyInverseMap(Vec3R(mMax[0], mMin[1], mMin[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyInverseMap(Vec3R(mMax[0], mMax[1], mMin[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyInverseMap(Vec3R(mMax[0], mMin[1], mMax[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyInverseMap(Vec3R(mMin[0], mMax[1], mMax[2])))"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(map.applyInverseMap(Vec3R(mMax[0], mMax[1], mMax[2])))"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (os<<b .)",
    "insertText": "min() << \" -> \" << b.max()"
  }
]