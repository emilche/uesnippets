[
  {
    "label": "Mat3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mat3"
  },
  {
    "label": "Vec3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Vec3"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_VEC3_HAS_BEEN_INCLUDED # define OPENVDB_MATH_VEC3_HAS_BEEN_INCLUDED # include<openvdb / Exceptions . h> # include \" Math . h \" # include \" Tuple . h \" # include<algorithm> # include<cmath> # include<type_traits> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { template<T> class Mat3 ; template<T> class Vec3 : public Tuple<3,T> { public : using value_type = T ; using ValueType = T ; # if OPENVDB_ABI_VERSION_NUMBER> = 8)",
    "insertText": "Vec3()"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "Vec3(T val)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = this -> mm [ 1 ] = this -> mm [ 2 ] = val ; })",
    "insertText": "Vec3(T x, T y, T z)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = x ; this -> mm [ 1 ] = y ; this -> mm [ 2 ] = z ; } template<Source>)",
    "insertText": "Vec3(Source *a)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = static_cast<)",
    "insertText": "T(a[0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] = static_cast<)",
    "insertText": "T(a[1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 2 ] = static_cast<)",
    "insertText": "T(a[2])"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (} template<Source>)",
    "insertText": "Vec3(const Tuple<3, Source> &v)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = static_cast<)",
    "insertText": "T(v[0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] = static_cast<)",
    "insertText": "T(v[1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 2 ] = static_cast<)",
    "insertText": "T(v[2])"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (} template<Other>)",
    "insertText": "Vec3(Other val, typename std::enable_if<std::is_arithmetic<Other>::value, Conversion>::type = Conversion{})"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = this -> mm [ 1 ] = this -> mm [ 2 ] = static_cast<)",
    "insertText": "T(val)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (} template<Other>)",
    "insertText": "Vec3(const Vec3<Other>& v)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "x()"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = x ; this -> mm [ 1 ] = y ; this -> mm [ 2 ] = z ; return* this ; } const Vec3<T>&)",
    "insertText": "setZero()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = 0 ; this -> mm [ 1 ] = 0 ; this -> mm [ 2 ] = 0 ; return* this ; } template<Source> const Vec3<T>&)",
    "insertText": "operator(const Vec3<Source> &v)"
  },
  {
    "label": "eq()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v [ 0 ] ; this -> mm [ 1 ] = v [ 1 ] ; this -> mm [ 2 ] = v [ 2 ] ; return* this ; } bool)",
    "insertText": "eq(const Vec3<T> &v, T eps = static_cast<T>(1.0e-7))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Vec3<T>)",
    "insertText": "operator()"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} template<T0,T1> const Vec3<T>&)",
    "insertText": "add(const Vec3<T0> &v1, const Vec3<T1> &v2)"
  },
  {
    "label": "sub()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v1 [ 0 ] + v2 [ 0 ] ; this -> mm [ 1 ] = v1 [ 1 ] + v2 [ 1 ] ; this -> mm [ 2 ] = v1 [ 2 ] + v2 [ 2 ] ; return* this ; } template<T0,T1> const Vec3<T>&)",
    "insertText": "sub(const Vec3<T0> &v1, const Vec3<T1> &v2)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v1 [ 0 ] - v2 [ 0 ] ; this -> mm [ 1 ] = v1 [ 1 ] - v2 [ 1 ] ; this -> mm [ 2 ] = v1 [ 2 ] - v2 [ 2 ] ; return* this ; } template<T0,T1> const Vec3<T>&)",
    "insertText": "scale(T0 scale, const Vec3<T1> &v)"
  },
  {
    "label": "div()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = scale* v [ 0 ] ; this -> mm [ 1 ] = scale* v [ 1 ] ; this -> mm [ 2 ] = scale* v [ 2 ] ; return* this ; } template<T0,T1> const Vec3<T>&)",
    "insertText": "div(T0 scale, const Vec3<T1> &v)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v [ 0 ] / scale ; this -> mm [ 1 ] = v [ 1 ] / scale ; this -> mm [ 2 ] = v [ 2 ] / scale ; return* this ; } T)",
    "insertText": "dot(const Vec3<T> &v)"
  },
  {
    "label": "lengthSqr()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "lengthSqr()"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (} const Vec3<T>&)",
    "insertText": "cross(const Vec3<T> &v1, const Vec3<T> &v2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v1 . mm [ 1 ]* v2 . mm [ 2 ] - v1 . mm [ 2 ]* v2 . mm [ 1 ] ; this -> mm [ 1 ] = v1 . mm [ 2 ]* v2 . mm [ 0 ] - v1 . mm [ 0 ]* v2 . mm [ 2 ] ; this -> mm [ 2 ] = v1 . mm [ 0 ]* v2 . mm [ 1 ] - v1 . mm [ 1 ]* v2 . mm [ 0 ] ; return* this ; } template<S> const Vec3<T>&)",
    "insertText": "operator(S scalar)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN const auto value0 = this -> mm [ 0 ]* scalar ; const auto value1 = this -> mm [ 1 ]* scalar ; const auto value2 = this -> mm [ 2 ]* scalar ; OPENVDB_NO_TYPE_CONVERSION_WARNING_END this -> mm [ 0 ] = static_cast<)",
    "insertText": "T(value0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] = static_cast<)",
    "insertText": "T(value1)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 2 ] = static_cast<)",
    "insertText": "T(value2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] / = scalar ; this -> mm [ 1 ] / = scalar ; this -> mm [ 2 ] / = scalar ; return* this ; } template<S> const Vec3<T>&)",
    "insertText": "operator(const Vec3<S> &v1)"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] - = v1 [ 0 ] ; this -> mm [ 1 ] - = v1 [ 1 ] ; this -> mm [ 2 ] - = v1 [ 2 ] ; return* this ; } const Vec3<T>&)",
    "insertText": "exp()"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] =)",
    "insertText": "exp(this->mm[0])"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] =)",
    "insertText": "exp(this->mm[1])"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 2 ] =)",
    "insertText": "exp(this->mm[2])"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] =)",
    "insertText": "log(this->mm[0])"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] =)",
    "insertText": "log(this->mm[1])"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 2 ] =)",
    "insertText": "log(this->mm[2])"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (T d =)",
    "insertText": "length()"
  },
  {
    "label": "unit()",
    "kind": "Method",
    "detail": "Function (T d ; return)",
    "insertText": "unit(eps, d)"
  },
  {
    "label": "unit()",
    "kind": "Method",
    "detail": "Function (} Vec3<T>)",
    "insertText": "unit(T eps, T& len)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"Normalizing null 3-vector\")"
  },
  {
    "label": "unitSafe()",
    "kind": "Method",
    "detail": "Function (} return* this / len ; } Vec3<T>)",
    "insertText": "unitSafe()"
  },
  {
    "label": "numRows()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "numRows()"
  },
  {
    "label": "projection()",
    "kind": "Method",
    "detail": "Function (} Vec3<T>)",
    "insertText": "projection(const Vec3<T> &onto, T eps = static_cast<T>(1.0e-7))"
  },
  {
    "label": "getArbPerpendicular()",
    "kind": "Method",
    "detail": "Function (} Vec3<T>)",
    "insertText": "getArbPerpendicular()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3<T> u ; T l ;)",
    "insertText": "if(fabs(this->mm[0]) >= fabs(this->mm[1]))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (l = this -> mm [ 0 ]* this -> mm [ 0 ] + this -> mm [ 2 ]* this -> mm [ 2 ] ; l = static_cast<)",
    "insertText": "T(T(1)/sqrt(double(l)))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (u . mm [ 0 ] = - this -> mm [ 2 ]* l ; u . mm [ 1 ] =)",
    "insertText": "T(0)"
  },
  {
    "label": "sorted()",
    "kind": "Method",
    "detail": "Function (u . mm [ 1 ] = + this -> mm [ 2 ]* l ; u . mm [ 2 ] = - this -> mm [ 1 ]* l ; } return u ; } Vec3<T>)",
    "insertText": "sorted()"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "r(*this)"
  },
  {
    "label": "zero()",
    "kind": "Method",
    "detail": "Function (} Vec3<T>)",
    "insertText": "zero()"
  },
  {
    "label": "ones()",
    "kind": "Method",
    "detail": "Function (} Vec3<T>)",
    "insertText": "ones()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<T0,T1> bool)",
    "insertText": "operator(const Vec3<T0> &v0, const Vec3<T1> &v1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<S,T> Vec3<promote<S,T>::type>)",
    "insertText": "operator(S scalar, const Vec3<T> &v)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec3<promote<S,T>::type>)",
    "insertText": "result(v)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec3<promote<T0,T1>::type>)",
    "insertText": "result(v0[0] * v1[0], v0[1] * v1[1], v0[2] * v1[2])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<S,T> Vec3<promote<S,T>::type>)",
    "insertText": "operator(const Vec3<T> &v, S scalar)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec3<promote<T0,T1>::type>)",
    "insertText": "result(v0[0] / v1[0], v0[1] / v1[1], v0[2] / v1[2])"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec3<promote<T0,T1>::type>)",
    "insertText": "result(v0)"
  },
  {
    "label": "angle()",
    "kind": "Method",
    "detail": "Function (result - = scalar ; return result ; } template<T> T)",
    "insertText": "angle(const Vec3<T> &v1, const Vec3<T> &v2)"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (Vec3<T> c = v1 .)",
    "insertText": "cross(v2)"
  },
  {
    "label": "isApproxEqual()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "isApproxEqual(const Vec3<T>& a, const Vec3<T>& b)"
  },
  {
    "label": "isApproxEqual()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "isApproxEqual(const Vec3<T>& a, const Vec3<T>& b, const Vec3<T>& eps)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec3<T>)",
    "insertText": "Abs(const Vec3<T>& v)"
  },
  {
    "label": "orthonormalize()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "orthonormalize(Vec3<T> &v1, Vec3<T> &v2, Vec3<T> &v3)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (v1 .)",
    "insertText": "normalize()"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (T d0 = v1 .)",
    "insertText": "dot(v2)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (T d1 = v2 .)",
    "insertText": "dot(v3)"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec3<T>)",
    "insertText": "minComponent(const Vec3<T> &v1, const Vec3<T> &v2)"
  },
  {
    "label": "maxComponent()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec3<T>)",
    "insertText": "maxComponent(const Vec3<T> &v1, const Vec3<T> &v2)"
  },
  {
    "label": "Exp()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec3<T>)",
    "insertText": "Exp(Vec3<T> v)"
  },
  {
    "label": "Log()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec3<T>)",
    "insertText": "Log(Vec3<T> v)"
  }
]