[
  {
    "label": "TDefaultDelete",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TDefaultDelete"
  },
  {
    "label": "TUniquePtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TUniquePtr"
  },
  {
    "label": "TIsZeroConstructType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsZeroConstructType"
  },
  {
    "label": "TIsBitwiseConstructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsBitwiseConstructible"
  },
  {
    "label": "DECLARE_INLINE_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Templates / UnrealTemplate . h \" # include \" Templates / IsArray . h \" # include \" Templates / RemoveExtent . h \" # include \" Templates / Requires . h \" # include \" Serialization / MemoryLayout . h \" # include<type_traits> template<T> struct TDefaultDelete {)",
    "insertText": "DECLARE_INLINE_TYPE_LAYOUT(TDefaultDelete, NonVirtual)"
  },
  {
    "label": "TDefaultDelete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDefaultDelete()"
  },
  {
    "label": "TDefaultDelete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDefaultDelete(const TDefaultDelete&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TDefaultDelete&)",
    "insertText": "operator(const TDefaultDelete&)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > TDefaultDelete(const TDefaultDelete<U>&)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > TDefaultDelete& operator=(const TDefaultDelete<U>&)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U(*)[], T(*)[]>) > TDefaultDelete(const TDefaultDelete<U[]>&)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U(*)[], T(*)[]>) > TDefaultDelete& operator=(const TDefaultDelete<U[]>&)"
  },
  {
    "label": "DECLARE_INLINE_TYPE_LAYOUT_EXPLICIT_BASES()",
    "kind": "Method",
    "detail": "Function (delete [ ] Ptr ; } } ; template<T,Deleter = TDefaultDelete<T>> class TUniquePtr : private Deleter {)",
    "insertText": "DECLARE_INLINE_TYPE_LAYOUT_EXPLICIT_BASES(TUniquePtr, NonVirtual, Deleter)"
  },
  {
    "label": "TUniquePtr()",
    "kind": "Method",
    "detail": "Function (template<OtherT,OtherDeleter> class TUniquePtr ; public : using ElementType = T ;)",
    "insertText": "TUniquePtr(const TUniquePtr&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TUniquePtr&)",
    "insertText": "operator(const TUniquePtr&)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > explicit FORCEINLINE TUniquePtr(U* InPtr) : Deleter() , Ptr (InPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > explicit FORCEINLINE TUniquePtr(U* InPtr, Deleter&& InDeleter) : Deleter(MoveTemp(InDeleter)) , Ptr (InPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U*, T*>) > explicit FORCEINLINE TUniquePtr(U* InPtr, const Deleter& InDeleter) : Deleter(InDeleter) , Ptr (InPtr)"
  },
  {
    "label": "TUniquePtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TUniquePtr(TYPE_OF_NULLPTR) : Deleter() , Ptr (nullptr)"
  },
  {
    "label": "TUniquePtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TUniquePtr(TUniquePtr&& Other) : Deleter(MoveTemp(Other.GetDeleter())) , Ptr (Other.Ptr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (Other . Ptr = nullptr ; } template<OtherT,OtherDeleter)",
    "insertText": "UE_REQUIRES(!std::is_array_v<OtherT> && std::is_convertible_v<OtherT*, T*> ) > FORCEINLINE TUniquePtr(TUniquePtr<OtherT, OtherDeleter>&& Other) : Deleter(MoveTemp(Other.GetDeleter())) , Ptr (Other.Ptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Other . Ptr = nullptr ; } TUniquePtr&)",
    "insertText": "operator(TUniquePtr&& Other)"
  },
  {
    "label": "GetDeleter()",
    "kind": "Method",
    "detail": "Function (T* OldPtr = Ptr ; Ptr = Other . Ptr ; Other . Ptr = nullptr ;)",
    "insertText": "GetDeleter()(OldPtr)"
  },
  {
    "label": "GetDeleter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "GetDeleter() = MoveTemp(Other.GetDeleter())"
  },
  {
    "label": "GetDeleter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetDeleter()(Ptr)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] T*)",
    "insertText": "operator()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (T* Result = Ptr ; Ptr = nullptr ; return Result ; } void)",
    "insertText": "Reset(T* InPtr = nullptr)"
  },
  {
    "label": "GetDeleter()",
    "kind": "Method",
    "detail": "Function (} } [ [ nodiscard ] ] Deleter&)",
    "insertText": "GetDeleter()"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (} private : using PtrType = T* ;)",
    "insertText": "LAYOUT_FIELD(PtrType, Ptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (public : template<RhsT> [ [ nodiscard ] ] bool)",
    "insertText": "operator(const TUniquePtr<RhsT>& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "operator(TYPE_OF_NULLPTR)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U(*)[], T(*)[]>) > explicit FORCEINLINE TUniquePtr(U* InPtr) : Deleter() , Ptr (InPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U(*)[], T(*)[]>) > explicit FORCEINLINE TUniquePtr(U* InPtr, Deleter&& InDeleter) : Deleter(MoveTemp(InDeleter)) , Ptr (InPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U(*)[], T(*)[]>) > explicit FORCEINLINE TUniquePtr(U* InPtr, const Deleter& InDeleter) : Deleter(InDeleter) , Ptr (InPtr)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (Other . Ptr = nullptr ; } template<OtherT,OtherDeleter)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<OtherT(*)[], T(*)[]>) > FORCEINLINE TUniquePtr(TUniquePtr<OtherT, OtherDeleter>&& Other) : Deleter(MoveTemp(Other.GetDeleter())) , Ptr (Other.Ptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] T&)",
    "insertText": "operator(SIZE_T Index)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (T* Result = Ptr ; Ptr = nullptr ; return Result ; } template<U)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<U(*)[], T(*)[]>) > FORCEINLINE void Reset(U* InPtr)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset(TYPE_OF_NULLPTR InPtr = nullptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif } ; # if ! PLATFORM_COMPILER_HAS_GENERATED_COMPARISON_OPERATORS template<T> [ [ nodiscard ] ] bool)",
    "insertText": "operator(TYPE_OF_NULLPTR, const TUniquePtr<T>& Rhs)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} # endif template<T> struct TIsZeroConstructType<TUniquePtr<T>> { enum { Value = true } ; } ; template<T> struct TIsBitwiseConstructible<TUniquePtr<T>,T*> { enum { Value = true } ; } ; template<T,. . . TArgs)",
    "insertText": "UE_REQUIRES(!std::is_array_v<T>) > [[nodiscard]] FORCEINLINE TUniquePtr<T> MakeUnique(TArgs&&... Args)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,. . . TArgs)",
    "insertText": "UE_REQUIRES(!std::is_array_v<T>) > [[nodiscard]] FORCEINLINE TUniquePtr<T> MakeUniqueForOverwrite()"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T)",
    "insertText": "UE_REQUIRES(TIsUnboundedArray<T>::Value) > [[nodiscard]] FORCEINLINE TUniquePtr<T> MakeUnique(SIZE_T Size)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (using ElementType = std::remove_extent_t<T> ; return TUniquePtr<)",
    "insertText": "T(new ElementType[Size]())"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T)",
    "insertText": "UE_REQUIRES(TIsUnboundedArray<T>::Value) > [[nodiscard]] FORCEINLINE TUniquePtr<T> MakeUniqueForOverwrite(SIZE_T Size)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (using ElementType = std::remove_extent_t<T> ; return TUniquePtr<)",
    "insertText": "T(new ElementType[Size])"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,. . . TArgs)",
    "insertText": "UE_REQUIRES(TIsBoundedArray<T>::Value) > TUniquePtr<T> MakeUnique(TArgs&&... Args)"
  }
]