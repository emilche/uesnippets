[
  {
    "label": "ZenServerState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ZenServerState"
  },
  {
    "label": "ZenServerEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ZenServerEntry"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "ZenSharedEvent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ZenSharedEvent"
  },
  {
    "label": "ZenLockFileData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ZenLockFileData"
  },
  {
    "label": "ZenServerState()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / StringFwd . h \" # include \" Serialization / CompactBinary . h \" # include \" Containers / AnsiString . h \" class ZenServerState { public :)",
    "insertText": "ZenServerState(bool ReadOnly)"
  },
  {
    "label": "ZenServerState()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ZenServerState()"
  },
  {
    "label": "AddSponsorProcess()",
    "kind": "Method",
    "detail": "Function (struct ZenServerEntry { std::atomic<uint32> Pid ; std::atomic<uint16> DesiredListenPort ; std::atomic<uint16> Flags ; uint8 SessionId [ 1 2 ] ; std::atomic<uint32> SponsorPids [ 8 ] ; std::atomic<uint16> EffectiveListenPort ; uint8 Padding [ 1 0 ] ; enum class FlagsEnum : uint16 { kShutdownPlease = 1<<0,kIsReady = 1<<1,} ; bool)",
    "insertText": "AddSponsorProcess(uint32 PidToAdd)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "static_assert(sizeof(ZenServerEntry) == 64)"
  },
  {
    "label": "LookupByDesiredListenPort()",
    "kind": "Method",
    "detail": "Function (const ZenServerEntry*)",
    "insertText": "LookupByDesiredListenPort(int DesiredListenPort)"
  },
  {
    "label": "LookupByEffectiveListenPort()",
    "kind": "Method",
    "detail": "Function (const ZenServerEntry*)",
    "insertText": "LookupByEffectiveListenPort(int EffectiveListenPort)"
  },
  {
    "label": "LookupByPid()",
    "kind": "Method",
    "detail": "Function (const ZenServerEntry*)",
    "insertText": "LookupByPid(uint32 Pid)"
  },
  {
    "label": "IsProcessRunning()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsProcessRunning(uint32 Pid)"
  },
  {
    "label": "Terminate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Terminate(uint32 Pid)"
  },
  {
    "label": "FindRunningProcessId()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FindRunningProcessId(const TCHAR* ExecutablePath, uint32* OutPid)"
  },
  {
    "label": "LookupByDesiredListenPortInternal()",
    "kind": "Method",
    "detail": "Function (private : const ZenServerEntry*)",
    "insertText": "LookupByDesiredListenPortInternal(int DesiredListenPort)"
  },
  {
    "label": "LookupByEffectiveListenPortInternal()",
    "kind": "Method",
    "detail": "Function (const ZenServerEntry*)",
    "insertText": "LookupByEffectiveListenPortInternal(int EffectiveListenPort)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (void* m_hMapFile = nullptr ; ZenServerEntry* m_Data = nullptr ; int m_MaxEntryCount = 6 5 5 3 6 /)",
    "insertText": "sizeof(ZenServerEntry)"
  },
  {
    "label": "ZenSharedEvent()",
    "kind": "Method",
    "detail": "Function (bool m_IsReadOnly = true ; } ; class ZenSharedEvent { public :)",
    "insertText": "ZenSharedEvent()"
  },
  {
    "label": "ZenSharedEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ZenSharedEvent(const ZenSharedEvent&)"
  },
  {
    "label": "ZenSharedEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ZenSharedEvent(ZenSharedEvent&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ZenSharedEvent&)",
    "insertText": "operator(const ZenSharedEvent&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ZenSharedEvent&)",
    "insertText": "operator(ZenSharedEvent&&)"
  },
  {
    "label": "ZenSharedEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ZenSharedEvent(FStringView EventName)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Create()"
  },
  {
    "label": "Exists()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Exists()"
  },
  {
    "label": "Open()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Open()"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Wait(int TimeoutMs = -1)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Set()"
  },
  {
    "label": "Close()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Close()"
  },
  {
    "label": "GetShutdownEventName()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "GetShutdownEventName(uint16 EffectiveListenPort)"
  },
  {
    "label": "GetStartupEventName()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "GetStartupEventName()"
  },
  {
    "label": "GetFullEventName()",
    "kind": "Method",
    "detail": "Function (private : FString m_EventName ; # if PLATFORM_WINDOWS FString)",
    "insertText": "GetFullEventName()"
  },
  {
    "label": "GetEventPath()",
    "kind": "Method",
    "detail": "Function (void* m_EventHandle = NULL ; # elif PLATFORM_UNIX | | PLATFORM_MAC FAnsiString)",
    "insertText": "GetEventPath()"
  },
  {
    "label": "IsLockFileLocked()",
    "kind": "Method",
    "detail": "Function (int m_Fd = - 1 ; int m_Semaphore = - 1 ; FAnsiString m_EventPath ; # endif } ; struct ZenLockFileData { uint32 ProcessId = 0 ; FString DataDir ; uint16 EffectivePort = 0 ; FCbObjectId SessionId ; bool IsReady = false ; bool IsValid = false ; bool)",
    "insertText": "IsLockFileLocked(const TCHAR* FileName, bool bAttemptCleanUp = false)"
  },
  {
    "label": "ReadCbLockFile()",
    "kind": "Method",
    "detail": "Function (ZenLockFileData)",
    "insertText": "ReadCbLockFile(const TCHAR* FileName)"
  }
]