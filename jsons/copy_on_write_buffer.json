[
  {
    "label": "RTC_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RTC_EXPORT"
  },
  {
    "label": "CopyOnWriteBuffer()",
    "kind": "Method",
    "detail": "Function (# ifndef RTC_BASE_COPY_ON_WRITE_BUFFER_H_ # define RTC_BASE_COPY_ON_WRITE_BUFFER_H_ # include<stdint . h> # include<algorithm> # include<cstring> # include<string> # include<type_traits> # include<utility> # include \" absl / strings / string_view . h \" # include \" api / scoped_refptr . h \" # include \" rtc_base / buffer . h \" # include \" rtc_base / checks . h \" # include \" rtc_base / ref_counted_object . h \" # include \" rtc_base / system / rtc_export . h \" # include \" rtc_base / type_traits . h \" namespace rtc { class RTC_EXPORT CopyOnWriteBuffer { public :)",
    "insertText": "CopyOnWriteBuffer()"
  },
  {
    "label": "CopyOnWriteBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyOnWriteBuffer(const CopyOnWriteBuffer& buf)"
  },
  {
    "label": "CopyOnWriteBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyOnWriteBuffer(CopyOnWriteBuffer&& buf)"
  },
  {
    "label": "CopyOnWriteBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyOnWriteBuffer(absl::string_view s)"
  },
  {
    "label": "CopyOnWriteBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyOnWriteBuffer(size_t size)"
  },
  {
    "label": "CopyOnWriteBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyOnWriteBuffer(size_t size, size_t capacity)"
  },
  {
    "label": "CopyOnWriteBuffer()",
    "kind": "Method",
    "detail": "Function (template<T,std::enable_if<internal::BufferCompat<uint8_t,T>::value>::type* = nullptr>)",
    "insertText": "CopyOnWriteBuffer(const T* data, size_t size) : CopyOnWriteBuffer(data, size, size)"
  },
  {
    "label": "CopyOnWriteBuffer()",
    "kind": "Method",
    "detail": "Function (} template<T,std::enable_if<internal::BufferCompat<uint8_t,T>::value>::type* = nullptr>)",
    "insertText": "CopyOnWriteBuffer(const T* data, size_t size, size_t capacity) : CopyOnWriteBuffer(size, capacity)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(buffer_->data(), data, size)"
  },
  {
    "label": "CopyOnWriteBuffer()",
    "kind": "Method",
    "detail": "Function (offset_ = 0 ; size_ = size ; } } template<T,size_t N,std::enable_if<internal::BufferCompat<uint8_t,T>::value>::type* = nullptr>)",
    "insertText": "CopyOnWriteBuffer(const T (&array)[N]) : CopyOnWriteBuffer(array, N)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<VecT,ElemT = std::remove_pointer_t<)",
    "insertText": "decltype(std::declval<VecT>().data())>, typename std::enable_if_t< !std::is_same<VecT, CopyOnWriteBuffer>::value && HasDataAndSize<VecT, ElemT>::value && internal::BufferCompat<uint8_t, ElemT>::value>* = nullptr> explicit CopyOnWriteBuffer(const VecT& v) : CopyOnWriteBuffer(v.data(), v.size())"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (template<T = uint8_t,std::enable_if<internal::BufferCompat<uint8_t,T>::value>::type* = nullptr> const T*)",
    "insertText": "data()"
  },
  {
    "label": "MutableData()",
    "kind": "Method",
    "detail": "Function (} template<T = uint8_t,std::enable_if<internal::BufferCompat<uint8_t,T>::value>::type* = nullptr> T*)",
    "insertText": "MutableData()"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(IsConsistent())"
  },
  {
    "label": "cdata()",
    "kind": "Method",
    "detail": "Function (} template<T = uint8_t,std::enable_if<internal::BufferCompat<uint8_t,T>::value>::type* = nullptr> const T*)",
    "insertText": "cdata()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "size()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} CopyOnWriteBuffer&)",
    "insertText": "operator(const CopyOnWriteBuffer& buf)"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(buf.IsConsistent())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (buffer_ = buf . buffer_ ; offset_ = buf . offset_ ; size_ = buf . size_ ; } return* this ; } CopyOnWriteBuffer&)",
    "insertText": "operator(CopyOnWriteBuffer&& buf)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (buffer_ =)",
    "insertText": "move(buf.buffer_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} uint8_t)",
    "insertText": "operator(size_t index)"
  },
  {
    "label": "RTC_DCHECK_LT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_LT(index, size())"
  },
  {
    "label": "SetData()",
    "kind": "Method",
    "detail": "Function (} template<T,std::enable_if<internal::BufferCompat<uint8_t,T>::value>::type* = nullptr> void)",
    "insertText": "SetData(const T* data, size_t size)"
  },
  {
    "label": "RefCountedBuffer()",
    "kind": "Method",
    "detail": "Function (buffer_ = size> 0 ? new)",
    "insertText": "RefCountedBuffer(data, size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!buffer_->HasOneRef())"
  },
  {
    "label": "RefCountedBuffer()",
    "kind": "Method",
    "detail": "Function (buffer_ = new)",
    "insertText": "RefCountedBuffer(data, size, capacity())"
  },
  {
    "label": "SetData()",
    "kind": "Method",
    "detail": "Function (} else { buffer_ ->)",
    "insertText": "SetData(data, size)"
  },
  {
    "label": "SetData()",
    "kind": "Method",
    "detail": "Function (} template<T,size_t N,std::enable_if<internal::BufferCompat<uint8_t,T>::value>::type* = nullptr> void)",
    "insertText": "SetData(const T (&array)[N])"
  },
  {
    "label": "SetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetData(array, N)"
  },
  {
    "label": "SetData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetData(const CopyOnWriteBuffer& buf)"
  },
  {
    "label": "AppendData()",
    "kind": "Method",
    "detail": "Function (buffer_ = buf . buffer_ ; offset_ = buf . offset_ ; size_ = buf . size_ ; } } template<T,std::enable_if<internal::BufferCompat<uint8_t,T>::value>::type* = nullptr> void)",
    "insertText": "AppendData(const T* data, size_t size)"
  },
  {
    "label": "SetSize()",
    "kind": "Method",
    "detail": "Function (buffer_ ->)",
    "insertText": "SetSize(offset_ + size_)"
  },
  {
    "label": "AppendData()",
    "kind": "Method",
    "detail": "Function (buffer_ ->)",
    "insertText": "AppendData(data, size)"
  },
  {
    "label": "AppendData()",
    "kind": "Method",
    "detail": "Function (} template<T,size_t N,std::enable_if<internal::BufferCompat<uint8_t,T>::value>::type* = nullptr> void)",
    "insertText": "AppendData(const T (&array)[N])"
  },
  {
    "label": "AppendData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendData(array, N)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<VecT,ElemT = std::remove_pointer_t<)",
    "insertText": "decltype(std::declval<VecT>().data())>, typename std::enable_if_t< HasDataAndSize<VecT, ElemT>::value && internal::BufferCompat<uint8_t, ElemT>::value>* = nullptr> void AppendData(const VecT& v)"
  },
  {
    "label": "AppendData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendData(v.data(), v.size())"
  },
  {
    "label": "SetSize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSize(size_t size)"
  },
  {
    "label": "EnsureCapacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnsureCapacity(size_t capacity)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear()"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(CopyOnWriteBuffer& a, CopyOnWriteBuffer& b)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (a . buffer_ .)",
    "insertText": "swap(b.buffer_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(a.offset_, b.offset_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(a.size_, b.size_)"
  },
  {
    "label": "Slice()",
    "kind": "Method",
    "detail": "Function (} CopyOnWriteBuffer)",
    "insertText": "Slice(size_t offset, size_t length)"
  },
  {
    "label": "slice()",
    "kind": "Method",
    "detail": "Function (CopyOnWriteBuffer)",
    "insertText": "slice(*this)"
  },
  {
    "label": "RTC_DCHECK_LE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_LE(offset, size_)"
  },
  {
    "label": "RTC_DCHECK_LE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_LE(length + offset, size_)"
  },
  {
    "label": "UnshareAndEnsureCapacity()",
    "kind": "Method",
    "detail": "Function (slice . offset_ + = offset ; slice . size_ = length ; return slice ; } private : using RefCountedBuffer = FinalRefCountedObject<Buffer> ; void)",
    "insertText": "UnshareAndEnsureCapacity(size_t new_capacity)"
  },
  {
    "label": "IsConsistent()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsConsistent()"
  }
]