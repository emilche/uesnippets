[
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "Sequence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Sequence"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "DelayedTaskGreater",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DelayedTaskGreater"
  },
  {
    "label": "Transaction()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TASK_THREAD_POOL_SEQUENCE_H_ # define BASE_TASK_THREAD_POOL_SEQUENCE_H_ # include<stddef . h> # include \" base / base_export . h \" # include \" base / containers / intrusive_heap . h \" # include \" base / containers / queue . h \" # include \" base / sequence_token . h \" # include \" base / task / task_traits . h \" # include \" base / task / thread_pool / pooled_parallel_task_runner . h \" # include \" base / task / thread_pool / task . h \" # include \" base / task / thread_pool / task_source . h \" # include \" base / task / thread_pool / task_source_sort_key . h \" # include \" base / threading / sequence_local_storage_map . h \" namespace base { namespace internal { class BASE_EXPORT Sequence : public TaskSource { public : class BASE_EXPORT Transaction : public TaskSource::Transaction { public :)",
    "insertText": "Transaction(Transaction&& other)"
  },
  {
    "label": "Transaction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Transaction(const Transaction&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Transaction&)",
    "insertText": "operator(const Transaction&)"
  },
  {
    "label": "Transaction()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "Transaction()"
  },
  {
    "label": "ShouldBeQueued()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "ShouldBeQueued()"
  },
  {
    "label": "TopDelayedTaskWillChange()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TopDelayedTaskWillChange(Task& delayed_task)"
  },
  {
    "label": "PushImmediateTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PushImmediateTask(Task task)"
  },
  {
    "label": "PushDelayedTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PushDelayedTask(Task task)"
  },
  {
    "label": "sequence()",
    "kind": "Method",
    "detail": "Function (Sequence*)",
    "insertText": "sequence()"
  },
  {
    "label": "Transaction()",
    "kind": "Method",
    "detail": "Function (} private : class Sequence ;)",
    "insertText": "Transaction(Sequence* sequence)"
  },
  {
    "label": "Sequence()",
    "kind": "Method",
    "detail": "Function (} ; enum class SequenceLocation { kNone,kImmediateQueue,kDelayedQueue,kInWorker,} ;)",
    "insertText": "Sequence(const TaskTraits& traits, TaskRunner* task_runner, TaskSourceExecutionMode execution_mode)"
  },
  {
    "label": "Sequence()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Sequence(const Sequence&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Sequence&)",
    "insertText": "operator(const Sequence&)"
  },
  {
    "label": "BeginTransaction()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] Transaction)",
    "insertText": "BeginTransaction()"
  },
  {
    "label": "GetExecutionEnvironment()",
    "kind": "Method",
    "detail": "Function (ExecutionEnvironment)",
    "insertText": "GetExecutionEnvironment()"
  },
  {
    "label": "GetRemainingConcurrency()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetRemainingConcurrency()"
  },
  {
    "label": "GetSortKey()",
    "kind": "Method",
    "detail": "Function (TaskSourceSortKey)",
    "insertText": "GetSortKey()"
  },
  {
    "label": "GetDelayedSortKey()",
    "kind": "Method",
    "detail": "Function (TimeTicks)",
    "insertText": "GetDelayedSortKey()"
  },
  {
    "label": "token()",
    "kind": "Method",
    "detail": "Function (const SequenceToken&)",
    "insertText": "token()"
  },
  {
    "label": "OnBecomeReady()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnBecomeReady()"
  },
  {
    "label": "Sequence()",
    "kind": "Method",
    "detail": "Function (private : ~)",
    "insertText": "Sequence()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (struct DelayedTaskGreater { bool)",
    "insertText": "operator()(const Task& lhs, const Task& rhs)"
  },
  {
    "label": "WillRunTask()",
    "kind": "Method",
    "detail": "Function (} ; RunStatus)",
    "insertText": "WillRunTask()"
  },
  {
    "label": "TakeTask()",
    "kind": "Method",
    "detail": "Function (Task)",
    "insertText": "TakeTask(TaskSource::Transaction* transaction)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (Task)",
    "insertText": "Clear(TaskSource::Transaction* transaction)"
  },
  {
    "label": "DidProcessTask()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DidProcessTask(TaskSource::Transaction* transaction)"
  },
  {
    "label": "WillReEnqueue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WillReEnqueue(TimeTicks now, TaskSource::Transaction* transaction)"
  },
  {
    "label": "TakeEarliestTask()",
    "kind": "Method",
    "detail": "Function (Task)",
    "insertText": "TakeEarliestTask()"
  },
  {
    "label": "TakeNextImmediateTask()",
    "kind": "Method",
    "detail": "Function (Task)",
    "insertText": "TakeNextImmediateTask()"
  },
  {
    "label": "GetNextReadyTime()",
    "kind": "Method",
    "detail": "Function (TimeTicks)",
    "insertText": "GetNextReadyTime()"
  },
  {
    "label": "HasImmediateTasks()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasImmediateTasks()"
  },
  {
    "label": "HasRipeDelayedTasks()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasRipeDelayedTasks(TimeTicks now)"
  },
  {
    "label": "HasReadyTasks()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasReadyTasks(TimeTicks now)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "GetReadyTime()",
    "kind": "Method",
    "detail": "Function (TimeTicks)",
    "insertText": "GetReadyTime()"
  },
  {
    "label": "ReleaseTaskRunner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseTaskRunner()"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (const SequenceToken token_ =)",
    "insertText": "Create()"
  },
  {
    "label": "TimeTicks()",
    "kind": "Method",
    "detail": "Function (base::queue<Task> queue_ ; base::IntrusiveHeap<Task,DelayedTaskGreater> delayed_queue_ ; std::atomic<TimeTicks> ready_time_ {)",
    "insertText": "TimeTicks()"
  }
]