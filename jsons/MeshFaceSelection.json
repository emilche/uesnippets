[
  {
    "label": "FMeshVertexSelection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshVertexSelection"
  },
  {
    "label": "FMeshEdgeSelection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshEdgeSelection"
  },
  {
    "label": "FMeshFaceSelection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMeshFaceSelection"
  },
  {
    "label": "FMeshFaceSelection()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" DynamicMesh / DynamicMesh3 . h \" # include \" Util / DynamicVector . h \" # include \" EdgeLoop . h \" namespace UE { namespace Geometry { class FMeshVertexSelection ; class FMeshEdgeSelection ; class FMeshFaceSelection { private : const FDynamicMesh3* Mesh ; TSet<int> Selected ; public :)",
    "insertText": "FMeshFaceSelection(const FDynamicMesh3* mesh)"
  },
  {
    "label": "FMeshFaceSelection()",
    "kind": "Method",
    "detail": "Function (Mesh = mesh ; })",
    "insertText": "FMeshFaceSelection(const FDynamicMesh3* mesh, const FMeshVertexSelection& convertV, int minCount = 3)"
  },
  {
    "label": "FMeshFaceSelection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FMeshFaceSelection(const FDynamicMesh3* mesh, int group_id) : Mesh(mesh)"
  },
  {
    "label": "SelectGroup()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SelectGroup(group_id)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} TSet<int>::TRangedForIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} TSet<int>::TRangedForIterator)",
    "insertText": "end()"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "add(int tid)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Selected .)",
    "insertText": "Add(tid)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "remove(int tid)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (Selected .)",
    "insertText": "Remove(tid)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} public : int)",
    "insertText": "Num()"
  },
  {
    "label": "IsSelected()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSelected(int tid)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(int tid)"
  },
  {
    "label": "Select()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Select(int tid)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(tid)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} } template<EnumerableType,E =)",
    "insertText": "decltype(DeclVal<EnumerableType>().begin())> void Select(const EnumerableType& Enumerable)"
  },
  {
    "label": "Select()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "Select(TFunctionRef<bool(int)> SelectF)"
  },
  {
    "label": "MaxTriangleID()",
    "kind": "Method",
    "detail": "Function (int NT = Mesh ->)",
    "insertText": "MaxTriangleID()"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(tID)"
  },
  {
    "label": "SelectVertexOneRing()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "SelectVertexOneRing(int vid)"
  },
  {
    "label": "EnumerateVertexTriangles()",
    "kind": "Method",
    "detail": "Function (Mesh ->)",
    "insertText": "EnumerateVertexTriangles(vid, [&](int tid) { add(tid); })"
  },
  {
    "label": "SelectVertexOneRings()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SelectVertexOneRings(TArrayView<const int> Vertices)"
  },
  {
    "label": "SelectVertexOneRing()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SelectVertexOneRing(vid)"
  },
  {
    "label": "SelectEdgeTris()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SelectEdgeTris(int eid)"
  },
  {
    "label": "GetEdgeT()",
    "kind": "Method",
    "detail": "Function (FIndex2i et = Mesh ->)",
    "insertText": "GetEdgeT(eid)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(et.A)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(et.B)"
  },
  {
    "label": "Deselect()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Deselect(int tid)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove(tid)"
  },
  {
    "label": "Deselect()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Deselect(TArrayView<const int> Triangles)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove(TID)"
  },
  {
    "label": "Deselect()",
    "kind": "Method",
    "detail": "Function (} } template<EnumerableType> void)",
    "insertText": "Deselect(const EnumerableType& Enumerable)"
  },
  {
    "label": "DeselectAll()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DeselectAll()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (Selected .)",
    "insertText": "Empty()"
  },
  {
    "label": "SelectGroup()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SelectGroup(int gid)"
  },
  {
    "label": "SelectGroupInverse()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "SelectGroupInverse(int gid)"
  },
  {
    "label": "DeselectGroup()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "DeselectGroup(int gid)"
  },
  {
    "label": "SetDifference()",
    "kind": "Method",
    "detail": "Function (} } } template<EnumerableType,StorageType> void)",
    "insertText": "SetDifference(const EnumerableType& SubtractSet, StorageType& DifferenceStorage)"
  },
  {
    "label": "SetIntersection()",
    "kind": "Method",
    "detail": "Function (} } } template<EnumerableType,StorageType> void)",
    "insertText": "SetIntersection(const EnumerableType& IntersectSet, StorageType& IntersectionStorage)"
  },
  {
    "label": "AsSet()",
    "kind": "Method",
    "detail": "Function (} } } const TSet<int>&)",
    "insertText": "AsSet()"
  },
  {
    "label": "AsBitArray()",
    "kind": "Method",
    "detail": "Function (} TBitArray<FDefaultBitArrayAllocator>)",
    "insertText": "AsBitArray()"
  },
  {
    "label": "Bitmap()",
    "kind": "Method",
    "detail": "Function (TBitArray<FDefaultBitArrayAllocator>)",
    "insertText": "Bitmap(false, Mesh->MaxTriangleID())"
  },
  {
    "label": "IsSelectionBoundaryEdge()",
    "kind": "Method",
    "detail": "Function (Bitmap [ tid ] = true ; } return Bitmap ; } TPair<bool,bool>)",
    "insertText": "IsSelectionBoundaryEdge(int32 eid)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (bool bA = Selected .)",
    "insertText": "Contains(EdgeT.A)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Selected.Contains(EdgeT.B) != bA)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} } return TPair<bool,)",
    "insertText": "bool(false, false)"
  },
  {
    "label": "FindNeighbourTris()",
    "kind": "Method",
    "detail": "Function (} TArray<int>)",
    "insertText": "FindNeighbourTris()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<int> result ;)",
    "insertText": "for(int tid : Selected)"
  },
  {
    "label": "GetTriNeighbourTris()",
    "kind": "Method",
    "detail": "Function (FIndex3i nbr_tris = Mesh ->)",
    "insertText": "GetTriNeighbourTris(tid)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (result .)",
    "insertText": "Add(nbr_tris[j])"
  },
  {
    "label": "FindBorderTris()",
    "kind": "Method",
    "detail": "Function (} } } return result ; } TArray<int>)",
    "insertText": "FindBorderTris()"
  },
  {
    "label": "ExpandToFaceNeighbours()",
    "kind": "Method",
    "detail": "Function (} } return result ; } void)",
    "insertText": "ExpandToFaceNeighbours(const TUniqueFunction<bool(int)>& FilterF = nullptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(nbr_tris[j] != FDynamicMesh3::InvalidID && !IsSelected(nbr_tris[j]))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "for(int ID : ToAdd)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(ID)"
  },
  {
    "label": "ExpandToFaceNeighbours()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ExpandToFaceNeighbours(int rounds, const TUniqueFunction<bool(int)>& FilterF = nullptr)"
  },
  {
    "label": "ExpandToFaceNeighbours()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpandToFaceNeighbours(FilterF)"
  },
  {
    "label": "ExpandToOneRingNeighbours()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ExpandToOneRingNeighbours(const TUniqueFunction<bool(int)>& FilterF = nullptr)"
  },
  {
    "label": "ExpandToOneRingNeighbours()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpandToOneRingNeighbours(int nRings, const TUniqueFunction<bool(int)>& FilterF = nullptr)"
  },
  {
    "label": "ContractBorderByOneRingNeighbours()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ContractBorderByOneRingNeighbours(int NumRings = 1, bool bContractFromMeshBoundary = false, const TUniqueFunction<bool(int)>& FilterF = nullptr)"
  },
  {
    "label": "FloodFill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FloodFill(int tSeed, const TUniqueFunction<bool(int)>& TriFilterF = nullptr, const TUniqueFunction<bool(int)>& EdgeFilterF = nullptr)"
  },
  {
    "label": "FloodFill()",
    "kind": "Method",
    "detail": "Function (TArray<int> Seeds = { tSeed } ;)",
    "insertText": "FloodFill(Seeds, TriFilterF, EdgeFilterF)"
  },
  {
    "label": "FloodFill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FloodFill(const TArray<int>& Seeds, const TUniqueFunction<bool(int)>& TriFilterF = nullptr, const TUniqueFunction<bool(int)>& EdgeFilterF = nullptr)"
  },
  {
    "label": "stack()",
    "kind": "Method",
    "detail": "Function (TDynamicVector<int>)",
    "insertText": "stack(Seeds)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(Seed)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(stack.Num() > 0)"
  },
  {
    "label": "Back()",
    "kind": "Method",
    "detail": "Function (int TID = stack .)",
    "insertText": "Back()"
  },
  {
    "label": "PopBack()",
    "kind": "Method",
    "detail": "Function (stack .)",
    "insertText": "PopBack()"
  },
  {
    "label": "GetTriNeighbourTris()",
    "kind": "Method",
    "detail": "Function (FIndex3i nbrs = Mesh ->)",
    "insertText": "GetTriNeighbourTris(TID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int nbr_tid = nbrs [ j ] ;)",
    "insertText": "if(nbr_tid == FDynamicMesh3::InvalidID || IsSelected(nbr_tid))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(TriFilterF && TriFilterF(nbr_tid) == false)"
  },
  {
    "label": "GetTriEdge()",
    "kind": "Method",
    "detail": "Function (continue ; } int EID = Mesh ->)",
    "insertText": "GetTriEdge(TID, j)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "add(nbr_tid)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (stack .)",
    "insertText": "Add(nbr_tid)"
  },
  {
    "label": "ClipFins()",
    "kind": "Method",
    "detail": "Function (} } } bool)",
    "insertText": "ClipFins(bool bClipLoners)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(int tid : ToRemove)"
  },
  {
    "label": "FillEars()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "FillEars(bool bFillTinyHoles)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int nbr_t = nbr_tris [ j ] ;)",
    "insertText": "if(IsSelected(nbr_t))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(is_ear(nbr_t, bFillTinyHoles))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (temp .)",
    "insertText": "Add(nbr_t)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "for(int tid : temp)"
  },
  {
    "label": "LocalOptimize()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "LocalOptimize(bool bClipFins, bool bFillEars, bool bFillTinyHoles = true, bool bClipLoners = true, bool bRemoveBowties = false)"
  },
  {
    "label": "ClipFins()",
    "kind": "Method",
    "detail": "Function (bool bModified = false ; bool done = false ; int count = 0 ; do { bool bDidClip = bClipFins&&)",
    "insertText": "ClipFins(bClipLoners)"
  },
  {
    "label": "FillEars()",
    "kind": "Method",
    "detail": "Function (bool bDidEars = bFillEars&&)",
    "insertText": "FillEars(bFillTinyHoles)"
  },
  {
    "label": "remove_bowties()",
    "kind": "Method",
    "detail": "Function (bool bDidBows = bRemoveBowties&&)",
    "insertText": "remove_bowties()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bModified = bModified | | ! done ; })",
    "insertText": "while(!done && count++ < 25)"
  },
  {
    "label": "LocalOptimize()",
    "kind": "Method",
    "detail": "Function (} return bModified ; } bool)",
    "insertText": "LocalOptimize(bool bRemoveBowties = true)"
  },
  {
    "label": "RemoveBowties()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "RemoveBowties()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (TSet<int> tempHash ; bool bModified = false ; bool done = false ; TSet<int> vertices ;)",
    "insertText": "while(!done)"
  },
  {
    "label": "GetTriangle()",
    "kind": "Method",
    "detail": "Function (FIndex3i tv = Mesh ->)",
    "insertText": "GetTriangle(tid)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (vertices .)",
    "insertText": "Add(tv.A)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (vertices .)",
    "insertText": "Add(tv.B)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (vertices .)",
    "insertText": "Add(tv.C)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int vid : vertices)"
  },
  {
    "label": "EnumerateVertexTriangles()",
    "kind": "Method",
    "detail": "Function (Mesh ->)",
    "insertText": "EnumerateVertexTriangles(vid, [&](int TID) { Deselect(TID); })"
  },
  {
    "label": "is_bowtie_vtx()",
    "kind": "Method",
    "detail": "Function (bModified = true ; } } return bModified ; } private : bool)",
    "insertText": "is_bowtie_vtx(int vid)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int border_edges = 0 ;)",
    "insertText": "for(int eid : Mesh->VtxEdgesItr(vid))"
  },
  {
    "label": "IsSelected()",
    "kind": "Method",
    "detail": "Function (bool in_a =)",
    "insertText": "IsSelected(et.A)"
  },
  {
    "label": "IsSelected()",
    "kind": "Method",
    "detail": "Function (bool in_b =)",
    "insertText": "IsSelected(et.B)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (border_edges + + ; } } else {)",
    "insertText": "if(IsSelected(et.A))"
  },
  {
    "label": "count_nbrs()",
    "kind": "Method",
    "detail": "Function (border_edges + + ; } } } return border_edges> 2 ; } void)",
    "insertText": "count_nbrs(int tid, int& nbr_in, int& nbr_out, int& bdry_e)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (nbr_in = 0 ; nbr_out = 0 ; bdry_e = 0 ;)",
    "insertText": "for(int j = 0; j < 3; ++j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int nbr_t = nbr_tris [ j ] ;)",
    "insertText": "if(nbr_t == FDynamicMesh3::InvalidID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bdry_e + + ; } else)",
    "insertText": "if(IsSelected(nbr_t) == true)"
  },
  {
    "label": "is_ear()",
    "kind": "Method",
    "detail": "Function (nbr_in + + ; } else { nbr_out + + ; } } } bool)",
    "insertText": "is_ear(int tid, bool include_tiny_holes)"
  }
]