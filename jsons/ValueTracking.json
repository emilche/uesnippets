[
  {
    "label": "Value",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Value"
  },
  {
    "label": "Instruction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Instruction"
  },
  {
    "label": "APInt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "APInt"
  },
  {
    "label": "DataLayout",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DataLayout"
  },
  {
    "label": "StringRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StringRef"
  },
  {
    "label": "MDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MDNode"
  },
  {
    "label": "AssumptionCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AssumptionCache"
  },
  {
    "label": "DominatorTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DominatorTree"
  },
  {
    "label": "TargetLibraryInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetLibraryInfo"
  },
  {
    "label": "LoopInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopInfo"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "SelectPatternFlavor",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "SelectPatternFlavor"
  },
  {
    "label": "computeKnownBits()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ANALYSIS_VALUETRACKING_H # define LLVM_ANALYSIS_VALUETRACKING_H # include \" llvm / ADT / ArrayRef . h \" # include \" llvm / IR / Instruction . h \" # include \" llvm / Support / DataTypes . h \" namespace llvm { class Value ; class Instruction ; class APInt ; class DataLayout ; class StringRef ; class MDNode ; class AssumptionCache ; class DominatorTree ; class TargetLibraryInfo ; class LoopInfo ; void)",
    "insertText": "computeKnownBits(Value *V, APInt &KnownZero, APInt &KnownOne, const DataLayout &DL, unsigned Depth = 0, AssumptionCache *AC = nullptr, const Instruction *CxtI = nullptr, const DominatorTree *DT = nullptr)"
  },
  {
    "label": "computeKnownBitsFromRangeMetadata()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeKnownBitsFromRangeMetadata(const MDNode &Ranges, APInt &KnownZero)"
  },
  {
    "label": "haveNoCommonBitsSet()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "haveNoCommonBitsSet(Value *LHS, Value *RHS, const DataLayout &DL, AssumptionCache *AC = nullptr, const Instruction *CxtI = nullptr, const DominatorTree *DT = nullptr)"
  },
  {
    "label": "ComputeSignBit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeSignBit(Value *V, bool &KnownZero, bool &KnownOne, const DataLayout &DL, unsigned Depth = 0, AssumptionCache *AC = nullptr, const Instruction *CxtI = nullptr, const DominatorTree *DT = nullptr)"
  },
  {
    "label": "isKnownToBeAPowerOfTwo()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isKnownToBeAPowerOfTwo(Value *V, const DataLayout &DL, bool OrZero = false, unsigned Depth = 0, AssumptionCache *AC = nullptr, const Instruction *CxtI = nullptr, const DominatorTree *DT = nullptr)"
  },
  {
    "label": "isKnownNonZero()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isKnownNonZero(Value *V, const DataLayout &DL, unsigned Depth = 0, AssumptionCache *AC = nullptr, const Instruction *CxtI = nullptr, const DominatorTree *DT = nullptr)"
  },
  {
    "label": "MaskedValueIsZero()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MaskedValueIsZero(Value *V, const APInt &Mask, const DataLayout &DL, unsigned Depth = 0, AssumptionCache *AC = nullptr, const Instruction *CxtI = nullptr, const DominatorTree *DT = nullptr)"
  },
  {
    "label": "ComputeNumSignBits()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "ComputeNumSignBits(Value *Op, const DataLayout &DL, unsigned Depth = 0, AssumptionCache *AC = nullptr, const Instruction *CxtI = nullptr, const DominatorTree *DT = nullptr)"
  },
  {
    "label": "ComputeMultiple()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ComputeMultiple(Value *V, unsigned Base, Value *&Multiple, bool LookThroughSExt = false, unsigned Depth = 0)"
  },
  {
    "label": "CannotBeNegativeZero()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CannotBeNegativeZero(const Value *V, unsigned Depth = 0)"
  },
  {
    "label": "CannotBeOrderedLessThanZero()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CannotBeOrderedLessThanZero(const Value *V, unsigned Depth = 0)"
  },
  {
    "label": "isBytewiseValue()",
    "kind": "Method",
    "detail": "Function (Value*)",
    "insertText": "isBytewiseValue(Value *V)"
  },
  {
    "label": "FindInsertedValue()",
    "kind": "Method",
    "detail": "Function (Value*)",
    "insertText": "FindInsertedValue(Value *V, ArrayRef<unsigned> idx_range, Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "GetPointerBaseWithConstantOffset()",
    "kind": "Method",
    "detail": "Function (Value*)",
    "insertText": "GetPointerBaseWithConstantOffset(Value *Ptr, int64_t &Offset, const DataLayout &DL)"
  },
  {
    "label": "GetPointerBaseWithConstantOffset()",
    "kind": "Method",
    "detail": "Function (const Value*)",
    "insertText": "GetPointerBaseWithConstantOffset(const Value *Ptr, int64_t &Offset, const DataLayout &DL)"
  },
  {
    "label": "getConstantStringInfo()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "getConstantStringInfo(const Value *V, StringRef &Str, uint64_t Offset = 0, bool TrimAtNul = true)"
  },
  {
    "label": "GetStringLength()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "GetStringLength(Value *V)"
  },
  {
    "label": "GetUnderlyingObject()",
    "kind": "Method",
    "detail": "Function (Value*)",
    "insertText": "GetUnderlyingObject(Value *V, const DataLayout &DL, unsigned MaxLookup = 6)"
  },
  {
    "label": "GetUnderlyingObject()",
    "kind": "Method",
    "detail": "Function (const Value*)",
    "insertText": "GetUnderlyingObject(const Value *V, const DataLayout &DL, unsigned MaxLookup = 6)"
  },
  {
    "label": "GetUnderlyingObjects()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetUnderlyingObjects(Value *V, SmallVectorImpl<Value *> &Objects, const DataLayout &DL, LoopInfo *LI = nullptr, unsigned MaxLookup = 6)"
  },
  {
    "label": "onlyUsedByLifetimeMarkers()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "onlyUsedByLifetimeMarkers(const Value *V)"
  },
  {
    "label": "isDereferenceablePointer()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isDereferenceablePointer(const Value *V, const DataLayout &DL, const Instruction *CtxI = nullptr, const DominatorTree *DT = nullptr, const TargetLibraryInfo *TLI = nullptr)"
  },
  {
    "label": "isSafeToSpeculativelyExecute()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isSafeToSpeculativelyExecute(const Value *V, const Instruction *CtxI = nullptr, const DominatorTree *DT = nullptr, const TargetLibraryInfo *TLI = nullptr)"
  },
  {
    "label": "isKnownNonNull()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isKnownNonNull(const Value *V, const TargetLibraryInfo *TLI = nullptr)"
  },
  {
    "label": "isKnownNonNullAt()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isKnownNonNullAt(const Value *V, const Instruction *CtxI = nullptr, const DominatorTree *DT = nullptr, const TargetLibraryInfo *TLI = nullptr)"
  },
  {
    "label": "isValidAssumeForContext()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isValidAssumeForContext(const Instruction *I, const Instruction *CxtI, const DominatorTree *DT = nullptr)"
  },
  {
    "label": "computeOverflowForUnsignedMul()",
    "kind": "Method",
    "detail": "Function (enum class OverflowResult { AlwaysOverflows,MayOverflow,NeverOverflows } ; OverflowResult)",
    "insertText": "computeOverflowForUnsignedMul(Value *LHS, Value *RHS, const DataLayout &DL, AssumptionCache *AC, const Instruction *CxtI, const DominatorTree *DT)"
  },
  {
    "label": "computeOverflowForUnsignedAdd()",
    "kind": "Method",
    "detail": "Function (OverflowResult)",
    "insertText": "computeOverflowForUnsignedAdd(Value *LHS, Value *RHS, const DataLayout &DL, AssumptionCache *AC, const Instruction *CxtI, const DominatorTree *DT)"
  },
  {
    "label": "matchSelectPattern()",
    "kind": "Method",
    "detail": "Function (enum SelectPatternFlavor { SPF_UNKNOWN = 0,SPF_SMIN,SPF_UMIN,SPF_SMAX,SPF_UMAX,SPF_ABS,SPF_NABS } ; SelectPatternFlavor)",
    "insertText": "matchSelectPattern(Value *V, Value *&LHS, Value *&RHS, Instruction::CastOps *CastOp = nullptr)"
  }
]