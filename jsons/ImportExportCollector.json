[
  {
    "label": "FImportExportCollector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImportExportCollector"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FImportExportCollector()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # if WITH_EDITORONLY_DATA # include \" Containers / Map . h \" # include \" Containers / RingBuffer . h \" # include \" Containers / Set . h \" # include \" Serialization / ArchiveUObject . h \" # include \" UObject / Package . h \" # include \" UObject / NameTypes . h \" # include \" UObject / SoftObjectPath . h \" # include \" UObject / UObjectGlobals . h \" class FImportExportCollector : public FArchiveUObject { public :)",
    "insertText": "FImportExportCollector(UPackage* InRootPackage)"
  },
  {
    "label": "AddExportToIgnore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddExportToIgnore(UObject* Export)"
  },
  {
    "label": "SerializeObjectAndReferencedExports()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SerializeObjectAndReferencedExports(UObject* RootObject)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "GetExports()",
    "kind": "Method",
    "detail": "Function (TArray<UObject*>)",
    "insertText": "GetExports()"
  },
  {
    "label": "GetImports()",
    "kind": "Method",
    "detail": "Function (const TMap<FSoftObjectPath,ESoftObjectPathCollectType>&)",
    "insertText": "GetImports()"
  },
  {
    "label": "GetImportedPackages()",
    "kind": "Method",
    "detail": "Function (const TMap<FName,ESoftObjectPathCollectType>&)",
    "insertText": "GetImportedPackages()"
  },
  {
    "label": "SetCallbackIsEditorOnlyObjectAllowed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCallbackIsEditorOnlyObjectAllowed(TFunction<bool(const UObject*)> InCallback)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(UObject*& Obj)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(FSoftObjectPath& Value)"
  },
  {
    "label": "AddImport()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "AddImport(const FSoftObjectPath& Path, ESoftObjectPathCollectType CollectType)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (ESoftObjectPathCollectType)",
    "insertText": "Union(ESoftObjectPathCollectType A, ESoftObjectPathCollectType B)"
  },
  {
    "label": "CachedIsEditorOnlyObject()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CachedIsEditorOnlyObject(const UObject* Object)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (enum class EVisitResult { Uninitialized,Excluded,Import,Export,} ; TMap<UObject*,EVisitResult> Visited ; TRingBuffer<UObject*> ExportsExploreQueue ; TMap<FSoftObjectPath,ESoftObjectPathCollectType> Imports ; TMap<FName,ESoftObjectPathCollectType> ImportedPackages ; TMap<const UObject*,UE::SavePackageUtilities::EEditorOnlyObjectResult> EditorOnlyObjectCache ; TFunction<)",
    "insertText": "bool(const UObject*)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<UObject*> Exports ;)",
    "insertText": "for(const TPair<UObject*, EVisitResult>& Pair : Visited)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Exports .)",
    "insertText": "Add(Pair.Key)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (CallbackIsEditorOnlyObjectAllowed =)",
    "insertText": "MoveTemp(InCallback)"
  }
]