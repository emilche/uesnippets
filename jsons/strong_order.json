[
  {
    "label": "__fn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__fn"
  },
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "_Up",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Up"
  },
  {
    "label": "_Dp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Dp"
  },
  {
    "label": "__go()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___COMPARE_STRONG_ORDER # define _LIBCPP___COMPARE_STRONG_ORDER # include<__bit / bit_cast . h> # include<__compare / compare_three_way . h> # include<__compare / ordering . h> # include<__config> # include<__utility / forward . h> # include<__utility / priority_tag . h> # include<cmath> # include<cstdint> # include<limits> # include<type_traits> # ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER # pragma GCC system_header # endif _LIBCPP_PUSH_MACROS # include<__undef_macros> _LIBCPP_BEGIN_NAMESPACE_STD # if _LIBCPP_STD_VER> 1 7 namespace __strong_order { struct __fn { template<class _Tp,class _Up> requires is_same_v<decay_t<_Tp>,decay_t<_Up>> _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "__go(_Tp&& __t, _Up&& __u, __priority_tag<2>) noexcept(noexcept(strong_ordering(strong_order(_VSTD::forward<_Tp>(__t), _VSTD::forward<_Up>(__u))))) -> decltype( strong_ordering(strong_order(_VSTD::forward<_Tp>(__t), _VSTD::forward<_Up>(__u))))"
  },
  {
    "label": "__go()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp,class _Up,class _Dp = decay_t<_Tp>> requires is_same_v<_Dp,decay_t<_Up>>&& is_floating_point_v<_Dp> _LIBCPP_HIDE_FROM_ABI strong_ordering)",
    "insertText": "__go(_Tp&& __t, _Up&& __u, __priority_tag<1>)"
  },
  {
    "label": "int32_t()",
    "kind": "Method",
    "detail": "Function (int32_t __rx = _VSTD::bit_cast<)",
    "insertText": "int32_t(__t)"
  },
  {
    "label": "int32_t()",
    "kind": "Method",
    "detail": "Function (int32_t __ry = _VSTD::bit_cast<)",
    "insertText": "int32_t(__u)"
  },
  {
    "label": "__rx()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__rx(__rx < 0) ? (numeric_limits<int32_t>::min() - __rx - 1)"
  },
  {
    "label": "__ry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__ry(__ry < 0) ? (numeric_limits<int32_t>::min() - __ry - 1)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(numeric_limits<_Dp>::is_iec559 && sizeof(_Dp) == sizeof(int64_t))"
  },
  {
    "label": "int64_t()",
    "kind": "Method",
    "detail": "Function (int64_t __rx = _VSTD::bit_cast<)",
    "insertText": "int64_t(__t)"
  },
  {
    "label": "int64_t()",
    "kind": "Method",
    "detail": "Function (int64_t __ry = _VSTD::bit_cast<)",
    "insertText": "int64_t(__u)"
  },
  {
    "label": "__rx()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__rx(__rx < 0) ? (numeric_limits<int64_t>::min() - __rx - 1)"
  },
  {
    "label": "__ry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__ry(__ry < 0) ? (numeric_limits<int64_t>::min() - __ry - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(__t < __u)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(__t == 0 || _VSTD::isinf(__t))"
  },
  {
    "label": "__uexp()",
    "kind": "Method",
    "detail": "Function (} else { int __texp,)",
    "insertText": "__uexp(void)_VSTD::frexp(__t, &__texp)"
  },
  {
    "label": "isnan()",
    "kind": "Method",
    "detail": "Function (} } } else { bool __t_is_nan =)",
    "insertText": "isnan(__t)"
  },
  {
    "label": "isnan()",
    "kind": "Method",
    "detail": "Function (bool __u_is_nan =)",
    "insertText": "isnan(__u)"
  },
  {
    "label": "signbit()",
    "kind": "Method",
    "detail": "Function (bool __t_is_negative =)",
    "insertText": "signbit(__t)"
  },
  {
    "label": "signbit()",
    "kind": "Method",
    "detail": "Function (bool __u_is_negative =)",
    "insertText": "signbit(__u)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (using _IntType = conditional_t<)",
    "insertText": "sizeof(__t) == sizeof(int32_t), int32_t, conditional_t< sizeof(__t) == sizeof(int64_t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(__t_is_nan && __u_is_nan)"
  },
  {
    "label": "_IntType()",
    "kind": "Method",
    "detail": "Function (} else { return _VSTD::bit_cast<)",
    "insertText": "_IntType(__t) <=> _VSTD::bit_cast<_IntType>(__u)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(__t_is_nan)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp,class _Up> _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t, _Up&& __u) const noexcept(noexcept(__go(_VSTD::forward<_Tp>(__t), _VSTD::forward<_Up>(__u), __priority_tag<2>()))) -> decltype( __go(_VSTD::forward<_Tp>(__t), _VSTD::forward<_Up>(__u), __priority_tag<2>()))"
  }
]