[
  {
    "label": "ChaosDeformableSimSpace",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ChaosDeformableSimSpace"
  },
  {
    "label": "FThreadingProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FThreadingProxy"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "FBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBuffer"
  },
  {
    "label": "FFleshThreadingProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFleshThreadingProxy"
  },
  {
    "label": "FFleshInputBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFleshInputBuffer"
  },
  {
    "label": "FFleshOutputBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFleshOutputBuffer"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / ObjectMacros . h \" # include \" GeometryCollection / GeometryCollection . h \" # include \" GeometryCollection / ManagedArrayCollection . h \" # include \" ChaosDeformableSolverProxy . generated . h \")",
    "insertText": "UENUM()"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (World)",
    "insertText": "UMETA(DisplayName = \"World\"), ComponentXf UMETA(DisplayName = \"Component\"), Bone UMETA(DisplayName = \"Bone\")"
  },
  {
    "label": "FName()",
    "kind": "Method",
    "detail": "Function (namespace Chaos::Softs { class FThreadingProxy { const UObject* Owner = nullptr ; FName =)",
    "insertText": "FName(\"\")"
  },
  {
    "label": "FThreadingProxy()",
    "kind": "Method",
    "detail": "Function (public : typedef const UObject* FKey ;)",
    "insertText": "FThreadingProxy(const UObject* InOwner = nullptr, FName InTypeName = FName(\"\")) : Owner(InOwner) , TypeName(InTypeName)"
  },
  {
    "label": "FThreadingProxy()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FThreadingProxy()"
  },
  {
    "label": "BaseTypeName()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "BaseTypeName()"
  },
  {
    "label": "As()",
    "kind": "Method",
    "detail": "Function (} template<class T> T*)",
    "insertText": "As()"
  },
  {
    "label": "GetOwner()",
    "kind": "Method",
    "detail": "Function (} const UObject*)",
    "insertText": "GetOwner()"
  },
  {
    "label": "FBuffer()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FBuffer(const FThreadingProxy& Ref) : Owner(Ref.GetOwner()) , TypeName(Ref.BaseTypeName())"
  },
  {
    "label": "FBuffer()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FBuffer(const UObject* InOwner,FName InTypeName) : Owner(InOwner) , TypeName(InTypeName)"
  },
  {
    "label": "FBuffer()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FBuffer()"
  },
  {
    "label": "FIntVector2()",
    "kind": "Method",
    "detail": "Function (} } ; } ; class FFleshThreadingProxy : public FThreadingProxy { typedef FThreadingProxy Super ; FTransform WorldToComponentXf = FTransform::Identity ; FTransform ComponentToWorldXf = FTransform::Identity ; FTransform ComponentToBoneXf = FTransform::Identity ; FTransform BoneToComponentXf = FTransform::Identity ; FTransform PrevComponentToBoneXf = FTransform::Identity ; FTransform PrevBoneToComponentXf = FTransform::Identity ; const FManagedArrayCollection& Rest ; FManagedArrayCollection Dynamic ; FIntVector2 SolverParticleRange =)",
    "insertText": "FIntVector2(0, 0)"
  },
  {
    "label": "FFleshThreadingProxy()",
    "kind": "Method",
    "detail": "Function (ChaosDeformableSimSpace SimSpace = ChaosDeformableSimSpace::World ; bool bIsCached = false ; public :)",
    "insertText": "FFleshThreadingProxy(UObject* InOwner, const FTransform& InWorldToComponentXf, const FTransform& InComponentToBoneXf, const ChaosDeformableSimSpace InSimSpace, const FManagedArrayCollection& InRest, const FManagedArrayCollection& InDynamic) : Super(InOwner, TypeName()) , WorldToComponentXf(InWorldToComponentXf) , ComponentToBoneXf(InComponentToBoneXf) , Rest(InRest) , Dynamic(InDynamic) , SimSpace(InSimSpace)"
  },
  {
    "label": "FTransform()",
    "kind": "Method",
    "detail": "Function (ComponentToWorldXf =)",
    "insertText": "FTransform(WorldToComponentXf.ToMatrixWithScale().Inverse())"
  },
  {
    "label": "FTransform()",
    "kind": "Method",
    "detail": "Function (BoneToComponentXf =)",
    "insertText": "FTransform(ComponentToBoneXf.ToMatrixWithScale().Inverse())"
  },
  {
    "label": "FFleshThreadingProxy()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "FFleshThreadingProxy()"
  },
  {
    "label": "TypeName()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "TypeName()"
  },
  {
    "label": "CanSimulate()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CanSimulate()"
  },
  {
    "label": "IsBoneSpace()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsBoneSpace()"
  },
  {
    "label": "GetIsCached()",
    "kind": "Method",
    "detail": "Function (bIsCached = bInIsCached ; } bool)",
    "insertText": "GetIsCached()"
  },
  {
    "label": "GetInitialPointsTransform()",
    "kind": "Method",
    "detail": "Function (} } const FTransform&)",
    "insertText": "GetInitialPointsTransform()"
  },
  {
    "label": "TransformVectorNoScale()",
    "kind": "Method",
    "detail": "Function (} case ChaosDeformableSimSpace::Bone : { FVector Tmp = ComponentToWorldXf .)",
    "insertText": "TransformVectorNoScale(FVector(Dir[0], Dir[1], Dir[2]))"
  },
  {
    "label": "GetFinalTransform()",
    "kind": "Method",
    "detail": "Function (} default : return Dir ; } } FTransform)",
    "insertText": "GetFinalTransform()"
  },
  {
    "label": "GetSolverParticleRange()",
    "kind": "Method",
    "detail": "Function (SolverParticleRange [ 0 ] = InStart ; SolverParticleRange [ 1 ] = InRange ; } const FIntVector2&)",
    "insertText": "GetSolverParticleRange()"
  },
  {
    "label": "FFleshInputBuffer()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FFleshInputBuffer(const FManagedArrayCollection&& InSimulationCollection, const FTransform& InWorldToComponentXf, const FTransform& InComponentToBoneXf, const int32 InSimSpaceBoneIndex, const TArray<FTransform>&& InTransforms, const TArray<FTransform>&& InRestTransforms, const bool InbEnableGravity, const float InStiffnessMultiplier, const float InDampingMultiplier, const float InMassMultiplier, const float InInCompressibilityMultiplier, const float InInflationMultiplier, const UObject* InOwner = nullptr) : Super(InOwner, FFleshThreadingProxy::TypeName()) , SimulationCollection(InSimulationCollection) , WorldToComponentXf(InWorldToComponentXf) , ComponentToBoneXf(InComponentToBoneXf) , Transforms(InTransforms) , RestTransforms(InRestTransforms) , bEnableGravity(InbEnableGravity) , StiffnessMultiplier(InStiffnessMultiplier) , DampingMultiplier(InDampingMultiplier) , MassMultiplier(InMassMultiplier) , IncompressibilityMultiplier(InInCompressibilityMultiplier) , InflationMultiplier(InInflationMultiplier) , SimSpaceBoneIndex(InSimSpaceBoneIndex)"
  },
  {
    "label": "FFleshInputBuffer()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FFleshInputBuffer()"
  },
  {
    "label": "FFleshOutputBuffer()",
    "kind": "Method",
    "detail": "Function (} const FManagedArrayCollection SimulationCollection ; FTransform WorldToComponentXf ; FTransform ComponentToBoneXf ; TArray<FTransform> Transforms ; TArray<FTransform> RestTransforms ; bool bEnableGravity ; float StiffnessMultiplier ; float DampingMultiplier ; float MassMultiplier ; float IncompressibilityMultiplier ; float InflationMultiplier ; int32 SimSpaceBoneIndex = INDEX_NONE ; } ; class FFleshOutputBuffer : public FThreadingProxy::FBuffer { typedef FThreadingProxy::FBuffer Super ; public : typedef FFleshThreadingProxy Source ;)",
    "insertText": "FFleshOutputBuffer(const Source& Ref) : Super(Ref)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (Dynamic . AddAttribute<)",
    "insertText": "FVector3f(\"Vertex\", FGeometryCollection::VerticesGroup)"
  },
  {
    "label": "CopyMatchingAttributesFrom()",
    "kind": "Method",
    "detail": "Function (Dynamic .)",
    "insertText": "CopyMatchingAttributesFrom(Ref.GetDynamicCollection())"
  },
  {
    "label": "FFleshOutputBuffer()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FFleshOutputBuffer()"
  }
]