[
  {
    "label": "FArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FArchive"
  },
  {
    "label": "FEdgeCollapseInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEdgeCollapseInfo"
  },
  {
    "label": "FEdgeFlipInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEdgeFlipInfo"
  },
  {
    "label": "FEdgeSplitInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEdgeSplitInfo"
  },
  {
    "label": "FMergeEdgesInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMergeEdgesInfo"
  },
  {
    "label": "FPokeTriangleInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPokeTriangleInfo"
  },
  {
    "label": "FVertexSplitInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVertexSplitInfo"
  },
  {
    "label": "FDynamicMesh3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDynamicMesh3"
  },
  {
    "label": "TDynamicMeshOverlay",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TDynamicMeshOverlay"
  },
  {
    "label": "FDynamicMeshAttributeSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDynamicMeshAttributeSet"
  },
  {
    "label": "TDynamicMeshVectorOverlay",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TDynamicMeshVectorOverlay"
  },
  {
    "label": "UE_EXTERN_TEMPLATE_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UE_EXTERN_TEMPLATE_API"
  },
  {
    "label": "TDynamicMeshOverlay()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / ArrayView . h \" # include \" Containers / Set . h \" # include \" DynamicMesh / DynamicMesh3 . h \" # include \" GeometryTypes . h \" # include \" IndexTypes . h \" # include \" InfoTypes . h \" # include \" IntVectorTypes . h \" # include \" Math / UnrealMathSSE . h \" # include \" Math / Vector . h \" # include \" Math / Vector2D . h \" # include \" Math / Vector4 . h \" # include \" Misc / AssertionMacros . h \" # include \" Templates / Function . h \" # include \" Templates / UnrealTemplate . h \" # include \" Util / CompactMaps . h \" # include \" Util / DynamicVector . h \" # include \" Util / RefCountVector . h \" # include \" Util / SmallListSet . h \" # include \" VectorTypes . h \" class FArchive ; namespace DynamicMeshInfo { struct FEdgeCollapseInfo ; } namespace DynamicMeshInfo { struct FEdgeFlipInfo ; } namespace DynamicMeshInfo { struct FEdgeSplitInfo ; } namespace DynamicMeshInfo { struct FMergeEdgesInfo ; } namespace DynamicMeshInfo { struct FPokeTriangleInfo ; } namespace DynamicMeshInfo { struct FVertexSplitInfo ; } namespace UE { namespace Geometry { class FDynamicMesh3 ; template<RealType,int ElementSize> class TDynamicMeshOverlay { protected : FDynamicMesh3* ParentMesh ; FRefCountVector ElementsRefCounts ; TDynamicVector<RealType> Elements ; TDynamicVector<int> ParentVertices ; TDynamicVector<int> ElementTriangles ; class FDynamicMesh3 ; class FDynamicMeshAttributeSet ; public :)",
    "insertText": "TDynamicMeshOverlay()"
  },
  {
    "label": "TDynamicMeshOverlay()",
    "kind": "Method",
    "detail": "Function (ParentMesh = nullptr ; })",
    "insertText": "TDynamicMeshOverlay(FDynamicMesh3* ParentMeshIn)"
  },
  {
    "label": "Reparent()",
    "kind": "Method",
    "detail": "Function (ParentMesh = ParentMeshIn ; } private : void)",
    "insertText": "Reparent(FDynamicMesh3* ParentMeshIn)"
  },
  {
    "label": "GetParentMesh()",
    "kind": "Method",
    "detail": "Function (ParentMesh = ParentMeshIn ; } public : const FDynamicMesh3*)",
    "insertText": "GetParentMesh()"
  },
  {
    "label": "FRefCountVector()",
    "kind": "Method",
    "detail": "Function (ElementsRefCounts =)",
    "insertText": "FRefCountVector(Copy.ElementsRefCounts)"
  },
  {
    "label": "CompactCopy()",
    "kind": "Method",
    "detail": "Function (Elements = Copy . Elements ; ParentVertices = Copy . ParentVertices ; ElementTriangles = Copy . ElementTriangles ; } void)",
    "insertText": "CompactCopy(const FCompactMaps& CompactMaps, const TDynamicMeshOverlay<RealType, ElementSize>& Copy)"
  },
  {
    "label": "ClearElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearElements()"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<int> MapE ; MapE .)",
    "insertText": "SetNumUninitialized(Copy.MaxElementID())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (RealType Data [ ElementSize ] ;)",
    "insertText": "for(int EID = 0; EID < Copy.MaxElementID(); EID++)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (Copy .)",
    "insertText": "GetElement(EID, Data)"
  },
  {
    "label": "AppendElement()",
    "kind": "Method",
    "detail": "Function (MapE [ EID ] =)",
    "insertText": "AppendElement(Data)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else { MapE [ EID ] = - 1 ; } })",
    "insertText": "check(CompactMaps.NumTriangleMappings() == Copy.GetParentMesh()->MaxTriangleID())"
  },
  {
    "label": "GetTriangleMapping()",
    "kind": "Method",
    "detail": "Function (continue ; } const int ToTID = CompactMaps .)",
    "insertText": "GetTriangleMapping(FromTID)"
  },
  {
    "label": "GetTriangle()",
    "kind": "Method",
    "detail": "Function (FIndex3i FromTriElements = Copy .)",
    "insertText": "GetTriangle(FromTID)"
  },
  {
    "label": "SetTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTriangle(ToTID, FIndex3i(MapE[FromTriElements.A], MapE[FromTriElements.B], MapE[FromTriElements.C]))"
  },
  {
    "label": "CompactInPlace()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "CompactInPlace(const FCompactMaps& CompactMaps)"
  },
  {
    "label": "MaxElementID()",
    "kind": "Method",
    "detail": "Function (int iLastE =)",
    "insertText": "MaxElementID()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (iLastE - - ; })",
    "insertText": "while(iCurE < iLastE && ElementsRefCounts.IsValidUnsafe(iCurE))"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (iCurE + + ; } TArray<int> MapE ; MapE .)",
    "insertText": "SetNumUninitialized(MaxElementID())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MapE [ ID ] = ID ;)",
    "insertText": "if(ParentVertices[ID] >= 0)"
  },
  {
    "label": "GetVertexMapping()",
    "kind": "Method",
    "detail": "Function (ParentVertices [ ID ] = CompactMaps .)",
    "insertText": "GetVertexMapping(ParentVertices[ID])"
  },
  {
    "label": "GetRawRefCountsUnsafe()",
    "kind": "Method",
    "detail": "Function (} } TDynamicVector<unsigned short>& ERef = ElementsRefCounts .)",
    "insertText": "GetRawRefCountsUnsafe()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (RealType Data [ ElementSize ] ;)",
    "insertText": "while(iCurE < iLastE)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetElement(iLastE, Data)"
  },
  {
    "label": "SetElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElement(iCurE, Data)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (ParentVertices [ iCurE ] = ParentVertices [ iLastE ] ; ERef [ iCurE ] = ERef [ iLastE ] ; ERef [ iLastE ] = FRefCountVector::INVALID_REF_COUNT ; MapE [ iLastE ] = iCurE ; iLastE - - ; iCurE + + ;)",
    "insertText": "while(iLastE >= 0 && ElementsRefCounts.IsValidUnsafe(iLastE) == false)"
  },
  {
    "label": "Trim()",
    "kind": "Method",
    "detail": "Function (iCurE + + ; } } ElementsRefCounts .)",
    "insertText": "Trim(ElementCount())"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Resize(ElementCount() * ElementSize)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (ParentVertices .)",
    "insertText": "Resize(ElementCount())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 MaxNewTID = 0 ;)",
    "insertText": "for(int TID = 0, OldMaxTID = ElementTriangles.Num() / 3; TID < OldMaxTID; TID++)"
  },
  {
    "label": "GetTriangleMapping()",
    "kind": "Method",
    "detail": "Function (const int32 OldStart = TID* 3 ; const int32 NewTID = CompactMaps .)",
    "insertText": "GetTriangleMapping(TID)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (continue ; } MaxNewTID =)",
    "insertText": "Max(NewTID, MaxNewTID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 NewStart = NewTID* 3 ;)",
    "insertText": "if(ElementTriangles[OldStart] == IndexConstants::InvalidID)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (ElementTriangles [ NewStart + SubIdx ] = IndexConstants::InvalidID ; } } else {)",
    "insertText": "for(int SubIdx = 0; SubIdx < 3; SubIdx++)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (ElementTriangles [ NewStart + SubIdx ] = MapE [ ElementTriangles [ OldStart + SubIdx ] ] ; } } })",
    "insertText": "checkSlow(ElementTriangles.Num() >= (MaxNewTID + 1) * 3)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (ElementTriangles .)",
    "insertText": "Resize((MaxNewTID + 1) * 3)"
  },
  {
    "label": "ClearElements()",
    "kind": "Method",
    "detail": "Function (template<EnumerableIntType> void)",
    "insertText": "ClearElements(const EnumerableIntType& Triangles)"
  },
  {
    "label": "UnsetTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnsetTriangle(TriID)"
  },
  {
    "label": "ElementCount()",
    "kind": "Method",
    "detail": "Function (} } int)",
    "insertText": "ElementCount()"
  },
  {
    "label": "IsElement()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsElement(int vID)"
  },
  {
    "label": "IsCompact()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsCompact()"
  },
  {
    "label": "ElementIndicesItr()",
    "kind": "Method",
    "detail": "Function (} typedef FRefCountVector::IndexEnumerable element_iterator ; element_iterator)",
    "insertText": "ElementIndicesItr()"
  },
  {
    "label": "AppendElement()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "AppendElement(RealType ConstantValue)"
  },
  {
    "label": "AppendElement()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "AppendElement(const RealType* Value)"
  },
  {
    "label": "SetParentVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetParentVertex(int ElementIndex, int ParentVertexIndex)"
  },
  {
    "label": "InitializeTriangles()",
    "kind": "Method",
    "detail": "Function (ParentVertices [ ElementIndex ] = ParentVertexIndex ; } void)",
    "insertText": "InitializeTriangles(int MaxTriangleID)"
  },
  {
    "label": "SetTriangle()",
    "kind": "Method",
    "detail": "Function (EMeshResult)",
    "insertText": "SetTriangle(int TriangleID, const FIndex3i& TriElements, bool bAllowElementFreeing = true)"
  },
  {
    "label": "FreeUnusedElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeUnusedElements(const TSet<int>* ElementsToCheck = nullptr)"
  },
  {
    "label": "UnsetTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnsetTriangle(int TriangleID, bool bAllowElementFreeing = true)"
  },
  {
    "label": "IsSetTriangle()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSetTriangle(int TID)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (bool bIsSet = ElementTriangles [ 3* TID ]> = 0 ;)",
    "insertText": "checkSlow(ElementTriangles[3 * TID + 1] >= 0 == bIsSet)"
  },
  {
    "label": "SplitVerticesWithPredicate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SplitVerticesWithPredicate(TFunctionRef<bool(int ElementIdx, int TriID)> ShouldSplitOutVertex, TFunctionRef<void(int ElementIdx, int TriID, RealType* FillVect)> GetNewElementValue)"
  },
  {
    "label": "MergeElement()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MergeElement(int SourceElementID, int TargetElementID)"
  },
  {
    "label": "SplitElement()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "SplitElement(int ElementID, const TArrayView<const int>& TrianglesToUpdate)"
  },
  {
    "label": "SplitElementWithNewParent()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "SplitElementWithNewParent(int ElementID, int SplitParentVertexID, const TArrayView<const int>& TrianglesToUpdate)"
  },
  {
    "label": "SplitBowtiesAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SplitBowtiesAtVertex(int32 Vid, TArray<int32>* NewElementIDs = nullptr)"
  },
  {
    "label": "SplitBowties()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SplitBowties()"
  },
  {
    "label": "BeginUnsafeElementsInsert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginUnsafeElementsInsert()"
  },
  {
    "label": "EndUnsafeElementsInsert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EndUnsafeElementsInsert()"
  },
  {
    "label": "RebuildFreeList()",
    "kind": "Method",
    "detail": "Function (ElementsRefCounts .)",
    "insertText": "RebuildFreeList()"
  },
  {
    "label": "InsertElement()",
    "kind": "Method",
    "detail": "Function (} EMeshResult)",
    "insertText": "InsertElement(int ElementID, const RealType* Value, bool bUnsafe = false)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetElement(int ElementID, RealType* Data)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int k = ElementID* ElementSize ;)",
    "insertText": "for(int i = 0; i < ElementSize; ++i)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (Data [ i ] = Elements [ k + i ] ; } } template<AsType> void)",
    "insertText": "GetElement(int ElementID, AsType& Data)"
  },
  {
    "label": "GetElementAtVertex()",
    "kind": "Method",
    "detail": "Function (Data [ i ] = Elements [ k + i ] ; } } template<AsType> void)",
    "insertText": "GetElementAtVertex(int TriangleID, int VertexID, AsType& Data)"
  },
  {
    "label": "GetElementIDAtVertex()",
    "kind": "Method",
    "detail": "Function (int ElementID =)",
    "insertText": "GetElementIDAtVertex(TriangleID, VertexID)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetElement(ElementID, Data)"
  },
  {
    "label": "GetParentVertex()",
    "kind": "Method",
    "detail": "Function (} } int)",
    "insertText": "GetParentVertex(int ElementID)"
  },
  {
    "label": "FIndex3i()",
    "kind": "Method",
    "detail": "Function (int i = 3* TriangleID ; return)",
    "insertText": "FIndex3i(ElementTriangles[i], ElementTriangles[i + 1], ElementTriangles[i + 2])"
  },
  {
    "label": "GetTriangleIfValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetTriangleIfValid(int TriangleID, FIndex3i& TriangleOut)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int i = 3* TriangleID ; int a = ElementTriangles [ i ] ;)",
    "insertText": "if(a >= 0)"
  },
  {
    "label": "FIndex3i()",
    "kind": "Method",
    "detail": "Function (TriangleOut =)",
    "insertText": "FIndex3i(a, ElementTriangles[i+1], ElementTriangles[i+2])"
  },
  {
    "label": "SetElement()",
    "kind": "Method",
    "detail": "Function (Elements [ k + i ] = Data [ i ] ; } } template<AsType> void)",
    "insertText": "SetElement(int ElementID, const AsType& Data)"
  },
  {
    "label": "TriangleHasElement()",
    "kind": "Method",
    "detail": "Function (Elements [ k + i ] = Data [ i ] ; } } bool)",
    "insertText": "TriangleHasElement(int TriangleID, int ElementID)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (int i = 3* TriangleID ;)",
    "insertText": "return(ElementTriangles[i] == ElementID || ElementTriangles[i+1] == ElementID || ElementTriangles[i+2] == ElementID)"
  },
  {
    "label": "IsSeamEdge()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSeamEdge(int EdgeID, bool* bIsNonIntersectingOut = nullptr)"
  },
  {
    "label": "IsSeamEndEdge()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSeamEndEdge(int EdgeID)"
  },
  {
    "label": "IsSeamVertex()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSeamVertex(int VertexID, bool bBoundaryIsSeam = true)"
  },
  {
    "label": "IsBowtieInOverlay()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsBowtieInOverlay(int32 VertexID)"
  },
  {
    "label": "AreTrianglesConnected()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AreTrianglesConnected(int TriangleID0, int TriangleID1)"
  },
  {
    "label": "GetVertexElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetVertexElements(int VertexID, TArray<int>& OutElements)"
  },
  {
    "label": "CountVertexElements()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "CountVertexElements(int VertexID, bool bBruteForce = false)"
  },
  {
    "label": "GetElementTriangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetElementTriangles(int ElementID, TArray<int>& OutTriangles)"
  },
  {
    "label": "GetElementIDAtVertex()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetElementIDAtVertex(int TriangleID, int VertexID)"
  },
  {
    "label": "HasInteriorSeamEdges()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasInteriorSeamEdges()"
  },
  {
    "label": "GetTriBaryInterpolate()",
    "kind": "Method",
    "detail": "Function (template<AsType> void)",
    "insertText": "GetTriBaryInterpolate(int32 TriangleID, const AsType* BaryCoords, AsType* DataOut)"
  },
  {
    "label": "Bary0()",
    "kind": "Method",
    "detail": "Function (int32 TriIndex = 3* TriangleID ; int32 ElemIndex0 = ElementTriangles [ TriIndex ]* ElementSize ; int32 ElemIndex1 = ElementTriangles [ TriIndex + 1 ]* ElementSize ; int32 ElemIndex2 = ElementTriangles [ TriIndex + 2 ]* ElementSize ; const AsType)",
    "insertText": "Bary0(AsType)BaryCoords[0], Bary1 = (AsType)BaryCoords[1], Bary2 = (AsType)"
  },
  {
    "label": "Bary0()",
    "kind": "Method",
    "detail": "Function (DataOut [ i ] =)",
    "insertText": "Bary0(AsType)Elements[ElemIndex0+i] + Bary1*(AsType)Elements[ElemIndex1+i] + Bary2*(AsType)"
  },
  {
    "label": "CheckValidity()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "CheckValidity(bool bAllowNonManifoldVertices = true, EValidityCheckFailMode FailMode = EValidityCheckFailMode::Check)"
  },
  {
    "label": "IsSameAs()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSameAs(const TDynamicMeshOverlay<RealType, ElementSize>& Other, bool bIgnoreDataLayout)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(FArchive& Ar, TDynamicMeshOverlay<RealType,ElementSize>& Overlay)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Overlay .)",
    "insertText": "Serialize(Ar, nullptr, false)"
  },
  {
    "label": "InitializeNewTriangle()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "InitializeNewTriangle(int TriangleID)"
  },
  {
    "label": "OnRemoveTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnRemoveTriangle(int TriangleID)"
  },
  {
    "label": "OnReverseTriOrientation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnReverseTriOrientation(int TriangleID)"
  },
  {
    "label": "OnSplitEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnSplitEdge(const DynamicMeshInfo::FEdgeSplitInfo& SplitInfo)"
  },
  {
    "label": "OnFlipEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnFlipEdge(const DynamicMeshInfo::FEdgeFlipInfo& FlipInfo)"
  },
  {
    "label": "OnCollapseEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnCollapseEdge(const DynamicMeshInfo::FEdgeCollapseInfo& CollapseInfo)"
  },
  {
    "label": "OnPokeTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnPokeTriangle(const DynamicMeshInfo::FPokeTriangleInfo& PokeInfo)"
  },
  {
    "label": "OnMergeEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnMergeEdges(const DynamicMeshInfo::FMergeEdgesInfo& MergeInfo)"
  },
  {
    "label": "OnMergeVertices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnMergeVertices(const DynamicMeshInfo::FMergeVerticesInfo& MergeInfo)"
  },
  {
    "label": "OnSplitVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnSplitVertex(const DynamicMeshInfo::FVertexSplitInfo& SplitInfo, const TArrayView<const int>& TrianglesToUpdate)"
  },
  {
    "label": "SetElementFromLerp()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "SetElementFromLerp(int SetElement, int ElementA, int ElementB, double Alpha)"
  },
  {
    "label": "SetElementFromBary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElementFromBary(int SetElement, int ElementA, int ElementB, int ElementC, const FVector3d& BaryCoords)"
  },
  {
    "label": "InternalSetTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InternalSetTriangle(int TriangleID, const FIndex3i& TriElements, bool bUpdateRefCounts, bool bAllowElementFreeing = true)"
  },
  {
    "label": "TDynamicMeshVectorOverlay()",
    "kind": "Method",
    "detail": "Function (} ; template<RealType,int ElementSize,VectorType> class TDynamicMeshVectorOverlay : public TDynamicMeshOverlay<RealType,ElementSize> { public : using BaseType = TDynamicMeshOverlay<RealType,ElementSize> ;)",
    "insertText": "TDynamicMeshVectorOverlay() : TDynamicMeshOverlay<RealType, ElementSize>()"
  },
  {
    "label": "TDynamicMeshVectorOverlay()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TDynamicMeshVectorOverlay(FDynamicMesh3* parentMesh) : TDynamicMeshOverlay<RealType, ElementSize>(parentMesh)"
  },
  {
    "label": "AppendElement()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "AppendElement(const VectorType& Value)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (} VectorType)",
    "insertText": "GetElement(int ElementID)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (VectorType V ;)",
    "insertText": "GetElement(ElementID, V)"
  },
  {
    "label": "GetElementAtVertex()",
    "kind": "Method",
    "detail": "Function (} VectorType)",
    "insertText": "GetElementAtVertex(int TriangleID, int VertexID)"
  },
  {
    "label": "GetElementAtVertex()",
    "kind": "Method",
    "detail": "Function (VectorType V ;)",
    "insertText": "GetElementAtVertex(TriangleID, VertexID, V)"
  },
  {
    "label": "GetTriElement()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetTriElement(int TriangleID, int32 TriVertexIndex, VectorType& Value)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetElement(BaseType::ElementTriangles[(3 * TriangleID) + TriVertexIndex], Value)"
  },
  {
    "label": "GetTriElements()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetTriElements(int TriangleID, VectorType& A, VectorType& B, VectorType& C)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (int i = 3* TriangleID ;)",
    "insertText": "GetElement(BaseType::ElementTriangles[i], A)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetElement(BaseType::ElementTriangles[i+1], B)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetElement(BaseType::ElementTriangles[i+2], C)"
  },
  {
    "label": "SetElement()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetElement(int ElementID, const VectorType& Value)"
  },
  {
    "label": "SetElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElement(ElementID, Value)"
  },
  {
    "label": "EnumerateVertexElements()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "EnumerateVertexElements(int VertexID, TFunctionRef<bool(int TriangleID, int ElementID, const VectorType& Value)> ProcessFunc, bool bFindUniqueElements = true)"
  }
]