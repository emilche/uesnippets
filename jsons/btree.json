[
  {
    "label": "StringBtreeDefaultLess",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StringBtreeDefaultLess"
  },
  {
    "label": "StringBtreeDefaultGreater",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StringBtreeDefaultGreater"
  },
  {
    "label": "checked_compare_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "checked_compare_base"
  },
  {
    "label": "BtreeTestOnlyCheckedCompareOptOutBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BtreeTestOnlyCheckedCompareOptOutBase"
  },
  {
    "label": "key_compare_adapter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "key_compare_adapter"
  },
  {
    "label": "checked_compare",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "checked_compare"
  },
  {
    "label": "has_linear_node_search_preference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "has_linear_node_search_preference"
  },
  {
    "label": "prefers_linear_node_search",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "prefers_linear_node_search"
  },
  {
    "label": "map_value_compare",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "map_value_compare"
  },
  {
    "label": "btree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "btree"
  },
  {
    "label": "common_params",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "common_params"
  },
  {
    "label": "upper_bound_adapter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "upper_bound_adapter"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "SearchResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SearchResult"
  },
  {
    "label": "btree_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "btree_node"
  },
  {
    "label": "btree_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "btree_iterator"
  },
  {
    "label": "BtreeNodePeer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BtreeNodePeer"
  },
  {
    "label": "btree_access",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "btree_access"
  },
  {
    "label": "btree_container",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "btree_container"
  },
  {
    "label": "btree_set_container",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "btree_set_container"
  },
  {
    "label": "btree_map_container",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "btree_map_container"
  },
  {
    "label": "btree_multiset_container",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "btree_multiset_container"
  },
  {
    "label": "base_checker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "base_checker"
  },
  {
    "label": "alignas",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "alignas"
  },
  {
    "label": "node_stats",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "node_stats"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_CONTAINER_INTERNAL_BTREE_H_ # define ABSL_CONTAINER_INTERNAL_BTREE_H_ # include<algorithm> # include<cassert> # include<cstddef> # include<cstdint> # include<cstring> # include<functional> # include<iterator> # include<limits> # include<new> # include<string> # include<type_traits> # include<utility> # include \" absl / base / internal / raw_logging . h \" # include \" absl / base / macros . h \" # include \" absl / container / internal / common . h \" # include \" absl / container / internal / common_policy_traits . h \" # include \" absl / container / internal / compressed_tuple . h \" # include \" absl / container / internal / container_memory . h \" # include \" absl / container / internal / layout . h \" # include \" absl / memory / memory . h \" # include \" absl / meta / type_traits . h \" # include \" absl / strings / cord . h \" # include \" absl / strings / string_view . h \" # include \" absl / types / compare . h \" # include \" absl / utility / utility . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace container_internal { # ifdef ABSL_BTREE_ENABLE_GENERATIONS # error ABSL_BTREE_ENABLE_GENERATIONS cannot be directly set # elif)",
    "insertText": "defined(ABSL_HAVE_ADDRESS_SANITIZER) || \\ defined(ABSL_HAVE_MEMORY_SANITIZER) #define ABSL_BTREE_ENABLE_GENERATIONS #endif template <typename Compare, typename T, typename U> using compare_result_t = absl::result_of_t<const Compare(const T &, const U &)"
  },
  {
    "label": "StringBtreeDefaultLess()",
    "kind": "Method",
    "detail": "Function (template<Compare,T> using btree_is_key_compare_to = std::is_convertible<compare_result_t<Compare,T,T>,absl::weak_ordering> ; struct StringBtreeDefaultLess { using is_transparent = void ;)",
    "insertText": "StringBtreeDefaultLess()"
  },
  {
    "label": "StringBtreeDefaultLess()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StringBtreeDefaultLess(std::less<std::string>)"
  },
  {
    "label": "StringBtreeDefaultLess()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "StringBtreeDefaultLess(std::less<absl::string_view>)"
  },
  {
    "label": "string()",
    "kind": "Method",
    "detail": "Function (} operator std::less<)",
    "insertText": "string()"
  },
  {
    "label": "StringBtreeDefaultLess()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "StringBtreeDefaultLess(std::less<absl::Cord>)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} absl::weak_ordering)",
    "insertText": "operator()(const absl::Cord &lhs, const absl::Cord &rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} absl::weak_ordering)",
    "insertText": "operator()(const absl::Cord &lhs, absl::string_view rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} absl::weak_ordering)",
    "insertText": "operator()(absl::string_view lhs, const absl::Cord &rhs)"
  },
  {
    "label": "StringBtreeDefaultGreater()",
    "kind": "Method",
    "detail": "Function (} } ; struct StringBtreeDefaultGreater { using is_transparent = void ;)",
    "insertText": "StringBtreeDefaultGreater()"
  },
  {
    "label": "StringBtreeDefaultGreater()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StringBtreeDefaultGreater(std::greater<std::string>)"
  },
  {
    "label": "StringBtreeDefaultGreater()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "StringBtreeDefaultGreater(std::greater<absl::string_view>)"
  },
  {
    "label": "StringBtreeDefaultGreater()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "StringBtreeDefaultGreater(std::greater<absl::Cord>)"
  },
  {
    "label": "checked_compare_base()",
    "kind": "Method",
    "detail": "Function (} } ; template<Compare,bool is_class = std::is_class<Compare>::value> struct checked_compare_base : Compare { using Compare::Compare ;)",
    "insertText": "checked_compare_base(Compare c) : Compare(std::move(c))"
  },
  {
    "label": "comp()",
    "kind": "Method",
    "detail": "Function (} const Compare&)",
    "insertText": "comp()"
  },
  {
    "label": "is_self_equivalent()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "is_self_equivalent(const T &)"
  },
  {
    "label": "Compare()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "Compare()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,U,absl::enable_if_t<std::is_same<bool,compare_result_t<Compare,T,U>>::value,int> = 0> bool)",
    "insertText": "operator()(const T &lhs, const U &rhs)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(is_self_equivalent(lhs))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(is_self_equivalent(rhs))"
  },
  {
    "label": "comp()",
    "kind": "Method",
    "detail": "Function (const bool lhs_comp_rhs =)",
    "insertText": "comp()(lhs, rhs)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!lhs_comp_rhs || !comp()(rhs, lhs))"
  },
  {
    "label": "comp()",
    "kind": "Method",
    "detail": "Function (# ifndef NDEBUG const absl::weak_ordering rhs_comp_lhs =)",
    "insertText": "comp()(rhs, lhs)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(rhs_comp_lhs < 0 && \"lhs_comp_rhs > 0 -> rhs_comp_lhs < 0\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(lhs_comp_rhs == 0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(rhs_comp_lhs == 0 && \"lhs_comp_rhs == 0 -> rhs_comp_lhs == 0\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "assert(rhs_comp_lhs > 0 && \"lhs_comp_rhs < 0 -> rhs_comp_lhs > 0\")"
  },
  {
    "label": "compare_has_valid_result_type()",
    "kind": "Method",
    "detail": "Function (} # endif return lhs_comp_rhs ; } } ; using type = absl::conditional_t<std::is_base_of<BtreeTestOnlyCheckedCompareOptOutBase,Compare>::value,Compare,checked_compare> ; } ; template<> struct key_compare_adapter<std::less<std::string>,std::string> { using type = StringBtreeDefaultLess ; } ; template<> struct key_compare_adapter<std::greater<std::string>,std::string> { using type = StringBtreeDefaultGreater ; } ; template<> struct key_compare_adapter<std::less<absl::string_view>,absl::string_view> { using type = StringBtreeDefaultLess ; } ; template<> struct key_compare_adapter<std::greater<absl::string_view>,absl::string_view> { using type = StringBtreeDefaultGreater ; } ; template<> struct key_compare_adapter<std::less<absl::Cord>,absl::Cord> { using type = StringBtreeDefaultLess ; } ; template<> struct key_compare_adapter<std::greater<absl::Cord>,absl::Cord> { using type = StringBtreeDefaultGreater ; } ; template<T,= void> struct has_linear_node_search_preference : std::false_type { } ; template<T,= void> struct prefers_linear_node_search : std::false_type { } ; template<T> struct has_linear_node_search_preference<T,absl::void_t<T::absl_btree_prefer_linear_node_search>> : std::true_type { } ; template<T> struct prefers_linear_node_search<T,absl::void_t<T::absl_btree_prefer_linear_node_search>> : T::absl_btree_prefer_linear_node_search { } ; template<Compare,Key> bool)",
    "insertText": "compare_has_valid_result_type()"
  },
  {
    "label": "map_value_compare()",
    "kind": "Method",
    "detail": "Function (using compare_result_type = compare_result_t<Compare,Key,Key> ; return std::is_same<compare_result_type,bool>::value | | std::is_convertible<compare_result_type,absl::weak_ordering>::value ; } template<original_key_compare,value_type> class map_value_compare { template<Params> class btree ; protected :)",
    "insertText": "map_value_compare(original_key_compare c) : comp(std::move(c))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} original_key_compare comp ; public : auto)",
    "insertText": "operator()(const value_type &lhs, const value_type &rhs) const -> decltype(comp(lhs.first, rhs.first))"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (} } ; template<Key,Compare,Alloc,int TargetNodeSize,bool IsMulti,bool IsMap,SlotPolicy> struct common_params : common_policy_traits<SlotPolicy> { using original_key_compare = Compare ; using key_compare = absl::conditional_t<! compare_has_valid_result_type<Compare,)",
    "insertText": "Key()"
  },
  {
    "label": "can_have_multiple_equivalent_keys()",
    "kind": "Method",
    "detail": "Function (bool kIsKeyCompareStringAdapted = std::is_same<key_compare,StringBtreeDefaultLess>::value | | std::is_same<key_compare,StringBtreeDefaultGreater>::value ; bool kIsKeyCompareTransparent = IsTransparent<original_key_compare>::value | | kIsKeyCompareStringAdapted ; bool kEnableGenerations = # ifdef ABSL_BTREE_ENABLE_GENERATIONS true ; # else false ; # endif using is_key_compare_to = btree_is_key_compare_to<key_compare,Key> ; using allocator_type = Alloc ; using key_type = Key ; using size_type = size_t ; using difference_type = ptrdiff_t ; using slot_policy = SlotPolicy ; using slot_type = slot_policy::slot_type ; using value_type = slot_policy::value_type ; using init_type = slot_policy::mutable_value_type ; using pointer = value_type* ; using const_pointer = const value_type* ; using reference = value_type& ; using const_reference = const value_type& ; using value_compare = absl::conditional_t<IsMap,map_value_compare<original_key_compare,value_type>,original_key_compare> ; using is_map_container = std::integral_constant<bool,IsMap> ; template<LookupKey> bool)",
    "insertText": "can_have_multiple_equivalent_keys()"
  },
  {
    "label": "TargetNodeSize()",
    "kind": "Method",
    "detail": "Function (} enum { kTargetNodeSize = TargetNodeSize,kNodeSlotSpace =)",
    "insertText": "TargetNodeSize(sizeof(void *) + 4)"
  },
  {
    "label": "conditional_t()",
    "kind": "Method",
    "detail": "Function (using node_count_type =)",
    "insertText": "conditional_t(kNodeSlotSpace / sizeof(slot_type) > (std::numeric_limits<uint8_t>::max)())"
  },
  {
    "label": "upper_bound_adapter()",
    "kind": "Method",
    "detail": "Function (} ; template<Compare> struct upper_bound_adapter {)",
    "insertText": "upper_bound_adapter(const Compare &c) : comp(c)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<K1,K2> bool)",
    "insertText": "operator()(const K1 &a, const K2 &b)"
  },
  {
    "label": "HasMatch()",
    "kind": "Method",
    "detail": "Function (} private : Compare comp ; } ; enum class MatchKind : uint8_t { kEq,kNe } ; template<V,bool IsCompareTo> struct SearchResult { V value ; MatchKind match ; bool)",
    "insertText": "HasMatch()"
  },
  {
    "label": "SearchResult()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SearchResult(V v) : value(v)"
  },
  {
    "label": "SearchResult()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SearchResult(V v, MatchKind ) : value(v)"
  },
  {
    "label": "btree_node()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "btree_node()"
  },
  {
    "label": "btree_node()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "btree_node(btree_node const &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (btree_node&)",
    "insertText": "operator(btree_node const &)"
  },
  {
    "label": "Alignment()",
    "kind": "Method",
    "detail": "Function (size_type)",
    "insertText": "Alignment()"
  },
  {
    "label": "SizeWithNSlots()",
    "kind": "Method",
    "detail": "Function (private : using layout_type = absl::container_internal::Layout<btree_node*,uint32_t,field_type,slot_type,btree_node*> ; size_type)",
    "insertText": "SizeWithNSlots(size_type n)"
  },
  {
    "label": "MinimumOverhead()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "MinimumOverhead()"
  },
  {
    "label": "NodeTargetSlots()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "NodeTargetSlots(const size_type begin, const size_type end)"
  },
  {
    "label": "NodeTargetSlots()",
    "kind": "Method",
    "detail": "Function (} size_type kTargetNodeSize = params_type::kTargetNodeSize ; size_type kNodeTargetSlots =)",
    "insertText": "NodeTargetSlots(0, kTargetNodeSize)"
  },
  {
    "label": "LeafLayout()",
    "kind": "Method",
    "detail": "Function (size_type kMinNodeSlots = 4 ; size_type kNodeSlots = kNodeTargetSlots> = kMinNodeSlots ? kNodeTargetSlots : kMinNodeSlots ; field_type kInternalNodeMaxCount = 0 ; layout_type)",
    "insertText": "LeafLayout(const size_type slot_count = kNodeSlots)"
  },
  {
    "label": "InternalLayout()",
    "kind": "Method",
    "detail": "Function (} layout_type)",
    "insertText": "InternalLayout()"
  },
  {
    "label": "LeafSize()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "LeafSize(const size_type slot_count = kNodeSlots)"
  },
  {
    "label": "InternalSize()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "InternalSize()"
  },
  {
    "label": "GetField()",
    "kind": "Method",
    "detail": "Function (} template<size_type N> layout_type::template ElementType<N>*)",
    "insertText": "GetField()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(N < 4 || is_internal())"
  },
  {
    "label": "set_parent()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_parent(btree_node *p)"
  },
  {
    "label": "mutable_finish()",
    "kind": "Method",
    "detail": "Function (} field_type&)",
    "insertText": "mutable_finish()"
  },
  {
    "label": "slot()",
    "kind": "Method",
    "detail": "Function (} slot_type*)",
    "insertText": "slot(size_type i)"
  },
  {
    "label": "start_slot()",
    "kind": "Method",
    "detail": "Function (} slot_type*)",
    "insertText": "start_slot()"
  },
  {
    "label": "finish_slot()",
    "kind": "Method",
    "detail": "Function (} slot_type*)",
    "insertText": "finish_slot()"
  },
  {
    "label": "set_position()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_position(field_type v)"
  },
  {
    "label": "set_start()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_start(field_type v)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_finish(field_type v)"
  },
  {
    "label": "set_max_count()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_max_count(field_type v)"
  },
  {
    "label": "is_leaf()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "is_leaf()"
  },
  {
    "label": "is_internal()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_internal()"
  },
  {
    "label": "position()",
    "kind": "Method",
    "detail": "Function (} field_type)",
    "insertText": "position()"
  },
  {
    "label": "start()",
    "kind": "Method",
    "detail": "Function (} field_type)",
    "insertText": "start()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(GetField<2>()[1] == 0)"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (} field_type)",
    "insertText": "count()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(finish() >= start())"
  },
  {
    "label": "max_count()",
    "kind": "Method",
    "detail": "Function (} field_type)",
    "insertText": "max_count()"
  },
  {
    "label": "is_root()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_root()"
  },
  {
    "label": "make_root()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "make_root()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(parent()->is_root())"
  },
  {
    "label": "set_generation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_generation(parent()->generation())"
  },
  {
    "label": "set_parent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_parent(parent()->parent())"
  },
  {
    "label": "get_root_generation()",
    "kind": "Method",
    "detail": "Function (} uint32_t*)",
    "insertText": "get_root_generation()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(params_type::kEnableGenerations)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const btree_node* curr = this ;)",
    "insertText": "for(; !curr->is_root(); curr = curr->parent())"
  },
  {
    "label": "generation()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "generation()"
  },
  {
    "label": "set_generation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_generation(uint32_t generation)"
  },
  {
    "label": "next_generation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "next_generation()"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (} const key_type&)",
    "insertText": "key(size_type i)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "value(size_type i)"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (} btree_node*)",
    "insertText": "child(field_type i)"
  },
  {
    "label": "start_child()",
    "kind": "Method",
    "detail": "Function (} btree_node*)",
    "insertText": "start_child()"
  },
  {
    "label": "mutable_child()",
    "kind": "Method",
    "detail": "Function (} btree_node*&)",
    "insertText": "mutable_child(field_type i)"
  },
  {
    "label": "clear_child()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear_child(field_type i)"
  },
  {
    "label": "SanitizerPoisonObject()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "SanitizerPoisonObject(&mutable_child(i))"
  },
  {
    "label": "set_child()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_child(field_type i, btree_node *c)"
  },
  {
    "label": "SanitizerUnpoisonObject()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "SanitizerUnpoisonObject(&mutable_child(i))"
  },
  {
    "label": "mutable_child()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mutable_child(i)"
  },
  {
    "label": "set_position()",
    "kind": "Method",
    "detail": "Function (c ->)",
    "insertText": "set_position(i)"
  },
  {
    "label": "init_child()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "init_child(field_type i, btree_node *c)"
  },
  {
    "label": "set_child()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_child(i, c)"
  },
  {
    "label": "set_parent()",
    "kind": "Method",
    "detail": "Function (c ->)",
    "insertText": "set_parent(this)"
  },
  {
    "label": "lower_bound()",
    "kind": "Method",
    "detail": "Function (} template<K> SearchResult<size_type,is_key_compare_to::value>)",
    "insertText": "lower_bound(const K &k, const key_compare &comp)"
  },
  {
    "label": "upper_bound()",
    "kind": "Method",
    "detail": "Function (} template<K> size_type)",
    "insertText": "upper_bound(const K &k, const key_compare &comp)"
  },
  {
    "label": "key_compare()",
    "kind": "Method",
    "detail": "Function (auto upper_compare = upper_bound_adapter<)",
    "insertText": "key_compare(comp)"
  },
  {
    "label": "linear_search()",
    "kind": "Method",
    "detail": "Function (} template<K,Compare> SearchResult<size_type,btree_is_key_compare_to<Compare,key_type>::value>)",
    "insertText": "linear_search(const K &k, const Compare &comp)"
  },
  {
    "label": "binary_search()",
    "kind": "Method",
    "detail": "Function (} template<K,Compare> SearchResult<size_type,btree_is_key_compare_to<Compare,key_type>::value>)",
    "insertText": "binary_search(const K &k, const Compare &comp)"
  },
  {
    "label": "linear_search_impl()",
    "kind": "Method",
    "detail": "Function (} template<K,Compare> SearchResult<size_type,false>)",
    "insertText": "linear_search_impl(const K &k, size_type s, const size_type e, const Compare &comp, std::false_type)"
  },
  {
    "label": "linear_search_impl()",
    "kind": "Method",
    "detail": "Function (break ; } + + s ; } return SearchResult<size_type,false> { s } ; } template<K,Compare> SearchResult<size_type,true>)",
    "insertText": "linear_search_impl(const K &k, size_type s, const size_type e, const Compare &comp, std::true_type)"
  },
  {
    "label": "comp()",
    "kind": "Method",
    "detail": "Function (const absl::weak_ordering c =)",
    "insertText": "comp(key(s), k)"
  },
  {
    "label": "binary_search_impl()",
    "kind": "Method",
    "detail": "Function (break ; } + + s ; } return { s,MatchKind::kNe } ; } template<K,Compare> SearchResult<size_type,false>)",
    "insertText": "binary_search_impl(const K &k, size_type s, size_type e, const Compare &comp, std::false_type)"
  },
  {
    "label": "mid()",
    "kind": "Method",
    "detail": "Function (const size_type)",
    "insertText": "mid(s + e)"
  },
  {
    "label": "binary_search_impl()",
    "kind": "Method",
    "detail": "Function (s = mid + 1 ; } else { e = mid ; } } return SearchResult<size_type,false> { s } ; } template<K,CompareTo> SearchResult<size_type,true>)",
    "insertText": "binary_search_impl(const K &k, size_type s, size_type e, const CompareTo &comp, std::true_type)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (MatchKind exact_match = MatchKind::kNe ;)",
    "insertText": "while(s != e)"
  },
  {
    "label": "comp()",
    "kind": "Method",
    "detail": "Function (const absl::weak_ordering c =)",
    "insertText": "comp(key(mid), k)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (s = mid + 1 ; } else { e = mid ;)",
    "insertText": "if(c == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (s = mid + 1 ; } else)",
    "insertText": "if(c > 0)"
  },
  {
    "label": "emplace_value()",
    "kind": "Method",
    "detail": "Function (e = mid ; } else { return { mid,MatchKind::kEq } ; } } return { s,MatchKind::kNe } ; } } template<. . . Args> void)",
    "insertText": "emplace_value(field_type i, allocator_type *alloc, Args &&...args)"
  },
  {
    "label": "remove_values()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove_values(field_type i, field_type to_erase, allocator_type *alloc)"
  },
  {
    "label": "rebalance_right_to_left()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rebalance_right_to_left(field_type to_move, btree_node *right, allocator_type *alloc)"
  },
  {
    "label": "rebalance_left_to_right()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rebalance_left_to_right(field_type to_move, btree_node *right, allocator_type *alloc)"
  },
  {
    "label": "split()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "split(int insert_position, btree_node *dest, allocator_type *alloc)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "merge(btree_node *src, allocator_type *alloc)"
  },
  {
    "label": "init_leaf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init_leaf(field_type max_count, btree_node *parent)"
  },
  {
    "label": "set_generation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_generation(0)"
  },
  {
    "label": "set_parent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_parent(parent)"
  },
  {
    "label": "set_position()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_position(0)"
  },
  {
    "label": "set_start()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_start(0)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_finish(0)"
  },
  {
    "label": "set_max_count()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_max_count(max_count)"
  },
  {
    "label": "SanitizerPoisonMemoryRegion()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "SanitizerPoisonMemoryRegion(start_slot(), max_count * sizeof(slot_type))"
  },
  {
    "label": "init_internal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "init_internal(btree_node *parent)"
  },
  {
    "label": "init_leaf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init_leaf(kNodeSlots, parent)"
  },
  {
    "label": "set_max_count()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_max_count(kInternalNodeMaxCount)"
  },
  {
    "label": "SanitizerPoisonMemoryRegion()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "SanitizerPoisonMemoryRegion(&mutable_child(start()), (kNodeSlots + 1) * sizeof(btree_node *))"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "deallocate(const size_type size, btree_node *node, allocator_type *alloc)"
  },
  {
    "label": "SanitizerUnpoisonMemoryRegion()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "SanitizerUnpoisonMemoryRegion(node, size)"
  },
  {
    "label": "Alignment()",
    "kind": "Method",
    "detail": "Function (absl::container_internal::Deallocate<)",
    "insertText": "Alignment()>(alloc, node, size)"
  },
  {
    "label": "clear_and_delete()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear_and_delete(btree_node *node, allocator_type *alloc)"
  },
  {
    "label": "value_init()",
    "kind": "Method",
    "detail": "Function (private : template<. . . Args> void)",
    "insertText": "value_init(const field_type i, allocator_type *alloc, Args &&...args)"
  },
  {
    "label": "SanitizerUnpoisonObject()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "SanitizerUnpoisonObject(slot(i))"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "construct(alloc, slot(i), std::forward<Args>(args)...)"
  },
  {
    "label": "value_destroy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "value_destroy(const field_type i, allocator_type *alloc)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy(alloc, slot(i))"
  },
  {
    "label": "SanitizerPoisonObject()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "SanitizerPoisonObject(slot(i))"
  },
  {
    "label": "value_destroy_n()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "value_destroy_n(const field_type i, const field_type n, allocator_type *alloc)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy(alloc, s)"
  },
  {
    "label": "SanitizerPoisonObject()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "SanitizerPoisonObject(s)"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "transfer(slot_type *dest, slot_type *src, allocator_type *alloc)"
  },
  {
    "label": "SanitizerUnpoisonObject()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "SanitizerUnpoisonObject(dest)"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer(alloc, dest, src)"
  },
  {
    "label": "SanitizerPoisonObject()",
    "kind": "Method",
    "detail": "Function (absl::)",
    "insertText": "SanitizerPoisonObject(src)"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "transfer(const size_type dest_i, const size_type src_i, btree_node *src_node, allocator_type *alloc)"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer(slot(dest_i), src_node->slot(src_i), alloc)"
  },
  {
    "label": "transfer_n()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "transfer_n(const size_type n, const size_type dest_i, const size_type src_i, btree_node *src_node, allocator_type *alloc)"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer(dest, src, alloc)"
  },
  {
    "label": "transfer_n_backward()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "transfer_n_backward(const size_type n, const size_type dest_i, const size_type src_i, btree_node *src_node, allocator_type *alloc)"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer(dest - 1, src - 1, alloc)"
  },
  {
    "label": "btree_iterator()",
    "kind": "Method",
    "detail": "Function (} } template<P> class btree ; template<N,R,P> class btree_iterator ; class BtreeNodePeer ; struct btree_access ; } ; template<Node,Reference,Pointer> class btree_iterator { using field_type = Node::field_type ; using key_type = Node::key_type ; using size_type = Node::size_type ; using params_type = Node::params_type ; using is_map_container = params_type::is_map_container ; using node_type = Node ; using normal_node = std::remove_const<Node>::type ; using const_node = const Node ; using normal_pointer = params_type::pointer ; using normal_reference = params_type::reference ; using const_pointer = params_type::const_pointer ; using const_reference = params_type::const_reference ; using slot_type = params_type::slot_type ; using iterator = btree_iterator<normal_node,normal_reference,normal_pointer> ; using const_iterator = btree_iterator<const_node,const_reference,const_pointer> ; public : using difference_type = Node::difference_type ; using value_type = params_type::value_type ; using pointer = Pointer ; using reference = Reference ; using iterator_category = std::bidirectional_iterator_tag ;)",
    "insertText": "btree_iterator() : btree_iterator(nullptr, -1)"
  },
  {
    "label": "btree_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "btree_iterator(Node *n) : btree_iterator(n, n->start())"
  },
  {
    "label": "btree_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "btree_iterator(Node *n, int p) : node_(n), position_(p)"
  },
  {
    "label": "btree_iterator()",
    "kind": "Method",
    "detail": "Function (} ; # endif } template<N,R,P,absl::enable_if_t<std::is_same<btree_iterator<N,R,P>,iterator>::value&& std::is_same<btree_iterator,const_iterator>::value,int> = 0>)",
    "insertText": "btree_iterator(const btree_iterator<N, R, P> other) : node_(other.node_), position_(other.position_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_BTREE_ENABLE_GENERATIONS generation_ = other . generation_ ; # endif } bool)",
    "insertText": "operator(const iterator &other)"
  },
  {
    "label": "distance_slow()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "distance_slow(other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "operator()"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(node_ != nullptr)"
  },
  {
    "label": "assert_valid_generation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert_valid_generation()"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(position_ >= node_->start())"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(!IsEndIterator() && \"Dereferencing end() iterator\")"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(position_ < node_->finish())"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} return node_ ->)",
    "insertText": "value(static_cast<field_type>(position_))"
  },
  {
    "label": "increment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "increment()"
  },
  {
    "label": "decrement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decrement()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (btree_iterator tmp =* this ; + +* this ; return tmp ; } btree_iterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "btree_iterator()",
    "kind": "Method",
    "detail": "Function (btree_iterator tmp =* this ; - -* this ; return tmp ; } private : iterator ; const_iterator ; template<Params> class btree ; template<Tree> class btree_container ; template<Tree> class btree_set_container ; template<Tree> class btree_map_container ; template<Tree> class btree_multiset_container ; template<TreeType,CheckerType> class base_checker ; struct btree_access ; template<N,R,P,absl::enable_if_t<std::is_same<btree_iterator<N,R,P>,const_iterator>::value&& std::is_same<btree_iterator,iterator>::value,int> = 0>)",
    "insertText": "btree_iterator(const btree_iterator<N, R, P> other) : node_(const_cast<node_type *>(other.node_)), position_(other.position_)"
  },
  {
    "label": "IsEndIterator()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_BTREE_ENABLE_GENERATIONS generation_ = other . generation_ ; # endif } bool)",
    "insertText": "IsEndIterator()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (node_type* node = node_ ;)",
    "insertText": "while(!node->is_root()) node = node->parent()"
  },
  {
    "label": "increment_slow()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "increment_slow()"
  },
  {
    "label": "decrement_slow()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "decrement_slow()"
  },
  {
    "label": "update_generation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "update_generation()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_BTREE_ENABLE_GENERATIONS)",
    "insertText": "if(node_ != nullptr) generation_ = node_->generation()"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (# endif } const key_type&)",
    "insertText": "key()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "decltype(std::declval<Node *>()->slot(0)) slot()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_BTREE_ENABLE_GENERATIONS)",
    "insertText": "if(node_ != nullptr && node_->generation() != generation_)"
  },
  {
    "label": "ABSL_INTERNAL_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_LOG(FATAL, \"Attempting to use an invalidated iterator. The corresponding b-tree \" \"container has been mutated since this iterator was constructed.\")"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (} # endif } Node* node_ ; int position_ ; # ifdef ABSL_BTREE_ENABLE_GENERATIONS uint32_t generation_ ; # endif } ; template<Params> class btree { using node_type = btree_node<Params> ; using is_key_compare_to = Params::is_key_compare_to ; using field_type = node_type::field_type ; struct)",
    "insertText": "alignas(node_type::Alignment())"
  },
  {
    "label": "EmptyNodeType()",
    "kind": "Method",
    "detail": "Function (using field_type = node_type::field_type ; node_type* parent ; # ifdef ABSL_BTREE_ENABLE_GENERATIONS uint32_t generation = 0 ; # endif field_type position = 0 ; field_type start = 0 ; field_type finish = 0 ; field_type max_count = node_type::kInternalNodeMaxCount + 1 ; # ifdef _MSC_VER)",
    "insertText": "EmptyNodeType() : parent(this)"
  },
  {
    "label": "EmptyNodeType()",
    "kind": "Method",
    "detail": "Function (} # else)",
    "insertText": "EmptyNodeType(node_type *p) : parent(p)"
  },
  {
    "label": "EmptyNode()",
    "kind": "Method",
    "detail": "Function (} # endif } ; node_type*)",
    "insertText": "EmptyNode()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_VER EmptyNodeType* empty_node = new EmptyNodeType ;)",
    "insertText": "assert(empty_node->parent == empty_node)"
  },
  {
    "label": "node_stats()",
    "kind": "Method",
    "detail": "Function (# endif } enum : uint32_t { kNodeSlots = node_type::kNodeSlots,kMinNodeValues = kNodeSlots / 2,} ; struct node_stats { using size_type = Params::size_type ;)",
    "insertText": "node_stats(size_type l, size_type i) : leaf_nodes(l), internal_nodes(i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} node_stats&)",
    "insertText": "operator(const node_stats &other)"
  },
  {
    "label": "copy_or_move_values_in_order()",
    "kind": "Method",
    "detail": "Function (leaf_nodes + = other . leaf_nodes ; internal_nodes + = other . internal_nodes ; return* this ; } size_type leaf_nodes ; size_type internal_nodes ; } ; public : using key_type = Params::key_type ; using value_type = Params::value_type ; using size_type = Params::size_type ; using difference_type = Params::difference_type ; using key_compare = Params::key_compare ; using original_key_compare = Params::original_key_compare ; using value_compare = Params::value_compare ; using allocator_type = Params::allocator_type ; using reference = Params::reference ; using const_reference = Params::const_reference ; using pointer = Params::pointer ; using const_pointer = Params::const_pointer ; using iterator = btree_iterator<node_type,reference,pointer>::iterator ; using const_iterator = iterator::const_iterator ; using reverse_iterator = std::reverse_iterator<iterator> ; using const_reverse_iterator = std::reverse_iterator<const_iterator> ; using node_handle_type = node_handle<Params,Params,allocator_type> ; using params_type = Params ; using slot_type = Params::slot_type ; private : template<Btree> void)",
    "insertText": "copy_or_move_values_in_order(Btree &other)"
  },
  {
    "label": "static_assert_validation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "static_assert_validation()"
  },
  {
    "label": "btree()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "btree(const key_compare &comp, const allocator_type &alloc) : root_(EmptyNode()), rightmost_(comp, alloc, EmptyNode()), size_(0)"
  },
  {
    "label": "btree()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "btree(const btree &other) : btree(other, other.allocator())"
  },
  {
    "label": "btree()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "btree(const btree &other, const allocator_type &alloc) : btree(other.key_comp(), alloc)"
  },
  {
    "label": "copy_or_move_values_in_order()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy_or_move_values_in_order(other)"
  },
  {
    "label": "btree()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "btree(btree &&other) noexcept : root_(absl::exchange(other.root_, EmptyNode())), rightmost_(std::move(other.rightmost_)), size_(absl::exchange(other.size_, 0u))"
  },
  {
    "label": "mutable_rightmost()",
    "kind": "Method",
    "detail": "Function (other .)",
    "insertText": "mutable_rightmost() = EmptyNode()"
  },
  {
    "label": "btree()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "btree(btree &&other, const allocator_type &alloc) : btree(other.key_comp(), alloc)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(other)"
  },
  {
    "label": "btree()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "btree()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} btree&)",
    "insertText": "operator(const btree &other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (btree&)",
    "insertText": "operator(btree &&other)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rbegin()"
  },
  {
    "label": "rend()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rend()"
  },
  {
    "label": "lower_bound()",
    "kind": "Method",
    "detail": "Function (} template<K> iterator)",
    "insertText": "lower_bound(const K &key)"
  },
  {
    "label": "lower_bound_equal()",
    "kind": "Method",
    "detail": "Function (} template<K> std::pair<iterator,bool>)",
    "insertText": "lower_bound_equal(const K &key)"
  },
  {
    "label": "upper_bound()",
    "kind": "Method",
    "detail": "Function (template<K> iterator)",
    "insertText": "upper_bound(const K &key)"
  },
  {
    "label": "equal_range()",
    "kind": "Method",
    "detail": "Function (} template<K> std::pair<iterator,iterator>)",
    "insertText": "equal_range(const K &key)"
  },
  {
    "label": "insert_unique()",
    "kind": "Method",
    "detail": "Function (} template<K,. . . Args> std::pair<iterator,bool>)",
    "insertText": "insert_unique(const K &key, Args &&...args)"
  },
  {
    "label": "insert_hint_unique()",
    "kind": "Method",
    "detail": "Function (template<K,. . . Args> std::pair<iterator,bool>)",
    "insertText": "insert_hint_unique(iterator position, const K &key, Args &&...args)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<InputIterator,=)",
    "insertText": "decltype(std::declval<const key_compare &>()( params_type::key(*std::declval<InputIterator>()), std::declval<const key_type &>()))> void insert_iterator_unique(InputIterator b, InputIterator e, int)"
  },
  {
    "label": "insert_iterator_unique()",
    "kind": "Method",
    "detail": "Function (template<InputIterator> void)",
    "insertText": "insert_iterator_unique(InputIterator b, InputIterator e, char)"
  },
  {
    "label": "insert_multi()",
    "kind": "Method",
    "detail": "Function (template<ValueType> iterator)",
    "insertText": "insert_multi(const key_type &key, ValueType &&v)"
  },
  {
    "label": "insert_multi()",
    "kind": "Method",
    "detail": "Function (template<ValueType> iterator)",
    "insertText": "insert_multi(ValueType &&v)"
  },
  {
    "label": "insert_hint_multi()",
    "kind": "Method",
    "detail": "Function (} template<ValueType> iterator)",
    "insertText": "insert_hint_multi(iterator position, ValueType &&v)"
  },
  {
    "label": "insert_iterator_multi()",
    "kind": "Method",
    "detail": "Function (template<InputIterator> void)",
    "insertText": "insert_iterator_multi(InputIterator b, InputIterator e)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "erase(iterator iter)"
  },
  {
    "label": "erase_range()",
    "kind": "Method",
    "detail": "Function (std::pair<size_type,iterator>)",
    "insertText": "erase_range(iterator begin, iterator end)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (template<K> iterator)",
    "insertText": "find(const K &key)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(btree &other)"
  },
  {
    "label": "key_comp()",
    "kind": "Method",
    "detail": "Function (const key_compare&)",
    "insertText": "key_comp()"
  },
  {
    "label": "compare_keys()",
    "kind": "Method",
    "detail": "Function (} template<K1,K2> bool)",
    "insertText": "compare_keys(const K1 &a, const K2 &b)"
  },
  {
    "label": "value_comp()",
    "kind": "Method",
    "detail": "Function (} value_compare)",
    "insertText": "value_comp()"
  },
  {
    "label": "verify()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "verify()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_type)",
    "insertText": "size()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_type h = 0 ;)",
    "insertText": "if(!empty())"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (const node_type* n =)",
    "insertText": "root()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(n != root())"
  },
  {
    "label": "leaf_nodes()",
    "kind": "Method",
    "detail": "Function (} return h ; } size_type)",
    "insertText": "leaf_nodes()"
  },
  {
    "label": "internal_nodes()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "internal_nodes()"
  },
  {
    "label": "nodes()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "nodes()"
  },
  {
    "label": "internal_stats()",
    "kind": "Method",
    "detail": "Function (node_stats stats =)",
    "insertText": "internal_stats(root())"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "sizeof(*this) + stats.leaf_nodes * node_type::LeafSize() + stats.internal_nodes * node_type::InternalSize()"
  },
  {
    "label": "average_bytes_per_value()",
    "kind": "Method",
    "detail": "Function (} } double)",
    "insertText": "average_bytes_per_value()"
  },
  {
    "label": "expected_values_per_node()",
    "kind": "Method",
    "detail": "Function (const double)",
    "insertText": "expected_values_per_node(kNodeSlots + kMinNodeValues)"
  },
  {
    "label": "fullness()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "fullness()"
  },
  {
    "label": "overhead()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "overhead()"
  },
  {
    "label": "get_allocator()",
    "kind": "Method",
    "detail": "Function (} allocator_type)",
    "insertText": "get_allocator()"
  },
  {
    "label": "rightmost()",
    "kind": "Method",
    "detail": "Function (} const node_type*)",
    "insertText": "rightmost()"
  },
  {
    "label": "mutable_rightmost()",
    "kind": "Method",
    "detail": "Function (} node_type*&)",
    "insertText": "mutable_rightmost()"
  },
  {
    "label": "mutable_key_comp()",
    "kind": "Method",
    "detail": "Function (} key_compare*)",
    "insertText": "mutable_key_comp()"
  },
  {
    "label": "leftmost()",
    "kind": "Method",
    "detail": "Function (} node_type*)",
    "insertText": "leftmost()"
  },
  {
    "label": "mutable_allocator()",
    "kind": "Method",
    "detail": "Function (} allocator_type*)",
    "insertText": "mutable_allocator()"
  },
  {
    "label": "allocator()",
    "kind": "Method",
    "detail": "Function (} const allocator_type&)",
    "insertText": "allocator()"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} node_type*)",
    "insertText": "allocate(size_type size)"
  },
  {
    "label": "new_internal_node()",
    "kind": "Method",
    "detail": "Function (} node_type*)",
    "insertText": "new_internal_node(node_type *parent)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (node_type* n =)",
    "insertText": "allocate(node_type::InternalSize())"
  },
  {
    "label": "init_internal()",
    "kind": "Method",
    "detail": "Function (n ->)",
    "insertText": "init_internal(parent)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (node_type* n =)",
    "insertText": "allocate(node_type::LeafSize())"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (node_type* n =)",
    "insertText": "allocate(node_type::LeafSize(max_count))"
  },
  {
    "label": "init_leaf()",
    "kind": "Method",
    "detail": "Function (n ->)",
    "insertText": "init_leaf(max_count, n)"
  },
  {
    "label": "rebalance_or_split()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rebalance_or_split(iterator *iter)"
  },
  {
    "label": "merge_nodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "merge_nodes(node_type *left, node_type *right)"
  },
  {
    "label": "try_merge_or_rebalance()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "try_merge_or_rebalance(iterator *iter)"
  },
  {
    "label": "try_shrink()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "try_shrink()"
  },
  {
    "label": "internal_end()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "internal_end(iterator iter)"
  },
  {
    "label": "internal_end()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "internal_end(const_iterator iter)"
  },
  {
    "label": "internal_emplace()",
    "kind": "Method",
    "detail": "Function (} template<. . . Args> iterator)",
    "insertText": "internal_emplace(iterator iter, Args &&...args)"
  },
  {
    "label": "internal_last()",
    "kind": "Method",
    "detail": "Function (template<IterType> IterType)",
    "insertText": "internal_last(IterType iter)"
  },
  {
    "label": "internal_locate()",
    "kind": "Method",
    "detail": "Function (template<K> SearchResult<iterator,is_key_compare_to::value>)",
    "insertText": "internal_locate(const K &key)"
  },
  {
    "label": "internal_lower_bound()",
    "kind": "Method",
    "detail": "Function (template<K> SearchResult<iterator,is_key_compare_to::value>)",
    "insertText": "internal_lower_bound(const K &key)"
  },
  {
    "label": "internal_upper_bound()",
    "kind": "Method",
    "detail": "Function (template<K> iterator)",
    "insertText": "internal_upper_bound(const K &key)"
  },
  {
    "label": "internal_find()",
    "kind": "Method",
    "detail": "Function (template<K> iterator)",
    "insertText": "internal_find(const K &key)"
  },
  {
    "label": "internal_verify()",
    "kind": "Method",
    "detail": "Function (size_type)",
    "insertText": "internal_verify(const node_type *node, const key_type *lo, const key_type *hi)"
  },
  {
    "label": "internal_stats()",
    "kind": "Method",
    "detail": "Function (node_stats)",
    "insertText": "internal_stats(const node_type *node)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(node->is_leaf())"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (} node_stats)",
    "insertText": "res(0, 1)"
  },
  {
    "label": "internal_stats()",
    "kind": "Method",
    "detail": "Function (res + =)",
    "insertText": "internal_stats(node->child(i))"
  },
  {
    "label": "emplace_value()",
    "kind": "Method",
    "detail": "Function (} return res ; } node_type* root_ ; absl::container_internal::CompressedTuple<key_compare,allocator_type,node_type*> rightmost_ ; size_type size_ ; } ; template<P> template<. . . Args> void btree_node<P)",
    "insertText": "emplace_value(const field_type i, allocator_type *alloc, Args &&...args)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i >= start())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i <= finish())"
  },
  {
    "label": "transfer_n_backward()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer_n_backward(finish() - i, i + 1, i, this, alloc)"
  },
  {
    "label": "value_init()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "value_init(static_cast<field_type>(i), alloc, std::forward<Args>(args)...)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_finish(finish() + 1)"
  },
  {
    "label": "set_child()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_child(j, child(j - 1))"
  },
  {
    "label": "clear_child()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "clear_child(i + 1)"
  },
  {
    "label": "remove_values()",
    "kind": "Method",
    "detail": "Function (} } template<P> void btree_node<P)",
    "insertText": "remove_values(const field_type i, const field_type to_erase, allocator_type *alloc)"
  },
  {
    "label": "value_destroy_n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "value_destroy_n(i, to_erase, alloc)"
  },
  {
    "label": "finish()",
    "kind": "Method",
    "detail": "Function (const field_type orig_finish =)",
    "insertText": "finish()"
  },
  {
    "label": "transfer_n()",
    "kind": "Method",
    "detail": "Function (const field_type src_i = i + to_erase ;)",
    "insertText": "transfer_n(orig_finish - src_i, i, src_i, this, alloc)"
  },
  {
    "label": "clear_and_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear_and_delete(child(i + j + 1), alloc)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(field_type j = i + to_erase + 1; j <= orig_finish; ++j)"
  },
  {
    "label": "set_child()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_child(j - to_erase, child(j))"
  },
  {
    "label": "clear_child()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear_child(j)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "set_finish(orig_finish - to_erase)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(parent() == right->parent())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(position() + 1 == right->position())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(right->count() >= count())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(to_move >= 1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(to_move <= right->count())"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer(finish(), position(), parent(), alloc)"
  },
  {
    "label": "transfer_n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer_n(to_move - 1, finish() + 1, right->start(), right, alloc)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parent()->transfer(position(), right->start() + to_move - 1, right, alloc)"
  },
  {
    "label": "transfer_n()",
    "kind": "Method",
    "detail": "Function (right ->)",
    "insertText": "transfer_n(right->count() - to_move, right->start(), right->start() + to_move, right, alloc)"
  },
  {
    "label": "init_child()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init_child(finish() + i + 1, right->child(i))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(field_type i = right->start(); i <= right->finish() - to_move; ++i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i + to_move <= right->max_count())"
  },
  {
    "label": "init_child()",
    "kind": "Method",
    "detail": "Function (right ->)",
    "insertText": "init_child(i, right->child(i + to_move))"
  },
  {
    "label": "clear_child()",
    "kind": "Method",
    "detail": "Function (right ->)",
    "insertText": "clear_child(i + to_move)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "set_finish(finish() + to_move)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (right ->)",
    "insertText": "set_finish(right->finish() - to_move)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(count() >= right->count())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(to_move <= count())"
  },
  {
    "label": "transfer_n_backward()",
    "kind": "Method",
    "detail": "Function (right ->)",
    "insertText": "transfer_n_backward(right->count(), right->start() + to_move, right->start(), right, alloc)"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (right ->)",
    "insertText": "transfer(right->start() + to_move - 1, position(), parent(), alloc)"
  },
  {
    "label": "transfer_n()",
    "kind": "Method",
    "detail": "Function (right ->)",
    "insertText": "transfer_n(to_move - 1, right->start(), finish() - (to_move - 1), this, alloc)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parent()->transfer(position(), finish() - to_move, this, alloc)"
  },
  {
    "label": "init_child()",
    "kind": "Method",
    "detail": "Function (right ->)",
    "insertText": "init_child(i - 1 + to_move, right->child(i - 1))"
  },
  {
    "label": "clear_child()",
    "kind": "Method",
    "detail": "Function (right ->)",
    "insertText": "clear_child(i - 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(field_type i = 1; i <= to_move; ++i)"
  },
  {
    "label": "init_child()",
    "kind": "Method",
    "detail": "Function (right ->)",
    "insertText": "init_child(i - 1, child(finish() - to_move + i))"
  },
  {
    "label": "clear_child()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear_child(finish() - to_move + i)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "set_finish(finish() - to_move)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (right ->)",
    "insertText": "set_finish(right->finish() + to_move)"
  },
  {
    "label": "split()",
    "kind": "Method",
    "detail": "Function (} template<P> void btree_node<P)",
    "insertText": "split(const int insert_position, btree_node *dest, allocator_type *alloc)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(dest->count() == 0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(max_count() == kNodeSlots)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (dest ->)",
    "insertText": "set_finish(dest->start() + finish() - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(insert_position == kNodeSlots)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (dest ->)",
    "insertText": "set_finish(dest->start())"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (} else { dest ->)",
    "insertText": "set_finish(dest->start() + count() / 2)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "set_finish(finish() - dest->count())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(count() >= 1)"
  },
  {
    "label": "transfer_n()",
    "kind": "Method",
    "detail": "Function (dest ->)",
    "insertText": "transfer_n(dest->count(), dest->start(), finish(), this, alloc)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parent()->emplace_value(position(), alloc, finish_slot())"
  },
  {
    "label": "value_destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "value_destroy(finish(), alloc)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parent()->init_child(position() + 1, dest)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(child(j) != nullptr)"
  },
  {
    "label": "init_child()",
    "kind": "Method",
    "detail": "Function (dest ->)",
    "insertText": "init_child(i, child(j))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(parent() == src->parent())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(position() + 1 == src->position())"
  },
  {
    "label": "value_init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "value_init(finish(), alloc, parent()->slot(position()))"
  },
  {
    "label": "transfer_n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer_n(src->count(), finish() + 1, src->start(), src, alloc)"
  },
  {
    "label": "init_child()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init_child(j, src->child(i))"
  },
  {
    "label": "clear_child()",
    "kind": "Method",
    "detail": "Function (src ->)",
    "insertText": "clear_child(i)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "set_finish(start() + 1 + count() + src->count())"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (src ->)",
    "insertText": "set_finish(src->start())"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parent()->remove_values(position(), 1, alloc)"
  },
  {
    "label": "value_destroy_n()",
    "kind": "Method",
    "detail": "Function (node ->)",
    "insertText": "value_destroy_n(node->start(), node->count(), alloc)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deallocate(LeafSize(node->max_count()), node, alloc)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deallocate(InternalSize(), node, alloc)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (btree_node* parent = node ->)",
    "insertText": "parent()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(pos <= parent->finish())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_BTREE_ENABLE_GENERATIONS)",
    "insertText": "if(leftmost_leaf != node) #endif deallocate(LeafSize(node->max_count()), node, alloc)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + pos ; })",
    "insertText": "while(pos <= parent->finish())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(pos > parent->finish())"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_BTREE_ENABLE_GENERATIONS)",
    "insertText": "deallocate(LeafSize(leftmost_leaf->max_count()), leftmost_leaf, alloc)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# endif return ; } + + pos ; })",
    "insertText": "while(pos > parent->finish())"
  },
  {
    "label": "distance_slow()",
    "kind": "Method",
    "detail": "Function (difference_type)",
    "insertText": "distance_slow(const_iterator other)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (const_iterator begin = other ; const_iterator end =* this ;)",
    "insertText": "assert(begin.node_ != end.node_ || !begin.node_->is_leaf() || begin.position_ != end.position_)"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (+ + count ; node = node ->)",
    "insertText": "child(begin.position_ + 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(node->is_internal()) node = node->start_child()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(node == end.node_)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(position_ >= node_->finish())"
  },
  {
    "label": "save()",
    "kind": "Method",
    "detail": "Function (btree_iterator)",
    "insertText": "save(*this)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(node_->parent()->child(node_->position()) == node_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(position_ == node_->finish())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (* this = save ; } } else {)",
    "insertText": "assert(position_ < node_->finish())"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (node_ = node_ ->)",
    "insertText": "child(static_cast<field_type>(position_ + 1))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(position_ <= -1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(position_ < node_->start())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (* this = save ; } } else {)",
    "insertText": "assert(position_ >= node_->start())"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (node_ = node_ ->)",
    "insertText": "child(static_cast<field_type>(position_))"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (node_ = node_ ->)",
    "insertText": "child(node_->finish())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(empty())"
  },
  {
    "label": "insert_multi()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert_multi(iter.slot())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (+ + iter ;)",
    "insertText": "for(; iter != other.end(); ++iter)"
  },
  {
    "label": "internal_emplace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_emplace(end(), iter.slot())"
  },
  {
    "label": "internal_lower_bound()",
    "kind": "Method",
    "detail": "Function (const SearchResult<iterator,is_key_compare_to::value> res =)",
    "insertText": "internal_lower_bound(key)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (const iterator lower =)",
    "insertText": "iterator(internal_end(res.value))"
  },
  {
    "label": "HasMatch()",
    "kind": "Method",
    "detail": "Function (const bool equal = res .)",
    "insertText": "HasMatch() ? res.IsEq() : lower != end() && !compare_keys(key, lower.key())"
  },
  {
    "label": "lower_bound_equal()",
    "kind": "Method",
    "detail": "Function (const std::pair<iterator,bool> lower_and_equal =)",
    "insertText": "lower_bound_equal(key)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const iterator lower = lower_and_equal . first ;)",
    "insertText": "if(!lower_and_equal.second)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(next == end() || compare_keys(key, next.key()))"
  },
  {
    "label": "upper_bound()",
    "kind": "Method",
    "detail": "Function (lower,next } ; return { lower,)",
    "insertText": "upper_bound(key)"
  },
  {
    "label": "mutable_root()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mutable_root() = mutable_rightmost() = new_leaf_root_node(1)"
  },
  {
    "label": "internal_locate()",
    "kind": "Method",
    "detail": "Function (} SearchResult<iterator,is_key_compare_to::value> res =)",
    "insertText": "internal_locate(key)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (iterator iter = res . value ;)",
    "insertText": "if(res.HasMatch())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(compare_keys(position.key(), key))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + position ;)",
    "insertText": "if(position == end() || compare_keys(key, position.key()))"
  },
  {
    "label": "insert_unique()",
    "kind": "Method",
    "detail": "Function (} } else { return { position,false } ; } } return)",
    "insertText": "insert_unique(key, std::forward<Args>(args)...)"
  },
  {
    "label": "insert_iterator_unique()",
    "kind": "Method",
    "detail": "Function (} template<P> template<InputIterator,> void btree<P)",
    "insertText": "insert_iterator_unique(InputIterator b, InputIterator e, int)"
  },
  {
    "label": "insert_hint_unique()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert_hint_unique(end(), params_type::key(*b), *b)"
  },
  {
    "label": "node_handle_type()",
    "kind": "Method",
    "detail": "Function (auto node_handle = CommonAccess::Construct<)",
    "insertText": "node_handle_type(get_allocator(), *b)"
  },
  {
    "label": "GetSlot()",
    "kind": "Method",
    "detail": "Function (slot_type* slot =)",
    "insertText": "GetSlot(node_handle)"
  },
  {
    "label": "insert_hint_unique()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert_hint_unique(end(), params_type::key(slot), slot)"
  },
  {
    "label": "internal_upper_bound()",
    "kind": "Method",
    "detail": "Function (} iterator iter =)",
    "insertText": "internal_upper_bound(key)"
  },
  {
    "label": "internal_emplace()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "internal_emplace(iter, std::forward<ValueType>(v))"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (const key_type& key =)",
    "insertText": "key(v)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else { + + position ;)",
    "insertText": "if(position == end() || !compare_keys(position.key(), key))"
  },
  {
    "label": "insert_multi()",
    "kind": "Method",
    "detail": "Function (} } } return)",
    "insertText": "insert_multi(std::forward<ValueType>(v))"
  },
  {
    "label": "insert_hint_multi()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert_hint_multi(end(), *b)"
  },
  {
    "label": "mutable_key_comp()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "mutable_key_comp() = other.key_comp()"
  },
  {
    "label": "mutable_allocator()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "mutable_allocator() = other.allocator()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "if(absl::allocator_traits< allocator_type>::propagate_on_container_copy_assignment::value)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(root_, other.root_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(rightmost_, other.rightmost_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(size_, other.size_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(allocator() == other.allocator())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(mutable_root(), other.mutable_root())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(*mutable_key_comp(), *other.mutable_key_comp())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(mutable_rightmost(), other.mutable_rightmost())"
  },
  {
    "label": "value_destroy()",
    "kind": "Method",
    "detail": "Function (iter . node_ ->)",
    "insertText": "value_destroy(static_cast<field_type>(iter.position_), mutable_allocator())"
  },
  {
    "label": "internal_iter()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "internal_iter(iter)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (- - iter ;)",
    "insertText": "assert(iter.node_->is_leaf())"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (internal_iter . node_ ->)",
    "insertText": "transfer(static_cast<size_type>(internal_iter.position_), static_cast<size_type>(iter.position_), iter.node_, mutable_allocator())"
  },
  {
    "label": "field_type()",
    "kind": "Method",
    "detail": "Function (} else { const field_type transfer_from = static_cast<)",
    "insertText": "field_type(iter.position_ + 1)"
  },
  {
    "label": "transfer_n()",
    "kind": "Method",
    "detail": "Function (iter . node_ ->)",
    "insertText": "transfer_n(num_to_transfer, static_cast<size_type>(iter.position_), transfer_from, iter.node_, mutable_allocator())"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (} iter . node_ ->)",
    "insertText": "set_finish(iter.node_->finish() - 1)"
  },
  {
    "label": "rebalance_after_delete()",
    "kind": "Method",
    "detail": "Function (- - size_ ; iterator res =)",
    "insertText": "rebalance_after_delete(iter)"
  },
  {
    "label": "rebalance_after_delete()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "rebalance_after_delete(iterator iter)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "res(iter)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool first_iteration = true ;)",
    "insertText": "for(;;)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} break ; })",
    "insertText": "if(iter.node_->count() >= kMinNodeValues)"
  },
  {
    "label": "try_merge_or_rebalance()",
    "kind": "Method",
    "detail": "Function (break ; } bool merged =)",
    "insertText": "try_merge_or_rebalance(&iter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (res = iter ; first_iteration = false ; })",
    "insertText": "if(!merged)"
  },
  {
    "label": "size_type()",
    "kind": "Method",
    "detail": "Function (size_type count = static_cast<)",
    "insertText": "size_type(end - begin)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(count >= 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(begin.node_ == end.node_)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(end.position_ > begin.position_)"
  },
  {
    "label": "remove_values()",
    "kind": "Method",
    "detail": "Function (begin . node_ ->)",
    "insertText": "remove_values(static_cast<field_type>(begin.position_), static_cast<field_type>(end.position_ - begin.position_), mutable_allocator())"
  },
  {
    "label": "rebalance_after_delete()",
    "kind": "Method",
    "detail": "Function (size_ - = count ; return { count,)",
    "insertText": "rebalance_after_delete(begin)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} const size_type target_size = size_ - count ;)",
    "insertText": "while(size_ > target_size)"
  },
  {
    "label": "size_type()",
    "kind": "Method",
    "detail": "Function (const size_type remaining_to_erase = size_ - target_size ; const size_type remaining_in_node = static_cast<)",
    "insertText": "size_type(begin.node_->finish() - begin.position_)"
  },
  {
    "label": "field_type()",
    "kind": "Method",
    "detail": "Function (const field_type to_erase = static_cast<)",
    "insertText": "field_type((std::min)(remaining_to_erase, remaining_in_node))"
  },
  {
    "label": "remove_values()",
    "kind": "Method",
    "detail": "Function (begin . node_ ->)",
    "insertText": "remove_values(static_cast<field_type>(begin.position_), to_erase, mutable_allocator())"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} else { begin =)",
    "insertText": "erase(begin)"
  },
  {
    "label": "clear_and_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear_and_delete(root(), mutable_allocator())"
  },
  {
    "label": "mutable_root()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "mutable_root() = mutable_rightmost() = EmptyNode()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "if(absl::allocator_traits< allocator_type>::propagate_on_container_swap::value)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "assert(allocator() == other.allocator())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(root() != nullptr)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(leftmost() != nullptr)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(rightmost() != nullptr)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(empty() || size() == internal_verify(root(), nullptr, nullptr))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(leftmost() == (++const_iterator(root(), -1)).node_)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(rightmost() == (--const_iterator(root(), root()->finish())).node_)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(leftmost()->is_leaf())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(rightmost()->is_leaf())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (node_type*& node = iter -> node_ ; int& insert_position = iter -> position_ ;)",
    "insertText": "assert(node->count() == node->max_count())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(kNodeSlots == node->max_count())"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (node_type* left = parent ->)",
    "insertText": "child(node->position() - 1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(left->max_count() == kNodeSlots)"
  },
  {
    "label": "to_move()",
    "kind": "Method",
    "detail": "Function (field_type)",
    "insertText": "to_move(kNodeSlots - left->count()) / (1 + (static_cast<field_type>(insert_position) < kNodeSlots))"
  },
  {
    "label": "to_move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "to_move(std::max)(field_type{1}, to_move)"
  },
  {
    "label": "rebalance_right_to_left()",
    "kind": "Method",
    "detail": "Function (left ->)",
    "insertText": "rebalance_right_to_left(to_move, node, mutable_allocator())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(node->max_count() - node->count() == to_move)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (insert_position = static_cast<)",
    "insertText": "int(static_cast<field_type>(insert_position) - to_move)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (node = left ; })",
    "insertText": "assert(node->count() < node->max_count())"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (node_type* right = parent ->)",
    "insertText": "child(node->position() + 1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(right->max_count() == kNodeSlots)"
  },
  {
    "label": "to_move()",
    "kind": "Method",
    "detail": "Function (field_type)",
    "insertText": "to_move(kNodeSlots - right->count()) / (1 + (insert_position > node->start()))"
  },
  {
    "label": "rebalance_left_to_right()",
    "kind": "Method",
    "detail": "Function (node ->)",
    "insertText": "rebalance_left_to_right(to_move, right, mutable_allocator())"
  },
  {
    "label": "parent_iter()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "parent_iter(node->parent(), node->position())"
  },
  {
    "label": "rebalance_or_split()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rebalance_or_split(&parent_iter)"
  },
  {
    "label": "new_internal_node()",
    "kind": "Method",
    "detail": "Function (} } else { parent =)",
    "insertText": "new_internal_node(parent)"
  },
  {
    "label": "set_generation()",
    "kind": "Method",
    "detail": "Function (parent ->)",
    "insertText": "set_generation(root()->generation())"
  },
  {
    "label": "init_child()",
    "kind": "Method",
    "detail": "Function (parent ->)",
    "insertText": "init_child(parent->start(), root())"
  },
  {
    "label": "mutable_root()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mutable_root()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(parent->start_child()->is_internal() || parent->start_child() == rightmost())"
  },
  {
    "label": "new_leaf_node()",
    "kind": "Method",
    "detail": "Function (split_node =)",
    "insertText": "new_leaf_node(parent)"
  },
  {
    "label": "split()",
    "kind": "Method",
    "detail": "Function (node ->)",
    "insertText": "split(insert_position, split_node, mutable_allocator())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(insert_position > node->finish())"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (left ->)",
    "insertText": "merge(right, mutable_allocator())"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (node_type* left = parent ->)",
    "insertText": "child(iter->node_->position() - 1)"
  },
  {
    "label": "merge_nodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "merge_nodes(left, iter->node_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (iter -> node_ = left ; return true ; } })",
    "insertText": "if(iter->node_->position() < parent->finish())"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (node_type* right = parent ->)",
    "insertText": "child(iter->node_->position() + 1)"
  },
  {
    "label": "merge_nodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "merge_nodes(iter->node_, right)"
  },
  {
    "label": "to_move()",
    "kind": "Method",
    "detail": "Function (field_type)",
    "insertText": "to_move(right->count() - iter->node_->count())"
  },
  {
    "label": "to_move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "to_move(std::min)(to_move, static_cast<field_type>(right->count() - 1))"
  },
  {
    "label": "rebalance_right_to_left()",
    "kind": "Method",
    "detail": "Function (iter -> node_ ->)",
    "insertText": "rebalance_right_to_left(to_move, right, mutable_allocator())"
  },
  {
    "label": "to_move()",
    "kind": "Method",
    "detail": "Function (field_type)",
    "insertText": "to_move(left->count() - iter->node_->count())"
  },
  {
    "label": "to_move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "to_move(std::min)(to_move, static_cast<field_type>(left->count() - 1))"
  },
  {
    "label": "rebalance_left_to_right()",
    "kind": "Method",
    "detail": "Function (left ->)",
    "insertText": "rebalance_left_to_right(to_move, iter->node_, mutable_allocator())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(size() == 0)"
  },
  {
    "label": "clear_and_delete()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "clear_and_delete(orig_root, mutable_allocator())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(iter.node_ != nullptr)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(iter.node_ == root())"
  },
  {
    "label": "new_leaf_root_node()",
    "kind": "Method",
    "detail": "Function (iter . node_ =)",
    "insertText": "new_leaf_root_node(static_cast<field_type>( (std::min)(static_cast<int>(kNodeSlots), 2 * max_count)))"
  },
  {
    "label": "transfer_n()",
    "kind": "Method",
    "detail": "Function (node_type* new_root = iter . node_ ; new_root ->)",
    "insertText": "transfer_n(old_root->count(), new_root->start(), old_root->start(), old_root, alloc)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (new_root ->)",
    "insertText": "set_finish(old_root->finish())"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (old_root ->)",
    "insertText": "set_finish(old_root->start())"
  },
  {
    "label": "set_generation()",
    "kind": "Method",
    "detail": "Function (new_root ->)",
    "insertText": "set_generation(old_root->generation())"
  },
  {
    "label": "clear_and_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear_and_delete(old_root, alloc)"
  },
  {
    "label": "mutable_root()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mutable_root() = mutable_rightmost()"
  },
  {
    "label": "rebalance_or_split()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "rebalance_or_split(&iter)"
  },
  {
    "label": "emplace_value()",
    "kind": "Method",
    "detail": "Function (} } iter . node_ ->)",
    "insertText": "emplace_value(static_cast<field_type>(iter.position_), alloc, std::forward<Args>(args)...)"
  },
  {
    "label": "iter()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "iter(const_cast<node_type *>(root()))"
  },
  {
    "label": "lower_bound()",
    "kind": "Method",
    "detail": "Function (SearchResult<size_type,is_key_compare_to::value> res = iter . node_ ->)",
    "insertText": "lower_bound(key, key_comp())"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (iter . position_ = static_cast<)",
    "insertText": "int(res.value)"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (break ; } iter . node_ = iter . node_ ->)",
    "insertText": "child(static_cast<field_type>(iter.position_))"
  },
  {
    "label": "internal_last()",
    "kind": "Method",
    "detail": "Function (ret . value =)",
    "insertText": "internal_last(ret.value)"
  },
  {
    "label": "IsEq()",
    "kind": "Method",
    "detail": "Function (break ; } seen_eq = seen_eq | | res .)",
    "insertText": "IsEq()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(res.IsEq())"
  },
  {
    "label": "internal_last()",
    "kind": "Method",
    "detail": "Function (iter,MatchKind::kEq } ; return {)",
    "insertText": "internal_last(iter)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (iter . position_ = static_cast<)",
    "insertText": "int(iter.node_->upper_bound(key, key_comp()))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(node->count() > 0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(node->count() <= node->max_count())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!compare_keys(node->key(node->start()), *lo))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(hi)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!compare_keys(*hi, node->key(node->finish() - 1)))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int i = node->start() + 1; i < node->finish(); ++i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!compare_keys(node->key(i), node->key(i - 1)))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(node->child(i) != nullptr)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(node->child(i)->parent() == node)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(node->child(i)->position() == i)"
  },
  {
    "label": "internal_verify()",
    "kind": "Method",
    "detail": "Function (count + =)",
    "insertText": "internal_verify(node->child(i), i == node->start() ? lo : &node->key(i - 1), i == node->finish() ? hi : &node->key(i))"
  },
  {
    "label": "erase_if()",
    "kind": "Method",
    "detail": "Function (typename BtreeContainer::size_type)",
    "insertText": "erase_if(BtreeContainer &container, Pred pred)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + it ; continue ; } auto* node = it . node_ ;)",
    "insertText": "if(node->is_internal())"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (it = container .)",
    "insertText": "erase(it)"
  },
  {
    "label": "value_destroy()",
    "kind": "Method",
    "detail": "Function (continue ; } int to_pos = it . position_ ; node ->)",
    "insertText": "value_destroy(it.position_, alloc)"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (} else { node ->)",
    "insertText": "transfer(node->slot(to_pos++), node->slot(it.position_), alloc)"
  },
  {
    "label": "set_finish()",
    "kind": "Method",
    "detail": "Function (tree . size_ - = num_deleted ; node ->)",
    "insertText": "set_finish(to_pos)"
  },
  {
    "label": "rebalance_after_delete()",
    "kind": "Method",
    "detail": "Function (it . position_ = to_pos ; it = tree .)",
    "insertText": "rebalance_after_delete(it)"
  }
]