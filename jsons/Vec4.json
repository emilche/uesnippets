[
  {
    "label": "Mat3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mat3"
  },
  {
    "label": "Vec4",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Vec4"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_VEC4_HAS_BEEN_INCLUDED # define OPENVDB_MATH_VEC4_HAS_BEEN_INCLUDED # include<openvdb / Exceptions . h> # include \" Math . h \" # include \" Tuple . h \" # include \" Vec3 . h \" # include<algorithm> # include<cmath> # include<type_traits> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { template<T> class Mat3 ; template<T> class Vec4 : public Tuple<4,T> { public : using value_type = T ; using ValueType = T ; # if OPENVDB_ABI_VERSION_NUMBER> = 8)",
    "insertText": "Vec4()"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "Vec4(T val)"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = this -> mm [ 1 ] = this -> mm [ 2 ] = this -> mm [ 3 ] = val ; })",
    "insertText": "Vec4(T x, T y, T z, T w)"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = x ; this -> mm [ 1 ] = y ; this -> mm [ 2 ] = z ; this -> mm [ 3 ] = w ; } template<Source>)",
    "insertText": "Vec4(Source *a)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = static_cast<)",
    "insertText": "T(a[0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] = static_cast<)",
    "insertText": "T(a[1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 2 ] = static_cast<)",
    "insertText": "T(a[2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 3 ] = static_cast<)",
    "insertText": "T(a[3])"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (} template<Source>)",
    "insertText": "Vec4(const Tuple<4, Source> &v)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = static_cast<)",
    "insertText": "T(v[0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] = static_cast<)",
    "insertText": "T(v[1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 2 ] = static_cast<)",
    "insertText": "T(v[2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 3 ] = static_cast<)",
    "insertText": "T(v[3])"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (} template<Other>)",
    "insertText": "Vec4(Other val, typename std::enable_if<std::is_arithmetic<Other>::value, Conversion>::type = Conversion{})"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = this -> mm [ 1 ] = this -> mm [ 2 ] = this -> mm [ 3 ] = static_cast<)",
    "insertText": "T(val)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "x()"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} const Vec4<T>&)",
    "insertText": "init(T x=0, T y=0, T z=0, T w=0)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = x ; this -> mm [ 1 ] = y ; this -> mm [ 2 ] = z ; this -> mm [ 3 ] = w ; return* this ; } const Vec4<T>&)",
    "insertText": "setZero()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = 0 ; this -> mm [ 1 ] = 0 ; this -> mm [ 2 ] = 0 ; this -> mm [ 3 ] = 0 ; return* this ; } template<Source> const Vec4<T>&)",
    "insertText": "operator(const Vec4<Source> &v)"
  },
  {
    "label": "eq()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v [ 0 ] ; this -> mm [ 1 ] = v [ 1 ] ; this -> mm [ 2 ] = v [ 2 ] ; this -> mm [ 3 ] = v [ 3 ] ; return* this ; } bool)",
    "insertText": "eq(const Vec4<T> &v, T eps = static_cast<T>(1.0e-8))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Vec4<T>)",
    "insertText": "operator()"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} template<T0,T1> const Vec4<T>&)",
    "insertText": "add(const Vec4<T0> &v1, const Vec4<T1> &v2)"
  },
  {
    "label": "sub()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v1 [ 0 ] + v2 [ 0 ] ; this -> mm [ 1 ] = v1 [ 1 ] + v2 [ 1 ] ; this -> mm [ 2 ] = v1 [ 2 ] + v2 [ 2 ] ; this -> mm [ 3 ] = v1 [ 3 ] + v2 [ 3 ] ; return* this ; } template<T0,T1> const Vec4<T>&)",
    "insertText": "sub(const Vec4<T0> &v1, const Vec4<T1> &v2)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v1 [ 0 ] - v2 [ 0 ] ; this -> mm [ 1 ] = v1 [ 1 ] - v2 [ 1 ] ; this -> mm [ 2 ] = v1 [ 2 ] - v2 [ 2 ] ; this -> mm [ 3 ] = v1 [ 3 ] - v2 [ 3 ] ; return* this ; } template<T0,T1> const Vec4<T>&)",
    "insertText": "scale(T0 scale, const Vec4<T1> &v)"
  },
  {
    "label": "div()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = scale* v [ 0 ] ; this -> mm [ 1 ] = scale* v [ 1 ] ; this -> mm [ 2 ] = scale* v [ 2 ] ; this -> mm [ 3 ] = scale* v [ 3 ] ; return* this ; } template<T0,T1> const Vec4<T>&)",
    "insertText": "div(T0 scalar, const Vec4<T1> &v)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v [ 0 ] / scalar ; this -> mm [ 1 ] = v [ 1 ] / scalar ; this -> mm [ 2 ] = v [ 2 ] / scalar ; this -> mm [ 3 ] = v [ 3 ] / scalar ; return* this ; } T)",
    "insertText": "dot(const Vec4<T> &v)"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "length()"
  },
  {
    "label": "lengthSqr()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "lengthSqr()"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (} const Vec4<T>&)",
    "insertText": "exp()"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] =)",
    "insertText": "exp(this->mm[0])"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] =)",
    "insertText": "exp(this->mm[1])"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 2 ] =)",
    "insertText": "exp(this->mm[2])"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 3 ] =)",
    "insertText": "exp(this->mm[3])"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] =)",
    "insertText": "log(this->mm[0])"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] =)",
    "insertText": "log(this->mm[1])"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 2 ] =)",
    "insertText": "log(this->mm[2])"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 3 ] =)",
    "insertText": "log(this->mm[3])"
  },
  {
    "label": "unit()",
    "kind": "Method",
    "detail": "Function (T d ; return)",
    "insertText": "unit(eps, d)"
  },
  {
    "label": "unit()",
    "kind": "Method",
    "detail": "Function (} Vec4<T>)",
    "insertText": "unit(T eps, T& len)"
  },
  {
    "label": "ArithmeticError()",
    "kind": "Method",
    "detail": "Function (throw)",
    "insertText": "ArithmeticError(\"Normalizing null 4-vector\")"
  },
  {
    "label": "unitSafe()",
    "kind": "Method",
    "detail": "Function (} return* this / len ; } Vec4<T>)",
    "insertText": "unitSafe()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<S> const Vec4<T>&)",
    "insertText": "operator(S scalar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ]* = scalar ; this -> mm [ 1 ]* = scalar ; this -> mm [ 2 ]* = scalar ; this -> mm [ 3 ]* = scalar ; return* this ; } template<S> const Vec4<T>&)",
    "insertText": "operator(const Vec4<S> &v1)"
  },
  {
    "label": "numRows()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] - = v1 [ 0 ] ; this -> mm [ 1 ] - = v1 [ 1 ] ; this -> mm [ 2 ] - = v1 [ 2 ] ; this -> mm [ 3 ] - = v1 [ 3 ] ; return* this ; } unsigned)",
    "insertText": "numRows()"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (} Vec4<T>)",
    "insertText": "origin()"
  },
  {
    "label": "ones()",
    "kind": "Method",
    "detail": "Function (} Vec4<T>)",
    "insertText": "ones()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<T0,T1> bool)",
    "insertText": "operator(const Vec4<T0> &v0, const Vec4<T1> &v1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<S,T> Vec4<promote<S,T>::type>)",
    "insertText": "operator(S scalar, const Vec4<T> &v)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec4<promote<S,T>::type>)",
    "insertText": "result(v)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec4<promote<T0,T1>::type>)",
    "insertText": "result(v0[0]*v1[0], v0[1]*v1[1], v0[2]*v1[2], v0[3]*v1[3])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<S,T> Vec4<promote<S,T>::type>)",
    "insertText": "operator(const Vec4<T> &v, S scalar)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec4<promote<T0,T1>::type>)",
    "insertText": "result(v0[0]/v1[0], v0[1]/v1[1], v0[2]/v1[2], v0[3]/v1[3])"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec4<promote<T0,T1>::type>)",
    "insertText": "result(v0)"
  },
  {
    "label": "isApproxEqual()",
    "kind": "Method",
    "detail": "Function (result - = scalar ; return result ; } template<T> bool)",
    "insertText": "isApproxEqual(const Vec4<T>& a, const Vec4<T>& b)"
  },
  {
    "label": "isApproxEqual()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "isApproxEqual(const Vec4<T>& a, const Vec4<T>& b, const Vec4<T>& eps)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec4<T>)",
    "insertText": "Abs(const Vec4<T>& v)"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec4<T>)",
    "insertText": "minComponent(const Vec4<T> &v1, const Vec4<T> &v2)"
  },
  {
    "label": "maxComponent()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec4<T>)",
    "insertText": "maxComponent(const Vec4<T> &v1, const Vec4<T> &v2)"
  },
  {
    "label": "Exp()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec4<T>)",
    "insertText": "Exp(Vec4<T> v)"
  },
  {
    "label": "Log()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec4<T>)",
    "insertText": "Log(Vec4<T> v)"
  }
]