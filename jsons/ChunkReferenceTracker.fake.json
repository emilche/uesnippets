[
  {
    "label": "FFakeChunkReferenceTracker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFakeChunkReferenceTracker"
  },
  {
    "label": "GetReferencedChunks()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Installer / ChunkReferenceTracker . h \" # include \" Templates / Greater . h \" # include \" Algo / Sort . h \" # if WITH_DEV_AUTOMATION_TESTS namespace BuildPatchServices { class FFakeChunkReferenceTracker : public IChunkReferenceTracker { public : TSet<FGuid>)",
    "insertText": "GetReferencedChunks()"
  },
  {
    "label": "SortByUseOrder()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SortByUseOrder(TArray<FGuid>& ChunkList, ESortDirection Direction)"
  },
  {
    "label": "SortBy()",
    "kind": "Method",
    "detail": "Function (break ; case ESortDirection::Descending :)",
    "insertText": "SortBy(ChunkList, [this](const FGuid& Element) { return NextReferences.IndexOfByKey(Element); }, TGreater<int32>())"
  },
  {
    "label": "GetNextReferences()",
    "kind": "Method",
    "detail": "Function (break ; } } TArray<FGuid>)",
    "insertText": "GetNextReferences(int32 Count, const TFunction<bool(const FGuid&)>& SelectPredicate)"
  },
  {
    "label": "SelectFromNextReferences()",
    "kind": "Method",
    "detail": "Function (} TArray<FGuid>)",
    "insertText": "SelectFromNextReferences(int32 Count, const TFunction<bool(const FGuid&)>& SelectPredicate)"
  },
  {
    "label": "PopReference()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "PopReference(const FGuid& ChunkId)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (NextReferences .)",
    "insertText": "RemoveAt(0)"
  },
  {
    "label": "CopyOutOrderedUseList()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "CopyOutOrderedUseList(TArray<FGuid>& OutUseList)"
  }
]