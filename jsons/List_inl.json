[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "CListComparator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CListComparator"
  },
  {
    "label": "CList()",
    "kind": "Method",
    "detail": "Function (template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator)",
    "insertText": "CList(void) : m_pStart(NULL), m_pEnd(NULL), m_uiSize(0)"
  },
  {
    "label": "CList()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator)",
    "insertText": "CList(const CList& cRight) : m_pStart(NULL), m_pEnd(NULL), m_uiSize(0)"
  },
  {
    "label": "CList()",
    "kind": "Method",
    "detail": "Function (* this = cRight ; } template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator>::~)",
    "insertText": "CList(void)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> void CList<T,bUseCustomAllocator)",
    "insertText": "clear(void)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (CNode* pCurrent = m_pStart ;)",
    "insertText": "while(pCurrent != NULL)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (CNode* pToDelete = pCurrent ; pCurrent = pCurrent -> m_pNext ;)",
    "insertText": "Deallocate(pToDelete)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} m_pStart = m_pEnd = NULL ; m_uiSize = 0 ; } template<class T,bool bUseCustomAllocator> bool CList<T,bUseCustomAllocator)",
    "insertText": "empty(void)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (m_pStart =)",
    "insertText": "Allocate(tData, NULL, NULL)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (m_pEnd = m_pStart ; } else { m_pEnd -> m_pNext =)",
    "insertText": "Allocate(tData, NULL, m_pEnd)"
  },
  {
    "label": "push_front()",
    "kind": "Method",
    "detail": "Function (m_pEnd = m_pEnd -> m_pNext ; } + + m_uiSize ; } template<class T,bool bUseCustomAllocator> void CList<T,bUseCustomAllocator)",
    "insertText": "push_front(const T& tData)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (m_pEnd = m_pStart ; } else { m_pStart =)",
    "insertText": "Allocate(tData, m_pStart, NULL)"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (m_pStart -> m_pNext -> m_pPrevious = m_pStart ; } + + m_uiSize ; } template<class T,bool bUseCustomAllocator> void CList<T,bUseCustomAllocator)",
    "insertText": "pop_back(void)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_pEnd != NULL)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deallocate(m_pEnd)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (m_pStart = m_pEnd = NULL ; } else { m_pEnd = m_pEnd -> m_pPrevious ;)",
    "insertText": "Deallocate(m_pEnd->m_pNext)"
  },
  {
    "label": "pop_front()",
    "kind": "Method",
    "detail": "Function (m_pEnd -> m_pNext = NULL ; } - - m_uiSize ; } template<class T,bool bUseCustomAllocator> void CList<T,bUseCustomAllocator)",
    "insertText": "pop_front(void)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_pStart != NULL)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deallocate(m_pStart)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (m_pStart = m_pEnd = NULL ; } else { m_pStart = m_pStart -> m_pNext ;)",
    "insertText": "Deallocate(m_pStart->m_pPrevious)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (m_pStart -> m_pPrevious = NULL ; } - - m_uiSize ; } template<class T,bool bUseCustomAllocator> T& CList<T,bUseCustomAllocator)",
    "insertText": "front(void)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (CNode* pCurrent = m_pStart ;)",
    "insertText": "for(const_iterator iter = cRight.begin( ); iter != cRight.end( ); ++iter)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator>::iterator CList<T,bUseCustomAllocator)",
    "insertText": "begin(void)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator>::iterator CList<T,bUseCustomAllocator)",
    "insertText": "end(void)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator>::iterator CList<T,bUseCustomAllocator)",
    "insertText": "erase(iterator iterWhere)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# ifdef SPEEDTREE_ITERATOR_DEBUGGING)",
    "insertText": "assert(iterWhere.m_pNode != NULL)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (m_pPrevious)",
    "insertText": "while(pRoot->m_pPrevious != NULL)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(pRoot == m_pStart)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_pPrevious->m_pNext = iterWhere.m_pNode->m_pNext)",
    "insertText": "if(iterWhere.m_pNode->m_pPrevious != NULL)"
  },
  {
    "label": "iterReturn()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "iterReturn(iterWhere.m_pNode->m_pNext)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deallocate(iterWhere.m_pNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef SPEEDTREE_ITERATOR_DEBUGGING)",
    "insertText": "if(iterWhere.m_pNode != NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "if(m_pStart == NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(iterWhere.m_pNode == NULL)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (} CNode* pNewNode =)",
    "insertText": "Allocate(tData, iterWhere.m_pNode, iterWhere.m_pNode->m_pPrevious)"
  },
  {
    "label": "CNode()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator>::)",
    "insertText": "CNode(const T& tData, CNode* pNext, CNode* pPrevious) : m_tData(tData), m_pNext(pNext), m_pPrevious(pPrevious)"
  },
  {
    "label": "iterator_base()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator>::)",
    "insertText": "iterator_base(CNode* pNode) : m_pNode(pNode)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator>::iterator::operator)",
    "insertText": "T(void)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(iterator_base::m_pNode != NULL)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_pNode != NULL)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (m_pNode = m_pNode -> m_pNext ;)",
    "insertText": "return(this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator>::iterator_base& CList<T,bUseCustomAllocator>::)",
    "insertText": "operator(void)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> bool CList<T,bUseCustomAllocator>::)",
    "insertText": "operator(const iterator_base& cRight)"
  },
  {
    "label": "insert_sorted()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator>::iterator CList<T,bUseCustomAllocator)",
    "insertText": "insert_sorted(const T& tData)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (m_pNext)",
    "insertText": "while(pCurrent != NULL && pCurrent->m_tData < tData)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} class CListComparator { public : template<class T> bool)",
    "insertText": "operator() (const T& pOne, const T& pTwo)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T,bool bUseCustomAllocator> void CList<T,bUseCustomAllocator)",
    "insertText": "sort(void)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (CArray<CNode*,bUseCustomAllocator> aIndirect ; aIndirect .)",
    "insertText": "reserve(m_uiSize)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (aIndirect .)",
    "insertText": "push_back(pCurrent)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (pCurrent = pCurrent -> m_pNext ; } aIndirect .)",
    "insertText": "sort(CListComparator( ))"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (aIndirect [ i ] -> m_pPrevious = aIndirect [ i - 1 ] ; aIndirect [ i ] -> m_pNext = aIndirect [ i + 1 ] ; } m_pStart = aIndirect .)",
    "insertText": "front()"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (m_pStart -> m_pPrevious = NULL ; m_pStart -> m_pNext = aIndirect [ 1 ] ; m_pEnd = aIndirect .)",
    "insertText": "back()"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (m_pEnd -> m_pNext = NULL ; m_pEnd -> m_pPrevious = aIndirect [ m_uiSize - 2 ] ; } template<class T,bool bUseCustomAllocator> CList<T,bUseCustomAllocator>::CNode* CList<T,bUseCustomAllocator)",
    "insertText": "Allocate(const T& tData, CNode* pNext, CNode* pPrevious)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> void CList<T,bUseCustomAllocator)",
    "insertText": "Deallocate(CNode* pData)"
  },
  {
    "label": "CNode()",
    "kind": "Method",
    "detail": "Function (# ifndef SPEEDTREE_NO_ALLOCATORS bUseCustomAllocator ? st_delete<)",
    "insertText": "CNode(pData)"
  }
]