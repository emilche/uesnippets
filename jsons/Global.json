[
  {
    "label": "IMalloc",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IMalloc"
  },
  {
    "label": "DxcThreadMalloc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DxcThreadMalloc"
  },
  {
    "label": "DXC_FAILED()",
    "kind": "Method",
    "detail": "Function (# pragma once # ifdef _WIN32 # define)",
    "insertText": "DXC_FAILED(hr) (((HRESULT)(hr)) < 0)"
  },
  {
    "label": "_Return_type_success_()",
    "kind": "Method",
    "detail": "Function (# else typedef)",
    "insertText": "_Return_type_success_(return >= 0)"
  },
  {
    "label": "DxcInitThreadMalloc()",
    "kind": "Method",
    "detail": "Function (# endif # endif # endif # include \" dxc / Support / exception . h \" # include \" dxc / WinAdapter . h \" # include<stdarg . h> # include<system_error> struct IMalloc ; HRESULT)",
    "insertText": "DxcInitThreadMalloc() throw()"
  },
  {
    "label": "DxcCleanupThreadMalloc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DxcCleanupThreadMalloc() throw()"
  },
  {
    "label": "DxcSetThreadMallocToDefault()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DxcSetThreadMallocToDefault() throw()"
  },
  {
    "label": "DxcClearThreadMalloc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DxcClearThreadMalloc() throw()"
  },
  {
    "label": "DxcGetThreadMallocNoRef()",
    "kind": "Method",
    "detail": "Function (IMalloc*)",
    "insertText": "DxcGetThreadMallocNoRef() throw()"
  },
  {
    "label": "DxcNew()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "DxcNew(std::size_t size) throw()"
  },
  {
    "label": "DxcDelete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DxcDelete(void *ptr) throw()"
  },
  {
    "label": "DxcThreadMalloc()",
    "kind": "Method",
    "detail": "Function (class DxcThreadMalloc { public :)",
    "insertText": "DxcThreadMalloc(IMalloc *pMallocOrNull) throw()"
  },
  {
    "label": "DxcThreadMalloc()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "DxcThreadMalloc()"
  },
  {
    "label": "GetInstalledAllocator()",
    "kind": "Method",
    "detail": "Function (IMalloc*)",
    "insertText": "GetInstalledAllocator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (DxcThreadMalloc&)",
    "insertText": "operator(const DxcThreadMalloc &)"
  },
  {
    "label": "DxcThreadMalloc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DxcThreadMalloc(DxcThreadMalloc &&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (DxcThreadMalloc&)",
    "insertText": "operator(DxcThreadMalloc &&)"
  },
  {
    "label": "CheckLLVMErrorCode()",
    "kind": "Method",
    "detail": "Function (IMalloc* p ; IMalloc* pPrior ; } ; void)",
    "insertText": "CheckLLVMErrorCode(const std::error_code &ec)"
  },
  {
    "label": "SAFE_RELEASE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "SAFE_RELEASE(p)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(p)"
  },
  {
    "label": "SAFE_ADDREF()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # define)",
    "insertText": "SAFE_ADDREF(p)"
  },
  {
    "label": "SAFE_DELETE_ARRAY()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # define)",
    "insertText": "SAFE_DELETE_ARRAY(p)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "delete(p)"
  },
  {
    "label": "SAFE_DELETE()",
    "kind": "Method",
    "detail": "Function (\\ p = nullptr ; \\ } # define)",
    "insertText": "SAFE_DELETE(p)"
  },
  {
    "label": "IFC()",
    "kind": "Method",
    "detail": "Function (\\ p = nullptr ; \\ } # define)",
    "insertText": "IFC(x)"
  },
  {
    "label": "hr()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "hr(x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(DXC_FAILED(hr))"
  },
  {
    "label": "IFR()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "IFR(x)"
  },
  {
    "label": "__hr()",
    "kind": "Method",
    "detail": "Function (\\ HRESULT)",
    "insertText": "__hr(x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(DXC_FAILED(__hr))"
  },
  {
    "label": "IFRBOOL()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "IFRBOOL(x, y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(!(x)) \\ return (y)"
  },
  {
    "label": "IFCBOOL()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "IFCBOOL(x, y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(!(x))"
  },
  {
    "label": "hr()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "hr(y)"
  },
  {
    "label": "IFCOOM()",
    "kind": "Method",
    "detail": "Function (\\ goto Cleanup ; \\ } \\ } # define)",
    "insertText": "IFCOOM(x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(nullptr == (x))"
  },
  {
    "label": "IFROOM()",
    "kind": "Method",
    "detail": "Function (\\ hr = E_OUTOFMEMORY ; \\ goto Cleanup ; \\ } \\ } # define)",
    "insertText": "IFROOM(x)"
  },
  {
    "label": "IFCPTR()",
    "kind": "Method",
    "detail": "Function (\\ return E_OUTOFMEMORY ; \\ } \\ } # define)",
    "insertText": "IFCPTR(x)"
  },
  {
    "label": "IFT()",
    "kind": "Method",
    "detail": "Function (\\ hr = E_POINTER ; \\ goto Cleanup ; \\ } \\ } # define)",
    "insertText": "IFT(x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(DXC_FAILED(__hr)) \\ throw ::hlsl::Exception(__hr)"
  },
  {
    "label": "IFTBOOL()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "IFTBOOL(x, y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(!(x)) \\ throw ::hlsl::Exception(y)"
  },
  {
    "label": "IFTOOM()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "IFTOOM(x)"
  },
  {
    "label": "Exception()",
    "kind": "Method",
    "detail": "Function (\\ throw::)",
    "insertText": "Exception(E_OUTOFMEMORY)"
  },
  {
    "label": "IFTPTR()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # define)",
    "insertText": "IFTPTR(x)"
  },
  {
    "label": "Exception()",
    "kind": "Method",
    "detail": "Function (\\ throw::)",
    "insertText": "Exception(E_POINTER)"
  },
  {
    "label": "IFTARG()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # define)",
    "insertText": "IFTARG(x)"
  },
  {
    "label": "Exception()",
    "kind": "Method",
    "detail": "Function (\\ throw::)",
    "insertText": "Exception(E_INVALIDARG)"
  },
  {
    "label": "IFTLLVM()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # define)",
    "insertText": "IFTLLVM(x)"
  },
  {
    "label": "IFTMSG()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "IFTMSG(x, msg)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(DXC_FAILED(__hr)) \\ throw ::hlsl::Exception(__hr, msg)"
  },
  {
    "label": "IFTBOOLMSG()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "IFTBOOLMSG(x, y, msg)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(!(x)) \\ throw ::hlsl::Exception(y, msg)"
  },
  {
    "label": "CATCH_CPP_ASSIGN_HRESULT()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "CATCH_CPP_ASSIGN_HRESULT() \\ catch (std::bad_alloc &)"
  },
  {
    "label": "catch()",
    "kind": "Method",
    "detail": "Function (\\ hr = E_OUTOFMEMORY ; \\ } \\)",
    "insertText": "catch(hlsl::Exception & _hlsl_exception_)"
  },
  {
    "label": "catch()",
    "kind": "Method",
    "detail": "Function (\\ hr = _hlsl_exception_ . hr ; \\ } \\)",
    "insertText": "catch(...)"
  },
  {
    "label": "CATCH_CPP_RETURN_HRESULT()",
    "kind": "Method",
    "detail": "Function (\\ hr = E_FAIL ; \\ } # define)",
    "insertText": "CATCH_CPP_RETURN_HRESULT() \\ catch (std::bad_alloc &)"
  },
  {
    "label": "VerifyNullAndThrow()",
    "kind": "Method",
    "detail": "Function (\\ return E_FAIL ; \\ } template<T> T*)",
    "insertText": "VerifyNullAndThrow(T *p)"
  },
  {
    "label": "OutputDebugBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutputDebugBytes(const void *ptr, size_t len)"
  },
  {
    "label": "pBytes()",
    "kind": "Method",
    "detail": "Function (const char digits [ ] = \" 0 1 2 3 4 5 6 7 8 9 abcdef \" ; const unsigned char*)",
    "insertText": "pBytes(const unsigned char *)"
  },
  {
    "label": "_countof()",
    "kind": "Method",
    "detail": "Function (const int bytesPerLine = 1 6 ; char buffer [ bytesPerLine* 3 + 2 + 1 ] ; buffer [)",
    "insertText": "_countof(buffer)"
  },
  {
    "label": "digits()",
    "kind": "Method",
    "detail": "Function (* pWrite + + =)",
    "insertText": "digits(*pBytes & 0xF0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* pWrite + + = digits [* pBytes& 0 x0f ] ;* pWrite + + = ' ' ;)",
    "insertText": "if(pWrite == pEnd)"
  },
  {
    "label": "OutputDebugStringA()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutputDebugStringA(buffer)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pWrite = buffer ; } - - len ; + + pBytes ; })",
    "insertText": "if(pWrite != buffer)"
  },
  {
    "label": "OutputDebugStringA()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutputDebugStringA(\"\\r\\n\")"
  },
  {
    "label": "OutputDebugFormatA()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "OutputDebugFormatA(const char *pszFormat, ...)"
  },
  {
    "label": "va_start()",
    "kind": "Method",
    "detail": "Function (char buffer [ 1 0 2 4 ] ; va_list argList ;)",
    "insertText": "va_start(argList, pszFormat)"
  },
  {
    "label": "vsnprintf_s()",
    "kind": "Method",
    "detail": "Function (int count =)",
    "insertText": "vsnprintf_s(buffer, _countof(buffer), pszFormat, argList)"
  },
  {
    "label": "va_end()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "va_end(argList)"
  },
  {
    "label": "OutputDebugStringA()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutputDebugStringA(\"...\\n\")"
  },
  {
    "label": "DXASSERT_ARGS()",
    "kind": "Method",
    "detail": "Function (} } # endif # ifndef NDEBUG # ifdef _WIN32 # define)",
    "insertText": "DXASSERT_ARGS(exp, fmt, ...)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(!(exp))"
  },
  {
    "label": "OutputDebugFormatA()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "OutputDebugFormatA(\\ \"Error: \\t%s\\nFile:\\n%s(%d)\\nFunc:\\t%s.\\n\\t\" fmt \"\\n\", \\ \"!(\" #exp \")\", __FILE__, __LINE__, __FUNCTION__, __VA_ARGS__)"
  },
  {
    "label": "__debugbreak()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "__debugbreak()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ } \\ })",
    "insertText": "while(0) #define DXASSERT(exp, msg) DXASSERT_ARGS(exp, msg) #define DXASSERT_LOCALVAR(local, exp, msg) DXASSERT(exp, msg) #define DXASSERT_LOCALVAR_NOMSG(local, exp) DXASSERT_LOCALVAR(local, exp, \"\") #define DXASSERT_NOMSG(exp) DXASSERT(exp, \"\") #define DXVERIFY_NOMSG(exp) DXASSERT(exp, \"\") #else #include <cassert> #define DXASSERT_NOMSG assert #define DXASSERT_LOCALVAR(local, exp, msg) DXASSERT(exp, msg) #define DXASSERT_LOCALVAR_NOMSG(local, exp) DXASSERT_LOCALVAR(local, exp, \"\") #define DXVERIFY_NOMSG assert #define DXASSERT_ARGS(expr, fmt, ...)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(!(expr))"
  },
  {
    "label": "fprintf()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "fprintf(stderr, fmt, __VA_ARGS__)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "assert(false)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ } \\ })",
    "insertText": "while(0) #define DXASSERT(expr, msg)"
  },
  {
    "label": "fprintf()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "fprintf(stderr, msg)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "assert(false && msg)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ } \\ })",
    "insertText": "while(0) #endif #else #define DXASSERT_ARGS(exp, s, ...)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(0) #define DXASSERT(exp, msg)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(0) #define DXASSERT_LOCALVAR(local, exp, msg)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(0) #define DXASSERT_LOCALVAR_NOMSG(local, exp) DXASSERT_LOCALVAR(local, exp, \"\") #define DXASSERT_NOMSG(exp)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(0) #define DXVERIFY_NOMSG(exp)"
  }
]