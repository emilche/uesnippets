[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TSegment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSegment"
  },
  {
    "label": "TSegment()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" namespace Chaos { template<class T> class TSegment { public :)",
    "insertText": "TSegment()"
  },
  {
    "label": "TSegment()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSegment(const TVec3<T>& X1, const TVec3<T>& X2) : MPoint(X1) , MAxis(X2 - X1) , MLength(MAxis.SafeNormalize())"
  },
  {
    "label": "TSegment()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSegment(const TVec3<T>& X1, const TVec3<T>& Axis, const T Length) : MPoint(X1) , MAxis(Axis) , MLength(Length)"
  },
  {
    "label": "IsConvex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsConvex()"
  },
  {
    "label": "GetX1()",
    "kind": "Method",
    "detail": "Function (} const TVec3<T>&)",
    "insertText": "GetX1()"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const T Dot = TVec3<T)",
    "insertText": "DotProduct(Direction, MAxis)"
  },
  {
    "label": "GetX2()",
    "kind": "Method",
    "detail": "Function (const bool bIsSecond = Dot> = 0 ; const TVec3<T> FarthestCap = bIsSecond ?)",
    "insertText": "GetX2() : GetX1()"
  },
  {
    "label": "SizeSquared()",
    "kind": "Method",
    "detail": "Function (VertexIndex = bIsSecond ? 1 : 0 ; T SizeSqr = Direction .)",
    "insertText": "SizeSquared()"
  },
  {
    "label": "SupportCore()",
    "kind": "Method",
    "detail": "Function (} TVec3<T>)",
    "insertText": "SupportCore(const TVec3<T>& Direction, int32& VertexIndex)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (VertexIndex = bIsSecond ? 1 : 0 ; return FarthestCap ; } void)",
    "insertText": "Serialize(FArchive &Ar)"
  },
  {
    "label": "LengthFloat()",
    "kind": "Method",
    "detail": "Function (Ar<<MPoint<<MAxis ; FRealSingle)",
    "insertText": "LengthFloat(FRealSingle)"
  },
  {
    "label": "MLength()",
    "kind": "Method",
    "detail": "Function (Ar<<LengthFloat ;)",
    "insertText": "MLength(T)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ToString()"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (} TAABB<T,3>)",
    "insertText": "BoundingBox()"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (TAABB<T,3>)",
    "insertText": "Box(MPoint,MPoint)"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (Box .)",
    "insertText": "GrowToInclude(GetX2())"
  }
]