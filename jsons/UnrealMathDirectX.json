[
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# pragma once # if defined __cplusplus_cli&& ! PLATFORM_HOLOLENS # include \" Math / UnrealMathFPU . h \" # else # pragma)",
    "insertText": "warning(push ) #pragma warning ( disable : 4668 ) #include <DirectXMath.h> #pragma warning( pop)"
  },
  {
    "label": "DECLARE_VECTOR_REGISTER()",
    "kind": "Method",
    "detail": "Function (typedef __m128i VectorRegister4Int ; # define)",
    "insertText": "DECLARE_VECTOR_REGISTER(X, Y, Z, W)"
  },
  {
    "label": "MakeVectorRegister()",
    "kind": "Method",
    "detail": "Function (X,Y,Z,W } VectorRegister)",
    "insertText": "MakeVectorRegister(uint32 X, uint32 Y, uint32 Z, uint32 W)"
  },
  {
    "label": "XMVectorSetInt()",
    "kind": "Method",
    "detail": "Function (using namespace DirectX ; return)",
    "insertText": "XMVectorSetInt(X, Y, Z, W)"
  },
  {
    "label": "MakeVectorRegister()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "MakeVectorRegister(float X, float Y, float Z, float W)"
  },
  {
    "label": "MakeVectorRegisterInt()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Int)",
    "insertText": "MakeVectorRegisterInt(int32 X, int32 Y, int32 Z, int32 W)"
  },
  {
    "label": "MakeVectorRegisterIntConstant()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Int)",
    "insertText": "MakeVectorRegisterIntConstant(int32 X, int32 Y, int32 Z, int32 W)"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "MakeVectorRegisterFloatConstant(float X, float Y, float Z, float W)"
  },
  {
    "label": "_mm_castpd_ps()",
    "kind": "Method",
    "detail": "Function (__m128 Ret =)",
    "insertText": "_mm_castpd_ps(_mm_load_sd((double const*)(Ptr1)))"
  },
  {
    "label": "_mm_loadh_pi()",
    "kind": "Method",
    "detail": "Function (Ret =)",
    "insertText": "_mm_loadh_pi(Ret, (__m64 const*)(Ptr2))"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (} return 0 . 0 f ; } # define)",
    "insertText": "VectorReplicate(Vec, ElementIndex ) DirectX::XMVectorSwizzle<ElementIndex,ElementIndex,ElementIndex,ElementIndex>(Vec) #define VectorAbs( Vec ) DirectX::XMVectorAbs( Vec ) #define VectorNegate( Vec ) DirectX::XMVectorNegate( Vec ) #define VectorAdd( Vec1, Vec2 ) DirectX::XMVectorAdd( Vec1, Vec2 ) #define VectorSubtract( Vec1, Vec2 ) DirectX::XMVectorSubtract( Vec1, Vec2 ) #define VectorMultiply( Vec1, Vec2 ) DirectX::XMVectorMultiply( Vec1, Vec2 ) #define VectorDivide( Vec1, Vec2 ) DirectX::XMVectorDivide( Vec1, Vec2 ) #define VectorMultiplyAdd( Vec1, Vec2, Vec3 ) DirectX::XMVectorMultiplyAdd( Vec1, Vec2, Vec3 ) #define VectorNegateMultiplyAdd(Vec1, Vec2, Vec3) DirectX::XMVectorNegativeMultiplySubtract( Vec1, Vec2, Vec3 ) #define VectorDot3( Vec1, Vec2 ) DirectX::XMVector3Dot( Vec1, Vec2 ) #define VectorDot4( Vec1, Vec2 ) DirectX::XMVector4Dot( Vec1, Vec2 ) #define VectorCompareEQ( Vec1, Vec2 ) DirectX::XMVectorEqual( Vec1, Vec2 ) #define VectorCompareNE( Vec1, Vec2 ) DirectX::XMVectorNotEqual( Vec1, Vec2 ) #define VectorCompareGT( Vec1, Vec2 ) DirectX::XMVectorGreater( Vec1, Vec2 ) #define VectorCompareGE( Vec1, Vec2 ) DirectX::XMVectorGreaterOrEqual( Vec1, Vec2 ) #define VectorCompareLT( Vec1, Vec2 ) _mm_cmplt_ps( Vec1, Vec2 ) #define VectorCompareLE( Vec1, Vec2 ) _mm_cmple_ps( Vec1, Vec2 ) #define VectorSelect( Mask, Vec1, Vec2 ) DirectX::XMVectorSelect( Vec2, Vec1, Mask ) #define VectorBitwiseOr( Vec1, Vec2 ) DirectX::XMVectorOrInt( Vec1, Vec2 ) #define VectorBitwiseAnd( Vec1, Vec2 ) DirectX::XMVectorAndInt( Vec1, Vec2 ) #define VectorBitwiseXor( Vec1, Vec2 ) DirectX::XMVectorXorInt( Vec1, Vec2 ) #define VectorMaskBits( VecMask ) _mm_movemask_ps( VecMask ) #define VectorCross( Vec1, Vec2 ) DirectX::XMVector3Cross( Vec1, Vec2 ) #define VectorPow( Vec1, Vec2 ) DirectX::XMVectorPow( Vec1, Vec2 ) #define VectorReciprocalSqrt( Vec ) DirectX::XMVectorReciprocalSqrtEst( Vec ) #define VectorReciprocal( Vec ) DirectX::XMVectorReciprocalEst( Vec ) #define VectorReciprocalLen( Vec ) DirectX::XMVector4ReciprocalLengthEst( Vec ) #define VectorReciprocalSqrtAccurate( Vec ) DirectX::XMVectorReciprocalSqrt( Vec ) #define VectorReciprocalAccurate( Vec ) DirectX::XMVectorReciprocal( Vec ) #define VectorNormalize( Vec ) DirectX::XMVector4NormalizeEst( Vec ) #define VectorSet_W0( Vec ) DirectX::XMVectorAndInt( Vec , DirectX::g_XMMask3 ) #define VectorSet_W1( Vec ) DirectX::XMVectorPermute<0,1,2,7>( Vec, VectorOne() ) FORCEINLINE void VectorMatrixMultiply( FMatrix* Result, const FMatrix* Matrix1, const FMatrix* Matrix2)"
  },
  {
    "label": "XMLoadFloat4x4A()",
    "kind": "Method",
    "detail": "Function (using namespace DirectX ; XMMATRIX XMatrix1 =)",
    "insertText": "XMLoadFloat4x4A((const XMFLOAT4X4A*)(Matrix1))"
  },
  {
    "label": "XMLoadFloat4x4A()",
    "kind": "Method",
    "detail": "Function (XMMATRIX XMatrix2 =)",
    "insertText": "XMLoadFloat4x4A((const XMFLOAT4X4A*)(Matrix2))"
  },
  {
    "label": "XMMatrixMultiply()",
    "kind": "Method",
    "detail": "Function (XMMATRIX XMatrixR =)",
    "insertText": "XMMatrixMultiply(XMatrix1, XMatrix2)"
  },
  {
    "label": "XMStoreFloat4x4A()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "XMStoreFloat4x4A((XMFLOAT4X4A*)(Result), XMatrixR)"
  },
  {
    "label": "VectorMatrixInverse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "VectorMatrixInverse(FMatrix* DstMatrix, const FMatrix* SrcMatrix)"
  },
  {
    "label": "XMLoadFloat4x4A()",
    "kind": "Method",
    "detail": "Function (using namespace DirectX ; XMMATRIX XMSrcMatrix =)",
    "insertText": "XMLoadFloat4x4A((const XMFLOAT4X4A*)(SrcMatrix))"
  },
  {
    "label": "XMMatrixInverse()",
    "kind": "Method",
    "detail": "Function (XMVECTOR XMDeterminant ; XMMATRIX XMDstMatrix =)",
    "insertText": "XMMatrixInverse(&XMDeterminant, XMSrcMatrix)"
  },
  {
    "label": "XMStoreFloat()",
    "kind": "Method",
    "detail": "Function (float Determinant ;)",
    "insertText": "XMStoreFloat(&Determinant,XMDeterminant)"
  },
  {
    "label": "XMStoreFloat4x4A()",
    "kind": "Method",
    "detail": "Function (* DstMatrix = FMatrix::Identity ; return false ; })",
    "insertText": "XMStoreFloat4x4A((XMFLOAT4X4A*)(DstMatrix), XMDstMatrix)"
  },
  {
    "label": "XMLoadFloat4x4A()",
    "kind": "Method",
    "detail": "Function (using namespace DirectX ; XMMATRIX M1 =)",
    "insertText": "XMLoadFloat4x4A((const XMFLOAT4X4A*)(MatrixM))"
  },
  {
    "label": "VectorMin()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorMin(Vec1, Vec2 ) DirectX::XMVectorMin( Vec1, Vec2 ) #define VectorMax( Vec1, Vec2 ) DirectX::XMVectorMax( Vec1, Vec2 ) #define VectorSwizzle( Vec, X, Y, Z, W ) DirectX::XMVectorSwizzle<X,Y,Z,W>( Vec ) #define VectorShuffle( Vec1, Vec2, X, Y, Z, W ) DirectX::XMVectorPermute<X,Y,Z+4,W+4>( Vec1, Vec2 ) FORCEINLINE VectorRegister VectorCombineHigh(const VectorRegister& Vec1, const VectorRegister& Vec2)"
  },
  {
    "label": "VectorCombineLow()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorCombineLow(const VectorRegister& Vec1, const VectorRegister& Vec2)"
  },
  {
    "label": "VectorDeinterleave()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorDeinterleave(VectorRegister& OutEvens, VectorRegister& OutOdds, const VectorRegister& Lo, const VectorRegister& Hi)"
  },
  {
    "label": "_mm_shuffle_ps()",
    "kind": "Method",
    "detail": "Function (OutEvens =)",
    "insertText": "_mm_shuffle_ps(Lo, Hi, _MM_SHUFFLE(2, 0, 2, 0))"
  },
  {
    "label": "_mm_shuffle_ps()",
    "kind": "Method",
    "detail": "Function (OutOdds =)",
    "insertText": "_mm_shuffle_ps(Lo, Hi, _MM_SHUFFLE(3, 1, 3, 1))"
  },
  {
    "label": "VectorMask_LT()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorMask_LT(Vec1, Vec2 ) _mm_cmplt_ps( Vec1, Vec2 ) #define VectorMask_LE( Vec1, Vec2 ) _mm_cmple_ps( Vec1, Vec2 ) #define VectorMask_GT( Vec1, Vec2 ) DirectX::XMVectorGreater( Vec1, Vec2 ) #define VectorMask_GE( Vec1, Vec2 ) DirectX::XMVectorGreaterOrEqual( Vec1, Vec2 ) #define VectorMask_EQ( Vec1, Vec2 ) DirectX::XMVectorEqual( Vec1, Vec2 ) #define VectorMask_NE( Vec1, Vec2 ) DirectX::XMVectorNotEqual( Vec1, Vec2 ) FORCEINLINE VectorRegister VectorMergeVecXYZ_VecW(const VectorRegister& VecXYZ, const VectorRegister& VecW)"
  },
  {
    "label": "XMVectorSelect()",
    "kind": "Method",
    "detail": "Function (using namespace DirectX ; return)",
    "insertText": "XMVectorSelect(VecXYZ, VecW, g_XMMaskW)"
  },
  {
    "label": "VectorLoadByte4()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorLoadByte4(Ptr ) DirectX::PackedVector::XMLoadUByte4((const DirectX::PackedVector::XMUBYTE4*)(Ptr) ) #define VectorLoadSignedByte4( Ptr ) DirectX::PackedVector::XMLoadByte4((const DirectX::PackedVector::XMBYTE4*)(Ptr) ) FORCEINLINE VectorRegister VectorLoadByte4Reverse( const uint8* Ptr)"
  },
  {
    "label": "VectorLoadByte4()",
    "kind": "Method",
    "detail": "Function (VectorRegister Temp =)",
    "insertText": "VectorLoadByte4(Ptr)"
  },
  {
    "label": "VectorStoreByte4()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorStoreByte4(Vec, Ptr ) DirectX::PackedVector::XMStoreUByte4( (DirectX::PackedVector::XMUBYTE4*)(Ptr), Vec ) #define VectorStoreSignedByte4( Vec, Ptr ) DirectX::PackedVector::XMStoreByte4( (DirectX::PackedVector::XMBYTE4*)(Ptr), Vec ) #define VectorLoadURGB10A2N( Ptr ) DirectX::PackedVector::XMLoadUDecN4( (const DirectX::PackedVector::XMUDECN4*)(Ptr) ) #define VectorStoreURGB10A2N( Vec, Ptr ) DirectX::PackedVector::XMStoreUDecN4( (const DirectX::PackedVector::XMUDECN4*)(Ptr), Vec ) #define VectorLoadURGBA16N( Ptr ) DirectX::PackedVector::XMLoadUShortN4( (const DirectX::PackedVector::XMUSHORTN4*)(Ptr) ) #define VectorLoadSRGBA16N( Ptr ) DirectX::PackedVector::XMLoadShortN4( (const DirectX::PackedVector::XMSHORTN4*)(Ptr) ) #define VectorStoreURGBA16N( Vec, Ptr ) DirectX::PackedVector::XMStoreUShortN4( (const DirectX::PackedVector::XMUSHORTN4*)(Ptr), Vec ) FORCEINLINE uint32 VectorAnyGreaterThan(const VectorRegister& Vec1, const VectorRegister& Vec2)"
  },
  {
    "label": "XMVector4GreaterR()",
    "kind": "Method",
    "detail": "Function (using namespace DirectX ; uint32_t comparisonValue =)",
    "insertText": "XMVector4GreaterR(Vec1, Vec2)"
  },
  {
    "label": "VectorResetFloatRegisters()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorResetFloatRegisters() #define VectorGetControlRegister() _mm_getcsr() #define VectorSetControlRegister(ControlStatus) _mm_setcsr( ControlStatus ) #define VECTOR_ROUND_TOWARD_ZERO _MM_ROUND_TOWARD_ZERO FORCEINLINE VectorRegister VectorQuaternionMultiply2( const VectorRegister& Quat1, const VectorRegister& Quat2)"
  },
  {
    "label": "VectorQuaternionMultiply()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorQuaternionMultiply(FQuat *Result, const FQuat* Quat1, const FQuat* Quat2)"
  },
  {
    "label": "VectorLoadAligned()",
    "kind": "Method",
    "detail": "Function (VectorRegister XMQuat1 =)",
    "insertText": "VectorLoadAligned(Quat1)"
  },
  {
    "label": "VectorLoadAligned()",
    "kind": "Method",
    "detail": "Function (VectorRegister XMQuat2 =)",
    "insertText": "VectorLoadAligned(Quat2)"
  },
  {
    "label": "VectorQuaternionMultiply2()",
    "kind": "Method",
    "detail": "Function (VectorRegister XMResult =)",
    "insertText": "VectorQuaternionMultiply2(XMQuat1, XMQuat2)"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreAligned(XMResult, Result)"
  },
  {
    "label": "VectorQuaternionMultiply()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorQuaternionMultiply(VectorRegister *VResult, const VectorRegister* VQuat1, const VectorRegister* VQuat2)"
  },
  {
    "label": "VectorQuaternionMultiply2()",
    "kind": "Method",
    "detail": "Function (* VResult =)",
    "insertText": "VectorQuaternionMultiply2(*VQuat1, *VQuat2)"
  },
  {
    "label": "VectorQuaternionVector3Rotate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorQuaternionVector3Rotate(FVector *Result, const FVector* Vec, const FQuat* Quat)"
  },
  {
    "label": "VectorLoadFloat3_W0()",
    "kind": "Method",
    "detail": "Function (VectorRegister XMVec =)",
    "insertText": "VectorLoadFloat3_W0(Vec)"
  },
  {
    "label": "VectorLoadAligned()",
    "kind": "Method",
    "detail": "Function (VectorRegister XMQuat =)",
    "insertText": "VectorLoadAligned(Quat)"
  },
  {
    "label": "XMVector3Rotate()",
    "kind": "Method",
    "detail": "Function (VectorRegister XMResult =)",
    "insertText": "XMVector3Rotate(XMVec, XMQuat)"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreFloat3(XMResult, Result)"
  },
  {
    "label": "VectorQuaternionVector3InverseRotate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorQuaternionVector3InverseRotate(FVector *Result, const FVector* Vec, const FQuat* Quat)"
  },
  {
    "label": "XMVector3InverseRotate()",
    "kind": "Method",
    "detail": "Function (VectorRegister XMResult =)",
    "insertText": "XMVector3InverseRotate(XMVec, XMQuat)"
  },
  {
    "label": "VectorSinCos()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VectorSinCos(VectorRegister* RESTRICT VSinAngles, VectorRegister* RESTRICT VCosAngles, const VectorRegister* RESTRICT VAngles)"
  },
  {
    "label": "XMVectorModAngles()",
    "kind": "Method",
    "detail": "Function (using namespace DirectX ; XMVECTOR x =)",
    "insertText": "XMVectorModAngles(*VAngles)"
  },
  {
    "label": "_mm_and_ps()",
    "kind": "Method",
    "detail": "Function (XMVECTOR sign =)",
    "insertText": "_mm_and_ps(x, g_XMNegativeZero)"
  },
  {
    "label": "_mm_or_ps()",
    "kind": "Method",
    "detail": "Function (__m128 c =)",
    "insertText": "_mm_or_ps(g_XMPi, sign)"
  },
  {
    "label": "_mm_andnot_ps()",
    "kind": "Method",
    "detail": "Function (__m128 absx =)",
    "insertText": "_mm_andnot_ps(sign, x)"
  },
  {
    "label": "_mm_sub_ps()",
    "kind": "Method",
    "detail": "Function (__m128 rflx =)",
    "insertText": "_mm_sub_ps(c, x)"
  },
  {
    "label": "_mm_cmple_ps()",
    "kind": "Method",
    "detail": "Function (__m128 comp =)",
    "insertText": "_mm_cmple_ps(absx, g_XMHalfPi)"
  },
  {
    "label": "_mm_and_ps()",
    "kind": "Method",
    "detail": "Function (__m128 select0 =)",
    "insertText": "_mm_and_ps(comp, x)"
  },
  {
    "label": "_mm_andnot_ps()",
    "kind": "Method",
    "detail": "Function (__m128 select1 =)",
    "insertText": "_mm_andnot_ps(comp, rflx)"
  },
  {
    "label": "_mm_or_ps()",
    "kind": "Method",
    "detail": "Function (x =)",
    "insertText": "_mm_or_ps(select0, select1)"
  },
  {
    "label": "_mm_and_ps()",
    "kind": "Method",
    "detail": "Function (select0 =)",
    "insertText": "_mm_and_ps(comp, g_XMOne)"
  },
  {
    "label": "_mm_andnot_ps()",
    "kind": "Method",
    "detail": "Function (select1 =)",
    "insertText": "_mm_andnot_ps(comp, g_XMNegativeOne)"
  },
  {
    "label": "_mm_mul_ps()",
    "kind": "Method",
    "detail": "Function (__m128 x2 =)",
    "insertText": "_mm_mul_ps(x, x)"
  },
  {
    "label": "XM_PERMUTE_PS()",
    "kind": "Method",
    "detail": "Function (const XMVECTOR SC1 = g_XMSinCoefficients1 ; XMVECTOR vConstants =)",
    "insertText": "XM_PERMUTE_PS(SC1, _MM_SHUFFLE(0, 0, 0, 0))"
  },
  {
    "label": "_mm_mul_ps()",
    "kind": "Method",
    "detail": "Function (__m128 Result =)",
    "insertText": "_mm_mul_ps(vConstants, x2)"
  },
  {
    "label": "XM_PERMUTE_PS()",
    "kind": "Method",
    "detail": "Function (const XMVECTOR SC0 = g_XMSinCoefficients0 ; vConstants =)",
    "insertText": "XM_PERMUTE_PS(SC0, _MM_SHUFFLE(3, 3, 3, 3))"
  },
  {
    "label": "_mm_add_ps()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "_mm_add_ps(Result, vConstants)"
  },
  {
    "label": "_mm_mul_ps()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "_mm_mul_ps(Result, x2)"
  },
  {
    "label": "XM_PERMUTE_PS()",
    "kind": "Method",
    "detail": "Function (vConstants =)",
    "insertText": "XM_PERMUTE_PS(SC0, _MM_SHUFFLE(2, 2, 2, 2))"
  },
  {
    "label": "XM_PERMUTE_PS()",
    "kind": "Method",
    "detail": "Function (vConstants =)",
    "insertText": "XM_PERMUTE_PS(SC0, _MM_SHUFFLE(1, 1, 1, 1))"
  },
  {
    "label": "XM_PERMUTE_PS()",
    "kind": "Method",
    "detail": "Function (vConstants =)",
    "insertText": "XM_PERMUTE_PS(SC0, _MM_SHUFFLE(0, 0, 0, 0))"
  },
  {
    "label": "_mm_add_ps()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "_mm_add_ps(Result, g_XMOne)"
  },
  {
    "label": "_mm_mul_ps()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "_mm_mul_ps(Result, x)"
  },
  {
    "label": "XM_PERMUTE_PS()",
    "kind": "Method",
    "detail": "Function (* VSinAngles = Result ; const XMVECTOR CC1 = g_XMCosCoefficients1 ; vConstants =)",
    "insertText": "XM_PERMUTE_PS(CC1, _MM_SHUFFLE(0, 0, 0, 0))"
  },
  {
    "label": "XM_PERMUTE_PS()",
    "kind": "Method",
    "detail": "Function (const XMVECTOR CC0 = g_XMCosCoefficients0 ; vConstants =)",
    "insertText": "XM_PERMUTE_PS(CC0, _MM_SHUFFLE(3, 3, 3, 3))"
  },
  {
    "label": "XM_PERMUTE_PS()",
    "kind": "Method",
    "detail": "Function (vConstants =)",
    "insertText": "XM_PERMUTE_PS(CC0, _MM_SHUFFLE(2, 2, 2, 2))"
  },
  {
    "label": "XM_PERMUTE_PS()",
    "kind": "Method",
    "detail": "Function (vConstants =)",
    "insertText": "XM_PERMUTE_PS(CC0, _MM_SHUFFLE(1, 1, 1, 1))"
  },
  {
    "label": "XM_PERMUTE_PS()",
    "kind": "Method",
    "detail": "Function (vConstants =)",
    "insertText": "XM_PERMUTE_PS(CC0, _MM_SHUFFLE(0, 0, 0, 0))"
  },
  {
    "label": "_mm_mul_ps()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "_mm_mul_ps(Result, sign)"
  },
  {
    "label": "VectorContainsNaNOrInfinite()",
    "kind": "Method",
    "detail": "Function (* VCosAngles = Result ; } bool)",
    "insertText": "VectorContainsNaNOrInfinite(const VectorRegister& Vec)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (const VectorRegister ExpTest =)",
    "insertText": "VectorBitwiseAnd(Vec, GlobalVectorConstants::FloatInfinity())"
  },
  {
    "label": "VectorMaskBits()",
    "kind": "Method",
    "detail": "Function (bool IsFinite =)",
    "insertText": "VectorMaskBits(VectorCompareEQ(ExpTest, GlobalVectorConstants::FloatInfinity()))"
  },
  {
    "label": "VectorExp2()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorExp2(const VectorRegister& X)"
  },
  {
    "label": "VectorLog()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorLog(const VectorRegister& X)"
  },
  {
    "label": "VectorLog2()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorLog2(const VectorRegister& X)"
  },
  {
    "label": "VectorSin()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorSin(const VectorRegister& X)"
  },
  {
    "label": "VectorCos()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorCos(const VectorRegister& X)"
  },
  {
    "label": "VectorTan()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorTan(const VectorRegister& X)"
  },
  {
    "label": "VectorASin()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorASin(const VectorRegister& X)"
  },
  {
    "label": "VectorACos()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorACos(const VectorRegister& X)"
  },
  {
    "label": "VectorATan()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorATan(const VectorRegister& X)"
  },
  {
    "label": "VectorATan2()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorATan2(const VectorRegister& X, const VectorRegister& Y)"
  },
  {
    "label": "VectorCeil()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorCeil(const VectorRegister& X)"
  },
  {
    "label": "VectorFloor()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorFloor(const VectorRegister& X)"
  },
  {
    "label": "VectorTruncate()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorTruncate(const VectorRegister& X)"
  },
  {
    "label": "VectorFractional()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorFractional(const VectorRegister& X)"
  },
  {
    "label": "VectorMod()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorMod(const VectorRegister& X, const VectorRegister& Y)"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (VectorRegister AbsY =)",
    "insertText": "VectorAbs(Y)"
  },
  {
    "label": "XMVectorMod()",
    "kind": "Method",
    "detail": "Function (VectorRegister Result =)",
    "insertText": "XMVectorMod(X, Y)"
  },
  {
    "label": "VectorSign()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorSign(const VectorRegister& X)"
  },
  {
    "label": "VectorStep()",
    "kind": "Method",
    "detail": "Function (} VectorRegister)",
    "insertText": "VectorStep(const VectorRegister& X)"
  },
  {
    "label": "VectorIntAnd()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorIntAnd(A, B) _mm_and_si128(A, B) #define VectorIntOr(A, B) _mm_or_si128(A, B) #define VectorIntXor(A, B) _mm_xor_si128(A, B) #define VectorIntAndNot(A, B) _mm_andnot_si128(A, B) #define VectorIntNot(A) _mm_xor_si128(A, GlobalVectorConstants::IntAllMask) #define VectorIntCompareEQ(A, B) _mm_cmpeq_epi32(A,B) #define VectorIntCompareNEQ(A, B) VectorIntNot(_mm_cmpeq_epi32(A,B)) #define VectorIntCompareGT(A, B) _mm_cmpgt_epi32(A,B) #define VectorIntCompareLT(A, B) _mm_cmplt_epi32(A,B) #define VectorIntCompareGE(A, B) VectorIntNot(VectorIntCompareLT(A,B)) #define VectorIntCompareLE(A, B) VectorIntNot(VectorIntCompareGT(A,B)) FORCEINLINE VectorRegister4Int VectorIntSelect(const VectorRegister4Int& Mask, const VectorRegister4Int& Vec1, const VectorRegister4Int& Vec2)"
  },
  {
    "label": "VectorIntAdd()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorIntAdd(A, B) _mm_add_epi32(A, B) #define VectorIntSubtract(A, B) _mm_sub_epi32(A, B) FORCEINLINE VectorRegister4Int VectorIntMultiply(const VectorRegister4Int& A, const VectorRegister4Int& B)"
  },
  {
    "label": "_mm_mul_epu32()",
    "kind": "Method",
    "detail": "Function (__m128i Temp0 =)",
    "insertText": "_mm_mul_epu32(A, B)"
  },
  {
    "label": "_mm_mul_epu32()",
    "kind": "Method",
    "detail": "Function (__m128i Temp1 =)",
    "insertText": "_mm_mul_epu32(_mm_srli_si128(A, 4), _mm_srli_si128(B, 4))"
  },
  {
    "label": "VectorIntNegate()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorIntNegate(A) VectorIntSubtract( GlobalVectorConstants::IntZero, A) FORCEINLINE VectorRegister4Int VectorIntMin(const VectorRegister4Int& A, const VectorRegister4Int& B)"
  },
  {
    "label": "VectorIntCompareLT()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Int Mask =)",
    "insertText": "VectorIntCompareLT(A, B)"
  },
  {
    "label": "VectorIntMax()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Int)",
    "insertText": "VectorIntMax(const VectorRegister4Int& A, const VectorRegister4Int& B)"
  },
  {
    "label": "VectorIntCompareGT()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Int Mask =)",
    "insertText": "VectorIntCompareGT(A, B)"
  },
  {
    "label": "VectorIntAbs()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Int)",
    "insertText": "VectorIntAbs(const VectorRegister4Int& A)"
  },
  {
    "label": "VectorIntCompareGE()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Int Mask =)",
    "insertText": "VectorIntCompareGE(A, GlobalVectorConstants::IntZero)"
  },
  {
    "label": "VectorIntSign()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "VectorIntSign(A) VectorIntSelect( VectorIntCompareGE(A, GlobalVectorConstants::IntZero), GlobalVectorConstants::IntOne, GlobalVectorConstants::IntMinusOne ) #define VectorIntToFloat(A) _mm_cvtepi32_ps(A) #define VectorFloatToInt(A) _mm_cvttps_epi32(A) FORCEINLINE VectorRegister4Int VectorRoundToIntHalfToEven(const VectorRegister4Float& Vec)"
  }
]