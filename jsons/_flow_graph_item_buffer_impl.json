[
  {
    "label": "reservable_item_buffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "reservable_item_buffer"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB__flow_graph_item_buffer_impl_H # define __TBB__flow_graph_item_buffer_impl_H # ifndef __TBB_flow_graph_H # error Do not # include this internal file directly ; use public TBB headers instead . # endif # include \" tbb / internal / _flow_graph_types_impl . h \" / false ) ; my_array = new_array ; my_array_size = new_size ; } bool)",
    "insertText": "push_back(item_type &v)"
  },
  {
    "label": "grow_my_array()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "grow_my_array(size() + 1)"
  },
  {
    "label": "set_my_item()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "set_my_item(my_tail, v)"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (+ + my_tail ; return true ; } bool)",
    "insertText": "pop_back(item_type &v)"
  },
  {
    "label": "destroy_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy_back()"
  },
  {
    "label": "destroy_front()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy_front()"
  },
  {
    "label": "allocator_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "allocator_type().deallocate(my_array,my_array_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} my_array = NULL ;)",
    "insertText": "if(reset_pointers)"
  },
  {
    "label": "item_buffer()",
    "kind": "Method",
    "detail": "Function (my_head = my_tail = my_array_size = 0 ; } } public :)",
    "insertText": "item_buffer() : my_array(NULL), my_array_size(0), my_head(0), my_tail(0)"
  },
  {
    "label": "grow_my_array()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "grow_my_array(initial_buffer_size)"
  },
  {
    "label": "item_buffer()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "item_buffer()"
  },
  {
    "label": "clean_up_buffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clean_up_buffer(true)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reset()"
  },
  {
    "label": "reservable_item_buffer()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,A = cache_aligned_allocator<T>> class reservable_item_buffer : public item_buffer<T,A> { protected : using item_buffer<T,A>::my_item_valid ; using item_buffer<T,A>::my_head ; public :)",
    "insertText": "reservable_item_buffer() : item_buffer<T, A>(), my_reserved(false)"
  },
  {
    "label": "reserve_front()",
    "kind": "Method",
    "detail": "Function (} protected : bool)",
    "insertText": "reserve_front(T &v)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (my_reserved = true ; v = this ->)",
    "insertText": "front()"
  },
  {
    "label": "reserve_item()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "reserve_item(this->my_head)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_reserved, \"Attempt to consume a non-reserved item\")"
  },
  {
    "label": "release_front()",
    "kind": "Method",
    "detail": "Function (my_reserved = false ; } void)",
    "insertText": "release_front()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_reserved, \"Attempt to release a non-reserved item\")"
  },
  {
    "label": "release_item()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "release_item(this->my_head)"
  }
]