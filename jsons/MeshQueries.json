[
  {
    "label": "TriangleMeshType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TriangleMeshType"
  },
  {
    "label": "TMeshQueries",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMeshQueries"
  },
  {
    "label": "TMeshQueries()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Distance / DistPoint3Triangle3 . h \" # include \" Intersection / IntrRay3Triangle3 . h \" # include \" Intersection / IntrTriangle3Triangle3 . h \" # include \" BoxTypes . h \" # include \" IndexTypes . h \" # include \" Algo / Accumulate . h \" # include \" Async / ParallelFor . h \" namespace UE { namespace Geometry { template<class TriangleMeshType> class TMeshQueries { public :)",
    "insertText": "TMeshQueries()"
  },
  {
    "label": "TriangleDistance()",
    "kind": "Method",
    "detail": "Function (FDistPoint3Triangle3d)",
    "insertText": "TriangleDistance(const TriangleMeshType& Mesh, int TriIdx, FVector3d Point)"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (FTriangle3d tri ; Mesh .)",
    "insertText": "GetTriVertices(TriIdx, tri.V[0], tri.V[1], tri.V[2])"
  },
  {
    "label": "q()",
    "kind": "Method",
    "detail": "Function (FDistPoint3Triangle3d)",
    "insertText": "q(Point, tri)"
  },
  {
    "label": "GetSquared()",
    "kind": "Method",
    "detail": "Function (q .)",
    "insertText": "GetSquared()"
  },
  {
    "label": "q()",
    "kind": "Method",
    "detail": "Function (FIntrRay3Triangle3d)",
    "insertText": "q(Ray, tri)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (q .)",
    "insertText": "Find()"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (FTriangle3d Triangle ; Mesh .)",
    "insertText": "GetTriVertices(TriIdx, Triangle.V[0], Triangle.V[1], Triangle.V[2])"
  },
  {
    "label": "GetTriNormalAreaCentroid()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetTriNormalAreaCentroid(const TriangleMeshType& Mesh, int TriIdx, FVector3d& Normal, double& Area, FVector3d& Centroid)"
  },
  {
    "label": "Centroid()",
    "kind": "Method",
    "detail": "Function (Centroid = Triangle .)",
    "insertText": "Centroid()"
  },
  {
    "label": "NormalArea()",
    "kind": "Method",
    "detail": "Function (Normal =)",
    "insertText": "NormalArea(Triangle.V[0], Triangle.V[1], Triangle.V[2], Area)"
  },
  {
    "label": "GetMeshVerticesCentroid()",
    "kind": "Method",
    "detail": "Function (} FVector3d)",
    "insertText": "GetMeshVerticesCentroid(const TriangleMeshType& Mesh)"
  },
  {
    "label": "Centroid()",
    "kind": "Method",
    "detail": "Function (FVector3d)",
    "insertText": "Centroid(0, 0, 0)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (Centroid + = Mesh .)",
    "insertText": "GetVertex(VertIdx)"
  },
  {
    "label": "VertexCount()",
    "kind": "Method",
    "detail": "Function (} } int NumVertices = Mesh .)",
    "insertText": "VertexCount()"
  },
  {
    "label": "Centroid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Centroid(double)"
  },
  {
    "label": "GetVolumeNonWatertight()",
    "kind": "Method",
    "detail": "Function (} return Centroid ; } double)",
    "insertText": "GetVolumeNonWatertight(const TriangleMeshType& Mesh, double DimScaleFactor = 1)"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (continue ; } FVector3d V0,V1,V2 ; Mesh .)",
    "insertText": "GetTriVertices(TriIdx, V0, V1, V2)"
  },
  {
    "label": "V1mRef()",
    "kind": "Method",
    "detail": "Function (FVector3d)",
    "insertText": "V1mRef(V1 - RefPt)"
  },
  {
    "label": "V2mRef()",
    "kind": "Method",
    "detail": "Function (FVector3d)",
    "insertText": "V2mRef(V2 - RefPt)"
  },
  {
    "label": "Cross()",
    "kind": "Method",
    "detail": "Function (FVector3d N = V2mRef .)",
    "insertText": "Cross(V1mRef)"
  },
  {
    "label": "Volume()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Volume((V0-RefPt) * DimScaleFactor).Dot(N)"
  },
  {
    "label": "Volume()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "Volume(1.0 / 6.0)"
  },
  {
    "label": "GetVolumeArea()",
    "kind": "Method",
    "detail": "Function (} FVector2d)",
    "insertText": "GetVolumeArea(const TriangleMeshType& Mesh)"
  },
  {
    "label": "Cross()",
    "kind": "Method",
    "detail": "Function (FVector3d V1mV0 = V1 - V0 ; FVector3d V2mV0 = V2 - V0 ; FVector3d N = V2mV0 .)",
    "insertText": "Cross(V1mV0)"
  },
  {
    "label": "Length()",
    "kind": "Method",
    "detail": "Function (Area + = N .)",
    "insertText": "Length()"
  },
  {
    "label": "GetVolumeAreaCenter()",
    "kind": "Method",
    "detail": "Function (} FVector2d)",
    "insertText": "GetVolumeAreaCenter(const TriangleMeshType& Mesh, FVector3d& OutCenterOfMass)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (break ; } })",
    "insertText": "for(int TriIdx = 0; TriIdx < Mesh.MaxTriangleID(); TriIdx++)"
  },
  {
    "label": "F2()",
    "kind": "Method",
    "detail": "Function (FVector3d F1 = V0 + V1 + V2 ; FVector3d)",
    "insertText": "F2(V0.X * V0.X + V1.X * (V0.X + V1.X) + V2.X * F1.X, V0.Y * V0.Y + V1.Y * (V0.Y + V1.Y) + V2.Y * F1.Y, V0.Z * V0.Z + V1.Z * (V0.Z + V1.Z) + V2.Z * F1.Z)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Volume + = N . X* F1 . X ; OutCenterOfMass + = N* F2 ; })",
    "insertText": "if(Volume != 0.0)"
  },
  {
    "label": "OutCenterOfMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutCenterOfMass(Volume * 4.0)"
  },
  {
    "label": "FVector2d()",
    "kind": "Method",
    "detail": "Function (} OutCenterOfMass + = RefVert ; return)",
    "insertText": "FVector2d(Volume * (1.0 / 6.0), Area * .5)"
  },
  {
    "label": "GetVolumeArea()",
    "kind": "Method",
    "detail": "Function (} FVector2d)",
    "insertText": "GetVolumeArea(const TriangleMeshType& Mesh, const TArray<int>& TriIndices)"
  },
  {
    "label": "GetTriBounds()",
    "kind": "Method",
    "detail": "Function (} FAxisAlignedBox3d)",
    "insertText": "GetTriBounds(const TriangleMeshType& Mesh, int TID)"
  },
  {
    "label": "GetTriangle()",
    "kind": "Method",
    "detail": "Function (FIndex3i TriInds = Mesh .)",
    "insertText": "GetTriangle(TID)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (FVector3d MinV,MaxV,V = Mesh .)",
    "insertText": "GetVertex(TriInds.A)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (MinV = MaxV = V ;)",
    "insertText": "for(int i = 1; i < 3; ++i)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (V = Mesh .)",
    "insertText": "GetVertex(TriInds[i])"
  },
  {
    "label": "FAxisAlignedBox3d()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "FAxisAlignedBox3d(MinV, MaxV)"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (} FAxisAlignedBox3d)",
    "insertText": "GetBounds(const TriangleMeshType& Mesh)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (FAxisAlignedBox3d Bounds =)",
    "insertText": "Empty()"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Bounds .)",
    "insertText": "Contain(Mesh.GetVertex(i))"
  },
  {
    "label": "GetTrianglesBounds()",
    "kind": "Method",
    "detail": "Function (} } return Bounds ; } template<EnumerableTriListType> FAxisAlignedBox3d)",
    "insertText": "GetTrianglesBounds(const TriangleMeshType& Mesh, const EnumerableTriListType& Triangles, const FTransform& Transform = FTransform::Identity)"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (FVector3d A,B,C ; Mesh .)",
    "insertText": "GetTriVertices(tid, A,B,C)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Bounds .)",
    "insertText": "Contain(Transform.TransformPosition(A))"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Bounds .)",
    "insertText": "Contain(Transform.TransformPosition(B))"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Bounds .)",
    "insertText": "Contain(Transform.TransformPosition(C))"
  },
  {
    "label": "GetVerticesBounds()",
    "kind": "Method",
    "detail": "Function (} } return Bounds ; } template<EnumerableTriListType> FAxisAlignedBox3d)",
    "insertText": "GetVerticesBounds(const TriangleMeshType& Mesh, const EnumerableTriListType& Vertices, const FTransform& Transform = FTransform::Identity)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Bounds .)",
    "insertText": "Contain(Transform.TransformPosition(Mesh.GetVertex(vid)))"
  },
  {
    "label": "FindNearestTriangle_LinearSearch()",
    "kind": "Method",
    "detail": "Function (} } return Bounds ; } int)",
    "insertText": "FindNearestTriangle_LinearSearch(const TriangleMeshType& Mesh, const FVector3d& P)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (int tNearest = IndexConstants::InvalidID ; double fNearestSqr = TNumericLimits<double)",
    "insertText": "Max()"
  },
  {
    "label": "FindNearestPoint_LinearSearch()",
    "kind": "Method",
    "detail": "Function (fNearestSqr = distSqr ; tNearest = TriIdx ; } } return tNearest ; } FVector3d)",
    "insertText": "FindNearestPoint_LinearSearch(const TriangleMeshType& Mesh, const FVector3d& P)"
  },
  {
    "label": "TriangleDistance()",
    "kind": "Method",
    "detail": "Function (FDistPoint3Triangle3d Query =)",
    "insertText": "TriangleDistance(Mesh, TriIdx, P)"
  },
  {
    "label": "TriDistanceSqr()",
    "kind": "Method",
    "detail": "Function (NearestPoint = Query . ClosestTrianglePoint ; } } return NearestPoint ; } double)",
    "insertText": "TriDistanceSqr(const TriangleMeshType& Mesh, int TriIdx, const FVector3d& Point)"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (FDistPoint3Triangle3d)",
    "insertText": "Distance(Point, Triangle)"
  },
  {
    "label": "FindHitTriangle_LinearSearch()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "FindHitTriangle_LinearSearch(const TriangleMeshType& Mesh, const FRay3d& Ray)"
  },
  {
    "label": "Query()",
    "kind": "Method",
    "detail": "Function (FIntrRay3Triangle3d)",
    "insertText": "Query(Ray, Triangle)"
  },
  {
    "label": "FindHitTriangles_LinearSearch()",
    "kind": "Method",
    "detail": "Function (fNearestT = Query . RayParameter ; tNearestID = TriIdx ; } } } return tNearestID ; } void)",
    "insertText": "FindHitTriangles_LinearSearch(const TriangleMeshType& Mesh, const FRay3d& Ray, TArray<TPair<float, int>>& SortedHitTriangles)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (SortedHitTriangles .)",
    "insertText": "Emplace(Query.RayParameter, TriIdx)"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (} } SortedHitTriangles .)",
    "insertText": "Sort([](const TPair<float, int>& A, const TPair<float, int>& B) { return A.Key < B.Key; })"
  },
  {
    "label": "FindIntersectingTriangles_LinearSearch()",
    "kind": "Method",
    "detail": "Function (} FIndex2i)",
    "insertText": "FindIntersectingTriangles_LinearSearch(const TriangleMeshType& Mesh1, const TriangleMeshType& Mesh2)"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (continue ; } FTriangle3d Tri1 ; Mesh1 .)",
    "insertText": "GetTriVertices(TI, Tri1.V[0], Tri1.V[1], Tri1.V[2])"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (continue ; } FTriangle3d Tri2 ; Mesh2 .)",
    "insertText": "GetTriVertices(TJ, Tri2.V[0], Tri2.V[1], Tri2.V[2])"
  },
  {
    "label": "Invalid()",
    "kind": "Method",
    "detail": "Function (} } } return)",
    "insertText": "Invalid()"
  },
  {
    "label": "RayTriangleIntersection()",
    "kind": "Method",
    "detail": "Function (} FIntrRay3Triangle3d)",
    "insertText": "RayTriangleIntersection(const TriangleMeshType& Mesh, int TriIdx, const FRay3d& Ray)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (Lengths .)",
    "insertText": "Init(-1.0, Mesh.MaxEdgeID())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TotalLength = 0 . 0 ;)",
    "insertText": "for(const int32 EdgeID : Mesh.EdgeIndicesItr())"
  },
  {
    "label": "GetEdgeV()",
    "kind": "Method",
    "detail": "Function (FVector3d vA,vB ; Mesh .)",
    "insertText": "GetEdgeV(EdgeID, vA, vB)"
  },
  {
    "label": "EdgeID()",
    "kind": "Method",
    "detail": "Function (Lengths [)",
    "insertText": "EdgeID(vA - vB).Length()"
  },
  {
    "label": "AverageEdgeLength()",
    "kind": "Method",
    "detail": "Function (TotalLength + = Lengths [ EdgeID ] ; } } double)",
    "insertText": "AverageEdgeLength(const TriangleMeshType& Mesh)"
  },
  {
    "label": "MaxEdgeLength()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "MaxEdgeLength(const TriangleMeshType& Mesh)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MaxLength =)",
    "insertText": "Max(MaxLength, (vA - vB).Length())"
  },
  {
    "label": "MinEdgeLength()",
    "kind": "Method",
    "detail": "Function (} return MaxLength ; } double)",
    "insertText": "MinEdgeLength(const TriangleMeshType& Mesh)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (MinLength =)",
    "insertText": "Min(MinLength, (vA - vB).Length())"
  },
  {
    "label": "TotalEdgeLength()",
    "kind": "Method",
    "detail": "Function (} return MinLength ; } double)",
    "insertText": "TotalEdgeLength(const TriangleMeshType& Mesh, const TArray<int>& Edges)"
  },
  {
    "label": "GetEdgeV()",
    "kind": "Method",
    "detail": "Function (FVector3d A,B ; Mesh .)",
    "insertText": "GetEdgeV(EdgeID, A, B)"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (AccumulatedLength + =)",
    "insertText": "Distance(A, B)"
  },
  {
    "label": "EdgeLengthStatsFromEdges()",
    "kind": "Method",
    "detail": "Function (} } return AccumulatedLength ; } void)",
    "insertText": "EdgeLengthStatsFromEdges(const TriangleMeshType& Mesh, const TArray<int>& Edges, double& MinEdgeLength, double& MaxEdgeLength, double& AverageEdgeLength)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (MinEdgeLength = 0 . 0 ; MaxEdgeLength = 0 . 0 ; AverageEdgeLength = 0 . 0 ; return ; } MinEdgeLength = BIG_NUMBER ; MaxEdgeLength = - BIG_NUMBER ; AverageEdgeLength = 0 ; int EdgeCount = 0 ;)",
    "insertText": "for(int EdgeID : Edges)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MinEdgeLength = Length ; })",
    "insertText": "if(Length > MaxEdgeLength)"
  },
  {
    "label": "AverageEdgeLength()",
    "kind": "Method",
    "detail": "Function (MaxEdgeLength = Length ; } AverageEdgeLength + = Length ; + + EdgeCount ; } })",
    "insertText": "AverageEdgeLength(double)"
  },
  {
    "label": "EdgeLengthStats()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EdgeLengthStats(const TriangleMeshType& Mesh, double& MinEdgeLength, double& MaxEdgeLength, double& AverageEdgeLength, int NumSamples = 0)"
  },
  {
    "label": "MaxEdgeID()",
    "kind": "Method",
    "detail": "Function (MinEdgeLength = 0 . 0 ; MaxEdgeLength = 0 . 0 ; AverageEdgeLength = 0 . 0 ; return ; } MinEdgeLength = BIG_NUMBER ; MaxEdgeLength = - BIG_NUMBER ; AverageEdgeLength = 0 ; int MaxID = Mesh .)",
    "insertText": "MaxEdgeID()"
  },
  {
    "label": "PrimeNumber()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "PrimeNumber(NumSamples == 0)"
  },
  {
    "label": "MaxCount()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "MaxCount(NumSamples == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FVector3d A,B ; int EdgeID = 0 ; int EdgeCount = 0 ; do {)",
    "insertText": "if(Mesh.IsEdge(EdgeID))"
  },
  {
    "label": "EdgeID()",
    "kind": "Method",
    "detail": "Function (AverageEdgeLength + = Length ; + + EdgeCount ; })",
    "insertText": "EdgeID(EdgeID + PrimeNumber)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(EdgeID != 0 && EdgeCount < MaxCount)"
  },
  {
    "label": "VertexToSurfaceDistances()",
    "kind": "Method",
    "detail": "Function (} template<MeshSpatialType> void)",
    "insertText": "VertexToSurfaceDistances(const TriangleMeshType& MeshA, const MeshSpatialType& SpatialB, TArray<double>& Distances)"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (Distances .)",
    "insertText": "SetNumZeroed(MeshA.VertexCount())"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(MeshA.VertexCount(), [&MeshA, &SpatialB, &Distances](int VertexID) { if (!MeshA.IsVertex(VertexID)) { return; } FVector3d VertexPosition = MeshA.GetVertex(VertexID); double DistSqr; SpatialB.FindNearestTriangle(VertexPosition, DistSqr); Distances[VertexID] = sqrt(DistSqr); })"
  },
  {
    "label": "HausdorffDistance()",
    "kind": "Method",
    "detail": "Function (} template<MeshSpatialType> double)",
    "insertText": "HausdorffDistance(const TriangleMeshType& MeshA, const MeshSpatialType& SpatialB)"
  },
  {
    "label": "VertexToSurfaceDistances()",
    "kind": "Method",
    "detail": "Function (TArray<double> Distances ;)",
    "insertText": "VertexToSurfaceDistances(MeshA, SpatialB, Distances)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MaxDist =)",
    "insertText": "Max(Dist, MaxDist)"
  },
  {
    "label": "TwoSidedHausdorffDistance()",
    "kind": "Method",
    "detail": "Function (} return MaxDist ; } template<MeshSpatialType> double)",
    "insertText": "TwoSidedHausdorffDistance(const TriangleMeshType& MeshA, const MeshSpatialType& SpatialA, const TriangleMeshType& MeshB, const MeshSpatialType& SpatialB)"
  },
  {
    "label": "VertexToSurfaceDistancesSerial()",
    "kind": "Method",
    "detail": "Function (} template<MeshSpatialType> void)",
    "insertText": "VertexToSurfaceDistancesSerial(const TriangleMeshType& MeshA, const MeshSpatialType& SpatialB, TArray<double>& Distances)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (continue ; } FVector3d VertexPosition = MeshA .)",
    "insertText": "GetVertex(VertexID)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (Distances [ VertexID ] =)",
    "insertText": "sqrt(DistSqr)"
  },
  {
    "label": "HausdorffDistanceSerial()",
    "kind": "Method",
    "detail": "Function (} } template<MeshSpatialType> double)",
    "insertText": "HausdorffDistanceSerial(const TriangleMeshType& MeshA, const MeshSpatialType& SpatialB)"
  },
  {
    "label": "VertexToSurfaceDistancesSerial()",
    "kind": "Method",
    "detail": "Function (TArray<double> Distances ;)",
    "insertText": "VertexToSurfaceDistancesSerial(MeshA, SpatialB, Distances)"
  },
  {
    "label": "TwoSidedHausdorffDistanceSerial()",
    "kind": "Method",
    "detail": "Function (} return MaxDist ; } template<MeshSpatialType> double)",
    "insertText": "TwoSidedHausdorffDistanceSerial(const TriangleMeshType& MeshA, const MeshSpatialType& SpatialA, const TriangleMeshType& MeshB, const MeshSpatialType& SpatialB)"
  },
  {
    "label": "MeshDistanceStatistics()",
    "kind": "Method",
    "detail": "Function (} template<MeshSpatialType> void)",
    "insertText": "MeshDistanceStatistics(const TriangleMeshType& MeshA, const MeshSpatialType& SpatialB, const TriangleMeshType* MeshB, const MeshSpatialType* SpatialA, bool bSymmetric, double& MaxDistance, double& MinDistance, double& AverageDistance, double& RootMeanSqrDeviation)"
  },
  {
    "label": "VertexToSurfaceDistances()",
    "kind": "Method",
    "detail": "Function (TArray<double> Distances2 ;)",
    "insertText": "VertexToSurfaceDistances(*MeshB, *SpatialA, Distances2)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (Distances .)",
    "insertText": "Append(Distances2)"
  },
  {
    "label": "NumDistances()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "NumDistances(double)Distances.Num()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (MaxDistance = - BIG_NUMBER ; MinDistance = BIG_NUMBER ; AverageDistance = 0 ;)",
    "insertText": "for(double& Dist : Distances)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MaxDistance =)",
    "insertText": "Max(Dist, MaxDistance)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (MinDistance =)",
    "insertText": "Min(Dist, MinDistance)"
  },
  {
    "label": "RootMeanSqrDeviation()",
    "kind": "Method",
    "detail": "Function (AverageDistance + = Dist / NumDistances ;)",
    "insertText": "RootMeanSqrDeviation(Dist * Dist)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (} RootMeanSqrDeviation =)",
    "insertText": "Sqrt(RootMeanSqrDeviation / NumDistances)"
  },
  {
    "label": "GetVertexWeightsOnTriangle()",
    "kind": "Method",
    "detail": "Function (} FVector3d)",
    "insertText": "GetVertexWeightsOnTriangle(const TriangleMeshType& Mesh, int TriID, double TriArea, bool bWeightByArea, bool bWeightByAngle)"
  },
  {
    "label": "One()",
    "kind": "Method",
    "detail": "Function (FVector3d TriNormalWeights =)",
    "insertText": "One()"
  },
  {
    "label": "GetTriInternalAnglesR()",
    "kind": "Method",
    "detail": "Function (TriNormalWeights = Mesh .)",
    "insertText": "GetTriInternalAnglesR(TriID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bWeightByArea)"
  },
  {
    "label": "GetVertexSelectedTriangles()",
    "kind": "Method",
    "detail": "Function (TriNormalWeights* = TriArea ; } return TriNormalWeights ; } TArray<int32>)",
    "insertText": "GetVertexSelectedTriangles(const TriangleMeshType& Mesh, const TArray<int32>& Vertices)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TSet<int32> TriangleSet ; TriangleSet .)",
    "insertText": "Reserve(Vertices.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TriangleSet .)",
    "insertText": "Add(TID)"
  },
  {
    "label": "Array()",
    "kind": "Method",
    "detail": "Function (} } return TriangleSet .)",
    "insertText": "Array()"
  },
  {
    "label": "ExpandVertexSelectionToNeighbors()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExpandVertexSelectionToNeighbors(const TriangleMeshType& Mesh, const TArray<int32>& Selection, TArray<int32>& ExpandedSelection, TMap<int32,int32>& VIDToExpandedSelectionIdx)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (VIDToExpandedSelectionIdx .)",
    "insertText": "Reserve(Selection.Num())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 Idx = 0 ;)",
    "insertText": "for(const int32 SelectedVID : Selection)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VIDToExpandedSelectionIdx .)",
    "insertText": "Add(SelectedVID, Idx++)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ExpandedSelection .)",
    "insertText": "Add(SelectedVID)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(const int32 NeighborVID : Mesh.VtxVerticesItr(SelectedVID))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VIDToExpandedSelectionIdx .)",
    "insertText": "Add(NeighborVID, Idx++)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ExpandedSelection .)",
    "insertText": "Add(NeighborVID)"
  }
]