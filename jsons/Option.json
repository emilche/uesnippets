[
  {
    "label": "Arg",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Arg"
  },
  {
    "label": "ArgList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ArgList"
  },
  {
    "label": "DriverFlag",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "DriverFlag"
  },
  {
    "label": "Option",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Option"
  },
  {
    "label": "OptionClass",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "OptionClass"
  },
  {
    "label": "RenderStyleKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "RenderStyleKind"
  },
  {
    "label": "HelpHidden()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_OPTION_OPTION_H # define LLVM_OPTION_OPTION_H # include \" llvm / ADT / SmallVector . h \" # include \" llvm / ADT / StringRef . h \" # include \" llvm / Option / OptTable . h \" # include \" llvm / Support / ErrorHandling . h \" namespace llvm { namespace opt { class Arg ; class ArgList ; typedef SmallVector<const char*,1 6> ArgStringList ; enum DriverFlag {)",
    "insertText": "HelpHidden(1 << 0), RenderAsInput = (1 << 1), RenderJoined = (1 << 2), RenderSeparate = (1 << 3)"
  },
  {
    "label": "Option()",
    "kind": "Method",
    "detail": "Function (class Option { public : enum OptionClass { GroupClass = 0,InputClass,UnknownClass,FlagClass,JoinedClass,SeparateClass,RemainingArgsClass,CommaJoinedClass,MultiArgClass,JoinedOrSeparateClass,JoinedAndSeparateClass } ; enum RenderStyleKind { RenderCommaJoinedStyle,RenderJoinedStyle,RenderSeparateStyle,RenderValuesStyle } ; protected : const OptTable::Info* Info ; const OptTable* Owner ; public :)",
    "insertText": "Option(const OptTable::Info *Info, const OptTable *Owner)"
  },
  {
    "label": "isValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isValid()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Info && \"Must have a valid info!\")"
  },
  {
    "label": "getName()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "getName()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Owner && \"Must have a valid owner!\")"
  },
  {
    "label": "getAlias()",
    "kind": "Method",
    "detail": "Function (} const Option)",
    "insertText": "getAlias()"
  },
  {
    "label": "getAliasArgs()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "getAliasArgs()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((!Info->AliasArgs || Info->AliasArgs[0] != 0) && \"AliasArgs should be either 0 or non-empty.\")"
  },
  {
    "label": "StringRef()",
    "kind": "Method",
    "detail": "Function (const char* Prefix =* Info -> Prefixes ; return Prefix ? Prefix :)",
    "insertText": "StringRef()"
  },
  {
    "label": "getPrefixedName()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "getPrefixedName()"
  },
  {
    "label": "getPrefix()",
    "kind": "Method",
    "detail": "Function (std::string Ret =)",
    "insertText": "getPrefix()"
  },
  {
    "label": "hasFlag()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasFlag(unsigned Val)"
  },
  {
    "label": "matches()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "matches(OptSpecifier ID)"
  },
  {
    "label": "accept()",
    "kind": "Method",
    "detail": "Function (Arg*)",
    "insertText": "accept(const ArgList &Args, unsigned &Index, unsigned ArgSize)"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dump()"
  }
]