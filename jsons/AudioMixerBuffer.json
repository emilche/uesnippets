[
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "FMixerDevice",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMixerDevice"
  },
  {
    "label": "FMixerBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMixerBuffer"
  },
  {
    "label": "IAudioTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IAudioTask"
  },
  {
    "label": "FMixerBuffer()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" AudioMixer . h \" # include \" Audio . h \" namespace Audio { namespace EBufferType { enum Type { PCM,PCMPreview,PCMRealTime,Streaming,Invalid,} ; } class FMixerDevice ; class FMixerBuffer ; class IAudioTask ; class FMixerBuffer : public FSoundBuffer { public :)",
    "insertText": "FMixerBuffer(FAudioDevice* InAudioDevice, USoundWave* InWave, EBufferType::Type InBufferType)"
  },
  {
    "label": "FMixerBuffer()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FMixerBuffer()"
  },
  {
    "label": "GetSize()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetSize()"
  },
  {
    "label": "GetCurrentChunkIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetCurrentChunkIndex()"
  },
  {
    "label": "GetCurrentChunkOffset()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetCurrentChunkOffset()"
  },
  {
    "label": "IsRealTimeSourceReady()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsRealTimeSourceReady()"
  },
  {
    "label": "ReadCompressedInfo()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReadCompressedInfo(USoundWave* SoundWave)"
  },
  {
    "label": "Seek()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Seek(const float SeekTime)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (FMixerBuffer*)",
    "insertText": "Init(FAudioDevice* AudioDevice, USoundWave* InWave, bool bForceRealtime)"
  },
  {
    "label": "CreatePreviewBuffer()",
    "kind": "Method",
    "detail": "Function (FMixerBuffer*)",
    "insertText": "CreatePreviewBuffer(FAudioDevice* AudioDevice, USoundWave* InWave)"
  },
  {
    "label": "CreateProceduralBuffer()",
    "kind": "Method",
    "detail": "Function (FMixerBuffer*)",
    "insertText": "CreateProceduralBuffer(FAudioDevice* AudioDevice, USoundWave* InWave)"
  },
  {
    "label": "CreateNativeBuffer()",
    "kind": "Method",
    "detail": "Function (FMixerBuffer*)",
    "insertText": "CreateNativeBuffer(FAudioDevice* AudioDevice, USoundWave* InWave)"
  },
  {
    "label": "CreateStreamingBuffer()",
    "kind": "Method",
    "detail": "Function (FMixerBuffer*)",
    "insertText": "CreateStreamingBuffer(FAudioDevice* AudioDevice, USoundWave* InWave)"
  },
  {
    "label": "CreateRealTimeBuffer()",
    "kind": "Method",
    "detail": "Function (FMixerBuffer*)",
    "insertText": "CreateRealTimeBuffer(FAudioDevice* AudioDevice, USoundWave* InWave)"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (EBufferType::Type)",
    "insertText": "GetType()"
  },
  {
    "label": "IsRealTimeBuffer()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsRealTimeBuffer()"
  },
  {
    "label": "GetDecompressionState()",
    "kind": "Method",
    "detail": "Function (ICompressedAudioInfo*)",
    "insertText": "GetDecompressionState(bool bTakesOwnership = false)"
  },
  {
    "label": "GetPCMData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPCMData(uint8** OutData, uint32* OutDataSize)"
  },
  {
    "label": "EnsureHeaderParseTaskFinished()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnsureHeaderParseTaskFinished()"
  },
  {
    "label": "GetSampleRate()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetSampleRate()"
  }
]