[
  {
    "label": "TSerializablePtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSerializablePtr"
  },
  {
    "label": "FErrorReporter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FErrorReporter"
  },
  {
    "label": "FClusterCreationParameters",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FClusterCreationParameters"
  },
  {
    "label": "FDirtyGeometryCollectionData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDirtyGeometryCollectionData"
  },
  {
    "label": "FPBDCollisionConstraints",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDCollisionConstraints"
  },
  {
    "label": "FPBDRigidsEvolutionBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDRigidsEvolutionBase"
  },
  {
    "label": "FGeometryCollectionItemIndex",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGeometryCollectionItemIndex"
  },
  {
    "label": "FStubGeometryCollectionData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStubGeometryCollectionData"
  },
  {
    "label": "FGeometryCollectionPhysicsProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGeometryCollectionPhysicsProxy"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FParticleCollisionFilterData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FParticleCollisionFilterData"
  },
  {
    "label": "FFieldData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFieldData"
  },
  {
    "label": "FGTParticleIndices",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGTParticleIndices"
  },
  {
    "label": "FDamageCollector",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDamageCollector"
  },
  {
    "label": "FDamageData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDamageData"
  },
  {
    "label": "FRuntimeDataCollector",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRuntimeDataCollector"
  },
  {
    "label": "CreateInternalClusterItemIndex()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" GeometryCollection / GeometryCollection . h \" # include \" GeometryCollectionProxyData . h \" # include \" Chaos / Framework / PhysicsProxy . h \" # include \" GeometryCollection / ManagedArray . h \" # include \" GeometryCollection / GeometryCollectionCollisionStructureManager . h \" # include \" Chaos / CollisionFilterData . h \" # include \" Chaos / Framework / BufferedData . h \" # include \" Chaos / GeometryParticlesfwd . h \" # include \" Chaos / ParticleHandle . h \" # include \" Chaos / ParticleHandleFwd . h \" # include \" Chaos / PhysicsObject . h \" # include \" Containers / Array . h \" # include \" PBDRigidsSolver . h \" # include \" Chaos / Defines . h \" # include \" Chaos / GeometryParticlesfwd . h \" namespace Chaos { template<T> class TSerializablePtr ; class FErrorReporter ; struct FClusterCreationParameters ; struct FDirtyGeometryCollectionData ; class FPBDCollisionConstraints ; class FPBDRigidsEvolutionBase ; } struct FGeometryCollectionItemIndex { public : FGeometryCollectionItemIndex)",
    "insertText": "CreateInternalClusterItemIndex(int32 ClusterUniqueIdx)"
  },
  {
    "label": "CreateTransformItemIndex()",
    "kind": "Method",
    "detail": "Function (} FGeometryCollectionItemIndex)",
    "insertText": "CreateTransformItemIndex(int32 TransformIndex)"
  },
  {
    "label": "CreateFromExistingItemIndex()",
    "kind": "Method",
    "detail": "Function (} FGeometryCollectionItemIndex)",
    "insertText": "CreateFromExistingItemIndex(int32 ItemIndex)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (FGeometryCollectionItemIndex)",
    "insertText": "Result(INDEX_NONE, false)"
  },
  {
    "label": "CreateInvalidItemIndex()",
    "kind": "Method",
    "detail": "Function (Result . ItemIndex = ItemIndex ; return Result ; } FGeometryCollectionItemIndex)",
    "insertText": "CreateInvalidItemIndex()"
  },
  {
    "label": "FGeometryCollectionItemIndex()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "FGeometryCollectionItemIndex(const FGeometryCollectionItemIndex& Other) : ItemIndex(Other.ItemIndex)"
  },
  {
    "label": "IsInternalCluster()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsInternalCluster()"
  },
  {
    "label": "GetTransformIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetTransformIndex()"
  },
  {
    "label": "FGeometryCollectionItemIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FGeometryCollectionItemIndex(int32 Index, bool bInternalCluster) : ItemIndex(INDEX_NONE)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (ItemIndex =)",
    "insertText": "Index(bInternalCluster? InternalClusterBaseIndex: 0)"
  },
  {
    "label": "FStubGeometryCollectionData()",
    "kind": "Method",
    "detail": "Function (} } int32 ItemIndex ; } ; class FStubGeometryCollectionData : public Chaos::FParticleData { public : typedef Chaos::FParticleData Base ;)",
    "insertText": "FStubGeometryCollectionData(const FGeometryCollectionResults* DataIn=nullptr) : Base(Chaos::EParticleType::GeometryCollection) , Data(DataIn)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "GetStateData()",
    "kind": "Method",
    "detail": "Function (} const FGeometryCollectionResults*)",
    "insertText": "GetStateData()"
  },
  {
    "label": "FGeometryCollectionPhysicsProxy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FGeometryCollectionPhysicsProxy(UObject* InOwner, FGeometryDynamicCollection& GameThreadCollection, const FSimulationParameters& SimulationParameters, FCollisionFilterData InSimFilter, FCollisionFilterData InQueryFilter, FGuid InCollectorGuid = FGuid::NewGuid(), const Chaos::EMultiBufferMode BufferMode=Chaos::EMultiBufferMode::TripleGuarded)"
  },
  {
    "label": "FGeometryCollectionPhysicsProxy()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FGeometryCollectionPhysicsProxy()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize(Chaos::FPBDRigidsEvolutionBase* Evolution)"
  },
  {
    "label": "IsInitializedOnPhysicsThread()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsInitializedOnPhysicsThread()"
  },
  {
    "label": "InitializeDynamicCollection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeDynamicCollection(FGeometryDynamicCollection& DynamicCollection, const FGeometryCollection& RestCollection, const FSimulationParameters& Params)"
  },
  {
    "label": "IsSimulating()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSimulating()"
  },
  {
    "label": "BufferGameState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BufferGameState()"
  },
  {
    "label": "ClearAccumulatedData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearAccumulatedData()"
  },
  {
    "label": "BufferPhysicsResults_Internal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BufferPhysicsResults_Internal(Chaos::FPBDRigidsSolver* CurrentSolver, Chaos::FDirtyGeometryCollectionData& BufferData)"
  },
  {
    "label": "BufferPhysicsResults_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BufferPhysicsResults_External(Chaos::FDirtyGeometryCollectionData& BufferData)"
  },
  {
    "label": "PushStateOnGameThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PushStateOnGameThread(Chaos::FPBDRigidsSolver* InSolver)"
  },
  {
    "label": "PushToPhysicsState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PushToPhysicsState()"
  },
  {
    "label": "FlipBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlipBuffer()"
  },
  {
    "label": "PullFromPhysicsState()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PullFromPhysicsState(const Chaos::FDirtyGeometryCollectionData& BufferData, const int32 SolverSyncTimestamp, const Chaos::FDirtyGeometryCollectionData* NextPullData = nullptr, const Chaos::FRealSingle* Alpha = nullptr, const Chaos::FDirtyRigidParticleReplicationErrorData* Error = nullptr, const Chaos::FReal AsyncFixedTimeStep = 0)"
  },
  {
    "label": "IsDirty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsDirty()"
  },
  {
    "label": "OnRemoveFromSolver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnRemoveFromSolver(Chaos::FPBDRigidsSolver *RBDSolver)"
  },
  {
    "label": "OnRemoveFromScene()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnRemoveFromScene()"
  },
  {
    "label": "OnUnregisteredFromSolver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnUnregisteredFromSolver()"
  },
  {
    "label": "SetCollisionParticlesPerObjectFraction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCollisionParticlesPerObjectFraction(float CollisionParticlesPerObjectFractionIn)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 ParticleIndex = FromTransformToParticleIndex [ Index ] ;)",
    "insertText": "if(ParticleIndex != INDEX_NONE)"
  },
  {
    "label": "BufferFieldCommand_External()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BufferFieldCommand_External(FFieldSystemCommand&& Command)"
  },
  {
    "label": "BufferFieldCommand_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BufferFieldCommand_Internal(Chaos::FPBDRigidsSolver* RigidsSolver, const FFieldSystemCommand& Command)"
  },
  {
    "label": "FieldForcesUpdateCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FieldForcesUpdateCallback(Chaos::FPBDRigidsSolver* RigidSolver)"
  },
  {
    "label": "FieldParameterUpdateCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FieldParameterUpdateCallback(Chaos::FPBDRigidsSolver* RigidSolver, const bool bUpdateViews = true)"
  },
  {
    "label": "NeedToInitializeSharedCollisionStructures()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "NeedToInitializeSharedCollisionStructures(const FGeometryCollection& RestCollection)"
  },
  {
    "label": "InitializeSharedCollisionStructures()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeSharedCollisionStructures(Chaos::FErrorReporter& ErrorReporter, FGeometryCollection& RestCollection, const FSharedSimulationParameters& SharedParams)"
  },
  {
    "label": "UpdateKinematicBodiesCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateKinematicBodiesCallback(const FParticlesType& InParticles, const float InDt, const float InTime, FKinematicProxy& InKinematicProxy)"
  },
  {
    "label": "StartFrameCallback()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "StartFrameCallback(const float InDt, const float InTime)"
  },
  {
    "label": "EndFrameCallback()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EndFrameCallback(const float InDt)"
  },
  {
    "label": "BindParticleCallbackMapping()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BindParticleCallbackMapping(Chaos::TArrayCollectionArray<PhysicsProxyWrapper>& PhysicsProxyReverseMap, Chaos::TArrayCollectionArray<int32>& ParticleIDReverseMap)"
  },
  {
    "label": "CreateRigidBodyCallback()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CreateRigidBodyCallback(FParticlesType& InOutParticles)"
  },
  {
    "label": "DisableCollisionsCallback()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DisableCollisionsCallback(TSet<TTuple<int32, int32>>& InPairs)"
  },
  {
    "label": "AddForceCallback()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddForceCallback(FParticlesType& InParticles, const float InDt, const int32 InIndex)"
  },
  {
    "label": "IsGTCollectionDirty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsGTCollectionDirty()"
  },
  {
    "label": "SetWorldTransform_External()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetWorldTransform_External(const FTransform& WorldTransform)"
  },
  {
    "label": "GetPreviousWorldTransform_External()",
    "kind": "Method",
    "detail": "Function (const FTransform&)",
    "insertText": "GetPreviousWorldTransform_External()"
  },
  {
    "label": "GetParticleByIndex_External()",
    "kind": "Method",
    "detail": "Function (const FParticle*)",
    "insertText": "GetParticleByIndex_External(int32 Index)"
  },
  {
    "label": "GetParticleByIndex_Internal()",
    "kind": "Method",
    "detail": "Function (FParticleHandle*)",
    "insertText": "GetParticleByIndex_Internal(int32 Index)"
  },
  {
    "label": "GetInitialRootParticle_External()",
    "kind": "Method",
    "detail": "Function (FParticle*)",
    "insertText": "GetInitialRootParticle_External()"
  },
  {
    "label": "GetInitialRootParticle_Internal()",
    "kind": "Method",
    "detail": "Function (} FParticleHandle*)",
    "insertText": "GetInitialRootParticle_Internal()"
  },
  {
    "label": "GetRelevantParticleHandles()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetRelevantParticleHandles(TArray<Chaos::TGeometryParticleHandle<Chaos::FReal, 3>*>& Handles, const Chaos::FPBDRigidsSolver* RigidSolver, EFieldResolutionType ResolutionType)"
  },
  {
    "label": "GetFilteredParticleHandles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetFilteredParticleHandles(TArray<Chaos::TGeometryParticleHandle<Chaos::FReal, 3>*>& Handles, const Chaos::FPBDRigidsSolver* RigidSolver, const EFieldFilterType FilterType, const EFieldObjectType ObjectType)"
  },
  {
    "label": "GetHandleUnsafe()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "GetHandleUnsafe()"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (IndicesOut .)",
    "insertText": "SetNumUninitialized(Handles.Num())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (IndicesOut [ HandleIndex ] = INDEX_NONE ;)",
    "insertText": "if(const int32* TransformGroupIndex = HandleToTransformGroupIndex.Find(Handles[HandleIndex]))"
  },
  {
    "label": "HandleIndex()",
    "kind": "Method",
    "detail": "Function (IndicesOut [)",
    "insertText": "HandleIndex(*TransformGroupIndex)"
  },
  {
    "label": "GetInternalClusterParentItemIndex_External()",
    "kind": "Method",
    "detail": "Function (} } } FGeometryCollectionItemIndex)",
    "insertText": "GetInternalClusterParentItemIndex_External(int32 ChildTransformIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const TUniquePtr<FParticle>& ChildGTParticle = GTParticles [ ChildTransformIndex ] ;)",
    "insertText": "if(const FGTParticleIndices* Indices = GTParticleToIndices.Find(ChildGTParticle.Get()))"
  },
  {
    "label": "FindInternalClusterChildrenTransformIndices_External()",
    "kind": "Method",
    "detail": "Function (} const TArray<int32>*)",
    "insertText": "FindInternalClusterChildrenTransformIndices_External(FGeometryCollectionItemIndex ItemIndex)"
  },
  {
    "label": "GetItemIndexFromGTParticle_External()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } FGeometryCollectionItemIndex)",
    "insertText": "GetItemIndexFromGTParticle_External(const FParticle* GTPParticle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Indices->TransformGroupIndex != INDEX_NONE)"
  },
  {
    "label": "GetItemIndexFromGTParticleNoInternalCluster_External()",
    "kind": "Method",
    "detail": "Function (} FGeometryCollectionItemIndex)",
    "insertText": "GetItemIndexFromGTParticleNoInternalCluster_External(const FParticle* GTPParticle)"
  },
  {
    "label": "GetTransformName_External()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "GetTransformName_External(FGeometryCollectionItemIndex ItemIndex)"
  },
  {
    "label": "GetIsObjectDynamic()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetIsObjectDynamic()"
  },
  {
    "label": "ApplyForceAt_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyForceAt_External(FVector Force, FVector WorldLocation)"
  },
  {
    "label": "ApplyImpulseAt_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyImpulseAt_External(FVector Force, FVector WorldLocation)"
  },
  {
    "label": "BreakClusters_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BreakClusters_External(TArray<FGeometryCollectionItemIndex>&& ItemIndices)"
  },
  {
    "label": "BreakActiveClusters_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BreakActiveClusters_External()"
  },
  {
    "label": "SetAnchoredByIndex_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAnchoredByIndex_External(int32 Index, bool bAnchored)"
  },
  {
    "label": "SetAnchoredByTransformedBox_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAnchoredByTransformedBox_External(const FBox& Box, const FTransform& Transform, bool bAnchored, int32 MaxLevel = INDEX_NONE)"
  },
  {
    "label": "RemoveAllAnchors_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAllAnchors_External()"
  },
  {
    "label": "ApplyExternalStrain_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyExternalStrain_External(FGeometryCollectionItemIndex ItemIndex, const FVector& WorldLocation, float Radius, int32 PropagationDepth, float PropagationFactor, float StrainValue)"
  },
  {
    "label": "ApplyInternalStrain_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyInternalStrain_External(FGeometryCollectionItemIndex ItemIndex, const FVector& WorldLocation, float Radius, int32 PropagationDepth, float PropagationFactor, float StrainValue)"
  },
  {
    "label": "ApplyBreakingLinearVelocity_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyBreakingLinearVelocity_External(FGeometryCollectionItemIndex ItemIndex, const FVector& LinearVelocity)"
  },
  {
    "label": "ApplyBreakingAngularVelocity_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyBreakingAngularVelocity_External(FGeometryCollectionItemIndex ItemIndex, const FVector& AngularVelocity)"
  },
  {
    "label": "ApplyLinearVelocity_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyLinearVelocity_External(FGeometryCollectionItemIndex ItemIndex, const FVector& LinearVelocity)"
  },
  {
    "label": "ApplyAngularVelocity_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAngularVelocity_External(FGeometryCollectionItemIndex ItemIndex, const FVector& AngularVelocity)"
  },
  {
    "label": "SetProxyDirty_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetProxyDirty_External()"
  },
  {
    "label": "SetEnableDamageFromCollision_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetEnableDamageFromCollision_External(bool bEnable)"
  },
  {
    "label": "SetNotifyBreakings_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNotifyBreakings_External(bool bNotify)"
  },
  {
    "label": "SetNotifyRemovals_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNotifyRemovals_External(bool bNotify)"
  },
  {
    "label": "SetNotifyCrumblings_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNotifyCrumblings_External(bool bNotify, bool bIncludeChildren)"
  },
  {
    "label": "SetNotifyGlobalBreakings_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNotifyGlobalBreakings_External(bool bNotify)"
  },
  {
    "label": "SetNotifyGlobalRemovals_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNotifyGlobalRemovals_External(bool bNotify)"
  },
  {
    "label": "SetNotifyGlobalCrumblings_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNotifyGlobalCrumblings_External(bool bNotify, bool bIncludeChildren)"
  },
  {
    "label": "ComputeMaterialBasedDamageThreshold_Internal()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "ComputeMaterialBasedDamageThreshold_Internal(Chaos::FPBDRigidClusteredParticleHandle& ClusteredParticle)"
  },
  {
    "label": "GetInterpolationData()",
    "kind": "Method",
    "detail": "Function (FProxyInterpolationBase*)",
    "insertText": "GetInterpolationData()"
  },
  {
    "label": "SetReplicationMode()",
    "kind": "Method",
    "detail": "Function (} enum class EReplicationMode : uint8 { Unknown,Server,Client,} ; void)",
    "insertText": "SetReplicationMode(EReplicationMode Mode)"
  },
  {
    "label": "GetReplicationMode()",
    "kind": "Method",
    "detail": "Function (ReplicationMode = Mode ; } EReplicationMode)",
    "insertText": "GetReplicationMode()"
  },
  {
    "label": "UpdatePerParticleFilterData_External()",
    "kind": "Method",
    "detail": "Function (struct FParticleCollisionFilterData { int32 ParticleIndex = INDEX_NONE ; bool bIsValid = false ; bool bQueryEnabled = false ; bool bSimEnabled = false ; FCollisionFilterData QueryFilter ; FCollisionFilterData SimFilter ; } ; void)",
    "insertText": "UpdatePerParticleFilterData_External(const TArray<FParticleCollisionFilterData>& Data)"
  },
  {
    "label": "SetDamageThresholds_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDamageThresholds_External(const TArray<float>& DamageThresholds)"
  },
  {
    "label": "SetDamagePropagationData_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDamagePropagationData_External(bool bEnabled, float BreakDamagePropagationFactor, float ShockDamagePropagationFactor)"
  },
  {
    "label": "SetDamageModel_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDamageModel_External(EDamageModelTypeEnum DamageModel)"
  },
  {
    "label": "SetUseMaterialDamageModifiers_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetUseMaterialDamageModifiers_External(bool bUseMaterialDamageModifiers)"
  },
  {
    "label": "SetMaterialOverrideMassScaleMultiplier_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaterialOverrideMassScaleMultiplier_External(float InMultiplier)"
  },
  {
    "label": "SetEnableGravity_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetEnableGravity_External(bool EnableGravity_External)"
  },
  {
    "label": "SetGravityGroupIndex_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetGravityGroupIndex_External(int32 GravityGroupIndex)"
  },
  {
    "label": "SetOneWayInteractionLevel_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOneWayInteractionLevel_External(int32 OneWayInteractionLevel)"
  },
  {
    "label": "SetPhysicsMaterial_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPhysicsMaterial_External(const Chaos::FMaterialHandle& MaterialHandle)"
  },
  {
    "label": "CalculateAndSetLevel()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "CalculateAndSetLevel(int32 TransformGroupIdx, const TManagedArray<int32>& Parent, TManagedArray<int32>& Levels)"
  },
  {
    "label": "SetPostPhysicsSyncCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPostPhysicsSyncCallback(TFunction<void()> Callback)"
  },
  {
    "label": "SetPostParticlesCreatedCallback()",
    "kind": "Method",
    "detail": "Function (PostPhysicsSyncCallback = Callback ; } void)",
    "insertText": "SetPostParticlesCreatedCallback(TFunction<void()> Callback)"
  },
  {
    "label": "GetInitialRootHandle_Internal()",
    "kind": "Method",
    "detail": "Function (PostParticlesCreatedCallback = Callback ; } FClusterHandle*)",
    "insertText": "GetInitialRootHandle_Internal()"
  },
  {
    "label": "GetAllPhysicsObjects()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::FPhysicsObjectHandle>)",
    "insertText": "GetAllPhysicsObjects()"
  },
  {
    "label": "GetAllPhysicsObjectIncludingNulls()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::FPhysicsObjectHandle>)",
    "insertText": "GetAllPhysicsObjectIncludingNulls()"
  },
  {
    "label": "GetPhysicsObjectByIndex()",
    "kind": "Method",
    "detail": "Function (Chaos::FPhysicsObjectHandle)",
    "insertText": "GetPhysicsObjectByIndex(int32 Index)"
  },
  {
    "label": "RebaseAllGameThreadCollectionTransformsOnNewWorldTransform_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RebaseAllGameThreadCollectionTransformsOnNewWorldTransform_External()"
  },
  {
    "label": "SetCreateTraceCollisionGeometryCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCreateTraceCollisionGeometryCallback(FCreateTraceCollisionGeometryCallback InCreateGeometryCallback)"
  },
  {
    "label": "CreateChildrenGeometry_Internal()",
    "kind": "Method",
    "detail": "Function (CreateTraceCollisionGeometryCallback = InCreateGeometryCallback ; } void)",
    "insertText": "CreateChildrenGeometry_Internal()"
  },
  {
    "label": "GetFromParticleToTransformIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetFromParticleToTransformIndex(int32 Index)"
  },
  {
    "label": "RebaseParticleGameThreadCollectionTransformOnNewWorldTransform_External()",
    "kind": "Method",
    "detail": "Function (bSkipChildToParentUpdateWhenInClusterUnion = bValue ; } ; protected : bool)",
    "insertText": "RebaseParticleGameThreadCollectionTransformOnNewWorldTransform_External(int32 ParticleIndex, const TManagedArray<FTransform>& MassToLocal, bool bIsComponentTransformScaled, const FTransform& ComponentScaleTransform)"
  },
  {
    "label": "ComputeMaterialBasedDamageThreshold_Internal()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "ComputeMaterialBasedDamageThreshold_Internal(int32 TransformIndex)"
  },
  {
    "label": "ComputeUserDefinedDamageThreshold_Internal()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "ComputeUserDefinedDamageThreshold_Internal(int32 TransformIndex)"
  },
  {
    "label": "AdjustMassForScale()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "AdjustMassForScale(float Mass)"
  },
  {
    "label": "AdjustInertiaForScale()",
    "kind": "Method",
    "detail": "Function (Chaos::FVec3f)",
    "insertText": "AdjustInertiaForScale(const Chaos::FVec3f& Inertia)"
  },
  {
    "label": "BuildNonClusters_Internal()",
    "kind": "Method",
    "detail": "Function (Chaos::TPBDGeometryCollectionParticleHandle<Chaos::FReal,3>*)",
    "insertText": "BuildNonClusters_Internal(const uint32 CollectionClusterIndex, Chaos::FPBDRigidsSolver* RigidsSolver, float Mass, Chaos::FVec3f Inertia, const Chaos::FUniqueIdx* ExistingIndex)"
  },
  {
    "label": "BuildClusters_Internal()",
    "kind": "Method",
    "detail": "Function (Chaos::FPBDRigidClusteredParticleHandle*)",
    "insertText": "BuildClusters_Internal(const uint32 CollectionClusterIndex, TArray<Chaos::FPBDRigidParticleHandle*>& ChildHandles, const TArray<int32>& ChildTransformGroupIndices, const Chaos::FClusterCreationParameters & Parameters, const Chaos::FUniqueIdx* ExistingIndex)"
  },
  {
    "label": "SetSleepingState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSleepingState(const Chaos::FPBDRigidsSolver& RigidsSolver)"
  },
  {
    "label": "DirtyAllParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DirtyAllParticles(const Chaos::FPBDRigidsSolver& RigidsSolver)"
  },
  {
    "label": "CalculateHierarchyLevel()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "CalculateHierarchyLevel(const FGeometryDynamicCollection& DynamicCollection, int32 TransformIndex)"
  },
  {
    "label": "SetClusteredParticleKinematicTarget_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetClusteredParticleKinematicTarget_Internal(Chaos::FPBDRigidClusteredParticleHandle* Handle, const FTransform& WorldTransform)"
  },
  {
    "label": "PrepareBufferData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrepareBufferData(Chaos::FDirtyGeometryCollectionData& BufferData, const FGeometryDynamicCollection& ThreadCollection, Chaos::FReal SolverLastDt = 0.0)"
  },
  {
    "label": "CreateNonClusteredParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateNonClusteredParticles(Chaos::FPBDRigidsSolver* RigidsSolver, const FGeometryCollection& RestCollection, const FGeometryDynamicCollection& DynamicCollection)"
  },
  {
    "label": "FindClusteredParticleHandleByItemIndex_Internal()",
    "kind": "Method",
    "detail": "Function (Chaos::FPBDRigidClusteredParticleHandle*)",
    "insertText": "FindClusteredParticleHandleByItemIndex_Internal(FGeometryCollectionItemIndex ItemIndex)"
  },
  {
    "label": "UpdateDamageThreshold_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateDamageThreshold_Internal()"
  },
  {
    "label": "ScaleClusterGeometry_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScaleClusterGeometry_Internal(const FVector& WorldScale)"
  },
  {
    "label": "SetWorldTransform_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetWorldTransform_Internal(const FTransform& WorldTransform, bool bInSkipChildToParentUpdateWhenInClusterUnion = false)"
  },
  {
    "label": "SetFilterData_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFilterData_Internal(const FCollisionFilterData& NewSimFilter, const FCollisionFilterData& NewQueryFilter)"
  },
  {
    "label": "SetPerParticleFilterData_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPerParticleFilterData_Internal(const TArray<FParticleCollisionFilterData>& PerParticleData)"
  },
  {
    "label": "SetDamagePropagationData_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDamagePropagationData_Internal(bool bEnabled, float BreakDamagePropagationFactor, float ShockDamagePropagationFactor)"
  },
  {
    "label": "SetEnableGravity_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetEnableGravity_Internal(bool bEnabled)"
  },
  {
    "label": "SetDamageThresholds_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDamageThresholds_Internal(const TArray<float>& DamageThresholds)"
  },
  {
    "label": "SetDamageModel_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDamageModel_Internal(EDamageModelTypeEnum DamageModel)"
  },
  {
    "label": "SetUseMaterialDamageModifiers_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetUseMaterialDamageModifiers_Internal(bool bUseMaterialDamageModifiers)"
  },
  {
    "label": "SetMaterialOverrideMassScaleMultiplier_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaterialOverrideMassScaleMultiplier_Internal(float InMultiplier)"
  },
  {
    "label": "SetGravityGroupIndex_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetGravityGroupIndex_Internal(int32 GravityGroupIndex)"
  },
  {
    "label": "SetOneWayInteractionLevel_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOneWayInteractionLevel_Internal(int32 InOneWayInteractionLevel)"
  },
  {
    "label": "SetPhysicsMaterial_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPhysicsMaterial_Internal(const Chaos::FMaterialHandle& MaterialHandle)"
  },
  {
    "label": "CalculateClustersToCreateFromChildren()",
    "kind": "Method",
    "detail": "Function (private : TBitArray<>)",
    "insertText": "CalculateClustersToCreateFromChildren(const FGeometryDynamicCollection& DynamicCollection, int32 NumTransforms)"
  },
  {
    "label": "CalculateEffectiveParticles()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "CalculateEffectiveParticles(const FGeometryDynamicCollection& DynamicCollection, int32 NumTransform, int32 MaxSimulatedLevel, bool bEnableClustering, const UObject* Owner, TBitArray<>& EffectiveParticles)"
  },
  {
    "label": "CreateGTParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateGTParticles(TManagedArray<Chaos::FImplicitObjectPtr>& Implicits, Chaos::FPBDRigidsEvolutionBase* Evolution, bool bInitializeRootOnly)"
  },
  {
    "label": "CreateChildrenGeometry_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateChildrenGeometry_External()"
  },
  {
    "label": "SyncParticles_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SyncParticles_External()"
  },
  {
    "label": "PullNonInterpolatableDataFromSinglePhysicsState()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PullNonInterpolatableDataFromSinglePhysicsState(const Chaos::FDirtyGeometryCollectionData& BufferData, bool bForcePullXRVW, const TBitArray<>* Seen)"
  },
  {
    "label": "GetOrCreateFieldData_Internal()",
    "kind": "Method",
    "detail": "Function (FSimulationParameters Parameters ; TArray<Chaos::FPhysicsObjectUniquePtr> PhysicsObjects ; FTransform WorldTransform_External ; FTransform PreviousWorldTransform_External ; int32 NumTransforms ; int32 NumEffectiveParticles ; int32 BaseParticleIndex ; float CollisionParticlesPerObjectFraction ; struct FFieldData { TArray<FFieldSystemCommand> Commands ; FFieldExecutionDatas ExecutionDatas ; } ; TUniquePtr<FFieldData> FieldData_Internal ; FFieldData&)",
    "insertText": "GetOrCreateFieldData_Internal()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (EReplicationMode ReplicationMode = EReplicationMode::Unknown ; uint8 bIsGameThreadWorldTransformDirty : 1 ; uint8 bHasBuiltGeometryOnPT : 1 ; uint8 bHasBuiltGeometryOnGT : 1 ; bool bIsInitializedOnPhysicsThread : 1 = false ; bool IsObjectDynamic : 1 ; bool IsObjectLoading : 1 ; bool IsObjectDeleting : 1 ; bool bSkipChildToParentUpdateWhenInClusterUnion : 1 ; TArray<FParticleHandle*> SolverClusterID ; TArray<FClusterHandle*> SolverClusterHandles ; TArray<FClusterHandle*> SolverParticleHandles ; TMap<FParticleHandle*,int32> HandleToTransformGroupIndex ; TMap<int32,FClusterHandle*> UniqueIdxToInternalClusterHandle ; TArray<Chaos::FUniqueIdx> UniqueIdxs ; TArray<int32> FromParticleToTransformIndex ; TArray<int32> FromTransformToParticleIndex ; TBitArray<> EffectiveParticles ; TArray<TUniquePtr<FParticle>> GTParticles ; struct FGTParticleIndices { int32 TransformGroupIndex = INDEX_NONE ; int32 InternalClusterUniqueId = INDEX_NONE ; } ; TMap<FParticle*,FGTParticleIndices> GTParticleToIndices ; TMap<int32,TArray<int32>> InternalClusterUniqueIdxToChildrenTransformIndices ; const FCollisionFilterData SimFilter ; const FCollisionFilterData QueryFilter ; FCreateTraceCollisionGeometryCallback CreateTraceCollisionGeometryCallback ; TFunction<)",
    "insertText": "void()"
  },
  {
    "label": "GetOrCreateErrorInterpolationData()",
    "kind": "Method",
    "detail": "Function (FGeometryDynamicCollection PhysicsThreadCollection ; FGeometryDynamicCollection& GameThreadCollection ; Chaos::FGuardedTripleBuffer<FGeometryCollectionResults> PhysToGameInterchange ; TUniquePtr<FProxyInterpolationBase> InterpolationData ; template<ErrorDataType> ErrorDataType*)",
    "insertText": "GetOrCreateErrorInterpolationData()"
  },
  {
    "label": "ErrorDataType()",
    "kind": "Method",
    "detail": "Function (InterpolationData = MakeUnique<)",
    "insertText": "ErrorDataType()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(InterpolationData.Get()->GetInterpolationType() != ErrorDataType::InterpolationType)"
  },
  {
    "label": "ErrorDataType()",
    "kind": "Method",
    "detail": "Function (InterpolationData = MakeUnique<)",
    "insertText": "ErrorDataType(InterpolationData.Get()->GetPullDataInterpIdx_External(), InterpolationData.Get()->GetInterpChannel_External())"
  },
  {
    "label": "ErrorDataType()",
    "kind": "Method",
    "detail": "Function (} return static_cast<)",
    "insertText": "ErrorDataType(InterpolationData.Get())"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} # if WITH_EDITORONLY_DATA FGuid CollectorGuid ; # endif } ; struct FDamageCollector { public : struct FDamageData { float DamageThreshold = 0 ; float MaxDamages = 0 ; bool bIsBroken = false ; } ; void)",
    "insertText": "Reset(int32 NumTransforms)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Num()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const FDamageData&)",
    "insertText": "operator(int32 TransformIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FDamageData DefaultDamageData ;)",
    "insertText": "if(DamageData.IsValidIndex(TransformIndex))"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (private : TArray<FDamageData> DamageData ; } ; struct FRuntimeDataCollector { public : void)",
    "insertText": "Clear()"
  },
  {
    "label": "AddCollector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCollector(const FGuid& Guid, int32 TransformNum)"
  },
  {
    "label": "RemoveCollector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveCollector(const FGuid& Guid)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (FDamageCollector*)",
    "insertText": "Find(const FGuid& Guid)"
  },
  {
    "label": "GetInstance()",
    "kind": "Method",
    "detail": "Function (FRuntimeDataCollector&)",
    "insertText": "GetInstance()"
  },
  {
    "label": "CreateTriangleMesh()",
    "kind": "Method",
    "detail": "Function (private : TMap<FGuid,FDamageCollector> Collectors ; } ; TUniquePtr<Chaos::FTriangleMesh>)",
    "insertText": "CreateTriangleMesh(const int32 FaceStart,const int32 FaceCount,const TManagedArray<bool>& Visible,const TManagedArray<FIntVector>& Indices, bool bRotateWinding = true)"
  },
  {
    "label": "BuildSimulationData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildSimulationData(Chaos::FErrorReporter& ErrorReporter, FGeometryCollection& GeometryCollection, const FSharedSimulationParameters& SharedParams)"
  }
]