[
  {
    "label": "EPhysicalSurface",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EPhysicalSurface"
  },
  {
    "label": "ERadialImpulseFalloff",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ERadialImpulseFalloff"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "EAngularConstraintMotion",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EAngularConstraintMotion"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "EConstraintPlasticityType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EConstraintPlasticityType"
  },
  {
    "label": "ELinearConstraintMotion",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ELinearConstraintMotion"
  },
  {
    "label": "FBVHParticles",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBVHParticles"
  },
  {
    "label": "TPBDRigidParticles",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPBDRigidParticles"
  },
  {
    "label": "FPerParticleGravity",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPerParticleGravity"
  },
  {
    "label": "FConvex",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConvex"
  },
  {
    "label": "FCapsule",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCapsule"
  },
  {
    "label": "TAABB",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TAABB"
  },
  {
    "label": "TBox",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBox"
  },
  {
    "label": "TSphere",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSphere"
  },
  {
    "label": "FConstraintBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConstraintBase"
  },
  {
    "label": "FJointConstraint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FJointConstraint"
  },
  {
    "label": "FSuspensionConstraint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSuspensionConstraint"
  },
  {
    "label": "FTriangleMeshImplicitObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTriangleMeshImplicitObject"
  },
  {
    "label": "FCollisionShape",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCollisionShape"
  },
  {
    "label": "UPhysicalMaterial",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPhysicalMaterial"
  },
  {
    "label": "FPhysicsAggregateReference_Chaos",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsAggregateReference_Chaos"
  },
  {
    "label": "FPhysicsConstraintReference_Chaos",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsConstraintReference_Chaos"
  },
  {
    "label": "FPhysicsShapeReference_Chaos",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsShapeReference_Chaos"
  },
  {
    "label": "FPhysicsShapeAdapter_Chaos",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsShapeAdapter_Chaos"
  },
  {
    "label": "FPhysicsGeometryCollection_Chaos",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPhysicsGeometryCollection_Chaos"
  },
  {
    "label": "FChaosEngineInterface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosEngineInterface"
  },
  {
    "label": "PxActor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PxActor"
  },
  {
    "label": "PxScene",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PxScene"
  },
  {
    "label": "PxSimulationEventCallback",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PxSimulationEventCallback"
  },
  {
    "label": "PxGeometry",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PxGeometry"
  },
  {
    "label": "PxTransform",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PxTransform"
  },
  {
    "label": "PxQuat",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PxQuat"
  },
  {
    "label": "PxMassProperties",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PxMassProperties"
  },
  {
    "label": "FContactModifyCallback",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FContactModifyCallback"
  },
  {
    "label": "ULineBatchComponent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ULineBatchComponent"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Chaos / Declares . h \" # include \" Chaos / PhysicsObject . h \" # include \" PhysicsInterfaceDeclaresCore . h \" # include \" PhysicsInterfaceWrapperShared . h \" # include \" PhysicsInterfaceTypesCore . h \" # include \" Chaos / Evolution / IterationSettings . h \" # include \" PhysicsProxy / SingleParticlePhysicsProxyFwd . h \" # include \" ChaosEngineInterface . generated . h \")",
    "insertText": "UENUM(BlueprintType)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (SurfaceType_Default)",
    "insertText": "UMETA(DisplayName=\"Default\"), SurfaceType1 UMETA(Hidden), SurfaceType2 UMETA(Hidden), SurfaceType3 UMETA(Hidden), SurfaceType4 UMETA(Hidden), SurfaceType5 UMETA(Hidden), SurfaceType6 UMETA(Hidden), SurfaceType7 UMETA(Hidden), SurfaceType8 UMETA(Hidden), SurfaceType9 UMETA(Hidden), SurfaceType10 UMETA(Hidden), SurfaceType11 UMETA(Hidden), SurfaceType12 UMETA(Hidden), SurfaceType13 UMETA(Hidden), SurfaceType14 UMETA(Hidden), SurfaceType15 UMETA(Hidden), SurfaceType16 UMETA(Hidden), SurfaceType17 UMETA(Hidden), SurfaceType18 UMETA(Hidden), SurfaceType19 UMETA(Hidden), SurfaceType20 UMETA(Hidden), SurfaceType21 UMETA(Hidden), SurfaceType22 UMETA(Hidden), SurfaceType23 UMETA(Hidden), SurfaceType24 UMETA(Hidden), SurfaceType25 UMETA(Hidden), SurfaceType26 UMETA(Hidden), SurfaceType27 UMETA(Hidden), SurfaceType28 UMETA(Hidden), SurfaceType29 UMETA(Hidden), SurfaceType30 UMETA(Hidden), SurfaceType31 UMETA(Hidden), SurfaceType32 UMETA(Hidden), SurfaceType33 UMETA(Hidden), SurfaceType34 UMETA(Hidden), SurfaceType35 UMETA(Hidden), SurfaceType36 UMETA(Hidden), SurfaceType37 UMETA(Hidden), SurfaceType38 UMETA(Hidden), SurfaceType39 UMETA(Hidden), SurfaceType40 UMETA(Hidden), SurfaceType41 UMETA(Hidden), SurfaceType42 UMETA(Hidden), SurfaceType43 UMETA(Hidden), SurfaceType44 UMETA(Hidden), SurfaceType45 UMETA(Hidden), SurfaceType46 UMETA(Hidden), SurfaceType47 UMETA(Hidden), SurfaceType48 UMETA(Hidden), SurfaceType49 UMETA(Hidden), SurfaceType50 UMETA(Hidden), SurfaceType51 UMETA(Hidden), SurfaceType52 UMETA(Hidden), SurfaceType53 UMETA(Hidden), SurfaceType54 UMETA(Hidden), SurfaceType55 UMETA(Hidden), SurfaceType56 UMETA(Hidden), SurfaceType57 UMETA(Hidden), SurfaceType58 UMETA(Hidden), SurfaceType59 UMETA(Hidden), SurfaceType60 UMETA(Hidden), SurfaceType61 UMETA(Hidden), SurfaceType62 UMETA(Hidden), SurfaceType_Max UMETA(Hidden)"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UENUM()"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (ACM_Free)",
    "insertText": "UMETA(DisplayName=\"Free\"), ACM_Limited UMETA(DisplayName=\"Limited\"), ACM_Locked UMETA(DisplayName=\"Locked\")"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (CCPT_Free)",
    "insertText": "UMETA(DisplayName = \"Free\"), CCPT_Shrink UMETA(DisplayName = \"Shrink\"), CCPT_Grow UMETA(DisplayName = \"Grow\")"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (LCM_Free)",
    "insertText": "UMETA(DisplayName=\"Free\"), LCM_Limited UMETA(DisplayName=\"Limited\"), LCM_Locked UMETA(DisplayName=\"Locked\")"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (typedef uint8 FMaskFilter ; namespace Chaos { class FBVHParticles ; template<T,int> class TPBDRigidParticles ; class FPerParticleGravity ; class FConvex ; class FCapsule ; template<T,int> class TAABB ; using FAABB3 = TAABB<FReal,3> ; template<T,int> class TBox ; template<T,int> class TSphere ; class FConstraintBase ; class FJointConstraint ; class FSuspensionConstraint ; class FTriangleMeshImplicitObject ; } struct FCollisionShape ; class UPhysicalMaterial ; class FPhysicsAggregateReference_Chaos { public : bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Chaos::FConstraintBase*)",
    "insertText": "operator()"
  },
  {
    "label": "FPhysicsShapeReference_Chaos()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FPhysicsShapeReference_Chaos(Chaos::FPerShapeData* ShapeIn, const FPhysicsActorHandle& ActorRefIn) : Shape(ShapeIn), ActorRef(ActorRefIn)"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Equals(const FPhysicsShapeReference_Chaos& Other)"
  },
  {
    "label": "GetGeometry()",
    "kind": "Method",
    "detail": "Function (} const Chaos::FImplicitObject&)",
    "insertText": "GetGeometry()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (Chaos::FPerShapeData* Shape ; FPhysicsActorHandle ActorRef ; uint32)",
    "insertText": "GetTypeHash(const FPhysicsShapeReference_Chaos& InShapeReference)"
  },
  {
    "label": "FPhysicsShapeAdapter_Chaos()",
    "kind": "Method",
    "detail": "Function (} } ; class FPhysicsShapeAdapter_Chaos { public :)",
    "insertText": "FPhysicsShapeAdapter_Chaos(const FQuat& Rot, const FCollisionShape& CollisionShape)"
  },
  {
    "label": "FPhysicsShapeAdapter_Chaos()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FPhysicsShapeAdapter_Chaos()"
  },
  {
    "label": "GetGeomPose()",
    "kind": "Method",
    "detail": "Function (FTransform)",
    "insertText": "GetGeomPose(const FVector& Pos)"
  },
  {
    "label": "GetGeomOrientation()",
    "kind": "Method",
    "detail": "Function (const FQuat&)",
    "insertText": "GetGeomOrientation()"
  },
  {
    "label": "FPhysicsGeometryCollection_Chaos()",
    "kind": "Method",
    "detail": "Function (private : TRefCountPtr<FPhysicsGeometry> Geometry ; FQuat GeometryRotation ; } ; struct FPhysicsGeometryCollection_Chaos {)",
    "insertText": "FPhysicsGeometryCollection_Chaos()"
  },
  {
    "label": "FPhysicsGeometryCollection_Chaos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPhysicsGeometryCollection_Chaos(const FPhysicsGeometryCollection_Chaos& Copy)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPhysicsGeometryCollection_Chaos&)",
    "insertText": "operator(const FPhysicsGeometryCollection_Chaos& Copy)"
  },
  {
    "label": "FPhysicsGeometryCollection_Chaos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPhysicsGeometryCollection_Chaos(FPhysicsGeometryCollection_Chaos&& Steal)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPhysicsGeometryCollection_Chaos&)",
    "insertText": "operator(FPhysicsGeometryCollection_Chaos&& Steal)"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (ECollisionShapeType)",
    "insertText": "GetType()"
  },
  {
    "label": "GetBoxGeometry()",
    "kind": "Method",
    "detail": "Function (const Chaos::TBox<Chaos::FReal,3>&)",
    "insertText": "GetBoxGeometry()"
  },
  {
    "label": "GetSphereGeometry()",
    "kind": "Method",
    "detail": "Function (const Chaos::TSphere<Chaos::FReal,3>&)",
    "insertText": "GetSphereGeometry()"
  },
  {
    "label": "GetCapsuleGeometry()",
    "kind": "Method",
    "detail": "Function (const Chaos::FCapsule&)",
    "insertText": "GetCapsuleGeometry()"
  },
  {
    "label": "GetConvexGeometry()",
    "kind": "Method",
    "detail": "Function (const Chaos::FConvex&)",
    "insertText": "GetConvexGeometry()"
  },
  {
    "label": "GetTriMeshGeometry()",
    "kind": "Method",
    "detail": "Function (const Chaos::FTriangleMeshImplicitObject&)",
    "insertText": "GetTriMeshGeometry()"
  },
  {
    "label": "FPhysicsGeometryCollection_Chaos()",
    "kind": "Method",
    "detail": "Function (private : class FChaosEngineInterface ;)",
    "insertText": "FPhysicsGeometryCollection_Chaos(const FPhysicsShapeReference_Chaos& InShape)"
  },
  {
    "label": "FPhysicsGeometryCollection_Chaos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPhysicsGeometryCollection_Chaos(const FPhysicsGeometry& InGeom)"
  },
  {
    "label": "FChaosEngineInterface()",
    "kind": "Method",
    "detail": "Function (const Chaos::FImplicitObject& Geom ; } ; namespace physx { class PxActor ; class PxScene ; class PxSimulationEventCallback ; class PxGeometry ; class PxTransform ; class PxQuat ; class PxMassProperties ; } struct FContactModifyCallback ; class ULineBatchComponent ; class FChaosEngineInterface { public : ~)",
    "insertText": "FChaosEngineInterface()"
  },
  {
    "label": "CreateActor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateActor(const FActorCreationParams& InParams,FPhysicsActorHandle& Handle)"
  },
  {
    "label": "ReleaseActor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseActor(FPhysicsActorHandle& InActorReference,FChaosScene* InScene = nullptr,bool bNeverDeferRelease=false)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValid(const FPhysicsActorHandle& Handle)"
  },
  {
    "label": "RemoveActorFromSolver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveActorFromSolver(FPhysicsActorHandle& Handle,Chaos::FPhysicsSolver* Solver)"
  },
  {
    "label": "SetGlobalPose_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetGlobalPose_AssumesLocked(const FPhysicsActorHandle& InActorReference,const FTransform& InNewPose,bool bAutoWake = true)"
  },
  {
    "label": "SetKinematicTarget_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetKinematicTarget_AssumesLocked(const FPhysicsActorHandle& InActorReference,const FTransform& InNewTarget)"
  },
  {
    "label": "GetCurrentScene()",
    "kind": "Method",
    "detail": "Function (FChaosScene*)",
    "insertText": "GetCurrentScene(const FPhysicsActorHandle& InHandle)"
  },
  {
    "label": "CreateMaterial()",
    "kind": "Method",
    "detail": "Function (FPhysicsMaterialHandle)",
    "insertText": "CreateMaterial(const UPhysicalMaterial* InMaterial)"
  },
  {
    "label": "UpdateMaterial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateMaterial(FPhysicsMaterialHandle& InHandle, UPhysicalMaterial* InMaterial)"
  },
  {
    "label": "ReleaseMaterial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseMaterial(FPhysicsMaterialHandle& InHandle)"
  },
  {
    "label": "SetUserData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetUserData(FPhysicsMaterialHandle& InHandle,void* InUserData)"
  },
  {
    "label": "ReleaseMaterialMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseMaterialMask(FPhysicsMaterialMaskHandle& InHandle)"
  },
  {
    "label": "CreateAggregate()",
    "kind": "Method",
    "detail": "Function (FPhysicsAggregateReference_Chaos)",
    "insertText": "CreateAggregate(int32 MaxBodies)"
  },
  {
    "label": "ReleaseAggregate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseAggregate(FPhysicsAggregateReference_Chaos& InAggregate)"
  },
  {
    "label": "GetNumActorsInAggregate()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumActorsInAggregate(const FPhysicsAggregateReference_Chaos& InAggregate)"
  },
  {
    "label": "AddActorToAggregate_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddActorToAggregate_AssumesLocked(const FPhysicsAggregateReference_Chaos& InAggregate,const FPhysicsActorHandle& InActor)"
  },
  {
    "label": "GetNumShapes()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumShapes(const FPhysicsActorHandle& InHandle)"
  },
  {
    "label": "ReleaseShape()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseShape(const FPhysicsShapeHandle& InShape)"
  },
  {
    "label": "AttachShape()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AttachShape(const FPhysicsActorHandle& InActor,const FPhysicsShapeHandle& InNewShape)"
  },
  {
    "label": "DetachShape()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DetachShape(const FPhysicsActorHandle& InActor,FPhysicsShapeHandle& InShape,bool bWakeTouching = true)"
  },
  {
    "label": "SetSmoothEdgeCollisionsEnabled_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSmoothEdgeCollisionsEnabled_AssumesLocked(const FPhysicsActorHandle& InActor, const bool bSmoothEdgeCollisionsEnabled)"
  },
  {
    "label": "AddDisabledCollisionsFor_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddDisabledCollisionsFor_AssumesLocked(const TMap<FPhysicsActorHandle, TArray< FPhysicsActorHandle > >& InMap)"
  },
  {
    "label": "RemoveDisabledCollisionsFor_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveDisabledCollisionsFor_AssumesLocked(TArray< FPhysicsActorHandle > & InPhysicsActors)"
  },
  {
    "label": "SetDisabled()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDisabled(const FPhysicsActorHandle& InPhysicsActor, bool bSetDisabled)"
  },
  {
    "label": "IsDisabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsDisabled(const FPhysicsActorHandle& InPhysicsActor)"
  },
  {
    "label": "SetActorUserData_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetActorUserData_AssumesLocked(FPhysicsActorHandle& InActorReference,FPhysicsUserData* InUserData)"
  },
  {
    "label": "IsRigidBody()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsRigidBody(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "IsDynamic()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsDynamic(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "IsStatic()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsStatic(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "IsKinematic()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsKinematic(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "IsKinematic_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsKinematic_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "IsSleeping()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSleeping(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "IsCcdEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsCcdEnabled(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "HasSyncSceneData()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasSyncSceneData(const FPhysicsActorHandle& InHandle)"
  },
  {
    "label": "GetAllShapes_AssumedLocked()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetAllShapes_AssumedLocked(const FPhysicsActorHandle& InActorHandle,TArray<FPhysicsShapeReference_Chaos,FDefaultAllocator>& OutShapes)"
  },
  {
    "label": "GetAllShapes_AssumedLocked()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetAllShapes_AssumedLocked(const FPhysicsActorHandle& InActorHandle,PhysicsInterfaceTypes::FInlineShapeArray& OutShapes)"
  },
  {
    "label": "CanSimulate_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanSimulate_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "GetMass_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetMass_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetSendsSleepNotifies_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSendsSleepNotifies_AssumesLocked(const FPhysicsActorHandle& InActorReference,bool bSendSleepNotifies)"
  },
  {
    "label": "PutToSleep_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PutToSleep_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "WakeUp_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WakeUp_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetIsKinematic_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetIsKinematic_AssumesLocked(const FPhysicsActorHandle& InActorReference,bool bIsKinematic)"
  },
  {
    "label": "SetCcdEnabled_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCcdEnabled_AssumesLocked(const FPhysicsActorHandle& InActorReference,bool bIsCcdEnabled)"
  },
  {
    "label": "SetMACDEnabled_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMACDEnabled_AssumesLocked(const FPhysicsActorHandle& InActorReference, bool bIsMACDEnabled)"
  },
  {
    "label": "SetPositionSolverIterationCount_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPositionSolverIterationCount_AssumesLocked(const FPhysicsActorHandle& InActorReference, uint8 PositionSolverIterationCount)"
  },
  {
    "label": "SetVelocitySolverIterationCount_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetVelocitySolverIterationCount_AssumesLocked(const FPhysicsActorHandle& InActorReference, uint8 VelocitySolverIterationCount)"
  },
  {
    "label": "SetProjectionSolverIterationCount_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetProjectionSolverIterationCount_AssumesLocked(const FPhysicsActorHandle& InActorReference, uint8 ProjectionSolverIterationCount)"
  },
  {
    "label": "SetIgnoreAnalyticCollisions_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetIgnoreAnalyticCollisions_AssumesLocked(const FPhysicsActorHandle& InActorReference,bool bIsCcdEnabled)"
  },
  {
    "label": "GetGlobalPose_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FTransform)",
    "insertText": "GetGlobalPose_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "GetTransform_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FTransform)",
    "insertText": "GetTransform_AssumesLocked(const FPhysicsActorHandle& InRef,bool bForceGlobalPose = false)"
  },
  {
    "label": "HasKinematicTarget_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasKinematicTarget_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "GetKinematicTarget_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FTransform)",
    "insertText": "GetKinematicTarget_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "GetLinearVelocity_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetLinearVelocity_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetLinearVelocity_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLinearVelocity_AssumesLocked(const FPhysicsActorHandle& InActorReference,const FVector& InNewVelocity,bool bAutoWake = true)"
  },
  {
    "label": "GetAngularVelocity_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetAngularVelocity_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetAngularVelocity_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAngularVelocity_AssumesLocked(const FPhysicsActorHandle& InActorReference,const FVector& InNewVelocity,bool bAutoWake = true)"
  },
  {
    "label": "GetMaxAngularVelocity_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetMaxAngularVelocity_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "GetMaxLinearVelocity_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetMaxLinearVelocity_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetMaxAngularVelocity_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaxAngularVelocity_AssumesLocked(const FPhysicsActorHandle& InActorReference,float InMaxAngularVelocityRadians)"
  },
  {
    "label": "SetMaxLinearVelocity_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaxLinearVelocity_AssumesLocked(const FPhysicsActorHandle& InActorReference, float InMaxLinearVelocity)"
  },
  {
    "label": "GetMaxDepenetrationVelocity_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetMaxDepenetrationVelocity_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetMaxDepenetrationVelocity_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaxDepenetrationVelocity_AssumesLocked(const FPhysicsActorHandle& InActorReference,float InMaxDepenetrationVelocity)"
  },
  {
    "label": "GetWorldVelocityAtPoint_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetWorldVelocityAtPoint_AssumesLocked(const FPhysicsActorHandle& InActorReference,const FVector& InPoint)"
  },
  {
    "label": "GetWorldVelocityAtPoint_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetWorldVelocityAtPoint_AssumesLocked(const Chaos::FRigidBodyHandle_Internal* InActorReference, const FVector& InPoint)"
  },
  {
    "label": "GetComTransform_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FTransform)",
    "insertText": "GetComTransform_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "GetComTransformLocal_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FTransform)",
    "insertText": "GetComTransformLocal_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "GetLocalInertiaTensor_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetLocalInertiaTensor_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "GetBounds_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FBox)",
    "insertText": "GetBounds_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "GetBounds_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FBox)",
    "insertText": "GetBounds_AssumesLocked(const FPhysicsActorHandle& InActorReference, const FTransform& InTransform)"
  },
  {
    "label": "GetBoundsLocal_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (FBox)",
    "insertText": "GetBoundsLocal_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetLinearDamping_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLinearDamping_AssumesLocked(const FPhysicsActorHandle& InActorReference,float InDamping)"
  },
  {
    "label": "SetAngularDamping_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAngularDamping_AssumesLocked(const FPhysicsActorHandle& InActorReference,float InDamping)"
  },
  {
    "label": "AddForce_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddForce_AssumesLocked(const FPhysicsActorHandle& InActorReference, const FVector& Force, bool bAllowSubstepping, bool bAccelChange, bool bIsInternal = false)"
  },
  {
    "label": "AddForceAtPosition_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddForceAtPosition_AssumesLocked(const FPhysicsActorHandle& InActorReference, const FVector& Force, const FVector& Position, bool bAllowSubstepping, bool bIsLocalForce = false, bool bIsInternal = false)"
  },
  {
    "label": "AddRadialForce_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRadialForce_AssumesLocked(const FPhysicsActorHandle& InActorReference, const FVector& Origin, const float Radius, const float Strength, const uint8 Falloff, bool bAccelChange, bool bAllowSubstepping, bool bIsInternal = false)"
  },
  {
    "label": "AddTorque_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTorque_AssumesLocked(const FPhysicsActorHandle& InActorReference, const FVector& Torque, bool bAllowSubstepping, bool bAccelChange, bool bIsInternal = false)"
  },
  {
    "label": "AddImpulse_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddImpulse_AssumesLocked(const FPhysicsActorHandle& InActorReference,const FVector& InForce, bool bIsInternal = false)"
  },
  {
    "label": "AddAngularImpulseInRadians_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAngularImpulseInRadians_AssumesLocked(const FPhysicsActorHandle& InActorReference,const FVector& InTorque, bool bIsInternal = false)"
  },
  {
    "label": "AddVelocity_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddVelocity_AssumesLocked(const FPhysicsActorHandle& InActorReference,const FVector& InForce, bool bIsInternal = false)"
  },
  {
    "label": "AddAngularVelocityInRadians_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAngularVelocityInRadians_AssumesLocked(const FPhysicsActorHandle& InActorReference,const FVector& InTorque, bool bIsInternal = false)"
  },
  {
    "label": "AddImpulseAtLocation_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddImpulseAtLocation_AssumesLocked(const FPhysicsActorHandle& InActorReference,const FVector& InImpulse,const FVector& InLocation, bool bIsInternal = false)"
  },
  {
    "label": "AddVelocityChangeImpulseAtLocation_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddVelocityChangeImpulseAtLocation_AssumesLocked(const FPhysicsActorHandle& InActorReference, const FVector& InVelocityDelta, const FVector& InLocation, bool bIsInternal = false)"
  },
  {
    "label": "AddRadialImpulse_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRadialImpulse_AssumesLocked(const FPhysicsActorHandle& InActorReference,const FVector& InOrigin,float InRadius,float InStrength,ERadialImpulseFalloff InFalloff,bool bInVelChange, bool bIsInternal = false)"
  },
  {
    "label": "IsGravityEnabled_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsGravityEnabled_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetGravityEnabled_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetGravityEnabled_AssumesLocked(const FPhysicsActorHandle& InActorReference,bool bEnabled)"
  },
  {
    "label": "GetGravityGroupIndex_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetGravityGroupIndex_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetGravityGroupIndex_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetGravityGroupIndex_AssumesLocked(const FPhysicsActorHandle& InActorReference, uint32 Index)"
  },
  {
    "label": "GetUpdateKinematicFromSimulation_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetUpdateKinematicFromSimulation_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetUpdateKinematicFromSimulation_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetUpdateKinematicFromSimulation_AssumesLocked(const FPhysicsActorHandle& InActorReference, bool bUpdateKinematicFromSimulation)"
  },
  {
    "label": "SetOneWayInteraction_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOneWayInteraction_AssumesLocked(const FPhysicsActorHandle& InHandle, bool InOneWayInteraction)"
  },
  {
    "label": "GetSleepEnergyThreshold_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetSleepEnergyThreshold_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetSleepEnergyThreshold_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSleepEnergyThreshold_AssumesLocked(const FPhysicsActorHandle& InActorReference, float InEnergyThreshold)"
  },
  {
    "label": "SetSleepThresholdMultiplier_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSleepThresholdMultiplier_AssumesLocked(const FPhysicsActorHandle& InActorReference, float ThresholdMultiplier)"
  },
  {
    "label": "SetMass_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMass_AssumesLocked(FPhysicsActorHandle& InHandle,float InMass)"
  },
  {
    "label": "SetMassSpaceInertiaTensor_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMassSpaceInertiaTensor_AssumesLocked(FPhysicsActorHandle& InHandle,const FVector& InTensor)"
  },
  {
    "label": "SetComLocalPose_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetComLocalPose_AssumesLocked(const FPhysicsActorHandle& InHandle,const FTransform& InComLocalPose)"
  },
  {
    "label": "IsInertiaConditioningEnabled_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsInertiaConditioningEnabled_AssumesLocked(const FPhysicsActorHandle& InActorReference)"
  },
  {
    "label": "SetInertiaConditioningEnabled_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetInertiaConditioningEnabled_AssumesLocked(const FPhysicsActorHandle& InActorReference, bool bEnabled)"
  },
  {
    "label": "GetStabilizationEnergyThreshold_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetStabilizationEnergyThreshold_AssumesLocked(const FPhysicsActorHandle& InHandle)"
  },
  {
    "label": "SetStabilizationEnergyThreshold_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetStabilizationEnergyThreshold_AssumesLocked(const FPhysicsActorHandle& InHandle,float InThreshold)"
  },
  {
    "label": "SetSolverPositionIterationCount_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSolverPositionIterationCount_AssumesLocked(const FPhysicsActorHandle& InHandle,uint32 InSolverIterationCount)"
  },
  {
    "label": "SetSolverVelocityIterationCount_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSolverVelocityIterationCount_AssumesLocked(const FPhysicsActorHandle& InHandle,uint32 InSolverIterationCount)"
  },
  {
    "label": "SetSolverProjectionIterationCount_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSolverProjectionIterationCount_AssumesLocked(const FPhysicsActorHandle& InHandle, uint32 InSolverIterationCount)"
  },
  {
    "label": "GetWakeCounter_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetWakeCounter_AssumesLocked(const FPhysicsActorHandle& InHandle)"
  },
  {
    "label": "SetWakeCounter_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetWakeCounter_AssumesLocked(const FPhysicsActorHandle& InHandle,float InWakeCounter)"
  },
  {
    "label": "SetInitialized_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetInitialized_AssumesLocked(const FPhysicsActorHandle& InHandle,bool InInitialized)"
  },
  {
    "label": "GetResourceSizeEx()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetResourceSizeEx(const FPhysicsActorHandle& InActorRef)"
  },
  {
    "label": "CreateConstraint()",
    "kind": "Method",
    "detail": "Function (FPhysicsConstraintHandle)",
    "insertText": "CreateConstraint(Chaos::FPhysicsObject* Body1, Chaos::FPhysicsObject* Body2, const FTransform& InLocalFrame1, const FTransform& InLocalFrame2)"
  },
  {
    "label": "CreateConstraint()",
    "kind": "Method",
    "detail": "Function (FPhysicsConstraintHandle)",
    "insertText": "CreateConstraint(const FPhysicsActorHandle& InActorRef1,const FPhysicsActorHandle& InActorRef2,const FTransform& InLocalFrame1,const FTransform& InLocalFrame2)"
  },
  {
    "label": "CreateSuspension()",
    "kind": "Method",
    "detail": "Function (FPhysicsConstraintHandle)",
    "insertText": "CreateSuspension(Chaos::FPhysicsObject* Body, const FVector& InLocalFrame)"
  },
  {
    "label": "CreateSuspension()",
    "kind": "Method",
    "detail": "Function (FPhysicsConstraintHandle)",
    "insertText": "CreateSuspension(const FPhysicsActorHandle& InActorRef, const FVector& InLocalFrame)"
  },
  {
    "label": "SetConstraintUserData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetConstraintUserData(const FPhysicsConstraintHandle& InConstraintRef,void* InUserData)"
  },
  {
    "label": "ReleaseConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseConstraint(FPhysicsConstraintHandle& InConstraintRef)"
  },
  {
    "label": "GetLocalPose()",
    "kind": "Method",
    "detail": "Function (FTransform)",
    "insertText": "GetLocalPose(const FPhysicsConstraintHandle& InConstraintRef,EConstraintFrame::Type InFrame)"
  },
  {
    "label": "GetGlobalPose()",
    "kind": "Method",
    "detail": "Function (FTransform)",
    "insertText": "GetGlobalPose(const FPhysicsConstraintHandle& InConstraintRef,EConstraintFrame::Type InFrame)"
  },
  {
    "label": "GetLocation()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetLocation(const FPhysicsConstraintHandle& InConstraintRef)"
  },
  {
    "label": "GetForce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetForce(const FPhysicsConstraintHandle& InConstraintRef,FVector& OutLinForce,FVector& OutAngForce)"
  },
  {
    "label": "GetDriveLinearVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetDriveLinearVelocity(const FPhysicsConstraintHandle& InConstraintRef,FVector& OutLinVelocity)"
  },
  {
    "label": "GetDriveAngularVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetDriveAngularVelocity(const FPhysicsConstraintHandle& InConstraintRef,FVector& OutAngVelocity)"
  },
  {
    "label": "GetCurrentSwing1()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetCurrentSwing1(const FPhysicsConstraintHandle& InConstraintRef)"
  },
  {
    "label": "GetCurrentSwing2()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetCurrentSwing2(const FPhysicsConstraintHandle& InConstraintRef)"
  },
  {
    "label": "GetCurrentTwist()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetCurrentTwist(const FPhysicsConstraintHandle& InConstraintRef)"
  },
  {
    "label": "SetCanVisualize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCanVisualize(const FPhysicsConstraintHandle& InConstraintRef,bool bInCanVisualize)"
  },
  {
    "label": "SetCollisionEnabled()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCollisionEnabled(const FPhysicsConstraintHandle& InConstraintRef,bool bInCollisionEnabled)"
  },
  {
    "label": "SetProjectionEnabled_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetProjectionEnabled_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef,bool bInProjectionEnabled,float InLinearAlpha = 1.0f,float InAngularAlpha = 0.0f, float InLinearTolerance = 0.0f, float InAngularToleranceDeg = 0.0f)"
  },
  {
    "label": "SetShockPropagationEnabled_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetShockPropagationEnabled_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, bool bInShockPropagationEnabled, float InShockPropagationAlpha)"
  },
  {
    "label": "SetParentDominates_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetParentDominates_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, bool bInParentDominates)"
  },
  {
    "label": "SetMassConditioningEnabled_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMassConditioningEnabled_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, bool bInMassConditioningEnabled)"
  },
  {
    "label": "SetBreakForces_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetBreakForces_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef,float InLinearBreakForce,float InAngularBreakForce)"
  },
  {
    "label": "SetViolationCallbackThresholds_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetViolationCallbackThresholds_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef,float InLinearBreakViolation,float InAngularBreakViolation)"
  },
  {
    "label": "SetPlasticityLimits_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPlasticityLimits_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, float InLinearPlasticityLimit, float InAngularPlasticityLimit, EConstraintPlasticityType InLinearPlasticityType)"
  },
  {
    "label": "SetContactTransferScale_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetContactTransferScale_AssumesLocked(const FPhysicsConstraintHandle& InConstraintRef, float InContactTransferScale)"
  },
  {
    "label": "SetLocalPose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLocalPose(const FPhysicsConstraintHandle& InConstraintRef, const FTransform& InPose, EConstraintFrame::Type InFrame)"
  },
  {
    "label": "SetDrivePosition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDrivePosition(const FPhysicsConstraintHandle& InConstraintRef,const FVector& InPosition)"
  },
  {
    "label": "SetDriveOrientation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDriveOrientation(const FPhysicsConstraintHandle& InConstraintRef,const FQuat& InOrientation)"
  },
  {
    "label": "SetDriveLinearVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDriveLinearVelocity(const FPhysicsConstraintHandle& InConstraintRef,const FVector& InLinVelocity)"
  },
  {
    "label": "SetDriveAngularVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDriveAngularVelocity(const FPhysicsConstraintHandle& InConstraintRef,const FVector& InAngVelocity)"
  },
  {
    "label": "SetTwistLimit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTwistLimit(const FPhysicsConstraintHandle& InConstraintRef,float InLowerLimit,float InUpperLimit,float InContactDistance)"
  },
  {
    "label": "SetSwingLimit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSwingLimit(const FPhysicsConstraintHandle& InConstraintRef,float InYLimit,float InZLimit,float InContactDistance)"
  },
  {
    "label": "SetLinearLimit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLinearLimit(const FPhysicsConstraintHandle& InConstraintRef,float InLimit)"
  },
  {
    "label": "IsBroken()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsBroken(const FPhysicsConstraintHandle& InConstraintRef)"
  },
  {
    "label": "SetGeometry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetGeometry(FPhysicsShapeHandle& InShape, Chaos::FImplicitObjectPtr&& InGeometry)"
  },
  {
    "label": "GetSimulationFilter()",
    "kind": "Method",
    "detail": "Function (} FCollisionFilterData)",
    "insertText": "GetSimulationFilter(const FPhysicsShapeHandle& InShape)"
  },
  {
    "label": "GetQueryFilter()",
    "kind": "Method",
    "detail": "Function (FCollisionFilterData)",
    "insertText": "GetQueryFilter(const FPhysicsShapeHandle& InShape)"
  },
  {
    "label": "IsSimulationShape()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSimulationShape(const FPhysicsShapeHandle& InShape)"
  },
  {
    "label": "IsQueryShape()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsQueryShape(const FPhysicsShapeHandle& InShape)"
  },
  {
    "label": "GetShapeType()",
    "kind": "Method",
    "detail": "Function (ECollisionShapeType)",
    "insertText": "GetShapeType(const FPhysicsShapeHandle& InShape)"
  },
  {
    "label": "GetLocalTransform()",
    "kind": "Method",
    "detail": "Function (FTransform)",
    "insertText": "GetLocalTransform(const FPhysicsShapeHandle& InShape)"
  },
  {
    "label": "GetUserData()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "GetUserData(const FPhysicsShapeHandle& InShape)"
  },
  {
    "label": "SetUserData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetUserData(const FPhysicsShapeHandle& InShape, void* InUserData)"
  },
  {
    "label": "CloneShape()",
    "kind": "Method",
    "detail": "Function (FPhysicsShapeHandle)",
    "insertText": "CloneShape(const FPhysicsShapeHandle& InShape)"
  },
  {
    "label": "GetGeometryCollection()",
    "kind": "Method",
    "detail": "Function (FPhysicsGeometryCollection_Chaos)",
    "insertText": "GetGeometryCollection(const FPhysicsShapeHandle& InShape)"
  },
  {
    "label": "GetGeometryCollection()",
    "kind": "Method",
    "detail": "Function (FPhysicsGeometryCollection_Chaos)",
    "insertText": "GetGeometryCollection(const FPhysicsGeometry& InShape)"
  },
  {
    "label": "SetMaskFilter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaskFilter(const FPhysicsShapeHandle& InShape,FMaskFilter InFilter)"
  },
  {
    "label": "SetSimulationFilter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSimulationFilter(const FPhysicsShapeHandle& InShape,const FCollisionFilterData& InFilter)"
  },
  {
    "label": "SetQueryFilter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetQueryFilter(const FPhysicsShapeHandle& InShape,const FCollisionFilterData& InFilter)"
  },
  {
    "label": "SetIsSimulationShape()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetIsSimulationShape(const FPhysicsShapeHandle& InShape,bool bIsSimShape)"
  },
  {
    "label": "SetIsProbeShape()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetIsProbeShape(const FPhysicsShapeHandle& InShape,bool bIsProbeShape)"
  },
  {
    "label": "SetIsQueryShape()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetIsQueryShape(const FPhysicsShapeHandle& InShape,bool bIsQueryShape)"
  },
  {
    "label": "SetLocalTransform()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLocalTransform(const FPhysicsShapeHandle& InShape,const FTransform& NewLocalTransform)"
  }
]