[
  {
    "label": "CompressedStorage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CompressedStorage"
  },
  {
    "label": "CompressedStorage()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_COMPRESSED_STORAGE_H # define EIGEN_COMPRESSED_STORAGE_H namespace Eigen { namespace internal { template<_Scalar,_StorageIndex> class CompressedStorage { public : typedef _Scalar Scalar ; typedef _StorageIndex StorageIndex ; protected : typedef NumTraits<Scalar>::Real RealScalar ; public :)",
    "insertText": "CompressedStorage() : m_values(0), m_indices(0), m_size(0), m_allocatedSize(0)"
  },
  {
    "label": "CompressedStorage()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CompressedStorage(Index size) : m_values(0), m_indices(0), m_size(0), m_allocatedSize(0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(size)"
  },
  {
    "label": "CompressedStorage()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CompressedStorage(const CompressedStorage& other) : m_values(0), m_indices(0), m_size(0), m_allocatedSize(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (* this = other ; } CompressedStorage&)",
    "insertText": "operator(const CompressedStorage& other)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(other.size())"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(other.m_values, other.m_values + m_size, m_values)"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(other.m_indices, other.m_indices + m_size, m_indices)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} return* this ; } void)",
    "insertText": "swap(CompressedStorage& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_values, other.m_values)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_indices, other.m_indices)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_size, other.m_size)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_allocatedSize, other.m_allocatedSize)"
  },
  {
    "label": "CompressedStorage()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "CompressedStorage()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (delete [ ] m_values ; delete [ ] m_indices ; } void)",
    "insertText": "reserve(Index size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index newAllocatedSize = m_size + size ;)",
    "insertText": "if(newAllocatedSize > m_allocatedSize) reallocate(newAllocatedSize)"
  },
  {
    "label": "squeeze()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "squeeze()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resize(Index size, double reserveSizeFactor = 0)"
  },
  {
    "label": "realloc_size()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "realloc_size(std::min<Index>)(NumTraits<StorageIndex>::highest(), size + Index(reserveSizeFactor*double(size)))"
  },
  {
    "label": "reallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reallocate(realloc_size)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (} m_size = size ; } void)",
    "insertText": "append(const Scalar& v, Index i)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (Index id = m_size ;)",
    "insertText": "resize(m_size+1, 1)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (m_values [ id ] = v ; m_indices [ id ] = internal::convert_index<)",
    "insertText": "StorageIndex(i)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "size()"
  },
  {
    "label": "valuePtr()",
    "kind": "Method",
    "detail": "Function (m_size = 0 ; } const Scalar*)",
    "insertText": "valuePtr()"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(m_values!=0)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(m_indices!=0)"
  },
  {
    "label": "searchLowerIndex()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "searchLowerIndex(Index start, Index end, Index key)"
  },
  {
    "label": "mid()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "mid(end+start)"
  },
  {
    "label": "searchLowerIndex()",
    "kind": "Method",
    "detail": "Function (const Index id =)",
    "insertText": "searchLowerIndex(0,m_size-1,key)"
  },
  {
    "label": "atInRange()",
    "kind": "Method",
    "detail": "Function (} Scalar)",
    "insertText": "atInRange(Index start, Index end, Index key, const Scalar &defaultValue = Scalar(0))"
  },
  {
    "label": "searchLowerIndex()",
    "kind": "Method",
    "detail": "Function (const Index id =)",
    "insertText": "searchLowerIndex(start,end-1,key)"
  },
  {
    "label": "atWithInsertion()",
    "kind": "Method",
    "detail": "Function (} Scalar&)",
    "insertText": "atWithInsertion(Index key, const Scalar& defaultValue = Scalar(0))"
  },
  {
    "label": "searchLowerIndex()",
    "kind": "Method",
    "detail": "Function (Index id =)",
    "insertText": "searchLowerIndex(0,m_size,key)"
  },
  {
    "label": "m_allocatedSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_allocatedSize(m_size+1)"
  },
  {
    "label": "newValues()",
    "kind": "Method",
    "detail": "Function (internal::scoped_array<Scalar>)",
    "insertText": "newValues(m_allocatedSize)"
  },
  {
    "label": "newIndices()",
    "kind": "Method",
    "detail": "Function (internal::scoped_array<StorageIndex>)",
    "insertText": "newIndices(m_allocatedSize)"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(m_values, m_values +id, newValues.ptr())"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(m_indices, m_indices+id, newIndices.ptr())"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(m_values +id, m_values +m_size, newValues.ptr() +id+1)"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(m_indices+id, m_indices+m_size, newIndices.ptr()+id+1)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "swap(m_values,newValues.ptr())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_indices,newIndices.ptr())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(m_size>id)"
  },
  {
    "label": "smart_memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_memmove(m_values +id, m_values +m_size, m_values +id+1)"
  },
  {
    "label": "smart_memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_memmove(m_indices+id, m_indices+m_size, m_indices+id+1)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (} m_size + + ; m_indices [ id ] = internal::convert_index<)",
    "insertText": "StorageIndex(key)"
  },
  {
    "label": "moveChunk()",
    "kind": "Method",
    "detail": "Function (m_values [ id ] = defaultValue ; } return m_values [ id ] ; } void)",
    "insertText": "moveChunk(Index from, Index to, Index chunkSize)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(to+chunkSize <= m_size)"
  },
  {
    "label": "smart_memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_memmove(m_values+from, m_values+from+chunkSize, m_values+to)"
  },
  {
    "label": "smart_memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_memmove(m_indices+from, m_indices+from+chunkSize, m_indices+to)"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "smart_copy(m_values+from, m_values+from+chunkSize, m_values+to)"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(m_indices+from, m_indices+from+chunkSize, m_indices+to)"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "value(k) = value(i)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "index(k) = index(i)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (+ + k ; } })",
    "insertText": "resize(k,0)"
  },
  {
    "label": "reallocate()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "reallocate(Index size)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_SPARSE_COMPRESSED_STORAGE_REALLOCATE_PLUGIN EIGEN_SPARSE_COMPRESSED_STORAGE_REALLOCATE_PLUGIN # endif)",
    "insertText": "eigen_internal_assert(size!=m_allocatedSize)"
  },
  {
    "label": "newValues()",
    "kind": "Method",
    "detail": "Function (internal::scoped_array<Scalar>)",
    "insertText": "newValues(size)"
  },
  {
    "label": "newIndices()",
    "kind": "Method",
    "detail": "Function (internal::scoped_array<StorageIndex>)",
    "insertText": "newIndices(size)"
  },
  {
    "label": "copySize()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "copySize(std::min)(size, m_size)"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(m_values, m_values+copySize, newValues.ptr())"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(m_indices, m_indices+copySize, newIndices.ptr())"
  }
]