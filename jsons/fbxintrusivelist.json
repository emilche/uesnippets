[
  {
    "label": "FbxListNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FbxListNode"
  },
  {
    "label": "FbxIntrusiveList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FbxIntrusiveList"
  },
  {
    "label": "IntrusiveListIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IntrusiveListIterator"
  },
  {
    "label": "IntrusiveListConstIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IntrusiveListConstIterator"
  },
  {
    "label": "FBXSDK_INTRUSIVE_LIST_NODE()",
    "kind": "Method",
    "detail": "Function (# ifndef _FBXSDK_CORE_BASE_INTRUSIVE_LIST_H_ # define _FBXSDK_CORE_BASE_INTRUSIVE_LIST_H_ # include<fbxsdk / fbxsdk_def . h> # include<fbxsdk / fbxsdk_nsbegin . h> # ifndef DOXYGEN_SHOULD_SKIP_THIS # define)",
    "insertText": "FBXSDK_INTRUSIVE_LIST_NODE(Class, NodeCount)\\ public: inline FbxListNode<Class>& GetListNode(int index = 0)"
  },
  {
    "label": "FbxListNode()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FbxListNode()"
  },
  {
    "label": "Disconnect()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Disconnect()"
  },
  {
    "label": "FbxIntrusiveList()",
    "kind": "Method",
    "detail": "Function (mPrev = mNext = 0 ; } NodeT* mNext ; NodeT* mPrev ; T* mData ; } ; template<T,int NodeIndex = 0> class FbxIntrusiveList { public : typedef T allocator_type ; typedef T value_type ; typedef T& reference ; typedef const T& const_reference ; typedef T* pointer ; typedef const T* const_pointer ; typedef FbxListNode<T> NodeT ;)",
    "insertText": "FbxIntrusiveList():mHead(0)"
  },
  {
    "label": "FbxIntrusiveList()",
    "kind": "Method",
    "detail": "Function (mHead . mNext = mHead . mPrev =& mHead ; } ~)",
    "insertText": "FbxIntrusiveList()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} ; bool)",
    "insertText": "Empty()"
  },
  {
    "label": "PushBack()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PushBack(T& pElement)"
  },
  {
    "label": "GetListNode()",
    "kind": "Method",
    "detail": "Function (NodeT* pNode =& pElement .)",
    "insertText": "GetListNode(NodeIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pNode -> mData =& pElement ;)",
    "insertText": "if(Empty())"
  },
  {
    "label": "PushFront()",
    "kind": "Method",
    "detail": "Function (pNode -> mNext =& mHead ; pNode -> mPrev =& mHead ; mHead . mNext = pNode ; mHead . mPrev = pNode ; } else { pNode -> mNext =& mHead ; pNode -> mPrev = mHead . mPrev ; pNode -> mPrev -> mNext = pNode ; mHead . mPrev = pNode ; } } void)",
    "insertText": "PushFront(T& pElement)"
  },
  {
    "label": "PopFront()",
    "kind": "Method",
    "detail": "Function (pNode -> mNext =& mHead ; pNode -> mPrev =& mHead ; mHead . mNext = pNode ; mHead . mPrev = pNode ; } else { pNode -> mNext = mHead . mNext ; pNode -> mPrev =& mHead ; pNode -> mNext -> mPrev = pNode ; mHead . mNext = pNode ; } } void)",
    "insertText": "PopFront()"
  },
  {
    "label": "Begin()",
    "kind": "Method",
    "detail": "Function (iterator begin =)",
    "insertText": "Begin()"
  },
  {
    "label": "Erase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Erase(begin)"
  },
  {
    "label": "PopBack()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PopBack()"
  },
  {
    "label": "Erase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Erase(--(End()))"
  },
  {
    "label": "IntrusiveListIterator()",
    "kind": "Method",
    "detail": "Function (} public : class IntrusiveListIterator { public :)",
    "insertText": "IntrusiveListIterator(NodeT* ptr=0):mPtr(ptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} IntrusiveListIterator&)",
    "insertText": "operator()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (mPtr = mPtr -> mNext ;)",
    "insertText": "return(*this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const IntrusiveListIterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (IntrusiveListIterator temp =* this ; + +* this ;)",
    "insertText": "return(temp)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} IntrusiveListIterator&)",
    "insertText": "operator(const IntrusiveListIterator &other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const IntrusiveListIterator& other)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} NodeT*)",
    "insertText": "Get()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} IntrusiveListConstIterator&)",
    "insertText": "operator(const IntrusiveListConstIterator &other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const IntrusiveListConstIterator& other)"
  },
  {
    "label": "End()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "End()"
  },
  {
    "label": "Front()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "Front()"
  },
  {
    "label": "Back()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "Back()"
  },
  {
    "label": "Erase()",
    "kind": "Method",
    "detail": "Function (} iterator&)",
    "insertText": "Erase(iterator& it)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (it .)",
    "insertText": "Get()->Disconnect()"
  },
  {
    "label": "FbxIntrusiveList()",
    "kind": "Method",
    "detail": "Function (} private : NodeT mHead ;)",
    "insertText": "FbxIntrusiveList(const FbxIntrusiveList&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FbxIntrusiveList&)",
    "insertText": "operator(const FbxIntrusiveList& Right)"
  }
]