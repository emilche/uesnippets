[
  {
    "label": "MaxSizeVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaxSizeVector"
  },
  {
    "label": "X",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "X"
  },
  {
    "label": "EIGEN_PLAIN_ENUM_MAX()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_FIXEDSIZEVECTOR_H # define EIGEN_FIXEDSIZEVECTOR_H namespace Eigen { template<T> class MaxSizeVector { const size_t alignment =)",
    "insertText": "EIGEN_PLAIN_ENUM_MAX(EIGEN_ALIGNOF(T), sizeof(void*))"
  },
  {
    "label": "MaxSizeVector()",
    "kind": "Method",
    "detail": "Function (public : EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "MaxSizeVector(size_t n) : reserve_(n), size_(0), data_(static_cast<T*>(internal::handmade_aligned_malloc(n * sizeof(T), alignment)))"
  },
  {
    "label": "MaxSizeVector()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "MaxSizeVector(size_t n, const T& init) : reserve_(n), size_(n), data_(static_cast<T*>(internal::handmade_aligned_malloc(n * sizeof(T), alignment)))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t i = 0 ; EIGEN_TRY {)",
    "insertText": "for(; i < size_; ++i)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&data_[i]) T(init)"
  },
  {
    "label": "EIGEN_CATCH()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "EIGEN_CATCH(...)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (data_ [ i - 1 ] . ~)",
    "insertText": "T()"
  },
  {
    "label": "handmade_aligned_free()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "handmade_aligned_free(data_)"
  },
  {
    "label": "MaxSizeVector()",
    "kind": "Method",
    "detail": "Function (EIGEN_THROW ; } } EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~)",
    "insertText": "MaxSizeVector()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resize(size_t n)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(n <= reserve_)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&data_[size_])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(; size_ > n; --size_)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "eigen_assert(size_ == n)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "push_back(const T& t)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(size_ < reserve_)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&data_[size_++]) T(t)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (} template<class X> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "emplace_back(const X& x)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&data_[size_++]) T(x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const T&)",
    "insertText": "operator(size_t i)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(i < size_)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(size_ > 0)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE size_t)",
    "insertText": "size()"
  }
]