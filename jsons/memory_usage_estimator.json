[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "C",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "C"
  },
  {
    "label": "A",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "A"
  },
  {
    "label": "D",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "D"
  },
  {
    "label": "F",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "F"
  },
  {
    "label": "S",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "S"
  },
  {
    "label": "K",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "K"
  },
  {
    "label": "V",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "V"
  },
  {
    "label": "H",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "H"
  },
  {
    "label": "KE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "KE"
  },
  {
    "label": "X",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "X"
  },
  {
    "label": "HasEMU",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HasEMU"
  },
  {
    "label": "EMUCaller",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EMUCaller"
  },
  {
    "label": "Container",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Container"
  },
  {
    "label": "I",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "I"
  },
  {
    "label": "IsComplexIteratorForContainer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsComplexIteratorForContainer"
  },
  {
    "label": "SharedPointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SharedPointer"
  },
  {
    "label": "Node",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Node"
  },
  {
    "label": "LruCacheType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LruCacheType"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TRACE_EVENT_MEMORY_USAGE_ESTIMATOR_H_ # define BASE_TRACE_EVENT_MEMORY_USAGE_ESTIMATOR_H_ # include<stdint . h> # include<array> # include<deque> # include<list> # include<map> # include<memory> # include<queue> # include<set> # include<stack> # include<string> # include<type_traits> # include<unordered_map> # include<unordered_set> # include<vector> # include \" base / base_export . h \" # include \" base / containers / circular_deque . h \" # include \" base / containers / flat_map . h \" # include \" base / containers / flat_set . h \" # include \" base / containers / linked_list . h \" # include \" base / containers / lru_cache . h \" # include \" base / containers / queue . h \" # include \" base / memory / raw_ptr . h \" # include \" base / stl_util . h \" # include \" base / template_util . h \" namespace base { namespace trace_event { template<class T> auto)",
    "insertText": "EstimateMemoryUsage(const T& object) -> decltype(object.EstimateMemoryUsage())"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class C,class T,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::basic_string<C, T, A>& string)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,size_t N> size_t)",
    "insertText": "EstimateMemoryUsage(const std::array<T, N>& array)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,size_t N> size_t)",
    "insertText": "EstimateMemoryUsage(T (&array)[N])"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T> size_t)",
    "insertText": "EstimateMemoryUsage(const T* array, size_t array_length)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class D> size_t)",
    "insertText": "EstimateMemoryUsage(const std::unique_ptr<T, D>& ptr)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class D> size_t)",
    "insertText": "EstimateMemoryUsage(const std::unique_ptr<T[], D>& array, size_t array_length)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T> size_t)",
    "insertText": "EstimateMemoryUsage(const std::shared_ptr<T>& ptr)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class F,class S> size_t)",
    "insertText": "EstimateMemoryUsage(const std::pair<F, S>& pair)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::vector<T, A>& vector)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::list<T, A>& list)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T> size_t)",
    "insertText": "EstimateMemoryUsage(const base::LinkedList<T>& list)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class C,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::set<T, C, A>& set)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class C,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::multiset<T, C, A>& set)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class K,class V,class C,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::map<K, V, C, A>& map)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class K,class V,class C,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::multimap<K, V, C, A>& map)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class H,class KE,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::unordered_set<T, H, KE, A>& set)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class H,class KE,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::unordered_multiset<T, H, KE, A>& set)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class K,class V,class H,class KE,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::unordered_map<K, V, H, KE, A>& map)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class K,class V,class H,class KE,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::unordered_multimap<K, V, H, KE, A>& map)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::deque<T, A>& deque)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const std::queue<T, C>& queue)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const std::priority_queue<T, C>& queue)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const std::stack<T, C>& stack)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T> size_t)",
    "insertText": "EstimateMemoryUsage(const base::circular_deque<T>& deque)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class T,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const base::flat_set<T, C>& set)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class K,class V,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const base::flat_map<K, V, C>& map)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class K,class V,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const base::LRUCache<K, V, C>& lru)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class K,class V,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const base::HashingLRUCache<K, V, C>& lru)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class V,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const base::LRUCacheSet<V, C>& lru)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template<class V,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const base::HashingLRUCacheSet<V, C>& lru)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (namespace internal { template<class T,class X = void> struct HasEMU : std::false_type { } ; template<class T> struct HasEMU<T,std::enable_if<std::is_same<size_t,)",
    "insertText": "decltype(EstimateMemoryUsage(std::declval<const T&>()))"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} ; template<class T,class X = void> struct EMUCaller {)",
    "insertText": "static_assert(std::is_same<T, std::false_type>::value, \"Neither global function 'size_t EstimateMemoryUsage(T)' \" \"nor member function 'size_t T::EstimateMemoryUsage() const' \" \"is defined for the type.\")"
  },
  {
    "label": "Call()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "Call(const T&)"
  },
  {
    "label": "OneOfContainersComplexIterators()",
    "kind": "Method",
    "detail": "Function (} } ; template<template<class . . .> class Container,class I,class = void> struct IsComplexIteratorForContainer : std::false_type { } ; template<template<class . . .> class Container,class I> struct IsComplexIteratorForContainer<Container,I,std::enable_if_t<! std::is_pointer<I>::value&& base::internal::is_iterator<I>::value>> { using value_type = std::iterator_traits<I>::value_type ; using container_type = Container<value_type> ; enum : bool { value = std::is_same<container_type::iterator,I>::value | | std::is_same<container_type::const_iterator,I>::value | | std::is_same<container_type::reverse_iterator,I>::value | | std::is_same<container_type::const_reverse_iterator,I>::value,} ; } ; template<class I,template<class . . .> class . . . Containers> bool)",
    "insertText": "OneOfContainersComplexIterators()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const bool all_tests [ ] = { IsComplexIteratorForContainer<Containers,I>::value . . . } ;)",
    "insertText": "for(bool test : all_tests) if (test)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} template<T> bool IsKnownNonAllocatingType_v = std::is_trivially_destructible<T>::value | | IsStandardContainerComplexIterator<)",
    "insertText": "T()"
  },
  {
    "label": "Call()",
    "kind": "Method",
    "detail": "Function (template<class T> struct EMUCaller<T,std::enable_if_t<! HasEMU<T>::value&& IsKnownNonAllocatingType_v<T>>> { size_t)",
    "insertText": "Call(const T& value)"
  },
  {
    "label": "EstimateIterableMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} template<class I> size_t)",
    "insertText": "EstimateIterableMemoryUsage(const I& iterable)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t memory_usage = 0 ;)",
    "insertText": "for(const auto& item : iterable)"
  },
  {
    "label": "EstimateItemMemoryUsage()",
    "kind": "Method",
    "detail": "Function (memory_usage + =)",
    "insertText": "EstimateItemMemoryUsage(item)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (using string_type = std::basic_string<C,T,A> ; using value_type = string_type::value_type ; const uint8_t* cstr = reinterpret_cast<const)",
    "insertText": "uint8_t(string.c_str())"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (const uint8_t* inline_cstr = reinterpret_cast<const)",
    "insertText": "uint8_t(&string)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} template BASE_EXPORT size_t)",
    "insertText": "EstimateMemoryUsage(const std::string&)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (template BASE_EXPORT size_t)",
    "insertText": "EstimateMemoryUsage(const std::u16string&)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (size_t memory_usage =)",
    "insertText": "sizeof(T)"
  },
  {
    "label": "EstimateItemMemoryUsage()",
    "kind": "Method",
    "detail": "Function (memory_usage + =)",
    "insertText": "EstimateItemMemoryUsage(array[i])"
  },
  {
    "label": "use_count()",
    "kind": "Method",
    "detail": "Function (auto use_count = ptr .)",
    "insertText": "use_count()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (using value_type = std::list<T,A>::value_type ; struct Node { raw_ptr<Node> prev ; raw_ptr<Node> next ; value_type value ; } ; return)",
    "insertText": "sizeof(Node) * list.size() + EstimateIterableMemoryUsage(list)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t memory_usage = 0 u ;)",
    "insertText": "for(base::LinkNode<T>* node = list.head(); node != list.end(); node = node->next())"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (memory_usage + =)",
    "insertText": "EstimateMemoryUsage(*node->value()) + sizeof(T)"
  },
  {
    "label": "EstimateTreeMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} return memory_usage ; } template<class V> size_t)",
    "insertText": "EstimateTreeMemoryUsage(size_t size)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (struct Node { raw_ptr<Node> left ; raw_ptr<Node> right ; raw_ptr<Node> parent ; bool is_black ; V value ; } ; return)",
    "insertText": "sizeof(Node)"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (using value_type = std::set<T,C,A>::value_type ; return EstimateTreeMemoryUsage<)",
    "insertText": "value_type(set.size()) + EstimateIterableMemoryUsage(set)"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (using value_type = std::map<K,V,C,A>::value_type ; return EstimateTreeMemoryUsage<)",
    "insertText": "value_type(map.size()) + EstimateIterableMemoryUsage(map)"
  },
  {
    "label": "HashMapBucketCountForTesting()",
    "kind": "Method",
    "detail": "Function (} namespace internal { template<class V> size_t)",
    "insertText": "HashMapBucketCountForTesting(size_t bucket_count)"
  },
  {
    "label": "EstimateHashMapMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} } template<class V> size_t)",
    "insertText": "EstimateHashMapMemoryUsage(size_t bucket_count, size_t size)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (struct Node { raw_ptr<void> next ; size_t hash ; V value ; } ; using Bucket = void* ; bucket_count = internal::HashMapBucketCountForTesting<)",
    "insertText": "V(bucket_count)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} template<class K,class H,class KE,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::unordered_set<K, H, KE, A>& set)"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (using value_type = std::unordered_set<K,H,KE,A>::value_type ; return EstimateHashMapMemoryUsage<)",
    "insertText": "value_type(set.bucket_count(), set.size()) + EstimateIterableMemoryUsage(set)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} template<class K,class H,class KE,class A> size_t)",
    "insertText": "EstimateMemoryUsage(const std::unordered_multiset<K, H, KE, A>& set)"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (using value_type = std::unordered_map<K,V,H,KE,A>::value_type ; return EstimateHashMapMemoryUsage<)",
    "insertText": "value_type(map.bucket_count(), map.size()) + EstimateIterableMemoryUsage(map)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_LIBCPP_VERSION)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (size_t kMinBlockLength = 1 6 ; # elif)",
    "insertText": "defined(__GLIBCXX__)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (size_t kMinBlockLength = 1 ; # elif)",
    "insertText": "defined(_MSC_VER)"
  },
  {
    "label": "block_length()",
    "kind": "Method",
    "detail": "Function (size_t kMinBlockLength = 1 ; # else size_t kBlockSize = 0 ; size_t kMinBlockLength = 1 ; # endif size_t)",
    "insertText": "block_length(sizeof(T) > kBlockSize) ? kMinBlockLength : kBlockSize / sizeof(T)"
  },
  {
    "label": "blocks()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "blocks(deque.size() + block_length - 1)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(__GLIBCXX__) if (!blocks)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "defined(_LIBCPP_VERSION) if (!blocks && deque.begin().operator->())"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "return(blocks * block_length * sizeof(T)) + EstimateIterableMemoryUsage(deque)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (using value_type = base::flat_set<T,C>::value_type ; return)",
    "insertText": "sizeof(value_type) * set.capacity() + EstimateIterableMemoryUsage(set)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (using value_type = base::flat_map<K,V,C>::value_type ; return)",
    "insertText": "sizeof(value_type) * map.capacity() + EstimateIterableMemoryUsage(map)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} template<class K,class V,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const LRUCache<K, V, C>& lru_cache)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} template<class K,class V,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const HashingLRUCache<K, V, C>& lru_cache)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} template<class V,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const LRUCacheSet<V, C>& lru_cache)"
  },
  {
    "label": "EstimateMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} template<class V,class C> size_t)",
    "insertText": "EstimateMemoryUsage(const HashingLRUCacheSet<V, C>& lru_cache)"
  }
]