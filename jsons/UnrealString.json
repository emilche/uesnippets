[
  {
    "label": "TTypeToString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TTypeToString"
  },
  {
    "label": "TTypeFromString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TTypeFromString"
  },
  {
    "label": "FStringOutputDevice",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStringOutputDevice"
  },
  {
    "label": "FName",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FName"
  },
  {
    "label": "TIsContiguousContainer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsContiguousContainer"
  },
  {
    "label": "FStringOutputDeviceCountLines",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStringOutputDeviceCountLines"
  },
  {
    "label": "FTextRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTextRange"
  },
  {
    "label": "UE_STRING_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / UnrealStringIncludes . h . inl \" # define UE_STRING_CLASS FString # define UE_STRING_CHARTYPE TCHAR # define UE_STRING_CHARTYPE_IS_TCHAR 1 # define UE_STRING_PRINTF_FMT_CHARTYPE TCHAR # define)",
    "insertText": "UE_STRING_DEPRECATED(Version, Message) #include \"Containers/UnrealString.h.inl\" #undef UE_STRING_DEPRECATED #undef UE_STRING_PRINTF_FMT_CHARTYPE #undef UE_STRING_CHARTYPE_IS_TCHAR #undef UE_STRING_CHARTYPE #undef UE_STRING_CLASS [[nodiscard]] inline FString BytesToString(const uint8* In, int32 Count)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (FString Result ; Result .)",
    "insertText": "Empty(Count)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (int16 Value =* In ; Value + = 1 ; Result + =)",
    "insertText": "ElementType(Value)"
  },
  {
    "label": "StringToBytes()",
    "kind": "Method",
    "detail": "Function (+ + In ; Count - - ; } return Result ; } int32)",
    "insertText": "StringToBytes(const FString& String, uint8* OutBytes, int32 MaxBufferSize)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 NumBytes = 0 ; const FString::ElementType* CharPos =* String ;)",
    "insertText": "while(*CharPos && NumBytes < MaxBufferSize)"
  },
  {
    "label": "NumBytes()",
    "kind": "Method",
    "detail": "Function (OutBytes [)",
    "insertText": "NumBytes(int8)(*CharPos - 1)"
  },
  {
    "label": "NibbleToTChar()",
    "kind": "Method",
    "detail": "Function (CharPos + + ; + + NumBytes ; } return NumBytes ; } [ [ nodiscard ] ] TCHAR)",
    "insertText": "NibbleToTChar(uint8 Num)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(TCHAR)('0' + Num)"
  },
  {
    "label": "ByteToHex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ByteToHex(uint8 In, FString& Result)"
  },
  {
    "label": "NibbleToTChar()",
    "kind": "Method",
    "detail": "Function (Result + =)",
    "insertText": "NibbleToTChar(In >> 4)"
  },
  {
    "label": "NibbleToTChar()",
    "kind": "Method",
    "detail": "Function (Result + =)",
    "insertText": "NibbleToTChar(In & 15)"
  },
  {
    "label": "BytesToHex()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] FString)",
    "insertText": "BytesToHex(const uint8* Bytes, int32 NumBytes)"
  },
  {
    "label": "BytesToHex()",
    "kind": "Method",
    "detail": "Function (FString Out ;)",
    "insertText": "BytesToHex(Bytes, NumBytes, Out)"
  },
  {
    "label": "BytesToHexLower()",
    "kind": "Method",
    "detail": "Function (FString Out ;)",
    "insertText": "BytesToHexLower(Bytes, NumBytes, Out)"
  },
  {
    "label": "TCharToNibble()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] const uint8)",
    "insertText": "TCharToNibble(const TCHAR Hex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Hex >= 'A' && Hex <= 'F')"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Hex >= 'a' && Hex <= 'f')"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "checkf(false, TEXT(\"'%c' (0x%02X) is not a valid hexadecimal digit\"), Hex, Hex)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<StringType = FString,CharType)",
    "insertText": "UE_REQUIRES(TIsCharType_V<CharType>) > [[nodiscard]] StringType LexToString(const CharType* Ptr)"
  },
  {
    "label": "LexToString()",
    "kind": "Method",
    "detail": "Function (} template<StringType = FString> [ [ nodiscard ] ] StringType)",
    "insertText": "LexToString(bool Value)"
  },
  {
    "label": "CHARTEXT()",
    "kind": "Method",
    "detail": "Function (using ElementType = StringType::ElementType ; return Value ?)",
    "insertText": "CHARTEXT(ElementType, \"true\") : CHARTEXT(ElementType, \"false\")"
  },
  {
    "label": "LexToSanitizedString()",
    "kind": "Method",
    "detail": "Function (} template<StringType = FString,T> [ [ nodiscard ] ] StringType)",
    "insertText": "LexToSanitizedString(const T& Value)"
  },
  {
    "label": "LexToSanitizedString()",
    "kind": "Method",
    "detail": "Function (} template<StringType = FString> [ [ nodiscard ] ] StringType)",
    "insertText": "LexToSanitizedString(float Value)"
  },
  {
    "label": "LexToSanitizedString()",
    "kind": "Method",
    "detail": "Function (} template<StringType = FString> [ [ nodiscard ] ] StringType)",
    "insertText": "LexToSanitizedString(double Value)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} template<T> struct TTypeToString { template<StringType = FString> [ [ nodiscard ] ] StringType)",
    "insertText": "ToString(const T& Value)"
  },
  {
    "label": "ToSanitizedString()",
    "kind": "Method",
    "detail": "Function (} template<StringType = FString> [ [ nodiscard ] ] StringType)",
    "insertText": "ToSanitizedString(const T& Value)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,CharType)",
    "insertText": "UE_REQUIRES(std::is_arithmetic_v<T>) > bool LexTryParseString(T& OutValue, const CharType* Buffer)"
  },
  {
    "label": "LexFromString()",
    "kind": "Method",
    "detail": "Function (OutValue = 0 ; return false ; })",
    "insertText": "LexFromString(OutValue, Buffer)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bool bSawZero = false ; CharType C =* Buffer ;)",
    "insertText": "while(C != CHARTEXT(CharType, '\\0') && (C == CHARTEXT(CharType, '+') || C == CHARTEXT(CharType, '-') || TChar<CharType>::IsWhitespace(C)))"
  },
  {
    "label": "C()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "C(++Buffer)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(C != CHARTEXT(CharType, '\\0') && !TChar<CharType>::IsWhitespace(C) && (std::is_floating_point_v<T> || C != CHARTEXT(CharType, '.')))"
  },
  {
    "label": "bSawZero()",
    "kind": "Method",
    "detail": "Function (bSawZero =)",
    "insertText": "bSawZero(C == CHARTEXT(CharType, '0'))"
  },
  {
    "label": "LexTryParseString()",
    "kind": "Method",
    "detail": "Function (} return bSawZero ; } return true ; } template<CharType> bool)",
    "insertText": "LexTryParseString(bool& OutValue, const CharType* Buffer)"
  },
  {
    "label": "InlineCombineSurrogates()",
    "kind": "Method",
    "detail": "Function (} } ; namespace StringConv { void)",
    "insertText": "InlineCombineSurrogates(FString& Str)"
  },
  {
    "label": "FStringOutputDevice()",
    "kind": "Method",
    "detail": "Function (} class FStringOutputDevice : public FString,public FOutputDevice { public :)",
    "insertText": "FStringOutputDevice(const TCHAR* OutputDeviceName=TEXT(\"\") ): FString( OutputDeviceName)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (bAutoEmitLineTerminator = false ; } void)",
    "insertText": "Serialize(const TCHAR* InData, ELogVerbosity::Type Verbosity, const class FName& Category)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator((TCHAR*)InData)"
  },
  {
    "label": "FStringOutputDevice()",
    "kind": "Method",
    "detail": "Function (* this + = LINE_TERMINATOR ; } })",
    "insertText": "FStringOutputDevice(FStringOutputDevice&&)"
  },
  {
    "label": "FStringOutputDevice()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FStringOutputDevice(const FStringOutputDevice&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FStringOutputDevice&)",
    "insertText": "operator(FStringOutputDevice&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FStringOutputDevice&)",
    "insertText": "operator(const FStringOutputDevice&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FString&)",
    "insertText": "operator(const FString& Other)"
  },
  {
    "label": "FStringOutputDeviceCountLines()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct TIsContiguousContainer<FStringOutputDevice> { enum { Value = true } ; } ; class FStringOutputDeviceCountLines : public FStringOutputDevice { typedef FStringOutputDevice Super ; int32 LineCount ; public :)",
    "insertText": "FStringOutputDeviceCountLines(const TCHAR* OutputDeviceName=TEXT(\"\") ) : Super( OutputDeviceName ) , LineCount(0)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Serialize(InData, Verbosity, Category)"
  },
  {
    "label": "Strlen()",
    "kind": "Method",
    "detail": "Function (int32 TermLength =)",
    "insertText": "Strlen(LINE_TERMINATOR)"
  },
  {
    "label": "Strstr()",
    "kind": "Method",
    "detail": "Function (InData =)",
    "insertText": "Strstr(InData, LINE_TERMINATOR)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } LineCount + + ; InData + = TermLength ; })",
    "insertText": "if(bAutoEmitLineTerminator)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (LineCount + + ; } } FStringOutputDeviceCountLines&)",
    "insertText": "operator(const FStringOutputDeviceCountLines& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(static_cast<const FString&>(Other))"
  },
  {
    "label": "GetLineCount()",
    "kind": "Method",
    "detail": "Function (LineCount + = Other .)",
    "insertText": "GetLineCount()"
  },
  {
    "label": "Log()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Log(Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FStringOutputDeviceCountLines&)",
    "insertText": "operator(const FStringOutputDeviceCountLines&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Other . LineCount = 0 ; } FStringOutputDeviceCountLines&)",
    "insertText": "operator(FStringOutputDeviceCountLines&& Other)"
  },
  {
    "label": "FTextRange()",
    "kind": "Method",
    "detail": "Function (LineCount = Other . LineCount ; Other . LineCount = 0 ; } return* this ; } } ; template<> struct TIsContiguousContainer<FStringOutputDeviceCountLines> { enum { Value = true } ; } ; struct FTextRange {)",
    "insertText": "FTextRange() : BeginIndex(INDEX_NONE) , EndIndex(INDEX_NONE)"
  },
  {
    "label": "FTextRange()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FTextRange(int32 InBeginIndex, int32 InEndIndex) : BeginIndex(InBeginIndex) , EndIndex(InEndIndex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FTextRange& Other)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(const FTextRange& Key)"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (uint32 KeyHash = 0 ; KeyHash =)",
    "insertText": "HashCombine(KeyHash, GetTypeHash(Key.BeginIndex))"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (KeyHash =)",
    "insertText": "HashCombine(KeyHash, GetTypeHash(Key.EndIndex))"
  },
  {
    "label": "Offset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Offset(int32 Amount)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (BeginIndex + = Amount ; BeginIndex =)",
    "insertText": "Max(0, BeginIndex)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (EndIndex + = Amount ; EndIndex =)",
    "insertText": "Max(0, EndIndex)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(int32 Index)"
  },
  {
    "label": "Intersected()",
    "kind": "Method",
    "detail": "Function (FTextRange)",
    "insertText": "Intersected(FMath::Max(BeginIndex, Other.BeginIndex), FMath::Min(EndIndex, Other.EndIndex))"
  },
  {
    "label": "CalculateLineRangesFromString()",
    "kind": "Method",
    "detail": "Function (} return Intersected ; } void)",
    "insertText": "CalculateLineRangesFromString(const FString& Input, TArray<FTextRange>& LineRanges)"
  },
  {
    "label": "StripNegativeZero()",
    "kind": "Method",
    "detail": "Function (int32 BeginIndex ; int32 EndIndex ; } ; namespace UE::Core::Private { void)",
    "insertText": "StripNegativeZero(double& InFloat)"
  }
]