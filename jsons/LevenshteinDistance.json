[
  {
    "label": "LevenshteinDistance()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" CoreTypes . h \" # include \" Templates / Invoke . h \" namespace Algo { template<RangeAType,RangeBType> int32)",
    "insertText": "LevenshteinDistance(const RangeAType& RangeA, const RangeBType& RangeB)"
  },
  {
    "label": "GetNum()",
    "kind": "Method",
    "detail": "Function (const int32 LenA =)",
    "insertText": "GetNum(RangeA)"
  },
  {
    "label": "GetNum()",
    "kind": "Method",
    "detail": "Function (const int32 LenB =)",
    "insertText": "GetNum(RangeB)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (auto DataB =)",
    "insertText": "GetData(RangeB)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<int32> OperationCount ; OperationCount .)",
    "insertText": "AddUninitialized(LenB + 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (OperationCount [ IndexB ] = IndexB ; })",
    "insertText": "for(int32 IndexA = 0; IndexA < LenA; ++IndexA)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 LastCount = IndexA + 1 ;)",
    "insertText": "for(int32 IndexB = 0; IndexB < LenB; ++IndexB)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 NewCount = OperationCount [ IndexB ] ;)",
    "insertText": "if(DataA[IndexA] != DataB[IndexB])"
  },
  {
    "label": "Min3()",
    "kind": "Method",
    "detail": "Function (NewCount =)",
    "insertText": "Min3(NewCount, LastCount, OperationCount[IndexB+1])"
  }
]