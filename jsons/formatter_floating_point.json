[
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "__traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__traits"
  },
  {
    "label": "_LIBCPP_TEMPLATE_VIS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_LIBCPP_TEMPLATE_VIS"
  },
  {
    "label": "__float_result",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__float_result"
  },
  {
    "label": "_Fp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Fp"
  },
  {
    "label": "_OutIt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_OutIt"
  },
  {
    "label": "_CharT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_CharT"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___FORMAT_FORMATTER_FLOATING_POINT_H # define _LIBCPP___FORMAT_FORMATTER_FLOATING_POINT_H # include<__algorithm / copy . h> # include<__algorithm / copy_n . h> # include<__algorithm / fill_n . h> # include<__algorithm / find . h> # include<__algorithm / min . h> # include<__algorithm / rotate . h> # include<__algorithm / transform . h> # include<__concepts / arithmetic . h> # include<__concepts / same_as . h> # include<__config> # include<__format / format_fwd . h> # include<__format / format_parse_context . h> # include<__format / formatter . h> # include<__format / formatter_integral . h> # include<__format / formatter_output . h> # include<__format / parser_std_format_spec . h> # include<__memory / allocator . h> # include<__utility / move . h> # include<__utility / unreachable . h> # include<charconv> # ifndef _LIBCPP_HAS_NO_LOCALIZATION # include<locale> # endif # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)"
  },
  {
    "label": "__to_buffer()",
    "kind": "Method",
    "detail": "Function (template<floating_point _Tp> _LIBCPP_HIDE_FROM_ABI char*)",
    "insertText": "__to_buffer(char* __first, char* __last, _Tp __value)"
  },
  {
    "label": "to_chars()",
    "kind": "Method",
    "detail": "Function (to_chars_result __r =)",
    "insertText": "to_chars(__first, __last, __value)"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_LIBCPP_ASSERT(__r.ec == errc(0), \"Internal buffer too small\")"
  },
  {
    "label": "to_chars()",
    "kind": "Method",
    "detail": "Function (to_chars_result __r =)",
    "insertText": "to_chars(__first, __last, __value, __fmt)"
  },
  {
    "label": "to_chars()",
    "kind": "Method",
    "detail": "Function (to_chars_result __r =)",
    "insertText": "to_chars(__first, __last, __value, __fmt, __precision)"
  },
  {
    "label": "__float_buffer()",
    "kind": "Method",
    "detail": "Function (using _Traits = __traits<_Fp> ; return 4 + _Traits::__max_integral + __precision + _Traits::__max_fractional_value ; } template<> struct __traits<float> { int __max_integral = 3 8 ; int __max_fractional = 1 4 9 ; int __max_fractional_value = 3 ; size_t __stack_buffer_size = 2 5 6 ; int __hex_precision_digits = 3 ; } ; template<> struct __traits<double> { int __max_integral = 3 0 8 ; int __max_fractional = 1 0 7 4 ; int __max_fractional_value = 4 ; size_t __stack_buffer_size = 1 0 2 4 ; int __hex_precision_digits = 4 ; } ; template<floating_point _Fp> class _LIBCPP_TEMPLATE_VIS __float_buffer { using _Traits = __traits<_Fp> ; public : _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__float_buffer(int __precision) : __precision_(__precision != -1 ? __precision : _Traits::__max_fractional)"
  },
  {
    "label": "_Fp()",
    "kind": "Method",
    "detail": "Function (__num_trailing_zeros_ = __precision_ - _Traits::__max_fractional ; __precision_ = _Traits::__max_fractional ; } __size_ = __formatter::__float_buffer_size<)",
    "insertText": "_Fp(__precision_)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} .)",
    "insertText": "allocate(__size_)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (} .)",
    "insertText": "deallocate(__begin_, __size_)"
  },
  {
    "label": "__float_buffer()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__float_buffer(const __float_buffer&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI __float_buffer&)",
    "insertText": "operator(const __float_buffer&)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI char*)",
    "insertText": "begin()"
  },
  {
    "label": "__find_exponent()",
    "kind": "Method",
    "detail": "Function (__num_trailing_zeros_ = 0 ; } private : int __precision_ ; int __num_trailing_zeros_ { 0 } ; size_t __size_ ; char* __begin_ ; char __buffer_ [ _Traits::__stack_buffer_size ] ; } ; struct __float_result { char* __integral ; char* __radix_point ; char* __exponent ; char* __last ; } ; _LIBCPP_HIDE_FROM_ABI char*)",
    "insertText": "__find_exponent(char* __first, char* __last)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ptrdiff_t __size = __last - __first ;)",
    "insertText": "if(__size > 4)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (__first = __last -)",
    "insertText": "min(__size, ptrdiff_t(6))"
  },
  {
    "label": "__format_buffer_default()",
    "kind": "Method",
    "detail": "Function (} } return __last ; } template<class _Fp,class _Tp> _LIBCPP_HIDE_FROM_ABI __float_result)",
    "insertText": "__format_buffer_default(const __float_buffer<_Fp>& __buffer, _Tp __value, char* __integral)"
  },
  {
    "label": "__to_buffer()",
    "kind": "Method",
    "detail": "Function (__float_result __result ; __result . __integral = __integral ; __result . __last =)",
    "insertText": "__to_buffer(__integral, __buffer.end(), __value)"
  },
  {
    "label": "__find_exponent()",
    "kind": "Method",
    "detail": "Function (__result . __exponent =)",
    "insertText": "__find_exponent(__result.__integral, __result.__last)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (__result . __radix_point =)",
    "insertText": "find(__result.__integral + 1, __result.__exponent, '.')"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_LIBCPP_ASSERT((__result.__integral != __result.__last) && (__result.__radix_point == __result.__last || *__result.__radix_point == '.') && (__result.__exponent == __result.__last || *__result.__exponent == 'e'), \"Post-condition failure.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__float_result __result ; __result . __integral = __integral ;)",
    "insertText": "if(__precision == -1) __result.__last = __formatter::__to_buffer(__integral, __buffer.end(), __value, chars_format::hex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (char* __first = __integral + 1 ;)",
    "insertText": "if(*__first == '.')"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (__result . __radix_point = __first ;)",
    "insertText": "static_assert(__traits<_Fp>::__hex_precision_digits <= 4, \"Guard against possible underflow.\")"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (char* __last = __result . __last - 2 ; __first = __last - __traits<_Fp>::__hex_precision_digits ; __result . __exponent =)",
    "insertText": "find(__first, __last, 'p')"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else { __result . __radix_point = __result . __last ; __result . __exponent = __first ; })",
    "insertText": "_LIBCPP_ASSERT((__result.__integral != __result.__last) && (__result.__radix_point == __result.__last || *__result.__radix_point == '.') && (__result.__exponent != __result.__last && *__result.__exponent == 'p'), \"Post-condition failure.\")"
  },
  {
    "label": "__format_buffer_hexadecimal_lower_case()",
    "kind": "Method",
    "detail": "Function (__float_result __result =)",
    "insertText": "__format_buffer_hexadecimal_lower_case(__buffer, __value, __precision, __integral)"
  },
  {
    "label": "transform()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transform(__result.__integral, __result.__exponent, __result.__integral, __hex_to_upper)"
  },
  {
    "label": "__format_buffer_scientific_lower_case()",
    "kind": "Method",
    "detail": "Function (* __result . __exponent = ' P ' ; return __result ; } template<class _Fp,class _Tp> _LIBCPP_HIDE_FROM_ABI __float_result)",
    "insertText": "__format_buffer_scientific_lower_case(const __float_buffer<_Fp>& __buffer, _Tp __value, int __precision, char* __integral)"
  },
  {
    "label": "__to_buffer()",
    "kind": "Method",
    "detail": "Function (__float_result __result ; __result . __integral = __integral ; __result . __last =)",
    "insertText": "__to_buffer(__integral, __buffer.end(), __value, chars_format::scientific, __precision)"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (char* __first = __integral + 1 ;)",
    "insertText": "_LIBCPP_ASSERT(__first != __result.__last, \"No exponent present\")"
  },
  {
    "label": "__find_exponent()",
    "kind": "Method",
    "detail": "Function (__result . __radix_point = __first ; __result . __exponent =)",
    "insertText": "__find_exponent(__first + 1, __result.__last)"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else { __result . __radix_point = __result . __last ; __result . __exponent = __first ; })",
    "insertText": "_LIBCPP_ASSERT((__result.__integral != __result.__last) && (__result.__radix_point == __result.__last || *__result.__radix_point == '.') && (__result.__exponent != __result.__last && *__result.__exponent == 'e'), \"Post-condition failure.\")"
  },
  {
    "label": "__format_buffer_scientific_lower_case()",
    "kind": "Method",
    "detail": "Function (__float_result __result =)",
    "insertText": "__format_buffer_scientific_lower_case(__buffer, __value, __precision, __integral)"
  },
  {
    "label": "__format_buffer_fixed()",
    "kind": "Method",
    "detail": "Function (* __result . __exponent = ' E ' ; return __result ; } template<class _Fp,class _Tp> _LIBCPP_HIDE_FROM_ABI __float_result)",
    "insertText": "__format_buffer_fixed(const __float_buffer<_Fp>& __buffer, _Tp __value, int __precision, char* __integral)"
  },
  {
    "label": "__to_buffer()",
    "kind": "Method",
    "detail": "Function (__float_result __result ; __result . __integral = __integral ; __result . __last =)",
    "insertText": "__to_buffer(__integral, __buffer.end(), __value, chars_format::fixed, __precision)"
  },
  {
    "label": "__last()",
    "kind": "Method",
    "detail": "Function (__result . __radix_point = __result .)",
    "insertText": "__last(__precision + bool(__precision))"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (__result . __exponent = __result . __last ;)",
    "insertText": "_LIBCPP_ASSERT((__result.__integral != __result.__last) && (__result.__radix_point == __result.__last || *__result.__radix_point == '.') && (__result.__exponent == __result.__last), \"Post-condition failure.\")"
  },
  {
    "label": "__remove_trailing_zeros()",
    "kind": "Method",
    "detail": "Function (__buffer .)",
    "insertText": "__remove_trailing_zeros()"
  },
  {
    "label": "__to_buffer()",
    "kind": "Method",
    "detail": "Function (__float_result __result ; __result . __integral = __integral ; __result . __last =)",
    "insertText": "__to_buffer(__integral, __buffer.end(), __value, chars_format::general, __precision)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (char* __first = __integral + 1 ;)",
    "insertText": "if(__first == __result.__last)"
  },
  {
    "label": "__find_exponent()",
    "kind": "Method",
    "detail": "Function (__result . __radix_point = __result . __last ; __result . __exponent = __result . __last ; } else { __result . __exponent =)",
    "insertText": "__find_exponent(__first, __result.__last)"
  },
  {
    "label": "__format_buffer_general_lower_case()",
    "kind": "Method",
    "detail": "Function (__float_result __result =)",
    "insertText": "__format_buffer_general_lower_case(__buffer, __value, __precision, __integral)"
  },
  {
    "label": "__insert_sign()",
    "kind": "Method",
    "detail": "Function (char* __first =)",
    "insertText": "__insert_sign(__buffer.begin(), __negative, __sign)"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (default :)",
    "insertText": "_LIBCPP_ASSERT(false, \"The parser should have validated the type\")"
  },
  {
    "label": "__libcpp_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__libcpp_unreachable()"
  },
  {
    "label": "__format_locale_specific_form()",
    "kind": "Method",
    "detail": "Function (} } # ifndef _LIBCPP_HAS_NO_LOCALIZATION template<class _OutIt,class _Fp,class _CharT> _LIBCPP_HIDE_FROM_ABI _OutIt)",
    "insertText": "__format_locale_specific_form(_OutIt __out_it, const __float_buffer<_Fp>& __buffer, const __float_result& __result, _VSTD::locale __loc, __format_spec::__parsed_specifications<_CharT> __specs)"
  },
  {
    "label": "_CharT()",
    "kind": "Method",
    "detail": "Function (const auto& __np = use_facet<numpunct<)",
    "insertText": "_CharT(__loc)"
  },
  {
    "label": "grouping()",
    "kind": "Method",
    "detail": "Function (string __grouping = __np .)",
    "insertText": "grouping()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (char* __first = __result . __integral ; char* __last =)",
    "insertText": "min(__result.__radix_point, __result.__exponent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ptrdiff_t __digits = __last - __first ;)",
    "insertText": "if(!__grouping.empty())"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} ptrdiff_t __size = __result . __last - __buffer .)",
    "insertText": "begin() + __buffer.__num_trailing_zeros() + __grouping.size() - !__grouping.empty()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__formatter::__padding_size_result __padding = { 0,0 } ; bool __zero_padding = __specs . __alignment_ = = __format_spec::__alignment::__zero_padding ;)",
    "insertText": "if(__size < __specs.__width_)"
  },
  {
    "label": "_CharT()",
    "kind": "Method",
    "detail": "Function (__specs . __alignment_ = __format_spec::__alignment::__right ; __specs . __fill_ =)",
    "insertText": "_CharT('0')"
  },
  {
    "label": "__padding_size()",
    "kind": "Method",
    "detail": "Function (} __padding =)",
    "insertText": "__padding_size(__size, __specs.__width_, __specs.__alignment_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(__zero_padding && __first != __buffer.begin()) *__out_it++ = *__buffer.begin()"
  },
  {
    "label": "fill_n()",
    "kind": "Method",
    "detail": "Function (__out_it =)",
    "insertText": "fill_n(_VSTD::move(__out_it), __padding.__before_, __specs.__fill_)"
  },
  {
    "label": "copy_n()",
    "kind": "Method",
    "detail": "Function (__out_it =)",
    "insertText": "copy_n(__first, __digits, _VSTD::move(__out_it))"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} else { auto __r = __grouping .)",
    "insertText": "rbegin()"
  },
  {
    "label": "rend()",
    "kind": "Method",
    "detail": "Function (auto __e = __grouping .)",
    "insertText": "rend()"
  },
  {
    "label": "thousands_sep()",
    "kind": "Method",
    "detail": "Function (_CharT __sep = __np .)",
    "insertText": "thousands_sep()"
  },
  {
    "label": "copy_n()",
    "kind": "Method",
    "detail": "Function (__out_it =)",
    "insertText": "copy_n(__first, *__r, _VSTD::move(__out_it))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__first + =* __r ;)",
    "insertText": "if(__r == __e)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + __r ;* __out_it + + = __sep ; } })",
    "insertText": "if(__result.__radix_point != __result.__last)"
  },
  {
    "label": "decimal_point()",
    "kind": "Method",
    "detail": "Function (* __out_it + + = __np .)",
    "insertText": "decimal_point()"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (__out_it =)",
    "insertText": "copy(__result.__radix_point + 1, __result.__exponent, _VSTD::move(__out_it))"
  },
  {
    "label": "fill_n()",
    "kind": "Method",
    "detail": "Function (__out_it =)",
    "insertText": "fill_n(_VSTD::move(__out_it), __buffer.__num_trailing_zeros(), _CharT('0'))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(__result.__exponent != __result.__last) __out_it = _VSTD::copy(__result.__exponent, __result.__last, _VSTD::move(__out_it))"
  },
  {
    "label": "__format_floating_point_non_finite()",
    "kind": "Method",
    "detail": "Function (} # endif template<class _OutIt,class _CharT> _LIBCPP_HIDE_FROM_ABI _OutIt)",
    "insertText": "__format_floating_point_non_finite(_OutIt __out_it, __format_spec::__parsed_specifications<_CharT> __specs, bool __negative, bool __isnan)"
  },
  {
    "label": "__insert_sign()",
    "kind": "Method",
    "detail": "Function (char __buffer [ 4 ] ; char* __last =)",
    "insertText": "__insert_sign(__buffer, __negative, __specs.__std_.__sign_)"
  },
  {
    "label": "copy_n()",
    "kind": "Method",
    "detail": "Function (bool __upper_case = __specs . __std_ . __type_ = = __format_spec::__type::__hexfloat_upper_case | | __specs . __std_ . __type_ = = __format_spec::__type::__scientific_upper_case | | __specs . __std_ . __type_ = = __format_spec::__type::__fixed_upper_case | | __specs . __std_ . __type_ = = __format_spec::__type::__general_upper_case ; __last =)",
    "insertText": "copy_n(&(\"infnanINFNAN\"[6 * __upper_case + 3 * __isnan]), 3, __last)"
  },
  {
    "label": "__format_floating_point()",
    "kind": "Method",
    "detail": "Function (} template<floating_point _Tp,class _CharT> _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "__format_floating_point(_Tp __value, auto& __ctx, __format_spec::__parsed_specifications<_CharT> __specs) -> decltype(__ctx.out())"
  },
  {
    "label": "signbit()",
    "kind": "Method",
    "detail": "Function (bool __negative =)",
    "insertText": "signbit(__value)"
  },
  {
    "label": "__buffer()",
    "kind": "Method",
    "detail": "Function (using _Fp = conditional_t<same_as<_Tp,long double>,double,_Tp> ; __float_buffer<_Fp>)",
    "insertText": "__buffer(__specs.__precision_)"
  },
  {
    "label": "__format_buffer()",
    "kind": "Method",
    "detail": "Function (__float_result __result =)",
    "insertText": "__format_buffer(__buffer, __value, __negative, (__specs.__has_precision()), __specs.__std_.__sign_, __specs.__std_.__type_)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (* __result . __last + + = ' . ' ;)",
    "insertText": "rotate(__result.__exponent, __result.__last - 1, __result.__last)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__result . __radix_point = __result . __exponent ; + + __result . __exponent ; } # ifndef _LIBCPP_HAS_NO_LOCALIZATION)",
    "insertText": "if(__specs.__std_.__locale_specific_form_) return __formatter::__format_locale_specific_form(__ctx.out(), __buffer, __result, __ctx.locale(), __specs)"
  },
  {
    "label": "__num_trailing_zeros()",
    "kind": "Method",
    "detail": "Function (int __num_trailing_zeros = __buffer .)",
    "insertText": "__num_trailing_zeros()"
  },
  {
    "label": "out()",
    "kind": "Method",
    "detail": "Function (} auto __out_it = __ctx .)",
    "insertText": "out()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(__num_trailing_zeros) return __formatter::__write_using_trailing_zeros( __first, __result.__last, _VSTD::move(__out_it), __specs, __size, __result.__exponent, __num_trailing_zeros)"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (} } template<__formatter::__char_type _CharT> struct _LIBCPP_TEMPLATE_VIS __formatter_floating_point { public : _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "parse(basic_format_parse_context<_CharT>& __parse_ctx) -> decltype(__parse_ctx.begin())"
  },
  {
    "label": "__parse()",
    "kind": "Method",
    "detail": "Function (auto __result = __parser_ .)",
    "insertText": "__parse(__parse_ctx, __format_spec::__fields_floating_point)"
  },
  {
    "label": "__process_parsed_floating_point()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__process_parsed_floating_point(__parser_)"
  }
]