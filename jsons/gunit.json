[
  {
    "label": "WAIT()",
    "kind": "Method",
    "detail": "Function (# ifndef RTC_BASE_GUNIT_H_ # define RTC_BASE_GUNIT_H_ # include \" absl / strings / string_view . h \" # include \" rtc_base / fake_clock . h \" # include \" rtc_base / logging . h \" # include \" rtc_base / thread . h \" # include \" test / gtest . h \" # define)",
    "insertText": "WAIT(ex, timeout) \\ for (int64_t start = rtc::SystemTimeMillis(); \\ !(ex) && rtc::SystemTimeMillis() < start + (timeout);)"
  },
  {
    "label": "Current()",
    "kind": "Method",
    "detail": "Function (\\ rtc::)",
    "insertText": "Current()->ProcessMessages(0)"
  },
  {
    "label": "Current()",
    "kind": "Method",
    "detail": "Function (\\ rtc::)",
    "insertText": "Current()->SleepMs(1)"
  },
  {
    "label": "WAIT_()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "WAIT_(ex, timeout, res)"
  },
  {
    "label": "SystemTimeMillis()",
    "kind": "Method",
    "detail": "Function (\\ int64_t start =)",
    "insertText": "SystemTimeMillis()"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "res(ex)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "while(!res && rtc::SystemTimeMillis() < start + (timeout))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ } \\ })",
    "insertText": "while(0) #define EXPECT_TRUE_WAIT(ex, timeout) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (bool res = true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(!res) \\ goto GTEST_CONCAT_TOKEN_(gunit_label_, __LINE__)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gunit_label_, __LINE__) : EXPECT_TRUE(ex) #define EXPECT_EQ_WAIT(v1, v2, timeout) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (bool res = true)"
  },
  {
    "label": "WAIT_()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "WAIT_(v1 == v2, timeout, res)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gunit_label_, __LINE__) : EXPECT_EQ(v1, v2) #define ASSERT_TRUE_WAIT(ex, timeout) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (bool res = true)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gunit_label_, __LINE__) : ASSERT_TRUE(ex) #define ASSERT_EQ_WAIT(v1, v2, timeout) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (bool res = true)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gunit_label_, __LINE__) : ASSERT_EQ(v1, v2) #define EXPECT_TRUE_WAIT_MARGIN(ex, timeout, margin) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (bool res = true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(res)"
  },
  {
    "label": "RTC_LOG()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "RTC_LOG(LS_WARNING) << \"Expression \" << #ex << \" still not true after \" \\ << (timeout)"
  },
  {
    "label": "WAIT_()",
    "kind": "Method",
    "detail": "Function (waiting an additional \"<<margin \\<<\" ms \" ; \\)",
    "insertText": "WAIT_(ex, margin, res)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gunit_label_, __LINE__) : EXPECT_TRUE(ex) #define SIMULATED_WAIT(ex, timeout, clock) \\ for (int64_t start = rtc::TimeMillis(); \\ !(ex) && rtc::TimeMillis() < start + (timeout);)"
  },
  {
    "label": "SIMULATED_WAIT_()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "SIMULATED_WAIT_(ex, timeout, res, clock)"
  },
  {
    "label": "TimeMillis()",
    "kind": "Method",
    "detail": "Function (\\ int64_t start =)",
    "insertText": "TimeMillis()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "while(!res && rtc::TimeMillis() < start + (timeout))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ } \\ })",
    "insertText": "while(0) #define EXPECT_TRUE_SIMULATED_WAIT(ex, timeout, clock)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(!res)"
  },
  {
    "label": "EXPECT_TRUE()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EXPECT_TRUE(ex)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ } \\ })",
    "insertText": "while(0) #define EXPECT_EQ_SIMULATED_WAIT(v1, v2, timeout, clock) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (bool res = true)"
  },
  {
    "label": "SIMULATED_WAIT_()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "SIMULATED_WAIT_(v1 == v2, timeout, res, clock)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gunit_label_, __LINE__) : EXPECT_EQ(v1, v2) #define ASSERT_TRUE_SIMULATED_WAIT(ex, timeout, clock) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (bool res = true)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gunit_label_, __LINE__) : ASSERT_TRUE(ex) #define ASSERT_EQ_SIMULATED_WAIT(v1, v2, timeout, clock) \\ GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\ if (bool res = true)"
  },
  {
    "label": "GTEST_CONCAT_TOKEN_()",
    "kind": "Method",
    "detail": "Function (\\ } else \\)",
    "insertText": "GTEST_CONCAT_TOKEN_(gunit_label_, __LINE__) : ASSERT_EQ(v1, v2) testing::AssertionResult AssertStartsWith(const char* text_expr, const char* prefix_expr, absl::string_view text, absl::string_view prefix)"
  },
  {
    "label": "AssertStringContains()",
    "kind": "Method",
    "detail": "Function (testing::AssertionResult)",
    "insertText": "AssertStringContains(const char* str_expr, const char* substr_expr, absl::string_view str, absl::string_view substr)"
  }
]