[
  {
    "label": "StringTypeTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StringTypeTrait"
  },
  {
    "label": "StringCodec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StringCodec"
  },
  {
    "label": "Storage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Storage"
  },
  {
    "label": "OPENVDB_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OPENVDB_API"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_POINTS_ATTRIBUTE_ARRAY_STRING_HAS_BEEN_INCLUDED # define OPENVDB_POINTS_ATTRIBUTE_ARRAY_STRING_HAS_BEEN_INCLUDED # include \" AttributeArray . h \" # include<memory> # include<deque> # include<unordered_map> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace points { namespace attribute_traits { template<bool Truncate> struct StringTypeTrait { using Type = Index ; } ; template<> struct StringTypeTrait<true> { using Type = uint16_t ; } ; } template<bool Truncate> struct StringCodec { using ValueType = Index ; template<T> struct Storage { using Type = attribute_traits::StringTypeTrait<Truncate>::Type ; } ; template<StorageType> void)",
    "insertText": "decode(const StorageType&, ValueType&)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (template<StorageType> void)",
    "insertText": "encode(const ValueType&, StorageType&)"
  },
  {
    "label": "name()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "name()"
  },
  {
    "label": "StringMetaCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StringMetaCache(const MetaMap& metadata)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "empty()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "size()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reset(const MetaMap& metadata)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(const Name& key, Index index)"
  },
  {
    "label": "map()",
    "kind": "Method",
    "detail": "Function (const ValueMap&)",
    "insertText": "map()"
  },
  {
    "label": "hasKey()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasKey(const Name& key)"
  },
  {
    "label": "hasIndex()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasIndex(Index index)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "insert(const Name& name, Index hint = Index(0))"
  },
  {
    "label": "resetCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resetCache()"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (private : using IndexPairArray = std::deque<std::pair<Index,Index>> ; MetaMap& mMetadata ; IndexPairArray mIdBlocks ; StringMetaCache mCache ; } ; template<bool Truncate> template<StorageType> void StringCodec<Truncate)",
    "insertText": "decode(const StorageType& data, ValueType& val)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (val = static_cast<)",
    "insertText": "ValueType(data)"
  },
  {
    "label": "encode()",
    "kind": "Method",
    "detail": "Function (} template<bool Truncate> template<StorageType> void StringCodec<Truncate)",
    "insertText": "encode(const ValueType& val, StorageType& data)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (data = static_cast<)",
    "insertText": "ValueType(val)"
  },
  {
    "label": "isString()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isString(const AttributeArray& array)"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (} class StringAttributeHandle { public : using Ptr = std::shared_ptr<StringAttributeHandle> ; using UniquePtr = std::unique_ptr<StringAttributeHandle> ; Ptr)",
    "insertText": "create(const AttributeArray& array, const MetaMap& metadata, const bool preserveCompression = true)"
  },
  {
    "label": "StringAttributeHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StringAttributeHandle(const AttributeArray& array, const MetaMap& metadata, const bool preserveCompression = true)"
  },
  {
    "label": "stride()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "stride()"
  },
  {
    "label": "isUniform()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isUniform()"
  },
  {
    "label": "hasConstantStride()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasConstantStride()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} Name)",
    "insertText": "get(Index n, Index m = 0)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "get(Name& name, Index n, Index m = 0)"
  },
  {
    "label": "array()",
    "kind": "Method",
    "detail": "Function (const AttributeArray&)",
    "insertText": "array()"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (protected : AttributeHandle<Index,StringCodec<false>> mHandle ; const MetaMap& mMetadata ; } ; class StringAttributeWriteHandle : public StringAttributeHandle { public : using Ptr = std::shared_ptr<StringAttributeWriteHandle> ; using UniquePtr = std::unique_ptr<StringAttributeWriteHandle> ; Ptr)",
    "insertText": "create(AttributeArray& array, const MetaMap& metadata, const bool expand = true)"
  },
  {
    "label": "StringAttributeWriteHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StringAttributeWriteHandle(AttributeArray& array, const MetaMap& metadata, const bool expand = true)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "expand(bool fill = true)"
  },
  {
    "label": "collapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collapse()"
  },
  {
    "label": "collapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collapse(const Name& name)"
  },
  {
    "label": "compact()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "compact()"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const Name& name)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(Index n, const Name& name)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(Index n, Index m, const Name& name)"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "contains(const Name& name)"
  },
  {
    "label": "getIndex()",
    "kind": "Method",
    "detail": "Function (private : Index)",
    "insertText": "getIndex(const Name& name)"
  }
]