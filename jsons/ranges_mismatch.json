[
  {
    "label": "_I1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_I1"
  },
  {
    "label": "_I2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_I2"
  },
  {
    "label": "__fn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__fn"
  },
  {
    "label": "_S1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_S1"
  },
  {
    "label": "_S2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_S2"
  },
  {
    "label": "_Pred",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Pred"
  },
  {
    "label": "_Proj1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Proj1"
  },
  {
    "label": "_Proj2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Proj2"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___ALGORITHM_RANGES_MISMATCH_H # define _LIBCPP___ALGORITHM_RANGES_MISMATCH_H # include<__algorithm / in_in_result . h> # include<__config> # include<__functional / identity . h> # include<__functional / invoke . h> # include<__functional / ranges_operations . h> # include<__iterator / concepts . h> # include<__iterator / indirectly_comparable . h> # include<__ranges / access . h> # include<__ranges / concepts . h> # include<__ranges / dangling . h> # include<__utility / move . h> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER) # pragma GCC system_header #endif _LIBCPP_BEGIN_NAMESPACE_STD #if _LIBCPP_STD_VER > 17 && !defined(_LIBCPP_HAS_NO_INCOMPLETE_RANGES)"
  },
  {
    "label": "__go()",
    "kind": "Method",
    "detail": "Function (template<class _I1,class _I2> using mismatch_result = in_in_result<_I1,_I2> ; namespace __mismatch { struct __fn { template<class _I1,class _S1,class _I2,class _S2,class _Pred,class _Proj1,class _Proj2> _LIBCPP_HIDE_FROM_ABI mismatch_result<_I1,_I2>)",
    "insertText": "__go(_I1 __first1, _S1 __last1, _I2 __first2, _S2 __last2, _Pred& __pred, _Proj1& __proj1, _Proj2& __proj2)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (+ + __first1 ; + + __first2 ; } return {)",
    "insertText": "move(__first1), std::move(__first2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<input_iterator _I1,sentinel_for<_I1> _S1,input_iterator _I2,sentinel_for<_I2> _S2,class _Pred = ranges::equal_to,class _Proj1 = identity,class _Proj2 = identity> requires indirectly_comparable<_I1,_I2,_Pred,_Proj1,_Proj2> _LIBCPP_HIDE_FROM_ABI mismatch_result<_I1,_I2>)",
    "insertText": "operator()(_I1 __first1, _S1 __last1, _I2 __first2, _S2 __last2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<input_range _R1,input_range _R2,class _Pred = ranges::equal_to,class _Proj1 = identity,class _Proj2 = identity> requires indirectly_comparable<iterator_t<_R1>,iterator_t<_R2>,_Pred,_Proj1,_Proj2> _LIBCPP_HIDE_FROM_ABI mismatch_result<borrowed_iterator_t<_R1>,borrowed_iterator_t<_R2>>)",
    "insertText": "operator()(_R1&& __r1, _R2&& __r2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})"
  }
]