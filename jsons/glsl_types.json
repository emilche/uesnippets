[
  {
    "label": "_mesa_glsl_parse_state",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_mesa_glsl_parse_state"
  },
  {
    "label": "glsl_symbol_table",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "glsl_symbol_table"
  },
  {
    "label": "glsl_base_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "glsl_base_type"
  },
  {
    "label": "glsl_sampler_dim",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "glsl_sampler_dim"
  },
  {
    "label": "glsl_outputstream_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "glsl_outputstream_type"
  },
  {
    "label": "glsl_domain",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "glsl_domain"
  },
  {
    "label": "glsl_partitioning",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "glsl_partitioning"
  },
  {
    "label": "glsl_outputtopology",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "glsl_outputtopology"
  },
  {
    "label": "glsl_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "glsl_type"
  },
  {
    "label": "glsl_struct_field",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "glsl_struct_field"
  },
  {
    "label": "hash_table",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "hash_table"
  },
  {
    "label": "SSourceLocation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SSourceLocation"
  },
  {
    "label": "glsl_tessellation_info",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "glsl_tessellation_info"
  },
  {
    "label": "_mesa_glsl_initialize_types()",
    "kind": "Method",
    "detail": "Function (# pragma once # ifndef GLSL_TYPES_H # define GLSL_TYPES_H # include<string> struct _mesa_glsl_parse_state ; struct glsl_symbol_table ; void)",
    "insertText": "_mesa_glsl_initialize_types(struct _mesa_glsl_parse_state *state)"
  },
  {
    "label": "_mesa_glsl_release_types()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mesa_glsl_release_types(void)"
  },
  {
    "label": "SetTransientContext()",
    "kind": "Method",
    "detail": "Function (enum glsl_base_type { GLSL_TYPE_UINT = 0,GLSL_TYPE_INT,GLSL_TYPE_HALF,GLSL_TYPE_FLOAT,GLSL_TYPE_BOOL,GLSL_TYPE_SAMPLER,GLSL_TYPE_STRUCT,GLSL_TYPE_ARRAY,GLSL_TYPE_VOID,GLSL_TYPE_ERROR,GLSL_TYPE_SAMPLER_STATE,GLSL_TYPE_OUTPUTSTREAM,GLSL_TYPE_IMAGE,GLSL_TYPE_INPUTPATCH,GLSL_TYPE_OUTPUTPATCH,GLSL_TYPE_MAX } ; enum glsl_sampler_dim { GLSL_SAMPLER_DIM_1D = 0,GLSL_SAMPLER_DIM_2D,GLSL_SAMPLER_DIM_3D,GLSL_SAMPLER_DIM_CUBE,GLSL_SAMPLER_DIM_RECT,GLSL_SAMPLER_DIM_BUF,GLSL_SAMPLER_DIM_EXTERNAL } ; enum glsl_outputstream_type { GLSL_OUTPUTSTREAM_NONE = 0,GLSL_OUTPUTSTREAM_POINTS,GLSL_OUTPUTSTREAM_LINES,GLSL_OUTPUTSTREAM_TRIANGLES } ; enum glsl_domain { GLSL_DOMAIN_NONE = 0,GLSL_DOMAIN_TRI,GLSL_DOMAIN_QUAD,GLSL_DOMAIN_ISOLINE } ; enum glsl_partitioning { GLSL_PARTITIONING_NONE = 0,GLSL_PARTITIONING_INTEGER,GLSL_PARTITIONING_FRACTIONAL_EVEN,GLSL_PARTITIONING_FRACTIONAL_ODD,GLSL_PARTITIONING_POW2,} ; enum glsl_outputtopology { GLSL_OUTPUTTOPOLOGY_NONE = 0,GLSL_OUTPUTTOPOLOGY_POINT,GLSL_OUTPUTTOPOLOGY_LINE,GLSL_OUTPUTTOPOLOGY_TRIANGLE_CW,GLSL_OUTPUTTOPOLOGY_TRIANGLE_CCW } ; # ifdef __cplusplus # include \" ralloc . h \" struct glsl_type { void)",
    "insertText": "SetTransientContext(void* ParseState)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (mem_ctx = ParseState ; } glsl_base_type base_type ; unsigned sampler_dimensionality : 3 ; unsigned sampler_shadow : 1 ; unsigned sampler_array : 1 ; unsigned sampler_ms : 1 ; unsigned sampler_buffer : 1 ; unsigned shader_storage_buffer : 1 ; unsigned outputstream_type : 2 ; int sample_count ; int patch_length ; const struct glsl_type* inner_type ; void* operator)",
    "insertText": "new(size_t size)"
  },
  {
    "label": "ralloc_size()",
    "kind": "Method",
    "detail": "Function (} void* type ; type =)",
    "insertText": "ralloc_size(glsl_type::mem_ctx, size)"
  },
  {
    "label": "ralloc_free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ralloc_free(type)"
  },
  {
    "label": "get_base_type()",
    "kind": "Method",
    "detail": "Function (} unsigned vector_elements : 3 ; unsigned matrix_columns : 3 ; const char* name ; const char* HlslName ; unsigned length ; union { const struct glsl_type* array ; const struct glsl_type* parameters ; struct glsl_struct_field* structure ; } fields ; const glsl_type* const error_type ; const glsl_type* const void_type ; const glsl_type* const int_type ; const glsl_type* const ivec2_type ; const glsl_type* const ivec3_type ; const glsl_type* const ivec4_type ; const glsl_type* const uint_type ; const glsl_type* const uvec2_type ; const glsl_type* const uvec3_type ; const glsl_type* const uvec4_type ; const glsl_type* const float_type ; const glsl_type* const vec2_type ; const glsl_type* const vec3_type ; const glsl_type* const vec4_type ; const glsl_type* const half_type ; const glsl_type* const half2_type ; const glsl_type* const half3_type ; const glsl_type* const half4_type ; const glsl_type* const bool_type ; const glsl_type* const mat2_type ; const glsl_type* const mat2x3_type ; const glsl_type* const mat2x4_type ; const glsl_type* const mat3x2_type ; const glsl_type* const mat3_type ; const glsl_type* const mat3x4_type ; const glsl_type* const mat4x2_type ; const glsl_type* const mat4x3_type ; const glsl_type* const mat4_type ; const glsl_type* const half2x2_type ; const glsl_type* const half2x3_type ; const glsl_type* const half2x4_type ; const glsl_type* const half3x2_type ; const glsl_type* const half3x3_type ; const glsl_type* const half3x4_type ; const glsl_type* const half4x2_type ; const glsl_type* const half4x3_type ; const glsl_type* const half4x4_type ; const glsl_type* const sampler_state_type ; const glsl_type* const sampler_cmp_state_type ; const glsl_type*)",
    "insertText": "get_base_type()"
  },
  {
    "label": "get_scalar_type()",
    "kind": "Method",
    "detail": "Function (const glsl_type*)",
    "insertText": "get_scalar_type()"
  },
  {
    "label": "element_type()",
    "kind": "Method",
    "detail": "Function (const glsl_type*)",
    "insertText": "element_type()"
  },
  {
    "label": "get_instance()",
    "kind": "Method",
    "detail": "Function (} const glsl_type*)",
    "insertText": "get_instance(unsigned base_type, unsigned rows, unsigned columns)"
  },
  {
    "label": "get_templated_instance()",
    "kind": "Method",
    "detail": "Function (const glsl_type*)",
    "insertText": "get_templated_instance(const glsl_type *base, const char *name, int num_samples, int patch_size)"
  },
  {
    "label": "GetByteAddressBufferInstance()",
    "kind": "Method",
    "detail": "Function (const glsl_type*)",
    "insertText": "GetByteAddressBufferInstance(const char* TypeName)"
  },
  {
    "label": "GetStructuredBufferInstance()",
    "kind": "Method",
    "detail": "Function (const glsl_type*)",
    "insertText": "GetStructuredBufferInstance(const char* TypeName, const glsl_type* InnerType)"
  },
  {
    "label": "get_array_instance()",
    "kind": "Method",
    "detail": "Function (const glsl_type*)",
    "insertText": "get_array_instance(const glsl_type *base, unsigned elements)"
  },
  {
    "label": "get_record_instance()",
    "kind": "Method",
    "detail": "Function (const glsl_type*)",
    "insertText": "get_record_instance(const glsl_struct_field *fields, unsigned num_fields, const char *name)"
  },
  {
    "label": "components()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "components()"
  },
  {
    "label": "can_implicitly_convert_to()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "can_implicitly_convert_to(const glsl_type *desired)"
  },
  {
    "label": "is_scalar()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_scalar()"
  },
  {
    "label": "is_vector()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_vector()"
  },
  {
    "label": "is_matrix()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_matrix()"
  },
  {
    "label": "is_numeric()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_numeric()"
  },
  {
    "label": "is_integer()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_integer()"
  },
  {
    "label": "is_float()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_float()"
  },
  {
    "label": "contains_sampler()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "contains_sampler()"
  },
  {
    "label": "get_shadow_sampler_type()",
    "kind": "Method",
    "detail": "Function (const glsl_type*)",
    "insertText": "get_shadow_sampler_type()"
  },
  {
    "label": "is_array()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_array()"
  },
  {
    "label": "column_type()",
    "kind": "Method",
    "detail": "Function (} const glsl_type*)",
    "insertText": "column_type()"
  },
  {
    "label": "field_type()",
    "kind": "Method",
    "detail": "Function (} const glsl_type*)",
    "insertText": "field_type(const char *name)"
  },
  {
    "label": "field_index()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "field_index(const char *name)"
  },
  {
    "label": "array_size()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "array_size()"
  },
  {
    "label": "patch_size()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "patch_size()"
  },
  {
    "label": "add_structure_member()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "add_structure_member(const glsl_struct_field* field)"
  },
  {
    "label": "replace_structure_member()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replace_structure_member(int memberIndex, const glsl_struct_field* new_field)"
  },
  {
    "label": "init_ralloc_type_ctx()",
    "kind": "Method",
    "detail": "Function (private : void* mem_ctx ; void* BaseTypesContext ; void)",
    "insertText": "init_ralloc_type_ctx(void)"
  },
  {
    "label": "glsl_type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "glsl_type(glsl_base_type base_type, unsigned vector_elements, unsigned matrix_columns, const char *name, const char* InHlslName)"
  },
  {
    "label": "glsl_type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "glsl_type(enum glsl_sampler_dim dim, bool shadow, bool array, bool multisample, int samples, bool is_sampler_buffer, const struct glsl_type* type, const char *name, const char* InHlslName)"
  },
  {
    "label": "glsl_type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "glsl_type(enum glsl_outputstream_type output_stream_type, const struct glsl_type* type, const char *name)"
  },
  {
    "label": "glsl_type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "glsl_type(enum glsl_base_type patch_type, unsigned patch_size, const struct glsl_type* type, const char *name)"
  },
  {
    "label": "glsl_type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "glsl_type(enum glsl_sampler_dim dim, bool array, bool is_sampler_buffer, bool is_shader_storage_buffer, const struct glsl_type* type, const char *name, const char* InHlslName)"
  },
  {
    "label": "glsl_type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "glsl_type(const glsl_struct_field *fields, unsigned num_fields, const char *name)"
  },
  {
    "label": "glsl_type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "glsl_type(const glsl_type *array, unsigned length)"
  },
  {
    "label": "record_key_compare()",
    "kind": "Method",
    "detail": "Function (struct hash_table* sampler_types ; hash_table* StructuredBufferTypes ; struct hash_table* outputstream_types ; struct hash_table* inputpatch_types ; struct hash_table* outputpatch_types ; struct hash_table* image_types ; struct hash_table* array_types ; struct hash_table* record_types ; int)",
    "insertText": "record_key_compare(const void *a, const void *b)"
  },
  {
    "label": "record_key_hash()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "record_key_hash(const void *key)"
  },
  {
    "label": "generate_100ES_types()",
    "kind": "Method",
    "detail": "Function (const glsl_type _error_type ; const glsl_type _void_type ; const glsl_type builtin_core_types [ ] ; const glsl_type builtin_structure_types [ ] ; const glsl_type builtin_110_deprecated_structure_types [ ] ; const glsl_type builtin_110_types [ ] ; const glsl_type builtin_120_types [ ] ; const glsl_type builtin_130_types [ ] ; const glsl_type builtin_140_types [ ] ; const glsl_type builtin_ARB_texture_rectangle_types [ ] ; const glsl_type builtin_EXT_texture_array_types [ ] ; const glsl_type builtin_EXT_texture_buffer_object_types [ ] ; const glsl_type builtin_OES_EGL_image_external_types [ ] ; void)",
    "insertText": "generate_100ES_types(glsl_symbol_table *)"
  },
  {
    "label": "generate_110_types()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "generate_110_types(glsl_symbol_table *, bool add_deprecated)"
  },
  {
    "label": "generate_120_types()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "generate_120_types(glsl_symbol_table *, bool add_deprecated)"
  },
  {
    "label": "generate_130_types()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "generate_130_types(glsl_symbol_table *, bool add_deprecated)"
  },
  {
    "label": "generate_140_types()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "generate_140_types(glsl_symbol_table *)"
  },
  {
    "label": "_mesa_glsl_initialize_types()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mesa_glsl_initialize_types(struct _mesa_glsl_parse_state *)"
  },
  {
    "label": "glsl_struct_field()",
    "kind": "Method",
    "detail": "Function (} ; struct glsl_struct_field { const struct glsl_type* type ; const char* name ; const char* semantic ; unsigned centroid : 1 ; unsigned interpolation : 2 ; unsigned geometryinput : 3 ; unsigned patchconstant : 1 ;)",
    "insertText": "glsl_struct_field(const struct glsl_type* InType = NULL, const char* InName = NULL) : type(InType), name(InName)"
  },
  {
    "label": "SSourceLocation()",
    "kind": "Method",
    "detail": "Function (semantic = NULL ; centroid = 0 ; interpolation = 0 ; geometryinput = 0 ; patchconstant = 0 ; } } ; struct SSourceLocation { const char* SourceFile ; unsigned Line ; unsigned Column ;)",
    "insertText": "SSourceLocation() : SourceFile(\"<unknown>\"), Line(0), Column(0)"
  },
  {
    "label": "glsl_tessellation_info()",
    "kind": "Method",
    "detail": "Function (} } ; struct glsl_tessellation_info {)",
    "insertText": "glsl_tessellation_info() : domain(GLSL_DOMAIN_NONE) , outputtopology(GLSL_OUTPUTTOPOLOGY_NONE) , partitioning(GLSL_PARTITIONING_NONE) , maxtessfactor(0) , outputcontrolpoints(0) , patchconstantfunc(0)"
  }
]