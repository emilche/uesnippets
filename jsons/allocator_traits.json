[
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "NAME",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NAME"
  },
  {
    "label": "_Alloc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Alloc"
  },
  {
    "label": "_RawAlloc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_RawAlloc"
  },
  {
    "label": "__pointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__pointer"
  },
  {
    "label": "_Ptr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Ptr"
  },
  {
    "label": "__const_pointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__const_pointer"
  },
  {
    "label": "__void_pointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__void_pointer"
  },
  {
    "label": "__const_void_pointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__const_void_pointer"
  },
  {
    "label": "_DiffType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_DiffType"
  },
  {
    "label": "__size_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__size_type"
  },
  {
    "label": "__alloc_traits_difference_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__alloc_traits_difference_type"
  },
  {
    "label": "__propagate_on_container_copy_assignment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__propagate_on_container_copy_assignment"
  },
  {
    "label": "__propagate_on_container_move_assignment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__propagate_on_container_move_assignment"
  },
  {
    "label": "__propagate_on_container_swap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__propagate_on_container_swap"
  },
  {
    "label": "__is_always_equal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_always_equal"
  },
  {
    "label": "_Up",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Up"
  },
  {
    "label": "__has_rebind_other",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_rebind_other"
  },
  {
    "label": "__allocator_traits_rebind",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__allocator_traits_rebind"
  },
  {
    "label": "_SizeType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_SizeType"
  },
  {
    "label": "_ConstVoidPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_ConstVoidPtr"
  },
  {
    "label": "__has_allocate_hint",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_allocate_hint"
  },
  {
    "label": "__has_construct_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_construct_impl"
  },
  {
    "label": "__has_construct",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_construct"
  },
  {
    "label": "_Pointer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Pointer"
  },
  {
    "label": "__has_destroy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_destroy"
  },
  {
    "label": "__has_max_size",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_max_size"
  },
  {
    "label": "__has_select_on_container_copy_construction",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_select_on_container_copy_construction"
  },
  {
    "label": "_LIBCPP_TEMPLATE_VIS",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_LIBCPP_TEMPLATE_VIS"
  },
  {
    "label": "rebind_alloc",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "rebind_alloc"
  },
  {
    "label": "rebind_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "rebind_traits"
  },
  {
    "label": "_Ap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Ap"
  },
  {
    "label": "_Traits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Traits"
  },
  {
    "label": "__rebind_alloc_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__rebind_alloc_helper"
  },
  {
    "label": "__is_default_allocator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_default_allocator"
  },
  {
    "label": "allocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "allocator"
  },
  {
    "label": "__is_cpp17_move_insertable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_cpp17_move_insertable"
  },
  {
    "label": "__is_cpp17_copy_insertable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_cpp17_copy_insertable"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___MEMORY_ALLOCATOR_TRAITS_H # define _LIBCPP___MEMORY_ALLOCATOR_TRAITS_H # include<__config> # include<__memory / construct_at . h> # include<__memory / pointer_traits . h> # include<__utility / forward . h> # include<limits> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER) # pragma GCC system_header #endif _LIBCPP_PUSH_MACROS #include <__undef_macros> _LIBCPP_BEGIN_NAMESPACE_STD #define _LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(NAME, PROPERTY)"
  },
  {
    "label": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX()",
    "kind": "Method",
    "detail": "Function (} ; \\ template<class _Tp> struct NAME<_Tp,__void_t<_Tp::PROPERTY>::type> : true_type { })",
    "insertText": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(__has_pointer, pointer)"
  },
  {
    "label": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX()",
    "kind": "Method",
    "detail": "Function (template<class _Tp,class _Alloc,class _RawAlloc = remove_reference<_Alloc>::type,bool = __has_pointer<_RawAlloc>::value> struct __pointer { using type _LIBCPP_NODEBUG = _RawAlloc::pointer ; } ; template<class _Tp,class _Alloc,class _RawAlloc> struct __pointer<_Tp,_Alloc,_RawAlloc,false> { using type _LIBCPP_NODEBUG = _Tp* ; } ;)",
    "insertText": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(__has_const_pointer, const_pointer)"
  },
  {
    "label": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX()",
    "kind": "Method",
    "detail": "Function (template<class _Tp,class _Ptr,class _Alloc,bool = __has_const_pointer<_Alloc>::value> struct __const_pointer { using type _LIBCPP_NODEBUG = _Alloc::const_pointer ; } ; template<class _Tp,class _Ptr,class _Alloc> struct __const_pointer<_Tp,_Ptr,_Alloc,false> { # ifdef _LIBCPP_CXX03_LANG using type = pointer_traits<_Ptr>::template rebind<const _Tp>::other ; # else using type _LIBCPP_NODEBUG = pointer_traits<_Ptr>::template rebind<const _Tp> ; # endif } ;)",
    "insertText": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(__has_void_pointer, void_pointer)"
  },
  {
    "label": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX()",
    "kind": "Method",
    "detail": "Function (template<class _Ptr,class _Alloc,bool = __has_void_pointer<_Alloc>::value> struct __void_pointer { using type _LIBCPP_NODEBUG = _Alloc::void_pointer ; } ; template<class _Ptr,class _Alloc> struct __void_pointer<_Ptr,_Alloc,false> { # ifdef _LIBCPP_CXX03_LANG using type _LIBCPP_NODEBUG = pointer_traits<_Ptr>::template rebind<void>::other ; # else using type _LIBCPP_NODEBUG = pointer_traits<_Ptr>::template rebind<void> ; # endif } ;)",
    "insertText": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(__has_const_void_pointer, const_void_pointer)"
  },
  {
    "label": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX()",
    "kind": "Method",
    "detail": "Function (template<class _Ptr,class _Alloc,bool = __has_const_void_pointer<_Alloc>::value> struct __const_void_pointer { using type _LIBCPP_NODEBUG = _Alloc::const_void_pointer ; } ; template<class _Ptr,class _Alloc> struct __const_void_pointer<_Ptr,_Alloc,false> { # ifdef _LIBCPP_CXX03_LANG using type _LIBCPP_NODEBUG = pointer_traits<_Ptr>::template rebind<const void>::other ; # else using type _LIBCPP_NODEBUG = pointer_traits<_Ptr>::template rebind<const void> ; # endif } ;)",
    "insertText": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(__has_size_type, size_type)"
  },
  {
    "label": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX()",
    "kind": "Method",
    "detail": "Function (template<class _Alloc,class _DiffType,bool = __has_size_type<_Alloc>::value> struct __size_type : make_unsigned<_DiffType> { } ; template<class _Alloc,class _DiffType> struct __size_type<_Alloc,_DiffType,true> { using type _LIBCPP_NODEBUG = _Alloc::size_type ; } ;)",
    "insertText": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(__has_alloc_traits_difference_type, difference_type)"
  },
  {
    "label": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX()",
    "kind": "Method",
    "detail": "Function (template<class _Alloc,class _Ptr,bool = __has_alloc_traits_difference_type<_Alloc>::value> struct __alloc_traits_difference_type { using type _LIBCPP_NODEBUG = pointer_traits<_Ptr>::difference_type ; } ; template<class _Alloc,class _Ptr> struct __alloc_traits_difference_type<_Alloc,_Ptr,true> { using type _LIBCPP_NODEBUG = _Alloc::difference_type ; } ;)",
    "insertText": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(__has_propagate_on_container_copy_assignment, propagate_on_container_copy_assignment)"
  },
  {
    "label": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX()",
    "kind": "Method",
    "detail": "Function (template<class _Alloc,bool = __has_propagate_on_container_copy_assignment<_Alloc>::value> struct __propagate_on_container_copy_assignment : false_type { } ; template<class _Alloc> struct __propagate_on_container_copy_assignment<_Alloc,true> { using type _LIBCPP_NODEBUG = _Alloc::propagate_on_container_copy_assignment ; } ;)",
    "insertText": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(__has_propagate_on_container_move_assignment, propagate_on_container_move_assignment)"
  },
  {
    "label": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX()",
    "kind": "Method",
    "detail": "Function (template<class _Alloc,bool = __has_propagate_on_container_move_assignment<_Alloc>::value> struct __propagate_on_container_move_assignment : false_type { } ; template<class _Alloc> struct __propagate_on_container_move_assignment<_Alloc,true> { using type _LIBCPP_NODEBUG = _Alloc::propagate_on_container_move_assignment ; } ;)",
    "insertText": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(__has_propagate_on_container_swap, propagate_on_container_swap)"
  },
  {
    "label": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX()",
    "kind": "Method",
    "detail": "Function (template<class _Alloc,bool = __has_propagate_on_container_swap<_Alloc>::value> struct __propagate_on_container_swap : false_type { } ; template<class _Alloc> struct __propagate_on_container_swap<_Alloc,true> { using type _LIBCPP_NODEBUG = _Alloc::propagate_on_container_swap ; } ;)",
    "insertText": "_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(__has_is_always_equal, is_always_equal)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<class _Alloc,bool = __has_is_always_equal<_Alloc>::value> struct __is_always_equal : is_empty<_Alloc> { } ; template<class _Alloc> struct __is_always_equal<_Alloc,true> { using type _LIBCPP_NODEBUG = _Alloc::is_always_equal ; } ; _LIBCPP_SUPPRESS_DEPRECATED_PUSH template<class _Tp,class _Up,class = void> struct __has_rebind_other : false_type { } ; template<class _Tp,class _Up> struct __has_rebind_other<_Tp,_Up,__void_t<_Tp::template rebind<_Up>::other>::type> : true_type { } ; template<class _Tp,class _Up,bool = __has_rebind_other<_Tp,_Up>::value> struct __allocator_traits_rebind { using type _LIBCPP_NODEBUG = _Tp::template rebind<_Up>::other ; } ; template<template<class,class . . .> class _Alloc,class _Tp,class . . . _Args,class _Up> struct __allocator_traits_rebind<_Alloc<_Tp,_Args . . .>,_Up,true> { using type _LIBCPP_NODEBUG = _Alloc<_Tp,_Args . . .>::template rebind<_Up>::other ; } ; template<template<class,class . . .> class _Alloc,class _Tp,class . . . _Args,class _Up> struct __allocator_traits_rebind<_Alloc<_Tp,_Args . . .>,_Up,false> { using type _LIBCPP_NODEBUG = _Alloc<_Up,_Args . . .> ; } ; _LIBCPP_SUPPRESS_DEPRECATED_POP template<class _Alloc,class _Tp> using __allocator_traits_rebind_t = __allocator_traits_rebind<_Alloc,_Tp>::type ; _LIBCPP_SUPPRESS_DEPRECATED_PUSH template<class _Alloc,class _SizeType,class _ConstVoidPtr,class = void> struct __has_allocate_hint : false_type { } ; template<class _Alloc,class _SizeType,class _ConstVoidPtr> struct __has_allocate_hint<_Alloc,_SizeType,_ConstVoidPtr,)",
    "insertText": "decltype((void)declval<_Alloc>().allocate(declval<_SizeType>(), declval<_ConstVoidPtr>()))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<class,class _Alloc,class . . . _Args> struct __has_construct_impl : false_type { } ; template<class _Alloc,class . . . _Args> struct __has_construct_impl<)",
    "insertText": "decltype((void)declval<_Alloc>().construct(declval<_Args>()...))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<class _Alloc,class . . . _Args> struct __has_construct : __has_construct_impl<void,_Alloc,_Args . . .> { } ; template<class _Alloc,class _Pointer,class = void> struct __has_destroy : false_type { } ; template<class _Alloc,class _Pointer> struct __has_destroy<_Alloc,_Pointer,)",
    "insertText": "decltype((void)declval<_Alloc>().destroy(declval<_Pointer>()))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<class _Alloc,class = void> struct __has_max_size : false_type { } ; template<class _Alloc> struct __has_max_size<_Alloc,)",
    "insertText": "decltype((void)declval<_Alloc&>().max_size())"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<class _Alloc,class = void> struct __has_select_on_container_copy_construction : false_type { } ; template<class _Alloc> struct __has_select_on_container_copy_construction<_Alloc,)",
    "insertText": "decltype((void)declval<_Alloc>().select_on_container_copy_construction())"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} ; _LIBCPP_SUPPRESS_DEPRECATED_POP template<class _Alloc> struct _LIBCPP_TEMPLATE_VIS allocator_traits { using allocator_type = _Alloc ; using value_type = allocator_type::value_type ; using pointer = __pointer<value_type,allocator_type>::type ; using const_pointer = __const_pointer<value_type,pointer,allocator_type>::type ; using void_pointer = __void_pointer<pointer,allocator_type>::type ; using const_void_pointer = __const_void_pointer<pointer,allocator_type>::type ; using difference_type = __alloc_traits_difference_type<allocator_type,pointer>::type ; using size_type = __size_type<allocator_type,difference_type>::type ; using propagate_on_container_copy_assignment = __propagate_on_container_copy_assignment<allocator_type>::type ; using propagate_on_container_move_assignment = __propagate_on_container_move_assignment<allocator_type>::type ; using propagate_on_container_swap = __propagate_on_container_swap<allocator_type>::type ; using is_always_equal = __is_always_equal<allocator_type>::type ; # ifndef _LIBCPP_CXX03_LANG template<class _Tp> using rebind_alloc = __allocator_traits_rebind_t<allocator_type,_Tp> ; template<class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>> ; # else template<class _Tp> struct rebind_alloc { using other = __allocator_traits_rebind_t<allocator_type,_Tp> ; } ; template<class _Tp> struct rebind_traits { using other = allocator_traits<rebind_alloc<_Tp>::other> ; } ; # endif _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 pointer)",
    "insertText": "allocate(allocator_type& __a, size_type __n)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} template<class _Ap = _Alloc,class = __enable_if_t<__has_allocate_hint<_Ap,size_type,const_void_pointer>::value>> _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 pointer)",
    "insertText": "allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_SUPPRESS_DEPRECATED_PUSH return __a .)",
    "insertText": "allocate(__n, __hint)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_SUPPRESS_DEPRECATED_POP } template<class _Ap = _Alloc,class = void,class = __enable_if_t<! __has_allocate_hint<_Ap,size_type,const_void_pointer>::value>> _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 pointer)",
    "insertText": "allocate(allocator_type& __a, size_type __n, const_void_pointer)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 void)",
    "insertText": "deallocate(allocator_type& __a, pointer __p, size_type __n)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (__a .)",
    "insertText": "deallocate(__p, __n)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp,class . . . _Args,class = __enable_if_t<__has_construct<allocator_type,_Tp*,_Args . . .>::value>> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 void)",
    "insertText": "construct(allocator_type& __a, _Tp* __p, _Args&&... __args)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_SUPPRESS_DEPRECATED_PUSH __a .)",
    "insertText": "construct(__p, _VSTD::forward<_Args>(__args)...)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_SUPPRESS_DEPRECATED_POP } template<class _Tp,class . . . _Args,class = void,class = __enable_if_t<! __has_construct<allocator_type,_Tp*,_Args . . .>::value>> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 void)",
    "insertText": "construct(allocator_type&, _Tp* __p, _Args&&... __args)"
  },
  {
    "label": "construct_at()",
    "kind": "Method",
    "detail": "Function (# if _LIBCPP_STD_VER> 1 7)",
    "insertText": "construct_at(__p, _VSTD::forward<_Args>(__args)...)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "new((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (# endif } template<class _Tp,class = __enable_if_t<__has_destroy<allocator_type,_Tp*>::value>> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 void)",
    "insertText": "destroy(allocator_type& __a, _Tp* __p)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_SUPPRESS_DEPRECATED_PUSH __a .)",
    "insertText": "destroy(__p)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_SUPPRESS_DEPRECATED_POP } template<class _Tp,class = void,class = __enable_if_t<! __has_destroy<allocator_type,_Tp*>::value>> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 void)",
    "insertText": "destroy(allocator_type&, _Tp* __p)"
  },
  {
    "label": "destroy_at()",
    "kind": "Method",
    "detail": "Function (# if _LIBCPP_STD_VER> 1 7)",
    "insertText": "destroy_at(__p)"
  },
  {
    "label": "_Tp()",
    "kind": "Method",
    "detail": "Function (# else __p -> ~)",
    "insertText": "_Tp()"
  },
  {
    "label": "max_size()",
    "kind": "Method",
    "detail": "Function (# endif } template<class _Ap = _Alloc,class = __enable_if_t<__has_max_size<const _Ap>::value>> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type)",
    "insertText": "max_size(const allocator_type& __a)"
  },
  {
    "label": "max_size()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_SUPPRESS_DEPRECATED_PUSH return __a .)",
    "insertText": "max_size()"
  },
  {
    "label": "max_size()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_SUPPRESS_DEPRECATED_POP } template<class _Ap = _Alloc,class = void,class = __enable_if_t<! __has_max_size<const _Ap>::value>> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 size_type)",
    "insertText": "max_size(const allocator_type&)"
  },
  {
    "label": "select_on_container_copy_construction()",
    "kind": "Method",
    "detail": "Function (} template<class _Ap = _Alloc,class = __enable_if_t<__has_select_on_container_copy_construction<const _Ap>::value>> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17 allocator_type)",
    "insertText": "select_on_container_copy_construction(const allocator_type& __a)"
  }
]