[
  {
    "label": "SmallVectorBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallVectorBase"
  },
  {
    "label": "SmallVectorStorage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SmallVectorStorage"
  },
  {
    "label": "SmallVectorTemplateCommon",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallVectorTemplateCommon"
  },
  {
    "label": "SmallVectorTemplateBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallVectorTemplateBase"
  },
  {
    "label": "SmallVectorImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallVectorImpl"
  },
  {
    "label": "SmallVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallVector"
  },
  {
    "label": "SmallVectorBase()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ADT_SMALLVECTOR_H # define LLVM_ADT_SMALLVECTOR_H # include \" llvm / ADT / iterator_range . h \" # include \" llvm / Support / AlignOf . h \" # include \" llvm / Support / Compiler . h \" # include \" llvm / Support / MathExtras . h \" # include \" llvm / Support / type_traits . h \" # include<algorithm> # include<cassert> # include<cstddef> # include<cstdlib> # include<cstring> # include<initializer_list> # include<iterator> # include<memory> namespace llvm { class SmallVectorBase { protected : void* BeginX,* EndX,* CapacityX ; protected :)",
    "insertText": "SmallVectorBase(void *FirstEl, size_t Size) : BeginX(FirstEl), EndX(FirstEl), CapacityX((char*)FirstEl+Size)"
  },
  {
    "label": "grow_pod()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "grow_pod(void *FirstEl, size_t MinSizeInBytes, size_t TSize)"
  },
  {
    "label": "size_in_bytes()",
    "kind": "Method",
    "detail": "Function (public : size_t)",
    "insertText": "size_in_bytes()"
  },
  {
    "label": "capacity_in_bytes()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "capacity_in_bytes()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool LLVM_ATTRIBUTE_UNUSED_RESULT)",
    "insertText": "empty()"
  },
  {
    "label": "grow_pod()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "grow_pod(size_t MinSizeInBytes, size_t TSize)"
  },
  {
    "label": "grow_pod()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "grow_pod(&FirstEl, MinSizeInBytes, TSize)"
  },
  {
    "label": "isSmall()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isSmall()"
  },
  {
    "label": "resetToSmall()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resetToSmall()"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (BeginX = EndX = CapacityX =& FirstEl ; } void)",
    "insertText": "setEnd(T *P)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (this -> EndX = P ; } public : typedef size_t size_type ; typedef ptrdiff_t difference_type ; typedef T value_type ; typedef T* iterator ; typedef const T* const_iterator ; typedef std::reverse_iterator<const_iterator> const_reverse_iterator ; typedef std::reverse_iterator<iterator> reverse_iterator ; typedef T& reference ; typedef const T& const_reference ; typedef T* pointer ; typedef const T* const_pointer ; iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "capacity_ptr()",
    "kind": "Method",
    "detail": "Function (} protected : iterator)",
    "insertText": "capacity_ptr()"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} public : reverse_iterator)",
    "insertText": "rbegin()"
  },
  {
    "label": "rend()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rend()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "size()"
  },
  {
    "label": "max_size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "max_size()"
  },
  {
    "label": "capacity()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "capacity()"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (} pointer)",
    "insertText": "data()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "operator(size_type idx)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(idx < size())"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "front()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!empty())"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "back()"
  },
  {
    "label": "SmallVectorTemplateBase()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,bool isPodLike> class SmallVectorTemplateBase : public SmallVectorTemplateCommon<T> { protected :)",
    "insertText": "SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size)"
  },
  {
    "label": "destroy_range()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "destroy_range(T *S, T *E)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (- - E ; E -> ~)",
    "insertText": "T()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (} } template<It1,It2> It2)",
    "insertText": "move(It1 I, It1 E, It2 Dest)"
  },
  {
    "label": "uninitialized_copy()",
    "kind": "Method",
    "detail": "Function (} template<It1,It2> void)",
    "insertText": "uninitialized_copy(It1 I, It1 E, It2 Dest)"
  },
  {
    "label": "uninitialized_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uninitialized_copy(I, E, Dest)"
  },
  {
    "label": "grow()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "grow(size_t MinSize = 0)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "push_back(const T &Elt)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*) this->end()) T(Elt)"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->end()+1)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_back(T &&Elt)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*) this->end()) T(::std::move(Elt))"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pop_back()"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->end()-1)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "end()->~T()"
  },
  {
    "label": "grow()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,bool isPodLike> void SmallVectorTemplateBase<T,isPodLike)",
    "insertText": "grow(size_t MinSize)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t NewCapacity =)",
    "insertText": "size_t(NextPowerOf2(CurCapacity+2))"
  },
  {
    "label": "NewElts()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "NewElts(T*)new char[NewCapacity*sizeof(T)"
  },
  {
    "label": "uninitialized_move()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "uninitialized_move(this->begin(), this->end(), NewElts)"
  },
  {
    "label": "destroy_range()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy_range(this->begin(), this->end())"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(NewElts+CurSize)"
  },
  {
    "label": "destroy_range()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "destroy_range(T *, T *)"
  },
  {
    "label": "move_backward()",
    "kind": "Method",
    "detail": "Function (} template<It1,It2> It2)",
    "insertText": "move_backward(It1 I, It1 E, It2 Dest)"
  },
  {
    "label": "uninitialized_move()",
    "kind": "Method",
    "detail": "Function (} template<It1,It2> void)",
    "insertText": "uninitialized_move(It1 I, It1 E, It2 Dest)"
  },
  {
    "label": "uninitialized_copy()",
    "kind": "Method",
    "detail": "Function (} template<T1,T2> void)",
    "insertText": "uninitialized_copy(T1 *I, T1 *E, T2 *Dest, typename std::enable_if<std::is_same<typename std::remove_const<T1>::type, T2>::value>::type * = nullptr)"
  },
  {
    "label": "grow_pod()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "grow_pod(MinSize*sizeof(T), sizeof(T))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(reinterpret_cast<void *>(this->end()), &Elt, sizeof(T))"
  },
  {
    "label": "SmallVectorImpl()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> class SmallVectorImpl : public SmallVectorTemplateBase<T,isPodLike<T>::value> { typedef SmallVectorTemplateBase<T,isPodLike<T>::value> SuperClass ;)",
    "insertText": "SmallVectorImpl(const SmallVectorImpl&)"
  },
  {
    "label": "SmallVectorImpl()",
    "kind": "Method",
    "detail": "Function (public : typedef SuperClass::iterator iterator ; typedef SuperClass::size_type size_type ; protected :)",
    "insertText": "SmallVectorImpl(unsigned N) : SmallVectorTemplateBase<T, isPodLike<T>::value>(N*sizeof(T))"
  },
  {
    "label": "SmallVectorImpl()",
    "kind": "Method",
    "detail": "Function (} public : ~)",
    "insertText": "SmallVectorImpl()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (this -> EndX = this -> BeginX ; } void)",
    "insertText": "resize(size_type N)"
  },
  {
    "label": "destroy_range()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "destroy_range(this->begin()+N, this->end())"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->begin()+N)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(N > this->size())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "resize(size_type N, const T &NV)"
  },
  {
    "label": "uninitialized_fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uninitialized_fill(this->end(), this->begin()+N, NV)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "reserve(size_type N)"
  },
  {
    "label": "pop_back_val()",
    "kind": "Method",
    "detail": "Function (} T LLVM_ATTRIBUTE_UNUSED_RESULT)",
    "insertText": "pop_back_val()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (T Result =::)",
    "insertText": "move(this->back())"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (template<in_iter> void)",
    "insertText": "append(in_iter in_start, in_iter in_end)"
  },
  {
    "label": "distance()",
    "kind": "Method",
    "detail": "Function (size_type NumInputs =)",
    "insertText": "distance(in_start, in_end)"
  },
  {
    "label": "uninitialized_copy()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "uninitialized_copy(in_start, in_end, this->end())"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->end() + NumInputs)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "append(size_type NumInputs, const T &Elt)"
  },
  {
    "label": "uninitialized_fill_n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uninitialized_fill_n(this->end(), NumInputs, Elt)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "append(std::initializer_list<T> IL)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "append(IL.begin(), IL.end())"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "assign(size_type NumElts, const T &Elt)"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->begin()+NumElts)"
  },
  {
    "label": "uninitialized_fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uninitialized_fill(this->begin(), this->end(), Elt)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "assign(std::initializer_list<T> IL)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "append(IL)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "erase(iterator I)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(I >= this->begin() && \"Iterator to erase is out of bounds.\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(I < this->end() && \"Erasing at past-the-end iterator.\")"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (iterator N = I ; this ->)",
    "insertText": "move(I+1, this->end(), I)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "erase(iterator S, iterator E)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(S >= this->begin() && \"Range to erase is out of bounds.\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(S <= E && \"Trying to erase invalid range.\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(E <= this->end() && \"Trying to erase past the end.\")"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (iterator N = S ; iterator I = this ->)",
    "insertText": "move(E, this->end(), S)"
  },
  {
    "label": "destroy_range()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "destroy_range(I, this->end())"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(I)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(iterator I, T &&Elt)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "push_back(::std::move(Elt))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(I >= this->begin() && \"Insertion iterator is out of bounds.\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(I <= this->end() && \"Inserting past the end of the vector.\")"
  },
  {
    "label": "grow()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "grow()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*) this->end()) T(::std::move(this->back()))"
  },
  {
    "label": "move_backward()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "move_backward(I, this->end()-1, this->end())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T* EltPtr =& Elt ;)",
    "insertText": "if(I <= EltPtr && EltPtr < this->EndX)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (* I =::)",
    "insertText": "move(*EltPtr)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "push_back(Elt)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*) this->end()) T(std::move(this->back()))"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (* I =* EltPtr ; return I ; } iterator)",
    "insertText": "insert(iterator I, size_type NumToInsert, const T &Elt)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "append(NumToInsert, Elt)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(this->size() + NumToInsert)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "append(std::move_iterator<iterator>(this->end() - NumToInsert), std::move_iterator<iterator>(this->end()))"
  },
  {
    "label": "move_backward()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "move_backward(I, OldEnd-NumToInsert, OldEnd)"
  },
  {
    "label": "fill_n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill_n(I, NumToInsert, Elt)"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->end() + NumToInsert)"
  },
  {
    "label": "uninitialized_move()",
    "kind": "Method",
    "detail": "Function (size_t NumOverwritten = OldEnd - I ; this ->)",
    "insertText": "uninitialized_move(I, OldEnd, this->end()-NumOverwritten)"
  },
  {
    "label": "fill_n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill_n(I, NumOverwritten, Elt)"
  },
  {
    "label": "uninitialized_fill_n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uninitialized_fill_n(OldEnd, NumToInsert-NumOverwritten, Elt)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "append(From, To)"
  },
  {
    "label": "distance()",
    "kind": "Method",
    "detail": "Function (size_t NumToInsert =)",
    "insertText": "distance(From, To)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(From, To, I)"
  },
  {
    "label": "uninitialized_copy()",
    "kind": "Method",
    "detail": "Function (* J =* From ; + + J ; + + From ; } this ->)",
    "insertText": "uninitialized_copy(From, To, OldEnd)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(I, IL.begin(), IL.end())"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (} template<. . . ArgTypes> void)",
    "insertText": "emplace_back(ArgTypes &&... Args)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void *)this->end()) T(std::forward<ArgTypes>(Args)...)"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->end() + 1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} SmallVectorImpl&)",
    "insertText": "operator(const SmallVectorImpl &RHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (SmallVectorImpl&)",
    "insertText": "operator(SmallVectorImpl &&RHS)"
  },
  {
    "label": "set_size()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_size(size_type N)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(N <= this->capacity())"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->begin() + N)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> void SmallVectorImpl<T)",
    "insertText": "swap(SmallVectorImpl<T> &RHS)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(this->BeginX, RHS.BeginX)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(this->EndX, RHS.EndX)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(this->CapacityX, RHS.CapacityX)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_t EltDiff = this ->)",
    "insertText": "size() - RHS.size()"
  },
  {
    "label": "uninitialized_copy()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "uninitialized_copy(this->begin()+NumShared, this->end(), RHS.end())"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (RHS .)",
    "insertText": "setEnd(RHS.end()+EltDiff)"
  },
  {
    "label": "destroy_range()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "destroy_range(this->begin()+NumShared, this->end())"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->begin()+NumShared)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(RHS.size() > this->size())"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_t EltDiff = RHS .)",
    "insertText": "size() - this->size()"
  },
  {
    "label": "uninitialized_copy()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "uninitialized_copy(RHS.begin()+NumShared, RHS.end(), this->end())"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->end() + EltDiff)"
  },
  {
    "label": "destroy_range()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "destroy_range(RHS.begin()+NumShared, RHS.end())"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (RHS .)",
    "insertText": "setEnd(RHS.begin()+NumShared)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } template<T> SmallVectorImpl<T>& SmallVectorImpl<T)",
    "insertText": "operator(const SmallVectorImpl<T> &RHS)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (iterator NewEnd ;)",
    "insertText": "if(RHSSize) NewEnd = std::copy(RHS.begin(), RHS.begin()+RHSSize, this->begin())"
  },
  {
    "label": "destroy_range()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "destroy_range(NewEnd, this->end())"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(NewEnd)"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->begin())"
  },
  {
    "label": "grow()",
    "kind": "Method",
    "detail": "Function (CurSize = 0 ; this ->)",
    "insertText": "grow(RHSSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(CurSize)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(RHS.begin(), RHS.begin()+CurSize, this->begin())"
  },
  {
    "label": "uninitialized_copy()",
    "kind": "Method",
    "detail": "Function (} this ->)",
    "insertText": "uninitialized_copy(RHS.begin()+CurSize, RHS.end(), this->begin()+CurSize)"
  },
  {
    "label": "setEnd()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setEnd(this->begin()+RHSSize)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "move(RHS.begin(), RHS.begin()+CurSize, this->begin())"
  },
  {
    "label": "uninitialized_move()",
    "kind": "Method",
    "detail": "Function (} this ->)",
    "insertText": "uninitialized_move(RHS.begin()+CurSize, RHS.end(), this->begin()+CurSize)"
  },
  {
    "label": "SmallVector()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SmallVector(size_t Size, const T &Value = T()) : SmallVectorImpl<T>(N)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "assign(Size, Value)"
  },
  {
    "label": "SmallVector()",
    "kind": "Method",
    "detail": "Function (} template<ItTy>)",
    "insertText": "SmallVector(ItTy S, ItTy E) : SmallVectorImpl<T>(N)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "append(S, E)"
  },
  {
    "label": "SmallVector()",
    "kind": "Method",
    "detail": "Function (} template<RangeTy>)",
    "insertText": "SmallVector(const llvm::iterator_range<RangeTy> R) : SmallVectorImpl<T>(N)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "append(R.begin(), R.end())"
  },
  {
    "label": "SmallVector()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SmallVector(std::initializer_list<T> IL) : SmallVectorImpl<T>(N)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "assign(IL)"
  },
  {
    "label": "SmallVector()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SmallVector(const SmallVector &RHS) : SmallVectorImpl<T>(N)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const SmallVector&)",
    "insertText": "operator(const SmallVector &RHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (SmallVectorImpl<T)",
    "insertText": "operator(RHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const SmallVector&)",
    "insertText": "operator(SmallVector &&RHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (SmallVectorImpl<T)",
    "insertText": "operator(::std::move(RHS))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const SmallVector&)",
    "insertText": "operator(SmallVectorImpl<T> &&RHS)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} } namespace std { template<T> void)",
    "insertText": "swap(llvm::SmallVectorImpl<T> &LHS, llvm::SmallVectorImpl<T> &RHS)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (LHS .)",
    "insertText": "swap(RHS)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} template<T,unsigned N> void)",
    "insertText": "swap(llvm::SmallVector<T, N> &LHS, llvm::SmallVector<T, N> &RHS)"
  }
]