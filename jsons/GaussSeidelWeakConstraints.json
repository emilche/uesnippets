[
  {
    "label": "FGaussSeidelWeakConstraintSingleData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGaussSeidelWeakConstraintSingleData"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TGaussSeidelWeakConstraintData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TGaussSeidelWeakConstraintData"
  },
  {
    "label": "FGaussSeidelWeakConstraints",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGaussSeidelWeakConstraints"
  },
  {
    "label": "FGaussSeidelConstraintHandle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGaussSeidelConstraintHandle"
  },
  {
    "label": "SingleStiffness()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / BoundingVolumeHierarchy . h \" # include \" Chaos / PBDSpringConstraintsBase . h \" # include \" Chaos / XPBDCorotatedConstraints . h \" # include \" ChaosStats . h \" # include \" Chaos / ImplicitQRSVD . h \" # include \" Chaos / GraphColoring . h \" # include \" Chaos / NewtonCorotatedCache . h \" # include \" Chaos / Framework / Parallel . h \" # include \" Chaos / Utilities . h \" # include \" Chaos / DebugDrawQueue . h \" # include \" Chaos / XPBDWeakConstraints . h \" # include \" Chaos / Triangle . h \" # include \" Chaos / TriangleCollisionPoint . h \" # include \" Chaos / TriangleMesh . h \" # include<unordered_map> namespace Chaos::Softs { using Chaos::TVec3 ; template<T> struct FGaussSeidelWeakConstraintSingleData { TArray<int32> SingleIndices = { } ; TArray<int32> SingleSecondIndices = { } ; T)",
    "insertText": "SingleStiffness(T)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TArray<T> SingleWeights = { } ; TArray<T> SingleSecondWeights = { } ; bool bIsAnisotropic = false ; TVec3<T> SingleNormal = TVec3<)",
    "insertText": "T((T)0.)"
  },
  {
    "label": "TGaussSeidelWeakConstraintData()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> class TGaussSeidelWeakConstraintData : public TArrayCollection { public :)",
    "insertText": "TGaussSeidelWeakConstraintData()"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MIndices)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MSecondIndices)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MWeights)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MSecondWeights)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MStiffness)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MIsAnisotropic)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MNormals)"
  },
  {
    "label": "TGaussSeidelWeakConstraintData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TGaussSeidelWeakConstraintData(const TGaussSeidelWeakConstraintData<T>& Other)"
  },
  {
    "label": "TGaussSeidelWeakConstraintData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TGaussSeidelWeakConstraintData(TGaussSeidelWeakConstraintData<T>&& Other) : TArrayCollection(), MIndices(MoveTemp(Other.MIndices)) , MSecondIndices(MoveTemp(Other.MSecondIndices)) , MWeights(MoveTemp(Other.MWeights)) , MSecondWeights(MoveTemp(Other.MSecondWeights)) , MStiffness(MoveTemp(Other.MStiffness)) , MIsAnisotropic(MoveTemp(Other.MIsAnisotropic))"
  },
  {
    "label": "AddParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddParticles(Other.Size())"
  },
  {
    "label": "AddConstraints()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddConstraints(const int32 Num)"
  },
  {
    "label": "AddElementsHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElementsHelper(Num)"
  },
  {
    "label": "RemoveConstraint()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveConstraint(const int32 Idx)"
  },
  {
    "label": "RemoveAtSwapHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAtSwapHelper(Idx)"
  },
  {
    "label": "SetSingleConstraint()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSingleConstraint(const FGaussSeidelWeakConstraintSingleData<T>& SingleData, const int32 ConstraintIndex)"
  },
  {
    "label": "AddSingleConstraint()",
    "kind": "Method",
    "detail": "Function (MIndices [ ConstraintIndex ] = SingleData . SingleIndices ; MSecondIndices [ ConstraintIndex ] = SingleData . SingleSecondIndices ; MStiffness [ ConstraintIndex ] = SingleData . SingleStiffness ; MWeights [ ConstraintIndex ] = SingleData . SingleWeights ; MSecondWeights [ ConstraintIndex ] = SingleData . SingleSecondWeights ; MNormals [ ConstraintIndex ] = SingleData . SingleNormal ; MIsAnisotropic [ ConstraintIndex ] = SingleData . bIsAnisotropic ; } void)",
    "insertText": "AddSingleConstraint(const FGaussSeidelWeakConstraintSingleData<T>& SingleData)"
  },
  {
    "label": "AddConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddConstraints(1)"
  },
  {
    "label": "SetSingleConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSingleConstraint(SingleData, MSize - 1)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Size()"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Resize(const int32 Num)"
  },
  {
    "label": "ResizeHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeHelper(Num)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TGaussSeidelWeakConstraintData&)",
    "insertText": "operator(TGaussSeidelWeakConstraintData<T>&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MIndices =)",
    "insertText": "MoveTemp(Other.MIndices)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MSecondIndices =)",
    "insertText": "MoveTemp(Other.MSecondIndices)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MWeights =)",
    "insertText": "MoveTemp(Other.MWeights)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MSecondWeights =)",
    "insertText": "MoveTemp(Other.MSecondWeights)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MStiffness =)",
    "insertText": "MoveTemp(Other.MStiffness)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MIsAnisotropic =)",
    "insertText": "MoveTemp(Other.MIsAnisotropic)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MNormals =)",
    "insertText": "MoveTemp(Other.MNormals)"
  },
  {
    "label": "ResizeHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeHelper(Other.Size())"
  },
  {
    "label": "Indices()",
    "kind": "Method",
    "detail": "Function (Other . MSize = 0 ; return* this ; } const TArrayCollectionArray<TArray<int32>>&)",
    "insertText": "Indices()"
  },
  {
    "label": "SecondIndices()",
    "kind": "Method",
    "detail": "Function (MIndices [ Index ] = InIndices ; } const TArrayCollectionArray<TArray<int32>>&)",
    "insertText": "SecondIndices()"
  },
  {
    "label": "Weights()",
    "kind": "Method",
    "detail": "Function (MSecondIndices [ Index ] = InIndices ; } const TArrayCollectionArray<TArray<T>>&)",
    "insertText": "Weights()"
  },
  {
    "label": "SecondWeights()",
    "kind": "Method",
    "detail": "Function (MWeights [ Index ] = InWeights ; } const TArrayCollectionArray<TArray<T>>&)",
    "insertText": "SecondWeights()"
  },
  {
    "label": "IsAnisotropic()",
    "kind": "Method",
    "detail": "Function (MSecondWeights [ Index ] = InWeights ; } const TArrayCollectionArray<bool>&)",
    "insertText": "IsAnisotropic()"
  },
  {
    "label": "Normals()",
    "kind": "Method",
    "detail": "Function (MIsAnisotropic [ Index ] = InIsAnisotropic ; } const TArrayCollectionArray<TVec3<T>>&)",
    "insertText": "Normals()"
  },
  {
    "label": "Stiffness()",
    "kind": "Method",
    "detail": "Function (MNormals [ Index ] = InNormal ; } const TArrayCollectionArray<T>&)",
    "insertText": "Stiffness()"
  },
  {
    "label": "GetSingleConstraintData()",
    "kind": "Method",
    "detail": "Function (MStiffness [ Index ] = InStiffness ; } const FGaussSeidelWeakConstraintSingleData<T>)",
    "insertText": "GetSingleConstraintData(const int32 ConstraintIndex)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (FGaussSeidelWeakConstraintSingleData<T> SingleConstraintData ;)",
    "insertText": "check(static_cast<uint32>(ConstraintIndex) < MSize)"
  },
  {
    "label": "FGaussSeidelWeakConstraints()",
    "kind": "Method",
    "detail": "Function (SingleConstraintData . SingleIndices = MIndices [ ConstraintIndex ] ; SingleConstraintData . SingleSecondIndices = MSecondIndices [ ConstraintIndex ] ; SingleConstraintData . SingleStiffness = MStiffness [ ConstraintIndex ] ; SingleConstraintData . SingleWeights = MWeights [ ConstraintIndex ] ; SingleConstraintData . SingleSecondWeights = MSecondWeights [ ConstraintIndex ] ; SingleConstraintData . bIsAnisotropic = MIsAnisotropic [ ConstraintIndex ] ; SingleConstraintData . SingleNormal = MNormals [ ConstraintIndex ] ; } return SingleConstraintData ; } private : TArrayCollectionArray<TArray<int32>> MIndices ; TArrayCollectionArray<TArray<int32>> MSecondIndices ; TArrayCollectionArray<TArray<T>> MWeights ; TArrayCollectionArray<TArray<T>> MSecondWeights ; TArrayCollectionArray<T> MStiffness ; TArrayCollectionArray<bool> MIsAnisotropic ; TArrayCollectionArray<TVector<T,3>> MNormals ; } ; template<T,ParticleType> struct FGaussSeidelWeakConstraints {)",
    "insertText": "FGaussSeidelWeakConstraints(const TArray<TArray<int32>>& InIndices, const TArray<TArray<T>>& InWeights, const TArray<T>& InStiffness, const TArray<TArray<int32>>& InSecondIndices, const TArray<TArray<T>>& InSecondWeights, const FDeformableXPBDWeakConstraintParams& InParams ): DebugDrawParams(InParams)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (ConstraintsData .)",
    "insertText": "Resize(0)"
  },
  {
    "label": "AddConstraints()",
    "kind": "Method",
    "detail": "Function (ConstraintsData .)",
    "insertText": "AddConstraints(InIndices.Num())"
  },
  {
    "label": "SetSingleConstraint()",
    "kind": "Method",
    "detail": "Function (FGaussSeidelWeakConstraintSingleData<T> SingleConstraintData ; SingleConstraintData . SingleIndices = InIndices [ i ] ; SingleConstraintData . SingleSecondIndices = InSecondIndices [ i ] ; SingleConstraintData . SingleWeights = InWeights [ i ] ; SingleConstraintData . SingleSecondWeights = InSecondWeights [ i ] ; SingleConstraintData . SingleStiffness = InStiffness [ i ] ; ConstraintsData .)",
    "insertText": "SetSingleConstraint(SingleConstraintData, i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 i = 0; i < ConstraintsData.Size(); i++)"
  },
  {
    "label": "GetIndices()",
    "kind": "Method",
    "detail": "Function (const TArray<int32>& SingleIndices = ConstraintsData .)",
    "insertText": "GetIndices(i)"
  },
  {
    "label": "GetSecondIndices()",
    "kind": "Method",
    "detail": "Function (const TArray<int32>& SingleSecondIndices = ConstraintsData .)",
    "insertText": "GetSecondIndices(i)"
  },
  {
    "label": "FGaussSeidelWeakConstraints()",
    "kind": "Method",
    "detail": "Function (} } } struct FGaussSeidelConstraintHandle { int32 ConstraintIndex ; } ; ~)",
    "insertText": "FGaussSeidelWeakConstraints()"
  },
  {
    "label": "ComputeInitialWCData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ComputeInitialWCData(const ParticleType& InParticles)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (TArray<TArray<int32>> ExtraConstraints ; ExtraConstraints .)",
    "insertText": "Init(TArray<int32>(), ConstraintsData.Size())"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (ExtraConstraints [ i ] .)",
    "insertText": "SetNum(ConstraintsData.GetIndices(i).Num() + ConstraintsData.GetSecondIndices(i).Num())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 j = 0; j < ConstraintsData.GetSecondIndices(i).Num(); j++)"
  },
  {
    "label": "GetIndices()",
    "kind": "Method",
    "detail": "Function (ExtraConstraints [ i ] [ j + ConstraintsData .)",
    "insertText": "GetIndices(i).Num()] = ConstraintsData.GetSecondIndices(i)"
  },
  {
    "label": "ComputeIncidentElements()",
    "kind": "Method",
    "detail": "Function (} } WCIncidentElements = Chaos::)",
    "insertText": "ComputeIncidentElements(ExtraConstraints, &WCIncidentElementsLocal)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (NodalWeights .)",
    "insertText": "Init({}, InParticles.Size())"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (int32 p = ExtraConstraints [ WCIncidentElements [ i ] [ 0 ] ] [ WCIncidentElementsLocal [ i ] [ 0 ] ] ; NodalWeights [ p ] .)",
    "insertText": "Init(T(0), 6)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (int32 ConstraintIndex = WCIncidentElements [ i ] [ j ] ; int32 LocalIndex = WCIncidentElementsLocal [ i ] [ j ] ; T Weight =)",
    "insertText": "T(0)"
  },
  {
    "label": "GetSecondWeights()",
    "kind": "Method",
    "detail": "Function (Weight = ConstraintsData .)",
    "insertText": "GetSecondWeights(ConstraintIndex)[LocalIndex - ConstraintsData.GetIndices(ConstraintIndex).Num()"
  },
  {
    "label": "GetWeights()",
    "kind": "Method",
    "detail": "Function (} else { Weight = ConstraintsData .)",
    "insertText": "GetWeights(ConstraintIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ConstraintsData.GetIsAnisotropic(ConstraintIndex))"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (NodalWeights [ p ] [ alpha ] + = ConstraintsData .)",
    "insertText": "GetNormal(ConstraintIndex)[alpha] * ConstraintsData.GetNormal(ConstraintIndex)[alpha] * Weight * Weight * ConstraintsData.GetStiffness(ConstraintIndex)"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (} NodalWeights [ p ] [ 3 ] + = ConstraintsData .)",
    "insertText": "GetNormal(ConstraintIndex)[0] * ConstraintsData.GetNormal(ConstraintIndex)[1] * Weight * Weight * ConstraintsData.GetStiffness(ConstraintIndex)"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (NodalWeights [ p ] [ 4 ] + = ConstraintsData .)",
    "insertText": "GetNormal(ConstraintIndex)[0] * ConstraintsData.GetNormal(ConstraintIndex)[2] * Weight * Weight * ConstraintsData.GetStiffness(ConstraintIndex)"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (NodalWeights [ p ] [ 5 ] + = ConstraintsData .)",
    "insertText": "GetNormal(ConstraintIndex)[1] * ConstraintsData.GetNormal(ConstraintIndex)[2] * Weight * Weight * ConstraintsData.GetStiffness(ConstraintIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(int32 alpha = 0; alpha < 3; alpha++)"
  },
  {
    "label": "GetStiffness()",
    "kind": "Method",
    "detail": "Function (NodalWeights [ p ] [ alpha ] + = Weight* Weight* ConstraintsData .)",
    "insertText": "GetStiffness(ConstraintIndex)"
  },
  {
    "label": "AddWCResidual()",
    "kind": "Method",
    "detail": "Function (NoCollisionWCIncidentElements = WCIncidentElements ; NoCollisionWCIncidentElementsLocal = WCIncidentElementsLocal ; } void)",
    "insertText": "AddWCResidual(const ParticleType& InParticles, const int32 p, const T Dt, TVec3<T>& res)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 WCIndex = Particle2WCIndices [ p ] ;)",
    "insertText": "if(WCIndex != INDEX_NONE)"
  },
  {
    "label": "SpringEdge()",
    "kind": "Method",
    "detail": "Function (int32 ConstraintIndex = WCIncidentElements [ WCIndex ] [ j ] ; int32 LocalIndex = WCIncidentElementsLocal [ WCIndex ] [ j ] ; TVec3<T>)",
    "insertText": "SpringEdge((T)0.)"
  },
  {
    "label": "GetSecondWeights()",
    "kind": "Method",
    "detail": "Function (const TArray<T>& SecondWeight = ConstraintsData .)",
    "insertText": "GetSecondWeights(ConstraintIndex)"
  },
  {
    "label": "GetIndices()",
    "kind": "Method",
    "detail": "Function (const TArray<int32>& LocalIndices = ConstraintsData .)",
    "insertText": "GetIndices(ConstraintIndex)"
  },
  {
    "label": "GetSecondIndices()",
    "kind": "Method",
    "detail": "Function (const TArray<int32>& LocalSecondIndices = ConstraintsData .)",
    "insertText": "GetSecondIndices(ConstraintIndex)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (SpringEdge [ beta ] + = Weight [ l ]* InParticles .)",
    "insertText": "P(LocalIndices[l])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(int32 l = 0; l < LocalSecondIndices.Num(); l++)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (SpringEdge [ beta ] - = SecondWeight [ l ]* InParticles .)",
    "insertText": "P(LocalSecondIndices[l])"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (weight = - SecondWeight [ LocalIndex - LocalIndices .)",
    "insertText": "Num()"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (T comp = TVec3<T)",
    "insertText": "DotProduct(SpringEdge, ConstraintsData.GetNormal(ConstraintIndex))"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (TVec3<T> proj = ConstraintsData .)",
    "insertText": "GetNormal(ConstraintIndex)"
  },
  {
    "label": "AddWCHessian()",
    "kind": "Method",
    "detail": "Function (} } } } } void)",
    "insertText": "AddWCHessian(const int32 p, const T Dt, Chaos::PMatrix<T, 3, 3>& ParticleHessian)"
  },
  {
    "label": "SetAt()",
    "kind": "Method",
    "detail": "Function (ParticleHessian .)",
    "insertText": "SetAt(alpha, alpha, ParticleHessian.GetAt(alpha, alpha) + Dt * Dt * NodalWeights[p][alpha])"
  },
  {
    "label": "SetAt()",
    "kind": "Method",
    "detail": "Function (} ParticleHessian .)",
    "insertText": "SetAt(0, 1, ParticleHessian.GetAt(0, 1) + Dt * Dt * NodalWeights[p][3])"
  },
  {
    "label": "SetAt()",
    "kind": "Method",
    "detail": "Function (ParticleHessian .)",
    "insertText": "SetAt(0, 2, ParticleHessian.GetAt(0, 2) + Dt * Dt * NodalWeights[p][4])"
  },
  {
    "label": "SetAt()",
    "kind": "Method",
    "detail": "Function (ParticleHessian .)",
    "insertText": "SetAt(1, 2, ParticleHessian.GetAt(1, 2) + Dt * Dt * NodalWeights[p][5])"
  },
  {
    "label": "SetAt()",
    "kind": "Method",
    "detail": "Function (ParticleHessian .)",
    "insertText": "SetAt(1, 0, ParticleHessian.GetAt(1, 0) + Dt * Dt * NodalWeights[p][3])"
  },
  {
    "label": "SetAt()",
    "kind": "Method",
    "detail": "Function (ParticleHessian .)",
    "insertText": "SetAt(2, 0, ParticleHessian.GetAt(2, 0) + Dt * Dt * NodalWeights[p][4])"
  },
  {
    "label": "SetAt()",
    "kind": "Method",
    "detail": "Function (ParticleHessian .)",
    "insertText": "SetAt(2, 1, ParticleHessian.GetAt(2, 1) + Dt * Dt * NodalWeights[p][5])"
  },
  {
    "label": "AddExtraConstraints()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "AddExtraConstraints(const TArray<TArray<int32>>& InIndices, const TArray<TArray<T>>& InWeights, const TArray<T>& InStiffness, const TArray<TArray<int32>>& InSecondIndices, const TArray<TArray<T>>& InSecondWeights)"
  },
  {
    "label": "SetSingleConstraint()",
    "kind": "Method",
    "detail": "Function (FGaussSeidelWeakConstraintSingleData<T> SingleConstraintData ; SingleConstraintData . SingleIndices = InIndices [ i ] ; SingleConstraintData . SingleSecondIndices = InSecondIndices [ i ] ; SingleConstraintData . SingleWeights = InWeights [ i ] ; SingleConstraintData . SingleSecondWeights = InSecondWeights [ i ] ; SingleConstraintData . SingleStiffness = InStiffness [ i ] ; ConstraintsData .)",
    "insertText": "SetSingleConstraint(SingleConstraintData, i + Offset)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Resize(int32 Size)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (ConstraintsData .)",
    "insertText": "Resize(Size)"
  },
  {
    "label": "UpdatePointTriangleCollisionWCData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UpdatePointTriangleCollisionWCData(const FSolverParticles& Particles)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (TGaussSeidelWeakConstraintData<T> OriginalConstraintsData = ConstraintsData ; ConstraintsData .)",
    "insertText": "Resize(InitialWCSize)"
  },
  {
    "label": "TriPos0()",
    "kind": "Method",
    "detail": "Function (Chaos::TVector<float,3>)",
    "insertText": "TriPos0(Particles.P(IndicesTemp[0])), TriPos1(Particles.P(IndicesTemp[1])), TriPos2(Particles.P(IndicesTemp[2])), ParticlePos(Particles.P(SecondIndicesTemp[0]))"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (Chaos::TVector<T,3> Normal =)",
    "insertText": "CrossProduct(TriPos1 - TriPos0, TriPos2 - TriPos0)"
  },
  {
    "label": "AddConstraints()",
    "kind": "Method",
    "detail": "Function (ConstraintsData .)",
    "insertText": "AddConstraints(OriginalConstraintsData.GetSingleConstraintData(i))"
  },
  {
    "label": "VisualizeAllBindings()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "VisualizeAllBindings(const FSolverParticles& InParticles, const T Dt)"
  },
  {
    "label": "DoubleVert()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR auto)",
    "insertText": "DoubleVert(Chaos::TVec3<T> V)"
  },
  {
    "label": "GetSingleConstraintData()",
    "kind": "Method",
    "detail": "Function (const FGaussSeidelWeakConstraintSingleData<T>& SingleConstraintData = ConstraintsData .)",
    "insertText": "GetSingleConstraintData(i)"
  },
  {
    "label": "SourcePos()",
    "kind": "Method",
    "detail": "Function (Chaos::TVec3<T>)",
    "insertText": "SourcePos((T)0.), TargetPos((T)0.)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (SourcePos + = SingleConstraintData . SingleWeights [ j ]* InParticles .)",
    "insertText": "P(SingleConstraintData.SingleIndices[j])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 j = 0; j < SingleConstraintData.SingleSecondIndices.Num(); j++)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (TargetPos + = SingleConstraintData . SingleSecondWeights [ j ]* InParticles .)",
    "insertText": "P(SingleConstraintData.SingleSecondIndices[j])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} float ParticleThickness = DebugDrawParams . DebugParticleWidth ; float LineThickness = DebugDrawParams . DebugLineWidth ;)",
    "insertText": "if(SingleConstraintData.SingleIndices.Num() == 1)"
  },
  {
    "label": "GetInstance()",
    "kind": "Method",
    "detail": "Function (Chaos::)",
    "insertText": "GetInstance().DrawDebugPoint(DoubleVert(SourcePos), FColor::Red, false, Dt, 0, ParticleThickness)"
  },
  {
    "label": "GetInstance()",
    "kind": "Method",
    "detail": "Function (Chaos::)",
    "insertText": "GetInstance().DrawDebugPoint(DoubleVert(InParticles.P(SingleConstraintData.SingleSecondIndices[j])), FColor::Green, false, Dt, 0, ParticleThickness)"
  },
  {
    "label": "GetInstance()",
    "kind": "Method",
    "detail": "Function (Chaos::)",
    "insertText": "GetInstance().DrawDebugLine(DoubleVert(InParticles.P(SingleConstraintData.SingleSecondIndices[j])), DoubleVert(InParticles.P(SingleConstraintData.SingleSecondIndices[(j + 1) % SingleConstraintData.SingleSecondIndices.Num()])), FColor::Green, false, Dt, 0, LineThickness)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(SingleConstraintData.SingleSecondIndices.Num() == 1)"
  },
  {
    "label": "GetInstance()",
    "kind": "Method",
    "detail": "Function (Chaos::)",
    "insertText": "GetInstance().DrawDebugPoint(DoubleVert(TargetPos), FColor::Red, false, Dt, 0, ParticleThickness)"
  },
  {
    "label": "GetInstance()",
    "kind": "Method",
    "detail": "Function (Chaos::)",
    "insertText": "GetInstance().DrawDebugPoint(DoubleVert(InParticles.P(SingleConstraintData.SingleIndices[j])), FColor::Green, false, Dt, 0, ParticleThickness)"
  },
  {
    "label": "GetInstance()",
    "kind": "Method",
    "detail": "Function (Chaos::)",
    "insertText": "GetInstance().DrawDebugLine(DoubleVert(InParticles.P(SingleConstraintData.SingleIndices[j])), DoubleVert(InParticles.P(SingleConstraintData.SingleIndices[(j + 1) % SingleConstraintData.SingleIndices.Num()])), FColor::Green, false, Dt, 0, LineThickness)"
  },
  {
    "label": "GetInstance()",
    "kind": "Method",
    "detail": "Function (} } Chaos::)",
    "insertText": "GetInstance().DrawDebugLine(DoubleVert(SourcePos), DoubleVert(TargetPos), FColor::Yellow, false, Dt, 0, LineThickness)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} # endif } void)",
    "insertText": "Init(const FSolverParticles& InParticles, const T Dt)"
  },
  {
    "label": "VisualizeAllBindings()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisualizeAllBindings(InParticles, Dt)"
  },
  {
    "label": "CollisionDetectionBVH()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "CollisionDetectionBVH(const FSolverParticles& Particles, const TArray<TVec3<int32>>& SurfaceElements, const TArray<int32>& ComponentIndex, float DetectRadius = 1.f, float PositionTargetStiffness = 10000.f, bool UseAnisotropicSpring = true)"
  },
  {
    "label": "TRACE_CPUPROFILER_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_CPUPROFILER_EVENT_SCOPE(STAT_ChaosGaussSeidelWeakConstraintsCollisionDetection)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::TVector<int32,3>> SurfaceElementsArray ;)",
    "insertText": "for(int32 i = 0; i < SurfaceElements.Num(); i++)"
  },
  {
    "label": "CurrentSurfaceElements()",
    "kind": "Method",
    "detail": "Function (Chaos::TVector<int32,3>)",
    "insertText": "CurrentSurfaceElements(0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CurrentSurfaceElements [ j ] = SurfaceElements [ i ] [ j ] ; })",
    "insertText": "if(CurrentSurfaceElements[0] != INDEX_NONE && CurrentSurfaceElements[1] != INDEX_NONE && CurrentSurfaceElements[2] != INDEX_NONE)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (SurfaceElementsArray .)",
    "insertText": "Emplace(CurrentSurfaceElements)"
  },
  {
    "label": "ComputeIncidentElements()",
    "kind": "Method",
    "detail": "Function (} } TArray<TArray<int32>> LocalIndex ; TArray<TArray<int32>>* LocalIndexPtr =& LocalIndex ; TArray<TArray<int>> GlobalIndex = Chaos::)",
    "insertText": "ComputeIncidentElements(SurfaceElementsArray, LocalIndexPtr)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 ActualParticleCount = 0 ;)",
    "insertText": "for(int32 l = 0; l < GlobalIndex.Num(); l++)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (ActualParticleCount + = 1 ; } } TArray<Chaos::TVector<float,3>> SurfaceElementsPositions ; SurfaceElementsPositions .)",
    "insertText": "SetNum(ActualParticleCount)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 CurrentParticleIndex = 0 ;)",
    "insertText": "for(int32 i = 0; i < GlobalIndex.Num(); i++)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (SurfaceElementsPositions [ CurrentParticleIndex ] = Particles .)",
    "insertText": "P(SurfaceElements[GlobalIndex[i][0]][LocalIndex[i][0]])"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (SurfaceElementsMap [ CurrentParticleIndex ] = SurfaceElements [ GlobalIndex [ i ] [ 0 ] ] [ LocalIndex [ i ] [ 0 ] ] ; CurrentParticleIndex + = 1 ; } } TArray<Chaos::TSphere<Chaos::FReal,3>*> VertexSpherePtrs ; TArray<Chaos::TSphere<Chaos::FReal,3>> VertexSpheres ; VertexSpheres .)",
    "insertText": "Init(Chaos::TSphere<Chaos::FReal, 3>(Chaos::TVec3<Chaos::FReal>(0), DetectRadius), SurfaceElementsPositions.Num())"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (VertexSpherePtrs .)",
    "insertText": "SetNum(SurfaceElementsPositions.Num())"
  },
  {
    "label": "SphereCenter()",
    "kind": "Method",
    "detail": "Function (Chaos::TVec3<Chaos::FReal>)",
    "insertText": "SphereCenter(SurfaceElementsPositions[i])"
  },
  {
    "label": "VertexSphere()",
    "kind": "Method",
    "detail": "Function (Chaos::TSphere<Chaos::FReal,3>)",
    "insertText": "VertexSphere(SphereCenter, DetectRadius)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (VertexSpheres [ i ] = Chaos::TSphere<)",
    "insertText": "FReal(SphereCenter, DetectRadius)"
  },
  {
    "label": "VertexBVH()",
    "kind": "Method",
    "detail": "Function (VertexSpherePtrs [ i ] =& VertexSpheres [ i ] ; } Chaos::TBoundingVolumeHierarchy<TArray<Chaos::TSphere<Chaos::FReal,3>*>,TArray<int32>,Chaos::FReal,3>)",
    "insertText": "VertexBVH(VertexSpherePtrs)"
  },
  {
    "label": "FindAllIntersections()",
    "kind": "Method",
    "detail": "Function (TArray<int32> TriangleIntersections0 = VertexBVH .)",
    "insertText": "FindAllIntersections(Particles.P(SurfaceElements[i][0]))"
  },
  {
    "label": "FindAllIntersections()",
    "kind": "Method",
    "detail": "Function (TArray<int32> TriangleIntersections1 = VertexBVH .)",
    "insertText": "FindAllIntersections(Particles.P(SurfaceElements[i][1]))"
  },
  {
    "label": "FindAllIntersections()",
    "kind": "Method",
    "detail": "Function (TArray<int32> TriangleIntersections2 = VertexBVH .)",
    "insertText": "FindAllIntersections(Particles.P(SurfaceElements[i][2]))"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (TriangleIntersections0 .)",
    "insertText": "Sort()"
  },
  {
    "label": "TriangleIntersections()",
    "kind": "Method",
    "detail": "Function (TArray<int32>)",
    "insertText": "TriangleIntersections({})"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (TriangleIntersections .)",
    "insertText": "Emplace(TriangleIntersections0[k])"
  },
  {
    "label": "ClosestBary()",
    "kind": "Method",
    "detail": "Function (} } int32 TriangleIndex = ComponentIndex [ SurfaceElements [ i ] [ 0 ] ] ; int32 MinIndex = INDEX_NONE ; float MinDis = DetectRadius ; Chaos::TVector<float,3>)",
    "insertText": "ClosestBary(0.f)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Chaos::TVector<float,3> FaceNormal ;)",
    "insertText": "for(int32 j = 0; j < TriangleIntersections.Num(); j++)"
  },
  {
    "label": "TriPos0()",
    "kind": "Method",
    "detail": "Function (Chaos::TVector<float,3> Bary,)",
    "insertText": "TriPos0(Particles.P(SurfaceElements[i][0])), TriPos1(Particles.P(SurfaceElements[i][1])), TriPos2(Particles.P(SurfaceElements[i][2])), ParticlePos(Particles.P(SurfaceElementsMap[TriangleIntersections[j]]))"
  },
  {
    "label": "FindClosestPointAndBaryOnTriangle()",
    "kind": "Method",
    "detail": "Function (Chaos::TVector<Chaos::FRealSingle,3> ClosestPoint =)",
    "insertText": "FindClosestPointAndBaryOnTriangle(TriPos0, TriPos1, TriPos2, ParticlePos, Bary)"
  },
  {
    "label": "CurrentDistance()",
    "kind": "Method",
    "detail": "Function (Chaos::FRealSingle)",
    "insertText": "CurrentDistance(Particles.P(SurfaceElementsMap[TriangleIntersections[j]]) - ClosestPoint).Size()"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (Chaos::TVector<T,3> Normal =)",
    "insertText": "CrossProduct(TriPos2 - TriPos0, TriPos1 - TriPos0)"
  },
  {
    "label": "SafeNormalize()",
    "kind": "Method",
    "detail": "Function (Normal .)",
    "insertText": "SafeNormalize(1e-8f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MinDis = CurrentDistance ; MinIndex = SurfaceElementsMap [ TriangleIntersections [ j ] ] ; ClosestBary = Bary ; FaceNormal = Normal ; } } } })",
    "insertText": "if(MinIndex != INDEX_NONE && MinIndex != SurfaceElements[i][0] && MinIndex != SurfaceElements[i][1] && MinIndex != SurfaceElements[i][2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (FGaussSeidelWeakConstraintSingleData<T> SingleConstraintData ; SingleConstraintData . SingleIndices = { SurfaceElements [ i ] [ 0 ],SurfaceElements [ i ] [ 1 ],SurfaceElements [ i ] [ 2 ] } ; SingleConstraintData . SingleSecondIndices = { MinIndex } ; SingleConstraintData . Weights = { ClosestBary [ 0 ],ClosestBary [ 1 ],ClosestBary [ 2 ] } ; SingleConstraintData . SecondWeights = {)",
    "insertText": "T(1.f)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (SingleConstraintData . bIsAnisotropic = UseAnisotropicSpring ; SingleConstraintData . SingleNormal = FaceNormal ; float SpringStiffness = 0 . f ;)",
    "insertText": "for(int32 k = 0; k < 3; k++)"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (SpringStiffness + = ClosestBary [ k ]* PositionTargetStiffness* Particles .)",
    "insertText": "M(SurfaceElements[i][k])"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (} SpringStiffness + = PositionTargetStiffness* Particles .)",
    "insertText": "M(MinIndex)"
  },
  {
    "label": "AddSingleConstraint()",
    "kind": "Method",
    "detail": "Function (ConstraintsData .)",
    "insertText": "AddSingleConstraint(SingleConstraintData)"
  },
  {
    "label": "CollisionDetectionSpatialHash()",
    "kind": "Method",
    "detail": "Function (} } } template<SpatialAccelerator> void)",
    "insertText": "CollisionDetectionSpatialHash(const FSolverParticles& Particles, const TArray<int32>& SurfaceVertices, const FTriangleMesh& TriangleMesh, const TArray<int32>& ComponentIndex, const SpatialAccelerator& Spatial, float DetectRadius = 1.f, float PositionTargetStiffness = 10000.f, bool UseAnisotropicSpring = true)"
  },
  {
    "label": "TRACE_CPUPROFILER_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_CPUPROFILER_EVENT_SCOPE(STAT_ChaosGaussSeidelWeakConstraintsCollisionDetectionSpatialHash)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Resize(InitialWCSize + Particles.Size())"
  },
  {
    "label": "ConstraintIndex()",
    "kind": "Method",
    "detail": "Function (std::atomic<int32>)",
    "insertText": "ConstraintIndex(InitialWCSize)"
  },
  {
    "label": "GetSurfaceElements()",
    "kind": "Method",
    "detail": "Function (const TArray<TVec3<int32>>& Elements = TriangleMesh .)",
    "insertText": "GetSurfaceElements()"
  },
  {
    "label": "PhysicsParallelFor()",
    "kind": "Method",
    "detail": "Function (const float HalfRadius = DetectRadius / 2 ;)",
    "insertText": "PhysicsParallelFor(SurfaceVertices.Num(), [this, &Spatial, &Particles, &SurfaceVertices, &ConstraintIndex, &TriangleMesh, &Elements, &HalfRadius, &ComponentIndex, &PositionTargetStiffness, &UseAnisotropicSpring](int32 i) { const int32 Index = SurfaceVertices[i]; TArray< TTriangleCollisionPoint<FSolverReal>> Result; if (TriangleMesh.PointClosestTriangleQuery(Spatial, static_cast<const TArrayView<const FSolverVec3>&>(Particles.XArray()), Index, Particles.GetX(Index), HalfRadius, HalfRadius, [this, &ComponentIndex, &Elements](const int32 PointIndex, const int32 TriangleIndex)->bool { return ComponentIndex[PointIndex] != ComponentIndex[Elements[TriangleIndex][0]] && (!NoCollisionWCIncidentElements.IsValidIndex(PointIndex) || NoCollisionWCIncidentElements[PointIndex].Num() == 0); }, Result)) { for (const TTriangleCollisionPoint<FSolverReal>& CollisionPoint : Result) { if (CollisionPoint.Phi < 0) { const TVector<int32, 3>& Elem = Elements[CollisionPoint.Indices[1]]; const int32 IndexToWrite = ConstraintIndex.fetch_add(1); FGaussSeidelWeakConstraintSingleData<T> SingleConstraintData; SingleConstraintData.SingleIndices = { Elem[0], Elem[1] ,Elem[2] }; SingleConstraintData.SingleSecondIndices = { Index }; SingleConstraintData.SingleWeights = { CollisionPoint.Bary[1], CollisionPoint.Bary[2], CollisionPoint.Bary[3] }; SingleConstraintData.SingleSecondWeights = {T(1.f)}; SingleConstraintData.bIsAnisotropic = UseAnisotropicSpring; SingleConstraintData.SingleNormal = CollisionPoint.Normal; float SpringStiffness = 0.f; for (int32 k = 0; k < 3; k++) { SpringStiffness += SingleConstraintData.SingleWeights[k] * PositionTargetStiffness * Particles.M(Elem[k]); } SpringStiffness += PositionTargetStiffness * Particles.M(Index); SingleConstraintData.SingleStiffness = (T)SpringStiffness; ConstraintsData.SetSingleConstraint(SingleConstraintData, IndexToWrite); } } } })"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (const int32 ConstraintNum = ConstraintIndex .)",
    "insertText": "load()"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Resize(ConstraintNum)"
  },
  {
    "label": "CollisionDetectionSpatialHashInComponent()",
    "kind": "Method",
    "detail": "Function (} template<SpatialAccelerator> void)",
    "insertText": "CollisionDetectionSpatialHashInComponent(const FSolverParticles& Particles, const TArray<int32>& SurfaceVertices, const FTriangleMesh& TriangleMesh, const TMap<int32, TSet<int32>>& ExcludeMap, const SpatialAccelerator& Spatial, float DetectRadius = 0.f, float PositionTargetStiffness = 10000.f, bool UseAnisotropicSpring = true)"
  },
  {
    "label": "TRACE_CPUPROFILER_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_CPUPROFILER_EVENT_SCOPE(STAT_ChaosGaussSeidelWeakConstraintsCollisionDetectionSpatialHashInComponent)"
  },
  {
    "label": "PhysicsParallelFor()",
    "kind": "Method",
    "detail": "Function (const float HalfRadius = DetectRadius / 2 ;)",
    "insertText": "PhysicsParallelFor(SurfaceVertices.Num(), [this, &Spatial, &Particles, &SurfaceVertices, &ConstraintIndex, &TriangleMesh, &ExcludeMap, &Elements, &HalfRadius, &PositionTargetStiffness, &UseAnisotropicSpring](int32 i) { const int32 Index = SurfaceVertices[i]; TArray< TTriangleCollisionPoint<FSolverReal>> Result; if (TriangleMesh.PointClosestTriangleQuery(Spatial, static_cast<const TArrayView<const FSolverVec3>&>(Particles.XArray()), Index, Particles.GetX(Index), HalfRadius, HalfRadius, [this, &Elements, &ExcludeMap](const int32 PointIndex, const int32 TriangleIndex)->bool { return !(ExcludeMap.Find(PointIndex) && ExcludeMap[PointIndex].Contains(TriangleIndex)); }, Result)) { for (const TTriangleCollisionPoint<FSolverReal>& CollisionPoint : Result) { if (CollisionPoint.Phi < 0) { const TVector<int32, 3>& Elem = Elements[CollisionPoint.Indices[1]]; const int32 IndexToWrite = ConstraintIndex.fetch_add(1); FGaussSeidelWeakConstraintSingleData<T> SingleConstraintData; SingleConstraintData.SingleIndices = { Elem[0], Elem[1] ,Elem[2] }; SingleConstraintData.SingleSecondIndices = { Index }; SingleConstraintData.SingleWeights = { CollisionPoint.Bary[1], CollisionPoint.Bary[2], CollisionPoint.Bary[3] }; SingleConstraintData.SingleSecondWeights = {T(1.f)}; SingleConstraintData.bIsAnisotropic = UseAnisotropicSpring; SingleConstraintData.SingleNormal = CollisionPoint.Normal; float SpringStiffness = 0.f; for (int32 k = 0; k < 3; k++) { SpringStiffness += SingleConstraintData.SingleWeights[k] * PositionTargetStiffness * Particles.M(Elem[k]); } SpringStiffness += PositionTargetStiffness * Particles.M(Index); SingleConstraintData.SingleStiffness = (T)SpringStiffness; ConstraintsData.SetSingleConstraint(SingleConstraintData, IndexToWrite); } } } })"
  },
  {
    "label": "ComputeCollisionWCDataSimplified()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ComputeCollisionWCDataSimplified(TArray<TArray<int32>>& ExtraConstraints, TArray<TArray<int32>>& ExtraWCIncidentElements, TArray<TArray<int32>>& ExtraWCIncidentElementsLocal)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (ExtraConstraints .)",
    "insertText": "Init(TArray<int32>(), ConstraintsData.Size() - InitialWCSize)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (ExtraConstraints [ i - InitialWCSize ] .)",
    "insertText": "SetNum(LocalIndices.Num() + LocalSecondIndices.Num())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (ExtraConstraints [ i - InitialWCSize ] [ j ] = LocalIndices [ j ] ; })",
    "insertText": "for(int32 j = 0; j < LocalSecondIndices.Num(); j++)"
  },
  {
    "label": "ComputeIncidentElements()",
    "kind": "Method",
    "detail": "Function (} } ExtraWCIncidentElements = Chaos::)",
    "insertText": "ComputeIncidentElements(ExtraConstraints, &ExtraWCIncidentElementsLocal)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (NodalWeights = NoCollisionNodalWeights ;)",
    "insertText": "for(int32 i = 0; i < ExtraWCIncidentElements.Num(); i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 p = ExtraConstraints [ ExtraWCIncidentElements [ i ] [ 0 ] ] [ ExtraWCIncidentElementsLocal [ i ] [ 0 ] ] ;)",
    "insertText": "if(NodalWeights[p].Num() == 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 j = 0; j < ExtraWCIncidentElements[i].Num(); j++)"
  },
  {
    "label": "GetSingleConstraintData()",
    "kind": "Method",
    "detail": "Function (int32 LocalIndex = ExtraWCIncidentElementsLocal [ i ] [ j ] ; int32 ConstraintIndex = ExtraWCIncidentElements [ i ] [ j ] + InitialWCSize ; const FGaussSeidelWeakConstraintSingleData<T>& SingleData = ConstraintsData .)",
    "insertText": "GetSingleConstraintData(ConstraintIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { weight = SingleData . SingleWeights [ LocalIndex ] ; })",
    "insertText": "if(SingleData.bIsAnisotropic)"
  },
  {
    "label": "GetStaticConstraintArrays()",
    "kind": "Method",
    "detail": "Function (NodalWeights [ p ] [ alpha ] + = weight* weight* SingleData . SingleStiffness ; } } } } } } TArray<TArray<int32>>)",
    "insertText": "GetStaticConstraintArrays(TArray<TArray<int32>>& IncidentElements, TArray<TArray<int32>>& IncidentElementsLocal)"
  },
  {
    "label": "GetDynamicConstraintArrays()",
    "kind": "Method",
    "detail": "Function (IncidentElements = NoCollisionWCIncidentElements ; IncidentElementsLocal = NoCollisionWCIncidentElementsLocal ; return NoCollisionConstraints ; } TArray<TArray<int32>>)",
    "insertText": "GetDynamicConstraintArrays(TArray<TArray<int32>>& IncidentElements, TArray<TArray<int32>>& IncidentElementsLocal)"
  },
  {
    "label": "ComputeIncidentElements()",
    "kind": "Method",
    "detail": "Function (} } IncidentElements = Chaos::)",
    "insertText": "ComputeIncidentElements(ExtraConstraints, &IncidentElementsLocal)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (SpringEdge [ beta ] + = SingleData . SingleWeights [ l ]* InParticles .)",
    "insertText": "P(SingleData.SingleIndices[l])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(int32 l = 0; l < SingleData.SingleSecondWeights.Num(); l++)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (SpringEdge [ beta ] - = SingleData . SingleSecondWeights [ l ]* InParticles .)",
    "insertText": "P(SingleData.SingleSecondIndices[l])"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (T comp = TVec3<T)",
    "insertText": "DotProduct(SpringEdge, SingleData.SingleNormal)"
  }
]