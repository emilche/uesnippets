[
  {
    "label": "Derived",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Derived"
  },
  {
    "label": "WithId",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "WithId"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "NonStandardLayout",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NonStandardLayout"
  },
  {
    "label": "StatefulTestingHash",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StatefulTestingHash"
  },
  {
    "label": "StatefulTestingEqual",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StatefulTestingEqual"
  },
  {
    "label": "U",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U"
  },
  {
    "label": "Alloc",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Alloc"
  },
  {
    "label": "rebind",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "rebind"
  },
  {
    "label": "Map",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Map"
  },
  {
    "label": "Set",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Set"
  },
  {
    "label": "WithId()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_CONTAINER_INTERNAL_HASH_POLICY_TESTING_H_ # define ABSL_CONTAINER_INTERNAL_HASH_POLICY_TESTING_H_ # include<cstdlib> # include<limits> # include<memory> # include<ostream> # include<type_traits> # include<utility> # include<vector> # include \" absl / hash / hash . h \" # include \" absl / strings / string_view . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace container_internal { namespace hash_testing_internal { template<class Derived> struct WithId {)",
    "insertText": "WithId() : id_(next_id<Derived>())"
  },
  {
    "label": "WithId()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "WithId(const WithId& that) : id_(that.id_)"
  },
  {
    "label": "WithId()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "WithId(WithId&& that) : id_(that.id_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (that . id_ = 0 ; } WithId&)",
    "insertText": "operator(const WithId& that)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (id_ = that . id_ ; return* this ; } WithId&)",
    "insertText": "operator(WithId&& that)"
  },
  {
    "label": "id()",
    "kind": "Method",
    "detail": "Function (id_ = that . id_ ; that . id_ = 0 ; return* this ; } size_t)",
    "insertText": "id()"
  },
  {
    "label": "WithId()",
    "kind": "Method",
    "detail": "Function (} protected :)",
    "insertText": "WithId(size_t id) : id_(id)"
  },
  {
    "label": "next_id()",
    "kind": "Method",
    "detail": "Function (} private : size_t id_ ; template<class T> size_t)",
    "insertText": "next_id()"
  },
  {
    "label": "NonStandardLayout()",
    "kind": "Method",
    "detail": "Function (size_t gId = 1 ; return gId + + ; } } ; } struct NonStandardLayout {)",
    "insertText": "NonStandardLayout()"
  },
  {
    "label": "NonStandardLayout()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NonStandardLayout(std::string s) : value(std::move(s))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const NonStandardLayout& a, const NonStandardLayout& b)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} std::string value ; } ; struct StatefulTestingHash : absl::container_internal::hash_testing_internal::WithId<StatefulTestingHash> { template<class T> size_t)",
    "insertText": "operator()(const T& t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; struct StatefulTestingEqual : absl::container_internal::hash_testing_internal::WithId<StatefulTestingEqual> { template<class T,class U> bool)",
    "insertText": "operator()(const T& t, const U& u)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Alloc(const Alloc&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Alloc&)",
    "insertText": "operator(const Alloc&)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (template<class U>)",
    "insertText": "Alloc(const Alloc<U>& that) : std::allocator<T>(that), id_(that.id())"
  },
  {
    "label": "id_()",
    "kind": "Method",
    "detail": "Function (} private : size_t)",
    "insertText": "id_(std::numeric_limits<size_t>::max)()"
  },
  {
    "label": "items()",
    "kind": "Method",
    "detail": "Function (std::vector<\n    std::pair<typename Map::key_type, typename Map::mapped_type>>)",
    "insertText": "items(const Map& m)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (using std::get ; std::vector<std::pair<Map::key_type,Map::mapped_type>> res ; res .)",
    "insertText": "reserve(m.size())"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::vector<std::decay<Set::key_type>::type> res ; res .)",
    "insertText": "reserve(s.size())"
  }
]