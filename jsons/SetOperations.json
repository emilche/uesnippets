[
  {
    "label": "S1Ty",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "S1Ty"
  },
  {
    "label": "S2Ty",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "S2Ty"
  },
  {
    "label": "set_union()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ADT_SETOPERATIONS_H # define LLVM_ADT_SETOPERATIONS_H namespace llvm { template<class S1Ty,class S2Ty> bool)",
    "insertText": "set_union(S1Ty &S1, const S2Ty &S2)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool Changed = false ;)",
    "insertText": "for(typename S2Ty::const_iterator SI = S2.begin(), SE = S2.end(); SI != SE; ++SI) if (S1.insert(*SI).second)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const S1Ty::key_type& E =* I ; + + I ;)",
    "insertText": "if(!S2.count(E)) S1.erase(E)"
  },
  {
    "label": "set_difference()",
    "kind": "Method",
    "detail": "Function (} } template<class S1Ty,class S2Ty> S1Ty)",
    "insertText": "set_difference(const S1Ty &S1, const S2Ty &S2)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (S1Ty Result ;)",
    "insertText": "for(typename S1Ty::const_iterator SI = S1.begin(), SE = S1.end(); SI != SE; ++SI) if (!S2.count(*SI)) Result.insert(*SI)"
  }
]