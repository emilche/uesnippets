[
  {
    "label": "MeshToVolumeFlags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "MeshToVolumeFlags"
  },
  {
    "label": "QuadAndTriangleDataAdapter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "QuadAndTriangleDataAdapter"
  },
  {
    "label": "MeshToVoxelEdgeData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MeshToVoxelEdgeData"
  },
  {
    "label": "EdgeData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EdgeData"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "GenEdgeData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GenEdgeData"
  },
  {
    "label": "TransformPoints",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TransformPoints"
  },
  {
    "label": "Tolerance",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Tolerance"
  },
  {
    "label": "CombineLeafNodes",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CombineLeafNodes"
  },
  {
    "label": "StashOriginAndStoreOffset",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StashOriginAndStoreOffset"
  },
  {
    "label": "RestoreOrigin",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RestoreOrigin"
  },
  {
    "label": "ComputeNodeConnectivity",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ComputeNodeConnectivity"
  },
  {
    "label": "LeafNodeConnectivityTable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LeafNodeConnectivityTable"
  },
  {
    "label": "SweepExteriorSign",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SweepExteriorSign"
  },
  {
    "label": "Axis",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Axis"
  },
  {
    "label": "SeedFillExteriorSign",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SeedFillExteriorSign"
  },
  {
    "label": "FillArray",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FillArray"
  },
  {
    "label": "SyncVoxelMask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SyncVoxelMask"
  },
  {
    "label": "SeedPoints",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SeedPoints"
  },
  {
    "label": "ComputeIntersectingVoxelSign",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ComputeIntersectingVoxelSign"
  },
  {
    "label": "ValidateIntersectingVoxels",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValidateIntersectingVoxels"
  },
  {
    "label": "IsNegative",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsNegative"
  },
  {
    "label": "RemoveSelfIntersectingSurface",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RemoveSelfIntersectingSurface"
  },
  {
    "label": "Comp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Comp"
  },
  {
    "label": "ReleaseChildNodes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ReleaseChildNodes"
  },
  {
    "label": "StealUniqueLeafNodes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StealUniqueLeafNodes"
  },
  {
    "label": "VoxelizationData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VoxelizationData"
  },
  {
    "label": "VoxelizePolygons",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VoxelizePolygons"
  },
  {
    "label": "Triangle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Triangle"
  },
  {
    "label": "SubTask",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SubTask"
  },
  {
    "label": "DiffLeafNodeMask",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DiffLeafNodeMask"
  },
  {
    "label": "UnionValueMasks",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnionValueMasks"
  },
  {
    "label": "ConstructVoxelMask",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConstructVoxelMask"
  },
  {
    "label": "ExpandNarrowband",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpandNarrowband"
  },
  {
    "label": "Fragment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Fragment"
  },
  {
    "label": "AddNodes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AddNodes"
  },
  {
    "label": "TransformValues",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TransformValues"
  },
  {
    "label": "InactivateValues",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InactivateValues"
  },
  {
    "label": "OffsetValues",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OffsetValues"
  },
  {
    "label": "Renormalize",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Renormalize"
  },
  {
    "label": "MinCombine",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MinCombine"
  },
  {
    "label": "Primitive",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Primitive"
  },
  {
    "label": "meshToVolume()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TOOLS_MESH_TO_VOLUME_HAS_BEEN_INCLUDED # define OPENVDB_TOOLS_MESH_TO_VOLUME_HAS_BEEN_INCLUDED # include<openvdb / Platform . h> # include<openvdb / Types . h> # include<openvdb / math / FiniteDifference . h> # include<openvdb / math / Proximity . h> # include<openvdb / util / NullInterrupter . h> # include<openvdb / util / Util . h> # include \" ChangeBackground . h \" # include \" Prune . h \" # include \" SignedFloodFill . h \" # include<tbb / blocked_range . h> # include<tbb / enumerable_thread_specific . h> # include<tbb / parallel_for . h> # include<tbb / parallel_reduce . h> # include<tbb / partitioner . h> # include<tbb / task_group . h> # include<tbb / task_scheduler_init . h> # include<algorithm> # include<cmath> # include<deque> # include<limits> # include<memory> # include<sstream> # include<type_traits> # include<vector> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tools { enum MeshToVolumeFlags { UNSIGNED_DISTANCE_FIELD = 0 x1,DISABLE_INTERSECTING_VOXEL_REMOVAL = 0 x2,DISABLE_RENORMALIZATION = 0 x4,DISABLE_NARROW_BAND_TRIMMING = 0 x8 } ; template<GridType,MeshDataAdapter> GridType::Ptr)",
    "insertText": "meshToVolume(const MeshDataAdapter& mesh, const math::Transform& transform, float exteriorBandWidth = 3.0f, float interiorBandWidth = 3.0f, int flags = 0, typename GridType::template ValueConverter<Int32>::Type * polygonIndexGrid = nullptr)"
  },
  {
    "label": "meshToVolume()",
    "kind": "Method",
    "detail": "Function (template<GridType,MeshDataAdapter,Interrupter> GridType::Ptr)",
    "insertText": "meshToVolume(Interrupter& interrupter, const MeshDataAdapter& mesh, const math::Transform& transform, float exteriorBandWidth = 3.0f, float interiorBandWidth = 3.0f, int flags = 0, typename GridType::template ValueConverter<Int32>::Type * polygonIndexGrid = nullptr)"
  },
  {
    "label": "QuadAndTriangleDataAdapter()",
    "kind": "Method",
    "detail": "Function (template<PointType,PolygonType> struct QuadAndTriangleDataAdapter {)",
    "insertText": "QuadAndTriangleDataAdapter(const std::vector<PointType>& points, const std::vector<PolygonType>& polygons) : mPointArray(points.empty() ? nullptr : &points[0]) , mPointArraySize(points.size()) , mPolygonArray(polygons.empty() ? nullptr : &polygons[0]) , mPolygonArraySize(polygons.size())"
  },
  {
    "label": "QuadAndTriangleDataAdapter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "QuadAndTriangleDataAdapter(const PointType * pointArray, size_t pointArraySize, const PolygonType* polygonArray, size_t polygonArraySize) : mPointArray(pointArray) , mPointArraySize(pointArraySize) , mPolygonArray(polygonArray) , mPolygonArraySize(polygonArraySize)"
  },
  {
    "label": "polygonCount()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "polygonCount()"
  },
  {
    "label": "getIndexSpacePoint()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "getIndexSpacePoint(size_t n, size_t v, Vec3d& pos)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (const PointType& p = mPointArray [ mPolygonArray [ n ] [)",
    "insertText": "int(v)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pos [ 0 ] =)",
    "insertText": "double(p[0])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pos [ 1 ] =)",
    "insertText": "double(p[1])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pos [ 2 ] =)",
    "insertText": "double(p[2])"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (} private : PointType const* const mPointArray ; size_t const mPointArraySize ; PolygonType const* const mPolygonArray ; size_t const mPolygonArraySize ; } ; template<GridType> GridType::Ptr)",
    "insertText": "meshToLevelSet(const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, float halfWidth = float(LEVEL_SET_HALF_WIDTH))"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (template<GridType,Interrupter> GridType::Ptr)",
    "insertText": "meshToLevelSet(Interrupter& interrupter, const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, float halfWidth = float(LEVEL_SET_HALF_WIDTH))"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::Ptr)",
    "insertText": "meshToLevelSet(const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec4I>& quads, float halfWidth = float(LEVEL_SET_HALF_WIDTH))"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (template<GridType,Interrupter> GridType::Ptr)",
    "insertText": "meshToLevelSet(Interrupter& interrupter, const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec4I>& quads, float halfWidth = float(LEVEL_SET_HALF_WIDTH))"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::Ptr)",
    "insertText": "meshToLevelSet(const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, const std::vector<Vec4I>& quads, float halfWidth = float(LEVEL_SET_HALF_WIDTH))"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (template<GridType,Interrupter> GridType::Ptr)",
    "insertText": "meshToLevelSet(Interrupter& interrupter, const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, const std::vector<Vec4I>& quads, float halfWidth = float(LEVEL_SET_HALF_WIDTH))"
  },
  {
    "label": "meshToSignedDistanceField()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::Ptr)",
    "insertText": "meshToSignedDistanceField(const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, const std::vector<Vec4I>& quads, float exBandWidth, float inBandWidth)"
  },
  {
    "label": "meshToSignedDistanceField()",
    "kind": "Method",
    "detail": "Function (template<GridType,Interrupter> GridType::Ptr)",
    "insertText": "meshToSignedDistanceField(Interrupter& interrupter, const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, const std::vector<Vec4I>& quads, float exBandWidth, float inBandWidth)"
  },
  {
    "label": "meshToUnsignedDistanceField()",
    "kind": "Method",
    "detail": "Function (template<GridType> GridType::Ptr)",
    "insertText": "meshToUnsignedDistanceField(const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, const std::vector<Vec4I>& quads, float bandWidth)"
  },
  {
    "label": "meshToUnsignedDistanceField()",
    "kind": "Method",
    "detail": "Function (template<GridType,Interrupter> GridType::Ptr)",
    "insertText": "meshToUnsignedDistanceField(Interrupter& interrupter, const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, const std::vector<Vec4I>& quads, float bandWidth)"
  },
  {
    "label": "createLevelSetBox()",
    "kind": "Method",
    "detail": "Function (template<GridType,VecType> GridType::Ptr)",
    "insertText": "createLevelSetBox(const math::BBox<VecType>& bbox, const openvdb::math::Transform& xform, typename VecType::ValueType halfWidth = LEVEL_SET_HALF_WIDTH)"
  },
  {
    "label": "traceExteriorBoundaries()",
    "kind": "Method",
    "detail": "Function (template<FloatTreeT> void)",
    "insertText": "traceExteriorBoundaries(FloatTreeT& tree)"
  },
  {
    "label": "EdgeData()",
    "kind": "Method",
    "detail": "Function (class MeshToVoxelEdgeData { public : struct EdgeData {)",
    "insertText": "EdgeData(float dist = 1.0) : mXDist(dist), mYDist(dist), mZDist(dist) , mXPrim(util::INVALID_IDX) , mYPrim(util::INVALID_IDX) , mZPrim(util::INVALID_IDX)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const EdgeData&)"
  },
  {
    "label": "convert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "convert(const std::vector<Vec3s>& pointList, const std::vector<Vec4I>& polygonList)"
  },
  {
    "label": "getEdgeData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getEdgeData(Accessor& acc, const Coord& ijk, std::vector<Vec3d>& points, std::vector<Index32>& primitives)"
  },
  {
    "label": "getAccessor()",
    "kind": "Method",
    "detail": "Function (Accessor)",
    "insertText": "getAccessor()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "operator(const MeshToVoxelEdgeData&)"
  },
  {
    "label": "TransformPoints()",
    "kind": "Method",
    "detail": "Function (} TreeType mTree ; class GenEdgeData ; } ; namespace mesh_to_volume_internal { template<PointType> struct TransformPoints {)",
    "insertText": "TransformPoints(const PointType* pointsIn, PointType* pointsOut, const math::Transform& xform) : mPointsIn(pointsIn), mPointsOut(pointsOut), mXform(&xform)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const tbb::blocked_range<size_t>& range)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Vec3d pos ;)",
    "insertText": "for(size_t n = range.begin(), N = range.end(); n < N; ++n)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (const PointType& wsP = mPointsIn [ n ] ; pos [ 0 ] =)",
    "insertText": "double(wsP[0])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pos [ 1 ] =)",
    "insertText": "double(wsP[1])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pos [ 2 ] =)",
    "insertText": "double(wsP[2])"
  },
  {
    "label": "worldToIndex()",
    "kind": "Method",
    "detail": "Function (pos = mXform ->)",
    "insertText": "worldToIndex(pos)"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (PointType& isP = mPointsOut [ n ] ; isP [ 0 ] =)",
    "insertText": "value_type(pos[0])"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (isP [ 1 ] =)",
    "insertText": "value_type(pos[1])"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (isP [ 2 ] =)",
    "insertText": "value_type(pos[2])"
  },
  {
    "label": "epsilon()",
    "kind": "Method",
    "detail": "Function (} } PointType const* const mPointsIn ; PointType* const mPointsOut ; math::Transform const* const mXform ; } ; template<ValueType> struct Tolerance { ValueType)",
    "insertText": "epsilon()"
  },
  {
    "label": "minNarrowBandWidth()",
    "kind": "Method",
    "detail": "Function (} ValueType)",
    "insertText": "minNarrowBandWidth()"
  },
  {
    "label": "CombineLeafNodes()",
    "kind": "Method",
    "detail": "Function (} } ; template<TreeType> class CombineLeafNodes { public : using Int32TreeType = TreeType::template ValueConverter<Int32>::Type ; using LeafNodeType = TreeType::LeafNodeType ; using Int32LeafNodeType = Int32TreeType::LeafNodeType ;)",
    "insertText": "CombineLeafNodes(TreeType& lhsDistTree, Int32TreeType& lhsIdxTree, LeafNodeType ** rhsDistNodes, Int32LeafNodeType ** rhsIdxNodes) : mDistTree(&lhsDistTree) , mIdxTree(&lhsIdxTree) , mRhsDistNodes(rhsDistNodes) , mRhsIdxNodes(rhsIdxNodes)"
  },
  {
    "label": "distAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<TreeType>)",
    "insertText": "distAcc(*mDistTree)"
  },
  {
    "label": "idxAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<Int32TreeType>)",
    "insertText": "idxAcc(*mIdxTree)"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (const Coord& origin = mRhsDistNodes [ n ] ->)",
    "insertText": "origin()"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (LeafNodeType* lhsDistNode = distAcc .)",
    "insertText": "probeLeaf(origin)"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (DistValueType* lhsDistData = lhsDistNode ->)",
    "insertText": "buffer().data()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const DistValueType& lhsValue = lhsDistData [ offset ] ; const DistValueType& rhsValue = rhsDistData [ offset ] ;)",
    "insertText": "if(rhsValue < lhsValue)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (lhsDistNode ->)",
    "insertText": "setValueOn(offset, rhsValue)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (lhsIdxNode ->)",
    "insertText": "setValueOn(offset, rhsIdxData[offset])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(math::isExactlyEqual(rhsValue, lhsValue))"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (lhsIdxNode ->)",
    "insertText": "setValueOn(offset, std::min(lhsIdxData[offset], rhsIdxData[offset]))"
  },
  {
    "label": "StashOriginAndStoreOffset()",
    "kind": "Method",
    "detail": "Function (} } } delete mRhsDistNodes [ n ] ; delete mRhsIdxNodes [ n ] ; } } private : TreeType* const mDistTree ; Int32TreeType* const mIdxTree ; LeafNodeType** const mRhsDistNodes ; Int32LeafNodeType** const mRhsIdxNodes ; } ; template<TreeType> struct StashOriginAndStoreOffset { using LeafNodeType = TreeType::LeafNodeType ;)",
    "insertText": "StashOriginAndStoreOffset(std::vector<LeafNodeType*>& nodes, Coord* coordinates) : mNodes(nodes.empty() ? nullptr : &nodes[0]), mCoordinates(coordinates)"
  },
  {
    "label": "Coord()",
    "kind": "Method",
    "detail": "Function (Coord& origin = const_cast<)",
    "insertText": "Coord(mNodes[n]->origin())"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (mCoordinates [ n ] = origin ; origin [ 0 ] = static_cast<)",
    "insertText": "int(n)"
  },
  {
    "label": "RestoreOrigin()",
    "kind": "Method",
    "detail": "Function (} } LeafNodeType** const mNodes ; Coord* const mCoordinates ; } ; template<TreeType> struct RestoreOrigin { using LeafNodeType = TreeType::LeafNodeType ;)",
    "insertText": "RestoreOrigin(std::vector<LeafNodeType*>& nodes, const Coord* coordinates) : mNodes(nodes.empty() ? nullptr : &nodes[0]), mCoordinates(coordinates)"
  },
  {
    "label": "ComputeNodeConnectivity()",
    "kind": "Method",
    "detail": "Function (origin [ 0 ] = mCoordinates [ n ] [ 0 ] ; } } LeafNodeType** const mNodes ; Coord const* const mCoordinates ; } ; template<TreeType> class ComputeNodeConnectivity { public : using LeafNodeType = TreeType::LeafNodeType ;)",
    "insertText": "ComputeNodeConnectivity(const TreeType& tree, const Coord* coordinates, size_t* offsets, size_t numNodes, const CoordBBox& bbox) : mTree(&tree) , mCoordinates(coordinates) , mOffsets(offsets) , mNumNodes(numNodes) , mBBox(bbox)"
  },
  {
    "label": "ComputeNodeConnectivity()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ComputeNodeConnectivity(const ComputeNodeConnectivity&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ComputeNodeConnectivity&)",
    "insertText": "operator(const ComputeNodeConnectivity&)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (size_t* offsetsNextX = mOffsets ; size_t* offsetsPrevX = mOffsets + mNumNodes ; size_t* offsetsNextY = mOffsets + mNumNodes* 2 ; size_t* offsetsPrevY = mOffsets + mNumNodes* 3 ; size_t* offsetsNextZ = mOffsets + mNumNodes* 4 ; size_t* offsetsPrevZ = mOffsets + mNumNodes* 5 ; tree::ValueAccessor<const TreeType>)",
    "insertText": "acc(*mTree)"
  },
  {
    "label": "Int32()",
    "kind": "Method",
    "detail": "Function (Coord ijk ; const Int32 DIM = static_cast<)",
    "insertText": "Int32(LeafNodeType::DIM)"
  },
  {
    "label": "findNeighbourNode()",
    "kind": "Method",
    "detail": "Function (const Coord& origin = mCoordinates [ n ] ; offsetsNextX [ n ] =)",
    "insertText": "findNeighbourNode(acc, origin, Coord(DIM, 0, 0))"
  },
  {
    "label": "findNeighbourNode()",
    "kind": "Method",
    "detail": "Function (offsetsPrevX [ n ] =)",
    "insertText": "findNeighbourNode(acc, origin, Coord(-DIM, 0, 0))"
  },
  {
    "label": "findNeighbourNode()",
    "kind": "Method",
    "detail": "Function (offsetsNextY [ n ] =)",
    "insertText": "findNeighbourNode(acc, origin, Coord(0, DIM, 0))"
  },
  {
    "label": "findNeighbourNode()",
    "kind": "Method",
    "detail": "Function (offsetsPrevY [ n ] =)",
    "insertText": "findNeighbourNode(acc, origin, Coord(0, -DIM, 0))"
  },
  {
    "label": "findNeighbourNode()",
    "kind": "Method",
    "detail": "Function (offsetsNextZ [ n ] =)",
    "insertText": "findNeighbourNode(acc, origin, Coord(0, 0, DIM))"
  },
  {
    "label": "findNeighbourNode()",
    "kind": "Method",
    "detail": "Function (offsetsPrevZ [ n ] =)",
    "insertText": "findNeighbourNode(acc, origin, Coord(0, 0, -DIM))"
  },
  {
    "label": "findNeighbourNode()",
    "kind": "Method",
    "detail": "Function (} } size_t)",
    "insertText": "findNeighbourNode(tree::ValueAccessor<const TreeType>& acc, const Coord& start, const Coord& step)"
  },
  {
    "label": "bbox()",
    "kind": "Method",
    "detail": "Function (Coord ijk = start + step ; CoordBBox)",
    "insertText": "bbox(mBBox)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (const LeafNodeType* node = acc .)",
    "insertText": "probeConstLeaf(ijk)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (ijk + = step ; } return std::numeric_limits<size_t)",
    "insertText": "max()"
  },
  {
    "label": "LeafNodeConnectivityTable()",
    "kind": "Method",
    "detail": "Function (using LeafNodeType = TreeType::LeafNodeType ;)",
    "insertText": "LeafNodeConnectivityTable(TreeType& tree)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (mLeafNodes .)",
    "insertText": "reserve(tree.leafCount())"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (tree .)",
    "insertText": "getNodes(mLeafNodes)"
  },
  {
    "label": "evalLeafBoundingBox()",
    "kind": "Method",
    "detail": "Function (CoordBBox bbox ; tree .)",
    "insertText": "evalLeafBoundingBox(bbox)"
  },
  {
    "label": "range()",
    "kind": "Method",
    "detail": "Function (const tbb::blocked_range<size_t>)",
    "insertText": "range(0, mLeafNodes.size())"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<Coord [ ]> coordinates { new Coord [ mLeafNodes .)",
    "insertText": "size()"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(range, StashOriginAndStoreOffset<TreeType>(mLeafNodes, coordinates.get()))"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mOffsets .)",
    "insertText": "reset(new size_t[mLeafNodes.size() * 6])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(range, ComputeNodeConnectivity<TreeType>( tree, coordinates.get(), mOffsets.get(), mLeafNodes.size(), bbox))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(range, RestoreOrigin<TreeType>(mLeafNodes, coordinates.get()))"
  },
  {
    "label": "nodes()",
    "kind": "Method",
    "detail": "Function (} std::vector<LeafNodeType*>&)",
    "insertText": "nodes()"
  },
  {
    "label": "offsetsPrevX()",
    "kind": "Method",
    "detail": "Function (} const size_t*)",
    "insertText": "offsetsPrevX()"
  },
  {
    "label": "offsetsNextY()",
    "kind": "Method",
    "detail": "Function (} const size_t*)",
    "insertText": "offsetsNextY()"
  },
  {
    "label": "offsetsPrevY()",
    "kind": "Method",
    "detail": "Function (} const size_t*)",
    "insertText": "offsetsPrevY()"
  },
  {
    "label": "offsetsNextZ()",
    "kind": "Method",
    "detail": "Function (} const size_t*)",
    "insertText": "offsetsNextZ()"
  },
  {
    "label": "offsetsPrevZ()",
    "kind": "Method",
    "detail": "Function (} const size_t*)",
    "insertText": "offsetsPrevZ()"
  },
  {
    "label": "SweepExteriorSign()",
    "kind": "Method",
    "detail": "Function (} private : std::vector<LeafNodeType*> mLeafNodes ; std::unique_ptr<size_t [ ]> mOffsets ; } ; template<TreeType> class SweepExteriorSign { public : enum Axis { X_AXIS = 0,Y_AXIS = 1,Z_AXIS = 2 } ; using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ; using ConnectivityTable = LeafNodeConnectivityTable<TreeType> ;)",
    "insertText": "SweepExteriorSign(Axis axis, const std::vector<size_t>& startNodeIndices, ConnectivityTable& connectivity) : mStartNodeIndices(startNodeIndices.empty() ? nullptr : &startNodeIndices[0]) , mConnectivity(&connectivity) , mAxis(axis)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(mAxis == X_AXIS)"
  },
  {
    "label": "offsetsNextX()",
    "kind": "Method",
    "detail": "Function (idxA = 1 ; idxB = 2 ; step = DIM* DIM ; nextOffsets = mConnectivity ->)",
    "insertText": "offsetsNextX()"
  },
  {
    "label": "ijk()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "ijk(0, 0, 0)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (size_t startOffset = mStartNodeIndices [ n ] ; size_t lastOffset = startOffset ; Int32)",
    "insertText": "pos(0)"
  },
  {
    "label": "Int32()",
    "kind": "Method",
    "detail": "Function (pos = static_cast<)",
    "insertText": "Int32(LeafNodeType::coordToOffset(ijk))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (size_t offset = startOffset ;)",
    "insertText": "while(offset != ConnectivityTable::INVALID_OFFSET && traceVoxelLine(*nodes[offset], pos, step))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (lastOffset = offset ; offset = nextOffsets [ offset ] ; } offset = lastOffset ;)",
    "insertText": "while(offset != ConnectivityTable::INVALID_OFFSET)"
  },
  {
    "label": "step()",
    "kind": "Method",
    "detail": "Function (lastOffset = offset ; offset = nextOffsets [ offset ] ; } offset = lastOffset ; pos + =)",
    "insertText": "step(DIM - 1)"
  },
  {
    "label": "traceVoxelLine()",
    "kind": "Method",
    "detail": "Function (offset = prevOffsets [ offset ] ; } } } } } bool)",
    "insertText": "traceVoxelLine(LeafNodeType& node, Int32 pos, const Int32 step)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool isOutside = true ;)",
    "insertText": "for(Index i = 0; i < LeafNodeType::DIM; ++i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(pos >= 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ValueType& dist = data [ pos ] ;)",
    "insertText": "if(dist < ValueType(0.0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (isOutside = true ; } else {)",
    "insertText": "if(!(dist > ValueType(0.75)))"
  },
  {
    "label": "seedFill()",
    "kind": "Method",
    "detail": "Function (} pos + = step ; } return isOutside ; } private : size_t const* const mStartNodeIndices ; ConnectivityTable* const mConnectivity ; const Axis mAxis ; } ; template<LeafNodeType> void)",
    "insertText": "seedFill(LeafNodeType& node)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Queue seedPoints ;)",
    "insertText": "for(Index pos = 0; pos < LeafNodeType::SIZE; ++pos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(seedPoints.empty())"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "pos(0), nextPos(0)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (pos = seedPoints .)",
    "insertText": "back()"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (seedPoints .)",
    "insertText": "pop_back()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ValueType& dist = data [ pos ] ;)",
    "insertText": "if(!(dist < ValueType(0.0)))"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (dist = - dist ; ijk =)",
    "insertText": "offsetToLocalCoord(pos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (nextPos = pos - LeafNodeType::DIM* LeafNodeType::DIM ;)",
    "insertText": "if(data[nextPos] > ValueType(0.75)) seedPoints.push_back(nextPos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ijk[0] != (LeafNodeType::DIM - 1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ijk[1] != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ijk[1] != (LeafNodeType::DIM - 1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ijk[2] != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ijk[2] != (LeafNodeType::DIM - 1))"
  },
  {
    "label": "scanFill()",
    "kind": "Method",
    "detail": "Function (} } } } template<LeafNodeType> bool)",
    "insertText": "scanFill(LeafNodeType& node)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bool updatedSign = true ;)",
    "insertText": "while(updatedSign)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ValueType& dist = data [ pos ] ;)",
    "insertText": "if(!(dist < ValueType(0.0)) && dist > ValueType(0.75))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (updatedSign = true ; dist =)",
    "insertText": "ValueType(-dist)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ijk[2] != (LeafNodeType::DIM - 1) && data[pos + 1] < ValueType(0.0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ijk[1] != 0 && data[pos - LeafNodeType::DIM] < ValueType(0.0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ijk[1] != (LeafNodeType::DIM - 1) && data[pos + LeafNodeType::DIM] < ValueType(0.0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ijk[0] != 0 && data[pos - LeafNodeType::DIM * LeafNodeType::DIM] < ValueType(0.0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ijk[0] != (LeafNodeType::DIM - 1) && data[pos + LeafNodeType::DIM * LeafNodeType::DIM] < ValueType(0.0))"
  },
  {
    "label": "SeedFillExteriorSign()",
    "kind": "Method",
    "detail": "Function (} } } updatedNode | = updatedSign ; } return updatedNode ; } template<TreeType> class SeedFillExteriorSign { public : using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ;)",
    "insertText": "SeedFillExteriorSign(std::vector<LeafNodeType*>& nodes, const bool* changedNodeMask) : mNodes(nodes.empty() ? nullptr : &nodes[0]) , mChangedNodeMask(changedNodeMask)"
  },
  {
    "label": "scanFill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "scanFill(*mNodes[n])"
  },
  {
    "label": "FillArray()",
    "kind": "Method",
    "detail": "Function (} } } LeafNodeType** const mNodes ; const bool* const mChangedNodeMask ; } ; template<ValueType> struct FillArray {)",
    "insertText": "FillArray(ValueType* array, const ValueType v) : mArray(array), mValue(v)"
  },
  {
    "label": "fillArray()",
    "kind": "Method",
    "detail": "Function (mArray [ n ] = v ; } } ValueType* const mArray ; const ValueType mValue ; } ; template<ValueType> void)",
    "insertText": "fillArray(ValueType* array, const ValueType val, const size_t length)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (const auto grainSize = std::max<)",
    "insertText": "size_t(length / tbb::task_scheduler_init::default_num_threads(), 1024)"
  },
  {
    "label": "range()",
    "kind": "Method",
    "detail": "Function (const tbb::blocked_range<size_t>)",
    "insertText": "range(0, length, grainSize)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(range, FillArray<ValueType>(array, val), tbb::simple_partitioner())"
  },
  {
    "label": "SyncVoxelMask()",
    "kind": "Method",
    "detail": "Function (} template<TreeType> class SyncVoxelMask { public : using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ;)",
    "insertText": "SyncVoxelMask(std::vector<LeafNodeType*>& nodes, const bool* changedNodeMask, bool* changedVoxelMask) : mNodes(nodes.empty() ? nullptr : &nodes[0]) , mChangedNodeMask(changedNodeMask) , mChangedVoxelMask(changedVoxelMask)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (data [ pos ] =)",
    "insertText": "ValueType(-data[pos])"
  },
  {
    "label": "SeedPoints()",
    "kind": "Method",
    "detail": "Function (mask [ pos ] = false ; } } } } } LeafNodeType** const mNodes ; bool const* const mChangedNodeMask ; bool* const mChangedVoxelMask ; } ; template<TreeType> class SeedPoints { public : using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ; using ConnectivityTable = LeafNodeConnectivityTable<TreeType> ;)",
    "insertText": "SeedPoints(ConnectivityTable& connectivity, bool* changedNodeMask, bool* nodeMask, bool* changedVoxelMask) : mConnectivity(&connectivity) , mChangedNodeMask(changedNodeMask) , mNodeMask(nodeMask) , mChangedVoxelMask(changedVoxelMask)"
  },
  {
    "label": "processZ()",
    "kind": "Method",
    "detail": "Function (bool changedValue = false ; changedValue | =)",
    "insertText": "processZ(n, true)"
  },
  {
    "label": "processZ()",
    "kind": "Method",
    "detail": "Function (changedValue | =)",
    "insertText": "processZ(n, false)"
  },
  {
    "label": "processY()",
    "kind": "Method",
    "detail": "Function (changedValue | =)",
    "insertText": "processY(n, true)"
  },
  {
    "label": "processY()",
    "kind": "Method",
    "detail": "Function (changedValue | =)",
    "insertText": "processY(n, false)"
  },
  {
    "label": "processX()",
    "kind": "Method",
    "detail": "Function (changedValue | =)",
    "insertText": "processX(n, true)"
  },
  {
    "label": "processX()",
    "kind": "Method",
    "detail": "Function (changedValue | =)",
    "insertText": "processX(n, false)"
  },
  {
    "label": "processZ()",
    "kind": "Method",
    "detail": "Function (mNodeMask [ n ] = changedValue ; } } bool)",
    "insertText": "processZ(const size_t n, bool firstFace)"
  },
  {
    "label": "offsetsPrevZ()",
    "kind": "Method",
    "detail": "Function (const size_t offset = firstFace ? mConnectivity ->)",
    "insertText": "offsetsPrevZ()[n] : mConnectivity->offsetsNextZ()"
  },
  {
    "label": "nodes()",
    "kind": "Method",
    "detail": "Function (bool* mask =& mChangedVoxelMask [ n* LeafNodeType::SIZE ] ; const ValueType* lhsData = mConnectivity ->)",
    "insertText": "nodes()[n]->buffer().data()"
  },
  {
    "label": "nodes()",
    "kind": "Method",
    "detail": "Function (const ValueType* rhsData = mConnectivity ->)",
    "insertText": "nodes()[offset]->buffer().data()"
  },
  {
    "label": "tmpPos()",
    "kind": "Method",
    "detail": "Function (const Index lastOffset = LeafNodeType::DIM - 1 ; const Index lhsOffset = firstFace ? 0 : lastOffset,rhsOffset = firstFace ? lastOffset : 0 ; Index)",
    "insertText": "tmpPos(0), pos(0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool changedValue = false ;)",
    "insertText": "for(Index x = 0; x < LeafNodeType::DIM; ++x)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (tmpPos =)",
    "insertText": "x(2 * LeafNodeType::LOG2DIM)"
  },
  {
    "label": "tmpPos()",
    "kind": "Method",
    "detail": "Function (pos =)",
    "insertText": "tmpPos(y << LeafNodeType::LOG2DIM)"
  },
  {
    "label": "processY()",
    "kind": "Method",
    "detail": "Function (changedValue = true ; mask [ pos + lhsOffset ] = true ; } } } } return changedValue ; } return false ; } bool)",
    "insertText": "processY(const size_t n, bool firstFace)"
  },
  {
    "label": "offsetsPrevY()",
    "kind": "Method",
    "detail": "Function (const size_t offset = firstFace ? mConnectivity ->)",
    "insertText": "offsetsPrevY()[n] : mConnectivity->offsetsNextY()"
  },
  {
    "label": "DIM()",
    "kind": "Method",
    "detail": "Function (const Index lastOffset =)",
    "insertText": "DIM(LeafNodeType::DIM - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pos = tmpPos + z ;)",
    "insertText": "if(lhsData[pos + lhsOffset] > ValueType(0.75))"
  },
  {
    "label": "processX()",
    "kind": "Method",
    "detail": "Function (changedValue = true ; mask [ pos + lhsOffset ] = true ; } } } } return changedValue ; } return false ; } bool)",
    "insertText": "processX(const size_t n, bool firstFace)"
  },
  {
    "label": "offsetsPrevX()",
    "kind": "Method",
    "detail": "Function (const size_t offset = firstFace ? mConnectivity ->)",
    "insertText": "offsetsPrevX()[n] : mConnectivity->offsetsNextX()"
  },
  {
    "label": "DIM()",
    "kind": "Method",
    "detail": "Function (const Index lastOffset = LeafNodeType::DIM*)",
    "insertText": "DIM(LeafNodeType::DIM-1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool changedValue = false ;)",
    "insertText": "for(Index y = 0; y < LeafNodeType::DIM; ++y)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (tmpPos = y<<LeafNodeType::LOG2DIM ;)",
    "insertText": "for(Index z = 0; z < LeafNodeType::DIM; ++z)"
  },
  {
    "label": "ComputeIntersectingVoxelSign()",
    "kind": "Method",
    "detail": "Function (changedValue = true ; mask [ pos + lhsOffset ] = true ; } } } } return changedValue ; } return false ; } ConnectivityTable* const mConnectivity ; bool* const mChangedNodeMask ; bool* const mNodeMask ; bool* const mChangedVoxelMask ; } ; template<TreeType,MeshDataAdapter> struct ComputeIntersectingVoxelSign { using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ; using Int32TreeType = TreeType::template ValueConverter<Int32>::Type ; using Int32LeafNodeType = Int32TreeType::LeafNodeType ; using PointArray = std::unique_ptr<Vec3d [ ]> ; using MaskArray = std::unique_ptr<bool [ ]> ; using LocalData = std::pair<PointArray,MaskArray> ; using LocalDataTable = tbb::enumerable_thread_specific<LocalData> ;)",
    "insertText": "ComputeIntersectingVoxelSign(std::vector<LeafNodeType*>& distNodes, const TreeType& distTree, const Int32TreeType& indexTree, const MeshDataAdapter& mesh) : mDistNodes(distNodes.empty() ? nullptr : &distNodes[0]) , mDistTree(&distTree) , mIndexTree(&indexTree) , mMesh(&mesh) , mLocalDataTable(new LocalDataTable())"
  },
  {
    "label": "idxAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const Int32TreeType>)",
    "insertText": "idxAcc(*mIndexTree)"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (ValueType nval ; CoordBBox bbox ; Index)",
    "insertText": "xPos(0), yPos(0)"
  },
  {
    "label": "local()",
    "kind": "Method",
    "detail": "Function (Coord ijk,nijk,nodeMin,nodeMax ; Vec3d cp,xyz,nxyz,dir1,dir2 ; LocalData& localData = mLocalDataTable ->)",
    "insertText": "local()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (PointArray& points = localData . first ;)",
    "insertText": "if(!points) points.reset(new Vec3d[LeafNodeType::SIZE * 2])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MaskArray& mask = localData . second ;)",
    "insertText": "if(!mask) mask.reset(new bool[LeafNodeType::SIZE])"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (const Int32LeafNodeType* idxNode = idxAcc .)",
    "insertText": "probeConstLeaf(node.origin())"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (nodeMax = nodeMin .)",
    "insertText": "offsetBy(LeafNodeType::DIM - 1)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(mask.get(), 0, sizeof(bool) * LeafNodeType::SIZE)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (Index pos = it .)",
    "insertText": "pos()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ValueType& dist = data [ pos ] ;)",
    "insertText": "if(dist < 0.0 || dist > 0.75)"
  },
  {
    "label": "offsetToGlobalCoord()",
    "kind": "Method",
    "detail": "Function (ijk = node .)",
    "insertText": "offsetToGlobalCoord(pos)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (xyz [ 0 ] =)",
    "insertText": "double(ijk[0])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (xyz [ 1 ] =)",
    "insertText": "double(ijk[1])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (xyz [ 2 ] =)",
    "insertText": "double(ijk[2])"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "min() = Coord::maxComponent(ijk.offsetBy(-1), nodeMin)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "max() = Coord::minComponent(ijk.offsetBy(1), nodeMax)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool flipSign = false ;)",
    "insertText": "for(nijk[0] = bbox.min()[0]; nijk[0] <= bbox.max()[0] && !flipSign; ++nijk[0])"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "xPos(nijk[0] & (LeafNodeType::DIM - 1u)) << (2 * LeafNodeType::LOG2DIM)"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (yPos =)",
    "insertText": "xPos((nijk[1] & (LeafNodeType::DIM-1u)) << LeafNodeType::LOG2DIM)"
  },
  {
    "label": "yPos()",
    "kind": "Method",
    "detail": "Function (pos =)",
    "insertText": "yPos(nijk[2] & (LeafNodeType::DIM - 1u))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Int32& polyIdx = idxData [ pos ] ;)",
    "insertText": "if(polyIdx == Int32(util::INVALID_IDX) || !(data[pos] < -0.75))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index pointIndex = pos* 2 ;)",
    "insertText": "if(!mask[pos])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (mask [ pos ] = true ; nxyz [ 0 ] =)",
    "insertText": "double(nijk[0])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (nxyz [ 1 ] =)",
    "insertText": "double(nijk[1])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (nxyz [ 2 ] =)",
    "insertText": "double(nijk[2])"
  },
  {
    "label": "closestPoint()",
    "kind": "Method",
    "detail": "Function (Vec3d& point = points [ pointIndex ] ; point =)",
    "insertText": "closestPoint(nxyz, polyIdx)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (Vec3d& direction = points [ pointIndex + 1 ] ; direction = nxyz - point ; direction .)",
    "insertText": "normalize()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (flipSign = true ; break ; } } } })",
    "insertText": "if(flipSign)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (dist = - dist ; } else {)",
    "insertText": "for(Int32 m = 0; m < 26; ++m)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (nijk = ijk + util::COORD_OFFSETS [ m ] ;)",
    "insertText": "if(!bbox.isInside(nijk) && distAcc.probeValue(nijk, nval) && nval<-0.75)"
  },
  {
    "label": "closestPoint()",
    "kind": "Method",
    "detail": "Function (cp =)",
    "insertText": "closestPoint(nxyz, idxAcc.getValue(nijk))"
  },
  {
    "label": "closestPoint()",
    "kind": "Method",
    "detail": "Function (dist = - dist ; break ; } } } } } } } private : Vec3d)",
    "insertText": "closestPoint(const Vec3d& center, Int32 polyIdx)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (Vec3d a,b,c,cp,uvw ; const size_t polygon =)",
    "insertText": "size_t(polyIdx)"
  },
  {
    "label": "getIndexSpacePoint()",
    "kind": "Method",
    "detail": "Function (mMesh ->)",
    "insertText": "getIndexSpacePoint(polygon, 0, a)"
  },
  {
    "label": "getIndexSpacePoint()",
    "kind": "Method",
    "detail": "Function (mMesh ->)",
    "insertText": "getIndexSpacePoint(polygon, 1, b)"
  },
  {
    "label": "getIndexSpacePoint()",
    "kind": "Method",
    "detail": "Function (mMesh ->)",
    "insertText": "getIndexSpacePoint(polygon, 2, c)"
  },
  {
    "label": "closestPointOnTriangleToPoint()",
    "kind": "Method",
    "detail": "Function (cp =)",
    "insertText": "closestPointOnTriangleToPoint(a, c, b, center, uvw)"
  },
  {
    "label": "getIndexSpacePoint()",
    "kind": "Method",
    "detail": "Function (mMesh ->)",
    "insertText": "getIndexSpacePoint(polygon, 3, b)"
  },
  {
    "label": "closestPointOnTriangleToPoint()",
    "kind": "Method",
    "detail": "Function (c =)",
    "insertText": "closestPointOnTriangleToPoint(a, b, c, center, uvw)"
  },
  {
    "label": "maskNodeInternalNeighbours()",
    "kind": "Method",
    "detail": "Function (cp = c ; } } return cp ; } LeafNodeType** const mDistNodes ; TreeType const* const mDistTree ; Int32TreeType const* const mIndexTree ; MeshDataAdapter const* const mMesh ; SharedPtr<LocalDataTable> mLocalDataTable ; } ; template<LeafNodeType> void)",
    "insertText": "maskNodeInternalNeighbours(const Index pos, bool (&mask)[26])"
  },
  {
    "label": "ijk()",
    "kind": "Method",
    "detail": "Function (mask [ 0 ] =)",
    "insertText": "ijk(NodeT::DIM - 1)"
  },
  {
    "label": "checkNeighbours()",
    "kind": "Method",
    "detail": "Function (mask [ 5 ] = ijk [ 2 ] ! = 0 ; mask [ 6 ] = mask [ 0 ]&& mask [ 5 ] ; mask [ 7 ] = mask [ 1 ]&& mask [ 5 ] ; mask [ 8 ] = mask [ 0 ]&& mask [ 4 ] ; mask [ 9 ] = mask [ 1 ]&& mask [ 4 ] ; mask [ 1 0 ] = mask [ 0 ]&& mask [ 2 ] ; mask [ 1 1 ] = mask [ 1 ]&& mask [ 2 ] ; mask [ 1 2 ] = mask [ 0 ]&& mask [ 3 ] ; mask [ 1 3 ] = mask [ 1 ]&& mask [ 3 ] ; mask [ 1 4 ] = mask [ 3 ]&& mask [ 4 ] ; mask [ 1 5 ] = mask [ 3 ]&& mask [ 5 ] ; mask [ 1 6 ] = mask [ 2 ]&& mask [ 4 ] ; mask [ 1 7 ] = mask [ 2 ]&& mask [ 5 ] ; mask [ 1 8 ] = mask [ 1 ]&& mask [ 3 ]&& mask [ 5 ] ; mask [ 1 9 ] = mask [ 1 ]&& mask [ 3 ]&& mask [ 4 ] ; mask [ 2 0 ] = mask [ 0 ]&& mask [ 3 ]&& mask [ 4 ] ; mask [ 2 1 ] = mask [ 0 ]&& mask [ 3 ]&& mask [ 5 ] ; mask [ 2 2 ] = mask [ 1 ]&& mask [ 2 ]&& mask [ 5 ] ; mask [ 2 3 ] = mask [ 1 ]&& mask [ 2 ]&& mask [ 4 ] ; mask [ 2 4 ] = mask [ 0 ]&& mask [ 2 ]&& mask [ 4 ] ; mask [ 2 5 ] = mask [ 0 ]&& mask [ 2 ]&& mask [ 5 ] ; } template<Compare,LeafNodeType> bool)",
    "insertText": "checkNeighbours(const Index pos, const typename LeafNodeType::ValueType * data, bool (&mask)[26])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using NodeT = LeafNodeType ;)",
    "insertText": "if(mask[5] && Compare::check(data[pos - 1]))"
  },
  {
    "label": "ValidateIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "ValidateIntersectingVoxels(TreeType& tree, std::vector<LeafNodeType*>& nodes) : mTree(&tree) , mNodes(nodes.empty() ? nullptr : &nodes[0])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (LeafNodeType::ValueOnCIter it ;)",
    "insertText": "for(it = node.cbeginValueOn(); it; ++it)"
  },
  {
    "label": "LeafNodeType()",
    "kind": "Method",
    "detail": "Function (maskNodeInternalNeighbours<)",
    "insertText": "LeafNodeType(pos, neighbourMask)"
  },
  {
    "label": "LeafNodeType()",
    "kind": "Method",
    "detail": "Function (const bool hasNegativeNeighbour = checkNeighbours<IsNegative,)",
    "insertText": "LeafNodeType(pos, data, neighbourMask) || checkNeighbours<IsNegative>(node.offsetToGlobalCoord(pos), acc, neighbourMask)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (dist =)",
    "insertText": "ValueType(0.75) + Tolerance<ValueType>::epsilon()"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} } } } TreeType* const mTree ; LeafNodeType** const mNodes ; } ; template<TreeType> struct RemoveSelfIntersectingSurface { using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ; using Int32TreeType = TreeType::template ValueConverter<Int32>::Type ; struct Comp { bool)",
    "insertText": "check(const ValueType v)"
  },
  {
    "label": "RemoveSelfIntersectingSurface()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "RemoveSelfIntersectingSurface(std::vector<LeafNodeType*>& nodes, TreeType& distTree, Int32TreeType& indexTree) : mNodes(nodes.empty() ? nullptr : &nodes[0]) , mDistTree(&distTree) , mIndexTree(&indexTree)"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (Int32TreeType::LeafNodeType* idxNode = idxAcc .)",
    "insertText": "probeLeaf(distNode.origin())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (LeafNodeType::ValueOnCIter it ;)",
    "insertText": "for(it = distNode.cbeginValueOn(); it; ++it)"
  },
  {
    "label": "LeafNodeType()",
    "kind": "Method",
    "detail": "Function (const bool hasBoundaryNeighbour = checkNeighbours<Comp,)",
    "insertText": "LeafNodeType(pos, data, neighbourMask) || checkNeighbours<Comp>(distNode.offsetToGlobalCoord(pos),distAcc,neighbourMask)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (distNode .)",
    "insertText": "setValueOff(pos)"
  },
  {
    "label": "ReleaseChildNodes()",
    "kind": "Method",
    "detail": "Function (} } } } LeafNodeType** const mNodes ; TreeType* const mDistTree ; Int32TreeType* const mIndexTree ; } ; template<NodeType> struct ReleaseChildNodes {)",
    "insertText": "ReleaseChildNodes(NodeType ** nodes) : mNodes(nodes)"
  },
  {
    "label": "NodeMaskType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeMaskType(mNodes[n]->getChildMask()).setOff()"
  },
  {
    "label": "releaseLeafNodes()",
    "kind": "Method",
    "detail": "Function (} } NodeType** const mNodes ; } ; template<TreeType> void)",
    "insertText": "releaseLeafNodes(TreeType& tree)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (using RootNodeType = TreeType::RootNodeType ; using NodeChainType = RootNodeType::NodeChainType ; using InternalNodeType = NodeChainType::template Get<1> ; std::vector<InternalNodeType*> nodes ; tree .)",
    "insertText": "getNodes(nodes)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, nodes.size()), ReleaseChildNodes<InternalNodeType>(nodes.empty() ? nullptr : &nodes[0]))"
  },
  {
    "label": "StealUniqueLeafNodes()",
    "kind": "Method",
    "detail": "Function (} template<TreeType> struct StealUniqueLeafNodes { using LeafNodeType = TreeType::LeafNodeType ;)",
    "insertText": "StealUniqueLeafNodes(TreeType& lhsTree, TreeType& rhsTree, std::vector<LeafNodeType*>& overlappingNodes) : mLhsTree(&lhsTree) , mRhsTree(&rhsTree) , mNodes(&overlappingNodes)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::vector<LeafNodeType*> rhsLeafNodes ; rhsLeafNodes .)",
    "insertText": "reserve(mRhsTree->leafCount())"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (mRhsTree ->)",
    "insertText": "stealNodes(rhsLeafNodes)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<TreeType>)",
    "insertText": "acc(*mLhsTree)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (acc .)",
    "insertText": "addLeaf(rhsLeafNodes[n])"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} else { mNodes ->)",
    "insertText": "push_back(rhsLeafNodes[n])"
  },
  {
    "label": "combineData()",
    "kind": "Method",
    "detail": "Function (} } } private : TreeType* const mLhsTree ; TreeType* const mRhsTree ; std::vector<LeafNodeType*>* const mNodes ; } ; template<DistTreeType,IndexTreeType> void)",
    "insertText": "combineData(DistTreeType& lhsDist, IndexTreeType& lhsIdx, DistTreeType& rhsDist, IndexTreeType& rhsIdx)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (using DistLeafNodeType = DistTreeType::LeafNodeType ; using IndexLeafNodeType = IndexTreeType::LeafNodeType ; std::vector<DistLeafNodeType*> overlappingDistNodes ; std::vector<IndexLeafNodeType*> overlappingIdxNodes ; tbb::task_group tasks ; tasks .)",
    "insertText": "run(StealUniqueLeafNodes<DistTreeType>(lhsDist, rhsDist, overlappingDistNodes))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (tasks .)",
    "insertText": "run(StealUniqueLeafNodes<IndexTreeType>(lhsIdx, rhsIdx, overlappingIdxNodes))"
  },
  {
    "label": "wait()",
    "kind": "Method",
    "detail": "Function (tasks .)",
    "insertText": "wait()"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, overlappingDistNodes.size()), CombineLeafNodes<DistTreeType>(lhsDist, lhsIdx, &overlappingDistNodes[0], &overlappingIdxNodes[0]))"
  },
  {
    "label": "VoxelizationData()",
    "kind": "Method",
    "detail": "Function (} } template<TreeType> struct VoxelizationData { using Ptr = std::unique_ptr<VoxelizationData> ; using ValueType = TreeType::ValueType ; using Int32TreeType = TreeType::template ValueConverter<Int32>::Type ; using UCharTreeType = TreeType::template ValueConverter<unsigned char>::Type ; using FloatTreeAcc = tree::ValueAccessor<TreeType> ; using Int32TreeAcc = tree::ValueAccessor<Int32TreeType> ; using UCharTreeAcc = tree::ValueAccessor<UCharTreeType> ;)",
    "insertText": "VoxelizationData() : distTree(std::numeric_limits<ValueType>::max()) , distAcc(distTree) , indexTree(Int32(util::INVALID_IDX)) , indexAcc(indexTree) , primIdTree(MaxPrimId) , primIdAcc(primIdTree) , mPrimCount(0)"
  },
  {
    "label": "getNewPrimId()",
    "kind": "Method",
    "detail": "Function (} TreeType distTree ; FloatTreeAcc distAcc ; Int32TreeType indexTree ; Int32TreeAcc indexAcc ; UCharTreeType primIdTree ; UCharTreeAcc primIdAcc ; unsigned char)",
    "insertText": "getNewPrimId()"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (mPrimCount = 0 ; primIdTree .)",
    "insertText": "root().clear()"
  },
  {
    "label": "clearAllAccessors()",
    "kind": "Method",
    "detail": "Function (primIdTree .)",
    "insertText": "clearAllAccessors()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mPrimCount == 0)"
  },
  {
    "label": "VoxelizePolygons()",
    "kind": "Method",
    "detail": "Function (} return mPrimCount + + ; } private : enum { MaxPrimId = 1 0 0 } ; unsigned char mPrimCount ; } ; template<TreeType,MeshDataAdapter,Interrupter = util::NullInterrupter> class VoxelizePolygons { public : using VoxelizationDataType = VoxelizationData<TreeType> ; using DataTable = tbb::enumerable_thread_specific<VoxelizationDataType::Ptr> ;)",
    "insertText": "VoxelizePolygons(DataTable& dataTable, const MeshDataAdapter& mesh, Interrupter* interrupter = nullptr) : mDataTable(&dataTable) , mMesh(&mesh) , mInterrupter(interrupter)"
  },
  {
    "label": "self()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "self().cancel_group_execution()"
  },
  {
    "label": "vertexCount()",
    "kind": "Method",
    "detail": "Function (break ; } const size_t numVerts = mMesh ->)",
    "insertText": "vertexCount(n)"
  },
  {
    "label": "Int32()",
    "kind": "Method",
    "detail": "Function (prim . index =)",
    "insertText": "Int32(n)"
  },
  {
    "label": "getIndexSpacePoint()",
    "kind": "Method",
    "detail": "Function (mMesh ->)",
    "insertText": "getIndexSpacePoint(n, 0, prim.a)"
  },
  {
    "label": "getIndexSpacePoint()",
    "kind": "Method",
    "detail": "Function (mMesh ->)",
    "insertText": "getIndexSpacePoint(n, 1, prim.b)"
  },
  {
    "label": "getIndexSpacePoint()",
    "kind": "Method",
    "detail": "Function (mMesh ->)",
    "insertText": "getIndexSpacePoint(n, 2, prim.c)"
  },
  {
    "label": "evalTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalTriangle(prim, *dataPtr)"
  },
  {
    "label": "getIndexSpacePoint()",
    "kind": "Method",
    "detail": "Function (mMesh ->)",
    "insertText": "getIndexSpacePoint(n, 3, prim.b)"
  },
  {
    "label": "wasInterrupted()",
    "kind": "Method",
    "detail": "Function (} } } } private : bool)",
    "insertText": "wasInterrupted()"
  },
  {
    "label": "SubTask()",
    "kind": "Method",
    "detail": "Function (} struct Triangle { Vec3d a,b,c ; Int32 index ; } ; struct SubTask { enum { POLYGON_LIMIT = 1 0 0 0 } ;)",
    "insertText": "SubTask(const Triangle& prim, DataTable& dataTable, int subdivisionCount, size_t polygonCount, Interrupter* interrupter = nullptr) : mLocalDataTable(&dataTable) , mPrim(prim) , mSubdivisionCount(subdivisionCount) , mPolygonCount(polygonCount) , mInterrupter(interrupter)"
  },
  {
    "label": "voxelizeTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "voxelizeTriangle(mPrim, *dataPtr, mInterrupter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!(mInterrupter && mInterrupter->wasInterrupted()))"
  },
  {
    "label": "spawnTasks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawnTasks(mPrim, *mLocalDataTable, mSubdivisionCount, mPolygonCount, mInterrupter)"
  },
  {
    "label": "evalSubdivisionCount()",
    "kind": "Method",
    "detail": "Function (} } DataTable* const mLocalDataTable ; Triangle const mPrim ; int const mSubdivisionCount ; size_t const mPolygonCount ; Interrupter* const mInterrupter ; } ; int)",
    "insertText": "evalSubdivisionCount(const Triangle& prim)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (const double ax = prim . a [ 0 ],bx = prim . b [ 0 ],cx = prim . c [ 0 ] ; const double dx =)",
    "insertText": "max(ax, std::max(bx, cx)) - std::min(ax, std::min(bx, cx))"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (const double ay = prim . a [ 1 ],by = prim . b [ 1 ],cy = prim . c [ 1 ] ; const double dy =)",
    "insertText": "max(ay, std::max(by, cy)) - std::min(ay, std::min(by, cy))"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (const double az = prim . a [ 2 ],bz = prim . b [ 2 ],cz = prim . c [ 2 ] ; const double dz =)",
    "insertText": "max(az, std::max(bz, cz)) - std::min(az, std::min(bz, cz))"
  },
  {
    "label": "evalTriangle()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "evalTriangle(const Triangle& prim, VoxelizationDataType& data)"
  },
  {
    "label": "evalSubdivisionCount()",
    "kind": "Method",
    "detail": "Function (const int subdivisionCount = polygonCount<SubTask::POLYGON_LIMIT ?)",
    "insertText": "evalSubdivisionCount(prim)"
  },
  {
    "label": "voxelizeTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "voxelizeTriangle(prim, data, mInterrupter)"
  },
  {
    "label": "spawnTasks()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "spawnTasks(prim, *mDataTable, subdivisionCount, polygonCount, mInterrupter)"
  },
  {
    "label": "spawnTasks()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "spawnTasks(const Triangle& mainPrim, DataTable& dataTable, int subdivisionCount, size_t polygonCount, Interrupter* const interrupter)"
  },
  {
    "label": "ac()",
    "kind": "Method",
    "detail": "Function (subdivisionCount - = 1 ; polygonCount* = 4 ; tbb::task_group tasks ; const Vec3d)",
    "insertText": "ac(mainPrim.a + mainPrim.c)"
  },
  {
    "label": "bc()",
    "kind": "Method",
    "detail": "Function (const Vec3d)",
    "insertText": "bc(mainPrim.b + mainPrim.c)"
  },
  {
    "label": "ab()",
    "kind": "Method",
    "detail": "Function (const Vec3d)",
    "insertText": "ab(mainPrim.a + mainPrim.b)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (Triangle prim ; prim . index = mainPrim . index ; prim . a = mainPrim . a ; prim . b = ab ; prim . c = ac ; tasks .)",
    "insertText": "run(SubTask(prim, dataTable, subdivisionCount, polygonCount, interrupter))"
  },
  {
    "label": "voxelizeTriangle()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "voxelizeTriangle(const Triangle& prim, VoxelizationDataType& data, Interrupter* const interrupter)"
  },
  {
    "label": "floor()",
    "kind": "Method",
    "detail": "Function (std::deque<Coord> coordList ; Coord ijk,nijk ; ijk =)",
    "insertText": "floor(prim.a)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (coordList .)",
    "insertText": "push_back(ijk)"
  },
  {
    "label": "updateDistance()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateDistance(ijk, prim, data)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (data . primIdAcc .)",
    "insertText": "setValueOnly(ijk, primId)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (break ; })",
    "insertText": "for(Int32 pass = 0; pass < 1048576 && !coordList.empty(); ++pass)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (nijk = ijk + util::COORD_OFFSETS [ i ] ;)",
    "insertText": "if(primId != data.primIdAcc.getValue(nijk))"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (data . primIdAcc .)",
    "insertText": "setValueOnly(nijk, primId)"
  },
  {
    "label": "updateDistance()",
    "kind": "Method",
    "detail": "Function (} } } } } bool)",
    "insertText": "updateDistance(const Coord& ijk, const Triangle& prim, VoxelizationDataType& data)"
  },
  {
    "label": "voxelCenter()",
    "kind": "Method",
    "detail": "Function (Vec3d uvw,)",
    "insertText": "voxelCenter(ijk[0], ijk[1], ijk[2])"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (using ValueType = TreeType::ValueType ; const ValueType dist =)",
    "insertText": "ValueType((voxelCenter - closestPointOnTriangleToPoint(prim.a, prim.c, prim.b, voxelCenter, uvw)).lengthSqr())"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ValueType oldDist = data . distAcc .)",
    "insertText": "getValue(ijk)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (data . distAcc .)",
    "insertText": "setValue(ijk, dist)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (data . indexAcc .)",
    "insertText": "setValue(ijk, prim.index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(math::isExactlyEqual(dist, oldDist))"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (data . indexAcc .)",
    "insertText": "setValueOnly(ijk, std::min(prim.index, data.indexAcc.getValue(ijk)))"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(dist > 0.75)"
  },
  {
    "label": "DiffLeafNodeMask()",
    "kind": "Method",
    "detail": "Function (} DataTable* const mDataTable ; MeshDataAdapter const* const mMesh ; Interrupter* const mInterrupter ; } ; template<TreeType> struct DiffLeafNodeMask { using AccessorType = tree::ValueAccessor<TreeType> ; using LeafNodeType = TreeType::LeafNodeType ; using BoolTreeType = TreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ;)",
    "insertText": "DiffLeafNodeMask(const TreeType& rhsTree, std::vector<BoolLeafNodeType*>& lhsNodes) : mRhsTree(&rhsTree), mLhsNodes(lhsNodes.empty() ? nullptr : &lhsNodes[0])"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const TreeType>)",
    "insertText": "acc(*mRhsTree)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (BoolLeafNodeType* lhsNode = mLhsNodes [ n ] ; const LeafNodeType* rhsNode = acc .)",
    "insertText": "probeConstLeaf(lhsNode->origin())"
  },
  {
    "label": "UnionValueMasks()",
    "kind": "Method",
    "detail": "Function (} } private : TreeType const* const mRhsTree ; BoolLeafNodeType** const mLhsNodes ; } ; template<LeafNodeTypeA,LeafNodeTypeB> struct UnionValueMasks {)",
    "insertText": "UnionValueMasks(std::vector<LeafNodeTypeA*>& nodesA, std::vector<LeafNodeTypeB*>& nodesB) : mNodesA(nodesA.empty() ? nullptr : &nodesA[0]) , mNodesB(nodesB.empty() ? nullptr : &nodesB[0])"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (mNodesA [ n ] ->)",
    "insertText": "topologyUnion(*mNodesB[n])"
  },
  {
    "label": "ConstructVoxelMask()",
    "kind": "Method",
    "detail": "Function (} } private : LeafNodeTypeA** const mNodesA ; LeafNodeTypeB** const mNodesB ; } ; template<TreeType> struct ConstructVoxelMask { using LeafNodeType = TreeType::LeafNodeType ; using BoolTreeType = TreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ;)",
    "insertText": "ConstructVoxelMask(BoolTreeType& maskTree, const TreeType& tree, std::vector<LeafNodeType*>& nodes) : mTree(&tree) , mNodes(nodes.empty() ? nullptr : &nodes[0]) , mLocalMaskTree(false) , mMaskTree(&maskTree)"
  },
  {
    "label": "ConstructVoxelMask()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ConstructVoxelMask(ConstructVoxelMask& rhs, tbb::split) : mTree(rhs.mTree) , mNodes(rhs.mNodes) , mLocalMaskTree(false) , mMaskTree(&mLocalMaskTree)"
  },
  {
    "label": "maskAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<BoolTreeType>)",
    "insertText": "maskAcc(*mMaskTree)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Coord ijk,nijk,localCorod ; Index pos,npos ;)",
    "insertText": "for(size_t n = range.begin(); n != range.end(); ++n)"
  },
  {
    "label": "getNodeBoundingBox()",
    "kind": "Method",
    "detail": "Function (LeafNodeType& node =* mNodes [ n ] ; CoordBBox bbox = node .)",
    "insertText": "getNodeBoundingBox()"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(-1)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (BoolLeafNodeType& maskNode =* maskAcc .)",
    "insertText": "touchLeaf(node.origin())"
  },
  {
    "label": "getCoord()",
    "kind": "Method",
    "detail": "Function (ijk = it .)",
    "insertText": "getCoord()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (npos = pos + 1 ;)",
    "insertText": "if(!node.isValueOn(npos)) maskNode.setValueOn(npos)"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (} else { nijk = ijk .)",
    "insertText": "offsetBy(0, 0, 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(localCorod[2] > 0)"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (} else { nijk = ijk .)",
    "insertText": "offsetBy(0, 0, -1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(localCorod[1] < int(LeafNodeType::DIM - 1))"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (} else { nijk = ijk .)",
    "insertText": "offsetBy(0, 1, 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(localCorod[1] > 0)"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (} else { nijk = ijk .)",
    "insertText": "offsetBy(0, -1, 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(localCorod[0] < int(LeafNodeType::DIM - 1))"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (} else { nijk = ijk .)",
    "insertText": "offsetBy(1, 0, 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(localCorod[0] > 0)"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (} else { nijk = ijk .)",
    "insertText": "offsetBy(-1, 0, 0)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "join(ConstructVoxelMask& rhs)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (mMaskTree ->)",
    "insertText": "merge(*rhs.mMaskTree)"
  },
  {
    "label": "Fragment()",
    "kind": "Method",
    "detail": "Function (} private : TreeType const* const mTree ; LeafNodeType** const mNodes ; BoolTreeType mLocalMaskTree ; BoolTreeType* const mMaskTree ; } ; template<TreeType,MeshDataAdapter> struct ExpandNarrowband { using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ; using NodeMaskType = LeafNodeType::NodeMaskType ; using Int32TreeType = TreeType::template ValueConverter<Int32>::Type ; using Int32LeafNodeType = Int32TreeType::LeafNodeType ; using BoolTreeType = TreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ; struct Fragment { Int32 idx,x,y,z ; ValueType dist ;)",
    "insertText": "Fragment() : idx(0), x(0), y(0), z(0), dist(0.0)"
  },
  {
    "label": "Fragment()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Fragment(Int32 idx_, Int32 x_, Int32 y_, Int32 z_, ValueType dist_) : idx(idx_), x(x_), y(y_), z(z_), dist(dist_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const Fragment& rhs)"
  },
  {
    "label": "ExpandNarrowband()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ExpandNarrowband(const ExpandNarrowband& rhs, tbb::split) : mMaskNodes(rhs.mMaskNodes) , mMaskTree(rhs.mMaskTree) , mDistTree(rhs.mDistTree) , mIndexTree(rhs.mIndexTree) , mMesh(rhs.mMesh) , mNewMaskTree(false) , mDistNodes() , mUpdatedDistNodes() , mIndexNodes() , mUpdatedIndexNodes() , mExteriorBandWidth(rhs.mExteriorBandWidth) , mInteriorBandWidth(rhs.mInteriorBandWidth) , mVoxelSize(rhs.mVoxelSize)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "join(ExpandNarrowband& rhs)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mDistNodes .)",
    "insertText": "insert(mDistNodes.end(), rhs.mDistNodes.begin(), rhs.mDistNodes.end())"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mIndexNodes .)",
    "insertText": "insert(mIndexNodes.end(), rhs.mIndexNodes.begin(), rhs.mIndexNodes.end())"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mUpdatedDistNodes .)",
    "insertText": "insert(mUpdatedDistNodes.end(), rhs.mUpdatedDistNodes.begin(), rhs.mUpdatedDistNodes.end())"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mUpdatedIndexNodes .)",
    "insertText": "insert(mUpdatedIndexNodes.end(), rhs.mUpdatedIndexNodes.begin(), rhs.mUpdatedIndexNodes.end())"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (mNewMaskTree .)",
    "insertText": "merge(rhs.mNewMaskTree)"
  },
  {
    "label": "newMaskAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<BoolTreeType>)",
    "insertText": "newMaskAcc(mNewMaskTree)"
  },
  {
    "label": "indexAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<Int32TreeType>)",
    "insertText": "indexAcc(*mIndexTree)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::vector<Fragment> fragments ; fragments .)",
    "insertText": "reserve(256)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BoolLeafNodeType& maskNode =* mMaskNodes [ n ] ;)",
    "insertText": "if(maskNode.isEmpty())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!distNodePt == !indexNodePt)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool usingNewNodes = false ;)",
    "insertText": "if(!distNodePt && !indexNodePt)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ValueType backgroundDist = distAcc .)",
    "insertText": "getValue(origin)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (newDistNodePt .)",
    "insertText": "reset(new LeafNodeType(origin, backgroundDist))"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (newIndexNodePt .)",
    "insertText": "reset(new Int32LeafNodeType(origin, indexAcc.getValue(origin)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if((backgroundDist < ValueType(0.0)) != (newDistNodePt->getValue(0) < ValueType(0.0)))"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (newDistNodePt ->)",
    "insertText": "buffer().fill(backgroundDist)"
  },
  {
    "label": "setOrigin()",
    "kind": "Method",
    "detail": "Function (} newDistNodePt ->)",
    "insertText": "setOrigin(origin)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} distNodePt = newDistNodePt .)",
    "insertText": "get()"
  },
  {
    "label": "bbox()",
    "kind": "Method",
    "detail": "Function (usingNewNodes = true ; } CoordBBox)",
    "insertText": "bbox(Coord::max(), Coord::min())"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(it.getCoord())"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (} bbox .)",
    "insertText": "expand(1)"
  },
  {
    "label": "gatherFragments()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "gatherFragments(fragments, bbox, distAcc, indexAcc)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (NodeMaskType mask ; bool updatedLeafNodes = false ;)",
    "insertText": "for(typename BoolLeafNodeType::ValueOnIter it = maskNode.beginValueOn(); it; ++it)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Coord nijk = ijk + util::COORD_OFFSETS [ i ] ;)",
    "insertText": "if(bbox.isInside(nijk))"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "setOn(BoolLeafNodeType::coordToOffset(nijk))"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} else { newMaskAcc .)",
    "insertText": "setValueOn(nijk)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(Int32 i = 6; i < 26; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } })",
    "insertText": "if(updatedLeafNodes)"
  },
  {
    "label": "getValueMask()",
    "kind": "Method",
    "detail": "Function (mask - = indexNodePt ->)",
    "insertText": "getValueMask()"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (const Coord ijk = maskNode .)",
    "insertText": "origin() + LeafNodeType::offsetToLocalCoord(pos)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (newMaskAcc .)",
    "insertText": "setValueOn(ijk + util::COORD_OFFSETS[i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(usingNewNodes)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (newDistNodePt ->)",
    "insertText": "topologyUnion(*newIndexNodePt)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mDistNodes .)",
    "insertText": "push_back(newDistNodePt.release())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mIndexNodes .)",
    "insertText": "push_back(newIndexNodePt.release())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} else { mUpdatedDistNodes .)",
    "insertText": "push_back(distNodePt)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mUpdatedIndexNodes .)",
    "insertText": "push_back(indexNodePt)"
  },
  {
    "label": "newMaskTree()",
    "kind": "Method",
    "detail": "Function (} } } } BoolTreeType&)",
    "insertText": "newMaskTree()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (fragments .)",
    "insertText": "clear()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (const Coord nodeMin = bbox .)",
    "insertText": "min() & ~(LeafNodeType::DIM - 1)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (const Coord nodeMax = bbox .)",
    "insertText": "max() & ~(LeafNodeType::DIM - 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (CoordBBox region ; Coord ijk ;)",
    "insertText": "for(ijk[0] = nodeMin[0]; ijk[0] <= nodeMax[0]; ijk[0] += LeafNodeType::DIM)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (region .)",
    "insertText": "min() = Coord::maxComponent(bbox.min(), ijk)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (region .)",
    "insertText": "max() = Coord::minComponent(bbox.max(), ijk.offsetBy(LeafNodeType::DIM - 1))"
  },
  {
    "label": "gatherFragments()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "gatherFragments(fragments, region, *distleaf, *indexAcc.probeLeaf(ijk))"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (} } } })",
    "insertText": "sort(fragments.begin(), fragments.end())"
  },
  {
    "label": "gatherFragments()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "gatherFragments(std::vector<Fragment>& fragments, const CoordBBox& bbox, const LeafNodeType& distLeaf, const Int32LeafNodeType& idxLeaf)"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "xPos(x & (LeafNodeType::DIM - 1u)) << (2 * LeafNodeType::LOG2DIM)"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (const Index yPos =)",
    "insertText": "xPos((y & (LeafNodeType::DIM - 1u)) << LeafNodeType::LOG2DIM)"
  },
  {
    "label": "yPos()",
    "kind": "Method",
    "detail": "Function (const Index pos =)",
    "insertText": "yPos(z & (LeafNodeType::DIM - 1u))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (fragments .)",
    "insertText": "push_back(Fragment(idxData[pos],x,y,z, std::abs(distData[pos])))"
  },
  {
    "label": "computeDistance()",
    "kind": "Method",
    "detail": "Function (} } } } } ValueType)",
    "insertText": "computeDistance(const Coord& ijk, const Int32 manhattanLimit, const std::vector<Fragment>& fragments, Int32& closestPrimIdx)"
  },
  {
    "label": "Int32()",
    "kind": "Method",
    "detail": "Function (Int32 lastIdx =)",
    "insertText": "Int32(util::INVALID_IDX)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Fragment& fragment = fragments [ n ] ;)",
    "insertText": "if(lastIdx == fragment.idx)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (const Int32 dx =)",
    "insertText": "abs(fragment.x - ijk[0])"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (const Int32 dy =)",
    "insertText": "abs(fragment.y - ijk[1])"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (const Int32 dz =)",
    "insertText": "abs(fragment.z - ijk[2])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Int32 manhattan = dx + dy + dz ;)",
    "insertText": "if(manhattan > manhattanLimit)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (lastIdx = fragment . idx ; const size_t polygon =)",
    "insertText": "size_t(lastIdx)"
  },
  {
    "label": "primDist()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "primDist(voxelCenter - closestPointOnTriangleToPoint(a, c, b, voxelCenter, uvw)).lengthSqr()"
  },
  {
    "label": "tmpDist()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tmpDist(voxelCenter - closestPointOnTriangleToPoint( a, b, c, voxelCenter, uvw)).lengthSqr()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(primDist < dist)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (dist = primDist ; closestPrimIdx = lastIdx ; } } return)",
    "insertText": "ValueType(std::sqrt(dist))"
  },
  {
    "label": "updateVoxel()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "updateVoxel(const Coord& ijk, const Int32 manhattanLimit, const std::vector<Fragment>& fragments, LeafNodeType& distLeaf, Int32LeafNodeType& idxLeaf, bool* updatedLeafNodes = nullptr)"
  },
  {
    "label": "computeDistance()",
    "kind": "Method",
    "detail": "Function (Int32 closestPrimIdx = 0 ; const ValueType distance =)",
    "insertText": "computeDistance(ijk, manhattanLimit, fragments, closestPrimIdx)"
  },
  {
    "label": "coordToOffset()",
    "kind": "Method",
    "detail": "Function (const Index pos =)",
    "insertText": "coordToOffset(ijk)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const bool inside = distLeaf .)",
    "insertText": "getValue(pos) < ValueType(0.0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool activateNeighbourVoxels = false ;)",
    "insertText": "if(!inside && distance < mExteriorBandWidth)"
  },
  {
    "label": "activateNeighbourVoxels()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "activateNeighbourVoxels(distance + mVoxelSize)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (distLeaf .)",
    "insertText": "setValueOnly(pos, distance)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (idxLeaf .)",
    "insertText": "setValueOn(pos, closestPrimIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(inside && distance < mInteriorBandWidth)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (distLeaf .)",
    "insertText": "setValueOnly(pos, -distance)"
  },
  {
    "label": "AddNodes()",
    "kind": "Method",
    "detail": "Function (} return activateNeighbourVoxels ; } BoolLeafNodeType** const mMaskNodes ; BoolTreeType* const mMaskTree ; TreeType* const mDistTree ; Int32TreeType* const mIndexTree ; MeshDataAdapter const* const mMesh ; BoolTreeType mNewMaskTree ; std::vector<LeafNodeType*> mDistNodes,mUpdatedDistNodes ; std::vector<Int32LeafNodeType*> mIndexNodes,mUpdatedIndexNodes ; const ValueType mExteriorBandWidth,mInteriorBandWidth,mVoxelSize ; } ; template<TreeType> struct AddNodes { using LeafNodeType = TreeType::LeafNodeType ;)",
    "insertText": "AddNodes(TreeType& tree, std::vector<LeafNodeType*>& nodes) : mTree(&tree) , mNodes(&nodes)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::vector<LeafNodeType*>& nodes =* mNodes ;)",
    "insertText": "for(size_t n = 0, N = nodes.size(); n < N; ++n)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (acc .)",
    "insertText": "addLeaf(nodes[n])"
  },
  {
    "label": "expandNarrowband()",
    "kind": "Method",
    "detail": "Function (} } TreeType* const mTree ; std::vector<LeafNodeType*>* const mNodes ; } ; template<TreeType,Int32TreeType,BoolTreeType,MeshDataAdapter> void)",
    "insertText": "expandNarrowband(TreeType& distTree, Int32TreeType& indexTree, BoolTreeType& maskTree, std::vector<typename BoolTreeType::LeafNodeType*>& maskNodes, const MeshDataAdapter& mesh, typename TreeType::ValueType exteriorBandWidth, typename TreeType::ValueType interiorBandWidth, typename TreeType::ValueType voxelSize)"
  },
  {
    "label": "expandOp()",
    "kind": "Method",
    "detail": "Function (ExpandNarrowband<TreeType,MeshDataAdapter>)",
    "insertText": "expandOp(maskNodes, maskTree, distTree, indexTree, mesh, exteriorBandWidth, interiorBandWidth, voxelSize)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, maskNodes.size()), expandOp)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, expandOp.updatedIndexNodes().size()), UnionValueMasks<typename TreeType::LeafNodeType, typename Int32TreeType::LeafNodeType>( expandOp.updatedDistNodes(), expandOp.updatedIndexNodes()))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (tbb::task_group tasks ; tasks .)",
    "insertText": "run(AddNodes<TreeType>(distTree, expandOp.newDistNodes()))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (tasks .)",
    "insertText": "run(AddNodes<Int32TreeType>(indexTree, expandOp.newIndexNodes()))"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (maskTree .)",
    "insertText": "merge(expandOp.newMaskTree())"
  },
  {
    "label": "TransformValues()",
    "kind": "Method",
    "detail": "Function (} template<TreeType> struct TransformValues { using LeafNodeType = TreeType::LeafNodeType ; using ValueType = TreeType::ValueType ;)",
    "insertText": "TransformValues(std::vector<LeafNodeType*>& nodes, ValueType voxelSize, bool unsignedDist) : mNodes(&nodes[0]) , mVoxelSize(voxelSize) , mUnsigned(unsignedDist)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType& val = const_cast<)",
    "insertText": "ValueType(iter.getValue())"
  },
  {
    "label": "udf()",
    "kind": "Method",
    "detail": "Function (val = w [)",
    "insertText": "udf(val < ValueType(0.0))] * std::sqrt(std::abs(val))"
  },
  {
    "label": "InactivateValues()",
    "kind": "Method",
    "detail": "Function (} } } private : LeafNodeType** const mNodes ; const ValueType mVoxelSize ; const bool mUnsigned ; } ; template<TreeType> struct InactivateValues { using LeafNodeType = TreeType::LeafNodeType ; using ValueType = TreeType::ValueType ;)",
    "insertText": "InactivateValues(std::vector<LeafNodeType*>& nodes, ValueType exBandWidth, ValueType inBandWidth) : mNodes(nodes.empty() ? nullptr : &nodes[0]) , mExBandWidth(exBandWidth) , mInBandWidth(inBandWidth)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (const bool inside = val<)",
    "insertText": "ValueType(0.0)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (val = inVal ; iter .)",
    "insertText": "setValueOff()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!inside && !(val < exVal))"
  },
  {
    "label": "OffsetValues()",
    "kind": "Method",
    "detail": "Function (} } } } private : LeafNodeType** const mNodes ; const ValueType mExBandWidth,mInBandWidth ; } ; template<TreeType> struct OffsetValues { using LeafNodeType = TreeType::LeafNodeType ; using ValueType = TreeType::ValueType ;)",
    "insertText": "OffsetValues(std::vector<LeafNodeType*>& nodes, ValueType offset) : mNodes(nodes.empty() ? nullptr : &nodes[0]), mOffset(offset)"
  },
  {
    "label": "beginValueOn()",
    "kind": "Method",
    "detail": "Function (LeafNodeType::ValueOnIter iter = mNodes [ n ] ->)",
    "insertText": "beginValueOn()"
  },
  {
    "label": "Renormalize()",
    "kind": "Method",
    "detail": "Function (val + = offset ; } } } private : LeafNodeType** const mNodes ; const ValueType mOffset ; } ; template<TreeType> struct Renormalize { using LeafNodeType = TreeType::LeafNodeType ; using ValueType = TreeType::ValueType ;)",
    "insertText": "Renormalize(const TreeType& tree, const std::vector<LeafNodeType*>& nodes, ValueType* buffer, ValueType voxelSize) : mTree(&tree) , mNodes(nodes.empty() ? nullptr : &nodes[0]) , mBuffer(buffer) , mVoxelSize(voxelSize)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (Coord ijk ; Vec3Type up,down ; const ValueType dx = mVoxelSize,invDx =)",
    "insertText": "ValueType(1.0)"
  },
  {
    "label": "cbeginValueOn()",
    "kind": "Method",
    "detail": "Function (ValueType* bufferData =& mBuffer [ n* LeafNodeType::SIZE ] ; LeafNodeType::ValueOnCIter iter = mNodes [ n ] ->)",
    "insertText": "cbeginValueOn()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (up [ 0 ] = acc .)",
    "insertText": "getValue(ijk.offsetBy(1, 0, 0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (up [ 1 ] = acc .)",
    "insertText": "getValue(ijk.offsetBy(0, 1, 0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (up [ 2 ] = acc .)",
    "insertText": "getValue(ijk.offsetBy(0, 0, 1))"
  },
  {
    "label": "GodunovsNormSqrd()",
    "kind": "Method",
    "detail": "Function (const ValueType normSqGradPhi =)",
    "insertText": "GodunovsNormSqrd(phi0 > 0.0, down, up)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (const ValueType diff =)",
    "insertText": "Sqrt(normSqGradPhi) * invDx - ValueType(1.0)"
  },
  {
    "label": "phi0()",
    "kind": "Method",
    "detail": "Function (const ValueType S =)",
    "insertText": "phi0(math::Sqrt(math::Pow2(phi0) + normSqGradPhi))"
  },
  {
    "label": "MinCombine()",
    "kind": "Method",
    "detail": "Function (} } } private : TreeType const* const mTree ; LeafNodeType const* const* const mNodes ; ValueType* const mBuffer ; const ValueType mVoxelSize ; } ; template<TreeType> struct MinCombine { using LeafNodeType = TreeType::LeafNodeType ; using ValueType = TreeType::ValueType ;)",
    "insertText": "MinCombine(std::vector<LeafNodeType*>& nodes, const ValueType* buffer) : mNodes(nodes.empty() ? nullptr : &nodes[0]), mBuffer(buffer)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (val =)",
    "insertText": "min(val, bufferData[iter.pos()])"
  },
  {
    "label": "nodeConnectivity()",
    "kind": "Method",
    "detail": "Function (using ConnectivityTable = mesh_to_volume_internal::LeafNodeConnectivityTable<FloatTreeT> ; ConnectivityTable)",
    "insertText": "nodeConnectivity(tree)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::vector<size_t> zStartNodes,yStartNodes,xStartNodes ;)",
    "insertText": "for(size_t n = 0; n < nodeConnectivity.size(); ++n)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (xStartNodes .)",
    "insertText": "push_back(n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ConnectivityTable::INVALID_OFFSET == nodeConnectivity.offsetsPrevY()[n])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ConnectivityTable::INVALID_OFFSET == nodeConnectivity.offsetsPrevZ()[n])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (} } using SweepingOp = mesh_to_volume_internal::SweepExteriorSign<FloatTreeT> ;)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, zStartNodes.size()), SweepingOp(SweepingOp::Z_AXIS, zStartNodes, nodeConnectivity))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, yStartNodes.size()), SweepingOp(SweepingOp::Y_AXIS, yStartNodes, nodeConnectivity))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, xStartNodes.size()), SweepingOp(SweepingOp::X_AXIS, xStartNodes, nodeConnectivity))"
  },
  {
    "label": "fillArray()",
    "kind": "Method",
    "detail": "Function (const size_t numVoxels = numLeafNodes* FloatTreeT::LeafNodeType::SIZE ; std::unique_ptr<bool [ ]> changedNodeMaskA { new bool [ numLeafNodes ] } ; std::unique_ptr<bool [ ]> changedNodeMaskB { new bool [ numLeafNodes ] } ; std::unique_ptr<bool [ ]> changedVoxelMask { new bool [ numVoxels ] } ;)",
    "insertText": "fillArray(changedNodeMaskA.get(), true, numLeafNodes)"
  },
  {
    "label": "fillArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fillArray(changedNodeMaskB.get(), false, numLeafNodes)"
  },
  {
    "label": "fillArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fillArray(changedVoxelMask.get(), false, numVoxels)"
  },
  {
    "label": "nodeRange()",
    "kind": "Method",
    "detail": "Function (const tbb::blocked_range<size_t>)",
    "insertText": "nodeRange(0, numLeafNodes)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (bool nodesUpdated = false ; do {)",
    "insertText": "parallel_for(nodeRange, mesh_to_volume_internal::SeedFillExteriorSign<FloatTreeT>( nodeConnectivity.nodes(), changedNodeMaskA.get()))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(nodeRange, mesh_to_volume_internal::SeedPoints<FloatTreeT>( nodeConnectivity, changedNodeMaskA.get(), changedNodeMaskB.get(), changedVoxelMask.get()))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (changedNodeMaskA .)",
    "insertText": "swap(changedNodeMaskB)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (nodesUpdated = false ;)",
    "insertText": "for(size_t n = 0; n < numLeafNodes; ++n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (nodesUpdated | = changedNodeMaskA [ n ] ;)",
    "insertText": "if(nodesUpdated)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(nodeRange, mesh_to_volume_internal::SyncVoxelMask<FloatTreeT>( nodeConnectivity.nodes(), changedNodeMaskA.get(), changedVoxelMask.get()))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "while(nodesUpdated)"
  },
  {
    "label": "meshToVolume()",
    "kind": "Method",
    "detail": "Function (} template<GridType,MeshDataAdapter,Interrupter> GridType::Ptr)",
    "insertText": "meshToVolume(Interrupter& interrupter, const MeshDataAdapter& mesh, const math::Transform& transform, float exteriorBandWidth, float interiorBandWidth, int flags, typename GridType::template ValueConverter<Int32>::Type * polygonIndexGrid)"
  },
  {
    "label": "distGrid()",
    "kind": "Method",
    "detail": "Function (using GridTypePtr = GridType::Ptr ; using TreeType = GridType::TreeType ; using LeafNodeType = TreeType::LeafNodeType ; using ValueType = GridType::ValueType ; using Int32GridType = GridType::template ValueConverter<Int32>::Type ; using Int32TreeType = Int32GridType::TreeType ; using BoolTreeType = TreeType::template ValueConverter<bool>::Type ; GridTypePtr)",
    "insertText": "distGrid(new GridType(std::numeric_limits<ValueType>::max()))"
  },
  {
    "label": "setTransform()",
    "kind": "Method",
    "detail": "Function (distGrid ->)",
    "insertText": "setTransform(transform.copy())"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType exteriorWidth =)",
    "insertText": "ValueType(exteriorBandWidth)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType interiorWidth =)",
    "insertText": "ValueType(interiorBandWidth)"
  },
  {
    "label": "OPENVDB_LOG_DEBUG()",
    "kind": "Method",
    "detail": "Function (std::stringstream msg ; msg<<\" Illegal narrow band width : exterior = \"<<exteriorWidth<<\",interior = \"<<interiorWidth ;)",
    "insertText": "OPENVDB_LOG_DEBUG(msg.str())"
  },
  {
    "label": "computeSignedDistanceField()",
    "kind": "Method",
    "detail": "Function (interiorWidth* = voxelSize ; } const bool)",
    "insertText": "computeSignedDistanceField(flags & UNSIGNED_DISTANCE_FIELD)"
  },
  {
    "label": "removeIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "removeIntersectingVoxels(flags & DISABLE_INTERSECTING_VOXEL_REMOVAL)"
  },
  {
    "label": "renormalizeValues()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "renormalizeValues(flags & DISABLE_RENORMALIZATION)"
  },
  {
    "label": "trimNarrowBand()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "trimNarrowBand(flags & DISABLE_NARROW_BAND_TRIMMING)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Int32GridType* indexGrid = nullptr ; Int32GridType::Ptr temporaryIndexGrid ;)",
    "insertText": "if(polygonIndexGrid)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (indexGrid = polygonIndexGrid ; } else { temporaryIndexGrid .)",
    "insertText": "reset(new Int32GridType(Int32(util::INVALID_IDX)))"
  },
  {
    "label": "newTree()",
    "kind": "Method",
    "detail": "Function (} indexGrid ->)",
    "insertText": "newTree()"
  },
  {
    "label": "setGridClass()",
    "kind": "Method",
    "detail": "Function (distGrid ->)",
    "insertText": "setGridClass(GRID_LEVEL_SET)"
  },
  {
    "label": "setGridClass()",
    "kind": "Method",
    "detail": "Function (} else { distGrid ->)",
    "insertText": "setGridClass(GRID_UNKNOWN)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (} TreeType& distTree = distGrid ->)",
    "insertText": "tree()"
  },
  {
    "label": "polygonRange()",
    "kind": "Method",
    "detail": "Function ({ using VoxelizationDataType = mesh_to_volume_internal::VoxelizationData<TreeType> ; using DataTable = tbb::enumerable_thread_specific<VoxelizationDataType::Ptr> ; DataTable data ; using Voxelizer = mesh_to_volume_internal::VoxelizePolygons<TreeType,MeshDataAdapter,Interrupter> ; const tbb::blocked_range<size_t>)",
    "insertText": "polygonRange(0, mesh.polygonCount())"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(polygonRange, Voxelizer(data, mesh, &interrupter))"
  },
  {
    "label": "combineData()",
    "kind": "Method",
    "detail": "Function (VoxelizationDataType& dataItem =** i ;)",
    "insertText": "combineData(distTree, indexTree, dataItem.distTree, dataItem.indexTree)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(interrupter.wasInterrupted(30))"
  },
  {
    "label": "traceExteriorBoundaries()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "traceExteriorBoundaries(distTree)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::vector<LeafNodeType*> nodes ; nodes .)",
    "insertText": "reserve(distTree.leafCount())"
  },
  {
    "label": "nodeRange()",
    "kind": "Method",
    "detail": "Function (const tbb::blocked_range<size_t>)",
    "insertText": "nodeRange(0, nodes.size())"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (using SignOp = mesh_to_volume_internal::ComputeIntersectingVoxelSign<TreeType,MeshDataAdapter> ;)",
    "insertText": "parallel_for(nodeRange, SignOp(nodes, distTree, indexTree, mesh))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(nodeRange, mesh_to_volume_internal::ValidateIntersectingVoxels<TreeType>(distTree, nodes))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(nodeRange, mesh_to_volume_internal::RemoveSelfIntersectingSurface<TreeType>( nodes, distTree, indexTree))"
  },
  {
    "label": "pruneInactive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pruneInactive(distTree, true)"
  },
  {
    "label": "pruneInactive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pruneInactive(indexTree, true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(interrupter.wasInterrupted(50))"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (distTree .)",
    "insertText": "root().setBackground(exteriorWidth, false)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, nodes.size()), mesh_to_volume_internal::TransformValues<TreeType>( nodes, voxelSize, !computeSignedDistanceField))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(computeSignedDistanceField)"
  },
  {
    "label": "signedFloodFillWithValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "signedFloodFillWithValues(distTree, exteriorWidth, -interiorWidth)"
  },
  {
    "label": "changeBackground()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "changeBackground(distTree, exteriorWidth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(interrupter.wasInterrupted(54))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (const ValueType minBandWidth = voxelSize*)",
    "insertText": "ValueType(2.0)"
  },
  {
    "label": "maskTree()",
    "kind": "Method",
    "detail": "Function (BoolTreeType)",
    "insertText": "maskTree(false)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (mesh_to_volume_internal::ConstructVoxelMask<TreeType>)",
    "insertText": "op(maskTree, distTree, nodes)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, nodes.size()), op)"
  },
  {
    "label": "ceil()",
    "kind": "Method",
    "detail": "Function (float progress = 5 4 . 0 f,step = 0 . 0 f ; double estimated = 2 . 0*)",
    "insertText": "ceil((std::max(interiorWidth, exteriorWidth) - minBandWidth) / voxelSize)"
  },
  {
    "label": "unsigned()",
    "kind": "Method",
    "detail": "Function (maxIterations =)",
    "insertText": "unsigned(estimated)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (step = 4 0 . 0 f /)",
    "insertText": "float(maxIterations)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} std::vector<BoolTreeType::LeafNodeType*> maskNodes ; unsigned count = 0 ;)",
    "insertText": "while(true)"
  },
  {
    "label": "leafCount()",
    "kind": "Method",
    "detail": "Function (const size_t maskNodeCount = maskTree .)",
    "insertText": "leafCount()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (maskNodes .)",
    "insertText": "reserve(maskNodeCount)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (maskTree .)",
    "insertText": "getNodes(maskNodes)"
  },
  {
    "label": "range()",
    "kind": "Method",
    "detail": "Function (const tbb::blocked_range<size_t>)",
    "insertText": "range(0, maskNodes.size())"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(range, mesh_to_volume_internal::DiffLeafNodeMask<TreeType>(distTree, maskNodes))"
  },
  {
    "label": "expandNarrowband()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "expandNarrowband(distTree, indexTree, maskTree, maskNodes, mesh, exteriorWidth, interiorWidth, voxelSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (progress + = step ; } })",
    "insertText": "if(interrupter.wasInterrupted(94))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (const ValueType offset =)",
    "insertText": "ValueType(0.8 * voxelSize)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, nodes.size()), mesh_to_volume_internal::OffsetValues<TreeType>(nodes, -offset))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, nodes.size()), mesh_to_volume_internal::Renormalize<TreeType>( distTree, nodes, buffer.get(), voxelSize))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, nodes.size()), mesh_to_volume_internal::MinCombine<TreeType>(nodes, buffer.get()))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, nodes.size()), mesh_to_volume_internal::OffsetValues<TreeType>( nodes, offset - mesh_to_volume_internal::Tolerance<ValueType>::epsilon()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(interrupter.wasInterrupted(99))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, nodes.size()), mesh_to_volume_internal::InactivateValues<TreeType>( nodes, exteriorWidth, computeSignedDistanceField ? interiorWidth : exteriorWidth))"
  },
  {
    "label": "pruneLevelSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pruneLevelSet(distTree, exteriorWidth, computeSignedDistanceField ? -interiorWidth : -exteriorWidth)"
  },
  {
    "label": "meshToVolume()",
    "kind": "Method",
    "detail": "Function (} return distGrid ; } template<GridType,MeshDataAdapter> GridType::Ptr)",
    "insertText": "meshToVolume(const MeshDataAdapter& mesh, const math::Transform& transform, float exteriorBandWidth, float interiorBandWidth, int flags, typename GridType::template ValueConverter<Int32>::Type * polygonIndexGrid)"
  },
  {
    "label": "GridType()",
    "kind": "Method",
    "detail": "Function (util::NullInterrupter nullInterrupter ; return meshToVolume<)",
    "insertText": "GridType(nullInterrupter, mesh, transform, exteriorBandWidth, interiorBandWidth, flags, polygonIndexGrid)"
  },
  {
    "label": "doMeshConversion()",
    "kind": "Method",
    "detail": "Function (} template<GridType,Interrupter> std::enable_if<std::is_floating_point<GridType::ValueType>::value,GridType::Ptr>::type)",
    "insertText": "doMeshConversion(Interrupter& interrupter, const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, const std::vector<Vec4I>& quads, float exBandWidth, float inBandWidth, bool unsignedDistanceField = false)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<Vec3s [ ]> indexSpacePoints { new Vec3s [ numPoints ] } ;)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, numPoints), mesh_to_volume_internal::TransformPoints<Vec3s>( &points[0], indexSpacePoints.get(), xform))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int conversionFlags = unsignedDistanceField ? UNSIGNED_DISTANCE_FIELD : 0 ;)",
    "insertText": "if(quads.empty())"
  },
  {
    "label": "mesh()",
    "kind": "Method",
    "detail": "Function (QuadAndTriangleDataAdapter<Vec3s,Vec3I>)",
    "insertText": "mesh(indexSpacePoints.get(), numPoints, &triangles[0], triangles.size())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(triangles.empty())"
  },
  {
    "label": "mesh()",
    "kind": "Method",
    "detail": "Function (QuadAndTriangleDataAdapter<Vec3s,Vec4I>)",
    "insertText": "mesh(indexSpacePoints.get(), numPoints, &quads[0], quads.size())"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} const size_t numPrimitives = triangles .)",
    "insertText": "size() + quads.size()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<Vec4I [ ]> prims { new Vec4I [ numPrimitives ] } ;)",
    "insertText": "for(size_t n = 0, N = triangles.size(); n < N; ++n)"
  },
  {
    "label": "mesh()",
    "kind": "Method",
    "detail": "Function (prims [ offset + n ] = quads [ n ] ; } QuadAndTriangleDataAdapter<Vec3s,Vec4I>)",
    "insertText": "mesh(indexSpacePoints.get(), numPoints, prims.get(), numPrimitives)"
  },
  {
    "label": "doMeshConversion()",
    "kind": "Method",
    "detail": "Function (} template<GridType,Interrupter> std::enable_if<! std::is_floating_point<GridType::ValueType>::value,GridType::Ptr>::type)",
    "insertText": "doMeshConversion(Interrupter&, const math::Transform& , const std::vector<Vec3s>& , const std::vector<Vec3I>& , const std::vector<Vec4I>& , float , float , bool = false)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(TypeError, \"mesh to volume conversion is supported only for scalar floating-point grids\")"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::Ptr)",
    "insertText": "meshToLevelSet(const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, float halfWidth)"
  },
  {
    "label": "quads()",
    "kind": "Method",
    "detail": "Function (util::NullInterrupter nullInterrupter ; std::vector<Vec4I>)",
    "insertText": "quads(0)"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (} template<GridType,Interrupter> GridType::Ptr)",
    "insertText": "meshToLevelSet(Interrupter& interrupter, const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, float halfWidth)"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::Ptr)",
    "insertText": "meshToLevelSet(const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec4I>& quads, float halfWidth)"
  },
  {
    "label": "triangles()",
    "kind": "Method",
    "detail": "Function (util::NullInterrupter nullInterrupter ; std::vector<Vec3I>)",
    "insertText": "triangles(0)"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (} template<GridType,Interrupter> GridType::Ptr)",
    "insertText": "meshToLevelSet(Interrupter& interrupter, const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec4I>& quads, float halfWidth)"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::Ptr)",
    "insertText": "meshToLevelSet(const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, const std::vector<Vec4I>& quads, float halfWidth)"
  },
  {
    "label": "GridType()",
    "kind": "Method",
    "detail": "Function (util::NullInterrupter nullInterrupter ; return doMeshConversion<)",
    "insertText": "GridType(nullInterrupter, xform, points, triangles, quads, halfWidth, halfWidth)"
  },
  {
    "label": "meshToLevelSet()",
    "kind": "Method",
    "detail": "Function (} template<GridType,Interrupter> GridType::Ptr)",
    "insertText": "meshToLevelSet(Interrupter& interrupter, const openvdb::math::Transform& xform, const std::vector<Vec3s>& points, const std::vector<Vec3I>& triangles, const std::vector<Vec4I>& quads, float halfWidth)"
  },
  {
    "label": "GridType()",
    "kind": "Method",
    "detail": "Function (util::NullInterrupter nullInterrupter ; return doMeshConversion<)",
    "insertText": "GridType(nullInterrupter, xform, points, triangles, quads, exBandWidth, inBandWidth)"
  },
  {
    "label": "GridType()",
    "kind": "Method",
    "detail": "Function (util::NullInterrupter nullInterrupter ; return doMeshConversion<)",
    "insertText": "GridType(nullInterrupter, xform, points, triangles, quads, bandWidth, bandWidth, true)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} std::ostream&)",
    "insertText": "operator(std::ostream& ostr, const MeshToVoxelEdgeData::EdgeData& rhs)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (ostr<<\" { [ \"<<rhs . mXPrim<<\",\"<<rhs . mXDist<<\" ] \" ; ostr<<\" [ \"<<rhs . mYPrim<<\",\"<<rhs . mYDist<<\" ] \" ; ostr<<\" [ \"<<rhs . mZPrim<<\",\"<<rhs . mZDist<<\" ] } \" ; return ostr ; } MeshToVoxelEdgeData::EdgeData)",
    "insertText": "Abs(const MeshToVoxelEdgeData::EdgeData& x)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "run(bool threaded = true)"
  },
  {
    "label": "GenEdgeData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GenEdgeData(GenEdgeData& rhs, tbb::split)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator() (const tbb::blocked_range<size_t> &range)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "join(GenEdgeData& rhs)"
  },
  {
    "label": "voxelize()",
    "kind": "Method",
    "detail": "Function (} struct Primitive { Vec3d a,b,c,d ; Int32 index ; } ; template<bool IsQuad> void)",
    "insertText": "voxelize(const Primitive&)"
  },
  {
    "label": "evalPrimitive()",
    "kind": "Method",
    "detail": "Function (template<bool IsQuad> bool)",
    "insertText": "evalPrimitive(const Coord&, const Primitive&)"
  },
  {
    "label": "rayTriangleIntersection()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "rayTriangleIntersection(const Vec3d& origin, const Vec3d& dir, const Vec3d& a, const Vec3d& b, const Vec3d& c, double& t)"
  },
  {
    "label": "GenEdgeData()",
    "kind": "Method",
    "detail": "Function (TreeType mTree ; Accessor mAccessor ; const std::vector<Vec3s>& mPointList ; const std::vector<Vec4I>& mPolygonList ; using IntTreeT = TreeType::ValueConverter<Int32>::Type ; IntTreeT mLastPrimTree ; tree::ValueAccessor<IntTreeT> mLastPrimAccessor ; } ; MeshToVoxelEdgeData::)",
    "insertText": "GenEdgeData(const std::vector<Vec3s>& pointList, const std::vector<Vec4I>& polygonList) : mTree(EdgeData()) , mAccessor(mTree) , mPointList(pointList) , mPolygonList(polygonList) , mLastPrimTree(Int32(util::INVALID_IDX)) , mLastPrimAccessor(mLastPrimTree)"
  },
  {
    "label": "GenEdgeData()",
    "kind": "Method",
    "detail": "Function (} MeshToVoxelEdgeData::)",
    "insertText": "GenEdgeData(GenEdgeData& rhs, tbb::split) : mTree(EdgeData()) , mAccessor(mTree) , mPointList(rhs.mPointList) , mPolygonList(rhs.mPolygonList) , mLastPrimTree(Int32(util::INVALID_IDX)) , mLastPrimAccessor(mLastPrimTree)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} void MeshToVoxelEdgeData::)",
    "insertText": "run(bool threaded)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, mPolygonList.size()), *this)"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "else(*this)(tbb::blocked_range<size_t>(0, mPolygonList.size()))"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using RootNodeType = TreeType::RootNodeType ; using NodeChainType = RootNodeType::NodeChainType ;)",
    "insertText": "static_assert(NodeChainType::Size > 1, \"expected tree height > 1\")"
  },
  {
    "label": "beginLeaf()",
    "kind": "Method",
    "detail": "Function (TreeType::LeafIter leafIt = rhs . mTree .)",
    "insertText": "beginLeaf()"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (TreeType::LeafNodeType* lhsLeafPt = mTree .)",
    "insertText": "probeLeaf(ijk)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (mAccessor .)",
    "insertText": "addLeaf(rhs.mAccessor.probeLeaf(ijk))"
  },
  {
    "label": "InternalNodeType()",
    "kind": "Method",
    "detail": "Function (InternalNodeType* node = rhs . mAccessor . getNode<)",
    "insertText": "InternalNodeType()"
  },
  {
    "label": "LeafNodeType()",
    "kind": "Method",
    "detail": "Function (node -> stealNode<)",
    "insertText": "LeafNodeType(ijk, EdgeData(), false)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const EdgeData& rhsValue = it .)",
    "insertText": "getValue()"
  },
  {
    "label": "EdgeData()",
    "kind": "Method",
    "detail": "Function (} else { EdgeData& lhsValue = const_cast<)",
    "insertText": "EdgeData(lhsLeafPt->getValue(offset))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lhsValue . mXDist = rhsValue . mXDist ; lhsValue . mXPrim = rhsValue . mXPrim ; })",
    "insertText": "if(rhsValue.mYDist < lhsValue.mYDist)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lhsValue . mYDist = rhsValue . mYDist ; lhsValue . mYPrim = rhsValue . mYPrim ; })",
    "insertText": "if(rhsValue.mZDist < lhsValue.mZDist)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (lhsValue . mZDist = rhsValue . mZDist ; lhsValue . mZPrim = rhsValue . mZPrim ; } } } } } } void MeshToVoxelEdgeData::)",
    "insertText": "operator()(const tbb::blocked_range<size_t> &range)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Primitive prim ;)",
    "insertText": "for(size_t n = range.begin(); n < range.end(); ++n)"
  },
  {
    "label": "Vec3d()",
    "kind": "Method",
    "detail": "Function (prim . a =)",
    "insertText": "Vec3d(mPointList[verts[0]])"
  },
  {
    "label": "Vec3d()",
    "kind": "Method",
    "detail": "Function (prim . b =)",
    "insertText": "Vec3d(mPointList[verts[1]])"
  },
  {
    "label": "Vec3d()",
    "kind": "Method",
    "detail": "Function (prim . c =)",
    "insertText": "Vec3d(mPointList[verts[2]])"
  },
  {
    "label": "Vec3d()",
    "kind": "Method",
    "detail": "Function (prim . d =)",
    "insertText": "Vec3d(mPointList[verts[3]])"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (voxelize<)",
    "insertText": "true(prim)"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (} else { voxelize<)",
    "insertText": "false(prim)"
  },
  {
    "label": "voxelize()",
    "kind": "Method",
    "detail": "Function (} } } template<bool IsQuad> void MeshToVoxelEdgeData::)",
    "insertText": "voxelize(const Primitive& prim)"
  },
  {
    "label": "IsQuad()",
    "kind": "Method",
    "detail": "Function (evalPrimitive<)",
    "insertText": "IsQuad(ijk, prim)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (nijk = ijk + util::COORD_OFFSETS [ i ] ;)",
    "insertText": "if(prim.index != mLastPrimAccessor.getValue(nijk))"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (mLastPrimAccessor .)",
    "insertText": "setValue(nijk, prim.index)"
  },
  {
    "label": "evalPrimitive()",
    "kind": "Method",
    "detail": "Function (} } } } template<bool IsQuad> bool MeshToVoxelEdgeData::)",
    "insertText": "evalPrimitive(const Coord& ijk, const Primitive& prim)"
  },
  {
    "label": "org()",
    "kind": "Method",
    "detail": "Function (Vec3d uvw,)",
    "insertText": "org(ijk[0], ijk[1], ijk[2])"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (bool intersecting = false ; double t ; EdgeData edgeData ; mAccessor .)",
    "insertText": "probeValue(ijk, edgeData)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (edgeData . mXDist =)",
    "insertText": "float(t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (edgeData . mXPrim = prim . index ; intersecting = true ; } })",
    "insertText": "if(rayTriangleIntersection(org, Vec3d(0.0, 1.0, 0.0), prim.a, prim.c, prim.b, t))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (edgeData . mYPrim = prim . index ; intersecting = true ; } })",
    "insertText": "if(rayTriangleIntersection(org, Vec3d(0.0, 0.0, 1.0), prim.a, prim.c, prim.b, t))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (edgeData . mZPrim = prim . index ; intersecting = true ; } })",
    "insertText": "if(IsQuad)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (edgeData . mXPrim = prim . index ; intersecting = true ; } })",
    "insertText": "if(rayTriangleIntersection(org, Vec3d(0.0, 1.0, 0.0), prim.a, prim.d, prim.c, t))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (edgeData . mYPrim = prim . index ; intersecting = true ; } })",
    "insertText": "if(rayTriangleIntersection(org, Vec3d(0.0, 0.0, 1.0), prim.a, prim.d, prim.c, t))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (edgeData . mZPrim = prim . index ; intersecting = true ; } } })",
    "insertText": "if(intersecting) mAccessor.setValue(ijk, edgeData)"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (Vec3d e1 = b - a ; Vec3d e2 = c - a ; Vec3d s1 = dir .)",
    "insertText": "cross(e2)"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (Vec3d s2 = d .)",
    "insertText": "cross(e1)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (t = e2 .)",
    "insertText": "dot(s2)"
  },
  {
    "label": "MeshToVoxelEdgeData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MeshToVoxelEdgeData() : mTree(EdgeData())"
  },
  {
    "label": "converter()",
    "kind": "Method",
    "detail": "Function (GenEdgeData)",
    "insertText": "converter(pointList, polygonList)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (converter .)",
    "insertText": "run()"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (mTree .)",
    "insertText": "merge(converter.tree())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (EdgeData data ; Vec3d point ; Coord coord = ijk ;)",
    "insertText": "if(acc.probeValue(coord, data))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (point [ 0 ] =)",
    "insertText": "double(coord[0])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (point [ 1 ] =)",
    "insertText": "double(coord[1])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (point [ 2 ] =)",
    "insertText": "double(coord[2])"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (points .)",
    "insertText": "push_back(point)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (primitives .)",
    "insertText": "push_back(data.mXPrim)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(data.mYPrim != util::INVALID_IDX)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (primitives .)",
    "insertText": "push_back(data.mYPrim)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(data.mZPrim != util::INVALID_IDX)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (primitives .)",
    "insertText": "push_back(data.mZPrim)"
  },
  {
    "label": "createLevelSetBox()",
    "kind": "Method",
    "detail": "Function (} } } template<GridType,VecType> GridType::Ptr)",
    "insertText": "createLevelSetBox(const math::BBox<VecType>& bbox, const openvdb::math::Transform& xform, typename VecType::ValueType halfWidth)"
  },
  {
    "label": "Vec3s()",
    "kind": "Method",
    "detail": "Function (const Vec3s pmin =)",
    "insertText": "Vec3s(xform.worldToIndex(bbox.min()))"
  },
  {
    "label": "Vec3s()",
    "kind": "Method",
    "detail": "Function (const Vec3s pmax =)",
    "insertText": "Vec3s(xform.worldToIndex(bbox.max()))"
  },
  {
    "label": "Vec3s()",
    "kind": "Method",
    "detail": "Function (Vec3s points [ 8 ] ; points [ 0 ] =)",
    "insertText": "Vec3s(pmin[0], pmin[1], pmin[2])"
  },
  {
    "label": "Vec3s()",
    "kind": "Method",
    "detail": "Function (points [ 1 ] =)",
    "insertText": "Vec3s(pmin[0], pmin[1], pmax[2])"
  },
  {
    "label": "Vec3s()",
    "kind": "Method",
    "detail": "Function (points [ 2 ] =)",
    "insertText": "Vec3s(pmax[0], pmin[1], pmax[2])"
  },
  {
    "label": "Vec3s()",
    "kind": "Method",
    "detail": "Function (points [ 3 ] =)",
    "insertText": "Vec3s(pmax[0], pmin[1], pmin[2])"
  },
  {
    "label": "Vec3s()",
    "kind": "Method",
    "detail": "Function (points [ 4 ] =)",
    "insertText": "Vec3s(pmin[0], pmax[1], pmin[2])"
  },
  {
    "label": "Vec3s()",
    "kind": "Method",
    "detail": "Function (points [ 5 ] =)",
    "insertText": "Vec3s(pmin[0], pmax[1], pmax[2])"
  },
  {
    "label": "Vec3s()",
    "kind": "Method",
    "detail": "Function (points [ 6 ] =)",
    "insertText": "Vec3s(pmax[0], pmax[1], pmax[2])"
  },
  {
    "label": "Vec3s()",
    "kind": "Method",
    "detail": "Function (points [ 7 ] =)",
    "insertText": "Vec3s(pmax[0], pmax[1], pmin[2])"
  },
  {
    "label": "Vec4I()",
    "kind": "Method",
    "detail": "Function (Vec4I faces [ 6 ] ; faces [ 0 ] =)",
    "insertText": "Vec4I(0, 1, 2, 3)"
  },
  {
    "label": "Vec4I()",
    "kind": "Method",
    "detail": "Function (faces [ 1 ] =)",
    "insertText": "Vec4I(7, 6, 5, 4)"
  },
  {
    "label": "Vec4I()",
    "kind": "Method",
    "detail": "Function (faces [ 2 ] =)",
    "insertText": "Vec4I(4, 5, 1, 0)"
  },
  {
    "label": "Vec4I()",
    "kind": "Method",
    "detail": "Function (faces [ 3 ] =)",
    "insertText": "Vec4I(6, 7, 3, 2)"
  },
  {
    "label": "Vec4I()",
    "kind": "Method",
    "detail": "Function (faces [ 4 ] =)",
    "insertText": "Vec4I(0, 3, 7, 4)"
  },
  {
    "label": "Vec4I()",
    "kind": "Method",
    "detail": "Function (faces [ 5 ] =)",
    "insertText": "Vec4I(1, 5, 6, 2)"
  },
  {
    "label": "mesh()",
    "kind": "Method",
    "detail": "Function (QuadAndTriangleDataAdapter<Vec3s,Vec4I>)",
    "insertText": "mesh(points, 8, faces, 6)"
  }
]