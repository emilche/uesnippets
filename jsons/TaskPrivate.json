[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FPipe",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPipe"
  },
  {
    "label": "FTaskBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTaskBase"
  },
  {
    "label": "FPrerequisites",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPrerequisites"
  },
  {
    "label": "FSubsequents",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSubsequents"
  },
  {
    "label": "TTaskWithResult",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TTaskWithResult"
  },
  {
    "label": "TExecutableTaskBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TExecutableTaskBase"
  },
  {
    "label": "TExecutableTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TExecutableTask"
  },
  {
    "label": "FTaskEventBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTaskEventBase"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Async / EventCount . h \" # include \" Async / Fundamental / Scheduler . h \" # include \" Async / Fundamental / Task . h \" # include \" Async / Mutex . h \" # include \" Async / TaskGraphFwd . h \" # include \" Async / TaskTrace . h \" # include \" Async / UniqueLock . h \" # include \" Containers / Array . h \" # include \" Containers / LockFreeFixedSizeAllocator . h \" # include \" Containers / LockFreeList . h \" # include \" CoreGlobals . h \" # include \" CoreTypes . h \" # include \" Experimental / ConcurrentLinearAllocator . h \" # include \" HAL / Event . h \" # include \" HAL / PlatformProcess . h \" # include \" HAL / PlatformTLS . h \" # include \" HAL / Thread . h \" # include \" Logging / LogCategory . h \" # include \" Logging / LogMacros . h \" # include \" Math / NumericLimits . h \" # include \" Math / UnrealMathUtility . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / Timeout . h \" # include \" Misc / Timespan . h \" # include \" ProfilingDebugging / CpuProfilerTrace . h \" # include \" Templates / EnableIf . h \" # include \" Templates / Invoke . h \" # include \" Templates / MemoryOps . h \" # include \" Templates / RefCounting . h \" # include \" Templates / TypeCompatibleBytes . h \" # include \" Templates / UnrealTemplate . h \" # include \" Templates / UnrealTypeTraits . h \" # include \" Async / InheritedContext . h \" # include<atomic> # include<type_traits> # ifndef WITH_TASKGRAPH_VERBOSE_TRACE # define WITH_TASKGRAPH_VERBOSE_TRACE 0 # endif # if WITH_TASKGRAPH_VERBOSE_TRACE # define)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(Name) TRACE_CPUPROFILER_EVENT_SCOPE(Name) #else #define TASKGRAPH_VERBOSE_EVENT_SCOPE(Name)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (using LowLevelTasks::ETaskPriority ; using LowLevelTasks::ToString ; using LowLevelTasks::ToTaskPriority ; enum class EExtendedTaskPriority { None,,TaskEvent,# if TASKGRAPH_NEW_FRONTEND GameThreadNormalPri,GameThreadHiPri,GameThreadNormalPriLocalQueue,GameThreadHiPriLocalQueue,RenderThreadNormalPri,RenderThreadHiPri,RenderThreadNormalPriLocalQueue,RenderThreadHiPriLocalQueue,RHIThreadNormalPri,RHIThreadHiPri,RHIThreadNormalPriLocalQueue,RHIThreadHiPriLocalQueue,# endif Count } ; const TCHAR*)",
    "insertText": "ToString(EExtendedTaskPriority ExtendedPriority)"
  },
  {
    "label": "ToExtendedTaskPriority()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ToExtendedTaskPriority(const TCHAR* ExtendedPriorityStr, EExtendedTaskPriority& OutExtendedPriority)"
  },
  {
    "label": "TranslatePriority()",
    "kind": "Method",
    "detail": "Function (enum class ETaskFlags { None,DoNotRunInsideBusyWait } ; namespace Private { void)",
    "insertText": "TranslatePriority(ENamedThreads::Type ThreadType, ETaskPriority& OutPriority, EExtendedTaskPriority& OutExtendedPriority)"
  },
  {
    "label": "TranslatePriority()",
    "kind": "Method",
    "detail": "Function (ENamedThreads::Type)",
    "insertText": "TranslatePriority(ETaskPriority Priority, EExtendedTaskPriority ExtendedPriority)"
  },
  {
    "label": "GetCurrentTask()",
    "kind": "Method",
    "detail": "Function (} class FPipe ; namespace Private { class FTaskBase ; FTaskBase*)",
    "insertText": "GetCurrentTask()"
  },
  {
    "label": "ExchangeCurrentTask()",
    "kind": "Method",
    "detail": "Function (FTaskBase*)",
    "insertText": "ExchangeCurrentTask(FTaskBase* Task)"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (class FTaskBase : private UE::FInheritedContextBase {)",
    "insertText": "UE_NONCOPYABLE(FTaskBase)"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (uint32 ExecutionFlag = 0 x80000000 ; public : void)",
    "insertText": "AddRef()"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (RefCount .)",
    "insertText": "fetch_add(1, std::memory_order_relaxed)"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Release()"
  },
  {
    "label": "fetch_sub()",
    "kind": "Method",
    "detail": "Function (uint32 LocalRefCount = RefCount .)",
    "insertText": "fetch_sub(1, std::memory_order_acq_rel)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(__clang_analyzer__)"
  },
  {
    "label": "GetRefCount()",
    "kind": "Method",
    "detail": "Function (# endif } } uint32)",
    "insertText": "GetRefCount(std::memory_order MemoryOrder = std::memory_order_relaxed)"
  },
  {
    "label": "FTaskBase()",
    "kind": "Method",
    "detail": "Function (} private : std::atomic<uint32> RefCount ; protected :)",
    "insertText": "FTaskBase(uint32 InitRefCount, bool bUnlockPrerequisites = true) : RefCount(InitRefCount)"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (Prerequisites .)",
    "insertText": "Unlock()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Init(const TCHAR* InDebugName, ETaskPriority InPriority, EExtendedTaskPriority InExtendedPriority, ETaskFlags Flags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (LowLevelTasks::ETaskFlags LowLevelTaskFlags = LowLevelTasks::ETaskFlags::DefaultFlags ;)",
    "insertText": "if(Flags == ETaskFlags::DoNotRunInsideBusyWait)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (LowLevelTaskFlags& = ~ LowLevelTasks::ETaskFlags::AllowBusyWaiting ; } LowLevelTask .)",
    "insertText": "Init(InDebugName, InPriority, [ this, Deleter = LowLevelTasks::TDeleter<FTaskBase, &FTaskBase::Release>{ this } ] { TryExecuteTask(); }, LowLevelTaskFlags)"
  },
  {
    "label": "CaptureInheritedContext()",
    "kind": "Method",
    "detail": "Function (ExtendedPriority = InExtendedPriority ;)",
    "insertText": "CaptureInheritedContext()"
  },
  {
    "label": "FTaskBase()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FTaskBase()"
  },
  {
    "label": "Destroyed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroyed(GetTraceId())"
  },
  {
    "label": "ExecuteTask()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExecuteTask()"
  },
  {
    "label": "IsAwaitable()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "IsAwaitable()"
  },
  {
    "label": "IsNamedThreadTask()",
    "kind": "Method",
    "detail": "Function (} # if TASKGRAPH_NEW_FRONTEND bool)",
    "insertText": "IsNamedThreadTask()"
  },
  {
    "label": "GetExtendedPriority()",
    "kind": "Method",
    "detail": "Function (} EExtendedTaskPriority)",
    "insertText": "GetExtendedPriority()"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FTaskBase::AddPrerequisites_Single)"
  },
  {
    "label": "fetch_sub()",
    "kind": "Method",
    "detail": "Function (NumLocks .)",
    "insertText": "fetch_sub(1, std::memory_order_relaxed)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (Prerequisites .)",
    "insertText": "Push(&Prerequisite)"
  },
  {
    "label": "AddPrerequisites()",
    "kind": "Method",
    "detail": "Function (} template<HigherLevelTaskType,std::enable_if_t<std::is_same_v<HigherLevelTaskType,FGraphEventRef>>* = nullptr> bool)",
    "insertText": "AddPrerequisites(const HigherLevelTaskType& Prerequisite)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} protected : template<PrerequisiteCollectionType,)",
    "insertText": "decltype(std::declval<PrerequisiteCollectionType>().begin())* = nullptr> void AddPrerequisites(const PrerequisiteCollectionType& InPrerequisites, bool bLockPrerequisite)"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FTaskBase::AddPrerequisites_Collection)"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (uint32 PrevNumLocks = NumLocks .)",
    "insertText": "fetch_add(GetNum(InPrerequisites), std::memory_order_relaxed)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (uint32 NumCompletedPrerequisites = 0 ;)",
    "insertText": "for(auto& Prereq : InPrerequisites)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (FTaskBase* Prerequisite ; using FPrerequisiteType = std::decay_t<)",
    "insertText": "decltype(*std::declval<PrerequisiteCollectionType>().begin())"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (Prerequisite = Prereq ; } else if)",
    "insertText": "constexpr(std::is_same_v<FPrerequisiteType, FGraphEventRef>)"
  },
  {
    "label": "GetReference()",
    "kind": "Method",
    "detail": "Function (Prerequisite = Prereq .)",
    "insertText": "GetReference()"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(std::is_pointer_v<FPrerequisiteType>)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Prerequisite = Prereq -> Pimpl ; } else { Prerequisite = Prereq . Pimpl ; })",
    "insertText": "if(Prerequisite == nullptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + NumCompletedPrerequisites ; continue ; })",
    "insertText": "if(Prerequisite->AddSubsequent(*this))"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (Prerequisites .)",
    "insertText": "Push(Prerequisite)"
  },
  {
    "label": "PushNoLock()",
    "kind": "Method",
    "detail": "Function (} else { Prerequisites .)",
    "insertText": "PushNoLock(Prerequisite)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (} } else { + + NumCompletedPrerequisites ; } })",
    "insertText": "checkf(PrevNumLocks + GetNum(InPrerequisites) < ExecutionFlag, TEXT(\"Max number of nested tasks reached: %d\"), ExecutionFlag)"
  },
  {
    "label": "fetch_sub()",
    "kind": "Method",
    "detail": "Function (NumLocks .)",
    "insertText": "fetch_sub(NumCompletedPrerequisites, std::memory_order_release)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} public : template<PrerequisiteCollectionType,)",
    "insertText": "decltype(std::declval<PrerequisiteCollectionType>().begin())* = nullptr> void AddPrerequisites(const PrerequisiteCollectionType& InPrerequisites)"
  },
  {
    "label": "AddPrerequisites()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddPrerequisites(InPrerequisites, true)"
  },
  {
    "label": "AddSubsequent()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "AddSubsequent(FTaskBase& Subsequent)"
  },
  {
    "label": "SubsequentAdded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubsequentAdded(GetTraceId(), Subsequent.GetTraceId())"
  },
  {
    "label": "SetPipe()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetPipe(FPipe& InPipe)"
  },
  {
    "label": "GetPipe()",
    "kind": "Method",
    "detail": "Function (Pipe =& InPipe ; } FPipe*)",
    "insertText": "GetPipe()"
  },
  {
    "label": "Launched()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Launched(GetTraceId(), LowLevelTask.GetDebugName(), true, TranslatePriority(LowLevelTask.GetPriority(), ExtendedPriority), TaskSize)"
  },
  {
    "label": "TryUnlock()",
    "kind": "Method",
    "detail": "Function (bool bWakeUpWorker = true ; return)",
    "insertText": "TryUnlock(bWakeUpWorker)"
  },
  {
    "label": "IsCompleted()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsCompleted()"
  },
  {
    "label": "TryRetractAndExecute()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "TryRetractAndExecute(FTimeout Timeout, uint32 RecursionDepth = 0)"
  },
  {
    "label": "ReleaseInternalReference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseInternalReference()"
  },
  {
    "label": "AddNested()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddNested(FTaskBase& Nested)"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FTaskBase::AddNested)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (Prerequisites .)",
    "insertText": "Push(&Nested)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "Wait(FTimeout Timeout)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Wait()"
  },
  {
    "label": "WaitWithNamedThreadsSupport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitWithNamedThreadsSupport()"
  },
  {
    "label": "WaitingScope()",
    "kind": "Method",
    "detail": "Function (TaskTrace::FWaitingScope)",
    "insertText": "WaitingScope(GetTraceId())"
  },
  {
    "label": "TRACE_CPUPROFILER_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_CPUPROFILER_EVENT_SCOPE(Tasks::BusyWait)"
  },
  {
    "label": "TryRetractAndExecute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TryRetractAndExecute(FTimeout::Never())"
  },
  {
    "label": "BusyWaitUntil()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BusyWaitUntil([this, Condition = Forward<ConditionType>(Condition)]{ return IsCompleted() || Condition(); })"
  },
  {
    "label": "GetTraceId()",
    "kind": "Method",
    "detail": "Function (} TaskTrace::FId)",
    "insertText": "GetTraceId()"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (# if UE_TASK_TRACE_ENABLED return TraceId .)",
    "insertText": "load(std::memory_order_relaxed)"
  },
  {
    "label": "TryExecuteTask()",
    "kind": "Method",
    "detail": "Function (# else return TaskTrace::InvalidId ; # endif } protected : bool)",
    "insertText": "TryExecuteTask()"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FTaskBase::TryExecuteTask)"
  },
  {
    "label": "ReleasePrerequisites()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleasePrerequisites()"
  },
  {
    "label": "ExchangeCurrentTask()",
    "kind": "Method",
    "detail": "Function (FTaskBase* PrevTask =)",
    "insertText": "ExchangeCurrentTask(this)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (ExecutingThreadId .)",
    "insertText": "store(FPlatformTLS::GetCurrentThreadId(), std::memory_order_relaxed)"
  },
  {
    "label": "StartPipeExecution()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartPipeExecution()"
  },
  {
    "label": "RestoreInheritedContext()",
    "kind": "Method",
    "detail": "Function (} { UE::FInheritedContextScope InheritedContextScope =)",
    "insertText": "RestoreInheritedContext()"
  },
  {
    "label": "TaskEventScope()",
    "kind": "Method",
    "detail": "Function (TaskTrace::FTaskTimingEventScope)",
    "insertText": "TaskEventScope(GetTraceId())"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FTaskBase::ExecuteTask)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(GetPipe() != nullptr)"
  },
  {
    "label": "FinishPipeExecution()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FinishPipeExecution()"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (} ExecutingThreadId .)",
    "insertText": "store(FThread::InvalidThreadId, std::memory_order_relaxed)"
  },
  {
    "label": "ExchangeCurrentTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExchangeCurrentTask(PrevTask)"
  },
  {
    "label": "Close()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Close()"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FTaskBase::Close)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bWakeUpWorker = ExtendedPriority = = EExtendedTaskPriority::TaskEvent ;)",
    "insertText": "for(FTaskBase* Subsequent : Subsequents.Close())"
  },
  {
    "label": "ClearPipe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearPipe()"
  },
  {
    "label": "Completed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Completed(GetTraceId())"
  },
  {
    "label": "Notify()",
    "kind": "Method",
    "detail": "Function (StateChangeEvent .)",
    "insertText": "Notify()"
  },
  {
    "label": "TryUnlock()",
    "kind": "Method",
    "detail": "Function (private : bool)",
    "insertText": "TryUnlock(bool& bWakeUpWorker)"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FTaskBase::TryUnlock)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32 LocalNumLocks = PrevNumLocks - 1 ;)",
    "insertText": "if(PrevNumLocks < ExecutionFlag)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bPrerequisitesCompleted = LocalPipe = = nullptr ? LocalNumLocks = = 0 : LocalNumLocks<= 1 ;)",
    "insertText": "if(!bPrerequisitesCompleted)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bFirstPipingAttempt = LocalNumLocks = = 1 ;)",
    "insertText": "if(bFirstPipingAttempt)"
  },
  {
    "label": "TryPushIntoPipe()",
    "kind": "Method",
    "detail": "Function (FTaskBase* PrevPipedTask =)",
    "insertText": "TryPushIntoPipe()"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (Prerequisites .)",
    "insertText": "Push(PrevPipedTask)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(ExtendedPriority == EExtendedTaskPriority::Inline)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ExtendedPriority == EExtendedTaskPriority::TaskEvent)"
  },
  {
    "label": "Schedule()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "Schedule(bWakeUpWorker)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (} return true ; })",
    "insertText": "checkf(PrevNumLocks != ExecutionFlag, TEXT(\"The task is not locked\"))"
  },
  {
    "label": "TrySetExecutionFlag()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TrySetExecutionFlag()"
  },
  {
    "label": "compare_exchange_strong()",
    "kind": "Method",
    "detail": "Function (uint32 ExpectedUnlocked = 0 ; return NumLocks .)",
    "insertText": "compare_exchange_strong(ExpectedUnlocked, ExecutionFlag + 1, std::memory_order_acq_rel, std::memory_order_relaxed)"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FTaskBase::ReleasePrerequisites)"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FTaskBase::ReleasePrerequisite)"
  },
  {
    "label": "WaitImpl()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WaitImpl(FTimeout Timeout)"
  },
  {
    "label": "GenerateTaskId()",
    "kind": "Method",
    "detail": "Function (private : uint32 NumInitialLocks = 1 ; std::atomic<uint32> NumLocks { NumInitialLocks } ; FPipe* Pipe { nullptr } ; FEventCount StateChangeEvent ; EExtendedTaskPriority ExtendedPriority ; std::atomic<uint32> ExecutingThreadId = FThread::InvalidThreadId ; # if UE_TASK_TRACE_ENABLED std::atomic<TaskTrace::FId> TraceId {)",
    "insertText": "GenerateTaskId()"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (# endif template<AllocatorType = FDefaultAllocator> class FPrerequisites { public : void)",
    "insertText": "Push(FTaskBase* Prerequisite)"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FPrerequisites::Push)"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (UE::TUniqueLock)",
    "insertText": "Lock(Mutex)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (Prerequisites .)",
    "insertText": "Emplace(Prerequisite)"
  },
  {
    "label": "PushNoLock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PushNoLock(FTaskBase* Prerequisite)"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FPrerequisites::PushNoLock)"
  },
  {
    "label": "PopAll()",
    "kind": "Method",
    "detail": "Function (} TArray<FTaskBase*,AllocatorType>)",
    "insertText": "PopAll()"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FPrerequisites::PopAll)"
  },
  {
    "label": "PushIfNotClosed()",
    "kind": "Method",
    "detail": "Function (} private : TArray<FTaskBase*,AllocatorType> Prerequisites ; UE::FMutex Mutex { UE::AcquireLock } ; } ; FPrerequisites<TInlineAllocator<1>> Prerequisites ; LowLevelTasks::FTask LowLevelTask ; template<AllocatorType = FDefaultAllocator> class FSubsequents { public : bool)",
    "insertText": "PushIfNotClosed(FTaskBase* NewItem)"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FSubsequents::PushIfNotClosed)"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(FSubsequents::Close)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (bIsClosed = true ; return)",
    "insertText": "MoveTemp(Subsequents)"
  },
  {
    "label": "IsClosed()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsClosed()"
  },
  {
    "label": "TTaskWithResult()",
    "kind": "Method",
    "detail": "Function (} } ; template<ResultType> class TTaskWithResult : public FTaskBase { protected :)",
    "insertText": "TTaskWithResult(const TCHAR* InDebugName, ETaskPriority InPriority, EExtendedTaskPriority InExtendedPriority, uint32 InitRefCount, ETaskFlags Flags) : FTaskBase(InitRefCount)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(InDebugName, InPriority, InExtendedPriority, Flags)"
  },
  {
    "label": "TTaskWithResult()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TTaskWithResult()"
  },
  {
    "label": "DestructItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItem(ResultStorage.GetTypedPtr())"
  },
  {
    "label": "GetResult()",
    "kind": "Method",
    "detail": "Function (} public : ResultType&)",
    "insertText": "GetResult()"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (} protected : TTypeCompatibleBytes<ResultType> ResultStorage ; } ; template<TaskBodyType,ResultType = TInvokeResult_T<TaskBodyType>,Enable = void> class TExecutableTaskBase : public TTaskWithResult<ResultType> {)",
    "insertText": "UE_NONCOPYABLE(TExecutableTaskBase)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&this->ResultStorage)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Invoke(*TaskBodyStorage.GetTypedPtr())"
  },
  {
    "label": "DestructItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItem(TaskBodyStorage.GetTypedPtr())"
  },
  {
    "label": "TExecutableTaskBase()",
    "kind": "Method",
    "detail": "Function (} protected :)",
    "insertText": "TExecutableTaskBase(const TCHAR* InDebugName, TaskBodyType&& TaskBody, ETaskPriority InPriority, EExtendedTaskPriority InExtendedPriority, ETaskFlags Flags) : TTaskWithResult<ResultType>(InDebugName, InPriority, InExtendedPriority, 2, Flags)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&TaskBodyStorage) TaskBodyType(MoveTemp(TaskBody))"
  },
  {
    "label": "TExecutableTaskBase()",
    "kind": "Method",
    "detail": "Function (} protected :)",
    "insertText": "TExecutableTaskBase(const TCHAR* InDebugName, TaskBodyType&& TaskBody, ETaskPriority InPriority, EExtendedTaskPriority InExtendedPriority, ETaskFlags Flags) : FTaskBase(2)"
  },
  {
    "label": "TExecutableTask()",
    "kind": "Method",
    "detail": "Function (} private : TTypeCompatibleBytes<TaskBodyType> TaskBodyStorage ; } ; int32 SmallTaskSize = 2 5 6 ; int32 LargeTaskAlignment = 1 6 ; using FExecutableTaskAllocator = TLockFreeFixedSizeAllocator_TLSCache<SmallTaskSize,PLATFORM_CACHE_LINE_SIZE> ; FExecutableTaskAllocator SmallTaskAllocator ; template<TaskBodyType> class TExecutableTask final : public TExecutableTaskBase<TaskBodyType> { public :)",
    "insertText": "TExecutableTask(const TCHAR* InDebugName, TaskBodyType&& TaskBody, ETaskPriority InPriority, EExtendedTaskPriority InExtendedPriority, ETaskFlags Flags) : TExecutableTaskBase<TaskBodyType>(InDebugName, MoveTemp(TaskBody), InPriority, InExtendedPriority, Flags)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (} TExecutableTask*)",
    "insertText": "Create(const TCHAR* InDebugName, TaskBodyType&& TaskBody, ETaskPriority InPriority, EExtendedTaskPriority InExtendedPriority, ETaskFlags Flags)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} void* operator)",
    "insertText": "new(size_t Size)"
  },
  {
    "label": "TASKGRAPH_VERBOSE_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "TASKGRAPH_VERBOSE_EVENT_SCOPE(TExecutableTask::LargeAlloc)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (} } void operator)",
    "insertText": "delete(void* Ptr, size_t Size)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (Size<= SmallTaskSize ? SmallTaskAllocator .)",
    "insertText": "Free(Ptr) : GMalloc->Free(Ptr)"
  },
  {
    "label": "TryWaitOnNamedThread()",
    "kind": "Method",
    "detail": "Function (} } ; bool)",
    "insertText": "TryWaitOnNamedThread(FTaskBase& Task)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (class FTaskEventBase : public FTaskBase { public : FTaskEventBase*)",
    "insertText": "Create(const TCHAR* DebugName)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (void operator)",
    "insertText": "delete(void* Ptr)"
  },
  {
    "label": "FTaskEventBase()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "FTaskEventBase(const TCHAR* InDebugName) : FTaskBase( 1)"
  },
  {
    "label": "Created()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Created(GetTraceId(), sizeof(*this))"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(InDebugName, ETaskPriority::Normal, EExtendedTaskPriority::TaskEvent, ETaskFlags::None)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} } ; using FTaskEventBaseAllocator = TLockFreeFixedSizeAllocator_TLSCache<)",
    "insertText": "sizeof(FTaskEventBase)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (TaskEventBaseAllocator .)",
    "insertText": "Free(Ptr)"
  },
  {
    "label": "TryRetractAndExecute()",
    "kind": "Method",
    "detail": "Function (} template<TaskCollectionType> bool)",
    "insertText": "TryRetractAndExecute(const TaskCollectionType& Tasks, FTimeout Timeout)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bResult = true ;)",
    "insertText": "for(auto& Task : Tasks)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bResult = false ; })",
    "insertText": "if(Timeout.IsExpired())"
  }
]