[
  {
    "label": "AnalysisManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AnalysisManager"
  },
  {
    "label": "PreservedAnalyses",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PreservedAnalyses"
  },
  {
    "label": "DominatorTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DominatorTree"
  },
  {
    "label": "LoopInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopInfo"
  },
  {
    "label": "Loop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Loop"
  },
  {
    "label": "MDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MDNode"
  },
  {
    "label": "PHINode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PHINode"
  },
  {
    "label": "raw_ostream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "raw_ostream"
  },
  {
    "label": "N",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "N"
  },
  {
    "label": "DominatorTreeBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DominatorTreeBase"
  },
  {
    "label": "M",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "M"
  },
  {
    "label": "LoopInfoBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopInfoBase"
  },
  {
    "label": "LoopBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopBase"
  },
  {
    "label": "BlockT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BlockT"
  },
  {
    "label": "LoopT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopT"
  },
  {
    "label": "InstT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InstT"
  },
  {
    "label": "GraphTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GraphTraits"
  },
  {
    "label": "LoopAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopAnalysis"
  },
  {
    "label": "LoopPrinterPass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopPrinterPass"
  },
  {
    "label": "LoopInfoWrapperPass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopInfoWrapperPass"
  },
  {
    "label": "LoopBase()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ANALYSIS_LOOPINFO_H # define LLVM_ANALYSIS_LOOPINFO_H # include \" llvm / ADT / DenseMap . h \" # include \" llvm / ADT / DenseSet . h \" # include \" llvm / ADT / GraphTraits . h \" # include \" llvm / ADT / SmallPtrSet . h \" # include \" llvm / ADT / SmallVector . h \" # include \" llvm / IR / CFG . h \" # include \" llvm / IR / Instruction . h \" # include \" llvm / Pass . h \" # include<algorithm> namespace llvm { template<IRUnitT> class AnalysisManager ; class PreservedAnalyses ; class DominatorTree ; class LoopInfo ; class Loop ; class MDNode ; class PHINode ; class raw_ostream ; template<class N> class DominatorTreeBase ; template<class N,class M> class LoopInfoBase ; template<class N,class M> class LoopBase ; template<class BlockT,class LoopT> class LoopBase { LoopT* ParentLoop ; std::vector<LoopT*> SubLoops ; std::vector<BlockT*> Blocks ; SmallPtrSet<const BlockT*,8> DenseBlockSet ;)",
    "insertText": "LoopBase(const LoopBase<BlockT, LoopT> &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (const LoopBase<BlockT,LoopT>&)",
    "insertText": "operator(const LoopBase<BlockT, LoopT> &)"
  },
  {
    "label": "LoopBase()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "LoopBase() : ParentLoop(nullptr)"
  },
  {
    "label": "LoopBase()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "LoopBase()"
  },
  {
    "label": "getLoopDepth()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getLoopDepth()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (unsigned D = 1 ;)",
    "insertText": "for(const LoopT *CurLoop = ParentLoop; CurLoop; CurLoop = CurLoop->ParentLoop)"
  },
  {
    "label": "getParentLoop()",
    "kind": "Method",
    "detail": "Function (} LoopT*)",
    "insertText": "getParentLoop()"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (ParentLoop = L ; } bool)",
    "insertText": "contains(const LoopT *L)"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# pragma)",
    "insertText": "warning(push) #pragma warning(suppress: 6011) return contains(L->getParentLoop())"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# pragma)",
    "insertText": "warning(pop) } bool contains(const BlockT *BB)"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (} template<class InstT> bool)",
    "insertText": "contains(const InstT *Inst)"
  },
  {
    "label": "getSubLoops()",
    "kind": "Method",
    "detail": "Function (} const std::vector<LoopT*>&)",
    "insertText": "getSubLoops()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rbegin()"
  },
  {
    "label": "rend()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rend()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "getBlocks()",
    "kind": "Method",
    "detail": "Function (} const std::vector<BlockT*>&)",
    "insertText": "getBlocks()"
  },
  {
    "label": "block_end()",
    "kind": "Method",
    "detail": "Function (} block_iterator)",
    "insertText": "block_end()"
  },
  {
    "label": "getNumBlocks()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getNumBlocks()"
  },
  {
    "label": "isLoopExiting()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isLoopExiting(const BlockT *BB)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (typedef GraphTraits<const BlockT*> BlockTraits ;)",
    "insertText": "for(typename BlockTraits::ChildIteratorType SI = BlockTraits::child_begin(BB), SE = BlockTraits::child_end(BB); SI != SE; ++SI)"
  },
  {
    "label": "getNumBackEdges()",
    "kind": "Method",
    "detail": "Function (} return false ; } unsigned)",
    "insertText": "getNumBackEdges()"
  },
  {
    "label": "getHeader()",
    "kind": "Method",
    "detail": "Function (unsigned NumBackEdges = 0 ; BlockT* H =)",
    "insertText": "getHeader()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (typedef GraphTraits<Inverse<BlockT*>> InvBlockTraits ;)",
    "insertText": "for(typename InvBlockTraits::ChildIteratorType I = InvBlockTraits::child_begin(H), E = InvBlockTraits::child_end(H); I != E; ++I) if (contains(*I))"
  },
  {
    "label": "getExitingBlock()",
    "kind": "Method",
    "detail": "Function (BlockT*)",
    "insertText": "getExitingBlock()"
  },
  {
    "label": "getExitBlocks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getExitBlocks(SmallVectorImpl<BlockT*> &ExitBlocks)"
  },
  {
    "label": "getExitBlock()",
    "kind": "Method",
    "detail": "Function (BlockT*)",
    "insertText": "getExitBlock()"
  },
  {
    "label": "getExitEdges()",
    "kind": "Method",
    "detail": "Function (typedef std::pair<const BlockT*,const BlockT*> Edge ; void)",
    "insertText": "getExitEdges(SmallVectorImpl<Edge> &ExitEdges)"
  },
  {
    "label": "getLoopPreheader()",
    "kind": "Method",
    "detail": "Function (BlockT*)",
    "insertText": "getLoopPreheader()"
  },
  {
    "label": "getLoopPredecessor()",
    "kind": "Method",
    "detail": "Function (BlockT*)",
    "insertText": "getLoopPredecessor()"
  },
  {
    "label": "getLoopLatch()",
    "kind": "Method",
    "detail": "Function (BlockT*)",
    "insertText": "getLoopLatch()"
  },
  {
    "label": "getLoopLatches()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getLoopLatches(SmallVectorImpl<BlockT *> &LoopLatches)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (typedef GraphTraits<Inverse<BlockT*>> InvBlockTraits ;)",
    "insertText": "for(typename InvBlockTraits::ChildIteratorType I = InvBlockTraits::child_begin(H), E = InvBlockTraits::child_end(H); I != E; ++I) if (contains(*I)) LoopLatches.push_back(*I)"
  },
  {
    "label": "addBasicBlockToLoop()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addBasicBlockToLoop(BlockT *NewBB, LoopInfoBase<BlockT, LoopT> &LI)"
  },
  {
    "label": "replaceChildLoopWith()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replaceChildLoopWith(LoopT *OldChild, LoopT *NewChild)"
  },
  {
    "label": "addChildLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addChildLoop(LoopT *NewChild)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!NewChild->ParentLoop && \"NewChild already has a parent!\")"
  },
  {
    "label": "LoopT()",
    "kind": "Method",
    "detail": "Function (NewChild -> ParentLoop = static_cast<)",
    "insertText": "LoopT(this)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (SubLoops .)",
    "insertText": "push_back(NewChild)"
  },
  {
    "label": "removeChildLoop()",
    "kind": "Method",
    "detail": "Function (} LoopT*)",
    "insertText": "removeChildLoop(iterator I)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(I != SubLoops.end() && \"Cannot remove end iterator!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (LoopT* Child =* I ;)",
    "insertText": "assert(Child->ParentLoop == this && \"Child is not a child of this loop!\")"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (SubLoops .)",
    "insertText": "erase(SubLoops.begin()+(I-begin()))"
  },
  {
    "label": "addBlockEntry()",
    "kind": "Method",
    "detail": "Function (Child -> ParentLoop = nullptr ; return Child ; } void)",
    "insertText": "addBlockEntry(BlockT *BB)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Blocks .)",
    "insertText": "push_back(BB)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (DenseBlockSet .)",
    "insertText": "insert(BB)"
  },
  {
    "label": "reverseBlock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reverseBlock(unsigned from)"
  },
  {
    "label": "reverse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reverse(Blocks.begin() + from, Blocks.end())"
  },
  {
    "label": "reserveBlocks()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reserveBlocks(unsigned size)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (Blocks .)",
    "insertText": "reserve(size)"
  },
  {
    "label": "moveToHeader()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "moveToHeader(BlockT *BB)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i != Blocks.size() && \"Loop does not contain BB!\")"
  },
  {
    "label": "removeBlockFromLoop()",
    "kind": "Method",
    "detail": "Function (Blocks [ i ] = Blocks [ 0 ] ; Blocks [ 0 ] = BB ; return ; } } } void)",
    "insertText": "removeBlockFromLoop(BlockT *BB)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (auto I =)",
    "insertText": "find(Blocks.begin(), Blocks.end(), BB)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(I != Blocks.end() && \"N is not in this list!\")"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (Blocks .)",
    "insertText": "erase(I)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (DenseBlockSet .)",
    "insertText": "erase(BB)"
  },
  {
    "label": "verifyLoop()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "verifyLoop()"
  },
  {
    "label": "verifyLoopNest()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "verifyLoopNest(DenseSet<const LoopT*> *Loops)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS, unsigned Depth = 0)"
  },
  {
    "label": "LoopBase()",
    "kind": "Method",
    "detail": "Function (protected : class LoopInfoBase<BlockT,LoopT> ;)",
    "insertText": "LoopBase(BlockT *BB) : ParentLoop(nullptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<class BlockT,class LoopT> raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const LoopBase<BlockT, LoopT> &Loop)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (Loop .)",
    "insertText": "print(OS)"
  },
  {
    "label": "isLoopInvariant()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isLoopInvariant(const Value *V)"
  },
  {
    "label": "hasLoopInvariantOperands()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasLoopInvariantOperands(const Instruction *I)"
  },
  {
    "label": "makeLoopInvariant()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "makeLoopInvariant(Value *V, bool &Changed, Instruction *InsertPt = nullptr)"
  },
  {
    "label": "makeLoopInvariant()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "makeLoopInvariant(Instruction *I, bool &Changed, Instruction *InsertPt = nullptr)"
  },
  {
    "label": "getCanonicalInductionVariable()",
    "kind": "Method",
    "detail": "Function (PHINode*)",
    "insertText": "getCanonicalInductionVariable()"
  },
  {
    "label": "isLCSSAForm()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLCSSAForm(DominatorTree &DT)"
  },
  {
    "label": "isLoopSimplifyForm()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLoopSimplifyForm()"
  },
  {
    "label": "isSafeToClone()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isSafeToClone()"
  },
  {
    "label": "isAnnotatedParallel()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isAnnotatedParallel()"
  },
  {
    "label": "getLoopID()",
    "kind": "Method",
    "detail": "Function (MDNode*)",
    "insertText": "getLoopID()"
  },
  {
    "label": "setLoopID()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setLoopID(MDNode *LoopID)"
  },
  {
    "label": "hasDedicatedExits()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasDedicatedExits()"
  },
  {
    "label": "getUniqueExitBlocks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getUniqueExitBlocks(SmallVectorImpl<BasicBlock *> &ExitBlocks)"
  },
  {
    "label": "getUniqueExitBlock()",
    "kind": "Method",
    "detail": "Function (BasicBlock*)",
    "insertText": "getUniqueExitBlock()"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dump()"
  },
  {
    "label": "getStartLoc()",
    "kind": "Method",
    "detail": "Function (DebugLoc)",
    "insertText": "getStartLoc()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BasicBlock* HeadBB ;)",
    "insertText": "if((HeadBB = getLoopPreheader()) != nullptr) if (DebugLoc DL = HeadBB->getTerminator()->getDebugLoc())"
  },
  {
    "label": "Loop()",
    "kind": "Method",
    "detail": "Function (} private : class LoopInfoBase<BasicBlock,Loop> ;)",
    "insertText": "Loop(BasicBlock *BB) : LoopBase<BasicBlock, Loop>(BB)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<class BlockT,class LoopT> class LoopInfoBase { DenseMap<const BlockT*,LoopT*> BBMap ; std::vector<LoopT*> TopLevelLoops ; class LoopBase<BlockT,LoopT> ; class LoopInfo ; void)",
    "insertText": "operator(const LoopInfoBase &)"
  },
  {
    "label": "LoopInfoBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LoopInfoBase(const LoopInfoBase &)"
  },
  {
    "label": "LoopInfoBase()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "LoopInfoBase()"
  },
  {
    "label": "releaseMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releaseMemory()"
  },
  {
    "label": "LoopInfoBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "LoopInfoBase(LoopInfoBase &&Arg) : BBMap(std::move(Arg.BBMap)), TopLevelLoops(std::move(Arg.TopLevelLoops))"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (Arg . TopLevelLoops .)",
    "insertText": "clear()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} LoopInfoBase&)",
    "insertText": "operator(LoopInfoBase &&RHS)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (BBMap =)",
    "insertText": "move(RHS.BBMap)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (TopLevelLoops =)",
    "insertText": "move(RHS.TopLevelLoops)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} typedef std::vector<LoopT*>::const_iterator iterator ; typedef std::vector<LoopT*>::const_reverse_iterator reverse_iterator ; iterator)",
    "insertText": "begin()"
  },
  {
    "label": "getLoopFor()",
    "kind": "Method",
    "detail": "Function (} LoopT*)",
    "insertText": "getLoopFor(const BlockT *BB)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const LoopT*)",
    "insertText": "operator(const BlockT *BB)"
  },
  {
    "label": "getLoopDepth()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getLoopDepth(const BlockT *BB)"
  },
  {
    "label": "getLoopFor()",
    "kind": "Method",
    "detail": "Function (const LoopT* L =)",
    "insertText": "getLoopFor(BB)"
  },
  {
    "label": "isLoopHeader()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isLoopHeader(const BlockT *BB)"
  },
  {
    "label": "removeLoop()",
    "kind": "Method",
    "detail": "Function (} LoopT*)",
    "insertText": "removeLoop(iterator I)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(I != end() && \"Cannot remove end iterator!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (LoopT* L =* I ;)",
    "insertText": "assert(!L->getParentLoop() && \"Not a top-level loop!\")"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (TopLevelLoops .)",
    "insertText": "erase(TopLevelLoops.begin() + (I-begin()))"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (auto I =)",
    "insertText": "find(TopLevelLoops.begin(), TopLevelLoops.end(), OldLoop)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(I != TopLevelLoops.end() && \"Old loop not at top level!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (* I = NewLoop ;)",
    "insertText": "assert(!NewLoop->ParentLoop && !OldLoop->ParentLoop && \"Loops already embedded into a subloop!\")"
  },
  {
    "label": "addTopLevelLoop()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addTopLevelLoop(LoopT *New)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!New->getParentLoop() && \"Loop already in subloop!\")"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (TopLevelLoops .)",
    "insertText": "push_back(New)"
  },
  {
    "label": "removeBlock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "removeBlock(BlockT *BB)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (auto I = BBMap .)",
    "insertText": "find(BB)"
  },
  {
    "label": "isNotAlreadyContainedIn()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "isNotAlreadyContainedIn(const LoopT *SubLoop, const LoopT *ParentLoop)"
  },
  {
    "label": "Analyze()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Analyze(DominatorTreeBase<BlockT> &DomTree)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS)"
  },
  {
    "label": "verify()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "verify()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template class LoopInfoBase<BasicBlock,Loop> ; class LoopInfo : public LoopInfoBase<BasicBlock,Loop> { typedef LoopInfoBase<BasicBlock,Loop> BaseT ; class LoopBase<BasicBlock,Loop> ; void)",
    "insertText": "operator(const LoopInfo &)"
  },
  {
    "label": "LoopInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LoopInfo(const LoopInfo &)"
  },
  {
    "label": "LoopInfo()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "LoopInfo()"
  },
  {
    "label": "LoopInfo()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "LoopInfo(LoopInfo &&Arg) : BaseT(std::move(static_cast<BaseT &>(Arg)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} LoopInfo&)",
    "insertText": "operator(LoopInfo &&RHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(std::move(static_cast<BaseT &>(RHS)))"
  },
  {
    "label": "replacementPreservesLCSSAForm()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "replacementPreservesLCSSAForm(Instruction *From, Value *To)"
  },
  {
    "label": "Instruction()",
    "kind": "Method",
    "detail": "Function (Instruction* I = dyn_cast<)",
    "insertText": "Instruction(To)"
  },
  {
    "label": "getLoopFor()",
    "kind": "Method",
    "detail": "Function (Loop* ToLoop =)",
    "insertText": "getLoopFor(I->getParent())"
  },
  {
    "label": "getEntryNode()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct GraphTraits<const Loop*> { typedef const Loop NodeType ; typedef LoopInfo::iterator ChildIteratorType ; NodeType*)",
    "insertText": "getEntryNode(const Loop *L)"
  },
  {
    "label": "child_end()",
    "kind": "Method",
    "detail": "Function (} ChildIteratorType)",
    "insertText": "child_end(NodeType *N)"
  },
  {
    "label": "getEntryNode()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct GraphTraits<Loop*> { typedef Loop NodeType ; typedef LoopInfo::iterator ChildIteratorType ; NodeType*)",
    "insertText": "getEntryNode(Loop *L)"
  },
  {
    "label": "ID()",
    "kind": "Method",
    "detail": "Function (} } ; class LoopAnalysis { char PassID ; public : typedef LoopInfo Result ; void*)",
    "insertText": "ID()"
  },
  {
    "label": "name()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "name()"
  },
  {
    "label": "LoopPrinterPass()",
    "kind": "Method",
    "detail": "Function (} ; class LoopPrinterPass { raw_ostream& OS ; public :)",
    "insertText": "LoopPrinterPass(raw_ostream &OS) : OS(OS)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} PreservedAnalyses)",
    "insertText": "run(Function &F, AnalysisManager<Function> *AM)"
  },
  {
    "label": "initializeLoopInfoWrapperPassPass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initializeLoopInfoWrapperPassPass(*PassRegistry::getPassRegistry())"
  },
  {
    "label": "getLoopInfo()",
    "kind": "Method",
    "detail": "Function (} LoopInfo&)",
    "insertText": "getLoopInfo()"
  },
  {
    "label": "verifyAnalysis()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "verifyAnalysis()"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "print(raw_ostream &O, const Module *M = nullptr)"
  },
  {
    "label": "getAnalysisUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getAnalysisUsage(AnalysisUsage &AU)"
  }
]