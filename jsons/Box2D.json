[
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "TBox2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TBox2"
  },
  {
    "label": "TIsUECoreVariant",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsUECoreVariant"
  },
  {
    "label": "TBox2()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / UnrealString . h \" # include \" CoreTypes . h \" # include \" Math / UnrealMathUtility . h \" # include \" Math / Vector2D . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / LargeWorldCoordinates . h \" # include \" Misc / LargeWorldCoordinatesSerializer . h \" # include \" Serialization / Archive . h \" # include \" Templates / IsUECoreType . h \" # include \" Templates / UnrealTypeTraits . h \" # include \" UObject / NameTypes . h \" # include \" UObject / UnrealNames . h \" template<T> struct TIsPODType ; namespace UE { namespace Math { template<T> struct TBox2 { public : using FReal = T ; TVector2<T> Min ; TVector2<T> Max ; bool bIsValid ; public :)",
    "insertText": "TBox2()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TBox2<)",
    "insertText": "T(EForceInit)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} TBox2<)",
    "insertText": "T(const TVector2<T>& InMin, const TVector2<T>& InMax ) : Min(InMin) , Max(InMax) , bIsValid(true)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} TBox2<)",
    "insertText": "T(const TVector2<T>* Points, const int32 Count)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TBox2<)",
    "insertText": "T(const TArray<TVector2<T>>& Points)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "operator(const TBox2<T>& Other)"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Equals(const TBox2<T>& Other, T Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TBox2<T>&)",
    "insertText": "operator(const TVector2<T> &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TBox2<T>)",
    "insertText": "operator(const TVector2<T>& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TVector2<T>&)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T DistSquared = 0 . f ;)",
    "insertText": "if(Point.X < Min.X)"
  },
  {
    "label": "Square()",
    "kind": "Method",
    "detail": "Function (DistSquared + =)",
    "insertText": "Square(Point.X - Min.X)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Point.X > Max.X)"
  },
  {
    "label": "Square()",
    "kind": "Method",
    "detail": "Function (DistSquared + =)",
    "insertText": "Square(Point.X - Max.X)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Point.Y < Min.Y)"
  },
  {
    "label": "Square()",
    "kind": "Method",
    "detail": "Function (DistSquared + =)",
    "insertText": "Square(Point.Y - Min.Y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Point.Y > Max.Y)"
  },
  {
    "label": "Square()",
    "kind": "Method",
    "detail": "Function (DistSquared + =)",
    "insertText": "Square(Point.Y - Max.Y)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(T)"
  },
  {
    "label": "ExpandBy()",
    "kind": "Method",
    "detail": "Function (} TBox2<T>)",
    "insertText": "ExpandBy(const T W)"
  },
  {
    "label": "ExpandBy()",
    "kind": "Method",
    "detail": "Function (} TBox2<T>)",
    "insertText": "ExpandBy(const TVector2<T>& V)"
  },
  {
    "label": "GetArea()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetArea()"
  },
  {
    "label": "GetCenter()",
    "kind": "Method",
    "detail": "Function (} TVector2<T>)",
    "insertText": "GetCenter()"
  },
  {
    "label": "GetCenterAndExtents()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetCenterAndExtents(TVector2<T> & center, TVector2<T> & Extents)"
  },
  {
    "label": "GetExtent()",
    "kind": "Method",
    "detail": "Function (Extents =)",
    "insertText": "GetExtent()"
  },
  {
    "label": "GetClosestPointTo()",
    "kind": "Method",
    "detail": "Function (center = Min + Extents ; } TVector2<T>)",
    "insertText": "GetClosestPointTo(const TVector2<T>& Point)"
  },
  {
    "label": "GetSize()",
    "kind": "Method",
    "detail": "Function (} TVector2<T>)",
    "insertText": "GetSize()"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (Min = Max = TVector2<T>::ZeroVector ; bIsValid = false ; } TBox2<T>)",
    "insertText": "Overlap(const TBox2<T>& Other)"
  },
  {
    "label": "IsInside()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsInside(const TVector2<T> & TestPoint)"
  },
  {
    "label": "IsInsideOrOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsInsideOrOn(const TVector2<T>& TestPoint)"
  },
  {
    "label": "IsInside()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsInside(const TBox2<T>& Other)"
  },
  {
    "label": "ShiftBy()",
    "kind": "Method",
    "detail": "Function (} TBox2<T>)",
    "insertText": "ShiftBy(const TVector2<T>& Offset)"
  },
  {
    "label": "MoveTo()",
    "kind": "Method",
    "detail": "Function (} TBox2<T>)",
    "insertText": "MoveTo(const TVector2<T>& Destination)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ToString()"
  },
  {
    "label": "BuildAABB()",
    "kind": "Method",
    "detail": "Function (TBox2<T>)",
    "insertText": "BuildAABB(const TVector2<T>& Origin, const TVector2<T>& Extent)"
  },
  {
    "label": "NewBox()",
    "kind": "Method",
    "detail": "Function (TBox2<T>)",
    "insertText": "NewBox(Origin - Extent, Origin + Extent)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar<<Min<<Max ; uint8 bValid = bIsValid ; Ar .)",
    "insertText": "Serialize(&bValid, sizeof(uint8))"
  },
  {
    "label": "SerializeFromMismatchedTag()",
    "kind": "Method",
    "detail": "Function (bIsValid = ! ! bValid ; return true ; } bool)",
    "insertText": "SerializeFromMismatchedTag(FName StructTag, FArchive& Ar)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<FArg)",
    "insertText": "UE_REQUIRES(!std::is_same_v<T, FArg>)> explicit TBox2(const TBox2<FArg>& From) : Min((TVector2<T>)From.Min) , Max((TVector2<T>)From.Max) , bIsValid(From.bIsValid)"
  },
  {
    "label": "TBox2()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> TBox2<T)",
    "insertText": "TBox2(const TVector2<T>* Points, const int32 Count) : Min(0.f, 0.f) , Max(0.f, 0.f) , bIsValid(false)"
  },
  {
    "label": "TBox2()",
    "kind": "Method",
    "detail": "Function (* this + = Points [ PointItr ] ; } } template<T> TBox2<T)",
    "insertText": "TBox2(const TArray<TVector2<T>>& Points) : Min(0.f, 0.f) , Max(0.f, 0.f) , bIsValid(false)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Min . X =)",
    "insertText": "Min(Min.X, Other.X)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Min . Y =)",
    "insertText": "Min(Min.Y, Other.Y)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Max . X =)",
    "insertText": "Max(Max.X, Other.X)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Max . Y =)",
    "insertText": "Max(Max.Y, Other.Y)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Min . X =)",
    "insertText": "Min(Min.X, Other.Min.X)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Min . Y =)",
    "insertText": "Min(Min.Y, Other.Min.Y)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Max . X =)",
    "insertText": "Max(Max.X, Other.Max.X)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Max . Y =)",
    "insertText": "Max(Max.Y, Other.Max.Y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Other.bIsValid)"
  },
  {
    "label": "EmptyBox()",
    "kind": "Method",
    "detail": "Function (TBox2<T>)",
    "insertText": "EmptyBox(ForceInit)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (MaxVector . X =)",
    "insertText": "Min(Max.X, Other.Max.X)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MinVector . Y =)",
    "insertText": "Max(Min.Y, Other.Min.Y)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (MaxVector . Y =)",
    "insertText": "Min(Max.Y, Other.Max.Y)"
  },
  {
    "label": "Intersect()",
    "kind": "Method",
    "detail": "Function (} template<T> bool TBox2<T)",
    "insertText": "Intersect(const TBox2<T> & Other)"
  },
  {
    "label": "UE_DECLARE_LWC_TYPE()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "UE_DECLARE_LWC_TYPE(Box2,, FBox2D)"
  }
]