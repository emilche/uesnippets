[
  {
    "label": "SeedBitsToBlocks()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_RANDOM_INTERNAL_SEED_MATERIAL_H_ # define ABSL_RANDOM_INTERNAL_SEED_MATERIAL_H_ # include<cassert> # include<cstdint> # include<cstdlib> # include<string> # include<vector> # include \" absl / base / attributes . h \" # include \" absl / random / internal / fast_uniform_bits . h \" # include \" absl / types / optional . h \" # include \" absl / types / span . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace random_internal { size_t)",
    "insertText": "SeedBitsToBlocks(size_t seed_size)"
  },
  {
    "label": "SeedBitsToBlocks()",
    "kind": "Method",
    "detail": "Function (} size_t kEntropyBitsNeeded = 2 5 6 ; size_t kEntropyBlocksNeeded =)",
    "insertText": "SeedBitsToBlocks(kEntropyBitsNeeded)"
  },
  {
    "label": "ReadSeedMaterialFromOSEntropy()",
    "kind": "Method",
    "detail": "Function (ABSL_MUST_USE_RESULT bool)",
    "insertText": "ReadSeedMaterialFromOSEntropy(absl::Span<uint32_t> values)"
  },
  {
    "label": "ReadSeedMaterialFromURBG()",
    "kind": "Method",
    "detail": "Function (template<URBG> ABSL_MUST_USE_RESULT bool)",
    "insertText": "ReadSeedMaterialFromURBG(URBG* urbg, absl::Span<uint32_t> values)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (random_internal::FastUniformBits<uint32_t> distr ;)",
    "insertText": "assert(urbg != nullptr && values.data() != nullptr)"
  },
  {
    "label": "distr()",
    "kind": "Method",
    "detail": "Function (seed_value =)",
    "insertText": "distr(*urbg)"
  },
  {
    "label": "MixIntoSeedMaterial()",
    "kind": "Method",
    "detail": "Function (} return true ; } void)",
    "insertText": "MixIntoSeedMaterial(absl::Span<const uint32_t> sequence, absl::Span<uint32_t> seed_material)"
  },
  {
    "label": "GetSaltMaterial()",
    "kind": "Method",
    "detail": "Function (absl::optional<uint32_t>)",
    "insertText": "GetSaltMaterial()"
  }
]