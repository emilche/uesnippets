[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "HbrVertex",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrVertex"
  },
  {
    "label": "HbrHalfedge",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrHalfedge"
  },
  {
    "label": "HbrFace",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrFace"
  },
  {
    "label": "HbrMesh",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrMesh"
  },
  {
    "label": "HbrHierarchicalEdit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrHierarchicalEdit"
  },
  {
    "label": "HbrFacePath",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HbrFacePath"
  },
  {
    "label": "HbrFaceChildren",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrFaceChildren"
  },
  {
    "label": "HbrAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrAllocator"
  },
  {
    "label": "PatchType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "PatchType"
  },
  {
    "label": "TransitionType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "TransitionType"
  },
  {
    "label": "AdaptiveFlags",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AdaptiveFlags"
  },
  {
    "label": "HbrFaceOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrFaceOperator"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENSUBDIV3_HBRFACE_H # define OPENSUBDIV3_HBRFACE_H # include<assert . h> # include<cstdio> # include<functional> # include<iostream> # include<algorithm> # include<vector> # include \" . . / hbr / fvarData . h \" # include \" . . / hbr / allocator . h \" # ifdef HBRSTITCH # include \" libgprims / stitch . h \" # include \" libgprims / stitchInternal . h \" # endif # include \" . . / version . h \" namespace OpenSubdiv { namespace OPENSUBDIV_VERSION { template<class T> class HbrVertex ; template<class T> class HbrHalfedge ; template<class T> class HbrFace ; template<class T> class HbrMesh ; template<class T> class HbrHierarchicalEdit ; template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& out, const HbrFace<T>& face)"
  },
  {
    "label": "Print()",
    "kind": "Method",
    "detail": "Function (struct HbrFacePath { void)",
    "insertText": "Print()"
  },
  {
    "label": "printf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printf(\"%d\", topface)"
  },
  {
    "label": "printf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printf(\" %d\", *i)"
  },
  {
    "label": "printf()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "printf(\"\\n\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} int topface ; std::vector<int> remainder ; bool)",
    "insertText": "operator(const HbrFacePath& x, const HbrFacePath& y)"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} else { std::vector<int>::const_reverse_iterator i = x . remainder .)",
    "insertText": "rbegin()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return true ; } } template<class T> class HbrFaceChildren { public : HbrFace<T>*&)",
    "insertText": "operator(const int index)"
  },
  {
    "label": "HbrFaceChildren()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "HbrFaceChildren()"
  },
  {
    "label": "HbrFace()",
    "kind": "Method",
    "detail": "Function (} HbrFace<T>* children [ 4 ] ; } ; template<class T> class HbrFace { private : class HbrAllocator<HbrFace<T>> ; class HbrHalfedge<T> ;)",
    "insertText": "HbrFace()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "Initialize(HbrMesh<T>* mesh, HbrFace<T>* parent, int childindex, int id, int uindex, int nvertices, HbrVertex<T>** vertices, int fvarwidth = 0, int depth = 0)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy()"
  },
  {
    "label": "GetMesh()",
    "kind": "Method",
    "detail": "Function (HbrMesh<T>*)",
    "insertText": "GetMesh()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else { return const_cast<HbrHalfedge<)",
    "insertText": "T(&edges[0])"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (} } HbrHalfedge<T>*)",
    "insertText": "GetEdge(int index)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "GetVertex(int index)"
  },
  {
    "label": "GetVertexID()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetVertexID(int index)"
  },
  {
    "label": "GetParent()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>*)",
    "insertText": "GetParent()"
  },
  {
    "label": "SetChild()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetChild(int index, HbrFace<T>* face)"
  },
  {
    "label": "GetChild()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>*)",
    "insertText": "GetChild(int index)"
  },
  {
    "label": "GetSubdivision()",
    "kind": "Method",
    "detail": "Function (int nchildren = mesh ->)",
    "insertText": "GetSubdivision()->GetFaceChildrenCount(nvertices)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (} } HbrVertex<T>*)",
    "insertText": "Subdivide()"
  },
  {
    "label": "HasChildVertex()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasChildVertex()"
  },
  {
    "label": "IsHole()",
    "kind": "Method",
    "detail": "Function (vchild = - 1 ; } bool)",
    "insertText": "IsHole()"
  },
  {
    "label": "IsCoarse()",
    "kind": "Method",
    "detail": "Function (hole = h ; } bool)",
    "insertText": "IsCoarse()"
  },
  {
    "label": "IsProtected()",
    "kind": "Method",
    "detail": "Function (coarse = 1 ; } bool)",
    "insertText": "IsProtected()"
  },
  {
    "label": "ClearProtected()",
    "kind": "Method",
    "detail": "Function (protect = 1 ; } void)",
    "insertText": "ClearProtected()"
  },
  {
    "label": "IsCollected()",
    "kind": "Method",
    "detail": "Function (protect = 0 ; } bool)",
    "insertText": "IsCollected()"
  },
  {
    "label": "ClearCollected()",
    "kind": "Method",
    "detail": "Function (collected = 1 ; } void)",
    "insertText": "ClearCollected()"
  },
  {
    "label": "Refine()",
    "kind": "Method",
    "detail": "Function (collected = 0 ; } void)",
    "insertText": "Refine()"
  },
  {
    "label": "Unrefine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unrefine()"
  },
  {
    "label": "HasLimit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasLimit()"
  },
  {
    "label": "GetMemStats()",
    "kind": "Method",
    "detail": "Function (unsigned long)",
    "insertText": "GetMemStats()"
  },
  {
    "label": "GetFVarData()",
    "kind": "Method",
    "detail": "Function (HbrFVarData<T>&)",
    "insertText": "GetFVarData(int index)"
  },
  {
    "label": "MarkUsage()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MarkUsage()"
  },
  {
    "label": "ClearUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearUsage()"
  },
  {
    "label": "GarbageCollectable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GarbageCollectable()"
  },
  {
    "label": "SetHierarchicalEdits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetHierarchicalEdits(HbrHierarchicalEdit<T>** edits)"
  },
  {
    "label": "GetHierarchicalEdits()",
    "kind": "Method",
    "detail": "Function (HbrHierarchicalEdit<T>**)",
    "insertText": "GetHierarchicalEdits()"
  },
  {
    "label": "HasVertexEdits()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasVertexEdits()"
  },
  {
    "label": "GetDepth()",
    "kind": "Method",
    "detail": "Function (hasVertexEdits = 1 ; } int)",
    "insertText": "GetDepth()"
  },
  {
    "label": "GetUniformIndex()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetUniformIndex()"
  },
  {
    "label": "GetPtexIndex()",
    "kind": "Method",
    "detail": "Function (uindex = i ; } int)",
    "insertText": "GetPtexIndex()"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (ptexindex = i ; } HbrFace<T>*&)",
    "insertText": "GetNext()"
  },
  {
    "label": "GetPath()",
    "kind": "Method",
    "detail": "Function (} HbrFacePath)",
    "insertText": "GetPath()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (HbrFacePath path ; path . remainder .)",
    "insertText": "reserve(GetDepth())"
  },
  {
    "label": "GetSubdivision()",
    "kind": "Method",
    "detail": "Function (int nchildren = mesh ->)",
    "insertText": "GetSubdivision()->GetFaceChildrenCount(p->nvertices)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (path . remainder .)",
    "insertText": "push_back(i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (break ; } } } else {)",
    "insertText": "for(int i = 0; i < nchildren; ++i)"
  },
  {
    "label": "GetID()",
    "kind": "Method",
    "detail": "Function (} path . topface = f ->)",
    "insertText": "GetID()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(GetDepth() == 0 || static_cast<int>(path.remainder.size()) == GetDepth())"
  },
  {
    "label": "GetPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPath().Print()"
  },
  {
    "label": "GetClientData()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "GetClientData()"
  },
  {
    "label": "SetClientData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetClientData(void *data)"
  },
  {
    "label": "SetFaceClientData()",
    "kind": "Method",
    "detail": "Function (mesh ->)",
    "insertText": "SetFaceClientData(id, data)"
  },
  {
    "label": "GetSupportingVertices()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetSupportingVertices(std::vector<int> &support)"
  },
  {
    "label": "AdaptiveFlags()",
    "kind": "Method",
    "detail": "Function (private : HbrMesh<T>* mesh ; int id ; int uindex ; int ptexindex ; int nvertices ; HbrHalfedge<T> edges [ 4 ] ; char* extraedges ; union { HbrFaceChildren<T>* children ; HbrFace<T>** extrachildren ; } children ; unsigned int* fvarbits ; # ifdef HBRSTITCH StitchEdge** stitchEdges ; # endif int parent ; int vchild ; int editOffset ; unsigned char depth ; unsigned short hole : 1 ; unsigned short coarse : 1 ; unsigned short protect : 1 ; unsigned short collected : 1 ; unsigned short hasVertexEdits : 1 ; unsigned short initialized : 1 ; unsigned short destroyed : 1 ; # ifdef HBR_ADAPTIVE public : enum PatchType { kUnknown = 0,kFull = 1,kEnd = 2,kGregory = 3 } ; enum TransitionType { kTransition0 = 0,kTransition1 = 1,kTransition2 = 2,kTransition3 = 3,kTransition4 = 4,kNone = 5 } ; struct AdaptiveFlags { unsigned patchType : 2 ; unsigned transitionType : 3 ; unsigned rots : 2 ; unsigned brots : 2 ; unsigned bverts : 2 ; unsigned isCritical : 1 ; unsigned isExtraordinary : 1 ; unsigned isTagged : 1 ;)",
    "insertText": "AdaptiveFlags() : patchType(0), transitionType(5), rots(0), brots(0), bverts(0), isCritical(0), isExtraordinary(0), isTagged(0)"
  },
  {
    "label": "isTransitionPatch()",
    "kind": "Method",
    "detail": "Function (} } ; AdaptiveFlags _adaptiveFlags ; bool)",
    "insertText": "isTransitionPatch()"
  },
  {
    "label": "hasTaggedVertices()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasTaggedVertices()"
  },
  {
    "label": "GetNumVertices()",
    "kind": "Method",
    "detail": "Function (int nv =)",
    "insertText": "GetNumVertices()"
  },
  {
    "label": "HbrFace()",
    "kind": "Method",
    "detail": "Function (} return false ; } # endif } ; } using namespace OPENSUBDIV_VERSION ; } # include \" . . / hbr / mesh . h \" namespace OpenSubdiv { namespace OPENSUBDIV_VERSION { template<class T> HbrFace<T)",
    "insertText": "HbrFace() : mesh(0), id(-1), uindex(-1), ptexindex(-1), nvertices(0), extraedges(0), fvarbits(0), parent(-1), vchild(-1), #ifdef HBRSTITCH stitchEdges(0), #endif editOffset(-1), depth(0), hole(0), coarse(0), protect(0), collected(0), hasVertexEdits(0), initialized(0), destroyed(0)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (children . children = 0 ; } template<class T> void HbrFace<T)",
    "insertText": "Initialize(HbrMesh<T>* m, HbrFace<T>* _parent, int childindex, int fid, int _uindex, int nv, HbrVertex<T>** vertices, int , int _depth)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (mesh = m ; id = fid ; uindex = _uindex ; ptexindex = - 1 ; nvertices = nv ; extraedges = 0 ; children . children = 0 ; vchild = - 1 ; fvarbits = 0 ; # ifdef HBRSTITCH stitchEdges = 0 ; # endif editOffset = - 1 ; depth = static_cast<unsigned)",
    "insertText": "char(_depth)"
  },
  {
    "label": "GetFVarCount()",
    "kind": "Method",
    "detail": "Function (hole = 0 ; coarse = 0 ; protect = 0 ; collected = 0 ; hasVertexEdits = 0 ; initialized = 1 ; destroyed = 0 ; int i ; const int fvarcount = mesh ->)",
    "insertText": "GetFVarCount()"
  },
  {
    "label": "fvarbitsSizePerEdge()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "fvarbitsSizePerEdge((fvarcount + 15) / 16)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef HBRSTITCH)",
    "insertText": "if(mesh->GetStitchCount())"
  },
  {
    "label": "nv()",
    "kind": "Method",
    "detail": "Function (const size_t buffersize =)",
    "insertText": "nv(mesh->GetStitchCount() * sizeof(StitchEdge*))"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "buffer(char *) malloc(buffersize)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(buffer, 0, buffersize)"
  },
  {
    "label": "stitchEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stitchEdges(StitchEdge**)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "if(fvarcount)"
  },
  {
    "label": "nv()",
    "kind": "Method",
    "detail": "Function (const size_t fvarbitsSize =)",
    "insertText": "nv(fvarbitsSizePerEdge * sizeof(unsigned int))"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "buffer(char*) malloc(fvarbitsSize)"
  },
  {
    "label": "fvarbits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fvarbits(unsigned int*)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} const size_t edgesize =)",
    "insertText": "sizeof(HbrHalfedge<T>) + sizeof(HbrFace<T>*)"
  },
  {
    "label": "extraedges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "extraedges(char *) malloc(nv * edgesize)"
  },
  {
    "label": "edge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>*)",
    "insertText": "edge(HbrHalfedge<T>*)(extraedges + i * edgesize)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(edge) HbrHalfedge<T>()"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (} } else { char*)",
    "insertText": "buffer((char *) this + sizeof(*this))"
  },
  {
    "label": "buffersize()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "buffersize(mesh->GetStitchCount() * sizeof(StitchEdge*))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(_parent)"
  },
  {
    "label": "SetChild()",
    "kind": "Method",
    "detail": "Function (_parent ->)",
    "insertText": "SetChild(childindex, this)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} int next ; unsigned int* curfvarbits = fvarbits ; HbrHalfedge<T>* edge ; size_t edgesize ;)",
    "insertText": "if(nv > 4)"
  },
  {
    "label": "edge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "edge(HbrHalfedge<T>*)(extraedges)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} else { edge = edges ; edgesize =)",
    "insertText": "sizeof(HbrHalfedge<T>)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = 0, next = 1; i < nv; ++i, ++next)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* opposite = vertices [ next ] ->)",
    "insertText": "GetEdge(vertices[i]->GetID())"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (edge ->)",
    "insertText": "Initialize(opposite, i, vertices[i], curfvarbits, this)"
  },
  {
    "label": "edge()",
    "kind": "Method",
    "detail": "Function (curfvarbits = curfvarbits + fvarbitsSizePerEdge ; })",
    "insertText": "edge(HbrHalfedge<T>*)((char *) edge + edgesize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else { edge = edges ; })",
    "insertText": "for(i = 0; i < nv; ++i)"
  },
  {
    "label": "AddIncidentEdge()",
    "kind": "Method",
    "detail": "Function (vertices [ i ] ->)",
    "insertText": "AddIncidentEdge(edge)"
  },
  {
    "label": "GetStitchCount()",
    "kind": "Method",
    "detail": "Function (int i ; # ifdef HBRSTITCH const int stitchCount = mesh ->)",
    "insertText": "GetStitchCount()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(children.children)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (children . extrachildren [ i ] -> parent = - 1 ; children . extrachildren [ i ] = 0 ; } } delete [ ] children . extrachildren ; children . extrachildren = 0 ; } else {)",
    "insertText": "for(i = 0; i < nchildren; ++i)"
  },
  {
    "label": "DeleteFaceChildren()",
    "kind": "Method",
    "detail": "Function (} } mesh ->)",
    "insertText": "DeleteFaceChildren(children.children)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (children . children = 0 ; } } HbrHalfedge<T>* edge ; size_t edgesize ;)",
    "insertText": "if(nvertices > 4)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = 0; i < nvertices; ++i)"
  },
  {
    "label": "DestroyStitchEdges()",
    "kind": "Method",
    "detail": "Function (# ifdef HBRSTITCH edge ->)",
    "insertText": "DestroyStitchEdges(stitchCount)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (# endif HbrVertex<T>* vertex = mesh ->)",
    "insertText": "GetVertex(edge->GetOrgVertexID())"
  },
  {
    "label": "GetFVarData()",
    "kind": "Method",
    "detail": "Function (HbrFVarData<T>& fvt = vertex ->)",
    "insertText": "GetFVarData(this)"
  },
  {
    "label": "SetFaceID()",
    "kind": "Method",
    "detail": "Function (fvt .)",
    "insertText": "SetFaceID(-1)"
  },
  {
    "label": "RemoveIncidentEdge()",
    "kind": "Method",
    "detail": "Function (} } vertex ->)",
    "insertText": "RemoveIncidentEdge(edge)"
  },
  {
    "label": "UnGuaranteeNeighbors()",
    "kind": "Method",
    "detail": "Function (vertex ->)",
    "insertText": "UnGuaranteeNeighbors()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(extraedges)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (edge -> ~ HbrHalfedge<)",
    "insertText": "T()"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "free(extraedges)"
  },
  {
    "label": "GetSubdivision()",
    "kind": "Method",
    "detail": "Function (bool parentHasOtherKids = false ; int nchildren = mesh ->)",
    "insertText": "GetSubdivision()->GetFaceChildrenCount(parentFace->nvertices)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (parentFace -> children . extrachildren [ i ] = 0 ; } else)",
    "insertText": "if(parentFace->children.extrachildren[i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!parentHasOtherKids)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (delete [ ] parentFace -> children . extrachildren ; parentFace -> children . extrachildren = 0 ;)",
    "insertText": "if(parentFace->GarbageCollectable())"
  },
  {
    "label": "DeleteFace()",
    "kind": "Method",
    "detail": "Function (mesh ->)",
    "insertText": "DeleteFace(parentFace)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((*parentFace->children.children)[i])"
  },
  {
    "label": "DeleteFaceChildren()",
    "kind": "Method",
    "detail": "Function (mesh ->)",
    "insertText": "DeleteFaceChildren(parentFace->children.children)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } parent = - 1 ; })",
    "insertText": "if(vchild != -1)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* vchildVert = mesh ->)",
    "insertText": "GetVertex(vchild)"
  },
  {
    "label": "SetParent()",
    "kind": "Method",
    "detail": "Function (vchildVert ->)",
    "insertText": "SetParent(static_cast<HbrFace*>(0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (vchild = - 1 ; })",
    "insertText": "if(nvertices > 4 && fvarbits)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(fvarbits)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef HBRSTITCH)",
    "insertText": "if(stitchEdges)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(stitchEdges)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif } fvarbits = 0 ; # ifdef HBRSTITCH stitchEdges = 0 ; # endif)",
    "insertText": "if(nvertices <= 4)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (edges [ i ] .)",
    "insertText": "Clear()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(index >= 0 && index < nvertices)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else { return const_cast<HbrHalfedge<)",
    "insertText": "T(edges + index)"
  },
  {
    "label": "edge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>*)",
    "insertText": "edge(HbrHalfedge<T>*)(extraedges + index * edgesize)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (} else { return mesh ->)",
    "insertText": "GetVertex(edges[index].GetOrgVertexID())"
  },
  {
    "label": "GetOrgVertexID()",
    "kind": "Method",
    "detail": "Function (} else { return edges [ index ] .)",
    "insertText": "GetOrgVertexID()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(id != -1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int i ;)",
    "insertText": "if(nchildren > 4)"
  },
  {
    "label": "NewFaceChildren()",
    "kind": "Method",
    "detail": "Function (children . extrachildren [ i ] = 0 ; } } else { children . children = mesh ->)",
    "insertText": "NewFaceChildren()"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (children . extrachildren [ index ] = face ; })",
    "insertText": "else(*children.children)"
  },
  {
    "label": "GetSubdivision()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* vchildVert = mesh ->)",
    "insertText": "GetSubdivision()->Subdivide(mesh, this)"
  },
  {
    "label": "SetParent()",
    "kind": "Method",
    "detail": "Function (vchildVert ->)",
    "insertText": "SetParent(this)"
  },
  {
    "label": "GetSubdivision()",
    "kind": "Method",
    "detail": "Function (mesh ->)",
    "insertText": "GetSubdivision()->Refine(mesh, this)"
  },
  {
    "label": "e()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "e(HbrHalfedge<T>*)(extraedges)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int i = 0; i < nvertices; ++i)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (v = mesh ->)",
    "insertText": "GetVertex(e->GetOrgVertexID())"
  },
  {
    "label": "GuaranteeNeighbors()",
    "kind": "Method",
    "detail": "Function (v ->)",
    "insertText": "GuaranteeNeighbors()"
  },
  {
    "label": "GetIncidentEdge()",
    "kind": "Method",
    "detail": "Function (start = v ->)",
    "insertText": "GetIncidentEdge()"
  },
  {
    "label": "GetLeftFace()",
    "kind": "Method",
    "detail": "Function (ee = start ; do { HbrFace<T>* f = ee ->)",
    "insertText": "GetLeftFace()"
  },
  {
    "label": "eee()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eee(HbrHalfedge<T>*)(f->extraedges)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int j = 0; j < nv; ++j)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (mesh ->)",
    "insertText": "GetVertex(eee->GetOrgVertexID())->IncrementUsage()"
  },
  {
    "label": "eee()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eee(HbrHalfedge<T>*)((char *) eee + eedgesize)"
  },
  {
    "label": "GetNextEdge()",
    "kind": "Method",
    "detail": "Function (} ee = v ->)",
    "insertText": "GetNextEdge(ee)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(ee)"
  },
  {
    "label": "e()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "e(HbrHalfedge<T>*)((char *) e + edgesize)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* vert = mesh ->)",
    "insertText": "GetVertex(eee->GetOrgVertexID())"
  },
  {
    "label": "DecrementUsage()",
    "kind": "Method",
    "detail": "Function (vert ->)",
    "insertText": "DecrementUsage()"
  },
  {
    "label": "AddGarbageCollectableVertex()",
    "kind": "Method",
    "detail": "Function (mesh ->)",
    "insertText": "AddGarbageCollectableVertex(vert)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(gc) mesh->GarbageCollect()"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* edge =)",
    "insertText": "GetEdge(i)"
  },
  {
    "label": "GetOrgVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* vertex = edge ->)",
    "insertText": "GetOrgVertex(mesh)"
  },
  {
    "label": "GetHierarchicalEditsAtOffset()",
    "kind": "Method",
    "detail": "Function (HbrHierarchicalEdit<T>** faceedits = edits ; HbrHierarchicalEdit<T>** baseedit = mesh ->)",
    "insertText": "GetHierarchicalEditsAtOffset(0)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (editOffset =)",
    "insertText": "int(faceedits - baseedit)"
  },
  {
    "label": "ApplyEditToFace()",
    "kind": "Method",
    "detail": "Function (edit ->)",
    "insertText": "ApplyEditToFace(this)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (support .)",
    "insertText": "reserve(16)"
  },
  {
    "label": "lower_bound()",
    "kind": "Method",
    "detail": "Function (std::vector<int>::iterator vi =)",
    "insertText": "lower_bound(support.begin(), support.end(), id)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (support .)",
    "insertText": "insert(vi, id)"
  },
  {
    "label": "GetID()",
    "kind": "Method",
    "detail": "Function (out<<\" face \"<<face .)",
    "insertText": "GetID() << \", \" << face.GetNumVertices() << \" vertices (\"; for (int i = 0; i < face.GetNumVertices(); ++i) { HbrHalfedge<T>* e = face.GetEdge(i); out << *(e->GetOrgVertex()); if (e->IsBoundary()) { out << \" -/-> \"; } else { out << \" ---> \"; } } out << \")"
  },
  {
    "label": "HbrFaceOperator()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "HbrFaceOperator()"
  }
]