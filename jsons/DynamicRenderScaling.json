[
  {
    "label": "TMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMap"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FHeuristicSettings",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHeuristicSettings"
  },
  {
    "label": "FBudget",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBudget"
  },
  {
    "label": "FItem",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FItem"
  },
  {
    "label": "IsEnabled()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / ContainerAllocationPolicies . h \" # include \" Containers / List . h \" # include \" CoreMinimal . h \" # include \" CoreTypes . h \" # include \" HAL / IConsoleManager . h \" # include \" Misc / AssertionMacros . h \" # include \" Stats / Stats . h \" namespace DynamicRenderScaling { template<Type> class TMap ; enum class EHeuristicModel { Unknown,Linear,Quadratic,} ; struct FHeuristicSettings final { float kDefaultMinResolutionFraction = 0 . 5 f ; float kDefaultMaxResolutionFraction = 1 . 0 f ; float kDefaultThrottlingMaxResolutionFraction = 0 . 0 f ; float kBudgetMsDisabled = 0 . 0 f ; float kDefaultChangeThreshold = 0 . 0 2 f ; float kDefaultTargetedHeadRoom = 0 . 0 5 f ; float kDefaultIncreaseAmortizationFactor = 0 . 9 f ; int32 kDefaultFractionQuantization = 0 ; int32 kDefaultUpperBoundQuantization = 0 ; EHeuristicModel Model = EHeuristicModel::Unknown ; bool bModelScalesWithPrimaryScreenPercentage = false ; float MinResolutionFraction = kDefaultMinResolutionFraction ; float MaxResolutionFraction = kDefaultMaxResolutionFraction ; float ThrottlingMaxResolutionFraction = kDefaultThrottlingMaxResolutionFraction ; float BudgetMs = kBudgetMsDisabled ; float ChangeThreshold = kDefaultChangeThreshold ; float TargetedHeadRoom = kDefaultTargetedHeadRoom ; float IncreaseAmortizationFactor = kDefaultIncreaseAmortizationFactor ; int32 FractionQuantization = kDefaultFractionQuantization ; int32 UpperBoundQuantization = kDefaultUpperBoundQuantization ; bool)",
    "insertText": "IsEnabled()"
  },
  {
    "label": "GetTargetedMs()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetTargetedMs(float BudgetMs)"
  },
  {
    "label": "EstimateCostScale()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "EstimateCostScale(float ResolutionFraction)"
  },
  {
    "label": "EstimateResolutionFactor()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "EstimateResolutionFactor(float TargetMs, float TimingMs)"
  },
  {
    "label": "EstimateTimeFactor()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "EstimateTimeFactor(float CurrentResolutionFraction, float NewResolutionFraction)"
  },
  {
    "label": "CorrectNewResolutionFraction()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "CorrectNewResolutionFraction(float CurrentResolutionFraction, float NewResolutionFraction, float ResolutionFractionScale)"
  },
  {
    "label": "DoesResolutionChangeEnough()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DoesResolutionChangeEnough(float CurrentResolutionFraction, float NewResolutionFraction, bool bCanChangeResolution)"
  },
  {
    "label": "FBudget()",
    "kind": "Method",
    "detail": "Function (} ; class FBudget final { public :)",
    "insertText": "FBudget(const TCHAR* Name, FHeuristicSettings (*HeuristicSettingsGetter)(void))"
  },
  {
    "label": "FBudget()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FBudget()"
  },
  {
    "label": "GetGlobalList()",
    "kind": "Method",
    "detail": "Function (TLinkedList<FBudget*>*&)",
    "insertText": "GetGlobalList()"
  },
  {
    "label": "GetGlobalListSize()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetGlobalListSize()"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (const TCHAR*)",
    "insertText": "GetName()"
  },
  {
    "label": "GetSettings()",
    "kind": "Method",
    "detail": "Function (} const FHeuristicSettings&)",
    "insertText": "GetSettings()"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (TLinkedList<FBudget*> GlobalListLink ; FHeuristicSettings CachedSettings ; int32 BudgetId = 0 ; # if STATS TStatId StatId_TargetMs ; TStatId StatId_MeasuredMs ; TStatId StatId_MinScaling ; TStatId StatId_MaxScaling ; TStatId StatId_CurrentScaling ; # endif)",
    "insertText": "UE_NONCOPYABLE(FBudget)"
  },
  {
    "label": "UpdateHeuristicsSettings()",
    "kind": "Method",
    "detail": "Function (template<Type> class TMap ; void)",
    "insertText": "UpdateHeuristicsSettings()"
  },
  {
    "label": "TMap()",
    "kind": "Method",
    "detail": "Function (} ; template<Type> class TMap final { public : int32 kInlineAllocatedBudgets = 1 6 ;)",
    "insertText": "TMap()"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Array .)",
    "insertText": "SetNum(FBudget::GetGlobalListSize())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# if ! UE_BUILD_SHIPPING)",
    "insertText": "for(TLinkedList<FBudget*>::TIterator BudgetIt(FBudget::GetGlobalList()); BudgetIt; BudgetIt.Next())"
  },
  {
    "label": "TMap()",
    "kind": "Method",
    "detail": "Function (} # endif })",
    "insertText": "TMap(const Type& Value) : TMap()"
  },
  {
    "label": "SetAll()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAll(Value)"
  },
  {
    "label": "TMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TMap(const TMap<Type>& Map)"
  },
  {
    "label": "SetAll()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAll(const Type& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Array [ i ] . Value = Value ; } } const Type&)",
    "insertText": "operator(const FBudget& Budget)"
  },
  {
    "label": "IsSupported()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSupported()"
  },
  {
    "label": "BeginFrame()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginFrame(const TMap<bool>& bIsBudgetEnabled)"
  },
  {
    "label": "EndFrame()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndFrame()"
  },
  {
    "label": "GetLatestTimings()",
    "kind": "Method",
    "detail": "Function (const TMap<uint64>&)",
    "insertText": "GetLatestTimings()"
  }
]