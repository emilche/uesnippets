[
  {
    "label": "int128",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "int128"
  },
  {
    "label": "numeric_limits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "numeric_limits"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_NUMERIC_INT128_H_ # define ABSL_NUMERIC_INT128_H_ # include<cassert> # include<cmath> # include<cstdint> # include<cstring> # include<iosfwd> # include<limits> # include<utility> # include \" absl / base / config . h \" # include \" absl / base / macros . h \" # include \" absl / base / port . h \" # if)",
    "insertText": "defined(_MSC_VER) #define ABSL_INTERNAL_WCHAR_T __wchar_t #if defined(_M_X64) && !defined(_M_ARM64EC) #include <intrin.h> #pragma intrinsic(_umul128)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (ABSL_NAMESPACE_BEGIN class int128 ; class # if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128) alignas(unsigned __int128)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "uint128()"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uint128(int v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uint128(unsigned int v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uint128(long v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uint128(unsigned long v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uint128(long long v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uint128(unsigned long long v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_HAVE_INTRINSIC_INT128)",
    "insertText": "uint128(__int128 v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uint128(unsigned __int128 v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "uint128(int128 v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uint128(float v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uint128(double v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uint128(long double v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint128&)",
    "insertText": "operator(int v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint128&)",
    "insertText": "operator(unsigned int v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint128&)",
    "insertText": "operator(long v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint128&)",
    "insertText": "operator(unsigned long v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint128&)",
    "insertText": "operator(long long v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint128&)",
    "insertText": "operator(unsigned long long v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_HAVE_INTRINSIC_INT128 uint128&)",
    "insertText": "operator(__int128 v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint128&)",
    "insertText": "operator(unsigned __int128 v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif uint128&)",
    "insertText": "operator(int128 v)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "bool()"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "char()"
  },
  {
    "label": "char16_t()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "char16_t()"
  },
  {
    "label": "char32_t()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "char32_t()"
  },
  {
    "label": "ABSL_INTERNAL_WCHAR_T()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "ABSL_INTERNAL_WCHAR_T()"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "short()"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "int()"
  },
  {
    "label": "long()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "long()"
  },
  {
    "label": "__int128()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_HAVE_INTRINSIC_INT128 operator)",
    "insertText": "__int128()"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (# endif operator)",
    "insertText": "float()"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "double()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint128&)",
    "insertText": "operator(uint128 other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint128)",
    "insertText": "operator(int)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint128&)",
    "insertText": "operator()"
  },
  {
    "label": "Uint128Low64()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "Uint128Low64(uint128 v)"
  },
  {
    "label": "Uint128High64()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "Uint128High64(uint128 v)"
  },
  {
    "label": "MakeUint128()",
    "kind": "Method",
    "detail": "Function (uint128)",
    "insertText": "MakeUint128(uint64_t high, uint64_t low)"
  },
  {
    "label": "Uint128Max()",
    "kind": "Method",
    "detail": "Function (uint128)",
    "insertText": "Uint128Max()"
  },
  {
    "label": "AbslHashValue()",
    "kind": "Method",
    "detail": "Function (template<H> H)",
    "insertText": "AbslHashValue(H h, uint128 v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "uint128(uint64_t high, uint64_t low)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_IS_LITTLE_ENDIAN)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (uint64_t hi_ ; # elif)",
    "insertText": "defined(ABSL_IS_BIG_ENDIAN)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint64_t lo_ ; # else # error \" Unsupported byte order : must be little - endian or big - endian . \" # endif } ; ABSL_DLL const uint128 kuint128max ; std::ostream&)",
    "insertText": "operator(std::ostream& os, uint128 v)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (} ABSL_NAMESPACE_END } namespace std { template<> class numeric_limits<absl::uint128> { public : bool is_specialized = true ; bool is_signed = false ; bool is_integer = true ; bool is_exact = true ; bool has_infinity = false ; bool has_quiet_NaN = false ; bool has_signaling_NaN = false ; float_denorm_style has_denorm = denorm_absent ; bool has_denorm_loss = false ; float_round_style round_style = round_toward_zero ; bool is_iec559 = false ; bool is_bounded = true ; bool is_modulo = true ; int digits = 1 2 8 ; int digits10 = 3 8 ; int max_digits10 = 0 ; int radix = 2 ; int min_exponent = 0 ; int min_exponent10 = 0 ; int max_exponent = 0 ; int max_exponent10 = 0 ; # ifdef ABSL_HAVE_INTRINSIC_INT128 bool traps = numeric_limits<unsigned __int128>::traps ; # else bool traps = numeric_limits<uint64_t>::traps ; # endif bool tinyness_before = false ;)",
    "insertText": "uint128(min)()"
  },
  {
    "label": "epsilon()",
    "kind": "Method",
    "detail": "Function (} absl::uint128)",
    "insertText": "epsilon()"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int128(int v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int128(unsigned int v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int128(long v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int128(unsigned long v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int128(long long v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int128(unsigned long long v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_HAVE_INTRINSIC_INT128)",
    "insertText": "int128(__int128 v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int128(unsigned __int128 v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "int128(uint128 v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int128(float v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int128(double v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int128(long double v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (int128&)",
    "insertText": "operator(int128 other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (int128&)",
    "insertText": "operator(int amount)"
  },
  {
    "label": "Int128Low64()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "Int128Low64(int128 v)"
  },
  {
    "label": "Int128High64()",
    "kind": "Method",
    "detail": "Function (int64_t)",
    "insertText": "Int128High64(int128 v)"
  },
  {
    "label": "MakeInt128()",
    "kind": "Method",
    "detail": "Function (int128)",
    "insertText": "MakeInt128(int64_t high, uint64_t low)"
  },
  {
    "label": "Int128Max()",
    "kind": "Method",
    "detail": "Function (int128)",
    "insertText": "Int128Max()"
  },
  {
    "label": "Int128Min()",
    "kind": "Method",
    "detail": "Function (int128)",
    "insertText": "Int128Min()"
  },
  {
    "label": "AbslHashValue()",
    "kind": "Method",
    "detail": "Function (template<H> H)",
    "insertText": "AbslHashValue(H h, int128 v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "int128(int64_t high, uint64_t low)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint64_t lo_ ; # else # error \" Unsupported byte order : must be little - endian or big - endian . \" # endif # endif } ; std::ostream&)",
    "insertText": "operator(std::ostream& os, int128 v)"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (} ABSL_NAMESPACE_END } namespace std { template<> class numeric_limits<absl::int128> { public : bool is_specialized = true ; bool is_signed = true ; bool is_integer = true ; bool is_exact = true ; bool has_infinity = false ; bool has_quiet_NaN = false ; bool has_signaling_NaN = false ; float_denorm_style has_denorm = denorm_absent ; bool has_denorm_loss = false ; float_round_style round_style = round_toward_zero ; bool is_iec559 = false ; bool is_bounded = true ; bool is_modulo = false ; int digits = 1 2 7 ; int digits10 = 3 8 ; int max_digits10 = 0 ; int radix = 2 ; int min_exponent = 0 ; int min_exponent10 = 0 ; int max_exponent = 0 ; int max_exponent10 = 0 ; # ifdef ABSL_HAVE_INTRINSIC_INT128 bool traps = numeric_limits<__int128>::traps ; # else bool traps = numeric_limits<uint64_t>::traps ; # endif bool tinyness_before = false ;)",
    "insertText": "int128(min)()"
  },
  {
    "label": "lowest()",
    "kind": "Method",
    "detail": "Function (} absl::int128)",
    "insertText": "lowest()"
  },
  {
    "label": "int128()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "int128(max)()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} uint128)",
    "insertText": "operator(uint128 lhs, int amount)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (uint128)",
    "insertText": "operator(uint128 lhs, uint128 rhs)"
  },
  {
    "label": "uint64_t()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "uint64_t(v)"
  },
  {
    "label": "v()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "v(std::numeric_limits<uint64_t>::max)()"
  },
  {
    "label": "uint64_t()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "uint64_t(v & ~uint64_t{0})"
  },
  {
    "label": "uint64_t()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "uint64_t(static_cast<unsigned __int128>(v) >> 64)"
  },
  {
    "label": "uint64_t()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "uint64_t(v >> 64)"
  },
  {
    "label": "Int128Low64()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Int128Low64(v)"
  },
  {
    "label": "uint64_t()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "uint64_t(Int128High64(v))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # elif)",
    "insertText": "defined(ABSL_IS_BIG_ENDIAN) constexpr uint128::uint128(uint64_t high, uint64_t low)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128) return static_cast<unsigned __int128>(lhs) == static_cast<unsigned __int128>(rhs)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "return(Uint128Low64(lhs) == Uint128Low64(rhs) && Uint128High64(lhs) == Uint128High64(rhs))"
  },
  {
    "label": "__int128()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_HAVE_INTRINSIC_INT128 return static_cast<unsigned)",
    "insertText": "__int128(lhs) < static_cast<unsigned __int128>(rhs)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "return(Uint128High64(lhs) == Uint128High64(rhs)) ? (Uint128Low64(lhs) < Uint128Low64(rhs)) : (Uint128High64(lhs) < Uint128High64(rhs))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} uint128)",
    "insertText": "operator(uint128 val)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128) return -static_cast<unsigned __int128>(val)"
  },
  {
    "label": "MakeUint128()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "MakeUint128(~Uint128High64(val) + static_cast<unsigned long>(Uint128Low64(val) == 0), ~Uint128Low64(val) + 1)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128) return !static_cast<unsigned __int128>(val)"
  },
  {
    "label": "Uint128High64()",
    "kind": "Method",
    "detail": "Function (# else return !)",
    "insertText": "Uint128High64(val) && !Uint128Low64(val)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128) return ~static_cast<unsigned __int128>(val)"
  },
  {
    "label": "MakeUint128()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "MakeUint128(~Uint128High64(val), ~Uint128Low64(val))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128) return static_cast<unsigned __int128>(lhs) | static_cast<unsigned __int128>(rhs)"
  },
  {
    "label": "MakeUint128()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "MakeUint128(Uint128High64(lhs) | Uint128High64(rhs), Uint128Low64(lhs) | Uint128Low64(rhs))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128) return static_cast<unsigned __int128>(lhs) & static_cast<unsigned __int128>(rhs)"
  },
  {
    "label": "MakeUint128()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "MakeUint128(Uint128High64(lhs) & Uint128High64(rhs), Uint128Low64(lhs) & Uint128Low64(rhs))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128) return static_cast<unsigned __int128>(lhs) ^ static_cast<unsigned __int128>(rhs)"
  },
  {
    "label": "MakeUint128()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "MakeUint128(Uint128High64(lhs) ^ Uint128High64(rhs), Uint128Low64(lhs) ^ Uint128Low64(rhs))"
  },
  {
    "label": "__int128()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_HAVE_INTRINSIC_INT128 return static_cast<unsigned)",
    "insertText": "__int128(lhs)"
  },
  {
    "label": "MakeUint128()",
    "kind": "Method",
    "detail": "Function (# else return amount> = 6 4 ?)",
    "insertText": "MakeUint128(Uint128Low64(lhs) << (amount - 64), 0) : amount == 0 ? lhs : MakeUint128((Uint128High64(lhs) << amount) | (Uint128Low64(lhs) >> (64 - amount)), Uint128Low64(lhs) << amount)"
  },
  {
    "label": "MakeUint128()",
    "kind": "Method",
    "detail": "Function (# else return amount> = 6 4 ?)",
    "insertText": "MakeUint128(0, Uint128High64(lhs) >> (amount - 64)) : amount == 0 ? lhs : MakeUint128(Uint128High64(lhs) >> amount, (Uint128Low64(lhs) >> amount) | (Uint128High64(lhs) << (64 - amount)))"
  },
  {
    "label": "AddResult()",
    "kind": "Method",
    "detail": "Function (uint128)",
    "insertText": "AddResult(uint128 result, uint128 lhs)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128) return static_cast<unsigned __int128>(lhs) + static_cast<unsigned __int128>(rhs)"
  },
  {
    "label": "AddResult()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "AddResult(MakeUint128(Uint128High64(lhs) + Uint128High64(rhs), Uint128Low64(lhs) + Uint128Low64(rhs)), lhs)"
  },
  {
    "label": "SubstructResult()",
    "kind": "Method",
    "detail": "Function (uint128)",
    "insertText": "SubstructResult(uint128 result, uint128 lhs, uint128 rhs)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128) return static_cast<unsigned __int128>(lhs) - static_cast<unsigned __int128>(rhs)"
  },
  {
    "label": "SubstructResult()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "SubstructResult(MakeUint128(Uint128High64(lhs) - Uint128High64(rhs), Uint128Low64(lhs) - Uint128Low64(rhs)), lhs, rhs)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(ABSL_HAVE_INTRINSIC_INT128) return static_cast<unsigned __int128>(lhs) * static_cast<unsigned __int128>(rhs)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# elif)",
    "insertText": "defined(_MSC_VER) && defined(_M_X64) && !defined(_M_ARM64EC)"
  },
  {
    "label": "_umul128()",
    "kind": "Method",
    "detail": "Function (uint64_t low =)",
    "insertText": "_umul128(Uint128Low64(lhs), Uint128Low64(rhs), &carry)"
  },
  {
    "label": "Uint128Low64()",
    "kind": "Method",
    "detail": "Function (# else uint64_t a32 =)",
    "insertText": "Uint128Low64(lhs)"
  },
  {
    "label": "Uint128Low64()",
    "kind": "Method",
    "detail": "Function (uint64_t b32 =)",
    "insertText": "Uint128Low64(rhs)"
  },
  {
    "label": "MakeUint128()",
    "kind": "Method",
    "detail": "Function (uint128 result =)",
    "insertText": "MakeUint128(Uint128High64(lhs) * Uint128Low64(rhs) + Uint128Low64(lhs) * Uint128High64(rhs) + a32 * b32, a00 * b00)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (result + =)",
    "insertText": "uint128(a32 * b00)"
  },
  {
    "label": "uint128()",
    "kind": "Method",
    "detail": "Function (result + =)",
    "insertText": "uint128(a00 * b32)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (uint128)",
    "insertText": "tmp(*this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (int128)",
    "insertText": "operator(int128 lhs, int128 rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (int128)",
    "insertText": "operator(int128 lhs, int amount)"
  },
  {
    "label": "BitCastToSigned()",
    "kind": "Method",
    "detail": "Function (namespace int128_internal { int64_t)",
    "insertText": "BitCastToSigned(uint64_t v)"
  }
]