[
  {
    "label": "Condition",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Condition"
  },
  {
    "label": "SynchWaitParams",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SynchWaitParams"
  },
  {
    "label": "ABSL_LOCKABLE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ABSL_LOCKABLE"
  },
  {
    "label": "MuHowS",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MuHowS"
  },
  {
    "label": "CondVar",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CondVar"
  },
  {
    "label": "ABSL_SCOPED_LOCKABLE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ABSL_SCOPED_LOCKABLE"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "Mutex()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_SYNCHRONIZATION_MUTEX_H_ # define ABSL_SYNCHRONIZATION_MUTEX_H_ # include<atomic> # include<cstdint> # include<string> # include \" absl / base / const_init . h \" # include \" absl / base / internal / identity . h \" # include \" absl / base / internal / low_level_alloc . h \" # include \" absl / base / internal / thread_identity . h \" # include \" absl / base / internal / tsan_mutex_interface . h \" # include \" absl / base / port . h \" # include \" absl / base / thread_annotations . h \" # include \" absl / synchronization / internal / kernel_timeout . h \" # include \" absl / synchronization / internal / per_thread_sem . h \" # include \" absl / time / time . h \" namespace absl { ABSL_NAMESPACE_BEGIN class Condition ; struct SynchWaitParams ; class ABSL_LOCKABLE Mutex { public :)",
    "insertText": "Mutex()"
  },
  {
    "label": "Mutex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Mutex(absl::ConstInitType)"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Lock() ABSL_EXCLUSIVE_LOCK_FUNCTION()"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unlock() ABSL_UNLOCK_FUNCTION()"
  },
  {
    "label": "TryLock()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryLock() ABSL_EXCLUSIVE_TRYLOCK_FUNCTION(true)"
  },
  {
    "label": "AssertHeld()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertHeld() const ABSL_ASSERT_EXCLUSIVE_LOCK()"
  },
  {
    "label": "ReaderLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReaderLock() ABSL_SHARED_LOCK_FUNCTION()"
  },
  {
    "label": "ReaderUnlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReaderUnlock() ABSL_UNLOCK_FUNCTION()"
  },
  {
    "label": "ReaderTryLock()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReaderTryLock() ABSL_SHARED_TRYLOCK_FUNCTION(true)"
  },
  {
    "label": "AssertReaderHeld()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertReaderHeld() const ABSL_ASSERT_SHARED_LOCK()"
  },
  {
    "label": "WriterLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriterLock() ABSL_EXCLUSIVE_LOCK_FUNCTION()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Lock()"
  },
  {
    "label": "WriterUnlock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "WriterUnlock() ABSL_UNLOCK_FUNCTION()"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Unlock()"
  },
  {
    "label": "WriterTryLock()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "WriterTryLock() ABSL_EXCLUSIVE_TRYLOCK_FUNCTION(true)"
  },
  {
    "label": "Await()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Await(const Condition &cond)"
  },
  {
    "label": "LockWhen()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LockWhen(const Condition &cond) ABSL_EXCLUSIVE_LOCK_FUNCTION()"
  },
  {
    "label": "ReaderLockWhen()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReaderLockWhen(const Condition &cond) ABSL_SHARED_LOCK_FUNCTION()"
  },
  {
    "label": "WriterLockWhen()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriterLockWhen(const Condition &cond) ABSL_EXCLUSIVE_LOCK_FUNCTION()"
  },
  {
    "label": "LockWhen()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "LockWhen(cond)"
  },
  {
    "label": "AwaitWithTimeout()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "AwaitWithTimeout(const Condition &cond, absl::Duration timeout)"
  },
  {
    "label": "AwaitWithDeadline()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AwaitWithDeadline(const Condition &cond, absl::Time deadline)"
  },
  {
    "label": "LockWhenWithTimeout()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "LockWhenWithTimeout(const Condition &cond, absl::Duration timeout) ABSL_EXCLUSIVE_LOCK_FUNCTION()"
  },
  {
    "label": "ReaderLockWhenWithTimeout()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReaderLockWhenWithTimeout(const Condition &cond, absl::Duration timeout) ABSL_SHARED_LOCK_FUNCTION()"
  },
  {
    "label": "WriterLockWhenWithTimeout()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WriterLockWhenWithTimeout(const Condition &cond, absl::Duration timeout) ABSL_EXCLUSIVE_LOCK_FUNCTION()"
  },
  {
    "label": "LockWhenWithDeadline()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "LockWhenWithDeadline(const Condition &cond, absl::Time deadline) ABSL_EXCLUSIVE_LOCK_FUNCTION()"
  },
  {
    "label": "ReaderLockWhenWithDeadline()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReaderLockWhenWithDeadline(const Condition &cond, absl::Time deadline) ABSL_SHARED_LOCK_FUNCTION()"
  },
  {
    "label": "WriterLockWhenWithDeadline()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WriterLockWhenWithDeadline(const Condition &cond, absl::Time deadline) ABSL_EXCLUSIVE_LOCK_FUNCTION()"
  },
  {
    "label": "EnableInvariantDebugging()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EnableInvariantDebugging(void (*invariant)(void *), void *arg)"
  },
  {
    "label": "EnableDebugLog()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnableDebugLog(const char *name)"
  },
  {
    "label": "ForgetDeadlockInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForgetDeadlockInfo()"
  },
  {
    "label": "AssertNotHeld()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertNotHeld()"
  },
  {
    "label": "InternalAttemptToUseMutexInFatalSignalHandler()",
    "kind": "Method",
    "detail": "Function (typedef const struct MuHowS* MuHow ; void)",
    "insertText": "InternalAttemptToUseMutexInFatalSignalHandler()"
  },
  {
    "label": "IncrementSynchSem()",
    "kind": "Method",
    "detail": "Function (private : std::atomic<intptr_t> mu_ ; void)",
    "insertText": "IncrementSynchSem(Mutex *mu, base_internal::PerThreadSynch *w)"
  },
  {
    "label": "DecrementSynchSem()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DecrementSynchSem(Mutex *mu, base_internal::PerThreadSynch *w, synchronization_internal::KernelTimeout t)"
  },
  {
    "label": "LockSlowLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LockSlowLoop(SynchWaitParams *waitp, int flags)"
  },
  {
    "label": "LockSlowWithDeadline()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "LockSlowWithDeadline(MuHow how, const Condition *cond, synchronization_internal::KernelTimeout t, int flags)"
  },
  {
    "label": "LockSlow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LockSlow(MuHow how, const Condition *cond, int flags)"
  },
  {
    "label": "UnlockSlow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnlockSlow(SynchWaitParams *waitp)"
  },
  {
    "label": "AwaitCommon()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AwaitCommon(const Condition &cond, synchronization_internal::KernelTimeout t)"
  },
  {
    "label": "TryRemove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TryRemove(base_internal::PerThreadSynch *s)"
  },
  {
    "label": "Block()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Block(base_internal::PerThreadSynch *s)"
  },
  {
    "label": "Wakeup()",
    "kind": "Method",
    "detail": "Function (base_internal::PerThreadSynch*)",
    "insertText": "Wakeup(base_internal::PerThreadSynch *w)"
  },
  {
    "label": "Trans()",
    "kind": "Method",
    "detail": "Function (class CondVar ; void)",
    "insertText": "Trans(MuHow how)"
  },
  {
    "label": "Fer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Fer(base_internal::PerThreadSynch *w)"
  },
  {
    "label": "Mutex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Mutex(const volatile Mutex *)"
  },
  {
    "label": "Mutex()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Mutex(const Mutex&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Mutex&)",
    "insertText": "operator(const Mutex&)"
  },
  {
    "label": "MutexLock()",
    "kind": "Method",
    "detail": "Function (} ; class ABSL_SCOPED_LOCKABLE MutexLock { public :)",
    "insertText": "MutexLock(Mutex *mu) ABSL_EXCLUSIVE_LOCK_FUNCTION(mu) : mu_(mu)"
  },
  {
    "label": "MutexLock()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MutexLock(Mutex *mu, const Condition &cond) ABSL_EXCLUSIVE_LOCK_FUNCTION(mu) : mu_(mu)"
  },
  {
    "label": "MutexLock()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MutexLock(const MutexLock &)"
  },
  {
    "label": "MutexLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MutexLock(MutexLock&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MutexLock&)",
    "insertText": "operator(const MutexLock&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MutexLock&)",
    "insertText": "operator(MutexLock&&)"
  },
  {
    "label": "MutexLock()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "MutexLock() ABSL_UNLOCK_FUNCTION()"
  },
  {
    "label": "ReaderMutexLock()",
    "kind": "Method",
    "detail": "Function (} private : Mutex* const mu_ ; } ; class ABSL_SCOPED_LOCKABLE ReaderMutexLock { public :)",
    "insertText": "ReaderMutexLock(Mutex *mu) ABSL_SHARED_LOCK_FUNCTION(mu) : mu_(mu)"
  },
  {
    "label": "ReaderLock()",
    "kind": "Method",
    "detail": "Function (mu ->)",
    "insertText": "ReaderLock()"
  },
  {
    "label": "ReaderMutexLock()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ReaderMutexLock(Mutex *mu, const Condition &cond) ABSL_SHARED_LOCK_FUNCTION(mu) : mu_(mu)"
  },
  {
    "label": "ReaderLockWhen()",
    "kind": "Method",
    "detail": "Function (mu ->)",
    "insertText": "ReaderLockWhen(cond)"
  },
  {
    "label": "ReaderMutexLock()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ReaderMutexLock(const ReaderMutexLock&)"
  },
  {
    "label": "ReaderMutexLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReaderMutexLock(ReaderMutexLock&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ReaderMutexLock&)",
    "insertText": "operator(const ReaderMutexLock&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ReaderMutexLock&)",
    "insertText": "operator(ReaderMutexLock&&)"
  },
  {
    "label": "ReaderMutexLock()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ReaderMutexLock() ABSL_UNLOCK_FUNCTION()"
  },
  {
    "label": "ReaderUnlock()",
    "kind": "Method",
    "detail": "Function (this -> mu_ ->)",
    "insertText": "ReaderUnlock()"
  },
  {
    "label": "WriterMutexLock()",
    "kind": "Method",
    "detail": "Function (} private : Mutex* const mu_ ; } ; class ABSL_SCOPED_LOCKABLE WriterMutexLock { public :)",
    "insertText": "WriterMutexLock(Mutex *mu) ABSL_EXCLUSIVE_LOCK_FUNCTION(mu) : mu_(mu)"
  },
  {
    "label": "WriterLock()",
    "kind": "Method",
    "detail": "Function (mu ->)",
    "insertText": "WriterLock()"
  },
  {
    "label": "WriterMutexLock()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "WriterMutexLock(Mutex *mu, const Condition &cond) ABSL_EXCLUSIVE_LOCK_FUNCTION(mu) : mu_(mu)"
  },
  {
    "label": "WriterLockWhen()",
    "kind": "Method",
    "detail": "Function (mu ->)",
    "insertText": "WriterLockWhen(cond)"
  },
  {
    "label": "WriterMutexLock()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "WriterMutexLock(const WriterMutexLock&)"
  },
  {
    "label": "WriterMutexLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriterMutexLock(WriterMutexLock&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (WriterMutexLock&)",
    "insertText": "operator(const WriterMutexLock&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (WriterMutexLock&)",
    "insertText": "operator(WriterMutexLock&&)"
  },
  {
    "label": "WriterMutexLock()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "WriterMutexLock() ABSL_UNLOCK_FUNCTION()"
  },
  {
    "label": "WriterUnlock()",
    "kind": "Method",
    "detail": "Function (this -> mu_ ->)",
    "insertText": "WriterUnlock()"
  },
  {
    "label": "Condition()",
    "kind": "Method",
    "detail": "Function (} private : Mutex* const mu_ ; } ; class Condition { public :)",
    "insertText": "Condition(bool (*func)(void *), void *arg)"
  },
  {
    "label": "Condition()",
    "kind": "Method",
    "detail": "Function (template<T>)",
    "insertText": "Condition(bool (*func)(T *), T *arg)"
  },
  {
    "label": "Condition()",
    "kind": "Method",
    "detail": "Function (template<T>)",
    "insertText": "Condition(T *object, bool (absl::internal::identity<T>::type::* method)())"
  },
  {
    "label": "Condition()",
    "kind": "Method",
    "detail": "Function (template<T>)",
    "insertText": "Condition(const T *object, bool (absl::internal::identity<T>::type::* method)() const)"
  },
  {
    "label": "Condition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Condition(const bool *cond)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<T,E =)",
    "insertText": "decltype(static_cast<bool (T::*)() const>(&T::operator()))> explicit Condition(const T *obj) : Condition(obj, static_cast<bool (T::*)() const>(&T::operator()))"
  },
  {
    "label": "Eval()",
    "kind": "Method",
    "detail": "Function (} const Condition kTrue ; bool)",
    "insertText": "Eval()"
  },
  {
    "label": "GuaranteedEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GuaranteedEqual(const Condition *a, const Condition *b)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (private : typedef)",
    "insertText": "bool(*InternalFunctionType)(void * arg)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "bool(Condition::*InternalMethodType)()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "bool(*InternalMethodCallerType)(void * arg, InternalMethodType internal_method)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bool(*eval_)(const Condition*)"
  },
  {
    "label": "Condition()",
    "kind": "Method",
    "detail": "Function (InternalFunctionType function_ ; InternalMethodType method_ ; void* arg_ ;)",
    "insertText": "Condition()"
  },
  {
    "label": "CallVoidPtrFunction()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CallVoidPtrFunction(const Condition*)"
  },
  {
    "label": "CastAndCallFunction()",
    "kind": "Method",
    "detail": "Function (template<T> bool)",
    "insertText": "CastAndCallFunction(const Condition* c)"
  },
  {
    "label": "CastAndCallMethod()",
    "kind": "Method",
    "detail": "Function (template<T> bool)",
    "insertText": "CastAndCallMethod(const Condition* c)"
  },
  {
    "label": "CondVar()",
    "kind": "Method",
    "detail": "Function (} ; class CondVar { public :)",
    "insertText": "CondVar()"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Wait(Mutex *mu)"
  },
  {
    "label": "WaitWithTimeout()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WaitWithTimeout(Mutex *mu, absl::Duration timeout)"
  },
  {
    "label": "WaitWithDeadline()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WaitWithDeadline(Mutex *mu, absl::Time deadline)"
  },
  {
    "label": "Signal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Signal()"
  },
  {
    "label": "SignalAll()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SignalAll()"
  },
  {
    "label": "WaitCommon()",
    "kind": "Method",
    "detail": "Function (private : bool)",
    "insertText": "WaitCommon(Mutex *mutex, synchronization_internal::KernelTimeout t)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Remove(base_internal::PerThreadSynch *s)"
  },
  {
    "label": "CondVar()",
    "kind": "Method",
    "detail": "Function (std::atomic<intptr_t> cv_ ;)",
    "insertText": "CondVar(const CondVar&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CondVar&)",
    "insertText": "operator(const CondVar&)"
  },
  {
    "label": "MutexLockMaybe()",
    "kind": "Method",
    "detail": "Function (} ; class ABSL_SCOPED_LOCKABLE MutexLockMaybe { public :)",
    "insertText": "MutexLockMaybe(Mutex *mu) ABSL_EXCLUSIVE_LOCK_FUNCTION(mu) : mu_(mu)"
  },
  {
    "label": "MutexLockMaybe()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "MutexLockMaybe(Mutex *mu, const Condition &cond) ABSL_EXCLUSIVE_LOCK_FUNCTION(mu) : mu_(mu)"
  },
  {
    "label": "MutexLockMaybe()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "MutexLockMaybe() ABSL_UNLOCK_FUNCTION()"
  },
  {
    "label": "MutexLockMaybe()",
    "kind": "Method",
    "detail": "Function (} } private : Mutex* const mu_ ;)",
    "insertText": "MutexLockMaybe(const MutexLockMaybe&)"
  },
  {
    "label": "MutexLockMaybe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MutexLockMaybe(MutexLockMaybe&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MutexLockMaybe&)",
    "insertText": "operator(const MutexLockMaybe&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MutexLockMaybe&)",
    "insertText": "operator(MutexLockMaybe&&)"
  },
  {
    "label": "ReleasableMutexLock()",
    "kind": "Method",
    "detail": "Function (} ; class ABSL_SCOPED_LOCKABLE ReleasableMutexLock { public :)",
    "insertText": "ReleasableMutexLock(Mutex *mu) ABSL_EXCLUSIVE_LOCK_FUNCTION(mu) : mu_(mu)"
  },
  {
    "label": "ReleasableMutexLock()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ReleasableMutexLock(Mutex *mu, const Condition &cond) ABSL_EXCLUSIVE_LOCK_FUNCTION(mu) : mu_(mu)"
  },
  {
    "label": "ReleasableMutexLock()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ReleasableMutexLock() ABSL_UNLOCK_FUNCTION()"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Release() ABSL_UNLOCK_FUNCTION()"
  },
  {
    "label": "ReleasableMutexLock()",
    "kind": "Method",
    "detail": "Function (private : Mutex* mu_ ;)",
    "insertText": "ReleasableMutexLock(const ReleasableMutexLock&)"
  },
  {
    "label": "ReleasableMutexLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleasableMutexLock(ReleasableMutexLock&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ReleasableMutexLock&)",
    "insertText": "operator(const ReleasableMutexLock&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ReleasableMutexLock&)",
    "insertText": "operator(ReleasableMutexLock&&)"
  },
  {
    "label": "Mutex()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "Mutex() : mu_(0)"
  },
  {
    "label": "ABSL_TSAN_MUTEX_CREATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_TSAN_MUTEX_CREATE(this, __tsan_mutex_not_static)"
  },
  {
    "label": "Mutex()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Mutex(absl::ConstInitType) : mu_(0)"
  },
  {
    "label": "CondVar()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CondVar() : cv_(0)"
  },
  {
    "label": "CastAndCallMethod()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "CastAndCallMethod(const Condition *c)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "bool(T::*MemberType)()"
  },
  {
    "label": "MemberType()",
    "kind": "Method",
    "detail": "Function (MemberType rm = reinterpret_cast<)",
    "insertText": "MemberType(c->method_)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T* x = static_cast<)",
    "insertText": "T(c->arg_)"
  },
  {
    "label": "CastAndCallFunction()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "CastAndCallFunction(const Condition *c)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "bool(*FuncType)(T *)"
  },
  {
    "label": "FuncType()",
    "kind": "Method",
    "detail": "Function (FuncType fn = reinterpret_cast<)",
    "insertText": "FuncType(c->function_)"
  },
  {
    "label": "Condition()",
    "kind": "Method",
    "detail": "Function (} template<T>)",
    "insertText": "Condition(bool (*func)(T *), T *arg) : eval_(&CastAndCallFunction<T>), function_(reinterpret_cast<InternalFunctionType>(func)), method_(nullptr), arg_(const_cast<void *>(static_cast<const void *>(arg)))"
  },
  {
    "label": "Condition()",
    "kind": "Method",
    "detail": "Function (} template<T>)",
    "insertText": "Condition(T *object, bool (absl::internal::identity<T>::type::*method)()) : eval_(&CastAndCallMethod<T>), function_(nullptr), method_(reinterpret_cast<InternalMethodType>(method)), arg_(object)"
  },
  {
    "label": "Condition()",
    "kind": "Method",
    "detail": "Function (} template<T>)",
    "insertText": "Condition(const T *object, bool (absl::internal::identity<T>::type::*method)() const) : eval_(&CastAndCallMethod<T>), function_(nullptr), method_(reinterpret_cast<InternalMethodType>(method)), arg_(reinterpret_cast<void *>(const_cast<T *>(object)))"
  },
  {
    "label": "RegisterMutexProfiler()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RegisterMutexProfiler(void (*fn)(int64_t wait_cycles))"
  },
  {
    "label": "RegisterMutexTracer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterMutexTracer(void (*fn)(const char *msg, const void *obj, int64_t wait_cycles))"
  },
  {
    "label": "RegisterCondVarTracer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterCondVarTracer(void (*fn)(const char *msg, const void *cv))"
  },
  {
    "label": "ABSL_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_DEPRECATED(\"absl::RegisterSymbolizer() is deprecated and will be removed \" \"on or after 2023-05-01\") void RegisterSymbolizer(bool (*fn)(const void *pc, char *out, int out_size))"
  },
  {
    "label": "EnableMutexInvariantDebugging()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnableMutexInvariantDebugging(bool enabled)"
  },
  {
    "label": "SetMutexDeadlockDetectionMode()",
    "kind": "Method",
    "detail": "Function (enum class OnDeadlockCycle { kIgnore,kReport,kAbort,} ; void)",
    "insertText": "SetMutexDeadlockDetectionMode(OnDeadlockCycle mode)"
  },
  {
    "label": "ABSL_INTERNAL_C_SYMBOL()",
    "kind": "Method",
    "detail": "Function (ABSL_NAMESPACE_END } \" C \" { void)",
    "insertText": "ABSL_INTERNAL_C_SYMBOL(AbslInternalMutexYield)()"
  }
]