[
  {
    "label": "MapVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MapVector"
  },
  {
    "label": "Predicate",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Predicate"
  },
  {
    "label": "Function",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Function"
  },
  {
    "label": "SmallMapVector",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SmallMapVector"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ADT_MAPVECTOR_H # define LLVM_ADT_MAPVECTOR_H # include \" llvm / ADT / DenseMap . h \" # include \" llvm / ADT / SmallVector . h \" # include<vector> namespace llvm { template<KeyT,ValueT,MapType = llvm::DenseMap<KeyT,unsigned>,VectorType = std::vector<std::pair<KeyT,ValueT>>> class MapVector { typedef VectorType::size_type size_type ; MapType Map ; VectorType Vector ; public : typedef VectorType::iterator iterator ; typedef VectorType::const_iterator const_iterator ; typedef VectorType::reverse_iterator reverse_iterator ; typedef VectorType::const_reverse_iterator const_reverse_iterator ; size_type)",
    "insertText": "size()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rbegin()"
  },
  {
    "label": "rend()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rend()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (} std::pair<KeyT,ValueT>&)",
    "insertText": "front()"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} std::pair<KeyT,ValueT>&)",
    "insertText": "back()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear()"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(MapVector &RHS)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(Map, RHS.Map)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(Vector, RHS.Vector)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ValueT&)",
    "insertText": "operator(const KeyT &Key)"
  },
  {
    "label": "make_pair()",
    "kind": "Method",
    "detail": "Function (std::pair<KeyT,unsigned> Pair =)",
    "insertText": "make_pair(Key, 0)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (std::pair<MapType::iterator,bool> Result = Map .)",
    "insertText": "insert(Pair)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned& I = Result . first -> second ;)",
    "insertText": "if(Result.second)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Vector .)",
    "insertText": "push_back(std::make_pair(Key, ValueT()))"
  },
  {
    "label": "lookup()",
    "kind": "Method",
    "detail": "Function (} return Vector [ I ] . second ; } ValueT)",
    "insertText": "lookup(const KeyT &Key)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (MapType::const_iterator Pos = Map .)",
    "insertText": "find(Key)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} std::pair<iterator,bool>)",
    "insertText": "insert(const std::pair<KeyT, ValueT> &KV)"
  },
  {
    "label": "make_pair()",
    "kind": "Method",
    "detail": "Function (std::pair<KeyT,unsigned> Pair =)",
    "insertText": "make_pair(KV.first, 0)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Vector .)",
    "insertText": "push_back(std::make_pair(KV.first, KV.second))"
  },
  {
    "label": "make_pair()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "make_pair(begin() + I, false)"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "count(const KeyT &Key)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "find(const KeyT &Key)"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pop_back()"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (MapType::iterator Pos = Map .)",
    "insertText": "find(Vector.back().first)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (Map .)",
    "insertText": "erase(Pos)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} VectorType::iterator)",
    "insertText": "erase(typename VectorType::iterator Iterator)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (Map .)",
    "insertText": "erase(Iterator->first)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (auto Next = Vector .)",
    "insertText": "erase(Iterator)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(I.second != Index && \"Index was already erased!\")"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} return Next ; } size_type)",
    "insertText": "erase(const KeyT &Key)"
  },
  {
    "label": "remove_if()",
    "kind": "Method",
    "detail": "Function (} ; template<KeyT,ValueT,MapType,VectorType> template<class Function> void MapVector<KeyT,ValueT,MapType,VectorType)",
    "insertText": "remove_if(Function Pred)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (Map .)",
    "insertText": "erase(I->first)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(I != O)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (* O =)",
    "insertText": "move(*I)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} + + O ; } Vector .)",
    "insertText": "erase(O, Vector.end())"
  }
]