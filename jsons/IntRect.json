[
  {
    "label": "TIntRect",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIntRect"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "TIsUECoreVariant",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsUECoreVariant"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Math / UnrealMathUtility . h \" # include \" Containers / UnrealString . h \" # include \" Math / IntPoint . h \" # include \" Math / Vector2D . h \" namespace UE::Math { template<InIntType> struct TIntRect { using IntType = InIntType ; using IntPointType = TIntPoint<IntType> ;)",
    "insertText": "static_assert(std::is_integral_v<IntType>, \"Only an integer types are supported.\")"
  },
  {
    "label": "TIntRect()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "TIntRect() : Min(ForceInit) , Max(ForceInit)"
  },
  {
    "label": "TIntRect()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TIntRect(IntType X0, IntType Y0, IntType X1, IntType Y1) : Min(X0, Y0) , Max(X1, Y1)"
  },
  {
    "label": "TIntRect()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TIntRect(IntPointType InMin, IntPointType InMax) : Min(InMin) , Max(InMax)"
  },
  {
    "label": "TIntRect()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TIntRect(const TIntRect& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (* this = Other ; } TIntRect&)",
    "insertText": "operator(const TIntRect& Other)"
  },
  {
    "label": "TIntRect()",
    "kind": "Method",
    "detail": "Function (Min = Other . Min ; Max = Other . Max ; return* this ; } template<OtherIntType>)",
    "insertText": "TIntRect(TIntRect<OtherIntType> Other) : Min(IntPointType(Other.Min)) , Max(IntPointType(Other.Max))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const TIntRect&)",
    "insertText": "operator()(int32 PointIndex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Min* = Scale ; Max* = Scale ; return* this ; } TIntRect&)",
    "insertText": "operator(const IntPointType& Point)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Min - = Point ; Max - = Point ; return* this ; } TIntRect)",
    "insertText": "operator(IntType Scale)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TIntRect)",
    "insertText": "operator(IntType Div)"
  },
  {
    "label": "Area()",
    "kind": "Method",
    "detail": "Function (} IntType)",
    "insertText": "Area()"
  },
  {
    "label": "Bottom()",
    "kind": "Method",
    "detail": "Function (} TIntRect)",
    "insertText": "Bottom(IntType InHeight)"
  },
  {
    "label": "Clip()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Clip(const TIntRect& R)"
  },
  {
    "label": "IntType()",
    "kind": "Method",
    "detail": "Function (Min . X = FMath::Max<)",
    "insertText": "IntType(Min.X, R.Min.X)"
  },
  {
    "label": "IntType()",
    "kind": "Method",
    "detail": "Function (Min . Y = FMath::Max<)",
    "insertText": "IntType(Min.Y, R.Min.Y)"
  },
  {
    "label": "IntType()",
    "kind": "Method",
    "detail": "Function (Max . X = FMath::Min<)",
    "insertText": "IntType(Max.X, R.Max.X)"
  },
  {
    "label": "IntType()",
    "kind": "Method",
    "detail": "Function (Max . Y = FMath::Min<)",
    "insertText": "IntType(Max.Y, R.Max.Y)"
  },
  {
    "label": "IntType()",
    "kind": "Method",
    "detail": "Function (Max . X = FMath::Max<)",
    "insertText": "IntType(Min.X, Max.X)"
  },
  {
    "label": "IntType()",
    "kind": "Method",
    "detail": "Function (Max . Y = FMath::Max<)",
    "insertText": "IntType(Min.Y, Max.Y)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Union(const TIntRect& R)"
  },
  {
    "label": "Intersect()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Intersect(const TIntRect& Other)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (OutExtent .)",
    "insertText": "X(Max.X - Min.X)"
  },
  {
    "label": "Y()",
    "kind": "Method",
    "detail": "Function (OutExtent .)",
    "insertText": "Y(Max.Y - Min.Y)"
  },
  {
    "label": "Height()",
    "kind": "Method",
    "detail": "Function (OutCenter . X = Min . X + OutExtent . X ; OutCenter . Y = Min . Y + OutExtent . Y ; } IntType)",
    "insertText": "Height()"
  },
  {
    "label": "InflateRect()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InflateRect(IntType Amount)"
  },
  {
    "label": "Include()",
    "kind": "Method",
    "detail": "Function (Min . X - = Amount ; Min . Y - = Amount ; Max . X + = Amount ; Max . Y + = Amount ; } void)",
    "insertText": "Include(IntPointType Point)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Min . X =)",
    "insertText": "Min(Min.X, Point.X)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Min . Y =)",
    "insertText": "Min(Min.Y, Point.Y)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Max . X =)",
    "insertText": "Max(Max.X, Point.X)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Max . Y =)",
    "insertText": "Max(Max.Y, Point.Y)"
  },
  {
    "label": "Inner()",
    "kind": "Method",
    "detail": "Function (} TIntRect)",
    "insertText": "Inner(IntPointType Shrink)"
  },
  {
    "label": "Right()",
    "kind": "Method",
    "detail": "Function (} TIntRect)",
    "insertText": "Right(IntType InWidth)"
  },
  {
    "label": "Scale()",
    "kind": "Method",
    "detail": "Function (} TIntRect)",
    "insertText": "Scale(double Fraction)"
  },
  {
    "label": "Vec2D()",
    "kind": "Method",
    "detail": "Function (using Vec2D = UE::Math::TVector2<double> ; const Vec2D Min2D =)",
    "insertText": "Vec2D((double)Min.X, (double)Min.Y)"
  },
  {
    "label": "Vec2D()",
    "kind": "Method",
    "detail": "Function (const Vec2D Max2D =)",
    "insertText": "Vec2D((double)Max.X, (double)Max.Y)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (} IntPointType)",
    "insertText": "Size()"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ToString()"
  },
  {
    "label": "Width()",
    "kind": "Method",
    "detail": "Function (} IntType)",
    "insertText": "Width()"
  },
  {
    "label": "DivideAndRoundUp()",
    "kind": "Method",
    "detail": "Function (} TIntRect)",
    "insertText": "DivideAndRoundUp(TIntRect lhs, IntType Div)"
  },
  {
    "label": "DivideAndRoundUp()",
    "kind": "Method",
    "detail": "Function (} TIntRect)",
    "insertText": "DivideAndRoundUp(TIntRect lhs, IntPointType Div)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Num()"
  }
]