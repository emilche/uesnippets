[
  {
    "label": "_Pred",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Pred"
  },
  {
    "label": "_Proj",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Proj"
  },
  {
    "label": "_ProjectedPred",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_ProjectedPred"
  },
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "_T1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_T1"
  },
  {
    "label": "_T2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_T2"
  },
  {
    "label": "__can_use_pristine_comp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__can_use_pristine_comp"
  },
  {
    "label": "_Comp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Comp"
  },
  {
    "label": "_Proj1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Proj1"
  },
  {
    "label": "_Proj2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Proj2"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___ALGORITHM_MAKE_PROJECTED_H # define _LIBCPP___ALGORITHM_MAKE_PROJECTED_H # include<__concepts / same_as . h> # include<__config> # include<__functional / identity . h> # include<__functional / invoke . h> # include<__type_traits / decay . h> # include<__type_traits / enable_if . h> # include<__type_traits / integral_constant . h> # include<__type_traits / is_member_pointer . h> # include<__type_traits / is_same . h> # include<__utility / declval . h> # include<__utility / forward . h> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)"
  },
  {
    "label": "_ProjectedPred()",
    "kind": "Method",
    "detail": "Function (_Pred& __pred ; _Proj& __proj ; _LIBCPP_CONSTEXPR)",
    "insertText": "_ProjectedPred(_Pred& __pred_arg, _Proj& __proj_arg) : __pred(__pred_arg), __proj(__proj_arg)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp> __invoke_of<_Pred&,)",
    "insertText": "decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_Tp>())) >::type _LIBCPP_CONSTEXPR operator()(_Tp&& __v)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<class _T1,class _T2> __invoke_of<_Pred&,)",
    "insertText": "decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_T1>())), decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_T2>())) >::type _LIBCPP_CONSTEXPR operator()(_T1&& __lhs, _T2&& __rhs)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} } ; template<class _Pred,class _Proj,class = void> struct __can_use_pristine_comp : false_type { } ; template<class _Pred,class _Proj> struct __can_use_pristine_comp<_Pred,_Proj,__enable_if_t<! is_member_pointer<decay<_Pred>::type)",
    "insertText": "value(#if _LIBCPP_STD_VER > 17 is_same<typename decay<_Proj>::type, identity>::value || #endif is_same<typename decay<_Proj>::type, __identity>::value)"
  },
  {
    "label": "__make_projected()",
    "kind": "Method",
    "detail": "Function (} ; template<class _Pred,class _Proj> _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR __enable_if_t<! __can_use_pristine_comp<_Pred,_Proj>::value,_ProjectedPred<_Pred,_Proj>>)",
    "insertText": "__make_projected(_Pred& __pred, _Proj& __proj)"
  },
  {
    "label": "__make_projected()",
    "kind": "Method",
    "detail": "Function (} template<class _Pred,class _Proj> _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR __enable_if_t<__can_use_pristine_comp<_Pred,_Proj>::value,_Pred&>)",
    "insertText": "__make_projected(_Pred& __pred, _Proj&)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<class _Comp,class _Proj1,class _Proj2> _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "decltype(auto) __make_projected_comp(_Comp& __comp, _Proj1& __proj1, _Proj2& __proj2)"
  }
]