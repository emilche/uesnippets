[
  {
    "label": "FSetKeyFuncsStats",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSetKeyFuncsStats"
  },
  {
    "label": "TSetKeyFuncs",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSetKeyFuncs"
  },
  {
    "label": "FIterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIterator"
  },
  {
    "label": "FIterationSentinel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIterationSentinel"
  },
  {
    "label": "TSetKeyFuncs()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" HAL / Platform . h \" # include \" HAL / UnrealMemory . h \" # include \" Math / NumericLimits . h \" # include \" Math / UnrealMath . h \" # include \" Misc / AssertionMacros . h \" # include \" Templates / Function . h \" # include \" Templates / UnrealTemplate . h \" struct FSetKeyFuncsStats ; template<ElementType,KeyFuncsType> class TSetKeyFuncs { public : struct FIterator ; struct FIterationSentinel ; public :)",
    "insertText": "TSetKeyFuncs(KeyFuncsType KeyFuncs, int32 ExpectedNumElements = 0)"
  },
  {
    "label": "TSetKeyFuncs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TSetKeyFuncs(const TSetKeyFuncs<ElementType, KeyFuncsType>& Other)"
  },
  {
    "label": "TSetKeyFuncs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TSetKeyFuncs(TSetKeyFuncs<ElementType, KeyFuncsType>&& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TSetKeyFuncs&)",
    "insertText": "operator(const TSetKeyFuncs<ElementType, KeyFuncsType>& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TSetKeyFuncs&)",
    "insertText": "operator(TSetKeyFuncs<ElementType, KeyFuncsType>&& Other)"
  },
  {
    "label": "TSetKeyFuncs()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "TSetKeyFuncs()"
  },
  {
    "label": "SetKeyFuncs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetKeyFuncs(KeyFuncsType KeyFuncs)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty(int32 ExpectedNumElements = 0)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reserve(int32 ExpectedNumElements)"
  },
  {
    "label": "ResizeToTargetSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeToTargetSize()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Num()"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "GetStats()",
    "kind": "Method",
    "detail": "Function (FSetKeyFuncsStats)",
    "insertText": "GetStats()"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (template<CompareType> const ElementType*)",
    "insertText": "Find(const CompareType& Key)"
  },
  {
    "label": "FindByHash()",
    "kind": "Method",
    "detail": "Function (template<CompareType> const ElementType*)",
    "insertText": "FindByHash(uint32 TypeHash, const CompareType& Key)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(ElementType Value, bool* bAlreadyExists = nullptr)"
  },
  {
    "label": "AddByHash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddByHash(uint32 TypeHash, ElementType Value, bool* bAlreadyExists = nullptr)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Remove(const ElementType& Value)"
  },
  {
    "label": "RemoveByHash()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "RemoveByHash(uint32 TypeHash, const ElementType& Value)"
  },
  {
    "label": "FIterator()",
    "kind": "Method",
    "detail": "Function (public : struct FIterator {)",
    "insertText": "FIterator(const TSetKeyFuncs<ElementType, KeyFuncsType>& InOwner)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (const ElementType&)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(FIterationSentinel)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (private : const TSetKeyFuncs& Owner ; uint32 Bucket ; } ; struct FIterationSentinel { } ; private : FIterator)",
    "insertText": "begin(const TSetKeyFuncs<ElementType, KeyFuncsType>& Set)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} FIterationSentinel)",
    "insertText": "end(const TSetKeyFuncs<ElementType, KeyFuncsType>& Set)"
  },
  {
    "label": "AddByHashNoReallocate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddByHashNoReallocate(uint32 TypeHash, ElementType Value, bool* bAlreadyExists)"
  },
  {
    "label": "Reallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reallocate(uint32 NewHashSize)"
  },
  {
    "label": "GetTargetHashSize()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetTargetHashSize()"
  },
  {
    "label": "GetTargetHashSize()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetTargetHashSize(uint32 TargetNumValues)"
  },
  {
    "label": "HashSpaceToBucketSpace()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "HashSpaceToBucketSpace(uint32 HashKey)"
  },
  {
    "label": "DestructHash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructHash()"
  },
  {
    "label": "TSetKeyFuncs()",
    "kind": "Method",
    "detail": "Function (private : float MaxLoadFactorDuringAdd = 0 . 7 5 f ; float TargetLoadFactor = 0 . 5 f ; uint32 InitialAllocationSize = 8 ; uint32 MinimumNonZeroSize = 8 ; KeyFuncsType KeyFuncs ; ElementType* Hash = nullptr ; uint32 HashSize = 0 ; uint32 NumValues = 0 ; } ; struct FSetKeyFuncsStats { float AverageSearch ; int32 LongestSearch ; } ; template<ElementType,KeyFuncsType> TSetKeyFuncs<ElementType,KeyFuncsType)",
    "insertText": "TSetKeyFuncs(KeyFuncsType InKeyFuncs, int32 ExpectedNumElements) : KeyFuncs(MoveTemp(InKeyFuncs))"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty(ExpectedNumElements)"
  },
  {
    "label": "TSetKeyFuncs()",
    "kind": "Method",
    "detail": "Function (} template<ElementType,KeyFuncsType> TSetKeyFuncs<ElementType,KeyFuncsType)",
    "insertText": "TSetKeyFuncs(const TSetKeyFuncs& Other)"
  },
  {
    "label": "TSetKeyFuncs()",
    "kind": "Method",
    "detail": "Function (* this = Other ; } template<ElementType,KeyFuncsType> TSetKeyFuncs<ElementType,KeyFuncsType)",
    "insertText": "TSetKeyFuncs(TSetKeyFuncs&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "MoveTemp(Other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (KeyFuncs = Other . KeyFuncs ; HashSize = Other . HashSize ; NumValues = Other . NumValues ;)",
    "insertText": "if(HashSize > 0)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (Hash = reinterpret_cast<)",
    "insertText": "ElementType(FMemory::Malloc(sizeof(ElementType) * HashSize, alignof(ElementType)))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&Hash[Bucket]) ElementType(Other.Hash[Bucket])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } return* this ; } template<ElementType,KeyFuncsType> TSetKeyFuncs<ElementType,KeyFuncsType>& TSetKeyFuncs<ElementType,KeyFuncsType)",
    "insertText": "operator(TSetKeyFuncs&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (KeyFuncs =)",
    "insertText": "MoveTemp(Other.KeyFuncs)"
  },
  {
    "label": "SetKeyFuncs()",
    "kind": "Method",
    "detail": "Function (} template<ElementType,KeyFuncsType> void TSetKeyFuncs<ElementType,KeyFuncsType)",
    "insertText": "SetKeyFuncs(KeyFuncsType InKeyFuncs)"
  },
  {
    "label": "KeyFuncsType()",
    "kind": "Method",
    "detail": "Function (KeyFuncs . ~)",
    "insertText": "KeyFuncsType()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&KeyFuncs) KeyFuncsType(MoveTemp(InKeyFuncs))"
  },
  {
    "label": "GetInvalidElement()",
    "kind": "Method",
    "detail": "Function (ElementType InvalidValue = KeyFuncs .)",
    "insertText": "GetInvalidElement()"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (Hash [ Bucket ] . ~)",
    "insertText": "ElementType()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&Hash[Bucket]) ElementType(InvalidValue)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} } } template<ElementType,KeyFuncsType> void TSetKeyFuncs<ElementType,KeyFuncsType)",
    "insertText": "Empty(int32 ExpectedNumElements)"
  },
  {
    "label": "GetTargetHashSize()",
    "kind": "Method",
    "detail": "Function (HashSize =)",
    "insertText": "GetTargetHashSize(static_cast<uint32>(FMath::Max(0,ExpectedNumElements)))"
  },
  {
    "label": "GetTargetHashSize()",
    "kind": "Method",
    "detail": "Function (uint32 NewHashSize =)",
    "insertText": "GetTargetHashSize(static_cast<uint32>(FMath::Max(0, ExpectedNumElements)))"
  },
  {
    "label": "Reallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reallocate(NewHashSize)"
  },
  {
    "label": "Reallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reallocate(TargetHashSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FSetKeyFuncsStats Result ;)",
    "insertText": "if(NumValues == 0)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (Result . AverageSearch = 0 . f ; Result . LongestSearch = 0 ; return Result ; })",
    "insertText": "check(HashSize > 0 && Hash != nullptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32 EnumerateStart = 0 ; uint32 CollisionChainCount = 0 ;)",
    "insertText": "if(!KeyFuncs.IsInvalid(Hash[EnumerateStart]))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (EnumerateStart = HashSize - 1 ; + + CollisionChainCount ;)",
    "insertText": "for(; CollisionChainCount < HashSize; ++CollisionChainCount)"
  },
  {
    "label": "HashSpaceToBucketSpace()",
    "kind": "Method",
    "detail": "Function (EnumerateStart =)",
    "insertText": "HashSpaceToBucketSpace(EnumerateStart + 1)"
  },
  {
    "label": "HashSpaceToBucketSpace()",
    "kind": "Method",
    "detail": "Function (break ; } EnumerateStart =)",
    "insertText": "HashSpaceToBucketSpace(EnumerateStart - 1)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "check(CollisionChainCount < HashSize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Result . LongestSearch = 0 ; uint64 SumOfSearches = 0 ; bool bFirstLoop = true ; uint32 CollisionChainStart ;)",
    "insertText": "for(CollisionChainStart = EnumerateStart; CollisionChainStart != EnumerateStart || bFirstLoop;)"
  },
  {
    "label": "HashSpaceToBucketSpace()",
    "kind": "Method",
    "detail": "Function (CollisionChainStart =)",
    "insertText": "HashSpaceToBucketSpace(CollisionChainStart + 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bFirstLoop = false ; continue ; } uint32 Bucket ;)",
    "insertText": "for(Bucket = CollisionChainStart; Bucket != EnumerateStart || bFirstLoop; Bucket = HashSpaceToBucketSpace(Bucket + 1), bFirstLoop = false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const ElementType& Element = Hash [ Bucket ] ;)",
    "insertText": "if(KeyFuncs.IsInvalid(Element))"
  },
  {
    "label": "HashSpaceToBucketSpace()",
    "kind": "Method",
    "detail": "Function (break ; } uint32 RealBucket =)",
    "insertText": "HashSpaceToBucketSpace(KeyFuncs.GetTypeHash(Element))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 SearchLength = 0 ;)",
    "insertText": "if(CollisionChainStart <= Bucket)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (SearchLength = static_cast<)",
    "insertText": "int32(Bucket - RealBucket + 1)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "check(CollisionChainStart <= RealBucket || RealBucket <= Bucket)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (} else { SearchLength = static_cast<)",
    "insertText": "int32((HashSize - RealBucket) + Bucket + 1)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} } Result . LongestSearch =)",
    "insertText": "Max(Result.LongestSearch, SearchLength)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (SumOfSearches + = SearchLength ; } CollisionChainStart = Bucket ; } Result . AverageSearch = static_cast<)",
    "insertText": "float(SumOfSearches) / static_cast<float>(NumValues)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (uint32 CollisionCount ;)",
    "insertText": "for(CollisionCount = 0; CollisionCount < HashSize; ++CollisionCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; })",
    "insertText": "if(KeyFuncs.Matches(Element, Key))"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(CollisionCount < HashSize)"
  },
  {
    "label": "AddByHash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddByHash(KeyFuncs.GetTypeHash(Value), MoveTemp(Value), bAlreadyExists)"
  },
  {
    "label": "AddByHash()",
    "kind": "Method",
    "detail": "Function (} template<ElementType,KeyFuncsType> void TSetKeyFuncs<ElementType,KeyFuncsType)",
    "insertText": "AddByHash(uint32 TypeHash, ElementType Value, bool* bAlreadyExists)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty(InitialAllocationSize)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(Hash != nullptr && HashSize > 0)"
  },
  {
    "label": "AddByHashNoReallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddByHashNoReallocate(TypeHash, Value, bAlreadyExists)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (float LoadFactor = static_cast<)",
    "insertText": "float(NumValues) / static_cast<float>(HashSize)"
  },
  {
    "label": "Reallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reallocate(GetTargetHashSize())"
  },
  {
    "label": "HashSpaceToBucketSpace()",
    "kind": "Method",
    "detail": "Function (uint32 CollisionChainCount = 0 ; uint32 Bucket =)",
    "insertText": "HashSpaceToBucketSpace(TypeHash)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const ElementType& ExistingElement = Hash [ Bucket ] ;)",
    "insertText": "if(KeyFuncs.IsInvalid(ExistingElement))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } else)",
    "insertText": "if(KeyFuncs.Matches(ExistingElement, Value))"
  },
  {
    "label": "HashSpaceToBucketSpace()",
    "kind": "Method",
    "detail": "Function (* bAlreadyExists = true ; return ; } } Bucket =)",
    "insertText": "HashSpaceToBucketSpace(Bucket + 1)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&Hash[Bucket]) ElementType(MoveTemp(Value))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + NumValues ;)",
    "insertText": "if(bAlreadyExists)"
  },
  {
    "label": "HashSpaceToBucketSpace()",
    "kind": "Method",
    "detail": "Function (uint32 HoleIndex = Bucket ; uint32 CurrentBucket =)",
    "insertText": "HashSpaceToBucketSpace(HoleIndex + 1)"
  },
  {
    "label": "HashSpaceToBucketSpace()",
    "kind": "Method",
    "detail": "Function (break ; } uint32 RealBucket =)",
    "insertText": "HashSpaceToBucketSpace(KeyFuncs.GetTypeHash(ExistingElement))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bPatchTheHole = false ;)",
    "insertText": "if(RealBucket == CurrentBucket)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(RealBucket < CurrentBucket)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bPatchTheHole = RealBucket<= HoleIndex&& HoleIndex<CurrentBucket ; } else { bPatchTheHole = HoleIndex<CurrentBucket | | RealBucket<= HoleIndex ; })",
    "insertText": "if(bPatchTheHole)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&Hash[HoleIndex]) ElementType(MoveTemp(ExistingElement))"
  },
  {
    "label": "HashSpaceToBucketSpace()",
    "kind": "Method",
    "detail": "Function (HoleIndex = CurrentBucket ; } CurrentBucket =)",
    "insertText": "HashSpaceToBucketSpace(CurrentBucket + 1)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&Hash[HoleIndex]) ElementType(KeyFuncs.GetInvalidElement())"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} NumValues = 0 ;)",
    "insertText": "for(uint32 OldBucket = 0; OldBucket < OldHashSize; ++OldBucket)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ElementType& OldElement = OldHash [ OldBucket ] ;)",
    "insertText": "if(!KeyFuncs.IsInvalid(OldElement))"
  },
  {
    "label": "AddByHashNoReallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddByHashNoReallocate(KeyFuncs.GetTypeHash(OldElement), MoveTemp(OldElement), nullptr)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Free(OldHash)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (TargetHashSize =)",
    "insertText": "Max(TargetHashSize, MinimumNonZeroSize)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Free(Hash)"
  },
  {
    "label": "FIterator()",
    "kind": "Method",
    "detail": "Function (Hash = nullptr ; } } template<ElementType,KeyFuncsType> TSetKeyFuncs<ElementType,KeyFuncsType>::)",
    "insertText": "FIterator(const TSetKeyFuncs& InOwner) : Owner(InOwner) , Bucket(0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + Bucket ;)",
    "insertText": "while(Bucket < Owner.HashSize && Owner.KeyFuncs.IsInvalid(Owner.Hash[Bucket]))"
  }
]