[
  {
    "label": "FCbFieldView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCbFieldView"
  },
  {
    "label": "FCbWriter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCbWriter"
  },
  {
    "label": "TIsContiguousContainer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsContiguousContainer"
  },
  {
    "label": "FMemoryImage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMemoryImage"
  },
  {
    "label": "FMemoryImageString",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMemoryImageString"
  },
  {
    "label": "FPointerTableBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPointerTableBase"
  },
  {
    "label": "TMemoryImageObject",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TMemoryImageObject"
  },
  {
    "label": "FMemoryImageVTablePointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMemoryImageVTablePointer"
  },
  {
    "label": "FMemoryImageNamePointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMemoryImageNamePointer"
  },
  {
    "label": "FMemoryImageResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMemoryImageResult"
  },
  {
    "label": "FMemoryImageSection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMemoryImageSection"
  },
  {
    "label": "FSectionPointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSectionPointer"
  },
  {
    "label": "UStruct",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UStruct"
  },
  {
    "label": "FFrozenMemoryImagePtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFrozenMemoryImagePtr"
  },
  {
    "label": "TMemoryImagePtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMemoryImagePtr"
  },
  {
    "label": "TUniqueMemoryImagePtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TUniqueMemoryImagePtr"
  },
  {
    "label": "CORE_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CORE_API"
  },
  {
    "label": "TMemoryImageAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMemoryImageAllocator"
  },
  {
    "label": "ForAnyElementType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ForAnyElementType"
  },
  {
    "label": "ForElementType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ForElementType"
  },
  {
    "label": "TAllocatorTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAllocatorTraits"
  },
  {
    "label": "FHashedNameDebugString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHashedNameDebugString"
  },
  {
    "label": "FHashedName",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FHashedName"
  },
  {
    "label": "FPatchOffset",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPatchOffset"
  },
  {
    "label": "FPatchOffsetList",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPatchOffsetList"
  },
  {
    "label": "TPtrTableBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPtrTableBase"
  },
  {
    "label": "TPtrTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPtrTable"
  },
  {
    "label": "TRefCountPtrTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRefCountPtrTable"
  },
  {
    "label": "FVoidPtrTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVoidPtrTable"
  },
  {
    "label": "TIndexedPtrBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TIndexedPtrBase"
  },
  {
    "label": "TPatchedPtrBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPatchedPtrBase"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / ContainerAllocationPolicies . h \" # include \" Containers / HashTable . h \" # include \" Containers / Map . h \" # include \" Containers / Set . h \" # include \" Containers / UnrealString . h \" # include \" CoreTypes . h \" # include \" HAL / MemoryBase . h \" # include \" HAL / PlatformCrt . h \" # include \" HAL / PlatformString . h \" # include \" HAL / PreprocessorHelpers . h \" # include \" HAL / UnrealMemory . h \" # include \" Math / UnrealMathUtility . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / CString . h \" # include \" Misc / Crc . h \" # include \" Misc / SecureHash . h \" # include \" Serialization / Archive . h \" # include \" Serialization / MemoryImageWriter . h \" # include \" Serialization / MemoryLayout . h \" # include \" Templates / AlignmentTemplates . h \" # include \" Templates / EnableIf . h \" # include \" Templates / RefCounting . h \" # include \" Templates / TypeHash . h \" # include \" Traits / IsCharType . h \" # include \" UObject / NameTypes . h \" class FCbFieldView ; class FCbWriter ; template<T> struct TIsContiguousContainer ; # if)",
    "insertText": "defined(WITH_RTTI) || defined(_CPPRTTI) || defined(__GXX_RTTI)"
  },
  {
    "label": "UE_MEMORYIMAGE_TRACK_TYPE_DEPENDENCIES()",
    "kind": "Method",
    "detail": "Function (class FMemoryImageString ; # define)",
    "insertText": "UE_MEMORYIMAGE_TRACK_TYPE_DEPENDENCIES(WITH_EDITORONLY_DATA)"
  },
  {
    "label": "FPointerTableBase()",
    "kind": "Method",
    "detail": "Function (public : ~)",
    "insertText": "FPointerTableBase()"
  },
  {
    "label": "AddIndexedPointer()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "AddIndexedPointer(const FTypeLayoutDesc& TypeDesc, void* Ptr)"
  },
  {
    "label": "GetIndexedPointer()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "GetIndexedPointer(const FTypeLayoutDesc& TypeDesc, uint32 i)"
  },
  {
    "label": "SaveToArchive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SaveToArchive(FArchive& Ar, const FPlatformTypeLayoutParameters& LayoutParams, const void* FrozenObject)"
  },
  {
    "label": "LoadFromArchive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "LoadFromArchive(FArchive& Ar, const FPlatformTypeLayoutParameters& LayoutParams, void* FrozenObject)"
  },
  {
    "label": "AddTypeDependency()",
    "kind": "Method",
    "detail": "Function (# if UE_MEMORYIMAGE_TRACK_TYPE_DEPENDENCIES int32)",
    "insertText": "AddTypeDependency(const FTypeLayoutDesc& TypeDesc)"
  },
  {
    "label": "GetTypeDependency()",
    "kind": "Method",
    "detail": "Function (const FTypeLayoutDesc*)",
    "insertText": "GetTypeDependency(int32 Index)"
  },
  {
    "label": "TMemoryImageObject()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TMemoryImageObject(const FTypeLayoutDesc& InTypeDesc, T* InObject, uint32 InFrozenSize) : TypeDesc(&InTypeDesc) , Object(InObject) , FrozenSize(InFrozenSize)"
  },
  {
    "label": "TMemoryImageObject()",
    "kind": "Method",
    "detail": "Function (} template<TOther>)",
    "insertText": "TMemoryImageObject(TOther* InObject) : TypeDesc(InObject ? &GetTypeLayoutDesc(nullptr, *InObject) : nullptr) , Object(InObject) , FrozenSize(0u)"
  },
  {
    "label": "TMemoryImageObject()",
    "kind": "Method",
    "detail": "Function (} template<TOther>)",
    "insertText": "TMemoryImageObject(const TMemoryImageObject<TOther>& Rhs) : TypeDesc(Rhs.TypeDesc) , Object(static_cast<T*>(Rhs.Object)) , FrozenSize(Rhs.FrozenSize)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Destroy(const FPointerTableBase* PointerTable)"
  },
  {
    "label": "Freeze()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Freeze(FPointerTableBase* PointerTable)"
  },
  {
    "label": "Unfreeze()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Unfreeze(const FPointerTableBase* PointerTable)"
  },
  {
    "label": "FreezeMemoryImageObject()",
    "kind": "Method",
    "detail": "Function (const FTypeLayoutDesc* TypeDesc ; T* Object ; uint32 FrozenSize ; } ; using FMemoryImageObject = TMemoryImageObject<void> ; FMemoryImageObject)",
    "insertText": "FreezeMemoryImageObject(const void* Object, const FTypeLayoutDesc& TypeDesc, FPointerTableBase* PointerTable)"
  },
  {
    "label": "UnfreezeMemoryImageObject()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "UnfreezeMemoryImageObject(const void* FrozenObject, const FTypeLayoutDesc& TypeDesc, const FPointerTableBase* PointerTable)"
  },
  {
    "label": "InternalDeleteObjectFromLayout()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InternalDeleteObjectFromLayout(Object, *TypeDesc, PointerTable, FrozenSize > 0u)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(Object)"
  },
  {
    "label": "FreezeMemoryImageObject()",
    "kind": "Method",
    "detail": "Function (const FMemoryImageObject FrozenContent =)",
    "insertText": "FreezeMemoryImageObject(Object, *TypeDesc, PointerTable)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy(nullptr)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Object = static_cast<)",
    "insertText": "T(FrozenContent.Object)"
  },
  {
    "label": "UnfreezeMemoryImageObject()",
    "kind": "Method",
    "detail": "Function (void* UnfrozenObject =)",
    "insertText": "UnfreezeMemoryImageObject(Object, *TypeDesc, PointerTable)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy(PointerTable)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Object = static_cast<)",
    "insertText": "T(UnfrozenObject)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FrozenSize = 0 u ; return true ; } return false ; } struct FMemoryImageVTablePointer { uint64 TypeNameHash ; uint32 VTableOffset ; uint32 Offset ; bool)",
    "insertText": "operator(const FMemoryImageVTablePointer& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FMemoryImageNamePointer& Rhs)"
  },
  {
    "label": "SaveToArchive()",
    "kind": "Method",
    "detail": "Function (} return Offset<Rhs . Offset ; } } ; struct FMemoryImageResult { TArray<uint8> Bytes ; FPointerTableBase* PointerTable = nullptr ; FPlatformTypeLayoutParameters TargetLayoutParameters ; TArray<FMemoryImageVTablePointer> VTables ; TArray<FMemoryImageNamePointer> ScriptNames ; TArray<FMemoryImageNamePointer> MemoryImageNames ; void)",
    "insertText": "SaveToArchive(FArchive& Ar)"
  },
  {
    "label": "ApplyPatches()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ApplyPatches(void* FrozenObject, uint64 FrozenObjectSize)"
  },
  {
    "label": "LoadFromArchive()",
    "kind": "Method",
    "detail": "Function (FMemoryImageObject)",
    "insertText": "LoadFromArchive(FArchive& Ar, const FTypeLayoutDesc& TypeDesc, FPointerTableBase* PointerTable, FPlatformTypeLayoutParameters& OutLayoutParameters)"
  },
  {
    "label": "FMemoryImageSection()",
    "kind": "Method",
    "detail": "Function (} ; class FMemoryImageSection : public FRefCountedObject { public : struct FSectionPointer { uint32 SectionIndex ; uint32 PointerOffset ; uint32 Offset ; } ;)",
    "insertText": "FMemoryImageSection(FMemoryImage* InImage) : ParentImage(InImage) , MaxAlignment(1u)"
  },
  {
    "label": "GetOffset()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetOffset()"
  },
  {
    "label": "WriteAlignment()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "WriteAlignment(uint32 Alignment)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const uint32 PrevSize = Bytes .)",
    "insertText": "Num()"
  },
  {
    "label": "Align()",
    "kind": "Method",
    "detail": "Function (const uint32 Offset =)",
    "insertText": "Align(PrevSize, Alignment)"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (Bytes .)",
    "insertText": "SetNumZeroed(Offset)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MaxAlignment =)",
    "insertText": "Max(MaxAlignment, Alignment)"
  },
  {
    "label": "WriteBytes()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "WriteBytes(const void* Data, uint32 Size)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (Bytes .)",
    "insertText": "SetNumUninitialized(Offset + Size)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(Bytes.GetData() + Offset, Data, Size)"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (Bytes .)",
    "insertText": "SetNumZeroed(Offset + Num)"
  },
  {
    "label": "WritePointer()",
    "kind": "Method",
    "detail": "Function (} FMemoryImageSection*)",
    "insertText": "WritePointer(const FTypeLayoutDesc& StaticTypeDesc, const FTypeLayoutDesc& DerivedTypeDesc, uint32* OutOffsetToBase = nullptr)"
  },
  {
    "label": "WriteRawPointerSizedBytes()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "WriteRawPointerSizedBytes(uint64 PointerValue)"
  },
  {
    "label": "WriteVTable()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "WriteVTable(const FTypeLayoutDesc& TypeDesc, const FTypeLayoutDesc& DerivedTypeDesc)"
  },
  {
    "label": "WriteFMemoryImageName()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "WriteFMemoryImageName(int32 NumBytes, const FName& Name)"
  },
  {
    "label": "WriteFScriptName()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "WriteFScriptName(const FScriptName& Name)"
  },
  {
    "label": "Flatten()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "Flatten(FMemoryImageResult& OutResult)"
  },
  {
    "label": "ComputeHash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeHash()"
  },
  {
    "label": "FMemoryImage()",
    "kind": "Method",
    "detail": "Function (FMemoryImage* ParentImage ; TArray<uint8> Bytes ; TArray<FSectionPointer> Pointers ; TArray<FMemoryImageVTablePointer> VTables ; TArray<FMemoryImageNamePointer> ScriptNames ; TArray<FMemoryImageNamePointer> MemoryImageNames ; FSHAHash Hash ; uint32 MaxAlignment ; } ; class FMemoryImage { public :)",
    "insertText": "FMemoryImage() : PointerTable(nullptr) , PrevPointerTable(nullptr) , CurrentStruct(nullptr)"
  },
  {
    "label": "InitializeForCurrent()",
    "kind": "Method",
    "detail": "Function (HostLayoutParameters .)",
    "insertText": "InitializeForCurrent()"
  },
  {
    "label": "GetPointerTable()",
    "kind": "Method",
    "detail": "Function (} FPointerTableBase&)",
    "insertText": "GetPointerTable()"
  },
  {
    "label": "FMemoryImageSection()",
    "kind": "Method",
    "detail": "Function (FMemoryImageSection* Section = new)",
    "insertText": "FMemoryImageSection(this)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Sections .)",
    "insertText": "Add(Section)"
  },
  {
    "label": "bIsFrozenMask()",
    "kind": "Method",
    "detail": "Function (TArray<TRefCountPtr<FMemoryImageSection>> Sections ; FPointerTableBase* PointerTable ; const FPointerTableBase* PrevPointerTable ; FPlatformTypeLayoutParameters HostLayoutParameters ; FPlatformTypeLayoutParameters TargetLayoutParameters ; const class UStruct* CurrentStruct ; } ; struct FFrozenMemoryImagePtr { uint64 bIsFrozenBits = 1 ; uint64 OffsetBits = 4 0 ; uint64 TypeIndexBits = 6 4 - OffsetBits - bIsFrozenBits ; uint64 bIsFrozenShift = 0 ; uint64 TypeIndexShift = bIsFrozenBits ; uint64 OffsetShift = bIsFrozenBits + TypeIndexBits ; uint64)",
    "insertText": "bIsFrozenMask(1ULL << bIsFrozenShift)"
  },
  {
    "label": "TypeIndexMask()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "TypeIndexMask(((1ULL << TypeIndexBits) - 1ULL) << TypeIndexShift)"
  },
  {
    "label": "OffsetMask()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "OffsetMask(((1ULL << OffsetBits) - 1ULL) << OffsetShift)"
  },
  {
    "label": "IsFrozen()",
    "kind": "Method",
    "detail": "Function (uint64 Packed ; bool)",
    "insertText": "IsFrozen()"
  },
  {
    "label": "SetIsFrozen()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetIsFrozen(bool bTrue)"
  },
  {
    "label": "Packed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Packed(Packed & ~bIsFrozenMask) | (bTrue ? 1 : 0)"
  },
  {
    "label": "GetOffsetFromThis()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "GetOffsetFromThis()"
  },
  {
    "label": "SetOffsetFromThis()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetOffsetFromThis(int64 Offset)"
  },
  {
    "label": "Packed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Packed(Packed & ~OffsetMask) | (static_cast<uint64>(Offset << OffsetShift) & OffsetMask)"
  },
  {
    "label": "GetTypeIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetTypeIndex()"
  },
  {
    "label": "SetTypeIndex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetTypeIndex(int32 TypeIndex)"
  },
  {
    "label": "Packed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Packed(Packed & ~TypeIndexMask) | ((static_cast<uint64>(TypeIndex + 1) << TypeIndexShift) & TypeIndexMask)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "static_assert(sizeof(FFrozenMemoryImagePtr) == sizeof(uint64), \"FFrozenMemoryImagePtr is larger than a native pointer would be\")"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "TMemoryImagePtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TMemoryImagePtr(const TMemoryImagePtr<T>& InPtr) : UnfrozenPtr(InPtr.Get())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TMemoryImagePtr&)",
    "insertText": "operator(T* InPtr)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (UnfrozenPtr = InPtr ;)",
    "insertText": "check(!Frozen.IsFrozen())"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (UnfrozenPtr = InPtr .)",
    "insertText": "Get()"
  },
  {
    "label": "GetFrozenOffsetFromThis()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "GetFrozenOffsetFromThis()"
  },
  {
    "label": "GetFrozenTypeIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetFrozenTypeIndex()"
  },
  {
    "label": "GetChecked()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "GetChecked()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "operator()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "T()"
  },
  {
    "label": "SafeDelete()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SafeDelete(const FPointerTableBase* PtrTable = nullptr)"
  },
  {
    "label": "DeleteObjectFromLayout()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeleteObjectFromLayout(RawPtr, PtrTable, IsFrozen())"
  },
  {
    "label": "WriteMemoryImageWithDerivedType()",
    "kind": "Method",
    "detail": "Function (UnfrozenPtr = nullptr ; } } void)",
    "insertText": "WriteMemoryImageWithDerivedType(FMemoryImageWriter& Writer, const FTypeLayoutDesc* DerivedTypeDesc)"
  },
  {
    "label": "WritePointer()",
    "kind": "Method",
    "detail": "Function (uint32 OffsetToBase = 0 u ; FMemoryImageWriter PointerWriter = Writer .)",
    "insertText": "WritePointer(StaticGetTypeLayoutDesc<T>(), *DerivedTypeDesc, &OffsetToBase)"
  },
  {
    "label": "WriteObject()",
    "kind": "Method",
    "detail": "Function (PointerWriter .)",
    "insertText": "WriteObject((uint8*)RawPtr - OffsetToBase, *DerivedTypeDesc)"
  },
  {
    "label": "WriteNullPointer()",
    "kind": "Method",
    "detail": "Function (} else { Writer .)",
    "insertText": "WriteNullPointer()"
  },
  {
    "label": "GetFrozenPtrInternal()",
    "kind": "Method",
    "detail": "Function (} } private : T*)",
    "insertText": "GetFrozenPtrInternal()"
  },
  {
    "label": "IntrinsicWriteMemoryImage()",
    "kind": "Method",
    "detail": "Function (} protected : union { uint64 Packed ; FFrozenMemoryImagePtr Frozen ; T* UnfrozenPtr ; } ; } ; namespace Freeze { template<T> void)",
    "insertText": "IntrinsicWriteMemoryImage(FMemoryImageWriter& Writer, const TMemoryImagePtr<T>& Object, const FTypeLayoutDesc&)"
  },
  {
    "label": "GetTypeLayoutDesc()",
    "kind": "Method",
    "detail": "Function (const FTypeLayoutDesc& DerivedTypeDesc =)",
    "insertText": "GetTypeLayoutDesc(Writer.TryGetPrevPointerTable(), *RawPtr)"
  },
  {
    "label": "WritePointer()",
    "kind": "Method",
    "detail": "Function (uint32 OffsetToBase = 0 u ; FMemoryImageWriter PointerWriter = Writer .)",
    "insertText": "WritePointer(StaticGetTypeLayoutDesc<T>(), DerivedTypeDesc, &OffsetToBase)"
  },
  {
    "label": "WriteObject()",
    "kind": "Method",
    "detail": "Function (PointerWriter .)",
    "insertText": "WriteObject((uint8*)RawPtr - OffsetToBase, DerivedTypeDesc)"
  },
  {
    "label": "IntrinsicUnfrozenCopy()",
    "kind": "Method",
    "detail": "Function (} } template<T> uint32)",
    "insertText": "IntrinsicUnfrozenCopy(const FMemoryUnfreezeContent& Context, const TMemoryImagePtr<T>& Object, void* OutDst)"
  },
  {
    "label": "GetDerivedTypeDesc()",
    "kind": "Method",
    "detail": "Function (const FTypeLayoutDesc* DerivedTypeDesc = Context .)",
    "insertText": "GetDerivedTypeDesc(StaticTypeDesc, Object.GetFrozenTypeIndex())"
  },
  {
    "label": "GetTypeLayoutDesc()",
    "kind": "Method",
    "detail": "Function (DerivedTypeDesc =&)",
    "insertText": "GetTypeLayoutDesc(Context.PrevPointerTable, *RawPtr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(DerivedTypeDesc)"
  },
  {
    "label": "GetOffsetToBase()",
    "kind": "Method",
    "detail": "Function (const uint32 OffsetToBase = DerivedTypeDesc ->)",
    "insertText": "GetOffsetToBase(StaticTypeDesc)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void* UnfrozenMemory =::operator)",
    "insertText": "new(DerivedTypeDesc->Size)"
  },
  {
    "label": "UnfreezeObject()",
    "kind": "Method",
    "detail": "Function (Context .)",
    "insertText": "UnfreezeObject((uint8*)RawPtr - OffsetToBase, *DerivedTypeDesc, UnfrozenMemory)"
  },
  {
    "label": "UnfrozenObject()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "UnfrozenObject(T*)((uint8*)UnfrozenMemory + OffsetToBase)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(OutDst) TMemoryImagePtr<T>(UnfrozenObject)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "new(OutDst) TMemoryImagePtr<T>(nullptr)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "sizeof(Object)"
  },
  {
    "label": "IntrinsicAppendHash()",
    "kind": "Method",
    "detail": "Function (} template<T> uint32)",
    "insertText": "IntrinsicAppendHash(const TMemoryImagePtr<T>* DummyObject, const FTypeLayoutDesc& TypeDesc, const FPlatformTypeLayoutParameters& LayoutParams, FSHA1& Hasher)"
  },
  {
    "label": "IntrinsicGetTargetAlignment()",
    "kind": "Method",
    "detail": "Function (} template<T> uint32)",
    "insertText": "IntrinsicGetTargetAlignment(const TMemoryImagePtr<T>* DummyObject, const FTypeLayoutDesc& TypeDesc, const FPlatformTypeLayoutParameters& LayoutParams)"
  },
  {
    "label": "IntrinsicToString()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "IntrinsicToString(const TMemoryImagePtr<T>& Object, const FTypeLayoutDesc& TypeDesc, const FPlatformTypeLayoutParameters& LayoutParams, FMemoryToStringContext& OutContext)"
  },
  {
    "label": "GetTypeLayoutDesc()",
    "kind": "Method",
    "detail": "Function (const FTypeLayoutDesc& DerivedTypeDesc =)",
    "insertText": "GetTypeLayoutDesc(OutContext.TryGetPrevPointerTable(), *RawPtr)"
  },
  {
    "label": "AppendFrozenPointer()",
    "kind": "Method",
    "detail": "Function (OutContext .)",
    "insertText": "AppendFrozenPointer(StaticTypeDesc, Object.GetFrozenTypeIndex())"
  },
  {
    "label": "AppendUnfrozenPointer()",
    "kind": "Method",
    "detail": "Function (} else { OutContext .)",
    "insertText": "AppendUnfrozenPointer(StaticTypeDesc)"
  },
  {
    "label": "ToStringFunc()",
    "kind": "Method",
    "detail": "Function (} DerivedTypeDesc .)",
    "insertText": "ToStringFunc((uint8*)RawPtr - OffsetToBase, DerivedTypeDesc, LayoutParams, OutContext)"
  },
  {
    "label": "AppendNullptr()",
    "kind": "Method",
    "detail": "Function (} else { OutContext .)",
    "insertText": "AppendNullptr()"
  },
  {
    "label": "DECLARE_TEMPLATE_INTRINSIC_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "DECLARE_TEMPLATE_INTRINSIC_TYPE_LAYOUT(template<typename T>, TMemoryImagePtr<T>)"
  },
  {
    "label": "TUniqueMemoryImagePtr()",
    "kind": "Method",
    "detail": "Function (template<T> class TUniqueMemoryImagePtr : public TMemoryImagePtr<T> { public :)",
    "insertText": "TUniqueMemoryImagePtr() : TMemoryImagePtr<T>(nullptr)"
  },
  {
    "label": "TUniqueMemoryImagePtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TUniqueMemoryImagePtr(T* InPtr) : TMemoryImagePtr<T>(InPtr)"
  },
  {
    "label": "TUniqueMemoryImagePtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TUniqueMemoryImagePtr(TUniqueMemoryImagePtr&& Other)"
  },
  {
    "label": "SafeDelete()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "SafeDelete()"
  },
  {
    "label": "TUniqueMemoryImagePtr()",
    "kind": "Method",
    "detail": "Function (this -> Ptr = Other . Ptr ; Other . Ptr = nullptr ; } ~)",
    "insertText": "TUniqueMemoryImagePtr()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this -> Ptr = InPtr ; return* this ; } TUniqueMemoryImagePtr&)",
    "insertText": "operator(TUniqueMemoryImagePtr&& Other)"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (this -> Ptr = Other . Ptr ; Other . Ptr = nullptr ; } return* this ; } } ; class FMemoryImageAllocatorBase {)",
    "insertText": "UE_NONCOPYABLE(FMemoryImageAllocatorBase)"
  },
  {
    "label": "FMemoryImageAllocatorBase()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FMemoryImageAllocatorBase()"
  },
  {
    "label": "MoveToEmpty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MoveToEmpty(FMemoryImageAllocatorBase& Other)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetAllocatedSize(int32 CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ResizeAllocation(int32 PreviousNumElements, int32 NumElements, SIZE_T NumBytesPerElement, uint32 Alignment)"
  },
  {
    "label": "WriteMemoryImage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteMemoryImage(FMemoryImageWriter& Writer, const FTypeLayoutDesc& TypeDesc, int32 NumAllocatedElements, uint32 Alignment)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ToString(const FTypeLayoutDesc& TypeDesc, int32 NumAllocatedElements, int32 MaxAllocatedElements, const FPlatformTypeLayoutParameters& LayoutParams, FMemoryToStringContext& OutContext)"
  },
  {
    "label": "CopyUnfrozen()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyUnfrozen(const FMemoryUnfreezeContent& Context, const FTypeLayoutDesc& TypeDesc, int32 NumAllocatedElements, void* Dst)"
  },
  {
    "label": "ForAnyElementType()",
    "kind": "Method",
    "detail": "Function (private : TMemoryImagePtr<FScriptContainerElement> Data ; } ; template<uint32 Alignment = DEFAULT_ALIGNMENT> class TMemoryImageAllocator { public : using SizeType = int32 ; enum { NeedsElementType = false } ; enum { RequireRangeCheck = true } ; enum { SupportsFreezeMemoryImage = true } ; class ForAnyElementType : public FMemoryImageAllocatorBase { public :)",
    "insertText": "ForAnyElementType()"
  },
  {
    "label": "CalculateSlackReserve()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "CalculateSlackReserve(int32 NewMax, int32 NumBytesPerElement, uint32 AlignmentOfElement)"
  },
  {
    "label": "CalculateSlackShrink()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "CalculateSlackShrink(int32 NewMax, int32 CurrentMax, int32 NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackShrink()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "CalculateSlackShrink(int32 NewMax, int32 CurrentMax, int32 NumBytesPerElement, uint32 AlignmentOfElement)"
  },
  {
    "label": "CalculateSlackGrow()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "CalculateSlackGrow(int32 NewMax, int32 CurrentMax, int32 NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackGrow()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "CalculateSlackGrow(int32 NewMax, int32 CurrentMax, int32 NumBytesPerElement, uint32 AlignmentOfElement)"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ResizeAllocation(int32 CurrentNum, int32 NewMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeAllocation(CurrentNum, NewMax, NumBytesPerElement, Alignment)"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ResizeAllocation(int32 CurrentNum, int32 NewMax, SIZE_T NumBytesPerElement, uint32 AlignmentOfElement)"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeAllocation(CurrentNum, NewMax, NumBytesPerElement, AlignmentOfElement)"
  },
  {
    "label": "WriteMemoryImage()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "WriteMemoryImage(FMemoryImageWriter& Writer, const FTypeLayoutDesc& TypeDesc, int32 NumAllocatedElements)"
  },
  {
    "label": "WriteMemoryImage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteMemoryImage(Writer, TypeDesc, NumAllocatedElements, Alignment)"
  },
  {
    "label": "ForElementType()",
    "kind": "Method",
    "detail": "Function (} } ; template<ElementType> class ForElementType : public ForAnyElementType { public :)",
    "insertText": "ForElementType()"
  },
  {
    "label": "GetAllocation()",
    "kind": "Method",
    "detail": "Function (} ElementType*)",
    "insertText": "GetAllocation()"
  },
  {
    "label": "DECLARE_EXPORTED_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (} } ; } ; template<uint32 Alignment> struct TAllocatorTraits<TMemoryImageAllocator<Alignment>> : TAllocatorTraitsBase<TMemoryImageAllocator<Alignment>> { enum { IsZeroConstruct = true } ; enum { SupportsFreezeMemoryImage = true } ; enum { SupportsElementAlignment = true } ; } ; using FMemoryImageAllocator = TMemoryImageAllocator<> ; using FMemoryImageSparseArrayAllocator = TSparseArrayAllocator<FMemoryImageAllocator,FMemoryImageAllocator> ; using FMemoryImageSetAllocator = TSetAllocator<FMemoryImageSparseArrayAllocator,FMemoryImageAllocator> ; template<T> using TMemoryImageArray = TArray<T,FMemoryImageAllocator> ; template<ElementType,KeyFuncs = DefaultKeyFuncs<ElementType>> using TMemoryImageSet = TSet<ElementType,KeyFuncs,FMemoryImageSetAllocator> ; template<KeyType,ValueType,KeyFuncs = TDefaultMapHashableKeyFuncs<KeyType,ValueType,false>> using TMemoryImageMap = TMap<KeyType,ValueType,FMemoryImageSetAllocator,KeyFuncs> ; template<> struct TIsContiguousContainer<FMemoryImageString> { bool Value = true ; } ; class FMemoryImageString {)",
    "insertText": "DECLARE_EXPORTED_TYPE_LAYOUT(FMemoryImageString, CORE_API, NonVirtual)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (private : using DataType = TMemoryImageArray<TCHAR> ;)",
    "insertText": "LAYOUT_FIELD(DataType, Data)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ToString(FMemoryToStringContext& OutContext)"
  },
  {
    "label": "LAYOUT_TOSTRING()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_TOSTRING(ToString)"
  },
  {
    "label": "FMemoryImageString()",
    "kind": "Method",
    "detail": "Function (public : using ElementType = TCHAR ;)",
    "insertText": "FMemoryImageString()"
  },
  {
    "label": "FMemoryImageString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FMemoryImageString(FMemoryImageString&&)"
  },
  {
    "label": "FMemoryImageString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FMemoryImageString(const FMemoryImageString&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FMemoryImageString&)",
    "insertText": "operator(FMemoryImageString&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FMemoryImageString&)",
    "insertText": "operator(const FMemoryImageString&)"
  },
  {
    "label": "FMemoryImageString()",
    "kind": "Method",
    "detail": "Function (} template<CharType,= TEnableIf<TIsCharType<CharType>::Value>::Type>)",
    "insertText": "FMemoryImageString(const CharType* Src)"
  },
  {
    "label": "Strlen()",
    "kind": "Method",
    "detail": "Function (int32 SrcLen = TCString<CharType)",
    "insertText": "Strlen(Src)"
  },
  {
    "label": "TCHAR()",
    "kind": "Method",
    "detail": "Function (int32 DestLen = FPlatformString::ConvertedLength<)",
    "insertText": "TCHAR(Src, SrcLen)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "AddUninitialized(DestLen)"
  },
  {
    "label": "Convert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Convert(Data.GetData(), DestLen, Src, SrcLen)"
  },
  {
    "label": "FString()",
    "kind": "Method",
    "detail": "Function (} } operator)",
    "insertText": "FString()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "Len()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Len()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} const TCHAR*)",
    "insertText": "GetData(const FMemoryImageString& String)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FArchive&)",
    "insertText": "operator(FArchive& Ar, FMemoryImageString& Ref)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ar<<Ref . Data ; return Ar ; } bool)",
    "insertText": "operator(const FMemoryImageString& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FString& Rhs)"
  },
  {
    "label": "GetAllocatorInstance()",
    "kind": "Method",
    "detail": "Function (} DataType::ElementAllocatorType&)",
    "insertText": "GetAllocatorInstance()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(const FMemoryImageString& S)"
  },
  {
    "label": "IntrinsicWriteMemoryImage()",
    "kind": "Method",
    "detail": "Function (} } ; # if WITH_EDITORONLY_DATA struct FHashedNameDebugString { TMemoryImagePtr<const char> String ; } ; namespace Freeze { void)",
    "insertText": "IntrinsicWriteMemoryImage(FMemoryImageWriter& Writer, const FHashedNameDebugString& Object, const FTypeLayoutDesc&)"
  },
  {
    "label": "IntrinsicUnfrozenCopy()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "IntrinsicUnfrozenCopy(const FMemoryUnfreezeContent& Context, const FHashedNameDebugString& Object, void* OutDst)"
  },
  {
    "label": "DECLARE_INTRINSIC_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DECLARE_INTRINSIC_TYPE_LAYOUT(FHashedNameDebugString)"
  },
  {
    "label": "DECLARE_EXPORTED_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (# endif class FHashedName {)",
    "insertText": "DECLARE_EXPORTED_TYPE_LAYOUT(FHashedName, CORE_API, NonVirtual)"
  },
  {
    "label": "FHashedName()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FHashedName() : Hash(0u)"
  },
  {
    "label": "FHashedName()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FHashedName(uint64 InHash)"
  },
  {
    "label": "FHashedName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FHashedName(const FHashedName& InName)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FHashedName&)",
    "insertText": "operator(const FHashedName& InName)"
  },
  {
    "label": "FHashedName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FHashedName(const TCHAR* InString)"
  },
  {
    "label": "FHashedName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FHashedName(const FString& InString)"
  },
  {
    "label": "FHashedName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FHashedName(const FName& InName)"
  },
  {
    "label": "GetHash()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "GetHash()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (Ar<<String . Hash ; return Ar ; } uint32)",
    "insertText": "GetTypeHash(const FHashedName& Name)"
  },
  {
    "label": "LAYOUT_FIELD()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "LAYOUT_FIELD(uint64, Hash)"
  },
  {
    "label": "LAYOUT_FIELD_EDITORONLY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LAYOUT_FIELD_EDITORONLY(FHashedNameDebugString, DebugString)"
  },
  {
    "label": "Save()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR void)",
    "insertText": "Save(FCbWriter& Writer)"
  },
  {
    "label": "TryLoad()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryLoad(FCbFieldView Field)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FCbWriter&)",
    "insertText": "operator(FCbWriter& Writer, const FHashedName& Value)"
  },
  {
    "label": "Save()",
    "kind": "Method",
    "detail": "Function (Value .)",
    "insertText": "Save(Writer)"
  },
  {
    "label": "IntrinsicToString()",
    "kind": "Method",
    "detail": "Function (# endif } ; namespace Freeze { void)",
    "insertText": "IntrinsicToString(const FHashedName& Object, const FTypeLayoutDesc& TypeDesc, const FPlatformTypeLayoutParameters& LayoutParams, FMemoryToStringContext& OutContext)"
  },
  {
    "label": "LoadAndApplyPatchesFromArchive()",
    "kind": "Method",
    "detail": "Function (} class FPtrTableBase { public : template<PtrType> void)",
    "insertText": "LoadAndApplyPatchesFromArchive(FArchive& Ar, void* FrozenBase, const PtrType& Ptr)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 NumOffsets = 0 ; Ar<<NumOffsets ;)",
    "insertText": "for(int32 OffsetIndex = 0; OffsetIndex < NumOffsets; ++OffsetIndex)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (uint32 Offset = 0 u ; Ar<<Offset ;)",
    "insertText": "new((char*)FrozenBase + Offset) PtrType(Ptr)"
  },
  {
    "label": "SavePatchesToArchive()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SavePatchesToArchive(FArchive& Ar, uint32 PtrIndex)"
  },
  {
    "label": "FPatchOffsetList()",
    "kind": "Method",
    "detail": "Function (protected : struct FPatchOffset { uint32 Offset ; uint32 NextIndex ; } ; struct FPatchOffsetList {)",
    "insertText": "FPatchOffsetList() : FirstIndex(~0u), NumOffsets(0u)"
  },
  {
    "label": "AddPatchedPointerBase()",
    "kind": "Method",
    "detail": "Function (} uint32 FirstIndex ; uint32 NumOffsets ; } ; void)",
    "insertText": "AddPatchedPointerBase(uint32 PtrIndex, uint64 Offset)"
  },
  {
    "label": "StaticGetPtrTypeLayoutDesc()",
    "kind": "Method",
    "detail": "Function (TArray<FPatchOffsetList> PatchLists ; TArray<FPatchOffset> PatchOffsets ; } ; template<T,PtrType> class TPtrTableBase : public FPtrTableBase { public : const FTypeLayoutDesc&)",
    "insertText": "StaticGetPtrTypeLayoutDesc()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty(int32 NewSize = 0)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (Pointers .)",
    "insertText": "Reset(NewSize)"
  },
  {
    "label": "AddIndexedPointer()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "AddIndexedPointer(T* Ptr)"
  },
  {
    "label": "TryAddIndexedPtr()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "TryAddIndexedPtr(const FTypeLayoutDesc& TypeDesc, void* Ptr, int32& OutIndex)"
  },
  {
    "label": "AddIndexedPointer()",
    "kind": "Method",
    "detail": "Function (OutIndex =)",
    "insertText": "AddIndexedPointer(static_cast<T*>(Ptr))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Pointers .)",
    "insertText": "Add(Ptr)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { Pointers .)",
    "insertText": "Add(nullptr)"
  },
  {
    "label": "AddPatchedPointer()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "AddPatchedPointer(T* Ptr, uint64 Offset)"
  },
  {
    "label": "AddIndexedPointer()",
    "kind": "Method",
    "detail": "Function (const uint32 PtrIndex =)",
    "insertText": "AddIndexedPointer(Ptr)"
  },
  {
    "label": "AddPatchedPointerBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddPatchedPointerBase(PtrIndex, Offset)"
  },
  {
    "label": "GetIndexedPointer()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "GetIndexedPointer(uint32 i)"
  },
  {
    "label": "GetIndexedPointer()",
    "kind": "Method",
    "detail": "Function (OutPtr =)",
    "insertText": "GetIndexedPointer(i)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (uint32 PatchIndex = PatchLists [ PtrIndex ] . FirstIndex ;)",
    "insertText": "while(PatchIndex != ~0u)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (const FPatchOffset& Patch = PatchOffsets [ PatchIndex ] ;)",
    "insertText": "new((char*)FrozenBase + Patch.Offset) PtrType(Pointers[PtrIndex])"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (PatchIndex = Patch . NextIndex ; } } } TArray<PtrType>::RangedForIteratorType)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} TArray<PtrType>::RangedForIteratorType)",
    "insertText": "end()"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (} private : TArray<PtrType> Pointers ; } ; template<T> class TPtrTable : public TPtrTableBase<T,T*> { } ; template<T> class TRefCountPtrTable : public TPtrTableBase<T,TRefCountPtr<T>> { using Super = TPtrTableBase<T,TRefCountPtr<T>> ; } ; class FVoidPtrTable : public TPtrTableBase<void,void*> { } ; # ifdef _MSC_VER # pragma)",
    "insertText": "warning(push) #pragma warning(disable : 4583)"
  },
  {
    "label": "TIndexedPtrBase()",
    "kind": "Method",
    "detail": "Function (public : using FPtrTable = TPtrTableBase<T,PtrType> ;)",
    "insertText": "TIndexedPtrBase(T* InPtr = nullptr) : Ptr(InPtr)"
  },
  {
    "label": "TIndexedPtrBase()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TIndexedPtrBase()"
  },
  {
    "label": "TIndexedPtrBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TIndexedPtrBase(const TIndexedPtrBase<T, PtrType>& Rhs) : Ptr(Rhs.GetUnfrozen())"
  },
  {
    "label": "TIndexedPtrBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TIndexedPtrBase(const TIndexedPtrBase<T, PtrType>& Rhs, const FPtrTable& InTable) : Ptr(Rhs.Get(InTable))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TIndexedPtrBase&)",
    "insertText": "operator(T* Rhs)"
  },
  {
    "label": "SafeReleaseImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SafeReleaseImpl(Ptr)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} } T*)",
    "insertText": "Get(const FPtrTable& PtrTable)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} return Ptr ; } T*)",
    "insertText": "Get(const FPointerTableBase* PtrTable)"
  },
  {
    "label": "PtrType()",
    "kind": "Method",
    "detail": "Function (const FTypeLayoutDesc& TypeDesc = StaticGetTypeLayoutDesc<TIndexedPtrBase<T,)",
    "insertText": "PtrType()"
  },
  {
    "label": "GetUnfrozen()",
    "kind": "Method",
    "detail": "Function (} return Ptr ; } T*)",
    "insertText": "GetUnfrozen()"
  },
  {
    "label": "SafeReleaseImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SafeReleaseImpl(T*& InPtr)"
  },
  {
    "label": "SafeReleaseImpl()",
    "kind": "Method",
    "detail": "Function (delete InPtr ; InPtr = nullptr ; } } void)",
    "insertText": "SafeReleaseImpl(TRefCountPtr<T>& InPtr)"
  },
  {
    "label": "SafeRelease()",
    "kind": "Method",
    "detail": "Function (InPtr .)",
    "insertText": "SafeRelease()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "static_assert(sizeof(PtrType) <= sizeof(uint64), \"PtrType must fit within a standard pointer\")"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (union { PtrType Ptr ; uint64 PackedIndex ; } ; } ; # ifdef _MSC_VER # pragma)",
    "insertText": "warning(pop) #endif template<typename T, typename PtrType> inline const FTypeLayoutDesc& TPtrTableBase<T, PtrType>::StaticGetPtrTypeLayoutDesc()"
  },
  {
    "label": "IntrinsicWriteMemoryImage()",
    "kind": "Method",
    "detail": "Function (} namespace Freeze { template<T,PtrType> void)",
    "insertText": "IntrinsicWriteMemoryImage(FMemoryImageWriter& Writer, const TIndexedPtrBase<T, PtrType>& Object, const FTypeLayoutDesc& TypeDesc)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (T* RawPtr = Object .)",
    "insertText": "Get(Writer.TryGetPrevPointerTable())"
  },
  {
    "label": "GetPointerTable()",
    "kind": "Method",
    "detail": "Function (const uint32 Index = Writer .)",
    "insertText": "GetPointerTable().AddIndexedPointer(TypeDesc, RawPtr)"
  },
  {
    "label": "FrozenPackedIndex()",
    "kind": "Method",
    "detail": "Function (const uint64)",
    "insertText": "FrozenPackedIndex((uint64)Index << 1u)"
  },
  {
    "label": "WriteBytes()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteBytes(FrozenPackedIndex)"
  },
  {
    "label": "WriteBytes()",
    "kind": "Method",
    "detail": "Function (} else { Writer .)",
    "insertText": "WriteBytes(uint64(0u))"
  },
  {
    "label": "IntrinsicUnfrozenCopy()",
    "kind": "Method",
    "detail": "Function (} } template<T,PtrType> uint32)",
    "insertText": "IntrinsicUnfrozenCopy(const FMemoryUnfreezeContent& Context, const TIndexedPtrBase<T, PtrType>& Object, void* OutDst)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(OutDst) TIndexedPtrBase<T, PtrType>(Object.Get(Context.TryGetPrevPointerTable()))"
  },
  {
    "label": "IntrinsicAppendHash()",
    "kind": "Method",
    "detail": "Function (} template<T,PtrType> uint32)",
    "insertText": "IntrinsicAppendHash(const TIndexedPtrBase<T, PtrType>* DummyObject, const FTypeLayoutDesc& TypeDesc, const FPlatformTypeLayoutParameters& LayoutParams, FSHA1& Hasher)"
  },
  {
    "label": "IntrinsicGetTargetAlignment()",
    "kind": "Method",
    "detail": "Function (} template<T,PtrType> uint32)",
    "insertText": "IntrinsicGetTargetAlignment(const TIndexedPtrBase<T, PtrType>* DummyObject, const FTypeLayoutDesc& TypeDesc, const FPlatformTypeLayoutParameters& LayoutParams)"
  },
  {
    "label": "TPatchedPtrBase()",
    "kind": "Method",
    "detail": "Function (} } template<T> using TIndexedPtr = TIndexedPtrBase<T,T*> ; template<T> using TIndexedRefCountPtr = TIndexedPtrBase<T,TRefCountPtr<T>> ; template<T,PtrType> class TPatchedPtrBase { public : using FPtrTable = TPtrTableBase<T,PtrType> ;)",
    "insertText": "TPatchedPtrBase(T* InPtr = nullptr) : Ptr(InPtr)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "static_assert(sizeof(PtrType) == sizeof(void*), \"PtrType must be a standard pointer\")"
  }
]