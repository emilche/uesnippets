[
  {
    "label": "BucketIndexLookup",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BucketIndexLookup"
  },
  {
    "label": "OrderIndexShift()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_BUCKET_LOOKUP_H_ # define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_BUCKET_LOOKUP_H_ # include<cstdint> # include \" base / allocator / partition_allocator / partition_alloc_base / bits . h \" # include \" base / allocator / partition_allocator / partition_alloc_base / compiler_specific . h \" # include \" base / allocator / partition_allocator / partition_alloc_check . h \" # include \" base / allocator / partition_allocator / partition_alloc_config . h \" # include \" base / allocator / partition_allocator / partition_alloc_constants . h \" namespace partition_alloc::internal { uint8_t)",
    "insertText": "OrderIndexShift(uint8_t order)"
  },
  {
    "label": "OrderSubIndexMask()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "OrderSubIndexMask(uint8_t order)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(PA_HAS_64_BITS_POINTERS) #define PA_BITS_PER_SIZE_T 64 static_assert(kBitsPerSizeT == 64, \"\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# else # define PA_BITS_PER_SIZE_T 3 2)",
    "insertText": "static_assert(kBitsPerSizeT == 32, \"\")"
  },
  {
    "label": "OrderIndexShift()",
    "kind": "Method",
    "detail": "Function (# endif uint8_t kOrderIndexShift [ PA_BITS_PER_SIZE_T + 1 ] = {)",
    "insertText": "OrderIndexShift(0), OrderIndexShift(1), OrderIndexShift(2), OrderIndexShift(3), OrderIndexShift(4), OrderIndexShift(5), OrderIndexShift(6), OrderIndexShift(7), OrderIndexShift(8), OrderIndexShift(9), OrderIndexShift(10), OrderIndexShift(11), OrderIndexShift(12), OrderIndexShift(13), OrderIndexShift(14), OrderIndexShift(15), OrderIndexShift(16), OrderIndexShift(17), OrderIndexShift(18), OrderIndexShift(19), OrderIndexShift(20), OrderIndexShift(21), OrderIndexShift(22), OrderIndexShift(23), OrderIndexShift(24), OrderIndexShift(25), OrderIndexShift(26), OrderIndexShift(27), OrderIndexShift(28), OrderIndexShift(29), OrderIndexShift(30), OrderIndexShift(31), OrderIndexShift(32), #if PA_BITS_PER_SIZE_T == 64 OrderIndexShift(33), OrderIndexShift(34), OrderIndexShift(35), OrderIndexShift(36), OrderIndexShift(37), OrderIndexShift(38), OrderIndexShift(39), OrderIndexShift(40), OrderIndexShift(41), OrderIndexShift(42), OrderIndexShift(43), OrderIndexShift(44), OrderIndexShift(45), OrderIndexShift(46), OrderIndexShift(47), OrderIndexShift(48), OrderIndexShift(49), OrderIndexShift(50), OrderIndexShift(51), OrderIndexShift(52), OrderIndexShift(53), OrderIndexShift(54), OrderIndexShift(55), OrderIndexShift(56), OrderIndexShift(57), OrderIndexShift(58), OrderIndexShift(59), OrderIndexShift(60), OrderIndexShift(61), OrderIndexShift(62), OrderIndexShift(63), OrderIndexShift(64)"
  },
  {
    "label": "OrderSubIndexMask()",
    "kind": "Method",
    "detail": "Function (size_t kOrderSubIndexMask [ PA_BITS_PER_SIZE_T + 1 ] = {)",
    "insertText": "OrderSubIndexMask(0), OrderSubIndexMask(1), OrderSubIndexMask(2), OrderSubIndexMask(3), OrderSubIndexMask(4), OrderSubIndexMask(5), OrderSubIndexMask(6), OrderSubIndexMask(7), OrderSubIndexMask(8), OrderSubIndexMask(9), OrderSubIndexMask(10), OrderSubIndexMask(11), OrderSubIndexMask(12), OrderSubIndexMask(13), OrderSubIndexMask(14), OrderSubIndexMask(15), OrderSubIndexMask(16), OrderSubIndexMask(17), OrderSubIndexMask(18), OrderSubIndexMask(19), OrderSubIndexMask(20), OrderSubIndexMask(21), OrderSubIndexMask(22), OrderSubIndexMask(23), OrderSubIndexMask(24), OrderSubIndexMask(25), OrderSubIndexMask(26), OrderSubIndexMask(27), OrderSubIndexMask(28), OrderSubIndexMask(29), OrderSubIndexMask(30), OrderSubIndexMask(31), OrderSubIndexMask(32), #if PA_BITS_PER_SIZE_T == 64 OrderSubIndexMask(33), OrderSubIndexMask(34), OrderSubIndexMask(35), OrderSubIndexMask(36), OrderSubIndexMask(37), OrderSubIndexMask(38), OrderSubIndexMask(39), OrderSubIndexMask(40), OrderSubIndexMask(41), OrderSubIndexMask(42), OrderSubIndexMask(43), OrderSubIndexMask(44), OrderSubIndexMask(45), OrderSubIndexMask(46), OrderSubIndexMask(47), OrderSubIndexMask(48), OrderSubIndexMask(49), OrderSubIndexMask(50), OrderSubIndexMask(51), OrderSubIndexMask(52), OrderSubIndexMask(53), OrderSubIndexMask(54), OrderSubIndexMask(55), OrderSubIndexMask(56), OrderSubIndexMask(57), OrderSubIndexMask(58), OrderSubIndexMask(59), OrderSubIndexMask(60), OrderSubIndexMask(61), OrderSubIndexMask(62), OrderSubIndexMask(63), OrderSubIndexMask(64)"
  },
  {
    "label": "GetIndexForDenserBuckets()",
    "kind": "Method",
    "detail": "Function (class BucketIndexLookup final { public : PA_ALWAYS_INLINE uint16_t)",
    "insertText": "GetIndexForDenserBuckets(size_t size)"
  },
  {
    "label": "GetIndexFor8Buckets()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE uint16_t)",
    "insertText": "GetIndexFor8Buckets(size_t size)"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE uint16_t)",
    "insertText": "GetIndex(size_t size)"
  },
  {
    "label": "BucketIndexLookup()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BucketIndexLookup()"
  },
  {
    "label": "InitBucketSizes()",
    "kind": "Method",
    "detail": "Function (uint16_t sentinel_bucket_index = kNumBuckets ;)",
    "insertText": "InitBucketSizes()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (uint16_t* bucket_index_ptr =& bucket_index_lookup_ [ 0 ] ; uint16_t bucket_index = 0 ;)",
    "insertText": "for(uint8_t order = 0; order < kMinBucketedOrder; ++order)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (* bucket_index_ptr + + = 0 ; } })",
    "insertText": "for(uint8_t order = kMinBucketedOrder; order <= kMaxBucketedOrder; ++order)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t size = static_cast<)",
    "insertText": "size_t(1) << (order - 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t current_increment = size>> kNumBucketsPerOrderBits ;)",
    "insertText": "for(uint16_t j = 0; j < kNumBucketsPerOrder; ++j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* bucket_index_ptr + + = bucket_index ;)",
    "insertText": "if(size % kAlignment != 0)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(bucket_sizes_[bucket_index] > size)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "PA_DCHECK(bucket_sizes_[bucket_index] == size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bucket_index + + ; } size + = current_increment ; } })",
    "insertText": "for(uint8_t order = kMaxBucketedOrder + 1; order <= kBitsPerSizeT; ++order)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (* bucket_index_ptr + + = sentinel_bucket_index ; } })",
    "insertText": "PA_DCHECK(bucket_index < kNumBuckets)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(bucket_index_ptr == bucket_index_lookup_ + ((kBitsPerSizeT + 1) * kNumBucketsPerOrder))"
  },
  {
    "label": "bucket_sizes()",
    "kind": "Method",
    "detail": "Function (* bucket_index_ptr = sentinel_bucket_index ; } const size_t*)",
    "insertText": "bucket_sizes()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t current_size = kSmallestBucket ; size_t current_increment = kSmallestBucket>> kNumBucketsPerOrderBits ; size_t* bucket_size =& bucket_sizes_ [ 0 ] ;)",
    "insertText": "for(size_t i = 0; i < kNumBucketedOrders; ++i)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (* bucket_size = current_size ; + + bucket_size ; } current_size + = current_increment ; } current_increment<<= 1 ; })",
    "insertText": "while(bucket_size < bucket_sizes_ + kNumBuckets)"
  },
  {
    "label": "bucket_index_lookup_()",
    "kind": "Method",
    "detail": "Function (} } size_t bucket_sizes_ [ kNumBuckets ] { } ; uint16_t)",
    "insertText": "bucket_index_lookup_((kBitsPerSizeT + 1) * kNumBucketsPerOrder)"
  },
  {
    "label": "RoundUpToPowerOfTwo()",
    "kind": "Method",
    "detail": "Function (} ; } ; PA_ALWAYS_INLINE size_t)",
    "insertText": "RoundUpToPowerOfTwo(size_t size)"
  },
  {
    "label": "Log2Ceiling()",
    "kind": "Method",
    "detail": "Function (const size_t n = 1<<base::)",
    "insertText": "Log2Ceiling(static_cast<uint32_t>(size))"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(size <= n)"
  },
  {
    "label": "RoundUpToPowerOfTwo()",
    "kind": "Method",
    "detail": "Function (const size_t next_power =)",
    "insertText": "RoundUpToPowerOfTwo(size)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (const size_t prev_power = next_power>> 1 ;)",
    "insertText": "PA_DCHECK(size <= next_power)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(prev_power < size)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (BucketIndexLookup lookup { } ; const size_t order = kBitsPerSizeT - static_cast<)",
    "insertText": "size_t(base::bits::CountLeadingZeroBits(size))"
  },
  {
    "label": "order_index()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "order_index(size >> kOrderIndexShift[order]) & (kNumBucketsPerOrder - 1)"
  },
  {
    "label": "bucket_index_lookup_()",
    "kind": "Method",
    "detail": "Function (const size_t sub_order_index = size& kOrderSubIndexMask [ order ] ; const uint16_t index = lookup .)",
    "insertText": "bucket_index_lookup_(order << kNumBucketsPerOrderBits)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(index <= kNumBuckets)"
  },
  {
    "label": "GetIndexFor8Buckets()",
    "kind": "Method",
    "detail": "Function (const auto index =)",
    "insertText": "GetIndexFor8Buckets(size)"
  }
]