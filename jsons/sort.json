[
  {
    "label": "_PolicyT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_PolicyT"
  },
  {
    "label": "_CompT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_CompT"
  },
  {
    "label": "_WrapAlgPolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_WrapAlgPolicy"
  },
  {
    "label": "_UnwrapAlgPolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_UnwrapAlgPolicy"
  },
  {
    "label": "_AlgPolicy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_AlgPolicy"
  },
  {
    "label": "_Compare",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Compare"
  },
  {
    "label": "_ForwardIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_ForwardIterator"
  },
  {
    "label": "_WrappedComp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_WrappedComp"
  },
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "__is_simple_comparator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_simple_comparator"
  },
  {
    "label": "_Iter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Iter"
  },
  {
    "label": "_RandomAccessIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_RandomAccessIterator"
  },
  {
    "label": "_BidirectionalIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_BidirectionalIterator"
  },
  {
    "label": "_Comp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Comp"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___ALGORITHM_SORT_H # define _LIBCPP___ALGORITHM_SORT_H # include<__algorithm / comp . h> # include<__algorithm / comp_ref_type . h> # include<__algorithm / iterator_operations . h> # include<__algorithm / min_element . h> # include<__algorithm / partial_sort . h> # include<__algorithm / unwrap_iter . h> # include<__bits> # include<__config> # include<__debug> # include<__debug_utils / randomize_range . h> # include<__functional / operations . h> # include<__functional / ranges_operations . h> # include<__iterator / iterator_traits . h> # include<climits> # include<memory> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)"
  },
  {
    "label": "_WrapAlgPolicy()",
    "kind": "Method",
    "detail": "Function (using type = _WrapAlgPolicy ; using _AlgPolicy = _PolicyT ; using _Comp = _CompT ; _Comp& __comp ; _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX11)",
    "insertText": "_WrapAlgPolicy(_Comp& __c) : __comp(__c)"
  },
  {
    "label": "__get_comp()",
    "kind": "Method",
    "detail": "Function (} } ; template<class _PolicyT,class _CompT> struct _WrapAlgPolicy<_PolicyT,_CompT,__enable_if_t<std::is_same<_PolicyT,_ClassicAlgPolicy>::value>> { using type = _CompT ; } ; template<class _CompT> struct _UnwrapAlgPolicy { using _AlgPolicy = _ClassicAlgPolicy ; using _Comp = _CompT ; _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX11 _Comp)",
    "insertText": "__get_comp(_Comp __comp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using _Ops = _IterOps<_AlgPolicy> ; unsigned __r = 0 ;)",
    "insertText": "if(!__c(*__y, *__x))"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iter_swap(__y, __z)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__r = 1 ;)",
    "insertText": "if(__c(*__y, *__x))"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iter_swap(__x, __y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__r = 2 ; } return __r ; })",
    "insertText": "if(__c(*__z, *__y))"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iter_swap(__x, __z)"
  },
  {
    "label": "__sort4()",
    "kind": "Method",
    "detail": "Function (__r = 2 ; } return __r ; } template<class _AlgPolicy,class _Compare,class _ForwardIterator> unsigned)",
    "insertText": "__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4, _Compare __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (using _Ops = _IterOps<_AlgPolicy> ; unsigned __r = std::__sort3<_AlgPolicy,)",
    "insertText": "_Compare(__x1, __x2, __x3, __c)"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iter_swap(__x3, __x4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + __r ;)",
    "insertText": "if(__c(*__x3, *__x2))"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iter_swap(__x2, __x3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + __r ;)",
    "insertText": "if(__c(*__x2, *__x1))"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iter_swap(__x1, __x2)"
  },
  {
    "label": "__sort5()",
    "kind": "Method",
    "detail": "Function (+ + __r ; } } } return __r ; } template<class _WrappedComp,class _ForwardIterator> _LIBCPP_HIDDEN unsigned)",
    "insertText": "__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4, _ForwardIterator __x5, _WrappedComp __wrapped_comp)"
  },
  {
    "label": "__get_comp()",
    "kind": "Method",
    "detail": "Function (using _Unwrap = _UnwrapAlgPolicy<_WrappedComp> ; using _AlgPolicy = _Unwrap::_AlgPolicy ; using _Ops = _IterOps<_AlgPolicy> ; using _Compare = _Unwrap::_Comp ; _Compare __c =)",
    "insertText": "__get_comp(__wrapped_comp)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (unsigned __r = std::__sort4<_AlgPolicy,)",
    "insertText": "_Compare(__x1, __x2, __x3, __x4, __c)"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iter_swap(__x4, __x5)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + __r ;)",
    "insertText": "if(__c(*__x4, *__x3))"
  },
  {
    "label": "__sort5_wrap_policy()",
    "kind": "Method",
    "detail": "Function (+ + __r ; } } } } return __r ; } template<class _AlgPolicy,class _Compare,class _ForwardIterator> _LIBCPP_HIDDEN unsigned)",
    "insertText": "__sort5_wrap_policy(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)"
  },
  {
    "label": "__wrapped_comp()",
    "kind": "Method",
    "detail": "Function (using _WrappedComp = _WrapAlgPolicy<_AlgPolicy,_Compare>::type ; _WrappedComp)",
    "insertText": "__wrapped_comp(__c)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp> struct __is_simple_comparator : false_type { } ; template<class _Tp> struct __is_simple_comparator<__less<_Tp>&> : true_type { } ; template<class _Tp> struct __is_simple_comparator<less<_Tp>&> : true_type { } ; template<class _Tp> struct __is_simple_comparator<greater<_Tp>&> : true_type { } ; # if _LIBCPP_STD_VER> 1 7 template<> struct __is_simple_comparator<ranges::less&> : true_type { } ; template<> struct __is_simple_comparator<ranges::greater&> : true_type { } ; # endif template<class _Compare,class _Iter,class _Tp = iterator_traits<_Iter>::value_type> using __use_branchless_sort = integral_constant<bool,__is_cpp17_contiguous_iterator<_Iter>::value&&)",
    "insertText": "sizeof(_Tp) <= sizeof(void*)"
  },
  {
    "label": "__cond_swap()",
    "kind": "Method",
    "detail": "Function (template<class _Compare,class _RandomAccessIterator> _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "__cond_swap(_RandomAccessIterator __x, _RandomAccessIterator __y, _Compare __c)"
  },
  {
    "label": "__c()",
    "kind": "Method",
    "detail": "Function (using value_type = iterator_traits<_RandomAccessIterator>::value_type ; bool __r =)",
    "insertText": "__c(*__x, *__y)"
  },
  {
    "label": "__partially_sorted_swap()",
    "kind": "Method",
    "detail": "Function (value_type __tmp = __r ?* __x :* __y ;* __y = __r ?* __y :* __x ;* __x = __tmp ; } template<class _Compare,class _RandomAccessIterator> _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "__partially_sorted_swap(_RandomAccessIterator __x, _RandomAccessIterator __y, _RandomAccessIterator __z, _Compare __c)"
  },
  {
    "label": "__c()",
    "kind": "Method",
    "detail": "Function (using value_type = iterator_traits<_RandomAccessIterator>::value_type ; bool __r =)",
    "insertText": "__c(*__z, *__x)"
  },
  {
    "label": "__c()",
    "kind": "Method",
    "detail": "Function (value_type __tmp = __r ?* __z :* __x ;* __z = __r ?* __x :* __z ; __r =)",
    "insertText": "__c(__tmp, *__y)"
  },
  {
    "label": "__sort3_maybe_branchless()",
    "kind": "Method",
    "detail": "Function (* __x = __r ?* __x :* __y ;* __y = __r ?* __y : __tmp ; } template<class,class _Compare,class _RandomAccessIterator> _LIBCPP_HIDE_FROM_ABI __enable_if_t<__use_branchless_sort<_Compare,_RandomAccessIterator>::value,void>)",
    "insertText": "__sort3_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3, _Compare __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (_VSTD::__cond_swap<)",
    "insertText": "_Compare(__x2, __x3, __c)"
  },
  {
    "label": "__sort4_maybe_branchless()",
    "kind": "Method",
    "detail": "Function (} template<class,class _Compare,class _RandomAccessIterator> _LIBCPP_HIDE_FROM_ABI __enable_if_t<__use_branchless_sort<_Compare,_RandomAccessIterator>::value,void>)",
    "insertText": "__sort4_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3, _RandomAccessIterator __x4, _Compare __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (_VSTD::__cond_swap<)",
    "insertText": "_Compare(__x1, __x3, __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (_VSTD::__cond_swap<)",
    "insertText": "_Compare(__x2, __x4, __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (_VSTD::__cond_swap<)",
    "insertText": "_Compare(__x1, __x2, __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (_VSTD::__cond_swap<)",
    "insertText": "_Compare(__x3, __x4, __c)"
  },
  {
    "label": "__sort5_maybe_branchless()",
    "kind": "Method",
    "detail": "Function (} template<class,class _Compare,class _RandomAccessIterator> _LIBCPP_HIDE_FROM_ABI __enable_if_t<__use_branchless_sort<_Compare,_RandomAccessIterator>::value,void>)",
    "insertText": "__sort5_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3, _RandomAccessIterator __x4, _RandomAccessIterator __x5, _Compare __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (_VSTD::__cond_swap<)",
    "insertText": "_Compare(__x4, __x5, __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (_VSTD::__partially_sorted_swap<)",
    "insertText": "_Compare(__x3, __x4, __x5, __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (_VSTD::__cond_swap<)",
    "insertText": "_Compare(__x2, __x5, __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (_VSTD::__partially_sorted_swap<)",
    "insertText": "_Compare(__x1, __x3, __x4, __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (_VSTD::__partially_sorted_swap<)",
    "insertText": "_Compare(__x2, __x3, __x4, __c)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (std::__sort5_wrap_policy<_AlgPolicy,)",
    "insertText": "_Compare(__x1, __x2, __x3, __x4, __x5, __c)"
  },
  {
    "label": "__selection_sort()",
    "kind": "Method",
    "detail": "Function (} template<class _AlgPolicy,class _Compare,class _BidirectionalIterator> _LIBCPP_CONSTEXPR_AFTER_CXX11 void)",
    "insertText": "__selection_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (_BidirectionalIterator __lm1 = __last ;)",
    "insertText": "for(--__lm1; __first != __lm1; ++__first)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (_BidirectionalIterator __i = std::__min_element<)",
    "insertText": "_Compare(__first, __last, __comp)"
  },
  {
    "label": "__insertion_sort()",
    "kind": "Method",
    "detail": "Function (} } template<class _AlgPolicy,class _Compare,class _BidirectionalIterator> void)",
    "insertText": "__insertion_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using _Ops = _IterOps<_AlgPolicy> ; typedef iterator_traits<_BidirectionalIterator>::value_type value_type ;)",
    "insertText": "if(__first != __last)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (_BidirectionalIterator __i = __first ;)",
    "insertText": "for(++__i; __i != __last; ++__i)"
  },
  {
    "label": "__t()",
    "kind": "Method",
    "detail": "Function (_BidirectionalIterator __j = __i ; value_type)",
    "insertText": "__t(_Ops::__iter_move(__j))"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (* __j =)",
    "insertText": "move(__t)"
  },
  {
    "label": "__insertion_sort_3()",
    "kind": "Method",
    "detail": "Function (} } } template<class _AlgPolicy,class _Compare,class _RandomAccessIterator> void)",
    "insertText": "__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
  },
  {
    "label": "difference_type()",
    "kind": "Method",
    "detail": "Function (using _Ops = _IterOps<_AlgPolicy> ; typedef iterator_traits<_RandomAccessIterator>::difference_type difference_type ; typedef iterator_traits<_RandomAccessIterator>::value_type value_type ; _RandomAccessIterator __j = __first +)",
    "insertText": "difference_type(2)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (std::__sort3_maybe_branchless<_AlgPolicy,)",
    "insertText": "_Compare(__first, __first + difference_type(1), __j, __comp)"
  },
  {
    "label": "__t()",
    "kind": "Method",
    "detail": "Function (value_type)",
    "insertText": "__t(_Ops::__iter_move(__i))"
  },
  {
    "label": "__iter_move()",
    "kind": "Method",
    "detail": "Function (_RandomAccessIterator __k = __j ; __j = __i ; do {* __j =)",
    "insertText": "__iter_move(__k)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (__j = __k ; })",
    "insertText": "while(__j != __first && __comp(__t, *--__k))"
  },
  {
    "label": "__insertion_sort_incomplete()",
    "kind": "Method",
    "detail": "Function (} __j = __i ; } } template<class _WrappedComp,class _RandomAccessIterator> bool)",
    "insertText": "__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _WrappedComp __wrapped_comp)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (typedef iterator_traits<_RandomAccessIterator>::difference_type difference_type ;)",
    "insertText": "switch(__last - __first)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const unsigned __limit = 8 ; unsigned __count = 0 ;)",
    "insertText": "for(_RandomAccessIterator __i = __j + difference_type(1); __i != __last; ++__i)"
  },
  {
    "label": "__insertion_sort_move()",
    "kind": "Method",
    "detail": "Function (} __j = __i ; } return true ; } template<class _AlgPolicy,class _Compare,class _BidirectionalIterator> void)",
    "insertText": "__insertion_sort_move(_BidirectionalIterator __first1, _BidirectionalIterator __last1, typename iterator_traits<_BidirectionalIterator>::value_type* __first2, _Compare __comp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using _Ops = _IterOps<_AlgPolicy> ; typedef iterator_traits<_BidirectionalIterator>::value_type value_type ;)",
    "insertText": "if(__first1 != __last1)"
  },
  {
    "label": "__d()",
    "kind": "Method",
    "detail": "Function (__destruct_n)",
    "insertText": "__d(0)"
  },
  {
    "label": "__h()",
    "kind": "Method",
    "detail": "Function (unique_ptr<value_type,__destruct_n&>)",
    "insertText": "__h(__first2, __d)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (value_type* __last2 = __first2)",
    "insertText": "new((void*)__last2) value_type(_Ops::__iter_move(__first1))"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (__d . template __incr<)",
    "insertText": "value_type()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (value_type* __j2 = __last2 ; value_type* __i2 = __j2 ;)",
    "insertText": "if(__comp(*__first1, *--__i2))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)__j2) value_type(std::move(*__i2))"
  },
  {
    "label": "__iter_move()",
    "kind": "Method",
    "detail": "Function (* __j2 =)",
    "insertText": "__iter_move(__first1)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "new((void*)__j2) value_type(_Ops::__iter_move(__first1))"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (} } __h .)",
    "insertText": "release()"
  },
  {
    "label": "__introsort()",
    "kind": "Method",
    "detail": "Function (} } template<class _AlgPolicy,class _Compare,class _RandomAccessIterator> void)",
    "insertText": "__introsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __depth)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (using _Ops = _IterOps<_AlgPolicy> ; typedef iterator_traits<_RandomAccessIterator>::difference_type difference_type ; typedef iterator_traits<_RandomAccessIterator>::value_type value_type ; const difference_type __limit = is_trivially_copy_constructible<value_type>::value&& is_trivially_copy_assignable<value_type>::value ? 3 0 : 6 ;)",
    "insertText": "while(true)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (__restart : difference_type __len = __last - __first ;)",
    "insertText": "switch(__len)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (std::__partial_sort<_AlgPolicy,)",
    "insertText": "_Compare(__first, __last, __last, __comp)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (__delta = __len / 2 ; __m + = __delta ; __delta / = 2 ; __n_swaps = std::__sort5_wrap_policy<_AlgPolicy,)",
    "insertText": "_Compare(__first, __first + __delta, __m, __m + __delta, __lm1, __comp)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (} else { __delta = __len / 2 ; __m + = __delta ; __n_swaps = std::__sort3<_AlgPolicy,)",
    "insertText": "_Compare(__first, __m, __lm1, __comp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } _RandomAccessIterator __i = __first ; _RandomAccessIterator __j = __lm1 ;)",
    "insertText": "if(!__comp(*__i, *__m))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + __i ; __j = __last ;)",
    "insertText": "if(!__comp(*__first, *--__j))"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iter_swap(__i, __j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + __n_swaps ; + + __i ; break ; } + + __i ; } })",
    "insertText": "if(__i == __j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + __n_swaps ; + + __i ; } __first = __i ; goto __restart ; })",
    "insertText": "if(__comp(*__j, *__m))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + __n_swaps ; break ; } } } + + __i ;)",
    "insertText": "if(__i < __j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + __n_swaps ;)",
    "insertText": "if(__m == __i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + __i ; } })",
    "insertText": "if(__i != __m && __comp(*__m, *__i))"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iter_swap(__i, __m)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + __n_swaps ; })",
    "insertText": "if(__n_swaps == 0)"
  },
  {
    "label": "__wrapped_comp()",
    "kind": "Method",
    "detail": "Function (using _WrappedComp = _WrapAlgPolicy<_AlgPolicy,_Compare>::type ; _WrappedComp)",
    "insertText": "__wrapped_comp(__comp)"
  },
  {
    "label": "_WrappedComp()",
    "kind": "Method",
    "detail": "Function (bool __fs = std::__insertion_sort_incomplete<)",
    "insertText": "_WrappedComp(__first, __i, __wrapped_comp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__last = __i ; continue ; } else {)",
    "insertText": "if(__fs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__first = + + __i ; continue ; } } })",
    "insertText": "if(__i - __first < __last - __i)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (std::__introsort<_AlgPolicy,)",
    "insertText": "_Compare(__first, __i, __comp, __depth)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (__first = + + __i ; } else { std::__introsort<_AlgPolicy,)",
    "insertText": "_Compare(__i + difference_type(1), __last, __comp, __depth)"
  },
  {
    "label": "__log2i()",
    "kind": "Method",
    "detail": "Function (__last = __i ; } } } template<_Number> _LIBCPP_HIDE_FROM_ABI _Number)",
    "insertText": "__log2i(_Number __n)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (_Number __log2 = 0 ;)",
    "insertText": "while(__n > 1)"
  },
  {
    "label": "__sort()",
    "kind": "Method",
    "detail": "Function (__log2 + + ; __n>> = 1 ; } return __log2 ; } template<class _WrappedComp,class _RandomAccessIterator> void)",
    "insertText": "__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _WrappedComp __wrapped_comp)"
  },
  {
    "label": "__log2i()",
    "kind": "Method",
    "detail": "Function (typedef iterator_traits<_RandomAccessIterator>::difference_type difference_type ; difference_type __depth_limit = 2*)",
    "insertText": "__log2i(__last - __first)"
  },
  {
    "label": "_Compare()",
    "kind": "Method",
    "detail": "Function (std::__introsort<_AlgPolicy,)",
    "insertText": "_Compare(__first, __last, __comp, __depth_limit)"
  },
  {
    "label": "__sort()",
    "kind": "Method",
    "detail": "Function (} template<class _Compare,class _Tp> _LIBCPP_INLINE_VISIBILITY void)",
    "insertText": "__sort(_Tp** __first, _Tp** __last, __less<_Tp*>&)"
  },
  {
    "label": "uintptr_t()",
    "kind": "Method",
    "detail": "Function (__less<uintptr_t> __comp ; std::__sort<__less<uintptr_t>&,)",
    "insertText": "uintptr_t((uintptr_t*)__first, (uintptr_t*)__last, __comp)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (} template _LIBCPP_FUNC_VIS void __sort<__less<char>&,)",
    "insertText": "char(char*, char*, __less<char>&)"
  },
  {
    "label": "wchar_t()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS template _LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&,)",
    "insertText": "wchar_t(wchar_t*, wchar_t*, __less<wchar_t>&)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (# endif template _LIBCPP_FUNC_VIS void __sort<__less<signed char>&,signed)",
    "insertText": "char(signed char*, signed char*, __less<signed char>&)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&,unsigned)",
    "insertText": "char(unsigned char*, unsigned char*, __less<unsigned char>&)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<short>&,)",
    "insertText": "short(short*, short*, __less<short>&)"
  },
  {
    "label": "short()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&,unsigned)",
    "insertText": "short(unsigned short*, unsigned short*, __less<unsigned short>&)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<int>&,)",
    "insertText": "int(int*, int*, __less<int>&)"
  },
  {
    "label": "unsigned()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<unsigned>&,)",
    "insertText": "unsigned(unsigned*, unsigned*, __less<unsigned>&)"
  },
  {
    "label": "long()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<long>&,)",
    "insertText": "long(long*, long*, __less<long>&)"
  },
  {
    "label": "long()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&,unsigned)",
    "insertText": "long(unsigned long*, unsigned long*, __less<unsigned long>&)"
  },
  {
    "label": "long()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<long long>&,long)",
    "insertText": "long(long long*, long long*, __less<long long>&)"
  },
  {
    "label": "long()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&,unsigned long)",
    "insertText": "long(unsigned long long*, unsigned long long*, __less<unsigned long long>&)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<float>&,)",
    "insertText": "float(float*, float*, __less<float>&)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<double>&,)",
    "insertText": "double(double*, double*, __less<double>&)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS void __sort<__less<long double>&,long)",
    "insertText": "double(long double*, long double*, __less<long double>&)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (template _LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&,long)",
    "insertText": "double(long double*, long double*, long double*, long double*, long double*, __less<long double>&)"
  },
  {
    "label": "__sort_impl()",
    "kind": "Method",
    "detail": "Function (template<class _AlgPolicy,class _RandomAccessIterator,class _Comp> _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void)",
    "insertText": "__sort_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp& __comp)"
  },
  {
    "label": "_AlgPolicy()",
    "kind": "Method",
    "detail": "Function (std::__debug_randomize_range<)",
    "insertText": "_AlgPolicy(__first, __last)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using _Comp_ref = __comp_ref_type<_Comp>::type ;)",
    "insertText": "if(__libcpp_is_constant_evaluated())"
  },
  {
    "label": "_AlgPolicy()",
    "kind": "Method",
    "detail": "Function (std::__partial_sort<)",
    "insertText": "_AlgPolicy(__first, __last, __last, __comp)"
  },
  {
    "label": "__comp_ref()",
    "kind": "Method",
    "detail": "Function (} else { using _WrappedComp = _WrapAlgPolicy<_AlgPolicy,_Comp_ref>::type ; _Comp_ref)",
    "insertText": "__comp_ref(__comp)"
  },
  {
    "label": "__wrapped_comp()",
    "kind": "Method",
    "detail": "Function (_WrappedComp)",
    "insertText": "__wrapped_comp(__comp_ref)"
  },
  {
    "label": "_WrappedComp()",
    "kind": "Method",
    "detail": "Function (std::__sort<)",
    "insertText": "_WrappedComp(std::__unwrap_iter(__first), std::__unwrap_iter(__last), __wrapped_comp)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (} } template<class _RandomAccessIterator,class _Comp> _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void)",
    "insertText": "sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp __comp)"
  },
  {
    "label": "_ClassicAlgPolicy()",
    "kind": "Method",
    "detail": "Function (std::__sort_impl<)",
    "insertText": "_ClassicAlgPolicy(std::move(__first), std::move(__last), __comp)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (} template<class _RandomAccessIterator> _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_AFTER_CXX17 void)",
    "insertText": "sort(_RandomAccessIterator __first, _RandomAccessIterator __last)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>())"
  }
]