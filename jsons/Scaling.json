[
  {
    "label": "IterScaling",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IterScaling"
  },
  {
    "label": "IterScaling()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_ITERSCALING_H # define EIGEN_ITERSCALING_H namespace Eigen { template<_MatrixType> class IterScaling { public : typedef _MatrixType MatrixType ; typedef MatrixType::Scalar Scalar ; typedef MatrixType::Index Index ; public :)",
    "insertText": "IterScaling()"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init()"
  },
  {
    "label": "IterScaling()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "IterScaling(const MatrixType& matrix)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(matrix)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "compute(const MatrixType& mat)"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (using std::abs ; int m = mat .)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (int n = mat .)",
    "insertText": "cols()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert((m>0 && m == n) && \"Please give a non - empty matrix\")"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_left .)",
    "insertText": "resize(m)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_right .)",
    "insertText": "resize(n)"
  },
  {
    "label": "setOnes()",
    "kind": "Method",
    "detail": "Function (m_left .)",
    "insertText": "setOnes()"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (Dc .)",
    "insertText": "setZero()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(int i = 0; i < m; ++i)"
  },
  {
    "label": "Dr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Dr(i) = std::sqrt(Dr(i))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int i = 0; i < n; ++i)"
  },
  {
    "label": "Dc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Dc(i) = std::sqrt(Dc(i))"
  },
  {
    "label": "m_left()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_left(i) /= Dr(i)"
  },
  {
    "label": "m_right()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_right(i) /= Dc(i)"
  },
  {
    "label": "valueRef()",
    "kind": "Method",
    "detail": "Function (it .)",
    "insertText": "valueRef() = it.value()/( Dr(it.row()) * Dc(it.col()))"
  },
  {
    "label": "array()",
    "kind": "Method",
    "detail": "Function (} } DrRes .)",
    "insertText": "array() = (1-DrRes.array()).abs()"
  },
  {
    "label": "maxCoeff()",
    "kind": "Method",
    "detail": "Function (EpsRow = DrRes .)",
    "insertText": "maxCoeff()"
  },
  {
    "label": "array()",
    "kind": "Method",
    "detail": "Function (DcRes .)",
    "insertText": "array() = (1-DcRes.array()).abs()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (its + + ; })",
    "insertText": "while((EpsRow >m_tol || EpsCol > m_tol) && (its < m_maxits))"
  },
  {
    "label": "computeRef()",
    "kind": "Method",
    "detail": "Function (m_isInitialized = true ; } void)",
    "insertText": "computeRef(MatrixType& mat)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(mat)"
  },
  {
    "label": "LeftScaling()",
    "kind": "Method",
    "detail": "Function (mat = m_matrix ; } VectorXd&)",
    "insertText": "LeftScaling()"
  }
]