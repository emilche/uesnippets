[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TLockFreeAllocOnceIndexedAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TLockFreeAllocOnceIndexedAllocator"
  },
  {
    "label": "FIndexedLockFreeLink",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIndexedLockFreeLink"
  },
  {
    "label": "FIndexedPointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIndexedPointer"
  },
  {
    "label": "FLockFreeLinkPolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLockFreeLinkPolicy"
  },
  {
    "label": "FLockFreePointerListLIFORoot",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLockFreePointerListLIFORoot"
  },
  {
    "label": "FLockFreePointerListLIFOBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLockFreePointerListLIFOBase"
  },
  {
    "label": "FLockFreePointerFIFOBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLockFreePointerFIFOBase"
  },
  {
    "label": "FStallingTaskQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStallingTaskQueue"
  },
  {
    "label": "TLockFreePointerListLIFOPad",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TLockFreePointerListLIFOPad"
  },
  {
    "label": "TLockFreePointerListLIFO",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TLockFreePointerListLIFO"
  },
  {
    "label": "TLockFreePointerListUnordered",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TLockFreePointerListUnordered"
  },
  {
    "label": "TLockFreePointerListFIFO",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TLockFreePointerListFIFO"
  },
  {
    "label": "TClosableLockFreePointerListUnorderedSingleConsumer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TClosableLockFreePointerListUnorderedSingleConsumer"
  },
  {
    "label": "DECLARE_LOG_CATEGORY_EXTERN()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / ContainersFwd . h \" # include \" CoreGlobals . h \" # include \" CoreTypes . h \" # include \" HAL / PlatformAtomics . h \" # include \" HAL / PlatformProcess . h \" # include \" HAL / ThreadSafeCounter . h \" # include \" Logging / LogMacros . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / NoopCounter . h \" # include \" Templates / AlignmentTemplates . h \" # include \" Templates / Function . h \" # include<atomic>)",
    "insertText": "DECLARE_LOG_CATEGORY_EXTERN(LogLockFreeList, Log, All)"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# if 1 # define checkLockFreePointerList checkSlow # else # if PLATFORM_WINDOWS # pragma)",
    "insertText": "warning(disable : 4706) #endif #define checkLockFreePointerList(x) ((x)||((*(char*)3) = 0)) #endif #if !UE_BUILD_SHIPPING && !UE_BUILD_TEST CORE_API void DoTestCriticalStall()"
  },
  {
    "label": "TestCriticalStall()",
    "kind": "Method",
    "detail": "Function (int32 GTestCriticalStalls ; void)",
    "insertText": "TestCriticalStall()"
  },
  {
    "label": "LockFreeTagCounterHasOverflowed()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "LockFreeTagCounterHasOverflowed()"
  },
  {
    "label": "LockFreeLinksExhausted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LockFreeLinksExhausted(uint32 TotalNum)"
  },
  {
    "label": "LockFreeAllocLinks()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "LockFreeAllocLinks(SIZE_T AllocSize)"
  },
  {
    "label": "LockFreeFreeLinks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LockFreeFreeLinks(SIZE_T AllocSize, void* Ptr)"
  },
  {
    "label": "MAX_LOCK_FREE_LINKS_AS_BITS()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "MAX_LOCK_FREE_LINKS_AS_BITS(26) #define MAX_LOCK_FREE_LINKS (1 << 26)"
  },
  {
    "label": "MaxBlocks()",
    "kind": "Method",
    "detail": "Function (enum {)",
    "insertText": "MaxBlocks(MaxTotalItems + ItemsPerPage - 1)"
  },
  {
    "label": "TLockFreeAllocOnceIndexedAllocator()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TLockFreeAllocOnceIndexedAllocator()"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (NextIndex .)",
    "insertText": "Increment()"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (Pages [ Index ] = nullptr ; } } uint32)",
    "insertText": "Alloc(uint32 Count = 1)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (uint32 FirstItem = NextIndex .)",
    "insertText": "Add(Count)"
  },
  {
    "label": "LockFreeLinksExhausted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LockFreeLinksExhausted(MaxTotalItems)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(uint32 CurrentItem = FirstItem; CurrentItem < FirstItem + Count; CurrentItem++)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(GetRawItem(CurrentItem)) T()"
  },
  {
    "label": "GetItem()",
    "kind": "Method",
    "detail": "Function (} return FirstItem ; } T*)",
    "insertText": "GetItem(uint32 Index)"
  },
  {
    "label": "checkLockFreePointerList()",
    "kind": "Method",
    "detail": "Function (uint32 BlockIndex = Index / ItemsPerPage ; uint32 SubIndex = Index % ItemsPerPage ;)",
    "insertText": "checkLockFreePointerList(Index && Index < (uint32)NextIndex.GetValue() && Index < MaxTotalItems && BlockIndex < MaxBlocks)"
  },
  {
    "label": "NewBlock()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "NewBlock(T*)LockFreeAllocLinks(ItemsPerPage * sizeof(T))"
  },
  {
    "label": "LockFreeFreeLinks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LockFreeFreeLinks(ItemsPerPage * sizeof(T), NewBlock)"
  },
  {
    "label": "checkLockFreePointerList()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "checkLockFreePointerList(Pages[BlockIndex])"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "return(void*)(Pages[BlockIndex] + SubIndex)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "alignas(PLATFORM_CACHE_LINE_SIZE)"
  },
  {
    "label": "MAX_TagBitsValue()",
    "kind": "Method",
    "detail": "Function (} ; # define)",
    "insertText": "MAX_TagBitsValue(uint64(1) << (64 - MAX_LOCK_FREE_LINKS_AS_BITS))"
  },
  {
    "label": "MS_ALIGN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MS_ALIGN(8)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init()"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (Ptrs .)",
    "insertText": "store(0, std::memory_order_relaxed)"
  },
  {
    "label": "SetAll()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAll(uint32 Ptr, uint64 CounterAndState)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (Ptrs .)",
    "insertText": "store(uint64(Ptr) | (CounterAndState << MAX_LOCK_FREE_LINKS_AS_BITS), std::memory_order_relaxed)"
  },
  {
    "label": "GetPtr()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetPtr()"
  },
  {
    "label": "SetPtr()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetPtr(uint32 To)"
  },
  {
    "label": "SetAll()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAll(To, GetCounterAndState())"
  },
  {
    "label": "GetCounterAndState()",
    "kind": "Method",
    "detail": "Function (} uint64)",
    "insertText": "GetCounterAndState()"
  },
  {
    "label": "SetCounterAndState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCounterAndState(uint64 To)"
  },
  {
    "label": "SetAll()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAll(GetPtr(), To)"
  },
  {
    "label": "AdvanceCounterAndState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AdvanceCounterAndState(const FIndexedPointer &From, uint64 TABAInc)"
  },
  {
    "label": "SetCounterAndState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCounterAndState(From.GetCounterAndState() + TABAInc)"
  },
  {
    "label": "GetState()",
    "kind": "Method",
    "detail": "Function (} } template<uint64 TABAInc> uint64)",
    "insertText": "GetState()"
  },
  {
    "label": "SetState()",
    "kind": "Method",
    "detail": "Function (} template<uint64 TABAInc> void)",
    "insertText": "SetState(uint64 Value)"
  },
  {
    "label": "SetCounterAndState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCounterAndState((GetCounterAndState() & ~(TABAInc - 1)) | Value)"
  },
  {
    "label": "AtomicRead()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AtomicRead(const FIndexedPointer& Other)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (Ptrs .)",
    "insertText": "store(Other.Ptrs.load(std::memory_order_acquire), std::memory_order_relaxed)"
  },
  {
    "label": "InterlockedCompareExchange()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "InterlockedCompareExchange(const FIndexedPointer& Exchange, const FIndexedPointer& Comparand)"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (uint64 Expected = Comparand . Ptrs .)",
    "insertText": "load(std::memory_order_relaxed)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FIndexedPointer& Other)"
  },
  {
    "label": "GCC_ALIGN()",
    "kind": "Method",
    "detail": "Function (} private : std::atomic<uint64> Ptrs ; })",
    "insertText": "GCC_ALIGN(8)"
  },
  {
    "label": "DerefLink()",
    "kind": "Method",
    "detail": "Function (struct FIndexedLockFreeLink { FIndexedPointer DoubleNext ; std::atomic<void*> Payload ; std::atomic<uint32> SingleNext ; } ; struct FLockFreeLinkPolicy { enum { MAX_BITS_IN_TLinkPtr = MAX_LOCK_FREE_LINKS_AS_BITS } ; typedef FIndexedPointer TDoublePtr ; typedef FIndexedLockFreeLink TLink ; typedef uint32 TLinkPtr ; typedef TLockFreeAllocOnceIndexedAllocator<FIndexedLockFreeLink,MAX_LOCK_FREE_LINKS,1 6 3 8 4> TAllocator ; FIndexedLockFreeLink*)",
    "insertText": "DerefLink(uint32 Ptr)"
  },
  {
    "label": "IndexToLink()",
    "kind": "Method",
    "detail": "Function (} FIndexedLockFreeLink*)",
    "insertText": "IndexToLink(uint32 Index)"
  },
  {
    "label": "IndexToPtr()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "IndexToPtr(uint32 Index)"
  },
  {
    "label": "FreeLockFreeLink()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeLockFreeLink(uint32 Item)"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (TAllocator LinkAllocator ; } ; template<int TPaddingForCacheContention,uint64 TABAInc = 1> class FLockFreePointerListLIFORoot {)",
    "insertText": "UE_NONCOPYABLE(FLockFreePointerListLIFORoot)"
  },
  {
    "label": "FLockFreePointerListLIFORoot()",
    "kind": "Method",
    "detail": "Function (typedef FLockFreeLinkPolicy::TLink TLink ; typedef FLockFreeLinkPolicy::TLinkPtr TLinkPtr ; public :)",
    "insertText": "FLockFreePointerListLIFORoot()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Push(TLinkPtr Item)"
  },
  {
    "label": "AtomicRead()",
    "kind": "Method",
    "detail": "Function (TDoublePtr LocalHead ; LocalHead .)",
    "insertText": "AtomicRead(Head)"
  },
  {
    "label": "AdvanceCounterAndState()",
    "kind": "Method",
    "detail": "Function (TDoublePtr NewHead ; NewHead .)",
    "insertText": "AdvanceCounterAndState(LocalHead, TABAInc)"
  },
  {
    "label": "SetPtr()",
    "kind": "Method",
    "detail": "Function (NewHead .)",
    "insertText": "SetPtr(Item)"
  },
  {
    "label": "DerefLink()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DerefLink(Item)->SingleNext.store(LocalHead.GetPtr(), std::memory_order_relaxed)"
  },
  {
    "label": "PushIf()",
    "kind": "Method",
    "detail": "Function (break ; } } } bool)",
    "insertText": "PushIf(TFunctionRef<TLinkPtr(uint64)> AllocateIfOkToPush)"
  },
  {
    "label": "TABAInc()",
    "kind": "Method",
    "detail": "Function (uint64 LocalState = LocalHead . GetState<)",
    "insertText": "TABAInc()"
  },
  {
    "label": "AllocateIfOkToPush()",
    "kind": "Method",
    "detail": "Function (TLinkPtr Item =)",
    "insertText": "AllocateIfOkToPush(LocalState)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (break ; } } return true ; } TLinkPtr)",
    "insertText": "Pop()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (TLinkPtr Item = 0 ;)",
    "insertText": "while(true)"
  },
  {
    "label": "DerefLink()",
    "kind": "Method",
    "detail": "Function (TLink* ItemP =)",
    "insertText": "DerefLink(Item)"
  },
  {
    "label": "SetPtr()",
    "kind": "Method",
    "detail": "Function (NewHead .)",
    "insertText": "SetPtr(ItemP->SingleNext.load(std::memory_order_relaxed))"
  },
  {
    "label": "PopAll()",
    "kind": "Method",
    "detail": "Function (break ; } } return Item ; } TLinkPtr)",
    "insertText": "PopAll()"
  },
  {
    "label": "SetPtr()",
    "kind": "Method",
    "detail": "Function (NewHead .)",
    "insertText": "SetPtr(0)"
  },
  {
    "label": "PopAllAndChangeState()",
    "kind": "Method",
    "detail": "Function (break ; } } return Item ; } TLinkPtr)",
    "insertText": "PopAllAndChangeState(TFunctionRef<uint64(uint64)> StateChange)"
  },
  {
    "label": "TABAInc()",
    "kind": "Method",
    "detail": "Function (NewHead . SetState<)",
    "insertText": "TABAInc(StateChange(LocalHead.GetState<TABAInc>()))"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (break ; } } return Item ; } bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "alignas(TPaddingForCacheContention)"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (} ; template<class T,int TPaddingForCacheContention,uint64 TABAInc = 1> class FLockFreePointerListLIFOBase {)",
    "insertText": "UE_NONCOPYABLE(FLockFreePointerListLIFOBase)"
  },
  {
    "label": "FLockFreePointerListLIFOBase()",
    "kind": "Method",
    "detail": "Function (typedef FLockFreeLinkPolicy::TLink TLink ; typedef FLockFreeLinkPolicy::TLinkPtr TLinkPtr ; public :)",
    "insertText": "FLockFreePointerListLIFOBase()"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Push(T* InPayload)"
  },
  {
    "label": "AllocLockFreeLink()",
    "kind": "Method",
    "detail": "Function (TLinkPtr Item =)",
    "insertText": "AllocLockFreeLink()"
  },
  {
    "label": "DerefLink()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DerefLink(Item)->Payload.store(InPayload, std::memory_order_relaxed)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (RootList .)",
    "insertText": "Push(Item)"
  },
  {
    "label": "PushIf()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "PushIf(T* InPayload, TFunctionRef<bool(uint64)> OkToPush)"
  },
  {
    "label": "Item()",
    "kind": "Method",
    "detail": "Function (TLinkPtr)",
    "insertText": "Item(uint64 State)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return Item ; } return 0 ; } ;)",
    "insertText": "if(!RootList.PushIf(AllocateIfOkToPush))"
  },
  {
    "label": "FreeLockFreeLink()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeLockFreeLink(Item)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T* Result = nullptr ;)",
    "insertText": "if(Item)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Result(T*)FLockFreeLinkPolicy::DerefLink(Item)->Payload.load(std::memory_order_relaxed)"
  },
  {
    "label": "PopAll()",
    "kind": "Method",
    "detail": "Function (} return Result ; } template<ContainerType> void)",
    "insertText": "PopAll(ContainerType& OutContainer)"
  },
  {
    "label": "DerefLink()",
    "kind": "Method",
    "detail": "Function (TLink* LinksP =)",
    "insertText": "DerefLink(Links)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutContainer .)",
    "insertText": "Add((T*)LinksP->Payload.load(std::memory_order_relaxed))"
  },
  {
    "label": "FreeLockFreeLink()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeLockFreeLink(Del)"
  },
  {
    "label": "PopAllAndApply()",
    "kind": "Method",
    "detail": "Function (} } template<FunctorType> void)",
    "insertText": "PopAllAndApply(FunctorType InFunctor)"
  },
  {
    "label": "InFunctor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InFunctor((T*)LinksP->Payload.load(std::memory_order_relaxed))"
  },
  {
    "label": "PopAllAndChangeState()",
    "kind": "Method",
    "detail": "Function (} } template<ContainerType> void)",
    "insertText": "PopAllAndChangeState(ContainerType& OutContainer, TFunctionRef<uint64(uint64)> StateChange)"
  },
  {
    "label": "PopAllAndChangeState()",
    "kind": "Method",
    "detail": "Function (TLinkPtr Links = RootList .)",
    "insertText": "PopAllAndChangeState(StateChange)"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (} private : FLockFreePointerListLIFORoot<TPaddingForCacheContention,TABAInc> RootList ; } ; template<class T,int TPaddingForCacheContention,uint64 TABAInc = 1> class FLockFreePointerFIFOBase {)",
    "insertText": "UE_NONCOPYABLE(FLockFreePointerFIFOBase)"
  },
  {
    "label": "FLockFreePointerFIFOBase()",
    "kind": "Method",
    "detail": "Function (typedef FLockFreeLinkPolicy::TLink TLink ; typedef FLockFreeLinkPolicy::TLinkPtr TLinkPtr ; public :)",
    "insertText": "FLockFreePointerFIFOBase()"
  },
  {
    "label": "SetPtr()",
    "kind": "Method",
    "detail": "Function (Head .)",
    "insertText": "SetPtr(Stub)"
  },
  {
    "label": "FreeLockFreeLink()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "FreeLockFreeLink(Head.GetPtr())"
  },
  {
    "label": "AtomicRead()",
    "kind": "Method",
    "detail": "Function (LocalTail .)",
    "insertText": "AtomicRead(Tail)"
  },
  {
    "label": "DerefLink()",
    "kind": "Method",
    "detail": "Function (TLink* LocalTailP =)",
    "insertText": "DerefLink(LocalTail.GetPtr())"
  },
  {
    "label": "AtomicRead()",
    "kind": "Method",
    "detail": "Function (TDoublePtr LocalNext ; LocalNext .)",
    "insertText": "AtomicRead(LocalTailP->DoubleNext)"
  },
  {
    "label": "AdvanceCounterAndState()",
    "kind": "Method",
    "detail": "Function (TDoublePtr NewTail ; NewTail .)",
    "insertText": "AdvanceCounterAndState(LocalTail, TABAInc)"
  },
  {
    "label": "SetPtr()",
    "kind": "Method",
    "detail": "Function (NewTail .)",
    "insertText": "SetPtr(LocalNext.GetPtr())"
  },
  {
    "label": "InterlockedCompareExchange()",
    "kind": "Method",
    "detail": "Function (Tail .)",
    "insertText": "InterlockedCompareExchange(NewTail, LocalTail)"
  },
  {
    "label": "AdvanceCounterAndState()",
    "kind": "Method",
    "detail": "Function (TDoublePtr NewNext ; NewNext .)",
    "insertText": "AdvanceCounterAndState(LocalNext, TABAInc)"
  },
  {
    "label": "AtomicRead()",
    "kind": "Method",
    "detail": "Function (TDoublePtr LocalNext ; LocalNext .)",
    "insertText": "AtomicRead(FLockFreeLinkPolicy::DerefLink(LocalHead.GetPtr())->DoubleNext)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Result(T*)FLockFreeLinkPolicy::DerefLink(LocalNext.GetPtr())->Payload.load(std::memory_order_relaxed)"
  },
  {
    "label": "FreeLockFreeLink()",
    "kind": "Method",
    "detail": "Function (break ; } } } })",
    "insertText": "FreeLockFreeLink(LocalHead.GetPtr())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutContainer .)",
    "insertText": "Add(Item)"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (} ; template<class T,int TPaddingForCacheContention,int NumPriorities> class FStallingTaskQueue {)",
    "insertText": "UE_NONCOPYABLE(FStallingTaskQueue)"
  },
  {
    "label": "FStallingTaskQueue()",
    "kind": "Method",
    "detail": "Function (typedef FLockFreeLinkPolicy::TLink TLink ; typedef FLockFreeLinkPolicy::TLinkPtr TLinkPtr ; public :)",
    "insertText": "FStallingTaskQueue()"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Push(T* InPayload, uint32 Priority)"
  },
  {
    "label": "AtomicRead()",
    "kind": "Method",
    "detail": "Function (TDoublePtr LocalMasterState ; LocalMasterState .)",
    "insertText": "AtomicRead(MasterState)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (PriorityQueues [ Priority ] .)",
    "insertText": "Push(InPayload)"
  },
  {
    "label": "AdvanceCounterAndState()",
    "kind": "Method",
    "detail": "Function (TDoublePtr NewMasterState ; NewMasterState .)",
    "insertText": "AdvanceCounterAndState(LocalMasterState, 1)"
  },
  {
    "label": "FindThreadToWake()",
    "kind": "Method",
    "detail": "Function (int32 ThreadToWake =)",
    "insertText": "FindThreadToWake(LocalMasterState.GetPtr())"
  },
  {
    "label": "SetPtr()",
    "kind": "Method",
    "detail": "Function (NewMasterState .)",
    "insertText": "SetPtr(TurnOffBit(LocalMasterState.GetPtr(), ThreadToWake))"
  },
  {
    "label": "SetPtr()",
    "kind": "Method",
    "detail": "Function (} else { NewMasterState .)",
    "insertText": "SetPtr(LocalMasterState.GetPtr())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(!MasterState.InterlockedCompareExchange(NewMasterState, LocalMasterState))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if 0)",
    "insertText": "if(ThreadToWake >= 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bAny = false ;)",
    "insertText": "for(int32 Index = 0; !bAny && Index < NumPriorities; Index++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!bAny)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (} } return ThreadToWake ; } T*)",
    "insertText": "Pop(int32 MyThread, bool bAllowStall)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(!bAllowStall)"
  },
  {
    "label": "SetPtr()",
    "kind": "Method",
    "detail": "Function (NewMasterState .)",
    "insertText": "SetPtr(TurnOnBit(LocalMasterState.GetPtr(), MyThread))"
  },
  {
    "label": "FindThreadToWake()",
    "kind": "Method",
    "detail": "Function (break ; } } } return nullptr ; } private : int32)",
    "insertText": "FindThreadToWake(TLinkPtr Ptr)"
  },
  {
    "label": "UPTRINT()",
    "kind": "Method",
    "detail": "Function (int32 Result = - 1 ; UPTRINT Test =)",
    "insertText": "UPTRINT(Ptr)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Result = 0 ;)",
    "insertText": "while(!(Test & 1))"
  },
  {
    "label": "TurnOffBit()",
    "kind": "Method",
    "detail": "Function (Test>> = 1 ; Result + + ; } } return Result ; } TLinkPtr)",
    "insertText": "TurnOffBit(TLinkPtr Ptr, int32 BitToTurnOff)"
  },
  {
    "label": "TurnOnBit()",
    "kind": "Method",
    "detail": "Function (} TLinkPtr)",
    "insertText": "TurnOnBit(TLinkPtr Ptr, int32 BitToTurnOn)"
  },
  {
    "label": "TestBit()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "TestBit(TLinkPtr Ptr, int32 BitToTest)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (} ; template<class T,int TPaddingForCacheContention> class TLockFreePointerListLIFOPad : private FLockFreePointerListLIFOBase<T,TPaddingForCacheContention> { public : void)",
    "insertText": "Push(T *NewItem)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (FLockFreePointerListLIFOBase<T,TPaddingForCacheContention)",
    "insertText": "Push(NewItem)"
  },
  {
    "label": "PopAll()",
    "kind": "Method",
    "detail": "Function (} template<ContainerType> void)",
    "insertText": "PopAll(ContainerType& Output)"
  },
  {
    "label": "PopAll()",
    "kind": "Method",
    "detail": "Function (FLockFreePointerListLIFOBase<T,TPaddingForCacheContention)",
    "insertText": "PopAll(Output)"
  },
  {
    "label": "PopAllAndApply()",
    "kind": "Method",
    "detail": "Function (FLockFreePointerListLIFOBase<T,TPaddingForCacheContention)",
    "insertText": "PopAllAndApply(InFunctor)"
  },
  {
    "label": "PushIfNotClosed()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "PushIfNotClosed(T *NewItem)"
  },
  {
    "label": "PopAllAndClose()",
    "kind": "Method",
    "detail": "Function (} template<ContainerType> void)",
    "insertText": "PopAllAndClose(ContainerType& Output)"
  },
  {
    "label": "CheckOpenAndClose()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "CheckOpenAndClose(uint64 State)"
  },
  {
    "label": "IsClosed()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsClosed()"
  }
]