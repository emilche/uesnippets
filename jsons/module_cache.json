[
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "AuxiliaryModuleProvider",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AuxiliaryModuleProvider"
  },
  {
    "label": "ModuleAndAddressCompare",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ModuleAndAddressCompare"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_PROFILER_MODULE_CACHE_H_ # define BASE_PROFILER_MODULE_CACHE_H_ # include<memory> # include<set> # include<string> # include<vector> # include \" base / base_export . h \" # include \" base / containers / flat_set . h \" # include \" base / files / file_path . h \" # include \" base / memory / raw_ptr . h \" # include \" base / strings / string_piece . h \" # include \" build / build_config . h \" # if)",
    "insertText": "BUILDFLAG(IS_WIN)"
  },
  {
    "label": "TransformModuleIDToBreakpadFormat()",
    "kind": "Method",
    "detail": "Function (BASE_EXPORT std::string)",
    "insertText": "TransformModuleIDToBreakpadFormat(StringPiece module_id)"
  },
  {
    "label": "Module()",
    "kind": "Method",
    "detail": "Function (class BASE_EXPORT ModuleCache { public : class BASE_EXPORT Module { public :)",
    "insertText": "Module()"
  },
  {
    "label": "Module()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Module(const Module&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Module&)",
    "insertText": "operator(const Module&)"
  },
  {
    "label": "GetBaseAddress()",
    "kind": "Method",
    "detail": "Function (uintptr_t)",
    "insertText": "GetBaseAddress()"
  },
  {
    "label": "GetId()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "GetId()"
  },
  {
    "label": "GetDebugBasename()",
    "kind": "Method",
    "detail": "Function (FilePath)",
    "insertText": "GetDebugBasename()"
  },
  {
    "label": "GetSize()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetSize()"
  },
  {
    "label": "IsNative()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsNative()"
  },
  {
    "label": "AuxiliaryModuleProvider()",
    "kind": "Method",
    "detail": "Function (} ; class AuxiliaryModuleProvider { public :)",
    "insertText": "AuxiliaryModuleProvider()"
  },
  {
    "label": "AuxiliaryModuleProvider()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AuxiliaryModuleProvider(const AuxiliaryModuleProvider&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (AuxiliaryModuleProvider&)",
    "insertText": "operator(const AuxiliaryModuleProvider&)"
  },
  {
    "label": "TryCreateModuleForAddress()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<const Module>)",
    "insertText": "TryCreateModuleForAddress(uintptr_t address)"
  },
  {
    "label": "ModuleCache()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "ModuleCache()"
  },
  {
    "label": "GetModuleForAddress()",
    "kind": "Method",
    "detail": "Function (const Module*)",
    "insertText": "GetModuleForAddress(uintptr_t address)"
  },
  {
    "label": "GetModules()",
    "kind": "Method",
    "detail": "Function (std::vector<const Module*>)",
    "insertText": "GetModules()"
  },
  {
    "label": "UpdateNonNativeModules()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateNonNativeModules(const std::vector<const Module*>& defunct_modules, std::vector<std::unique_ptr<const Module>> new_modules)"
  },
  {
    "label": "AddCustomNativeModule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomNativeModule(std::unique_ptr<const Module> module)"
  },
  {
    "label": "RegisterAuxiliaryModuleProvider()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterAuxiliaryModuleProvider(AuxiliaryModuleProvider* auxiliary_module_provider)"
  },
  {
    "label": "UnregisterAuxiliaryModuleProvider()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterAuxiliaryModuleProvider(AuxiliaryModuleProvider* auxiliary_module_provider)"
  },
  {
    "label": "GetExistingModuleForAddress()",
    "kind": "Method",
    "detail": "Function (const Module*)",
    "insertText": "GetExistingModuleForAddress(uintptr_t address)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (private : struct ModuleAndAddressCompare { using is_transparent = void ; bool)",
    "insertText": "operator()(const std::unique_ptr<const Module>& m1, const std::unique_ptr<const Module>& m2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator()(const std::unique_ptr<const Module>& m1, uintptr_t address)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator()(uintptr_t address, const std::unique_ptr<const Module>& m2)"
  },
  {
    "label": "CreateModuleForAddress()",
    "kind": "Method",
    "detail": "Function (} ; std::unique_ptr<const Module>)",
    "insertText": "CreateModuleForAddress(uintptr_t address)"
  }
]