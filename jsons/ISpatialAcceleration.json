[
  {
    "label": "FQueryFastData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQueryFastData"
  },
  {
    "label": "FQueryFastDataVoid",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQueryFastDataVoid"
  },
  {
    "label": "TAABB",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TAABB"
  },
  {
    "label": "TGeometryParticle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TGeometryParticle"
  },
  {
    "label": "TSpatialRay",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSpatialRay"
  },
  {
    "label": "TSpatialVisitorData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TSpatialVisitorData"
  },
  {
    "label": "ISpatialVisitor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ISpatialVisitor"
  },
  {
    "label": "ISpacialDebugDrawInterface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ISpacialDebugDrawInterface"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "TPayloadBoundsElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPayloadBoundsElement"
  },
  {
    "label": "ISpatialAcceleration",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ISpatialAcceleration"
  },
  {
    "label": "TSpatialAccelerationSerializationFactory",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TSpatialAccelerationSerializationFactory"
  },
  {
    "label": "FOutputDevice",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOutputDevice"
  },
  {
    "label": "TSpatialVisitor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSpatialVisitor"
  },
  {
    "label": "TArrayAsMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TArrayAsMap"
  },
  {
    "label": "FEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEntry"
  },
  {
    "label": "Element",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Element"
  },
  {
    "label": "SQMapKeyWithValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SQMapKeyWithValue"
  },
  {
    "label": "FSQHashTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSQHashTable"
  },
  {
    "label": "TSQMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSQMap"
  },
  {
    "label": "CHAOS_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CHAOS_API"
  },
  {
    "label": "FQueryFastData()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Vector . h \" # include \" Chaos / Box . h \" # include \" GeometryParticlesfwd . h \" # include \" ChaosCheck . h \" # include \" ChaosDebugDrawDeclares . h \" # include \" Containers / HashTable . h \" namespace Chaos { struct FQueryFastData {)",
    "insertText": "FQueryFastData(const FVec3& InDir, const FReal InLength) : Dir(InDir) , InvDir( (FMath::Abs(InDir[0]) < UE_SMALL_NUMBER) ? 0 : 1 / Dir[0], (FMath::Abs(InDir[1]) < UE_SMALL_NUMBER) ? 0 : 1 / Dir[1], (FMath::Abs(InDir[2]) < UE_SMALL_NUMBER) ? 0 : 1 / Dir[2])"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Abs(InDir[0]) < UE_SMALL_NUMBER, FMath::Abs(InDir[1]) < UE_SMALL_NUMBER, FMath::Abs(InDir[2])"
  },
  {
    "label": "CHAOS_ENSURE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CHAOS_ENSURE(InLength != 0.0f)"
  },
  {
    "label": "SetLength()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLength(InLength)"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (} const FVec3& Dir ; const FVec3 InvDir ; FReal CurrentLength ; FReal InvCurrentLength ; const bool bParallel [ 3 ] ; # ifdef _MSC_VER # pragma)",
    "insertText": "warning(push) #pragma warning(disable:4723) #endif void SetLength(const FReal InLength)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CurrentLength = InLength ;)",
    "insertText": "if(InLength != 0.0f)"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (InvCurrentLength = 1 / InLength ; } } # ifdef _MSC_VER # pragma)",
    "insertText": "warning(pop) #endif protected: FQueryFastData(const FVec3& InDummyDir) : Dir(InDummyDir) , InvDir()"
  },
  {
    "label": "FQueryFastDataVoid()",
    "kind": "Method",
    "detail": "Function (} { } } ; struct FQueryFastDataVoid : public FQueryFastData {)",
    "insertText": "FQueryFastDataVoid() : FQueryFastData(DummyDir)"
  },
  {
    "label": "TSpatialRay()",
    "kind": "Method",
    "detail": "Function (} FVec3 DummyDir ; } ; template<T,int d> class TAABB ; template<T,int d> class TGeometryParticle ; template<T,int d> class TSpatialRay { public :)",
    "insertText": "TSpatialRay() : Start((T)0) , End((T)0)"
  },
  {
    "label": "TSpatialRay()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSpatialRay(const TVector<T, d>& InStart, const TVector<T, d> InEnd) : Start(InStart) , End(InEnd)"
  },
  {
    "label": "TSpatialVisitorData()",
    "kind": "Method",
    "detail": "Function (} TVector<T,d> Start ; TVector<T,d> End ; } ; template<TPayloadType> struct TSpatialVisitorData { TPayloadType Payload ;)",
    "insertText": "TSpatialVisitorData(const TPayloadType& InPayload, const bool bInHasBounds = false, const FAABB3& InBounds = FAABB3::ZeroAABB()) : Payload(InPayload) #if CHAOS_DEBUG_DRAW , bHasBounds(bInHasBounds) , Bounds(InBounds)"
  },
  {
    "label": "ISpatialVisitor()",
    "kind": "Method",
    "detail": "Function (} bool bHasBounds ; FAABB3 Bounds ; # else { } # endif } ; template<TPayloadType,T = FReal> class ISpatialVisitor { public : ~)",
    "insertText": "ISpatialVisitor()"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Overlap(const TSpatialVisitorData<TPayloadType>& Instance)"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Raycast(const TSpatialVisitorData<TPayloadType>& Instance, FQueryFastData& CurData)"
  },
  {
    "label": "Sweep()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Sweep(const TSpatialVisitorData<TPayloadType>& Instance, FQueryFastData& CurData)"
  },
  {
    "label": "GetQueryData()",
    "kind": "Method",
    "detail": "Function (const void*)",
    "insertText": "GetQueryData()"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Box(const TAABB<T, 3>& InBox, const TVector<T, 3>& InLinearColor, float InThickness)"
  },
  {
    "label": "Line()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Line(const TVector<T, 3>& InBegin, const TVector<T, 3>& InEnd, const TVector<T, 3>& InLinearColor, float InThickness)"
  },
  {
    "label": "SpatialAccelerationEqual()",
    "kind": "Method",
    "detail": "Function (} ; using ISpatialDebugDrawInterface = ISpacialDebugDrawInterface<FReal> ; using SpatialAccelerationType = uint8 ; enum class ESpatialAcceleration : SpatialAccelerationType { BoundingVolume,AABBTree,AABBTreeBV,Collection,Unknown,} ; bool)",
    "insertText": "SpatialAccelerationEqual(ESpatialAcceleration A, SpatialAccelerationType B)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(ESpatialAcceleration A, SpatialAccelerationType B)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(SpatialAccelerationType A, ESpatialAcceleration B)"
  },
  {
    "label": "GetUniqueIdx()",
    "kind": "Method",
    "detail": "Function (} template<TPayload> TEnableIf<! TIsPointer<TPayload>::Value,FUniqueIdx>::Type)",
    "insertText": "GetUniqueIdx(const TPayload& Payload)"
  },
  {
    "label": "UniqueIdx()",
    "kind": "Method",
    "detail": "Function (const FUniqueIdx Idx = Payload .)",
    "insertText": "UniqueIdx()"
  },
  {
    "label": "GetUniqueIdx()",
    "kind": "Method",
    "detail": "Function (} FUniqueIdx)",
    "insertText": "GetUniqueIdx(const FUniqueIdx Payload)"
  },
  {
    "label": "SerializeAsAABB()",
    "kind": "Method",
    "detail": "Function (Ar<<Payload ; TBox<T,3)",
    "insertText": "SerializeAsAABB(Ar, Bounds)"
  },
  {
    "label": "GetPayload()",
    "kind": "Method",
    "detail": "Function (} template<TPayloadType2> TPayloadType2)",
    "insertText": "GetPayload(int32 Idx)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<TPayloadType,T> FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, TPayloadBoundsElement<TPayloadType, T>& PayloadElement)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (PayloadElement .)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (} ; template<TPayloadType,T,int d> class ISpatialAcceleration { public :)",
    "insertText": "UE_NONCOPYABLE(ISpatialAcceleration)"
  },
  {
    "label": "ISpatialAcceleration()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ISpatialAcceleration(SpatialAccelerationType InType = static_cast<SpatialAccelerationType>(ESpatialAcceleration::Unknown)) : SyncTimestamp(0), AsyncTimeSlicingComplete(true), Type(InType)"
  },
  {
    "label": "ISpatialAcceleration()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ISpatialAcceleration(ESpatialAcceleration InType) : ISpatialAcceleration(static_cast<SpatialAccelerationType>(InType))"
  },
  {
    "label": "ISpatialAcceleration()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ISpatialAcceleration()"
  },
  {
    "label": "IsAsyncTimeSlicingComplete()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAsyncTimeSlicingComplete()"
  },
  {
    "label": "ShouldRebuild()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ShouldRebuild()"
  },
  {
    "label": "PrepareCopyTimeSliced()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PrepareCopyTimeSliced(const ISpatialAcceleration<TPayloadType, T, 3>& InFrom)"
  },
  {
    "label": "ProgressCopyTimeSliced()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ProgressCopyTimeSliced(const ISpatialAcceleration<TPayloadType, T, 3>& InFrom, int MaximumBytesToCopy)"
  },
  {
    "label": "CacheOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CacheOverlappingLeaves()"
  },
  {
    "label": "FindAllIntersections()",
    "kind": "Method",
    "detail": "Function (} TArray<TPayloadType>)",
    "insertText": "FindAllIntersections(const FAABB3& Box)"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Raycast(const FVec3& Start, const FVec3& Dir, const FReal Length, ISpatialVisitor<TPayloadType, FReal>& Visitor)"
  },
  {
    "label": "Sweep()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Sweep(const FVec3& Start, const FVec3& Dir, const FReal Length, const FVec3 QueryHalfExtents, ISpatialVisitor<TPayloadType, FReal>& Visitor)"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Overlap(const FAABB3& QueryBounds, ISpatialVisitor<TPayloadType, FReal>& Visitor)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "RemoveElement()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "RemoveElement(const TPayloadType& Payload)"
  },
  {
    "label": "UpdateElementIn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "UpdateElementIn(const TPayloadType& Payload, const TAABB<T, d>& NewBounds, bool bHasBounds, FSpatialAccelerationIdx Idx)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (} TUniquePtr<ISpatialAcceleration<TPayloadType,T,d>>)",
    "insertText": "Copy()"
  },
  {
    "label": "DebugDraw()",
    "kind": "Method",
    "detail": "Function (Type = Other . Type ; SyncTimestamp = Other . SyncTimestamp ; AsyncTimeSlicingComplete = Other . AsyncTimeSlicingComplete ; } # if ! UE_BUILD_SHIPPING void)",
    "insertText": "DebugDraw(ISpacialDebugDrawInterface<T>* InInterface)"
  },
  {
    "label": "DebugDrawLeaf()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DebugDrawLeaf(ISpacialDebugDrawInterface<T>& InInterface, const FLinearColor& InLinearColor, float InThickness)"
  },
  {
    "label": "DumpStats()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DumpStats()"
  },
  {
    "label": "DumpStatsTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DumpStatsTo(class FOutputDevice& Ar)"
  },
  {
    "label": "SerializationFactory()",
    "kind": "Method",
    "detail": "Function (} # endif ISpatialAcceleration<TPayloadType,T,d>*)",
    "insertText": "SerializationFactory(FChaosArchive& Ar, ISpatialAcceleration<TPayloadType, T, d>* Accel)"
  },
  {
    "label": "IsLoading()",
    "kind": "Method",
    "detail": "Function (Type)",
    "insertText": "IsLoading() ? 0 : (int8)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (Ar<<AccelType ;)",
    "insertText": "switch((ESpatialAcceleration)AccelType)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (default :)",
    "insertText": "check(false)"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (} SpatialAccelerationType)",
    "insertText": "GetType()"
  },
  {
    "label": "As()",
    "kind": "Method",
    "detail": "Function (} template<TConcrete> const TConcrete*)",
    "insertText": "As()"
  },
  {
    "label": "AsChecked()",
    "kind": "Method",
    "detail": "Function (} template<TConcrete> TConcrete&)",
    "insertText": "AsChecked()"
  },
  {
    "label": "GetSyncTimestamp()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetSyncTimestamp()"
  },
  {
    "label": "SetAsyncTimeSlicingComplete()",
    "kind": "Method",
    "detail": "Function (SyncTimestamp = InTimestamp ; } protected : void)",
    "insertText": "SetAsyncTimeSlicingComplete(bool InState)"
  },
  {
    "label": "AsUniqueSpatialAcceleration()",
    "kind": "Method",
    "detail": "Function (AsyncTimeSlicingComplete = InState ; } private : int32 SyncTimestamp ; bool AsyncTimeSlicingComplete ; SpatialAccelerationType Type ; } ; template<TBase,TDerived> TUniquePtr<TDerived>)",
    "insertText": "AsUniqueSpatialAcceleration(TUniquePtr<TBase>&& Base)"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (Base .)",
    "insertText": "Release()"
  },
  {
    "label": "AsUniqueSpatialAccelerationChecked()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } template<TDerived,TBase> TUniquePtr<TDerived>)",
    "insertText": "AsUniqueSpatialAccelerationChecked(TUniquePtr<TBase>&& Base)"
  },
  {
    "label": "TDerived()",
    "kind": "Method",
    "detail": "Function (TDerived& Derived = Base -> template AsChecked<)",
    "insertText": "TDerived()"
  },
  {
    "label": "TSpatialVisitor()",
    "kind": "Method",
    "detail": "Function (} template<TPayloadType,T> class TSpatialVisitor { public :)",
    "insertText": "TSpatialVisitor(ISpatialVisitor<TPayloadType, T>& InVisitor) : Visitor(InVisitor)"
  },
  {
    "label": "VisitOverlap()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "VisitOverlap(const TSpatialVisitorData<TPayloadType>& Instance)"
  },
  {
    "label": "VisitRaycast()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "VisitRaycast(const TSpatialVisitorData<TPayloadType>& Instance, FQueryFastData& CurData)"
  },
  {
    "label": "VisitSweep()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "VisitSweep(const TSpatialVisitorData<TPayloadType>& Instance, FQueryFastData& CurData)"
  },
  {
    "label": "GetSimData()",
    "kind": "Method",
    "detail": "Function (} const void*)",
    "insertText": "GetSimData()"
  },
  {
    "label": "ShouldIgnore()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ShouldIgnore(const TSpatialVisitorData<TPayloadType>& Instance)"
  },
  {
    "label": "GetQueryPayload()",
    "kind": "Method",
    "detail": "Function (} const void*)",
    "insertText": "GetQueryPayload()"
  },
  {
    "label": "HasBlockingHit()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasBlockingHit()"
  },
  {
    "label": "FEntry()",
    "kind": "Method",
    "detail": "Function (} private : ISpatialVisitor<TPayloadType,T>& Visitor ; } ; # ifndef CHAOS_SERIALIZE_OUT # define CHAOS_SERIALIZE_OUT WITH_EDITOR # endif template<TKey,TValue> class TArrayAsMap { struct FEntry { TValue Value ; bool bSet ;)",
    "insertText": "FEntry() : bSet(false)"
  },
  {
    "label": "GetTypeSize()",
    "kind": "Method",
    "detail": "Function (} } ; public : using ElementType = TValue ; uint32)",
    "insertText": "GetTypeSize()"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "Capacity()",
    "kind": "Method",
    "detail": "Function (# endif return AllocatedSize ; } int32)",
    "insertText": "Capacity()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} struct Element { # if CHAOS_SERIALIZE_OUT TKey KeyToSerializeOut ; # endif TValue Entry ; } ; int32)",
    "insertText": "Num()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reserve(int32 Size)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Entries .)",
    "insertText": "Reserve(Size)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (# endif } TValue*)",
    "insertText": "Find(const TKey& Key)"
  },
  {
    "label": "GetUniqueIdx()",
    "kind": "Method",
    "detail": "Function (const int32 Idx =)",
    "insertText": "GetUniqueIdx(Key)"
  },
  {
    "label": "FindChecked()",
    "kind": "Method",
    "detail": "Function (} const TValue&)",
    "insertText": "FindChecked(const TKey& Key)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} TValue&)",
    "insertText": "FindOrAdd(const TKey& Key)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Empty()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} TValue&)",
    "insertText": "Add(const TKey& Key)"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (Entries .)",
    "insertText": "AddDefaulted(NumToAdd)"
  },
  {
    "label": "ensure()",
    "kind": "Method",
    "detail": "Function (# endif })",
    "insertText": "ensure(Entries[Idx].bSet == false)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Entries [ Idx ] . bSet = true ; # if CHAOS_SERIALIZE_OUT KeysToSerializeOut [ Idx ] = Key ; # endif return Entries [ Idx ] . Value ; } void)",
    "insertText": "Add(const TKey& Key, const TValue& Value)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(Key)"
  },
  {
    "label": "RemoveChecked()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveChecked(const TKey& Key)"
  },
  {
    "label": "FEntry()",
    "kind": "Method",
    "detail": "Function (Entries [ Idx ] =)",
    "insertText": "FEntry()"
  },
  {
    "label": "TKey()",
    "kind": "Method",
    "detail": "Function (# if CHAOS_SERIALIZE_OUT KeysToSerializeOut [ Idx ] =)",
    "insertText": "TKey()"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "Remove(const TKey& Key)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "Serialize(FChaosArchive& Ar)"
  },
  {
    "label": "IsLoading()",
    "kind": "Method",
    "detail": "Function (bool bCanSerialize = Ar .)",
    "insertText": "IsLoading()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if CHAOS_SERIALIZE_OUT bCanSerialize = true ; # endif)",
    "insertText": "if(bCanSerialize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<TKey> DirectKeys ; Ar<<DirectKeys ;)",
    "insertText": "for(auto& Key : DirectKeys)"
  },
  {
    "label": "CHAOS_ENSURE()",
    "kind": "Method",
    "detail": "Function (Ar<<Value ; } } else {)",
    "insertText": "CHAOS_ENSURE(false)"
  },
  {
    "label": "AddFrom()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "AddFrom(const TArrayAsMap<TKey, TValue>& Source, int32 SourceIndex)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Entries .)",
    "insertText": "Add(Source.Entries[SourceIndex])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (# if CHAOS_SERIALIZE_OUT KeysToSerializeOut .)",
    "insertText": "Add(Source.KeysToSerializeOut[SourceIndex])"
  },
  {
    "label": "SQMapKeyWithValue()",
    "kind": "Method",
    "detail": "Function (# endif } private : TArray<FEntry> Entries ; # if CHAOS_SERIALIZE_OUT TArray<TKey> KeysToSerializeOut ; # endif } ; template<TKey,TValue> struct SQMapKeyWithValue {)",
    "insertText": "SQMapKeyWithValue()"
  },
  {
    "label": "SQMapKeyWithValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SQMapKeyWithValue(const TKey& InKey, const TValue& InValue) : Key(InKey) , Value(InValue)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TKey Key ; TValue Value ; } ; template<TKey,TValue> FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, SQMapKeyWithValue<TKey, TValue>& Pair)"
  },
  {
    "label": "GetIndexSize()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetIndexSize()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reserve(int32 NumToReserve)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Reserve(NumToReserve)"
  },
  {
    "label": "RoundUpToPowerOfTwo()",
    "kind": "Method",
    "detail": "Function (const uint32 RequiredSize =)",
    "insertText": "RoundUpToPowerOfTwo(NumToReserve + 1)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (HashTable .)",
    "insertText": "Resize(RequiredSize)"
  },
  {
    "label": "ResizeHashBuckets()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ResizeHashBuckets(uint32 NewSize)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (HashTable .)",
    "insertText": "Clear(NewSize, FMath::RoundUpToPowerOfTwo(NumElements + 1))"
  },
  {
    "label": "MurmurFinalize32()",
    "kind": "Method",
    "detail": "Function (const uint32 ElemHash =)",
    "insertText": "MurmurFinalize32(GetUniqueIdx(Elements[ElemIdx].Key).Idx)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (HashTable .)",
    "insertText": "Add(ElemHash, ElemIdx)"
  },
  {
    "label": "FindIndex()",
    "kind": "Method",
    "detail": "Function (int32 Index =)",
    "insertText": "FindIndex(Key)"
  },
  {
    "label": "MurmurFinalize32()",
    "kind": "Method",
    "detail": "Function (const uint32 Hash =)",
    "insertText": "MurmurFinalize32(KeyIndex)"
  },
  {
    "label": "FindIndex()",
    "kind": "Method",
    "detail": "Function (int32 Index =)",
    "insertText": "FindIndex(Hash, KeyIndex)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (HashTable .)",
    "insertText": "Free()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} TValue&)",
    "insertText": "Add(uint32 InHash, const TKey& Key)"
  },
  {
    "label": "FindIndex()",
    "kind": "Method",
    "detail": "Function (int32 ExistingIndex =)",
    "insertText": "FindIndex(InHash, GetUniqueIdx(Key).Idx)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Emplace(Key, TValue{})"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (HashTable .)",
    "insertText": "Add(InHash, ExistingIndex)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Remove(Key)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (HashTable .)",
    "insertText": "Remove(Hash, Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 BackIndex = NumElems - 1 ;)",
    "insertText": "if(NumElems > 1)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "RemoveAtSwap(Index, EAllowShrinking::No)"
  },
  {
    "label": "MurmurFinalize32()",
    "kind": "Method",
    "detail": "Function (} else { PairType& BackPair = Elements [ NumElems - 1 ] ; const uint32 BackHash =)",
    "insertText": "MurmurFinalize32(GetUniqueIdx(BackPair.Key).Idx)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (HashTable .)",
    "insertText": "Remove(BackHash, NumElems - 1)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (HashTable .)",
    "insertText": "Add(BackHash, Index)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (HashTable .)",
    "insertText": "Clear()"
  },
  {
    "label": "FindIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "FindIndex(const TKey& Key)"
  },
  {
    "label": "FindIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "FindIndex(uint32 InHash, int32 UniqueIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<Elements ;)",
    "insertText": "if(Ar.IsLoading())"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (HashTable .)",
    "insertText": "Clear(1024, FMath::RoundUpToPowerOfTwo(NumElements))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (HashTable .)",
    "insertText": "Add(MurmurFinalize32(GetUniqueIdx(Elements[i].Key).Idx), i)"
  },
  {
    "label": "AddFrom()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "AddFrom(const TSQMap<TKey, TValue>& Source, int32 SourceIndex)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (const PairType& SourcePair = Source . Elements [ SourceIndex ] ;)",
    "insertText": "Add(SourcePair.Key, SourcePair.Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TArray<PairType> Elements ; FSQHashTable HashTable ; } ; template<TKey,TValue> FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, TArrayAsMap<TKey, TValue>& Map)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(const void* SimData = Visitor.GetSimData())"
  },
  {
    "label": "PrePreFilterHelper()",
    "kind": "Method",
    "detail": "Function (} return false ; } template<TPayload,TVisitor> TEnableIf<TIsPointer<TPayload>::Value,bool>::Type)",
    "insertText": "PrePreFilterHelper(const TPayload& Payload, const TVisitor& Visitor)"
  }
]