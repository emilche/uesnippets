[
  {
    "label": "A",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "A"
  },
  {
    "label": "concurrent_vector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "concurrent_vector"
  },
  {
    "label": "vector_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "vector_iterator"
  },
  {
    "label": "concurrent_vector_base_v3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "concurrent_vector_base_v3"
  },
  {
    "label": "segment_not_used",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "segment_not_used"
  },
  {
    "label": "segment_allocated",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "segment_allocated"
  },
  {
    "label": "segment_allocation_failed",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "segment_allocation_failed"
  },
  {
    "label": "segment_t",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "segment_t"
  },
  {
    "label": "segment_value_t",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "segment_value_t"
  },
  {
    "label": "internal_segments_table",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "internal_segments_table"
  },
  {
    "label": "helper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "helper"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "tbb",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "tbb"
  },
  {
    "label": "allocator_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "allocator_base"
  },
  {
    "label": "generic_range_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "generic_range_type"
  },
  {
    "label": "M",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "M"
  },
  {
    "label": "I",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "I"
  },
  {
    "label": "is_integer_tag",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "is_integer_tag"
  },
  {
    "label": "internal_loop_guide",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal_loop_guide"
  },
  {
    "label": "push_back_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "push_back_helper"
  },
  {
    "label": "element_construction_guard",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "element_construction_guard"
  },
  {
    "label": "A1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "A1"
  },
  {
    "label": "A2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "A2"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_concurrent_vector_H # define __TBB_concurrent_vector_H # include \" tbb_stddef . h \" # include \" tbb_exception . h \" # include \" atomic . h \" # include \" cache_aligned_allocator . h \" # include \" blocked_range . h \" # include \" tbb_machine . h \" # include \" tbb_profiling . h \" # include<new> # include<cstring> # include __TBB_STD_SWAP_HEADER # include<algorithm> # include<iterator> # include \" internal / _allocator_traits . h \" # if _MSC_VER = = 1 5 0 0&& ! __INTEL_COMPILER # pragma)",
    "insertText": "warning(push ) #pragma warning( disable: 4985 ) #endif #include <limits> #if _MSC_VER==1500 && !__INTEL_COMPILER #pragma warning( pop ) #endif #if __TBB_INITIALIZER_LISTS_PRESENT #include <initializer_list> #endif #if defined(_MSC_VER) && !defined(__INTEL_COMPILER) #pragma warning (push) #if defined(_Wp64) #pragma warning (disable: 4267) #endif #pragma warning (disable: 4127)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (template<T,class A = cache_aligned_allocator<T>> class concurrent_vector ; namespace internal { template<Container,Value> class vector_iterator ; void* const vector_allocation_error_flag = reinterpret_cast<)",
    "insertText": "void(size_t(63))"
  },
  {
    "label": "handle_unconstructed_elements()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "handle_unconstructed_elements(T* array, size_t n_of_elements)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(static_cast<void*>(array), 0, n_of_elements * sizeof( T ))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} class concurrent_vector_base_v3 { protected : typedef size_t segment_index_t ; typedef size_t size_type ; enum { default_initial_segments = 1,pointers_per_short_table = 3,pointers_per_long_table =)",
    "insertText": "sizeof(segment_index_t)"
  },
  {
    "label": "segment_value_t()",
    "kind": "Method",
    "detail": "Function (struct segment_not_used { } ; struct segment_allocated { } ; struct segment_allocation_failed { } ; class segment_t ; class segment_value_t { void* array ; private : class segment_t ;)",
    "insertText": "segment_value_t(void* an_array):array(an_array)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "operator(segment_value_t const& lhs, segment_not_used)"
  },
  {
    "label": "pointer()",
    "kind": "Method",
    "detail": "Function (} template<T> T*)",
    "insertText": "pointer()"
  },
  {
    "label": "enforce_segment_allocated()",
    "kind": "Method",
    "detail": "Function (} } ; void)",
    "insertText": "enforce_segment_allocated(segment_value_t const& s, internal::exception_id exception = eid_bad_last_alloc)"
  },
  {
    "label": "throw_exception()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "throw_exception(exception)"
  },
  {
    "label": "segment_t()",
    "kind": "Method",
    "detail": "Function (} } class segment_t { atomic<void*> array ; public :)",
    "insertText": "segment_t()"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (store<)",
    "insertText": "relaxed(segment_not_used())"
  },
  {
    "label": "segment_t()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "segment_t(segment_t const& rhs)"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (array . store<)",
    "insertText": "relaxed(rhs.array.load<relaxed>())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(segment_t & rhs)"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (tbb::internal::swap<)",
    "insertText": "relaxed(array, rhs.array)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} segment_t&)",
    "insertText": "operator(segment_t const& rhs)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (} template<memory_semantics M> void)",
    "insertText": "store(segment_not_used)"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (array . store<)",
    "insertText": "M(0)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (} template<memory_semantics M> void)",
    "insertText": "store(segment_allocation_failed)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(load<relaxed>() != segment_allocated(),\"transition from \\\"allocated\\\" to \\\"allocation failed\\\" state looks non-logical\")"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (array . store<)",
    "insertText": "M(internal::vector_allocation_error_flag)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (} template<memory_semantics M> void)",
    "insertText": "store(void* allocated_segment_pointer) __TBB_NOEXCEPT(true)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(segment_value_t(allocated_segment_pointer) == segment_allocated(), \"other overloads of store should be used for marking segment as not_used or allocation_failed\")"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (array . store<)",
    "insertText": "M(allocated_segment_pointer)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(load<relaxed>() != segment_allocated(), \"should have been freed by clear\")"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} # endif } ; void)",
    "insertText": "swap(segment_t & , segment_t & ) __TBB_NOEXCEPT(true)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*vector_allocator_ptr)(concurrent_vector_base_v3 &, size_t)"
  },
  {
    "label": "concurrent_vector_base_v3()",
    "kind": "Method",
    "detail": "Function (atomic<size_type> my_first_block ; atomic<size_type> my_early_size ; atomic<segment_t*> my_segment ; segment_t my_storage [ pointers_per_short_table ] ;)",
    "insertText": "concurrent_vector_base_v3()"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (my_early_size . store<)",
    "insertText": "relaxed(0)"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (my_segment . store<)",
    "insertText": "relaxed(my_storage)"
  },
  {
    "label": "segment_index_of()",
    "kind": "Method",
    "detail": "Function (segment_index_t)",
    "insertText": "segment_index_of(size_type index)"
  },
  {
    "label": "segment_base()",
    "kind": "Method",
    "detail": "Function (} segment_index_t)",
    "insertText": "segment_base(segment_index_t k)"
  },
  {
    "label": "segment_base_index_of()",
    "kind": "Method",
    "detail": "Function (} segment_index_t)",
    "insertText": "segment_base_index_of(segment_index_t &index)"
  },
  {
    "label": "segment_index_of()",
    "kind": "Method",
    "detail": "Function (segment_index_t k =)",
    "insertText": "segment_index_of(index)"
  },
  {
    "label": "segment_base()",
    "kind": "Method",
    "detail": "Function (index - =)",
    "insertText": "segment_base(k)"
  },
  {
    "label": "is_first_element_in_segment()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_first_element_in_segment(size_type element_index)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(element_index, \"there should be no need to call \" \"is_first_element_in_segment for 0th element\")"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} typedef)",
    "insertText": "void(__TBB_EXPORTED_FUNC *internal_array_op1)(void* begin, size_type n)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(__TBB_EXPORTED_FUNC *internal_array_op2)(void* dst, const void* src, size_type n)"
  },
  {
    "label": "internal_reserve()",
    "kind": "Method",
    "detail": "Function (struct internal_segments_table { segment_index_t first_block ; segment_t table [ pointers_per_long_table ] ; } ; void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_reserve(size_type n, size_type element_size, size_type max_size)"
  },
  {
    "label": "internal_capacity()",
    "kind": "Method",
    "detail": "Function (size_type __TBB_EXPORTED_METHOD)",
    "insertText": "internal_capacity()"
  },
  {
    "label": "internal_grow()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_grow(size_type start, size_type finish, size_type element_size, internal_array_op2 init, const void *src)"
  },
  {
    "label": "internal_grow_by()",
    "kind": "Method",
    "detail": "Function (size_type __TBB_EXPORTED_METHOD)",
    "insertText": "internal_grow_by(size_type delta, size_type element_size, internal_array_op2 init, const void *src)"
  },
  {
    "label": "internal_push_back()",
    "kind": "Method",
    "detail": "Function (void* __TBB_EXPORTED_METHOD)",
    "insertText": "internal_push_back(size_type element_size, size_type& index)"
  },
  {
    "label": "internal_clear()",
    "kind": "Method",
    "detail": "Function (segment_index_t __TBB_EXPORTED_METHOD)",
    "insertText": "internal_clear(internal_array_op1 destroy)"
  },
  {
    "label": "internal_compact()",
    "kind": "Method",
    "detail": "Function (void* __TBB_EXPORTED_METHOD)",
    "insertText": "internal_compact(size_type element_size, void *table, internal_array_op1 destroy, internal_array_op2 copy)"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_copy(const concurrent_vector_base_v3& src, size_type element_size, internal_array_op2 copy)"
  },
  {
    "label": "internal_assign()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_assign(const concurrent_vector_base_v3& src, size_type element_size, internal_array_op1 destroy, internal_array_op2 assign, internal_array_op2 copy)"
  },
  {
    "label": "internal_throw_exception()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_throw_exception(size_type)"
  },
  {
    "label": "internal_swap()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_swap(concurrent_vector_base_v3& v)"
  },
  {
    "label": "internal_resize()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_resize(size_type n, size_type element_size, size_type max_size, const void *src, internal_array_op1 destroy, internal_array_op2 init)"
  },
  {
    "label": "internal_grow_to_at_least_with_result()",
    "kind": "Method",
    "detail": "Function (size_type __TBB_EXPORTED_METHOD)",
    "insertText": "internal_grow_to_at_least_with_result(size_type new_size, size_type element_size, internal_array_op2 init, const void *src)"
  },
  {
    "label": "internal_grow_to_at_least()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_grow_to_at_least(size_type new_size, size_type element_size, internal_array_op2 init, const void *src)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (private : class helper ; class helper ; template<Container,Value> class vector_iterator ; } ; void)",
    "insertText": "swap(concurrent_vector_base_v3::segment_t & lhs, concurrent_vector_base_v3::segment_t & rhs) __TBB_NOEXCEPT(true)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (lhs .)",
    "insertText": "swap(rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} typedef concurrent_vector_base_v3 concurrent_vector_base ; template<Container,Value> class vector_iterator { Container* my_vector ; size_t my_index ; Value* my_item ; template<C,T> vector_iterator<C,T>)",
    "insertText": "operator(ptrdiff_t offset, const vector_iterator<C,T>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<C,T,U> bool)",
    "insertText": "operator(const vector_iterator<C,T>& i, const vector_iterator<C,U>& j)"
  },
  {
    "label": "vector_iterator()",
    "kind": "Method",
    "detail": "Function (template<C,U> class internal::vector_iterator ; # if ! __TBB_TEMPLATE_FRIENDS_BROKEN template<T,class A> class tbb::concurrent_vector ; # else public : # endif)",
    "insertText": "vector_iterator(const Container& vector, size_t index, void *ptr = 0 ) : my_vector(const_cast<Container*>(&vector)), my_index(index), my_item(static_cast<Value*>(ptr))"
  },
  {
    "label": "vector_iterator()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "vector_iterator() : my_vector(NULL), my_index(~size_t(0)), my_item(NULL)"
  },
  {
    "label": "vector_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "vector_iterator(const vector_iterator<Container,typename Container::value_type>& other ) : my_vector(other.my_vector), my_index(other.my_index), my_item(other.my_item)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} vector_iterator)",
    "insertText": "operator(ptrdiff_t offset)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (my_index - = offset ; my_item = NULL ; return* this ; } Value&)",
    "insertText": "operator()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Value* item = my_item ;)",
    "insertText": "if(!item)"
  },
  {
    "label": "internal_subscript()",
    "kind": "Method",
    "detail": "Function (item = my_item =& my_vector ->)",
    "insertText": "internal_subscript(my_index)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "__TBB_ASSERT(item==&my_vector->internal_subscript(my_index), \"corrupt cache\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t element_index = + + my_index ;)",
    "insertText": "if(my_item)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_index>0, \"operator--() applied to iterator already at beginning of concurrent_vector\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (my_item = NULL ; } else { - - my_item ; } } return* this ; } vector_iterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Container,T,U> bool)",
    "insertText": "operator(const vector_iterator<Container,T>& i, const vector_iterator<Container,U>& j)"
  },
  {
    "label": "allocator_base()",
    "kind": "Method",
    "detail": "Function (} template<T,class A> class allocator_base { public : typedef tbb::internal::allocator_rebind<A,T>::type allocator_type ; allocator_type my_allocator ;)",
    "insertText": "allocator_base(const allocator_type &a = allocator_type() ) : my_allocator(a)"
  },
  {
    "label": "generic_range_type()",
    "kind": "Method",
    "detail": "Function (} } ; } template<T,class A> class concurrent_vector : protected internal::allocator_base<T,A>,private internal::concurrent_vector_base { private : template<I> class generic_range_type : public blocked_range<I> { public : typedef T value_type ; typedef T& reference ; typedef const T& const_reference ; typedef I iterator ; typedef ptrdiff_t difference_type ;)",
    "insertText": "generic_range_type(I begin_, I end_, size_t grainsize_ = 1) : blocked_range<I>(begin_,end_,grainsize_)"
  },
  {
    "label": "generic_range_type()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "generic_range_type(const generic_range_type<U>& r) : blocked_range<I>(r.begin(),r.end(),r.grainsize())"
  },
  {
    "label": "generic_range_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "generic_range_type(generic_range_type& r, split ) : blocked_range<I>(r,split())"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; template<C,U> class internal::vector_iterator ; public : typedef internal::concurrent_vector_base_v3::size_type size_type ; typedef internal::allocator_base<T,A>::allocator_type allocator_type ; typedef T value_type ; typedef ptrdiff_t difference_type ; typedef T& reference ; typedef const T& const_reference ; typedef T* pointer ; typedef const T* const_pointer ; typedef internal::vector_iterator<concurrent_vector,T> iterator ; typedef internal::vector_iterator<concurrent_vector,const T> const_iterator ; # if !)",
    "insertText": "defined(_MSC_VER)"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (typedef std::reverse_iterator<const_iterator> const_reverse_iterator ; # else typedef std::reverse_iterator<iterator,T,T&,T*> reverse_iterator ; typedef std::reverse_iterator<const_iterator,T,const T&,const T*> const_reverse_iterator ; # endif typedef generic_range_type<iterator> range_type ; typedef generic_range_type<const_iterator> const_range_type ;)",
    "insertText": "concurrent_vector(const allocator_type &a = allocator_type()) : internal::allocator_base<T, A>(a), internal::concurrent_vector_base()"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (vector_allocator_ptr =& internal_allocator ; } # if __TBB_INITIALIZER_LISTS_PRESENT)",
    "insertText": "concurrent_vector(std::initializer_list<T> init_list, const allocator_type &a = allocator_type()) : internal::allocator_base<T, A>(a), internal::concurrent_vector_base()"
  },
  {
    "label": "internal_assign_iterators()",
    "kind": "Method",
    "detail": "Function (vector_allocator_ptr =& internal_allocator ; __TBB_TRY {)",
    "insertText": "internal_assign_iterators(init_list.begin(), init_list.end())"
  },
  {
    "label": "__TBB_CATCH()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "__TBB_CATCH(...)"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (segment_t* table = my_segment . load<)",
    "insertText": "relaxed()"
  },
  {
    "label": "internal_free_segments()",
    "kind": "Method",
    "detail": "Function (;)",
    "insertText": "internal_free_segments(table, internal_clear(&destroy_array), my_first_block.load<relaxed>())"
  },
  {
    "label": "__TBB_RETHROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_RETHROW()"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (} } # endif)",
    "insertText": "concurrent_vector(const concurrent_vector& vector, const allocator_type& a = allocator_type() ) : internal::allocator_base<T, A>(a), internal::concurrent_vector_base()"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (vector_allocator_ptr =& internal_allocator ; __TBB_TRY {)",
    "insertText": "internal_copy(vector, sizeof(T), &copy_array)"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (} } # if __TBB_CPP11_RVALUE_REF_PRESENT)",
    "insertText": "concurrent_vector(concurrent_vector&& source) : internal::allocator_base<T, A>(std::move(source)), internal::concurrent_vector_base()"
  },
  {
    "label": "internal_swap()",
    "kind": "Method",
    "detail": "Function (vector_allocator_ptr =& internal_allocator ;)",
    "insertText": "internal_swap(source)"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "concurrent_vector(concurrent_vector&& source, const allocator_type& a) : internal::allocator_base<T, A>(a), internal::concurrent_vector_base()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (vector_allocator_ptr =& internal_allocator ;)",
    "insertText": "if(a == source.my_allocator)"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (} else { __TBB_TRY {)",
    "insertText": "internal_copy(source, sizeof(T), &move_array)"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (} } } # endif template<class M>)",
    "insertText": "concurrent_vector(const concurrent_vector<T, M>& vector, const allocator_type& a = allocator_type() ) : internal::allocator_base<T, A>(a), internal::concurrent_vector_base()"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (vector_allocator_ptr =& internal_allocator ; __TBB_TRY {)",
    "insertText": "internal_copy(vector.internal_vector_base(), sizeof(T), &copy_array)"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "concurrent_vector(size_type n)"
  },
  {
    "label": "internal_resize()",
    "kind": "Method",
    "detail": "Function (vector_allocator_ptr =& internal_allocator ; __TBB_TRY {)",
    "insertText": "internal_resize(n, sizeof(T), max_size(), NULL, &destroy_array, &initialize_array)"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "concurrent_vector(size_type n, const_reference t, const allocator_type& a = allocator_type()) : internal::allocator_base<T, A>(a)"
  },
  {
    "label": "internal_resize()",
    "kind": "Method",
    "detail": "Function (vector_allocator_ptr =& internal_allocator ; __TBB_TRY {)",
    "insertText": "internal_resize(n, sizeof(T), max_size(), static_cast<const void*>(&t), &destroy_array, &initialize_array_by)"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (} } template<class I>)",
    "insertText": "concurrent_vector(I first, I last, const allocator_type &a = allocator_type()) : internal::allocator_base<T, A>(a)"
  },
  {
    "label": "internal_assign_range()",
    "kind": "Method",
    "detail": "Function (vector_allocator_ptr =& internal_allocator ; __TBB_TRY {)",
    "insertText": "internal_assign_range(first, last, static_cast<is_integer_tag<std::numeric_limits<I>::is_integer> *>(0))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } concurrent_vector&)",
    "insertText": "operator(const concurrent_vector& vector)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(this != &other, \"Move assignment to itself is prohibited \")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (typedef tbb::internal::allocator_traits<A>::propagate_on_container_move_assignment pocma_t ;)",
    "insertText": "if(pocma_t::value || this->my_allocator == other.my_allocator)"
  },
  {
    "label": "trash()",
    "kind": "Method",
    "detail": "Function (concurrent_vector)",
    "insertText": "trash(std::move(*this))"
  },
  {
    "label": "internal_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_swap(other)"
  },
  {
    "label": "allocator_move_assignment()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "allocator_move_assignment(this->my_allocator, other.my_allocator, pocma_t())"
  },
  {
    "label": "internal_assign()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "internal_assign(other, sizeof(T), &destroy_array, &move_assign_array, &move_array)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } # endif template<class M> concurrent_vector&)",
    "insertText": "operator(const concurrent_vector<T, M>& vector)"
  },
  {
    "label": "internal_clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_clear(&destroy_array)"
  },
  {
    "label": "grow_by()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "grow_by(size_type delta, const_reference t)"
  },
  {
    "label": "grow_by()",
    "kind": "Method",
    "detail": "Function (} template<I> iterator)",
    "insertText": "grow_by(I first, I last)"
  },
  {
    "label": "distance()",
    "kind": "Method",
    "detail": "Function (std::iterator_traits<I>::difference_type delta =)",
    "insertText": "distance(first, last)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(delta >= 0, NULL)"
  },
  {
    "label": "grow_by()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_INITIALIZER_LISTS_PRESENT iterator)",
    "insertText": "grow_by(std::initializer_list<T> init_list)"
  },
  {
    "label": "grow_to_at_least()",
    "kind": "Method",
    "detail": "Function (} # endif iterator)",
    "insertText": "grow_to_at_least(size_type n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_type m = 0 ;)",
    "insertText": "if(n)"
  },
  {
    "label": "internal_grow_to_at_least_with_result()",
    "kind": "Method",
    "detail": "Function (m =)",
    "insertText": "internal_grow_to_at_least_with_result(n, sizeof(T), &initialize_array, NULL)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "iterator(*this, m)"
  },
  {
    "label": "grow_to_at_least()",
    "kind": "Method",
    "detail": "Function (} ; iterator)",
    "insertText": "grow_to_at_least(size_type n, const_reference t)"
  },
  {
    "label": "internal_grow_to_at_least_with_result()",
    "kind": "Method",
    "detail": "Function (m =)",
    "insertText": "internal_grow_to_at_least_with_result(n, sizeof(T), &initialize_array_by, &t)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} ; iterator)",
    "insertText": "push_back(const_reference item)"
  },
  {
    "label": "prolog()",
    "kind": "Method",
    "detail": "Function (push_back_helper)",
    "insertText": "prolog(*this)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(prolog.internal_push_back_result()) T(item)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT iterator)",
    "insertText": "push_back(T&& item)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(prolog.internal_push_back_result()) T(std::move(item))"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_VARIADIC_TEMPLATES_PRESENT template<. . . Args> iterator)",
    "insertText": "emplace_back(Args&&... args)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(prolog.internal_push_back_result()) T(std::forward<Args>(args)...)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif # endif reference)",
    "insertText": "operator(size_type index)"
  },
  {
    "label": "at()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "at(size_type index)"
  },
  {
    "label": "range()",
    "kind": "Method",
    "detail": "Function (} range_type)",
    "insertText": "range(size_t grainsize = 1)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "size()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reserve(size_type n)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resize(size_type n)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resize(size_type n, const_reference t)"
  },
  {
    "label": "shrink_to_fit()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "shrink_to_fit()"
  },
  {
    "label": "max_size()",
    "kind": "Method",
    "detail": "Function (size_type)",
    "insertText": "max_size()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "cbegin()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "cbegin()"
  },
  {
    "label": "cend()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "cend()"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rbegin()"
  },
  {
    "label": "rend()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rend()"
  },
  {
    "label": "crbegin()",
    "kind": "Method",
    "detail": "Function (} const_reverse_iterator)",
    "insertText": "crbegin()"
  },
  {
    "label": "crend()",
    "kind": "Method",
    "detail": "Function (} const_reverse_iterator)",
    "insertText": "crend()"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "front()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(size()>0, NULL)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "back()"
  },
  {
    "label": "get_allocator()",
    "kind": "Method",
    "detail": "Function (} allocator_type)",
    "insertText": "get_allocator()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (} template<class I> void)",
    "insertText": "assign(I first, I last)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_INITIALIZER_LISTS_PRESENT void)",
    "insertText": "assign(std::initializer_list<T> init_list)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "swap(concurrent_vector &vector)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (typedef tbb::internal::allocator_traits<A>::propagate_on_container_swap pocs_t ;)",
    "insertText": "if(this != &vector && (this->my_allocator == vector.my_allocator || pocs_t::value))"
  },
  {
    "label": "internal_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_swap(static_cast<concurrent_vector_base_v3&>(vector))"
  },
  {
    "label": "allocator_swap()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "allocator_swap(this->my_allocator, vector.my_allocator, pocs_t())"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "concurrent_vector()"
  },
  {
    "label": "internal_vector_base()",
    "kind": "Method",
    "detail": "Function (} const internal::concurrent_vector_base_v3&)",
    "insertText": "internal_vector_base()"
  },
  {
    "label": "internal_free_segments()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_free_segments(segment_t table[], segment_index_t k, segment_index_t first_block)"
  },
  {
    "label": "internal_subscript()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "internal_subscript(size_type index)"
  },
  {
    "label": "internal_subscript_with_exceptions()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "internal_subscript_with_exceptions(size_type index)"
  },
  {
    "label": "internal_assign_n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_assign_n(size_type n, const_pointer p)"
  },
  {
    "label": "internal_resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_resize(n, sizeof(T), max_size(), static_cast<const void*>(p), &destroy_array, p? &initialize_array_by : &initialize_array)"
  },
  {
    "label": "internal_assign_range()",
    "kind": "Method",
    "detail": "Function (} template<bool B> class is_integer_tag ; template<class I> void)",
    "insertText": "internal_assign_range(I first, I last, is_integer_tag<true> *)"
  },
  {
    "label": "internal_assign_n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_assign_n(static_cast<size_type>(first), &static_cast<T&>(last))"
  },
  {
    "label": "internal_assign_range()",
    "kind": "Method",
    "detail": "Function (} template<class I> void)",
    "insertText": "internal_assign_range(I first, I last, is_integer_tag<false> *)"
  },
  {
    "label": "internal_assign_iterators()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_assign_iterators(first, last)"
  },
  {
    "label": "internal_assign_iterators()",
    "kind": "Method",
    "detail": "Function (} template<class I> void)",
    "insertText": "internal_assign_iterators(I first, I last)"
  },
  {
    "label": "initialize_array()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "initialize_array(void* begin, const void*, size_type n)"
  },
  {
    "label": "initialize_array_by()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "initialize_array_by(void* begin, const void* src, size_type n)"
  },
  {
    "label": "copy_array()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "copy_array(void* dst, const void* src, size_type n)"
  },
  {
    "label": "move_array_if_noexcept()",
    "kind": "Method",
    "detail": "Function (# if __TBB_MOVE_IF_NOEXCEPT_PRESENT void __TBB_EXPORTED_FUNC)",
    "insertText": "move_array_if_noexcept(void* dst, const void* src, size_type n)"
  },
  {
    "label": "move_array()",
    "kind": "Method",
    "detail": "Function (# endif # if __TBB_CPP11_RVALUE_REF_PRESENT void __TBB_EXPORTED_FUNC)",
    "insertText": "move_array(void* dst, const void* src, size_type n)"
  },
  {
    "label": "move_assign_array()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "move_assign_array(void* dst, const void* src, size_type n)"
  },
  {
    "label": "copy_range()",
    "kind": "Method",
    "detail": "Function (# endif template<Iterator> void __TBB_EXPORTED_FUNC)",
    "insertText": "copy_range(void* dst, const void* p_type_erased_iterator, size_type n)"
  },
  {
    "label": "assign_array()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "assign_array(void* dst, const void* src, size_type n)"
  },
  {
    "label": "destroy_array()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "destroy_array(void* begin, size_type n)"
  },
  {
    "label": "as_const_pointer()",
    "kind": "Method",
    "detail": "Function (class internal_loop_guide : internal::no_copy { public : const pointer array ; const size_type n ; size_type i ; const T*)",
    "insertText": "as_const_pointer(const void *ptr)"
  },
  {
    "label": "as_pointer()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "as_pointer(const void *src)"
  },
  {
    "label": "internal_loop_guide()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "internal_loop_guide(size_type ntrials, void *ptr) : array(as_pointer(ptr)), n(ntrials), i(0)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "init()"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "init(const void *src)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "copy(const void *src)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "assign(const void *src)"
  },
  {
    "label": "move_assign()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT void)",
    "insertText": "move_assign(const void *src)"
  },
  {
    "label": "move_construct()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "move_construct(const void *src)"
  },
  {
    "label": "move_construct_if_noexcept()",
    "kind": "Method",
    "detail": "Function (} # endif # if __TBB_MOVE_IF_NOEXCEPT_PRESENT void)",
    "insertText": "move_construct_if_noexcept(const void *src)"
  },
  {
    "label": "iterate()",
    "kind": "Method",
    "detail": "Function (} # endif template<class I> void)",
    "insertText": "iterate(I &src)"
  },
  {
    "label": "internal_loop_guide()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "internal_loop_guide()"
  },
  {
    "label": "handle_unconstructed_elements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "handle_unconstructed_elements(array+i, n-i)"
  },
  {
    "label": "element_construction_guard()",
    "kind": "Method",
    "detail": "Function (} } } ; struct push_back_helper : internal::no_copy { struct element_construction_guard : internal::no_copy { pointer element ;)",
    "insertText": "element_construction_guard(pointer an_element) : element (an_element)"
  },
  {
    "label": "dismiss()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "dismiss()"
  },
  {
    "label": "element_construction_guard()",
    "kind": "Method",
    "detail": "Function (element = NULL ; } ~)",
    "insertText": "element_construction_guard()"
  },
  {
    "label": "handle_unconstructed_elements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "handle_unconstructed_elements(element, 1)"
  },
  {
    "label": "push_back_helper()",
    "kind": "Method",
    "detail": "Function (} } } ; concurrent_vector& v ; size_type k ; element_construction_guard g ;)",
    "insertText": "push_back_helper(concurrent_vector & vector) : v(vector), g (static_cast<T*>(v.internal_push_back(sizeof(T),k)))"
  },
  {
    "label": "internal_push_back_result()",
    "kind": "Method",
    "detail": "Function (} pointer)",
    "insertText": "internal_push_back_result()"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (concurrent_vector<T, A>)",
    "insertText": "concurrent_vector(I, I, const A& = A())"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (concurrent_vector<T, A2>)",
    "insertText": "concurrent_vector(const concurrent_vector<T, A1> &, const A2 &)"
  },
  {
    "label": "concurrent_vector()",
    "kind": "Method",
    "detail": "Function (concurrent_vector<T, A>)",
    "insertText": "concurrent_vector(std::initializer_list<T>, const A& = A())"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "defined(_MSC_VER) && !defined(__INTEL_COMPILER) #pragma warning (push) #pragma warning (disable: 4701) #endif template<typename T, class A> void concurrent_vector<T, A>::shrink_to_fit()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (internal_segments_table old ; __TBB_TRY { internal_array_op2 copy_or_move_array = # if __TBB_MOVE_IF_NOEXCEPT_PRESENT& move_array_if_noexcept # else& copy_array # endif ;)",
    "insertText": "if(internal_compact( sizeof(T), &old, &destroy_array, copy_or_move_array ) ) internal_free_segments( old.table, pointers_per_long_table, old.first_block)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } # if)",
    "insertText": "defined(_MSC_VER) && !defined(__INTEL_COMPILER) #pragma warning (pop) #endif template<typename T, class A> void concurrent_vector<T, A>::internal_free_segments(segment_t table[], segment_index_t k, segment_index_t first_block)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(first_block > 0, NULL)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (this -> my_allocator .)",
    "insertText": "deallocate((segment_value.pointer<T>()), segment_size(first_block))"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(index < my_early_size, \"index out of bounds\")"
  },
  {
    "label": "segment_base_index_of()",
    "kind": "Method",
    "detail": "Function (size_type j = index ; segment_index_t k =)",
    "insertText": "segment_base_index_of(j)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_segment.load<acquire>() != my_storage || k < pointers_per_short_table, \"index is being allocated\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(segment_value != segment_allocation_failed(), \"the instance is broken by bad allocation. Use at() instead\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(segment_value != segment_not_used(), \"index is being allocated\")"
  },
  {
    "label": "enforce_segment_allocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enforce_segment_allocated(segment_value, internal::eid_index_range_error)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_early_size == 0, NULL)"
  },
  {
    "label": "internal_reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_reserve(n, sizeof(T), max_size())"
  },
  {
    "label": "segment_size()",
    "kind": "Method",
    "detail": "Function (my_early_size = n ; segment_index_t k = 0 ; size_type sz =)",
    "insertText": "segment_size(my_first_block)"
  },
  {
    "label": "loop()",
    "kind": "Method",
    "detail": "Function (internal_loop_guide)",
    "insertText": "loop(sz, my_segment[k].template load<relaxed>().template pointer<void>())"
  },
  {
    "label": "iterate()",
    "kind": "Method",
    "detail": "Function (loop .)",
    "insertText": "iterate(first)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (n - = sz ;)",
    "insertText": "if(!k)"
  },
  {
    "label": "initialize_array()",
    "kind": "Method",
    "detail": "Function (} template<T,class A> void concurrent_vector<T,A)",
    "insertText": "initialize_array(void* begin, const void *, size_type n)"
  },
  {
    "label": "loop()",
    "kind": "Method",
    "detail": "Function (internal_loop_guide)",
    "insertText": "loop(n, begin)"
  },
  {
    "label": "initialize_array_by()",
    "kind": "Method",
    "detail": "Function (} template<T,class A> void concurrent_vector<T,A)",
    "insertText": "initialize_array_by(void* begin, const void *src, size_type n)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (loop .)",
    "insertText": "init(src)"
  },
  {
    "label": "loop()",
    "kind": "Method",
    "detail": "Function (internal_loop_guide)",
    "insertText": "loop(n, dst)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (loop .)",
    "insertText": "copy(src)"
  },
  {
    "label": "move_construct()",
    "kind": "Method",
    "detail": "Function (loop .)",
    "insertText": "move_construct(src)"
  },
  {
    "label": "move_assign()",
    "kind": "Method",
    "detail": "Function (loop .)",
    "insertText": "move_assign(src)"
  },
  {
    "label": "move_construct_if_noexcept()",
    "kind": "Method",
    "detail": "Function (loop .)",
    "insertText": "move_construct_if_noexcept(src)"
  },
  {
    "label": "iterate()",
    "kind": "Method",
    "detail": "Function (loop .)",
    "insertText": "iterate(*(static_cast<I*>(const_cast<void*>(p_type_erased_iterator))))"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (loop .)",
    "insertText": "assign(src)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(_MSC_VER) && !defined(__INTEL_COMPILER) #pragma warning (push) #pragma warning (disable: 4189) #endif template<typename T, class A> void concurrent_vector<T, A>::destroy_array( void* begin, size_type n)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T* array = static_cast<)",
    "insertText": "T(begin)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(_MSC_VER) && !defined(__INTEL_COMPILER) #pragma warning (pop) #endif template<typename T, class A1, class A2> inline bool operator==(const concurrent_vector<T, A1> &a, const concurrent_vector<T, A2> &b)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (concurrent_vector<T,A1>::const_iterator)",
    "insertText": "i(a.begin())"
  },
  {
    "label": "j()",
    "kind": "Method",
    "detail": "Function (concurrent_vector<T,A2>::const_iterator)",
    "insertText": "j(b.begin())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,class A1,class A2> bool)",
    "insertText": "operator(const concurrent_vector<T, A1> &a, const concurrent_vector<T, A2> &b)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} template<T,class A> void)",
    "insertText": "swap(concurrent_vector<T, A> &a, concurrent_vector<T, A> &b)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (a .)",
    "insertText": "swap(b)"
  }
]