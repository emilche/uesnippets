[
  {
    "label": "Fun",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Fun"
  },
  {
    "label": "GeneratorType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GeneratorType"
  },
  {
    "label": "EquivalenceClassType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EquivalenceClassType"
  },
  {
    "label": "OrderedEquivalenceClasses",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OrderedEquivalenceClasses"
  },
  {
    "label": "GivenDeclaration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GivenDeclaration"
  },
  {
    "label": "Expect",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Expect"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "ExpectNot",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectNot"
  },
  {
    "label": "ExpectSameHash",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectSameHash"
  },
  {
    "label": "Prof",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Prof"
  },
  {
    "label": "ExpectMoveConstructOneGenerator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectMoveConstructOneGenerator"
  },
  {
    "label": "ExpectCopyConstructOneGenerator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectCopyConstructOneGenerator"
  },
  {
    "label": "ExpectDefaultConstructWithDestruct",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectDefaultConstructWithDestruct"
  },
  {
    "label": "ExpectDefaultConstructWithMoveAssign",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectDefaultConstructWithMoveAssign"
  },
  {
    "label": "ExpectDefaultConstructWithCopyAssign",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectDefaultConstructWithCopyAssign"
  },
  {
    "label": "ExpectSelfMoveAssign",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectSelfMoveAssign"
  },
  {
    "label": "ExpectSelfCopyAssign",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectSelfCopyAssign"
  },
  {
    "label": "ExpectSelfSwap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectSelfSwap"
  },
  {
    "label": "ExpectSelfComparison",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectSelfComparison"
  },
  {
    "label": "ExpectConsistency",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectConsistency"
  },
  {
    "label": "ExpectMoveAssign",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectMoveAssign"
  },
  {
    "label": "Fun0",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Fun0"
  },
  {
    "label": "Fun1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Fun1"
  },
  {
    "label": "ExpectCopyAssign",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectCopyAssign"
  },
  {
    "label": "ExpectSwap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectSwap"
  },
  {
    "label": "ExpectEquivalenceClassComparison",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectEquivalenceClassComparison"
  },
  {
    "label": "ExpectEquivalenceClassConsistency",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectEquivalenceClassConsistency"
  },
  {
    "label": "ExpectEquivalenceClassComparisons",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectEquivalenceClassComparisons"
  },
  {
    "label": "ExpectEquivalenceClass",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectEquivalenceClass"
  },
  {
    "label": "SmallGenerator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallGenerator"
  },
  {
    "label": "ExpectBiggerGeneratorThanComparisons",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectBiggerGeneratorThanComparisons"
  },
  {
    "label": "BigGenerator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BigGenerator"
  },
  {
    "label": "ExpectBiggerGeneratorThan",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectBiggerGeneratorThan"
  },
  {
    "label": "ExpectBiggerGeneratorThanEqClassesComparisons",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectBiggerGeneratorThanEqClassesComparisons"
  },
  {
    "label": "BigEqClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BigEqClass"
  },
  {
    "label": "ExpectBiggerGeneratorThanEqClasses",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectBiggerGeneratorThanEqClasses"
  },
  {
    "label": "ExpectOrderedEquivalenceClassesComparisons",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectOrderedEquivalenceClassesComparisons"
  },
  {
    "label": "Impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Impl"
  },
  {
    "label": "SmallEqClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallEqClass"
  },
  {
    "label": "ExpectOrderedEquivalenceClasses",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectOrderedEquivalenceClasses"
  },
  {
    "label": "MinProf",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MinProf"
  },
  {
    "label": "MaxProf",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaxProf"
  },
  {
    "label": "ExpectHashable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectHashable"
  },
  {
    "label": "ExpectModels",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectModels"
  },
  {
    "label": "LogicalProf",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LogicalProf"
  },
  {
    "label": "MinimalCheckableProfile",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MinimalCheckableProfile"
  },
  {
    "label": "Always",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Always"
  },
  {
    "label": "ProfileRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ProfileRange"
  },
  {
    "label": "StrictnessDomain",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StrictnessDomain"
  },
  {
    "label": "StrictProfileRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StrictProfileRange"
  },
  {
    "label": "ProfOrRange",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ProfOrRange"
  },
  {
    "label": "MakeStrictProfileRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MakeStrictProfileRange"
  },
  {
    "label": "ProfileRangeOfImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ProfileRangeOfImpl"
  },
  {
    "label": "ProfileRangeOf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ProfileRangeOf"
  },
  {
    "label": "IsProfileOrProfileRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsProfileOrProfileRange"
  },
  {
    "label": "ExpectConformanceOf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpectConformanceOf"
  },
  {
    "label": "ProfRange",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ProfRange"
  },
  {
    "label": "EquivalenceClassMaker",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EquivalenceClassMaker"
  },
  {
    "label": "constexpr_instantiation_when_unevaluated()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_TYPES_INTERNAL_CONFORMANCE_TESTING_H_ # define ABSL_TYPES_INTERNAL_CONFORMANCE_TESTING_H_ # include<cstddef> # include<set> # include<tuple> # include<type_traits> # include<utility> # include \" gtest / gtest . h \" # include \" absl / meta / type_traits . h \" # include \" absl / strings / ascii . h \" # include \" absl / strings / str_cat . h \" # include \" absl / strings / string_view . h \" # include \" absl / types / internal / conformance_aliases . h \" # include \" absl / types / internal / conformance_archetype . h \" # include \" absl / types / internal / conformance_profile . h \" # include \" absl / types / internal / conformance_testing_helpers . h \" # include \" absl / types / internal / parentheses . h \" # include \" absl / types / internal / transform_args . h \" # include \" absl / utility / utility . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace types_internal { bool)",
    "insertText": "constexpr_instantiation_when_unevaluated()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(__apple_build_version__)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# elif)",
    "insertText": "defined(__clang__)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# elif)",
    "insertText": "defined(__GNUC__) return __GNUC__ < 5 || (__GNUC__ == 5 && __GNUC_MINOR__ < 2)"
  },
  {
    "label": "poisoned_hash_fails_instantiation()",
    "kind": "Method",
    "detail": "Function (# else return false ; # endif } bool)",
    "insertText": "poisoned_hash_fails_instantiation()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_MSC_VER) && !defined(_LIBCPP_VERSION)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (# else return false ; # endif } template<class Fun> struct GeneratorType {)",
    "insertText": "decltype(std::declval<const Fun&>()()) operator()() const noexcept(noexcept(std::declval<const Fun&>()()))"
  },
  {
    "label": "Generator()",
    "kind": "Method",
    "detail": "Function (} Fun fun ; const char* description ; } ; template<class Fun,absl::enable_if_t<IsNullaryCallable<Fun>::value>** = nullptr> GeneratorType<Fun>)",
    "insertText": "Generator(Fun fun, const char* description)"
  },
  {
    "label": "EquivalenceClass()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Funs> struct EquivalenceClassType { std::tuple<GeneratorType<Funs> . . .> generators ; } ; template<class . . . Funs,absl::enable_if_t<AreGeneratorsWithTheSameReturnType<Funs . . .>::value>** = nullptr> EquivalenceClassType<Funs . . .>)",
    "insertText": "EquivalenceClass(GeneratorType<Funs>... funs)"
  },
  {
    "label": "outputDeclaration()",
    "kind": "Method",
    "detail": "Function (} template<class . . . EqClasses> struct OrderedEquivalenceClasses { std::tuple<EqClasses . . .> eq_classes ; } ; struct GivenDeclaration { std::string)",
    "insertText": "outputDeclaration(std::size_t width)"
  },
  {
    "label": "StrCat()",
    "kind": "Method",
    "detail": "Function (const std::size_t indent_size = 2 ; std::string result =)",
    "insertText": "StrCat(\" \", name)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (result .)",
    "insertText": "resize(indent_size + width, ' ')"
  },
  {
    "label": "StrAppend()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StrAppend(&result, \" = \", expression, \";\\n\")"
  },
  {
    "label": "StrAppend()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "StrAppend(&result, \";\\n\")"
  },
  {
    "label": "PrepareGivenContext()",
    "kind": "Method",
    "detail": "Function (} return result ; } std::string name ; std::string expression ; } ; template<class . . . Decls> std::string)",
    "insertText": "PrepareGivenContext(const Decls&... decls)"
  },
  {
    "label": "width()",
    "kind": "Method",
    "detail": "Function (const std::size_t)",
    "insertText": "width(std::max)({decls.name.size()...})"
  },
  {
    "label": "ABSL_INTERNAL_EXPECT_OP()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "ABSL_INTERNAL_EXPECT_OP(name, op)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (\\ template<class T> \\ void)",
    "insertText": "operator()(absl::string_view test_name, absl::string_view context, \\ const T& lhs, const T& rhs, absl::string_view lhs_name, \\ absl::string_view rhs_name)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(!static_cast<bool>(lhs op rhs))"
  },
  {
    "label": "addTestFailure()",
    "kind": "Method",
    "detail": "Function (\\ errors ->)",
    "insertText": "addTestFailure(\\ test_name, absl::StrCat(context, \\ \"**Unexpected comparison result**\\n\" \\ \"\\n\" \\ \"Expression:\\n\" \\ \" \", \\ lhs_name, \" \" #op \" \", rhs_name, \\ \"\\n\" \\ \"\\n\" \\ \"Expected: true\\n\" \\ \" Actual: false\"))"
  },
  {
    "label": "addTestSuccess()",
    "kind": "Method",
    "detail": "Function (\\ } else { \\ errors ->)",
    "insertText": "addTestSuccess(test_name)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(lhs op rhs)"
  },
  {
    "label": "addTestFailure()",
    "kind": "Method",
    "detail": "Function (\\ errors ->)",
    "insertText": "addTestFailure(\\ test_name, absl::StrCat(context, \\ \"**Unexpected comparison result**\\n\" \\ \"\\n\" \\ \"Expression:\\n\" \\ \" \", \\ lhs_name, \" \" #op \" \", rhs_name, \\ \"\\n\" \\ \"\\n\" \\ \"Expected: false\\n\" \\ \" Actual: true\"))"
  },
  {
    "label": "ABSL_INTERNAL_EXPECT_OP()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } \\ \\ ConformanceErrors* errors ; \\ })",
    "insertText": "ABSL_INTERNAL_EXPECT_OP(Eq, ==)"
  },
  {
    "label": "ABSL_INTERNAL_EXPECT_OP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_EXPECT_OP(Ne, !=)"
  },
  {
    "label": "ABSL_INTERNAL_EXPECT_OP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_EXPECT_OP(Lt, <)"
  },
  {
    "label": "ABSL_INTERNAL_EXPECT_OP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_EXPECT_OP(Le, <=)"
  },
  {
    "label": "ABSL_INTERNAL_EXPECT_OP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_EXPECT_OP(Ge, >=)"
  },
  {
    "label": "ABSL_INTERNAL_EXPECT_OP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_EXPECT_OP(Gt, >)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# undef ABSL_INTERNAL_EXPECT_OP struct ExpectSameHash { template<class T> void)",
    "insertText": "operator()(absl::string_view test_name, absl::string_view context, const T& lhs, const T& rhs, absl::string_view lhs_name, absl::string_view rhs_name)"
  },
  {
    "label": "addTestFailure()",
    "kind": "Method",
    "detail": "Function (errors ->)",
    "insertText": "addTestFailure(test_name, absl::StrCat(context, \"**Unexpected hash result**\\n\" \"\\n\" \"Expression:\\n\" \" std::hash<T>()(\", lhs_name, \") == std::hash<T>()(\", rhs_name, \")\\n\" \"\\n\" \"Expected: true\\n\" \" Actual: false\"))"
  },
  {
    "label": "ExpectOneWayEquality()",
    "kind": "Method",
    "detail": "Function (} } ConformanceErrors* errors ; } ; template<class T,class Prof> void)",
    "insertText": "ExpectOneWayEquality(ConformanceErrors* errors, absl::string_view test_name, absl::string_view context, const T& lhs, const T& rhs, absl::string_view lhs_name, absl::string_view rhs_name)"
  },
  {
    "label": "ExpectEquality()",
    "kind": "Method",
    "detail": "Function (} template<class T,class Prof> void)",
    "insertText": "ExpectEquality(ConformanceErrors* errors, absl::string_view test_name, absl::string_view context, const T& lhs, const T& rhs, absl::string_view lhs_name, absl::string_view rhs_name)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T,class Prof> struct ExpectMoveConstructOneGenerator { template<class Fun> void)",
    "insertText": "operator()(const Fun& generator)"
  },
  {
    "label": "generator()",
    "kind": "Method",
    "detail": "Function (const T object =)",
    "insertText": "generator()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (const T moved_object =)",
    "insertText": "move(generator())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T copied_object = static_cast<const)",
    "insertText": "T(generator())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ConformanceErrors* errors ; } ; template<class T> struct ExpectDefaultConstructWithDestruct { void)",
    "insertText": "operator()()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function ({ T object ; static_cast<)",
    "insertText": "void(object)"
  },
  {
    "label": "addTestSuccess()",
    "kind": "Method",
    "detail": "Function (} errors ->)",
    "insertText": "addTestSuccess(\"Default construction\")"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (object =)",
    "insertText": "move(object)"
  },
  {
    "label": "const_object()",
    "kind": "Method",
    "detail": "Function (const T& const_object = object ; object =)",
    "insertText": "const_object(ExpectEquality<T, Prof>)(errors, \"Copy assignment\", PrepareGivenContext( GivenDeclaration{\"const _T source_of_truth\", generator.description}, GivenDeclaration{\"_T object\", generator.description}, GivenDeclaration{\"object\", \"std::as_const(object)\"}), const_object, source_of_truth, \"std::as_const(object)\", \"source_of_truth\")"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(object, object)"
  },
  {
    "label": "StrCat()",
    "kind": "Method",
    "detail": "Function (std::string preliminary_info =)",
    "insertText": "StrCat(PrepareGivenContext( GivenDeclaration{\"const _T source_of_truth\", generator.description}, GivenDeclaration{\"_T object\", generator.description}), \"After performing a self-swap:\\n\" \" using std::swap;\\n\" \" swap(object, object);\\n\" \"\\n\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ConformanceErrors* errors ; } ; template<class T,class Prof> struct ExpectMoveAssign { template<class Fun0,class Fun1> void)",
    "insertText": "operator()(const Fun0& generator0, const Fun1& generator1)"
  },
  {
    "label": "generator1()",
    "kind": "Method",
    "detail": "Function (const T source_of_truth1 =)",
    "insertText": "generator1()"
  },
  {
    "label": "generator0()",
    "kind": "Method",
    "detail": "Function (T object =)",
    "insertText": "generator0()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (object = static_cast<const)",
    "insertText": "T(generator1())"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(object0, object1)"
  },
  {
    "label": "PrepareGivenContext()",
    "kind": "Method",
    "detail": "Function (const std::string context =)",
    "insertText": "PrepareGivenContext(GivenDeclaration{\"const _T source_of_truth0\", generator0.description}, GivenDeclaration{\"const _T source_of_truth1\", generator1.description}, GivenDeclaration{\"_T object0\", generator0.description}, GivenDeclaration{\"_T object1\", generator1.description})"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (\\ n \" \")",
    "insertText": "swap(object0, object1)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (\\ n \" \" \\)",
    "insertText": "n(ExpectEquality<T, Prof>)(errors, \"Swap\", context, object0, source_of_truth1, \"std::as_const(object0)\", \"source_of_truth1\")"
  },
  {
    "label": "ExpectOrdered()",
    "kind": "Method",
    "detail": "Function (} ConformanceErrors* errors ; } ; template<class T,class Prof> void)",
    "insertText": "ExpectOrdered(ConformanceErrors* errors, absl::string_view context, const T& small, const T& big, absl::string_view small_name, absl::string_view big_name)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (const absl::string_view test_name = \" Comparison \" ; If<PropertiesOfT<Prof>::is_equality_comparable)",
    "insertText": "Invoke(ExpectNotEq{errors}, test_name, context, small, big, small_name, big_name)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T,class Prof> struct ExpectEquivalenceClassComparisons { template<class . . . Funs> void)",
    "insertText": "operator()(EquivalenceClassType<Funs...> eq_class)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ConformanceErrors* errors ; } ; template<class T,class Prof,class SmallGenerator> struct ExpectBiggerGeneratorThanComparisons { template<class BigGenerator> void)",
    "insertText": "operator()(BigGenerator big_gen)"
  },
  {
    "label": "small_gen()",
    "kind": "Method",
    "detail": "Function (const T small =)",
    "insertText": "small_gen()"
  },
  {
    "label": "big_gen()",
    "kind": "Method",
    "detail": "Function (const T big =)",
    "insertText": "big_gen()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} SmallGenerator small_gen ; ConformanceErrors* errors ; } ; template<class T,class Prof,class SmallGenerator> struct ExpectBiggerGeneratorThanEqClassesComparisons { template<class BigEqClass> void)",
    "insertText": "operator()(BigEqClass big_eq_class)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} SmallGenerator small_gen ; ConformanceErrors* errors ; } ; template<class T,class Prof> struct ExpectOrderedEquivalenceClassesComparisons { template<class . . . BigEqClasses> struct Impl { template<class SmallGenerator> void)",
    "insertText": "operator()(SmallGenerator small_gen)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class SmallEqClass,class . . . BigEqClasses> void)",
    "insertText": "operator()(SmallEqClass small_eq_class, BigEqClasses... big_eq_classes)"
  },
  {
    "label": "MaxProf()",
    "kind": "Method",
    "detail": "Function (ExpectModelOfHashable<T,MinProf,)",
    "insertText": "MaxProf(errors)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ConformanceErrors* errors ; } ; template<class T,class MinProf,class MaxProf> struct ExpectModels { void)",
    "insertText": "operator()(ConformanceErrors* errors)"
  },
  {
    "label": "ExpectRegularityImpl()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> struct Always { using type = T ; } ; template<class T,class LogicalProf,class MinProf,class MaxProf,class . . . EqClasses> ConformanceErrors)",
    "insertText": "ExpectRegularityImpl(OrderedEquivalenceClasses<EqClasses...> vals)"
  },
  {
    "label": "errors()",
    "kind": "Method",
    "detail": "Function (ConformanceErrors)",
    "insertText": "errors((NameOf<T>()))"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "apply(ExpectOrderedEquivalenceClassesComparisons<T, minimal_profile>{&errors}, vals.eq_classes)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "apply(ExpectOrderedEquivalenceClasses<T, minimal_profile>{&errors}, vals.eq_classes)"
  },
  {
    "label": "initializer()",
    "kind": "Method",
    "detail": "Function (using strictness_domain = StrictnessDomain ; using logical_profile = LogicalProf ; using min_profile = MinProf ; using max_profile = MaxProf ; } ; template<class StrictnessDomain,class ProfOrRange> struct MakeStrictProfileRange ; template<class StrictnessDomain,class LogicalProf> struct MakeStrictProfileRange { using type = StrictProfileRange<StrictnessDomain,LogicalProf> ; } ; template<class StrictnessDomain,class LogicalProf,class MinProf,class MaxProf> struct MakeStrictProfileRange<StrictnessDomain,ProfileRange<LogicalProf,MinProf,MaxProf>> { using type = StrictProfileRange<StrictnessDomain,LogicalProf,MinProf,MaxProf> ; } ; template<class StrictnessDomain,class ProfOrRange> using MakeStrictProfileRangeT = MakeStrictProfileRange<StrictnessDomain,ProfOrRange>::type ; using MostStrictProfile = CombineProfiles<TriviallyCompleteProfile,NothrowComparableProfile> ; template<class LogicalProf,class MinProf = LogicalProf> using LooseProfileRange = StrictProfileRange<RegularityDomain,LogicalProf,MinProf,MostStrictProfile> ; template<class Prof> using MakeLooseProfileRangeT = Prof ; template<class T,class = void> struct ProfileRangeOfImpl ; template<class T> struct ProfileRangeOfImpl<T,absl::void_t<PropertiesOfT<T>>> { using type = LooseProfileRange<T> ; } ; template<class T> struct ProfileRangeOf : ProfileRangeOfImpl<T> { } ; template<class StrictnessDomain,class LogicalProf,class MinProf,class MaxProf> struct ProfileRangeOf<StrictProfileRange<StrictnessDomain,LogicalProf,MinProf,MaxProf>> { using type = StrictProfileRange<StrictnessDomain,LogicalProf,MinProf,MaxProf> ; } ; template<class T> using ProfileRangeOfT = ProfileRangeOf<T>::type ; template<class T> using LogicalProfileOfT = ProfileRangeOfT<T>::logical_profile ; template<class T> using MinProfileOfT = ProfileRangeOfT<T>::min_profile ; template<class T> using MaxProfileOfT = ProfileRangeOfT<T>::max_profile ; template<class T> struct IsProfileOrProfileRange : IsProfile<T>::type { } ; template<class StrictnessDomain,class LogicalProf,class MinProf,class MaxProf> struct IsProfileOrProfileRange<StrictProfileRange<StrictnessDomain,LogicalProf,MinProf,MaxProf>> : std::true_type { } ; template<bool ExpectSuccess,class T,class . . . EqClasses> struct ExpectConformanceOf { template<class Fun,absl::enable_if_t<std::is_same<ResultOfGeneratorT<GeneratorType<Fun>>,T>::value>** = nullptr> ABSL_MUST_USE_RESULT ExpectConformanceOf<ExpectSuccess,T,EqClasses . . .,EquivalenceClassType<Fun>>)",
    "insertText": "initializer(GeneratorType<Fun> fun)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} template<class . . . TestNames,absl::enable_if_t<! ExpectSuccess&&)",
    "insertText": "sizeof(EqClasses) == 0 && absl::conjunction<std::is_convertible< TestNames, absl::string_view>...>::value>** = nullptr> ABSL_MUST_USE_RESULT ExpectConformanceOf<ExpectSuccess, T, EqClasses...> due_to(TestNames&&... test_names)"
  },
  {
    "label": "dont_class_directly_stateful_initializer()",
    "kind": "Method",
    "detail": "Function (} template<class Fun,absl::enable_if_t<std::is_same<ResultOfGeneratorT<GeneratorType<Fun>>,T>::value>** = nullptr> ABSL_MUST_USE_RESULT ExpectConformanceOf<ExpectSuccess,T,EqClasses . . .,EquivalenceClassType<Fun>>)",
    "insertText": "dont_class_directly_stateful_initializer(GeneratorType<Fun> fun)"
  },
  {
    "label": "equivalence_class()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Funs,absl::void_t<absl::enable_if_t<std::is_same<ResultOfGeneratorT<GeneratorType<Funs>>,T>::value> . . .>** = nullptr> ABSL_MUST_USE_RESULT ExpectConformanceOf<ExpectSuccess,T,EqClasses . . .,EquivalenceClassType<Funs . . .>>)",
    "insertText": "equivalence_class(GeneratorType<Funs>... funs)"
  },
  {
    "label": "with_strict_profile()",
    "kind": "Method",
    "detail": "Function (} template<class ProfRange,absl::enable_if_t<IsProfileOrProfileRange<ProfRange>::value>** = nullptr> ABSL_MUST_USE_RESULT::testing::AssertionResult)",
    "insertText": "with_strict_profile(ProfRange)"
  },
  {
    "label": "test_result()",
    "kind": "Method",
    "detail": "Function (ConformanceErrors)",
    "insertText": "test_result(ExpectRegularityImpl< T, LogicalProfileOfT<ProfRange>, MinProfileOfT<ProfRange>, MaxProfileOfT<ProfRange>>)(absl::move(ordered_vals))"
  },
  {
    "label": "with_loose_profile()",
    "kind": "Method",
    "detail": "Function (} template<class Prof,absl::enable_if_t<IsProfile<Prof>::value>** = nullptr> ABSL_MUST_USE_RESULT::testing::AssertionResult)",
    "insertText": "with_loose_profile(Prof)"
  },
  {
    "label": "test_result()",
    "kind": "Method",
    "detail": "Function (ConformanceErrors)",
    "insertText": "test_result(ExpectRegularityImpl< T, Prof, Prof, CombineProfiles<TriviallyCompleteProfile, NothrowComparableProfile>>)(absl:: move(ordered_vals))"
  },
  {
    "label": "GTEST_FATAL_FAILURE_()",
    "kind": "Method",
    "detail": "Function (\\ else)",
    "insertText": "GTEST_FATAL_FAILURE_(gtest_ar.failure_message()) #define WITH_STRICT_PROFILE(...) \\ with_strict_profile( \\ ::absl::types_internal::MakeStrictProfileRangeT<__VA_ARGS__>())"
  }
]