[
  {
    "label": "arpack_wrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "arpack_wrapper"
  },
  {
    "label": "OP",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OP"
  },
  {
    "label": "ArpackGeneralizedSelfAdjointEigenSolver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ArpackGeneralizedSelfAdjointEigenSolver"
  },
  {
    "label": "arpack_wrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "arpack_wrapper"
  },
  {
    "label": "arpack_wrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "arpack_wrapper"
  },
  {
    "label": "arpack_wrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "arpack_wrapper"
  },
  {
    "label": "OP",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OP"
  },
  {
    "label": "OP",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OP"
  },
  {
    "label": "OP",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OP"
  },
  {
    "label": "B()",
    "kind": "Method",
    "detail": "Function (MatrixType)",
    "insertText": "B(0,0)"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (MatrixType::InnerIterator)",
    "insertText": "it(B, i)"
  },
  {
    "label": "AminusSigmaB()",
    "kind": "Method",
    "detail": "Function (MatrixType)",
    "insertText": "AminusSigmaB(A)"
  },
  {
    "label": "ssaupd_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ssaupd_(int *ido, char *bmat, int *n, char *which,\n    int *nev, float *tol, float *resid, int *ncv,\n    float *v, int *ldv, int *iparam, int *ipntr,\n    float *workd, float *workl, int *lworkl,\n    int *info)"
  },
  {
    "label": "sseupd_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sseupd_(int *rvec, char *All, int *select, float *d,\n    float *z, int *ldz, float *sigma, \n    char *bmat, int *n, char *which, int *nev,\n    float *tol, float *resid, int *ncv, float *v,\n    int *ldv, int *iparam, int *ipntr, float *workd,\n    float *workl, int *lworkl, int *ierr)"
  },
  {
    "label": "dsaupd_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dsaupd_(int *ido, char *bmat, int *n, char *which,\n    int *nev, double *tol, double *resid, int *ncv,\n    double *v, int *ldv, int *iparam, int *ipntr,\n    double *workd, double *workl, int *lworkl,\n    int *info)"
  },
  {
    "label": "dseupd_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dseupd_(int *rvec, char *All, int *select, double *d,\n    double *z, int *ldz, double *sigma, \n    char *bmat, int *n, char *which, int *nev,\n    double *tol, double *resid, int *ncv, double *v,\n    int *ldv, int *iparam, int *ipntr, double *workd,\n    double *workl, int *lworkl, int *ierr)"
  },
  {
    "label": "applyOP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applyOP(MatrixSolver &OP, const MatrixType &A, int n, Scalar *in, Scalar *out)"
  },
  {
    "label": "project()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "project(MatrixSolver &OP, int n, int k, Scalar *vecs)"
  }
]