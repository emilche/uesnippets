[
  {
    "label": "TIndexedWeightMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TIndexedWeightMap"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" BoxTypes . h \" # include \" CoreMinimal . h \" # include \" VectorTypes . h \" # include \" IndexTypes . h \" namespace UE { namespace Geometry { template<RealType> class TIndexedWeightMap { public : RealType DefaultValue ; TArray<RealType> Values ; int32)",
    "insertText": "Num()"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetNum(int32 NewNum)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Values .)",
    "insertText": "SetNum(NewNum)"
  },
  {
    "label": "GetValueUnsafe()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "GetValueUnsafe(int32 Index)"
  },
  {
    "label": "GetInterpValueUnsafe()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "GetInterpValueUnsafe(const FIndex3i& Indices, const FVector3d& BaryCoords)"
  },
  {
    "label": "GetInterpValue()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "GetInterpValue(const FIndex3i& Indices, const FVector3d& BaryCoords)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (RealType A =)",
    "insertText": "GetValue(Indices.A)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (RealType B =)",
    "insertText": "GetValue(Indices.B)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (RealType C =)",
    "insertText": "GetValue(Indices.C)"
  },
  {
    "label": "InvertWeightMap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InvertWeightMap(TInterval1<RealType> Range = TInterval1<RealType>((RealType)0, (RealType)1.0))"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (Values [ k ] = Range .)",
    "insertText": "Clamp((Range.Max - (Values[k] - Range.Min)))"
  }
]