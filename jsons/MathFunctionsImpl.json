[
  {
    "label": "hypot_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "hypot_impl"
  },
  {
    "label": "generic_fast_tanh_float()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_MATHFUNCTIONSIMPL_H # define EIGEN_MATHFUNCTIONSIMPL_H namespace Eigen { namespace internal { template<T> T)",
    "insertText": "generic_fast_tanh_float(const T& a_x)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_VECTORIZE_FMA const T plus_clamp = pset1<)",
    "insertText": "T(7.99881172180175781f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T minus_clamp = pset1<)",
    "insertText": "T(-7.99881172180175781f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (# else const T plus_clamp = pset1<)",
    "insertText": "T(7.90531110763549805f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T minus_clamp = pset1<)",
    "insertText": "T(-7.90531110763549805f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (# endif const T tiny = pset1<)",
    "insertText": "T(0.0004f)"
  },
  {
    "label": "pmax()",
    "kind": "Method",
    "detail": "Function (const T x =)",
    "insertText": "pmax(pmin(a_x, plus_clamp), minus_clamp)"
  },
  {
    "label": "pcmp_lt()",
    "kind": "Method",
    "detail": "Function (const T tiny_mask =)",
    "insertText": "pcmp_lt(pabs(a_x), tiny)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_1 = pset1<)",
    "insertText": "T(4.89352455891786e-03f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_3 = pset1<)",
    "insertText": "T(6.37261928875436e-04f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_5 = pset1<)",
    "insertText": "T(1.48572235717979e-05f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_7 = pset1<)",
    "insertText": "T(5.12229709037114e-08f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_9 = pset1<)",
    "insertText": "T(-8.60467152213735e-11f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_11 = pset1<)",
    "insertText": "T(2.00018790482477e-13f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T alpha_13 = pset1<)",
    "insertText": "T(-2.76076847742355e-16f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T beta_0 = pset1<)",
    "insertText": "T(4.89352518554385e-03f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T beta_2 = pset1<)",
    "insertText": "T(2.26843463243900e-03f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T beta_4 = pset1<)",
    "insertText": "T(1.18534705686654e-04f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T beta_6 = pset1<)",
    "insertText": "T(1.19825839466702e-06f)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (const T x2 =)",
    "insertText": "pmul(x, x)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (T p =)",
    "insertText": "pmadd(x2, alpha_13, alpha_11)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_9)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_7)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_5)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_3)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_1)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmul(x, p)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (T q =)",
    "insertText": "pmadd(x2, beta_6, beta_4)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (q =)",
    "insertText": "pmadd(x2, q, beta_2)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (q =)",
    "insertText": "pmadd(x2, q, beta_0)"
  },
  {
    "label": "positive_real_hypot()",
    "kind": "Method",
    "detail": "Function (} template<RealScalar> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE RealScalar)",
    "insertText": "positive_real_hypot(const RealScalar& x, const RealScalar& y)"
  },
  {
    "label": "EIGEN_USING_STD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_USING_STD(sqrt)"
  },
  {
    "label": "maxi()",
    "kind": "Method",
    "detail": "Function (RealScalar p,qp ; p =)",
    "insertText": "maxi(x,y)"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (qp =)",
    "insertText": "mini(y,x)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} template<Scalar> struct hypot_impl { typedef NumTraits<Scalar>::Real RealScalar ; EIGEN_DEVICE_FUNC RealScalar)",
    "insertText": "run(const Scalar& x, const Scalar& y)"
  },
  {
    "label": "EIGEN_USING_STD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_USING_STD(abs)"
  },
  {
    "label": "complex_sqrt()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> EIGEN_DEVICE_FUNC std::complex<T>)",
    "insertText": "complex_sqrt(const std::complex<T>& z)"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (const T x =)",
    "insertText": "real(z)"
  },
  {
    "label": "imag()",
    "kind": "Method",
    "detail": "Function (const T y =)",
    "insertText": "imag(z)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T zero =)",
    "insertText": "T(0)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (const T w =)",
    "insertText": "sqrt(T(0.5) * (numext::abs(x) + numext::hypot(x, y)))"
  },
  {
    "label": "complex_rsqrt()",
    "kind": "Method",
    "detail": "Function (} template<T> EIGEN_DEVICE_FUNC std::complex<T>)",
    "insertText": "complex_rsqrt(const std::complex<T>& z)"
  },
  {
    "label": "hypot()",
    "kind": "Method",
    "detail": "Function (const T abs_z =)",
    "insertText": "hypot(x, y)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (const T w =)",
    "insertText": "sqrt(T(0.5) * (numext::abs(x) + abs_z))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T woz = w / abs_z ; return abs_z = = zero ? std::complex<)",
    "insertText": "T(NumTraits<T>::infinity(), NumTraits<T>::quiet_NaN()) : ((numext::isinf)(x) || (numext::isinf)(y)) ? std::complex<T>(zero, zero) : x == zero ? std::complex<T>(woz, y < zero ? woz : -woz) : x > zero ? std::complex<T>(woz, -y / (2 * w * abs_z)) : std::complex<T>(numext::abs(y) / (2 * w * abs_z), y < zero ? woz : -woz)"
  },
  {
    "label": "complex_log()",
    "kind": "Method",
    "detail": "Function (} template<T> EIGEN_DEVICE_FUNC std::complex<T>)",
    "insertText": "complex_log(const std::complex<T>& z)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (T a =)",
    "insertText": "abs(z)"
  },
  {
    "label": "EIGEN_USING_STD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_USING_STD(atan2)"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (T b =)",
    "insertText": "atan2(z.imag(), z.real())"
  }
]