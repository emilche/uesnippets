[
  {
    "label": "FSolverBody",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSolverBody"
  },
  {
    "label": "FSolverBodyContainer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSolverBodyContainer"
  },
  {
    "label": "FState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FState"
  },
  {
    "label": "FConstraintSolverBody",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConstraintSolverBody"
  },
  {
    "label": "CHAOS_CONSTRAINTSOLVER_NAN_DIAGNOSTIC()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" # include \" Math / Quat . h \" # ifndef CHAOS_CONSTRAINTSOLVER_NAN_DIAGNOSTIC # define)",
    "insertText": "CHAOS_CONSTRAINTSOLVER_NAN_DIAGNOSTIC((DO_CHECK && UE_BUILD_DEBUG) || ENABLE_NAN_DIAGNOSTIC) #endif #define CHAOS_CONSTRAINTSOLVER_LOWPRECISION 1 #if CHAOS_CONSTRAINTSOLVER_NAN_DIAGNOSTIC inline void ChaosSolverCheckNaN(const Chaos::FRealSingle& V)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ChaosSolverCheckNaN(const Chaos::TVec3<Chaos::FRealSingle>& V)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ChaosSolverCheckNaN(const Chaos::TRotation3<Chaos::FRealSingle>& V)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ChaosSolverCheckNaN(const Chaos::FRealDouble& V)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ChaosSolverCheckNaN(const Chaos::TVec3<Chaos::FRealDouble>& V)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ChaosSolverCheckNaN(const Chaos::TRotation3<Chaos::FRealDouble>& V)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (} # else # define)",
    "insertText": "ChaosSolverCheckNaN(...)"
  },
  {
    "label": "SolverQuaternionNormalizeApprox()",
    "kind": "Method",
    "detail": "Function (# if CHAOS_CONSTRAINTSOLVER_LOWPRECISION using FSolverReal = FRealSingle ; using SolverVectorRegister = VectorRegister4Float ; # else using FSolverReal = FReal ; using SolverVectorRegister = VectorRegister4 ; # endif using FSolverVec3 = TVec3<FSolverReal> ; using FSolverRotation3 = TRotation3<FSolverReal> ; using FSolverMatrix33 = TMatrix33<FSolverReal> ; class FSolverBody ; class FSolverBodyContainer ; using FSolverBodyPtrPair = TVector<FSolverBody*,2> ; void)",
    "insertText": "SolverQuaternionNormalizeApprox(FRotation3& InOutQ)"
  },
  {
    "label": "SolverQuaternionApplyAngularDeltaApprox()",
    "kind": "Method",
    "detail": "Function (FRotation3)",
    "insertText": "SolverQuaternionApplyAngularDeltaApprox(const FRotation3& InQ0, const FVec3& InDR)"
  },
  {
    "label": "ZeroMassThreshold()",
    "kind": "Method",
    "detail": "Function (class FSolverBody { public : FSolverReal)",
    "insertText": "ZeroMassThreshold()"
  },
  {
    "label": "MakeInitialized()",
    "kind": "Method",
    "detail": "Function (} FSolverBody)",
    "insertText": "MakeInitialized()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (FSolverBody SolverBody ; SolverBody . State .)",
    "insertText": "Init()"
  },
  {
    "label": "FSolverBody()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSolverBody()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "FSolverVec3()",
    "kind": "Method",
    "detail": "Function (State . DP =)",
    "insertText": "FSolverVec3(0)"
  },
  {
    "label": "SetImplicitVelocity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetImplicitVelocity(FReal Dt)"
  },
  {
    "label": "FSolverReal()",
    "kind": "Method",
    "detail": "Function (const FSolverReal InvDt =)",
    "insertText": "FSolverReal(1) / FSolverReal(Dt)"
  },
  {
    "label": "SetV()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetV(State.V + FVec3((State.DP - State.CP) * InvDt))"
  },
  {
    "label": "SetW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetW(State.W + FVec3((State.DQ - State.CQ) * InvDt))"
  },
  {
    "label": "InvM()",
    "kind": "Method",
    "detail": "Function (} } FSolverReal)",
    "insertText": "InvM()"
  },
  {
    "label": "FSolverReal()",
    "kind": "Method",
    "detail": "Function (State . InvM =)",
    "insertText": "FSolverReal(InInvM)"
  },
  {
    "label": "InvI()",
    "kind": "Method",
    "detail": "Function (} const FSolverMatrix33&)",
    "insertText": "InvI()"
  },
  {
    "label": "FSolverMatrix33()",
    "kind": "Method",
    "detail": "Function (State . InvI =)",
    "insertText": "FSolverMatrix33(InInvI)"
  },
  {
    "label": "InvILocal()",
    "kind": "Method",
    "detail": "Function (} const FSolverVec3&)",
    "insertText": "InvILocal()"
  },
  {
    "label": "FSolverVec3()",
    "kind": "Method",
    "detail": "Function (State . InvILocal =)",
    "insertText": "FSolverVec3(InInvILocal)"
  },
  {
    "label": "UpdateRotationDependentState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateRotationDependentState()"
  },
  {
    "label": "CoMTransform()",
    "kind": "Method",
    "detail": "Function (} FRigidTransform3)",
    "insertText": "CoMTransform()"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (} const FVec3&)",
    "insertText": "X()"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (State . X = InX ; } const FRotation3&)",
    "insertText": "R()"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChaosSolverCheckNaN(InR)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (State . R = InR ; } const FVec3&)",
    "insertText": "P()"
  },
  {
    "label": "Q()",
    "kind": "Method",
    "detail": "Function (State . P = InP ; } const FRotation3&)",
    "insertText": "Q()"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChaosSolverCheckNaN(InQ)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (State . Q = InQ ; } const FSolverVec3&)",
    "insertText": "V()"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChaosSolverCheckNaN(InV)"
  },
  {
    "label": "FSolverVec3()",
    "kind": "Method",
    "detail": "Function (State . V =)",
    "insertText": "FSolverVec3(InV)"
  },
  {
    "label": "W()",
    "kind": "Method",
    "detail": "Function (} const FSolverVec3&)",
    "insertText": "W()"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChaosSolverCheckNaN(InW)"
  },
  {
    "label": "FSolverVec3()",
    "kind": "Method",
    "detail": "Function (State . W =)",
    "insertText": "FSolverVec3(InW)"
  },
  {
    "label": "CoM()",
    "kind": "Method",
    "detail": "Function (} const FVec3&)",
    "insertText": "CoM()"
  },
  {
    "label": "RoM()",
    "kind": "Method",
    "detail": "Function (State . CoM = InCoM ; } const FRotation3&)",
    "insertText": "RoM()"
  },
  {
    "label": "DP()",
    "kind": "Method",
    "detail": "Function (State . RoM = InRoM ; } const FSolverVec3&)",
    "insertText": "DP()"
  },
  {
    "label": "DQ()",
    "kind": "Method",
    "detail": "Function (State . DP = InDP ; } const FSolverVec3&)",
    "insertText": "DQ()"
  },
  {
    "label": "CP()",
    "kind": "Method",
    "detail": "Function (State . DQ = InDQ ; } const FSolverVec3&)",
    "insertText": "CP()"
  },
  {
    "label": "CorrectedQ()",
    "kind": "Method",
    "detail": "Function (} FRotation3)",
    "insertText": "CorrectedQ()"
  },
  {
    "label": "ApplyCorrections()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ApplyCorrections()"
  },
  {
    "label": "CorrectedP()",
    "kind": "Method",
    "detail": "Function (State . P =)",
    "insertText": "CorrectedP()"
  },
  {
    "label": "ActorP()",
    "kind": "Method",
    "detail": "Function (} FVec3)",
    "insertText": "ActorP()"
  },
  {
    "label": "ActorQ()",
    "kind": "Method",
    "detail": "Function (} FRotation3)",
    "insertText": "ActorQ()"
  },
  {
    "label": "CorrectedActorP()",
    "kind": "Method",
    "detail": "Function (} FVec3)",
    "insertText": "CorrectedActorP()"
  },
  {
    "label": "CorrectedActorQ()",
    "kind": "Method",
    "detail": "Function (} FRotation3)",
    "insertText": "CorrectedActorQ()"
  },
  {
    "label": "Level()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Level()"
  },
  {
    "label": "IsDynamic()",
    "kind": "Method",
    "detail": "Function (State . Level = InLevel ; } bool)",
    "insertText": "IsDynamic()"
  },
  {
    "label": "ApplyTransformDelta()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ApplyTransformDelta(const FSolverVec3& DP, const FSolverVec3& DR)"
  },
  {
    "label": "ApplyPositionDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionDelta(DP)"
  },
  {
    "label": "ApplyRotationDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRotationDelta(DR)"
  },
  {
    "label": "ApplyPositionDelta()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ApplyPositionDelta(const FSolverVec3& DP)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChaosSolverCheckNaN(DP)"
  },
  {
    "label": "ApplyRotationDelta()",
    "kind": "Method",
    "detail": "Function (State . DP + = DP ; } void)",
    "insertText": "ApplyRotationDelta(const FSolverVec3& DR)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChaosSolverCheckNaN(DR)"
  },
  {
    "label": "ApplyPositionCorrectionDelta()",
    "kind": "Method",
    "detail": "Function (State . DQ + = DR ; } void)",
    "insertText": "ApplyPositionCorrectionDelta(const FSolverVec3& CP)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChaosSolverCheckNaN(CP)"
  },
  {
    "label": "ApplyRotationCorrectionDelta()",
    "kind": "Method",
    "detail": "Function (State . CP + = CP ; State . DP + = CP ; } void)",
    "insertText": "ApplyRotationCorrectionDelta(const FSolverVec3& CR)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChaosSolverCheckNaN(CR)"
  },
  {
    "label": "ApplyVelocityDelta()",
    "kind": "Method",
    "detail": "Function (State . CQ + = CR ; State . DQ + = CR ; } void)",
    "insertText": "ApplyVelocityDelta(const FSolverVec3& DV, const FSolverVec3& DW)"
  },
  {
    "label": "ApplyLinearVelocityDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyLinearVelocityDelta(DV)"
  },
  {
    "label": "ApplyAngularVelocityDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAngularVelocityDelta(DW)"
  },
  {
    "label": "ApplyLinearVelocityDelta()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ApplyLinearVelocityDelta(const FSolverVec3& DV)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChaosSolverCheckNaN(DV)"
  },
  {
    "label": "ApplyAngularVelocityDelta()",
    "kind": "Method",
    "detail": "Function (State . V + = DV ; } void)",
    "insertText": "ApplyAngularVelocityDelta(const FSolverVec3& DW)"
  },
  {
    "label": "ChaosSolverCheckNaN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ChaosSolverCheckNaN(DW)"
  },
  {
    "label": "SetW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetW(State.W + DW)"
  },
  {
    "label": "EnforceShortestRotationTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EnforceShortestRotationTo(const FRotation3& InQ)"
  },
  {
    "label": "EnforceShortestArcWith()",
    "kind": "Method",
    "detail": "Function (State . Q .)",
    "insertText": "EnforceShortestArcWith(InQ)"
  },
  {
    "label": "PrefetchPositionSolverData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrefetchPositionSolverData()"
  },
  {
    "label": "PrefetchBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrefetchBlock(&State.DP, 8 * sizeof(float))"
  },
  {
    "label": "PrefetchVelocitySolverData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PrefetchVelocitySolverData()"
  },
  {
    "label": "PrefetchBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrefetchBlock(&State.V, 8 * sizeof(float))"
  },
  {
    "label": "FState()",
    "kind": "Method",
    "detail": "Function (} private : struct FState {)",
    "insertText": "FState()"
  },
  {
    "label": "FSolverMatrix33()",
    "kind": "Method",
    "detail": "Function (InvI =)",
    "insertText": "FSolverMatrix33(0)"
  },
  {
    "label": "FromIdentity()",
    "kind": "Method",
    "detail": "Function (RoM =)",
    "insertText": "FromIdentity()"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (CoM =)",
    "insertText": "FVec3(0)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (Level = 0 ; })",
    "insertText": "alignas(16)"
  },
  {
    "label": "FConstraintSolverBody()",
    "kind": "Method",
    "detail": "Function (FSolverMatrix33 InvI ; FRotation3 RoM ; FRotation3 R ; FRotation3 Q ; FVec3 CoM ; FVec3 X ; FVec3 P ; FSolverVec3 InvILocal ; FSolverReal InvM ; FSolverVec3 CP ; FSolverVec3 CQ ; int32 Level ; } ; FState State ; } ; class FConstraintSolverBody { public :)",
    "insertText": "FConstraintSolverBody() : Body(nullptr)"
  },
  {
    "label": "FConstraintSolverBody()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FConstraintSolverBody(FSolverBody& InBody) : Body(&InBody)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "SetSolverBody()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSolverBody(FSolverBody& InSolverBody)"
  },
  {
    "label": "SolverBody()",
    "kind": "Method",
    "detail": "Function (Body =& InSolverBody ; } FSolverBody&)",
    "insertText": "SolverBody()"
  },
  {
    "label": "FSolverReal()",
    "kind": "Method",
    "detail": "Function (State . InvMScale =)",
    "insertText": "FSolverReal(InValue)"
  },
  {
    "label": "InvIScale()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "InvIScale()"
  },
  {
    "label": "ShockPropagationScale()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "ShockPropagationScale()"
  },
  {
    "label": "SetImplicitVelocity()",
    "kind": "Method",
    "detail": "Function (Body ->)",
    "insertText": "SetImplicitVelocity(Dt)"
  },
  {
    "label": "CQ()",
    "kind": "Method",
    "detail": "Function (} const FSolverVec3&)",
    "insertText": "CQ()"
  },
  {
    "label": "ApplyTransformDelta()",
    "kind": "Method",
    "detail": "Function (Body ->)",
    "insertText": "ApplyTransformDelta(DP, DR)"
  },
  {
    "label": "ApplyPositionCorrectionDelta()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ApplyPositionCorrectionDelta(const FSolverVec3& DP)"
  },
  {
    "label": "ApplyPositionCorrectionDelta()",
    "kind": "Method",
    "detail": "Function (Body ->)",
    "insertText": "ApplyPositionCorrectionDelta(DP)"
  },
  {
    "label": "ApplyRotationCorrectionDelta()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ApplyRotationCorrectionDelta(const FSolverVec3& DR)"
  },
  {
    "label": "ApplyRotationCorrectionDelta()",
    "kind": "Method",
    "detail": "Function (Body ->)",
    "insertText": "ApplyRotationCorrectionDelta(DR)"
  },
  {
    "label": "ApplyVelocityDelta()",
    "kind": "Method",
    "detail": "Function (Body ->)",
    "insertText": "ApplyVelocityDelta(DV, DW)"
  },
  {
    "label": "EnforceShortestRotationTo()",
    "kind": "Method",
    "detail": "Function (Body ->)",
    "insertText": "EnforceShortestRotationTo(InQ)"
  },
  {
    "label": "FSolverReal()",
    "kind": "Method",
    "detail": "Function (InvMScale =)",
    "insertText": "FSolverReal(1)"
  }
]