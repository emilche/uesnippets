[
  {
    "label": "FManifoldPoint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FManifoldPoint"
  },
  {
    "label": "FPBDCollisionConstraint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDCollisionConstraint"
  },
  {
    "label": "TPBDCollisionSolverSimd",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPBDCollisionSolverSimd"
  },
  {
    "label": "TSolverBodyPtrPairSimd",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TSolverBodyPtrPairSimd"
  },
  {
    "label": "TPBDCollisionSolverManifoldPointsSimd",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPBDCollisionSolverManifoldPointsSimd"
  },
  {
    "label": "FPBDCollisionSolverHelperSimd",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDCollisionSolverHelperSimd"
  },
  {
    "label": "GatherBodyPositionCorrections()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" # include \" Chaos / Collision / ContactPoint . h \" # include \" Chaos / Defines . h \" # include \" Chaos / Evolution / SolverBody . h \" # include \" Chaos / Simd4 . h \" # ifndef CHAOS_SIMDCOLLISIONSOLVER_USEDUMMYSOLVERBODY # define CHAOS_SIMDCOLLISIONSOLVER_USEDUMMYSOLVERBODY 0 # endif namespace Chaos { class FManifoldPoint ; class FPBDCollisionConstraint ; namespace CVars { float Chaos_PBDCollisionSolver_Position_MinInvMassScale ; float Chaos_PBDCollisionSolver_Velocity_MinInvMassScale ; } namespace Private { template<int TNumLanes> class TPBDCollisionSolverSimd ; template<int TNumLanes> using TSolverBodyPtrSimd = TSimdValue<FSolverBody*,TNumLanes> ; void)",
    "insertText": "GatherBodyPositionCorrections(const TSolverBodyPtrSimd<4>& Body0, const TSolverBodyPtrSimd<4>& Body1, TSimdVec3f<4>& DP0, TSimdVec3f<4>& DQ0, TSimdVec3f<4>& DP1, TSimdVec3f<4>& DQ1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# if ! CHAOS_SIMDCOLLISIONSOLVER_USEDUMMYSOLVERBODY)",
    "insertText": "for(int32 LaneIndex = 0; LaneIndex < 4; ++LaneIndex)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (const FSolverBody* LaneBody0 = Body0 .)",
    "insertText": "GetValue(LaneIndex)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (DP0 .)",
    "insertText": "SetValue(LaneIndex, LaneBody0->DP())"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (DQ0 .)",
    "insertText": "SetValue(LaneIndex, LaneBody0->DQ())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(LaneBody1 != nullptr)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (DP1 .)",
    "insertText": "SetValue(LaneIndex, LaneBody1->DP())"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (DQ1 .)",
    "insertText": "SetValue(LaneIndex, LaneBody1->DQ())"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (} } # else const FSolverBody* Body00 = Body0 .)",
    "insertText": "GetValue(0)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (const FSolverBody* Body01 = Body0 .)",
    "insertText": "GetValue(1)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (const FSolverBody* Body02 = Body0 .)",
    "insertText": "GetValue(2)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (const FSolverBody* Body03 = Body0 .)",
    "insertText": "GetValue(3)"
  },
  {
    "label": "SimdGatherAligned()",
    "kind": "Method",
    "detail": "Function (DP0 =)",
    "insertText": "SimdGatherAligned(Body00->DP(), Body01->DP(), Body02->DP(), Body03->DP())"
  },
  {
    "label": "SimdGatherAligned()",
    "kind": "Method",
    "detail": "Function (DQ0 =)",
    "insertText": "SimdGatherAligned(Body00->DQ(), Body01->DQ(), Body02->DQ(), Body03->DQ())"
  },
  {
    "label": "SimdGatherAligned()",
    "kind": "Method",
    "detail": "Function (DP1 =)",
    "insertText": "SimdGatherAligned(Body10->DP(), Body11->DP(), Body12->DP(), Body13->DP())"
  },
  {
    "label": "SimdGatherAligned()",
    "kind": "Method",
    "detail": "Function (DQ1 =)",
    "insertText": "SimdGatherAligned(Body10->DQ(), Body11->DQ(), Body12->DQ(), Body13->DQ())"
  },
  {
    "label": "ScatterBodyPositionCorrections()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "ScatterBodyPositionCorrections(const TSimdVec3f<4>& DP0, const TSimdVec3f<4>& DQ0, const TSimdVec3f<4>& DP1, const TSimdVec3f<4>& DQ1, const TSolverBodyPtrSimd<4>& Body0, const TSolverBodyPtrSimd<4>& Body1)"
  },
  {
    "label": "SetDP()",
    "kind": "Method",
    "detail": "Function (LaneBody0 ->)",
    "insertText": "SetDP(DP0.GetValue(LaneIndex))"
  },
  {
    "label": "SetDQ()",
    "kind": "Method",
    "detail": "Function (LaneBody0 ->)",
    "insertText": "SetDQ(DQ0.GetValue(LaneIndex))"
  },
  {
    "label": "SetDP()",
    "kind": "Method",
    "detail": "Function (LaneBody1 ->)",
    "insertText": "SetDP(DP1.GetValue(LaneIndex))"
  },
  {
    "label": "SetDQ()",
    "kind": "Method",
    "detail": "Function (LaneBody1 ->)",
    "insertText": "SetDQ(DQ1.GetValue(LaneIndex))"
  },
  {
    "label": "GatherBodyVelocities()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "GatherBodyVelocities(const TSolverBodyPtrSimd<4>& Body0, const TSolverBodyPtrSimd<4>& Body1, TSimdVec3f<4>& V0, TSimdVec3f<4>& W0, TSimdVec3f<4>& V1, TSimdVec3f<4>& W1)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (V0 .)",
    "insertText": "SetValue(LaneIndex, LaneBody0->V())"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (W0 .)",
    "insertText": "SetValue(LaneIndex, LaneBody0->W())"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (V1 .)",
    "insertText": "SetValue(LaneIndex, LaneBody1->V())"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (W1 .)",
    "insertText": "SetValue(LaneIndex, LaneBody1->W())"
  },
  {
    "label": "ScatterBodyVelocities()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "ScatterBodyVelocities(const TSimdVec3f<4>& V0, const TSimdVec3f<4>& W0, const TSimdVec3f<4>& V1, const TSimdVec3f<4>& W1, const TSolverBodyPtrSimd<4>& Body0, const TSolverBodyPtrSimd<4>& Body1)"
  },
  {
    "label": "SetV()",
    "kind": "Method",
    "detail": "Function (LaneBody0 ->)",
    "insertText": "SetV(V0.GetValue(LaneIndex))"
  },
  {
    "label": "SetW()",
    "kind": "Method",
    "detail": "Function (LaneBody0 ->)",
    "insertText": "SetW(W0.GetValue(LaneIndex))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(LaneBody0 != nullptr)"
  },
  {
    "label": "SetV()",
    "kind": "Method",
    "detail": "Function (LaneBody1 ->)",
    "insertText": "SetV(V1.GetValue(LaneIndex))"
  },
  {
    "label": "SetW()",
    "kind": "Method",
    "detail": "Function (LaneBody1 ->)",
    "insertText": "SetW(W1.GetValue(LaneIndex))"
  },
  {
    "label": "MakeInitialized()",
    "kind": "Method",
    "detail": "Function (} } } template<int TNumLanes> struct TSolverBodyPtrPairSimd { TSolverBodyPtrSimd<TNumLanes> Body0 ; TSolverBodyPtrSimd<TNumLanes> Body1 ; } ; template<int TNumLanes> class TPBDCollisionSolverManifoldPointsSimd { public : using FSimdVec3f = TSimdVec3f<TNumLanes> ; using FSimdRealf = TSimdRealf<TNumLanes> ; using FSimdInt32 = TSimdInt32<TNumLanes> ; using FSimdSelector = TSimdSelector<TNumLanes> ; using FSimdSolverBodyPtr = TSolverBodyPtrSimd<TNumLanes> ; FSimdSelector IsValid ; FSimdVec3f SimdRelativeContactPoint0 ; FSimdVec3f SimdRelativeContactPoint1 ; FSimdVec3f SimdContactNormal ; FSimdRealf SimdContactDeltaNormal ; FSimdRealf SimdNetPushOutNormal ; FSimdRealf SimdContactMassNormal ; FSimdVec3f SimdContactNormalAngular0 ; FSimdVec3f SimdContactNormalAngular1 ; FSimdVec3f SimdContactTangentU ; FSimdVec3f SimdContactTangentV ; FSimdRealf SimdContactDeltaTangentU ; FSimdRealf SimdContactDeltaTangentV ; FSimdRealf SimdNetPushOutTangentU ; FSimdRealf SimdNetPushOutTangentV ; FSimdRealf SimdStaticFrictionRatio ; FSimdRealf SimdContactMassTangentU ; FSimdRealf SimdContactMassTangentV ; FSimdVec3f SimdContactTangentUAngular0 ; FSimdVec3f SimdContactTangentVAngular0 ; FSimdVec3f SimdContactTangentUAngular1 ; FSimdVec3f SimdContactTangentVAngular1 ; FSimdRealf SimdContactTargetVelocityNormal ; FSimdRealf SimdNetImpulseNormal ; FSimdRealf SimdNetImpulseTangentU ; FSimdRealf SimdNetImpulseTangentV ; } ; template<int TNumLanes> class TPBDCollisionSolverSimd { public : using FSimdVec3f = TSimdVec3f<TNumLanes> ; using FSimdRealf = TSimdRealf<TNumLanes> ; using FSimdInt32 = TSimdInt32<TNumLanes> ; using FSimdSelector = TSimdSelector<TNumLanes> ; using FSimdSolverBodyPtr = TSolverBodyPtrSimd<TNumLanes> ; using FSimdManifoldPoint = TPBDCollisionSolverManifoldPointsSimd<TNumLanes> ; const int32 MaxConstrainedBodies = 2 ; const int32 MaxPointsPerConstraint = 4 ; TPBDCollisionSolverSimd<TNumLanes>)",
    "insertText": "MakeInitialized()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (TPBDCollisionSolverSimd<TNumLanes> Solver ; Solver .)",
    "insertText": "Init()"
  },
  {
    "label": "TPBDCollisionSolverSimd()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TPBDCollisionSolverSimd()"
  },
  {
    "label": "NumManifoldPoints()",
    "kind": "Method",
    "detail": "Function (} FSimdInt32)",
    "insertText": "NumManifoldPoints()"
  },
  {
    "label": "SetManifoldPointsBuffer()",
    "kind": "Method",
    "detail": "Function (SimdNumManifoldPoints = InNum ; } void)",
    "insertText": "SetManifoldPointsBuffer(const int32 InBeginIndex, const int32 InMax)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (ManifoldPointBeginIndex = InBeginIndex ; MaxManifoldPoints = InMax ; SimdNumManifoldPoints =)",
    "insertText": "Zero()"
  },
  {
    "label": "GetMaxManifoldPoints()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetMaxManifoldPoints()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "ResetManifold()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ResetManifold()"
  },
  {
    "label": "SetFriction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetFriction(const FSimdRealf InStaticFriction, const FSimdRealf InDynamicFriction, const FSimdRealf InVelocityFriction)"
  },
  {
    "label": "SetStiffness()",
    "kind": "Method",
    "detail": "Function (SimdStaticFriction = InStaticFriction ; SimdDynamicFriction = InDynamicFriction ; SimdVelocityFriction = InVelocityFriction ; } void)",
    "insertText": "SetStiffness(const FSimdRealf InStiffness)"
  },
  {
    "label": "InitManifoldPoints()",
    "kind": "Method",
    "detail": "Function (SimdStiffness = InStiffness ; } void)",
    "insertText": "InitManifoldPoints(const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer)"
  },
  {
    "label": "SetManifoldPoint()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetManifoldPoint(const int32 ManifoldPointIndex, const int32 LaneIndex, const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer, const FSolverVec3& InRelativeContactPosition0, const FSolverVec3& InRelativeContactPosition1, const FSolverVec3& InWorldContactNormal, const FSolverVec3& InWorldContactTangentU, const FSolverVec3& InWorldContactTangentV, const FSolverReal InWorldContactDeltaNormal, const FSolverReal InWorldContactDeltaTangentU, const FSolverReal InWorldContactDeltaTangentV, const FSolverReal InWorldContactVelocityTargetNormal, const FSolverBody& Body0, const FSolverBody& Body1, const FSolverReal InvMScale0, const FSolverReal InvIScale0, const FSolverReal InvMScale1, const FSolverReal InvIScale1)"
  },
  {
    "label": "GetBufferIndex()",
    "kind": "Method",
    "detail": "Function (const int32 BufferIndex =)",
    "insertText": "GetBufferIndex(ManifoldPointIndex)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (FSimdManifoldPoint& ManifoldPoint = ManifoldPointsBuffer [ BufferIndex ] ; ManifoldPoint . IsValid .)",
    "insertText": "SetValue(LaneIndex, true)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdRelativeContactPoint0 .)",
    "insertText": "SetValue(LaneIndex, InRelativeContactPosition0)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdRelativeContactPoint1 .)",
    "insertText": "SetValue(LaneIndex, InRelativeContactPosition1)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactNormal .)",
    "insertText": "SetValue(LaneIndex, InWorldContactNormal)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactTangentU .)",
    "insertText": "SetValue(LaneIndex, InWorldContactTangentU)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactTangentV .)",
    "insertText": "SetValue(LaneIndex, InWorldContactTangentV)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactDeltaNormal .)",
    "insertText": "SetValue(LaneIndex, InWorldContactDeltaNormal)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactDeltaTangentU .)",
    "insertText": "SetValue(LaneIndex, InWorldContactDeltaTangentU)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactDeltaTangentV .)",
    "insertText": "SetValue(LaneIndex, InWorldContactDeltaTangentV)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactTargetVelocityNormal .)",
    "insertText": "SetValue(LaneIndex, InWorldContactVelocityTargetNormal)"
  },
  {
    "label": "UpdateManifoldPointMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateManifoldPointMass(ManifoldPointIndex, LaneIndex, ManifoldPointsBuffer, Body0, Body1, InvMScale0, InvIScale0, InvMScale1, InvIScale1)"
  },
  {
    "label": "UpdateManifoldPointMass()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UpdateManifoldPointMass(const int32 ManifoldPointIndex, const int32 LaneIndex, const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer, const FSolverBody& Body0, const FSolverBody& Body1, const FSolverReal InvMScale0, const FSolverReal InvIScale0, const FSolverReal InvMScale1, const FSolverReal InvIScale1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FSimdManifoldPoint& ManifoldPoint = ManifoldPointsBuffer [ BufferIndex ] ;)",
    "insertText": "if(!ManifoldPoint.IsValid.GetValue(LaneIndex))"
  },
  {
    "label": "FSolverReal()",
    "kind": "Method",
    "detail": "Function (FSolverReal ContactMassInvTangentU =)",
    "insertText": "FSolverReal(0)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (SimdInvM0 .)",
    "insertText": "SetValue(LaneIndex, 0)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactNormalAngular0 .)",
    "insertText": "SetValue(LaneIndex, FVec3f(0))"
  },
  {
    "label": "InvM()",
    "kind": "Method",
    "detail": "Function (const FSolverReal InvM0 = InvMScale0* Body0 .)",
    "insertText": "InvM()"
  },
  {
    "label": "InvI()",
    "kind": "Method",
    "detail": "Function (const FSolverMatrix33 InvI0 = InvIScale0* Body0 .)",
    "insertText": "InvI()"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 R0xN =)",
    "insertText": "CrossProduct(RelativeContactPoint0, ContactNormal)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 R0xU =)",
    "insertText": "CrossProduct(RelativeContactPoint0, ContactTangentU)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 R0xV =)",
    "insertText": "CrossProduct(RelativeContactPoint0, ContactTangentV)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 IR0xN = InvI0* R0xN ; const FSolverVec3 IR0xU = InvI0* R0xU ; const FSolverVec3 IR0xV = InvI0* R0xV ; SimdInvM0 .)",
    "insertText": "SetValue(LaneIndex, InvM0)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactNormalAngular0 .)",
    "insertText": "SetValue(LaneIndex, IR0xN)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactTangentUAngular0 .)",
    "insertText": "SetValue(LaneIndex, IR0xU)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactTangentVAngular0 .)",
    "insertText": "SetValue(LaneIndex, IR0xV)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactMassInvNormal + =)",
    "insertText": "DotProduct(R0xN, IR0xN)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactMassInvTangentU + =)",
    "insertText": "DotProduct(R0xU, IR0xU)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactMassInvTangentV + =)",
    "insertText": "DotProduct(R0xV, IR0xV)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InvM1 > 0)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 R1xN =)",
    "insertText": "CrossProduct(RelativeContactPoint1, ContactNormal)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 R1xU =)",
    "insertText": "CrossProduct(RelativeContactPoint1, ContactTangentU)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 R1xV =)",
    "insertText": "CrossProduct(RelativeContactPoint1, ContactTangentV)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 IR1xN = InvI1* R1xN ; const FSolverVec3 IR1xU = InvI1* R1xU ; const FSolverVec3 IR1xV = InvI1* R1xV ; SimdInvM1 .)",
    "insertText": "SetValue(LaneIndex, InvM1)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactNormalAngular1 .)",
    "insertText": "SetValue(LaneIndex, IR1xN)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactTangentUAngular1 .)",
    "insertText": "SetValue(LaneIndex, IR1xU)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactTangentVAngular1 .)",
    "insertText": "SetValue(LaneIndex, IR1xV)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactMassInvNormal + =)",
    "insertText": "DotProduct(R1xN, IR1xN)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactMassInvTangentU + =)",
    "insertText": "DotProduct(R1xU, IR1xU)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactMassInvTangentV + =)",
    "insertText": "DotProduct(R1xV, IR1xV)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (} ManifoldPoint . SimdContactMassNormal .)",
    "insertText": "SetValue(LaneIndex, (ContactMassInvNormal > FSolverReal(UE_SMALL_NUMBER)) ? FSolverReal(1) / ContactMassInvNormal : FSolverReal(0))"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactMassTangentU .)",
    "insertText": "SetValue(LaneIndex, (ContactMassInvTangentU > FSolverReal(UE_SMALL_NUMBER)) ? FSolverReal(1) / ContactMassInvTangentU : FSolverReal(0))"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactMassTangentV .)",
    "insertText": "SetValue(LaneIndex, (ContactMassInvTangentV > FSolverReal(UE_SMALL_NUMBER)) ? FSolverReal(1) / ContactMassInvTangentV : FSolverReal(0))"
  },
  {
    "label": "UpdateManifoldPointMassNormal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UpdateManifoldPointMassNormal(const int32 ManifoldPointIndex, const int32 LaneIndex, const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer, const FSolverBody& Body0, const FSolverBody& Body1, const FSolverReal InvMScale0, const FSolverReal InvIScale0, const FSolverReal InvMScale1, const FSolverReal InvIScale1)"
  },
  {
    "label": "ContactMassNormal()",
    "kind": "Method",
    "detail": "Function (} const FSolverReal)",
    "insertText": "ContactMassNormal(ContactMassInvNormal > FSolverReal(UE_SMALL_NUMBER)) ? FSolverReal(1) / ContactMassInvNormal : FSolverReal(0)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdContactMassNormal .)",
    "insertText": "SetValue(LaneIndex, ContactMassNormal)"
  },
  {
    "label": "UpdateMassNormal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UpdateMassNormal(const int32 LaneIndex, const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer, const FSolverBody& Body0, const FSolverBody& Body1, const FSolverReal InvMScale0, const FSolverReal InvIScale0, const FSolverReal InvMScale1, const FSolverReal InvIScale1)"
  },
  {
    "label": "UpdateManifoldPointMassNormal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateManifoldPointMassNormal(ManifoldPointIndex, LaneIndex, ManifoldPointsBuffer, Body0, Body1, InvMScale0, InvIScale0, InvMScale1, InvIScale1)"
  },
  {
    "label": "SolvePositionNoFriction()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SolvePositionNoFriction(const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer, const FSimdSolverBodyPtr& Body0, const FSimdSolverBodyPtr& Body1, const FSimdRealf& MaxPushOut)"
  },
  {
    "label": "GatherBodyPositionCorrections()",
    "kind": "Method",
    "detail": "Function (FSimdVec3f DP0,DQ0,DP1,DQ1 ;)",
    "insertText": "GatherBodyPositionCorrections(Body0, Body1, DP0, DQ0, DP1, DQ1)"
  },
  {
    "label": "SimdCrossProduct()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DQ0xR0 =)",
    "insertText": "SimdCrossProduct(DQ0, ManifoldPoint.SimdRelativeContactPoint0)"
  },
  {
    "label": "SimdCrossProduct()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DQ1xR1 =)",
    "insertText": "SimdCrossProduct(DQ1, ManifoldPoint.SimdRelativeContactPoint1)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f ContactDelta0 =)",
    "insertText": "SimdAdd(DP0, DQ0xR0)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f ContactDelta1 =)",
    "insertText": "SimdAdd(DP1, DQ1xR1)"
  },
  {
    "label": "SimdSubtract()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f ContactDelta =)",
    "insertText": "SimdSubtract(ContactDelta0, ContactDelta1)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (FSimdRealf ContactErrorNormal =)",
    "insertText": "SimdAdd(ManifoldPoint.SimdContactDeltaNormal, SimdDotProduct(ContactDelta, ManifoldPoint.SimdContactNormal))"
  },
  {
    "label": "SimdNegate()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf NegMaxPushOut =)",
    "insertText": "SimdNegate(MaxPushOut)"
  },
  {
    "label": "SimdAnd()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector ShouldClampError =)",
    "insertText": "SimdAnd(SimdLess(NegMaxPushOut, FSimdRealf::Zero()), SimdLess(ContactErrorNormal, NegMaxPushOut))"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (ContactErrorNormal =)",
    "insertText": "SimdSelect(ShouldClampError, NegMaxPushOut, ContactErrorNormal)"
  },
  {
    "label": "SimdLess()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector IsErrorNegative =)",
    "insertText": "SimdLess(ContactErrorNormal, FSimdRealf::Zero())"
  },
  {
    "label": "SimdGreater()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector IsNetPushOutPositive =)",
    "insertText": "SimdGreater(ManifoldPoint.SimdNetPushOutNormal, FSimdRealf::Zero())"
  },
  {
    "label": "SimdAnd()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector ShouldProcess =)",
    "insertText": "SimdAnd(ManifoldPoint.IsValid, SimdOr(IsErrorNegative, IsNetPushOutPositive))"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (ContactErrorNormal =)",
    "insertText": "SimdSelect(ShouldProcess, ContactErrorNormal, FSimdRealf::Zero())"
  },
  {
    "label": "SimdNegate()",
    "kind": "Method",
    "detail": "Function (FSimdRealf PushOutNormal =)",
    "insertText": "SimdNegate(SimdMultiply(ContactErrorNormal, SimdMultiply(SimdStiffness, ManifoldPoint.SimdContactMassNormal)))"
  },
  {
    "label": "SimdGreater()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector IsPositive =)",
    "insertText": "SimdGreater(SimdAdd(ManifoldPoint.SimdNetPushOutNormal, PushOutNormal), FSimdRealf::Zero())"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (PushOutNormal =)",
    "insertText": "SimdSelect(IsPositive, PushOutNormal, SimdNegate(ManifoldPoint.SimdNetPushOutNormal))"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdNetPushOutNormal =)",
    "insertText": "SimdAdd(PushOutNormal, ManifoldPoint.SimdNetPushOutNormal)"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DDP0 =)",
    "insertText": "SimdMultiply(ManifoldPoint.SimdContactNormal, SimdMultiply(SimdInvM0, PushOutNormal))"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DDQ0 =)",
    "insertText": "SimdMultiply(ManifoldPoint.SimdContactNormalAngular0, PushOutNormal)"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DDP1 =)",
    "insertText": "SimdMultiply(ManifoldPoint.SimdContactNormal, SimdMultiply(SimdInvM1, PushOutNormal))"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DDQ1 =)",
    "insertText": "SimdMultiply(ManifoldPoint.SimdContactNormalAngular1, PushOutNormal)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (DP0 =)",
    "insertText": "SimdAdd(DP0, DDP0)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (DQ0 =)",
    "insertText": "SimdAdd(DQ0, DDQ0)"
  },
  {
    "label": "SimdSubtract()",
    "kind": "Method",
    "detail": "Function (DP1 =)",
    "insertText": "SimdSubtract(DP1, DDP1)"
  },
  {
    "label": "SimdSubtract()",
    "kind": "Method",
    "detail": "Function (DQ1 =)",
    "insertText": "SimdSubtract(DQ1, DDQ1)"
  },
  {
    "label": "ScatterBodyPositionCorrections()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ScatterBodyPositionCorrections(DP0, DQ0, DP1, DQ1, Body0, Body1)"
  },
  {
    "label": "SolvePositionWithFriction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SolvePositionWithFriction(const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer, const FSimdSolverBodyPtr& Body0, const FSimdSolverBodyPtr& Body1, const FSimd4Realf& MaxPushOut, const FSimd4Realf& FrictionStiffnessScale)"
  },
  {
    "label": "One()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf One =)",
    "insertText": "One()"
  },
  {
    "label": "Make()",
    "kind": "Method",
    "detail": "Function (FSimdRealf NumFrictionPoints = Zero ; FSimdRealf MaxFrictionPushOut = Zero ; const FSimdRealf PushOutNormalTolerance =)",
    "insertText": "Make(UE_SMALL_NUMBER)"
  },
  {
    "label": "Make()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf MaxFrictionPushOutTolerance =)",
    "insertText": "Make(UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "SimdAnd()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector ShouldClampError =)",
    "insertText": "SimdAnd(SimdLess(NegMaxPushOut, Zero), SimdLess(ContactErrorNormal, NegMaxPushOut))"
  },
  {
    "label": "SimdLess()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector IsErrorNegative =)",
    "insertText": "SimdLess(ContactErrorNormal, Zero)"
  },
  {
    "label": "SimdGreater()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector IsNetPushOutPositive =)",
    "insertText": "SimdGreater(ManifoldPoint.SimdNetPushOutNormal, PushOutNormalTolerance)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (ContactErrorNormal =)",
    "insertText": "SimdSelect(ProcessManifoldPoint, ContactErrorNormal, Zero)"
  },
  {
    "label": "SimdGreater()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector IsPositive =)",
    "insertText": "SimdGreater(SimdAdd(ManifoldPoint.SimdNetPushOutNormal, PushOutNormal), Zero)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (MaxFrictionPushOut =)",
    "insertText": "SimdSelect(IsPositive, SimdAdd(MaxFrictionPushOut, ManifoldPoint.SimdNetPushOutNormal), MaxFrictionPushOut)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (NumFrictionPoints =)",
    "insertText": "SimdSelect(IsPositive, SimdAdd(NumFrictionPoints, One), NumFrictionPoints)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (} MaxFrictionPushOut =)",
    "insertText": "SimdSelect(SimdGreater(NumFrictionPoints, Zero), SimdDivide(MaxFrictionPushOut, NumFrictionPoints), Zero)"
  },
  {
    "label": "SimdGreater()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector HasFriction =)",
    "insertText": "SimdGreater(SimdStaticFriction, Zero)"
  },
  {
    "label": "SimdGreater()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector HasNormalPushout =)",
    "insertText": "SimdGreater(ManifoldPoint.SimdNetPushOutNormal, Zero)"
  },
  {
    "label": "SimdNotEqual()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector HasTangentUPushout =)",
    "insertText": "SimdNotEqual(ManifoldPoint.SimdNetPushOutTangentU, Zero)"
  },
  {
    "label": "SimdNotEqual()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector HasTangentVPushout =)",
    "insertText": "SimdNotEqual(ManifoldPoint.SimdNetPushOutTangentV, Zero)"
  },
  {
    "label": "SimdAnd()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector ApplyPointFriction =)",
    "insertText": "SimdAnd(HasFriction, SimdOr(HasNormalPushout, SimdOr(HasTangentUPushout, HasTangentVPushout)))"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function ({ const FSimdRealf ContactErrorTangentU =)",
    "insertText": "SimdAdd(ManifoldPoint.SimdContactDeltaTangentU, SimdDotProduct(ContactDelta, ManifoldPoint.SimdContactTangentU))"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf ContactErrorTangentV =)",
    "insertText": "SimdAdd(ManifoldPoint.SimdContactDeltaTangentV, SimdDotProduct(ContactDelta, ManifoldPoint.SimdContactTangentV))"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf FrictionStiffness =)",
    "insertText": "SimdMultiply(FrictionStiffnessScale, SimdStiffness)"
  },
  {
    "label": "SimdNegate()",
    "kind": "Method",
    "detail": "Function (FSimdRealf PushOutTangentU =)",
    "insertText": "SimdNegate(SimdMultiply(FrictionStiffness, SimdMultiply(ContactErrorTangentU, ManifoldPoint.SimdContactMassTangentU)))"
  },
  {
    "label": "SimdNegate()",
    "kind": "Method",
    "detail": "Function (FSimdRealf PushOutTangentV =)",
    "insertText": "SimdNegate(SimdMultiply(FrictionStiffness, SimdMultiply(ContactErrorTangentV, ManifoldPoint.SimdContactMassTangentV)))"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (FSimdRealf NetPushOutTangentU =)",
    "insertText": "SimdAdd(ManifoldPoint.SimdNetPushOutTangentU, PushOutTangentU)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (FSimdRealf NetPushOutTangentV =)",
    "insertText": "SimdAdd(ManifoldPoint.SimdNetPushOutTangentV, PushOutTangentV)"
  },
  {
    "label": "SimdGreaterEqual()",
    "kind": "Method",
    "detail": "Function (FSimdRealf StaticFrictionRatio = One ; const FSimdSelector ApplyFrictionCone =)",
    "insertText": "SimdGreaterEqual(MaxFrictionPushOut, MaxFrictionPushOutTolerance)"
  },
  {
    "label": "SimdSquare()",
    "kind": "Method",
    "detail": "Function ({ const FSimdRealf MaxStaticPushOutTangentSq =)",
    "insertText": "SimdSquare(SimdMultiply(SimdStaticFriction, MaxFrictionPushOut))"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf NetPushOutTangentSq =)",
    "insertText": "SimdAdd(SimdSquare(NetPushOutTangentU), SimdSquare(NetPushOutTangentV))"
  },
  {
    "label": "SimdAnd()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector ExceededFrictionCone =)",
    "insertText": "SimdAnd(ApplyFrictionCone, SimdGreater(NetPushOutTangentSq, MaxStaticPushOutTangentSq))"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function ({ const FSimdRealf MaxDynamicPushOutTangent =)",
    "insertText": "SimdMultiply(SimdDynamicFriction, MaxFrictionPushOut)"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf FrictionMultiplier =)",
    "insertText": "SimdMultiply(MaxDynamicPushOutTangent, SimdInvSqrt(NetPushOutTangentSq))"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf ClampedNetPushOutTangentU =)",
    "insertText": "SimdMultiply(FrictionMultiplier, NetPushOutTangentU)"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf ClampedNetPushOutTangentV =)",
    "insertText": "SimdMultiply(FrictionMultiplier, NetPushOutTangentV)"
  },
  {
    "label": "SimdSubtract()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf ClampedPushOutTangentU =)",
    "insertText": "SimdSubtract(ClampedNetPushOutTangentU, ManifoldPoint.SimdNetPushOutTangentU)"
  },
  {
    "label": "SimdSubtract()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf ClampedPushOutTangentV =)",
    "insertText": "SimdSubtract(ClampedNetPushOutTangentV, ManifoldPoint.SimdNetPushOutTangentV)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (PushOutTangentU =)",
    "insertText": "SimdSelect(ExceededFrictionCone, ClampedPushOutTangentU, PushOutTangentU)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (PushOutTangentV =)",
    "insertText": "SimdSelect(ExceededFrictionCone, ClampedPushOutTangentV, PushOutTangentV)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (NetPushOutTangentU =)",
    "insertText": "SimdSelect(ExceededFrictionCone, ClampedNetPushOutTangentU, NetPushOutTangentU)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (NetPushOutTangentV =)",
    "insertText": "SimdSelect(ExceededFrictionCone, ClampedNetPushOutTangentV, NetPushOutTangentV)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (StaticFrictionRatio =)",
    "insertText": "SimdSelect(ExceededFrictionCone, FrictionMultiplier, StaticFrictionRatio)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (} } { PushOutTangentU =)",
    "insertText": "SimdSelect(ApplyFrictionCone, PushOutTangentU, SimdNegate(ManifoldPoint.SimdNetPushOutTangentU))"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (PushOutTangentV =)",
    "insertText": "SimdSelect(ApplyFrictionCone, PushOutTangentV, SimdNegate(ManifoldPoint.SimdNetPushOutTangentV))"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (NetPushOutTangentU =)",
    "insertText": "SimdSelect(ApplyFrictionCone, NetPushOutTangentU, Zero)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (NetPushOutTangentV =)",
    "insertText": "SimdSelect(ApplyFrictionCone, NetPushOutTangentV, Zero)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (StaticFrictionRatio =)",
    "insertText": "SimdSelect(ApplyFrictionCone, StaticFrictionRatio, Zero)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (} { PushOutTangentU =)",
    "insertText": "SimdSelect(ApplyPointFriction, PushOutTangentU, Zero)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (PushOutTangentV =)",
    "insertText": "SimdSelect(ApplyPointFriction, PushOutTangentV, Zero)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (NetPushOutTangentU =)",
    "insertText": "SimdSelect(ApplyPointFriction, NetPushOutTangentU, ManifoldPoint.SimdNetPushOutTangentU)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (NetPushOutTangentV =)",
    "insertText": "SimdSelect(ApplyPointFriction, NetPushOutTangentV, ManifoldPoint.SimdNetPushOutTangentV)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (StaticFrictionRatio =)",
    "insertText": "SimdSelect(ApplyPointFriction, StaticFrictionRatio, One)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (} ManifoldPoint . SimdNetPushOutTangentU = NetPushOutTangentU ; ManifoldPoint . SimdNetPushOutTangentV = NetPushOutTangentV ; ManifoldPoint . SimdStaticFrictionRatio = StaticFrictionRatio ; const FSimdVec3f PushOut =)",
    "insertText": "SimdAdd(SimdMultiply(PushOutTangentU, ManifoldPoint.SimdContactTangentU), SimdMultiply(PushOutTangentV, ManifoldPoint.SimdContactTangentV))"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DDP0 =)",
    "insertText": "SimdMultiply(SimdInvM0, PushOut)"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DDP1 =)",
    "insertText": "SimdMultiply(SimdInvM1, PushOut)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DDQ0 =)",
    "insertText": "SimdAdd(SimdMultiply(ManifoldPoint.SimdContactTangentUAngular0, PushOutTangentU), SimdMultiply(ManifoldPoint.SimdContactTangentVAngular0, PushOutTangentV))"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DDQ1 =)",
    "insertText": "SimdAdd(SimdMultiply(ManifoldPoint.SimdContactTangentUAngular1, PushOutTangentU), SimdMultiply(ManifoldPoint.SimdContactTangentVAngular1, PushOutTangentV))"
  },
  {
    "label": "SolveVelocityNoFriction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SolveVelocityNoFriction(const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer, const FSimdSolverBodyPtr& Body0, const FSimdSolverBodyPtr& Body1, const FSimdRealf& Dt)"
  },
  {
    "label": "GatherBodyVelocities()",
    "kind": "Method",
    "detail": "Function (FSimdVec3f V0,W0,V1,W1 ;)",
    "insertText": "GatherBodyVelocities(Body0, Body1, V0, W0, V1, W1)"
  },
  {
    "label": "SimdOr()",
    "kind": "Method",
    "detail": "Function (FSimdSelector ShouldSolveVelocity =)",
    "insertText": "SimdOr(SimdGreater(ManifoldPoint.SimdNetPushOutNormal, FSimdRealf::Zero()), SimdLess(ManifoldPoint.SimdContactDeltaNormal, FSimdRealf::Zero()))"
  },
  {
    "label": "SimdAnd()",
    "kind": "Method",
    "detail": "Function (ShouldSolveVelocity =)",
    "insertText": "SimdAnd(ManifoldPoint.IsValid, ShouldSolveVelocity)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f ContactVelocity0 =)",
    "insertText": "SimdAdd(V0, SimdCrossProduct(W0, ManifoldPoint.SimdRelativeContactPoint0))"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f ContactVelocity1 =)",
    "insertText": "SimdAdd(V1, SimdCrossProduct(W1, ManifoldPoint.SimdRelativeContactPoint1))"
  },
  {
    "label": "SimdSubtract()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f ContactVelocity =)",
    "insertText": "SimdSubtract(ContactVelocity0, ContactVelocity1)"
  },
  {
    "label": "SimdDotProduct()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf ContactVelocityNormal =)",
    "insertText": "SimdDotProduct(ContactVelocity, ManifoldPoint.SimdContactNormal)"
  },
  {
    "label": "SimdSubtract()",
    "kind": "Method",
    "detail": "Function (FSimdRealf ContactVelocityErrorNormal =)",
    "insertText": "SimdSubtract(ContactVelocityNormal, ManifoldPoint.SimdContactTargetVelocityNormal)"
  },
  {
    "label": "SimdNegate()",
    "kind": "Method",
    "detail": "Function (FSimdRealf ImpulseNormal =)",
    "insertText": "SimdNegate(SimdMultiply(SimdMultiply(SimdStiffness, ManifoldPoint.SimdContactMassNormal), ContactVelocityErrorNormal))"
  },
  {
    "label": "SimdMin()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf MinImpulseNormal =)",
    "insertText": "SimdMin(SimdDivide(SimdNegate(ManifoldPoint.SimdNetPushOutNormal), Dt), FSimdRealf::Zero())"
  },
  {
    "label": "SimdLess()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector ShouldClampImpulse =)",
    "insertText": "SimdLess(SimdAdd(ManifoldPoint.SimdNetImpulseNormal, ImpulseNormal), MinImpulseNormal)"
  },
  {
    "label": "SimdSubtract()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf ClampedImpulseNormal =)",
    "insertText": "SimdSubtract(MinImpulseNormal, ManifoldPoint.SimdNetImpulseNormal)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (ImpulseNormal =)",
    "insertText": "SimdSelect(ShouldClampImpulse, ClampedImpulseNormal, ImpulseNormal)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (ImpulseNormal =)",
    "insertText": "SimdSelect(ShouldSolveVelocity, ImpulseNormal, FSimdRealf::Zero())"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdNetImpulseNormal =)",
    "insertText": "SimdAdd(ManifoldPoint.SimdNetImpulseNormal, ImpulseNormal)"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f Impulse =)",
    "insertText": "SimdMultiply(ImpulseNormal, ManifoldPoint.SimdContactNormal)"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DV0 =)",
    "insertText": "SimdMultiply(Impulse, SimdInvM0)"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DV1 =)",
    "insertText": "SimdMultiply(Impulse, SimdInvM1)"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DW0 =)",
    "insertText": "SimdMultiply(ImpulseNormal, ManifoldPoint.SimdContactNormalAngular0)"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DW1 =)",
    "insertText": "SimdMultiply(ImpulseNormal, ManifoldPoint.SimdContactNormalAngular1)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (V0 =)",
    "insertText": "SimdAdd(V0, DV0)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (W0 =)",
    "insertText": "SimdAdd(W0, DW0)"
  },
  {
    "label": "SimdSubtract()",
    "kind": "Method",
    "detail": "Function (V1 =)",
    "insertText": "SimdSubtract(V1, DV1)"
  },
  {
    "label": "SimdSubtract()",
    "kind": "Method",
    "detail": "Function (W1 =)",
    "insertText": "SimdSubtract(W1, DW1)"
  },
  {
    "label": "ScatterBodyVelocities()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ScatterBodyVelocities(V0, W0, V1, W1, Body0, Body1)"
  },
  {
    "label": "SolveVelocityWithFrictionImpl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SolveVelocityWithFrictionImpl(const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer, const FSimdSolverBodyPtr& Body0, const FSimdSolverBodyPtr& Body1, const FSimdRealf& Dt, const FSimd4Realf& FrictionStiffnessScale)"
  },
  {
    "label": "SimdSubtract()",
    "kind": "Method",
    "detail": "Function (FSimdRealf ContactVelocityErrorNormal =)",
    "insertText": "SimdSubtract(SimdDotProduct(ContactVelocity, ManifoldPoint.SimdContactNormal), ManifoldPoint.SimdContactTargetVelocityNormal)"
  },
  {
    "label": "SimdDotProduct()",
    "kind": "Method",
    "detail": "Function (FSimdRealf ContactVelocityErrorTangentU =)",
    "insertText": "SimdDotProduct(ContactVelocity, ManifoldPoint.SimdContactTangentU)"
  },
  {
    "label": "SimdDotProduct()",
    "kind": "Method",
    "detail": "Function (FSimdRealf ContactVelocityErrorTangentV =)",
    "insertText": "SimdDotProduct(ContactVelocity, ManifoldPoint.SimdContactTangentV)"
  },
  {
    "label": "SimdNegate()",
    "kind": "Method",
    "detail": "Function (FSimdRealf ImpulseTangentU =)",
    "insertText": "SimdNegate(SimdMultiply(SimdMultiply(FrictionStiffness, ManifoldPoint.SimdContactMassTangentU), ContactVelocityErrorTangentU))"
  },
  {
    "label": "SimdNegate()",
    "kind": "Method",
    "detail": "Function (FSimdRealf ImpulseTangentV =)",
    "insertText": "SimdNegate(SimdMultiply(SimdMultiply(FrictionStiffness, ManifoldPoint.SimdContactMassTangentV), ContactVelocityErrorTangentV))"
  },
  {
    "label": "SimdAnd()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector HasFriction =)",
    "insertText": "SimdAnd(ShouldSolveVelocity, SimdGreater(SimdVelocityFriction, FSimdRealf::Zero()))"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (ImpulseTangentU =)",
    "insertText": "SimdSelect(HasFriction, ImpulseTangentU, FSimdRealf::Zero())"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (ImpulseTangentV =)",
    "insertText": "SimdSelect(HasFriction, ImpulseTangentV, FSimdRealf::Zero())"
  },
  {
    "label": "SimdMin()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf MinImpulseNormal =)",
    "insertText": "SimdMin(SimdNegate(SimdDivide(ManifoldPoint.SimdNetPushOutNormal, Dt)), FSimdRealf::Zero())"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf MaxNetImpulseAndPushOutTangent =)",
    "insertText": "SimdAdd(ManifoldPoint.SimdNetImpulseNormal, SimdAdd(ImpulseNormal, SimdDivide(ManifoldPoint.SimdNetPushOutNormal, Dt)))"
  },
  {
    "label": "SimdMax()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf MaxImpulseTangent =)",
    "insertText": "SimdMax(FSimdRealf::Zero(), SimdMultiply(SimdVelocityFriction, MaxNetImpulseAndPushOutTangent))"
  },
  {
    "label": "SimdSquare()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf MaxImpulseTangentSq =)",
    "insertText": "SimdSquare(MaxImpulseTangent)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf ImpulseTangentSq =)",
    "insertText": "SimdAdd(SimdSquare(ImpulseTangentU), SimdSquare(ImpulseTangentV))"
  },
  {
    "label": "SimdMultiply()",
    "kind": "Method",
    "detail": "Function (const FSimdRealf ImpulseTangentScale =)",
    "insertText": "SimdMultiply(MaxImpulseTangent, SimdInvSqrt(ImpulseTangentSq))"
  },
  {
    "label": "SimdGreater()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector ExceededFrictionCone =)",
    "insertText": "SimdGreater(ImpulseTangentSq, SimdAdd(MaxImpulseTangentSq, FSimdRealf::Make(UE_SMALL_NUMBER)))"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (ImpulseTangentU =)",
    "insertText": "SimdSelect(ExceededFrictionCone, SimdMultiply(ImpulseTangentScale, ImpulseTangentU), ImpulseTangentU)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (ImpulseTangentV =)",
    "insertText": "SimdSelect(ExceededFrictionCone, SimdMultiply(ImpulseTangentScale, ImpulseTangentV), ImpulseTangentV)"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (ImpulseTangentU =)",
    "insertText": "SimdSelect(ShouldSolveVelocity, ImpulseTangentU, FSimdRealf::Zero())"
  },
  {
    "label": "SimdSelect()",
    "kind": "Method",
    "detail": "Function (ImpulseTangentV =)",
    "insertText": "SimdSelect(ShouldSolveVelocity, ImpulseTangentV, FSimdRealf::Zero())"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdNetImpulseTangentU =)",
    "insertText": "SimdAdd(ManifoldPoint.SimdNetImpulseTangentU, ImpulseTangentU)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . SimdNetImpulseTangentV =)",
    "insertText": "SimdAdd(ManifoldPoint.SimdNetImpulseTangentU, ImpulseTangentV)"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f Impulse =)",
    "insertText": "SimdAdd(SimdMultiply(ImpulseNormal, ManifoldPoint.SimdContactNormal), SimdAdd(SimdMultiply(ImpulseTangentU, ManifoldPoint.SimdContactTangentU), SimdMultiply(ImpulseTangentV, ManifoldPoint.SimdContactTangentV)))"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DW0 =)",
    "insertText": "SimdAdd(SimdMultiply(ImpulseNormal, ManifoldPoint.SimdContactNormalAngular0), SimdAdd(SimdMultiply(ImpulseTangentU, ManifoldPoint.SimdContactTangentUAngular0), SimdMultiply(ImpulseTangentV, ManifoldPoint.SimdContactTangentVAngular0)))"
  },
  {
    "label": "SimdAdd()",
    "kind": "Method",
    "detail": "Function (const FSimdVec3f DW1 =)",
    "insertText": "SimdAdd(SimdMultiply(ImpulseNormal, ManifoldPoint.SimdContactNormalAngular1), SimdAdd(SimdMultiply(ImpulseTangentU, ManifoldPoint.SimdContactTangentUAngular1), SimdMultiply(ImpulseTangentV, ManifoldPoint.SimdContactTangentVAngular1)))"
  },
  {
    "label": "SolveVelocityWithFriction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SolveVelocityWithFriction(const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer, const FSimdSolverBodyPtr& Body0, const FSimdSolverBodyPtr& Body1, const FSimdRealf& Dt, const FSimd4Realf& FrictionStiffnessScale)"
  },
  {
    "label": "SimdGreater()",
    "kind": "Method",
    "detail": "Function (const FSimdSelector HasNonZeroFriction =)",
    "insertText": "SimdGreater(SimdVelocityFriction, FSimdRealf::Zero())"
  },
  {
    "label": "SolveVelocityNoFriction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolveVelocityNoFriction(ManifoldPointsBuffer, Body0, Body1, Dt)"
  },
  {
    "label": "GetNetPushOut()",
    "kind": "Method",
    "detail": "Function (} FSolverVec3)",
    "insertText": "GetNetPushOut(const int32 ManifoldPointIndex, const int32 LaneIndex, const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (const FSimdManifoldPoint& ManifoldPoint = ManifoldPointsBuffer [ BufferIndex ] ; return ManifoldPoint . SimdNetPushOutNormal .)",
    "insertText": "GetValue(LaneIndex) * ManifoldPoint.SimdContactNormal.GetValue(LaneIndex) + ManifoldPoint.SimdNetPushOutTangentU.GetValue(LaneIndex) * ManifoldPoint.SimdContactTangentU.GetValue(LaneIndex) + ManifoldPoint.SimdNetPushOutTangentV.GetValue(LaneIndex) * ManifoldPoint.SimdContactTangentV.GetValue(LaneIndex)"
  },
  {
    "label": "GetNetImpulse()",
    "kind": "Method",
    "detail": "Function (} FSolverVec3)",
    "insertText": "GetNetImpulse(const int32 ManifoldPointIndex, const int32 LaneIndex, const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (const FSimdManifoldPoint& ManifoldPoint = ManifoldPointsBuffer [ BufferIndex ] ; return ManifoldPoint . SimdNetImpulseNormal .)",
    "insertText": "GetValue(LaneIndex) * ManifoldPoint.SimdContactNormal.GetValue(LaneIndex) + ManifoldPoint.SimdNetImpulseTangentU.GetValue(LaneIndex) * ManifoldPoint.SimdContactTangentU.GetValue(LaneIndex) + ManifoldPoint.SimdNetImpulseTangentV.GetValue(LaneIndex) * ManifoldPoint.SimdContactTangentV.GetValue(LaneIndex)"
  },
  {
    "label": "GetStaticFrictionRatio()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "GetStaticFrictionRatio(const int32 ManifoldPointIndex, const int32 LaneIndex, const TArrayView<FSimdManifoldPoint>& ManifoldPointsBuffer)"
  },
  {
    "label": "GetBufferIndex()",
    "kind": "Method",
    "detail": "Function (} public : int32)",
    "insertText": "GetBufferIndex(const int32 ManifoldPointIndex)"
  },
  {
    "label": "SetValues()",
    "kind": "Method",
    "detail": "Function (MaxManifoldPoints = 0 ; ManifoldPointBeginIndex = INDEX_NONE ; SimdNumManifoldPoints .)",
    "insertText": "SetValues(0)"
  },
  {
    "label": "SetValues()",
    "kind": "Method",
    "detail": "Function (SimdStiffness .)",
    "insertText": "SetValues(1)"
  },
  {
    "label": "SolvePositionNoFriction()",
    "kind": "Method",
    "detail": "Function (} int32 MaxManifoldPoints ; int32 ManifoldPointBeginIndex ; FSimdInt32 SimdNumManifoldPoints ; FSimdRealf SimdStaticFriction ; FSimdRealf SimdDynamicFriction ; FSimdRealf SimdVelocityFriction ; FSimdRealf SimdStiffness ; FSimdRealf SimdInvM0 ; FSimdRealf SimdInvM1 ; } ; class FPBDCollisionSolverHelperSimd { public : template<int TNumLanes> void)",
    "insertText": "SolvePositionNoFriction(const TArrayView<TPBDCollisionSolverSimd<TNumLanes>>& Solvers, const TArrayView<TPBDCollisionSolverManifoldPointsSimd<TNumLanes>>& ManifoldPoints, const TArrayView<TSolverBodyPtrPairSimd<TNumLanes>>& SolverBodies, const FSolverReal Dt, const FSolverReal MaxPushOut)"
  },
  {
    "label": "SolvePositionWithFriction()",
    "kind": "Method",
    "detail": "Function (template<int TNumLanes> void)",
    "insertText": "SolvePositionWithFriction(const TArrayView<TPBDCollisionSolverSimd<TNumLanes>>& Solvers, const TArrayView<TPBDCollisionSolverManifoldPointsSimd<TNumLanes>>& ManifoldPoints, const TArrayView<TSolverBodyPtrPairSimd<TNumLanes>>& SolverBodies, const FSolverReal Dt, const FSolverReal MaxPushOut)"
  },
  {
    "label": "SolveVelocityNoFriction()",
    "kind": "Method",
    "detail": "Function (template<int TNumLanes> void)",
    "insertText": "SolveVelocityNoFriction(const TArrayView<TPBDCollisionSolverSimd<TNumLanes>>& Solvers, const TArrayView<TPBDCollisionSolverManifoldPointsSimd<TNumLanes>>& ManifoldPoints, const TArrayView<TSolverBodyPtrPairSimd<TNumLanes>>& SolverBodies, const FSolverReal Dt)"
  },
  {
    "label": "SolveVelocityWithFriction()",
    "kind": "Method",
    "detail": "Function (template<int TNumLanes> void)",
    "insertText": "SolveVelocityWithFriction(const TArrayView<TPBDCollisionSolverSimd<TNumLanes>>& Solvers, const TArrayView<TPBDCollisionSolverManifoldPointsSimd<TNumLanes>>& ManifoldPoints, const TArrayView<TSolverBodyPtrPairSimd<TNumLanes>>& SolverBodies, const FSolverReal Dt)"
  },
  {
    "label": "CheckISPC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckISPC()"
  },
  {
    "label": "SolvePositionNoFriction()",
    "kind": "Method",
    "detail": "Function (} ; template<> void)",
    "insertText": "SolvePositionNoFriction(const TArrayView<TPBDCollisionSolverSimd<4>>& Solvers, const TArrayView<TPBDCollisionSolverManifoldPointsSimd<4>>& ManifoldPoints, const TArrayView<TSolverBodyPtrPairSimd<4>>& SolverBodies, const FSolverReal Dt, const FSolverReal MaxPushOut)"
  },
  {
    "label": "SolvePositionWithFriction()",
    "kind": "Method",
    "detail": "Function (template<> void)",
    "insertText": "SolvePositionWithFriction(const TArrayView<TPBDCollisionSolverSimd<4>>& Solvers, const TArrayView<TPBDCollisionSolverManifoldPointsSimd<4>>& ManifoldPoints, const TArrayView<TSolverBodyPtrPairSimd<4>>& SolverBodies, const FSolverReal Dt, const FSolverReal MaxPushOut)"
  },
  {
    "label": "SolveVelocityNoFriction()",
    "kind": "Method",
    "detail": "Function (template<> void)",
    "insertText": "SolveVelocityNoFriction(const TArrayView<TPBDCollisionSolverSimd<4>>& Solvers, const TArrayView<TPBDCollisionSolverManifoldPointsSimd<4>>& ManifoldPoints, const TArrayView<TSolverBodyPtrPairSimd<4>>& SolverBodies, const FSolverReal Dt)"
  },
  {
    "label": "SolveVelocityWithFriction()",
    "kind": "Method",
    "detail": "Function (template<> void)",
    "insertText": "SolveVelocityWithFriction(const TArrayView<TPBDCollisionSolverSimd<4>>& Solvers, const TArrayView<TPBDCollisionSolverManifoldPointsSimd<4>>& ManifoldPoints, const TArrayView<TSolverBodyPtrPairSimd<4>>& SolverBodies, const FSolverReal Dt)"
  }
]