[
  {
    "label": "DefaultSingletonTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DefaultSingletonTraits"
  },
  {
    "label": "LeakySingletonTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LeakySingletonTraits"
  },
  {
    "label": "StaticMemorySingletonTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StaticMemorySingletonTraits"
  },
  {
    "label": "Singleton",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Singleton"
  },
  {
    "label": "New()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_MEMORY_SINGLETON_H_ # define BASE_MEMORY_SINGLETON_H_ # include<atomic> # include \" base / dcheck_is_on . h \" # include \" base / lazy_instance_helpers . h \" # include \" base / threading / thread_restrictions . h \" namespace base { template<Type> struct DefaultSingletonTraits { Type*)",
    "insertText": "New()"
  },
  {
    "label": "Delete()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Delete(Type* x)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (delete x ; } const bool kRegisterAtExit = true ; # if)",
    "insertText": "DCHECK_IS_ON()"
  },
  {
    "label": "Delete()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Delete(Type* p)"
  },
  {
    "label": "ResurrectForTesting()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "ResurrectForTesting()"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (dead_ .)",
    "insertText": "store(false, std::memory_order_relaxed)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "alignas(Type) static char buffer_[sizeof(Type)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (std::atomic<bool> dead_ ; } ; template<Type>)",
    "insertText": "alignas(Type) char StaticMemorySingletonTraits<Type>::buffer_[sizeof(Type)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (template<Type> std::atomic<bool> StaticMemorySingletonTraits<Type>::dead_ = false ; template<Type,Traits = DefaultSingletonTraits<Type>,DifferentiatingType = Type> class Singleton { private : Type ; Type*)",
    "insertText": "get()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() if (!Traits::kAllowedToAccessOnNonjoinableThread) internal::AssertSingletonAllowed()"
  },
  {
    "label": "GetOrCreateLazyPointer()",
    "kind": "Method",
    "detail": "Function (# endif return)",
    "insertText": "GetOrCreateLazyPointer(instance_, &CreatorFunc, nullptr, Traits::kRegisterAtExit ? OnExit : nullptr, nullptr)"
  },
  {
    "label": "GetIfExists()",
    "kind": "Method",
    "detail": "Function (} Type*)",
    "insertText": "GetIfExists()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(!instance_.load(std::memory_order_relaxed))"
  },
  {
    "label": "CreatorFunc()",
    "kind": "Method",
    "detail": "Function (} Type*)",
    "insertText": "CreatorFunc(void*)"
  },
  {
    "label": "OnExit()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnExit(void*)"
  },
  {
    "label": "Delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Delete(reinterpret_cast<Type*>(instance_.load(std::memory_order_relaxed)))"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (instance_ .)",
    "insertText": "store(0, std::memory_order_relaxed)"
  }
]