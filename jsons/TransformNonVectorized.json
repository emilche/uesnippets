[
  {
    "label": "Z_Construct_UScriptStruct_FTransform3f_Statics",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Z_Construct_UScriptStruct_FTransform3f_Statics"
  },
  {
    "label": "Z_Construct_UScriptStruct_FTransform3d_Statics",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Z_Construct_UScriptStruct_FTransform3d_Statics"
  },
  {
    "label": "Z_Construct_UScriptStruct_FTransform_Statics",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Z_Construct_UScriptStruct_FTransform_Statics"
  },
  {
    "label": "alignas",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "alignas"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / AssertionMacros . h \" # include \" Math / UnrealMathUtility . h \" # include \" Math / VectorRegister . h \" # include \" Math / ScalarRegister . h \" # if ! ENABLE_VECTORIZED_TRANSFORM struct Z_Construct_UScriptStruct_FTransform3f_Statics ; struct Z_Construct_UScriptStruct_FTransform3d_Statics ; struct Z_Construct_UScriptStruct_FTransform_Statics ; namespace UE { namespace Math { template<T> struct)",
    "insertText": "alignas(alignof(TQuat<T>))"
  },
  {
    "label": "DiagnosticCheckNaN_Scale3D()",
    "kind": "Method",
    "detail": "Function (Z_Construct_UScriptStruct_FTransform3f_Statics ; Z_Construct_UScriptStruct_FTransform3d_Statics ; Z_Construct_UScriptStruct_FTransform_Statics ; using FReal = T ; using TransformVectorRegister = TVectorRegisterType<T> ; protected : TQuat<T> Rotation ; TVector<T> Translation ; TVector<T> Scale3D ; public : const TTransform<T> Identity ; # if ENABLE_NAN_DIAGNOSTIC void)",
    "insertText": "DiagnosticCheckNaN_Scale3D()"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"TTransform<T> Scale3D contains NaN: %s\"), *Scale3D.ToString())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Scale3D = TVector<T>::OneVector)",
    "insertText": "T(this)"
  },
  {
    "label": "DiagnosticCheckNaN_Translate()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DiagnosticCheckNaN_Translate()"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"TTransform<T> Translation contains NaN: %s\"), *Translation.ToString())"
  },
  {
    "label": "DiagnosticCheckNaN_Rotate()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DiagnosticCheckNaN_Rotate()"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"TTransform<T> Rotation contains NaN: %s\"), *Rotation.ToString())"
  },
  {
    "label": "DiagnosticCheckNaN_All()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DiagnosticCheckNaN_All()"
  },
  {
    "label": "DiagnosticCheck_IsValid()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DiagnosticCheck_IsValid()"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"TTransform<T> transform is not valid: %s\"), *ToHumanReadableString())"
  },
  {
    "label": "TTransform()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "TTransform() : Rotation(0.f, 0.f, 0.f, 1.f) , Translation(0.f) , Scale3D(TVector<T>::OneVector)"
  },
  {
    "label": "TTransform()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TTransform(const TVector<T>& InTranslation) : Rotation(TQuat<T>::Identity), Translation(InTranslation), Scale3D(TVector<T>::OneVector)"
  },
  {
    "label": "TTransform()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TTransform(ENoInit)"
  },
  {
    "label": "Log2()",
    "kind": "Method",
    "detail": "Function (# if ENABLE_NAN_DIAGNOSTIC T qnan =)",
    "insertText": "Log2(-5.3f)"
  },
  {
    "label": "TTransform()",
    "kind": "Method",
    "detail": "Function (Translation . X = Translation . Y = Translation . Z = qnan ; Rotation . X = Rotation . Y = Rotation . Z = Rotation . W = qnan ; Scale3D . X = Scale3D . Y = Scale3D . Z = qnan ; # endif })",
    "insertText": "TTransform(const TQuat<T>& InRotation) : Rotation(InRotation), Translation(TVector<T>::ZeroVector), Scale3D(TVector<T>::OneVector)"
  },
  {
    "label": "TTransform()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TTransform(const TRotator<T>& InRotation) : Rotation(InRotation), Translation(TVector<T>::ZeroVector), Scale3D(TVector<T>::OneVector)"
  },
  {
    "label": "TTransform()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TTransform(const TQuat<T>& InRotation, const TVector<T>& InTranslation, const TVector<T>& InScale3D = TVector<T>::OneVector) : Rotation(InRotation), Translation(InTranslation), Scale3D(InScale3D)"
  },
  {
    "label": "TTransform()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TTransform(const TRotator<T>& InRotation, const TVector<T>& InTranslation, const TVector<T>& InScale3D = TVector<T>::OneVector) : Rotation(InRotation), Translation(InTranslation), Scale3D(InScale3D)"
  },
  {
    "label": "TTransform()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TTransform(const TMatrix<T>& InMatrix)"
  },
  {
    "label": "SetFromMatrix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFromMatrix(InMatrix)"
  },
  {
    "label": "TTransform()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TTransform(const TVector<T>& InX, const TVector<T>& InY, const TVector<T>& InZ, const TVector<T>& InTranslation)"
  },
  {
    "label": "SetFromMatrix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFromMatrix(TMatrix<T>(InX, InY, InZ, InTranslation))"
  },
  {
    "label": "DebugPrint()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DebugPrint()"
  },
  {
    "label": "DebugEqualMatrix()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DebugEqualMatrix(const TMatrix<T>& Matrix)"
  },
  {
    "label": "ToHumanReadableString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ToHumanReadableString()"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ToString()"
  },
  {
    "label": "InitFromString()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "InitFromString(const FString& InSourceString)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TMatrix<T> OutMatrix ; #)",
    "insertText": "if(UE_BUILD_SHIPPING || UE_BUILD_TEST) && WITH_EDITORONLY_DATA check(IsRotationNormalized())"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (# endif OutMatrix . M [ 3 ] [ 0 ] = Translation . X ; OutMatrix . M [ 3 ] [ 1 ] = Translation . Y ; OutMatrix . M [ 3 ] [ 2 ] = Translation . Z ; const FReal x2 = Rotation . X + Rotation . X ; const FReal y2 = Rotation . Y + Rotation . Y ; const FReal z2 = Rotation . Z + Rotation . Z ; { const FReal xx2 = Rotation . X* x2 ; const FReal yy2 = Rotation . Y* y2 ; const FReal zz2 = Rotation . Z* z2 ; OutMatrix .)",
    "insertText": "M(1.0f - (yy2 + zz2))"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (OutMatrix .)",
    "insertText": "M(1.0f - (xx2 + zz2))"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (OutMatrix .)",
    "insertText": "M(1.0f - (xx2 + yy2))"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (} { const FReal yz2 = Rotation . Y* z2 ; const FReal wx2 = Rotation . W* x2 ; OutMatrix .)",
    "insertText": "M(yz2 - wx2)"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (OutMatrix .)",
    "insertText": "M(yz2 + wx2)"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (} { const FReal xy2 = Rotation . X* y2 ; const FReal wz2 = Rotation . W* z2 ; OutMatrix .)",
    "insertText": "M(xy2 - wz2)"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (OutMatrix .)",
    "insertText": "M(xy2 + wz2)"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (} { const FReal xz2 = Rotation . X* z2 ; const FReal wy2 = Rotation . W* y2 ; OutMatrix .)",
    "insertText": "M(xz2 + wy2)"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (OutMatrix .)",
    "insertText": "M(xz2 - wy2)"
  },
  {
    "label": "ToInverseMatrixWithScale()",
    "kind": "Method",
    "detail": "Function (} OutMatrix . M [ 0 ] [ 3 ] = 0 . 0 f ; OutMatrix . M [ 1 ] [ 3 ] = 0 . 0 f ; OutMatrix . M [ 2 ] [ 3 ] = 0 . 0 f ; OutMatrix . M [ 3 ] [ 3 ] = 1 . 0 f ; return OutMatrix ; } TMatrix<T>)",
    "insertText": "ToInverseMatrixWithScale()"
  },
  {
    "label": "Inverse()",
    "kind": "Method",
    "detail": "Function (} TTransform<T>)",
    "insertText": "Inverse()"
  },
  {
    "label": "GetSafeScaleReciprocal()",
    "kind": "Method",
    "detail": "Function (TVector<T> InvScale3D =)",
    "insertText": "GetSafeScaleReciprocal(Scale3D)"
  },
  {
    "label": "InvRotation()",
    "kind": "Method",
    "detail": "Function (TVector<T> InvTranslation =)",
    "insertText": "InvRotation(InvScale3D * -Translation)"
  },
  {
    "label": "ToMatrixNoScale()",
    "kind": "Method",
    "detail": "Function (} TMatrix<T>)",
    "insertText": "ToMatrixNoScale()"
  },
  {
    "label": "Blend()",
    "kind": "Method",
    "detail": "Function (} OutMatrix . M [ 0 ] [ 3 ] = 0 . 0 f ; OutMatrix . M [ 1 ] [ 3 ] = 0 . 0 f ; OutMatrix . M [ 2 ] [ 3 ] = 0 . 0 f ; OutMatrix . M [ 3 ] [ 3 ] = 1 . 0 f ; return OutMatrix ; } void)",
    "insertText": "Blend(const TTransform<T>& Atom1, const TTransform<T>& Atom2, float Alpha)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "if(UE_BUILD_SHIPPING || UE_BUILD_TEST) && WITH_EDITORONLY_DATA check(Atom1.IsRotationNormalized())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(Alpha <= ZERO_ANIMWEIGHT_THRESH)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Alpha >= 1.f - ZERO_ANIMWEIGHT_THRESH)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (} else { Translation =)",
    "insertText": "Lerp(Atom1.Translation, Atom2.Translation, Alpha)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (Scale3D =)",
    "insertText": "Lerp(Atom1.Scale3D, Atom2.Scale3D, Alpha)"
  },
  {
    "label": "FastLerp()",
    "kind": "Method",
    "detail": "Function (Rotation = TQuat<T)",
    "insertText": "FastLerp(Atom1.Rotation, Atom2.Rotation, Alpha)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (Rotation .)",
    "insertText": "Normalize()"
  },
  {
    "label": "BlendWith()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "BlendWith(const TTransform<T>& OtherAtom, float Alpha)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(Alpha > ZERO_ANIMWEIGHT_THRESH)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (} else { Translation =)",
    "insertText": "Lerp(Translation, OtherAtom.Translation, Alpha)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (Scale3D =)",
    "insertText": "Lerp(Scale3D, OtherAtom.Scale3D, Alpha)"
  },
  {
    "label": "FastLerp()",
    "kind": "Method",
    "detail": "Function (Rotation = TQuat<T)",
    "insertText": "FastLerp(Rotation, OtherAtom.Rotation, Alpha)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } } TTransform<T>)",
    "insertText": "operator(const TTransform<T>& Atom)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Translation + = Atom . Translation ; Rotation . X + = Atom . Rotation . X ; Rotation . Y + = Atom . Rotation . Y ; Rotation . Z + = Atom . Rotation . Z ; Rotation . W + = Atom . Rotation . W ; Scale3D + = Atom . Scale3D ; return* this ; } TTransform<T>)",
    "insertText": "operator(T Mult)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Translation* = Mult ; Rotation . X* = Mult ; Rotation . Y* = Mult ; Rotation . Z* = Mult ; Rotation . W* = Mult ; Scale3D* = Mult ; return* this ; } TTransform<T>)",
    "insertText": "operator(const TTransform<T>& Other)"
  },
  {
    "label": "GetRelativeTransform()",
    "kind": "Method",
    "detail": "Function (TTransform<T>)",
    "insertText": "GetRelativeTransform(const TTransform<T>& Other)"
  },
  {
    "label": "GetRelativeTransformReverse()",
    "kind": "Method",
    "detail": "Function (TTransform<T>)",
    "insertText": "GetRelativeTransformReverse(const TTransform<T>& Other)"
  },
  {
    "label": "SetToRelativeTransform()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetToRelativeTransform(const TTransform<T>& ParentTransform)"
  },
  {
    "label": "Rotator()",
    "kind": "Method",
    "detail": "Function (} TRotator<T>)",
    "insertText": "Rotator()"
  },
  {
    "label": "GetDeterminant()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "GetDeterminant()"
  },
  {
    "label": "SetLocation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetLocation(const TVector<T>& Origin)"
  },
  {
    "label": "ContainsNaN()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ContainsNaN()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar<<M . Rotation ; Ar<<M . Translation ; Ar<<M . Scale3D ; return Ar ; } bool)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "SerializeFromMismatchedTag()",
    "kind": "Method",
    "detail": "Function (Ar<<* this ; return true ; } bool)",
    "insertText": "SerializeFromMismatchedTag(FName StructTag, FArchive& Ar)"
  },
  {
    "label": "Private_RotationEquals()",
    "kind": "Method",
    "detail": "Function (private : bool)",
    "insertText": "Private_RotationEquals(const TQuat<T>& InRotation, const FReal Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "Private_TranslationEquals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Private_TranslationEquals(const TVector<T>& InTranslation, const FReal Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "Private_Scale3DEquals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Private_Scale3DEquals(const TVector<T>& InScale3D, const FReal Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "AreRotationsEqual()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "AreRotationsEqual(const TTransform<T>& A, const TTransform<T>& B, FReal Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "AreTranslationsEqual()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "AreTranslationsEqual(const TTransform<T>& A, const TTransform<T>& B, FReal Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "AreScale3DsEqual()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "AreScale3DsEqual(const TTransform<T>& A, const TTransform<T>& B, FReal Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "RotationEquals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "RotationEquals(const TTransform<T>& Other, FReal Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "TranslationEquals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "TranslationEquals(const TTransform<T>& Other, FReal Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "Scale3DEquals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Scale3DEquals(const TTransform<T>& Other, FReal Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Equals(const TTransform<T>& Other, FReal Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "Identical()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Identical(const TTransform<T>* Other, uint32 PortFlags)"
  },
  {
    "label": "EqualsNoScale()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "EqualsNoScale(const TTransform<T>& Other, FReal Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "Multiply()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Multiply(TTransform<T>* OutTransform, const TTransform<T>* A, const TTransform<T>* B)"
  },
  {
    "label": "SetIdentity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetIdentity()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Rotation = TQuat<T>::Identity ; Translation = TVector<T>::ZeroVector ; Scale3D = TVector<)",
    "insertText": "T(1, 1, 1)"
  },
  {
    "label": "SetIdentityZeroScale()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetIdentityZeroScale()"
  },
  {
    "label": "MultiplyScale3D()",
    "kind": "Method",
    "detail": "Function (Rotation = TQuat<T>::Identity ; Translation = TVector<T>::ZeroVector ; Scale3D = TVector<T>::ZeroVector ; } void)",
    "insertText": "MultiplyScale3D(const TVector<T>& Scale3DMultiplier)"
  },
  {
    "label": "SetTranslation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetTranslation(const TVector<T>& NewTranslation)"
  },
  {
    "label": "CopyTranslation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CopyTranslation(const TTransform<T>& Other)"
  },
  {
    "label": "ConcatenateRotation()",
    "kind": "Method",
    "detail": "Function (Translation = Other . Translation ; } void)",
    "insertText": "ConcatenateRotation(const TQuat<T>& DeltaRotation)"
  },
  {
    "label": "AddToTranslation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddToTranslation(const TVector<T>& DeltaTranslation)"
  },
  {
    "label": "AddTranslations()",
    "kind": "Method",
    "detail": "Function (} TVector<T>)",
    "insertText": "AddTranslations(const TTransform<T>& A, const TTransform<T>& B)"
  },
  {
    "label": "CopyRotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CopyRotation(const TTransform<T>& Other)"
  },
  {
    "label": "SetScale3D()",
    "kind": "Method",
    "detail": "Function (Rotation = Other . Rotation ; } void)",
    "insertText": "SetScale3D(const TVector<T>& NewScale3D)"
  },
  {
    "label": "CopyScale3D()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CopyScale3D(const TTransform<T>& Other)"
  },
  {
    "label": "SetTranslationAndScale3D()",
    "kind": "Method",
    "detail": "Function (Scale3D = Other . Scale3D ; } void)",
    "insertText": "SetTranslationAndScale3D(const TVector<T>& NewTranslation, const TVector<T>& NewScale3D)"
  },
  {
    "label": "GetTranslationRegister()",
    "kind": "Method",
    "detail": "Function (} TransformVectorRegister)",
    "insertText": "GetTranslationRegister()"
  },
  {
    "label": "GetRotationRegister()",
    "kind": "Method",
    "detail": "Function (} TransformVectorRegister)",
    "insertText": "GetRotationRegister()"
  },
  {
    "label": "SetTranslationRegister()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetTranslationRegister(TransformVectorRegister InTranslation)"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreFloat3(InTranslation, &Translation)"
  },
  {
    "label": "SetRotationRegister()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetRotationRegister(TransformVectorRegister InRotation)"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStore(InRotation, &Rotation)"
  },
  {
    "label": "Accumulate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Accumulate(const TTransform<T>& SourceAtom)"
  },
  {
    "label": "Accumulate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Accumulate(const TTransform<T>& Atom, FReal BlendWeight)"
  },
  {
    "label": "SourceAtom()",
    "kind": "Method",
    "detail": "Function (TTransform<T>)",
    "insertText": "SourceAtom(Atom * BlendWeight)"
  },
  {
    "label": "AccumulateWithShortestRotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AccumulateWithShortestRotation(const TTransform<T>& DeltaAtom, FReal BlendWeight)"
  },
  {
    "label": "Atom()",
    "kind": "Method",
    "detail": "Function (TTransform<T>)",
    "insertText": "Atom(DeltaAtom * BlendWeight)"
  },
  {
    "label": "AccumulateWithAdditiveScale()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AccumulateWithAdditiveScale(const TTransform<T>& Atom, T BlendWeight)"
  },
  {
    "label": "DefaultScale()",
    "kind": "Method",
    "detail": "Function (const TVector<T>)",
    "insertText": "DefaultScale(TVector<T>::OneVector)"
  },
  {
    "label": "Scale3D()",
    "kind": "Method",
    "detail": "Function (Rotation = SourceAtom . Rotation* Rotation ; Translation + = SourceAtom . Translation ;)",
    "insertText": "Scale3D(DefaultScale + SourceAtom.Scale3D)"
  },
  {
    "label": "LerpTranslationScale3D()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "LerpTranslationScale3D(const TTransform<T>& SourceAtom1, const TTransform<T>& SourceAtom2, ScalarRegister Alpha)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (Translation =)",
    "insertText": "Lerp(SourceAtom1.Translation, SourceAtom2.Translation, Alpha)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (Scale3D =)",
    "insertText": "Lerp(SourceAtom1.Scale3D, SourceAtom2.Scale3D, Alpha)"
  },
  {
    "label": "NormalizeRotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "NormalizeRotation()"
  },
  {
    "label": "IsRotationNormalized()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsRotationNormalized()"
  },
  {
    "label": "BlendFromIdentityAndAccumulate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BlendFromIdentityAndAccumulate(TTransform<T>& FinalAtom, const TTransform<T>& SourceAtom, float BlendWeight)"
  },
  {
    "label": "AdditiveIdentity()",
    "kind": "Method",
    "detail": "Function (const TTransform<T>)",
    "insertText": "AdditiveIdentity(TQuat<T>::Identity, TVector<T>::ZeroVector, TVector<T>::ZeroVector)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TTransform<T> DeltaAtom = SourceAtom ;)",
    "insertText": "if(BlendWeight < (1.f - ZERO_ANIMWEIGHT_THRESH))"
  },
  {
    "label": "Blend()",
    "kind": "Method",
    "detail": "Function (DeltaAtom .)",
    "insertText": "Blend(AdditiveIdentity, DeltaAtom, BlendWeight)"
  },
  {
    "label": "Scale3D()",
    "kind": "Method",
    "detail": "Function (} FinalAtom . Rotation = DeltaAtom . Rotation* FinalAtom . Rotation ; FinalAtom . Translation + = DeltaAtom . Translation ; FinalAtom .)",
    "insertText": "Scale3D(DefaultScale + DeltaAtom.Scale3D)"
  },
  {
    "label": "GetRotation()",
    "kind": "Method",
    "detail": "Function (} TQuat<T>)",
    "insertText": "GetRotation()"
  },
  {
    "label": "CopyTranslationAndScale3D()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CopyTranslationAndScale3D(const TTransform<T>& SrcBA)"
  },
  {
    "label": "SetFromMatrix()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetFromMatrix(const TMatrix<T>& InMatrix)"
  },
  {
    "label": "ExtractScaling()",
    "kind": "Method",
    "detail": "Function (TMatrix<T> M = InMatrix ; Scale3D = M .)",
    "insertText": "ExtractScaling()"
  },
  {
    "label": "SetAxis()",
    "kind": "Method",
    "detail": "Function (Scale3D . X* = - 1 . f ; M .)",
    "insertText": "SetAxis(0, -M.GetScaledAxis(EAxis::X))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} Rotation = TQuat<)",
    "insertText": "T(M)"
  },
  {
    "label": "GetOrigin()",
    "kind": "Method",
    "detail": "Function (Translation = InMatrix .)",
    "insertText": "GetOrigin()"
  },
  {
    "label": "MultiplyUsingMatrixWithScale()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "MultiplyUsingMatrixWithScale(TTransform<T>* OutTransform, const TTransform<T>* A, const TTransform<T>* B)"
  },
  {
    "label": "GetRelativeTransformUsingMatrixWithScale()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetRelativeTransformUsingMatrixWithScale(TTransform<T>* OutTransform, const TTransform<T>* Base, const TTransform<T>* Relative)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (public : template<FArg)",
    "insertText": "UE_REQUIRES(!std::is_same_v<T, FArg>)> explicit TTransform(const TTransform<FArg>& From) : TTransform<T>((TQuat<T>)From.GetRotation(), (TVector<T>)From.GetTranslation(), (TVector<T>)From.GetScale3D())"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # if !)",
    "insertText": "defined(_MSC_VER) || defined(__clang__)"
  },
  {
    "label": "AnyHasNegativeScale()",
    "kind": "Method",
    "detail": "Function (template<> const FTransform3d FTransform3d::Identity ; # endif template<T> bool TTransform<T)",
    "insertText": "AnyHasNegativeScale(const TVector<T>& InScale3D, const TVector<T>& InOtherScale3D)"
  },
  {
    "label": "ScaleTranslation()",
    "kind": "Method",
    "detail": "Function (} template<T> void TTransform<T)",
    "insertText": "ScaleTranslation(const TVector<T>& InScale3D)"
  },
  {
    "label": "ScaleTranslation()",
    "kind": "Method",
    "detail": "Function (} template<T> void TTransform<T)",
    "insertText": "ScaleTranslation(const FReal& Scale)"
  },
  {
    "label": "RemoveScaling()",
    "kind": "Method",
    "detail": "Function (} template<T> void TTransform<T)",
    "insertText": "RemoveScaling(T Tolerance)"
  },
  {
    "label": "ConstructTransformFromMatrixWithDesiredScale()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstructTransformFromMatrixWithDesiredScale(A->ToMatrixWithScale(), B->ToMatrixWithScale(), A->Scale3D*B->Scale3D, *OutTransform)"
  },
  {
    "label": "ConstructTransformFromMatrixWithDesiredScale()",
    "kind": "Method",
    "detail": "Function (} template<T> void TTransform<T)",
    "insertText": "ConstructTransformFromMatrixWithDesiredScale(const TMatrix<T>& AMatrix, const TMatrix<T>& BMatrix, const TVector<T>& DesiredScale, TTransform<T>& OutTransform)"
  },
  {
    "label": "RemoveScaling()",
    "kind": "Method",
    "detail": "Function (TMatrix<T> M = AMatrix* BMatrix ; M .)",
    "insertText": "RemoveScaling()"
  },
  {
    "label": "GetSignVector()",
    "kind": "Method",
    "detail": "Function (TVector<T> SignedScale = DesiredScale .)",
    "insertText": "GetSignVector()"
  },
  {
    "label": "SetAxis()",
    "kind": "Method",
    "detail": "Function (M .)",
    "insertText": "SetAxis(0, SignedScale.X * M.GetScaledAxis(EAxis::X))"
  },
  {
    "label": "SetAxis()",
    "kind": "Method",
    "detail": "Function (M .)",
    "insertText": "SetAxis(1, SignedScale.Y * M.GetScaledAxis(EAxis::Y))"
  },
  {
    "label": "SetAxis()",
    "kind": "Method",
    "detail": "Function (M .)",
    "insertText": "SetAxis(2, SignedScale.Z * M.GetScaledAxis(EAxis::Z))"
  },
  {
    "label": "MultiplyUsingMatrixWithScale()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MultiplyUsingMatrixWithScale(OutTransform, A, B)"
  },
  {
    "label": "Rotation()",
    "kind": "Method",
    "detail": "Function (Translation)",
    "insertText": "Rotation(B->Scale3D*A->Translation)"
  },
  {
    "label": "GetScaled()",
    "kind": "Method",
    "detail": "Function (} } template<T> TTransform<T> TTransform<T)",
    "insertText": "GetScaled(T InScale)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (TTransform<T>)",
    "insertText": "A(*this)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TVector4<T> Transform = TVector4<)",
    "insertText": "T(Rotation.RotateVector(TVector<T>(V)), 0.f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Transform + = TVector4<)",
    "insertText": "T(Translation, 1.f)"
  },
  {
    "label": "TransformFVector4()",
    "kind": "Method",
    "detail": "Function (} return Transform ; } template<T> TVector4<T> TTransform<T)",
    "insertText": "TransformFVector4(const TVector4<T>& V)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TVector4<T> Transform = TVector4<)",
    "insertText": "T(Rotation.RotateVector(Scale3D*TVector<T>(V)), 0.f)"
  },
  {
    "label": "TransformPosition()",
    "kind": "Method",
    "detail": "Function (} return Transform ; } template<T> TVector<T> TTransform<T)",
    "insertText": "TransformPosition(const TVector<T>& V)"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector<T> TTransform<T)",
    "insertText": "TransformPositionNoScale(const TVector<T>& V)"
  },
  {
    "label": "TransformVector()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector<T> TTransform<T)",
    "insertText": "TransformVector(const TVector<T>& V)"
  },
  {
    "label": "TransformVectorNoScale()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector<T> TTransform<T)",
    "insertText": "TransformVectorNoScale(const TVector<T>& V)"
  },
  {
    "label": "InverseTransformPosition()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector<T> TTransform<T)",
    "insertText": "InverseTransformPosition(const TVector<T> &V)"
  },
  {
    "label": "InverseTransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector<T> TTransform<T)",
    "insertText": "InverseTransformPositionNoScale(const TVector<T> &V)"
  },
  {
    "label": "InverseTransformVector()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector<T> TTransform<T)",
    "insertText": "InverseTransformVector(const TVector<T> &V)"
  },
  {
    "label": "InverseTransformVectorNoScale()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector<T> TTransform<T)",
    "insertText": "InverseTransformVectorNoScale(const TVector<T> &V)"
  },
  {
    "label": "TransformRotation()",
    "kind": "Method",
    "detail": "Function (} template<T> TQuat<T> TTransform<T)",
    "insertText": "TransformRotation(const TQuat<T>& Q)"
  },
  {
    "label": "InverseTransformRotation()",
    "kind": "Method",
    "detail": "Function (} template<T> TQuat<T> TTransform<T)",
    "insertText": "InverseTransformRotation(const TQuat<T>& Q)"
  },
  {
    "label": "Multiply()",
    "kind": "Method",
    "detail": "Function (TTransform<T> Output ;)",
    "insertText": "Multiply(&Output, this, &Other)"
  },
  {
    "label": "Multiply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Multiply(this, this, &Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> TTransform<T> TTransform<T)",
    "insertText": "operator(const TQuat<T>& Other)"
  },
  {
    "label": "OtherTransform()",
    "kind": "Method",
    "detail": "Function (TTransform<T> Output,)",
    "insertText": "OtherTransform(Other, TVector<T>::ZeroVector, TVector<T>::OneVector)"
  },
  {
    "label": "Multiply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Multiply(&Output, this, &OtherTransform)"
  },
  {
    "label": "Multiply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Multiply(this, this, &OtherTransform)"
  },
  {
    "label": "GetScaledAxis()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector<T> TTransform<T)",
    "insertText": "GetScaledAxis(EAxis::Type InAxis)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(InAxis == EAxis::Y)"
  },
  {
    "label": "TransformVector()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "TransformVector(TVector<T>(0.f, 0.f, 1.f))"
  },
  {
    "label": "GetUnitAxis()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector<T> TTransform<T)",
    "insertText": "GetUnitAxis(EAxis::Type InAxis)"
  },
  {
    "label": "TransformVectorNoScale()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "TransformVectorNoScale(TVector<T>(0.f, 0.f, 1.f))"
  },
  {
    "label": "Mirror()",
    "kind": "Method",
    "detail": "Function (} template<T> void TTransform<T)",
    "insertText": "Mirror(EAxis::Type MirrorAxis, EAxis::Type FlipAxis)"
  },
  {
    "label": "ToMatrixWithScale()",
    "kind": "Method",
    "detail": "Function (TMatrix<T> M =)",
    "insertText": "ToMatrixWithScale()"
  },
  {
    "label": "Mirror()",
    "kind": "Method",
    "detail": "Function (M .)",
    "insertText": "Mirror(MirrorAxis, FlipAxis)"
  },
  {
    "label": "SetFromMatrix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFromMatrix(M)"
  },
  {
    "label": "GetMaximumAxisScale()",
    "kind": "Method",
    "detail": "Function (} template<T> T TTransform<T)",
    "insertText": "GetMaximumAxisScale()"
  },
  {
    "label": "GetMinimumAxisScale()",
    "kind": "Method",
    "detail": "Function (} template<T> T TTransform<T)",
    "insertText": "GetMinimumAxisScale()"
  },
  {
    "label": "GetSafeScaleReciprocal()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector<T> TTransform<T)",
    "insertText": "GetSafeScaleReciprocal(const TVector<T>& InScale, T Tolerance)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TVector<T> SafeReciprocalScale ;)",
    "insertText": "if(FMath::Abs(InScale.X) <= Tolerance)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SafeReciprocalScale . X = 0 . f ; } else { SafeReciprocalScale . X = 1 / InScale . X ; })",
    "insertText": "if(FMath::Abs(InScale.Y) <= Tolerance)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SafeReciprocalScale . Y = 0 . f ; } else { SafeReciprocalScale . Y = 1 / InScale . Y ; })",
    "insertText": "if(FMath::Abs(InScale.Z) <= Tolerance)"
  }
]