[
  {
    "label": "PardisoLU",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PardisoLU"
  },
  {
    "label": "PardisoLLT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PardisoLLT"
  },
  {
    "label": "PardisoLDLT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PardisoLDLT"
  },
  {
    "label": "pardiso_run_selector",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "pardiso_run_selector"
  },
  {
    "label": "Pardiso",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Pardiso"
  },
  {
    "label": "pardiso_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "pardiso_traits"
  },
  {
    "label": "Derived",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Derived"
  },
  {
    "label": "PardisoImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PardisoImpl"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_PARDISOSUPPORT_H # define EIGEN_PARDISOSUPPORT_H namespace Eigen { template<_MatrixType> class PardisoLU ; template<_MatrixType,int Options = Upper> class PardisoLLT ; template<_MatrixType,int Options = Upper> class PardisoLDLT ; namespace internal { template<IndexType> struct pardiso_run_selector { IndexType)",
    "insertText": "run(_MKL_DSS_HANDLE_t pt, IndexType maxfct, IndexType mnum, IndexType type, IndexType phase, IndexType n, void *a, IndexType *ia, IndexType *ja, IndexType *perm, IndexType nrhs, IndexType *iparm, IndexType msglvl, void *b, void *x)"
  },
  {
    "label": "pardiso()",
    "kind": "Method",
    "detail": "Function (IndexType error = 0)",
    "insertText": "pardiso(pt, &maxfct, &mnum, &type, &phase, &n, a, ia, ja, perm, &nrhs, iparm, &msglvl, b, x, &error)"
  },
  {
    "label": "pardiso_64()",
    "kind": "Method",
    "detail": "Function (IndexType error = 0)",
    "insertText": "pardiso_64(pt, &maxfct, &mnum, &type, &phase, &n, a, ia, ja, perm, &nrhs, iparm, &msglvl, b, x, &error)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert((sizeof(StorageIndex) >= sizeof(_INTEGER_t) && sizeof(StorageIndex) <= 8) && \"Non-supported index type\")"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (m_iparm .)",
    "insertText": "setZero()"
  },
  {
    "label": "PardisoImpl()",
    "kind": "Method",
    "detail": "Function (m_msglvl = 0 ; m_isInitialized = false ; } ~)",
    "insertText": "PardisoImpl()"
  },
  {
    "label": "pardisoRelease()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pardisoRelease()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "cols()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized && \"Decomposition is not initialized.\")"
  },
  {
    "label": "factorize()",
    "kind": "Method",
    "detail": "Function (Derived&)",
    "insertText": "factorize(const MatrixType& matrix)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (Derived&)",
    "insertText": "compute(const MatrixType& matrix)"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (template<Rhs,Dest> void)",
    "insertText": "_solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (internal::pardiso_run_selector<StorageIndex)",
    "insertText": "run(m_pt, 1, 1, m_type, -1, internal::convert_index<StorageIndex>(m_size),0, 0, 0, m_perm.data(), 0, m_iparm.data(), m_msglvl, NULL, NULL)"
  },
  {
    "label": "pardisoInit()",
    "kind": "Method",
    "detail": "Function (m_isInitialized = false ; } } void)",
    "insertText": "pardisoInit(int type)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (m_type = type ; bool symmetric =)",
    "insertText": "abs(m_type)"
  },
  {
    "label": "m_iparm()",
    "kind": "Method",
    "detail": "Function (m_iparm [ 0 ] = 1 ; m_iparm [ 1 ] = 2 ; m_iparm [ 2 ] = 0 ; m_iparm [ 3 ] = 0 ; m_iparm [ 4 ] = 0 ; m_iparm [ 5 ] = 0 ; m_iparm [ 6 ] = 0 ; m_iparm [ 7 ] = 2 ; m_iparm [ 8 ] = 0 ; m_iparm [ 9 ] = 1 3 ; m_iparm [ 1 0 ] = symmetric ? 0 : 1 ; m_iparm [ 1 1 ] = 0 ; m_iparm [ 1 2 ] = symmetric ? 0 : 1 ; m_iparm [ 1 3 ] = 0 ; m_iparm [ 1 4 ] = 0 ; m_iparm [ 1 5 ] = 0 ; m_iparm [ 1 6 ] = 0 ; m_iparm [ 1 7 ] = - 1 ; m_iparm [ 1 8 ] = - 1 ; m_iparm [ 1 9 ] = 0 ; m_iparm [ 2 0 ] = 0 ; m_iparm [ 2 6 ] = 0 ;)",
    "insertText": "m_iparm(sizeof(RealScalar) == 4)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (m_iparm [ 3 4 ] = 1 ; m_iparm [ 3 6 ] = 0 ; m_iparm [ 5 9 ] = 0 ;)",
    "insertText": "memset(m_pt, 0, sizeof(m_pt))"
  },
  {
    "label": "manageErrorCode()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "manageErrorCode(Index error)"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (m_size = a .)",
    "insertText": "rows()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(a.rows() == a.cols())"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (m_perm .)",
    "insertText": "setZero(m_size)"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "derived().getMatrix(a)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (Index error ; error = internal::pardiso_run_selector<StorageIndex)",
    "insertText": "run(m_pt, 1, 1, m_type, 12, internal::convert_index<StorageIndex>(m_size), m_matrix.valuePtr(), m_matrix.outerIndexPtr(), m_matrix.innerIndexPtr(), m_perm.data(), 0, m_iparm.data(), m_msglvl, NULL, NULL)"
  },
  {
    "label": "manageErrorCode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "manageErrorCode(error)"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (m_analysisIsOk = true ; m_factorizationIsOk = true ; m_isInitialized = true ; return)",
    "insertText": "derived()"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (} template<class Derived> Derived& PardisoImpl<Derived)",
    "insertText": "analyzePattern(const MatrixType& a)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_size == a.cols())"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (Index error ; error = internal::pardiso_run_selector<StorageIndex)",
    "insertText": "run(m_pt, 1, 1, m_type, 11, internal::convert_index<StorageIndex>(m_size), m_matrix.valuePtr(), m_matrix.outerIndexPtr(), m_matrix.innerIndexPtr(), m_perm.data(), 0, m_iparm.data(), m_msglvl, NULL, NULL)"
  },
  {
    "label": "factorize()",
    "kind": "Method",
    "detail": "Function (} template<class Derived> Derived& PardisoImpl<Derived)",
    "insertText": "factorize(const MatrixType& a)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_analysisIsOk && \"You must first call analyzePattern()\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_size == a.rows() && m_size == a.cols())"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (Index error ; error = internal::pardiso_run_selector<StorageIndex)",
    "insertText": "run(m_pt, 1, 1, m_type, 22, internal::convert_index<StorageIndex>(m_size), m_matrix.valuePtr(), m_matrix.outerIndexPtr(), m_matrix.innerIndexPtr(), m_perm.data(), 0, m_iparm.data(), m_msglvl, NULL, NULL)"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (} template<class Derived> template<BDerived,XDerived> void PardisoImpl<Derived)",
    "insertText": "_solve_impl(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (m_info = InvalidInput ; return ; } Index nrhs =)",
    "insertText": "Index(b.cols())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_size==b.rows())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(((MatrixBase<BDerived>::Flags & RowMajorBit) == 0 || nrhs == 1) && \"Row-major right hand sides are not supported\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(((MatrixBase<XDerived>::Flags & RowMajorBit) == 0 || nrhs == 1) && \"Row-major matrices of unknowns are not supported\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(((nrhs == 1) || b.outerStride() == b.rows()))"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (Scalar* rhs_ptr = const_cast<)",
    "insertText": "Scalar(b.derived().data())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Matrix<Scalar,Dynamic,Dynamic,ColMajor> tmp ;)",
    "insertText": "if(rhs_ptr == x.derived().data())"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (tmp = b ; rhs_ptr = tmp .)",
    "insertText": "data()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} Index error ; error = internal::pardiso_run_selector<StorageIndex)",
    "insertText": "run(m_pt, 1, 1, m_type, 33, internal::convert_index<StorageIndex>(m_size), m_matrix.valuePtr(), m_matrix.outerIndexPtr(), m_matrix.innerIndexPtr(), m_perm.data(), internal::convert_index<StorageIndex>(nrhs), m_iparm.data(), m_msglvl, rhs_ptr, x.derived().data())"
  },
  {
    "label": "PardisoLU()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> class PardisoLU : public PardisoImpl<PardisoLU<MatrixType>> { protected : typedef PardisoImpl<PardisoLU> Base ; using Base::pardisoInit ; using Base::m_matrix ; class PardisoImpl<PardisoLU<MatrixType>> ; public : typedef Base::Scalar Scalar ; typedef Base::RealScalar RealScalar ; using Base::compute ; using Base::solve ;)",
    "insertText": "PardisoLU() : Base()"
  },
  {
    "label": "pardisoInit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pardisoInit(Base::ScalarIsComplex ? 13 : 11)"
  },
  {
    "label": "PardisoLU()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PardisoLU(const MatrixType& matrix) : Base()"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(matrix)"
  },
  {
    "label": "getMatrix()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "getMatrix(const MatrixType& matrix)"
  },
  {
    "label": "makeCompressed()",
    "kind": "Method",
    "detail": "Function (m_matrix = matrix ; m_matrix .)",
    "insertText": "makeCompressed()"
  },
  {
    "label": "PardisoLLT()",
    "kind": "Method",
    "detail": "Function (} } ; template<MatrixType,int _UpLo> class PardisoLLT : public PardisoImpl<PardisoLLT<MatrixType,_UpLo>> { protected : typedef PardisoImpl<PardisoLLT<MatrixType,_UpLo>> Base ; using Base::pardisoInit ; using Base::m_matrix ; class PardisoImpl<PardisoLLT<MatrixType,_UpLo>> ; public : typedef Base::Scalar Scalar ; typedef Base::RealScalar RealScalar ; typedef Base::StorageIndex StorageIndex ; enum { UpLo = _UpLo } ; using Base::compute ;)",
    "insertText": "PardisoLLT() : Base()"
  },
  {
    "label": "pardisoInit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pardisoInit(Base::ScalarIsComplex ? 4 : 2)"
  },
  {
    "label": "PardisoLLT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PardisoLLT(const MatrixType& matrix) : Base()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (PermutationMatrix<Dynamic,Dynamic,StorageIndex> p_null ; m_matrix .)",
    "insertText": "resize(matrix.rows(), matrix.cols())"
  },
  {
    "label": "Upper()",
    "kind": "Method",
    "detail": "Function (m_matrix . template selfadjointView<)",
    "insertText": "Upper() = matrix.template selfadjointView<UpLo>().twistedBy(p_null)"
  },
  {
    "label": "Options()",
    "kind": "Method",
    "detail": "Function (} } ; template<MatrixType,int Options> class PardisoLDLT : public PardisoImpl<PardisoLDLT<MatrixType,Options>> { protected : typedef PardisoImpl<PardisoLDLT<MatrixType,Options>> Base ; using Base::pardisoInit ; using Base::m_matrix ; class PardisoImpl<PardisoLDLT<MatrixType,Options>> ; public : typedef Base::Scalar Scalar ; typedef Base::RealScalar RealScalar ; typedef Base::StorageIndex StorageIndex ; using Base::compute ; enum { UpLo =)",
    "insertText": "Options(Upper|Lower)"
  },
  {
    "label": "PardisoLDLT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PardisoLDLT() : Base()"
  },
  {
    "label": "pardisoInit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pardisoInit(Base::ScalarIsComplex ? ( bool(Options&Symmetric) ? 6 : -4 ) : -2)"
  },
  {
    "label": "PardisoLDLT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PardisoLDLT(const MatrixType& matrix) : Base()"
  }
]