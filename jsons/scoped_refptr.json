[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "scoped_refptr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "scoped_refptr"
  },
  {
    "label": "RefCounted",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCounted"
  },
  {
    "label": "RefCountedThreadSafe",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCountedThreadSafe"
  },
  {
    "label": "RefCountedDeleteOnSequence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCountedDeleteOnSequence"
  },
  {
    "label": "SequencedTaskRunner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SequencedTaskRunner"
  },
  {
    "label": "WrappedPromise",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "WrappedPromise"
  },
  {
    "label": "BasePromise",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BasePromise"
  },
  {
    "label": "AdoptRefTag",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "AdoptRefTag"
  },
  {
    "label": "StartRefCountFromZeroTag",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "StartRefCountFromZeroTag"
  },
  {
    "label": "StartRefCountFromOneTag",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "StartRefCountFromOneTag"
  },
  {
    "label": "TRIVIAL_ABI",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRIVIAL_ABI"
  },
  {
    "label": "AdoptRef()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_MEMORY_SCOPED_REFPTR_H_ # define BASE_MEMORY_SCOPED_REFPTR_H_ # include<stddef . h> # include<iosfwd> # include<type_traits> # include<utility> # include \" base / check . h \" # include \" base / compiler_specific . h \" template<class T> class scoped_refptr ; namespace base { template<class,> class RefCounted ; template<class,> class RefCountedThreadSafe ; template<class> class RefCountedDeleteOnSequence ; class SequencedTaskRunner ; class WrappedPromise ; template<T> scoped_refptr<T>)",
    "insertText": "AdoptRef(T* t)"
  },
  {
    "label": "IsRefCountPreferenceOverridden()",
    "kind": "Method",
    "detail": "Function (namespace internal { class BasePromise ; } namespace subtle { enum AdoptRefTag { kAdoptRefTag } ; enum StartRefCountFromZeroTag { kStartRefCountFromZeroTag } ; enum StartRefCountFromOneTag { kStartRefCountFromOneTag } ; template<T,U,V> bool)",
    "insertText": "IsRefCountPreferenceOverridden(const T*, const RefCounted<U, V>*)"
  },
  {
    "label": "IsRefCountPreferenceOverridden()",
    "kind": "Method",
    "detail": "Function (} template<T,U,V> bool)",
    "insertText": "IsRefCountPreferenceOverridden(const T*, const RefCountedThreadSafe<U, V>*)"
  },
  {
    "label": "IsRefCountPreferenceOverridden()",
    "kind": "Method",
    "detail": "Function (} template<T,U> bool)",
    "insertText": "IsRefCountPreferenceOverridden(const T*, const RefCountedDeleteOnSequence<U>*)"
  },
  {
    "label": "IsRefCountPreferenceOverridden()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsRefCountPreferenceOverridden(...)"
  },
  {
    "label": "AssertRefCountBaseMatches()",
    "kind": "Method",
    "detail": "Function (} template<T,U,V> void)",
    "insertText": "AssertRefCountBaseMatches(const T*, const RefCountedThreadSafe<U, V>*)"
  },
  {
    "label": "AssertRefCountBaseMatches()",
    "kind": "Method",
    "detail": "Function (} template<T,U> void)",
    "insertText": "AssertRefCountBaseMatches(const T*, const RefCountedDeleteOnSequence<U>*)"
  },
  {
    "label": "AssertRefCountBaseMatches()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AssertRefCountBaseMatches(...)"
  },
  {
    "label": "AdoptRef()",
    "kind": "Method",
    "detail": "Function (} } template<T> scoped_refptr<T>)",
    "insertText": "AdoptRef(T* obj)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using Tag = std::decay_t<)",
    "insertText": "decltype(T::kRefCountPreference)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(obj)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(obj->HasOneRef())"
  },
  {
    "label": "Adopted()",
    "kind": "Method",
    "detail": "Function (obj ->)",
    "insertText": "Adopted()"
  },
  {
    "label": "AdoptRefIfNeeded()",
    "kind": "Method",
    "detail": "Function (} namespace subtle { template<T> scoped_refptr<T>)",
    "insertText": "AdoptRefIfNeeded(T* obj, StartRefCountFromZeroTag)"
  },
  {
    "label": "AdoptRefIfNeeded()",
    "kind": "Method",
    "detail": "Function (} template<T> scoped_refptr<T>)",
    "insertText": "AdoptRefIfNeeded(T* obj, StartRefCountFromOneTag)"
  },
  {
    "label": "MakeRefCounted()",
    "kind": "Method",
    "detail": "Function (} } template<T,. . . Args> scoped_refptr<T>)",
    "insertText": "MakeRefCounted(Args&&... args)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T* obj = new)",
    "insertText": "T(std::forward<Args>(args)...)"
  },
  {
    "label": "WrapRefCounted()",
    "kind": "Method",
    "detail": "Function (} template<T> scoped_refptr<T>)",
    "insertText": "WrapRefCounted(T* t)"
  },
  {
    "label": "scoped_refptr()",
    "kind": "Method",
    "detail": "Function (} } template<class T> class TRIVIAL_ABI scoped_refptr { public : typedef T element_type ;)",
    "insertText": "scoped_refptr()"
  },
  {
    "label": "scoped_refptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "scoped_refptr(std::nullptr_t)"
  },
  {
    "label": "scoped_refptr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "scoped_refptr(T* p) : ptr_(p)"
  },
  {
    "label": "scoped_refptr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "scoped_refptr(const scoped_refptr& r) : scoped_refptr(r.ptr_)"
  },
  {
    "label": "scoped_refptr()",
    "kind": "Method",
    "detail": "Function (} template<U,= std::enable_if<std::is_convertible<U*,T*>::value>::type>)",
    "insertText": "scoped_refptr(const scoped_refptr<U>& r) : scoped_refptr(r.ptr_)"
  },
  {
    "label": "scoped_refptr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "scoped_refptr(scoped_refptr&& r) noexcept : ptr_(r.ptr_)"
  },
  {
    "label": "scoped_refptr()",
    "kind": "Method",
    "detail": "Function (r . ptr_ = nullptr ; } template<U,= std::enable_if<std::is_convertible<U*,T*>::value>::type>)",
    "insertText": "scoped_refptr(scoped_refptr<U>&& r) noexcept : ptr_(r.ptr_)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "get()"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(ptr_)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} scoped_refptr&)",
    "insertText": "operator(scoped_refptr r)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(r)"
  },
  {
    "label": "scoped_refptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "scoped_refptr().swap(*this)"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] T*)",
    "insertText": "release()"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(scoped_refptr& r)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(ptr_, r.ptr_)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<U> bool)",
    "insertText": "operator(const scoped_refptr<U>& rhs)"
  },
  {
    "label": "AdoptRef()",
    "kind": "Method",
    "detail": "Function (} protected : T* ptr_ = nullptr ; private : template<U> scoped_refptr<U>)",
    "insertText": "AdoptRef(U*)"
  },
  {
    "label": "scoped_refptr()",
    "kind": "Method",
    "detail": "Function (class::base::SequencedTaskRunner ; class::base::internal::BasePromise ; class::base::WrappedPromise ;)",
    "insertText": "scoped_refptr(T* p, base::subtle::AdoptRefTag) : ptr_(p)"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (} template<U> class scoped_refptr ; void)",
    "insertText": "AddRef(T* ptr)"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Release(T* ptr)"
  },
  {
    "label": "AssertRefCountBaseMatches()",
    "kind": "Method",
    "detail": "Function (base::)",
    "insertText": "AssertRefCountBaseMatches(ptr, ptr)"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (ptr ->)",
    "insertText": "AddRef()"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (ptr ->)",
    "insertText": "Release()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,U> bool)",
    "insertText": "operator(const scoped_refptr<T>& lhs, const U* rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,U> bool)",
    "insertText": "operator(const T* lhs, const scoped_refptr<U>& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "operator(const scoped_refptr<T>& lhs, std::nullptr_t null)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "operator(std::nullptr_t null, const scoped_refptr<T>& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> std::ostream&)",
    "insertText": "operator(std::ostream& out, const scoped_refptr<T>& p)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "swap(scoped_refptr<T>& lhs, scoped_refptr<T>& rhs)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (lhs .)",
    "insertText": "swap(rhs)"
  }
]