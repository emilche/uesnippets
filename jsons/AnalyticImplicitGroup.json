[
  {
    "label": "FAnalyticImplicitGroup",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnalyticImplicitGroup"
  },
  {
    "label": "FBoneHierarchy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBoneHierarchy"
  },
  {
    "label": "TImplicitShape",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TImplicitShape"
  },
  {
    "label": "FPhysicsAssetSimulationUtil",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPhysicsAssetSimulationUtil"
  },
  {
    "label": "FAnalyticImplicitGroup()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Box . h \" # include \" Chaos / Capsule . h \" # include \" Chaos / Convex . h \" # include \" Chaos / ImplicitObject . h \" # include \" Chaos / ImplicitObjectTransformed . h \" # include \" Chaos / ImplicitObjectUnion . h \" # include \" Chaos / Levelset . h \" # include \" Chaos / MassProperties . h \" # include \" Chaos / Sphere . h \" # include \" Chaos / TaperedCylinder . h \" # include \" GeometryCollection / GeometryCollectionSimulationTypes . h \" class FAnalyticImplicitGroup { public :)",
    "insertText": "FAnalyticImplicitGroup() : BoneName(NAME_None) , BoneIndex(INDEX_NONE) , ParentBoneIndex(INDEX_NONE) , RigidBodyId(INDEX_NONE) , RigidBodyState(EObjectStateTypeEnum::Chaos_Object_Kinematic) , Parent(nullptr)"
  },
  {
    "label": "FAnalyticImplicitGroup()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAnalyticImplicitGroup(const FName &InBoneName, const int32 InBoneIndex) : BoneName(InBoneName) , BoneIndex(InBoneIndex) , ParentBoneIndex(INDEX_NONE) , RigidBodyId(INDEX_NONE) , RigidBodyState(EObjectStateTypeEnum::Chaos_Object_Kinematic) , Parent(nullptr)"
  },
  {
    "label": "FAnalyticImplicitGroup()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAnalyticImplicitGroup(const FAnalyticImplicitGroup &)"
  },
  {
    "label": "FAnalyticImplicitGroup()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAnalyticImplicitGroup(FAnalyticImplicitGroup &&Other) : BoneName(MoveTemp(Other.BoneName)) , BoneIndex(MoveTemp(Other.BoneIndex)) , ParentBoneIndex(MoveTemp(Other.ParentBoneIndex)) , RigidBodyId(MoveTemp(Other.RigidBodyId)) , RigidBodyState(MoveTemp(Other.RigidBodyState)) , Spheres(MoveTemp(Other.Spheres)) , Boxes(MoveTemp(Other.Boxes)) , Capsules(MoveTemp(Other.Capsules)) , TaperedCylinders(MoveTemp(Other.TaperedCylinders)) , ConvexHulls(MoveTemp(Other.ConvexHulls)) , LevelSets(MoveTemp(Other.LevelSets)) , Transforms(MoveTemp(Other.Transforms)) , Parent(MoveTemp(Other.Parent)) , Children(MoveTemp(Other.Children))"
  },
  {
    "label": "FAnalyticImplicitGroup()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FAnalyticImplicitGroup()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Init(const int32 NumStructures, const bool DoCollGeom=true)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Transforms .)",
    "insertText": "Reserve(NumStructures)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (CollisionPoints .)",
    "insertText": "SetNum(NumStructures)"
  },
  {
    "label": "NumStructures()",
    "kind": "Method",
    "detail": "Function (} } int32)",
    "insertText": "NumStructures()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "GetParentBoneIndex()",
    "kind": "Method",
    "detail": "Function (ParentBoneIndex = InParentBoneIndex ; } const int32)",
    "insertText": "GetParentBoneIndex()"
  },
  {
    "label": "GetRigidBodyId()",
    "kind": "Method",
    "detail": "Function (RigidBodyId = InRigidBodyId ; } int32)",
    "insertText": "GetRigidBodyId()"
  },
  {
    "label": "GetRigidBodyState()",
    "kind": "Method",
    "detail": "Function (RigidBodyState = State ; } EObjectStateTypeEnum)",
    "insertText": "GetRigidBodyState()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Spheres .)",
    "insertText": "Add(Sphere)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Add(const FTransform &InitialXf, Chaos::TBox<Chaos::FReal, 3> *Box)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Boxes .)",
    "insertText": "Add(Box)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Add(const FTransform &InitialXf, Chaos::FCapsule *Capsule)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Capsules .)",
    "insertText": "Add(Capsule)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Add(const FTransform &InitialXf, Chaos::FTaperedCylinder *TaperedCylinder)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TaperedCylinders .)",
    "insertText": "Add(TaperedCylinder)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Add(const FTransform &InitialXf, Chaos::FConvex *ConvexHull)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ConvexHulls .)",
    "insertText": "Add(ConvexHull)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Add(const FTransform &InitialXf, Chaos::FLevelSet *LevelSet)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (LevelSets .)",
    "insertText": "Add(LevelSet)"
  },
  {
    "label": "SetCollisionTopology()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCollisionTopology(const int32 Index, TArray<Chaos::FVec3>&& Points, TArray<Chaos::TVec3<int32>>&& Triangles)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (CollisionPoints [ Index ] =)",
    "insertText": "MoveTemp(Points)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (CollisionTriangles [ Index ] =)",
    "insertText": "MoveTemp(Triangles)"
  },
  {
    "label": "GetInitialStructureTransforms()",
    "kind": "Method",
    "detail": "Function (} const TArray<FTransform>&)",
    "insertText": "GetInitialStructureTransforms()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (Transforms .)",
    "insertText": "Init(FTransform::Identity, Transforms.Num())"
  },
  {
    "label": "BuildMassProperties()",
    "kind": "Method",
    "detail": "Function (} Chaos::FMassProperties)",
    "insertText": "BuildMassProperties(const Chaos::FReal Density, Chaos::FReal& TotalMass)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::FMassProperties> MPArray ; TArray<Chaos::FAABB3> BBoxes ; MPArray .)",
    "insertText": "SetNum(Num)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 TransformIndex = 0 ;)",
    "insertText": "for(Chaos::TSphere<Chaos::FReal, 3>* Sphere : Spheres)"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (const FTransform& Xf = Transforms [ TransformIndex ] ; BBoxes [ TransformIndex ] = Sphere ->)",
    "insertText": "BoundingBox().TransformedAABB(Xf)"
  },
  {
    "label": "GetVolume()",
    "kind": "Method",
    "detail": "Function (Chaos::FMassProperties& MP = MPArray [ TransformIndex + + ] ; MP . Volume = Sphere ->)",
    "insertText": "GetVolume()"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (MP . CenterOfMass = Xf .)",
    "insertText": "TransformPositionNoScale(Sphere->GetCenterOfMass())"
  },
  {
    "label": "TransformRotation()",
    "kind": "Method",
    "detail": "Function (MP . RotationOfMass = Xf .)",
    "insertText": "TransformRotation(Sphere->GetRotationOfMass())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Chaos::TBox<Chaos::FReal, 3>* Box : Boxes)"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (MP . CenterOfMass = Xf .)",
    "insertText": "TransformPositionNoScale(Box->GetCenterOfMass())"
  },
  {
    "label": "TransformRotation()",
    "kind": "Method",
    "detail": "Function (MP . RotationOfMass = Xf .)",
    "insertText": "TransformRotation(Box->GetRotationOfMass())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Chaos::FCapsule* Capsule : Capsules)"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (MP . CenterOfMass = Xf .)",
    "insertText": "TransformPositionNoScale(Capsule->GetCenterOfMass())"
  },
  {
    "label": "TransformRotation()",
    "kind": "Method",
    "detail": "Function (MP . RotationOfMass = Xf .)",
    "insertText": "TransformRotation(Capsule->GetRotationOfMass())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Chaos::FTaperedCylinder* TaperedCylinder : TaperedCylinders)"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (MP . CenterOfMass = Xf .)",
    "insertText": "TransformPositionNoScale(TaperedCylinder->GetCenterOfMass())"
  },
  {
    "label": "TransformRotation()",
    "kind": "Method",
    "detail": "Function (MP . RotationOfMass = Xf .)",
    "insertText": "TransformRotation(TaperedCylinder->GetRotationOfMass())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Chaos::FConvex* Convex : ConvexHulls)"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (Chaos::FMassProperties& MP = MPArray [ TransformIndex + + ] ; MP . Volume = Convex ->)",
    "insertText": "BoundingBox().GetVolume()"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (MP . CenterOfMass = Xf .)",
    "insertText": "TransformPositionNoScale(Convex->BoundingBox().Center())"
  },
  {
    "label": "TransformRotation()",
    "kind": "Method",
    "detail": "Function (MP . RotationOfMass = Xf .)",
    "insertText": "TransformRotation(Convex->BoundingBox().GetRotationOfMass())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Chaos::FLevelSet* LevelSet : LevelSets)"
  },
  {
    "label": "TransformPositionNoScale()",
    "kind": "Method",
    "detail": "Function (MP . CenterOfMass = Xf .)",
    "insertText": "TransformPositionNoScale(LevelSet->BoundingBox().Center())"
  },
  {
    "label": "TransformRotation()",
    "kind": "Method",
    "detail": "Function (MP . RotationOfMass = Xf .)",
    "insertText": "TransformRotation(LevelSet->BoundingBox().GetRotationOfMass())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 i=0; i < Num-1; i++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const Chaos::FAABB3& BoxI = BBoxes [ i ] ;)",
    "insertText": "for(int32 j = i+1; j < Num; j++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Chaos::FAABB3& BoxJ = BBoxes [ j ] ;)",
    "insertText": "if(BoxI.Intersects(BoxJ))"
  },
  {
    "label": "GetIntersection()",
    "kind": "Method",
    "detail": "Function (Chaos::FAABB3 BoxIJ = BoxI .)",
    "insertText": "GetIntersection(BoxJ)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (const Chaos::FReal PctOverlapI = VolI> UE_KINDA_SMALL_NUMBER ? VolIJ / VolI : 0 . f ; const Chaos::FReal PctOverlapJ = VolJ> UE_KINDA_SMALL_NUMBER ? VolIJ / VolJ : 0 . f ; MPArray [ i ] . Volume* = static_cast<)",
    "insertText": "FReal(1.0 - PctOverlapI / 2.0)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (MPArray [ j ] . Volume* = static_cast<)",
    "insertText": "FReal(1.0 - PctOverlapJ / 2.0)"
  },
  {
    "label": "GetInertiaTensor()",
    "kind": "Method",
    "detail": "Function (Chaos::FMassProperties& MP = MPArray [ TransformIndex + + ] ; Chaos::FReal Mass = Density* MP . Volume ; TotalMass + = Mass ; MP . InertiaTensor = Sphere ->)",
    "insertText": "GetInertiaTensor(Mass)"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (Chaos::FMassProperties& MP = MPArray [ TransformIndex + + ] ; Chaos::FReal Mass = Density* MP . Volume ; TotalMass + = Mass ; MP . InertiaTensor = Convex ->)",
    "insertText": "BoundingBox().GetInertiaTensor(Mass)"
  },
  {
    "label": "Combine()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "Combine(MPArray)"
  },
  {
    "label": "BuildSamplePoints()",
    "kind": "Method",
    "detail": "Function (} TArray<Chaos::FVec3>*)",
    "insertText": "BuildSamplePoints(const Chaos::FReal ParticlesPerUnitArea, const int32 MinParticles, const int32 MaxParticles)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (ContiguousCollisionPoints .)",
    "insertText": "Reset()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::FVec3>& Points = CollisionPoints [ TransformIndex ] ;)",
    "insertText": "if(!Points.Num()) Points = Sphere->ComputeSamplePoints(ParticlesPerUnitArea, MinParticles, MaxParticles)"
  },
  {
    "label": "CullDeepPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CullDeepPoints(Points, TransformIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::FVec3>& Points = CollisionPoints [ TransformIndex ] ;)",
    "insertText": "if(!Points.Num()) Points = Box->ComputeSamplePoints()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::FVec3>& Points = CollisionPoints [ TransformIndex ] ;)",
    "insertText": "if(!Points.Num()) Points = Capsule->ComputeSamplePoints(ParticlesPerUnitArea, MinParticles, MaxParticles)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::FVec3>& Points = CollisionPoints [ TransformIndex ] ;)",
    "insertText": "if(!Points.Num()) Points = TaperedCylinder->ComputeSamplePoints(ParticlesPerUnitArea, false, MinParticles, MaxParticles)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::FVec3>& Points = CollisionPoints [ TransformIndex ] ;)",
    "insertText": "if(!Points.Num())"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (const Chaos::FAABB3& BBox = Convex ->)",
    "insertText": "BoundingBox()"
  },
  {
    "label": "Sphere()",
    "kind": "Method",
    "detail": "Function (Chaos::TSphere<Chaos::FReal,3>)",
    "insertText": "Sphere(BBox.Center(), BBox.Extents().Size() / 2)"
  },
  {
    "label": "ComputeSamplePoints()",
    "kind": "Method",
    "detail": "Function (Points = Sphere .)",
    "insertText": "ComputeSamplePoints(ParticlesPerUnitArea, MinParticles, MaxParticles)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Chaos::FVec3 Normal ;)",
    "insertText": "for(Chaos::FVec3 &Pt : Points)"
  },
  {
    "label": "PhiWithNormal()",
    "kind": "Method",
    "detail": "Function (const Chaos::FReal Phi = Convex ->)",
    "insertText": "PhiWithNormal(Pt, Normal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TransformIndex + + ; })",
    "insertText": "if(Num > 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 NumPoints = 0 ;)",
    "insertText": "for(const auto& PtArray : CollisionPoints) NumPoints += PtArray.Num()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (ContiguousCollisionPoints .)",
    "insertText": "Reserve(NumPoints)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(TransformIndex = 0; TransformIndex < Num; TransformIndex++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::FVec3>& PtArray = CollisionPoints [ TransformIndex ] ; const FTransform& Xf = Transforms [ TransformIndex ] ;)",
    "insertText": "if(!Xf.Equals(FTransform::Identity))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Num == 1)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (ContiguousCollisionPoints .)",
    "insertText": "Empty()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 NumTris = 0 ;)",
    "insertText": "for(const TArray<Chaos::TVec3<int32>>& Tris : CollisionTriangles)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (NumTris + = Tris .)",
    "insertText": "Num()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} TArray<Chaos::TVec3<int32>> AllTriangles ; AllTriangles .)",
    "insertText": "Reserve(NumTris)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 Offset = 0 ;)",
    "insertText": "for(int32 Index=0; Index < CollisionTriangles.Num(); Index++)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (AllTriangles .)",
    "insertText": "Add(Tri + Offset)"
  },
  {
    "label": "BuildSimImplicitObject()",
    "kind": "Method",
    "detail": "Function (} return AllTriangles ; } Chaos::FImplicitObject*)",
    "insertText": "BuildSimImplicitObject()"
  },
  {
    "label": "ObjPtr()",
    "kind": "Method",
    "detail": "Function (} else { Chaos::FImplicitObjectPtr)",
    "insertText": "ObjPtr(TransferImplicitObj(0))"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} } else { TArray<Chaos::FImplicitObjectPtr> ImplicitObjects ; ImplicitObjects .)",
    "insertText": "Reserve(Num)"
  },
  {
    "label": "ObjPtr()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "ObjPtr(TransferImplicitObj(i))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FTransform& Xf = Transforms [ i ] ;)",
    "insertText": "if(Xf.Equals(FTransform::Identity))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ImplicitObjects .)",
    "insertText": "Add(MoveTemp(ObjPtr))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { ImplicitObjects .)",
    "insertText": "Add(Chaos::FImplicitObjectPtr( new Chaos::TImplicitObjectTransformed<Chaos::FReal, 3, true>( MoveTemp(ObjPtr), Chaos::FRigidTransform3(Xf))))"
  },
  {
    "label": "FImplicitObjectUnion()",
    "kind": "Method",
    "detail": "Function (} } return new)",
    "insertText": "FImplicitObjectUnion(MoveTemp(ImplicitObjects))"
  },
  {
    "label": "SetParent()",
    "kind": "Method",
    "detail": "Function (} } protected : class FBoneHierarchy ; void)",
    "insertText": "SetParent(FAnalyticImplicitGroup *InParent)"
  },
  {
    "label": "GetParent()",
    "kind": "Method",
    "detail": "Function (Parent = InParent ; } const FAnalyticImplicitGroup*)",
    "insertText": "GetParent()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "Add(Child)"
  },
  {
    "label": "GetChildren()",
    "kind": "Method",
    "detail": "Function (} const TArray<FAnalyticImplicitGroup*>&)",
    "insertText": "GetChildren()"
  },
  {
    "label": "CullDeepPoints()",
    "kind": "Method",
    "detail": "Function (} template<class TImplicitShape> void)",
    "insertText": "CullDeepPoints(TArray<Chaos::FVec3>& Points, const TImplicitShape& Shape, const FTransform& Xf)"
  },
  {
    "label": "Extents()",
    "kind": "Method",
    "detail": "Function (const Chaos::FReal Tolerance = - BBox .)",
    "insertText": "Extents().Max() / (Chaos::FReal)"
  },
  {
    "label": "SignedDistance()",
    "kind": "Method",
    "detail": "Function (const Chaos::FVec3& LocalPoint = Points [ i ] ; const Chaos::FReal Phi = Shape .)",
    "insertText": "SignedDistance(LocalPoint)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (Points .)",
    "insertText": "RemoveAt(i)"
  },
  {
    "label": "Inverse()",
    "kind": "Method",
    "detail": "Function (} } } else { const FTransform InvXf = Xf .)",
    "insertText": "Inverse()"
  },
  {
    "label": "TransformPosition()",
    "kind": "Method",
    "detail": "Function (const Chaos::FVec3 LocalPoint = InvXf .)",
    "insertText": "TransformPosition(Points[i])"
  },
  {
    "label": "CullDeepPoints()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "CullDeepPoints(TArray<Chaos::FVec3>& Points, const int32 SkipIndex)"
  },
  {
    "label": "CullDeepPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CullDeepPoints(Points, *Sphere, Transforms[TransformIndex])"
  },
  {
    "label": "CullDeepPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CullDeepPoints(Points, *Box, Transforms[TransformIndex])"
  },
  {
    "label": "CullDeepPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CullDeepPoints(Points, *Capsule, Transforms[TransformIndex])"
  },
  {
    "label": "CullDeepPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CullDeepPoints(Points, *TaperedCylinder, Transforms[TransformIndex])"
  },
  {
    "label": "CullDeepPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CullDeepPoints(Points, *Convex, Transforms[TransformIndex])"
  },
  {
    "label": "CullDeepPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CullDeepPoints(Points, *LevelSet, Transforms[TransformIndex])"
  },
  {
    "label": "TransferImplicitObj()",
    "kind": "Method",
    "detail": "Function (} TransformIndex + + ; } } Chaos::FImplicitObject*)",
    "insertText": "TransferImplicitObj(int32 Idx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObject* Obj = nullptr ;)",
    "insertText": "if(Idx < Spheres.Num())"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (Obj = LevelSets [ Idx ] ; LevelSets [ Idx ] = nullptr ; return Obj ; })",
    "insertText": "check(false)"
  }
]