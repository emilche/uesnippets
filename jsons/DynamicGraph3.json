[
  {
    "label": "FDynamicGraph3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDynamicGraph3"
  },
  {
    "label": "InvalidVertex()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" BoxTypes . h \" # include \" DynamicGraph . h \" # include \" SegmentTypes . h \" # include \" Util / DynamicVector . h \" # include \" Util / IndexUtil . h \" # include \" Util / IteratorUtil . h \" # include \" Util / RefCountVector . h \" # include \" Util / SmallListSet . h \" # include \" VectorTypes . h \" # include \" VectorUtil . h \" namespace UE { namespace Geometry { using namespace UE::Math ; template<T> class FDynamicGraph3 : public FDynamicGraph { TDynamicVectorN<T,3> Vertices ; public : TVector<T>)",
    "insertText": "InvalidVertex()"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (} TVector<T>)",
    "insertText": "GetVertex(int VID)"
  },
  {
    "label": "SetVertex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetVertex(int VID, TVector<T> VNewPos)"
  },
  {
    "label": "SetVector3()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "SetVector3(VID, VNewPos)"
  },
  {
    "label": "updateTimeStamp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateTimeStamp(true)"
  },
  {
    "label": "GetEdgeV()",
    "kind": "Method",
    "detail": "Function (} } using FDynamicGraph::GetEdgeV ; bool)",
    "insertText": "GetEdgeV(int EID, TVector<T>& A, TVector<T>& B)"
  },
  {
    "label": "AsVector3()",
    "kind": "Method",
    "detail": "Function (A = Vertices .)",
    "insertText": "AsVector3(edges[EID].A)"
  },
  {
    "label": "AsVector3()",
    "kind": "Method",
    "detail": "Function (B = Vertices .)",
    "insertText": "AsVector3(edges[EID].B)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const FEdge& e = edges [ EID ] ; return TSegment3<)",
    "insertText": "T(Vertices.AsVector3(e.A), Vertices.AsVector3(e.B))"
  },
  {
    "label": "GetEdgeCenter()",
    "kind": "Method",
    "detail": "Function (} TVector<T>)",
    "insertText": "GetEdgeCenter(int EID)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (const FEdge& e = edges [ EID ] ;)",
    "insertText": "return(Vertices.AsVector3(e.A) + Vertices.AsVector3(e.B))"
  },
  {
    "label": "AppendVertex()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "AppendVertex(TVector<T> V)"
  },
  {
    "label": "append_vertex_internal()",
    "kind": "Method",
    "detail": "Function (int vid =)",
    "insertText": "append_vertex_internal()"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "InsertAt({{V.X, V.Y, V.Z}}, vid)"
  },
  {
    "label": "VerticesItr()",
    "kind": "Method",
    "detail": "Function (} value_iteration<TVector<T>>)",
    "insertText": "VerticesItr()"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (} FAxisAlignedBox2d)",
    "insertText": "GetBounds()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TAxisAlignedBox2<T> AABB ;)",
    "insertText": "for(const TVector<T>& V : Vertices())"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (AABB .)",
    "insertText": "Contain(V)"
  },
  {
    "label": "append_new_split_vertex()",
    "kind": "Method",
    "detail": "Function (} return AABB ; } protected : int)",
    "insertText": "append_new_split_vertex(int A, int B)"
  },
  {
    "label": "vNew()",
    "kind": "Method",
    "detail": "Function (TVector<T>)",
    "insertText": "vNew(GetVertex(A) + GetVertex(B))"
  },
  {
    "label": "AppendVertex()",
    "kind": "Method",
    "detail": "Function (int f =)",
    "insertText": "AppendVertex(vNew)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (TVector<T> V =)",
    "insertText": "GetVertex(VID)"
  }
]