[
  {
    "label": "compute_tensor_flags",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "compute_tensor_flags"
  },
  {
    "label": "traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "traits"
  },
  {
    "label": "MakePointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MakePointer"
  },
  {
    "label": "MakePointer_",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MakePointer_"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "eval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "eval"
  },
  {
    "label": "nested",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "nested"
  },
  {
    "label": "is_aligned()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_CXX11_TENSOR_TENSOR_TRAITS_H # define EIGEN_CXX11_TENSOR_TENSOR_TRAITS_H namespace Eigen { namespace internal { template<Scalar,int Options> class compute_tensor_flags { enum { is_dynamic_size_storage = 1,)",
    "insertText": "is_aligned(((Options&DontAlign)==0) && ( #if EIGEN_MAX_STATIC_ALIGN_BYTES>0 (!is_dynamic_size_storage) #else 0 #endif | #if EIGEN_MAX_ALIGN_BYTES>0 is_dynamic_size_storage #else 0 #endif ))"
  },
  {
    "label": "ret()",
    "kind": "Method",
    "detail": "Function (public : enum { ret = packet_access_bit } ; } ; template<Scalar_,int NumIndices_,int Options_,IndexType_> struct traits<Tensor<Scalar_,NumIndices_,Options_,IndexType_>> { typedef Scalar_ Scalar ; typedef Dense StorageKind ; typedef IndexType_ Index ; const int NumDimensions = NumIndices_ ; const int Layout = Options_& RowMajor ? RowMajor : ColMajor ; enum { Options = Options_,Flags = compute_tensor_flags<Scalar_,Options_)",
    "insertText": "ret(is_const<Scalar_>::value ? 0 : LvalueBit)"
  },
  {
    "label": "ret()",
    "kind": "Method",
    "detail": "Function (template<T> struct MakePointer { typedef T* Type ; } ; typedef MakePointer<Scalar>::Type PointerType ; } ; template<Scalar_,Dimensions,int Options_,IndexType_> struct traits<TensorFixedSize<Scalar_,Dimensions,Options_,IndexType_>> { typedef Scalar_ Scalar ; typedef Dense StorageKind ; typedef IndexType_ Index ; const int NumDimensions = array_size<Dimensions>::value ; const int Layout = Options_& RowMajor ? RowMajor : ColMajor ; enum { Options = Options_,Flags = compute_tensor_flags<Scalar_,Options_)",
    "insertText": "ret(is_const<Scalar_>::value ? 0: LvalueBit)"
  }
]