[
  {
    "label": "APlayerState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "APlayerState"
  },
  {
    "label": "ULocalMessage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ULocalMessage"
  },
  {
    "label": "UNetDriver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UNetDriver"
  },
  {
    "label": "AGameMode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AGameMode"
  },
  {
    "label": "UCLASS()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / ObjectMacros . h \" # include \" Templates / SubclassOf . h \" # include \" GameFramework / GameModeBase . h \" # include \" GameMode . generated . h \" class APlayerState ; class ULocalMessage ; class UNetDriver ; namespace MatchState { const FName EnteringMap ; const FName WaitingToStart ; const FName InProgress ; const FName WaitingPostMatch ; const FName LeavingMap ; const FName Aborted ; })",
    "insertText": "UCLASS(MinimalAPI)"
  },
  {
    "label": "GENERATED_UCLASS_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_UCLASS_BODY() UFUNCTION(BlueprintCallable, Category=\"Game\") FName GetMatchState()"
  },
  {
    "label": "SetMatchState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMatchState(FName NewState)"
  },
  {
    "label": "OnMatchStateSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnMatchStateSet()"
  },
  {
    "label": "HandleMatchIsWaitingToStart()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleMatchIsWaitingToStart()"
  },
  {
    "label": "HandleMatchHasStarted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleMatchHasStarted()"
  },
  {
    "label": "HandleMatchHasEnded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleMatchHasEnded()"
  },
  {
    "label": "HandleLeavingMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleLeavingMap()"
  },
  {
    "label": "HandleMatchAborted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleMatchAborted()"
  },
  {
    "label": "GetNetworkNumber()",
    "kind": "Method",
    "detail": "Function (public : FString)",
    "insertText": "GetNetworkNumber()"
  },
  {
    "label": "PlayerSwitchedToSpectatorOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PlayerSwitchedToSpectatorOnly(APlayerController* PC)"
  },
  {
    "label": "RemovePlayerControllerFromPlayerCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemovePlayerControllerFromPlayerCount(APlayerController* PC)"
  },
  {
    "label": "GetTravelType()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetTravelType()"
  },
  {
    "label": "Broadcast()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Broadcast(AActor* Sender, const FString& Msg, FName Type = NAME_None)"
  },
  {
    "label": "BroadcastLocalized()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BroadcastLocalized(AActor* Sender, TSubclassOf<ULocalMessage> Message, int32 Switch = 0, APlayerState* RelatedPlayerState_1 = NULL, APlayerState* RelatedPlayerState_2 = NULL, UObject* OptionalObject = NULL)"
  },
  {
    "label": "AddInactivePlayer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddInactivePlayer(APlayerState* PlayerState, APlayerController* PC)"
  },
  {
    "label": "FindInactivePlayer()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FindInactivePlayer(APlayerController* PC)"
  },
  {
    "label": "OverridePlayerState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OverridePlayerState(APlayerController* PC, APlayerState* OldPlayerState)"
  },
  {
    "label": "SetSeamlessTravelViewTarget()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSeamlessTravelViewTarget(APlayerController* PC)"
  },
  {
    "label": "PreCommitMapChange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PreCommitMapChange(const FString& PreviousMapName, const FString& NextMapName)"
  },
  {
    "label": "PostCommitMapChange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PostCommitMapChange()"
  },
  {
    "label": "NotifyPendingConnectionLost()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NotifyPendingConnectionLost(const FUniqueNetIdRepl& ConnectionUniqueId)"
  },
  {
    "label": "HandleDisconnect()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleDisconnect(UWorld* InWorld, UNetDriver* NetDriver)"
  },
  {
    "label": "Tick()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Tick(float DeltaSeconds)"
  },
  {
    "label": "InitGame()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage)"
  },
  {
    "label": "StartPlay()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartPlay()"
  },
  {
    "label": "HasMatchStarted()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasMatchStarted()"
  },
  {
    "label": "HasMatchEnded()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasMatchEnded()"
  },
  {
    "label": "PostLogin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PostLogin(APlayerController* NewPlayer)"
  },
  {
    "label": "Logout()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Logout(AController* Exiting)"
  },
  {
    "label": "GetNumPlayers()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumPlayers()"
  },
  {
    "label": "GetNumSpectators()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumSpectators()"
  },
  {
    "label": "IsHandlingReplays()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsHandlingReplays()"
  },
  {
    "label": "HandleStartingNewPlayer_Implementation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleStartingNewPlayer_Implementation(APlayerController* NewPlayer)"
  },
  {
    "label": "PlayerCanRestart_Implementation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PlayerCanRestart_Implementation(APlayerController* Player)"
  },
  {
    "label": "PostSeamlessTravel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PostSeamlessTravel()"
  },
  {
    "label": "HandleSeamlessTravelPlayer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleSeamlessTravelPlayer(AController*& C)"
  },
  {
    "label": "InitSeamlessTravelPlayer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitSeamlessTravelPlayer(AController* NewController)"
  },
  {
    "label": "CanServerTravel()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanServerTravel(const FString& URL, bool bAbsolute)"
  },
  {
    "label": "StartToLeaveMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartToLeaveMap()"
  },
  {
    "label": "SpawnPlayerFromSimulate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SpawnPlayerFromSimulate(const FVector& NewLocation, const FRotator& NewRotation)"
  }
]