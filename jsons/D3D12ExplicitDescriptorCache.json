[
  {
    "label": "FD3D12DynamicRHI",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FD3D12DynamicRHI"
  },
  {
    "label": "FD3D12DefaultViews",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FD3D12DefaultViews"
  },
  {
    "label": "FD3D12CommandContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FD3D12CommandContext"
  },
  {
    "label": "FD3D12DescriptorCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FD3D12DescriptorCache"
  },
  {
    "label": "FD3D12VertexBufferCache",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FD3D12VertexBufferCache"
  },
  {
    "label": "FD3D12IndexBufferCache",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FD3D12IndexBufferCache"
  },
  {
    "label": "FD3D12ConstantBufferCache",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FD3D12ConstantBufferCache"
  },
  {
    "label": "FD3D12ShaderResourceViewCache",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FD3D12ShaderResourceViewCache"
  },
  {
    "label": "FD3D12UnorderedAccessViewCache",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FD3D12UnorderedAccessViewCache"
  },
  {
    "label": "FD3D12SamplerStateCache",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FD3D12SamplerStateCache"
  },
  {
    "label": "FD3D12ExplicitDescriptorHeapCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FD3D12ExplicitDescriptorHeapCache"
  },
  {
    "label": "FEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEntry"
  },
  {
    "label": "FD3D12ExplicitDescriptorHeap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FD3D12ExplicitDescriptorHeap"
  },
  {
    "label": "FD3D12ExplicitDescriptorCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FD3D12ExplicitDescriptorCache"
  },
  {
    "label": "TIdentityHash",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIdentityHash"
  },
  {
    "label": "alignas",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "alignas"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" D3D12RHICommon . h \" # include \" Experimental / Containers / SherwoodHashTable . h \" class FD3D12DynamicRHI ; struct FD3D12DefaultViews ; class FD3D12CommandContext ; class FD3D12DescriptorCache ; struct FD3D12VertexBufferCache ; struct FD3D12IndexBufferCache ; struct FD3D12ConstantBufferCache ; struct FD3D12ShaderResourceViewCache ; struct FD3D12UnorderedAccessViewCache ; struct FD3D12SamplerStateCache ; class FD3D12ExplicitDescriptorHeapCache : FD3D12DeviceChild { public :)",
    "insertText": "UE_NONCOPYABLE(FD3D12ExplicitDescriptorHeapCache)"
  },
  {
    "label": "FD3D12ExplicitDescriptorHeapCache()",
    "kind": "Method",
    "detail": "Function (ID3D12DescriptorHeap* Heap = nullptr ; uint32 NumDescriptors = 0 ; D3D12_DESCRIPTOR_HEAP_TYPE Type = D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES ; uint64 LastUsedFrame = 0 ; double LastUsedTime = 0 . 0 ; } ;)",
    "insertText": "FD3D12ExplicitDescriptorHeapCache(FD3D12Device* Device) : FD3D12DeviceChild(Device)"
  },
  {
    "label": "FD3D12ExplicitDescriptorHeapCache()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FD3D12ExplicitDescriptorHeapCache()"
  },
  {
    "label": "AllocateHeap()",
    "kind": "Method",
    "detail": "Function (FEntry)",
    "insertText": "AllocateHeap(D3D12_DESCRIPTOR_HEAP_TYPE Type, uint32 NumDescriptors)"
  },
  {
    "label": "DeferredReleaseHeap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeferredReleaseHeap(FEntry&& Entry)"
  },
  {
    "label": "FlushFreeList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushFreeList()"
  },
  {
    "label": "ReleaseHeap()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "ReleaseHeap(FEntry&& Entry)"
  },
  {
    "label": "ReleaseStaleEntries()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseStaleEntries(uint32 MaxAgeInFrames, float MaxAgeInSeconds)"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (FCriticalSection CriticalSection ; TArray<FEntry> FreeList ; uint32 NumAllocatedEntries = 0 ; } ; struct FD3D12ExplicitDescriptorHeap : public FD3D12DeviceChild {)",
    "insertText": "UE_NONCOPYABLE(FD3D12ExplicitDescriptorHeap) FD3D12ExplicitDescriptorHeap(FD3D12Device* Device) : FD3D12DeviceChild(Device)"
  },
  {
    "label": "FD3D12ExplicitDescriptorHeap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FD3D12ExplicitDescriptorHeap()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(uint32 InMaxNumDescriptors, D3D12_DESCRIPTOR_HEAP_TYPE InType)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Allocate(uint32 InNumDescriptors)"
  },
  {
    "label": "CopyDescriptors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyDescriptors(int32 BaseIndex, const D3D12_CPU_DESCRIPTOR_HANDLE* InDescriptors, uint32 InNumDescriptors)"
  },
  {
    "label": "CompareDescriptors()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CompareDescriptors(int32 BaseIndex, const D3D12_CPU_DESCRIPTOR_HANDLE* InDescriptors, uint32 InNumDescriptors)"
  },
  {
    "label": "GetDescriptorCPU()",
    "kind": "Method",
    "detail": "Function (D3D12_CPU_DESCRIPTOR_HANDLE)",
    "insertText": "GetDescriptorCPU(uint32 Index)"
  },
  {
    "label": "GetDescriptorGPU()",
    "kind": "Method",
    "detail": "Function (D3D12_GPU_DESCRIPTOR_HANDLE)",
    "insertText": "GetDescriptorGPU(uint32 Index)"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (D3D12_DESCRIPTOR_HEAP_TYPE Type = D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES ; ID3D12DescriptorHeap* D3D12Heap = nullptr ; uint32 MaxNumDescriptors = 0 ; int32 NumAllocatedDescriptors = 0 ; int32 NumWrittenSamplerDescriptors = 0 ; uint32 DescriptorSize = 0 ; D3D12_CPU_DESCRIPTOR_HANDLE CPUBase = { } ; D3D12_GPU_DESCRIPTOR_HANDLE GPUBase = { } ; FD3D12ExplicitDescriptorHeapCache::FEntry HeapCacheEntry ; TArray<D3D12_CPU_DESCRIPTOR_HANDLE> Descriptors ; bool bExhaustiveSamplerDeduplication = false ; } ; class FD3D12ExplicitDescriptorCache : public FD3D12DeviceChild { public :)",
    "insertText": "UE_NONCOPYABLE(FD3D12ExplicitDescriptorCache) FD3D12ExplicitDescriptorCache(FD3D12Device* Device, uint32 MaxWorkerCount) : FD3D12DeviceChild(Device) , ViewHeap(Device) , SamplerHeap(Device)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (WorkerData .)",
    "insertText": "SetNum(MaxWorkerCount)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Init(uint32 NumConstantDescriptors, uint32 NumViewDescriptors, uint32 NumSamplerDescriptors, ERHIBindlessConfiguration BindlessConfig)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Allocate(const D3D12_CPU_DESCRIPTOR_HANDLE* Descriptors, uint32 NumDescriptors, D3D12_DESCRIPTOR_HEAP_TYPE Type, uint32 WorkerIndex)"
  },
  {
    "label": "AllocateDeduplicated()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "AllocateDeduplicated(const uint32* DescriptorVersions, const D3D12_CPU_DESCRIPTOR_HANDLE* Descriptors, uint32 NumDescriptors, D3D12_DESCRIPTOR_HEAP_TYPE Type, uint32 WorkerIndex)"
  },
  {
    "label": "Matches()",
    "kind": "Method",
    "detail": "Function (FD3D12ExplicitDescriptorHeap ViewHeap ; FD3D12ExplicitDescriptorHeap SamplerHeap ; # if PLATFORM_SUPPORTS_BINDLESS_RENDERING ERHIBindlessConfiguration BindlessConfiguration { } ; bool bBindlessViews = false ; bool bBindlessSamplers = false ; # endif template<KeyType> struct TIdentityHash { bool)",
    "insertText": "Matches(KeyType A, KeyType B)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (} } ; using TDescriptorHashMap = Experimental::TSherwoodMap<uint64,int32,TIdentityHash<uint64>> ; struct)",
    "insertText": "alignas(PLATFORM_CACHE_LINE_SIZE)"
  }
]