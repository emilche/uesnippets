[
  {
    "label": "PolynomialSolverBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PolynomialSolverBase"
  },
  {
    "label": "PolynomialSolver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PolynomialSolver"
  },
  {
    "label": "EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_POLYNOMIAL_SOLVER_H # define EIGEN_POLYNOMIAL_SOLVER_H namespace Eigen { template<_Scalar,int _Deg> class PolynomialSolverBase { public :)",
    "insertText": "EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE(_Scalar,_Deg==Dynamic ? Dynamic : _Deg)"
  },
  {
    "label": "setPolynomial()",
    "kind": "Method",
    "detail": "Function (typedef NumTraits<Scalar>::Real RealScalar ; typedef std::complex<RealScalar> RootType ; typedef Matrix<RootType,_Deg,1> RootsType ; typedef DenseIndex Index ; protected : template<OtherPolynomial> void)",
    "insertText": "setPolynomial(const OtherPolynomial& poly)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_roots .)",
    "insertText": "resize(poly.size()-1)"
  },
  {
    "label": "PolynomialSolverBase()",
    "kind": "Method",
    "detail": "Function (} public : template<OtherPolynomial>)",
    "insertText": "PolynomialSolverBase(const OtherPolynomial& poly)"
  },
  {
    "label": "setPolynomial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setPolynomial(poly())"
  },
  {
    "label": "PolynomialSolverBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PolynomialSolverBase()"
  },
  {
    "label": "roots()",
    "kind": "Method",
    "detail": "Function (} public : const RootsType&)",
    "insertText": "roots()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (using std::abs ; bi_seq .)",
    "insertText": "clear()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (bi_seq .)",
    "insertText": "push_back(m_roots[i].real())"
  },
  {
    "label": "selectComplexRoot_withRespectToNorm()",
    "kind": "Method",
    "detail": "Function (} } } protected : template<squaredNormBinaryPredicate> const RootType&)",
    "insertText": "selectComplexRoot_withRespectToNorm(squaredNormBinaryPredicate& pred)"
  },
  {
    "label": "abs2()",
    "kind": "Method",
    "detail": "Function (Index res = 0 ; RealScalar norm2 =)",
    "insertText": "abs2(m_roots[0])"
  },
  {
    "label": "abs2()",
    "kind": "Method",
    "detail": "Function (const RealScalar currNorm2 =)",
    "insertText": "abs2(m_roots[i])"
  },
  {
    "label": "greatestRoot()",
    "kind": "Method",
    "detail": "Function (res = i ; norm2 = currNorm2 ; } } return m_roots [ res ] ; } public : const RootType&)",
    "insertText": "greatestRoot()"
  },
  {
    "label": "selectComplexRoot_withRespectToNorm()",
    "kind": "Method",
    "detail": "Function (std::greater<RealScalar> greater ; return)",
    "insertText": "selectComplexRoot_withRespectToNorm(greater)"
  },
  {
    "label": "smallestRoot()",
    "kind": "Method",
    "detail": "Function (} const RootType&)",
    "insertText": "smallestRoot()"
  },
  {
    "label": "selectComplexRoot_withRespectToNorm()",
    "kind": "Method",
    "detail": "Function (std::less<RealScalar> less ; return)",
    "insertText": "selectComplexRoot_withRespectToNorm(less)"
  },
  {
    "label": "selectRealRoot_withRespectToAbsRealPart()",
    "kind": "Method",
    "detail": "Function (} protected : template<squaredRealPartBinaryPredicate> const RealScalar&)",
    "insertText": "selectRealRoot_withRespectToAbsRealPart(squaredRealPartBinaryPredicate& pred, bool& hasArealRoot, const RealScalar& absImaginaryThreshold = NumTraits<Scalar>::dummy_precision())"
  },
  {
    "label": "abs2()",
    "kind": "Method",
    "detail": "Function (using std::abs ; hasArealRoot = false ; Index res = 0 ; RealScalar)",
    "insertText": "abs2(0)"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (hasArealRoot = true ; res = i ; abs2 = m_roots [ i ] .)",
    "insertText": "real() * m_roots[i].real()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (abs2 = currAbs2 ; res = i ; } } } else)",
    "insertText": "if(!hasArealRoot)"
  },
  {
    "label": "real_ref()",
    "kind": "Method",
    "detail": "Function (res = i ; } } } return)",
    "insertText": "real_ref(m_roots[res])"
  },
  {
    "label": "selectRealRoot_withRespectToRealPart()",
    "kind": "Method",
    "detail": "Function (} template<RealPartBinaryPredicate> const RealScalar&)",
    "insertText": "selectRealRoot_withRespectToRealPart(RealPartBinaryPredicate& pred, bool& hasArealRoot, const RealScalar& absImaginaryThreshold = NumTraits<Scalar>::dummy_precision())"
  },
  {
    "label": "val()",
    "kind": "Method",
    "detail": "Function (using std::abs ; hasArealRoot = false ; Index res = 0 ; RealScalar)",
    "insertText": "val(0)"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (hasArealRoot = true ; res = i ; val = m_roots [ i ] .)",
    "insertText": "real()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (val = curr ; res = i ; } } } else {)",
    "insertText": "if(abs( m_roots[i].imag() ) < abs( m_roots[res].imag() ))"
  },
  {
    "label": "absGreatestRealRoot()",
    "kind": "Method",
    "detail": "Function (} public : const RealScalar&)",
    "insertText": "absGreatestRealRoot(bool& hasArealRoot, const RealScalar& absImaginaryThreshold = NumTraits<Scalar>::dummy_precision())"
  },
  {
    "label": "selectRealRoot_withRespectToAbsRealPart()",
    "kind": "Method",
    "detail": "Function (std::greater<RealScalar> greater ; return)",
    "insertText": "selectRealRoot_withRespectToAbsRealPart(greater, hasArealRoot, absImaginaryThreshold)"
  },
  {
    "label": "absSmallestRealRoot()",
    "kind": "Method",
    "detail": "Function (} const RealScalar&)",
    "insertText": "absSmallestRealRoot(bool& hasArealRoot, const RealScalar& absImaginaryThreshold = NumTraits<Scalar>::dummy_precision())"
  },
  {
    "label": "selectRealRoot_withRespectToAbsRealPart()",
    "kind": "Method",
    "detail": "Function (std::less<RealScalar> less ; return)",
    "insertText": "selectRealRoot_withRespectToAbsRealPart(less, hasArealRoot, absImaginaryThreshold)"
  },
  {
    "label": "greatestRealRoot()",
    "kind": "Method",
    "detail": "Function (} const RealScalar&)",
    "insertText": "greatestRealRoot(bool& hasArealRoot, const RealScalar& absImaginaryThreshold = NumTraits<Scalar>::dummy_precision())"
  },
  {
    "label": "selectRealRoot_withRespectToRealPart()",
    "kind": "Method",
    "detail": "Function (std::greater<RealScalar> greater ; return)",
    "insertText": "selectRealRoot_withRespectToRealPart(greater, hasArealRoot, absImaginaryThreshold)"
  },
  {
    "label": "smallestRealRoot()",
    "kind": "Method",
    "detail": "Function (} const RealScalar&)",
    "insertText": "smallestRealRoot(bool& hasArealRoot, const RealScalar& absImaginaryThreshold = NumTraits<Scalar>::dummy_precision())"
  },
  {
    "label": "selectRealRoot_withRespectToRealPart()",
    "kind": "Method",
    "detail": "Function (std::less<RealScalar> less ; return)",
    "insertText": "selectRealRoot_withRespectToRealPart(less, hasArealRoot, absImaginaryThreshold)"
  },
  {
    "label": "EIGEN_POLYNOMIAL_SOLVER_BASE_INHERITED_TYPES()",
    "kind": "Method",
    "detail": "Function (} protected : RootsType m_roots ; } ; # define)",
    "insertText": "EIGEN_POLYNOMIAL_SOLVER_BASE_INHERITED_TYPES(BASE)"
  },
  {
    "label": "EIGEN_POLYNOMIAL_SOLVER_BASE_INHERITED_TYPES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_POLYNOMIAL_SOLVER_BASE_INHERITED_TYPES(PS_Base)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (typedef internal::conditional<NumTraits<Scalar>::IsComplex,ComplexEigenSolver<CompanionMatrixType>,EigenSolver<CompanionMatrixType>>::type EigenSolverType ; typedef internal::conditional<NumTraits<Scalar>::IsComplex,Scalar,std::complex<Scalar>>::type ComplexScalar ; public : template<OtherPolynomial> void)",
    "insertText": "compute(const OtherPolynomial& poly)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(Scalar(0) != poly[poly.size()-1])"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(poly.size() > 1)"
  },
  {
    "label": "companion()",
    "kind": "Method",
    "detail": "Function (internal::companion<Scalar,_Deg>)",
    "insertText": "companion(poly)"
  },
  {
    "label": "balance()",
    "kind": "Method",
    "detail": "Function (companion .)",
    "insertText": "balance()"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (m_eigenSolver .)",
    "insertText": "compute(companion.denseMatrix())"
  },
  {
    "label": "eigenvalues()",
    "kind": "Method",
    "detail": "Function (m_roots = m_eigenSolver .)",
    "insertText": "eigenvalues()"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (RealScalar coarse_prec =)",
    "insertText": "RealScalar(std::pow(4,poly.size()+1))*NumTraits<RealScalar>::epsilon()"
  },
  {
    "label": "ComplexScalar()",
    "kind": "Method",
    "detail": "Function (ComplexScalar as_real_root =)",
    "insertText": "ComplexScalar(numext::real(m_roots[i]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_roots [ i ] = as_real_root ; } } } } else)",
    "insertText": "if(poly.size () == 2)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_roots .)",
    "insertText": "resize(1)"
  },
  {
    "label": "PolynomialSolver()",
    "kind": "Method",
    "detail": "Function (m_roots [ 0 ] = - poly [ 0 ] / poly [ 1 ] ; } } public : template<OtherPolynomial>)",
    "insertText": "PolynomialSolver(const OtherPolynomial& poly)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(poly)"
  },
  {
    "label": "PolynomialSolver()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PolynomialSolver()"
  },
  {
    "label": "EIGEN_POLYNOMIAL_SOLVER_BASE_INHERITED_TYPES()",
    "kind": "Method",
    "detail": "Function (} protected : using PS_Base::m_roots ; EigenSolverType m_eigenSolver ; } ; template<_Scalar> class PolynomialSolver<_Scalar,1> : public PolynomialSolverBase<_Scalar,1> { public : typedef PolynomialSolverBase<_Scalar,1> PS_Base ;)",
    "insertText": "EIGEN_POLYNOMIAL_SOLVER_BASE_INHERITED_TYPES(PS_Base ) public: template< typename OtherPolynomial > void compute( const OtherPolynomial& poly)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(poly.size() == 2)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(Scalar(0) != poly[1])"
  }
]