[
  {
    "label": "FSparseArrayAllocationInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSparseArrayAllocationInfo"
  },
  {
    "label": "TSparseArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSparseArray"
  },
  {
    "label": "TScriptSparseArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TScriptSparseArray"
  },
  {
    "label": "TBaseIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBaseIterator"
  },
  {
    "label": "TIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TIterator"
  },
  {
    "label": "TConstIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TConstIterator"
  },
  {
    "label": "TRangedForIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRangedForIterator"
  },
  {
    "label": "TRangedForConstIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRangedForConstIterator"
  },
  {
    "label": "TConstSubsetIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TConstSubsetIterator"
  },
  {
    "label": "FElementCompareClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FElementCompareClass"
  },
  {
    "label": "FScriptSparseArrayLayout",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FScriptSparseArrayLayout"
  },
  {
    "label": "FFreeListLink",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFreeListLink"
  },
  {
    "label": "TIsZeroConstructType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsZeroConstructType"
  },
  {
    "label": "FScriptSparseArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FScriptSparseArray"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / AssertionMacros . h \" # include \" HAL / UnrealMemory . h \" # include \" Templates / UnrealTypeTraits . h \" # include \" Templates / UnrealTemplate . h \" # include \" Containers / ContainerAllocationPolicies . h \" # include \" Templates / Less . h \" # include \" Containers / Array . h \" # include \" Math / UnrealMathUtility . h \" # include \" Containers / ScriptArray . h \" # include \" Containers / BitArray . h \" # include \" Serialization / StructuredArchive . h \" # include \" Serialization / MemoryImageWriter . h \" # include \" Containers / UnrealString . h \" # include \" Misc / IntrusiveUnsetOptionalState . h \" # if UE_BUILD_SHIPPING | | UE_BUILD_TEST # define TSPARSEARRAY_RANGED_FOR_CHECKS 0 # else # define TSPARSEARRAY_RANGED_FOR_CHECKS 1 # endif struct FSparseArrayAllocationInfo { int32 Index ; void* Pointer ; } ; template<ElementType,Allocator = FDefaultSparseArrayAllocator> class TSparseArray ; template<T,Allocator> void* operator)",
    "insertText": "new(size_t Size, TSparseArray<T, Allocator>& Array)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (template<T,Allocator> void* operator)",
    "insertText": "new(size_t Size, TSparseArray<T, Allocator>& Array, int32 Index)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void* operator)",
    "insertText": "new(size_t Size, const FSparseArrayAllocationInfo& Allocation)"
  },
  {
    "label": "DECLARE_TEMPLATE_INTRINSIC_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (template<ElementType> union TSparseArrayElementOrFreeListLink { ElementType ElementData ; struct { int32 PrevFreeIndex ; int32 NextFreeIndex ; } ; } ;)",
    "insertText": "DECLARE_TEMPLATE_INTRINSIC_TYPE_LAYOUT(template<typename ElementType>, TSparseArrayElementOrFreeListLink<ElementType>)"
  },
  {
    "label": "TSparseArray()",
    "kind": "Method",
    "detail": "Function (template<AllocatorType,InDerivedType = void> class TScriptSparseArray ; template<InElementType,Allocator> class TSparseArray { using ElementType = InElementType ; template<,> class TScriptSparseArray ; public : ~)",
    "insertText": "TSparseArray()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "TSparseArray()",
    "kind": "Method",
    "detail": "Function (} bool bHasIntrusiveUnsetOptionalState = true ; using IntrusiveUnsetOptionalStateType = TSparseArray ;)",
    "insertText": "TSparseArray(FIntrusiveUnsetOptionalState Tag) : Data(Tag)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(FIntrusiveUnsetOptionalState Tag)"
  },
  {
    "label": "Pointer()",
    "kind": "Method",
    "detail": "Function (AllocationFlags [ Index ] = true ; FSparseArrayAllocationInfo Result ; Result . Index = Index ; Result .)",
    "insertText": "Pointer((FElementOrFreeListLink*)Data.GetData())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 Index ;)",
    "insertText": "if(NumFreeIndices)"
  },
  {
    "label": "DataPtr()",
    "kind": "Method",
    "detail": "Function (FElementOrFreeListLink*)",
    "insertText": "DataPtr(FElementOrFreeListLink*)Data.GetData()"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (DataPtr [ FirstFreeIndex ] . PrevFreeIndex = - 1 ; } } else { Index = Data .)",
    "insertText": "AddUninitialized(1)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (AllocationFlags .)",
    "insertText": "Add(false)"
  },
  {
    "label": "AllocateIndex()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "AllocateIndex(Index)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Add(const ElementType& Element)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (FSparseArrayAllocationInfo Allocation =)",
    "insertText": "AddUninitialized()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(Allocation) ElementType(Element)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(Allocation) ElementType(MoveTemp(Element))"
  },
  {
    "label": "FindAndSetFirstZeroBit()",
    "kind": "Method",
    "detail": "Function (Index = AllocationFlags .)",
    "insertText": "FindAndSetFirstZeroBit(LowestFreeIndexSearchStart)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FirstFreeIndex = DataPtr [ Index ] . NextFreeIndex ; })",
    "insertText": "if(DataPtr[Index].NextFreeIndex >= 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (DataPtr [ DataPtr [ Index ] . NextFreeIndex ] . PrevFreeIndex = DataPtr [ Index ] . PrevFreeIndex ; })",
    "insertText": "if(DataPtr[Index].PrevFreeIndex >= 0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (AllocationFlags .)",
    "insertText": "Add(true)"
  },
  {
    "label": "AddUninitializedAtLowestFreeIndex()",
    "kind": "Method",
    "detail": "Function (FSparseArrayAllocationInfo Allocation =)",
    "insertText": "AddUninitializedAtLowestFreeIndex(LowestFreeIndexSearchStart)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(Allocation) ElementType(Forward<ArgsType>(Args)...)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FSparseArrayAllocationInfo Allocation ;)",
    "insertText": "if(!AllocationFlags.IsValidIndex(Index) || !AllocationFlags[Index])"
  },
  {
    "label": "InsertUninitialized()",
    "kind": "Method",
    "detail": "Function (Allocation =)",
    "insertText": "InsertUninitialized(Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FElementOrFreeListLink* DataPtr ;)",
    "insertText": "if(Index >= Data.Num())"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "AddUninitialized(Index + 1 - Data.Num())"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 FreeIndex = AllocationFlags .)",
    "insertText": "Num()"
  },
  {
    "label": "verify()",
    "kind": "Method",
    "detail": "Function (DataPtr [ FirstFreeIndex ] . PrevFreeIndex = FreeIndex ; } FirstFreeIndex = FreeIndex ;)",
    "insertText": "verify(AllocationFlags.Add(false) == FreeIndex)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(!AllocationFlags[Index])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - NumFreeIndices ; const int32 PrevFreeIndex = DataPtr [ Index ] . PrevFreeIndex ; const int32 NextFreeIndex = DataPtr [ Index ] . NextFreeIndex ;)",
    "insertText": "if(PrevFreeIndex != -1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (DataPtr [ PrevFreeIndex ] . NextFreeIndex = NextFreeIndex ; } else { FirstFreeIndex = NextFreeIndex ; })",
    "insertText": "if(NextFreeIndex != -1)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Insert(int32 Index,typename TTypeTraits<ElementType>::ConstInitType Element)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(InsertUninitialized(Index)) ElementType(Element)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveAt(int32 Index,int32 Count = 1)"
  },
  {
    "label": "RemoveAtUninitialized()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "RemoveAtUninitialized(Index, Count)"
  },
  {
    "label": "RemoveAtUninitialized()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveAtUninitialized(int32 Index,int32 Count = 1)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (DataPtr [ FirstFreeIndex ] . PrevFreeIndex = Index ; } DataPtr [ Index ] . PrevFreeIndex = - 1 ; DataPtr [ Index ] . NextFreeIndex = NumFreeIndices> 0 ? FirstFreeIndex : INDEX_NONE ; FirstFreeIndex = Index ; + + NumFreeIndices ; AllocationFlags [ Index ] = false ; + + Index ; } } void)",
    "insertText": "Empty(int32 ExpectedNumElements = 0)"
  },
  {
    "label": "ElementType()",
    "kind": "Method",
    "detail": "Function (ElementType& Element =* It ; Element . ~)",
    "insertText": "ElementType()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} } Data .)",
    "insertText": "Empty(ExpectedNumElements)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reserve(int32 ExpectedNumElements)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (int32 ElementIndex = Data .)",
    "insertText": "AddUninitialized(ElementsToAdd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (DataPtr [ FirstFreeIndex ] . PrevFreeIndex = FreeIndex ; } DataPtr [ FreeIndex ] . PrevFreeIndex = - 1 ; DataPtr [ FreeIndex ] . NextFreeIndex = NumFreeIndices> 0 ? FirstFreeIndex : INDEX_NONE ; FirstFreeIndex = FreeIndex ; + + NumFreeIndices ; })",
    "insertText": "if(ElementsToAdd == ExpectedNumElements)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (AllocationFlags .)",
    "insertText": "Init(false, ElementsToAdd)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { AllocationFlags .)",
    "insertText": "Add(false, ElementsToAdd)"
  },
  {
    "label": "Shrink()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "Shrink()"
  },
  {
    "label": "FindLast()",
    "kind": "Method",
    "detail": "Function (int32 MaxAllocatedIndex = AllocationFlags .)",
    "insertText": "FindLast(true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 FirstIndexToRemove = MaxAllocatedIndex + 1 ;)",
    "insertText": "if(FirstIndexToRemove < Data.Num())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 FreeIndex = FirstFreeIndex ;)",
    "insertText": "while(FreeIndex != INDEX_NONE)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (DataPtr [ PrevFreeIndex ] . NextFreeIndex = NextFreeIndex ; } else { FirstFreeIndex = NextFreeIndex ; } - - NumFreeIndices ; FreeIndex = NextFreeIndex ; } else { FreeIndex = DataPtr [ FreeIndex ] . NextFreeIndex ; } } } Data .)",
    "insertText": "RemoveAt(FirstIndexToRemove, Data.Num() - FirstIndexToRemove, EAllowShrinking::No)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (AllocationFlags .)",
    "insertText": "RemoveAt(FirstIndexToRemove,AllocationFlags.Num() - FirstIndexToRemove)"
  },
  {
    "label": "Compact()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Compact()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 NumFree = NumFreeIndices ;)",
    "insertText": "if(NumFree == 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 TargetIndex = EndIndex - NumFree ; int32 FreeIndex = FirstFreeIndex ;)",
    "insertText": "while(FreeIndex != -1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 NextFreeIndex = DataPtr [ FreeIndex ] . NextFreeIndex ;)",
    "insertText": "if(FreeIndex < TargetIndex)"
  },
  {
    "label": "FElementOrFreeListLink()",
    "kind": "Method",
    "detail": "Function (RelocateConstructItems<)",
    "insertText": "FElementOrFreeListLink(DataPtr + FreeIndex, DataPtr + EndIndex, 1)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (AllocationFlags [ FreeIndex ] = true ; bResult = true ; } FreeIndex = NextFreeIndex ; } Data .)",
    "insertText": "RemoveAt(TargetIndex, NumFree, EAllowShrinking::No)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (AllocationFlags .)",
    "insertText": "RemoveAt(TargetIndex, NumFree)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(CompactedArray.AddUninitialized()) ElementType(MoveTempIfPossible(*It))"
  },
  {
    "label": "Exchange()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Exchange(*this,CompactedArray)"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Sort(TArrayView<FElementOrFreeListLink>(Data.GetData(), Num()), FElementCompareClass< PREDICATE_CLASS >( Predicate ))"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Sort()"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Sort(TLess< ElementType >())"
  },
  {
    "label": "StableSort()",
    "kind": "Method",
    "detail": "Function (} template<PREDICATE_CLASS> void)",
    "insertText": "StableSort(const PREDICATE_CLASS& Predicate)"
  },
  {
    "label": "CompactStable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CompactStable()"
  },
  {
    "label": "StableSort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StableSort(TArrayView<FElementOrFreeListLink>(Data.GetData(), Num()), FElementCompareClass< PREDICATE_CLASS >(Predicate))"
  },
  {
    "label": "StableSort()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "StableSort()"
  },
  {
    "label": "StableSort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StableSort(TLess< ElementType >())"
  },
  {
    "label": "SortFreeList()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SortFreeList()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 CurrentHeadIndex = INDEX_NONE ; int32 NumFreeIndicesProcessed = 0 ;)",
    "insertText": "for(int32 Index = Data.Num() - 1; NumFreeIndicesProcessed < NumFreeIndices; --Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (DataPtr [ Index ] . PrevFreeIndex = INDEX_NONE ; DataPtr [ Index ] . NextFreeIndex = INDEX_NONE ;)",
    "insertText": "if(CurrentHeadIndex != INDEX_NONE)"
  },
  {
    "label": "IndexOfByPredicate()",
    "kind": "Method",
    "detail": "Function (DataPtr [ CurrentHeadIndex ] . PrevFreeIndex = Index ; DataPtr [ Index ] . NextFreeIndex = CurrentHeadIndex ; } CurrentHeadIndex = Index ; + + NumFreeIndicesProcessed ; } } FirstFreeIndex = CurrentHeadIndex ; } template<Predicate> int32)",
    "insertText": "IndexOfByPredicate(Predicate Pred)"
  },
  {
    "label": "FindArbitraryElementIndex()",
    "kind": "Method",
    "detail": "Function (} } return INDEX_NONE ; } int32)",
    "insertText": "FindArbitraryElementIndex()"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} return AllocationFlags .)",
    "insertText": "Find(true)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetAllocatedSize(void)"
  },
  {
    "label": "CountBytes()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CountBytes(FArchive& Ar)"
  },
  {
    "label": "CountBytes()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "CountBytes(Ar)"
  },
  {
    "label": "IsCompact()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsCompact()"
  },
  {
    "label": "IsAllocated()",
    "kind": "Method",
    "detail": "Function (const bool bIsAllocatedA =)",
    "insertText": "IsAllocated(ElementIndex)"
  },
  {
    "label": "TSparseArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSparseArray() : FirstFreeIndex(-1) , NumFreeIndices(0)"
  },
  {
    "label": "TSparseArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSparseArray(TSparseArray&& InCopy)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Move(*this, InCopy)"
  },
  {
    "label": "TSparseArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSparseArray(const TSparseArray& InCopy) : FirstFreeIndex(-1) , NumFreeIndices(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (* this = InCopy ; } TSparseArray&)",
    "insertText": "operator(TSparseArray&& InCopy)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } TSparseArray&)",
    "insertText": "operator(const TSparseArray& InCopy)"
  },
  {
    "label": "GetMaxIndex()",
    "kind": "Method",
    "detail": "Function (int32 SrcMax = InCopy .)",
    "insertText": "GetMaxIndex()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty(SrcMax)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "AddUninitialized(SrcMax)"
  },
  {
    "label": "DestData()",
    "kind": "Method",
    "detail": "Function (FirstFreeIndex = InCopy . FirstFreeIndex ; NumFreeIndices = InCopy . NumFreeIndices ; AllocationFlags = InCopy . AllocationFlags ; FElementOrFreeListLink*)",
    "insertText": "DestData(FElementOrFreeListLink*)Data.GetData()"
  },
  {
    "label": "SrcData()",
    "kind": "Method",
    "detail": "Function (const FElementOrFreeListLink*)",
    "insertText": "SrcData(const FElementOrFreeListLink*)InCopy.Data.GetData()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FElementOrFreeListLink& DestElement = DestData [ Index ] ; const FElementOrFreeListLink& SrcElement = SrcData [ Index ] ;)",
    "insertText": "if(InCopy.IsAllocated(Index))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((uint8*)&DestElement.ElementData) ElementType(*(const ElementType*)&SrcElement.ElementData)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { DestElement . PrevFreeIndex = SrcElement . PrevFreeIndex ; DestElement . NextFreeIndex = SrcElement . NextFreeIndex ; } } } else {)",
    "insertText": "if(SrcMax)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(DestData, SrcData, sizeof(FElementOrFreeListLink) * SrcMax)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (} } } return* this ; } private : template<SparseArrayType> void)",
    "insertText": "Move(SparseArrayType& ToArray, SparseArrayType& FromArray)"
  },
  {
    "label": "DestructItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItem(&Element)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (} } ToArray .)",
    "insertText": "Data(DataType&&)"
  },
  {
    "label": "AllocationFlags()",
    "kind": "Method",
    "detail": "Function (ToArray .)",
    "insertText": "AllocationFlags(AllocationBitArrayType&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ToArray . FirstFreeIndex = FromArray . FirstFreeIndex ; ToArray . NumFreeIndices = FromArray . NumFreeIndices ; FromArray . FirstFreeIndex = - 1 ; FromArray . NumFreeIndices = 0 ; } public : ElementType&)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "PointerToIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "PointerToIndex(const ElementType* Ptr)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Index(int32)((FElementOrFreeListLink*)Ptr - (FElementOrFreeListLink*)Data.GetData())"
  },
  {
    "label": "IsAllocated()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsAllocated(int32 Index)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "CheckAddress()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CheckAddress(const ElementType* Addr)"
  },
  {
    "label": "CheckAddress()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "CheckAddress(Addr)"
  },
  {
    "label": "TBaseIterator()",
    "kind": "Method",
    "detail": "Function (} private : template<bool bConst> class TBaseIterator { public : typedef TConstSetBitIterator<Allocator::BitArrayAllocator> BitArrayItType ; private : typedef std::conditional_t<bConst,const TSparseArray,TSparseArray> ArrayType ; typedef std::conditional_t<bConst,const ElementType,ElementType> ItElementType ; public :)",
    "insertText": "TBaseIterator(ArrayType& InArray, const BitArrayItType& InBitArrayIt) : Array (InArray) , BitArrayIt(InBitArrayIt)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TBaseIterator&)",
    "insertText": "operator()"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (+ + BitArrayIt ; return* this ; } int32)",
    "insertText": "GetIndex()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TBaseIterator& Rhs)"
  },
  {
    "label": "GetRelativeBitReference()",
    "kind": "Method",
    "detail": "Function (} const FRelativeBitReference&)",
    "insertText": "GetRelativeBitReference()"
  },
  {
    "label": "TIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TIterator(TSparseArray& InArray, const typename TBaseIterator<false>::BitArrayItType& InBitArrayIt) : TBaseIterator<false>(InArray, InBitArrayIt)"
  },
  {
    "label": "RemoveCurrent()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveCurrent()"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (this -> Array .)",
    "insertText": "RemoveAt(this->GetIndex())"
  },
  {
    "label": "TConstIterator()",
    "kind": "Method",
    "detail": "Function (} } ; class TConstIterator : public TBaseIterator<true> { public :)",
    "insertText": "TConstIterator(const TSparseArray& InArray) : TBaseIterator<true>(InArray, TConstSetBitIterator<typename Allocator::BitArrayAllocator>(InArray.AllocationFlags))"
  },
  {
    "label": "TConstIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TConstIterator(const TSparseArray& InArray, const typename TBaseIterator<true>::BitArrayItType& InBitArrayIt) : TBaseIterator<true>(InArray, InBitArrayIt)"
  },
  {
    "label": "TRangedForIterator()",
    "kind": "Method",
    "detail": "Function (} } ; # if TSPARSEARRAY_RANGED_FOR_CHECKS class TRangedForIterator : public TIterator { public :)",
    "insertText": "TRangedForIterator(TSparseArray& InArray, const typename TBaseIterator<false>::BitArrayItType& InBitArrayIt) : TIterator (InArray, InBitArrayIt) , InitialNum(InArray.Num())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TRangedForIterator& Rhs)"
  },
  {
    "label": "TRangedForConstIterator()",
    "kind": "Method",
    "detail": "Function (} private : int32 InitialNum ; } ; class TRangedForConstIterator : public TConstIterator { public :)",
    "insertText": "TRangedForConstIterator(const TSparseArray& InArray, const typename TBaseIterator<true>::BitArrayItType& InBitArrayIt) : TConstIterator(InArray, InBitArrayIt) , InitialNum (InArray.Num())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TRangedForConstIterator& Rhs)"
  },
  {
    "label": "CreateIterator()",
    "kind": "Method",
    "detail": "Function (} private : int32 InitialNum ; } ; # else using TRangedForIterator = TIterator ; using TRangedForConstIterator = TConstIterator ; # endif TIterator)",
    "insertText": "CreateIterator()"
  },
  {
    "label": "CreateConstIterator()",
    "kind": "Method",
    "detail": "Function (} TConstIterator)",
    "insertText": "CreateConstIterator()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} public : TRangedForIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} TRangedForIterator)",
    "insertText": "end()"
  },
  {
    "label": "TConstSubsetIterator()",
    "kind": "Method",
    "detail": "Function (} public : template<SubsetAllocator = FDefaultBitArrayAllocator> class TConstSubsetIterator { public :)",
    "insertText": "TConstSubsetIterator(const TSparseArray& InArray, const TBitArray<SubsetAllocator>& InBitArray ): Array(InArray), BitArrayIt(InArray.AllocationFlags,InBitArray)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Reserve(this->Num() + OtherArray.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Add(*It)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } TSparseArray&)",
    "insertText": "operator(const TArray<ElementType>& OtherArray)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Add(OtherArray[Idx])"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} return* this ; } private : typedef TSparseArrayElementOrFreeListLink<TAlignedBytes<)",
    "insertText": "sizeof(ElementType), alignof(ElementType)"
  },
  {
    "label": "FElementCompareClass()",
    "kind": "Method",
    "detail": "Function (template<PREDICATE_CLASS> class FElementCompareClass { const PREDICATE_CLASS& Predicate ; public :)",
    "insertText": "FElementCompareClass(const PREDICATE_CLASS& InPredicate ) : Predicate( InPredicate)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator()( const FElementOrFreeListLink& A,const FElementOrFreeListLink& B)"
  },
  {
    "label": "WriteMemoryImage()",
    "kind": "Method",
    "detail": "Function (} } ; typedef TArray<FElementOrFreeListLink,Allocator::ElementAllocator> DataType ; DataType Data ; typedef TBitArray<Allocator::BitArrayAllocator> AllocationBitArrayType ; AllocationBitArrayType AllocationFlags ; int32 FirstFreeIndex = - 1 ; int32 NumFreeIndices = 0 ; public : void)",
    "insertText": "WriteMemoryImage(FMemoryImageWriter& Writer)"
  },
  {
    "label": "WritePointer()",
    "kind": "Method",
    "detail": "Function (FMemoryImageWriter ArrayWriter = Writer .)",
    "insertText": "WritePointer(ElementTypeDesc)"
  },
  {
    "label": "Elem()",
    "kind": "Method",
    "detail": "Function (const FElementOrFreeListLink&)",
    "insertText": "Elem((const FElementOrFreeListLink*)this->Data.GetData())"
  },
  {
    "label": "FElementOrFreeListLink()",
    "kind": "Method",
    "detail": "Function (const uint32 StartOffset = ArrayWriter . WriteAlignment<)",
    "insertText": "FElementOrFreeListLink()"
  },
  {
    "label": "WriteObject()",
    "kind": "Method",
    "detail": "Function (ArrayWriter .)",
    "insertText": "WriteObject(&Elem.ElementData, ElementTypeDesc)"
  },
  {
    "label": "WriteBytes()",
    "kind": "Method",
    "detail": "Function (} else { ArrayWriter .)",
    "insertText": "WriteBytes(Elem.PrevFreeIndex)"
  },
  {
    "label": "WriteBytes()",
    "kind": "Method",
    "detail": "Function (ArrayWriter .)",
    "insertText": "WriteBytes(Elem.NextFreeIndex)"
  },
  {
    "label": "WritePaddingToSize()",
    "kind": "Method",
    "detail": "Function (} ArrayWriter .)",
    "insertText": "WritePaddingToSize(StartOffset + sizeof(FElementOrFreeListLink))"
  },
  {
    "label": "WriteNullPointer()",
    "kind": "Method",
    "detail": "Function (} } else { Writer .)",
    "insertText": "WriteNullPointer()"
  },
  {
    "label": "WriteBytes()",
    "kind": "Method",
    "detail": "Function (} Writer .)",
    "insertText": "WriteBytes(NumElements)"
  },
  {
    "label": "WriteMemoryImage()",
    "kind": "Method",
    "detail": "Function (this -> AllocationFlags .)",
    "insertText": "WriteMemoryImage(Writer)"
  },
  {
    "label": "WriteBytes()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteBytes(this->FirstFreeIndex)"
  },
  {
    "label": "WriteBytes()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteBytes(this->NumFreeIndices)"
  },
  {
    "label": "WriteBytes()",
    "kind": "Method",
    "detail": "Function (} else { Writer .)",
    "insertText": "WriteBytes(TSparseArray())"
  },
  {
    "label": "CopyUnfrozen()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "CopyUnfrozen(const FMemoryUnfreezeContent& Context, void* Dst)"
  },
  {
    "label": "DstObject()",
    "kind": "Method",
    "detail": "Function (TSparseArray*)",
    "insertText": "DstObject(TSparseArray*)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)&DstObject->Data) DataType()"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (DstObject -> Data .)",
    "insertText": "SetNumUninitialized(this->Data.Num())"
  },
  {
    "label": "Elem()",
    "kind": "Method",
    "detail": "Function (const FElementOrFreeListLink&)",
    "insertText": "Elem((const FElementOrFreeListLink*)this ->Data.GetData())"
  },
  {
    "label": "DstElem()",
    "kind": "Method",
    "detail": "Function (FElementOrFreeListLink&)",
    "insertText": "DstElem(( FElementOrFreeListLink*)DstObject->Data.GetData())"
  },
  {
    "label": "UnfreezeObject()",
    "kind": "Method",
    "detail": "Function (Context .)",
    "insertText": "UnfreezeObject(&Elem.ElementData, ElementTypeDesc, &DstElem.ElementData)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} else { DstElem . PrevFreeIndex = Elem . PrevFreeIndex ; DstElem . NextFreeIndex = Elem . NextFreeIndex ; } })",
    "insertText": "new((void*)&DstObject->AllocationFlags) AllocationBitArrayType(this->AllocationFlags)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (DstObject -> FirstFreeIndex = this -> FirstFreeIndex ; DstObject -> NumFreeIndices = this -> NumFreeIndices ; } else)",
    "insertText": "new((void*)Dst) TSparseArray()"
  },
  {
    "label": "AppendHash()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "AppendHash(const FPlatformTypeLayoutParameters& LayoutParams, FSHA1& Hasher)"
  },
  {
    "label": "AppendHash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendHash(StaticGetTypeLayoutDesc<ElementType>(), LayoutParams, Hasher)"
  },
  {
    "label": "IntrinsicWriteMemoryImage()",
    "kind": "Method",
    "detail": "Function (} } } ; namespace Freeze { template<ElementType,Allocator> void)",
    "insertText": "IntrinsicWriteMemoryImage(FMemoryImageWriter& Writer, const TSparseArray<ElementType, Allocator>& Object, const FTypeLayoutDesc&)"
  },
  {
    "label": "IntrinsicUnfrozenCopy()",
    "kind": "Method",
    "detail": "Function (} template<ElementType,Allocator> uint32)",
    "insertText": "IntrinsicUnfrozenCopy(const FMemoryUnfreezeContent& Context, const TSparseArray<ElementType, Allocator>& Object, void* OutDst)"
  },
  {
    "label": "CopyUnfrozen()",
    "kind": "Method",
    "detail": "Function (Object .)",
    "insertText": "CopyUnfrozen(Context, OutDst)"
  },
  {
    "label": "IntrinsicAppendHash()",
    "kind": "Method",
    "detail": "Function (} template<ElementType,Allocator> uint32)",
    "insertText": "IntrinsicAppendHash(const TSparseArray<ElementType, Allocator>* DummyObject, const FTypeLayoutDesc& TypeDesc, const FPlatformTypeLayoutParameters& LayoutParams, FSHA1& Hasher)"
  },
  {
    "label": "AppendHash()",
    "kind": "Method",
    "detail": "Function (TSparseArray<ElementType,Allocator)",
    "insertText": "AppendHash(LayoutParams, Hasher)"
  },
  {
    "label": "DECLARE_TEMPLATE_INTRINSIC_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "DECLARE_TEMPLATE_INTRINSIC_TYPE_LAYOUT((template <typename ElementType, typename Allocator>), (TSparseArray<ElementType, Allocator>))"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (FScriptSparseArrayLayout Result ; Result . Alignment =)",
    "insertText": "Max(ElementAlignment, (int32)alignof(FFreeListLink))"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Result . Size =)",
    "insertText": "Max(ElementSize, (int32)sizeof (FFreeListLink))"
  },
  {
    "label": "TScriptSparseArray()",
    "kind": "Method",
    "detail": "Function (} bool bHasIntrusiveUnsetOptionalState = true ; using IntrusiveUnsetOptionalStateType = TScriptSparseArray ;)",
    "insertText": "TScriptSparseArray(FIntrusiveUnsetOptionalState Tag) : Data(Tag)"
  },
  {
    "label": "NumUnchecked()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "NumUnchecked()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} const void*)",
    "insertText": "GetData(int32 Index, const FScriptSparseArrayLayout& Layout)"
  },
  {
    "label": "MoveAssign()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MoveAssign(DerivedType& Other, const FScriptSparseArrayLayout& Layout)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty(0, Layout)"
  },
  {
    "label": "MoveAssign()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "MoveAssign(Other.Data, Layout.Size, Layout.Alignment)"
  },
  {
    "label": "MoveAssign()",
    "kind": "Method",
    "detail": "Function (AllocationFlags .)",
    "insertText": "MoveAssign(Other.AllocationFlags)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (FirstFreeIndex = Other . FirstFreeIndex ; Other . FirstFreeIndex = 0 ; NumFreeIndices = Other . NumFreeIndices ; Other . NumFreeIndices = 0 ; } void)",
    "insertText": "Empty(int32 Slack, const FScriptSparseArrayLayout& Layout)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "Empty(Slack, Layout.Size, Layout.Alignment)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (FirstFreeIndex = - 1 ; NumFreeIndices = 0 ; AllocationFlags .)",
    "insertText": "Empty(Slack)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "AddUninitialized(const FScriptSparseArrayLayout& Layout)"
  },
  {
    "label": "GetFreeListLink()",
    "kind": "Method",
    "detail": "Function (NextFreeIndex)",
    "insertText": "GetFreeListLink(FirstFreeIndex, Layout)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} } else { Index = Data .)",
    "insertText": "Add(1, Layout.Size, Layout.Alignment)"
  },
  {
    "label": "RemoveAtUninitialized()",
    "kind": "Method",
    "detail": "Function (} AllocationFlags [ Index ] = true ; return Index ; } void)",
    "insertText": "RemoveAtUninitialized(const FScriptSparseArrayLayout& Layout, int32 Index, int32 Count = 1)"
  },
  {
    "label": "GetFreeListLink()",
    "kind": "Method",
    "detail": "Function (} auto* IndexData =)",
    "insertText": "GetFreeListLink(Index, Layout)"
  },
  {
    "label": "CheckConstraints()",
    "kind": "Method",
    "detail": "Function (IndexData -> PrevFreeIndex = - 1 ; IndexData -> NextFreeIndex = NumFreeIndices> 0 ? FirstFreeIndex : INDEX_NONE ; FirstFreeIndex = Index ; + + NumFreeIndices ; AllocationFlags [ Index ] = false ; + + Index ; } } private : TScriptArray<AllocatorType::ElementAllocator> Data ; TScriptBitArray<AllocatorType::BitArrayAllocator> AllocationFlags ; int32 FirstFreeIndex = - 1 ; int32 NumFreeIndices = 0 ; void)",
    "insertText": "CheckConstraints()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (typedef TScriptSparseArray ScriptType ; typedef TSparseArray<int32> RealType ;)",
    "insertText": "static_assert(sizeof (ScriptType) == sizeof (RealType), \"TScriptSparseArray's size doesn't match TSparseArray\")"
  },
  {
    "label": "GetFreeListLink()",
    "kind": "Method",
    "detail": "Function (} struct FFreeListLink { int32 PrevFreeIndex ; int32 NextFreeIndex ; } ; FFreeListLink*)",
    "insertText": "GetFreeListLink(int32 Index, const FScriptSparseArrayLayout& Layout)"
  },
  {
    "label": "TScriptSparseArray()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "TScriptSparseArray(const TScriptSparseArray&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator(const TScriptSparseArray&)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} } ; template<AllocatorType,InDerivedType> struct TIsZeroConstructType<TScriptSparseArray<AllocatorType,InDerivedType>> { enum { Value = true } ; } ; class FScriptSparseArray : public TScriptSparseArray<FDefaultSparseArrayAllocator,FScriptSparseArray> { using Super = TScriptSparseArray<FDefaultSparseArrayAllocator,FScriptSparseArray> ; public : using Super::Super ; using IntrusiveUnsetOptionalStateType = FScriptSparseArray ; } ; void* operator)",
    "insertText": "new(size_t Size,const FSparseArrayAllocationInfo& Allocation)"
  },
  {
    "label": "UE_ASSUME()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_ASSUME(Allocation.Pointer)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (int32 NewNumElements = 0 ; Ar<<NewNumElements ; Array .)",
    "insertText": "Empty(NewNumElements)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (Ar<<)",
    "insertText": "new(Array.AddUninitialized())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Ar<<NewNumElements ;)",
    "insertText": "for(typename TSparseArray<ElementType, Allocator>::TIterator It(Array);It;++It)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ar<<* It ; } } return Ar ; } template<ElementType,Allocator> void)",
    "insertText": "operator(FStructuredArchive::FSlot Slot, TSparseArray<ElementType, Allocator>& InArray)"
  },
  {
    "label": "EnterArray()",
    "kind": "Method",
    "detail": "Function (FStructuredArchive::FArray Array = Slot .)",
    "insertText": "EnterArray(NumElements)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (InArray .)",
    "insertText": "Empty(NumElements)"
  },
  {
    "label": "EnterElement()",
    "kind": "Method",
    "detail": "Function (FStructuredArchive::FSlot ElementSlot = Array .)",
    "insertText": "EnterElement()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (ElementSlot<<)",
    "insertText": "new(InArray.AddUninitialized())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "for(typename TSparseArray<ElementType, Allocator>::TIterator It(InArray); It; ++It)"
  }
]