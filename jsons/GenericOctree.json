[
  {
    "label": "FOctreeChildNodeRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOctreeChildNodeRef"
  },
  {
    "label": "FBoxCenterAndExtent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBoxCenterAndExtent"
  },
  {
    "label": "FOctreeChildNodeSubset",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOctreeChildNodeSubset"
  },
  {
    "label": "FOctreeNodeContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FOctreeNodeContext"
  },
  {
    "label": "TOctree2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TOctree2"
  },
  {
    "label": "FNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNode"
  },
  {
    "label": "FFreeList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFreeList"
  },
  {
    "label": "FSpan",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSpan"
  },
  {
    "label": "COctreeSemanticsV2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "COctreeSemanticsV2"
  },
  {
    "label": "TOctree_DEPRECATED",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TOctree_DEPRECATED"
  },
  {
    "label": "FNodeReference",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNodeReference"
  },
  {
    "label": "TConstIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TConstIterator"
  },
  {
    "label": "TConstElementBoxIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TConstElementBoxIterator"
  },
  {
    "label": "UE_DEPRECATED",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UE_DEPRECATED"
  },
  {
    "label": "FOREACH_OCTREE_CHILD_NODE()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / ArrayView . h \" # include \" Containers / ContainerAllocationPolicies . h \" # include \" CoreGlobals . h \" # include \" CoreMinimal . h \" # include \" CoreTypes . h \" # include \" GenericOctreePublic . h \" # include \" HAL / PlatformMisc . h \" # include \" Logging / LogCategory . h \" # include \" Logging / LogMacros . h \" # include \" Math / Box . h \" # include \" Math / BoxSphereBounds . h \" # include \" Math / MathFwd . h \" # include \" Math / UnrealMathSSE . h \" # include \" Math / UnrealMathUtility . h \" # include \" Math / Vector . h \" # include \" Math / Vector4 . h \" # include \" Math / VectorRegister . h \" # include \" Misc / AssertionMacros . h \" # include \" Templates / EnableIf . h \" # include \" Templates / Models . h \" # include \" Templates / UnrealTemplate . h \" # include \" Templates / UnrealTypeTraits . h \" # include \" Trace / Detail / Channel . h \" # define)",
    "insertText": "FOREACH_OCTREE_CHILD_NODE(ChildRef) \\ for(FOctreeChildNodeRef ChildRef(0);!ChildRef.IsNULL();ChildRef.Advance())"
  },
  {
    "label": "FBoxCenterAndExtent()",
    "kind": "Method",
    "detail": "Function (class FBoxCenterAndExtent { public : using FReal = FVector4::FReal ; FVector4 Center ; FVector4 Extent ;)",
    "insertText": "FBoxCenterAndExtent()"
  },
  {
    "label": "FBoxCenterAndExtent()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FBoxCenterAndExtent(const FVector& InCenter,const FVector& InExtent) : Center(InCenter,0) , Extent(InExtent,0)"
  },
  {
    "label": "FBoxCenterAndExtent()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FBoxCenterAndExtent(const FBox& Box)"
  },
  {
    "label": "GetCenterAndExtents()",
    "kind": "Method",
    "detail": "Function (FVector C,E ; Box .)",
    "insertText": "GetCenterAndExtents(C,E)"
  },
  {
    "label": "FVector4()",
    "kind": "Method",
    "detail": "Function (Center =)",
    "insertText": "FVector4(C, 0)"
  },
  {
    "label": "FVector4()",
    "kind": "Method",
    "detail": "Function (Extent =)",
    "insertText": "FVector4(E, 0)"
  },
  {
    "label": "FBoxCenterAndExtent()",
    "kind": "Method",
    "detail": "Function (} template<TExtent>)",
    "insertText": "FBoxCenterAndExtent(const UE::Math::TBoxSphereBounds<FReal, TExtent>& BoxSphere)"
  },
  {
    "label": "FVector()",
    "kind": "Method",
    "detail": "Function (Center = BoxSphere . Origin ; Extent =)",
    "insertText": "FVector(BoxSphere.BoxExtent)"
  },
  {
    "label": "FBoxCenterAndExtent()",
    "kind": "Method",
    "detail": "Function (Center . W = Extent . W = 0 ; })",
    "insertText": "FBoxCenterAndExtent(const float PositionRadius[4])"
  },
  {
    "label": "FVector4()",
    "kind": "Method",
    "detail": "Function (Center =)",
    "insertText": "FVector4(PositionRadius[0],PositionRadius[1],PositionRadius[2], 0)"
  },
  {
    "label": "FVector4()",
    "kind": "Method",
    "detail": "Function (Extent =)",
    "insertText": "FVector4(PositionRadius[3],PositionRadius[3],PositionRadius[3], 0)"
  },
  {
    "label": "GetBox()",
    "kind": "Method",
    "detail": "Function (} FBox)",
    "insertText": "GetBox()"
  },
  {
    "label": "Intersect()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Intersect(const FBoxCenterAndExtent& A,const FBoxCenterAndExtent& B)"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (const VectorRegister CenterDifference =)",
    "insertText": "VectorAbs(VectorSubtract(VectorLoadAligned(&A.Center),VectorLoadAligned(&B.Center)))"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (const VectorRegister CompositeExtent =)",
    "insertText": "VectorAdd(VectorLoadAligned(&A.Extent),VectorLoadAligned(&B.Extent))"
  },
  {
    "label": "Intersect()",
    "kind": "Method",
    "detail": "Function (} template<TExtent> bool)",
    "insertText": "Intersect(const UE::Math::TBoxSphereBounds<FReal, TExtent>& A,const FBoxCenterAndExtent& B)"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (const VectorRegister CenterDifference =)",
    "insertText": "VectorAbs(VectorSubtract(VectorLoadFloat3_W0(&A.Origin),VectorLoadAligned(&B.Center)))"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (const VectorRegister CompositeExtent =)",
    "insertText": "VectorAdd(VectorLoadFloat3_W0(&A.BoxExtent),VectorLoadAligned(&B.Extent))"
  },
  {
    "label": "Intersect()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Intersect(const float A[4],const FBoxCenterAndExtent& B)"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (const VectorRegister CenterDifference =)",
    "insertText": "VectorAbs(VectorSubtract(VectorLoadFloat3_W0(A),VectorLoadAligned(&B.Center)))"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (const VectorRegister CompositeExtent =)",
    "insertText": "VectorAdd(VectorSet_W0(VectorLoadFloat1(A+3)),VectorLoadAligned(&B.Extent))"
  },
  {
    "label": "FOctreeChildNodeRef()",
    "kind": "Method",
    "detail": "Function (} } ; class FOctreeChildNodeRef { public : int8 Index ;)",
    "insertText": "FOctreeChildNodeRef(int8 InX, int8 InY, int8 InZ)"
  },
  {
    "label": "int8()",
    "kind": "Method",
    "detail": "Function (Index =)",
    "insertText": "int8(InX << 0) | int8(InY << 1) | int8(InZ << 2)"
  },
  {
    "label": "FOctreeChildNodeRef()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FOctreeChildNodeRef(int8 InIndex = 0) : Index(InIndex)"
  },
  {
    "label": "Advance()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Advance()"
  },
  {
    "label": "IsNULL()",
    "kind": "Method",
    "detail": "Function (+ + Index ; } bool)",
    "insertText": "IsNULL()"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (Index = 8 ; } int32)",
    "insertText": "X()"
  },
  {
    "label": "Y()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Y()"
  },
  {
    "label": "Z()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Z()"
  },
  {
    "label": "FOctreeChildNodeSubset()",
    "kind": "Method",
    "detail": "Function (} } ; class FOctreeChildNodeSubset { public : union { struct { uint32 bPositiveX : 1 ; uint32 bPositiveY : 1 ; uint32 bPositiveZ : 1 ; uint32 bNegativeX : 1 ; uint32 bNegativeY : 1 ; uint32 bNegativeZ : 1 ; } ; struct { uint32 PositiveChildBits : 3 ; uint32 NegativeChildBits : 3 ; } ; uint32 ChildBits : 6 ; uint32 AllBits ; } ;)",
    "insertText": "FOctreeChildNodeSubset() : AllBits(0)"
  },
  {
    "label": "FOctreeChildNodeSubset()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FOctreeChildNodeSubset(FOctreeChildNodeRef ChildRef) : AllBits(0)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (PositiveChildBits = ChildRef . Index ; NegativeChildBits = ~ ChildRef . Index ; } bool)",
    "insertText": "Contains(FOctreeChildNodeRef ChildRef)"
  },
  {
    "label": "FOctreeNodeContext()",
    "kind": "Method",
    "detail": "Function (} ; class FOctreeNodeContext { public : using FReal = FVector4::FReal ; enum { LoosenessDenominator = 1 6 } ; FBoxCenterAndExtent Bounds ; FReal ChildExtent ; FReal ChildCenterOffset ; uint32 InCullBits ; uint32 OutCullBits ;)",
    "insertText": "FOctreeNodeContext()"
  },
  {
    "label": "FOctreeNodeContext()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FOctreeNodeContext(uint32 InInCullBits, uint32 InOutCullBits) : InCullBits(InInCullBits) , OutCullBits(InOutCullBits)"
  },
  {
    "label": "FOctreeNodeContext()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FOctreeNodeContext(const FBoxCenterAndExtent& InBounds) : Bounds(InBounds)"
  },
  {
    "label": "TightChildExtent()",
    "kind": "Method",
    "detail": "Function (const FReal TightChildExtent = Bounds . Extent . X* 0 . 5 f ; const FReal LooseChildExtent =)",
    "insertText": "TightChildExtent(1.0f + 1.0f / (FReal)LoosenessDenominator)"
  },
  {
    "label": "FOctreeNodeContext()",
    "kind": "Method",
    "detail": "Function (ChildExtent = LooseChildExtent ; ChildCenterOffset = Bounds . Extent . X - LooseChildExtent ; })",
    "insertText": "FOctreeNodeContext(const FBoxCenterAndExtent& InBounds, uint32 InInCullBits, uint32 InOutCullBits) : Bounds(InBounds) , InCullBits(InInCullBits) , OutCullBits(InOutCullBits)"
  },
  {
    "label": "GetChildOffsetVec()",
    "kind": "Method",
    "detail": "Function (ChildExtent = LooseChildExtent ; ChildCenterOffset = Bounds . Extent . X - LooseChildExtent ; } VectorRegister)",
    "insertText": "GetChildOffsetVec(int i)"
  },
  {
    "label": "MaskType()",
    "kind": "Method",
    "detail": "Function (union MaskType { VectorRegister4Float v ; VectorRegister4Int i ; # if PLATFORM_HOLOLENS)",
    "insertText": "MaskType() : v(MakeVectorRegister(0.0f, 0.0f, 0.0f, 0.0f))"
  },
  {
    "label": "MakeVectorRegister()",
    "kind": "Method",
    "detail": "Function (} # endif } Mask ; Mask . v =)",
    "insertText": "MakeVectorRegister(1u, 2u, 4u, 8u)"
  },
  {
    "label": "VectorIntLoad1()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Int X =)",
    "insertText": "VectorIntLoad1(&i)"
  },
  {
    "label": "VectorIntAnd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Int A =)",
    "insertText": "VectorIntAnd(X, Mask.i)"
  },
  {
    "label": "VectorIntCompareEQ()",
    "kind": "Method",
    "detail": "Function (Mask . i =)",
    "insertText": "VectorIntCompareEQ(Mask.i, A)"
  },
  {
    "label": "GetChildContext()",
    "kind": "Method",
    "detail": "Function (} FOctreeNodeContext)",
    "insertText": "GetChildContext(FOctreeChildNodeRef ChildRef)"
  },
  {
    "label": "MakeVectorRegister()",
    "kind": "Method",
    "detail": "Function (FBoxCenterAndExtent LocalBounds ; VectorRegister ZeroW =)",
    "insertText": "MakeVectorRegister(1.0f, 1.0f, 1.0f, 0.0f)"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreAligned(VectorMultiply(ZeroW, VectorAdd(VectorLoadAligned(&Bounds.Center), GetChildOffsetVec(ChildRef.Index))), &(LocalBounds.Center.X))"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreAligned(VectorMultiply(ZeroW, VectorSetFloat1(ChildExtent)), &(LocalBounds.Extent.X))"
  },
  {
    "label": "GetChildContext()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetChildContext(FOctreeChildNodeRef ChildRef, FOctreeNodeContext* ChildContext)"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreAligned(VectorMultiply(ZeroW, VectorAdd(VectorLoadAligned(&Bounds.Center), GetChildOffsetVec(ChildRef.Index))), &(ChildContext->Bounds.Center.X))"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreAligned(VectorMultiply(ZeroW, VectorSetFloat1(ChildExtent)), &(ChildContext->Bounds.Extent.X))"
  },
  {
    "label": "GetChildContext()",
    "kind": "Method",
    "detail": "Function (ChildContext -> ChildExtent = LooseChildExtent ; ChildContext -> ChildCenterOffset = ChildExtent - LooseChildExtent ; } FOctreeNodeContext)",
    "insertText": "GetChildContext(FOctreeChildNodeRef ChildRef, uint32 InInCullBits, uint32 InOutCullBits)"
  },
  {
    "label": "GetIntersectingChildren()",
    "kind": "Method",
    "detail": "Function (} FOctreeChildNodeSubset)",
    "insertText": "GetIntersectingChildren(const FBoxCenterAndExtent& BoundingBox)"
  },
  {
    "label": "GetContainingChild()",
    "kind": "Method",
    "detail": "Function (FOctreeChildNodeRef)",
    "insertText": "GetContainingChild(const FBoxCenterAndExtent& BoundingBox)"
  },
  {
    "label": "DECLARE_LOG_CATEGORY_EXTERN()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "DECLARE_LOG_CATEGORY_EXTERN(LogGenericOctree, Log, All)"
  },
  {
    "label": "IsLeaf()",
    "kind": "Method",
    "detail": "Function (template<ElementType,OctreeSemantics> class TOctree2 { using ElementArrayType = TArray<ElementType,OctreeSemantics::ElementAllocator> ; public : using FNodeIndex = uint32 ; using FReal = FVector::FReal ; private : struct FNode { FNodeIndex ChildNodes = INDEX_NONE ; uint32 InclusiveNumElements = 0 ; bool)",
    "insertText": "IsLeaf()"
  },
  {
    "label": "FFreeList()",
    "kind": "Method",
    "detail": "Function (class FFreeList { struct FSpan { FNodeIndex Start ; FNodeIndex End ; } ; TArray<FSpan> FreeList ; public :)",
    "insertText": "FFreeList()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Push(FNodeIndex NodeIndex)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int Index = 1 ; int Size = FreeList .)",
    "insertText": "Num()"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (const int LeftoverSize = Size % 2 ; Size = Size / 2 ; const int CheckIndex = Index + Size ; const int IndexIfLess = CheckIndex + LeftoverSize ; Index = FreeList [ CheckIndex ] . Start> NodeIndex ? IndexIfLess : Index ; } int ArrayEnd =)",
    "insertText": "Min(Index + Size + 1, FreeList.Num())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } Index + + ; })",
    "insertText": "if(Index < FreeList.Num() && FreeList[Index].End + 1 == NodeIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FreeList [ Index ] . End = NodeIndex ;)",
    "insertText": "if(FreeList[Index - 1].Start - 1 == NodeIndex)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (FreeList [ Index - 1 ] . Start = FreeList [ Index ] . Start ; FreeList .)",
    "insertText": "RemoveAt(Index)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (FreeList [ Index - 1 ] . Start = NodeIndex ; return ; } FreeList .)",
    "insertText": "Insert(FSpan{ NodeIndex , NodeIndex }, Index)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (} FNodeIndex)",
    "insertText": "Pop()"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (FSpan& Span = FreeList .)",
    "insertText": "Last()"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (FNodeIndex Index = Span . Start ;)",
    "insertText": "checkSlow(Index != INDEX_NONE)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (FreeList .)",
    "insertText": "Reset(1)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (FreeList .)",
    "insertText": "Push(FSpan{ INDEX_NONE, INDEX_NONE })"
  },
  {
    "label": "AllocateEightNodes()",
    "kind": "Method",
    "detail": "Function (} } ; TArray<FNodeIndex> FreeList ; FVector::FReal MinLeafExtent ; FNodeIndex)",
    "insertText": "AllocateEightNodes()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FNodeIndex Index = INDEX_NONE ;)",
    "insertText": "if(FreeList.Num())"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Index(FreeList.Pop() * 8)"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (} else { Index = TreeNodes .)",
    "insertText": "AddDefaulted(8)"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (ParentLinks .)",
    "insertText": "AddDefaulted()"
  },
  {
    "label": "FreeEightNodes()",
    "kind": "Method",
    "detail": "Function (} return Index ; } void)",
    "insertText": "FreeEightNodes(FNodeIndex Index)"
  },
  {
    "label": "FNode()",
    "kind": "Method",
    "detail": "Function (TreeNodes [ Index + i ] =)",
    "insertText": "FNode()"
  },
  {
    "label": "ParentLinks()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ParentLinks(Index - 1)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (FreeList .)",
    "insertText": "Push((Index - 1) / 8)"
  },
  {
    "label": "AddElementInternal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddElementInternal(FNodeIndex CurrentNodeIndex, const FOctreeNodeContext& NodeContext, const FBoxCenterAndExtent& ElementBounds, typename TCallTraits<ElementType>::ConstReference Element, ElementArrayType& TempElementStorage)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TreeNodes [ CurrentNodeIndex ] . InclusiveNumElements + + ;)",
    "insertText": "if(TreeNodes[CurrentNodeIndex].IsLeaf())"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (TempElementStorage =)",
    "insertText": "MoveTemp(TreeElements[CurrentNodeIndex])"
  },
  {
    "label": "ParentLinks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParentLinks(ChildStartIndex - 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TreeNodes [ CurrentNodeIndex ] . ChildNodes = ChildStartIndex ; TreeNodes [ CurrentNodeIndex ] . InclusiveNumElements = 0 ;)",
    "insertText": "for(typename TCallTraits<ElementType>::ConstReference ChildElement : TempElementStorage)"
  },
  {
    "label": "ChildElementBounds()",
    "kind": "Method",
    "detail": "Function (const FBoxCenterAndExtent)",
    "insertText": "ChildElementBounds(OctreeSemantics::GetBoundingBox(ChildElement))"
  },
  {
    "label": "AddElementInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElementInternal(CurrentNodeIndex, NodeContext, ChildElementBounds, ChildElement, TempElementStorage)"
  },
  {
    "label": "AddElementInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElementInternal(CurrentNodeIndex, NodeContext, ElementBounds, Element, TempElementStorage)"
  },
  {
    "label": "SetElementId()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElementId(Element, FOctreeElementId2(CurrentNodeIndex, ElementIndex))"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (int ElementIndex = TreeElements [ CurrentNodeIndex ] .)",
    "insertText": "Emplace(Element)"
  },
  {
    "label": "AddElementInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElementInternal(ChildNodeIndex, ChildNodeContext, ElementBounds, Element, TempElementStorage)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (CollapsedNodeElements .)",
    "insertText": "Append(MoveTemp(TreeElements[CurrentNodeIndex]))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FNodeIndex ChildStartIndex = TreeNodes [ CurrentNodeIndex ] . ChildNodes ;)",
    "insertText": "for(int8 i = 0; i < 8; i++)"
  },
  {
    "label": "CollapseNodesInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CollapseNodesInternal(ChildStartIndex + i, CollapsedNodeElements)"
  },
  {
    "label": "FreeEightNodes()",
    "kind": "Method",
    "detail": "Function (} TreeNodes [ CurrentNodeIndex ] . ChildNodes = INDEX_NONE ;)",
    "insertText": "FreeEightNodes(ChildStartIndex)"
  },
  {
    "label": "FindNodesWithPredicateInternal()",
    "kind": "Method",
    "detail": "Function (} } template<PredicateFunc,IterateFunc> void)",
    "insertText": "FindNodesWithPredicateInternal(FNodeIndex ParentNodeIndex, FNodeIndex CurrentNodeIndex, const FOctreeNodeContext& NodeContext, const PredicateFunc& Predicate, const IterateFunc& Func)"
  },
  {
    "label": "Func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Func(ParentNodeIndex, CurrentNodeIndex, NodeContext.Bounds)"
  },
  {
    "label": "FindNodesWithPredicateInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindNodesWithPredicateInternal(CurrentNodeIndex, ChildStartIndex + i, NodeContext.GetChildContext(FOctreeChildNodeRef(i)), Predicate, Func)"
  },
  {
    "label": "FindElementsWithBoundsTestInternal()",
    "kind": "Method",
    "detail": "Function (} } } } } template<IterateFunc> void)",
    "insertText": "FindElementsWithBoundsTestInternal(FNodeIndex CurrentNodeIndex, const FOctreeNodeContext& NodeContext, const FBoxCenterAndExtent& BoxBounds, const IterateFunc& Func)"
  },
  {
    "label": "Func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Func(Element)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(!TreeNodes[CurrentNodeIndex].IsLeaf())"
  },
  {
    "label": "GetIntersectingChildren()",
    "kind": "Method",
    "detail": "Function (const FOctreeChildNodeSubset IntersectingChildSubset = NodeContext .)",
    "insertText": "GetIntersectingChildren(BoxBounds)"
  },
  {
    "label": "FindElementsWithBoundsTestInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindElementsWithBoundsTestInternal(ChildStartIndex + i, NodeContext.GetChildContext(FOctreeChildNodeRef(i)), BoxBounds, Func)"
  },
  {
    "label": "FindFirstElementWithBoundsTestInternal()",
    "kind": "Method",
    "detail": "Function (} } } } } template<IterateFunc> void)",
    "insertText": "FindFirstElementWithBoundsTestInternal(FNodeIndex CurrentNodeIndex, const FOctreeNodeContext& NodeContext, const FBoxCenterAndExtent& BoxBounds, const IterateFunc& Func, bool& ContinueTraversal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TCallTraits<ElementType>::ConstReference Element = TreeElements [ CurrentNodeIndex ] [ Index ] ;)",
    "insertText": "if(Intersect(OctreeSemantics::GetBoundingBox(Element), BoxBounds))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(ContinueTraversal && !TreeNodes[CurrentNodeIndex].IsLeaf())"
  },
  {
    "label": "FindFirstElementWithBoundsTestInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindFirstElementWithBoundsTestInternal(ChildStartIndex + i, NodeContext.GetChildContext(FOctreeChildNodeRef(i)), BoxBounds, Func, ContinueTraversal)"
  },
  {
    "label": "FindNearbyElementsInternal()",
    "kind": "Method",
    "detail": "Function (} } } } } template<IterateFunc> void)",
    "insertText": "FindNearbyElementsInternal(FNodeIndex CurrentNodeIndex, const FOctreeNodeContext& NodeContext, const FBoxCenterAndExtent& BoxBounds, const IterateFunc& Func)"
  },
  {
    "label": "Func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Func(TreeElements[CurrentNodeIndex][Index])"
  },
  {
    "label": "GetContainingChild()",
    "kind": "Method",
    "detail": "Function (FOctreeChildNodeRef ChildRef = NodeContext .)",
    "insertText": "GetContainingChild(BoxBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FNodeIndex ChildStartIndex = TreeNodes [ CurrentNodeIndex ] . ChildNodes ;)",
    "insertText": "if(TreeNodes[ChildStartIndex + ChildRef.Index].InclusiveNumElements > 0)"
  },
  {
    "label": "FindNearbyElementsInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindNearbyElementsInternal(ChildStartIndex + ChildRef.Index, NodeContext.GetChildContext(ChildRef), BoxBounds, Func)"
  },
  {
    "label": "FindNearbyElementsInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindNearbyElementsInternal(ChildStartIndex + i, NodeContext.GetChildContext(FOctreeChildNodeRef(i)), BoxBounds, Func)"
  },
  {
    "label": "GetNumNodes()",
    "kind": "Method",
    "detail": "Function (} } } } } } public : int32)",
    "insertText": "GetNumNodes()"
  },
  {
    "label": "FindAllElements()",
    "kind": "Method",
    "detail": "Function (} template<IterateAllElementsFunc> void)",
    "insertText": "FindAllElements(const IterateAllElementsFunc& Func)"
  },
  {
    "label": "FindNodesWithPredicate()",
    "kind": "Method",
    "detail": "Function (} } } template<PredicateFunc,IterateFunc> void)",
    "insertText": "FindNodesWithPredicate(const PredicateFunc& Predicate, const IterateFunc& Func)"
  },
  {
    "label": "FindNodesWithPredicateInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindNodesWithPredicateInternal(INDEX_NONE, 0, RootNodeContext, Predicate, Func)"
  },
  {
    "label": "FindElementsWithPredicate()",
    "kind": "Method",
    "detail": "Function (} template<PredicateFunc,IterateFunc> void)",
    "insertText": "FindElementsWithPredicate(const PredicateFunc& Predicate, const IterateFunc& Func)"
  },
  {
    "label": "FindNodesWithPredicateInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindNodesWithPredicateInternal(INDEX_NONE, 0, RootNodeContext, Predicate, [&Func, this](FNodeIndex , FNodeIndex NodeIndex, const FBoxCenterAndExtent& ) { for (typename TCallTraits<ElementType>::ConstReference Element : TreeElements[NodeIndex]) { Func(NodeIndex, Element); } })"
  },
  {
    "label": "FindElementsWithBoundsTest()",
    "kind": "Method",
    "detail": "Function (} template<IterateBoundsFunc> void)",
    "insertText": "FindElementsWithBoundsTest(const FBoxCenterAndExtent& BoxBounds, const IterateBoundsFunc& Func)"
  },
  {
    "label": "FindElementsWithBoundsTestInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindElementsWithBoundsTestInternal(0, RootNodeContext, BoxBounds, Func)"
  },
  {
    "label": "FindFirstElementWithBoundsTest()",
    "kind": "Method",
    "detail": "Function (} template<IterateBoundsFunc> void)",
    "insertText": "FindFirstElementWithBoundsTest(const FBoxCenterAndExtent& BoxBounds, const IterateBoundsFunc& Func)"
  },
  {
    "label": "FindFirstElementWithBoundsTestInternal()",
    "kind": "Method",
    "detail": "Function (bool ContinueTraversal = true ;)",
    "insertText": "FindFirstElementWithBoundsTestInternal(0, RootNodeContext, BoxBounds, Func, ContinueTraversal)"
  },
  {
    "label": "FindNearbyElements()",
    "kind": "Method",
    "detail": "Function (} template<IterateBoundsFunc> void)",
    "insertText": "FindNearbyElements(const FVector& Position, const IterateBoundsFunc& Func)"
  },
  {
    "label": "FindNearbyElementsInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindNearbyElementsInternal(0, RootNodeContext, FBoxCenterAndExtent(Position, FVector::ZeroVector), Func)"
  },
  {
    "label": "AddElement()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddElement(typename TCallTraits<ElementType>::ConstReference Element)"
  },
  {
    "label": "ElementBounds()",
    "kind": "Method",
    "detail": "Function (ElementArrayType TempElementStorage ; const FBoxCenterAndExtent)",
    "insertText": "ElementBounds(OctreeSemantics::GetBoundingBox(Element))"
  },
  {
    "label": "AddElementInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElementInternal(0, RootNodeContext, ElementBounds, Element, TempElementStorage)"
  },
  {
    "label": "RemoveElement()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveElement(FOctreeElementId2 ElementId)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (TreeElements [ ElementId . NodeIndex ] .)",
    "insertText": "RemoveAtSwap(ElementId.ElementIndex, EAllowShrinking::No)"
  },
  {
    "label": "SetElementId()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElementId(TreeElements[ElementId.NodeIndex][ElementId.ElementIndex], ElementId)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} FNodeIndex CollapseNodeIndex = INDEX_NONE ; { FNodeIndex NodeIndex = ElementId . NodeIndex ;)",
    "insertText": "while(true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TreeNodes [ NodeIndex ] . InclusiveNumElements - - ;)",
    "insertText": "if(TreeNodes[NodeIndex].InclusiveNumElements < OctreeSemantics::MinInclusiveElementsPerNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CollapseNodeIndex = NodeIndex ; })",
    "insertText": "if(NodeIndex == 0)"
  },
  {
    "label": "ParentLinks()",
    "kind": "Method",
    "detail": "Function (break ; } NodeIndex =)",
    "insertText": "ParentLinks(NodeIndex - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(CollapseNodeIndex != INDEX_NONE && !TreeNodes[CollapseNodeIndex].IsLeaf())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (ElementArrayType TempElementStorage ; TempElementStorage .)",
    "insertText": "Reserve(TreeNodes[CollapseNodeIndex].InclusiveNumElements)"
  },
  {
    "label": "CollapseNodesInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CollapseNodesInternal(CollapseNodeIndex, TempElementStorage)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (TreeElements [ CollapseNodeIndex ] =)",
    "insertText": "MoveTemp(TempElementStorage)"
  },
  {
    "label": "SetElementId()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElementId(TreeElements[CollapseNodeIndex][ElementIndex], FOctreeElementId2(CollapseNodeIndex, ElementIndex))"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "Destroy()"
  },
  {
    "label": "GetElementById()",
    "kind": "Method",
    "detail": "Function (} ElementType&)",
    "insertText": "GetElementById(FOctreeElementId2 ElementId)"
  },
  {
    "label": "GetElementsForNode()",
    "kind": "Method",
    "detail": "Function (} ; TArrayView<const ElementType>)",
    "insertText": "GetElementsForNode(FNodeIndex NodeIndex)"
  },
  {
    "label": "FindNodesWithPredicateInternal()",
    "kind": "Method",
    "detail": "Function (int32 NumNodes = 0 ; int32 NumLeaves = 0 ; int32 NumElements = 0 ; int32 MaxElementsPerNode = 0 ; TArray<int32> NodeElementDistribution ;)",
    "insertText": "FindNodesWithPredicateInternal(INDEX_NONE, 0, RootNodeContext, [](FNodeIndex , FNodeIndex , const FBoxCenterAndExtent&) { return true; }, [&, this](FNodeIndex , FNodeIndex NodeIndex, const FBoxCenterAndExtent&) { const int32 CurrentNodeElementCount = GetElementsForNode(NodeIndex).Num(); NumNodes++; if (TreeNodes[NodeIndex].IsLeaf()) { NumLeaves++; } NumElements += CurrentNodeElementCount; MaxElementsPerNode = FMath::Max(MaxElementsPerNode, CurrentNodeElementCount); if (CurrentNodeElementCount >= NodeElementDistribution.Num()) { NodeElementDistribution.AddZeroed(CurrentNodeElementCount - NodeElementDistribution.Num() + 1); } NodeElementDistribution[CurrentNodeElementCount]++; })"
  },
  {
    "label": "GetSizeBytes()",
    "kind": "Method",
    "detail": "Function (} } } SIZE_T)",
    "insertText": "GetSizeBytes()"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (SIZE_T TotalSizeBytes = TreeNodes .)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (TotalSizeBytes + = TreeNodes [ 0 ] . InclusiveNumElements*)",
    "insertText": "sizeof(ElementType)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (const int32 ClampedLevel = FMath::Clamp<)",
    "insertText": "uint32(Level, 0, OctreeSemantics::MaxNodeDepth)"
  },
  {
    "label": "GetRootBounds()",
    "kind": "Method",
    "detail": "Function (} FBoxCenterAndExtent)",
    "insertText": "GetRootBounds()"
  },
  {
    "label": "Shrink()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Shrink()"
  },
  {
    "label": "ApplyOffset()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ApplyOffset(const FVector& InOffset, bool bGlobalOctree = false)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (ElementArrayType TempElementStorage ; TempElementStorage .)",
    "insertText": "Reserve(TreeNodes[0].InclusiveNumElements)"
  },
  {
    "label": "CollapseNodesInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CollapseNodesInternal(0, TempElementStorage)"
  },
  {
    "label": "FVector4()",
    "kind": "Method",
    "detail": "Function (RootNodeContext . Bounds . Center + =)",
    "insertText": "FVector4(InOffset, 0.0f)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(ElementType& Element : TempElementStorage)"
  },
  {
    "label": "ApplyOffset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyOffset(Element, InOffset)"
  },
  {
    "label": "AddElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElement(Element)"
  },
  {
    "label": "TOctree2()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TOctree2(const FVector& InOrigin,FVector::FReal InExtent) : RootNodeContext(FBoxCenterAndExtent(InOrigin, FVector(InExtent, InExtent, InExtent)), 0, 0) , MinLeafExtent(InExtent* FMath::Pow((1.0f + 1.0f / (FReal)FOctreeNodeContext::LoosenessDenominator) / 2.0f, FReal(OctreeSemantics::MaxNodeDepth)))"
  },
  {
    "label": "TOctree2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TOctree2()"
  },
  {
    "label": "Requires()",
    "kind": "Method",
    "detail": "Function (} private : struct COctreeSemanticsV2 { template<Semantics> auto)",
    "insertText": "Requires(typename Semantics::FOctree& OctreeInstance, const ElementType& Element, FOctreeElementId2 Id) -> decltype(Semantics::SetElementId(OctreeInstance, Element, Id))"
  },
  {
    "label": "SetOctreeSemanticsElementId()",
    "kind": "Method",
    "detail": "Function (} ; template<Semantics> void)",
    "insertText": "SetOctreeSemanticsElementId(const ElementType& Element, FOctreeElementId2 Id)"
  },
  {
    "label": "SetElementId()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElementId(static_cast<typename Semantics::FOctree&>(*this), Element, Id)"
  },
  {
    "label": "SetElementId()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "SetElementId(Element, Id)"
  },
  {
    "label": "SetElementId()",
    "kind": "Method",
    "detail": "Function (} } protected : void)",
    "insertText": "SetElementId(const ElementType& Element, FOctreeElementId2 Id)"
  },
  {
    "label": "OctreeSemantics()",
    "kind": "Method",
    "detail": "Function (SetOctreeSemanticsElementId<)",
    "insertText": "OctreeSemantics(Element, Id)"
  },
  {
    "label": "FNode()",
    "kind": "Method",
    "detail": "Function (} } ; template<ElementType,OctreeSemantics> class TOctree_DEPRECATED { public : using FReal = FVector4::FReal ; typedef TArray<ElementType,OctreeSemantics::ElementAllocator> ElementArrayType ; typedef ElementArrayType::TConstIterator ElementConstIt ; class FNode { public : class TOctree_DEPRECATED ;)",
    "insertText": "FNode(const FNode* InParent) : Parent(InParent) , InclusiveNumElements(0) , bIsLeaf(true)"
  },
  {
    "label": "GetElementIt()",
    "kind": "Method",
    "detail": "Function (delete Children [ ChildRef . Index ] ; } } ElementConstIt)",
    "insertText": "GetElementIt()"
  },
  {
    "label": "GetInclusiveElementCount()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetInclusiveElementCount()"
  },
  {
    "label": "ShrinkElements()",
    "kind": "Method",
    "detail": "Function (Children [ ChildRef . Index ] ->)",
    "insertText": "ShrinkElements()"
  },
  {
    "label": "ApplyOffset()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "ApplyOffset(const FVector& InOffset)"
  },
  {
    "label": "FOREACH_OCTREE_CHILD_NODE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FOREACH_OCTREE_CHILD_NODE(ChildRef)"
  },
  {
    "label": "ApplyOffset()",
    "kind": "Method",
    "detail": "Function (Children [ ChildRef . Index ] ->)",
    "insertText": "ApplyOffset(InOffset)"
  },
  {
    "label": "FNodeReference()",
    "kind": "Method",
    "detail": "Function (} } } private : ElementArrayType Elements ; const FNode* Parent ; FNode* Children [ 8 ] ; uint32 InclusiveNumElements : 3 1 ; uint32 bIsLeaf : 1 ; } ; class FNodeReference { public : const FNode* Node ; FOctreeNodeContext Context ;)",
    "insertText": "FNodeReference() : Node(NULL), Context()"
  },
  {
    "label": "FNodeReference()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FNodeReference(const FNode* InNode, const FOctreeNodeContext& InContext) : Node(InNode), Context(InContext)"
  },
  {
    "label": "TInlineAllocator()",
    "kind": "Method",
    "detail": "Function (} } ; typedef)",
    "insertText": "TInlineAllocator(14 - 1)"
  },
  {
    "label": "PushChild()",
    "kind": "Method",
    "detail": "Function (template<StackAllocator = DefaultStackAllocator> class TConstIterator { public : void)",
    "insertText": "PushChild(FOctreeChildNodeRef ChildRef)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (FNodeReference* NewNode =)",
    "insertText": "new(NodeStack)"
  },
  {
    "label": "GetChild()",
    "kind": "Method",
    "detail": "Function (NewNode -> Node = CurrentNode . Node ->)",
    "insertText": "GetChild(ChildRef)"
  },
  {
    "label": "GetChildContext()",
    "kind": "Method",
    "detail": "Function (CurrentNode . Context .)",
    "insertText": "GetChildContext(ChildRef, &NewNode->Context)"
  },
  {
    "label": "PushChild()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PushChild(FOctreeChildNodeRef ChildRef, uint32 FullyInsideView, uint32 FullyOutsideView)"
  },
  {
    "label": "PushChild()",
    "kind": "Method",
    "detail": "Function (NewNode -> Context . InCullBits = FullyInsideView ; NewNode -> Context . OutCullBits = FullyOutsideView ; } void)",
    "insertText": "PushChild(FOctreeChildNodeRef ChildRef, const FOctreeNodeContext& Context)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(NodeStack) FNodeReference(CurrentNode.Node->GetChild(ChildRef), Context)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (NodeStack .)",
    "insertText": "RemoveAt(NodeStack.Num() - 1)"
  },
  {
    "label": "FNodeReference()",
    "kind": "Method",
    "detail": "Function (} else { CurrentNode =)",
    "insertText": "FNodeReference()"
  },
  {
    "label": "HasPendingNodes()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "HasPendingNodes()"
  },
  {
    "label": "TConstIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TConstIterator(const FNode& Node, const FOctreeNodeContext& Context) : CurrentNode(FNodeReference(&Node, Context))"
  },
  {
    "label": "GetCurrentNode()",
    "kind": "Method",
    "detail": "Function (} const FNode&)",
    "insertText": "GetCurrentNode()"
  },
  {
    "label": "AdvanceToNextIntersectingElement()",
    "kind": "Method",
    "detail": "Function (+ + ElementIt ;)",
    "insertText": "AdvanceToNextIntersectingElement()"
  },
  {
    "label": "HasPendingElements()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasPendingElements()"
  },
  {
    "label": "TConstElementBoxIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TConstElementBoxIterator(const TOctree_DEPRECATED& Tree, const FBoxCenterAndExtent& InBoundingBox) : IteratorBounds(InBoundingBox) , NodeIt(Tree) , ElementIt(Tree.RootNode.GetElementIt())"
  },
  {
    "label": "ProcessChildren()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessChildren()"
  },
  {
    "label": "GetCurrentElement()",
    "kind": "Method",
    "detail": "Function (} const ElementType&)",
    "insertText": "GetCurrentElement()"
  },
  {
    "label": "GetCurrentContext()",
    "kind": "Method",
    "detail": "Function (const FOctreeNodeContext& Context = NodeIt .)",
    "insertText": "GetCurrentContext()"
  },
  {
    "label": "GetIntersectingChildren()",
    "kind": "Method",
    "detail": "Function (const FOctreeChildNodeSubset IntersectingChildSubset = Context .)",
    "insertText": "GetIntersectingChildren(IteratorBounds)"
  },
  {
    "label": "PushChild()",
    "kind": "Method",
    "detail": "Function (NodeIt .)",
    "insertText": "PushChild(ChildRef)"
  },
  {
    "label": "LocalElementIt()",
    "kind": "Method",
    "detail": "Function (ElementConstIt)",
    "insertText": "LocalElementIt(ElementIt)"
  },
  {
    "label": "Prefetch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Prefetch(&(*LocalElementIt))"
  },
  {
    "label": "Prefetch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Prefetch(&(*LocalElementIt), PLATFORM_CACHE_LINE_SIZE)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Move(ElementIt, LocalElementIt)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Move(ElementIt, NodeIt.GetCurrentNode().GetElementIt())"
  },
  {
    "label": "AddElement()",
    "kind": "Method",
    "detail": "Function (} } } ; void)",
    "insertText": "AddElement(typename TTypeTraits<ElementType>::ConstInitType Element)"
  },
  {
    "label": "AddElementToNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElementToNode(Element, RootNode, RootNodeContext)"
  },
  {
    "label": "RemoveElement()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveElement(FOctreeElementId ElementId)"
  },
  {
    "label": "ElementIdNode()",
    "kind": "Method",
    "detail": "Function (FNode*)",
    "insertText": "ElementIdNode(FNode*)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (ElementIdNode -> Elements .)",
    "insertText": "RemoveAtSwap(ElementId.ElementIndex)"
  },
  {
    "label": "SetOctreeMemoryUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOctreeMemoryUsage(this, TotalSizeBytes - sizeof(ElementType))"
  },
  {
    "label": "SetElementId()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElementId(ElementIdNode->Elements[ElementId.ElementIndex], ElementId)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} const FNode* CollapseNode = NULL ;)",
    "insertText": "for(const FNode* Node = ElementIdNode; Node; Node = Node->Parent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - Node -> InclusiveNumElements ;)",
    "insertText": "if(Node->InclusiveNumElements < OctreeSemantics::MinInclusiveElementsPerNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CollapseNode = Node ; } })",
    "insertText": "if(CollapseNode && !CollapseNode->bIsLeaf)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (CollapseNode -> Elements .)",
    "insertText": "Reserve(CollapseNode->InclusiveNumElements)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (const int32 NewElementIndex = CollapseNode -> Elements .)",
    "insertText": "Add(MoveTemp(Element))"
  },
  {
    "label": "SetElementId()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElementId(CollapseNode->Elements[NewElementIndex], FOctreeElementId(CollapseNode, NewElementIndex))"
  },
  {
    "label": "SetOctreeMemoryUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOctreeMemoryUsage(this, TotalSizeBytes - sizeof(*CollapseNode->Children[ChildRef.Index]))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&RootNode) FNode(NULL)"
  },
  {
    "label": "SetOctreeMemoryUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOctreeMemoryUsage(this, 0)"
  },
  {
    "label": "GetElementById()",
    "kind": "Method",
    "detail": "Function (} ElementType&)",
    "insertText": "GetElementById(FOctreeElementId ElementId)"
  },
  {
    "label": "DumpStats()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "DumpStats()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 NumNodes = 0 ; int32 NumLeaves = 0 ; int32 NumElements = 0 ; int32 MaxElementsPerNode = 0 ; TArray<int32> NodeElementDistribution ;)",
    "insertText": "for(TConstIterator<> NodeIt(*this); NodeIt.HasPendingNodes(); NodeIt.Advance())"
  },
  {
    "label": "GetElementCount()",
    "kind": "Method",
    "detail": "Function (const int32 CurrentNodeElementCount = CurrentNode .)",
    "insertText": "GetElementCount()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NumNodes + + ;)",
    "insertText": "if(CurrentNode.IsLeaf())"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (NumLeaves + + ; } NumElements + = CurrentNodeElementCount ; MaxElementsPerNode =)",
    "insertText": "Max(MaxElementsPerNode, CurrentNodeElementCount)"
  },
  {
    "label": "AddZeroed()",
    "kind": "Method",
    "detail": "Function (NodeElementDistribution .)",
    "insertText": "AddZeroed(CurrentNodeElementCount - NodeElementDistribution.Num() + 1)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "UE_LOG(LogGenericOctree, Log, TEXT(\"Octree overview:\"))"
  },
  {
    "label": "ApplyOffset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ApplyOffset(const FVector& InOffset, bool bGlobalOctree)"
  },
  {
    "label": "FNode()",
    "kind": "Method",
    "detail": "Function (FNode OldRootNode = RootNode ; RootNode =)",
    "insertText": "FNode(nullptr)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(TConstIterator<> NodeIt(OldRootNode, RootNodeContext); NodeIt.HasPendingNodes(); NodeIt.Advance())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(auto ElementIt = CurrentNode.GetElementIt(); ElementIt; ++ElementIt)"
  },
  {
    "label": "AddElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElement(*ElementIt)"
  },
  {
    "label": "TOctree_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "TOctree_DEPRECATED(const FVector& InOrigin, FReal InExtent) : RootNode(NULL) , RootNodeContext(FBoxCenterAndExtent(InOrigin, FVector(InExtent, InExtent, InExtent)), 0, 0) , MinLeafExtent(InExtent* FMath::Pow((1.0f + 1.0f / (FReal)FOctreeNodeContext::LoosenessDenominator) / 2.0f, FReal(OctreeSemantics::MaxNodeDepth))) , TotalSizeBytes(0)"
  },
  {
    "label": "TOctree_DEPRECATED()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TOctree_DEPRECATED() : RootNode(nullptr)"
  },
  {
    "label": "SetOctreeMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} private : FNode RootNode ; FOctreeNodeContext RootNodeContext ; FReal MinLeafExtent ; void)",
    "insertText": "SetOctreeMemoryUsage(TOctree_DEPRECATED<ElementType, OctreeSemantics>* Octree, int32 NewSize)"
  },
  {
    "label": "AddElementToNode()",
    "kind": "Method",
    "detail": "Function (Octree -> TotalSizeBytes = NewSize ; } SIZE_T TotalSizeBytes ; void)",
    "insertText": "AddElementToNode(typename TTypeTraits<ElementType>::ConstInitType Element, const FNode& InNode, const FOctreeNodeContext& InContext)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bAddElementToThisNode = false ; Node . InclusiveNumElements + + ;)",
    "insertText": "if(bIsLeaf)"
  },
  {
    "label": "Exchange()",
    "kind": "Method",
    "detail": "Function (ElementArrayType ChildElements ;)",
    "insertText": "Exchange(ChildElements, Node.Elements)"
  },
  {
    "label": "SetOctreeMemoryUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOctreeMemoryUsage(this, TotalSizeBytes - ChildElements.Num() * sizeof(ElementType))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Node . InclusiveNumElements = 0 ; Node . bIsLeaf = false ;)",
    "insertText": "for(ElementConstIt ElementIt(ChildElements); ElementIt; ++ElementIt)"
  },
  {
    "label": "AddElementToNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElementToNode(*ElementIt, Node, Context)"
  },
  {
    "label": "AddElementToNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AddElementToNode(Element, Node, Context)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bAddElementToThisNode = true ; } else {)",
    "insertText": "if(!Node.Children[ChildRef.Index])"
  },
  {
    "label": "FNode()",
    "kind": "Method",
    "detail": "Function (Node . Children [ ChildRef . Index ] = new TOctree_DEPRECATED<ElementType,OctreeSemantics)",
    "insertText": "FNode(&Node)"
  },
  {
    "label": "SetOctreeMemoryUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOctreeMemoryUsage(this, TotalSizeBytes + sizeof(*Node.Children[ChildRef.Index]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(bAddElementToThisNode)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(Node.Elements) ElementType(Element)"
  },
  {
    "label": "SetOctreeMemoryUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOctreeMemoryUsage(this, TotalSizeBytes + sizeof(ElementType))"
  },
  {
    "label": "SetElementId()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElementId(Element, FOctreeElementId(&Node, Node.Elements.Num() - 1))"
  },
  {
    "label": "Requires()",
    "kind": "Method",
    "detail": "Function (} struct COctreeSemanticsV2 { template<Semantics> auto)",
    "insertText": "Requires(typename Semantics::FOctree& OctreeInstance, const ElementType& Element, FOctreeElementId Id) -> decltype(Semantics::SetElementId(OctreeInstance, Element, Id))"
  },
  {
    "label": "SetOctreeSemanticsElementId()",
    "kind": "Method",
    "detail": "Function (} ; template<Semantics> void)",
    "insertText": "SetOctreeSemanticsElementId(const ElementType& Element, FOctreeElementId Id)"
  },
  {
    "label": "SetElementId()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetElementId(*this, Element, Id)"
  },
  {
    "label": "SetElementId()",
    "kind": "Method",
    "detail": "Function (} } protected : void)",
    "insertText": "SetElementId(const ElementType& Element, FOctreeElementId Id)"
  },
  {
    "label": "TOctree()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TOctree(const FVector& InOrigin, FVector::FReal InExtent) : TOctree_DEPRECATED<ElementType, OctreeSemantics>(InOrigin, InExtent)"
  },
  {
    "label": "TOctree()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TOctree() : TOctree_DEPRECATED<ElementType, OctreeSemantics>()"
  }
]