[
  {
    "label": "FStreamableHandle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStreamableHandle"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "TStreamableHandleContextDataTypeIDStorage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TStreamableHandleContextDataTypeIDStorage"
  },
  {
    "label": "TStreamableHandleContextData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TStreamableHandleContextData"
  },
  {
    "label": "FStreamableHandleContextDataBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStreamableHandleContextDataBase"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "FStreamableManager",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStreamableManager"
  },
  {
    "label": "FStreamable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStreamable"
  },
  {
    "label": "FRedirectedPath",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRedirectedPath"
  },
  {
    "label": "DECLARE_DELEGATE()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Containers / ArrayView . h \" # include \" Math / NumericLimits . h \" # include \" Misc / PackageAccessTracking . h \" # include \" Templates / Casts . h \" # include \" Templates / Function . h \" # include \" UObject / Class . h \" # include \" UObject / GCObject . h \" # include \" UObject / ObjectMacros . h \" # include \" UObject / SoftObjectPtr . h \" # include \" Misc / SourceLocation . h \" # include \" Misc / SourceLocationUtils . h \")",
    "insertText": "DECLARE_DELEGATE(FStreamableDelegate)"
  },
  {
    "label": "DECLARE_DELEGATE_OneParam()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_DELEGATE_OneParam(FStreamableUpdateDelegate, TSharedRef<struct FStreamableHandle>)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR enum class ECookLoadType : uint8 ; # endif typedef uint8 TStreamableHandleContextDataTypeID ; enum { TStreamableHandleContextDataTypeIDInvalid = TNumericLimits<TStreamableHandleContextDataTypeID)",
    "insertText": "Max()"
  },
  {
    "label": "GetInstanceTypeId()",
    "kind": "Method",
    "detail": "Function (struct TStreamableHandleContextDataTypeIDStorage { private : TStreamableHandleContextDataTypeID Value = TStreamableHandleContextDataTypeIDInvalid ; template<SubClassType> struct TStreamableHandleContextData ; } ; struct FStreamableHandleContextDataBase : public TSharedFromThis<FStreamableHandleContextDataBase,ESPMode::ThreadSafe> { TStreamableHandleContextDataTypeID)",
    "insertText": "GetInstanceTypeId()"
  },
  {
    "label": "FStreamableHandleContextDataBase()",
    "kind": "Method",
    "detail": "Function (} protected :)",
    "insertText": "FStreamableHandleContextDataBase(TStreamableHandleContextDataTypeID TypeId) : InstanceTypeId(TypeId)"
  },
  {
    "label": "AllocateClassTypeId()",
    "kind": "Method",
    "detail": "Function (} TStreamableHandleContextDataTypeID)",
    "insertText": "AllocateClassTypeId()"
  },
  {
    "label": "TStreamableHandleContextData()",
    "kind": "Method",
    "detail": "Function (private : TStreamableHandleContextDataTypeID InstanceTypeId ; } ; template<SubClassType> struct TStreamableHandleContextData : public FStreamableHandleContextDataBase {)",
    "insertText": "TStreamableHandleContextData() : FStreamableHandleContextDataBase(GetClassTypeId())"
  },
  {
    "label": "GetClassTypeId()",
    "kind": "Method",
    "detail": "Function (} TStreamableHandleContextDataTypeID)",
    "insertText": "GetClassTypeId()"
  },
  {
    "label": "TypeIdCrossModuleStorage()",
    "kind": "Method",
    "detail": "Function (TStreamableHandleContextDataTypeIDStorage& ClassTypeId =)",
    "insertText": "TypeIdCrossModuleStorage()"
  },
  {
    "label": "HasLoadCompleted()",
    "kind": "Method",
    "detail": "Function (} return ClassTypeId . Value ; } } ; struct FStreamableHandle : public TSharedFromThis<FStreamableHandle> { bool)",
    "insertText": "HasLoadCompleted()"
  },
  {
    "label": "SetDebugNameIfEmptyOrDefault()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDebugNameIfEmptyOrDefault(const FString& NewName)"
  },
  {
    "label": "GetDebugName()",
    "kind": "Method",
    "detail": "Function (const FString&)",
    "insertText": "GetDebugName()"
  },
  {
    "label": "CancelHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CancelHandle()"
  },
  {
    "label": "StartStalledHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartStalledHandle()"
  },
  {
    "label": "HasCompleteDelegate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasCompleteDelegate()"
  },
  {
    "label": "HasCancelDelegate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasCancelDelegate()"
  },
  {
    "label": "HasUpdateDelegate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasUpdateDelegate()"
  },
  {
    "label": "BindCompleteDelegate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "BindCompleteDelegate(FStreamableDelegate NewDelegate)"
  },
  {
    "label": "BindCancelDelegate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "BindCancelDelegate(FStreamableDelegate NewDelegate)"
  },
  {
    "label": "BindUpdateDelegate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "BindUpdateDelegate(FStreamableUpdateDelegate NewDelegate)"
  },
  {
    "label": "WaitUntilComplete()",
    "kind": "Method",
    "detail": "Function (EAsyncPackageState::Type)",
    "insertText": "WaitUntilComplete(float Timeout = 0.0f, bool bStartStalledHandles = true)"
  },
  {
    "label": "GetRequestedAssets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetRequestedAssets(TArray<FSoftObjectPath>& AssetList, bool bIncludeChildren = true)"
  },
  {
    "label": "GetLoadedAssets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetLoadedAssets(TArray<UObject *>& LoadedAssets)"
  },
  {
    "label": "GetLoadedAssets()",
    "kind": "Method",
    "detail": "Function (template<class T> void)",
    "insertText": "GetLoadedAssets(TArray<T*>& LoadedAssets)"
  },
  {
    "label": "GetLoadedAsset()",
    "kind": "Method",
    "detail": "Function (} UObject*)",
    "insertText": "GetLoadedAsset()"
  },
  {
    "label": "GetLoadedCount()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetLoadedCount(int32& LoadedCount, int32& RequestedCount)"
  },
  {
    "label": "ForEachLoadedAsset()",
    "kind": "Method",
    "detail": "Function (template<CallableT> void)",
    "insertText": "ForEachLoadedAsset(CallableT Callable)"
  },
  {
    "label": "GetProgress()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetProgress()"
  },
  {
    "label": "GetOwningManager()",
    "kind": "Method",
    "detail": "Function (struct FStreamableManager*)",
    "insertText": "GetOwningManager()"
  },
  {
    "label": "ExecuteDelegate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExecuteDelegate(const FStreamableDelegate& Delegate, TSharedPtr<FStreamableHandle> AssociatedHandle = nullptr, const FStreamableDelegate& CancelDelegate = FStreamableDelegate())"
  },
  {
    "label": "ExecuteDelegate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExecuteDelegate(FStreamableDelegate&& Delegate, TSharedPtr<FStreamableHandle> AssociatedHandle = nullptr, FStreamableDelegate&& CancelDelegate = FStreamableDelegate())"
  },
  {
    "label": "FindMatchingHandle()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<FStreamableHandle>)",
    "insertText": "FindMatchingHandle(TFunction<bool(const FStreamableHandle&)> Predicate)"
  },
  {
    "label": "CreateCombinedHandle()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<FStreamableHandle>)",
    "insertText": "CreateCombinedHandle(const TConstArrayView<TSharedPtr<FStreamableHandle>>& OtherHandles)"
  },
  {
    "label": "GetOutermostHandle()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<FStreamableHandle>)",
    "insertText": "GetOutermostHandle()"
  },
  {
    "label": "FindOrAddContextData()",
    "kind": "Method",
    "detail": "Function (template<T> T&)",
    "insertText": "FindOrAddContextData()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<T> FoundInternally = FindFirstContextDataOfType<)",
    "insertText": "T()"
  },
  {
    "label": "AddContextData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddContextData(FreshlyAdded)"
  },
  {
    "label": "AddContextData()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "AddContextData(const TSharedPtr<T>& NewData)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (AdditionalContextData .)",
    "insertText": "Add(NewData)"
  },
  {
    "label": "FindFirstContextDataOfType()",
    "kind": "Method",
    "detail": "Function (} template<T> TSharedPtr<T>)",
    "insertText": "FindFirstContextDataOfType()"
  },
  {
    "label": "GetContextDataOfType()",
    "kind": "Method",
    "detail": "Function (} } return nullptr ; } template<T> TArray<TSharedPtr<T>>)",
    "insertText": "GetContextDataOfType()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<TSharedPtr<T>> OfType ;)",
    "insertText": "for(const TSharedPtr<FStreamableHandleContextDataBase>& InternalPtr : AdditionalContextData)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OfType .)",
    "insertText": "Add(StaticCastSharedPtr<T>(InternalPtr))"
  },
  {
    "label": "FStreamableHandle()",
    "kind": "Method",
    "detail": "Function (} } return OfType ; } ~)",
    "insertText": "FStreamableHandle()"
  },
  {
    "label": "FStreamableHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FStreamableHandle(const FStreamableHandle&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FStreamableHandle&)",
    "insertText": "operator(const FStreamableHandle&)"
  },
  {
    "label": "IsHandleNameEmptyOrDefault()",
    "kind": "Method",
    "detail": "Function (const FString HandleDebugName_Preloading ; const FString HandleDebugName_AssetList ; const FString HandleDebugName_CombinedHandle ; private : struct FStreamableManager ; struct FStreamable ; bool)",
    "insertText": "IsHandleNameEmptyOrDefault()"
  },
  {
    "label": "CompleteLoad()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CompleteLoad()"
  },
  {
    "label": "AsyncLoadCallbackWrapper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AsyncLoadCallbackWrapper(const FName& PackageName, UPackage* LevelPackage, EAsyncLoadingResult::Type Result, FSoftObjectPath TargetName)"
  },
  {
    "label": "NotifyParentsOfCompletion()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NotifyParentsOfCompletion()"
  },
  {
    "label": "NotifyParentsOfCancellation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NotifyParentsOfCancellation()"
  },
  {
    "label": "UpdateCombinedHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateCombinedHandle()"
  },
  {
    "label": "CallUpdateDelegate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CallUpdateDelegate()"
  },
  {
    "label": "UnbindDelegates()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnbindDelegates()"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (} ; enum class EStreamableManagerCombinedHandleOptions : uint8 { None = 0,MergeDebugNames = 0 x01,RedirectParents = 0 x02,SkipNulls = 0 x04,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(EStreamableManagerCombinedHandleOptions)"
  },
  {
    "label": "RequestAsyncLoad()",
    "kind": "Method",
    "detail": "Function (struct FStreamableManager : public FGCObject { TAsyncLoadPriority DefaultAsyncLoadPriority = 0 ; TAsyncLoadPriority AsyncLoadHighPriority = 1 0 0 ; template<PathContainerType = TArray<FSoftObjectPath>,FuncType = FStreamableDelegate,DebugNameType = UE::FSourceLocation> TSharedPtr<FStreamableHandle>)",
    "insertText": "RequestAsyncLoad(PathContainerType&& TargetsToStream, FuncType&& DelegateToCall = FStreamableDelegate(), TAsyncLoadPriority Priority = DefaultAsyncLoadPriority, bool bManageActiveHandle = false, bool bStartStalled = false, DebugNameType&& DebugNameOrLocation = UE::FSourceLocation::Current())"
  },
  {
    "label": "RequestSyncLoad()",
    "kind": "Method",
    "detail": "Function (template<PathContainerType = TArray<FSoftObjectPath>,DebugNameType = UE::FSourceLocation> TSharedPtr<FStreamableHandle>)",
    "insertText": "RequestSyncLoad(PathContainerType&& TargetsToStream, bool bManageActiveHandle = false, DebugNameType&& DebugNameOrLocation = UE::FSourceLocation::Current())"
  },
  {
    "label": "LoadSynchronous()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "LoadSynchronous(const FSoftObjectPath& Target, bool bManageActiveHandle = false, TSharedPtr<FStreamableHandle>* RequestHandlePointer = nullptr, UE::FSourceLocation Location = UE::FSourceLocation::Current())"
  },
  {
    "label": "LoadSynchronous()",
    "kind": "Method",
    "detail": "Function (} template<T> T*)",
    "insertText": "LoadSynchronous(const TSoftObjectPtr<T>& Target, bool bManageActiveHandle = false, TSharedPtr<FStreamableHandle>* RequestHandlePointer = nullptr, UE::FSourceLocation Location = UE::FSourceLocation::Current())"
  },
  {
    "label": "LoadSynchronous()",
    "kind": "Method",
    "detail": "Function (} template<T> TSubclassOf<T>)",
    "insertText": "LoadSynchronous(const TSoftClassPtr<T>& Target, bool bManageActiveHandle = false, TSharedPtr<FStreamableHandle>* RequestHandlePointer = nullptr, UE::FSourceLocation Location = UE::FSourceLocation::Current())"
  },
  {
    "label": "UClass()",
    "kind": "Method",
    "detail": "Function (TSubclassOf<T> ReturnClass ; ReturnClass = Cast<)",
    "insertText": "UClass(LoadSynchronous(Target.ToSoftObjectPath(), bManageActiveHandle, RequestHandlePointer, MoveTemp(Location)))"
  },
  {
    "label": "GetActiveHandles()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetActiveHandles(const FSoftObjectPath& Target, TArray<TSharedRef<FStreamableHandle>>& HandleList, bool bOnlyManagedHandles = false)"
  },
  {
    "label": "AreAllAsyncLoadsComplete()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AreAllAsyncLoadsComplete()"
  },
  {
    "label": "IsAsyncLoadComplete()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAsyncLoadComplete(const FSoftObjectPath& Target)"
  },
  {
    "label": "Unload()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unload(const FSoftObjectPath& Target)"
  },
  {
    "label": "ResolveRedirects()",
    "kind": "Method",
    "detail": "Function (FSoftObjectPath)",
    "insertText": "ResolveRedirects(const FSoftObjectPath& Target)"
  },
  {
    "label": "GetManagerName()",
    "kind": "Method",
    "detail": "Function (const FString&)",
    "insertText": "GetManagerName()"
  },
  {
    "label": "SetManagerName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetManagerName(FString InName)"
  },
  {
    "label": "AddReferencedObjects()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddReferencedObjects(FReferenceCollector& Collector)"
  },
  {
    "label": "GetReferencerName()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "GetReferencerName()"
  },
  {
    "label": "FStreamableManager()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FStreamableManager()"
  },
  {
    "label": "FStreamableManager()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FStreamableManager(const FStreamableManager&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FStreamableManager&)",
    "insertText": "operator(const FStreamableManager&)"
  },
  {
    "label": "RemoveReferencedAsset()",
    "kind": "Method",
    "detail": "Function (private : FStreamableHandle ; void)",
    "insertText": "RemoveReferencedAsset(const FSoftObjectPath& Target, TSharedRef<FStreamableHandle> Handle)"
  },
  {
    "label": "StartHandleRequests()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartHandleRequests(TSharedRef<FStreamableHandle> Handle)"
  },
  {
    "label": "GetAsyncLoadRequestIds()",
    "kind": "Method",
    "detail": "Function (TArray<int32>)",
    "insertText": "GetAsyncLoadRequestIds(TSharedRef<FStreamableHandle> Handle)"
  },
  {
    "label": "FindInMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindInMemory(FSoftObjectPath& InOutTarget, struct FStreamable* Existing, UPackage* Package = nullptr)"
  },
  {
    "label": "HandleLoadedRedirector()",
    "kind": "Method",
    "detail": "Function (FSoftObjectPath)",
    "insertText": "HandleLoadedRedirector(UObjectRedirector* LoadedRedirector, FSoftObjectPath RequestedPath, struct FStreamable* RequestedStreamable)"
  },
  {
    "label": "FindStreamable()",
    "kind": "Method",
    "detail": "Function (struct FStreamable*)",
    "insertText": "FindStreamable(const FSoftObjectPath& Target)"
  },
  {
    "label": "StreamInternal()",
    "kind": "Method",
    "detail": "Function (struct FStreamable*)",
    "insertText": "StreamInternal(const FSoftObjectPath& Target, TAsyncLoadPriority Priority, TSharedRef<FStreamableHandle> Handle)"
  },
  {
    "label": "GetStreamed()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "GetStreamed(const FSoftObjectPath& Target)"
  },
  {
    "label": "CheckCompletedRequests()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckCompletedRequests(const FSoftObjectPath& Target, struct FStreamable* Existing)"
  },
  {
    "label": "OnPreGarbageCollect()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnPreGarbageCollect()"
  },
  {
    "label": "AsyncLoadCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AsyncLoadCallback(FSoftObjectPath Request, UPackage* Package)"
  },
  {
    "label": "ShouldStripDebugName()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldStripDebugName()"
  },
  {
    "label": "RequestAsyncLoadInternal()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<FStreamableHandle>)",
    "insertText": "RequestAsyncLoadInternal(TArray<FSoftObjectPath>&& TargetsToStream, FStreamableDelegate&& DelegateToCall, TAsyncLoadPriority Priority, bool bManageActiveHandle, bool bStartStalled, FString&& DebugName)"
  },
  {
    "label": "RequestSyncLoadInternal()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<FStreamableHandle>)",
    "insertText": "RequestSyncLoadInternal(TArray<FSoftObjectPath>&& TargetsToStream, bool bManageActiveHandle, FString&& DebugName)"
  },
  {
    "label": "FRedirectedPath()",
    "kind": "Method",
    "detail": "Function (typedef TMap<FSoftObjectPath,struct FStreamable*> TStreamableMap ; TStreamableMap StreamableItems ; struct FRedirectedPath { FSoftObjectPath NewPath ; TObjectPtr<UObjectRedirector> LoadedRedirector ;)",
    "insertText": "FRedirectedPath() : LoadedRedirector(nullptr)"
  },
  {
    "label": "FRedirectedPath()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FRedirectedPath(const FSoftObjectPath& InNewPath, UObjectRedirector* InLoadedRedirector) : NewPath(InNewPath),LoadedRedirector(InLoadedRedirector)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Invoke(Callable, OwningManager->GetStreamed(Ref))"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "Invoke(Callable, Ref.ResolveObject())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(const TSharedPtr<FStreamableHandle>& ChildHandle : ChildHandles)"
  },
  {
    "label": "RequestAsyncLoad()",
    "kind": "Method",
    "detail": "Function (} } } } } template<PathContainerType,FuncType,DebugNameType> TSharedPtr<FStreamableHandle>)",
    "insertText": "RequestAsyncLoad(PathContainerType&& TargetsToStream, FuncType&& Callback, TAsyncLoadPriority Priority, bool bManageActiveHandle, bool bStartStalled, DebugNameType&& DebugNameOrLocation)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (FStreamableDelegate DelegateToCall ; if)",
    "insertText": "constexpr(std::is_constructible_v<FStreamableDelegate, FuncType>)"
  },
  {
    "label": "FStreamableDelegate()",
    "kind": "Method",
    "detail": "Function (DelegateToCall =)",
    "insertText": "FStreamableDelegate(Forward<FuncType>(Callback))"
  },
  {
    "label": "CreateLambda()",
    "kind": "Method",
    "detail": "Function (} else { DelegateToCall =)",
    "insertText": "CreateLambda(Forward<FuncType>(Callback))"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} if)",
    "insertText": "constexpr(std::is_same_v<std::decay_t<DebugNameType>, UE::FSourceLocation>)"
  },
  {
    "label": "RequestAsyncLoadInternal()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "RequestAsyncLoadInternal(TArray<FSoftObjectPath>{ Forward<PathContainerType>(TargetsToStream) }, MoveTemp(DelegateToCall), Priority, bManageActiveHandle, bStartStalled, ShouldStripDebugName() ? FString() : FString{ Forward<DebugNameType>(DebugNameOrLocation) })"
  },
  {
    "label": "RequestSyncLoad()",
    "kind": "Method",
    "detail": "Function (} } template<PathContainerType,DebugNameType> TSharedPtr<FStreamableHandle>)",
    "insertText": "RequestSyncLoad(PathContainerType&& TargetsToStream, bool bManageActiveHandle, DebugNameType&& DebugNameOrLocation)"
  },
  {
    "label": "RequestSyncLoadInternal()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "RequestSyncLoadInternal(TArray<FSoftObjectPath>{ Forward<PathContainerType>(TargetsToStream) }, bManageActiveHandle, ShouldStripDebugName() ? FString() : FString{ Forward<DebugNameType>(DebugNameOrLocation) })"
  }
]