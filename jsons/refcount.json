[
  {
    "label": "RefCounted",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefCounted"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "RefPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefPtr"
  },
  {
    "label": "Ref",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Ref"
  },
  {
    "label": "U",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U"
  },
  {
    "label": "RefCounted()",
    "kind": "Method",
    "detail": "Function (# pragma once # include<zenbase / atomic . h> # include<zenbase / concepts . h> # include<compare> namespace zen { class RefCounted { public :)",
    "insertText": "RefCounted()"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "AddRef()"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "Release()"
  },
  {
    "label": "AtomicDecrement()",
    "kind": "Method",
    "detail": "Function (const uint32_t RefCount =)",
    "insertText": "AtomicDecrement(const_cast<RefCounted*>(this)->m_RefCount)"
  },
  {
    "label": "RefCounted()",
    "kind": "Method",
    "detail": "Function (delete this ; } return RefCount ; })",
    "insertText": "RefCounted(const RefCounted&)"
  },
  {
    "label": "RefCounted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefCounted(RefCounted&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RefCounted&)",
    "insertText": "operator(const RefCounted&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RefCounted&)",
    "insertText": "operator(RefCounted&&)"
  },
  {
    "label": "RefCount()",
    "kind": "Method",
    "detail": "Function (protected : uint32_t)",
    "insertText": "RefCount()"
  },
  {
    "label": "RefPtr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefPtr(const RefPtr& Rhs) : m_Ref(Rhs.m_Ref)"
  },
  {
    "label": "RefPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RefPtr(T* Ptr) : m_Ref(Ptr)"
  },
  {
    "label": "RefPtr()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "RefPtr()"
  },
  {
    "label": "IsNull()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "IsNull()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RefPtr&)",
    "insertText": "operator(T* Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (m_Ref = Rhs ; return* this ; } RefPtr&)",
    "insertText": "operator(const RefPtr& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (m_Ref = Rhs . m_Ref ; } return* this ; } RefPtr&)",
    "insertText": "operator(RefPtr&& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (m_Ref = Rhs . m_Ref ; Rhs . m_Ref = nullptr ; } return* this ; } template<OtherType> RefPtr&)",
    "insertText": "operator(RefPtr<OtherType>&& Rhs)"
  },
  {
    "label": "RefPtr()",
    "kind": "Method",
    "detail": "Function (m_Ref = Rhs . m_Ref ; Rhs . m_Ref = nullptr ; } return* this ; })",
    "insertText": "RefPtr(RefPtr&& Rhs) noexcept : m_Ref(Rhs.m_Ref)"
  },
  {
    "label": "RefPtr()",
    "kind": "Method",
    "detail": "Function (Rhs . m_Ref = nullptr ; } template<OtherType>)",
    "insertText": "RefPtr(RefPtr<OtherType>&& Rhs) noexcept : m_Ref(Rhs.m_Ref)"
  },
  {
    "label": "Ref()",
    "kind": "Method",
    "detail": "Function (Rhs . m_Ref = nullptr ; } private : T* m_Ref = nullptr ; template<U> class RefPtr ; } ; template<class T> class Ref { public :)",
    "insertText": "Ref()"
  },
  {
    "label": "Ref()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Ref(const Ref& Rhs) : m_Ref(Rhs.m_Ref)"
  },
  {
    "label": "Ref()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Ref(T* Ptr) : m_Ref(Ptr)"
  },
  {
    "label": "Ref()",
    "kind": "Method",
    "detail": "Function (} template<DerivedType> requires DerivedFrom<DerivedType,T>)",
    "insertText": "Ref(const Ref<DerivedType>& Rhs) : Ref(Rhs.m_Ref)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (m_Ref = Rhs ; return* this ; } Ref&)",
    "insertText": "operator(const Ref& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (m_Ref = Rhs . m_Ref ; } return* this ; } Ref&)",
    "insertText": "operator(Ref&& Rhs)"
  },
  {
    "label": "Ref()",
    "kind": "Method",
    "detail": "Function (m_Ref = Rhs . m_Ref ; Rhs . m_Ref = nullptr ; } return* this ; })",
    "insertText": "Ref(Ref&& Rhs) noexcept : m_Ref(Rhs.m_Ref)"
  }
]