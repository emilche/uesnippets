[
  {
    "label": "RepeatingTestFuture",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RepeatingTestFuture"
  },
  {
    "label": "RepeatingTestFuture()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TEST_REPEATING_TEST_FUTURE_H_ # define BASE_TEST_REPEATING_TEST_FUTURE_H_ # include<utility> # include \" base / check . h \" # include \" base / containers / queue . h \" # include \" base / memory / weak_ptr . h \" # include \" base / run_loop . h \" # include \" base / sequence_checker . h \" # include \" base / test / test_future_internal . h \" # include \" base / thread_annotations . h \" # include \" third_party / abseil - cpp / absl / types / optional . h \" namespace base::test { template<. . . Types> class RepeatingTestFuture { public : using TupleType = std::tuple<std::decay_t<Types> . . .> ; using FirstType = std::tuple_element<0,TupleType>::type ;)",
    "insertText": "RepeatingTestFuture()"
  },
  {
    "label": "RepeatingTestFuture()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RepeatingTestFuture(const RepeatingTestFuture&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RepeatingTestFuture&)",
    "insertText": "operator(const RepeatingTestFuture&)"
  },
  {
    "label": "RepeatingTestFuture()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RepeatingTestFuture(RepeatingTestFuture&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RepeatingTestFuture&)",
    "insertText": "operator(RepeatingTestFuture&&)"
  },
  {
    "label": "AddValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddValue(Types... values)"
  },
  {
    "label": "DCHECK_CALLED_ON_VALID_SEQUENCE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_)"
  },
  {
    "label": "push()",
    "kind": "Method",
    "detail": "Function (elements_ .)",
    "insertText": "push(std::make_tuple(std::forward<Types>(values)...))"
  },
  {
    "label": "SignalElementIsAvailable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SignalElementIsAvailable()"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "Wait()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} template<. . . CallbackArgumentsTypes> base::RepeatingCallback<)",
    "insertText": "void(CallbackArgumentsTypes...)> GetCallback()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} base::RepeatingCallback<)",
    "insertText": "void(Types...)> GetCallback()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Take()",
    "kind": "Method",
    "detail": "Function (} template<T = TupleType,internal::EnableIfSingleValue<T> = true> FirstType)",
    "insertText": "Take()"
  },
  {
    "label": "WaitForANewElement()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "WaitForANewElement() VALID_CONTEXT_REQUIRED(sequence_checker_)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!run_loop_.has_value())"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (run_loop_ .)",
    "insertText": "emplace()"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (run_loop_ ->)",
    "insertText": "Run()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (run_loop_ .)",
    "insertText": "reset()"
  },
  {
    "label": "SignalElementIsAvailable()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SignalElementIsAvailable() VALID_CONTEXT_REQUIRED(sequence_checker_)"
  },
  {
    "label": "TakeTuple()",
    "kind": "Method",
    "detail": "Function (} TupleType)",
    "insertText": "TakeTuple()"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(success)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (auto result =)",
    "insertText": "move(elements_.front())"
  },
  {
    "label": "pop()",
    "kind": "Method",
    "detail": "Function (elements_ .)",
    "insertText": "pop()"
  },
  {
    "label": "GUARDED_BY_CONTEXT()",
    "kind": "Method",
    "detail": "Function (absl::optional<base::RunLoop> run_loop_)",
    "insertText": "GUARDED_BY_CONTEXT(sequence_checker_)"
  },
  {
    "label": "SEQUENCE_CHECKER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SEQUENCE_CHECKER(sequence_checker_)"
  }
]