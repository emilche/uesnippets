[
  {
    "label": "TRemoveCV",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TRemoveCV"
  },
  {
    "label": "TAreTypesEqual",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAreTypesEqual"
  },
  {
    "label": "TIsEnum",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsEnum"
  },
  {
    "label": "TIsArithmetic",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsArithmetic"
  },
  {
    "label": "TIsIntegral",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsIntegral"
  },
  {
    "label": "TIsPointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPointer"
  },
  {
    "label": "TIsMemberPointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsMemberPointer"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "TPointerIsConvertibleFromTo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPointerIsConvertibleFromTo"
  },
  {
    "label": "TPointerIsStaticCastableFromTo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPointerIsStaticCastableFromTo"
  },
  {
    "label": "TPointerIsConvertibleFromTo_TestBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPointerIsConvertibleFromTo_TestBase"
  },
  {
    "label": "TPointerIsConvertibleFromTo_TestDerived",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPointerIsConvertibleFromTo_TestDerived"
  },
  {
    "label": "TPointerIsConvertibleFromTo_Unrelated",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPointerIsConvertibleFromTo_Unrelated"
  },
  {
    "label": "TIsConstructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsConstructible"
  },
  {
    "label": "TIsTriviallyDestructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsTriviallyDestructible"
  },
  {
    "label": "TIsContiguousContainer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsContiguousContainer"
  },
  {
    "label": "TIsSame",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsSame"
  },
  {
    "label": "TIsReferenceType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsReferenceType"
  },
  {
    "label": "TIsLValueReferenceType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsLValueReferenceType"
  },
  {
    "label": "TIsRValueReferenceType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsRValueReferenceType"
  },
  {
    "label": "TIsZeroConstructType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsZeroConstructType"
  },
  {
    "label": "TCallTraitsParamTypeHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCallTraitsParamTypeHelper"
  },
  {
    "label": "TCallTraitsBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCallTraitsBase"
  },
  {
    "label": "TCallTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCallTraits"
  },
  {
    "label": "TTypeTraitsBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TTypeTraitsBase"
  },
  {
    "label": "TTypeTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TTypeTraits"
  },
  {
    "label": "TContainerTraitsBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TContainerTraitsBase"
  },
  {
    "label": "TContainerTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TContainerTraits"
  },
  {
    "label": "TIsBitwiseConstructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsBitwiseConstructible"
  },
  {
    "label": "__is_enum()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" uLang / Common / Common . h \" # include \" uLang / Common / Templates / Conditionals . h \" # include<initializer_list> # include<type_traits> namespace uLang { template<T> struct TRemoveCV { using Type = T ; } ; template<T> struct TRemoveCV<const T> { using Type = T ; } ; template<T> struct TRemoveCV<volatile T> { using Type = T ; } ; template<T> struct TRemoveCV<const volatile T> { using Type = T ; } ; template<A,B> struct TAreTypesEqual ; template<,> struct TAreTypesEqual { enum { Value = false } ; } ; template<A> struct TAreTypesEqual<A,A> { enum { Value = true } ; } ; template<T> struct TIsEnum { enum { Value =)",
    "insertText": "__is_enum(T)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct TIsArithmetic { enum { Value = false } ; } ; template<> struct TIsArithmetic<float> { enum { Value = true } ; } ; template<> struct TIsArithmetic<double> { enum { Value = true } ; } ; template<> struct TIsArithmetic<long double> { enum { Value = true } ; } ; template<> struct TIsArithmetic<uint8_t> { enum { Value = true } ; } ; template<> struct TIsArithmetic<uint16_t> { enum { Value = true } ; } ; template<> struct TIsArithmetic<uint32_t> { enum { Value = true } ; } ; template<> struct TIsArithmetic<uint64_t> { enum { Value = true } ; } ; template<> struct TIsArithmetic<int8_t> { enum { Value = true } ; } ; template<> struct TIsArithmetic<int16_t> { enum { Value = true } ; } ; template<> struct TIsArithmetic<int32_t> { enum { Value = true } ; } ; template<> struct TIsArithmetic<int64_t> { enum { Value = true } ; } ; template<> struct TIsArithmetic<bool> { enum { Value = true } ; } ; template<> struct TIsArithmetic<char> { enum { Value = true } ; } ; template<> struct TIsArithmetic<wchar_t> { enum { Value = true } ; } ; template<T> struct TIsArithmetic<const T> { enum { Value = TIsArithmetic<T>::Value } ; } ; template<T> struct TIsArithmetic<volatile T> { enum { Value = TIsArithmetic<T>::Value } ; } ; template<T> struct TIsArithmetic<const volatile T> { enum { Value = TIsArithmetic<T>::Value } ; } ; template<T> struct TIsIntegral { enum { Value = false } ; } ; template<> struct TIsIntegral<bool> { enum { Value = true } ; } ; template<> struct TIsIntegral<char> { enum { Value = true } ; } ; template<> struct TIsIntegral<signed char> { enum { Value = true } ; } ; template<> struct TIsIntegral<unsigned char> { enum { Value = true } ; } ; template<> struct TIsIntegral<char16_t> { enum { Value = true } ; } ; template<> struct TIsIntegral<char32_t> { enum { Value = true } ; } ; template<> struct TIsIntegral<wchar_t> { enum { Value = true } ; } ; template<> struct TIsIntegral<short> { enum { Value = true } ; } ; template<> struct TIsIntegral<unsigned short> { enum { Value = true } ; } ; template<> struct TIsIntegral<int> { enum { Value = true } ; } ; template<> struct TIsIntegral<unsigned int> { enum { Value = true } ; } ; template<> struct TIsIntegral<long> { enum { Value = true } ; } ; template<> struct TIsIntegral<unsigned long> { enum { Value = true } ; } ; template<> struct TIsIntegral<long long> { enum { Value = true } ; } ; template<> struct TIsIntegral<unsigned long long> { enum { Value = true } ; } ; template<T> struct TIsIntegral<const T> { enum { Value = TIsIntegral<T>::Value } ; } ; template<T> struct TIsIntegral<volatile T> { enum { Value = TIsIntegral<T>::Value } ; } ; template<T> struct TIsIntegral<const volatile T> { enum { Value = TIsIntegral<T>::Value } ; } ; template<T> struct TIsPointer { enum { Value = false } ; } ; template<T> struct TIsPointer<T*> { enum { Value = true } ; } ; template<T> struct TIsPointer<const T> { enum { Value = TIsPointer<T>::Value } ; } ; template<T> struct TIsPointer<volatile T> { enum { Value = TIsPointer<T>::Value } ; } ; template<T> struct TIsPointer<const volatile T> { enum { Value = TIsPointer<T>::Value } ; } ; template<T> struct TIsMemberPointer { enum { Value = false } ; } ; template<T,U> struct TIsMemberPointer<T U::*> { enum { Value = true } ; } ; template<T> struct TIsMemberPointer<const T> { enum { Value = TIsPointer<T>::Value } ; } ; template<T> struct TIsMemberPointer<volatile T> { enum { Value = TIsPointer<T>::Value } ; } ; template<T> struct TIsMemberPointer<const volatile T> { enum { Value = TIsPointer<T>::Value } ; } ; # if)",
    "insertText": "defined(_MSC_VER) && _MSC_VER >= 1900 #pragma warning(push) #pragma warning(disable:4647)"
  },
  {
    "label": "__is_pod()",
    "kind": "Method",
    "detail": "Function (enum { Value = TOrValue<)",
    "insertText": "__is_pod(T) || __is_enum(T)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} ; # if)",
    "insertText": "defined(_MSC_VER) && _MSC_VER >= 1900 #pragma warning(pop)"
  },
  {
    "label": "Test()",
    "kind": "Method",
    "detail": "Function (private : uint8_t)",
    "insertText": "Test(...)"
  },
  {
    "label": "Test()",
    "kind": "Method",
    "detail": "Function (uint16_t)",
    "insertText": "Test(To*)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (public : enum { Value =)",
    "insertText": "sizeof(Test((From*)nullptr))"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (} ; template<T1,T2> struct TPointerIsStaticCastableFromTo { enum { Value = static_cast<)",
    "insertText": "size_t(TPointerIsConvertibleFromTo<T1, T2>::Value) | static_cast<size_t>(TPointerIsConvertibleFromTo<T2, T1>::Value)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} ; class TPointerIsConvertibleFromTo_TestBase { } ; class TPointerIsConvertibleFromTo_TestDerived : public TPointerIsConvertibleFromTo_TestBase { } ; class TPointerIsConvertibleFromTo_Unrelated { } ;)",
    "insertText": "static_assert(TPointerIsConvertibleFromTo<bool, bool>::Value, \"Platform TPointerIsConvertibleFromTo test failed.\")"
  },
  {
    "label": "__is_constructible()",
    "kind": "Method",
    "detail": "Function (template<T,. . . Args> struct TIsConstructible { enum { Value =)",
    "insertText": "__is_constructible(T, Args...)"
  },
  {
    "label": "TAndValue()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct TIsTriviallyDestructible { enum { Value = std::is_trivially_destructible_v<T> } ; } ; template<T> struct TIsContiguousContainer { enum { Value = false } ; } ; template<T> struct TIsContiguousContainer<T&> : TIsContiguousContainer<T> { } ; template<T> struct TIsContiguousContainer<T&&> : TIsContiguousContainer<T> { } ; template<T> struct TIsContiguousContainer<const T> : TIsContiguousContainer<T> { } ; template<T> struct TIsContiguousContainer<volatile T> : TIsContiguousContainer<T> { } ; template<T> struct TIsContiguousContainer<const volatile T> : TIsContiguousContainer<T> { } ; template<T,size_t N> struct TIsContiguousContainer<T [ N ]> { enum { Value = true } ; } ; template<T,size_t N> struct TIsContiguousContainer<const T [ N ]> { enum { Value = true } ; } ; template<T,size_t N> struct TIsContiguousContainer<volatile T [ N ]> { enum { Value = true } ; } ; template<T,size_t N> struct TIsContiguousContainer<const volatile T [ N ]> { enum { Value = true } ; } ; template<T> struct TIsContiguousContainer<std::initializer_list<T>> { enum { Value = true } ; } ; template<A,B> struct TIsSame { enum { Value = false } ; } ; template<T> struct TIsSame<T,T> { enum { Value = true } ; } ; template<T> struct TIsReferenceType { enum { Value = false } ; } ; template<T> struct TIsReferenceType<T&> { enum { Value = true } ; } ; template<T> struct TIsReferenceType<T&&> { enum { Value = true } ; } ; template<T> struct TIsLValueReferenceType { enum { Value = false } ; } ; template<T> struct TIsLValueReferenceType<T&> { enum { Value = true } ; } ; template<T> struct TIsRValueReferenceType { enum { Value = false } ; } ; template<T> struct TIsRValueReferenceType<T&&> { enum { Value = true } ; } ; template<T> struct TIsZeroConstructType { enum { Value = TOr<TIsEnum<T>,TIsArithmetic<T>,TIsPointer<T>>::Value } ; } ; template<T,bool TypeIsSmall> struct TCallTraitsParamTypeHelper { using ParamType = const T& ; using ConstParamType = const T& ; } ; template<T> struct TCallTraitsParamTypeHelper<T,true> { using ParamType = const T ; using ConstParamType = const T ; } ; template<T> struct TCallTraitsParamTypeHelper<T*,true> { using ParamType = T* ; using ConstParamType = const T* ; } ; template<T> struct TCallTraitsBase { private : enum { PassByValue = TOr<)",
    "insertText": "TAndValue(sizeof(T) <= sizeof(void*))"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (public : using ValueType = T ; using Reference = T& ; using ConstReference = const T& ; using ParamType = TCallTraitsParamTypeHelper<T,PassByValue>::ParamType ; using ConstPointerType = TCallTraitsParamTypeHelper<T,PassByValue>::ConstParamType ; } ; template<T> struct TCallTraits : public TCallTraitsBase<T> { } ; template<T> struct TCallTraits<T&> { using ValueType = T& ; using Reference = T& ; using ConstReference = const T& ; using ParamType = T& ; using ConstPointerType = T& ; } ; template<T,size_t N> struct TCallTraits<T [ N ]> { private : using ArrayType = T [ N ] ; public : using ValueType = const T* ; using Reference = ArrayType& ; using ConstReference = const ArrayType& ; using ParamType = const T* const ; using ConstPointerType = const T* const ; } ; template<T,size_t N> struct TCallTraits<const T [ N ]> { private : using ArrayType = T [ N ] ; public : using ValueType = const T* ; using Reference = ArrayType& ; using ConstReference = const ArrayType& ; using ParamType = const T* const ; using ConstPointerType = const T* const ; } ; template<T> struct TTypeTraitsBase { using ConstInitType = TCallTraits<T>::ParamType ; using ConstPointerType = TCallTraits<T>::ConstPointerType ; enum { IsBytewiseComparable = TOr<TIsEnum<T>,TIsArithmetic<T>,TIsPointer<T>>::Value } ; } ; template<T> struct TTypeTraits : public TTypeTraitsBase<T> { } ; template<T> struct TContainerTraitsBase { enum { MoveWillEmptyContainer = false } ; } ; template<T> struct TContainerTraits : public TContainerTraitsBase<T> { } ; template<T,Arg> struct TIsBitwiseConstructible {)",
    "insertText": "static_assert(!TIsReferenceType<T >::Value && !TIsReferenceType<Arg>::Value, \"TIsBitwiseConstructible is not designed to accept reference types\")"
  }
]