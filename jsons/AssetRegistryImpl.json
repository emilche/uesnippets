[
  {
    "label": "FDependsNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDependsNode"
  },
  {
    "label": "FARFilter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FARFilter"
  },
  {
    "label": "FAssetDataGatherer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAssetDataGatherer"
  },
  {
    "label": "FFileChangeData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFileChangeData"
  },
  {
    "label": "FPackageReader",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPackageReader"
  },
  {
    "label": "UAssetRegistryImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAssetRegistryImpl"
  },
  {
    "label": "FEventContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEventContext"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FAsyncConsumer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAsyncConsumer"
  },
  {
    "label": "FInitializeContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FInitializeContext"
  },
  {
    "label": "FScanPathContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FScanPathContext"
  },
  {
    "label": "FTickContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTickContext"
  },
  {
    "label": "FClassInheritanceContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FClassInheritanceContext"
  },
  {
    "label": "TRWScopeLockWithPriority",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRWScopeLockWithPriority"
  },
  {
    "label": "FRWScopeLockWithPriority",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRWScopeLockWithPriority"
  },
  {
    "label": "FRegisteredAssetDependencyGatherer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRegisteredAssetDependencyGatherer"
  },
  {
    "label": "FRWLockWithPriority",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRWLockWithPriority"
  },
  {
    "label": "ELockPriority",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ELockPriority"
  },
  {
    "label": "FClassInheritanceBuffer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FClassInheritanceBuffer"
  },
  {
    "label": "EPerformanceMode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EPerformanceMode"
  },
  {
    "label": "FInterruptionContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FInterruptionContext"
  },
  {
    "label": "FAssetRegistryImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAssetRegistryImpl"
  },
  {
    "label": "FAssetRegistryPackageRedirect",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAssetRegistryPackageRedirect"
  },
  {
    "label": "UE",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UE"
  },
  {
    "label": "Impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Impl"
  },
  {
    "label": "FAsyncConsumer()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" AssetDataGatherer . h \" # include \" AssetRegistry / AssetData . h \" # include \" AssetRegistry / AssetRegistryState . h \" # include \" AssetRegistry / IAssetRegistry . h \" # include \" AssetRegistry / PathTree . h \" # include \" Containers / RingBuffer . h \" # include \" HAL / CriticalSection . h \" # include \" Math / NumericLimits . h \" # include \" ModuleDescriptor . h \" # include \" PackageDependencyData . h \" # include \" Templates / Function . h \" # include \" Templates / UniquePtr . h \" # ifndef ASSETREGISTRY_ENABLE_PREMADE_REGISTRY_IN_EDITOR # define ASSETREGISTRY_ENABLE_PREMADE_REGISTRY_IN_EDITOR 0 # endif class FDependsNode ; struct FARFilter ; class FAssetDataGatherer ; struct FFileChangeData ; class FPackageReader ; class UAssetRegistryImpl ; namespace UE::AssetRegistry::Impl { struct FEventContext ; } namespace UE::AssetRegistry::Premade { enum class ELoadResult : uint8 ; } namespace UE::AssetRegistry::Premade { struct FAsyncConsumer ; } namespace UE::AssetRegistry::Impl { struct FInitializeContext ; } namespace UE::AssetRegistry::Impl { struct FScanPathContext ; } namespace UE::AssetRegistry::Impl { struct FTickContext ; } namespace UE::AssetRegistry::Impl { struct FClassInheritanceContext ; } namespace UE::AssetRegistry { template<TScopeLockType> class TRWScopeLockWithPriority ; } namespace UE::AssetRegistry { using FInterfaceReadScopeLock = TRWScopeLockWithPriority<FReadScopeLock> ; } namespace UE::AssetRegistry { using FInterfaceWriteScopeLock = TRWScopeLockWithPriority<FWriteScopeLock> ; } namespace UE::AssetRegistry { using FInterfaceRWScopeLock = class FRWScopeLockWithPriority ; } # if WITH_EDITOR namespace UE::AssetDependencyGatherer::Private { class FRegisteredAssetDependencyGatherer ; } # endif namespace UE::AssetRegistry::Premade { struct FAsyncConsumer { ~)",
    "insertText": "FAsyncConsumer()"
  },
  {
    "label": "PrepareForConsume()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrepareForConsume()"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Wait(UAssetRegistryImpl& UARI, FInterfaceWriteScopeLock& ScopeLock)"
  },
  {
    "label": "Consume()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Consume(UAssetRegistryImpl& UARI, UE::AssetRegistry::Impl::FEventContext& EventContext, ELoadResult LoadResult, FAssetRegistryState&& ARState)"
  },
  {
    "label": "HasWaiters()",
    "kind": "Method",
    "detail": "Function (private : int32 ReferenceCount = 0 ; FEvent* Consumed = nullptr ; } ; } namespace UE::AssetRegistry { namespace Private { class FRWLockWithPriority : public FRWLock { public : bool)",
    "insertText": "HasWaiters()"
  },
  {
    "label": "IsUpToDate()",
    "kind": "Method",
    "detail": "Function (} private : FInterfaceReadScopeLock ; FInterfaceWriteScopeLock ; FInterfaceRWScopeLock ; std::atomic<int32> HighPriorityWaitersCount ; } ; enum ELockPriority : uint8 { PriorityLow,PriorityHigh } ; using FInterfaceRWLock = FRWLockWithPriority ; } namespace Impl { struct FClassInheritanceBuffer { TMap<FTopLevelAssetPath,FTopLevelAssetPath> InheritanceMap ; TMap<FTopLevelAssetPath,TArray<FTopLevelAssetPath>> ReverseInheritanceMap ; uint64 SavedAllClassesVersionNumber = MAX_uint64 ; bool bDirty = true ; bool)",
    "insertText": "IsUpToDate(uint64 CurrentAllClassesVersionNumber)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear()"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} ; enum class EGatherStatus : uint8 { TickActiveGatherActive,TickActiveGatherIdle,TickGameThreadActiveGatherIdle,Complete,UnableToProgress,WaitingForEvents,} ; enum EPerformanceMode : uint8 { BulkLoading,MostlyStatic,} ; struct FInterruptionContext { public : typedef TFunction<)",
    "insertText": "bool(void)"
  },
  {
    "label": "FInterruptionContext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FInterruptionContext()"
  },
  {
    "label": "FInterruptionContext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FInterruptionContext(double InTickStartTime, double InMaxRunningTime) : TickStartTime(InTickStartTime) , MaxRunningTime(InMaxRunningTime)"
  },
  {
    "label": "FInterruptionContext()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FInterruptionContext(double InTickStartTime, double InMaxRunningTime, ShouldExitEarlyCallbackType& Callback) : TickStartTime(InTickStartTime) , MaxRunningTime(InMaxRunningTime) , EarlyExitCallback(Callback)"
  },
  {
    "label": "SetEarlyExitCallback()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetEarlyExitCallback(const ShouldExitEarlyCallbackType& InCallback)"
  },
  {
    "label": "SetUnlimitedTickTime()",
    "kind": "Method",
    "detail": "Function (EarlyExitCallback = InCallback ; } void)",
    "insertText": "SetUnlimitedTickTime()"
  },
  {
    "label": "SetLimitedTickTime()",
    "kind": "Method",
    "detail": "Function (TickStartTime = - 1 . ; MaxRunningTime = - 1 . ; } void)",
    "insertText": "SetLimitedTickTime(double InTickStartTime, double InMaxRunningTime)"
  },
  {
    "label": "GetTickStartTime()",
    "kind": "Method",
    "detail": "Function (TickStartTime = InTickStartTime ; MaxRunningTime = InMaxRunningTime ; } double)",
    "insertText": "GetTickStartTime()"
  },
  {
    "label": "RequestEarlyExit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RequestEarlyExit()"
  },
  {
    "label": "IsTickActive()",
    "kind": "Method",
    "detail": "Function (OutInterrupted = true ; } private : double TickStartTime = - 1 . ; double MaxRunningTime = - 1 . ; ShouldExitEarlyCallbackType EarlyExitCallback ; bool OutInterrupted = false ; } ; } } bool)",
    "insertText": "IsTickActive(UE::AssetRegistry::Impl::EGatherStatus Status)"
  },
  {
    "label": "FAssetRegistryImpl()",
    "kind": "Method",
    "detail": "Function (} namespace UE::AssetRegistry { class FAssetRegistryImpl { using FAssetDataMap = UE::AssetRegistry::Private::FAssetDataMap ; using FCachedAssetKey = UE::AssetRegistry::Private::FCachedAssetKey ; public :)",
    "insertText": "FAssetRegistryImpl()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize(Impl::FInitializeContext& Context)"
  },
  {
    "label": "HasAssets()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasAssets(const FName PackagePath, const bool bRecursive)"
  },
  {
    "label": "GetRedirectedObjectPath()",
    "kind": "Method",
    "detail": "Function (FSoftObjectPath)",
    "insertText": "GetRedirectedObjectPath(const FSoftObjectPath& ObjectPath, UE::AssetRegistry::Impl::FEventContext* EventContext, UE::AssetRegistry::Impl::FClassInheritanceContext* InheritanceContext, bool bNeedsScanning)"
  },
  {
    "label": "GetAncestorClassNames()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetAncestorClassNames(Impl::FClassInheritanceContext& InheritanceContext, FTopLevelAssetPath ClassName, TArray<FTopLevelAssetPath>& OutAncestorClassNames)"
  },
  {
    "label": "CompileFilter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CompileFilter(Impl::FClassInheritanceContext& InheritanceContext, const FARFilter& InFilter, FARCompiledFilter& OutCompiledFilter)"
  },
  {
    "label": "SetTemporaryCachingMode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTemporaryCachingMode(bool bEnable)"
  },
  {
    "label": "SetTemporaryCachingModeInvalidated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTemporaryCachingModeInvalidated()"
  },
  {
    "label": "AddPath()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AddPath(Impl::FEventContext& EventContext, FStringView PathToAdd)"
  },
  {
    "label": "SearchAllAssets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SearchAllAssets(Impl::FEventContext& EventContext, Impl::FClassInheritanceContext& InheritanceContext, bool bSynchronousSearch)"
  },
  {
    "label": "GetVerseFilesByPath()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetVerseFilesByPath(FName PackagePath, TArray<FName>* OutFilePaths, bool bRecursive)"
  },
  {
    "label": "ScanPathsSynchronous()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScanPathsSynchronous(Impl::FScanPathContext& Context)"
  },
  {
    "label": "PrioritizeSearchPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrioritizeSearchPath(const FString& PathToPrioritize)"
  },
  {
    "label": "ScanModifiedAssetFiles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScanModifiedAssetFiles(Impl::FEventContext& EventContext, Impl::FClassInheritanceContext& InheritanceContext, const TArray<FString>& InFilePaths, UE::AssetRegistry::EScanFlags ScanFlags)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Serialize(FArchive& Ar, Impl::FEventContext& EventContext)"
  },
  {
    "label": "AppendState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendState(Impl::FEventContext& EventContext, const FAssetRegistryState& InState, FAssetRegistryState::EInitializationMode Mode = FAssetRegistryState::EInitializationMode::Append, bool bEmitAssetEvents = false)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetAllocatedSize(bool bLogDetailed, SIZE_T& StateSize, SIZE_T& StaticSize, SIZE_T& SearchSize)"
  },
  {
    "label": "IsLoadingAssets()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsLoadingAssets()"
  },
  {
    "label": "SetManageReferences()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetManageReferences(const TMultiMap<FAssetIdentifier, FAssetIdentifier>& ManagerMap, bool bClearExisting, UE::AssetRegistry::EDependencyCategory RecurseType, TSet<FDependsNode*>& ExistingManagedNodes, IAssetRegistry::ShouldSetManagerPredicate ShouldSetManager)"
  },
  {
    "label": "SetPrimaryAssetIdForObjectPath()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SetPrimaryAssetIdForObjectPath(Impl::FEventContext& EventContext, const FSoftObjectPath& ObjectPath, FPrimaryAssetId PrimaryAssetId)"
  },
  {
    "label": "ResolveRedirect()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ResolveRedirect(const FString& InPackageName, FString& OutPackageName)"
  },
  {
    "label": "OnDirectoryChanged()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR void)",
    "insertText": "OnDirectoryChanged(Impl::FEventContext& EventContext, Impl::FClassInheritanceContext& InheritanceContext, TArray<FFileChangeData>& FileChangesProcessed)"
  },
  {
    "label": "OnDirectoryRescanRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnDirectoryRescanRequired(Impl::FEventContext& EventContext, Impl::FClassInheritanceContext& InheritanceContext, FString& DirPath, int64 BeforeTimeStamp)"
  },
  {
    "label": "AddLoadedAssetToProcess()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddLoadedAssetToProcess(const UObject& AssetLoaded)"
  },
  {
    "label": "OnContentPathMounted()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "OnContentPathMounted(Impl::FEventContext& EventContext, Impl::FClassInheritanceContext& InheritanceContext, const FString& InAssetPath, const FString& AssetPathWithTrailingSlash, const FString& FileSystemPath)"
  },
  {
    "label": "OnContentPathDismounted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnContentPathDismounted(Impl::FEventContext& EventContext, const FString& InAssetPath, const FString& AssetPathNoTrailingSlash, const FString& FileSystemPath)"
  },
  {
    "label": "OnPluginLoadingComplete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnPluginLoadingComplete(bool bPhaseSuccessful)"
  },
  {
    "label": "RefreshNativeClasses()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefreshNativeClasses()"
  },
  {
    "label": "EnumerateDiskAssets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateDiskAssets(const FARCompiledFilter& InFilter, TSet<FName>& PackagesToSkip, TFunctionRef<bool(const FAssetData&)> Callback, UE::AssetRegistry::EEnumerateAssetsFlags InEnumerateFlags)"
  },
  {
    "label": "EnumerateAllDiskAssets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateAllDiskAssets(TSet<FName>& PackageNamesToSkip, TFunctionRef<bool(const FAssetData&)> Callback, UE::AssetRegistry::EEnumerateAssetsFlags InEnumerateFlags = UE::AssetRegistry::EEnumerateAssetsFlags::None)"
  },
  {
    "label": "WaitForGathererIdleIfSynchronous()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitForGathererIdleIfSynchronous()"
  },
  {
    "label": "WaitForGathererIdle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitForGathererIdle(float TimeoutSeconds)"
  },
  {
    "label": "TickGatherer()",
    "kind": "Method",
    "detail": "Function (Impl::EGatherStatus)",
    "insertText": "TickGatherer(Impl::FTickContext& TickContext)"
  },
  {
    "label": "IsGameThreadTakeOverGatherEachTick()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsGameThreadTakeOverGatherEachTick()"
  },
  {
    "label": "SetGameThreadTakeOverGatherEachTick()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetGameThreadTakeOverGatherEachTick(bool bValue)"
  },
  {
    "label": "LogSearchDiagnostics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LogSearchDiagnostics(double StartTime)"
  },
  {
    "label": "TickGatherPackage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TickGatherPackage(Impl::FEventContext& EventContext, const FString& PackageName, const FString& LocalPath)"
  },
  {
    "label": "ClearGathererCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearGathererCache()"
  },
  {
    "label": "AssetsSaved()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR void)",
    "insertText": "AssetsSaved(UE::AssetRegistry::Impl::FEventContext& EventContext, TArray<FAssetData>&& Assets)"
  },
  {
    "label": "GetProcessLoadedAssetsBatch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetProcessLoadedAssetsBatch(TArray<const UObject*>& OutLoadedAssets, uint32 BatchSize, bool bUpdateDiskCacheAfterLoad)"
  },
  {
    "label": "PushProcessLoadedAssetsBatch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PushProcessLoadedAssetsBatch(Impl::FEventContext& EventContext, TArrayView<FAssetData> LoadedAssetDatas, TArrayView<const UObject*> UnprocessedFromBatch)"
  },
  {
    "label": "LoadCalculatedDependencies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LoadCalculatedDependencies(TArray<FName>* AssetPackageNamessToCalculate, Impl::FClassInheritanceContext& InheritanceContext, TSet<FName>* InPackagesNeedingDependencyCalculation, Impl::FInterruptionContext& InOutInterruptionContext)"
  },
  {
    "label": "PruneAndCoalescePackagesRequiringDependencyCalculation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PruneAndCoalescePackagesRequiringDependencyCalculation(TSet<FName>& BackgroundPackages, TSet<FName>& GameThreadPackages, Impl::FInterruptionContext& InOutInterruptionContext)"
  },
  {
    "label": "LoadCalculatedDependencies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LoadCalculatedDependencies(FName PackageName, Impl::FClassInheritanceContext& InheritanceContext, bool& bOutHadActivity)"
  },
  {
    "label": "AddDirectoryReferencer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddDirectoryReferencer(FName PackageName, const FString& DirectoryLocalPathOrLongPackageName)"
  },
  {
    "label": "RemoveDirectoryReferencer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveDirectoryReferencer(FName PackageName)"
  },
  {
    "label": "OnAssetDependencyGathererRegistered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnAssetDependencyGathererRegistered()"
  },
  {
    "label": "AddEmptyPackage()",
    "kind": "Method",
    "detail": "Function (bRegisteredDependencyGathererClassesDirty = true ; } # endif void)",
    "insertText": "AddEmptyPackage(FName PackageName)"
  },
  {
    "label": "RemoveEmptyPackage()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemoveEmptyPackage(FName PackageName)"
  },
  {
    "label": "AddAssetPath()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AddAssetPath(Impl::FEventContext& EventContext, FName PathToAdd)"
  },
  {
    "label": "RemoveAssetPath()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemoveAssetPath(Impl::FEventContext& EventContext, FName PathToRemove, bool bEvenIfAssetsStillExist = false)"
  },
  {
    "label": "RemovePackageData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemovePackageData(Impl::FEventContext& EventContext, const FName PackageName)"
  },
  {
    "label": "AddVerseFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddVerseFile(Impl::FEventContext& EventContext, FName VerseFilePathToAdd)"
  },
  {
    "label": "RemoveVerseFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveVerseFile(Impl::FEventContext& EventContext, FName VerseFilePathToRemove)"
  },
  {
    "label": "GetSubClasses()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSubClasses(Impl::FClassInheritanceContext& InheritanceContext, const TArray<FTopLevelAssetPath>& InClassNames, const TSet<FTopLevelAssetPath>& ExcludedClassNames, TSet<FTopLevelAssetPath>& SubClassNames)"
  },
  {
    "label": "IsInitialSearchCompleted()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsInitialSearchCompleted()"
  },
  {
    "label": "IsTempCachingEnabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsTempCachingEnabled()"
  },
  {
    "label": "GetCurrentAllClassesVersionNumber()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "GetCurrentAllClassesVersionNumber()"
  },
  {
    "label": "CopySerializationOptions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopySerializationOptions(FAssetRegistrySerializationOptions& OutOptions, ESerializationTarget Target)"
  },
  {
    "label": "GetPerformanceMode()",
    "kind": "Method",
    "detail": "Function (Impl::EPerformanceMode)",
    "insertText": "GetPerformanceMode()"
  },
  {
    "label": "ShouldSortDependencies()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldSortDependencies()"
  },
  {
    "label": "ShouldSortReferencers()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldSortReferencers()"
  },
  {
    "label": "GetState()",
    "kind": "Method",
    "detail": "Function (const FAssetRegistryState&)",
    "insertText": "GetState()"
  },
  {
    "label": "GetCachedPathTree()",
    "kind": "Method",
    "detail": "Function (const FPathTree&)",
    "insertText": "GetCachedPathTree()"
  },
  {
    "label": "GetCachedEmptyPackages()",
    "kind": "Method",
    "detail": "Function (const TSet<FName>&)",
    "insertText": "GetCachedEmptyPackages()"
  },
  {
    "label": "ShouldSkipAsset()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldSkipAsset(FTopLevelAssetPath AssetClass, uint32 PackageFlags)"
  },
  {
    "label": "ShouldSkipAsset()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldSkipAsset(const UObject* InAsset)"
  },
  {
    "label": "CollectCodeGeneratorClasses()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CollectCodeGeneratorClasses()"
  },
  {
    "label": "ConditionalLoadPremadeAssetRegistry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConditionalLoadPremadeAssetRegistry(UAssetRegistryImpl& UARI, UE::AssetRegistry::Impl::FEventContext& EventContext, FInterfaceWriteScopeLock& ScopeLock)"
  },
  {
    "label": "RequestPauseBackgroundProcessing()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR void)",
    "insertText": "RequestPauseBackgroundProcessing()"
  },
  {
    "label": "RequestResumeBackgroundProcessing()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RequestResumeBackgroundProcessing()"
  },
  {
    "label": "IsBackgroundProcessingPaused()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsBackgroundProcessingPaused()"
  },
  {
    "label": "GetBackgroundTickInterruptionsCount()",
    "kind": "Method",
    "detail": "Function (uint32&)",
    "insertText": "GetBackgroundTickInterruptionsCount()"
  },
  {
    "label": "EnumerateAssetsByPathNoTags()",
    "kind": "Method",
    "detail": "Function (# endif private : void)",
    "insertText": "EnumerateAssetsByPathNoTags(FName PackagePath, TFunctionRef<bool(const FAssetData&)> Callback, bool bRecursive, bool bIncludeOnlyOnDiskAssets)"
  },
  {
    "label": "InitRedirectors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitRedirectors(Impl::FEventContext& EventContext, Impl::FClassInheritanceContext& InheritanceContext, bool& bOutRedirectorsNeedSubscribe)"
  },
  {
    "label": "ReadScriptPackages()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReadScriptPackages()"
  },
  {
    "label": "TryConstructGathererIfNeeded()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryConstructGathererIfNeeded()"
  },
  {
    "label": "SearchAllAssetsInitialAsync()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SearchAllAssetsInitialAsync(Impl::FEventContext& EventContext, Impl::FClassInheritanceContext& InheritanceContext)"
  },
  {
    "label": "AssetSearchDataGathered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssetSearchDataGathered(Impl::FEventContext& EventContext, TMultiMap<FName, TUniquePtr<FAssetData>>& AssetResults, TMultiMap<FName, TUniquePtr<FAssetData>>& OutDeferredResults,\\ Impl::FInterruptionContext& InOutInterruptionContext)"
  },
  {
    "label": "ShouldSkipGatheredAsset()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldSkipGatheredAsset(FAssetData& AssetData)"
  },
  {
    "label": "PathDataGathered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PathDataGathered(Impl::FEventContext& EventContext, TRingBuffer<FString>& PathResults, Impl::FInterruptionContext& InOutInterruptionContext)"
  },
  {
    "label": "DependencyDataGathered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DependencyDataGathered(TMultiMap<FName, FPackageDependencyData>& DependsResults, TMultiMap<FName, FPackageDependencyData>& OutDeferredDependencyResults, TSet<FName>* OutPackagesNeedingDependencyCalculation, Impl::FInterruptionContext& InOutInterruptionContext)"
  },
  {
    "label": "CookedPackageNamesWithoutAssetDataGathered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CookedPackageNamesWithoutAssetDataGathered(Impl::FEventContext& EventContext, TRingBuffer<FString>& CookedPackageNamesWithoutAssetDataResults, Impl::FInterruptionContext& InOutInterruptionContext)"
  },
  {
    "label": "VerseFilesGathered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VerseFilesGathered(Impl::FEventContext& EventContext, TRingBuffer<FName>& VerseResults, Impl::FInterruptionContext& InOutInterruptionContext)"
  },
  {
    "label": "AddAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAssetData(Impl::FEventContext& EventContext, FAssetData* AssetData)"
  },
  {
    "label": "UpdateAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateAssetData(Impl::FEventContext& EventContext, FAssetData* AssetData, FAssetData&& NewAssetData, bool bKeepDeletedTags)"
  },
  {
    "label": "AddNonOverlappingTags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddNonOverlappingTags(Impl::FEventContext& EventContext, FAssetData& ExistingAssetData, const FAssetData& NewAssetData)"
  },
  {
    "label": "RemoveAssetData()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemoveAssetData(Impl::FEventContext& EventContext, FAssetData* AssetData)"
  },
  {
    "label": "ResolveAssetIdCollision()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR FAssetData*)",
    "insertText": "ResolveAssetIdCollision(FAssetData& A, FAssetData& B)"
  },
  {
    "label": "TryPostLoadAssetRegistryTags()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryPostLoadAssetRegistryTags(FAssetData* AssetData)"
  },
  {
    "label": "UpdateRedirectCollector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateRedirectCollector()"
  },
  {
    "label": "RebuildAssetDependencyGathererMapIfNeeded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RebuildAssetDependencyGathererMapIfNeeded()"
  },
  {
    "label": "GetSubClasses_Recursive()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "GetSubClasses_Recursive(Impl::FClassInheritanceContext& InheritanceContext, FTopLevelAssetPath InClassName, TSet<FTopLevelAssetPath>& SubClassNames, TSet<FTopLevelAssetPath>& ProcessedClassNames, const TSet<FTopLevelAssetPath>& ExcludedClassNames)"
  },
  {
    "label": "CachePathsFromState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CachePathsFromState(Impl::FEventContext& EventContext, const FAssetRegistryState& InState)"
  },
  {
    "label": "AddCachedBPClassParent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCachedBPClassParent(const FTopLevelAssetPath& ClassPath, const FTopLevelAssetPath& NotYetRedirectedParentPath)"
  },
  {
    "label": "UpdateInheritanceBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateInheritanceBuffer(Impl::FClassInheritanceBuffer& OutBuffer)"
  },
  {
    "label": "ConsumeOrDeferPreloadedPremade()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConsumeOrDeferPreloadedPremade(UAssetRegistryImpl& UARI, Impl::FEventContext& EventContext)"
  },
  {
    "label": "LoadPremadeAssetRegistry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LoadPremadeAssetRegistry(Impl::FEventContext& Context, Premade::ELoadResult LoadResult, FAssetRegistryState&& ARState)"
  },
  {
    "label": "UpdatePersistentMountPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdatePersistentMountPoints()"
  },
  {
    "label": "OnInitialSearchCompleted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnInitialSearchCompleted(Impl::FEventContext& EventContext)"
  },
  {
    "label": "ClassRequiresGameThreadProcessing()",
    "kind": "Method",
    "detail": "Function (FAssetDataGatherer ; bool)",
    "insertText": "ClassRequiresGameThreadProcessing(const UClass* Class)"
  },
  {
    "label": "AccessGlobalGatherer()",
    "kind": "Method",
    "detail": "Function (UAssetRegistryImpl ; TUniquePtr<FAssetDataGatherer>&)",
    "insertText": "AccessGlobalGatherer()"
  },
  {
    "label": "FAssetRegistryPackageRedirect()",
    "kind": "Method",
    "detail": "Function (private : FAssetRegistryState State ; TSet<FName> CachedVerseFiles ; TMap<FName,TArray<FName>> CachedVerseFilesByPath ; FAssetRegistrySerializationOptions SerializationOptions ; FAssetRegistrySerializationOptions DevelopmentSerializationOptions ; TSet<FName> CachedEmptyPackages ; TMap<FTopLevelAssetPath,FTopLevelAssetPath> CachedBPInheritanceMap ; bool bIsTempCachingEnabled ; bool bIsTempCachingAlwaysEnabled ; Impl::FClassInheritanceBuffer TempCachedInheritanceBuffer ; uint64 SavedGeneratorClassesVersionNumber ; uint64 SavedAllClassesVersionNumber ; FPathTree CachedPathTree ; TUniquePtr<FAssetDataGatherer> GlobalGatherer ; FAssetDataGatherer::FResults BackgroundResults ; TMultiMap<FName,TUniquePtr<FAssetData>> DeferredAssets ; TMultiMap<FName,TUniquePtr<FAssetData>> DeferredAssetsForGameThread ; TMultiMap<FName,FPackageDependencyData> DeferredDependencies ; TMultiMap<FName,FPackageDependencyData> DeferredDependenciesForGameThread ; # if ! NO_LOGGING TMap<FTopLevelAssetPath,int64> TagSizeByClass ; # endif TSet<FName> PersistentMountPoints ; float StoreGatherResultsTimeSeconds ; int32 HighestPending = 0 ; double InitialSearchStartTime = 0 . 0 f ; bool bInitialSearchStarted ; std::atomic<bool> bInitialSearchCompleted ; bool bPreloadingComplete = false ; Impl::EGatherStatus GatherStatus ; Impl::EPerformanceMode PerformanceMode ; bool bVerifyMountPointAfterGather ; bool bSearchAllAssets ; bool bVerboseLogging ; bool bForceCompletionEvenIfPostLoadsFail = false ; bool bProcessedAnyAssetsAfterRetryDeferred = true ; float MaxSecondsPerFrame = 0 . 0 4 f ; TSet<FTopLevelAssetPath> ClassGeneratorNames ; struct FAssetRegistryPackageRedirect { public :)",
    "insertText": "FAssetRegistryPackageRedirect(const FString& InSourcePackageName, const FString& InDestPackageName) : SourcePackageName(InSourcePackageName), DestPackageName(InDestPackageName)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Append(FEventContext&& Other)"
  },
  {
    "label": "BindToBuffer()",
    "kind": "Method",
    "detail": "Function (} ; struct FClassInheritanceContext { FClassInheritanceBuffer* Buffer = nullptr ; FAssetRegistryImpl* AssetRegistryImpl = nullptr ; bool bInheritanceMapUpToDate = false ; bool bCodeGeneratorClassesUpToDate = false ; void)",
    "insertText": "BindToBuffer(FClassInheritanceBuffer& InBuffer, FAssetRegistryImpl& InAssetRegistryImpl, bool bInInheritanceMapUpToDate, bool bInCodeGeneratorClassesUpToDate)"
  },
  {
    "label": "ConditionalUpdate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConditionalUpdate()"
  },
  {
    "label": "FScanPathContext()",
    "kind": "Method",
    "detail": "Function (} ; struct FScanPathContext {)",
    "insertText": "FScanPathContext(FEventContext& InEventContext, FClassInheritanceContext& InInheritanceContext, const TArray<FString>& InDirs, const TArray<FString>& InFiles, UE::AssetRegistry::EScanFlags InScanFlags = UE::AssetRegistry::EScanFlags::None, TArray<FSoftObjectPath>* FoundAssets = nullptr)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (TArray<FString> PackageDirs ; TArray<FString> LocalDirs ; TArray<FString> PackageFiles ; TArray<FString> LocalFiles ; TArray<FString> LocalPaths ; FEventContext& EventContext ; FClassInheritanceContext& InheritanceContext ; TArray<FSoftObjectPath>* OutFoundAssets = nullptr ; int32 NumFoundAssets = 0 ; bool bForceRescan = false ; bool bIgnoreDenyListScanFilters = false ; bool bIgnoreInvalidPathWarning = false ; EGatherStatus Status = EGatherStatus::TickActiveGatherActive ; } ; typedef TFunctionRef<)",
    "insertText": "void(const TMultiMap<FName, FAssetData*>&)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef TFunctionRef<)",
    "insertText": "void(const TRingBuffer<FName>&)"
  },
  {
    "label": "FTickContext()",
    "kind": "Method",
    "detail": "Function (struct FTickContext {)",
    "insertText": "FTickContext(Impl::FEventContext& InEventContext, Impl::FClassInheritanceContext& InInheritanceContext) : EventContext(InEventContext) , InheritanceContext(InInheritanceContext)"
  },
  {
    "label": "IsFilterValid()",
    "kind": "Method",
    "detail": "Function (} Impl::FInterruptionContext InterruptionContext ; Impl::FEventContext& EventContext ; Impl::FClassInheritanceContext& InheritanceContext ; TOptional<FAssetsFoundCallback> AssetsFoundCallback ; TOptional<FVerseFilesFoundCallback> VerseFilesFoundCallback ; bool bHandleCompletion = false ; bool bHandleDeferred = false ; } ; } namespace Utils { enum class EFilterMode : uint8 { Inclusive,Exclusive,} ; bool)",
    "insertText": "IsFilterValid(const FARCompiledFilter& Filter)"
  },
  {
    "label": "RunAssetThroughFilter()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RunAssetThroughFilter(const FAssetData& AssetData, const FARCompiledFilter& Filter, const EFilterMode FilterMode)"
  },
  {
    "label": "RunAssetThroughFilter_Unchecked()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RunAssetThroughFilter_Unchecked(const FAssetData& AssetData, const FARCompiledFilter& Filter, const bool bPassFilterValue)"
  },
  {
    "label": "RunAssetsThroughFilter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RunAssetsThroughFilter(TArray<FAssetData>& AssetDataList, const FARCompiledFilter& Filter, const EFilterMode FilterMode)"
  },
  {
    "label": "InitializeSerializationOptionsFromIni()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeSerializationOptionsFromIni(FAssetRegistrySerializationOptions& Options, const FString& PlatformIniName, ESerializationTarget Target = ESerializationTarget::ForGame)"
  },
  {
    "label": "GetAssetAvailability()",
    "kind": "Method",
    "detail": "Function (EAssetAvailability::Type)",
    "insertText": "GetAssetAvailability(const FAssetData& AssetData)"
  },
  {
    "label": "GetAssetAvailabilityProgress()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetAssetAvailabilityProgress(const FAssetData& AssetData, EAssetAvailabilityProgressReportingType::Type ReportType)"
  },
  {
    "label": "GetAssetAvailabilityProgressTypeSupported()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetAssetAvailabilityProgressTypeSupported(EAssetAvailabilityProgressReportingType::Type ReportType)"
  },
  {
    "label": "PrioritizeAssetInstall()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrioritizeAssetInstall(const FAssetData& AssetData)"
  },
  {
    "label": "ReadAssetFile()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReadAssetFile(FPackageReader& PackageReader, IAssetRegistry::FLoadPackageRegistryData& InOutData)"
  },
  {
    "label": "IsPathMounted()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPathMounted(const FString& Path, const TSet<FString>& MountPointsNoTrailingSlashes, FString& StringBuffer)"
  },
  {
    "label": "EnumerateAllMemoryAssets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateAllMemoryAssets(TSet<FName>& OutPackageNamesWithAssets, bool& bOutStopIteration, TFunctionRef<bool(FAssetData&&)> Callback)"
  },
  {
    "label": "EnumerateMemoryAssetsHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateMemoryAssetsHelper(const FARCompiledFilter& InFilter, TSet<FName>& OutPackageNamesWithAssets, bool& bOutStopIteration, TFunctionRef<bool(const UObject* Object, FAssetData&& PartialAssetData)> Callback, bool bSkipARFilteredAssets)"
  },
  {
    "label": "EnumerateMemoryAssets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateMemoryAssets(const FARCompiledFilter& InFilter, TSet<FName>& OutPackageNamesWithAssets, bool& bOutStopIteration, UE::AssetRegistry::Private::FInterfaceRWLock& InterfaceLock, const FAssetRegistryState& GuardedDataState, TFunctionRef<bool(FAssetData&&)> Callback, bool bSkipARFilteredAssets)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (bGameThreadTakeOverGatherEachTick .)",
    "insertText": "store(bValue, std::memory_order_relaxed)"
  }
]