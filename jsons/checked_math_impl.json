[
  {
    "label": "Enable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Enable"
  },
  {
    "label": "CheckedAddOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedAddOp"
  },
  {
    "label": "CheckedSubOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedSubOp"
  },
  {
    "label": "CheckedMulOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedMulOp"
  },
  {
    "label": "CheckedDivOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedDivOp"
  },
  {
    "label": "CheckedModOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedModOp"
  },
  {
    "label": "CheckedLshOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedLshOp"
  },
  {
    "label": "CheckedRshOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedRshOp"
  },
  {
    "label": "CheckedAndOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedAndOp"
  },
  {
    "label": "CheckedOrOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedOrOp"
  },
  {
    "label": "CheckedXorOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedXorOp"
  },
  {
    "label": "CheckedMaxOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedMaxOp"
  },
  {
    "label": "CheckedMinOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CheckedMinOp"
  },
  {
    "label": "Checked",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Checked"
  },
  {
    "label": "NumericRepresentation",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "NumericRepresentation"
  },
  {
    "label": "GetNumericRepresentation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GetNumericRepresentation"
  },
  {
    "label": "CheckedNumericState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CheckedNumericState"
  },
  {
    "label": "CheckedAddImpl()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_NUMERICS_CHECKED_MATH_IMPL_H_ # define BASE_NUMERICS_CHECKED_MATH_IMPL_H_ # include<stddef . h> # include<stdint . h> # include<climits> # include<cmath> # include<cstdlib> # include<limits> # include<type_traits> # include \" base / numerics / safe_conversions . h \" # include \" base / numerics / safe_math_shared_impl . h \" namespace base { namespace internal { template<T> bool)",
    "insertText": "CheckedAddImpl(T x, T y, T* result)"
  },
  {
    "label": "UnsignedDst()",
    "kind": "Method",
    "detail": "Function (using UnsignedDst = std::make_unsigned<T>::type ; using SignedDst = std::make_signed<T>::type ; const UnsignedDst ux = static_cast<)",
    "insertText": "UnsignedDst(x)"
  },
  {
    "label": "UnsignedDst()",
    "kind": "Method",
    "detail": "Function (const UnsignedDst uy = static_cast<)",
    "insertText": "UnsignedDst(y)"
  },
  {
    "label": "UnsignedDst()",
    "kind": "Method",
    "detail": "Function (const UnsignedDst uresult = static_cast<)",
    "insertText": "UnsignedDst(ux + uy)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (* result = static_cast<)",
    "insertText": "T(uresult)"
  },
  {
    "label": "conditional()",
    "kind": "Method",
    "detail": "Function (using FastPromotion = FastIntegerArithmeticPromotion<T,U>::type ; using Promotion =)",
    "insertText": "conditional(IntegerBitsPlusSign<FastPromotion>::value > IntegerBitsPlusSign<intptr_t>::value)"
  },
  {
    "label": "Promotion()",
    "kind": "Method",
    "detail": "Function (presult = static_cast<)",
    "insertText": "Promotion(x) + static_cast<Promotion>(y)"
  },
  {
    "label": "CheckedAddImpl()",
    "kind": "Method",
    "detail": "Function (} else { is_valid =)",
    "insertText": "CheckedAddImpl(static_cast<Promotion>(x), static_cast<Promotion>(y), &presult)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!is_valid || !IsValueInRangeForNumericType<V>(presult))"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (* result = static_cast<)",
    "insertText": "V(presult)"
  },
  {
    "label": "UnsignedDst()",
    "kind": "Method",
    "detail": "Function (const UnsignedDst uresult = static_cast<)",
    "insertText": "UnsignedDst(ux - uy)"
  },
  {
    "label": "Promotion()",
    "kind": "Method",
    "detail": "Function (presult = static_cast<)",
    "insertText": "Promotion(x) - static_cast<Promotion>(y)"
  },
  {
    "label": "CheckedSubImpl()",
    "kind": "Method",
    "detail": "Function (} else { is_valid =)",
    "insertText": "CheckedSubImpl(static_cast<Promotion>(x), static_cast<Promotion>(y), &presult)"
  },
  {
    "label": "SafeUnsignedAbs()",
    "kind": "Method",
    "detail": "Function (using UnsignedDst = std::make_unsigned<T>::type ; using SignedDst = std::make_signed<T>::type ; const UnsignedDst ux =)",
    "insertText": "SafeUnsignedAbs(x)"
  },
  {
    "label": "SafeUnsignedAbs()",
    "kind": "Method",
    "detail": "Function (const UnsignedDst uy =)",
    "insertText": "SafeUnsignedAbs(y)"
  },
  {
    "label": "UnsignedDst()",
    "kind": "Method",
    "detail": "Function (const UnsignedDst uresult = static_cast<)",
    "insertText": "UnsignedDst(ux * uy)"
  },
  {
    "label": "SignedDst()",
    "kind": "Method",
    "detail": "Function (const bool is_negative = std::is_signed<T>::value&& static_cast<)",
    "insertText": "SignedDst(x ^ y)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (* result = static_cast<)",
    "insertText": "T(is_negative ? 0 - uresult : uresult)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using Promotion = FastIntegerArithmeticPromotion<T,U>::type ;)",
    "insertText": "if(BASE_NUMERICS_UNLIKELY((!IsValueInRangeForNumericType<Promotion>(x) || !IsValueInRangeForNumericType<Promotion>(y)) && x && y))"
  },
  {
    "label": "Do()",
    "kind": "Method",
    "detail": "Function (is_valid = CheckedMulFastOp<Promotion,Promotion)",
    "insertText": "Do(static_cast<Promotion>(x), static_cast<Promotion>(y), &presult)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(IsIntegerArithmeticSafe<Promotion, T, U>::value)"
  },
  {
    "label": "Promotion()",
    "kind": "Method",
    "detail": "Function (presult = static_cast<)",
    "insertText": "Promotion(x) * static_cast<Promotion>(y)"
  },
  {
    "label": "CheckedMulImpl()",
    "kind": "Method",
    "detail": "Function (} else { is_valid =)",
    "insertText": "CheckedMulImpl(static_cast<Promotion>(x), static_cast<Promotion>(y), &presult)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using Promotion = BigEnoughPromotion<T,U>::type ;)",
    "insertText": "if(BASE_NUMERICS_UNLIKELY( (std::is_signed<T>::value && std::is_signed<U>::value && IsTypeInRangeForNumericType<T, Promotion>::value && static_cast<Promotion>(x) == std::numeric_limits<Promotion>::lowest() && y == static_cast<U>(-1))))"
  },
  {
    "label": "Promotion()",
    "kind": "Method",
    "detail": "Function (* result = 0 ; return true ; } const Promotion presult = static_cast<)",
    "insertText": "Promotion(x) % static_cast<Promotion>(y)"
  },
  {
    "label": "Promotion()",
    "kind": "Method",
    "detail": "Function (* result = static_cast<)",
    "insertText": "Promotion(presult)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (* result = static_cast<)",
    "insertText": "V(as_unsigned(x) << shift)"
  },
  {
    "label": "Do()",
    "kind": "Method",
    "detail": "Function (* result = 0 ; return true ; } } ; template<T,U,class Enable = void> struct CheckedRshOp { } ; template<T,U> struct CheckedRshOp<T,U,std::enable_if<std::is_integral<T>::value&& std::is_integral<U>::value>::type> { using result_type = T ; template<V> bool)",
    "insertText": "Do(T x, U shift, V* result)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (* result = static_cast<)",
    "insertText": "V(tmp)"
  },
  {
    "label": "result_type()",
    "kind": "Method",
    "detail": "Function (const result_type tmp = static_cast<)",
    "insertText": "result_type(x) & static_cast<result_type>(y)"
  },
  {
    "label": "result_type()",
    "kind": "Method",
    "detail": "Function (const result_type tmp = static_cast<)",
    "insertText": "result_type(x) | static_cast<result_type>(y)"
  },
  {
    "label": "result_type()",
    "kind": "Method",
    "detail": "Function (const result_type tmp = static_cast<)",
    "insertText": "result_type(x) ^ static_cast<result_type>(y)"
  },
  {
    "label": "Test()",
    "kind": "Method",
    "detail": "Function (const result_type tmp = IsGreater<T,U)",
    "insertText": "Test(x, y) ? static_cast<result_type>(x) : static_cast<result_type>(y)"
  },
  {
    "label": "Do()",
    "kind": "Method",
    "detail": "Function (\\ using result_type = MaxExponentPromotion<T,U>::type ; \\ template<V> \\ bool)",
    "insertText": "Do(T x, U y, V* result)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ using Promotion = MaxExponentPromotion<T,U>::type ; \\ const Promotion presult = x OP y ; \\)",
    "insertText": "if(!IsValueInRangeForNumericType<V>(presult))"
  },
  {
    "label": "BASE_FLOAT_ARITHMETIC_OPS()",
    "kind": "Method",
    "detail": "Function (\\ return true ; \\ } \\ } ;)",
    "insertText": "BASE_FLOAT_ARITHMETIC_OPS(Add, +) BASE_FLOAT_ARITHMETIC_OPS(Sub, -) BASE_FLOAT_ARITHMETIC_OPS(Mul, *) BASE_FLOAT_ARITHMETIC_OPS(Div, /)"
  },
  {
    "label": "NUMERIC_INTEGER()",
    "kind": "Method",
    "detail": "Function (NUMERIC_INTEGER,NUMERIC_FLOATING,NUMERIC_UNKNOWN } ; template<NumericType> struct GetNumericRepresentation { const NumericRepresentation value = std::is_integral<NumericType>::value ?)",
    "insertText": "NUMERIC_INTEGER(std::is_floating_point<NumericType>::value ? NUMERIC_FLOATING : NUMERIC_UNKNOWN)"
  },
  {
    "label": "CheckedNumericState()",
    "kind": "Method",
    "detail": "Function (} ; template<T,NumericRepresentation type = GetNumericRepresentation<T>::value> class CheckedNumericState { } ; template<T> class CheckedNumericState<T,NUMERIC_INTEGER> { public : template<Src = int>)",
    "insertText": "CheckedNumericState(Src value = 0, bool is_valid = true) : is_valid_(is_valid && IsValueInRangeForNumericType<T>(value)), value_(WellDefinedConversionOrZero(value, is_valid_))"
  },
  {
    "label": "CheckedNumericState()",
    "kind": "Method",
    "detail": "Function (} template<Src>)",
    "insertText": "CheckedNumericState(const CheckedNumericState<Src>& rhs) : CheckedNumericState(rhs.value(), rhs.is_valid())"
  },
  {
    "label": "is_valid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_valid()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (using SrcType = internal::UnderlyingType<Src>::type ;)",
    "insertText": "return(std::is_integral<SrcType>::value || is_valid) ? static_cast<T>(value)"
  },
  {
    "label": "CheckedNumericState()",
    "kind": "Method",
    "detail": "Function (} bool is_valid_ ; T value_ ; } ; template<T> class CheckedNumericState<T,NUMERIC_FLOATING> { public : template<Src = double>)",
    "insertText": "CheckedNumericState(Src value = 0.0, bool is_valid = true) : value_(WellDefinedConversionOrNaN( value, is_valid && IsValueInRangeForNumericType<T>(value)))"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "value()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (using SrcType = internal::UnderlyingType<Src>::type ;)",
    "insertText": "return(StaticDstRangeRelationToSrcRange<T, SrcType>::value == NUMERIC_RANGE_CONTAINED || is_valid) ? static_cast<T>(value) : std::numeric_limits<T>::quiet_NaN()"
  }
]