[
  {
    "label": "APInt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "APInt"
  },
  {
    "label": "AssumptionCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AssumptionCache"
  },
  {
    "label": "Constant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Constant"
  },
  {
    "label": "ConstantInt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstantInt"
  },
  {
    "label": "DominatorTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DominatorTree"
  },
  {
    "label": "Type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Type"
  },
  {
    "label": "ScalarEvolution",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScalarEvolution"
  },
  {
    "label": "DataLayout",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DataLayout"
  },
  {
    "label": "TargetLibraryInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetLibraryInfo"
  },
  {
    "label": "LLVMContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LLVMContext"
  },
  {
    "label": "Loop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Loop"
  },
  {
    "label": "LoopInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopInfo"
  },
  {
    "label": "Operator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Operator"
  },
  {
    "label": "SCEVUnknown",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SCEVUnknown"
  },
  {
    "label": "SCEV",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SCEV"
  },
  {
    "label": "FoldingSetTrait",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FoldingSetTrait"
  },
  {
    "label": "NoWrapFlags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "NoWrapFlags"
  },
  {
    "label": "SCEVCouldNotCompute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SCEVCouldNotCompute"
  },
  {
    "label": "LoopDisposition",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "LoopDisposition"
  },
  {
    "label": "BlockDisposition",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "BlockDisposition"
  },
  {
    "label": "SCEVCallbackVH",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SCEVCallbackVH"
  },
  {
    "label": "SCEVExpander",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SCEVExpander"
  },
  {
    "label": "ExitLimit",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExitLimit"
  },
  {
    "label": "ExitNotTakenInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExitNotTakenInfo"
  },
  {
    "label": "BackedgeTakenInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BackedgeTakenInfo"
  },
  {
    "label": "RangeSignHint",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "RangeSignHint"
  },
  {
    "label": "SCEV()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ANALYSIS_SCALAREVOLUTION_H # define LLVM_ANALYSIS_SCALAREVOLUTION_H # include \" llvm / ADT / DenseSet . h \" # include \" llvm / ADT / FoldingSet . h \" # include \" llvm / IR / ConstantRange . h \" # include \" llvm / IR / Function . h \" # include \" llvm / IR / Instructions . h \" # include \" llvm / IR / Operator . h \" # include \" llvm / IR / ValueHandle . h \" # include \" llvm / Pass . h \" # include \" llvm / Support / Allocator . h \" # include \" llvm / Support / DataTypes . h \" # include<map> namespace llvm { class APInt ; class AssumptionCache ; class Constant ; class ConstantInt ; class DominatorTree ; class Type ; class ScalarEvolution ; class DataLayout ; class TargetLibraryInfo ; class LLVMContext ; class Loop ; class LoopInfo ; class Operator ; class SCEVUnknown ; class SCEV ; template<> struct FoldingSetTrait<SCEV> ; class SCEV : public FoldingSetNode { struct FoldingSetTrait<SCEV> ; FoldingSetNodeIDRef FastID ; const unsigned short SCEVType ; protected : unsigned short SubclassData ; private :)",
    "insertText": "SCEV(const SCEV &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const SCEV &)"
  },
  {
    "label": "FlagNW()",
    "kind": "Method",
    "detail": "Function (public : enum NoWrapFlags { FlagAnyWrap = 0,)",
    "insertText": "FlagNW(1 << 0), FlagNUW = (1 << 1), FlagNSW = (1 << 2), NoWrapMask = (1 << 3)"
  },
  {
    "label": "SCEV()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SCEV(const FoldingSetNodeIDRef ID, unsigned SCEVTy) : FastID(ID), SCEVType(SCEVTy), SubclassData(0)"
  },
  {
    "label": "getSCEVType()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getSCEVType()"
  },
  {
    "label": "isZero()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isZero()"
  },
  {
    "label": "isOne()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isOne()"
  },
  {
    "label": "isAllOnesValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isAllOnesValue()"
  },
  {
    "label": "isNonConstantNegative()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isNonConstantNegative()"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(NDEBUG) || defined(LLVM_ENABLE_DUMP) void dump()"
  },
  {
    "label": "Profile()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<> struct FoldingSetTrait<SCEV> : DefaultFoldingSetTrait<SCEV> { void)",
    "insertText": "Profile(const SCEV &X, FoldingSetNodeID& ID)"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (ID = X . FastID ; } bool)",
    "insertText": "Equals(const SCEV &X, const FoldingSetNodeID &ID, unsigned IDHash, FoldingSetNodeID &TempID)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const SCEV &S)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (S .)",
    "insertText": "print(OS)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "classof(const SCEV *S)"
  },
  {
    "label": "maskFlags()",
    "kind": "Method",
    "detail": "Function (} ; class ScalarEvolution : public FunctionPass { public : enum LoopDisposition { LoopVariant,LoopInvariant,LoopComputable } ; enum BlockDisposition { DoesNotDominateBlock,DominatesBlock,ProperlyDominatesBlock } ; SCEV::NoWrapFlags LLVM_ATTRIBUTE_UNUSED_RESULT)",
    "insertText": "maskFlags(SCEV::NoWrapFlags Flags, int Mask)"
  },
  {
    "label": "setFlags()",
    "kind": "Method",
    "detail": "Function (} SCEV::NoWrapFlags LLVM_ATTRIBUTE_UNUSED_RESULT)",
    "insertText": "setFlags(SCEV::NoWrapFlags Flags, SCEV::NoWrapFlags OnFlags)"
  },
  {
    "label": "clearFlags()",
    "kind": "Method",
    "detail": "Function (} SCEV::NoWrapFlags LLVM_ATTRIBUTE_UNUSED_RESULT)",
    "insertText": "clearFlags(SCEV::NoWrapFlags Flags, SCEV::NoWrapFlags OffFlags)"
  },
  {
    "label": "deleted()",
    "kind": "Method",
    "detail": "Function (} private : class SCEVCallbackVH : public CallbackVH { ScalarEvolution* SE ; void)",
    "insertText": "deleted()"
  },
  {
    "label": "allUsesReplacedWith()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "allUsesReplacedWith(Value *New)"
  },
  {
    "label": "SCEVCallbackVH()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "SCEVCallbackVH(Value *V, ScalarEvolution *SE = nullptr)"
  },
  {
    "label": "ExitLimit()",
    "kind": "Method",
    "detail": "Function (} ; class SCEVCallbackVH ; class SCEVExpander ; class SCEVUnknown ; Function* F ; AssumptionCache* AC ; LoopInfo* LI ; TargetLibraryInfo* TLI ; DominatorTree* DT ; SCEVCouldNotCompute CouldNotCompute ; typedef DenseMap<SCEVCallbackVH,const SCEV*,DenseMapInfo<Value*>> ValueExprMapType ; ValueExprMapType ValueExprMap ; DenseSet<Value*> PendingLoopPredicates ; bool WalkingBEDominatingConds ; struct ExitLimit { const SCEV* Exact ; const SCEV* Max ;)",
    "insertText": "ExitLimit(const SCEV *E) : Exact(E), Max(E)"
  },
  {
    "label": "ExitLimit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ExitLimit(const SCEV *E, const SCEV *M) : Exact(E), Max(M)"
  },
  {
    "label": "hasAnyInfo()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasAnyInfo()"
  },
  {
    "label": "ExitNotTakenInfo()",
    "kind": "Method",
    "detail": "Function (} } ; struct ExitNotTakenInfo { AssertingVH<BasicBlock> ExitingBlock ; const SCEV* ExactNotTaken ; PointerIntPair<ExitNotTakenInfo*,1> NextExit ;)",
    "insertText": "ExitNotTakenInfo() : ExitingBlock(nullptr), ExactNotTaken(nullptr)"
  },
  {
    "label": "isCompleteList()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isCompleteList()"
  },
  {
    "label": "setIncomplete()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setIncomplete()"
  },
  {
    "label": "setInt()",
    "kind": "Method",
    "detail": "Function (NextExit .)",
    "insertText": "setInt(1)"
  },
  {
    "label": "getNextExit()",
    "kind": "Method",
    "detail": "Function (} ExitNotTakenInfo*)",
    "insertText": "getNextExit()"
  },
  {
    "label": "setNextExit()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setNextExit(ExitNotTakenInfo *ENT)"
  },
  {
    "label": "setPointer()",
    "kind": "Method",
    "detail": "Function (NextExit .)",
    "insertText": "setPointer(ENT)"
  },
  {
    "label": "BackedgeTakenInfo()",
    "kind": "Method",
    "detail": "Function (} } ; class BackedgeTakenInfo { ExitNotTakenInfo ExitNotTaken ; const SCEV* Max ; public :)",
    "insertText": "BackedgeTakenInfo() : Max(nullptr)"
  },
  {
    "label": "BackedgeTakenInfo()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BackedgeTakenInfo(SmallVectorImpl< std::pair<BasicBlock *, const SCEV *> > &ExitCounts, bool Complete, const SCEV *MaxCount)"
  },
  {
    "label": "getExact()",
    "kind": "Method",
    "detail": "Function (} const SCEV*)",
    "insertText": "getExact(ScalarEvolution *SE)"
  },
  {
    "label": "getExact()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getExact(BasicBlock *ExitingBlock, ScalarEvolution *SE)"
  },
  {
    "label": "getMax()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getMax(ScalarEvolution *SE)"
  },
  {
    "label": "hasOperand()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasOperand(const SCEV *S, ScalarEvolution *SE)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "computeLoopDisposition()",
    "kind": "Method",
    "detail": "Function (} ; DenseMap<const Loop*,BackedgeTakenInfo> BackedgeTakenCounts ; DenseMap<PHINode*,Constant*> ConstantEvolutionLoopExitValue ; DenseMap<const SCEV*,SmallVector<std::pair<const Loop*,const SCEV*>,2>> ValuesAtScopes ; DenseMap<const SCEV*,SmallVector<PointerIntPair<const Loop*,2,LoopDisposition>,2>> LoopDispositions ; LoopDisposition)",
    "insertText": "computeLoopDisposition(const SCEV *S, const Loop *L)"
  },
  {
    "label": "computeBlockDisposition()",
    "kind": "Method",
    "detail": "Function (DenseMap<const SCEV*,SmallVector<PointerIntPair<const BasicBlock*,2,BlockDisposition>,2>> BlockDispositions ; BlockDisposition)",
    "insertText": "computeBlockDisposition(const SCEV *S, const BasicBlock *BB)"
  },
  {
    "label": "setRange()",
    "kind": "Method",
    "detail": "Function (DenseMap<const SCEV*,ConstantRange> UnsignedRanges ; DenseMap<const SCEV*,ConstantRange> SignedRanges ; enum RangeSignHint { HINT_RANGE_UNSIGNED,HINT_RANGE_SIGNED } ; const ConstantRange&)",
    "insertText": "setRange(const SCEV *S, RangeSignHint Hint, const ConstantRange &CR)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (DenseMap<const SCEV*,ConstantRange>& Cache = Hint = = HINT_RANGE_UNSIGNED ? UnsignedRanges : SignedRanges ; std::pair<DenseMap<const SCEV*,ConstantRange>::iterator,bool> Pair = Cache .)",
    "insertText": "insert(std::make_pair(S, CR))"
  },
  {
    "label": "createSCEV()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "createSCEV(Value *V)"
  },
  {
    "label": "createNodeForPHI()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "createNodeForPHI(PHINode *PN)"
  },
  {
    "label": "createNodeForGEP()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "createNodeForGEP(GEPOperator *GEP)"
  },
  {
    "label": "computeSCEVAtScope()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "computeSCEVAtScope(const SCEV *S, const Loop *L)"
  },
  {
    "label": "ForgetSymbolicName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForgetSymbolicName(Instruction *I, const SCEV *SymName)"
  },
  {
    "label": "getBackedgeTakenInfo()",
    "kind": "Method",
    "detail": "Function (const BackedgeTakenInfo&)",
    "insertText": "getBackedgeTakenInfo(const Loop *L)"
  },
  {
    "label": "ComputeBackedgeTakenCount()",
    "kind": "Method",
    "detail": "Function (BackedgeTakenInfo)",
    "insertText": "ComputeBackedgeTakenCount(const Loop *L)"
  },
  {
    "label": "ComputeExitLimit()",
    "kind": "Method",
    "detail": "Function (ExitLimit)",
    "insertText": "ComputeExitLimit(const Loop *L, BasicBlock *ExitingBlock)"
  },
  {
    "label": "ComputeExitLimitFromCond()",
    "kind": "Method",
    "detail": "Function (ExitLimit)",
    "insertText": "ComputeExitLimitFromCond(const Loop *L, Value *ExitCond, BasicBlock *TBB, BasicBlock *FBB, bool IsSubExpr)"
  },
  {
    "label": "ComputeExitLimitFromICmp()",
    "kind": "Method",
    "detail": "Function (ExitLimit)",
    "insertText": "ComputeExitLimitFromICmp(const Loop *L, ICmpInst *ExitCond, BasicBlock *TBB, BasicBlock *FBB, bool IsSubExpr)"
  },
  {
    "label": "ComputeExitLimitFromSingleExitSwitch()",
    "kind": "Method",
    "detail": "Function (ExitLimit)",
    "insertText": "ComputeExitLimitFromSingleExitSwitch(const Loop *L, SwitchInst *Switch, BasicBlock *ExitingBB, bool IsSubExpr)"
  },
  {
    "label": "ComputeLoadConstantCompareExitLimit()",
    "kind": "Method",
    "detail": "Function (ExitLimit)",
    "insertText": "ComputeLoadConstantCompareExitLimit(LoadInst *LI, Constant *RHS, const Loop *L, ICmpInst::Predicate p)"
  },
  {
    "label": "ComputeExitCountExhaustively()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "ComputeExitCountExhaustively(const Loop *L, Value *Cond, bool ExitWhen)"
  },
  {
    "label": "HowFarToZero()",
    "kind": "Method",
    "detail": "Function (ExitLimit)",
    "insertText": "HowFarToZero(const SCEV *V, const Loop *L, bool IsSubExpr)"
  },
  {
    "label": "HowFarToNonZero()",
    "kind": "Method",
    "detail": "Function (ExitLimit)",
    "insertText": "HowFarToNonZero(const SCEV *V, const Loop *L)"
  },
  {
    "label": "HowManyLessThans()",
    "kind": "Method",
    "detail": "Function (ExitLimit)",
    "insertText": "HowManyLessThans(const SCEV *LHS, const SCEV *RHS, const Loop *L, bool isSigned, bool IsSubExpr)"
  },
  {
    "label": "HowManyGreaterThans()",
    "kind": "Method",
    "detail": "Function (ExitLimit)",
    "insertText": "HowManyGreaterThans(const SCEV *LHS, const SCEV *RHS, const Loop *L, bool isSigned, bool IsSubExpr)"
  },
  {
    "label": "getPredecessorWithUniqueSuccessorForBB()",
    "kind": "Method",
    "detail": "Function (std::pair<BasicBlock*,BasicBlock*>)",
    "insertText": "getPredecessorWithUniqueSuccessorForBB(BasicBlock *BB)"
  },
  {
    "label": "isImpliedCond()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS, Value *FoundCondValue, bool Inverse)"
  },
  {
    "label": "isImpliedCondOperands()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isImpliedCondOperands(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS, const SCEV *FoundLHS, const SCEV *FoundRHS)"
  },
  {
    "label": "isImpliedCondOperandsHelper()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isImpliedCondOperandsHelper(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS, const SCEV *FoundLHS, const SCEV *FoundRHS)"
  },
  {
    "label": "isImpliedCondOperandsViaRanges()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isImpliedCondOperandsViaRanges(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS, const SCEV *FoundLHS, const SCEV *FoundRHS)"
  },
  {
    "label": "getConstantEvolutionLoopExitValue()",
    "kind": "Method",
    "detail": "Function (Constant*)",
    "insertText": "getConstantEvolutionLoopExitValue(PHINode *PN, const APInt& BEs, const Loop *L)"
  },
  {
    "label": "isKnownPredicateWithRanges()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isKnownPredicateWithRanges(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "forgetMemoizedResults()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "forgetMemoizedResults(const SCEV *S)"
  },
  {
    "label": "checkValidity()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "checkValidity(const SCEV *S)"
  },
  {
    "label": "proveNoWrapByVaryingStart()",
    "kind": "Method",
    "detail": "Function (template<ExtendOpTy> bool)",
    "insertText": "proveNoWrapByVaryingStart(const SCEV *Start, const SCEV *Step, const Loop *L)"
  },
  {
    "label": "ScalarEvolution()",
    "kind": "Method",
    "detail": "Function (public : char ID ;)",
    "insertText": "ScalarEvolution()"
  },
  {
    "label": "getContext()",
    "kind": "Method",
    "detail": "Function (LLVMContext&)",
    "insertText": "getContext()"
  },
  {
    "label": "isSCEVable()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isSCEVable(Type *Ty)"
  },
  {
    "label": "getTypeSizeInBits()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "getTypeSizeInBits(Type *Ty)"
  },
  {
    "label": "getEffectiveSCEVType()",
    "kind": "Method",
    "detail": "Function (Type*)",
    "insertText": "getEffectiveSCEVType(Type *Ty)"
  },
  {
    "label": "getSCEV()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getSCEV(Value *V)"
  },
  {
    "label": "getConstant()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getConstant(ConstantInt *V)"
  },
  {
    "label": "getConstant()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getConstant(const APInt& Val)"
  },
  {
    "label": "getConstant()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getConstant(Type *Ty, uint64_t V, bool isSigned = false)"
  },
  {
    "label": "getTruncateExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getTruncateExpr(const SCEV *Op, Type *Ty)"
  },
  {
    "label": "getZeroExtendExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getZeroExtendExpr(const SCEV *Op, Type *Ty)"
  },
  {
    "label": "getSignExtendExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getSignExtendExpr(const SCEV *Op, Type *Ty)"
  },
  {
    "label": "getAnyExtendExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getAnyExtendExpr(const SCEV *Op, Type *Ty)"
  },
  {
    "label": "getAddExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getAddExpr(SmallVectorImpl<const SCEV *> &Ops, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap)"
  },
  {
    "label": "getAddExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getAddExpr(const SCEV *LHS, const SCEV *RHS, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (SmallVector<const SCEV*,2> Ops ; Ops .)",
    "insertText": "push_back(LHS)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Ops .)",
    "insertText": "push_back(RHS)"
  },
  {
    "label": "getAddExpr()",
    "kind": "Method",
    "detail": "Function (} const SCEV*)",
    "insertText": "getAddExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (SmallVector<const SCEV*,3> Ops ; Ops .)",
    "insertText": "push_back(Op0)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Ops .)",
    "insertText": "push_back(Op1)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Ops .)",
    "insertText": "push_back(Op2)"
  },
  {
    "label": "getMulExpr()",
    "kind": "Method",
    "detail": "Function (} const SCEV*)",
    "insertText": "getMulExpr(SmallVectorImpl<const SCEV *> &Ops, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap)"
  },
  {
    "label": "getMulExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getMulExpr(const SCEV *LHS, const SCEV *RHS, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap)"
  },
  {
    "label": "getMulExpr()",
    "kind": "Method",
    "detail": "Function (} const SCEV*)",
    "insertText": "getMulExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap)"
  },
  {
    "label": "getUDivExpr()",
    "kind": "Method",
    "detail": "Function (} const SCEV*)",
    "insertText": "getUDivExpr(const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "getUDivExactExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getUDivExactExpr(const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "getAddRecExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getAddRecExpr(const SCEV *Start, const SCEV *Step, const Loop *L, SCEV::NoWrapFlags Flags)"
  },
  {
    "label": "getAddRecExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getAddRecExpr(SmallVectorImpl<const SCEV *> &Operands, const Loop *L, SCEV::NoWrapFlags Flags)"
  },
  {
    "label": "getAddRecExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getAddRecExpr(const SmallVectorImpl<const SCEV *> &Operands, const Loop *L, SCEV::NoWrapFlags Flags)"
  },
  {
    "label": "NewOp()",
    "kind": "Method",
    "detail": "Function (SmallVector<const SCEV*,4>)",
    "insertText": "NewOp(Operands.begin(), Operands.end())"
  },
  {
    "label": "getGEPExpr()",
    "kind": "Method",
    "detail": "Function (} const SCEV*)",
    "insertText": "getGEPExpr(Type *PointeeType, const SCEV *BaseExpr, const SmallVectorImpl<const SCEV *> &IndexExprs, bool InBounds = false)"
  },
  {
    "label": "getSMaxExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getSMaxExpr(const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "getSMaxExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getSMaxExpr(SmallVectorImpl<const SCEV *> &Operands)"
  },
  {
    "label": "getUMaxExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getUMaxExpr(const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "getUMaxExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getUMaxExpr(SmallVectorImpl<const SCEV *> &Operands)"
  },
  {
    "label": "getSMinExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getSMinExpr(const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "getUMinExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getUMinExpr(const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "getUnknown()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getUnknown(Value *V)"
  },
  {
    "label": "getCouldNotCompute()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getCouldNotCompute()"
  },
  {
    "label": "getSizeOfExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getSizeOfExpr(Type *IntTy, Type *AllocTy)"
  },
  {
    "label": "getOffsetOfExpr()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getOffsetOfExpr(Type *IntTy, StructType *STy, unsigned FieldNo)"
  },
  {
    "label": "getNegativeSCEV()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getNegativeSCEV(const SCEV *V)"
  },
  {
    "label": "getNotSCEV()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getNotSCEV(const SCEV *V)"
  },
  {
    "label": "getMinusSCEV()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getMinusSCEV(const SCEV *LHS, const SCEV *RHS, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap)"
  },
  {
    "label": "getTruncateOrZeroExtend()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getTruncateOrZeroExtend(const SCEV *V, Type *Ty)"
  },
  {
    "label": "getTruncateOrSignExtend()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getTruncateOrSignExtend(const SCEV *V, Type *Ty)"
  },
  {
    "label": "getNoopOrZeroExtend()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getNoopOrZeroExtend(const SCEV *V, Type *Ty)"
  },
  {
    "label": "getNoopOrSignExtend()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getNoopOrSignExtend(const SCEV *V, Type *Ty)"
  },
  {
    "label": "getNoopOrAnyExtend()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getNoopOrAnyExtend(const SCEV *V, Type *Ty)"
  },
  {
    "label": "getTruncateOrNoop()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getTruncateOrNoop(const SCEV *V, Type *Ty)"
  },
  {
    "label": "getUMaxFromMismatchedTypes()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getUMaxFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "getUMinFromMismatchedTypes()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getUMinFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "getPointerBase()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getPointerBase(const SCEV *V)"
  },
  {
    "label": "getSCEVAtScope()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getSCEVAtScope(const SCEV *S, const Loop *L)"
  },
  {
    "label": "getSCEVAtScope()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getSCEVAtScope(Value *V, const Loop *L)"
  },
  {
    "label": "isLoopEntryGuardedByCond()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLoopEntryGuardedByCond(const Loop *L, ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "isLoopBackedgeGuardedByCond()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLoopBackedgeGuardedByCond(const Loop *L, ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "getSmallConstantTripCount()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getSmallConstantTripCount(Loop *L)"
  },
  {
    "label": "getSmallConstantTripCount()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getSmallConstantTripCount(Loop *L, BasicBlock *ExitingBlock)"
  },
  {
    "label": "getSmallConstantTripMultiple()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getSmallConstantTripMultiple(Loop *L)"
  },
  {
    "label": "getSmallConstantTripMultiple()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getSmallConstantTripMultiple(Loop *L, BasicBlock *ExitingBlock)"
  },
  {
    "label": "getExitCount()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getExitCount(Loop *L, BasicBlock *ExitingBlock)"
  },
  {
    "label": "getBackedgeTakenCount()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getBackedgeTakenCount(const Loop *L)"
  },
  {
    "label": "getMaxBackedgeTakenCount()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getMaxBackedgeTakenCount(const Loop *L)"
  },
  {
    "label": "hasLoopInvariantBackedgeTakenCount()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasLoopInvariantBackedgeTakenCount(const Loop *L)"
  },
  {
    "label": "forgetLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "forgetLoop(const Loop *L)"
  },
  {
    "label": "forgetValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "forgetValue(Value *V)"
  },
  {
    "label": "forgetLoopDispositions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "forgetLoopDispositions(const Loop *L)"
  },
  {
    "label": "GetMinTrailingZeros()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "GetMinTrailingZeros(const SCEV *S)"
  },
  {
    "label": "getUnsignedRange()",
    "kind": "Method",
    "detail": "Function (ConstantRange)",
    "insertText": "getUnsignedRange(const SCEV *S)"
  },
  {
    "label": "getSignedRange()",
    "kind": "Method",
    "detail": "Function (} ConstantRange)",
    "insertText": "getSignedRange(const SCEV *S)"
  },
  {
    "label": "isKnownNegative()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isKnownNegative(const SCEV *S)"
  },
  {
    "label": "isKnownPositive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isKnownPositive(const SCEV *S)"
  },
  {
    "label": "isKnownNonNegative()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isKnownNonNegative(const SCEV *S)"
  },
  {
    "label": "isKnownNonPositive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isKnownNonPositive(const SCEV *S)"
  },
  {
    "label": "isKnownNonZero()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isKnownNonZero(const SCEV *S)"
  },
  {
    "label": "isKnownPredicate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isKnownPredicate(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS)"
  },
  {
    "label": "SimplifyICmpOperands()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SimplifyICmpOperands(ICmpInst::Predicate &Pred, const SCEV *&LHS, const SCEV *&RHS, unsigned Depth = 0)"
  },
  {
    "label": "getLoopDisposition()",
    "kind": "Method",
    "detail": "Function (LoopDisposition)",
    "insertText": "getLoopDisposition(const SCEV *S, const Loop *L)"
  },
  {
    "label": "isLoopInvariant()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLoopInvariant(const SCEV *S, const Loop *L)"
  },
  {
    "label": "hasComputableLoopEvolution()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasComputableLoopEvolution(const SCEV *S, const Loop *L)"
  },
  {
    "label": "getBlockDisposition()",
    "kind": "Method",
    "detail": "Function (BlockDisposition)",
    "insertText": "getBlockDisposition(const SCEV *S, const BasicBlock *BB)"
  },
  {
    "label": "dominates()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "dominates(const SCEV *S, const BasicBlock *BB)"
  },
  {
    "label": "properlyDominates()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "properlyDominates(const SCEV *S, const BasicBlock *BB)"
  },
  {
    "label": "hasOperand()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasOperand(const SCEV *S, const SCEV *Op)"
  },
  {
    "label": "getElementSize()",
    "kind": "Method",
    "detail": "Function (const SCEV*)",
    "insertText": "getElementSize(Instruction *Inst)"
  },
  {
    "label": "findArrayDimensions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "findArrayDimensions(SmallVectorImpl<const SCEV *> &Terms, SmallVectorImpl<const SCEV *> &Sizes, const SCEV *ElementSize)"
  },
  {
    "label": "runOnFunction()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "runOnFunction(Function &F)"
  },
  {
    "label": "releaseMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releaseMemory()"
  },
  {
    "label": "getAnalysisUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getAnalysisUsage(AnalysisUsage &AU)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS, const Module* = nullptr)"
  },
  {
    "label": "verifyAnalysis()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "verifyAnalysis()"
  },
  {
    "label": "collectParametricTerms()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collectParametricTerms(const SCEV *Expr, SmallVectorImpl<const SCEV *> &Terms)"
  },
  {
    "label": "computeAccessFunctions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeAccessFunctions(const SCEV *Expr, SmallVectorImpl<const SCEV *> &Subscripts, SmallVectorImpl<const SCEV *> &Sizes)"
  },
  {
    "label": "delinearize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "delinearize(const SCEV *Expr, SmallVectorImpl<const SCEV *> &Subscripts, SmallVectorImpl<const SCEV *> &Sizes, const SCEV *ElementSize)"
  },
  {
    "label": "computeBECount()",
    "kind": "Method",
    "detail": "Function (private : const SCEV*)",
    "insertText": "computeBECount(const SCEV *Delta, const SCEV *Stride, bool Equality)"
  },
  {
    "label": "doesIVOverflowOnLT()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "doesIVOverflowOnLT(const SCEV *RHS, const SCEV *Stride, bool IsSigned, bool NoWrap)"
  },
  {
    "label": "doesIVOverflowOnGT()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "doesIVOverflowOnGT(const SCEV *RHS, const SCEV *Stride, bool IsSigned, bool NoWrap)"
  }
]