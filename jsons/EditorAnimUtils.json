[
  {
    "label": "UAnimationAsset",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimationAsset"
  },
  {
    "label": "UAnimBlueprint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimBlueprint"
  },
  {
    "label": "UAnimSequenceBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimSequenceBase"
  },
  {
    "label": "FNameDuplicationRule",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNameDuplicationRule"
  },
  {
    "label": "FAnimationRetargetContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimationRetargetContext"
  },
  {
    "label": "AssetType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AssetType"
  },
  {
    "label": "FNameDuplicationRule()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / UnrealType . h \" # include \" Animation / AnimCurveTypes . h \" # include \" AssetRegistry / AssetData . h \" class UAnimationAsset ; class UAnimBlueprint ; class UAnimSequenceBase ; namespace EditorAnimUtils { struct FNameDuplicationRule { FString Prefix ; FString Suffix ; FString ReplaceFrom ; FString ReplaceTo ; FString FolderPath ;)",
    "insertText": "FNameDuplicationRule() : Prefix(), Suffix(), ReplaceFrom(), ReplaceTo(), FolderPath(TEXT(\"/Game\"))"
  },
  {
    "label": "Rename()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "Rename(const UObject* Asset)"
  },
  {
    "label": "FAnimationRetargetContext()",
    "kind": "Method",
    "detail": "Function (} ; class FAnimationRetargetContext { public :)",
    "insertText": "FAnimationRetargetContext(const TArray<FAssetData>& AssetsToRetarget, bool bRetargetReferredAssets, bool bInConvertAnimationDataInComponentSpaces, const FNameDuplicationRule& NameRule=FNameDuplicationRule())"
  },
  {
    "label": "FAnimationRetargetContext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAnimationRetargetContext(TArray<TWeakObjectPtr<UObject>> AssetsToRetarget, bool bRetargetReferredAssets, bool bInConvertAnimationDataInComponentSpaces, const FNameDuplicationRule& NameRule=FNameDuplicationRule())"
  },
  {
    "label": "HasAssetsToRetarget()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasAssetsToRetarget()"
  },
  {
    "label": "HasDuplicates()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasDuplicates()"
  },
  {
    "label": "GetSingleTargetObject()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "GetSingleTargetObject()"
  },
  {
    "label": "GetDuplicate()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "GetDuplicate(const UObject* OriginalObject)"
  },
  {
    "label": "GetAllDuplicates()",
    "kind": "Method",
    "detail": "Function (TArray<UObject*>)",
    "insertText": "GetAllDuplicates()"
  },
  {
    "label": "DuplicateAssetsToRetarget()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DuplicateAssetsToRetarget(UPackage* DestinationPackage, const FNameDuplicationRule* NameRule)"
  },
  {
    "label": "RetargetAnimations()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RetargetAnimations(USkeleton* OldSkeleton, USkeleton* NewSkeleton)"
  },
  {
    "label": "AddRemappedAsset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRemappedAsset(UAnimationAsset* OriginalAsset, UAnimationAsset* NewAsset)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (private : TArray<UAnimationAsset*> AnimationAssetsToRetarget ; TArray<UAnimBlueprint*> AnimBlueprintsToRetarget ; TMap<UAnimationAsset*,UAnimationAsset*> DuplicatedAnimAssets ; TMap<UAnimBlueprint*,UAnimBlueprint*> DuplicatedBlueprints ; TMap<UAnimationAsset*,UAnimationAsset*> RemappedAnimAssets ; UObject* SingleTargetObject ; bool bConvertAnimationDataInComponentSpaces ; void)",
    "insertText": "Initialize(TArray<TWeakObjectPtr<UObject>> AssetsToRetarget, bool bRetargetReferredAssets)"
  },
  {
    "label": "RetargetAnimations()",
    "kind": "Method",
    "detail": "Function (} ; UObject*)",
    "insertText": "RetargetAnimations(USkeleton* OldSkeleton, USkeleton* NewSkeleton, TArray<TWeakObjectPtr<UObject>> AssetsToRetarget, bool bRetargetReferredAssets, const FNameDuplicationRule* NameRule, bool bConvertSpace)"
  },
  {
    "label": "RetargetAnimations()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "RetargetAnimations(USkeleton* OldSkeleton, USkeleton* NewSkeleton, const TArray<FAssetData>& AssetsToRetarget, bool bRetargetReferredAssets, const FNameDuplicationRule* NameRule, bool bConvertSpace)"
  },
  {
    "label": "RetargetAnimations()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "RetargetAnimations(USkeleton* OldSkeleton, USkeleton* NewSkeleton, FAnimationRetargetContext& RetargetContext, bool bRetargetReferredAssets, const FNameDuplicationRule* NameRule)"
  },
  {
    "label": "GetAllAnimationSequencesReferredInBlueprint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetAllAnimationSequencesReferredInBlueprint(UAnimBlueprint* AnimBlueprint, TArray<UAnimationAsset*>& AnimationAsset)"
  },
  {
    "label": "ReplaceReferredAnimationsInBlueprint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReplaceReferredAnimationsInBlueprint(UAnimBlueprint* AnimBlueprint, const TMap<UAnimationAsset*, UAnimationAsset*>& AnimAssetReplacementMap)"
  },
  {
    "label": "DuplicateAssetsInternal()",
    "kind": "Method",
    "detail": "Function (TMap<UObject*,UObject*>)",
    "insertText": "DuplicateAssetsInternal(const TArray<UObject*>& AssetsToDuplicate, UPackage* DestinationPackage, const FNameDuplicationRule* NameRule)"
  },
  {
    "label": "DuplicateAssets()",
    "kind": "Method",
    "detail": "Function (template<class AssetType> TMap<AssetType*,AssetType*>)",
    "insertText": "DuplicateAssets(const TArray<AssetType*>& AssetsToDuplicate, UPackage* DestinationPackage, const FNameDuplicationRule* NameRule)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<UObject*> Assets ;)",
    "insertText": "for(auto Iter = AssetsToDuplicate.CreateConstIterator(); Iter; ++Iter)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Assets .)",
    "insertText": "Add(*Iter)"
  },
  {
    "label": "DuplicateAssetsInternal()",
    "kind": "Method",
    "detail": "Function (} TMap<UObject*,UObject*> AssetMap =)",
    "insertText": "DuplicateAssetsInternal(Assets, DestinationPackage, NameRule)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TMap<AssetType*,AssetType*> ReturnMap ;)",
    "insertText": "for(auto Iter = AssetMap.CreateIterator(); Iter; ++Iter)"
  },
  {
    "label": "GetAssetsFromProperties()",
    "kind": "Method",
    "detail": "Function (} return ReturnMap ; } template<class AssetType> void)",
    "insertText": "GetAssetsFromProperties(TArray<FProperty*> InProperties, UObject* Scope, TArray<AssetType*>& OutAssets)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (OutAssets .)",
    "insertText": "Empty()"
  },
  {
    "label": "Helper()",
    "kind": "Method",
    "detail": "Function (FScriptArrayHelper)",
    "insertText": "Helper(ArrayProp, Prop->ContainerPtrToValuePtr<uint8>(Scope))"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 ArrayNum = Helper .)",
    "insertText": "Num()"
  },
  {
    "label": "Object()",
    "kind": "Method",
    "detail": "Function (UObject**)",
    "insertText": "Object(UObject**)Helper.GetRawPtr(Idx)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutAssets .)",
    "insertText": "Add(Asset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else)",
    "insertText": "if(Prop->ArrayDim > 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } } else)",
    "insertText": "if(UObject** ResolvedObject = Prop->ContainerPtrToValuePtr<UObject*>(Scope))"
  }
]