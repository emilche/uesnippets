[
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "FEnsureHandlerArgs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEnsureHandlerArgs"
  },
  {
    "label": "TFunction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TFunction"
  },
  {
    "label": "FDebug",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDebug"
  },
  {
    "label": "InnerType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InnerType"
  },
  {
    "label": "FRecursionScopeMarker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRecursionScopeMarker"
  },
  {
    "label": "FStaticEnsureRecord",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStaticEnsureRecord"
  },
  {
    "label": "UE_DEPRECATED",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UE_DEPRECATED"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" HAL / Platform . h \" # include \" HAL / PlatformMisc . h \" # include \" HAL / PreprocessorHelpers . h \" # include \" Templates / EnableIf . h \" # include \" Templates / IsArrayOrRefOfTypeByPredicate . h \" # include \" Templates / IsValidVariadicFunctionArg . h \" # include \" Traits / IsCharEncodingCompatibleWith . h \" # include \" Misc / VarArgs . h \" # include \" String / FormatStringSan . h \" # include<atomic> # ifndef UE_DEBUG_SECTION #)",
    "insertText": "if(DO_CHECK || DO_GUARD_SLOW || DO_ENSURE) && !PLATFORM_CPU_ARM_FAMILY #define UE_DEBUG_SECTION PLATFORM_CODE_SECTION(\".uedbg\")"
  },
  {
    "label": "PrintScriptCallstack()",
    "kind": "Method",
    "detail": "Function (enum Type : uint8 ; } \" C \" void)",
    "insertText": "PrintScriptCallstack()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (struct FEnsureHandlerArgs { const ANSICHAR* Expression ; const TCHAR* Message ; } ; template<FuncType> class TFunction ; TFunction<)",
    "insertText": "bool(const FEnsureHandlerArgs& Args)> SetEnsureHandler(TFunction<bool(const FEnsureHandlerArgs& Args)> EnsureHandler)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (TFunction<)",
    "insertText": "bool(const FEnsureHandlerArgs& Args)> GetEnsureHandler()"
  },
  {
    "label": "AssertFailed()",
    "kind": "Method",
    "detail": "Function (struct FDebug { void VARARGS)",
    "insertText": "AssertFailed(const ANSICHAR* Expr, const ANSICHAR* File, int32 Line, const TCHAR* Format = TEXT(\"\"), ...)"
  },
  {
    "label": "AssertFailedV()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertFailedV(const ANSICHAR* Expr, const ANSICHAR* File, int32 Line, const TCHAR* Format, va_list Args)"
  },
  {
    "label": "ProcessFatalError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessFatalError(void* ProgramCounter)"
  },
  {
    "label": "HasAsserted()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasAsserted()"
  },
  {
    "label": "IsEnsuring()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEnsuring()"
  },
  {
    "label": "GetNumEnsureFailures()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetNumEnsureFailures()"
  },
  {
    "label": "DumpStackTraceToLog()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DumpStackTraceToLog(const ELogVerbosity::Type LogVerbosity)"
  },
  {
    "label": "DumpStackTraceToLog()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DumpStackTraceToLog(const TCHAR* Heading, const ELogVerbosity::Type LogVerbosity)"
  },
  {
    "label": "CheckVerifyFailedImpl()",
    "kind": "Method",
    "detail": "Function (# if DO_CHECK | | DO_GUARD_SLOW | | DO_ENSURE public : bool VARARGS)",
    "insertText": "CheckVerifyFailedImpl(const ANSICHAR* Expr, const ANSICHAR* File, int32 Line, void* ProgramCounter, const TCHAR* Format, ...)"
  },
  {
    "label": "CheckVerifyFailedImpl2()",
    "kind": "Method",
    "detail": "Function (bool VARARGS)",
    "insertText": "CheckVerifyFailedImpl2(const ANSICHAR* Expr, const ANSICHAR* File, int32 Line, const TCHAR* Format, ...)"
  },
  {
    "label": "LogAssertFailedMessageImpl()",
    "kind": "Method",
    "detail": "Function (private : void VARARGS)",
    "insertText": "LogAssertFailedMessageImpl(const ANSICHAR* Expr, const ANSICHAR* File, int32 Line, void* ProgramCounter, const TCHAR* Fmt, ...)"
  },
  {
    "label": "LogAssertFailedMessageImplV()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LogAssertFailedMessageImplV(const ANSICHAR* Expr, const ANSICHAR* File, int32 Line, void* ProgramCounter, const TCHAR* Fmt, va_list Args)"
  },
  {
    "label": "EnsureFailed()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "EnsureFailed(const ANSICHAR* Expr, const ANSICHAR* File, int32 Line, void* ProgramCounter, const TCHAR* Msg)"
  },
  {
    "label": "OptionallyLogFormattedEnsureMessageReturningFalseImpl()",
    "kind": "Method",
    "detail": "Function (private : bool VARARGS)",
    "insertText": "OptionallyLogFormattedEnsureMessageReturningFalseImpl(bool bLog, const ANSICHAR* Expr, const ANSICHAR* File, int32 Line, void* ProgramCounter, const TCHAR* FormattedMsg, ...)"
  },
  {
    "label": "OptionallyLogFormattedEnsureMessageReturningFalseImpl()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OptionallyLogFormattedEnsureMessageReturningFalseImpl(bool bLog, const ANSICHAR* Expr, const ANSICHAR* File, int32 Line, void* ProgramCounter, const TCHAR* FormattedMsg, va_list Args)"
  },
  {
    "label": "OptionallyLogFormattedEnsureMessageReturningFalse()",
    "kind": "Method",
    "detail": "Function (public : template<FmtType,. . . Types> bool)",
    "insertText": "OptionallyLogFormattedEnsureMessageReturningFalse(bool bLog, const ANSICHAR* Expr, const ANSICHAR* File, int32 Line, void* ProgramCounter, const FmtType& FormattedMsg, Types... Args)"
  },
  {
    "label": "OptionallyLogFormattedEnsureMessageReturningFalse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "OptionallyLogFormattedEnsureMessageReturningFalse(bool bLog, const ANSICHAR* Expr, const ANSICHAR* File, int32 Line, void* ProgramCounter, const TCHAR* FormattedMsg, va_list Args)"
  },
  {
    "label": "LogFormattedMessageWithCallstack()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "LogFormattedMessageWithCallstack(const FName& LogName, const ANSICHAR* File, int32 Line, const TCHAR* Heading, const TCHAR* Message, ELogVerbosity::Type Verbosity)"
  },
  {
    "label": "DispatchCheckVerify()",
    "kind": "Method",
    "detail": "Function (} ; template<RetType = void,class InnerType,. . . ArgTypes> RetType UE_COLD UE_DEBUG_SECTION)",
    "insertText": "DispatchCheckVerify(InnerType&& Inner, ArgTypes const&... Args)"
  },
  {
    "label": "UE_DEBUG_BREAK_AND_PROMPT_FOR_REMOTE()",
    "kind": "Method",
    "detail": "Function (} # if ! UE_BUILD_SHIPPING # define)",
    "insertText": "UE_DEBUG_BREAK_AND_PROMPT_FOR_REMOTE() \\ if (!FPlatformMisc::IsDebuggerPresent())"
  },
  {
    "label": "PromptForRemoteDebugging()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PromptForRemoteDebugging(false)"
  },
  {
    "label": "UE_DEBUG_BREAK()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UE_DEBUG_BREAK()"
  },
  {
    "label": "UE_DEBUG_BREAK_AND_PROMPT_FOR_REMOTE()",
    "kind": "Method",
    "detail": "Function (# else # define)",
    "insertText": "UE_DEBUG_BREAK_AND_PROMPT_FOR_REMOTE() #endif #define _DebugBreakAndPromptForRemote() \\ UE_DEPRECATED_MACRO(5.1, \"Use UE_DEBUG_BREAK_AND_PROMPT_FOR_REMOTE.\")"
  },
  {
    "label": "PLATFORM_BREAK_IF_DESIRED()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "PLATFORM_BREAK_IF_DESIRED() if (LIKELY(!GIgnoreDebugger))"
  },
  {
    "label": "PLATFORM_BREAK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PLATFORM_BREAK()"
  },
  {
    "label": "PLATFORM_BREAK_IF_DESIRED()",
    "kind": "Method",
    "detail": "Function (} # else # define)",
    "insertText": "PLATFORM_BREAK_IF_DESIRED() PLATFORM_BREAK()"
  },
  {
    "label": "checkCode()",
    "kind": "Method",
    "detail": "Function (# endif # if DO_CHECK # ifndef checkCode # define)",
    "insertText": "checkCode(Code)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Code ; })",
    "insertText": "while(false)"
  },
  {
    "label": "verify()",
    "kind": "Method",
    "detail": "Function (# endif # ifndef verify # define)",
    "insertText": "verify(expr) UE_CHECK_IMPL(expr) #endif #ifndef check #define check(expr) UE_CHECK_IMPL(expr) #endif #define UE_CHECK_IMPL(expr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(UNLIKELY(!(expr)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(FDebug::CheckVerifyFailedImpl2(#expr, __FILE__, __LINE__, TEXT(\"\")))"
  },
  {
    "label": "CA_ASSUME()",
    "kind": "Method",
    "detail": "Function (\\ } \\)",
    "insertText": "CA_ASSUME(false)"
  },
  {
    "label": "verifyf()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # ifndef verifyf # define)",
    "insertText": "verifyf(expr, format, ...) UE_CHECK_F_IMPL(expr, format, ##__VA_ARGS__) #endif #ifndef checkf #define checkf(expr, format, ...) UE_CHECK_F_IMPL(expr, format, ##__VA_ARGS__) #endif #define UE_CHECK_F_IMPL(expr, format, ...)"
  },
  {
    "label": "UE_VALIDATE_FORMAT_STRING()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "UE_VALIDATE_FORMAT_STRING(format, ##__VA_ARGS__)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(FDebug::CheckVerifyFailedImpl2(#expr, __FILE__, __LINE__, format, ##__VA_ARGS__))"
  },
  {
    "label": "checkNoEntry()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # ifndef checkNoEntry # define)",
    "insertText": "checkNoEntry() check(!\"Enclosing block should never be called\") #endif #ifndef checkNoReentry #define checkNoReentry()"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (bool s_beenHere # # __LINE__ = false ; \\)",
    "insertText": "check(!\"Enclosing block was called more than once\" || !s_beenHere##__LINE__)"
  },
  {
    "label": "FRecursionScopeMarker()",
    "kind": "Method",
    "detail": "Function (\\ s_beenHere # # __LINE__ = true ; } # endif class FRecursionScopeMarker { public :)",
    "insertText": "FRecursionScopeMarker(uint16 &InCounter) : Counter( InCounter)"
  },
  {
    "label": "FRecursionScopeMarker()",
    "kind": "Method",
    "detail": "Function (+ + Counter ; } ~)",
    "insertText": "FRecursionScopeMarker()"
  },
  {
    "label": "checkNoRecursion()",
    "kind": "Method",
    "detail": "Function (- - Counter ; } private : uint16& Counter ; } ; # ifndef checkNoRecursion # define)",
    "insertText": "checkNoRecursion()"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "check(!\"Enclosing block was entered recursively\" || RecursionCounter##__LINE__ == 0)"
  },
  {
    "label": "__LINE__()",
    "kind": "Method",
    "detail": "Function (\\ const FRecursionScopeMarker ScopeMarker # #)",
    "insertText": "__LINE__(RecursionCounter##__LINE__ ) #endif #ifndef unimplemented #define unimplemented() check(!\"Unimplemented function called\") #endif #else #define checkCode(...) #define check(expr)"
  },
  {
    "label": "CA_ASSUME()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CA_ASSUME(expr)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "checkf(expr, format, ...)"
  },
  {
    "label": "checkNoEntry()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "checkNoEntry() #define checkNoReentry() #define checkNoRecursion() #define verify(expr)"
  },
  {
    "label": "verifyf()",
    "kind": "Method",
    "detail": "Function (} } # define)",
    "insertText": "verifyf(expr, format, ...)"
  },
  {
    "label": "unimplemented()",
    "kind": "Method",
    "detail": "Function (} } # define)",
    "insertText": "unimplemented()"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (} # endif # if DO_GUARD_SLOW # define)",
    "insertText": "checkSlow(expr) check(expr) #define checkfSlow(expr, format, ...) checkf(expr, format, ##__VA_ARGS__) #define verifySlow(expr) check(expr) #else #define checkSlow(expr)"
  },
  {
    "label": "checkfSlow()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "checkfSlow(expr, format, ...)"
  },
  {
    "label": "verifySlow()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "verifySlow(expr)"
  },
  {
    "label": "FStaticEnsureRecord()",
    "kind": "Method",
    "detail": "Function (} } # endif # if DO_ENSURE&& ! USING_CODE_ANALYSIS namespace UE::Assert::Private { struct FStaticEnsureRecord { const TCHAR* Format = nullptr ; const ANSICHAR* Expression = nullptr ; const ANSICHAR* File = nullptr ; int32 Line = 0 ; bool bAlways = false ;)",
    "insertText": "FStaticEnsureRecord(const TCHAR* InFormat, const ANSICHAR* InExpression, const ANSICHAR* InFile, int32 InLine, bool bInAlways) : Format(InFormat) , Expression(InExpression) , File(InFile) , Line(InLine) , bAlways(bInAlways)"
  },
  {
    "label": "EnsureFailed()",
    "kind": "Method",
    "detail": "Function (} } ; bool UE_COLD UE_DEBUG_SECTION VARARGS)",
    "insertText": "EnsureFailed(std::atomic<bool>& bExecuted, const FStaticEnsureRecord* Ensure, ...)"
  },
  {
    "label": "ExecCheckImplInternal()",
    "kind": "Method",
    "detail": "Function (bool UE_COLD UE_DEBUG_SECTION)",
    "insertText": "ExecCheckImplInternal(std::atomic<bool>& bExecuted, bool bAlways, const ANSICHAR* File, int32 Line, const ANSICHAR* Expr)"
  },
  {
    "label": "FValidateArgsInternal()",
    "kind": "Method",
    "detail": "Function (template<. . . Types>)",
    "insertText": "FValidateArgsInternal(Types... Args)"
  },
  {
    "label": "UE_ENSURE_IMPL()",
    "kind": "Method",
    "detail": "Function (} } ; # define)",
    "insertText": "UE_ENSURE_IMPL(Always, InExpression) \\ (LIKELY(!!(InExpression)) \\ || (::UE::Assert::Private::ExecCheckImplInternal([]() UE_COLD UE_DEBUG_SECTION -> std::atomic<bool>& { static std::atomic<bool> ENSURE_bExecuted = false; return ENSURE_bExecuted; } (), Always, __FILE__, __LINE__, #InExpression) \\ && [] () { PLATFORM_BREAK(); return false; } ())) #define UE_ENSURE_IMPL2(Capture, Always, InExpression, InFormat, ...) \\ (LIKELY(!!(InExpression)) || ([Capture] () UE_COLD UE_DEBUG_SECTION \\ { \\ UE_VALIDATE_FORMAT_STRING(InFormat, ##__VA_ARGS__); \\ static std::atomic<bool> ENSURE_bExecuted = false; \\ static constexpr ::UE::Assert::Private::FStaticEnsureRecord ENSURE_Static(InFormat, #InExpression, __builtin_FILE(), __builtin_LINE(), Always); \\ if ((Always || !ENSURE_bExecuted.load(std::memory_order_relaxed)) && FPlatformMisc::IsEnsureAllowed() && ::UE::Assert::Private::EnsureFailed(ENSURE_bExecuted, &ENSURE_Static, ##__VA_ARGS__)) \\ { \\ PLATFORM_BREAK(); \\ } \\ return false; \\ } ())) #define ensure( InExpression ) UE_ENSURE_IMPL ( false, InExpression) #define ensureMsgf( InExpression, InFormat, ... ) UE_ENSURE_IMPL2(&, false, InExpression, InFormat, ##__VA_ARGS__) #define ensureAlways( InExpression ) UE_ENSURE_IMPL ( true, InExpression) #define ensureAlwaysMsgf( InExpression, InFormat, ... ) UE_ENSURE_IMPL2(&, true, InExpression, InFormat, ##__VA_ARGS__) #else #define ensure( InExpression ) (LIKELY(!!(InExpression))) #define ensureMsgf( InExpression, InFormat, ... ) (LIKELY(!!(InExpression))) #define ensureAlways( InExpression ) (LIKELY(!!(InExpression))) #define ensureAlwaysMsgf( InExpression, InFormat, ... ) (LIKELY(!!(InExpression)))"
  },
  {
    "label": "GetMemberNameCheckedJunk()",
    "kind": "Method",
    "detail": "Function (template<T> bool)",
    "insertText": "GetMemberNameCheckedJunk(const T&)"
  },
  {
    "label": "GetMemberNameCheckedJunk()",
    "kind": "Method",
    "detail": "Function (template<T> bool)",
    "insertText": "GetMemberNameCheckedJunk(const volatile T&)"
  },
  {
    "label": "GetMemberNameCheckedJunk()",
    "kind": "Method",
    "detail": "Function (template<R,. . . Args> bool)",
    "insertText": "GetMemberNameCheckedJunk(R(*)(Args...))"
  },
  {
    "label": "GET_ENUMERATOR_NAME_CHECKED()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "GET_ENUMERATOR_NAME_CHECKED(EnumName, EnumeratorName) \\ ((void)sizeof(UEAsserts_Private::GetMemberNameCheckedJunk(EnumName::EnumeratorName)), FName(TEXT(#EnumeratorName))) #define GET_ENUMERATOR_NAME_STRING_CHECKED(EnumName, EnumeratorName) \\ ((void)sizeof(UEAsserts_Private::GetMemberNameCheckedJunk(EnumName::EnumeratorName)), TEXT(#EnumeratorName)) #define GET_ENUMERATOR_NAME_STRING_VIEW_CHECKED(EnumName, EnumeratorName) \\ ((void)sizeof(UEAsserts_Private::GetMemberNameCheckedJunk(EnumName::EnumeratorName)), TEXTVIEW(#EnumeratorName)) #define GET_MEMBER_NAME_CHECKED(ClassName, MemberName) \\ ((void)sizeof(UEAsserts_Private::GetMemberNameCheckedJunk(((ClassName*)0)->MemberName)), FName(TEXT(#MemberName))) #define GET_MEMBER_NAME_STRING_CHECKED(ClassName, MemberName) \\ ((void)sizeof(UEAsserts_Private::GetMemberNameCheckedJunk(((ClassName*)0)->MemberName)), TEXT(#MemberName)) #define GET_MEMBER_NAME_STRING_VIEW_CHECKED(ClassName, MemberName) \\ ((void)sizeof(UEAsserts_Private::GetMemberNameCheckedJunk(((ClassName*)0)->MemberName)), TEXTVIEW(#MemberName)) #define GET_FUNCTION_NAME_CHECKED(ClassName, FunctionName) \\ ((void)sizeof(&ClassName::FunctionName), FName(TEXT(#FunctionName))) #define GET_FUNCTION_NAME_STRING_CHECKED(ClassName, FunctionName) \\ ((void)sizeof(&ClassName::FunctionName), TEXT(#FunctionName)) #define GET_FUNCTION_NAME_STRING_VIEW_CHECKED(ClassName, FunctionName) \\ ((void)sizeof(&ClassName::FunctionName), TEXTVIEW(#FunctionName)) #define GET_FUNCTION_NAME_CHECKED_OneParam(ClassName, FunctionName, ArgType) \\ ((void)sizeof((std::declval<ClassName&>().FunctionName(std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType)>()), (int)0)), FName(TEXT(#FunctionName))) #define GET_FUNCTION_NAME_CHECKED_TwoParams(ClassName, FunctionName, ArgType1, ArgType2) \\ ((void)sizeof((std::declval<ClassName&>().FunctionName(std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType1)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType2)>()), (int)0)), FName(TEXT(#FunctionName))) #define GET_FUNCTION_NAME_CHECKED_ThreeParams(ClassName, FunctionName, ArgType1, ArgType2, ArgType3) \\ ((void)sizeof((std::declval<ClassName&>().FunctionName(std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType1)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType2)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType3)>()), (int)0)), FName(TEXT(#FunctionName))) #define GET_FUNCTION_NAME_CHECKED_FourParams(ClassName, FunctionName, ArgType1, ArgType2, ArgType3, ArgType4) \\ ((void)sizeof((std::declval<ClassName&>().FunctionName(std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType1)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType2)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType3)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType4)>()), (int)0)), FName(TEXT(#FunctionName))) #define GET_FUNCTION_NAME_STRING_CHECKED_OneParam(ClassName, FunctionName, ArgType) \\ ((void)sizeof((std::declval<ClassName&>().FunctionName(std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType)>()), (int)0)), TEXT(#FunctionName)) #define GET_FUNCTION_NAME_STRING_CHECKED_TwoParams(ClassName, FunctionName, ArgType1, ArgType2) \\ ((void)sizeof((std::declval<ClassName&>().FunctionName(std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType1)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType2)>()), (int)0)), TEXT(#FunctionName)) #define GET_FUNCTION_NAME_STRING_CHECKED_ThreeParams(ClassName, FunctionName, ArgType1, ArgType2, ArgType3) \\ ((void)sizeof((std::declval<ClassName&>().FunctionName(std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType1)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType2)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType3)>()), (int)0)), TEXT(#FunctionName)) #define GET_FUNCTION_NAME_STRING_CHECKED_FourParams(ClassName, FunctionName, ArgType1, ArgType2, ArgType3, ArgType4) \\ ((void)sizeof((std::declval<ClassName&>().FunctionName(std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType1)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType2)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType3)>(), std::declval<PREPROCESSOR_REMOVE_OPTIONAL_PARENS(ArgType4)>()), (int)0)), TEXT(#FunctionName)) CORE_API void UE_COLD UE_DEBUG_SECTION VARARGS LowLevelFatalErrorHandler (const ANSICHAR* File, int32 Line, const TCHAR* Format=TEXT(\"\"), ...)"
  },
  {
    "label": "LowLevelFatalError()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "LowLevelFatalError(Format, ...)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "static_assert(TIsArrayOrRefOfTypeByPredicate<decltype(Format), TIsCharEncodingCompatibleWithTCHAR>::Value, \"Formatting string must be a TCHAR array.\")"
  },
  {
    "label": "LowLevelFatalErrorHandler()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "LowLevelFatalErrorHandler(__FILE__, __LINE__, (const TCHAR*)Format, ##__VA_ARGS__)"
  }
]