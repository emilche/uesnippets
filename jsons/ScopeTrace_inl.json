[
  {
    "label": "SNodeCellSorter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SNodeCellSorter"
  },
  {
    "label": "CScopeTrace()",
    "kind": "Method",
    "detail": "Function (# ifdef SPEEDTREE_INTEL_GPA ST_INLINE)",
    "insertText": "CScopeTrace(const char* pName)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(pName)"
  },
  {
    "label": "__itt_string_handle_createA()",
    "kind": "Method",
    "detail": "Function (__itt_string_handle* pTaskHandle =)",
    "insertText": "__itt_string_handle_createA(pName)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(pTaskHandle)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_pDomain)"
  },
  {
    "label": "__itt_task_begin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__itt_task_begin(m_pDomain, __itt_null, __itt_null, pTaskHandle)"
  },
  {
    "label": "CScopeTrace()",
    "kind": "Method",
    "detail": "Function (} ST_INLINE CScopeTrace::~)",
    "insertText": "CScopeTrace()"
  },
  {
    "label": "__itt_task_end()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__itt_task_end(m_pDomain)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} ST_INLINE void)",
    "insertText": "Init(void)"
  },
  {
    "label": "__itt_domain_createA()",
    "kind": "Method",
    "detail": "Function (m_pDomain =)",
    "insertText": "__itt_domain_createA(\"IDV.SpeedTree\")"
  },
  {
    "label": "CScopeTrace()",
    "kind": "Method",
    "detail": "Function (} # else # ifdef SPEEDTREE_FALLBACK_TIMING ST_INLINE)",
    "insertText": "CScopeTrace(const char* pName) : m_pParent(m_pActiveNode)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (m_pParent = m_pActiveNode ; SNode* pThisNode = NULL ;)",
    "insertText": "for(size_t i = 0; i < m_pActiveNode->m_aChildren.size( ); ++i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_pActiveNode->m_aChildren[i]->m_pName)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pThisNode = m_pActiveNode -> m_aChildren [ i ] ; break ; } })",
    "insertText": "if(!pThisNode)"
  },
  {
    "label": "st_new()",
    "kind": "Method",
    "detail": "Function (pThisNode =)",
    "insertText": "st_new(SNode, \"CScopeTrace::SNode\")"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (pThisNode -> m_pName = pName ; m_pActiveNode -> m_aChildren .)",
    "insertText": "push_back(pThisNode)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(pThisNode)"
  },
  {
    "label": "Start()",
    "kind": "Method",
    "detail": "Function (m_pActiveNode = pThisNode ; m_cTimer .)",
    "insertText": "Start()"
  },
  {
    "label": "CScopeTrace()",
    "kind": "Method",
    "detail": "Function (} # else ST_INLINE)",
    "insertText": "CScopeTrace(const char*)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef SPEEDTREE_FALLBACK_TIMING)",
    "insertText": "if(!IsActive( ))"
  },
  {
    "label": "Stop()",
    "kind": "Method",
    "detail": "Function (m_cTimer .)",
    "insertText": "Stop()"
  },
  {
    "label": "GetMilliSec()",
    "kind": "Method",
    "detail": "Function (m_pActiveNode -> m_fTime + = m_cTimer .)",
    "insertText": "GetMilliSec()"
  },
  {
    "label": "Start()",
    "kind": "Method",
    "detail": "Function (} ST_INLINE void)",
    "insertText": "Start(void)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# ifdef SPEEDTREE_FALLBACK_TIMING)",
    "insertText": "for(size_t i = 0; i < m_sRootNode.m_aChildren.size( ); ++i) st_delete<SNode>(m_sRootNode.m_aChildren[i])"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (m_sRootNode . m_aChildren .)",
    "insertText": "clear()"
  },
  {
    "label": "IsActive()",
    "kind": "Method",
    "detail": "Function (m_pActiveNode =& m_sRootNode ; m_bActive = true ; # endif } ST_INLINE st_bool)",
    "insertText": "IsActive(void)"
  },
  {
    "label": "Stop()",
    "kind": "Method",
    "detail": "Function (# ifdef SPEEDTREE_FALLBACK_TIMING return m_bActive ; # else return false ; # endif } ST_INLINE void)",
    "insertText": "Stop(void)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# ifdef SPEEDTREE_FALLBACK_TIMING m_bActive = false ; # endif } # ifdef SPEEDTREE_FALLBACK_TIMING class SNodeCellSorter { public : bool)",
    "insertText": "operator()(const CScopeTrace::SNode* pLeft, const CScopeTrace::SNode* pRight)"
  },
  {
    "label": "Report()",
    "kind": "Method",
    "detail": "Function (} } ; # endif void)",
    "insertText": "Report(EReportFormat eFormat, CString& strReport, SNode* pStart)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_fTime)",
    "insertText": "if(pStart)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!pStart)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(pStart)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (pStart -> m_aChildren .)",
    "insertText": "sort(SNodeCellSorter( ))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (SNode* pChild = pStart -> m_aChildren [ i ] ;)",
    "insertText": "assert(pChild)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const st_int32 c_nIndentSize = 2 ; const st_int32 c_nLabelWidth = 4 0 ;)",
    "insertText": "for(st_int32 j = 0; j < nIndent * c_nIndentSize; ++j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (st_char szFormat [ 2 5 6 ] ;)",
    "insertText": "if(eFormat == FORMAT_PRINT) sprintf(szFormat, \"%%-%ds %%6.4f ms %%5.1f%%%%\\n\", c_nLabelWidth)"
  },
  {
    "label": "Format()",
    "kind": "Method",
    "detail": "Function (strReport + =)",
    "insertText": "Format(szFormat, pChild->m_pName, pChild->m_fTime, 100.0f * pChild->m_fTime / fScopeSum).c_str()"
  },
  {
    "label": "Report()",
    "kind": "Method",
    "detail": "Function (+ + nIndent ;)",
    "insertText": "Report(eFormat, strReport, pChild)"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (- - nIndent ; } #)",
    "insertText": "else(void) (eFormat)"
  },
  {
    "label": "SNode()",
    "kind": "Method",
    "detail": "Function (# endif } const st_float32 c_fBadTiming = - 1 . 0 f ; ST_INLINE CScopeTrace::)",
    "insertText": "SNode() : m_pName(\"Root\"), m_fTime(0.0)"
  },
  {
    "label": "SNode()",
    "kind": "Method",
    "detail": "Function (} ST_INLINE CScopeTrace::SNode::~)",
    "insertText": "SNode()"
  }
]