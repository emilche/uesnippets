[
  {
    "label": "PermPermProduct_t",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "PermPermProduct_t"
  },
  {
    "label": "PermutationBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PermutationBase"
  },
  {
    "label": "traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "traits"
  },
  {
    "label": "PermutationMatrix",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PermutationMatrix"
  },
  {
    "label": "Map",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Map"
  },
  {
    "label": "TranspositionsWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TranspositionsWrapper"
  },
  {
    "label": "PermutationWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PermutationWrapper"
  },
  {
    "label": "InverseImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InverseImpl"
  },
  {
    "label": "AssignmentKind",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AssignmentKind"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_PERMUTATIONMATRIX_H # define EIGEN_PERMUTATIONMATRIX_H namespace Eigen { namespace internal { enum PermPermProduct_t { PermPermProduct } ; } template<Derived> class PermutationBase : public EigenBase<Derived> { typedef internal::traits<Derived> Traits ; typedef EigenBase<Derived> Base ; public : # ifndef EIGEN_PARSED_BY_DOXYGEN typedef Traits::IndicesType IndicesType ; enum { Flags = Traits::Flags,RowsAtCompileTime = Traits::RowsAtCompileTime,ColsAtCompileTime = Traits::ColsAtCompileTime,MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,MaxColsAtCompileTime = Traits::MaxColsAtCompileTime } ; typedef Traits::StorageIndex StorageIndex ; typedef Matrix<StorageIndex,RowsAtCompileTime,ColsAtCompileTime,0,MaxRowsAtCompileTime,MaxColsAtCompileTime> DenseMatrixType ; typedef PermutationMatrix<IndicesType::SizeAtCompileTime,IndicesType::MaxSizeAtCompileTime,StorageIndex> PlainPermutationType ; typedef PlainPermutationType PlainObject ; using Base::derived ; typedef Inverse<Derived> InverseReturnType ; typedef void Scalar ; # endif template<OtherDerived> Derived&)",
    "insertText": "operator(const PermutationBase<OtherDerived>& other)"
  },
  {
    "label": "indices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "indices() = other.indices()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived> Derived&)",
    "insertText": "operator(const TranspositionsBase<OtherDerived>& tr)"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setIdentity(tr.size())"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC Index)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC Index)",
    "insertText": "cols()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC Index)",
    "insertText": "size()"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (} # ifndef EIGEN_PARSED_BY_DOXYGEN template<DenseDerived> void)",
    "insertText": "evalTo(MatrixBase<DenseDerived>& other)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (other .)",
    "insertText": "setZero()"
  },
  {
    "label": "toDenseMatrix()",
    "kind": "Method",
    "detail": "Function (} # endif DenseMatrixType)",
    "insertText": "toDenseMatrix()"
  },
  {
    "label": "indices()",
    "kind": "Method",
    "detail": "Function (} const IndicesType&)",
    "insertText": "indices()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resize(Index newSize)"
  },
  {
    "label": "indices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "indices().resize(newSize)"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setIdentity()"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (StorageIndex n =)",
    "insertText": "StorageIndex(size())"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setIdentity(Index newSize)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(newSize)"
  },
  {
    "label": "applyTranspositionOnTheLeft()",
    "kind": "Method",
    "detail": "Function (} Derived&)",
    "insertText": "applyTranspositionOnTheLeft(Index i, Index j)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(i>=0 && j>=0 && i<size() && j<size())"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "derived()"
  },
  {
    "label": "applyTranspositionOnTheRight()",
    "kind": "Method",
    "detail": "Function (} Derived&)",
    "insertText": "applyTranspositionOnTheRight(Index i, Index j)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(indices().coeffRef(i), indices().coeffRef(j))"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (} InverseReturnType)",
    "insertText": "inverse()"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (} InverseReturnType)",
    "insertText": "transpose()"
  },
  {
    "label": "assignTranspose()",
    "kind": "Method",
    "detail": "Function (} # ifndef EIGEN_PARSED_BY_DOXYGEN protected : template<OtherDerived> void)",
    "insertText": "assignTranspose(const PermutationBase<OtherDerived>& other)"
  },
  {
    "label": "assignProduct()",
    "kind": "Method",
    "detail": "Function (} template<Lhs,Rhs> void)",
    "insertText": "assignProduct(const Lhs& lhs, const Rhs& rhs)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(lhs.cols() == rhs.rows())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif public : template<Other> PlainPermutationType)",
    "insertText": "operator(const PermutationBase<Other>& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Other> PlainPermutationType)",
    "insertText": "operator(const InverseImpl<Other,PermutationStorage>& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Other> PlainPermutationType)",
    "insertText": "operator(const InverseImpl<Other, PermutationStorage>& other, const PermutationBase& perm)"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "determinant()"
  },
  {
    "label": "mask()",
    "kind": "Method",
    "detail": "Function (Matrix<bool,RowsAtCompileTime,1,0,MaxRowsAtCompileTime>)",
    "insertText": "mask(n)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "fill(false)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Index r = 0 ;)",
    "insertText": "while(r < n)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (Index k0 = r + + ; mask .)",
    "insertText": "coeffRef(k0)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "coeffRef(k)"
  },
  {
    "label": "PermutationMatrix()",
    "kind": "Method",
    "detail": "Function (res = - res ; } } return res ; } protected : } ; namespace internal { template<int SizeAtCompileTime,int MaxSizeAtCompileTime,_StorageIndex> struct traits<PermutationMatrix<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex>> : traits<Matrix<_StorageIndex,SizeAtCompileTime,SizeAtCompileTime,0,MaxSizeAtCompileTime,MaxSizeAtCompileTime>> { typedef PermutationStorage StorageKind ; typedef Matrix<_StorageIndex,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1> IndicesType ; typedef _StorageIndex StorageIndex ; typedef void Scalar ; } ; } template<int SizeAtCompileTime,int MaxSizeAtCompileTime,_StorageIndex> class PermutationMatrix : public PermutationBase<PermutationMatrix<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex>> { typedef PermutationBase<PermutationMatrix> Base ; typedef internal::traits<PermutationMatrix> Traits ; public : typedef const PermutationMatrix& Nested ; # ifndef EIGEN_PARSED_BY_DOXYGEN typedef Traits::IndicesType IndicesType ; typedef Traits::StorageIndex StorageIndex ; # endif)",
    "insertText": "PermutationMatrix()"
  },
  {
    "label": "PermutationMatrix()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PermutationMatrix(Index size) : m_indices(size)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(size <= NumTraits<StorageIndex>::highest())"
  },
  {
    "label": "PermutationMatrix()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived>)",
    "insertText": "PermutationMatrix(const PermutationBase<OtherDerived>& other) : m_indices(other.indices())"
  },
  {
    "label": "PermutationMatrix()",
    "kind": "Method",
    "detail": "Function (} template<Other>)",
    "insertText": "PermutationMatrix(const MatrixBase<Other>& indices) : m_indices(indices)"
  },
  {
    "label": "PermutationMatrix()",
    "kind": "Method",
    "detail": "Function (} template<Other>)",
    "insertText": "PermutationMatrix(const TranspositionsBase<Other>& tr) : m_indices(tr.size())"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(m_indices.size() <= NumTraits<StorageIndex>::highest())"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (StorageIndex end =)",
    "insertText": "StorageIndex(m_indices.size())"
  },
  {
    "label": "PermutationMatrix()",
    "kind": "Method",
    "detail": "Function (} template<Lhs,Rhs>)",
    "insertText": "PermutationMatrix(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs) : m_indices(lhs.indices().size())"
  },
  {
    "label": "assignProduct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assignProduct(lhs,rhs)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (} # endif protected : IndicesType m_indices ; } ; namespace internal { template<int SizeAtCompileTime,int MaxSizeAtCompileTime,_StorageIndex,int _PacketAccess> struct traits<Map<PermutationMatrix<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex>,_PacketAccess>> : traits<Matrix<_StorageIndex,SizeAtCompileTime,SizeAtCompileTime,0,MaxSizeAtCompileTime,MaxSizeAtCompileTime>> { typedef PermutationStorage StorageKind ; typedef Map<const Matrix<_StorageIndex,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1>,_PacketAccess> IndicesType ; typedef _StorageIndex StorageIndex ; typedef void Scalar ; } ; } template<int SizeAtCompileTime,int MaxSizeAtCompileTime,_StorageIndex,int _PacketAccess> class Map<PermutationMatrix<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex>,_PacketAccess> : public PermutationBase<Map<PermutationMatrix<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex>,_PacketAccess>> { typedef PermutationBase<Map> Base ; typedef internal::traits<Map> Traits ; public : # ifndef EIGEN_PARSED_BY_DOXYGEN typedef Traits::IndicesType IndicesType ; typedef IndicesType::Scalar StorageIndex ; # endif)",
    "insertText": "Map(const StorageIndex* indicesPtr) : m_indices(indicesPtr)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Map(const StorageIndex* indicesPtr, Index size) : m_indices(indicesPtr,size)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Other> Map&)",
    "insertText": "operator(const TranspositionsBase<Other>& tr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # ifndef EIGEN_PARSED_BY_DOXYGEN Map&)",
    "insertText": "operator(const Map& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<PermutationDerived,MatrixDerived> EIGEN_DEVICE_FUNC const Product<PermutationDerived,MatrixDerived,AliasFreeProduct>)",
    "insertText": "operator(const PermutationBase<PermutationDerived> &permutation, const MatrixBase<MatrixDerived>& matrix)"
  },
  {
    "label": "InverseImpl()",
    "kind": "Method",
    "detail": "Function (} template<PermutationType> class InverseImpl<PermutationType,PermutationStorage> : public EigenBase<Inverse<PermutationType>> { typedef PermutationType::PlainPermutationType PlainPermutationType ; typedef internal::traits<PermutationType> PermTraits ; protected :)",
    "insertText": "InverseImpl()"
  },
  {
    "label": "eval()",
    "kind": "Method",
    "detail": "Function (} # endif PlainPermutationType)",
    "insertText": "eval()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived> const Product<OtherDerived,InverseType,AliasFreeProduct>)",
    "insertText": "operator(const MatrixBase<OtherDerived>& matrix, const InverseType& trPerm)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived> const Product<InverseType,OtherDerived,AliasFreeProduct>)",
    "insertText": "operator(const MatrixBase<OtherDerived>& matrix)"
  },
  {
    "label": "asPermutation()",
    "kind": "Method",
    "detail": "Function (} } ; template<Derived> const PermutationWrapper<const Derived> MatrixBase<Derived)",
    "insertText": "asPermutation()"
  }
]