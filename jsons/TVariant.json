[
  {
    "label": "TInPlaceType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TInPlaceType"
  },
  {
    "label": "FEmptyVariantState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEmptyVariantState"
  },
  {
    "label": "TVariant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TVariant"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Templates / Requires . h \" # include \" TVariantMeta . h \" # include<type_traits> template<T> struct TInPlaceType { } ; struct FEmptyVariantState { FArchive&)",
    "insertText": "operator(FArchive& Ar, FEmptyVariantState&)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (# if UE_TVARIANT_TRIVIAL_DESTRUCTOR_USING_CONCEPTS using Super = UE::Core::Private::TVariantStorage<T,Ts . . .> ; # else using Super = std::conditional_t<! std::is_trivially_destructible_v<)",
    "insertText": "T(!std::is_trivially_destructible_v<Ts> || ...)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "static_assert(!UE::Core::Private::TTypePackContainsDuplicates<T, Ts...>::Value, \"All the types used in TVariant should be unique\")"
  },
  {
    "label": "TVariant()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TVariant()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)&UE::Core::Private::CastToStorage(*this).Storage) T()"
  },
  {
    "label": "TVariant()",
    "kind": "Method",
    "detail": "Function (TypeIndex = 0 ; } template<U,. . . TArgs>)",
    "insertText": "TVariant(TInPlaceType<U>&&, TArgs&&... Args)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (SIZE_T Index = UE::Core::Private::TParameterPackTypeIndex<U,T,Ts . . .>::Value ;)",
    "insertText": "static_assert(Index != (SIZE_T)-1, \"The TVariant is not declared to hold the type being constructed\")"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)&UE::Core::Private::CastToStorage(*this).Storage) U(Forward<TArgs>(Args)...)"
  },
  {
    "label": "TypeIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TypeIndex(uint8)"
  },
  {
    "label": "TVariant()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TVariant(const TVariant& Other)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (TypeIndex = Other . TypeIndex ; UE::Core::Private::TCopyConstructorLookup<T,Ts . . .)",
    "insertText": "Construct(TypeIndex, &UE::Core::Private::CastToStorage(*this).Storage, &UE::Core::Private::CastToStorage(Other).Storage)"
  },
  {
    "label": "TVariant()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TVariant(TVariant&& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TVariant&)",
    "insertText": "operator(const TVariant& Other)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (TVariant Temp = Other ;)",
    "insertText": "Swap(Temp, *this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } TVariant&)",
    "insertText": "operator(TVariant&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (TVariant Temp =)",
    "insertText": "MoveTemp(Other)"
  },
  {
    "label": "TVariant()",
    "kind": "Method",
    "detail": "Function (} return* this ; } # if UE_TVARIANT_TRIVIAL_DESTRUCTOR_USING_CONCEPTS ~)",
    "insertText": "TVariant() requires(!std::is_trivially_destructible_v<T> || (!std::is_trivially_destructible_v<Ts> || ...))"
  },
  {
    "label": "Destruct()",
    "kind": "Method",
    "detail": "Function (UE::Core::Private::TDestructorLookup<T,Ts . . .)",
    "insertText": "Destruct(TypeIndex, &UE::Core::Private::CastToStorage(*this).Storage)"
  },
  {
    "label": "TVariant()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TVariant() requires(std::is_trivially_destructible_v<T> && (std::is_trivially_destructible_v<Ts> && ...))"
  },
  {
    "label": "IsType()",
    "kind": "Method",
    "detail": "Function (# endif template<U> bool)",
    "insertText": "IsType()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} template<U> U&)",
    "insertText": "Get()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (SIZE_T Index = UE::Core::Private::TParameterPackTypeIndex<U,T,Ts . . .>::Value ;)",
    "insertText": "static_assert(Index != (SIZE_T)-1, \"The TVariant is not declared to hold the type passed to Get<>\")"
  },
  {
    "label": "TryGet()",
    "kind": "Method",
    "detail": "Function (} template<U> U*)",
    "insertText": "TryGet()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (SIZE_T Index = UE::Core::Private::TParameterPackTypeIndex<U,T,Ts . . .>::Value ;)",
    "insertText": "static_assert(Index != (SIZE_T)-1, \"The TVariant is not declared to hold the type passed to TryGet<>\")"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} template<U> void)",
    "insertText": "Set(typename TIdentity<U>::Type&& Value)"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (Emplace<)",
    "insertText": "U(MoveTemp(Value))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} template<U> void)",
    "insertText": "Set(const typename TIdentity<U>::Type& Value)"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (Emplace<)",
    "insertText": "U(Value)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (} template<U,. . . TArgs> void)",
    "insertText": "Emplace(TArgs&&... Args)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (SIZE_T Index = UE::Core::Private::TParameterPackTypeIndex<U,T,Ts . . .>::Value ;)",
    "insertText": "static_assert(Index != (SIZE_T)-1, \"The TVariant is not declared to hold the type passed to Emplace<>\")"
  },
  {
    "label": "IndexOfType()",
    "kind": "Method",
    "detail": "Function (} template<U> SIZE_T)",
    "insertText": "IndexOfType()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (SIZE_T Index = UE::Core::Private::TParameterPackTypeIndex<U,T,Ts . . .>::Value ;)",
    "insertText": "static_assert(Index != (SIZE_T)-1, \"The TVariant is not declared to hold the type passed to IndexOfType<>\")"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} private : # if UE_TVARIANT_TRIVIAL_DESTRUCTOR_USING_CONCEPTS uint8 TypeIndex ; # else using Super::TypeIndex ; # endif } ; template<Func,. . . Variants)",
    "insertText": "UE_REQUIRES((TIsVariant_V<std::decay_t<Variants>> && ...)) > decltype(auto) Visit(Func&& Callable, Variants&&... Args)"
  },
  {
    "label": "NumPermutations()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "NumPermutations(1 * ... * (TVariantSize_V<std::decay_t<Variants>>))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<. . . Ts> FArchive&)",
    "insertText": "operator(typename UE::Core::Private::TAlwaysFArchive<TVariant<Ts...>>::Type& Ar, TVariant<Ts...>& Variant)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (uint8 Index ; Ar<<Index ;)",
    "insertText": "check(Index < sizeof...(Ts))"
  },
  {
    "label": "Load()",
    "kind": "Method",
    "detail": "Function (UE::Core::Private::TVariantLoadFromArchiveLookup<Ts . . .)",
    "insertText": "Load((SIZE_T)Index, Ar, Variant)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (} else { uint8)",
    "insertText": "Index(uint8)Variant.GetIndex()"
  },
  {
    "label": "Visit()",
    "kind": "Method",
    "detail": "Function (Ar<<Index ;)",
    "insertText": "Visit([&Ar](auto& StoredValue) { Ar << StoredValue; }, Variant)"
  }
]