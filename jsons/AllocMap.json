[
  {
    "label": "FAllocMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAllocMap"
  },
  {
    "label": "TAddressKeyFuncs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAddressKeyFuncs"
  },
  {
    "label": "FAllocMap()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Map . h \" # include \" Model / AllocationItem . h \" namespace TraceServices { class FAllocMap { public : typedef int32 SizeType ; public :)",
    "insertText": "FAllocMap()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Empty(SizeType ExpectedNumElements = 0)"
  },
  {
    "label": "DestructAllocs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructAllocs()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (AllocsMap .)",
    "insertText": "Empty(ExpectedNumElements)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} SizeType)",
    "insertText": "Num()"
  },
  {
    "label": "FindRef()",
    "kind": "Method",
    "detail": "Function (} FAllocationItem*)",
    "insertText": "FindRef(uint64 Address)"
  },
  {
    "label": "FindRange()",
    "kind": "Method",
    "detail": "Function (} FAllocationItem*)",
    "insertText": "FindRange(uint64 Address)"
  },
  {
    "label": "Callback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Callback(*KV.Value)"
  },
  {
    "label": "Enumerate()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Enumerate(uint64 StartAddress, uint64 EndAddress, TFunctionRef<void(const FAllocationItem& Alloc)> Callback)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FAllocationItem& Allocation =* KV . Value ;)",
    "insertText": "if(Allocation.Address >= StartAddress && Allocation.Address < EndAddress)"
  },
  {
    "label": "Callback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Callback(Allocation)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "Add(FAllocationItem* Alloc)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (AllocsMap .)",
    "insertText": "Add(Alloc->Address, Alloc)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} FAllocationItem*)",
    "insertText": "Remove(uint64 Address)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FAllocationItem* RemovedLongLivingAlloc ;)",
    "insertText": "if(AllocsMap.RemoveAndCopyValue(Address, RemovedLongLivingAlloc))"
  },
  {
    "label": "GetSetKey()",
    "kind": "Method",
    "detail": "Function (const FAllocationItem* Allocation = KV . Value ; delete Allocation ; } } private : template<ValueType> struct TAddressKeyFuncs : BaseKeyFuncs<TPair<uint64,ValueType>,uint64,false> { typedef TTypeTraits<uint64>::ConstPointerType KeyInitType ; typedef const TPairInitializer<TTypeTraits<uint64>::ConstInitType,TTypeTraits<ValueType>::ConstInitType>& ElementInitType ; uint64)",
    "insertText": "GetSetKey(ElementInitType Element)"
  }
]