[
  {
    "label": "traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "traits"
  },
  {
    "label": "SparseMatrix",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseMatrix"
  },
  {
    "label": "SparseVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseVector"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "internal"
  },
  {
    "label": "SizesType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SizesType"
  },
  {
    "label": "SingletonVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SingletonVector"
  },
  {
    "label": "IndexPosPair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IndexPosPair"
  },
  {
    "label": "default_prunning_func",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "default_prunning_func"
  },
  {
    "label": "evaluator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "evaluator"
  },
  {
    "label": "EIGEN_SPARSE_PUBLIC_INTERFACE()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_SPARSEMATRIX_H # define EIGEN_SPARSEMATRIX_H namespace Eigen { namespace internal { template<_Scalar,int _Options,_StorageIndex> struct traits<SparseMatrix<_Scalar,_Options,_StorageIndex>> { typedef _Scalar Scalar ; typedef _StorageIndex StorageIndex ; typedef Sparse StorageKind ; typedef MatrixXpr XprKind ; enum { RowsAtCompileTime = Dynamic,ColsAtCompileTime = Dynamic,MaxRowsAtCompileTime = Dynamic,MaxColsAtCompileTime = Dynamic,Flags = _Options | NestByRefBit | LvalueBit | CompressedAccessBit,SupportedAccessPatterns = InnerRandomAccessPattern } ; } ; template<_Scalar,int _Options,_StorageIndex,int DiagIndex> struct traits<Diagonal<SparseMatrix<_Scalar,_Options,_StorageIndex>,DiagIndex>> { typedef SparseMatrix<_Scalar,_Options,_StorageIndex> MatrixType ; typedef ref_selector<MatrixType>::type MatrixTypeNested ; typedef remove_reference<MatrixTypeNested>::type _MatrixTypeNested ; typedef _Scalar Scalar ; typedef Dense StorageKind ; typedef _StorageIndex StorageIndex ; typedef MatrixXpr XprKind ; enum { RowsAtCompileTime = Dynamic,ColsAtCompileTime = 1,MaxRowsAtCompileTime = Dynamic,MaxColsAtCompileTime = 1,Flags = LvalueBit } ; } ; template<_Scalar,int _Options,_StorageIndex,int DiagIndex> struct traits<Diagonal<const SparseMatrix<_Scalar,_Options,_StorageIndex>,DiagIndex>> : public traits<Diagonal<SparseMatrix<_Scalar,_Options,_StorageIndex>,DiagIndex>> { enum { Flags = 0 } ; } ; } template<_Scalar,int _Options,_StorageIndex> class SparseMatrix : public SparseCompressedBase<SparseMatrix<_Scalar,_Options,_StorageIndex>> { typedef SparseCompressedBase<SparseMatrix> Base ; using Base::convert_index ; class SparseVector<_Scalar,0,_StorageIndex> ; template<,,,,> struct internal::Assignment ; public : using Base::isCompressed ; using Base::nonZeros ;)",
    "insertText": "EIGEN_SPARSE_PUBLIC_INTERFACE(SparseMatrix)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (using Base::operator - = ; typedef MappedSparseMatrix<Scalar,Flags> Map ; typedef Diagonal<SparseMatrix> DiagonalReturnType ; typedef Diagonal<const SparseMatrix> ConstDiagonalReturnType ; typedef Base::InnerIterator InnerIterator ; typedef Base::ReverseInnerIterator ReverseInnerIterator ; using Base::IsRowMajor ; typedef internal::CompressedStorage<Scalar,StorageIndex> Storage ; enum { Options = _Options } ; typedef Base::IndexVector IndexVector ; typedef Base::ScalarVector ScalarVector ; protected : typedef SparseMatrix<)",
    "insertText": "Scalar(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0)"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (Index m_outerSize ; Index m_innerSize ; StorageIndex* m_outerIndex ; StorageIndex* m_innerNonZeros ; Storage m_data ; public : Index)",
    "insertText": "rows()"
  },
  {
    "label": "valuePtr()",
    "kind": "Method",
    "detail": "Function (} Scalar*)",
    "insertText": "valuePtr()"
  },
  {
    "label": "innerIndexPtr()",
    "kind": "Method",
    "detail": "Function (} const StorageIndex*)",
    "insertText": "innerIndexPtr()"
  },
  {
    "label": "outerIndexPtr()",
    "kind": "Method",
    "detail": "Function (} const StorageIndex*)",
    "insertText": "outerIndexPtr()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(row>=0 && row<rows() && col>=0 && col<cols())"
  },
  {
    "label": "atInRange()",
    "kind": "Method",
    "detail": "Function (const Index outer = IsRowMajor ? row : col ; const Index inner = IsRowMajor ? col : row ; Index end = m_innerNonZeros ? m_outerIndex [ outer ] + m_innerNonZeros [ outer ] : m_outerIndex [ outer + 1 ] ; return m_data .)",
    "insertText": "atInRange(m_outerIndex[outer], end, StorageIndex(inner))"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (} Scalar&)",
    "insertText": "coeffRef(Index row, Index col)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (const Index outer = IsRowMajor ? row : col ; const Index inner = IsRowMajor ? col : row ; Index start = m_outerIndex [ outer ] ; Index end = m_innerNonZeros ? m_outerIndex [ outer ] + m_innerNonZeros [ outer ] : m_outerIndex [ outer + 1 ] ;)",
    "insertText": "eigen_assert(end>=start && \"you probably called coeffRef on a non finalized matrix\")"
  },
  {
    "label": "searchLowerIndex()",
    "kind": "Method",
    "detail": "Function (const Index p = m_data .)",
    "insertText": "searchLowerIndex(start,end-1,StorageIndex(inner))"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} Scalar&)",
    "insertText": "insert(Index row, Index col)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "setZero()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "clear()"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(m_outerIndex, 0, (m_outerSize+1)*sizeof(StorageIndex))"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reserve(Index reserveSize)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(isCompressed() && \"This function does not make sense in non compressed mode.\")"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "reserve(reserveSize)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} # ifdef EIGEN_PARSED_BY_DOXYGEN template<class SizesType> void)",
    "insertText": "reserve(const SizesType& reserveSizes)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (# else template<class SizesType> void)",
    "insertText": "reserve(const SizesType& reserveSizes, const typename SizesType::value_type& enableif = #if (!EIGEN_COMP_MSVC) || (EIGEN_COMP_MSVC>=1500) typename #endif SizesType::value_type())"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(enableif)"
  },
  {
    "label": "reserveInnerVectors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserveInnerVectors(reserveSizes)"
  },
  {
    "label": "reserveInnerVectors()",
    "kind": "Method",
    "detail": "Function (} # endif protected : template<class SizesType> void)",
    "insertText": "reserveInnerVectors(const SizesType& reserveSizes)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (Index totalReserveSize = 0 ; m_innerNonZeros = static_cast<)",
    "insertText": "StorageIndex(EIGEN_STD_MALLOC(m_outerSize * sizeof(StorageIndex)))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (StorageIndex* newOuterIndex = m_innerNonZeros ; StorageIndex count = 0 ;)",
    "insertText": "for(Index j=0; j<m_outerSize; ++j)"
  },
  {
    "label": "j()",
    "kind": "Method",
    "detail": "Function (newOuterIndex [ j ] = count ; count + = reserveSizes [)",
    "insertText": "j(m_outerIndex[j+1]-m_outerIndex[j])"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (totalReserveSize + = reserveSizes [ j ] ; } m_data .)",
    "insertText": "reserve(totalReserveSize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (StorageIndex previousOuterIndex = m_outerIndex [ m_outerSize ] ;)",
    "insertText": "for(Index j=m_outerSize-1; j>=0; --j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (StorageIndex innerNNZ = previousOuterIndex - m_outerIndex [ j ] ;)",
    "insertText": "for(Index i=innerNNZ-1; i>=0; --i)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "index(newOuterIndex[j]+i) = m_data.index(m_outerIndex[j]+i)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "value(newOuterIndex[j]+i) = m_data.value(m_outerIndex[j]+i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} previousOuterIndex = m_outerIndex [ j ] ; m_outerIndex [ j ] = newOuterIndex [ j ] ; m_innerNonZeros [ j ] = innerNNZ ; })",
    "insertText": "if(m_outerSize>0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "resize(m_outerIndex[m_outerSize])"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (} else { StorageIndex* newOuterIndex = static_cast<)",
    "insertText": "StorageIndex(EIGEN_STD_MALLOC((m_outerSize+1)*sizeof(StorageIndex)))"
  },
  {
    "label": "alreadyReserved()",
    "kind": "Method",
    "detail": "Function (newOuterIndex [ j ] = count ; StorageIndex)",
    "insertText": "alreadyReserved(m_outerIndex[j+1]-m_outerIndex[j])"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (StorageIndex toReserve = std::max<)",
    "insertText": "StorageIndex(reserveSizes[j], alreadyReserved)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (count + = toReserve + m_innerNonZeros [ j ] ; } newOuterIndex [ m_outerSize ] = count ; m_data .)",
    "insertText": "resize(count)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index offset = newOuterIndex [ j ] - m_outerIndex [ j ] ;)",
    "insertText": "if(offset>0)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "swap(m_outerIndex, newOuterIndex)"
  },
  {
    "label": "EIGEN_STD_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STD_FREE(newOuterIndex)"
  },
  {
    "label": "insertBack()",
    "kind": "Method",
    "detail": "Function (} } public : Scalar&)",
    "insertText": "insertBack(Index row, Index col)"
  },
  {
    "label": "insertBackByOuterInner()",
    "kind": "Method",
    "detail": "Function (} Scalar&)",
    "insertText": "insertBackByOuterInner(Index outer, Index inner)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(Index(m_outerIndex[outer+1]) == m_data.size() && \"Invalid ordered insertion (invalid outer index)\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert((m_outerIndex[outer+1]-m_outerIndex[outer]==0 || m_data.index(m_data.size()-1)<inner) && \"Invalid ordered insertion (invalid inner index)\")"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (Index p = m_outerIndex [ outer + 1 ] ; + + m_outerIndex [ outer + 1 ] ; m_data .)",
    "insertText": "append(Scalar(0), inner)"
  },
  {
    "label": "insertBackByOuterInnerUnordered()",
    "kind": "Method",
    "detail": "Function (} Scalar&)",
    "insertText": "insertBackByOuterInnerUnordered(Index outer, Index inner)"
  },
  {
    "label": "startVec()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "startVec(Index outer)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_outerIndex[outer]==Index(m_data.size()) && \"You must call startVec for each inner vector sequentially\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_outerIndex[outer+1]==0 && \"You must call startVec for each inner vector sequentially\")"
  },
  {
    "label": "finalize()",
    "kind": "Method",
    "detail": "Function (m_outerIndex [ outer + 1 ] = m_outerIndex [ outer ] ; } void)",
    "insertText": "finalize()"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (StorageIndex size = internal::convert_index<)",
    "insertText": "StorageIndex(m_data.size())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Index i = m_outerSize ;)",
    "insertText": "while(i>=0 && m_outerIndex[i]==0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + i ;)",
    "insertText": "while(i<=m_outerSize)"
  },
  {
    "label": "setFromTriplets()",
    "kind": "Method",
    "detail": "Function (m_outerIndex [ i ] = size ; + + i ; } } } template<InputIterators> void)",
    "insertText": "setFromTriplets(const InputIterators& begin, const InputIterators& end)"
  },
  {
    "label": "setFromTriplets()",
    "kind": "Method",
    "detail": "Function (template<InputIterators,DupFunctor> void)",
    "insertText": "setFromTriplets(const InputIterators& begin, const InputIterators& end, DupFunctor dup_func)"
  },
  {
    "label": "sumupDuplicates()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sumupDuplicates()"
  },
  {
    "label": "collapseDuplicates()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collapseDuplicates(internal::scalar_sum_op<Scalar,Scalar>())"
  },
  {
    "label": "collapseDuplicates()",
    "kind": "Method",
    "detail": "Function (} template<DupFunctor> void)",
    "insertText": "collapseDuplicates(DupFunctor dup_func = DupFunctor())"
  },
  {
    "label": "insertByOuterInner()",
    "kind": "Method",
    "detail": "Function (Scalar&)",
    "insertText": "insertByOuterInner(Index j, Index i)"
  },
  {
    "label": "makeCompressed()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "makeCompressed()"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(m_outerIndex!=0 && m_outerSize>0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index oldStart = m_outerIndex [ 1 ] ; m_outerIndex [ 1 ] = m_innerNonZeros [ 0 ] ;)",
    "insertText": "for(Index j=1; j<m_outerSize; ++j)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "index(m_outerIndex[j]+k) = m_data.index(oldStart+k)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "value(m_outerIndex[j]+k) = m_data.value(oldStart+k)"
  },
  {
    "label": "EIGEN_STD_FREE()",
    "kind": "Method",
    "detail": "Function (} } m_outerIndex [ j + 1 ] = m_outerIndex [ j ] + m_innerNonZeros [ j ] ; oldStart = nextOldStart ; })",
    "insertText": "EIGEN_STD_FREE(m_innerNonZeros)"
  },
  {
    "label": "squeeze()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "squeeze()"
  },
  {
    "label": "uncompress()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "uncompress()"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (m_innerNonZeros [ i ] = m_outerIndex [ i + 1 ] - m_outerIndex [ i ] ; } } void)",
    "insertText": "prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prune(default_prunning_func(reference,epsilon))"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (} template<KeepFunc> void)",
    "insertText": "prune(const KeepFunc& keep = KeepFunc())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index previousStart = m_outerIndex [ j ] ; m_outerIndex [ j ] = k ; Index end = m_outerIndex [ j + 1 ] ;)",
    "insertText": "for(Index i=previousStart; i<end; ++i)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "value(k) = m_data.value(i)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "index(k) = m_data.index(i)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (+ + k ; } } } m_outerIndex [ m_outerSize ] = k ; m_data .)",
    "insertText": "resize(k,0)"
  },
  {
    "label": "conservativeResize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "conservativeResize(Index rows, Index cols)"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (Index innerChange = IsRowMajor ? cols - this ->)",
    "insertText": "cols() : rows - this->rows()"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (Index outerChange = IsRowMajor ? rows - this ->)",
    "insertText": "rows() : cols - this->cols()"
  },
  {
    "label": "convert_index()",
    "kind": "Method",
    "detail": "Function (StorageIndex newInnerSize =)",
    "insertText": "convert_index(IsRowMajor ? cols : rows)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (StorageIndex* newInnerNonZeros = static_cast<)",
    "insertText": "StorageIndex(EIGEN_STD_REALLOC(m_innerNonZeros, (m_outerSize + outerChange) * sizeof(StorageIndex)))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (m_innerNonZeros = newInnerNonZeros ;)",
    "insertText": "for(Index i=m_outerSize; i<m_outerSize+outerChange; i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(innerChange < 0)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (m_innerNonZeros = static_cast<)",
    "insertText": "StorageIndex(EIGEN_STD_MALLOC((m_outerSize + outerChange) * sizeof(StorageIndex)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_innerNonZeros && innerChange < 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (StorageIndex& n = m_innerNonZeros [ i ] ; StorageIndex start = m_outerIndex [ i ] ;)",
    "insertText": "while(n > 0 && m_data.index(start+n-1) >= newInnerSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } m_innerSize = newInnerSize ;)",
    "insertText": "if(outerChange == 0)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (StorageIndex* newOuterIndex = static_cast<)",
    "insertText": "StorageIndex(EIGEN_STD_REALLOC(m_outerIndex, (m_outerSize + outerChange + 1) * sizeof(StorageIndex)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_outerIndex = newOuterIndex ;)",
    "insertText": "if(outerChange > 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (StorageIndex lastIdx = m_outerSize = = 0 ? 0 : m_outerIndex [ m_outerSize ] ;)",
    "insertText": "for(Index i=m_outerSize; i<m_outerSize+outerChange+1; i++)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} m_outerSize + = outerChange ; } void)",
    "insertText": "resize(Index rows, Index cols)"
  },
  {
    "label": "EIGEN_STD_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STD_FREE(m_outerIndex)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (m_outerIndex = static_cast<)",
    "insertText": "StorageIndex(EIGEN_STD_MALLOC((outerSize + 1) * sizeof(StorageIndex)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_outerSize = outerSize ; })",
    "insertText": "if(m_innerNonZeros)"
  },
  {
    "label": "resizeNonZeros()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resizeNonZeros(Index size)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "resize(size)"
  },
  {
    "label": "diagonal()",
    "kind": "Method",
    "detail": "Function (} const ConstDiagonalReturnType)",
    "insertText": "diagonal()"
  },
  {
    "label": "SparseMatrix()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SparseMatrix() : m_outerSize(-1), m_innerSize(0), m_outerIndex(0), m_innerNonZeros(0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(0, 0)"
  },
  {
    "label": "SparseMatrix()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SparseMatrix(Index rows, Index cols) : m_outerSize(0), m_innerSize(0), m_outerIndex(0), m_innerNonZeros(0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(rows, cols)"
  },
  {
    "label": "SparseMatrix()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived>)",
    "insertText": "SparseMatrix(const SparseMatrixBase<OtherDerived>& other) : m_outerSize(0), m_innerSize(0), m_outerIndex(0), m_innerNonZeros(0)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT((internal::is_same<Scalar, typename OtherDerived::Scalar>::value), YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) check_template_parameters()"
  },
  {
    "label": "needToTranspose()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "needToTranspose(Flags & RowMajorBit) != (internal::evaluator<OtherDerived>::Flags & RowMajorBit)"
  },
  {
    "label": "SparseMatrix()",
    "kind": "Method",
    "detail": "Function (} } template<OtherDerived,unsigned int UpLo>)",
    "insertText": "SparseMatrix(const SparseSelfAdjointView<OtherDerived, UpLo>& other) : m_outerSize(0), m_innerSize(0), m_outerIndex(0), m_innerNonZeros(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(other)"
  },
  {
    "label": "SparseMatrix()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SparseMatrix(const SparseMatrix& other) : Base(), m_outerSize(0), m_innerSize(0), m_outerIndex(0), m_innerNonZeros(0)"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (* this = other .)",
    "insertText": "derived()"
  },
  {
    "label": "SparseMatrix()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived>)",
    "insertText": "SparseMatrix(const ReturnByValue<OtherDerived>& other) : Base(), m_outerSize(0), m_innerSize(0), m_outerIndex(0), m_innerNonZeros(0)"
  },
  {
    "label": "initAssignment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initAssignment(other)"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (other .)",
    "insertText": "evalTo(*this)"
  },
  {
    "label": "SparseMatrix()",
    "kind": "Method",
    "detail": "Function (} template<OtherDerived>)",
    "insertText": "SparseMatrix(const DiagonalBase<OtherDerived>& other) : Base(), m_outerSize(0), m_innerSize(0), m_outerIndex(0), m_innerNonZeros(0)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(SparseMatrix& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_outerIndex, other.m_outerIndex)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_innerSize, other.m_innerSize)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_outerSize, other.m_outerSize)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_innerNonZeros, other.m_innerNonZeros)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "swap(other.m_data)"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setIdentity()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(rows() == cols() && \"ONLY FOR SQUARED MATRICES\")"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (this -> m_data .)",
    "insertText": "resize(rows())"
  },
  {
    "label": "IndexVector()",
    "kind": "Method",
    "detail": "Function (Eigen::Map<)",
    "insertText": "IndexVector(this->m_data.indexPtr(), rows()).setLinSpaced(0, StorageIndex(rows()-1))"
  },
  {
    "label": "ScalarVector()",
    "kind": "Method",
    "detail": "Function (Eigen::Map<)",
    "insertText": "ScalarVector(this->m_data.valuePtr(), rows()).setOnes()"
  },
  {
    "label": "IndexVector()",
    "kind": "Method",
    "detail": "Function (Eigen::Map<)",
    "insertText": "IndexVector(this->m_outerIndex, rows()+1).setLinSpaced(0, StorageIndex(rows()))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (m_innerNonZeros = 0 ; } SparseMatrix&)",
    "insertText": "operator(const SparseMatrix& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(other.const_cast_derived())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this!=&other)"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(other.m_outerIndex, other.m_outerIndex + m_outerSize + 1, m_outerIndex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } return* this ; } # ifndef EIGEN_PARSED_BY_DOXYGEN template<OtherDerived> SparseMatrix&)",
    "insertText": "operator(const EigenBase<OtherDerived>& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Lhs,Rhs> SparseMatrix&)",
    "insertText": "operator(const Product<Lhs,Rhs,AliasFreeProduct>& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif template<OtherDerived> EIGEN_DONT_INLINE SparseMatrix&)",
    "insertText": "operator(const SparseMatrixBase<OtherDerived>& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (std::ostream&)",
    "insertText": "operator(std::ostream & s, const SparseMatrix& m)"
  },
  {
    "label": "EIGEN_DBG_SPARSE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_DBG_SPARSE(s << \"Nonzero entries:\\n\"; if(m.isCompressed()) { for (Index i=0; i<m.nonZeros(); ++i) s << \"(\" << m.m_data.value(i) << \",\" << m.m_data.index(i) << \") \"; } else { for (Index i=0; i<m.outerSize(); ++i) { Index p = m.m_outerIndex[i]; Index pe = m.m_outerIndex[i]+m.m_innerNonZeros[i]; Index k=p; for (; k<pe; ++k) { s << \"(\" << m.m_data.value(k) << \",\" << m.m_data.index(k) << \") \"; } for (; k<m.m_outerIndex[i+1]; ++k) { s << \"(_,_) \"; } } } s << std::endl; s << std::endl; s << \"Outer pointers:\\n\"; for (Index i=0; i<m.outerSize(); ++i) { s << m.m_outerIndex[i] << \" \"; } s << \" $\" << std::endl; if(!m.isCompressed()) { s << \"Inner non zeros:\\n\"; for (Index i=0; i<m.outerSize(); ++i) { s << m.m_innerNonZeros[i] << \" \"; } s << \" $\" << std::endl; } s << std::endl;)"
  },
  {
    "label": "SparseMatrix()",
    "kind": "Method",
    "detail": "Function (s<<static_cast<const SparseMatrixBase<)",
    "insertText": "SparseMatrix(m)"
  },
  {
    "label": "sum()",
    "kind": "Method",
    "detail": "Function (} Scalar)",
    "insertText": "sum()"
  },
  {
    "label": "initAssignment()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_SPARSEMATRIX_PLUGIN # include EIGEN_SPARSEMATRIX_PLUGIN # endif protected : template<Other> void)",
    "insertText": "initAssignment(const Other& other)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(other.rows(), other.cols())"
  },
  {
    "label": "insertCompressed()",
    "kind": "Method",
    "detail": "Function (m_innerNonZeros = 0 ; } } EIGEN_DONT_INLINE Scalar&)",
    "insertText": "insertCompressed(Index row, Index col)"
  },
  {
    "label": "SingletonVector()",
    "kind": "Method",
    "detail": "Function (class SingletonVector { StorageIndex m_index ; StorageIndex m_value ; public : typedef StorageIndex value_type ;)",
    "insertText": "SingletonVector(Index i, Index v) : m_index(convert_index(i)), m_value(convert_index(v))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} StorageIndex)",
    "insertText": "operator(Index i)"
  },
  {
    "label": "insertBackUncompressed()",
    "kind": "Method",
    "detail": "Function (public : EIGEN_STRONG_INLINE Scalar&)",
    "insertText": "insertBackUncompressed(Index row, Index col)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (const Index outer = IsRowMajor ? row : col ; const Index inner = IsRowMajor ? col : row ;)",
    "insertText": "eigen_assert(!isCompressed())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_innerNonZeros[outer]<=(m_outerIndex[outer+1] - m_outerIndex[outer]))"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (Index p = m_outerIndex [ outer ] + m_innerNonZeros [ outer ] + + ; m_data .)",
    "insertText": "index(p) = convert_index(inner)"
  },
  {
    "label": "IndexPosPair()",
    "kind": "Method",
    "detail": "Function (} protected : struct IndexPosPair {)",
    "insertText": "IndexPosPair(Index a_i, Index a_p) : i(a_i), p(a_p)"
  },
  {
    "label": "assignDiagonal()",
    "kind": "Method",
    "detail": "Function (} Index i ; Index p ; } ; template<DiagXpr,Func> void)",
    "insertText": "assignDiagonal(const DiagXpr diagXpr, const Func& assignFunc)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (Index n = diagXpr .)",
    "insertText": "size()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const bool overwrite = internal::is_same<Func,internal::assign_op<Scalar,Scalar>>::value ;)",
    "insertText": "if(overwrite)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_data.size()==0 || overwrite)"
  },
  {
    "label": "resizeNonZeros()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "resizeNonZeros(n)"
  },
  {
    "label": "ArrayXI()",
    "kind": "Method",
    "detail": "Function (Eigen::Map<)",
    "insertText": "ArrayXI(this->innerIndexPtr(), n).setLinSpaced(0,StorageIndex(n)-1)"
  },
  {
    "label": "ArrayXI()",
    "kind": "Method",
    "detail": "Function (Eigen::Map<)",
    "insertText": "ArrayXI(this->outerIndexPtr(), n+1).setLinSpaced(0,StorageIndex(n))"
  },
  {
    "label": "coeffs()",
    "kind": "Method",
    "detail": "Function (Eigen::Map<Array<Scalar,Dynamic,1>> values = this ->)",
    "insertText": "coeffs()"
  },
  {
    "label": "call_assignment_no_alias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_assignment_no_alias(values, diagXpr, assignFunc)"
  },
  {
    "label": "isCompressed()",
    "kind": "Method",
    "detail": "Function (} else { bool isComp =)",
    "insertText": "isCompressed()"
  },
  {
    "label": "diaEval()",
    "kind": "Method",
    "detail": "Function (internal::evaluator<DiagXpr>)",
    "insertText": "diaEval(diagXpr)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::vector<IndexPosPair> newEntries ;)",
    "insertText": "for(Index i = 0; i<n; ++i)"
  },
  {
    "label": "lower_bound()",
    "kind": "Method",
    "detail": "Function (internal::LowerBoundIndex lb = this ->)",
    "insertText": "lower_bound(i,i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index p = lb . value ;)",
    "insertText": "if(lb.found)"
  },
  {
    "label": "assignCoeff()",
    "kind": "Method",
    "detail": "Function (assignFunc .)",
    "insertText": "assignCoeff(m_data.value(p), diaEval.coeff(i))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((!isComp) && m_innerNonZeros[i] < (m_outerIndex[i+1]-m_outerIndex[i]))"
  },
  {
    "label": "moveChunk()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "moveChunk(p, p+1, m_outerIndex[i]+m_innerNonZeros[i]-p)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (m_innerNonZeros [ i ] + + ; m_data .)",
    "insertText": "value(p) = Scalar(0)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "index(p) = StorageIndex(i)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} else { newEntries .)",
    "insertText": "push_back(IndexPosPair(i,p))"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (} } Index n_entries =)",
    "insertText": "Index(newEntries.size())"
  },
  {
    "label": "newData()",
    "kind": "Method",
    "detail": "Function (Storage)",
    "insertText": "newData(m_data.size()+n_entries)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index prev_p = 0 ; Index prev_i = 0 ;)",
    "insertText": "for(Index k=0; k<n_entries;++k)"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (Index i = newEntries [ k ] . i ; Index p = newEntries [ k ] . p ;)",
    "insertText": "smart_copy(m_data.valuePtr()+prev_p, m_data.valuePtr()+p, newData.valuePtr()+prev_p+k)"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(m_data.indexPtr()+prev_p, m_data.indexPtr()+p, newData.indexPtr()+prev_p+k)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (prev_p = p ; prev_i = i ; newData .)",
    "insertText": "value(p+k) = Scalar(0)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (newData .)",
    "insertText": "index(p+k) = StorageIndex(i)"
  },
  {
    "label": "assignCoeff()",
    "kind": "Method",
    "detail": "Function (assignFunc .)",
    "insertText": "assignCoeff(newData.value(p+k), diaEval.coeff(i))"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (} {)",
    "insertText": "smart_copy(m_data.valuePtr()+prev_p, m_data.valuePtr()+m_data.size(), newData.valuePtr()+prev_p+n_entries)"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(m_data.indexPtr()+prev_p, m_data.indexPtr()+m_data.size(), newData.indexPtr()+prev_p+n_entries)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} m_data .)",
    "insertText": "swap(newData)"
  },
  {
    "label": "check_template_parameters()",
    "kind": "Method",
    "detail": "Function (} } } private : void)",
    "insertText": "check_template_parameters()"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT(NumTraits<StorageIndex>::IsSigned,THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT((Options&(ColMajor|RowMajor))==Options,INVALID_MATRIX_TEMPLATE_PARAMETERS)"
  },
  {
    "label": "default_prunning_func()",
    "kind": "Method",
    "detail": "Function (} struct default_prunning_func {)",
    "insertText": "default_prunning_func(const Scalar& ref, const RealScalar& eps) : reference(ref), epsilon(eps)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator() (const Index&, const Index&, const Scalar& value)"
  },
  {
    "label": "set_from_triplets()",
    "kind": "Method",
    "detail": "Function (} Scalar reference ; RealScalar epsilon ; } ; } ; namespace internal { template<InputIterator,SparseMatrixType,DupFunctor> void)",
    "insertText": "set_from_triplets(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, DupFunctor dup_func)"
  },
  {
    "label": "trMat()",
    "kind": "Method",
    "detail": "Function (enum { IsRowMajor = SparseMatrixType::IsRowMajor } ; typedef SparseMatrixType::Scalar Scalar ; typedef SparseMatrixType::StorageIndex StorageIndex ; SparseMatrix<Scalar,IsRowMajor ? ColMajor : RowMajor,StorageIndex>)",
    "insertText": "trMat(mat.rows(),mat.cols())"
  },
  {
    "label": "wi()",
    "kind": "Method",
    "detail": "Function (SparseMatrixType::IndexVector)",
    "insertText": "wi(trMat.outerSize())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(it->row()>=0 && it->row()<mat.rows() && it->col()>=0 && it->col()<mat.cols())"
  },
  {
    "label": "wi()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wi(IsRowMajor ? it->col() : it->row())"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} trMat .)",
    "insertText": "reserve(wi)"
  },
  {
    "label": "collapseDuplicates()",
    "kind": "Method",
    "detail": "Function (trMat .)",
    "insertText": "collapseDuplicates(dup_func)"
  },
  {
    "label": "_StorageIndex()",
    "kind": "Method",
    "detail": "Function (internal::set_from_triplets<InputIterators,SparseMatrix<Scalar,_Options,)",
    "insertText": "_StorageIndex(begin, end, *this, internal::scalar_sum_op<Scalar,Scalar>())"
  },
  {
    "label": "DupFunctor()",
    "kind": "Method",
    "detail": "Function (internal::set_from_triplets<InputIterators,SparseMatrix<Scalar,_Options,_StorageIndex>,)",
    "insertText": "DupFunctor(begin, end, *this, dup_func)"
  },
  {
    "label": "collapseDuplicates()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,int _Options,_StorageIndex> template<DupFunctor> void SparseMatrix<Scalar,_Options,_StorageIndex)",
    "insertText": "collapseDuplicates(DupFunctor dup_func)"
  },
  {
    "label": "wi()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "wi(innerSize())"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (wi .)",
    "insertText": "fill(-1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (StorageIndex count = 0 ;)",
    "insertText": "for(Index j=0; j<outerSize(); ++j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (StorageIndex start = count ; Index oldEnd = m_outerIndex [ j ] + m_innerNonZeros [ j ] ;)",
    "insertText": "for(Index k=m_outerIndex[j]; k<oldEnd; ++k)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (Index i = m_data .)",
    "insertText": "index(k)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "value(wi(i)) = dup_func(m_data.value(wi(i)), m_data.value(k))"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} else { m_data .)",
    "insertText": "value(count) = m_data.value(k)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "index(count) = m_data.index(k)"
  },
  {
    "label": "wi()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wi(i)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT((internal::is_same<Scalar, typename OtherDerived::Scalar>::value), YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) #ifdef EIGEN_SPARSE_CREATE_TEMPORARY_PLUGIN EIGEN_SPARSE_CREATE_TEMPORARY_PLUGIN #endif const bool needToTranspose = (Flags & RowMajorBit) != (internal::evaluator<OtherDerived>::Flags & RowMajorBit)"
  },
  {
    "label": "otherCopy()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_SPARSE_TRANSPOSED_COPY_PLUGIN EIGEN_SPARSE_TRANSPOSED_COPY_PLUGIN # endif typedef internal::nested_eval<OtherDerived,2,internal::plain_matrix_type<OtherDerived>::type>::type OtherCopy ; typedef internal::remove_all<OtherCopy>::type _OtherCopy ; typedef internal::evaluator<_OtherCopy> OtherCopyEval ; OtherCopy)",
    "insertText": "otherCopy(other.derived())"
  },
  {
    "label": "otherCopyEval()",
    "kind": "Method",
    "detail": "Function (OtherCopyEval)",
    "insertText": "otherCopyEval(otherCopy)"
  },
  {
    "label": "dest()",
    "kind": "Method",
    "detail": "Function (SparseMatrix)",
    "insertText": "dest(other.rows(),other.cols())"
  },
  {
    "label": "IndexVector()",
    "kind": "Method",
    "detail": "Function (Eigen::Map<)",
    "insertText": "IndexVector(dest.m_outerIndex,dest.outerSize()).setZero()"
  },
  {
    "label": "positions()",
    "kind": "Method",
    "detail": "Function (StorageIndex count = 0 ; IndexVector)",
    "insertText": "positions(dest.outerSize())"
  },
  {
    "label": "outerSize()",
    "kind": "Method",
    "detail": "Function (StorageIndex tmp = dest . m_outerIndex [ j ] ; dest . m_outerIndex [ j ] = count ; positions [ j ] = count ; count + = tmp ; } dest . m_outerIndex [ dest .)",
    "insertText": "outerSize()"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (Index pos = positions [ it .)",
    "insertText": "index()"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (dest . m_data .)",
    "insertText": "index(pos)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (dest . m_data .)",
    "insertText": "value(pos) = it.value()"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} } this ->)",
    "insertText": "swap(dest)"
  },
  {
    "label": "initAssignment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initAssignment(other.derived())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "operator(other.derived())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index outer = IsRowMajor ? row : col ; const Index inner = IsRowMajor ? col : row ;)",
    "insertText": "if(isCompressed())"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(m_innerNonZeros, 0, (m_outerSize)*sizeof(StorageIndex))"
  },
  {
    "label": "convert_index()",
    "kind": "Method",
    "detail": "Function (StorageIndex end =)",
    "insertText": "convert_index(m_data.allocatedSize())"
  },
  {
    "label": "allocatedSize()",
    "kind": "Method",
    "detail": "Function (} } Index data_end = m_data .)",
    "insertText": "allocatedSize()"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(m_innerNonZeros[outer]==0)"
  },
  {
    "label": "convert_index()",
    "kind": "Method",
    "detail": "Function (StorageIndex p =)",
    "insertText": "convert_index(m_data.size())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Index j = outer ;)",
    "insertText": "while(j>=0 && m_innerNonZeros[j]==0)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(data_end < m_data.allocatedSize())"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} return m_data .)",
    "insertText": "value(p)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_outerIndex[outer+1]==data_end && m_outerIndex[outer]+m_innerNonZeros[outer]==m_data.size())"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(outer+1==m_outerSize || m_innerNonZeros[outer+1]==0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (+ + m_innerNonZeros [ outer ] ; m_data .)",
    "insertText": "resize(m_data.size()+1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} Index startId = m_outerIndex [ outer ] ; Index p = m_outerIndex [ outer ] + m_innerNonZeros [ outer ] - 1 ;)",
    "insertText": "while((p > startId) && (m_data.index(p-1) > inner))"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "index(p) = m_data.index(p-1)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "value(p) = m_data.value(p-1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_data.size() != m_data.allocatedSize())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "resize(m_data.allocatedSize())"
  },
  {
    "label": "reserveInnerVectors()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "reserveInnerVectors(Array<StorageIndex,Dynamic,1>::Constant(m_outerSize, 2))"
  },
  {
    "label": "insertUncompressed()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "insertUncompressed(row,col)"
  },
  {
    "label": "insertUncompressed()",
    "kind": "Method",
    "detail": "Function (} template<_Scalar,int _Options,_StorageIndex> EIGEN_DONT_INLINE SparseMatrix<_Scalar,_Options,_StorageIndex>::Scalar& SparseMatrix<_Scalar,_Options,_StorageIndex)",
    "insertText": "insertUncompressed(Index row, Index col)"
  },
  {
    "label": "convert_index()",
    "kind": "Method",
    "detail": "Function (const Index outer = IsRowMajor ? row : col ; const StorageIndex inner =)",
    "insertText": "convert_index(IsRowMajor ? col : row)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index room = m_outerIndex [ outer + 1 ] - m_outerIndex [ outer ] ; StorageIndex innerNNZ = m_innerNonZeros [ outer ] ;)",
    "insertText": "if(innerNNZ>=room)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(SingletonVector(outer,std::max<StorageIndex>(2,innerNNZ)))"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (- - p ; })",
    "insertText": "eigen_assert((p<=startId || m_data.index(p-1)!=inner) && \"you cannot insert an element that already exists, you must call coeffRef to this end\")"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (m_innerNonZeros [ outer ] + + ; m_data .)",
    "insertText": "index(p)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(isCompressed())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index outer = IsRowMajor ? row : col ; const Index inner = IsRowMajor ? col : row ; Index previousOuter = outer ;)",
    "insertText": "if(m_outerIndex[outer+1]==0)"
  },
  {
    "label": "isLastVec()",
    "kind": "Method",
    "detail": "Function (- - previousOuter ; } m_outerIndex [ outer + 1 ] = m_outerIndex [ outer ] ; } bool)",
    "insertText": "isLastVec(!(previousOuter==-1 && m_data.size()!=0)) && (std::size_t(m_outerIndex[outer+1]) == m_data.size())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (std::size_t startId = m_outerIndex [ outer ] ; std::size_t p = m_outerIndex [ outer + 1 ] ; + + m_outerIndex [ outer + 1 ] ; double reallocRatio = 1 ;)",
    "insertText": "if(m_data.allocatedSize()<=m_data.size())"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "reserve(32)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (} else { double nnzEstimate =)",
    "insertText": "double(m_outerIndex[outer])*double(m_outerSize)/double(outer+1)"
  },
  {
    "label": "reallocRatio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reallocRatio(nnzEstimate-double(m_data.size()))/double(m_data.size())"
  },
  {
    "label": "reallocRatio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reallocRatio(std::min)((std::max)(reallocRatio,1.5),8.)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} } m_data .)",
    "insertText": "resize(m_data.size()+1,reallocRatio)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Index k = outer + 1 ;)",
    "insertText": "while(m_outerIndex[k]==0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (p = 0 ; - - k ; k = m_outerIndex [ k ] - 1 ;)",
    "insertText": "while(k>0)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "index(k) = m_data.index(k-1)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (m_data .)",
    "insertText": "value(k) = m_data.value(k-1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (k - - ; } } else { Index j = outer + 2 ;)",
    "insertText": "while(j<=m_outerSize && m_outerIndex[j]!=0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (- - j ; Index k = m_outerIndex [ j ] - 1 ;)",
    "insertText": "while(k>=Index(p))"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (} namespace internal { template<_Scalar,int _Options,_StorageIndex> struct evaluator<SparseMatrix<_Scalar,_Options,_StorageIndex>> : evaluator<SparseCompressedBase<SparseMatrix<_Scalar,_Options,_StorageIndex>>> { typedef evaluator<SparseCompressedBase<SparseMatrix<_Scalar,_Options,_StorageIndex>>> Base ; typedef SparseMatrix<_Scalar,_Options,_StorageIndex> SparseMatrixType ;)",
    "insertText": "evaluator() : Base()"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "evaluator(const SparseMatrixType &mat) : Base(mat)"
  }
]