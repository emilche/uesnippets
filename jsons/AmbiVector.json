[
  {
    "label": "AmbiVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AmbiVector"
  },
  {
    "label": "Iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Iterator"
  },
  {
    "label": "ListEl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ListEl"
  },
  {
    "label": "AmbiVector()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_AMBIVECTOR_H # define EIGEN_AMBIVECTOR_H namespace Eigen { namespace internal { template<_Scalar,_StorageIndex> class AmbiVector { public : typedef _Scalar Scalar ; typedef _StorageIndex StorageIndex ; typedef NumTraits<Scalar>::Real RealScalar ;)",
    "insertText": "AmbiVector(Index size) : m_buffer(0), m_zero(0), m_size(0), m_end(0), m_allocatedSize(0), m_allocatedElements(0), m_mode(-1)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(size)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "init(double estimatedDensity)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init(int mode)"
  },
  {
    "label": "nonZeros()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "nonZeros()"
  },
  {
    "label": "setBounds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setBounds(Index start, Index end)"
  },
  {
    "label": "convert_index()",
    "kind": "Method",
    "detail": "Function (m_start =)",
    "insertText": "convert_index(start)"
  },
  {
    "label": "convert_index()",
    "kind": "Method",
    "detail": "Function (m_end =)",
    "insertText": "convert_index(end)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setZero()"
  },
  {
    "label": "restart()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "restart()"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (Scalar&)",
    "insertText": "coeffRef(Index i)"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (Scalar&)",
    "insertText": "coeff(Index i)"
  },
  {
    "label": "AmbiVector()",
    "kind": "Method",
    "detail": "Function (class Iterator ; ~)",
    "insertText": "AmbiVector()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (delete [ ] m_buffer ; } void)",
    "insertText": "resize(Index size)"
  },
  {
    "label": "convert_index()",
    "kind": "Method",
    "detail": "Function (m_size =)",
    "insertText": "convert_index(size)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} StorageIndex)",
    "insertText": "size()"
  },
  {
    "label": "reallocate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reallocate(Index size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (delete [ ] m_buffer ;)",
    "insertText": "if(size<1000)"
  },
  {
    "label": "allocSize()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "allocSize(size * sizeof(ListEl) + sizeof(Scalar) - 1)/sizeof(Scalar)"
  },
  {
    "label": "convert_index()",
    "kind": "Method",
    "detail": "Function (m_allocatedElements =)",
    "insertText": "convert_index((allocSize*sizeof(Scalar))/sizeof(ListEl))"
  },
  {
    "label": "convert_index()",
    "kind": "Method",
    "detail": "Function (m_buffer = new Scalar [ allocSize ] ; } else { m_allocatedElements =)",
    "insertText": "convert_index((size*sizeof(Scalar))/sizeof(ListEl))"
  },
  {
    "label": "reallocateSparse()",
    "kind": "Method",
    "detail": "Function (m_start = 0 ; m_end = m_size ; } void)",
    "insertText": "reallocateSparse()"
  },
  {
    "label": "m_allocatedElements()",
    "kind": "Method",
    "detail": "Function (Index copyElements = m_allocatedElements ;)",
    "insertText": "m_allocatedElements(std::min)(StorageIndex(m_allocatedElements*1.5),m_size)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (Index allocSize = m_allocatedElements*)",
    "insertText": "sizeof(ListEl)"
  },
  {
    "label": "allocSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "allocSize(allocSize + sizeof(Scalar) - 1)/sizeof(Scalar)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (Scalar* newBuffer = new Scalar [ allocSize ] ;)",
    "insertText": "memcpy(newBuffer, m_buffer, copyElements * sizeof(ListEl))"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "eigen_assert(m_mode==IsSparse)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (m_llStart = 0 ; m_llCurrent = 0 ; + + m_llSize ; llElements [ 0 ] . value =)",
    "insertText": "Scalar(0)"
  },
  {
    "label": "convert_index()",
    "kind": "Method",
    "detail": "Function (llElements [ 0 ] . index =)",
    "insertText": "convert_index(i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (llElements [ 0 ] . next = - 1 ; return llElements [ 0 ] . value ; } else)",
    "insertText": "if(i<llElements[m_llStart].index)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (el . next = m_llStart ; m_llStart = m_llSize ; + + m_llSize ; m_llCurrent = m_llStart ; return el . value ; } else { StorageIndex nextel = llElements [ m_llCurrent ] . next ;)",
    "insertText": "eigen_assert(i>=llElements[m_llCurrent].index && \"you must call restart() before inserting an element with lower or equal index\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_llCurrent = nextel ; nextel = llElements [ nextel ] . next ; })",
    "insertText": "if(llElements[m_llCurrent].index==i)"
  },
  {
    "label": "ListEl()",
    "kind": "Method",
    "detail": "Function (llElements = reinterpret_cast<)",
    "insertText": "ListEl(m_buffer)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "eigen_internal_assert(m_llSize<m_allocatedElements && \"internal error: overflow in sparse mode\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using std::abs ; m_epsilon = epsilon ; m_isDense = m_vector . m_mode = = IsDense ;)",
    "insertText": "if(m_isDense)"
  },
  {
    "label": "m_start()",
    "kind": "Method",
    "detail": "Function (m_currentEl = 0 ; m_cachedValue = 0 ; m_cachedIndex = m_vector .)",
    "insertText": "m_start(*this)"
  },
  {
    "label": "ListEl()",
    "kind": "Method",
    "detail": "Function (} else { ListEl* EIGEN_RESTRICT llElements = reinterpret_cast<)",
    "insertText": "ListEl(m_vector.m_buffer)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (m_currentEl = m_vector . m_llStart ;)",
    "insertText": "while(m_currentEl>=0 && abs(llElements[m_currentEl].value)<=m_epsilon)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (m_cachedValue = 0 ; m_cachedIndex = - 1 ; } else { m_cachedIndex = llElements [ m_currentEl ] . index ; m_cachedValue = llElements [ m_currentEl ] . value ; } } } StorageIndex)",
    "insertText": "index()"
  }
]