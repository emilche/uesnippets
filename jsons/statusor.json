[
  {
    "label": "BadStatusOrAccess",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BadStatusOrAccess"
  },
  {
    "label": "ABSL_MUST_USE_RESULT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ABSL_MUST_USE_RESULT"
  },
  {
    "label": "StatusOr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StatusOr"
  },
  {
    "label": "BadStatusOrAccess()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_STATUS_STATUSOR_H_ # define ABSL_STATUS_STATUSOR_H_ # include<exception> # include<initializer_list> # include<new> # include<string> # include<type_traits> # include<utility> # include \" absl / base / attributes . h \" # include \" absl / base / call_once . h \" # include \" absl / meta / type_traits . h \" # include \" absl / status / internal / statusor_internal . h \" # include \" absl / status / status . h \" # include \" absl / types / variant . h \" # include \" absl / utility / utility . h \" namespace absl { ABSL_NAMESPACE_BEGIN class BadStatusOrAccess : public std::exception { public :)",
    "insertText": "BadStatusOrAccess(absl::Status status)"
  },
  {
    "label": "BadStatusOrAccess()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "BadStatusOrAccess()"
  },
  {
    "label": "BadStatusOrAccess()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BadStatusOrAccess(const BadStatusOrAccess& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (BadStatusOrAccess&)",
    "insertText": "operator(const BadStatusOrAccess& other)"
  },
  {
    "label": "BadStatusOrAccess()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BadStatusOrAccess(BadStatusOrAccess&& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (BadStatusOrAccess&)",
    "insertText": "operator(BadStatusOrAccess&& other)"
  },
  {
    "label": "what()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "what()"
  },
  {
    "label": "status()",
    "kind": "Method",
    "detail": "Function (const absl::Status&)",
    "insertText": "status()"
  },
  {
    "label": "InitWhat()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "InitWhat()"
  },
  {
    "label": "ABSL_HAVE_CPP_ATTRIBUTE()",
    "kind": "Method",
    "detail": "Function (absl::Status status_ ; absl::once_flag init_what_ ; std::string what_ ; } ; template<T> # if)",
    "insertText": "ABSL_HAVE_CPP_ATTRIBUTE(nodiscard)"
  },
  {
    "label": "StatusOr()",
    "kind": "Method",
    "detail": "Function (# else class ABSL_MUST_USE_RESULT StatusOr ; # endif template<T> class StatusOr : private internal_statusor::StatusOrData<T>,private internal_statusor::CopyCtorBase<T>,private internal_statusor::MoveCtorBase<T>,private internal_statusor::CopyAssignBase<T>,private internal_statusor::MoveAssignBase<T> { template<U> class StatusOr ; typedef internal_statusor::StatusOrData<T> Base ; public : typedef T value_type ;)",
    "insertText": "StatusOr()"
  },
  {
    "label": "StatusOr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StatusOr(const StatusOr&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (StatusOr&)",
    "insertText": "operator(const StatusOr&)"
  },
  {
    "label": "StatusOr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StatusOr(StatusOr&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (StatusOr&)",
    "insertText": "operator(StatusOr&&)"
  },
  {
    "label": "StatusOr()",
    "kind": "Method",
    "detail": "Function (template<U,absl::enable_if_t<absl::conjunction<absl::negation<std::is_same<T,U>>,std::is_constructible<T,const U&>,std::is_convertible<const U&,T>,absl::negation<internal_statusor::IsConstructibleOrConvertibleFromStatusOr<T,U>>>::value,int> = 0>)",
    "insertText": "StatusOr(const StatusOr<U>& other) : Base(static_cast<const typename StatusOr<U>::Base&>(other))"
  },
  {
    "label": "StatusOr()",
    "kind": "Method",
    "detail": "Function (} template<U,absl::enable_if_t<absl::conjunction<absl::negation<std::is_same<T,U>>,std::is_constructible<T,U&&>,std::is_convertible<U&&,T>,absl::negation<internal_statusor::IsConstructibleOrConvertibleFromStatusOr<T,U>>>::value,int> = 0>)",
    "insertText": "StatusOr(StatusOr<U>&& other) : Base(static_cast<typename StatusOr<U>::Base&&>(other))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<U,absl::enable_if_t<absl::conjunction<absl::negation<std::is_same<T,U>>,std::is_constructible<T,const U&>,std::is_assignable<T,const U&>,absl::negation<internal_statusor::IsConstructibleOrConvertibleOrAssignableFromStatusOr<T,U>>>::value,int> = 0> StatusOr&)",
    "insertText": "operator(const StatusOr<U>& other)"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Assign(other)"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Assign(std::move(other))"
  },
  {
    "label": "StatusOr()",
    "kind": "Method",
    "detail": "Function (} template<U = absl::Status,absl::enable_if_t<absl::conjunction<absl::negation<std::is_convertible<U&&,absl::Status>>,std::is_constructible<absl::Status,U&&>,absl::negation<std::is_same<absl::decay_t<U>,absl::StatusOr<T>>>,absl::negation<std::is_same<absl::decay_t<U>,T>>,absl::negation<std::is_same<absl::decay_t<U>,absl::in_place_t>>,absl::negation<internal_statusor::HasConversionOperatorToStatusOr<T,U&&>>>::value,int> = 0>)",
    "insertText": "StatusOr(U&& v) : Base(std::forward<U>(v))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<U = absl::Status,absl::enable_if_t<absl::conjunction<std::is_convertible<U&&,absl::Status>,std::is_constructible<absl::Status,U&&>,absl::negation<std::is_same<absl::decay_t<U>,absl::StatusOr<T>>>,absl::negation<std::is_same<absl::decay_t<U>,T>>,absl::negation<std::is_same<absl::decay_t<U>,absl::in_place_t>>,absl::negation<internal_statusor::HasConversionOperatorToStatusOr<T,U&&>>>::value,int> = 0> StatusOr&)",
    "insertText": "operator(U&& v)"
  },
  {
    "label": "AssignStatus()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "AssignStatus(std::forward<U>(v))"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Assign(std::forward<U>(v))"
  },
  {
    "label": "StatusOr()",
    "kind": "Method",
    "detail": "Function (template<U,. . . Args>)",
    "insertText": "StatusOr(absl::in_place_t, std::initializer_list<U> ilist, Args&&... args)"
  },
  {
    "label": "StatusOr()",
    "kind": "Method",
    "detail": "Function (template<U = T,absl::enable_if_t<absl::conjunction<internal_statusor::IsDirectInitializationValid<T,U&&>,std::is_constructible<T,U&&>,std::is_convertible<U&&,T>,absl::disjunction<std::is_same<absl::remove_cv_t<absl::remove_reference_t<U>>,T>,absl::conjunction<absl::negation<std::is_convertible<U&&,absl::Status>>,absl::negation<internal_statusor::HasConversionOperatorToStatusOr<T,U&&>>>>>::value,int> = 0>)",
    "insertText": "StatusOr(U&& u) : StatusOr(absl::in_place, std::forward<U>(u))"
  },
  {
    "label": "ok()",
    "kind": "Method",
    "detail": "Function (} ABSL_MUST_USE_RESULT bool)",
    "insertText": "ok()"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (const T&)",
    "insertText": "value()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (const T&)",
    "insertText": "operator()"
  },
  {
    "label": "value_or()",
    "kind": "Method",
    "detail": "Function (template<U> T)",
    "insertText": "value_or(U&& default_value)"
  },
  {
    "label": "IgnoreError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IgnoreError()"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (template<. . . Args> T&)",
    "insertText": "emplace(Args&&... args)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Clear()"
  },
  {
    "label": "MakeValue()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "MakeValue(std::forward<Args>(args)...)"
  },
  {
    "label": "OkStatus()",
    "kind": "Method",
    "detail": "Function (this -> status_ =)",
    "insertText": "OkStatus()"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (} return this -> data_ ; } template<U,. . . Args,absl::enable_if_t<std::is_constructible<T,std::initializer_list<U>&,Args&& . . .>::value,int> = 0> T&)",
    "insertText": "emplace(std::initializer_list<U> ilist, Args&&... args)"
  },
  {
    "label": "MakeValue()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "MakeValue(ilist, std::forward<Args>(args)...)"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (} return this -> data_ ; } private : using internal_statusor::StatusOrData<T>::Assign ; template<U> void)",
    "insertText": "Assign(const absl::StatusOr<U>& other)"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (template<U> void)",
    "insertText": "Assign(absl::StatusOr<U>&& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<T> bool)",
    "insertText": "operator(const StatusOr<T>& lhs, const StatusOr<T>& rhs)"
  },
  {
    "label": "StatusOr()",
    "kind": "Method",
    "detail": "Function (} template<T> StatusOr<T)",
    "insertText": "StatusOr() : Base(Status(absl::StatusCode::kUnknown, \"\"))"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (} template<T> template<U> void StatusOr<T)",
    "insertText": "Assign(const StatusOr<U>& other)"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Assign(*other)"
  },
  {
    "label": "AssignStatus()",
    "kind": "Method",
    "detail": "Function (} else { this ->)",
    "insertText": "AssignStatus(other.status())"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (} } template<T> template<U> void StatusOr<T)",
    "insertText": "Assign(StatusOr<U>&& other)"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Assign(*std::move(other))"
  },
  {
    "label": "AssignStatus()",
    "kind": "Method",
    "detail": "Function (} else { this ->)",
    "insertText": "AssignStatus(std::move(other).status())"
  },
  {
    "label": "StatusOr()",
    "kind": "Method",
    "detail": "Function (} } template<T> template<. . . Args> StatusOr<T)",
    "insertText": "StatusOr(absl::in_place_t, Args&&... args) : Base(absl::in_place, std::forward<Args>(args)...)"
  },
  {
    "label": "StatusOr()",
    "kind": "Method",
    "detail": "Function (} template<T> template<U,. . . Args> StatusOr<T)",
    "insertText": "StatusOr(absl::in_place_t, std::initializer_list<U> ilist, Args&&... args) : Base(absl::in_place, ilist, std::forward<Args>(args)...)"
  },
  {
    "label": "ThrowBadStatusOrAccess()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ThrowBadStatusOrAccess(std::move(this->status_))"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "move(this->data_)"
  },
  {
    "label": "EnsureOk()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "EnsureOk()"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (} return std::forward<)",
    "insertText": "U(default_value)"
  }
]