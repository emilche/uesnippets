[
  {
    "label": "USkeleton",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "USkeleton"
  },
  {
    "label": "FBoneContainer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBoneContainer"
  },
  {
    "label": "FCurveUtils",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCurveUtils"
  },
  {
    "label": "FCurveFilter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCurveFilter"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "EAnimAssetCurveFlags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EAnimAssetCurveFlags"
  },
  {
    "label": "FAnimCurveParam",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimCurveParam"
  },
  {
    "label": "FAnimCurveBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimCurveBase"
  },
  {
    "label": "TStructOpsTypeTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TStructOpsTypeTraits"
  },
  {
    "label": "FFloatCurve",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFloatCurve"
  },
  {
    "label": "FVectorCurve",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVectorCurve"
  },
  {
    "label": "FTransformCurve",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTransformCurve"
  },
  {
    "label": "FCachedFloatCurve",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCachedFloatCurve"
  },
  {
    "label": "UE_DEPRECATED",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UE_DEPRECATED"
  },
  {
    "label": "FCurveElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCurveElement"
  },
  {
    "label": "FCurveElementIndexed",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCurveElementIndexed"
  },
  {
    "label": "FBaseBlendedCurve_DEPRECATED",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBaseBlendedCurve_DEPRECATED"
  },
  {
    "label": "TBaseBlendedCurve",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TBaseBlendedCurve"
  },
  {
    "label": "UE",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UE"
  },
  {
    "label": "FBlendedCurve",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBlendedCurve"
  },
  {
    "label": "FBlendedHeapCurve",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBlendedHeapCurve"
  },
  {
    "label": "FRawCurveTracks",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRawCurveTracks"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / ObjectMacros . h \" # include \" Animation / AnimTypes . h \" # include \" Animation / SmartName . h \" # include \" Curves / RichCurve . h \" # include \" Misc / EnumRange . h \" # include \" AnimCurveElementFlags . h \" # include \" Animation / NamedValueArray . h \" # include \" AnimCurveTypes . generated . h \" typedef SmartName::UID_Type SkeletonAnimCurveUID ; class USkeleton ; struct FBoneContainer ; namespace UE::Anim { struct FCurveUtils ; struct FCurveFilter ; })",
    "insertText": "UENUM()"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (AttributeCurve,MaterialCurve,MorphTargetCurve,MaxAnimCurveType)",
    "insertText": "UMETA(Hidden)"
  },
  {
    "label": "ENUM_RANGE_BY_COUNT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ENUM_RANGE_BY_COUNT(EAnimCurveType, EAnimCurveType::MaxAnimCurveType)"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UENUM(BlueprintType, meta=(Bitflags))"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (AACF_NONE = 0)",
    "insertText": "UMETA(Hidden), AACF_DriveMorphTarget_DEPRECATED = 0x00000001 UMETA(Hidden), AACF_DriveAttribute_DEPRECATED = 0x00000002 UMETA(Hidden), AACF_Editable = 0x00000004 UMETA(DisplayName = \"Editable\"), AACF_DriveMaterial_DEPRECATED = 0x00000008 UMETA(Hidden), AACF_Metadata = 0x00000010 UMETA(DisplayName = \"Metadata\"), AACF_DriveTrack = 0x00000020 UMETA(Hidden), AACF_Disabled = 0x00000040 UMETA(Hidden)"
  },
  {
    "label": "ENUM_RANGE_BY_FIRST_AND_LAST()",
    "kind": "Method",
    "detail": "Function (const EAnimAssetCurveFlags AACF_DefaultCurve = AACF_Editable ;)",
    "insertText": "ENUM_RANGE_BY_FIRST_AND_LAST(EAnimAssetCurveFlags, AACF_DriveMorphTarget_DEPRECATED, AACF_Disabled)"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "USTRUCT()"
  },
  {
    "label": "GENERATED_USTRUCT_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_USTRUCT_BODY() UPROPERTY(EditAnywhere, Category = FAnimCurveParam)"
  },
  {
    "label": "FAnimCurveParam()",
    "kind": "Method",
    "detail": "Function (SmartName::UID_Type UID ;)",
    "insertText": "FAnimCurveParam() : UID(SmartName::MaxUID)"
  },
  {
    "label": "GENERATED_USTRUCT_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_USTRUCT_BODY() #if WITH_EDITORONLY_DATA UPROPERTY()"
  },
  {
    "label": "FAnimCurveBase()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FAnimCurveBase() : CurveTypeFlags(0)"
  },
  {
    "label": "MakeColor()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITORONLY_DATA Color =)",
    "insertText": "MakeColor(CurveName)"
  },
  {
    "label": "FAnimCurveBase()",
    "kind": "Method",
    "detail": "Function (# endif })",
    "insertText": "FAnimCurveBase(FName InName, int32 InCurveTypeFlags) : CurveName(InName) , CurveTypeFlags(InCurveTypeFlags)"
  },
  {
    "label": "PostSerializeFixup()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "PostSerializeFixup(FArchive& Ar)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "PostSerialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PostSerialize(const FArchive& Ar)"
  },
  {
    "label": "SetCurveTypeFlag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCurveTypeFlag(EAnimAssetCurveFlags InFlag, bool bValue)"
  },
  {
    "label": "ToggleCurveTypeFlag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ToggleCurveTypeFlag(EAnimAssetCurveFlags InFlag)"
  },
  {
    "label": "GetCurveTypeFlag()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetCurveTypeFlag(EAnimAssetCurveFlags InFlag)"
  },
  {
    "label": "SetCurveTypeFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCurveTypeFlags(int32 NewCurveTypeFlags)"
  },
  {
    "label": "GetCurveTypeFlags()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetCurveTypeFlags()"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (FName)",
    "insertText": "GetName()"
  },
  {
    "label": "GetColor()",
    "kind": "Method",
    "detail": "Function (CurveName = InName ; } # if WITH_EDITORONLY_DATA FLinearColor)",
    "insertText": "GetColor()"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<> struct TStructOpsTypeTraits<FAnimCurveBase> : public TStructOpsTypeTraitsBase2<FAnimCurveBase> { enum { WithSerializer = true,WithPostSerialize = true,} ; } ;)",
    "insertText": "USTRUCT(BlueprintType)"
  },
  {
    "label": "GENERATED_USTRUCT_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_USTRUCT_BODY() UPROPERTY()"
  },
  {
    "label": "FFloatCurve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FFloatCurve()"
  },
  {
    "label": "FFloatCurve()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FFloatCurve(FName InName, int32 InCurveTypeFlags) : FAnimCurveBase(InName, InCurveTypeFlags)"
  },
  {
    "label": "CopyCurve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CopyCurve(const FFloatCurve& SourceCurve)"
  },
  {
    "label": "Evaluate()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "Evaluate(float CurrentTime)"
  },
  {
    "label": "UpdateOrAddKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateOrAddKey(float NewKey, float CurrentTime)"
  },
  {
    "label": "GetKeys()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetKeys(TArray<float>& OutTimes, TArray<float>& OutValues)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Resize(float NewLength, bool bInsert , float OldStartTime, float OldEndTime)"
  },
  {
    "label": "GENERATED_USTRUCT_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_USTRUCT_BODY()"
  },
  {
    "label": "FVectorCurve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FVectorCurve()"
  },
  {
    "label": "FVectorCurve()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FVectorCurve(FName InName, int32 InCurveTypeFlags) : FAnimCurveBase(InName, InCurveTypeFlags)"
  },
  {
    "label": "CopyCurve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CopyCurve(const FVectorCurve& SourceCurve)"
  },
  {
    "label": "Evaluate()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "Evaluate(float CurrentTime, float BlendWeight)"
  },
  {
    "label": "UpdateOrAddKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateOrAddKey(const FVector& NewKey, float CurrentTime)"
  },
  {
    "label": "GetKeys()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetKeys(TArray<float>& OutTimes, TArray<FVector>& OutValues)"
  },
  {
    "label": "DoesContainKey()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DoesContainKey()"
  },
  {
    "label": "GetNumKeys()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumKeys()"
  },
  {
    "label": "FTransformCurve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FTransformCurve()"
  },
  {
    "label": "FTransformCurve()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FTransformCurve(FName InName, int32 InCurveTypeFlags) : FAnimCurveBase(InName, InCurveTypeFlags)"
  },
  {
    "label": "CopyCurve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CopyCurve(const FTransformCurve& SourceCurve)"
  },
  {
    "label": "UpdateOrAddKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateOrAddKey(const FTransform& NewKey, float CurrentTime)"
  },
  {
    "label": "GetKeys()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetKeys(TArray<float>& OutTimes, TArray<FTransform>& OutValues)"
  },
  {
    "label": "GetVectorCurveByIndex()",
    "kind": "Method",
    "detail": "Function (const FVectorCurve*)",
    "insertText": "GetVectorCurveByIndex(int32 Index)"
  },
  {
    "label": "GENERATED_USTRUCT_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_USTRUCT_BODY() public: UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Curve Settings\")"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "IsValid(const UAnimSequenceBase* InAnimSequence)"
  },
  {
    "label": "GetValueAtPosition()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetValueAtPosition(const UAnimSequenceBase* InAnimSequence, const float& InPosition)"
  },
  {
    "label": "GetFloatCurve()",
    "kind": "Method",
    "detail": "Function (const FFloatCurve*)",
    "insertText": "GetFloatCurve(const UAnimSequenceBase* InAnimSequence)"
  },
  {
    "label": "FCurveElement()",
    "kind": "Method",
    "detail": "Function (float Value ; bool bValid ;)",
    "insertText": "FCurveElement(float InValue) : Value(InValue) , bValid (true)"
  },
  {
    "label": "FCurveElement()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FCurveElement() : Value(0.f) , bValid(false)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "FCurveElement()",
    "kind": "Method",
    "detail": "Function (Value = InValue ; bValid = true ; } } ; namespace UE::Anim { struct FCurveElement {)",
    "insertText": "FCurveElement()"
  },
  {
    "label": "FCurveElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FCurveElement(FName InName) : Name(InName)"
  },
  {
    "label": "FCurveElement()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FCurveElement(FName InName, float InValue) : Name(InName) , Value(InValue)"
  },
  {
    "label": "FCurveElement()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FCurveElement(FName InName, ECurveElementFlags InFlags) : Name(InName) , Flags(InFlags)"
  },
  {
    "label": "FCurveElement()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FCurveElement(FName InName, float InValue, ECurveElementFlags InFlags) : Name(InName) , Value(InValue) , Flags(InFlags)"
  },
  {
    "label": "FCurveElementIndexed()",
    "kind": "Method",
    "detail": "Function (} FName Name = NAME_None ; float Value = 0 . 0 f ; ECurveElementFlags Flags = ECurveElementFlags::None ; } ; struct FCurveElementIndexed : public UE::Anim::FCurveElement {)",
    "insertText": "FCurveElementIndexed()"
  },
  {
    "label": "FCurveElementIndexed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FCurveElementIndexed(FName InName, int32 InIndex) : UE::Anim::FCurveElement(InName) , Index(InIndex)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (Super::Elements .)",
    "insertText": "Reset()"
  },
  {
    "label": "InitFrom()",
    "kind": "Method",
    "detail": "Function (Filter = nullptr ; Super::bSorted = false ; } template<OtherAllocator,OtherElementType> void)",
    "insertText": "InitFrom(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& InCurveToInitFrom)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_InitFrom)"
  },
  {
    "label": "InvalidateCurveWeight()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InvalidateCurveWeight(FName InName)"
  },
  {
    "label": "IndexOf()",
    "kind": "Method",
    "detail": "Function (const int32 ElementIndex =)",
    "insertText": "IndexOf(InName)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (Super::Elements .)",
    "insertText": "RemoveAt(ElementIndex)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(FName InName, float InValue)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (CurveElement -> Value = InValue ; } else {)",
    "insertText": "Add(InName, InValue)"
  },
  {
    "label": "SetFlags()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetFlags(FName InName, UE::Anim::ECurveElementFlags InFlags)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (CurveElement -> Flags = InFlags ; } else {)",
    "insertText": "Add(InName, InFlags)"
  },
  {
    "label": "Mirror()",
    "kind": "Method",
    "detail": "Function (OutHasElement = true ; return CurveElement -> Value ; } OutHasElement = false ; return InDefaultValue ; } void)",
    "insertText": "Mirror(FName InName0, FName InName1)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (ElementType* CurveElement0 =)",
    "insertText": "Find(InName0)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (ElementType* CurveElement1 =)",
    "insertText": "Find(InName1)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(CurveElement0->Value, CurveElement1->Value)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(CurveElement0->Flags, CurveElement1->Flags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(CurveElement0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CurveElement0 -> Name = InName1 ; Super::bSorted = false ; } else)",
    "insertText": "if(CurveElement1)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_Lerp)"
  },
  {
    "label": "Override()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Override(A)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!FAnimWeight::IsRelevant(FMath::Abs(Alpha - 1.0f)))"
  },
  {
    "label": "Override()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Override(B)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (} else { UE::Anim::)",
    "insertText": "Union(*this, A, B, [&Alpha](ElementType& OutResult, const ElementTypeA& InElement0, const ElementTypeB& InElement1, UE::Anim::ENamedValueUnionFlags InFlags) { OutResult.Value = FMath::Lerp(InElement0.Value, InElement1.Value, Alpha); OutResult.Flags = InElement0.Flags | InElement1.Flags; })"
  },
  {
    "label": "LerpTo()",
    "kind": "Method",
    "detail": "Function (} } template<OtherAllocator,OtherElementType> void)",
    "insertText": "LerpTo(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& Other, float Alpha)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_LerpTo)"
  },
  {
    "label": "Override()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Override(Other)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (} else { UE::Anim::)",
    "insertText": "Union(*this, Other, [&Alpha](ElementType& InOutThisElement, const OtherElementType& InOtherElement, UE::Anim::ENamedValueUnionFlags InFlags) { InOutThisElement.Value = FMath::Lerp(InOutThisElement.Value, InOtherElement.Value, Alpha); InOutThisElement.Flags |= InOtherElement.Flags; })"
  },
  {
    "label": "LerpValid()",
    "kind": "Method",
    "detail": "Function (} } template<AllocatorA,ElementTypeA,AllocatorB,ElementTypeB> void)",
    "insertText": "LerpValid(const TBaseBlendedCurve<AllocatorA, ElementTypeA>& A, const TBaseBlendedCurve<AllocatorB, ElementTypeB>& B, float Alpha)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_LerpValid)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (UE::Anim::)",
    "insertText": "Union(*this, A, B, [&Alpha](UE::Anim::FCurveElement& OutResult, const ElementTypeA& InElement0, const ElementTypeB& InElement1, UE::Anim::ENamedValueUnionFlags InFlags) { if (EnumHasAllFlags(InFlags, UE::Anim::ENamedValueUnionFlags::BothArgsValid)) { OutResult.Value = FMath::Lerp(InElement0.Value, InElement1.Value, Alpha); OutResult.Flags = InElement0.Flags | InElement1.Flags; } else if(EnumHasAllFlags(InFlags, UE::Anim::ENamedValueUnionFlags::ValidArg0)) { OutResult.Value = InElement0.Value; OutResult.Flags = InElement0.Flags; } else if(EnumHasAllFlags(InFlags, UE::Anim::ENamedValueUnionFlags::ValidArg1)) { OutResult.Value = InElement1.Value; OutResult.Flags = InElement1.Flags; } })"
  },
  {
    "label": "LerpToValid()",
    "kind": "Method",
    "detail": "Function (} template<OtherAllocator,OtherElementType> void)",
    "insertText": "LerpToValid(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& Other, float Alpha)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_LerpToValid)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (UE::Anim::)",
    "insertText": "Union(*this, Other, [&Alpha](ElementType& InOutThisElement, const OtherElementType& InOtherElement, UE::Anim::ENamedValueUnionFlags InFlags) { if (EnumHasAllFlags(InFlags, UE::Anim::ENamedValueUnionFlags::BothArgsValid)) { InOutThisElement.Value = FMath::Lerp(InOutThisElement.Value, InOtherElement.Value, Alpha); InOutThisElement.Flags |= InOtherElement.Flags; } else if(EnumHasAllFlags(InFlags, UE::Anim::ENamedValueUnionFlags::ValidArg1)) { InOutThisElement.Value = InOtherElement.Value; InOutThisElement.Flags = InOtherElement.Flags; } })"
  },
  {
    "label": "ConvertToAdditive()",
    "kind": "Method",
    "detail": "Function (} template<OtherAllocator,OtherElementType> void)",
    "insertText": "ConvertToAdditive(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& BaseCurve)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_ConvertToAdditive)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (UE::Anim::)",
    "insertText": "Union(*this, BaseCurve, [](ElementType& InOutThisElement, const OtherElementType& InBaseCurveElement, UE::Anim::ENamedValueUnionFlags InFlags) { InOutThisElement.Value -= InBaseCurveElement.Value; InOutThisElement.Flags |= InBaseCurveElement.Flags; })"
  },
  {
    "label": "Accumulate()",
    "kind": "Method",
    "detail": "Function (} template<OtherAllocator,OtherElementType> void)",
    "insertText": "Accumulate(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& AdditiveCurve, float Weight)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_Accumulate)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (UE::Anim::)",
    "insertText": "Union(*this, AdditiveCurve, [Weight](ElementType& InOutThisElement, const OtherElementType& InAdditiveCurveElement, UE::Anim::ENamedValueUnionFlags InFlags) { InOutThisElement.Value += InAdditiveCurveElement.Value * Weight; InOutThisElement.Flags |= InAdditiveCurveElement.Flags; })"
  },
  {
    "label": "UseMaxValue()",
    "kind": "Method",
    "detail": "Function (} } template<OtherAllocator,OtherElementType> void)",
    "insertText": "UseMaxValue(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& CurveToCombine)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_UseMaxValue)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (UE::Anim::)",
    "insertText": "Union(*this, CurveToCombine, [](ElementType& InOutThisElement, const OtherElementType& InCurveToCombineElement, UE::Anim::ENamedValueUnionFlags InFlags) { if(EnumHasAllFlags(InFlags, UE::Anim::ENamedValueUnionFlags::BothArgsValid)) { InOutThisElement.Value = FMath::Max(InOutThisElement.Value, InCurveToCombineElement.Value); InOutThisElement.Flags |= InCurveToCombineElement.Flags; } else if(EnumHasAllFlags(InFlags, UE::Anim::ENamedValueUnionFlags::ValidArg1)) { InOutThisElement.Value = InCurveToCombineElement.Value; InOutThisElement.Flags = InCurveToCombineElement.Flags; } })"
  },
  {
    "label": "UseMinValue()",
    "kind": "Method",
    "detail": "Function (} template<OtherAllocator,OtherElementType> void)",
    "insertText": "UseMinValue(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& CurveToCombine)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_UseMinValue)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (UE::Anim::)",
    "insertText": "Union(*this, CurveToCombine, [](ElementType& InOutThisElement, const OtherElementType& InCurveToCombineElement, UE::Anim::ENamedValueUnionFlags InFlags) { if(EnumHasAllFlags(InFlags, UE::Anim::ENamedValueUnionFlags::BothArgsValid)) { InOutThisElement.Value = FMath::Min(InOutThisElement.Value, InCurveToCombineElement.Value); InOutThisElement.Flags |= InCurveToCombineElement.Flags; } else if(EnumHasAllFlags(InFlags, UE::Anim::ENamedValueUnionFlags::ValidArg1)) { InOutThisElement.Value = InCurveToCombineElement.Value; InOutThisElement.Flags = InCurveToCombineElement.Flags; } })"
  },
  {
    "label": "CombinePreserved()",
    "kind": "Method",
    "detail": "Function (} template<OtherAllocator,OtherElementType> void)",
    "insertText": "CombinePreserved(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& CurveToCombine)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_CombinePreserved)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (UE::Anim::)",
    "insertText": "Union(*this, CurveToCombine, [](ElementType& InOutThisElement, const OtherElementType& InCurveToCombineElement, UE::Anim::ENamedValueUnionFlags InFlags) { if(!EnumHasAnyFlags(InFlags, UE::Anim::ENamedValueUnionFlags::ValidArg0)) { InOutThisElement.Value = InCurveToCombineElement.Value; InOutThisElement.Flags = InCurveToCombineElement.Flags; } })"
  },
  {
    "label": "Combine()",
    "kind": "Method",
    "detail": "Function (} template<OtherAllocator,OtherElementType> void)",
    "insertText": "Combine(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& CurveToCombine)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_Combine)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (UE::Anim::)",
    "insertText": "Union(*this, CurveToCombine, [](ElementType& InOutThisElement, const OtherElementType& InCurveToCombineElement, UE::Anim::ENamedValueUnionFlags InFlags) { if(EnumHasAnyFlags(InFlags, UE::Anim::ENamedValueUnionFlags::ValidArg1)) { InOutThisElement.Value = InCurveToCombineElement.Value; InOutThisElement.Flags = InCurveToCombineElement.Flags; } })"
  },
  {
    "label": "Override()",
    "kind": "Method",
    "detail": "Function (} template<OtherAllocator,OtherElementType> void)",
    "insertText": "Override(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& CurveToOverrideFrom, float Weight)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_Override_Weighted)"
  },
  {
    "label": "CopyFrom()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyFrom(CurveToOverrideFrom)"
  },
  {
    "label": "Override()",
    "kind": "Method",
    "detail": "Function (Element . Value* = Weight ; } } } public : template<OtherAllocator,OtherElementType> void)",
    "insertText": "Override(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& CurveToOverrideFrom)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_Override)"
  },
  {
    "label": "OverrideMove()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OverrideMove(TBaseBlendedCurve& CurveToOverrideFrom)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Super::Elements =)",
    "insertText": "MoveTemp(CurveToOverrideFrom.Elements)"
  },
  {
    "label": "CopyFrom()",
    "kind": "Method",
    "detail": "Function (} template<OtherAllocator,OtherElementType> void)",
    "insertText": "CopyFrom(const TBaseBlendedCurve<OtherAllocator, OtherElementType>& InCurveToCopyFrom)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_CopyFrom)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (UE::Anim::)",
    "insertText": "Union(*this, InCurveToCopyFrom, [](ElementType& InOutResultElement, const OtherElementType& InParamElement, UE::Anim::ENamedValueUnionFlags InFlags) { InOutResultElement.Value = InParamElement.Value; InOutResultElement.Flags = InParamElement.Flags; })"
  },
  {
    "label": "MoveFrom()",
    "kind": "Method",
    "detail": "Function (Super::bSorted = InCurveToCopyFrom . bSorted ; } } void)",
    "insertText": "MoveFrom(TBaseBlendedCurve& CurveToMoveFrom)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Super::Elements =)",
    "insertText": "MoveTemp(CurveToMoveFrom.Elements)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Super::bSorted = CurveToMoveFrom . bSorted ; CurveToMoveFrom . bSorted = false ; } void)",
    "insertText": "Reserve(int32 InNumElements)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(TBaseBlendedCurve_Reserve)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Super::Elements .)",
    "insertText": "Reserve(InNumElements)"
  },
  {
    "label": "GetFilter()",
    "kind": "Method",
    "detail": "Function (Filter = InFilter ; } const UE::Anim::FCurveFilter*)",
    "insertText": "GetFilter()"
  },
  {
    "label": "InitFrom()",
    "kind": "Method",
    "detail": "Function (} ; struct FBlendedCurve : public TBaseBlendedCurve<FAnimStackAllocator> { using TBaseBlendedCurve<FAnimStackAllocator>::InitFrom ; void)",
    "insertText": "InitFrom(const FBoneContainer& InBoneContainer)"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "UENUM(BlueprintType)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (RCT_Float)",
    "insertText": "UMETA(DisplayName = \"Float Curve\"), RCT_Vector UMETA(DisplayName = \"Vector Curve\", Hidden), RCT_Transform UMETA(DisplayName = \"Transformation Curve\")"
  },
  {
    "label": "EvaluateCurveData()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "EvaluateCurveData(FBlendedCurve& Curves, float CurrentTime)"
  },
  {
    "label": "EvaluateTransformCurveData()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR void)",
    "insertText": "EvaluateTransformCurveData(USkeleton * Skeleton, TMap<FName, FTransform>&OutCurves, float CurrentTime, float BlendWeight)"
  },
  {
    "label": "AddFloatCurveKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddFloatCurveKey(const FName& NewCurve, int32 CurveFlags, float Time, float Value)"
  },
  {
    "label": "AddFloatCurveKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddFloatCurveKey(NewCurve.DisplayName, CurveFlags, Time, Value)"
  },
  {
    "label": "RemoveRedundantKeys()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveRedundantKeys(float Tolerance = UE_SMALL_NUMBER, FFrameRate SampleRate = FFrameRate(0,0))"
  },
  {
    "label": "GetCurveData()",
    "kind": "Method",
    "detail": "Function (const FAnimCurveBase*)",
    "insertText": "GetCurveData(FName Name, ERawCurveTrackTypes SupportedCurveType = ERawCurveTrackTypes::RCT_Float)"
  },
  {
    "label": "AddCurveData()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AddCurveData(const FName& NewCurve, int32 CurveFlags = AACF_DefaultCurve, ERawCurveTrackTypes SupportedCurveType = ERawCurveTrackTypes::RCT_Float)"
  },
  {
    "label": "DeleteCurveData()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "DeleteCurveData(const FName& CurveToDelete, ERawCurveTrackTypes SupportedCurveType = ERawCurveTrackTypes::RCT_Float)"
  },
  {
    "label": "DeleteAllCurveData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DeleteAllCurveData(ERawCurveTrackTypes SupportedCurveType = ERawCurveTrackTypes::RCT_Float)"
  },
  {
    "label": "DuplicateCurveData()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DuplicateCurveData(const FName& CurveToCopy, const FName& NewCurve, ERawCurveTrackTypes SupportedCurveType = ERawCurveTrackTypes::RCT_Float)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Resize(float TotalLength, bool bInsert , float OldStartTime, float OldEndTime)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "GetCurveDataImpl()",
    "kind": "Method",
    "detail": "Function (# endif } private : template<DataType> DataType*)",
    "insertText": "GetCurveDataImpl(TArray<DataType>& Curves, FName Name)"
  },
  {
    "label": "GetCurveDataImpl()",
    "kind": "Method",
    "detail": "Function (template<DataType> const DataType*)",
    "insertText": "GetCurveDataImpl(const TArray<DataType>& Curves, FName Name)"
  },
  {
    "label": "AddCurveDataImpl()",
    "kind": "Method",
    "detail": "Function (template<DataType> bool)",
    "insertText": "AddCurveDataImpl(TArray<DataType>& Curves, const FName& NewCurve, int32 CurveFlags)"
  },
  {
    "label": "DeleteCurveDataImpl()",
    "kind": "Method",
    "detail": "Function (template<DataType> bool)",
    "insertText": "DeleteCurveDataImpl(TArray<DataType>& Curves, const FName& CurveToDelete)"
  },
  {
    "label": "DuplicateCurveDataImpl()",
    "kind": "Method",
    "detail": "Function (template<DataType> bool)",
    "insertText": "DuplicateCurveDataImpl(TArray<DataType>& Curves, const FName& CurveToCopy, const FName& NewCurve)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; FArchive&)",
    "insertText": "operator(FArchive& Ar, FRawCurveTracks& D)"
  }
]