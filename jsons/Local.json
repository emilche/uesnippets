[
  {
    "label": "User",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "User"
  },
  {
    "label": "BasicBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BasicBlock"
  },
  {
    "label": "Function",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Function"
  },
  {
    "label": "BranchInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BranchInst"
  },
  {
    "label": "Instruction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Instruction"
  },
  {
    "label": "DbgDeclareInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DbgDeclareInst"
  },
  {
    "label": "StoreInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StoreInst"
  },
  {
    "label": "LoadInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoadInst"
  },
  {
    "label": "Value",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Value"
  },
  {
    "label": "PHINode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PHINode"
  },
  {
    "label": "AllocaInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AllocaInst"
  },
  {
    "label": "AssumptionCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AssumptionCache"
  },
  {
    "label": "ConstantExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstantExpr"
  },
  {
    "label": "DataLayout",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DataLayout"
  },
  {
    "label": "TargetLibraryInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetLibraryInfo"
  },
  {
    "label": "TargetTransformInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetTransformInfo"
  },
  {
    "label": "DIBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIBuilder"
  },
  {
    "label": "AliasAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AliasAnalysis"
  },
  {
    "label": "DominatorTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DominatorTree"
  },
  {
    "label": "SmallVectorImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallVectorImpl"
  },
  {
    "label": "ConstantFoldTerminator()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_TRANSFORMS_UTILS_LOCAL_H # define LLVM_TRANSFORMS_UTILS_LOCAL_H # include \" llvm / IR / DataLayout . h \" # include \" llvm / IR / Dominators . h \" # include \" llvm / IR / GetElementPtrTypeIterator . h \" # include \" llvm / IR / IRBuilder . h \" # include \" llvm / IR / Operator . h \" namespace llvm { class User ; class BasicBlock ; class Function ; class BranchInst ; class Instruction ; class DbgDeclareInst ; class StoreInst ; class LoadInst ; class Value ; class PHINode ; class AllocaInst ; class AssumptionCache ; class ConstantExpr ; class DataLayout ; class TargetLibraryInfo ; class TargetTransformInfo ; class DIBuilder ; class AliasAnalysis ; class DominatorTree ; template<T> class SmallVectorImpl ; bool)",
    "insertText": "ConstantFoldTerminator(BasicBlock *BB, bool DeleteDeadConditions = false, const TargetLibraryInfo *TLI = nullptr)"
  },
  {
    "label": "isInstructionTriviallyDead()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isInstructionTriviallyDead(Instruction *I, const TargetLibraryInfo *TLI = nullptr)"
  },
  {
    "label": "RecursivelyDeleteTriviallyDeadInstructions()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RecursivelyDeleteTriviallyDeadInstructions(Value *V, const TargetLibraryInfo *TLI = nullptr)"
  },
  {
    "label": "RecursivelyDeleteDeadPHINode()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RecursivelyDeleteDeadPHINode(PHINode *PN, const TargetLibraryInfo *TLI = nullptr)"
  },
  {
    "label": "SimplifyInstructionsInBlock()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SimplifyInstructionsInBlock(BasicBlock *BB, const TargetLibraryInfo *TLI = nullptr)"
  },
  {
    "label": "RemovePredecessorAndSimplify()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemovePredecessorAndSimplify(BasicBlock *BB, BasicBlock *Pred)"
  },
  {
    "label": "MergeBasicBlockIntoOnlyPred()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MergeBasicBlockIntoOnlyPred(BasicBlock *BB, DominatorTree *DT = nullptr)"
  },
  {
    "label": "TryToSimplifyUncondBranchFromEmptyBlock()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryToSimplifyUncondBranchFromEmptyBlock(BasicBlock *BB)"
  },
  {
    "label": "EliminateDuplicatePHINodes()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EliminateDuplicatePHINodes(BasicBlock *BB)"
  },
  {
    "label": "SimplifyCFG()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SimplifyCFG(BasicBlock *BB, const TargetTransformInfo &TTI, unsigned BonusInstThreshold, AssumptionCache *AC = nullptr)"
  },
  {
    "label": "FlattenCFG()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FlattenCFG(BasicBlock *BB, AliasAnalysis *AA = nullptr)"
  },
  {
    "label": "FoldBranchToCommonDest()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FoldBranchToCommonDest(BranchInst *BI, unsigned BonusInstThreshold = 1)"
  },
  {
    "label": "DemoteRegToStack()",
    "kind": "Method",
    "detail": "Function (AllocaInst*)",
    "insertText": "DemoteRegToStack(Instruction &X, bool VolatileLoads = false, Instruction *AllocaPoint = nullptr)"
  },
  {
    "label": "DemotePHIToStack()",
    "kind": "Method",
    "detail": "Function (AllocaInst*)",
    "insertText": "DemotePHIToStack(PHINode *P, Instruction *AllocaPoint = nullptr)"
  },
  {
    "label": "getOrEnforceKnownAlignment()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getOrEnforceKnownAlignment(Value *V, unsigned PrefAlign, const DataLayout &DL, const Instruction *CxtI = nullptr, AssumptionCache *AC = nullptr, const DominatorTree *DT = nullptr)"
  },
  {
    "label": "getKnownAlignment()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getKnownAlignment(Value *V, const DataLayout &DL, const Instruction *CxtI = nullptr, AssumptionCache *AC = nullptr, const DominatorTree *DT = nullptr)"
  },
  {
    "label": "EmitGEPOffset()",
    "kind": "Method",
    "detail": "Function (} template<IRBuilderTy> Value*)",
    "insertText": "EmitGEPOffset(IRBuilderTy *Builder, const DataLayout &DL, User *GEP, bool NoAssumptions = false)"
  },
  {
    "label": "GEPOperator()",
    "kind": "Method",
    "detail": "Function (GEPOperator* GEPOp = cast<)",
    "insertText": "GEPOperator(GEP)"
  },
  {
    "label": "getIntPtrType()",
    "kind": "Method",
    "detail": "Function (Type* IntPtrTy = DL .)",
    "insertText": "getIntPtrType(GEP->getType())"
  },
  {
    "label": "getNullValue()",
    "kind": "Method",
    "detail": "Function (Value* Result =)",
    "insertText": "getNullValue(IntPtrTy)"
  },
  {
    "label": "isInBounds()",
    "kind": "Method",
    "detail": "Function (bool isInBounds = GEPOp ->)",
    "insertText": "isInBounds()"
  },
  {
    "label": "getScalarType()",
    "kind": "Method",
    "detail": "Function (unsigned IntPtrWidth = IntPtrTy ->)",
    "insertText": "getScalarType()->getIntegerBitWidth()"
  },
  {
    "label": "ULL()",
    "kind": "Method",
    "detail": "Function (uint64_t PtrSizeMask = ~ 0)",
    "insertText": "ULL(64 - IntPtrWidth)"
  },
  {
    "label": "gep_type_begin()",
    "kind": "Method",
    "detail": "Function (gep_type_iterator GTI =)",
    "insertText": "gep_type_begin(GEP)"
  },
  {
    "label": "getTypeAllocSize()",
    "kind": "Method",
    "detail": "Function (Value* Op =* i ; uint64_t Size = DL .)",
    "insertText": "getTypeAllocSize(GTI.getIndexedType())"
  },
  {
    "label": "ConstantInt()",
    "kind": "Method",
    "detail": "Function (uint64_t OpValue = cast<)",
    "insertText": "ConstantInt(OpC)->getZExtValue()"
  },
  {
    "label": "getStructLayout()",
    "kind": "Method",
    "detail": "Function (Size = DL .)",
    "insertText": "getStructLayout(STy)->getElementOffset(OpValue)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (continue ; } Constant* Scale =)",
    "insertText": "get(IntPtrTy, Size)"
  },
  {
    "label": "getIntegerCast()",
    "kind": "Method",
    "detail": "Function (Constant* OC =)",
    "insertText": "getIntegerCast(OpC, IntPtrTy, true)"
  },
  {
    "label": "getMul()",
    "kind": "Method",
    "detail": "Function (Scale =)",
    "insertText": "getMul(OC, Scale, isInBounds)"
  },
  {
    "label": "CreateAdd()",
    "kind": "Method",
    "detail": "Function (Result = Builder ->)",
    "insertText": "CreateAdd(Result, Scale, GEP->getName()+\".offs\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(Op->getType() != IntPtrTy) Op = Builder->CreateIntCast(Op, IntPtrTy, true, Op->getName()+\".c\")"
  },
  {
    "label": "CreateMul()",
    "kind": "Method",
    "detail": "Function (Op = Builder ->)",
    "insertText": "CreateMul(Op, ConstantInt::get(IntPtrTy, Size), GEP->getName()+\".idx\", isInBounds)"
  },
  {
    "label": "CreateAdd()",
    "kind": "Method",
    "detail": "Function (} Result = Builder ->)",
    "insertText": "CreateAdd(Op, Result, GEP->getName()+\".offs\")"
  },
  {
    "label": "ConvertDebugDeclareToDebugValue()",
    "kind": "Method",
    "detail": "Function (} return Result ; } bool)",
    "insertText": "ConvertDebugDeclareToDebugValue(DbgDeclareInst *DDI, StoreInst *SI, DIBuilder &Builder)"
  },
  {
    "label": "ConvertDebugDeclareToDebugValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ConvertDebugDeclareToDebugValue(DbgDeclareInst *DDI, LoadInst *LI, DIBuilder &Builder)"
  },
  {
    "label": "LowerDbgDeclare()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "LowerDbgDeclare(Function &F)"
  },
  {
    "label": "FindAllocaDbgDeclare()",
    "kind": "Method",
    "detail": "Function (DbgDeclareInst*)",
    "insertText": "FindAllocaDbgDeclare(Value *V)"
  },
  {
    "label": "FindAllocaDbgDeclare()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindAllocaDbgDeclare(Value *V, SmallVectorImpl<DbgDeclareInst *> &Declares)"
  },
  {
    "label": "replaceDbgDeclareForAlloca()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "replaceDbgDeclareForAlloca(AllocaInst *AI, Value *NewAllocaAddress, DIBuilder &Builder, bool Deref)"
  },
  {
    "label": "removeUnreachableBlocks()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "removeUnreachableBlocks(Function &F)"
  },
  {
    "label": "combineMetadata()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "combineMetadata(Instruction *K, const Instruction *J, ArrayRef<unsigned> KnownIDs)"
  },
  {
    "label": "replaceDominatedUsesWith()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "replaceDominatedUsesWith(Value *From, Value *To, DominatorTree &DT, const BasicBlockEdge &Edge)"
  }
]