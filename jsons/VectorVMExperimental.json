[
  {
    "label": "FDataSetMeta",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDataSetMeta"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "EVectorVMFlags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EVectorVMFlags"
  },
  {
    "label": "FVectorVMOptimizeContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVectorVMOptimizeContext"
  },
  {
    "label": "FVectorVMExtFunctionData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVectorVMExtFunctionData"
  },
  {
    "label": "FVectorVMOptimizeInstruction",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVectorVMOptimizeInstruction"
  },
  {
    "label": "EVectorVMOptimizeError",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EVectorVMOptimizeError"
  },
  {
    "label": "EVectorVMStateError",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EVectorVMStateError"
  },
  {
    "label": "FVectorVMBatchState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVectorVMBatchState"
  },
  {
    "label": "FVectorVMState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVectorVMState"
  },
  {
    "label": "FVectorVMExecContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVectorVMExecContext"
  },
  {
    "label": "FVectorVMExternalFunctionContextExperimental",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVectorVMExternalFunctionContextExperimental"
  },
  {
    "label": "VVM_OP_CAT_XM()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" VectorVMSerialization . h \" # include \" VectorVMCommon . h \" # include \" Math / RandomStream . h \" # if VECTORVM_SUPPORTS_EXPERIMENTAL # define VECTORVM_SUPPORTS_COMPUTED_GOTO 0 struct FDataSetMeta ; # define VVM_INS_PARAM_FFFFFF 0 b000000 # define VVM_INS_PARAM_FFFFFI 0 b000001 # define VVM_INS_PARAM_FFFFIF 0 b000010 # define VVM_INS_PARAM_FFFFII 0 b000011 # define VVM_INS_PARAM_FFFIFF 0 b000100 # define VVM_INS_PARAM_FFFIFI 0 b000101 # define VVM_INS_PARAM_FFFIIF 0 b000110 # define VVM_INS_PARAM_FFFIII 0 b000111 # define VVM_INS_PARAM_FFIFFF 0 b001000 # define VVM_INS_PARAM_FFIFFI 0 b001001 # define VVM_INS_PARAM_FFIFIF 0 b001010 # define VVM_INS_PARAM_FFIFII 0 b001011 # define VVM_INS_PARAM_FFIIFF 0 b001100 # define VVM_INS_PARAM_FFIIFI 0 b001101 # define VVM_INS_PARAM_FFIIIF 0 b001110 # define VVM_INS_PARAM_FFIIII 0 b001111 # define VVM_INS_PARAM_FIFFFF 0 b010000 # define VVM_INS_PARAM_FIFFFI 0 b010001 # define VVM_INS_PARAM_FIFFIF 0 b010010 # define VVM_INS_PARAM_FIFFII 0 b010011 # define VVM_INS_PARAM_FIFIFF 0 b010100 # define VVM_INS_PARAM_FIFIFI 0 b010101 # define VVM_INS_PARAM_FIFIIF 0 b010110 # define VVM_INS_PARAM_FIFIII 0 b010111 # define VVM_INS_PARAM_FIIFFF 0 b011000 # define VVM_INS_PARAM_FIIFFI 0 b011001 # define VVM_INS_PARAM_FIIFIF 0 b011010 # define VVM_INS_PARAM_FIIFII 0 b011011 # define VVM_INS_PARAM_FIIIFF 0 b011100 # define VVM_INS_PARAM_FIIIFI 0 b011101 # define VVM_INS_PARAM_FIIIIF 0 b011110 # define VVM_INS_PARAM_FIIIII 0 b011111 # define VVM_INS_PARAM_IFFFFF 0 b100000 # define VVM_INS_PARAM_IFFFFI 0 b100001 # define VVM_INS_PARAM_IFFFIF 0 b100010 # define VVM_INS_PARAM_IFFFII 0 b100011 # define VVM_INS_PARAM_IFFIFF 0 b100100 # define VVM_INS_PARAM_IFFIFI 0 b100101 # define VVM_INS_PARAM_IFFIIF 0 b100110 # define VVM_INS_PARAM_IFFIII 0 b100111 # define VVM_INS_PARAM_IFIFFF 0 b101000 # define VVM_INS_PARAM_IFIFFI 0 b101001 # define VVM_INS_PARAM_IFIFIF 0 b101010 # define VVM_INS_PARAM_IFIFII 0 b101011 # define VVM_INS_PARAM_IFIIFF 0 b101100 # define VVM_INS_PARAM_IFIIFI 0 b101101 # define VVM_INS_PARAM_IFIIIF 0 b101110 # define VVM_INS_PARAM_IFIIII 0 b101111 # define VVM_INS_PARAM_IIFFFF 0 b110000 # define VVM_INS_PARAM_IIFFFI 0 b110001 # define VVM_INS_PARAM_IIFFIF 0 b110010 # define VVM_INS_PARAM_IIFFII 0 b110011 # define VVM_INS_PARAM_IIFIFF 0 b110100 # define VVM_INS_PARAM_IIFIFI 0 b110101 # define VVM_INS_PARAM_IIFIIF 0 b110110 # define VVM_INS_PARAM_IIFIII 0 b110111 # define VVM_INS_PARAM_IIIFFF 0 b111000 # define VVM_INS_PARAM_IIIFFI 0 b111001 # define VVM_INS_PARAM_IIIFIF 0 b111010 # define VVM_INS_PARAM_IIIFII 0 b111011 # define VVM_INS_PARAM_IIIIFF 0 b111100 # define VVM_INS_PARAM_IIIIFI 0 b111101 # define VVM_INS_PARAM_IIIIIF 0 b111110 # define VVM_INS_PARAM_IIIIII 0 b111111 # define VVM_OP_CAT_XM_LIST \\)",
    "insertText": "VVM_OP_CAT_XM(Input) \\ VVM_OP_CAT_XM(Output) \\ VVM_OP_CAT_XM(Op) \\ VVM_OP_CAT_XM(ExtFnCall) \\ VVM_OP_CAT_XM(IndexGen) \\ VVM_OP_CAT_XM(RWBuffer) \\ VVM_OP_CAT_XM(Stat) \\ VVM_OP_CAT_XM(Other) #define VVM_OP_CAT_XM(Category, ...)"
  },
  {
    "label": "VVM_OP_XM()",
    "kind": "Method",
    "detail": "Function (VVM_OP_CAT_XM_LIST MAX } ; # undef VVM_OP_CAT_XM const EVectorVMOpCategory VVM_OP_CATEGORIES [ ] = { # define)",
    "insertText": "VVM_OP_XM(op, cat, ...)"
  },
  {
    "label": "VVM_MIN()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "VVM_MIN(a, b) ((a) < (b) ? (a) : (b)) #define VVM_MAX(a, b) ((a) > (b) ? (a) : (b)) #define VVM_CLAMP(v, min, max) ((v) < (min) ? (min) : ((v) < (max) ? (v) : (max))) #define VVM_ALIGN(num, alignment) (((size_t)(num) + (alignment) - 1) & ~((alignment) - 1)) #define VVM_ALIGN_4(num) (((size_t)(num) + 3) & ~3) #define VVM_ALIGN_8(num) (((size_t)(num) + 7) & ~7) #define VVM_ALIGN_16(num) (((size_t)(num) + 15) & ~15) #define VVM_ALIGN_32(num) (((size_t)(num) + 31) & ~31) #define VVM_ALIGN_64(num) (((size_t)(num) + 63) & ~63) #define VVM_PTR_ALIGN VVM_ALIGN_16 #define VVM_REG_SIZE sizeof(FVecReg)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (VVM_RT_TEMPREG,VVM_RT_CONST,VVM_RT_INPUT,VVM_RT_OUTPUT,VVM_RT_INVALID } ; enum EVectorVMFlags { VVMFlag_OptSaveIntermediateState = 1<<0,VVMFlag_OptOmitStats = 1<<1,VVMFlag_LargeScript = 1<<2,VVMFlag_HasRandInstruction = 1<<3,VVMFlag_DataMapCacheSetup = 1<<4,} ; typedef)",
    "insertText": "uint32(VectorVMOptimizeErrorCallback) (struct FVectorVMOptimizeContext *OptimizeContext, uint32 ErrorFlags)"
  },
  {
    "label": "MS_ALIGN()",
    "kind": "Method",
    "detail": "Function (union FVecReg { VectorRegister4f v ; VectorRegister4i i ; } ; struct FVectorVMExtFunctionData { const FVMExternalFunction* Function ; int32 NumInputs ; int32 NumOutputs ; } ; struct FVectorVMOptimizeInstruction { EVectorVMOp OpCode ; EVectorVMOpCategory OpCat ; uint32 PtrOffsetInOrigBytecode ; uint32 PtrOffsetInOptimizedBytecode ; int Index ; int InsMergedIdx ; int OutputMergeIdx [ 2 ] ; uint16 RegPtrOffset ; int NumInputRegisters ; int NumOutputRegisters ; union { struct { uint16 DataSetIdx ; uint16 InputIdx ; } Input ; struct { uint16 DataSetIdx ; uint16 DstRegIdx ; int MergeIdx ; uint16 SerialIdx ; } Output ; struct { } Op ; struct { uint16 DataSetIdx ; } IndexGen ; struct { uint16 ExtFnIdx ; uint16 NumInputs ; uint16 NumOutputs ; } ExtFnCall ; struct { uint16 DataSetIdx ; } RWBuffer ; struct { uint16 ID ; } Stat ; struct { } Other ; } ; } ; enum EVectorVMOptimizeError { VVMOptErr_OutOfMemory = 1<<0,VVMOptErr_Overflow = 1<<1,VVMOptErr_Bytecode = 1<<2,VVMOptErr_RegisterUsage = 1<<3,VVMOptErr_ConstRemap = 1<<4,VVMOptErr_Instructions = 1<<5,VVMOptErr_InputMergeBuffer = 1<<6,VVMOptErr_InstructionReOrder = 1<<7,VVMOptErr_SSARemap = 1<<8,VVMOptErr_OptimizedBytecode = 1<<9,VVMOptErr_ExternalFunction = 1<<1 0,VVMOptErr_RedundantInstruction = 1<<1 1,VVMOptErr_Fatal = 1<<3 1 } ; struct FVectorVMOptimizeContext { uint8* OutputBytecode ; uint16* ConstRemap [ 2 ] ; uint16* InputRemapTable ; uint16* InputDataSetOffsets ; uint8* OutputRemapDataSetIdx ; uint16* OutputRemapDataType ; uint16* OutputRemapDst ; FVectorVMExtFunctionData* ExtFnTable ; uint32 NumBytecodeBytes ; uint32 MaxOutputDataSet ; uint16 NumConstsAlloced ; uint32 NumTempRegisters ; uint16 NumConstsRemapped ; uint16 NumInputsRemapped ; uint16 NumNoAdvanceInputs ; uint16 NumInputDataSets ; uint16 NumOutputsRemapped ; uint16 NumOutputInstructions ; uint32 NumExtFns ; uint32 MaxExtFnRegisters ; uint32 NumDummyRegsReq ; int32 MaxExtFnUsed ; uint32 Flags ; uint64 HashId ; # if WITH_EDITORONLY_DATA struct { VectorVMReallocFn* ReallocFn ; VectorVMFreeFn* FreeFn ; const char* ScriptName ; } Init ; struct { uint32 Flags ; uint32 Line ; VectorVMOptimizeErrorCallback* CallbackFn ; } Error ; struct { FVectorVMOptimizeInstruction* Instructions ; uint8* RegisterUsageType ; uint16* RegisterUsageBuffer ; uint16* SSARegisterUsageBuffer ; uint16* ParentInstructionIdx ; uint32 NumInstructions ; uint32 NumInstructionsAlloced ; uint32 NumRegistersUsed ; } Intermediate ; # endif } ; enum EVectorVMStateError { VVMErr_InitOutOfMemory = 1<<0,VVMErr_InitMemMismatch = 1<<1,VVMErr_BatchMemory = 1<<2,VVMErr_AssignInstances = 1<<3,VVMErr_Fatal = 1<<3 1 } ; struct FVectorVMBatchState {)",
    "insertText": "MS_ALIGN(16) FVecReg * RegisterData GCC_ALIGN(16)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (struct { uint32* StartingOutputIdxPerDataSet ; uint32* NumOutputPerDataSet ; uint8** OutputMaskIdx ; struct { uint32** RegData ; uint8* RegInc ; FVecReg* DummyRegs ; } ExtFnDecodedReg ; int32* RandCounters ; int ChunkIdx ; int StartInstanceThisChunk ; int NumInstancesThisChunk ; } ChunkLocalData ; uint8** RegPtrTable ; uint8* RegIncTable ; uint8* OutputMaskIdx ; union { struct { VectorRegister4i State [ 5 ] ; VectorRegister4i Counters ; } ; } RandState ; FRandomStream RandStream ; } ;)",
    "insertText": "static_assert((sizeof(FVectorVMBatchState) & 0xF) == 0, \"FVectorVMBatchState must be 16 byte aligned\")"
  },
  {
    "label": "MS_ALIGN()",
    "kind": "Method",
    "detail": "Function (struct FVectorVMState { uint8* Bytecode ; uint32 NumBytecodeBytes ; FVecReg* ConstantBuffers ; FVectorVMExtFunctionData* ExtFunctionTable ; int32* NumOutputPerDataSet ; uint16* ConstRemapTable ; uint16* InputRemapTable ; uint16* InputDataSetOffsets ; uint8* OutputRemapDataSetIdx ; uint16* OutputRemapDataType ; uint16* OutputRemapDst ; uint8* ConstMapCacheIdx ; uint16* ConstMapCacheSrc ; uint8* InputMapCacheIdx ; uint16* InputMapCacheSrc ; int32 NumInstancesExecCached ; uint32 Flags ; uint32 NumExtFunctions ; uint32 MaxExtFnRegisters ; uint32 NumTempRegisters ; uint32 NumConstBuffers ; uint32 NumInputBuffers ; uint32 NumInputDataSets ; uint32 NumOutputsRemapped ; uint32 NumOutputBuffers ; uint32 MaxOutputDataSet ; uint32 NumDummyRegsRequired ; uint32 BatchOverheadSize ; uint32 ChunkLocalDataOutputIdxNumBytes ; uint32 ChunkLocalNumOutputNumBytes ; uint32 ChunkLocalOutputMaskIdxNumBytes ; uint64 OptimizerHashId ; uint32 TotalNumBytes ; struct { uint32 NumBytesRequiredPerBatch ; uint32 PerBatchRegisterDataBytesRequired ; uint32 MaxChunksPerBatch ; uint32 MaxInstancesPerChunk ; } ExecCtxCache ; } ; struct FVectorVMExecContext { struct { uint32 NumBytesRequiredPerBatch ; uint32 PerBatchRegisterDataBytesRequired ; uint32 MaxChunksPerBatch ; uint32 MaxInstancesPerChunk ; } Internal ; FVectorVMState* VVMState ; TArrayView<FDataSetMeta> DataSets ; TArrayView<const FVMExternalFunction*> ExtFunctionTable ; TArrayView<void*> UserPtrTable ; int32 NumInstances ; const uint8* const* ConstantTableData ; const int* ConstantTableNumBytes ; int32 ConstantTableCount ; } ; class FVectorVMExternalFunctionContextExperimental { public :)",
    "insertText": "MS_ALIGN(32) uint32** RegisterData GCC_ALIGN(32)"
  },
  {
    "label": "GetStartInstance()",
    "kind": "Method",
    "detail": "Function (uint8* RegInc ; int RegReadCount ; int NumRegisters ; int StartInstance ; int NumInstances ; int NumLoops ; int PerInstanceFnInstanceIdx ; void** UserPtrTable ; int NumUserPtrs ; FRandomStream* RandStream ; int32** RandCounters ; TArrayView<FDataSetMeta> DataSets ; int32)",
    "insertText": "GetStartInstance()"
  },
  {
    "label": "RandCounters()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "RandCounters(int *)FMemory::MallocZeroed(sizeof(int32) * NumInstances)"
  },
  {
    "label": "GetRandStream()",
    "kind": "Method",
    "detail": "Function (} return* RandCounters ; } FRandomStream&)",
    "insertText": "GetRandStream()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (* OutAdvanceOffset = RegInc [ RegReadCount ] ;)",
    "insertText": "return(float*)"
  },
  {
    "label": "AllocVectorVMState()",
    "kind": "Method",
    "detail": "Function (} } ; FVectorVMState*)",
    "insertText": "AllocVectorVMState(FVectorVMOptimizeContext *OptimizeCtx)"
  },
  {
    "label": "FreeVectorVMState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVectorVMState(FVectorVMState *VectorVMState)"
  },
  {
    "label": "ExecVectorVMState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExecVectorVMState(FVectorVMExecContext *ExecCtx, FVectorVMSerializeState *SerializeState, FVectorVMSerializeState *CmpSerializeState)"
  },
  {
    "label": "OptimizeVectorVMScript()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITORONLY_DATA uint32)",
    "insertText": "OptimizeVectorVMScript(const uint8 *Bytecode, int BytecodeLen, FVectorVMExtFunctionData *ExtFnIOData, int NumExtFns, FVectorVMOptimizeContext *OptContext, uint64 HashId, uint32 Flags)"
  },
  {
    "label": "FreeVectorVMOptimizeContext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVectorVMOptimizeContext(FVectorVMOptimizeContext *Context)"
  },
  {
    "label": "FreezeVectorVMOptimizeContext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreezeVectorVMOptimizeContext(const FVectorVMOptimizeContext& Context, TArray<uint8>& ContextData)"
  },
  {
    "label": "GenerateHumanReadableVectorVMScript()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GenerateHumanReadableVectorVMScript(const FVectorVMOptimizeContext& Context, FString& VMScript)"
  },
  {
    "label": "ReinterpretVectorVMOptimizeContextData()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "ReinterpretVectorVMOptimizeContextData(TConstArrayView<uint8> ContextData, FVectorVMOptimizeContext& Context)"
  },
  {
    "label": "SerializeVectorVMInputDataSets()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "SerializeVectorVMInputDataSets(FVectorVMSerializeState *SerializeState, FVectorVMExecContext *ExecContext)"
  },
  {
    "label": "SerializeVectorVMOutputDataSets()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "SerializeVectorVMOutputDataSets(FVectorVMSerializeState *SerializeState, FVectorVMExecContext *ExecContext)"
  },
  {
    "label": "SerializeVectorVMWriteToFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SerializeVectorVMWriteToFile(FVectorVMSerializeState *SerializeState, uint8 WhichStateWritten, const wchar_t *Filename)"
  },
  {
    "label": "FreeVectorVMSerializeState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVectorVMSerializeState(FVectorVMSerializeState *SerializeState)"
  },
  {
    "label": "VVMDbgGetRemappedInputIdx()",
    "kind": "Method",
    "detail": "Function (uint16)",
    "insertText": "VVMDbgGetRemappedInputIdx(FVectorVMState *VectorVMState, int InputRegisterIdx, int DataSetIdx, bool IntReg, uint16 *OptOutIdxInRegTable)"
  },
  {
    "label": "VVMDbgGetRemappedOutputIdx()",
    "kind": "Method",
    "detail": "Function (uint16)",
    "insertText": "VVMDbgGetRemappedOutputIdx(FVectorVMState *VectorVMState, int OutputRegisterIdx, int DataSetIdx, bool IntReg, uint16 *OptOutIdxInRegTable)"
  },
  {
    "label": "VVMDbgGetRemappedConstIdx()",
    "kind": "Method",
    "detail": "Function (uint16)",
    "insertText": "VVMDbgGetRemappedConstIdx(FVectorVMState *VectorVMState, int ConstTableIdx, int ConstBuffIdx, uint16 *OptOutIdxInRegTable)"
  },
  {
    "label": "SerializeVectorVMInputDataSets()",
    "kind": "Method",
    "detail": "Function (# endif # if VECTORVM_SUPPORTS_LEGACY uint32)",
    "insertText": "SerializeVectorVMInputDataSets(FVectorVMSerializeState *SerializeState, TArrayView<FDataSetMeta>, const uint8 * const *ConstantTableData, const int *ConstantTableSizes, int32 ConstantTableCount)"
  },
  {
    "label": "SerializeVectorVMOutputDataSets()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "SerializeVectorVMOutputDataSets(FVectorVMSerializeState *SerializeState, TArrayView<FDataSetMeta>, const uint8 * const *ConstantTableData, const int *ConstantTableSizes, int32 ConstantTableCount)"
  }
]