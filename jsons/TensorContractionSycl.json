[
  {
    "label": "TVPanelSize",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TVPanelSize"
  },
  {
    "label": "TTPanelSize",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TTPanelSize"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "BlockProperties",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BlockProperties"
  },
  {
    "label": "ThreadProperties",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ThreadProperties"
  },
  {
    "label": "TensorContractionKernel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TensorContractionKernel"
  },
  {
    "label": "MemHolder",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MemHolder"
  },
  {
    "label": "TiledMemory",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TiledMemory"
  },
  {
    "label": "GeneralVectorTensor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GeneralVectorTensor"
  },
  {
    "label": "GeneralScalarContraction",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GeneralScalarContraction"
  },
  {
    "label": "TensorEvaluator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TensorEvaluator"
  },
  {
    "label": "TripleDim",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TripleDim"
  },
  {
    "label": "input_mapper_propertis",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "input_mapper_propertis"
  },
  {
    "label": "LoadPerThreadLhs()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_CXX11_TENSOR_TENSOR_CONTRACTION_SYCL_H # define EIGEN_CXX11_TENSOR_TENSOR_CONTRACTION_SYCL_H namespace Eigen { namespace TensorSycl { namespace internal { # ifndef EIGEN_SYCL_DISABLE_GEMV template<Scalar,StorageIndex,StorageIndex NCWindow,StorageIndex CFactor,StorageIndex NCFactor> struct TVPanelSize { EIGEN_CONSTEXPR StorageIndex LocalThreadSizeC = EIGEN_SYCL_LOCAL_THREAD_DIM0 ; EIGEN_CONSTEXPR StorageIndex LocalThreadSizeNC = EIGEN_SYCL_LOCAL_THREAD_DIM1 ; EIGEN_CONSTEXPR StorageIndex TileSizeDimNC = NCWindow / NCFactor ; EIGEN_CONSTEXPR StorageIndex TileSizeDimC = CFactor* LocalThreadSizeNC* LocalThreadSizeC ; EIGEN_CONSTEXPR StorageIndex WorkLoadPerThreadNC = TileSizeDimNC / LocalThreadSizeNC ; EIGEN_CONSTEXPR StorageIndex WorkLoadPerThreadC = TileSizeDimC / LocalThreadSizeC ; EIGEN_CONSTEXPR bool BC = false ; } ; # endif template<Scalar,StorageIndex,StorageIndex REG_SIZE_M,StorageIndex REG_SIZE_N,StorageIndex TSDK> struct TTPanelSize { EIGEN_CONSTEXPR StorageIndex TileSizeDimK = TSDK ; # ifndef EIGEN_SYCL_REG_M EIGEN_CONSTEXPR StorageIndex WorkLoadPerThreadM = REG_SIZE_M ; # else EIGEN_CONSTEXPR StorageIndex WorkLoadPerThreadM = EIGEN_SYCL_REG_M ; # endif # ifndef EIGEN_SYCL_REG_N EIGEN_CONSTEXPR StorageIndex WorkLoadPerThreadN = REG_SIZE_N ; # else EIGEN_CONSTEXPR StorageIndex WorkLoadPerThreadN = EIGEN_SYCL_REG_N ; # endif EIGEN_CONSTEXPR StorageIndex LocalThreadSizeM = EIGEN_SYCL_LOCAL_THREAD_DIM0 ; EIGEN_CONSTEXPR StorageIndex LocalThreadSizeN = EIGEN_SYCL_LOCAL_THREAD_DIM1 ; EIGEN_CONSTEXPR StorageIndex TileSizeDimM = LocalThreadSizeM* WorkLoadPerThreadM ; EIGEN_CONSTEXPR StorageIndex TileSizeDimN = LocalThreadSizeN* WorkLoadPerThreadN ; EIGEN_CONSTEXPR StorageIndex)",
    "insertText": "LoadPerThreadLhs((TileSizeDimK * WorkLoadPerThreadM * WorkLoadPerThreadN) / (TileSizeDimN))"
  },
  {
    "label": "LoadPerThreadRhs()",
    "kind": "Method",
    "detail": "Function (EIGEN_CONSTEXPR StorageIndex)",
    "insertText": "LoadPerThreadRhs((TileSizeDimK * WorkLoadPerThreadM * WorkLoadPerThreadN) / (TileSizeDimM))"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (EIGEN_CONSTEXPR bool BC = true ; EIGEN_CONSTEXPR bool DoubleBuffer = # ifdef EIGEN_SYCL_DISABLE_DOUBLE_BUFFER false ; # else true ; # endif } ; enum class contraction_type { local,no_local } ; enum class data_source { global_mem,local_mem,private_mem } ; template<bool PacketLoad,bool is_coalesced_layout,bool,PacketType,TensorMapper,StorageIndex> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE::Eigen::internal::enable_if<PacketLoad,PacketType>::type)",
    "insertText": "read(const TensorMapper &tensorMapper, const StorageIndex &NCIndex, const StorageIndex &CIndex, const StorageIndex &ld)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (const StorageIndex)",
    "insertText": "row(is_coalesced_layout)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (const StorageIndex)",
    "insertText": "col(is_coalesced_layout)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} template<bool PacketLoad,bool,bool IsRhs,PacketType,TensorMapper,StorageIndex> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE::Eigen::internal::enable_if<! PacketLoad,PacketType>::type)",
    "insertText": "read(const TensorMapper &tensorMapper, const StorageIndex &NCIndex, const StorageIndex &CIndex, const StorageIndex &)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (const StorageIndex)",
    "insertText": "row(IsRhs)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (const StorageIndex)",
    "insertText": "col(IsRhs)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (} template<StorageIndex,StorageIndex ld,data_source dt,PacketType,DataScalar> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE::Eigen::internal::enable_if<dt ! = data_source::global_mem,void>::type)",
    "insertText": "write(PacketType &packet_data, DataScalar ptr)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (EIGEN_CONSTEXPR int PacketSize = Eigen::internal::unpacket_traits<PacketType>::size ; EIGEN_UNROLL_LOOP)",
    "insertText": "for(int i = 0; i < PacketSize; i++)"
  },
  {
    "label": "scalarize()",
    "kind": "Method",
    "detail": "Function (* ptr = PacketWrapper<PacketType,PacketSize)",
    "insertText": "scalarize(i, packet_data)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (ptr + = ld ; } } template<data_source dt,PacketType,DataScalar> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE::Eigen::internal::enable_if<Eigen::internal::unpacket_traits<PacketType>::size ! = 1&& dt = = data_source::global_mem,void>::type)",
    "insertText": "write(PacketType &packet_data, DataScalar *ptr)"
  },
  {
    "label": "PacketType()",
    "kind": "Method",
    "detail": "Function (::Eigen::internal::pstoreu<DataScalar,)",
    "insertText": "PacketType(ptr, packet_data)"
  },
  {
    "label": "check_boundary()",
    "kind": "Method",
    "detail": "Function (* ptr = packet_data ; } template<bool is_internal> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool)",
    "insertText": "check_boundary(bool)"
  },
  {
    "label": "nc_stride()",
    "kind": "Method",
    "detail": "Function (EIGEN_CONSTEXPR int)",
    "insertText": "nc_stride(is_coalesced_layout ? elements_per_access : 1)"
  },
  {
    "label": "c_stride()",
    "kind": "Method",
    "detail": "Function (EIGEN_CONSTEXPR int)",
    "insertText": "c_stride(is_coalesced_layout ? 1 : elements_per_access)"
  },
  {
    "label": "ThreadProperties()",
    "kind": "Method",
    "detail": "Function (} ; template<StorageIndex> struct ThreadProperties { const StorageIndex linearLocalThreadId ; const StorageIndex kGroupId ; const StorageIndex mGroupOffset ; const StorageIndex nGroupOffset ; const StorageIndex kGroupOffset ; const StorageIndex mLocalOffset ; const StorageIndex nLocalOffset ; const StorageIndex mGlobalOffset ; const StorageIndex nGlobalOffset ; StorageIndex kSize ; const bool is_internal ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "ThreadProperties(const StorageIndex linearLocalThreadId_, const StorageIndex kGroupId_, const StorageIndex mGroupOffset_, const StorageIndex nGroupOffset_, const StorageIndex kGroupOffset_, const StorageIndex mLocalOffset_, const StorageIndex nLocalOffset_, const StorageIndex mGlobalOffset_, const StorageIndex nGlobalOffset_, StorageIndex kSize_, const bool is_internal_) : linearLocalThreadId(linearLocalThreadId_), kGroupId(kGroupId_), mGroupOffset(mGroupOffset_), nGroupOffset(nGroupOffset_), kGroupOffset(kGroupOffset_), mLocalOffset(mLocalOffset_), nLocalOffset(nLocalOffset_), mGlobalOffset(mGlobalOffset_), nGlobalOffset(nGlobalOffset_), kSize(kSize_), is_internal(is_internal_)"
  },
  {
    "label": "MemHolder()",
    "kind": "Method",
    "detail": "Function (} } ; template<OutScalar,LhsScalar,RhsScalar,OutAccessor,LhsMapper,RhsMapper,StorageIndex,Properties,TripleDim,bool Vectorizable,input_mapper_properties,bool IsFinal,contraction_type contraction_tp> class TensorContractionKernel { public : typedef Eigen::TensorSycl::internal::Vectorise<OutScalar,Eigen::SyclDevice,Vectorizable>::PacketReturnType PacketReturnType ; EIGEN_CONSTEXPR int PacketSize = Eigen::TensorSycl::internal::Vectorise<OutScalar,Eigen::SyclDevice,Vectorizable>::PacketSize ; EIGEN_CONSTEXPR bool is_lhs_transposed = !::Eigen::internal::TensorContractionInputMapperTrait<LhsMapper>::inner_dim_contiguous ; EIGEN_CONSTEXPR bool is_rhs_transposed = !::Eigen::internal::TensorContractionInputMapperTrait<RhsMapper>::inner_dim_contiguous ; typedef BlockProperties<is_lhs_transposed,false,input_mapper_properties::is_lhs_matrix&& Vectorizable,PacketReturnType> LHSBlockProperties ; typedef BlockProperties<is_rhs_transposed,true,input_mapper_properties::is_rhs_matrix&& Vectorizable,PacketReturnType> RHSBlockProperties ; EIGEN_CONSTEXPR StorageIndex NStride = contraction_tp = = contraction_type::local ? Properties::WorkLoadPerThreadN : RHSBlockProperties::nc_stride ; typedef cl::sycl::accessor<OutScalar,1,cl::sycl::access::mode::read_write,cl::sycl::access::target::local> Scratch ; typedef cl::sycl::multi_ptr<OutScalar,cl::sycl::access::address_space::local_space> local_ptr ; typedef OutScalar* private_ptr ; typedef::Eigen::internal::conditional<contraction_tp = = contraction_type::local,local_ptr,private_ptr>::type tile_ptr ; EIGEN_CONSTEXPR StorageIndex LSDL = contraction_tp = = contraction_type::local ? Properties::TileSizeDimM + Properties::BC : Properties::WorkLoadPerThreadM ; EIGEN_CONSTEXPR StorageIndex LSDR = contraction_tp = = contraction_type::local ? Properties::TileSizeDimN + Properties::BC : Properties::WorkLoadPerThreadN ; EIGEN_CONSTEXPR StorageIndex LocalOffset = Properties::LocalThreadSizeM* Properties::LocalThreadSizeN ; template<contraction_type,StorageIndex> struct MemHolder { tile_ptr ptr ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "MemHolder(local_ptr block_start_ptr) : ptr(block_start_ptr)"
  },
  {
    "label": "TiledMemory()",
    "kind": "Method",
    "detail": "Function (} } ; template<StorageIndex MemSize> struct MemHolder<contraction_type::no_local,MemSize> { OutScalar ptr [ MemSize ] = { OutScalar { 0 } } ; } ; struct TiledMemory { MemHolder<contraction_tp,Properties::WorkLoadPerThreadM* Properties::TileSizeDimK> lhs_scratch_extract ; MemHolder<contraction_tp,Properties::WorkLoadPerThreadN* Properties::TileSizeDimK> rhs_scratch_extract ; tile_ptr lhs_scratch_ptr_compute ; tile_ptr rhs_scratch_ptr_compute ; const std::pair<StorageIndex,StorageIndex> lhs_extract_index ; const std::pair<StorageIndex,StorageIndex> rhs_extract_index ; template<contraction_type tp = contraction_tp> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "TiledMemory(const ThreadProperties<StorageIndex> &, local_ptr, typename ::Eigen::internal::enable_if<tp == contraction_type::no_local>::type * = 0)"
  },
  {
    "label": "lhs_scratch_ptr_compute()",
    "kind": "Method",
    "detail": "Function (},rhs_scratch_extract { },)",
    "insertText": "lhs_scratch_ptr_compute(lhs_scratch_extract.ptr), rhs_scratch_ptr_compute(rhs_scratch_extract.ptr), lhs_extract_index(std::pair<StorageIndex, StorageIndex>(StorageIndex{0}, StorageIndex{0})), rhs_extract_index(std::pair<StorageIndex, StorageIndex>(StorageIndex{0}, StorageIndex{0}))"
  },
  {
    "label": "TiledMemory()",
    "kind": "Method",
    "detail": "Function (} template<contraction_type tp = contraction_tp> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "TiledMemory(const ThreadProperties<StorageIndex> &thread_properties, local_ptr block_start_ptr, typename ::Eigen::internal::enable_if<tp == contraction_type::local>::type * = 0)"
  },
  {
    "label": "ptr()",
    "kind": "Method",
    "detail": "Function (block_start_ptr },rhs_scratch_extract { lhs_scratch_extract .)",
    "insertText": "ptr((Properties::DoubleBuffer + 1) * LSDL * Properties::TileSizeDimK)}, lhs_scratch_ptr_compute(lhs_scratch_extract.ptr + thread_properties.mLocalOffset), rhs_scratch_ptr_compute(rhs_scratch_extract.ptr + thread_properties.nLocalOffset), lhs_extract_index( local_id_extract<LHSBlockProperties, Properties::TileSizeDimM>(thread_properties.linearLocalThreadId)), rhs_extract_index( local_id_extract<RHSBlockProperties, Properties::TileSizeDimN>(thread_properties.linearLocalThreadId))"
  },
  {
    "label": "TensorContractionKernel()",
    "kind": "Method",
    "detail": "Function (} } ; Scratch scratch ; const LhsMapper lhs ; const RhsMapper rhs ; OutAccessor out_res ; const StorageIndex groupSizeM ; const StorageIndex groupSizeN ; const StorageIndex numTiles ; const TripleDim triple_dim ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "TensorContractionKernel(Scratch scratch_, const LhsMapper lhs_, const RhsMapper rhs_, OutAccessor out_res_, const StorageIndex groupSizeM_, const StorageIndex groupSizeN_, const StorageIndex numTiles_, const TripleDim triple_dim_) : scratch(scratch_), lhs(lhs_), rhs(rhs_), out_res(out_res_), groupSizeM(groupSizeM_), groupSizeN(groupSizeN_), numTiles(numTiles_), triple_dim(triple_dim_)"
  },
  {
    "label": "TensorContractionKernel()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "TensorContractionKernel(Scratch scratch_, const LhsMapper lhs_, const RhsMapper rhs_, OutAccessor out_res_, const StorageIndex groupSizeM_, const StorageIndex numTiles_, const TripleDim triple_dim_) : TensorContractionKernel(scratch_, lhs_, rhs_, out_res_, groupSizeM_, 1, numTiles_, triple_dim_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "operator()(cl::sycl::nd_item<1> itemID)"
  },
  {
    "label": "get_local_id()",
    "kind": "Method",
    "detail": "Function (const StorageIndex linearLocalThreadId = itemID .)",
    "insertText": "get_local_id(0)"
  },
  {
    "label": "get_group()",
    "kind": "Method",
    "detail": "Function (const StorageIndex nLocalThreadId = linearLocalThreadId / Properties::LocalThreadSizeM ; const StorageIndex mLocalThreadId = linearLocalThreadId % Properties::LocalThreadSizeM ; const StorageIndex mGroupId = itemID .)",
    "insertText": "get_group(0)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (const StorageIndex nGroupId = IsFinal ? tmp : tmp % groupSizeN ; const StorageIndex kGroupId = IsFinal ? 0 : tmp / groupSizeN ; const StorageIndex mGroupOffset = mGroupId* Properties::TileSizeDimM ; const StorageIndex nGroupOffset = nGroupId* Properties::TileSizeDimN ; const StorageIndex mLocalOffset = PacketSize* mLocalThreadId ; const StorageIndex nLocalOffset = NStride* nLocalThreadId ; const StorageIndex mGlobalOffset = mGroupOffset + mLocalOffset ; const StorageIndex nGlobalOffset = nGroupOffset + nLocalOffset ; const StorageIndex kSizePerWG = IsFinal ? triple_dim . K : numTiles* Properties::TileSizeDimK ; StorageIndex kGroupOffset = kGroupId* kSizePerWG ; const bool is_internal = triple_dim . M - mGroupOffset> = Properties::TileSizeDimM&& triple_dim . N - nGroupOffset> = Properties::TileSizeDimN&& triple_dim . K - kGroupOffset> = kSizePerWG ; StorageIndex kSize = IsFinal ? triple_dim . K :)",
    "insertText": "min(kSizePerWG, triple_dim.K - kGroupOffset)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (kGroupOffset + = kSize ; auto thread_properties = ThreadProperties<)",
    "insertText": "StorageIndex(linearLocalThreadId, kGroupId, mGroupOffset, nGroupOffset, kGroupOffset, mLocalOffset, nLocalOffset, mGlobalOffset, nGlobalOffset, kSize, is_internal)"
  },
  {
    "label": "get_pointer()",
    "kind": "Method",
    "detail": "Function (auto out_ptr = out_res .)",
    "insertText": "get_pointer() + (IsFinal ? 0 : thread_properties.kGroupId * triple_dim.M * triple_dim.N)"
  },
  {
    "label": "compute_block_per_tile()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "compute_block_per_tile(OutScalar *lhs_block_ptr, OutScalar *rhs_block_ptr, PacketReturnType *privateRes)"
  },
  {
    "label": "local()",
    "kind": "Method",
    "detail": "Function (StorageIndex idx = 0 ; EIGEN_CONSTEXPR StorageIndex lhs_stride = contraction_tp = =)",
    "insertText": "local(PacketSize * Properties::LocalThreadSizeM)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex wLPTN = 0; wLPTN < Properties::WorkLoadPerThreadN; wLPTN++)"
  },
  {
    "label": "PacketReturnType()",
    "kind": "Method",
    "detail": "Function (auto rhsPacket =)",
    "insertText": "PacketReturnType(rhs_block_ptr + wLPTN)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (StorageIndex lhs_index = 0 ; EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex wLPTM = 0; wLPTM < Properties::WorkLoadPerThreadM / PacketSize; wLPTM++)"
  },
  {
    "label": "set_packet()",
    "kind": "Method",
    "detail": "Function (PacketReturnType lhsPack { } ; Eigen::TensorSycl::internal::PacketWrapper<PacketReturnType,PacketSize)",
    "insertText": "set_packet(lhsPack, lhs_block_ptr + lhs_index)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (privateRes [ idx ] =::Eigen::)",
    "insertText": "pmadd(lhsPack, rhsPacket, privateRes[idx])"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (lhs_index + = lhs_stride ; idx + + ; } } } template<bool is_internal_block,StorageIndex PrivateNStride,OutPtr> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "store(OutPtr *out_ptr, PacketReturnType *privateRes, StorageIndex mGlobalOffset, StorageIndex nGlobalOffset)"
  },
  {
    "label": "chk_bound()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "chk_bound(const StorageIndex &mIndex, const StorageIndex &nIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} ; EIGEN_CONSTEXPR StorageIndex GlobalNStride = contraction_tp = = contraction_type::local ? 1 : Properties::LocalThreadSizeN ; EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex wLPTN = 0; wLPTN < Properties::WorkLoadPerThreadN / PrivateNStride; wLPTN++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (StorageIndex outputLD = 0 ; EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex nId = 0; nId < PrivateNStride; nId++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (PacketReturnType privetOut = privateRes [ wLPTM ] ;)",
    "insertText": "if(check_boundary<is_internal_block>(chk_bound(globalRow, nId)))"
  },
  {
    "label": "global_mem()",
    "kind": "Method",
    "detail": "Function (write<)",
    "insertText": "global_mem(privetOut, out_ptr + outputLD + globalRow)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else { EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex mId = 0; mId < PacketSize; mId++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StorageIndex mOffset = globalRow + mId ;)",
    "insertText": "if(mOffset < triple_dim.M && (nGlobalOffset + nId < triple_dim.N))"
  },
  {
    "label": "scalarize()",
    "kind": "Method",
    "detail": "Function (out_ptr [ mOffset + outputLD ] = Eigen::TensorSycl::internal::PacketWrapper<PacketReturnType,PacketSize)",
    "insertText": "scalarize(mId, privetOut)"
  },
  {
    "label": "globalRow()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "globalRow(PacketSize * Properties::LocalThreadSizeM)"
  },
  {
    "label": "out_ptr()",
    "kind": "Method",
    "detail": "Function (} outputLD + = triple_dim . M ; privateRes + = Properties::WorkLoadPerThreadM / PacketSize ; })",
    "insertText": "out_ptr(GlobalNStride * outputLD)"
  },
  {
    "label": "nGlobalOffset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nGlobalOffset(PrivateNStride * GlobalNStride)"
  },
  {
    "label": "extract_block()",
    "kind": "Method",
    "detail": "Function (} } template<InputBlockProperties,bool is_internal_block,Input,PrivateReg,contraction_type contract_tp = contraction_tp> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE::Eigen::internal::enable_if<contract_tp = = contraction_type::no_local>::type)",
    "insertText": "extract_block(const Input &inpt, PrivateReg private_ptr, const std::pair<StorageIndex, StorageIndex> &, const StorageIndex &ncOffset, const StorageIndex cOffset)"
  },
  {
    "label": "chk_bound()",
    "kind": "Method",
    "detail": "Function (EIGEN_CONSTEXPR StorageIndex LocalThreadSizeNC = InputBlockProperties::is_rhs ? Properties::LocalThreadSizeN : Properties::LocalThreadSizeM ; EIGEN_CONSTEXPR StorageIndex WorkLoadPerThreadNC = InputBlockProperties::is_rhs ? Properties::WorkLoadPerThreadN : Properties::WorkLoadPerThreadM ; const StorageIndex& NC = InputBlockProperties::is_rhs ? triple_dim . N : triple_dim . M ; auto)",
    "insertText": "chk_bound(const StorageIndex &CIndex, const StorageIndex &NCIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} ; const StorageIndex ld = InputBlockProperties::is_coalesced_layout ? NC : triple_dim . K ; StorageIndex cIndex = cOffset ; EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex cId = 0; cId < Properties::TileSizeDimK / InputBlockProperties::c_stride; cId++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (StorageIndex ncIndex = ncOffset ; EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex ncId = 0; ncId < WorkLoadPerThreadNC / InputBlockProperties::nc_stride; ncId++)"
  },
  {
    "label": "OutType()",
    "kind": "Method",
    "detail": "Function (auto val = read<InputBlockProperties::packet_load,InputBlockProperties::is_coalesced_layout,InputBlockProperties::is_rhs,)",
    "insertText": "OutType(inpt, ncIndex, cIndex, ld)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (write<)",
    "insertText": "StorageIndex(InputBlockProperties::is_coalesced_layout ? 1 : WorkLoadPerThreadNC), data_source::private_mem>(val, private_ptr)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else { EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex i = 0; i < InputBlockProperties::elements_per_access; i++)"
  },
  {
    "label": "ncIndex()",
    "kind": "Method",
    "detail": "Function (const StorageIndex ncInd =)",
    "insertText": "ncIndex(InputBlockProperties::is_coalesced_layout ? i : 0)"
  },
  {
    "label": "cIndex()",
    "kind": "Method",
    "detail": "Function (const StorageIndex cInd =)",
    "insertText": "cIndex(InputBlockProperties::is_coalesced_layout ? 0 : i)"
  },
  {
    "label": "val()",
    "kind": "Method",
    "detail": "Function (OutScalar)",
    "insertText": "val(ncInd < NC && cInd < triple_dim.K) ? read<false, InputBlockProperties::is_coalesced_layout, InputBlockProperties::is_rhs, OutScalar>( inpt, ncInd, cInd, ld) : OutScalar(0)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (write<)",
    "insertText": "StorageIndex(InputBlockProperties::is_coalesced_layout ? 1 : WorkLoadPerThreadNC), data_source::private_mem>( val, private_ptr + (InputBlockProperties::is_coalesced_layout ? i : 0) + ((InputBlockProperties::is_coalesced_layout ? 0 : i) * WorkLoadPerThreadNC))"
  },
  {
    "label": "ncIndex()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "ncIndex(!InputBlockProperties::is_rhs && InputBlockProperties::nc_stride == 1 && PacketSize != 1) ? ncOffset + (ncId + 1) % PacketSize + ((ncId + 1) / PacketSize) * LocalThreadSizeNC : (ncIndex + InputBlockProperties::nc_stride * LocalThreadSizeNC)"
  },
  {
    "label": "private_ptr()",
    "kind": "Method",
    "detail": "Function (private_ptr + = InputBlockProperties::nc_stride ; })",
    "insertText": "private_ptr(InputBlockProperties::c_stride - 1)"
  },
  {
    "label": "local_id_extract()",
    "kind": "Method",
    "detail": "Function (cIndex + = InputBlockProperties::c_stride ; } } template<InputBlockProperties,StorageIndex TileSizeDimNC> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::pair<StorageIndex,StorageIndex>)",
    "insertText": "local_id_extract(const StorageIndex &linearLocalThreadId)"
  },
  {
    "label": "localThreadNC()",
    "kind": "Method",
    "detail": "Function (const StorageIndex)",
    "insertText": "localThreadNC(InputBlockProperties::is_coalesced_layout) ? linearLocalThreadId % (TileSizeDimNC / InputBlockProperties::nc_stride) : linearLocalThreadId / (Properties::TileSizeDimK / InputBlockProperties::c_stride)"
  },
  {
    "label": "localThreadC()",
    "kind": "Method",
    "detail": "Function (const StorageIndex)",
    "insertText": "localThreadC(InputBlockProperties::is_coalesced_layout) ? linearLocalThreadId / (TileSizeDimNC / InputBlockProperties::nc_stride) : linearLocalThreadId % (Properties::TileSizeDimK / InputBlockProperties::c_stride)"
  },
  {
    "label": "sync_mem()",
    "kind": "Method",
    "detail": "Function (} template<bool db = Properties::DoubleBuffer,contraction_type ctp = contraction_tp> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE::Eigen::internal::enable_if<db&& ctp = = contraction_type::local>::type)",
    "insertText": "sync_mem(const cl::sycl::nd_item<1> &, bool &db_offset)"
  },
  {
    "label": "sync_mem()",
    "kind": "Method",
    "detail": "Function (db_offset = ! db_offset ; } template<bool db = Properties::DoubleBuffer,contraction_type ctp = contraction_tp> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE::Eigen::internal::enable_if<! db&& ctp = = contraction_type::local>::type)",
    "insertText": "sync_mem(const cl::sycl::nd_item<1> &itemID, bool &)"
  },
  {
    "label": "barrier()",
    "kind": "Method",
    "detail": "Function (itemID .)",
    "insertText": "barrier(cl::sycl::access::fence_space::local_space)"
  },
  {
    "label": "sync_mem()",
    "kind": "Method",
    "detail": "Function (} template<contraction_type ctp = contraction_tp> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE::Eigen::internal::enable_if<ctp = = contraction_type::no_local>::type)",
    "insertText": "sync_mem(const cl::sycl::nd_item<1> &, bool &)"
  },
  {
    "label": "barrier()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_SYCL_ARM_GPU_CACHE_OPTIMISATION itemID .)",
    "insertText": "barrier(cl::sycl::access::fence_spacce::local_space)"
  },
  {
    "label": "sync_thread()",
    "kind": "Method",
    "detail": "Function (# else return ; # endif } template<bool need_sync,contraction_type ctp = contraction_tp> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE::Eigen::internal::enable_if<need_sync&& ctp = = contraction_type::local>::type)",
    "insertText": "sync_thread(const cl::sycl::nd_item<1> &itemID)"
  },
  {
    "label": "sync_thread()",
    "kind": "Method",
    "detail": "Function (} template<bool need_sync> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE::Eigen::internal::enable_if<! need_sync>::type)",
    "insertText": "sync_thread(const cl::sycl::nd_item<1> &)"
  },
  {
    "label": "is_internal_block()",
    "kind": "Method",
    "detail": "Function (extract_block<RHSBlockProperties,)",
    "insertText": "is_internal_block(rhs, tiled_input_block.rhs_scratch_extract.ptr + (db_offset * Properties::TileSizeDimK * LSDR), tiled_input_block.rhs_extract_index, contraction_tp == contraction_type::local ? thread_properties.nGroupOffset : thread_properties.nGlobalOffset, thread_properties.kGroupOffset - thread_properties.kSize)"
  },
  {
    "label": "no_local()",
    "kind": "Method",
    "detail": "Function (sync_thread<contraction_tp = =)",
    "insertText": "no_local(itemID)"
  },
  {
    "label": "is_internal_block()",
    "kind": "Method",
    "detail": "Function (extract_block<LHSBlockProperties,)",
    "insertText": "is_internal_block(lhs, tiled_input_block.lhs_scratch_extract.ptr + (db_offset * LSDL * Properties::TileSizeDimK), tiled_input_block.lhs_extract_index, contraction_tp == contraction_type::local ? thread_properties.mGroupOffset : thread_properties.mGlobalOffset, thread_properties.kGroupOffset - thread_properties.kSize)"
  },
  {
    "label": "local()",
    "kind": "Method",
    "detail": "Function (sync_thread<contraction_tp = =)",
    "insertText": "local(itemID)"
  },
  {
    "label": "lhs_offset()",
    "kind": "Method",
    "detail": "Function (StorageIndex)",
    "insertText": "lhs_offset(db_offset * LSDL * Properties::TileSizeDimK)"
  },
  {
    "label": "rhs_offset()",
    "kind": "Method",
    "detail": "Function (StorageIndex)",
    "insertText": "rhs_offset(db_offset * Properties::TileSizeDimK * LSDR)"
  },
  {
    "label": "compute_block_per_tile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_block_per_tile(tiled_input_block.lhs_scratch_ptr_compute + lhs_offset, tiled_input_block.rhs_scratch_ptr_compute + rhs_offset, privateRes)"
  },
  {
    "label": "sync_mem()",
    "kind": "Method",
    "detail": "Function (lhs_offset + = LSDL ; rhs_offset + = LSDR ; } thread_properties . kSize - = Properties::TileSizeDimK ;)",
    "insertText": "sync_mem(itemID, db_offset)"
  },
  {
    "label": "compute_panel()",
    "kind": "Method",
    "detail": "Function (} template<bool is_internal_block,OutPtr> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "compute_panel(const cl::sycl::nd_item<1> &itemID, ThreadProperties<StorageIndex> &thread_properties, OutPtr out_ptr)"
  },
  {
    "label": "get_pointer()",
    "kind": "Method",
    "detail": "Function (auto tiled_input_block = TiledMemory { thread_properties,scratch .)",
    "insertText": "get_pointer()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (PacketReturnType privateRes [ Properties::WorkLoadPerThreadM* Properties::WorkLoadPerThreadN / PacketSize ] = { PacketReturnType { 0 } } ; bool db_offset = 0 ;)",
    "insertText": "while(thread_properties.kSize >= Properties::TileSizeDimK)"
  },
  {
    "label": "is_internal_block()",
    "kind": "Method",
    "detail": "Function (compute_tile_per_panel<)",
    "insertText": "is_internal_block(itemID, thread_properties, tiled_input_block, privateRes, db_offset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(thread_properties.kSize > 0)"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (compute_tile_per_panel<)",
    "insertText": "false(itemID, thread_properties, tiled_input_block, privateRes, db_offset)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (} store<is_internal_block,contraction_tp = = contraction_type::local ? static_cast<)",
    "insertText": "StorageIndex(1) : RHSBlockProperties::nc_stride>( out_ptr + thread_properties.nGlobalOffset * triple_dim.M, privateRes, thread_properties.mGlobalOffset, thread_properties.nGlobalOffset)"
  },
  {
    "label": "extract_block()",
    "kind": "Method",
    "detail": "Function (} template<InputBlockProperties,bool is_internal_block,Input,Local,contraction_type contract_tp = contraction_tp> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE::Eigen::internal::enable_if<contract_tp = = contraction_type::local>::type)",
    "insertText": "extract_block(const Input &inpt, Local local_ptr, const std::pair<StorageIndex, StorageIndex>& local_index, const StorageIndex &ncOffset, const StorageIndex cOffset)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (EIGEN_CONSTEXPR StorageIndex TileSizeDimNC = InputBlockProperties::is_rhs ? Properties::TileSizeDimN : Properties::TileSizeDimM ; EIGEN_CONSTEXPR StorageIndex LoadPerThread = InputBlockProperties::is_rhs ? Properties::LoadPerThreadRhs : Properties::LoadPerThreadLhs ; EIGEN_CONSTEXPR StorageIndex LSD = InputBlockProperties::is_rhs ? LSDR : LSDL ;)",
    "insertText": "static_assert(((LocalOffset % (TileSizeDimNC / InputBlockProperties::nc_stride) == 0) && (LocalOffset % (Properties::TileSizeDimK / InputBlockProperties::c_stride) == 0)), \" LocalOffset must be divisable by stride\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} ; EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex lPT = 0; lPT < LoadPerThread / InputBlockProperties::elements_per_access; lPT++)"
  },
  {
    "label": "cOffset()",
    "kind": "Method",
    "detail": "Function (const StorageIndex CIndex =)",
    "insertText": "cOffset(InputBlockProperties::c_stride * localThreadC)"
  },
  {
    "label": "ncOffset()",
    "kind": "Method",
    "detail": "Function (const StorageIndex NCIndex =)",
    "insertText": "ncOffset(InputBlockProperties::nc_stride * localThreadNC)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const StorageIndex ld = InputBlockProperties::is_coalesced_layout ? NC : triple_dim . K ;)",
    "insertText": "if(check_boundary<is_internal_block>(chk_bound(CIndex, NCIndex)))"
  },
  {
    "label": "OutType()",
    "kind": "Method",
    "detail": "Function (auto val = read<InputBlockProperties::packet_load,InputBlockProperties::is_coalesced_layout,InputBlockProperties::is_rhs,)",
    "insertText": "OutType(inpt, NCIndex, CIndex, ld)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (write<)",
    "insertText": "StorageIndex(InputBlockProperties::is_coalesced_layout ? 1 : LSD), data_source::local_mem>( val, local_ptr + (InputBlockProperties::nc_stride * localThreadNC) + (InputBlockProperties::c_stride * localThreadC * LSD))"
  },
  {
    "label": "NCIndex()",
    "kind": "Method",
    "detail": "Function (const StorageIndex nCInd =)",
    "insertText": "NCIndex(InputBlockProperties::is_coalesced_layout ? i : 0)"
  },
  {
    "label": "CIndex()",
    "kind": "Method",
    "detail": "Function (const StorageIndex cInd =)",
    "insertText": "CIndex(InputBlockProperties::is_coalesced_layout ? 0 : i)"
  },
  {
    "label": "val()",
    "kind": "Method",
    "detail": "Function (OutScalar)",
    "insertText": "val(nCInd < NC && cInd < triple_dim.K) ? read<false, InputBlockProperties::is_coalesced_layout, InputBlockProperties::is_rhs, OutScalar>( inpt, nCInd, cInd, ld) : OutScalar(0)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (write<)",
    "insertText": "StorageIndex(InputBlockProperties::is_coalesced_layout ? 1 : LSD), data_source::local_mem>( val, local_ptr + (InputBlockProperties::nc_stride * localThreadNC) + (InputBlockProperties::is_coalesced_layout ? i : 0) + ((InputBlockProperties::c_stride * localThreadC + (InputBlockProperties::is_coalesced_layout ? 0 : i)) * LSD))"
  },
  {
    "label": "localThreadNC()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "localThreadNC(InputBlockProperties::is_coalesced_layout) ? LocalOffset % (TileSizeDimNC / InputBlockProperties::nc_stride) : LocalOffset / (Properties::TileSizeDimK / InputBlockProperties::c_stride)"
  },
  {
    "label": "localThreadC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "localThreadC(InputBlockProperties::is_coalesced_layout) ? LocalOffset / (TileSizeDimNC / InputBlockProperties::nc_stride) : LocalOffset % (Properties::TileSizeDimK / InputBlockProperties::c_stride)"
  },
  {
    "label": "GeneralVectorTensor()",
    "kind": "Method",
    "detail": "Function (} } } ; # ifndef EIGEN_SYCL_DISABLE_GEMV template<OutScalar,OutAccessor,VectorMapper,TensorMapper,StorageIndex,Properties,StorageIndex KFactor,bool Vectorizable,bool is_lhs_vec,bool IsFinal> struct GeneralVectorTensor { typedef Eigen::TensorSycl::internal::Vectorise<OutScalar,Eigen::SyclDevice,Vectorizable>::PacketReturnType PacketReturnType ; EIGEN_CONSTEXPR int PacketSize = Eigen::TensorSycl::internal::Vectorise<OutScalar,Eigen::SyclDevice,Vectorizable>::PacketSize ; typedef cl::sycl::accessor<OutScalar,1,cl::sycl::access::mode::read_write,cl::sycl::access::target::local> Scratch ; EIGEN_CONSTEXPR StorageIndex OutScratchOffset = KFactor* Properties::LocalThreadSizeC* Properties::LocalThreadSizeNC ; typedef BlockProperties<is_lhs_vec ? false : true,is_lhs_vec ? false : true,Vectorizable,PacketReturnType> VecBlockProperties ; Scratch scratch ; const VectorMapper vec ; const TensorMapper mat ; OutAccessor out_res ; const StorageIndex nonContractGroupSize ; const StorageIndex nonContractDim ; const StorageIndex contractDim ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "GeneralVectorTensor(Scratch scratch_, const VectorMapper vec_, const TensorMapper mat_, OutAccessor out_res_, const StorageIndex nonContractGroupSize_, const StorageIndex nonContractDim_, const StorageIndex contractDim_) : scratch(scratch_), vec(vec_), mat(mat_), out_res(out_res_), nonContractGroupSize(nonContractGroupSize_), nonContractDim(nonContractDim_), contractDim(contractDim_)"
  },
  {
    "label": "get_group_range()",
    "kind": "Method",
    "detail": "Function (StorageIndex nonContractId = is_lhs_vec ? linearLocalThreadId / Properties::LocalThreadSizeC : linearLocalThreadId % Properties::LocalThreadSizeNC ; StorageIndex contractId = is_lhs_vec ? linearLocalThreadId % Properties::LocalThreadSizeC : linearLocalThreadId / Properties::LocalThreadSizeNC ; const StorageIndex cGroupSize = itemID .)",
    "insertText": "get_group_range(0)"
  },
  {
    "label": "get_group()",
    "kind": "Method",
    "detail": "Function (const StorageIndex nonContractGroupId = is_lhs_vec ? itemID .)",
    "insertText": "get_group(0) / cGroupSize : itemID.get_group(0)"
  },
  {
    "label": "get_group()",
    "kind": "Method",
    "detail": "Function (const StorageIndex contractGroupId = is_lhs_vec ? itemID .)",
    "insertText": "get_group(0) % cGroupSize : itemID.get_group(0)"
  },
  {
    "label": "get_pointer()",
    "kind": "Method",
    "detail": "Function (auto out_ptr = out_res .)",
    "insertText": "get_pointer() + (IsFinal ? 0 : contractGroupId * nonContractDim)"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (const StorageIndex nonContractGroupOffset = nonContractGroupId* Properties::TileSizeDimNC ; const StorageIndex contractGroupOffset = contractGroupId* Properties::TileSizeDimC ; auto outScratchIndex = nonContractId + contractId* Properties::LocalThreadSizeNC ; const StorageIndex globalNonContractDimOffset = nonContractGroupOffset + nonContractId ; const StorageIndex globalContractDimOffset = contractGroupOffset + contractId ; auto local_output = scratch_ptr + OutScratchOffset ; const bool is_internal = nonContractDim - nonContractGroupOffset> = Properties::TileSizeDimNC&& contractDim - contractGroupOffset> = Properties::TileSizeDimC ; is_internal ? compute_panel<)",
    "insertText": "true(itemID, vec, mat, local_output, out_ptr, #ifdef EIGEN_SYCL_LOCAL_MEM_UNSET_OR_ON scratch_ptr, contractGroupOffset, #endif nonContractGroupOffset, linearLocalThreadId, contractDim, nonContractDim, contractId, nonContractId, globalContractDimOffset, globalNonContractDimOffset, outScratchIndex) : compute_panel<false>(itemID, vec, mat, local_output, out_ptr, #ifdef EIGEN_SYCL_LOCAL_MEM_UNSET_OR_ON scratch_ptr, contractGroupOffset, #endif nonContractGroupOffset, linearLocalThreadId, contractDim, nonContractDim, contractId, nonContractId, globalContractDimOffset, globalNonContractDimOffset, outScratchIndex)"
  },
  {
    "label": "compute_panel()",
    "kind": "Method",
    "detail": "Function (} template<bool is_internal_block,OutPtr> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "compute_panel(const cl::sycl::nd_item<1> &itemID, const VectorMapper &vec, const TensorMapper &mat, OutScalar *local_output, OutPtr out_ptr, #ifdef EIGEN_SYCL_LOCAL_MEM_UNSET_OR_ON OutScalar *scratch_ptr, const StorageIndex contractGroupOffset, #endif const StorageIndex nonContractGroupOffset, const StorageIndex linearLocalThreadId, StorageIndex contractDim, StorageIndex nonContractDim, StorageIndex contractId, StorageIndex nonContractId, StorageIndex globalContractDimOffset, StorageIndex globalNonContractDimOffset, StorageIndex outScratchIndex)"
  },
  {
    "label": "OutScalar()",
    "kind": "Method",
    "detail": "Function (OutScalar outScalar [ Properties::WorkLoadPerThreadNC ] = {)",
    "insertText": "OutScalar(0)"
  },
  {
    "label": "LocalThreadSizeC()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_SYCL_LOCAL_MEM_UNSET_OR_ON const StorageIndex vectorOffset = contractGroupOffset + linearLocalThreadId ; extract_block<VecBlockProperties,is_internal_block,KFactor,Properties::LocalThreadSizeNC*)",
    "insertText": "LocalThreadSizeC(vec, scratch_ptr, linearLocalThreadId, vectorOffset, contractDim)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (auto in_scratch_ptr = scratch_ptr + contractId ; # endif StorageIndex privateOffsetC = 0 ; EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex i = 0; i < Properties::WorkLoadPerThreadC; i++)"
  },
  {
    "label": "contract_conds()",
    "kind": "Method",
    "detail": "Function (StorageIndex privateOffsetNC = 0 ; bool)",
    "insertText": "contract_conds((globalContractDimOffset + privateOffsetC) < contractDim)"
  },
  {
    "label": "vecScalar()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_SYCL_LOCAL_MEM_UNSET_OR_ON auto vecScalar =* in_scratch_ptr ; # else auto)",
    "insertText": "vecScalar(check_boundary<is_internal_block>(contract_conds)) ? vec(is_lhs_vec ? StorageIndex(0) : globalContractDimOffset + privateOffsetC, is_lhs_vec ? globalContractDimOffset + privateOffsetC : StorageIndex(0)) : OutScalar(0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# endif EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex j = 0; j < Properties::WorkLoadPerThreadNC; j++)"
  },
  {
    "label": "matScalar()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "matScalar(check_boundary<is_internal_block>( contract_conds && ((globalNonContractDimOffset + privateOffsetNC) < nonContractDim))) ? mat(is_lhs_vec ? globalContractDimOffset + privateOffsetC : globalNonContractDimOffset + privateOffsetNC, is_lhs_vec ? globalNonContractDimOffset + privateOffsetNC : globalContractDimOffset + privateOffsetC) : OutScalar(0)"
  },
  {
    "label": "mad()",
    "kind": "Method",
    "detail": "Function (outScalar [ j ] = cl::)",
    "insertText": "mad(matScalar, vecScalar, outScalar[j])"
  },
  {
    "label": "out_scratch_ptr()",
    "kind": "Method",
    "detail": "Function (* out_scratch_ptr = outScalar [ j ] ;)",
    "insertText": "out_scratch_ptr(Properties::LocalThreadSizeNC * Properties::LocalThreadSizeC)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(is_lhs_vec)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (EIGEN_UNROLL_LOOP)",
    "insertText": "for(StorageIndex offset = Properties::LocalThreadSizeC >> 1; offset > 0; offset >>= 1)"
  },
  {
    "label": "myNeigbourId()",
    "kind": "Method",
    "detail": "Function (StorageIndex)",
    "insertText": "myNeigbourId(Properties::LocalThreadSizeNC * offset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(contractId == 0)"
  },
  {
    "label": "extract_block()",
    "kind": "Method",
    "detail": "Function (} } } template<InputBlockProperties,bool is_internal_block,int CFactor,int GroupSize,Input,Local> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "extract_block(const Input &inpt, Local *local_ptr, const StorageIndex &linearLocalThreadId, const StorageIndex &cOffset, const StorageIndex &C)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (local_ptr + = InputBlockProperties::c_stride* linearLocalThreadId ; StorageIndex cIndex = cOffset ;)",
    "insertText": "for(StorageIndex cId = 0; cId < CFactor / InputBlockProperties::c_stride; cId++)"
  },
  {
    "label": "OutType()",
    "kind": "Method",
    "detail": "Function (auto val = read<InputBlockProperties::packet_load,InputBlockProperties::is_coalesced_layout,InputBlockProperties::is_rhs,)",
    "insertText": "OutType(inpt, StorageIndex(0), cIndex, StorageIndex(1))"
  },
  {
    "label": "local_mem()",
    "kind": "Method",
    "detail": "Function (write<StorageIndex,1,)",
    "insertText": "local_mem(val, local_ptr)"
  },
  {
    "label": "val()",
    "kind": "Method",
    "detail": "Function (OutScalar)",
    "insertText": "val(cIndex + i < C) ? read<false, InputBlockProperties::is_coalesced_layout, InputBlockProperties::is_rhs, OutScalar>( inpt, StorageIndex(0), cIndex + i, StorageIndex(1)) : OutScalar(0)"
  },
  {
    "label": "local_mem()",
    "kind": "Method",
    "detail": "Function (write<StorageIndex,1,)",
    "insertText": "local_mem(val, local_ptr + i)"
  },
  {
    "label": "GeneralScalarContraction()",
    "kind": "Method",
    "detail": "Function (} } local_ptr + = InputBlockProperties::c_stride* GroupSize ; cIndex + = InputBlockProperties::c_stride* GroupSize ; } } } ; # endif # ifndef EIGEN_SYCL_DISABLE_SCALAR template<OutScalar,LhsScalar,RhsScalar,OutAccessor,LhsMapper,RhsMapper,StorageIndex,bool Vectorizable> struct GeneralScalarContraction { typedef cl::sycl::accessor<OutScalar,1,cl::sycl::access::mode::read_write,cl::sycl::access::target::local> Scratch ; Scratch scratch ; const LhsMapper lhs ; const RhsMapper rhs ; OutAccessor out_res ; const StorageIndex rng ; EIGEN_DEVICE_FUNC)",
    "insertText": "GeneralScalarContraction(Scratch scratch_, const LhsMapper lhs_, const RhsMapper rhs_, OutAccessor out_res_, const StorageIndex rng_) : scratch(scratch_), lhs(lhs_), rhs(rhs_), out_res(out_res_), rng(rng_)"
  },
  {
    "label": "get_pointer()",
    "kind": "Method",
    "detail": "Function (auto scratch_ptr = scratch .)",
    "insertText": "get_pointer().get()"
  },
  {
    "label": "get_global_id()",
    "kind": "Method",
    "detail": "Function (StorageIndex globalid = itemID .)",
    "insertText": "get_global_id(0)"
  },
  {
    "label": "mad()",
    "kind": "Method",
    "detail": "Function (accumulator = cl::)",
    "insertText": "mad(lhs(0, i), rhs(i, 0), accumulator)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} auto out_scratch_ptr = scratch_ptr + localid ;* out_scratch_ptr = accumulator ;)",
    "insertText": "for(StorageIndex offset = itemID.get_local_range(0) >> 1; offset > 0; offset >>= 1)"
  },
  {
    "label": "out_scratch_ptr()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "out_scratch_ptr(accumulator += out_scratch_ptr[offset])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(localid == 0)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } } ; # endif } } template<Indices,LeftArgType,RightArgType,OutputKernelType> struct TensorEvaluator<const TensorContractionOp<Indices,LeftArgType,RightArgType,OutputKernelType>,Eigen::SyclDevice> : public TensorContractionEvaluatorBase<TensorEvaluator<const TensorContractionOp<Indices,LeftArgType,RightArgType,OutputKernelType>,Eigen::SyclDevice>> {)",
    "insertText": "static_assert(std::is_same<OutputKernelType, const NoOpOutputKernel>::value, \"SYCL tensor contraction does not support output kernels.\")"
  },
  {
    "label": "TripleDim()",
    "kind": "Method",
    "detail": "Function (typedef Eigen::SyclDevice Device ; typedef TensorEvaluator<const TensorContractionOp<Indices,LeftArgType,RightArgType,OutputKernelType>,Device> Self ; typedef TensorContractionEvaluatorBase<Self> Base ; typedef TensorContractionOp<Indices,LeftArgType,RightArgType,OutputKernelType> XprType ; typedef internal::remove_const<XprType::Scalar>::type Scalar ; typedef XprType::Index StorageIndex ; typedef XprType::CoeffReturnType CoeffReturnType ; typedef PacketType<CoeffReturnType,Device>::type PacketReturnType ; typedef Base::Storage Storage ; typedef Base::EvaluatorPointerType EvaluatorPointerType ; struct TripleDim { const StorageIndex M ; const StorageIndex N ; const StorageIndex K ;)",
    "insertText": "TripleDim(const StorageIndex M_, const StorageIndex N_, const StorageIndex K_) : M(M_), N(N_), K(K_)"
  },
  {
    "label": "PacketAccess()",
    "kind": "Method",
    "detail": "Function (} } ; enum { Layout = TensorEvaluator<LeftArgType,Device>::Layout,)",
    "insertText": "PacketAccess(PacketType<CoeffReturnType, Device>::size > 1)"
  },
  {
    "label": "is_lhs_matrix()",
    "kind": "Method",
    "detail": "Function (EIGEN_CONSTEXPR int LDims = Base::LDims ; EIGEN_CONSTEXPR int RDims = Base::RDims ; EIGEN_CONSTEXPR int ContractDims = Base::ContractDims ; typedef array<StorageIndex,LDims> left_dim_mapper_t ; typedef array<StorageIndex,RDims> right_dim_mapper_t ; typedef array<StorageIndex,ContractDims> contract_t ; typedef array<StorageIndex,LDims - ContractDims> left_nocontract_t ; typedef array<StorageIndex,RDims - ContractDims> right_nocontract_t ; const int NumDims = LDims + RDims - 2* ContractDims ; typedef DSizes<StorageIndex,NumDims> Dimensions ; typedef TensorEvaluator<Base::EvalLeftArgType,Device> LeftEvaluator ; typedef TensorEvaluator<Base::EvalRightArgType,Device> RightEvaluator ; typedef Eigen::internal::remove_const<LeftEvaluator::CoeffReturnType>::type LhsScalar ; typedef Eigen::internal::remove_const<RightEvaluator::CoeffReturnType>::type RhsScalar ; typedef LeftEvaluator::Dimensions LeftDimensions ; typedef RightEvaluator::Dimensions RightDimensions ; template<bool lhs_inner_dim_contiguous,bool rhs_inner_dim_contiguous,bool rhs_inner_dim_reordered> struct input_mapper_propertis { EIGEN_CONSTEXPR bool)",
    "insertText": "is_lhs_matrix(LDims == 2 && ContractDims == 1)"
  },
  {
    "label": "is_rhs_matrix()",
    "kind": "Method",
    "detail": "Function (EIGEN_CONSTEXPR bool)",
    "insertText": "is_rhs_matrix(RDims == 2 && ContractDims == 1) || (rhs_inner_dim_contiguous && !rhs_inner_dim_reordered)"
  },
  {
    "label": "TensorEvaluator()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "TensorEvaluator(const XprType &op, const Device &device) : Base(op, device)"
  },
  {
    "label": "evalSubExprsIfNeeded()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE bool)",
    "insertText": "evalSubExprsIfNeeded(typename Base::EvaluatorPointerType data)"
  },
  {
    "label": "evalSubExprsIfNeeded()",
    "kind": "Method",
    "detail": "Function (this -> m_leftImpl .)",
    "insertText": "evalSubExprsIfNeeded(NULL)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (this -> m_result = this -> m_device .)",
    "insertText": "get(static_cast<Scalar *>(this->m_device.allocate_temp(this->dimensions().TotalSize() * sizeof(Scalar))))"
  },
  {
    "label": "evalToSycl()",
    "kind": "Method",
    "detail": "Function (data = this -> m_result ; })",
    "insertText": "evalToSycl(data)"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (} const Eigen::SyclDevice&)",
    "insertText": "device()"
  },
  {
    "label": "Unaligned()",
    "kind": "Method",
    "detail": "Function (evalTyped<true,true,true,)",
    "insertText": "Unaligned(buffer)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(this->m_rhs_inner_dim_reordered)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "if(this->m_rhs_inner_dim_contiguous)"
  },
  {
    "label": "evalTyped()",
    "kind": "Method",
    "detail": "Function (} } } } template<bool lhs_inner_dim_contiguous,bool rhs_inner_dim_contiguous,bool rhs_inner_dim_reordered,int Alignment> void)",
    "insertText": "evalTyped(typename Base::EvaluatorPointerType buffer)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (const auto triple_dim = TripleDim { this -> m_i_size,this -> m_j_size,this -> m_k_size } ; typedef internal::TensorContractionInputMapper<LhsScalar,StorageIndex,internal::Lhs,LeftEvaluator,left_nocontract_t,contract_t,PacketType<CoeffReturnType,Device>::size,lhs_inner_dim_contiguous,false,Unaligned,MakeSYCLPointer> LhsMapper ; typedef internal::TensorContractionInputMapper<RhsScalar,StorageIndex,internal::Rhs,RightEvaluator,right_nocontract_t,contract_t,PacketType<CoeffReturnType,Device>::size,rhs_inner_dim_contiguous,rhs_inner_dim_reordered,Unaligned,MakeSYCLPointer> RhsMapper ; LhsMapper)",
    "insertText": "lhs(this->m_leftImpl, this->m_left_nocontract_strides, this->m_i_strides, this->m_left_contracting_strides, this->m_k_strides)"
  },
  {
    "label": "rhs()",
    "kind": "Method",
    "detail": "Function (RhsMapper)",
    "insertText": "rhs(this->m_rightImpl, this->m_right_nocontract_strides, this->m_j_strides, this->m_right_contracting_strides, this->m_k_strides)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_SYCL_DISABLE_SCALAR)",
    "insertText": "if(triple_dim.M == 1 && triple_dim.N == 1)"
  },
  {
    "label": "launchSC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "launchSC(buffer, lhs, rhs, triple_dim.K)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else # endif # ifndef EIGEN_SYCL_DISABLE_GEMV)",
    "insertText": "if(triple_dim.M != 1 && triple_dim.N == 1)"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (LaunchVT<)",
    "insertText": "false(buffer, rhs, lhs, triple_dim.M, triple_dim.K)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(triple_dim.M == 1 && triple_dim.N != 1)"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (LaunchVT<)",
    "insertText": "true(buffer, lhs, rhs, triple_dim.N, triple_dim.K)"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (} else # endif { typedef input_mapper_propertis<lhs_inner_dim_contiguous,rhs_inner_dim_contiguous,rhs_inner_dim_reordered> inpt_mapper_properties ; # ifndef EIGEN_SYCL_DISABLE_SKINNY bool skinny = false ; auto platform_name = this ->)",
    "insertText": "device().getPlatformName()"
  },
  {
    "label": "skinny()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "skinny(triple_dim.M < triple_dim.K || triple_dim.N < triple_dim.K) && ((triple_dim.M < 1024 && triple_dim.N < 1024) || (uint64_t(triple_dim.M * triple_dim.N) < uint64_t(triple_dim.K)))"
  },
  {
    "label": "skinny()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "skinny(((std::max(triple_dim.K, triple_dim.N) / std::min(triple_dim.K, triple_dim.N)) > 100) || ((std::max(triple_dim.K, triple_dim.M) / std::min(triple_dim.K, triple_dim.M)) > 100) || ((std::max(triple_dim.N, triple_dim.M) / std::min(triple_dim.N, triple_dim.M)) > 100))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(skinny) adjustTT<true, inpt_mapper_properties>(buffer, lhs, rhs, triple_dim)"
  },
  {
    "label": "adjustTT()",
    "kind": "Method",
    "detail": "Function (} } template<bool skinny,input_mapper_properties,LhsMapper,RhsMapper> void EIGEN_ALWAYS_INLINE)",
    "insertText": "adjustTT(EvaluatorPointerType buffer, const LhsMapper &lhs, const RhsMapper &rhs, const TripleDim &triple_dim)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_SYCL_LOCAL_MEM_UNSET_OR_ON)",
    "insertText": "if(device().has_local_memory())"
  },
  {
    "label": "PanelParameters()",
    "kind": "Method",
    "detail": "Function (typedef TensorSycl::internal::TTPanelSize<CoeffReturnType,StorageIndex,4,4,1 6> PanelParameters ; launchTT<TensorSycl::internal::contraction_type::local,skinny,input_mapper_properties,)",
    "insertText": "PanelParameters(buffer, lhs, rhs, triple_dim)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif # ifdef EIGEN_SYCL_LOCAL_MEM_UNSET_OR_OFF)",
    "insertText": "if(!(device().has_local_memory()))"
  },
  {
    "label": "launchTT()",
    "kind": "Method",
    "detail": "Function (} # endif } template<TensorSycl::internal::contraction_type ct,bool skinny,input_mapper_properties,Properties,LhsMapper,RhsMapper> void)",
    "insertText": "launchTT(EvaluatorPointerType buffer, const LhsMapper &lhs, const RhsMapper &rhs, const TripleDim &triple_dim)"
  },
  {
    "label": "roundUp()",
    "kind": "Method",
    "detail": "Function (const StorageIndex roundUpM = Eigen::TensorSycl::)",
    "insertText": "roundUp(triple_dim.M, Properties::TileSizeDimM)"
  },
  {
    "label": "roundUp()",
    "kind": "Method",
    "detail": "Function (const StorageIndex roundUpN = Eigen::TensorSycl::)",
    "insertText": "roundUp(triple_dim.N, Properties::TileSizeDimN)"
  },
  {
    "label": "roundUp()",
    "kind": "Method",
    "detail": "Function (const StorageIndex groupSizeM = roundUpM / Properties::TileSizeDimM ; const StorageIndex groupSizeN = roundUpN / Properties::TileSizeDimN ; const StorageIndex roundUpK = Eigen::TensorSycl::)",
    "insertText": "roundUp(triple_dim.K, Properties::TileSizeDimK)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (StorageIndex totalTilesK = roundUpK / Properties::TileSizeDimK ; StorageIndex groupSizeK = skinny ?)",
    "insertText": "max(std::min(totalTilesK, (StorageIndex)(device().getPowerOfTwo(device().getNumSyclMultiProcessors(), true) * 4) / (groupSizeM * groupSizeN)), StorageIndex(1)) : StorageIndex(1)"
  },
  {
    "label": "roundUp()",
    "kind": "Method",
    "detail": "Function (const StorageIndex numTilesPerGroup = Eigen::TensorSycl::)",
    "insertText": "roundUp(totalTilesK, groupSizeK)"
  },
  {
    "label": "scratchSize()",
    "kind": "Method",
    "detail": "Function (const StorageIndex totalGroupSize = groupSizeM* groupSizeN* groupSizeK ; const StorageIndex localRange = Properties::LocalThreadSizeM* Properties::LocalThreadSizeN ; const StorageIndex globalRange = totalGroupSize* localRange ; const StorageIndex)",
    "insertText": "scratchSize(ct == TensorSycl::internal::contraction_type::local) ? ((Properties::DoubleBuffer + 1) * (Properties::TileSizeDimM + Properties::BC) * (Properties::TileSizeDimK)) + ((Properties::DoubleBuffer + 1) * (Properties::TileSizeDimK) * (Properties::TileSizeDimN + Properties::BC)) : StorageIndex(1)"
  },
  {
    "label": "nd_range()",
    "kind": "Method",
    "detail": "Function (auto thread_range = cl::)",
    "insertText": "nd_range(cl::sycl::range<1>(globalRange), cl::sycl::range<1>(localRange))"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (typedef TensorSycl::internal::TensorContractionKernel<CoeffReturnType,LhsScalar,RhsScalar,EvaluatorPointerType,LhsMapper,RhsMapper,StorageIndex,Properties,TripleDim,PacketAccess,input_mapper_properties,true,ct> ContractKernelName ;)",
    "insertText": "device().template binary_kernel_launcher<CoeffReturnType, ContractKernelName>( lhs, rhs, buffer, thread_range, scratchSize, groupSizeM, groupSizeN, numTilesPerGroup, triple_dim)"
  },
  {
    "label": "CoeffReturnType()",
    "kind": "Method",
    "detail": "Function (} else { typedef TensorSycl::internal::TensorContractionKernel<CoeffReturnType,LhsScalar,RhsScalar,EvaluatorPointerType,LhsMapper,RhsMapper,StorageIndex,Properties,TripleDim,PacketAccess,input_mapper_properties,false,ct> ContractKernelName ; CoeffReturnType* temp_pointer = static_cast<)",
    "insertText": "CoeffReturnType(device().allocate_temp(triple_dim.M * triple_dim.N * groupSizeK * sizeof(CoeffReturnType)))"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (EvaluatorPointerType tmp_global_accessor =)",
    "insertText": "device().get(temp_pointer)"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "device().template binary_kernel_launcher<CoeffReturnType, ContractKernelName>( lhs, rhs, tmp_global_accessor, thread_range, scratchSize, groupSizeM, groupSizeN, numTilesPerGroup, triple_dim)"
  },
  {
    "label": "Op()",
    "kind": "Method",
    "detail": "Function (typedef Eigen::internal::SumReducer<CoeffReturnType> Op ; auto op =)",
    "insertText": "Op()"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (typedef TensorSycl::internal::SecondStepPartialReduction<CoeffReturnType,StorageIndex,EvaluatorPointerType,EvaluatorPointerType,Op> ReductionKernel ;)",
    "insertText": "device().template unary_kernel_launcher<CoeffReturnType, ReductionKernel>( tmp_global_accessor, buffer, cl::sycl::nd_range<1>(cl::sycl::range<1>(StorageIndex( Eigen::TensorSycl::internal::roundUp(triple_dim.M * triple_dim.N, localRange))), cl::sycl::range<1>(localRange)), StorageIndex(1), op, StorageIndex(triple_dim.M * triple_dim.N), groupSizeK)"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "device().deallocate_temp(temp_pointer)"
  },
  {
    "label": "LaunchVT()",
    "kind": "Method",
    "detail": "Function (} } # ifndef EIGEN_SYCL_DISABLE_GEMV template<bool is_lhs_vec,VectorMapper,TensorMapper,StorageIndex> void EIGEN_ALWAYS_INLINE)",
    "insertText": "LaunchVT(EvaluatorPointerType buffer, const VectorMapper &vec, const TensorMapper &mat, StorageIndex NC, StorageIndex C)"
  },
  {
    "label": "roundUp()",
    "kind": "Method",
    "detail": "Function (const StorageIndex nonContractDim = NC ; EIGEN_CONSTEXPR StorageIndex NCFactor = 1 ; EIGEN_CONSTEXPR StorageIndex CFactor = 1 ; EIGEN_CONSTEXPR StorageIndex NCWindow = 1 6 ; typedef Eigen::TensorSycl::internal::TVPanelSize<CoeffReturnType,StorageIndex,NCWindow,CFactor,NCFactor> Properties ; const StorageIndex roundUpC = Eigen::TensorSycl::)",
    "insertText": "roundUp(C, Properties::TileSizeDimC)"
  },
  {
    "label": "roundUpC()",
    "kind": "Method",
    "detail": "Function (const StorageIndex cNumGroups =)",
    "insertText": "roundUpC(Properties::LocalThreadSizeC * Properties::WorkLoadPerThreadC)"
  },
  {
    "label": "roundUp()",
    "kind": "Method",
    "detail": "Function (const StorageIndex roundUpNC = Eigen::TensorSycl::)",
    "insertText": "roundUp(nonContractDim, Properties::TileSizeDimNC)"
  },
  {
    "label": "roundUpNC()",
    "kind": "Method",
    "detail": "Function (const StorageIndex nCNumGroups =)",
    "insertText": "roundUpNC(Properties::LocalThreadSizeNC * Properties::WorkLoadPerThreadNC)"
  },
  {
    "label": "globalRange()",
    "kind": "Method",
    "detail": "Function (const StorageIndex)",
    "insertText": "globalRange(roundUpNC / (Properties::WorkLoadPerThreadNC)) * (roundUpC / (Properties::WorkLoadPerThreadC))"
  },
  {
    "label": "scratchSize()",
    "kind": "Method",
    "detail": "Function (const StorageIndex localRange = Properties::LocalThreadSizeNC* Properties::LocalThreadSizeC ; const StorageIndex)",
    "insertText": "scratchSize(Properties::WorkLoadPerThreadNC + CFactor)"
  },
  {
    "label": "CoeffReturnType()",
    "kind": "Method",
    "detail": "Function (typedef Eigen::TensorSycl::internal::GeneralVectorTensor<CoeffReturnType,EvaluatorPointerType,VectorMapper,TensorMapper,StorageIndex,Properties,CFactor,false,is_lhs_vec,false> ContractKernelName ; CoeffReturnType* temp_pointer = static_cast<)",
    "insertText": "CoeffReturnType(device().allocate_temp(nonContractDim * cNumGroups * sizeof(CoeffReturnType)))"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "device().template binary_kernel_launcher<CoeffReturnType, ContractKernelName>( vec, mat, tmp_global_accessor, thread_range, scratchSize, nCNumGroups, nonContractDim, C)"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (typedef Eigen::internal::SumReducer<CoeffReturnType> Op ; typedef TensorSycl::internal::SecondStepPartialReduction<CoeffReturnType,StorageIndex,EvaluatorPointerType,EvaluatorPointerType,Op> ReductionKernel ;)",
    "insertText": "device().template unary_kernel_launcher<CoeffReturnType, ReductionKernel>( tmp_global_accessor, buffer, cl::sycl::nd_range<1>(cl::sycl::range<1>(Eigen::TensorSycl::internal::roundUp(nonContractDim, localRange)), cl::sycl::range<1>(localRange)), StorageIndex(1), Op(), nonContractDim, cNumGroups)"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (} else { typedef Eigen::TensorSycl::internal::GeneralVectorTensor<CoeffReturnType,EvaluatorPointerType,VectorMapper,TensorMapper,StorageIndex,Properties,CFactor,false,is_lhs_vec,true> ContractKernelName ;)",
    "insertText": "device().template binary_kernel_launcher<CoeffReturnType, ContractKernelName>( vec, mat, buffer, thread_range, scratchSize, nCNumGroups, nonContractDim, C)"
  },
  {
    "label": "launchSC()",
    "kind": "Method",
    "detail": "Function (} } # endif # ifndef EIGEN_SYCL_DISABLE_SCALAR template<LhsMapper,RhsMapper> EIGEN_ALWAYS_INLINE void)",
    "insertText": "launchSC(EvaluatorPointerType buffer, const LhsMapper &lhs, const RhsMapper &rhs, StorageIndex K)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT(!((EIGEN_SYCL_LOCAL_THREAD_DIM0 * EIGEN_SYCL_LOCAL_THREAD_DIM1) & (EIGEN_SYCL_LOCAL_THREAD_DIM0 * EIGEN_SYCL_LOCAL_THREAD_DIM1 - 1)), \"The Local thread size must be a power of 2 for the reduction \" \"operation\")"
  },
  {
    "label": "num_work_group()",
    "kind": "Method",
    "detail": "Function (EIGEN_CONSTEXPR StorageIndex local_range = EIGEN_SYCL_LOCAL_THREAD_DIM0* EIGEN_SYCL_LOCAL_THREAD_DIM1 ; const StorageIndex)",
    "insertText": "num_work_group((K + (512 * local_range - 1)) / (512 * local_range) > 1 ? local_range : 1)"
  },
  {
    "label": "nd_range()",
    "kind": "Method",
    "detail": "Function (const StorageIndex global_range = num_work_group* local_range ; typedef Eigen::TensorSycl::internal::GeneralScalarContraction<CoeffReturnType,LhsScalar,RhsScalar,EvaluatorPointerType,LhsMapper,RhsMapper,StorageIndex,false> ContractKernelName ; auto thread_range = cl::)",
    "insertText": "nd_range(cl::sycl::range<1>(global_range), cl::sycl::range<1>(local_range))"
  },
  {
    "label": "CoeffReturnType()",
    "kind": "Method",
    "detail": "Function (CoeffReturnType* temp_pointer = static_cast<)",
    "insertText": "CoeffReturnType(device().allocate_temp(num_work_group * sizeof(CoeffReturnType)))"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "device().template binary_kernel_launcher<CoeffReturnType, ContractKernelName>(lhs, rhs, tmp_global_accessor, thread_range, local_range, K)"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (typedef Eigen::internal::SumReducer<CoeffReturnType> Op ; typedef TensorSycl::internal::SecondStepFullReducer<CoeffReturnType,Op,EvaluatorPointerType,EvaluatorPointerType,StorageIndex,local_range> GenericRKernel ;)",
    "insertText": "device().template unary_kernel_launcher<CoeffReturnType, GenericRKernel>( tmp_global_accessor, buffer, cl::sycl::nd_range<1>(cl::sycl::range<1>(local_range), cl::sycl::range<1>(local_range)), local_range, Op())"
  },
  {
    "label": "device()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "device().template binary_kernel_launcher<CoeffReturnType, ContractKernelName>(lhs, rhs, buffer, thread_range, local_range, K)"
  },
  {
    "label": "cleanup()",
    "kind": "Method",
    "detail": "Function (} } # endif EIGEN_STRONG_INLINE void)",
    "insertText": "cleanup()"
  },
  {
    "label": "deallocate_temp()",
    "kind": "Method",
    "detail": "Function (this -> m_device .)",
    "insertText": "deallocate_temp(this->m_result)"
  },
  {
    "label": "bind()",
    "kind": "Method",
    "detail": "Function (this -> m_result = NULL ; } } EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "bind(cl::sycl::handler &cgh)"
  },
  {
    "label": "bind()",
    "kind": "Method",
    "detail": "Function (this -> m_leftImpl .)",
    "insertText": "bind(cgh)"
  }
]