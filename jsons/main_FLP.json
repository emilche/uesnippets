[
  {
    "label": "silk_HP_variable_cutoff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_HP_variable_cutoff(\n    silk_encoder_state_Fxx          state_Fxx[]                         /* I/O  Encoder states                              */\n)"
  },
  {
    "label": "silk_encode_do_VAD_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_encode_do_VAD_FLP(\n    silk_encoder_state_FLP          *psEnc,                             /* I/O  Encoder state FLP                           */\n    opus_int                        activity                            /* I    Decision of Opus voice activity detector    */\n)"
  },
  {
    "label": "silk_encode_frame_FLP()",
    "kind": "Method",
    "detail": "Function (opus_int)",
    "insertText": "silk_encode_frame_FLP(\n    silk_encoder_state_FLP          *psEnc,                             /* I/O  Encoder state FLP                           */\n    opus_int32                      *pnBytesOut,                        /* O    Number of payload bytes;                    */\n    ec_enc                          *psRangeEnc,                        /* I/O  compressor data structure                   */\n    opus_int                        condCoding,                         /* I    The type of conditional coding to use       */\n    opus_int                        maxBits,                            /* I    If > 0: maximum number of output bits       */\n    opus_int                        useCBR                              /* I    Flag to force constant-bitrate operation    */\n)"
  },
  {
    "label": "silk_init_encoder()",
    "kind": "Method",
    "detail": "Function (opus_int)",
    "insertText": "silk_init_encoder(\n    silk_encoder_state_FLP          *psEnc,                             /* I/O  Encoder state FLP                           */\n    int                              arch                               /* I    Run-tim architecture                        */\n)"
  },
  {
    "label": "silk_control_encoder()",
    "kind": "Method",
    "detail": "Function (opus_int)",
    "insertText": "silk_control_encoder(\n    silk_encoder_state_FLP          *psEnc,                             /* I/O  Pointer to Silk encoder state FLP           */\n    silk_EncControlStruct           *encControl,                        /* I    Control structure                           */\n    const opus_int                  allow_bw_switch,                    /* I    Flag to allow switching audio bandwidth     */\n    const opus_int                  channelNb,                          /* I    Channel number                              */\n    const opus_int                  force_fs_kHz\n)"
  },
  {
    "label": "silk_noise_shape_analysis_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_noise_shape_analysis_FLP(\n    silk_encoder_state_FLP          *psEnc,                             /* I/O  Encoder state FLP                           */\n    silk_encoder_control_FLP        *psEncCtrl,                         /* I/O  Encoder control FLP                         */\n    const silk_float                *pitch_res,                         /* I    LPC residual from pitch analysis            */\n    const silk_float                *x                                  /* I    Input signal [frame_length + la_shape]      */\n)"
  },
  {
    "label": "silk_LTP_scale_ctrl_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_LTP_scale_ctrl_FLP(\n    silk_encoder_state_FLP          *psEnc,                             /* I/O  Encoder state FLP                           */\n    silk_encoder_control_FLP        *psEncCtrl,                         /* I/O  Encoder control FLP                         */\n    opus_int                        condCoding                          /* I    The type of conditional coding to use       */\n)"
  },
  {
    "label": "silk_find_pitch_lags_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_find_pitch_lags_FLP(\n    silk_encoder_state_FLP          *psEnc,                             /* I/O  Encoder state FLP                           */\n    silk_encoder_control_FLP        *psEncCtrl,                         /* I/O  Encoder control FLP                         */\n    silk_float                      res[],                              /* O    Residual                                    */\n    const silk_float                x[],                                /* I    Speech signal                               */\n    int                             arch                                /* I    Run-time architecture                       */\n)"
  },
  {
    "label": "silk_find_pred_coefs_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_find_pred_coefs_FLP(\n    silk_encoder_state_FLP          *psEnc,                             /* I/O  Encoder state FLP                           */\n    silk_encoder_control_FLP        *psEncCtrl,                         /* I/O  Encoder control FLP                         */\n    const silk_float                res_pitch[],                        /* I    Residual from pitch analysis                */\n    const silk_float                x[],                                /* I    Speech signal                               */\n    opus_int                        condCoding                          /* I    The type of conditional coding to use       */\n)"
  },
  {
    "label": "silk_find_LTP_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_find_LTP_FLP(\n    silk_float                      XX[ MAX_NB_SUBFR * LTP_ORDER * LTP_ORDER ], /* O    Weight for LTP quantization         */\n    silk_float                      xX[ MAX_NB_SUBFR * LTP_ORDER ],     /* O    Weight for LTP quantization                 */\n    const silk_float                r_ptr[],                            /* I    LPC residual                                */\n    const opus_int                  lag[  MAX_NB_SUBFR ],               /* I    LTP lags                                    */\n    const opus_int                  subfr_length,                       /* I    Subframe length                             */\n    const opus_int                  nb_subfr                            /* I    number of subframes                         */\n)"
  },
  {
    "label": "silk_residual_energy_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_residual_energy_FLP(\n    silk_float                      nrgs[ MAX_NB_SUBFR ],               /* O    Residual energy per subframe                */\n    const silk_float                x[],                                /* I    Input signal                                */\n    silk_float                      a[ 2 ][ MAX_LPC_ORDER ],            /* I    AR coefs for each frame half                */\n    const silk_float                gains[],                            /* I    Quantization gains                          */\n    const opus_int                  subfr_length,                       /* I    Subframe length                             */\n    const opus_int                  nb_subfr,                           /* I    number of subframes                         */\n    const opus_int                  LPC_order                           /* I    LPC order                                   */\n)"
  },
  {
    "label": "silk_LPC_analysis_filter_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_LPC_analysis_filter_FLP(\n    silk_float                      r_LPC[],                            /* O    LPC residual signal                         */\n    const silk_float                PredCoef[],                         /* I    LPC coefficients                            */\n    const silk_float                s[],                                /* I    Input signal                                */\n    const opus_int                  length,                             /* I    Length of input signal                      */\n    const opus_int                  Order                               /* I    LPC order                                   */\n)"
  },
  {
    "label": "silk_quant_LTP_gains_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_quant_LTP_gains_FLP(\n    silk_float                      B[ MAX_NB_SUBFR * LTP_ORDER ],      /* O    Quantized LTP gains                         */\n    opus_int8                       cbk_index[ MAX_NB_SUBFR ],          /* O    Codebook index                              */\n    opus_int8                       *periodicity_index,                 /* O    Periodicity index                           */\n    opus_int32                      *sum_log_gain_Q7,                   /* I/O  Cumulative max prediction gain  */\n    silk_float                      *pred_gain_dB,                      /* O    LTP prediction gain                         */\n    const silk_float                XX[ MAX_NB_SUBFR * LTP_ORDER * LTP_ORDER ], /* I    Correlation matrix                  */\n    const silk_float                xX[ MAX_NB_SUBFR * LTP_ORDER ],     /* I    Correlation vector                          */\n    const opus_int                  subfr_len,                          /* I    Number of samples per subframe              */\n    const opus_int                  nb_subfr,                           /* I    Number of subframes                         */\n    int                             arch                                /* I    Run-time architecture                       */\n)"
  },
  {
    "label": "silk_residual_energy_covar_FLP()",
    "kind": "Method",
    "detail": "Function (silk_float)",
    "insertText": "silk_residual_energy_covar_FLP(                              /* O    Weighted residual energy                    */\n    const silk_float                *c,                                 /* I    Filter coefficients                         */\n    silk_float                      *wXX,                               /* I/O  Weighted correlation matrix, reg. out       */\n    const silk_float                *wXx,                               /* I    Weighted correlation vector                 */\n    const silk_float                wxx,                                /* I    Weighted correlation value                  */\n    const opus_int                  D                                   /* I    Dimension                                   */\n)"
  },
  {
    "label": "silk_process_gains_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_process_gains_FLP(\n    silk_encoder_state_FLP          *psEnc,                             /* I/O  Encoder state FLP                           */\n    silk_encoder_control_FLP        *psEncCtrl,                         /* I/O  Encoder control FLP                         */\n    opus_int                        condCoding                          /* I    The type of conditional coding to use       */\n)"
  },
  {
    "label": "silk_corrMatrix_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_corrMatrix_FLP(\n    const silk_float                *x,                                 /* I    x vector [ L+order-1 ] used to create X     */\n    const opus_int                  L,                                  /* I    Length of vectors                           */\n    const opus_int                  Order,                              /* I    Max lag for correlation                     */\n    silk_float                      *XX                                 /* O    X'*X correlation matrix [order x order]     */\n)"
  },
  {
    "label": "silk_corrVector_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_corrVector_FLP(\n    const silk_float                *x,                                 /* I    x vector [L+order-1] used to create X       */\n    const silk_float                *t,                                 /* I    Target vector [L]                           */\n    const opus_int                  L,                                  /* I    Length of vecors                            */\n    const opus_int                  Order,                              /* I    Max lag for correlation                     */\n    silk_float                      *Xt                                 /* O    X'*t correlation vector [order]             */\n)"
  },
  {
    "label": "silk_apply_sine_window_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_apply_sine_window_FLP(\n    silk_float                      px_win[],                           /* O    Pointer to windowed signal                  */\n    const silk_float                px[],                               /* I    Pointer to input signal                     */\n    const opus_int                  win_type,                           /* I    Selects a window type                       */\n    const opus_int                  length                              /* I    Window length, multiple of 4                */\n)"
  },
  {
    "label": "silk_A2NLSF_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_A2NLSF_FLP(\n    opus_int16                      *NLSF_Q15,                          /* O    NLSF vector      [ LPC_order ]              */\n    const silk_float                *pAR,                               /* I    LPC coefficients [ LPC_order ]              */\n    const opus_int                  LPC_order                           /* I    LPC order                                   */\n)"
  },
  {
    "label": "silk_NLSF2A_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_NLSF2A_FLP(\n    silk_float                      *pAR,                               /* O    LPC coefficients [ LPC_order ]              */\n    const opus_int16                *NLSF_Q15,                          /* I    NLSF vector      [ LPC_order ]              */\n    const opus_int                  LPC_order,                          /* I    LPC order                                   */\n    int                             arch                                /* I    Run-time architecture                       */\n)"
  },
  {
    "label": "silk_NSQ_wrapper_FLP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "silk_NSQ_wrapper_FLP(\n    silk_encoder_state_FLP          *psEnc,                             /* I/O  Encoder state FLP                           */\n    silk_encoder_control_FLP        *psEncCtrl,                         /* I/O  Encoder control FLP                         */\n    SideInfoIndices                 *psIndices,                         /* I/O  Quantization indices                        */\n    silk_nsq_state                  *psNSQ,                             /* I/O  Noise Shaping Quantzation state             */\n    opus_int8                       pulses[],                           /* O    Quantized pulse signal                      */\n    const silk_float                x[]                                 /* I    Prefiltered input signal                    */\n)"
  }
]