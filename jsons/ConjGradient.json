[
  {
    "label": "Vector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Vector"
  },
  {
    "label": "SparseStencilMatrix",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SparseStencilMatrix"
  },
  {
    "label": "Preconditioner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Preconditioner"
  },
  {
    "label": "JacobiPreconditioner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "JacobiPreconditioner"
  },
  {
    "label": "IncompleteCholeskyPreconditioner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IncompleteCholeskyPreconditioner"
  },
  {
    "label": "State",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "State"
  },
  {
    "label": "ScaleOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ScaleOp"
  },
  {
    "label": "DeterministicDotProductOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DeterministicDotProductOp"
  },
  {
    "label": "EqOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EqOp"
  },
  {
    "label": "InfNormOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InfNormOp"
  },
  {
    "label": "IsFiniteOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsFiniteOp"
  },
  {
    "label": "ConstValueIter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstValueIter"
  },
  {
    "label": "ConstRow",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstRow"
  },
  {
    "label": "RowEditor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RowEditor"
  },
  {
    "label": "RowData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RowData"
  },
  {
    "label": "ConstRowData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConstRowData"
  },
  {
    "label": "RowBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RowBase"
  },
  {
    "label": "MatrixCopyOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MatrixCopyOp"
  },
  {
    "label": "VecMultOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VecMultOp"
  },
  {
    "label": "RowScaleOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RowScaleOp"
  },
  {
    "label": "CopyOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CopyOp"
  },
  {
    "label": "FillOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FillOp"
  },
  {
    "label": "LinearOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LinearOp"
  },
  {
    "label": "InitOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InitOp"
  },
  {
    "label": "ApplyOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ApplyOp"
  },
  {
    "label": "CopyToLowerOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CopyToLowerOp"
  },
  {
    "label": "TransposeOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TransposeOp"
  },
  {
    "label": "terminationDefaults()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_CONJGRADIENT_HAS_BEEN_INCLUDED # define OPENVDB_MATH_CONJGRADIENT_HAS_BEEN_INCLUDED # include<openvdb / Exceptions . h> # include<openvdb / Types . h> # include<openvdb / util / logging . h> # include<openvdb / util / NullInterrupter . h> # include \" Math . h \" # include<tbb / parallel_for . h> # include<tbb / parallel_reduce . h> # include<algorithm> # include<cassert> # include<cmath> # include<limits> # include<sstream> # include<string> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { namespace pcg { using SizeType = Index32 ; using SizeRange = tbb::blocked_range<SizeType> ; template<ValueType> class Vector ; template<ValueType,SizeType STENCIL_SIZE> class SparseStencilMatrix ; template<ValueType> class Preconditioner ; template<MatrixType> class JacobiPreconditioner ; template<MatrixType> class IncompleteCholeskyPreconditioner ; struct State { bool success ; int iterations ; double relativeError ; double absoluteError ; } ; template<ValueType> State)",
    "insertText": "terminationDefaults()"
  },
  {
    "label": "epsilon()",
    "kind": "Method",
    "detail": "Function (State s ; s . success = false ; s . iterations = 5 0 ; s . relativeError = 1 . 0 e - 6 ; s . absoluteError = std::numeric_limits<ValueType)",
    "insertText": "epsilon()"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (template<PositiveDefMatrix,Interrupter> State)",
    "insertText": "solve(const PositiveDefMatrix& A, const Vector<typename PositiveDefMatrix::ValueType>& b, Vector<typename PositiveDefMatrix::ValueType>& x, Preconditioner<typename PositiveDefMatrix::ValueType>& preconditioner, Interrupter& interrupter, const State& termination = terminationDefaults<typename PositiveDefMatrix::ValueType>())"
  },
  {
    "label": "Vector()",
    "kind": "Method",
    "detail": "Function (template<T> class Vector { public : using ValueType = T ; using Ptr = SharedPtr<Vector> ;)",
    "insertText": "Vector(): mData(nullptr), mSize(0)"
  },
  {
    "label": "Vector()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Vector(SizeType n): mData(new T[n]), mSize(n)"
  },
  {
    "label": "Vector()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Vector(SizeType n, const ValueType& val): mData(new T[n]), mSize(n)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "fill(val)"
  },
  {
    "label": "Vector()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "Vector()"
  },
  {
    "label": "Vector()",
    "kind": "Method",
    "detail": "Function (mSize = 0 ; delete [ ] mData ; mData = nullptr ; })",
    "insertText": "Vector(const Vector&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Vector&)",
    "insertText": "operator(const Vector&)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (SizeType)",
    "insertText": "size()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resize(SizeType n)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(Vector& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(mData, other.mData)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(mSize, other.mSize)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "fill(const ValueType& value)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (template<Scalar> void)",
    "insertText": "scale(const Scalar& s)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<Scalar> Vector&)",
    "insertText": "operator(const Scalar& s)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "scale(s)"
  },
  {
    "label": "infNorm()",
    "kind": "Method",
    "detail": "Function (ValueType)",
    "insertText": "infNorm()"
  },
  {
    "label": "l2Norm()",
    "kind": "Method",
    "detail": "Function (ValueType)",
    "insertText": "l2Norm()"
  },
  {
    "label": "isFinite()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isFinite()"
  },
  {
    "label": "eq()",
    "kind": "Method",
    "detail": "Function (template<OtherValueType> bool)",
    "insertText": "eq(const Vector<OtherValueType>& other, ValueType eps = Tolerance<ValueType>::value())"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "str()"
  },
  {
    "label": "at()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "at(SizeType i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const T&)",
    "insertText": "operator(SizeType i)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "data()"
  },
  {
    "label": "SparseStencilMatrix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SparseStencilMatrix(const SparseStencilMatrix&)"
  },
  {
    "label": "numRows()",
    "kind": "Method",
    "detail": "Function (SizeType)",
    "insertText": "numRows()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "getValue(SizeType row, SizeType col)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "operator()(SizeType row, SizeType col)"
  },
  {
    "label": "getConstRow()",
    "kind": "Method",
    "detail": "Function (ConstRow)",
    "insertText": "getConstRow(SizeType row)"
  },
  {
    "label": "getRowEditor()",
    "kind": "Method",
    "detail": "Function (RowEditor)",
    "insertText": "getRowEditor(SizeType row)"
  },
  {
    "label": "vectorMultiply()",
    "kind": "Method",
    "detail": "Function (template<VecValueType> void)",
    "insertText": "vectorMultiply(const VecValueType* inVec, VecValueType* resultVec)"
  },
  {
    "label": "eq()",
    "kind": "Method",
    "detail": "Function (template<OtherValueType> bool)",
    "insertText": "eq(const SparseStencilMatrix<OtherValueType, STENCIL_SIZE>& other, ValueType eps = Tolerance<ValueType>::value())"
  },
  {
    "label": "RowData()",
    "kind": "Method",
    "detail": "Function (private : struct RowData {)",
    "insertText": "RowData(ValueType* v, SizeType* c, SizeType& s): mVals(v), mCols(c), mSize(s)"
  },
  {
    "label": "ConstRowData()",
    "kind": "Method",
    "detail": "Function (} ValueType* mVals ; SizeType* mCols ; SizeType& mSize ; } ; struct ConstRowData {)",
    "insertText": "ConstRowData(const ValueType* v, const SizeType* c, const SizeType& s): mVals(v), mCols(c), mSize(s)"
  },
  {
    "label": "capacity()",
    "kind": "Method",
    "detail": "Function (} const ValueType* mVals ; const SizeType* mCols ; const SizeType& mSize ; } ; template<DataType_ = RowData> class RowBase { public : using DataType = DataType_ ; SizeType)",
    "insertText": "capacity()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "getValue(SizeType columnIdx)"
  },
  {
    "label": "cbegin()",
    "kind": "Method",
    "detail": "Function (ConstValueIter)",
    "insertText": "cbegin()"
  },
  {
    "label": "eq()",
    "kind": "Method",
    "detail": "Function (template<OtherDataType> bool)",
    "insertText": "eq(const RowBase<OtherDataType>& other, ValueType eps = Tolerance<ValueType>::value())"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (template<VecValueType> VecValueType)",
    "insertText": "dot(const VecValueType* inVec, SizeType vecSize)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (template<VecValueType> VecValueType)",
    "insertText": "dot(const Vector<VecValueType>& inVec)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (protected : class ConstValueIter ; const ValueType&)",
    "insertText": "value(SizeType i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (DataType mData ; } ; using ConstRowBase = RowBase<ConstRowData> ; public : class ConstValueIter { public : const ValueType&)",
    "insertText": "operator()"
  },
  {
    "label": "increment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "increment()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reset()"
  },
  {
    "label": "ConstValueIter()",
    "kind": "Method",
    "detail": "Function (mCursor = 0 ; } private : class SparseStencilMatrix ;)",
    "insertText": "ConstValueIter(const RowData& d): mData(d.mVals, d.mCols, d.mSize), mCursor(0)"
  },
  {
    "label": "ConstValueIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ConstValueIter(const ConstRowData& d): mData(d), mCursor(0)"
  },
  {
    "label": "ConstRow()",
    "kind": "Method",
    "detail": "Function (} const ConstRowData mData ; SizeType mCursor ; } ; class ConstRow : public ConstRowBase { public :)",
    "insertText": "ConstRow(const ValueType* valueHead, const SizeType* columnHead, const SizeType& rowSize)"
  },
  {
    "label": "RowEditor()",
    "kind": "Method",
    "detail": "Function (} ; class RowEditor : public RowBase<> { public :)",
    "insertText": "RowEditor(ValueType* valueHead, SizeType* columnHead, SizeType& rowSize, SizeType colSize)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (SizeType)",
    "insertText": "setValue(SizeType column, const ValueType& value)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (template<Scalar> void)",
    "insertText": "scale(const Scalar&)"
  },
  {
    "label": "Preconditioner()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "Preconditioner()"
  },
  {
    "label": "isValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isValid()"
  },
  {
    "label": "CopyOp()",
    "kind": "Method",
    "detail": "Function (} ; namespace internal { template<T> struct CopyOp {)",
    "insertText": "CopyOp(const T* from_, T* to_): from(from_), to(to_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const SizeRange& range)"
  },
  {
    "label": "FillOp()",
    "kind": "Method",
    "detail": "Function (} const T* from ; T* to ; } ; template<T> struct FillOp {)",
    "insertText": "FillOp(T* data_, const T& val_): data(data_), val(val_)"
  },
  {
    "label": "LinearOp()",
    "kind": "Method",
    "detail": "Function (} T* data ; const T val ; } ; template<T> struct LinearOp {)",
    "insertText": "LinearOp(const T& a_, const T* x_, const T* y_, T* out_): a(a_), x(x_), y(y_), out(out_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(isExactlyEqual(a, T(-1)))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(SizeType n = range.begin(), N = range.end(); n < N; ++n)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } const T a,* x,* y ; T* out ; } ; } std::ostream&)",
    "insertText": "operator(std::ostream& os, const State& state)"
  },
  {
    "label": "os()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "os(state.success ? \"succeeded with \" : \"\") << \"rel. err. \" << state.relativeError << \", abs. err. \" << state.absoluteError << \" after \" << state.iterations << \" iteration\" << (state.iterations == 1 ? \"\" : \"s\")"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, mSize), internal::CopyOp<T>( other.mData, mData))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> Vector<T>& Vector<T)",
    "insertText": "operator(const Vector<T>& other)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, mSize), internal::FillOp<T>(mData, value))"
  },
  {
    "label": "ScaleOp()",
    "kind": "Method",
    "detail": "Function (} template<T> template<Scalar> struct Vector<T>::ScaleOp {)",
    "insertText": "ScaleOp(T* data_, const Scalar& s_): data(data_), s(s_)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, mSize), ScaleOp<Scalar>(mData, s))"
  },
  {
    "label": "DeterministicDotProductOp()",
    "kind": "Method",
    "detail": "Function (} template<T> struct Vector<T>::DeterministicDotProductOp {)",
    "insertText": "DeterministicDotProductOp(const T* a_, const T* b_, const SizeType binCount_, const SizeType arraySize_, T* reducetmp_): a(a_), b(b_), binCount(binCount_), arraySize(arraySize_), reducetmp(reducetmp_)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (const SizeType begin = n* binSize ; const SizeType)",
    "insertText": "end(n == binCount-1)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T sum = zeroVal<)",
    "insertText": "T()"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (sum + = a [ i ]* b [ i ] ; } reducetmp [ n ] = sum ; } } const T* a ; const T* b ; const SizeType binCount ; const SizeType arraySize ; T* reducetmp ; } ; template<T> T Vector<T)",
    "insertText": "dot(const Vector<T>& other)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(this->size() == other.size())"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (result + = aData [ n ]* bData [ n ] ; } } else { const SizeType binCount = 1 0 0 ; T partialSums [ 1 0 0 ] ;)",
    "insertText": "parallel_for(SizeRange(0, binCount), DeterministicDotProductOp(aData, bData, binCount, arraySize, partialSums))"
  },
  {
    "label": "InfNormOp()",
    "kind": "Method",
    "detail": "Function (result + = partialSums [ n ] ; } } return result ; } template<T> struct Vector<T>::InfNormOp {)",
    "insertText": "InfNormOp(const T* data_): data(data_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "operator()(const SizeRange& range, T maxValue)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (maxValue =)",
    "insertText": "Max(maxValue, Abs(data[n]))"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (T result =)",
    "insertText": "parallel_reduce(SizeRange(0, this->size()), zeroVal<T>(), InfNormOp(this->data()), [](T max1, T max2) { return Max(max1, max2); })"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator()(const SizeRange& range, bool finite)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (bool finite =)",
    "insertText": "parallel_reduce(SizeRange(0, this->size()), true, IsFiniteOp(this->data()), [](bool finite1, bool finite2) { return (finite1 && finite2); })"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator()(const SizeRange& range, bool equal)"
  },
  {
    "label": "eq()",
    "kind": "Method",
    "detail": "Function (} } return equal ; } const T* a ; const OtherValueType* b ; const T eps ; } ; template<T> template<OtherValueType> bool Vector<T)",
    "insertText": "eq(const Vector<OtherValueType>& other, ValueType eps)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (bool equal =)",
    "insertText": "parallel_reduce(SizeRange(0, this->size()), true, EqOp<OtherValueType>(this->data(), other.data(), eps), [](bool eq1, bool eq2) { return (eq1 && eq2); })"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::ostringstream ostr ; ostr<<\" [ \" ; std::string sep ;)",
    "insertText": "for(SizeType n = 0, N = this->size(); n < N; ++n)"
  },
  {
    "label": "sep()",
    "kind": "Method",
    "detail": "Function (ostr<<)",
    "insertText": "sep(*this)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> const ValueType SparseStencilMatrix<ValueType,STENCIL_SIZE>::sZeroValue = zeroVal<)",
    "insertText": "ValueType()"
  },
  {
    "label": "SparseStencilMatrix()",
    "kind": "Method",
    "detail": "Function (template<ValueType,SizeType STENCIL_SIZE> SparseStencilMatrix<ValueType,STENCIL_SIZE)",
    "insertText": "SparseStencilMatrix(SizeType numRows) : mNumRows(numRows) , mValueArray(new ValueType[mNumRows * STENCIL_SIZE]) , mColumnIdxArray(new SizeType[mNumRows * STENCIL_SIZE]) , mRowSizeArray(new SizeType[mNumRows])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, mNumRows), internal::FillOp<SizeType>(mRowSizeArray.get(), 0))"
  },
  {
    "label": "MatrixCopyOp()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> struct SparseStencilMatrix<ValueType,STENCIL_SIZE>::MatrixCopyOp {)",
    "insertText": "MatrixCopyOp(const SparseStencilMatrix& from_, SparseStencilMatrix& to_): from(&from_), to(&to_)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (const ValueType* fromVal = from -> mValueArray .)",
    "insertText": "get()"
  },
  {
    "label": "SparseStencilMatrix()",
    "kind": "Method",
    "detail": "Function (toVal [ n ] = fromVal [ n ] ; toCol [ n ] = fromCol [ n ] ; } } const SparseStencilMatrix* from ; SparseStencilMatrix* to ; } ; template<ValueType,SizeType STENCIL_SIZE> SparseStencilMatrix<ValueType,STENCIL_SIZE)",
    "insertText": "SparseStencilMatrix(const SparseStencilMatrix& other) : mNumRows(other.mNumRows) , mValueArray(new ValueType[mNumRows * STENCIL_SIZE]) , mColumnIdxArray(new SizeType[mNumRows * STENCIL_SIZE]) , mRowSizeArray(new SizeType[mNumRows])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (SizeType size = mNumRows* STENCIL_SIZE ;)",
    "insertText": "parallel_for(SizeRange(0, size), MatrixCopyOp( other, *this))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, mNumRows), internal::CopyOp<SizeType>( other.mRowSizeArray.get(), mRowSizeArray.get()))"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> void SparseStencilMatrix<ValueType,STENCIL_SIZE)",
    "insertText": "setValue(SizeType row, SizeType col, const ValueType& val)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(row < mNumRows)"
  },
  {
    "label": "getRowEditor()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "getRowEditor(row).setValue(col, val)"
  },
  {
    "label": "RowScaleOp()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> template<Scalar> struct SparseStencilMatrix<ValueType,STENCIL_SIZE>::RowScaleOp {)",
    "insertText": "RowScaleOp(SparseStencilMatrix& m, const Scalar& s_): mat(&m), s(s_)"
  },
  {
    "label": "getRowEditor()",
    "kind": "Method",
    "detail": "Function (RowEditor row = mat ->)",
    "insertText": "getRowEditor(n)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, mNumRows), RowScaleOp<Scalar>(*this, s))"
  },
  {
    "label": "VecMultOp()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> template<VecValueType> struct SparseStencilMatrix<ValueType,STENCIL_SIZE>::VecMultOp {)",
    "insertText": "VecMultOp(const SparseStencilMatrix& m, const VecValueType* i, VecValueType* o): mat(&m), in(i), out(o)"
  },
  {
    "label": "getConstRow()",
    "kind": "Method",
    "detail": "Function (ConstRow row = mat ->)",
    "insertText": "getConstRow(n)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (out [ n ] = row .)",
    "insertText": "dot(in, mat->numRows())"
  },
  {
    "label": "vectorMultiply()",
    "kind": "Method",
    "detail": "Function (} } const SparseStencilMatrix* mat ; const VecValueType* in ; VecValueType* out ; } ; template<ValueType,SizeType STENCIL_SIZE> template<VecValueType> void SparseStencilMatrix<ValueType,STENCIL_SIZE)",
    "insertText": "vectorMultiply(const Vector<VecValueType>& inVec, Vector<VecValueType>& resultVec)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"matrix and input vector have incompatible sizes (\" << mNumRows << \"x\" << mNumRows << \" vs. \" << inVec.size() << \")\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(resultVec.size() != mNumRows)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"matrix and result vector have incompatible sizes (\" << mNumRows << \"x\" << mNumRows << \" vs. \" << resultVec.size() << \")\")"
  },
  {
    "label": "vectorMultiply()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "vectorMultiply(inVec.data(), resultVec.data())"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, mNumRows), VecMultOp<VecValueType>(*this, inVec, resultVec))"
  },
  {
    "label": "EqOp()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> template<OtherValueType> struct SparseStencilMatrix<ValueType,STENCIL_SIZE>::EqOp {)",
    "insertText": "EqOp(const SparseStencilMatrix& a_, const SparseStencilMatrix<OtherValueType, STENCIL_SIZE>& b_, ValueType e): a(&a_), b(&b_), eps(e)"
  },
  {
    "label": "eq()",
    "kind": "Method",
    "detail": "Function (} } return equal ; } const SparseStencilMatrix* a ; const SparseStencilMatrix<OtherValueType,STENCIL_SIZE>* b ; const ValueType eps ; } ; template<ValueType,SizeType STENCIL_SIZE> template<OtherValueType> bool SparseStencilMatrix<ValueType,STENCIL_SIZE)",
    "insertText": "eq(const SparseStencilMatrix<OtherValueType, STENCIL_SIZE>& other, ValueType eps)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (bool equal =)",
    "insertText": "parallel_reduce(SizeRange(0, this->numRows()), true, EqOp<OtherValueType>(*this, other, eps), [](bool eq1, bool eq2) { return (eq1 && eq2); })"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (bool finite =)",
    "insertText": "parallel_reduce(SizeRange(0, this->numRows()), true, IsFiniteOp(*this), [](bool finite1, bool finite2) { return (finite1&&finite2); })"
  },
  {
    "label": "getConstRow()",
    "kind": "Method",
    "detail": "Function (ostr<<n<<\" : \"<<this ->)",
    "insertText": "getConstRow(n).str()"
  },
  {
    "label": "getRowEditor()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> SparseStencilMatrix<ValueType,STENCIL_SIZE>::RowEditor SparseStencilMatrix<ValueType,STENCIL_SIZE)",
    "insertText": "getRowEditor(SizeType i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < mNumRows)"
  },
  {
    "label": "RowEditor()",
    "kind": "Method",
    "detail": "Function (const SizeType head = i* STENCIL_SIZE ; return)",
    "insertText": "RowEditor(&mValueArray[head], &mColumnIdxArray[head], mRowSizeArray[i], mNumRows)"
  },
  {
    "label": "getConstRow()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> SparseStencilMatrix<ValueType,STENCIL_SIZE>::ConstRow SparseStencilMatrix<ValueType,STENCIL_SIZE)",
    "insertText": "getConstRow(SizeType i)"
  },
  {
    "label": "ConstRow()",
    "kind": "Method",
    "detail": "Function (const SizeType head = i* STENCIL_SIZE ; return)",
    "insertText": "ConstRow(&mValueArray[head], &mColumnIdxArray[head], mRowSizeArray[i])"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> template<DataType> SizeType SparseStencilMatrix<ValueType,STENCIL_SIZE>::RowBase<DataType)",
    "insertText": "find(SizeType columnIdx)"
  },
  {
    "label": "lower_bound()",
    "kind": "Method",
    "detail": "Function (const SizeType* colPtr =)",
    "insertText": "lower_bound(mData.mCols, mData.mCols + mData.mSize, columnIdx)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> template<DataType> const ValueType& SparseStencilMatrix<ValueType,STENCIL_SIZE>::RowBase<DataType)",
    "insertText": "getValue(SizeType columnIdx, bool& active)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (active = false ; SizeType idx = this ->)",
    "insertText": "find(columnIdx)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (active = true ; return this ->)",
    "insertText": "value(idx)"
  },
  {
    "label": "eq()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> template<DataType> template<OtherDataType> bool SparseStencilMatrix<ValueType,STENCIL_SIZE>::RowBase<DataType)",
    "insertText": "eq(const RowBase<OtherDataType>& other, ValueType eps)"
  },
  {
    "label": "VecValueType()",
    "kind": "Method",
    "detail": "Function (VecValueType result = zeroVal<)",
    "insertText": "VecValueType()"
  },
  {
    "label": "VecValueType()",
    "kind": "Method",
    "detail": "Function (result + = static_cast<)",
    "insertText": "VecValueType(this->value(idx) * inVec[this->column(idx)])"
  },
  {
    "label": "sep()",
    "kind": "Method",
    "detail": "Function (ostr<<)",
    "insertText": "sep(\" << this->column(n) << \", \" << this->value(n) << \")"
  },
  {
    "label": "ConstRow()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> SparseStencilMatrix<ValueType,STENCIL_SIZE>::)",
    "insertText": "ConstRow(const ValueType* valueHead, const SizeType* columnHead, const SizeType& rowSize): ConstRowBase(ConstRowData(const_cast<ValueType*>(valueHead), const_cast<SizeType*>(columnHead), const_cast<SizeType&>(rowSize)))"
  },
  {
    "label": "RowEditor()",
    "kind": "Method",
    "detail": "Function (} template<ValueType,SizeType STENCIL_SIZE> SparseStencilMatrix<ValueType,STENCIL_SIZE>::)",
    "insertText": "RowEditor(ValueType* valueHead, SizeType* columnHead, SizeType& rowSize, SizeType colSize): RowBase<>(RowData(valueHead, columnHead, rowSize)), mNumColumns(colSize)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(column < mNumColumns)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (RowData& data = RowBase<>::mData ; SizeType offset = this ->)",
    "insertText": "find(column)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (data . mVals [ offset ] = value ; return data . mSize ; })",
    "insertText": "assert(data.mSize < this->capacity())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (data . mVals [ data . mSize ] = value ; data . mCols [ data . mSize ] = column ; } else {)",
    "insertText": "for(SizeType i = data.mSize; i > offset; --i)"
  },
  {
    "label": "JacobiPreconditioner()",
    "kind": "Method",
    "detail": "Function (RowBase<>::mData . mVals [ idx ]* = s ; } } template<MatrixType> class JacobiPreconditioner : public Preconditioner<MatrixType::ValueType> { private : struct InitOp ; struct ApplyOp ; public : using ValueType = MatrixType::ValueType ; using BaseType = Preconditioner<ValueType> ; using VectorType = Vector<ValueType> ; using Ptr = SharedPtr<JacobiPreconditioner> ;)",
    "insertText": "JacobiPreconditioner(const MatrixType& A): BaseType(A), mDiag(A.numRows())"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, A.numRows()), InitOp(A, mDiag.data()))"
  },
  {
    "label": "JacobiPreconditioner()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "JacobiPreconditioner()"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "apply(const Vector<ValueType>& r, Vector<ValueType>& z)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(r.size() == z.size())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(r.size() == size)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, size), ApplyOp(mDiag.data(), r.data(), z.data()))"
  },
  {
    "label": "InitOp()",
    "kind": "Method",
    "detail": "Function (} private : struct InitOp {)",
    "insertText": "InitOp(const MatrixType& m, ValueType* v): mat(&m), vec(v)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ValueType val = mat ->)",
    "insertText": "getValue(n, n)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isApproxZero(val, ValueType(0.0001)))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (vec [ n ] = static_cast<)",
    "insertText": "ValueType(1.0 / val)"
  },
  {
    "label": "ApplyOp()",
    "kind": "Method",
    "detail": "Function (} } const MatrixType* mat ; ValueType* vec ; } ; struct ApplyOp {)",
    "insertText": "ApplyOp(const ValueType* x_, const ValueType* y_, ValueType* out_): x(x_), y(y_), out(out_)"
  },
  {
    "label": "IncompleteCholeskyPreconditioner()",
    "kind": "Method",
    "detail": "Function (} const ValueType* x,* y ; ValueType* out ; } ; VectorType mDiag ; } ; template<MatrixType> class IncompleteCholeskyPreconditioner : public Preconditioner<MatrixType::ValueType> { private : struct CopyToLowerOp ; struct TransposeOp ; public : using ValueType = MatrixType::ValueType ; using BaseType = Preconditioner<ValueType> ; using VectorType = Vector<ValueType> ; using Ptr = SharedPtr<IncompleteCholeskyPreconditioner> ; using TriangularMatrix = SparseStencilMatrix<ValueType,4> ; using TriangleConstRow = TriangularMatrix::ConstRow ; using TriangleRowEditor = TriangularMatrix::RowEditor ;)",
    "insertText": "IncompleteCholeskyPreconditioner(const MatrixType& matrix) : BaseType(matrix) , mLowerTriangular(matrix.numRows()) , mUpperTriangular(matrix.numRows()) , mTempVec(matrix.numRows())"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, numRows), CopyToLowerOp(matrix, mLowerTriangular))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (mPassedCompatibilityCondition = true ;)",
    "insertText": "for(SizeType k = 0; k < numRows; ++k)"
  },
  {
    "label": "getConstRow()",
    "kind": "Method",
    "detail": "Function (TriangleConstRow crow_k = mLowerTriangular .)",
    "insertText": "getConstRow(k)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (ValueType diagonalValue = crow_k .)",
    "insertText": "getValue(k)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (mPassedCompatibilityCondition = false ; break ; } diagonalValue =)",
    "insertText": "Sqrt(diagonalValue)"
  },
  {
    "label": "getRowEditor()",
    "kind": "Method",
    "detail": "Function (TriangleRowEditor row_k = mLowerTriangular .)",
    "insertText": "getRowEditor(k)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (row_k .)",
    "insertText": "setValue(k, diagonalValue)"
  },
  {
    "label": "column()",
    "kind": "Method",
    "detail": "Function (SizeType ii = citer .)",
    "insertText": "column()"
  },
  {
    "label": "getRowEditor()",
    "kind": "Method",
    "detail": "Function (TriangleRowEditor row_ii = mLowerTriangular .)",
    "insertText": "getRowEditor(ii)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (row_ii .)",
    "insertText": "setValue(k, *citer / diagonalValue)"
  },
  {
    "label": "getConstRow()",
    "kind": "Method",
    "detail": "Function (TriangleConstRow row_j = mLowerTriangular .)",
    "insertText": "getConstRow(j)"
  },
  {
    "label": "getConstRow()",
    "kind": "Method",
    "detail": "Function (TriangleConstRow crow_i = mLowerTriangular .)",
    "insertText": "getConstRow(i)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (ValueType a_ij = crow_i .)",
    "insertText": "getValue(j)"
  },
  {
    "label": "getRowEditor()",
    "kind": "Method",
    "detail": "Function (TriangleRowEditor row_i = mLowerTriangular .)",
    "insertText": "getRowEditor(i)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (a_ij - = a_ik* a_jk ; row_i .)",
    "insertText": "setValue(j, a_ij)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "parallel_for(SizeRange(0, numRows), TransposeOp(matrix, mLowerTriangular, mUpperTriangular))"
  },
  {
    "label": "IncompleteCholeskyPreconditioner()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "IncompleteCholeskyPreconditioner()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"invalid Cholesky decomposition\")"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (zVec .)",
    "insertText": "fill(zeroVal<ValueType>())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(rVec.size() == size)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(zVec.size() == size)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (ValueType diagonal = row .)",
    "insertText": "getValue(i)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (ValueType dot = row .)",
    "insertText": "dot(mTempVec)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (tmpData [)",
    "insertText": "i(rData[i] - dot)"
  },
  {
    "label": "OPENVDB_LOG_DEBUG_RUNTIME()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_LOG_DEBUG_RUNTIME(\"1 diagonal was \" << diagonal)"
  },
  {
    "label": "OPENVDB_LOG_DEBUG_RUNTIME()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_LOG_DEBUG_RUNTIME(\"1a diagonal \" << row.getValue(i))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(SizeType ii = 0; ii < size; ++ii)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (ValueType dot = row .)",
    "insertText": "dot(zVec)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (zData [)",
    "insertText": "i(tmpData[i] - dot)"
  },
  {
    "label": "OPENVDB_LOG_DEBUG_RUNTIME()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_LOG_DEBUG_RUNTIME(\"2 diagonal was \" << diagonal)"
  },
  {
    "label": "lowerMatrix()",
    "kind": "Method",
    "detail": "Function (} } } const TriangularMatrix&)",
    "insertText": "lowerMatrix()"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (outRow .)",
    "insertText": "setValue(it.column(), *it)"
  },
  {
    "label": "TransposeOp()",
    "kind": "Method",
    "detail": "Function (} } } const MatrixType* mat ; TriangularMatrix* lower ; } ; struct TransposeOp {)",
    "insertText": "TransposeOp(const MatrixType& m, const TriangularMatrix& l, TriangularMatrix& u): mat(&m), lower(&l), upper(&u)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (outRow .)",
    "insertText": "setValue(column, lower->getValue(column, n))"
  },
  {
    "label": "axpy()",
    "kind": "Method",
    "detail": "Function (} } } const MatrixType* mat ; const TriangularMatrix* lower ; TriangularMatrix* upper ; } ; TriangularMatrix mLowerTriangular ; TriangularMatrix mUpperTriangular ; Vector<ValueType> mTempVec ; bool mPassedCompatibilityCondition ; } ; namespace internal { template<T> void)",
    "insertText": "axpy(const T& a, const T* xVec, const T* yVec, T* resultVec, SizeType size)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, size), LinearOp<T>(a, xVec, yVec, resultVec))"
  },
  {
    "label": "axpy()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "axpy(const T& a, const Vector<T>& xVec, const Vector<T>& yVec, Vector<T>& result)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(xVec.size() == yVec.size())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(xVec.size() == result.size())"
  },
  {
    "label": "axpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "axpy(a, xVec.data(), yVec.data(), result.data(), xVec.size())"
  },
  {
    "label": "computeResidual()",
    "kind": "Method",
    "detail": "Function (} template<MatrixOperator,VecValueType> void)",
    "insertText": "computeResidual(const MatrixOperator& A, const VecValueType* x, const VecValueType* b, VecValueType* r)"
  },
  {
    "label": "vectorMultiply()",
    "kind": "Method",
    "detail": "Function (A .)",
    "insertText": "vectorMultiply(x, r)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(SizeRange(0, A.numRows()), LinearOp<VecValueType>(-1.0, r, b, r))"
  },
  {
    "label": "computeResidual()",
    "kind": "Method",
    "detail": "Function (} template<MatrixOperator,T> void)",
    "insertText": "computeResidual(const MatrixOperator& A, const Vector<T>& x, const Vector<T>& b, Vector<T>& r)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(x.size() == b.size())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(x.size() == r.size())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(x.size() == A.numRows())"
  },
  {
    "label": "computeResidual()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeResidual(A, x.data(), b.data(), r.data())"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (} } template<PositiveDefMatrix> State)",
    "insertText": "solve(const PositiveDefMatrix& Amat, const Vector<typename PositiveDefMatrix::ValueType>& bVec, Vector<typename PositiveDefMatrix::ValueType>& xVec, Preconditioner<typename PositiveDefMatrix::ValueType>& precond, const State& termination)"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (util::NullInterrupter interrupter ; return)",
    "insertText": "solve(Amat, bVec, xVec, precond, interrupter, termination)"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (} template<PositiveDefMatrix,Interrupter> State)",
    "insertText": "solve(const PositiveDefMatrix& Amat, const Vector<typename PositiveDefMatrix::ValueType>& bVec, Vector<typename PositiveDefMatrix::ValueType>& xVec, Preconditioner<typename PositiveDefMatrix::ValueType>& precond, Interrupter& interrupter, const State& termination)"
  },
  {
    "label": "OPENVDB_LOG_WARN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_LOG_WARN(\"pcg::solve(): matrix has dimension zero\")"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"A and b have incompatible sizes\" << size << \"x\" << size << \" vs. \" << bVec.size() << \")\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(size != xVec.size())"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"A and x have incompatible sizes\" << size << \"x\" << size << \" vs. \" << xVec.size() << \")\")"
  },
  {
    "label": "zVec()",
    "kind": "Method",
    "detail": "Function (} VectorType)",
    "insertText": "zVec(size)"
  },
  {
    "label": "pVec()",
    "kind": "Method",
    "detail": "Function (VectorType)",
    "insertText": "pVec(size)"
  },
  {
    "label": "qVec()",
    "kind": "Method",
    "detail": "Function (VectorType)",
    "insertText": "qVec(size)"
  },
  {
    "label": "isZero()",
    "kind": "Method",
    "detail": "Function (const ValueType infNormOfB =)",
    "insertText": "isZero(tmp) ? ValueType(1)"
  },
  {
    "label": "rVec()",
    "kind": "Method",
    "detail": "Function (VectorType)",
    "insertText": "rVec(size)"
  },
  {
    "label": "computeResidual()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeResidual(Amat, xVec, bVec, rVec)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(rVec.isFinite())"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (result . absoluteError = static_cast<)",
    "insertText": "double(rVec.infNorm())"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (result . relativeError = static_cast<)",
    "insertText": "double(result.absoluteError / infNormOfB)"
  },
  {
    "label": "rDotZPrev()",
    "kind": "Method",
    "detail": "Function (result . success = true ; return result ; } ValueType)",
    "insertText": "rDotZPrev(1)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (ValueType minL2Error = std::numeric_limits<ValueType)",
    "insertText": "max()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (ValueType l2Error ; int iteration = 0 ;)",
    "insertText": "for(; iteration < termination.iterations; ++iteration)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(RuntimeError, \"conjugate gradient solver was interrupted\")"
  },
  {
    "label": "OPENVDB_LOG_DEBUG_RUNTIME()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "OPENVDB_LOG_DEBUG_RUNTIME(\"pcg::solve() \" << result)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (result . iterations = iteration + 1 ; precond .)",
    "insertText": "apply(rVec, zVec)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(std::isfinite(rDotZ))"
  },
  {
    "label": "axpy()",
    "kind": "Method",
    "detail": "Function (pVec = zVec ; } else { const ValueType beta = rDotZ / rDotZPrev ;)",
    "insertText": "axpy(beta, pVec, zVec, pVec)"
  },
  {
    "label": "vectorMultiply()",
    "kind": "Method",
    "detail": "Function (} Amat .)",
    "insertText": "vectorMultiply(pVec, qVec)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (const ValueType pAp = pVec .)",
    "insertText": "dot(qVec)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(std::isfinite(pAp))"
  },
  {
    "label": "axpy()",
    "kind": "Method",
    "detail": "Function (const ValueType alpha = rDotZ / pAp ; rDotZPrev = rDotZ ;)",
    "insertText": "axpy(alpha, pVec, xVec, xVec)"
  },
  {
    "label": "axpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "axpy(-alpha, qVec, rVec, rVec)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (minL2Error =)",
    "insertText": "Min(l2Error, minL2Error)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (result . success = false ; break ; })",
    "insertText": "if(!std::isfinite(result.absoluteError))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (result . success = false ; break ; })",
    "insertText": "if(result.absoluteError <= termination.absoluteError)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (result . success = true ; break ; })",
    "insertText": "if(result.relativeError <= termination.relativeError)"
  }
]