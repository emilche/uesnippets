[
  {
    "label": "TPolygon2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPolygon2"
  },
  {
    "label": "SegmentIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SegmentIterator"
  },
  {
    "label": "SegmentEnumerable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SegmentEnumerable"
  },
  {
    "label": "TPolygon2()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Templates / UnrealTemplate . h \" # include \" Math / UnrealMath . h \" # include \" VectorTypes . h \" # include \" BoxTypes . h \" # include \" SegmentTypes . h \" # include \" LineTypes . h \" # include \" MathUtil . h \" # include \" Intersection / IntrSegment2Segment2 . h \" # include \" Curve / CurveUtil . h \" # include \" Algo / Reverse . h \" namespace UE { namespace Geometry { using namespace UE::Math ; template<T> class TPolygon2 { protected : TArray<TVector2<T>> Vertices ; public :)",
    "insertText": "TPolygon2()"
  },
  {
    "label": "TPolygon2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TPolygon2(const TArray<TVector2<T>>& VertexList) : Vertices(VertexList)"
  },
  {
    "label": "TPolygon2()",
    "kind": "Method",
    "detail": "Function (} template<OtherVertexType>)",
    "insertText": "TPolygon2(const TArray<OtherVertexType>& VertexList)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Reserve(VertexList.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Add(TVector2<T>(OtherVtx.X, OtherVtx.Y))"
  },
  {
    "label": "TPolygon2()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TPolygon2(TArrayView<const TVector2<T>> VertexArray, TArrayView<const int32> VertexIndices)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "SetNum(VertexIndices.Num())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Vertices [ Idx ] = VertexArray [ VertexIndices [ Idx ] ] ; } } const TVector2<T>&)",
    "insertText": "operator(int Index)"
  },
  {
    "label": "AppendVertex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendVertex(const TVector2<T>& Position)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Add(Position)"
  },
  {
    "label": "AppendVertices()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendVertices(const TArray<TVector2<T>>& NewVertices)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Append(NewVertices)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(int VertexIndex, const TVector2<T>& Position)"
  },
  {
    "label": "RemoveVertex()",
    "kind": "Method",
    "detail": "Function (Vertices [ VertexIndex ] = Position ; } void)",
    "insertText": "RemoveVertex(int VertexIndex)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "RemoveAt(VertexIndex)"
  },
  {
    "label": "SetVertices()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetVertices(const TArray<TVector2<T>>& NewVertices)"
  },
  {
    "label": "Reverse()",
    "kind": "Method",
    "detail": "Function (Vertices = NewVertices ; } void)",
    "insertText": "Reverse()"
  },
  {
    "label": "Reverse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reverse(Vertices)"
  },
  {
    "label": "GetTangent()",
    "kind": "Method",
    "detail": "Function (} TVector2<T>)",
    "insertText": "GetTangent(int VertexIndex)"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (} TVector2<T>)",
    "insertText": "GetNormal(int VertexIndex)"
  },
  {
    "label": "GetNormal_FaceAvg()",
    "kind": "Method",
    "detail": "Function (} TVector2<T>)",
    "insertText": "GetNormal_FaceAvg(int VertexIndex)"
  },
  {
    "label": "Bounds()",
    "kind": "Method",
    "detail": "Function (} TAxisAlignedBox2<T>)",
    "insertText": "Bounds()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} class SegmentIterator { public : bool)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (i + + ; return* this ; } SegmentIterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (SegmentIterator)",
    "insertText": "copy(*this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (i + + ; return copy ; } bool)",
    "insertText": "operator(const SegmentIterator & i2)"
  },
  {
    "label": "SegmentItr()",
    "kind": "Method",
    "detail": "Function (} class TPolygon2 ; } ; class SegmentIterator ; SegmentIterator)",
    "insertText": "SegmentItr()"
  },
  {
    "label": "SegmentEnumerable()",
    "kind": "Method",
    "detail": "Function (} class SegmentEnumerable { public : const TPolygon2<T>* polygon ;)",
    "insertText": "SegmentEnumerable() : polygon(nullptr)"
  },
  {
    "label": "SegmentEnumerable()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SegmentEnumerable(const TPolygon2<T> * p) : polygon(p)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} SegmentIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} SegmentIterator)",
    "insertText": "end()"
  },
  {
    "label": "Segments()",
    "kind": "Method",
    "detail": "Function (} } ; SegmentEnumerable)",
    "insertText": "Segments()"
  },
  {
    "label": "IsClockwise()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsClockwise()"
  },
  {
    "label": "SignedArea()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "SignedArea()"
  },
  {
    "label": "Area()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "Area()"
  },
  {
    "label": "Perimeter()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "Perimeter()"
  },
  {
    "label": "NeighbourPoints()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "NeighbourPoints(int VertexIdx, TVector2<T>& OutPrevNbr, TVector2<T>& OutNextNbr)"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (CurveUtil::GetPrevNext<T,TVector2<T>,)",
    "insertText": "true(Vertices, VertexIdx, OutPrevNbr, OutNextNbr)"
  },
  {
    "label": "NeighbourVectors()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "NeighbourVectors(int VertexIdx, TVector2<T>& OutToPrev, TVector2<T>& OutToNext, bool bNormalize = false)"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (CurveUtil::GetVectorsToPrevNext<T,TVector2<T>,)",
    "insertText": "true(Vertices, VertexIdx, OutToPrev, OutToNext, bNormalize)"
  },
  {
    "label": "OpeningAngleDeg()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "OpeningAngleDeg(int iVertex)"
  },
  {
    "label": "NeighbourVectors()",
    "kind": "Method",
    "detail": "Function (TVector2<T> e0,e1 ;)",
    "insertText": "NeighbourVectors(iVertex, e0, e1, true)"
  },
  {
    "label": "WindingIntegral()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "WindingIntegral(const TVector2<T>& QueryPoint)"
  },
  {
    "label": "IsConvex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsConvex(T RadiansTolerance = TMathUtil<T>::ZeroTolerance, bool bDegenerateIsConvex = true)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(const TVector2<T>& QueryPoint)"
  },
  {
    "label": "Overlaps()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Overlaps(const TPolygon2<T>& OtherPoly)"
  },
  {
    "label": "VertexCount()",
    "kind": "Method",
    "detail": "Function (int N = OtherPoly .)",
    "insertText": "VertexCount()"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (CurveUtil::ClipConvexToBounds<T,TVector2<T>,)",
    "insertText": "true(Vertices, Bounds.Min, Bounds.Max)"
  },
  {
    "label": "Intersects()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Intersects(const TPolygon2<T>& OtherPoly)"
  },
  {
    "label": "intr()",
    "kind": "Method",
    "detail": "Function (TIntrSegment2Segment2<T>)",
    "insertText": "intr(seg, oseg)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (bFoundIntersections = true ; OutArray .)",
    "insertText": "Add(intr.Point0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutArray .)",
    "insertText": "Add(intr.Point1)"
  },
  {
    "label": "Segment()",
    "kind": "Method",
    "detail": "Function (} } } } } return bFoundIntersections ; } TSegment2<T>)",
    "insertText": "Segment(int SegmentIndex)"
  },
  {
    "label": "GetSegmentPoint()",
    "kind": "Method",
    "detail": "Function (} TVector2<T>)",
    "insertText": "GetSegmentPoint(int SegmentIndex, T SegmentParam)"
  },
  {
    "label": "seg()",
    "kind": "Method",
    "detail": "Function (TSegment2<T>)",
    "insertText": "seg(Vertices[SegmentIndex], Vertices[(SegmentIndex + 1) % Vertices.Num()])"
  },
  {
    "label": "GetSegmentPointUnitParam()",
    "kind": "Method",
    "detail": "Function (} TVector2<T>)",
    "insertText": "GetSegmentPointUnitParam(int SegmentIndex, T SegmentParam)"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (} TVector2<T>)",
    "insertText": "GetNormal(int iSeg, T SegmentParam)"
  },
  {
    "label": "seg()",
    "kind": "Method",
    "detail": "Function (TSegment2<T>)",
    "insertText": "seg(Vertices[iSeg], Vertices[(iSeg + 1) % Vertices.Num()])"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "t((SegmentParam / seg.Extent) + 1.0)"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (TVector2<T> n0 =)",
    "insertText": "GetNormal(iSeg)"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (TVector2<T> n1 =)",
    "insertText": "GetNormal((iSeg + 1) % Vertices.Num())"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "DistanceSquared(const TVector2<T>& QueryPoint, int& NearestSegIndexOut, T& NearestSegParamOut)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (NearestSegIndexOut = - 1 ; NearestSegParamOut = TNumericLimits<T)",
    "insertText": "Max()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int N = Vertices .)",
    "insertText": "Num()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TSegment2<T> seg = TSegment2<)",
    "insertText": "T(Vertices[vi], Vertices[(vi + 1) % N])"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "t(QueryPoint - seg.Center).Dot(seg.Direction)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (d = UE::)",
    "insertText": "DistanceSquared(seg.EndPoint(), QueryPoint)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(t <= -seg.Extent)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (d = UE::)",
    "insertText": "DistanceSquared(seg.StartPoint(), QueryPoint)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "d(seg.PointAt(t) - QueryPoint).SquaredLength()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(d < dist)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (dist = d ; NearestSegIndexOut = vi ; NearestSegParamOut = TMathUtil<T)",
    "insertText": "Clamp(t, -seg.Extent, seg.Extent)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (} } return dist ; } T)",
    "insertText": "DistanceSquared(const TVector2<T>& QueryPoint)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (int seg ; T segt ; return)",
    "insertText": "DistanceSquared(QueryPoint, seg, segt)"
  },
  {
    "label": "AverageEdgeLength()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "AverageEdgeLength()"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (avg + =)",
    "insertText": "Distance(Vertices[i], Vertices[i - 1])"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (} avg + =)",
    "insertText": "Distance(Vertices[N - 1], Vertices[0])"
  },
  {
    "label": "Scale()",
    "kind": "Method",
    "detail": "Function (Vertices [ i ] + = Translate ; } return* this ; } TPolygon2<T>&)",
    "insertText": "Scale(const TVector2<T>& Scale, const TVector2<T>& Origin)"
  },
  {
    "label": "Scale()",
    "kind": "Method",
    "detail": "Function (Vertices [ i ] =)",
    "insertText": "Scale(Vertices[i] - Origin)"
  },
  {
    "label": "Transform()",
    "kind": "Method",
    "detail": "Function (} return* this ; } TPolygon2<T>&)",
    "insertText": "Transform(const TFunction<TVector2<T> (const TVector2<T>&)>& TransformFunc)"
  },
  {
    "label": "TransformFunc()",
    "kind": "Method",
    "detail": "Function (Vertices [ i ] =)",
    "insertText": "TransformFunc(Vertices[i])"
  },
  {
    "label": "VtxNormalOffset()",
    "kind": "Method",
    "detail": "Function (} return* this ; } void)",
    "insertText": "VtxNormalOffset(T OffsetDistance, bool bUseFaceAvg = false)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<TVector2<T>> NewVertices ; NewVertices .)",
    "insertText": "SetNumUninitialized(Vertices.Num())"
  },
  {
    "label": "GetNormal_FaceAvg()",
    "kind": "Method",
    "detail": "Function (NewVertices [ k ] = Vertices [ k ] + OffsetDistance*)",
    "insertText": "GetNormal_FaceAvg(k)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "for(int k = 0; k < Vertices.Num(); ++k)"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (NewVertices [ k ] = Vertices [ k ] + OffsetDistance*)",
    "insertText": "GetNormal(k)"
  },
  {
    "label": "PolyOffset()",
    "kind": "Method",
    "detail": "Function (Vertices [ k ] = NewVertices [ k ] ; } } void)",
    "insertText": "PolyOffset(T OffsetDistance)"
  },
  {
    "label": "Vertices()",
    "kind": "Method",
    "detail": "Function (TVector2<T> v = Vertices [ k ] ; TVector2<T> next =)",
    "insertText": "Vertices(k + 1) % Vertices.Num()"
  },
  {
    "label": "Normalized()",
    "kind": "Method",
    "detail": "Function (TVector2<T> dn =)",
    "insertText": "Normalized(next - v)"
  },
  {
    "label": "Normalized()",
    "kind": "Method",
    "detail": "Function (TVector2<T> dp =)",
    "insertText": "Normalized(prev - v)"
  },
  {
    "label": "ln()",
    "kind": "Method",
    "detail": "Function (TLine2<T>)",
    "insertText": "ln(v + OffsetDistance * PerpCW(dn), dn)"
  },
  {
    "label": "lp()",
    "kind": "Method",
    "detail": "Function (TLine2<T>)",
    "insertText": "lp(v - OffsetDistance * PerpCW(dp), dp)"
  },
  {
    "label": "IntersectionPoint()",
    "kind": "Method",
    "detail": "Function (bool bIntersectsAtPoint = ln .)",
    "insertText": "IntersectionPoint(lp, NewVertices[k])"
  },
  {
    "label": "SimplifyDouglasPeucker()",
    "kind": "Method",
    "detail": "Function (Vertices [ k ] = NewVertices [ k ] ; } } private : void)",
    "insertText": "SimplifyDouglasPeucker(T Tolerance, const TArray<TVector2<T>>& Vertices, int j, int k, TArray<bool>& Marked)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Marked .)",
    "insertText": "SetNum(Vertices.Num())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (int maxi = j ; T maxd2 = 0 ; T tol2 = Tolerance* Tolerance ; TSegment2<T> S = TSegment2<)",
    "insertText": "T(Vertices[j], Vertices[k])"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (T dv2 = S .)",
    "insertText": "DistanceSquared(Vertices[i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (maxi = i ; maxd2 = dv2 ; })",
    "insertText": "if(maxd2 > tol2)"
  },
  {
    "label": "SimplifyDouglasPeucker()",
    "kind": "Method",
    "detail": "Function (Marked [ maxi ] = true ;)",
    "insertText": "SimplifyDouglasPeucker(Tolerance, Vertices, j, maxi, Marked)"
  },
  {
    "label": "SimplifyDouglasPeucker()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SimplifyDouglasPeucker(Tolerance, Vertices, maxi, k, Marked)"
  },
  {
    "label": "Simplify()",
    "kind": "Method",
    "detail": "Function (} return ; } public : void)",
    "insertText": "Simplify(T ClusterTolerance = 0.0001, T LineDeviationTolerance = 0.01)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<bool> Marked ; Marked .)",
    "insertText": "SetNumUninitialized(n + 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Marked [ i ] = false ; } T clusterTol2 = ClusterTolerance* ClusterTolerance ; NewVertices [ 0 ] = Vertices [ 0 ] ;)",
    "insertText": "for(i = 1, k = 1, pv = 0; i < n; i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } NewVertices [ k + + ] = Vertices [ i ] ; pv = i ; } bool skip_dp = false ;)",
    "insertText": "if(k == 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NewVertices [ k + + ] = Vertices [ 1 ] ; NewVertices [ k + + ] = Vertices [ 2 ] ; skip_dp = true ; } else)",
    "insertText": "if(k == 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NewVertices [ 2 ] = Vertices [ pv + 1 ] ; } else { NewVertices [ 1 ] = Vertices [ pv - 1 ] ; NewVertices [ 2 ] = Vertices [ pv ] ; } k = 3 ; skip_dp = true ; } NewVertices [ k + + ] = Vertices [ 0 ] ; int nv = 0 ;)",
    "insertText": "if(skip_dp == false && LineDeviationTolerance > 0)"
  },
  {
    "label": "SimplifyDouglasPeucker()",
    "kind": "Method",
    "detail": "Function (Marked [ 0 ] = Marked [ k - 1 ] = true ;)",
    "insertText": "SimplifyDouglasPeucker(LineDeviationTolerance, NewVertices, 0, k - 1, Marked)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (nv + + ; } } } else {)",
    "insertText": "for(i = 0; i < k; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Marked [ i ] = true ; } nv = k - 1 ; })",
    "insertText": "if(nv == 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Marked [ 1 ] = true ; } else)",
    "insertText": "if(Marked[k - 2] == false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Marked [ k - 2 ] = true ; } } nv + + ; } else)",
    "insertText": "if(nv == 1)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (Marked [ 1 ] = true ; Marked [ 2 ] = true ; nv + = 2 ; } Vertices .)",
    "insertText": "Reset()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Add(NewVertices[i])"
  },
  {
    "label": "Chamfer()",
    "kind": "Method",
    "detail": "Function (} } return ; } void)",
    "insertText": "Chamfer(T ChamferDist, T MinConvexAngleDeg = 30, T MinConcaveAngleDeg = 30)"
  },
  {
    "label": "iPrev()",
    "kind": "Method",
    "detail": "Function (int iCur = 0 ; do { TVector2<T> center = OldV [ iCur ] ; int)",
    "insertText": "iPrev(iCur == 0)"
  },
  {
    "label": "iNext()",
    "kind": "Method",
    "detail": "Function (TVector2<T> prev = OldV [ iPrev ] ; int)",
    "insertText": "iNext(iCur + 1)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (TVector2<T> next = OldV [ iNext ] ; TVector2<T> cp = prev - center ; T cpdist =)",
    "insertText": "Normalize(cp)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (TVector2<T> cn = next - center ; T cndist =)",
    "insertText": "Normalize(cn)"
  },
  {
    "label": "AngleD()",
    "kind": "Method",
    "detail": "Function (iCur = iNext ; continue ; } T angle =)",
    "insertText": "AngleD(cp, cn)"
  },
  {
    "label": "DotPerp()",
    "kind": "Method",
    "detail": "Function (T sign =)",
    "insertText": "DotPerp(cn, cp)"
  },
  {
    "label": "bConcave()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bConcave(sign > 0)"
  },
  {
    "label": "thresh()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "thresh(bConcave)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Add(center)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (iCur = iNext ; continue ; } T prev_cut_dist = TMathUtil<T)",
    "insertText": "Min(ChamferDist, cpdist*0.5)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (TVector2<T> prev_cut = center + cp* prev_cut_dist ; T next_cut_dist = TMathUtil<T)",
    "insertText": "Min(ChamferDist, cndist * 0.5)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TVector2<T> next_cut = center + cn* next_cut_dist ; Vertices .)",
    "insertText": "Add(prev_cut)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "Add(next_cut)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (iCur = iNext ; })",
    "insertText": "while(iCur != 0)"
  },
  {
    "label": "MakeRectangle()",
    "kind": "Method",
    "detail": "Function (} TPolygon2<T>)",
    "insertText": "MakeRectangle(const TVector2<T>& Center, T Width, T Height)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (TPolygon2<T> Rectangle ; Rectangle . Vertices .)",
    "insertText": "SetNumUninitialized(4)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (Rectangle .)",
    "insertText": "Set(0, TVector2<T>(Center.X - Width / 2, Center.Y - Height / 2))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (Rectangle .)",
    "insertText": "Set(1, TVector2<T>(Center.X + Width / 2, Center.Y - Height / 2))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (Rectangle .)",
    "insertText": "Set(2, TVector2<T>(Center.X + Width / 2, Center.Y + Height / 2))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (Rectangle .)",
    "insertText": "Set(3, TVector2<T>(Center.X - Width / 2, Center.Y + Height / 2))"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (TPolygon2<T> RRectangle ; CornerSteps =)",
    "insertText": "Max(2, CornerSteps)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (RRectangle . Vertices .)",
    "insertText": "SetNumUninitialized(CornerSteps * 4)"
  },
  {
    "label": "InnerExtents()",
    "kind": "Method",
    "detail": "Function (TVector2<T>)",
    "insertText": "InnerExtents(Width*.5 - Corner, Height*.5 - Corner)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TVector2<T> InnerCorners [ 4 ] { Center - InnerExtents,TVector2<)",
    "insertText": "T(Center.X + InnerExtents.X, Center.Y - InnerExtents.Y), Center + InnerExtents, TVector2<T>(Center.X - InnerExtents.X, Center.Y + InnerExtents.Y)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T IdxToAng = TMathUtil<T>::HalfPi /)",
    "insertText": "T(CornerSteps - 1)"
  },
  {
    "label": "Cos()",
    "kind": "Method",
    "detail": "Function (T Angle = StepIdx* IdxToAng ; T OffC = TMathUtil<T)",
    "insertText": "Cos(Angle)"
  },
  {
    "label": "Sin()",
    "kind": "Method",
    "detail": "Function (T OffS = TMathUtil<T)",
    "insertText": "Sin(Angle)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (RRectangle .)",
    "insertText": "Set(StepIdx + CornerSteps * 0, InnerCorners[0] + TVector2<T>(-OffC, -OffS))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (RRectangle .)",
    "insertText": "Set(StepIdx + CornerSteps * 1, InnerCorners[1] + TVector2<T>(OffS, -OffC))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (RRectangle .)",
    "insertText": "Set(StepIdx + CornerSteps * 2, InnerCorners[2] + TVector2<T>(OffC, OffS))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (RRectangle .)",
    "insertText": "Set(StepIdx + CornerSteps * 3, InnerCorners[3] + TVector2<T>(-OffS, OffC))"
  },
  {
    "label": "MakeCircle()",
    "kind": "Method",
    "detail": "Function (} return RRectangle ; } TPolygon2<T>)",
    "insertText": "MakeCircle(T Radius, int Steps, T AngleShiftRadians = 0)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (TPolygon2<T> Circle ; Circle . Vertices .)",
    "insertText": "SetNumUninitialized(Steps)"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "t(T)i / (T)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (T a = TMathUtil<T>::TwoPi* t + AngleShiftRadians ; Circle .)",
    "insertText": "Set(i, TVector2<T>(Radius * TMathUtil<T>::Cos(a), Radius * TMathUtil<T>::Sin(a)))"
  }
]