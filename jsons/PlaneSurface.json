[
  {
    "label": "CADKERNEL_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CADKERNEL_API"
  },
  {
    "label": "FPlaneSurface()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Geo / Surfaces / Surface . h \" namespace UE::CADKernel { class FPlaneSurface : public FSurface { FEntity ; protected : FMatrixH Matrix ; FMatrixH InverseMatrix ;)",
    "insertText": "FPlaneSurface(const double InToleranceGeometric, const FMatrixH& InMatrix, const FSurfacicBoundary& InBoundary)"
  },
  {
    "label": "FPlaneSurface()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPlaneSurface(const double InToleranceGeometric, double InDistanceFromOrigin, FPoint InNormal, const FSurfacicBoundary& InBoundary) : FPlaneSurface(InToleranceGeometric, InNormal* InDistanceFromOrigin, InNormal, InBoundary)"
  },
  {
    "label": "FPlaneSurface()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FPlaneSurface(const double InToleranceGeometric, const FPoint& Position, FPoint Normal, const FSurfacicBoundary& InBoundary)"
  },
  {
    "label": "FPlaneSurface()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPlaneSurface()"
  },
  {
    "label": "ComputeMinToleranceIso()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeMinToleranceIso()"
  },
  {
    "label": "Multiply()",
    "kind": "Method",
    "detail": "Function (FPoint Origin = Matrix .)",
    "insertText": "Multiply(FPoint::ZeroPoint)"
  },
  {
    "label": "ComputeScaleAlongAxis()",
    "kind": "Method",
    "detail": "Function (FPoint Point2DU { 1,0,0 } ; FPoint Point2DV { 0,1,0 } ; double ToleranceU = Tolerance3D /)",
    "insertText": "ComputeScaleAlongAxis(Point2DU, Matrix, Origin)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (MinToleranceIso .)",
    "insertText": "Set(ToleranceU, ToleranceV)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "Serialize(FCADKernelArchive& Ar)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "GetSurfaceType()",
    "kind": "Method",
    "detail": "Function (Ar<<Matrix ; Ar<<InverseMatrix ; } ESurface)",
    "insertText": "GetSurfaceType()"
  },
  {
    "label": "GetInfo()",
    "kind": "Method",
    "detail": "Function (# ifdef CADKERNEL_DEV FInfoEntity&)",
    "insertText": "GetInfo(FInfoEntity&)"
  },
  {
    "label": "ApplyMatrix()",
    "kind": "Method",
    "detail": "Function (# endif TSharedPtr<FEntityGeom>)",
    "insertText": "ApplyMatrix(const FMatrixH& InMatrix)"
  },
  {
    "label": "EvaluatePoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EvaluatePoint(const FPoint2D& InSurfacicCoordinate, FSurfacicPoint& OutPoint3D, int32 InDerivativeOrder = 0)"
  },
  {
    "label": "EvaluatePoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EvaluatePoints(const TArray<FPoint2D>& InSurfacicCoordinates, TArray<FSurfacicPoint>& OutPoint3D, int32 InDerivativeOrder = 0)"
  },
  {
    "label": "EvaluatePointGrid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EvaluatePointGrid(const FCoordinateGrid& Coordinates, FSurfacicSampling& OutPoints, bool bComputeNormals = false)"
  },
  {
    "label": "ProjectPoint()",
    "kind": "Method",
    "detail": "Function (FPoint)",
    "insertText": "ProjectPoint(const FPoint& InPoint, FPoint* OutProjectedPoint = nullptr)"
  },
  {
    "label": "ProjectPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProjectPoints(const TArray<FPoint>& InPoints, TArray<FPoint>* OutProjectedPointCoordinates, TArray<FPoint>* OutProjectedPoints = nullptr)"
  },
  {
    "label": "Presample()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Presample(const FSurfacicBoundary& InBoundaries, FCoordinateGrid& OutCoordinates)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (OutCoordinates [ EIso::IsoU ] .)",
    "insertText": "Empty(3)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutCoordinates [ EIso::IsoU ] .)",
    "insertText": "Add(InBoundaries[EIso::IsoU].Min)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutCoordinates [ EIso::IsoU ] .)",
    "insertText": "Add(InBoundaries[EIso::IsoU].GetMiddle())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutCoordinates [ EIso::IsoU ] .)",
    "insertText": "Add(InBoundaries[EIso::IsoU].Max)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutCoordinates [ EIso::IsoV ] .)",
    "insertText": "Add(InBoundaries[EIso::IsoV].Min)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutCoordinates [ EIso::IsoV ] .)",
    "insertText": "Add(InBoundaries[EIso::IsoV].GetMiddle())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutCoordinates [ EIso::IsoV ] .)",
    "insertText": "Add(InBoundaries[EIso::IsoV].Max)"
  },
  {
    "label": "IsSurfaceClosed()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "IsSurfaceClosed(bool& bOutClosedAlongU, bool& bOutClosedAlongV)"
  }
]