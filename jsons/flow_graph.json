[
  {
    "label": "concurrency",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "concurrency"
  },
  {
    "label": "null_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "null_type"
  },
  {
    "label": "continue_msg",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "continue_msg"
  },
  {
    "label": "sender",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "sender"
  },
  {
    "label": "receiver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "receiver"
  },
  {
    "label": "continue_receiver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "continue_receiver"
  },
  {
    "label": "limiter_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "limiter_node"
  },
  {
    "label": "run_and_put_task",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "run_and_put_task"
  },
  {
    "label": "successor_cache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "successor_cache"
  },
  {
    "label": "broadcast_cache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "broadcast_cache"
  },
  {
    "label": "round_robin_cache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "round_robin_cache"
  },
  {
    "label": "predecessor_cache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "predecessor_cache"
  },
  {
    "label": "reservable_predecessor_cache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "reservable_predecessor_cache"
  },
  {
    "label": "edge_container",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "edge_container"
  },
  {
    "label": "async_msg",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "async_msg"
  },
  {
    "label": "async_storage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "async_storage"
  },
  {
    "label": "async_helpers",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "async_helpers"
  },
  {
    "label": "untyped_receiver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "untyped_receiver"
  },
  {
    "label": "untyped_sender",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "untyped_sender"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "proxy_dependency_receiver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "proxy_dependency_receiver"
  },
  {
    "label": "tbb",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "tbb"
  },
  {
    "label": "source_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "source_node"
  },
  {
    "label": "function_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "function_node"
  },
  {
    "label": "multifunction_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "multifunction_node"
  },
  {
    "label": "split_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "split_node"
  },
  {
    "label": "continue_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "continue_node"
  },
  {
    "label": "broadcast_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "broadcast_node"
  },
  {
    "label": "buffer_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "buffer_node"
  },
  {
    "label": "op_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "op_type"
  },
  {
    "label": "buffer_operation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "buffer_operation"
  },
  {
    "label": "for",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "for"
  },
  {
    "label": "queue_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "queue_node"
  },
  {
    "label": "sequencer_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "sequencer_node"
  },
  {
    "label": "priority_queue_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "priority_queue_node"
  },
  {
    "label": "join_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "join_node"
  },
  {
    "label": "indexer_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "indexer_node"
  },
  {
    "label": "composite_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "composite_node"
  },
  {
    "label": "async_body_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "async_body_base"
  },
  {
    "label": "async_body",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "async_body"
  },
  {
    "label": "async_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "async_node"
  },
  {
    "label": "try_put_functor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "try_put_functor"
  },
  {
    "label": "receiver_gateway_impl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "receiver_gateway_impl"
  },
  {
    "label": "overwrite_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "overwrite_node"
  },
  {
    "label": "register_predecessor_task",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "register_predecessor_task"
  },
  {
    "label": "write_once_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "write_once_node"
  },
  {
    "label": "FLOW_SPAWN()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_flow_graph_H # define __TBB_flow_graph_H # include \" tbb_stddef . h \" # include \" atomic . h \" # include \" spin_mutex . h \" # include \" null_mutex . h \" # include \" spin_rw_mutex . h \" # include \" null_rw_mutex . h \" # include \" task . h \" # include \" cache_aligned_allocator . h \" # include \" tbb_exception . h \" # include \" internal / _template_helpers . h \" # include \" internal / _aggregator_impl . h \" # include \" tbb_profiling . h \" # include \" task_arena . h \" # if __TBB_PREVIEW_ASYNC_MSG # include<vector> # include<memory> # endif # if __TBB_PREVIEW_STREAMING_NODE # include<array> # include<unordered_map> # include<type_traits> # endif # if TBB_DEPRECATED_FLOW_ENQUEUE # define)",
    "insertText": "FLOW_SPAWN(a) tbb::task::enqueue((a)) #else #define FLOW_SPAWN(a) tbb::task::spawn((a))"
  },
  {
    "label": "add_edge()",
    "kind": "Method",
    "detail": "Function (namespace flow { using std::tuple ; using std::tuple_size ; using std::tuple_element ; using std::get ; } } # else # include \" compat / tuple \" # endif # include<list> # include<queue> namespace tbb { namespace flow { enum concurrency { unlimited = 0,serial = 1 } ; namespace interface10 { struct null_type { } ; class continue_msg { } ; template<T> class sender ; template<T> class receiver ; class continue_receiver ; } namespace interface11 { template<T,U> class limiter_node ; } namespace interface10 { template<R,B> class run_and_put_task ; namespace internal { template<T,M> class successor_cache ; template<T,M> class broadcast_cache ; template<T,M> class round_robin_cache ; template<T,M> class predecessor_cache ; template<T,M> class reservable_predecessor_cache ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION template<C> class edge_container { public : typedef std::list<C*,tbb::tbb_allocator<C*>> edge_list_type ; void)",
    "insertText": "add_edge(C &s)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (built_edges .)",
    "insertText": "push_back(&s)"
  },
  {
    "label": "delete_edge()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "delete_edge(C &s)"
  },
  {
    "label": "edge_count()",
    "kind": "Method",
    "detail": "Function (v = built_edges ; } size_t)",
    "insertText": "edge_count()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear()"
  },
  {
    "label": "sender_extract()",
    "kind": "Method",
    "detail": "Function (} template<S> void)",
    "insertText": "sender_extract(S &s)"
  },
  {
    "label": "receiver_extract()",
    "kind": "Method",
    "detail": "Function (template<R> void)",
    "insertText": "receiver_extract(R &r)"
  },
  {
    "label": "combine_tasks()",
    "kind": "Method",
    "detail": "Function (private : edge_list_type built_edges ; } ; # endif } } } } # include \" internal / _flow_graph_impl . h \" namespace tbb { namespace flow { namespace interface10 { tbb::task*)",
    "insertText": "combine_tasks(graph& g, tbb::task * left, tbb::task * right)"
  },
  {
    "label": "spawn_in_graph_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn_in_graph_arena(g, *left)"
  },
  {
    "label": "to_void_ptr()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "to_void_ptr(T& t)"
  },
  {
    "label": "from_void_ptr()",
    "kind": "Method",
    "detail": "Function (} const T&)",
    "insertText": "from_void_ptr(const void* p)"
  },
  {
    "label": "from_void_ptr()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "from_void_ptr(void* p)"
  },
  {
    "label": "try_put_task_wrapper_impl()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "try_put_task_wrapper_impl(receiver<T>* const this_recv, const void *p, bool is_async)"
  },
  {
    "label": "from_void_ptr()",
    "kind": "Method",
    "detail": "Function (const async_msg<filtered_type>& msg = async_helpers<async_msg<filtered_type>)",
    "insertText": "from_void_ptr(p)"
  },
  {
    "label": "subscribe()",
    "kind": "Method",
    "detail": "Function (task* const new_task = msg . my_storage ->)",
    "insertText": "subscribe(*this_recv, this_recv->graph_reference())"
  },
  {
    "label": "finalize()",
    "kind": "Method",
    "detail": "Function (msg .)",
    "insertText": "finalize()"
  },
  {
    "label": "to_void_ptr()",
    "kind": "Method",
    "detail": "Function (} } } ; template<T> struct async_helpers<T,std::enable_if<std::is_base_of<async_msg<T::async_msg_data_type>,T>::value>::type> { typedef T async_type ; typedef T::async_msg_data_type filtered_type ; const bool is_async_type = true ; const void*)",
    "insertText": "to_void_ptr(const T& t)"
  },
  {
    "label": "msg()",
    "kind": "Method",
    "detail": "Function (const T)",
    "insertText": "msg(t)"
  },
  {
    "label": "untyped_sender()",
    "kind": "Method",
    "detail": "Function (} } } ; class untyped_receiver ; class untyped_sender { template<,> class internal::predecessor_cache ; template<,> class internal::reservable_predecessor_cache ; public : typedef untyped_receiver successor_type ; ~)",
    "insertText": "untyped_sender()"
  },
  {
    "label": "register_successor()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "register_successor(successor_type &r)"
  },
  {
    "label": "remove_successor()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "remove_successor(successor_type &r)"
  },
  {
    "label": "try_release()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "try_release()"
  },
  {
    "label": "internal_add_built_successor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_add_built_successor(successor_type &)"
  },
  {
    "label": "internal_delete_built_successor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_delete_built_successor(successor_type &)"
  },
  {
    "label": "copy_successors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy_successors(successor_list_type &)"
  },
  {
    "label": "successor_count()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "successor_count()"
  },
  {
    "label": "try_get()",
    "kind": "Method",
    "detail": "Function (# endif protected : template<X> bool)",
    "insertText": "try_get(X &t)"
  },
  {
    "label": "try_reserve()",
    "kind": "Method",
    "detail": "Function (} template<X> bool)",
    "insertText": "try_reserve(X &t)"
  },
  {
    "label": "try_get_wrapper()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "try_get_wrapper(void* p, bool is_async)"
  },
  {
    "label": "try_reserve_wrapper()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "try_reserve_wrapper(void* p, bool is_async)"
  },
  {
    "label": "untyped_receiver()",
    "kind": "Method",
    "detail": "Function (} ; class untyped_receiver { template<,> class run_and_put_task ; template<,> class internal::broadcast_cache ; template<,> class internal::round_robin_cache ; template<,> class internal::successor_cache ; # if __TBB_PREVIEW_OPENCL_NODE template<,> class proxy_dependency_receiver ; # endif public : typedef untyped_sender predecessor_type ; ~)",
    "insertText": "untyped_receiver()"
  },
  {
    "label": "try_put()",
    "kind": "Method",
    "detail": "Function (} template<X> bool)",
    "insertText": "try_put(const X& t)"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (task* res =)",
    "insertText": "try_put_task(t)"
  },
  {
    "label": "internal_add_built_predecessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_add_built_predecessor(predecessor_type &)"
  },
  {
    "label": "internal_delete_built_predecessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_delete_built_predecessor(predecessor_type &)"
  },
  {
    "label": "copy_predecessors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy_predecessors(predecessor_list_type &)"
  },
  {
    "label": "predecessor_count()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "predecessor_count()"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (# endif protected : template<X> task*)",
    "insertText": "try_put_task(const X& t)"
  },
  {
    "label": "try_put_task_wrapper()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "try_put_task_wrapper(const void* p, bool is_async)"
  },
  {
    "label": "graph_reference()",
    "kind": "Method",
    "detail": "Function (graph&)",
    "insertText": "graph_reference()"
  },
  {
    "label": "reset_receiver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset_receiver(reset_flags f = rf_reset_protocol)"
  },
  {
    "label": "is_continue_receiver()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_continue_receiver()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "__TBB_ASSERT(false, \"async_msg interface does not support 'pull' protocol in try_get()\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "__TBB_ASSERT(false, \"async_msg interface does not support 'pull' protocol in try_reserve()\")"
  },
  {
    "label": "try_put()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "try_put(const typename internal::async_helpers<T>::async_type& t)"
  },
  {
    "label": "try_put_task_wrapper()",
    "kind": "Method",
    "detail": "Function (} protected : task*)",
    "insertText": "try_put_task_wrapper(const void *p, bool is_async)"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "try_put_task(const T& t)"
  },
  {
    "label": "sender()",
    "kind": "Method",
    "detail": "Function (} ; # else template<T> class sender { public : typedef T output_type ; typedef receiver<T> successor_type ; ~)",
    "insertText": "sender()"
  },
  {
    "label": "try_get()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "try_get(T &)"
  },
  {
    "label": "receiver()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<T> class receiver { public : typedef T input_type ; typedef sender<T> predecessor_type ; ~)",
    "insertText": "receiver()"
  },
  {
    "label": "try_put()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "try_put(const T& t)"
  },
  {
    "label": "register_predecessor()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "register_predecessor(predecessor_type &)"
  },
  {
    "label": "__TBB_FLOW_GRAPH_PRIORITY_EXPR()",
    "kind": "Method",
    "detail": "Function (my_predecessor_count = my_initial_predecessor_count = number_of_predecessors ; my_current_count = 0 ;)",
    "insertText": "__TBB_FLOW_GRAPH_PRIORITY_EXPR(my_priority = priority; ) } continue_receiver( const continue_receiver& src ) : receiver<continue_msg>()"
  },
  {
    "label": "__TBB_FLOW_GRAPH_PRIORITY_EXPR()",
    "kind": "Method",
    "detail": "Function (my_predecessor_count = my_initial_predecessor_count = src . my_initial_predecessor_count ; my_current_count = 0 ;)",
    "insertText": "__TBB_FLOW_GRAPH_PRIORITY_EXPR(my_priority = src.my_priority; ) } bool register_predecessor( predecessor_type &)"
  },
  {
    "label": "l()",
    "kind": "Method",
    "detail": "Function (spin_mutex::scoped_lock)",
    "insertText": "l(my_mutex)"
  },
  {
    "label": "remove_predecessor()",
    "kind": "Method",
    "detail": "Function (+ + my_predecessor_count ; return true ; } bool)",
    "insertText": "remove_predecessor(predecessor_type &)"
  },
  {
    "label": "built_predecessors()",
    "kind": "Method",
    "detail": "Function (- - my_predecessor_count ; return true ; } # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef internal::edge_container<predecessor_type> built_predecessors_type ; typedef built_predecessors_type::edge_list_type predecessor_list_type ; built_predecessors_type&)",
    "insertText": "built_predecessors()"
  },
  {
    "label": "add_edge()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "add_edge(s)"
  },
  {
    "label": "internal_delete_built_predecessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_predecessor(predecessor_type &s)"
  },
  {
    "label": "delete_edge()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "delete_edge(s)"
  },
  {
    "label": "copy_predecessors()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "copy_predecessors(predecessor_list_type &v)"
  },
  {
    "label": "copy_edges()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "copy_edges(v)"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (} # endif protected : template<R,B> class run_and_put_task ; template<X,Y> class internal::broadcast_cache ; template<X,Y> class internal::round_robin_cache ; task*)",
    "insertText": "try_put_task(const input_type &)"
  },
  {
    "label": "reset_receiver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset_receiver(reset_flags f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (my_current_count = 0 ;)",
    "insertText": "if(f & rf_clear_edges)"
  },
  {
    "label": "execute()",
    "kind": "Method",
    "detail": "Function (# endif my_predecessor_count = my_initial_predecessor_count ; } } task*)",
    "insertText": "execute()"
  },
  {
    "label": "graph_iterator()",
    "kind": "Method",
    "detail": "Function (} # endif using interface10::sender ; using interface10::receiver ; using interface10::continue_receiver ; } } # include \" internal / _flow_graph_trace_impl . h \" # include \" internal / _tbb_hash_compare_impl . h \" namespace tbb { namespace flow { namespace interface10 { # include \" internal / _flow_graph_body_impl . h \" # include \" internal / _flow_graph_cache_impl . h \" # include \" internal / _flow_graph_types_impl . h \" # if __TBB_PREVIEW_ASYNC_MSG # include \" internal / _flow_graph_async_msg_impl . h \" # endif using namespace internal::graph_policy_namespace ; template<C,N> graph_iterator<C,N)",
    "insertText": "graph_iterator(C *g, bool begin) : my_graph(g), current_node(NULL)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<C,N> graph_iterator<C,N>::reference graph_iterator<C,N)",
    "insertText": "operator()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(current_node, \"graph_iterator at end\")"
  },
  {
    "label": "graph()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "graph() : my_nodes(NULL), my_nodes_last(NULL), my_task_arena(NULL)"
  },
  {
    "label": "prepare_task_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prepare_task_arena()"
  },
  {
    "label": "task_group_context()",
    "kind": "Method",
    "detail": "Function (own_context = true ; cancelled = false ; caught_exception = false ; my_context = new)",
    "insertText": "task_group_context(tbb::internal::FLOW_TASKS)"
  },
  {
    "label": "my_root_task()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "my_root_task(new (task::allocate_root(*my_context)) empty_task)"
  },
  {
    "label": "set_ref_count()",
    "kind": "Method",
    "detail": "Function (my_root_task ->)",
    "insertText": "set_ref_count(1)"
  },
  {
    "label": "fgt_graph()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_graph(this)"
  },
  {
    "label": "graph()",
    "kind": "Method",
    "detail": "Function (my_is_active = true ; })",
    "insertText": "graph(task_group_context& use_this_context) : my_context(&use_this_context), my_nodes(NULL), my_nodes_last(NULL), my_task_arena(NULL)"
  },
  {
    "label": "graph()",
    "kind": "Method",
    "detail": "Function (my_is_active = true ; } graph::~)",
    "insertText": "graph()"
  },
  {
    "label": "wait_for_all()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "wait_for_all()"
  },
  {
    "label": "set_ref_count()",
    "kind": "Method",
    "detail": "Function (my_root_task ->)",
    "insertText": "set_ref_count(0)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "destroy(*my_root_task)"
  },
  {
    "label": "reserve_wait()",
    "kind": "Method",
    "detail": "Function (delete my_task_arena ; } void)",
    "insertText": "reserve_wait()"
  },
  {
    "label": "increment_ref_count()",
    "kind": "Method",
    "detail": "Function (my_root_task ->)",
    "insertText": "increment_ref_count()"
  },
  {
    "label": "fgt_reserve_wait()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_reserve_wait(this)"
  },
  {
    "label": "release_wait()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "release_wait()"
  },
  {
    "label": "fgt_release_wait()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_release_wait(this)"
  },
  {
    "label": "decrement_ref_count()",
    "kind": "Method",
    "detail": "Function (my_root_task ->)",
    "insertText": "decrement_ref_count()"
  },
  {
    "label": "register_node()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "register_node(graph_node *n)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (n -> next = NULL ; { spin_mutex::scoped_lock)",
    "insertText": "lock(nodelist_mutex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (next = n)",
    "insertText": "if(my_nodes_last)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (my_nodes_last = n ;)",
    "insertText": "if(!my_nodes)"
  },
  {
    "label": "remove_node()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "remove_node(graph_node *n)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_nodes && my_nodes_last, \"graph::remove_node: Error: no registered nodes\")"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} n -> prev = n -> next = NULL ; } void)",
    "insertText": "reset(reset_flags f)"
  },
  {
    "label": "deactivate_graph()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deactivate_graph(*this)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (cancelled = false ; caught_exception = false ;)",
    "insertText": "for(iterator ii = begin(); ii != end(); ++ii)"
  },
  {
    "label": "my_p()",
    "kind": "Method",
    "detail": "Function (graph_node*)",
    "insertText": "my_p(*ii)"
  },
  {
    "label": "reset_node()",
    "kind": "Method",
    "detail": "Function (my_p ->)",
    "insertText": "reset_node(f)"
  },
  {
    "label": "prepare_task_arena()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "prepare_task_arena(true)"
  },
  {
    "label": "activate_graph()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "activate_graph(*this)"
  },
  {
    "label": "spawn_in_graph_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn_in_graph_arena(*this, *(*rti))"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} graph::iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} graph::iterator)",
    "insertText": "end()"
  },
  {
    "label": "cbegin()",
    "kind": "Method",
    "detail": "Function (} graph::const_iterator)",
    "insertText": "cbegin()"
  },
  {
    "label": "cend()",
    "kind": "Method",
    "detail": "Function (} graph::const_iterator)",
    "insertText": "cend()"
  },
  {
    "label": "set_name()",
    "kind": "Method",
    "detail": "Function (} # if TBB_PREVIEW_FLOW_GRAPH_TRACE void)",
    "insertText": "set_name(const char *name)"
  },
  {
    "label": "fgt_graph_desc()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_graph_desc(this, name)"
  },
  {
    "label": "graph_node()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "graph_node(graph& g) : my_graph(g)"
  },
  {
    "label": "register_node()",
    "kind": "Method",
    "detail": "Function (my_graph .)",
    "insertText": "register_node(this)"
  },
  {
    "label": "graph_node()",
    "kind": "Method",
    "detail": "Function (} graph_node::~)",
    "insertText": "graph_node()"
  },
  {
    "label": "remove_node()",
    "kind": "Method",
    "detail": "Function (my_graph .)",
    "insertText": "remove_node(this)"
  },
  {
    "label": "source_node()",
    "kind": "Method",
    "detail": "Function (} # include \" internal / _flow_graph_node_impl . h \" template<Output> class source_node : public graph_node,public sender<Output> { public : typedef Output output_type ; typedef sender<output_type>::successor_type successor_type ; typedef null_type input_type ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef sender<output_type>::built_successors_type built_successors_type ; typedef sender<output_type>::successor_list_type successor_list_type ; # endif template<Body>)",
    "insertText": "source_node(graph &g, Body body, bool is_active = true ) : graph_node(g), my_active(is_active), init_my_active(is_active), my_body( new internal::source_body_leaf< output_type, Body>(body) ), my_init_body( new internal::source_body_leaf< output_type, Body>(body) ), my_reserved(false), my_has_cached_item(false)"
  },
  {
    "label": "set_owner()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "set_owner(this)"
  },
  {
    "label": "fgt_node_with_body()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node_with_body(tbb::internal::FLOW_SOURCE_NODE, &this->my_graph, static_cast<sender<output_type> *>(this), this->my_body)"
  },
  {
    "label": "source_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "source_node(const source_node& src ) : graph_node(src.my_graph), sender<Output>(), my_active(src.init_my_active), init_my_active(src.init_my_active), my_body( src.my_init_body->clone() ), my_init_body(src.my_init_body->clone() ), my_reserved(false), my_has_cached_item(false)"
  },
  {
    "label": "source_node()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "source_node()"
  },
  {
    "label": "fgt_node_desc()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node_desc(this, name)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (spin_mutex::scoped_lock)",
    "insertText": "lock(my_mutex)"
  },
  {
    "label": "register_successor()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "register_successor(r)"
  },
  {
    "label": "remove_successor()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "remove_successor(r)"
  },
  {
    "label": "internal_add_built_successor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_add_built_successor(successor_type &r)"
  },
  {
    "label": "internal_add_built_successor()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "internal_add_built_successor(r)"
  },
  {
    "label": "internal_delete_built_successor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_successor(successor_type &r)"
  },
  {
    "label": "internal_delete_built_successor()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "internal_delete_built_successor(r)"
  },
  {
    "label": "copy_successors()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "copy_successors(successor_list_type &v)"
  },
  {
    "label": "copy_successors()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "copy_successors(v)"
  },
  {
    "label": "try_get()",
    "kind": "Method",
    "detail": "Function (} # endif bool)",
    "insertText": "try_get(output_type &v)"
  },
  {
    "label": "spawn_put()",
    "kind": "Method",
    "detail": "Function (v = my_cached_item ; my_has_cached_item = false ; return true ; })",
    "insertText": "spawn_put()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_reserved && my_has_cached_item, \"releasing non-existent reservation\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (my_reserved = false ;)",
    "insertText": "if(!my_successors.empty()) spawn_put()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_reserved && my_has_cached_item, \"consuming non-existent reservation\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (my_reserved = false ; my_has_cached_item = false ;)",
    "insertText": "if(!my_successors.empty())"
  },
  {
    "label": "activate()",
    "kind": "Method",
    "detail": "Function (} return true ; } void)",
    "insertText": "activate()"
  },
  {
    "label": "copy_function_object()",
    "kind": "Method",
    "detail": "Function (} template<Body> Body)",
    "insertText": "copy_function_object()"
  },
  {
    "label": "Body()",
    "kind": "Method",
    "detail": "Function (internal::source_body<output_type>& body_ref =* this -> my_body ; return dynamic_cast<internal::source_body_leaf<output_type,)",
    "insertText": "Body(body_ref).get_body()"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (} # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION void)",
    "insertText": "extract()"
  },
  {
    "label": "built_successors()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "built_successors().sender_extract(*this)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (my_active = init_my_active ; my_reserved = false ;)",
    "insertText": "if(my_has_cached_item)"
  },
  {
    "label": "reset_node()",
    "kind": "Method",
    "detail": "Function (} # endif protected : void)",
    "insertText": "reset_node(reset_flags f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (my_has_cached_item = false ; })",
    "insertText": "if(f & rf_clear_edges) my_successors.clear()"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (internal::source_body<output_type>* tmp = my_init_body ->)",
    "insertText": "clone()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (delete my_body ; my_body = tmp ; })",
    "insertText": "if(my_active) internal::add_task_to_graph_reset_list(this->my_graph, create_put_task())"
  },
  {
    "label": "try_reserve_apply_body()",
    "kind": "Method",
    "detail": "Function (} private : spin_mutex my_mutex ; bool my_active ; bool init_my_active ; internal::source_body<output_type>* my_body ; internal::source_body<output_type>* my_init_body ; internal::broadcast_cache<output_type> my_successors ; bool my_reserved ; bool my_has_cached_item ; output_type my_cached_item ; bool)",
    "insertText": "try_reserve_apply_body(output_type &v)"
  },
  {
    "label": "fgt_begin_body()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_begin_body(my_body)"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "r(*my_body)(my_cached_item)"
  },
  {
    "label": "fgt_end_body()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_end_body(my_body)"
  },
  {
    "label": "create_put_task()",
    "kind": "Method",
    "detail": "Function (v = my_cached_item ; my_reserved = true ; return true ; } else { return false ; } } task*)",
    "insertText": "create_put_task()"
  },
  {
    "label": "spawn_in_graph_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn_in_graph_arena(this->my_graph, *create_put_task())"
  },
  {
    "label": "apply_body_bypass()",
    "kind": "Method",
    "detail": "Function (} } class internal::source_task_bypass<source_node<output_type>> ; task*)",
    "insertText": "apply_body_bypass()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (output_type v ;)",
    "insertText": "if(!try_reserve_apply_body(v))"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (task* last_task = my_successors .)",
    "insertText": "try_put_task(v)"
  },
  {
    "label": "fgt_node_with_body()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node_with_body(tbb::internal::FLOW_FUNCTION_NODE, &this->my_graph, static_cast<receiver<input_type> *>(this), static_cast<sender<output_type> *>(this), this->my_body)"
  },
  {
    "label": "function_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "function_node(const function_node& src ) : graph_node(src.my_graph), input_impl_type(src), fOutput_type()"
  },
  {
    "label": "built_predecessors()",
    "kind": "Method",
    "detail": "Function (my_predecessors .)",
    "insertText": "built_predecessors().receiver_extract(*this)"
  },
  {
    "label": "successors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "successors().built_successors().sender_extract(*this)"
  },
  {
    "label": "successors()",
    "kind": "Method",
    "detail": "Function (} # endif protected : template<R,B> class run_and_put_task ; template<X,Y> class internal::broadcast_cache ; template<X,Y> class internal::round_robin_cache ; using input_impl_type::try_put_task ; internal::broadcast_cache<output_type>&)",
    "insertText": "successors()"
  },
  {
    "label": "reset_function_input()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset_function_input(f)"
  },
  {
    "label": "successors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "successors().clear()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "__TBB_ASSERT(!(f & rf_clear_edges) || successors().empty(), \"function_node successors not empty\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(this->my_predecessors.empty(), \"function_node predecessors not empty\")"
  },
  {
    "label": "multifunction_node()",
    "kind": "Method",
    "detail": "Function (} } ; template<Input,Output,Policy = queueing,Allocator = cache_aligned_allocator<Input>> class multifunction_node : public graph_node,public internal::multifunction_input<Input,internal::wrap_tuple_elements<tbb::flow::tuple_size<Output>::value,internal::multifunction_output,Output>::type,Policy,Allocator> { protected : const int N = tbb::flow::tuple_size<Output>::value ; public : typedef Input input_type ; typedef null_type output_type ; typedef internal::wrap_tuple_elements<N,internal::multifunction_output,Output>::type output_ports_type ; typedef internal::multifunction_input<input_type,output_ports_type,Policy,Allocator> input_impl_type ; typedef internal::function_input_queue<input_type,Allocator> input_queue_type ; private : typedef internal::multifunction_input<input_type,output_ports_type,Policy,Allocator> base_type ; using input_impl_type::my_predecessors ; public : template<Body>)",
    "insertText": "multifunction_node(graph &g, size_t concurrency, __TBB_FLOW_GRAPH_PRIORITY_ARG1( Body body, node_priority_t priority = tbb::flow::internal::no_priority ) ) : graph_node(g), base_type(g, concurrency, __TBB_FLOW_GRAPH_PRIORITY_ARG1(body, priority))"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::internal::fgt_multioutput_node_with_body<)",
    "insertText": "N(tbb::internal::FLOW_MULTIFUNCTION_NODE, &this->my_graph, static_cast<receiver<input_type> *>(this), this->output_ports(), this->my_body)"
  },
  {
    "label": "multifunction_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "multifunction_node(const multifunction_node &other) : graph_node(other.my_graph), base_type(other)"
  },
  {
    "label": "fgt_multioutput_node_desc()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_multioutput_node_desc(this, name)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset(f)"
  },
  {
    "label": "split_node()",
    "kind": "Method",
    "detail": "Function (} } ; template<TupleType,Allocator = cache_aligned_allocator<TupleType>> class split_node : public graph_node,public receiver<TupleType> { const int N = tbb::flow::tuple_size<TupleType>::value ; typedef receiver<TupleType> base_type ; public : typedef TupleType input_type ; typedef Allocator allocator_type ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef base_type::predecessor_type predecessor_type ; typedef base_type::predecessor_list_type predecessor_list_type ; typedef internal::predecessor_cache<input_type,null_mutex> predecessor_cache_type ; typedef predecessor_cache_type::built_predecessors_type built_predecessors_type ; # endif typedef internal::wrap_tuple_elements<N,internal::multifunction_output,TupleType>::type output_ports_type ;)",
    "insertText": "split_node(graph &g) : graph_node(g)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::internal::fgt_multioutput_node<)",
    "insertText": "N(tbb::internal::FLOW_SPLIT_NODE, &this->my_graph, static_cast<receiver<input_type> *>(this), this->output_ports())"
  },
  {
    "label": "split_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "split_node(const split_node & other) : graph_node(other.my_graph), base_type(other)"
  },
  {
    "label": "output_ports()",
    "kind": "Method",
    "detail": "Function (} # endif output_ports_type&)",
    "insertText": "output_ports()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!(f & rf_clear_edges) || internal::clear_element<N>::this_empty(my_output_ports), \"split_node reset failed\")"
  },
  {
    "label": "reset_receiver()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reset_receiver(reset_flags)"
  },
  {
    "label": "internal_add_built_predecessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_add_built_predecessor(predecessor_type&)"
  },
  {
    "label": "internal_delete_built_predecessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_predecessor(predecessor_type&)"
  },
  {
    "label": "fgt_node_with_body()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node_with_body(tbb::internal::FLOW_CONTINUE_NODE, &this->my_graph, static_cast<receiver<input_type> *>(this), static_cast<sender<output_type> *>(this), this->my_body)"
  },
  {
    "label": "continue_node()",
    "kind": "Method",
    "detail": "Function (} template<Body>)",
    "insertText": "continue_node(graph &g, int number_of_predecessors, __TBB_FLOW_GRAPH_PRIORITY_ARG1( Body body, node_priority_t priority = tbb::flow::internal::no_priority ) ) : graph_node(g) , input_impl_type(g, number_of_predecessors, __TBB_FLOW_GRAPH_PRIORITY_ARG1(body, priority))"
  },
  {
    "label": "continue_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "continue_node(const continue_node& src ) : graph_node(src.my_graph), input_impl_type(src), internal::function_output<Output>()"
  },
  {
    "label": "receiver_extract()",
    "kind": "Method",
    "detail": "Function (input_impl_type::my_built_predecessors .)",
    "insertText": "receiver_extract(*this)"
  },
  {
    "label": "reset_receiver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset_receiver(f)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!(f & rf_clear_edges) || successors().empty(), \"continue_node not reset\")"
  },
  {
    "label": "broadcast_node()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> class broadcast_node : public graph_node,public receiver<T>,public sender<T> { public : typedef T input_type ; typedef T output_type ; typedef receiver<input_type>::predecessor_type predecessor_type ; typedef sender<output_type>::successor_type successor_type ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef receiver<input_type>::predecessor_list_type predecessor_list_type ; typedef sender<output_type>::successor_list_type successor_list_type ; # endif private : internal::broadcast_cache<input_type> my_successors ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION internal::edge_container<predecessor_type> my_built_predecessors ; spin_mutex pred_mutex ; # endif public :)",
    "insertText": "broadcast_node(graph& g) : graph_node(g)"
  },
  {
    "label": "fgt_node()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node(tbb::internal::FLOW_BROADCAST_NODE, &this->my_graph, static_cast<receiver<input_type> *>(this), static_cast<sender<output_type> *>(this))"
  },
  {
    "label": "broadcast_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "broadcast_node(const broadcast_node& src ) : graph_node(src.my_graph), receiver<T>(), sender<T>()"
  },
  {
    "label": "l()",
    "kind": "Method",
    "detail": "Function (spin_mutex::scoped_lock)",
    "insertText": "l(pred_mutex)"
  },
  {
    "label": "add_edge()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "add_edge(p)"
  },
  {
    "label": "internal_delete_built_predecessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_predecessor(predecessor_type &p)"
  },
  {
    "label": "delete_edge()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "delete_edge(p)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (# endif })",
    "insertText": "__TBB_ASSERT(!(f & rf_clear_edges) || my_successors.empty(), \"Error resetting broadcast_node\")"
  },
  {
    "label": "buffer_operation()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,A = cache_aligned_allocator<T>> class buffer_node : public graph_node,public internal::reservable_item_buffer<T,A>,public receiver<T>,public sender<T> { public : typedef T input_type ; typedef T output_type ; typedef receiver<input_type>::predecessor_type predecessor_type ; typedef sender<output_type>::successor_type successor_type ; typedef buffer_node<T,A> class_type ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef receiver<input_type>::predecessor_list_type predecessor_list_type ; typedef sender<output_type>::successor_list_type successor_list_type ; # endif protected : typedef size_t size_type ; internal::round_robin_cache<T,null_rw_mutex> my_successors ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION internal::edge_container<predecessor_type> my_built_predecessors ; # endif class internal::forward_task_bypass<buffer_node<T,A>> ; enum op_type { reg_succ,rem_succ,req_item,res_item,rel_res,con_res,put_item,try_fwd_task # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION,add_blt_succ,del_blt_succ,add_blt_pred,del_blt_pred,blt_succ_cnt,blt_pred_cnt,blt_succ_cpy,blt_pred_cpy # endif } ; class buffer_operation : public internal::aggregated_operation<buffer_operation> { public : char type ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION task* ltask ; union { input_type* elem ; successor_type* r ; predecessor_type* p ; size_t cnt_val ; successor_list_type* svec ; predecessor_list_type* pvec ; } ; # else T* elem ; task* ltask ; successor_type* r ; # endif)",
    "insertText": "buffer_operation(const T& e, op_type t) : type(char(t)) #if TBB_DEPRECATED_FLOW_NODE_EXTRACTION , ltask(NULL), elem(const_cast<T*>(&e)) #else , elem(const_cast<T*>(&e)) , ltask(NULL)"
  },
  {
    "label": "buffer_operation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "buffer_operation(op_type t) : type(char(t)), ltask(NULL)"
  },
  {
    "label": "handle_operations()",
    "kind": "Method",
    "detail": "Function (} } ; bool forwarder_busy ; typedef internal::aggregating_functor<class_type,buffer_operation> handler_type ; class internal::aggregating_functor<class_type,buffer_operation> ; internal::aggregator<handler_type,buffer_operation> my_aggregator ; void)",
    "insertText": "handle_operations(buffer_operation *op_list)"
  },
  {
    "label": "handle_operations_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "handle_operations_impl(op_list, this)"
  },
  {
    "label": "handle_operations_impl()",
    "kind": "Method",
    "detail": "Function (} template<derived_type> void)",
    "insertText": "handle_operations_impl(buffer_operation *op_list, derived_type* derived)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(static_cast<class_type*>(derived) == this, \"'this' is not a base class for derived\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (buffer_operation* tmp = NULL ; bool try_forwarding = false ;)",
    "insertText": "while(op_list)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (tmp = op_list ; op_list = op_list -> next ;)",
    "insertText": "switch(tmp->type)"
  },
  {
    "label": "internal_rem_succ()",
    "kind": "Method",
    "detail": "Function (try_forwarding = true ; break ; case rem_succ :)",
    "insertText": "internal_rem_succ(tmp)"
  },
  {
    "label": "internal_pop()",
    "kind": "Method",
    "detail": "Function (break ; case req_item :)",
    "insertText": "internal_pop(tmp)"
  },
  {
    "label": "internal_reserve()",
    "kind": "Method",
    "detail": "Function (break ; case res_item :)",
    "insertText": "internal_reserve(tmp)"
  },
  {
    "label": "internal_release()",
    "kind": "Method",
    "detail": "Function (break ; case rel_res :)",
    "insertText": "internal_release(tmp)"
  },
  {
    "label": "internal_consume()",
    "kind": "Method",
    "detail": "Function (try_forwarding = true ; break ; case con_res :)",
    "insertText": "internal_consume(tmp)"
  },
  {
    "label": "internal_push()",
    "kind": "Method",
    "detail": "Function (try_forwarding = true ; break ; case put_item : try_forwarding =)",
    "insertText": "internal_push(tmp)"
  },
  {
    "label": "internal_forward_task()",
    "kind": "Method",
    "detail": "Function (break ; case try_fwd_task :)",
    "insertText": "internal_forward_task(tmp)"
  },
  {
    "label": "internal_add_built_succ()",
    "kind": "Method",
    "detail": "Function (break ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION case add_blt_succ :)",
    "insertText": "internal_add_built_succ(tmp)"
  },
  {
    "label": "internal_del_built_succ()",
    "kind": "Method",
    "detail": "Function (break ; case del_blt_succ :)",
    "insertText": "internal_del_built_succ(tmp)"
  },
  {
    "label": "internal_add_built_pred()",
    "kind": "Method",
    "detail": "Function (break ; case add_blt_pred :)",
    "insertText": "internal_add_built_pred(tmp)"
  },
  {
    "label": "internal_del_built_pred()",
    "kind": "Method",
    "detail": "Function (break ; case del_blt_pred :)",
    "insertText": "internal_del_built_pred(tmp)"
  },
  {
    "label": "internal_succ_cnt()",
    "kind": "Method",
    "detail": "Function (break ; case blt_succ_cnt :)",
    "insertText": "internal_succ_cnt(tmp)"
  },
  {
    "label": "internal_pred_cnt()",
    "kind": "Method",
    "detail": "Function (break ; case blt_pred_cnt :)",
    "insertText": "internal_pred_cnt(tmp)"
  },
  {
    "label": "internal_copy_succs()",
    "kind": "Method",
    "detail": "Function (break ; case blt_succ_cpy :)",
    "insertText": "internal_copy_succs(tmp)"
  },
  {
    "label": "internal_copy_preds()",
    "kind": "Method",
    "detail": "Function (break ; case blt_pred_cpy :)",
    "insertText": "internal_copy_preds(tmp)"
  },
  {
    "label": "order()",
    "kind": "Method",
    "detail": "Function (break ; # endif } } derived ->)",
    "insertText": "order()"
  },
  {
    "label": "combine_tasks()",
    "kind": "Method",
    "detail": "Function (tbb::task* z = tmp -> ltask ; graph& g = this -> my_graph ; tmp -> ltask =)",
    "insertText": "combine_tasks(g, z, new_task)"
  },
  {
    "label": "grab_forwarding_task()",
    "kind": "Method",
    "detail": "Function (} } } task*)",
    "insertText": "grab_forwarding_task(buffer_operation &op_data)"
  },
  {
    "label": "grab_forwarding_task()",
    "kind": "Method",
    "detail": "Function (task* ft =)",
    "insertText": "grab_forwarding_task(op_data)"
  },
  {
    "label": "spawn_in_graph_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn_in_graph_arena(graph_reference(), *ft)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(try_fwd_task)"
  },
  {
    "label": "execute()",
    "kind": "Method",
    "detail": "Function (task* last_task = NULL ; do { op_data . status = internal::WAIT ; op_data . ltask = NULL ; my_aggregator .)",
    "insertText": "execute(&op_data)"
  },
  {
    "label": "combine_tasks()",
    "kind": "Method",
    "detail": "Function (tbb::task* xtask = op_data . ltask ; graph& g = this -> my_graph ; last_task =)",
    "insertText": "combine_tasks(g, last_task, xtask)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(op_data.status ==internal::SUCCEEDED)"
  },
  {
    "label": "register_successor()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "register_successor(*(op->r))"
  },
  {
    "label": "__TBB_store_with_release()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_store_with_release(op->status, internal::SUCCEEDED)"
  },
  {
    "label": "internal_rem_succ()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_rem_succ(buffer_operation *op)"
  },
  {
    "label": "remove_successor()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "remove_successor(*(op->r))"
  },
  {
    "label": "built_successors()",
    "kind": "Method",
    "detail": "Function (} # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef sender<T>::built_successors_type built_successors_type ; built_successors_type&)",
    "insertText": "built_successors()"
  },
  {
    "label": "internal_add_built_succ()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_add_built_succ(buffer_operation *op)"
  },
  {
    "label": "internal_add_built_successor()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "internal_add_built_successor(*(op->r))"
  },
  {
    "label": "internal_del_built_succ()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_del_built_succ(buffer_operation *op)"
  },
  {
    "label": "internal_delete_built_successor()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "internal_delete_built_successor(*(op->r))"
  },
  {
    "label": "add_edge()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "add_edge(*(op->p))"
  },
  {
    "label": "internal_del_built_pred()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_del_built_pred(buffer_operation *op)"
  },
  {
    "label": "delete_edge()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "delete_edge(*(op->p))"
  },
  {
    "label": "internal_succ_cnt()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_succ_cnt(buffer_operation *op)"
  },
  {
    "label": "internal_pred_cnt()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_pred_cnt(buffer_operation *op)"
  },
  {
    "label": "internal_copy_succs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_copy_succs(buffer_operation *op)"
  },
  {
    "label": "copy_successors()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "copy_successors(*(op->svec))"
  },
  {
    "label": "internal_copy_preds()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_copy_preds(buffer_operation *op)"
  },
  {
    "label": "copy_edges()",
    "kind": "Method",
    "detail": "Function (my_built_predecessors .)",
    "insertText": "copy_edges(*(op->pvec))"
  },
  {
    "label": "is_item_valid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_item_valid()"
  },
  {
    "label": "try_put_and_add_task()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "try_put_and_add_task(task*& last_task)"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (task* new_task = my_successors .)",
    "insertText": "try_put_task(this->back())"
  },
  {
    "label": "combine_tasks()",
    "kind": "Method",
    "detail": "Function (graph& g = this -> my_graph ; last_task =)",
    "insertText": "combine_tasks(g, last_task, new_task)"
  },
  {
    "label": "destroy_back()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "destroy_back()"
  },
  {
    "label": "internal_forward_task()",
    "kind": "Method",
    "detail": "Function (} } protected : void)",
    "insertText": "internal_forward_task(buffer_operation *op)"
  },
  {
    "label": "internal_forward_task_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_forward_task_impl(op, this)"
  },
  {
    "label": "internal_forward_task_impl()",
    "kind": "Method",
    "detail": "Function (} template<derived_type> void)",
    "insertText": "internal_forward_task_impl(buffer_operation *op, derived_type* derived)"
  },
  {
    "label": "__TBB_store_with_release()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_store_with_release(op->status, internal::FAILED)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (this -> forwarder_busy = false ; return ; } task* last_task = NULL ; size_type counter = my_successors .)",
    "insertText": "size()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (op -> ltask = last_task ;)",
    "insertText": "if(last_task && !counter)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "push_back(*(op->elem))"
  },
  {
    "label": "internal_reserve()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "internal_reserve(buffer_operation *op)"
  },
  {
    "label": "internal_consume()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "internal_consume(buffer_operation *op)"
  },
  {
    "label": "consume_front()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "consume_front()"
  },
  {
    "label": "internal_release()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_release(buffer_operation *op)"
  },
  {
    "label": "release_front()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "release_front()"
  },
  {
    "label": "buffer_node()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "buffer_node(graph &g ) : graph_node(g), internal::reservable_item_buffer<T>(), forwarder_busy(false)"
  },
  {
    "label": "initialize_handler()",
    "kind": "Method",
    "detail": "Function (my_aggregator .)",
    "insertText": "initialize_handler(handler_type(this))"
  },
  {
    "label": "fgt_node()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node(tbb::internal::FLOW_BUFFER_NODE, &this->my_graph, static_cast<receiver<input_type> *>(this), static_cast<sender<output_type> *>(this))"
  },
  {
    "label": "buffer_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "buffer_node(const buffer_node& src ) : graph_node(src.my_graph), internal::reservable_item_buffer<T>(), receiver<T>(), sender<T>()"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(reg_succ)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(add_blt_succ)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(del_blt_succ)"
  },
  {
    "label": "internal_add_built_predecessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_add_built_predecessor(predecessor_type &p)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(add_blt_pred)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(del_blt_pred)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(blt_pred_cnt)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(blt_succ_cnt)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(blt_pred_cpy)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(blt_succ_cpy)"
  },
  {
    "label": "remove_predecessor()",
    "kind": "Method",
    "detail": "Function (r .)",
    "insertText": "remove_predecessor(*this)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(rem_succ)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(req_item)"
  },
  {
    "label": "try_reserve()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "try_reserve(T &v)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(res_item)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(rel_res)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(con_res)"
  },
  {
    "label": "op_data()",
    "kind": "Method",
    "detail": "Function (buffer_operation)",
    "insertText": "op_data(t, put_item)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ft = NULL ; } else)",
    "insertText": "if(!ft && op_data.status ==internal::SUCCEEDED)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (internal::reservable_item_buffer<T,A)",
    "insertText": "reset()"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (task* new_task = this -> my_successors .)",
    "insertText": "try_put_task(this->front())"
  },
  {
    "label": "combine_tasks()",
    "kind": "Method",
    "detail": "Function (last_task =)",
    "insertText": "combine_tasks(graph_ref, last_task, new_task)"
  },
  {
    "label": "destroy_front()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "destroy_front()"
  },
  {
    "label": "internal_forward_task()",
    "kind": "Method",
    "detail": "Function (} } protected : void)",
    "insertText": "internal_forward_task(queue_operation *op)"
  },
  {
    "label": "internal_pop()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_pop(queue_operation *op)"
  },
  {
    "label": "pop_front()",
    "kind": "Method",
    "detail": "Function (} else { this ->)",
    "insertText": "pop_front(*(op->elem))"
  },
  {
    "label": "internal_reserve()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "internal_reserve(queue_operation *op)"
  },
  {
    "label": "reserve_front()",
    "kind": "Method",
    "detail": "Function (} else { this ->)",
    "insertText": "reserve_front(*(op->elem))"
  },
  {
    "label": "internal_consume()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "internal_consume(queue_operation *op)"
  },
  {
    "label": "queue_node()",
    "kind": "Method",
    "detail": "Function (} public : typedef T input_type ; typedef T output_type ; typedef receiver<input_type>::predecessor_type predecessor_type ; typedef sender<output_type>::successor_type successor_type ;)",
    "insertText": "queue_node(graph &g ) : base_type(g)"
  },
  {
    "label": "fgt_node()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node(tbb::internal::FLOW_QUEUE_NODE, &(this->my_graph), static_cast<receiver<input_type> *>(this), static_cast<sender<output_type> *>(this))"
  },
  {
    "label": "queue_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "queue_node(const queue_node& src) : base_type(src)"
  },
  {
    "label": "sequencer_node()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,A = cache_aligned_allocator<T>> class sequencer_node : public queue_node<T,A> { internal::function_body<T,size_t>* my_sequencer ; public : typedef T input_type ; typedef T output_type ; typedef receiver<input_type>::predecessor_type predecessor_type ; typedef sender<output_type>::successor_type successor_type ; template<Sequencer>)",
    "insertText": "sequencer_node(graph &g, const Sequencer& s ) : queue_node<T, A>(g), my_sequencer(new internal::function_body_leaf< T, size_t, Sequencer>(s))"
  },
  {
    "label": "fgt_node()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node(tbb::internal::FLOW_SEQUENCER_NODE, &(this->my_graph), static_cast<receiver<input_type> *>(this), static_cast<sender<output_type> *>(this))"
  },
  {
    "label": "sequencer_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "sequencer_node(const sequencer_node& src ) : queue_node<T, A>(src), my_sequencer( src.my_sequencer->clone())"
  },
  {
    "label": "sequencer_node()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "sequencer_node()"
  },
  {
    "label": "internal_push()",
    "kind": "Method",
    "detail": "Function (} # endif protected : typedef buffer_node<T,A>::size_type size_type ; typedef buffer_node<T,A>::buffer_operation sequencer_operation ; private : bool)",
    "insertText": "internal_push(sequencer_operation *op)"
  },
  {
    "label": "tag()",
    "kind": "Method",
    "detail": "Function (size_type)",
    "insertText": "tag(*my_sequencer)(*(op->elem))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if ! TBB_DEPRECATED_SEQUENCER_DUPLICATES)",
    "insertText": "if(tag < this->my_head)"
  },
  {
    "label": "grow_my_array()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "grow_my_array(this->size(new_tail))"
  },
  {
    "label": "place_item()",
    "kind": "Method",
    "detail": "Function (} this -> my_tail = new_tail ; const internal::op_stat res = this ->)",
    "insertText": "place_item(tag, *(op->elem))"
  },
  {
    "label": "__TBB_store_with_release()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_store_with_release(op->status, res)"
  },
  {
    "label": "fgt_node()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node(tbb::internal::FLOW_PRIORITY_QUEUE_NODE, &(this->my_graph), static_cast<receiver<input_type> *>(this), static_cast<sender<output_type> *>(this))"
  },
  {
    "label": "priority_queue_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "priority_queue_node(const priority_queue_node &src ) : buffer_node<T, A>(src), mark(0)"
  },
  {
    "label": "internal_forward_task()",
    "kind": "Method",
    "detail": "Function (} typedef buffer_node<T,A>::size_type size_type ; typedef buffer_node<T,A>::item_type item_type ; typedef buffer_node<T,A>::buffer_operation prio_operation ; void)",
    "insertText": "internal_forward_task(prio_operation *op)"
  },
  {
    "label": "handle_operations()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "handle_operations(prio_operation *op_list)"
  },
  {
    "label": "internal_push()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "internal_push(prio_operation *op)"
  },
  {
    "label": "prio_push()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prio_push(*(op->elem))"
  },
  {
    "label": "prio_pop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prio_pop()"
  },
  {
    "label": "internal_reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_reserve(prio_operation *op)"
  },
  {
    "label": "reserved_item()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserved_item(op->elem)"
  },
  {
    "label": "internal_consume()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_consume(prio_operation *op)"
  },
  {
    "label": "input_type()",
    "kind": "Method",
    "detail": "Function (this -> my_reserved = false ; reserved_item =)",
    "insertText": "input_type()"
  },
  {
    "label": "internal_release()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_release(prio_operation *op)"
  },
  {
    "label": "prio_push()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prio_push(reserved_item)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(mark == this->my_tail, \"mark unequal after heapify\")"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (task* new_task = this -> my_successors .)",
    "insertText": "try_put_task(this->prio())"
  },
  {
    "label": "prio_use_tail()",
    "kind": "Method",
    "detail": "Function (} } private : Compare compare ; size_type mark ; input_type reserved_item ; bool)",
    "insertText": "prio_use_tail()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(mark <= this->my_tail, \"mark outside bounds before test\")"
  },
  {
    "label": "prio_push()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "prio_push(const T &src)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(mark < this->my_tail, \"mark outside bounds after push\")"
  },
  {
    "label": "destroy_item()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "destroy_item(this->my_tail-1)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(mark <= this->my_tail, \"mark outside bounds after pop\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(this->my_item_valid(this->my_tail - 1), NULL)"
  },
  {
    "label": "move_item()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "move_item(0,this->my_tail - 1)"
  },
  {
    "label": "prio()",
    "kind": "Method",
    "detail": "Function (} const T&)",
    "insertText": "prio()"
  },
  {
    "label": "heapify()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "heapify()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mark = 0 ; return ; })",
    "insertText": "if(!mark)"
  },
  {
    "label": "fetch_item()",
    "kind": "Method",
    "detail": "Function (size_type cur_pos = mark ; input_type to_place ; this ->)",
    "insertText": "fetch_item(mark,to_place)"
  },
  {
    "label": "move_item()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "move_item(cur_pos, parent)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (cur_pos = parent ; })",
    "insertText": "while(cur_pos)"
  },
  {
    "label": "reheap()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "reheap()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (size_type cur_pos = 0,child = 1 ;)",
    "insertText": "while(child < mark)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_type target = child ;)",
    "insertText": "if(child+1<mark && compare(this->get_my_item(child), this->get_my_item(child+1)))"
  },
  {
    "label": "swap_items()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "swap_items(cur_pos, target)"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (cur_pos = target ;)",
    "insertText": "child(cur_pos<<1)"
  },
  {
    "label": "__TBB_DEPRECATED_LIMITER_EXPR()",
    "kind": "Method",
    "detail": "Function (} } } ; } namespace interface11 { using namespace interface10 ; namespace internal = interface10::internal ; template<T,DecrementType = continue_msg> class limiter_node : public graph_node,public receiver<T>,public sender<T> { public : typedef T input_type ; typedef T output_type ; typedef receiver<input_type>::predecessor_type predecessor_type ; typedef sender<output_type>::successor_type successor_type ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef receiver<input_type>::built_predecessors_type built_predecessors_type ; typedef sender<output_type>::built_successors_type built_successors_type ; typedef receiver<input_type>::predecessor_list_type predecessor_list_type ; typedef sender<output_type>::successor_list_type successor_list_type ; # endif private : size_t my_threshold ; size_t my_count ; size_t my_tries ; internal::reservable_predecessor_cache<T,spin_mutex> my_predecessors ; spin_mutex my_mutex ; internal::broadcast_cache<T> my_successors ;)",
    "insertText": "__TBB_DEPRECATED_LIMITER_EXPR(int init_decrement_predecessors;)"
  },
  {
    "label": "check_conditions()",
    "kind": "Method",
    "detail": "Function (class internal::decrementer<limiter_node<T,DecrementType>,DecrementType> ; bool)",
    "insertText": "check_conditions()"
  },
  {
    "label": "forward_task()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "forward_task()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (reserved = true ;)",
    "insertText": "if((rval = my_successors.try_put_task(v)) != NULL)"
  },
  {
    "label": "try_consume()",
    "kind": "Method",
    "detail": "Function (+ + my_count ; - - my_tries ; my_predecessors .)",
    "insertText": "try_consume()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (task* rtask =)",
    "insertText": "new(task::allocate_additional_child_of( *(this->my_graph.root_task()) ) ) internal::forward_task_bypass< limiter_node<T, DecrementType> >( *this)"
  },
  {
    "label": "spawn_in_graph_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn_in_graph_arena(graph_reference(), *rtask)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - my_tries ;)",
    "insertText": "if(reserved) my_predecessors.try_release()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!rval, \"Have two tasks to handle\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(false, \"Should never be called\")"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "initialize()"
  },
  {
    "label": "fgt_node()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node(tbb::internal::FLOW_LIMITER_NODE, &this->my_graph, static_cast<receiver<input_type> *>(this), static_cast<receiver<DecrementType> *>(&decrement), static_cast<sender<output_type> *>(this))"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (} public : internal::decrementer<limiter_node<T,DecrementType>,DecrementType> decrement ; # if TBB_DEPRECATED_LIMITER_NODE_CONSTRUCTOR)",
    "insertText": "__TBB_STATIC_ASSERT((tbb::internal::is_same_type<DecrementType, continue_msg>::value), \"Deprecated interface of the limiter node can be used only in conjunction \" \"with continue_msg as the type of DecrementType template parameter.\")"
  },
  {
    "label": "limiter_node()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "limiter_node(graph &g, __TBB_DEPRECATED_LIMITER_ARG2(size_t threshold, int num_decrement_predecessors=0)) : graph_node(g), my_threshold(threshold), my_count(0), __TBB_DEPRECATED_LIMITER_ARG4( my_tries(0), decrement(), init_decrement_predecessors(num_decrement_predecessors), decrement(num_decrement_predecessors))"
  },
  {
    "label": "limiter_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "limiter_node(const limiter_node& src ) : graph_node(src.my_graph), receiver<T>(), sender<T>(), my_threshold(src.my_threshold), my_count(0), __TBB_DEPRECATED_LIMITER_ARG4( my_tries(0), decrement(), init_decrement_predecessors(src.init_decrement_predecessors), decrement(src.init_decrement_predecessors))"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (bool was_empty = my_successors .)",
    "insertText": "empty()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (task* task =)",
    "insertText": "new(task::allocate_additional_child_of( *(this->my_graph.root_task()) ) ) internal::forward_task_bypass < limiter_node<T, DecrementType> >( *this)"
  },
  {
    "label": "spawn_in_graph_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn_in_graph_arena(graph_reference(), *task)"
  },
  {
    "label": "internal_add_built_successor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_add_built_successor(successor_type &src)"
  },
  {
    "label": "internal_add_built_successor()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "internal_add_built_successor(src)"
  },
  {
    "label": "internal_delete_built_successor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_successor(successor_type &src)"
  },
  {
    "label": "internal_delete_built_successor()",
    "kind": "Method",
    "detail": "Function (my_successors .)",
    "insertText": "internal_delete_built_successor(src)"
  },
  {
    "label": "internal_add_built_predecessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_add_built_predecessor(predecessor_type &src)"
  },
  {
    "label": "internal_add_built_predecessor()",
    "kind": "Method",
    "detail": "Function (my_predecessors .)",
    "insertText": "internal_add_built_predecessor(src)"
  },
  {
    "label": "internal_delete_built_predecessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_predecessor(predecessor_type &src)"
  },
  {
    "label": "internal_delete_built_predecessor()",
    "kind": "Method",
    "detail": "Function (my_predecessors .)",
    "insertText": "internal_delete_built_predecessor(src)"
  },
  {
    "label": "copy_predecessors()",
    "kind": "Method",
    "detail": "Function (my_predecessors .)",
    "insertText": "copy_predecessors(v)"
  },
  {
    "label": "built_predecessors()",
    "kind": "Method",
    "detail": "Function (decrement .)",
    "insertText": "built_predecessors().receiver_extract(decrement)"
  },
  {
    "label": "register_predecessor()",
    "kind": "Method",
    "detail": "Function (} # endif bool)",
    "insertText": "register_predecessor(predecessor_type &src)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (my_predecessors .)",
    "insertText": "add(src)"
  },
  {
    "label": "remove_predecessor()",
    "kind": "Method",
    "detail": "Function (} return true ; } bool)",
    "insertText": "remove_predecessor(predecessor_type &src)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (my_predecessors .)",
    "insertText": "remove(src)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - my_tries ;)",
    "insertText": "if(check_conditions() && internal::is_graph_active(this->my_graph))"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(false,NULL)"
  },
  {
    "label": "join_node()",
    "kind": "Method",
    "detail": "Function (} } ; } namespace interface10 { # include \" internal / _flow_graph_join_impl . h \" using internal::reserving_port ; using internal::queueing_port ; using internal::key_matching_port ; using internal::input_port ; using internal::tag_value ; template<OutputTuple,JP = queueing> class join_node ; template<OutputTuple> class join_node<OutputTuple,reserving> : public internal::unfolded_join_node<tbb::flow::tuple_size<OutputTuple>::value,reserving_port,OutputTuple,reserving> { private : const int N = tbb::flow::tuple_size<OutputTuple>::value ; typedef internal::unfolded_join_node<N,reserving_port,OutputTuple,reserving> unfolded_type ; public : typedef OutputTuple output_type ; typedef unfolded_type::input_ports_type input_ports_type ;)",
    "insertText": "join_node(graph &g) : unfolded_type(g)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::internal::fgt_multiinput_node<)",
    "insertText": "N(tbb::internal::FLOW_JOIN_NODE_RESERVING, &this->my_graph, this->input_ports(), static_cast< sender< output_type > *>(this))"
  },
  {
    "label": "join_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "join_node(const join_node &other) : unfolded_type(other)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::internal::fgt_multiinput_node<)",
    "insertText": "N(tbb::internal::FLOW_JOIN_NODE_QUEUEING, &this->my_graph, this->input_ports(), static_cast< sender< output_type > *>(this))"
  },
  {
    "label": "join_node()",
    "kind": "Method",
    "detail": "Function (} # endif template<__TBB_B0,__TBB_B1>)",
    "insertText": "join_node(graph &g, __TBB_B0 b0, __TBB_B1 b1) : unfolded_type(g, b0, b1)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::internal::fgt_multiinput_node<)",
    "insertText": "N(tbb::internal::FLOW_JOIN_NODE_TAG_MATCHING, &this->my_graph, this->input_ports(), static_cast< sender< output_type > *>(this))"
  },
  {
    "label": "join_node()",
    "kind": "Method",
    "detail": "Function (} template<__TBB_B0,__TBB_B1,__TBB_B2>)",
    "insertText": "join_node(graph &g, __TBB_B0 b0, __TBB_B1 b1, __TBB_B2 b2) : unfolded_type(g, b0, b1, b2)"
  },
  {
    "label": "join_node()",
    "kind": "Method",
    "detail": "Function (} template<__TBB_B0,__TBB_B1,__TBB_B2,__TBB_B3>)",
    "insertText": "join_node(graph &g, __TBB_B0 b0, __TBB_B1 b1, __TBB_B2 b2, __TBB_B3 b3) : unfolded_type(g, b0, b1, b2, b3)"
  },
  {
    "label": "join_node()",
    "kind": "Method",
    "detail": "Function (} template<__TBB_B0,__TBB_B1,__TBB_B2,__TBB_B3,__TBB_B4>)",
    "insertText": "join_node(graph &g, __TBB_B0 b0, __TBB_B1 b1, __TBB_B2 b2, __TBB_B3 b3, __TBB_B4 b4) : unfolded_type(g, b0, b1, b2, b3, b4)"
  },
  {
    "label": "join_node()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_VARIADIC_MAX> = 6 template<__TBB_B0,__TBB_B1,__TBB_B2,__TBB_B3,__TBB_B4,__TBB_B5>)",
    "insertText": "join_node(graph &g, __TBB_B0 b0, __TBB_B1 b1, __TBB_B2 b2, __TBB_B3 b3, __TBB_B4 b4, __TBB_B5 b5) : unfolded_type(g, b0, b1, b2, b3, b4, b5)"
  },
  {
    "label": "join_node()",
    "kind": "Method",
    "detail": "Function (} # endif # if __TBB_VARIADIC_MAX> = 7 template<__TBB_B0,__TBB_B1,__TBB_B2,__TBB_B3,__TBB_B4,__TBB_B5,__TBB_B6>)",
    "insertText": "join_node(graph &g, __TBB_B0 b0, __TBB_B1 b1, __TBB_B2 b2, __TBB_B3 b3, __TBB_B4 b4, __TBB_B5 b5, __TBB_B6 b6) : unfolded_type(g, b0, b1, b2, b3, b4, b5, b6)"
  },
  {
    "label": "join_node()",
    "kind": "Method",
    "detail": "Function (} # endif # if __TBB_VARIADIC_MAX> = 8 template<__TBB_B0,__TBB_B1,__TBB_B2,__TBB_B3,__TBB_B4,__TBB_B5,__TBB_B6,__TBB_B7>)",
    "insertText": "join_node(graph &g, __TBB_B0 b0, __TBB_B1 b1, __TBB_B2 b2, __TBB_B3 b3, __TBB_B4 b4, __TBB_B5 b5, __TBB_B6 b6, __TBB_B7 b7) : unfolded_type(g, b0, b1, b2, b3, b4, b5, b6, b7)"
  },
  {
    "label": "join_node()",
    "kind": "Method",
    "detail": "Function (} # endif # if __TBB_VARIADIC_MAX> = 9 template<__TBB_B0,__TBB_B1,__TBB_B2,__TBB_B3,__TBB_B4,__TBB_B5,__TBB_B6,__TBB_B7,__TBB_B8>)",
    "insertText": "join_node(graph &g, __TBB_B0 b0, __TBB_B1 b1, __TBB_B2 b2, __TBB_B3 b3, __TBB_B4 b4, __TBB_B5 b5, __TBB_B6 b6, __TBB_B7 b7, __TBB_B8 b8) : unfolded_type(g, b0, b1, b2, b3, b4, b5, b6, b7, b8)"
  },
  {
    "label": "join_node()",
    "kind": "Method",
    "detail": "Function (} # endif # if __TBB_VARIADIC_MAX> = 1 0 template<__TBB_B0,__TBB_B1,__TBB_B2,__TBB_B3,__TBB_B4,__TBB_B5,__TBB_B6,__TBB_B7,__TBB_B8,__TBB_B9>)",
    "insertText": "join_node(graph &g, __TBB_B0 b0, __TBB_B1 b1, __TBB_B2 b2, __TBB_B3 b3, __TBB_B4 b4, __TBB_B5 b5, __TBB_B6 b6, __TBB_B7 b7, __TBB_B8 b8, __TBB_B9 b9) : unfolded_type(g, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9)"
  },
  {
    "label": "indexer_node()",
    "kind": "Method",
    "detail": "Function (} # endif } ; # include \" internal / _flow_graph_indexer_impl . h \" template<T0,T1 = null_type,T2 = null_type,T3 = null_type,T4 = null_type,T5 = null_type,T6 = null_type,T7 = null_type,T8 = null_type,T9 = null_type> class indexer_node ; template<T0> class indexer_node<T0> : public internal::unfolded_indexer_node<tuple<T0>> { private : const int N = 1 ; public : typedef tuple<T0> InputTuple ; typedef internal::tagged_msg<size_t,T0> output_type ; typedef internal::unfolded_indexer_node<InputTuple> unfolded_type ;)",
    "insertText": "indexer_node(graph& g) : unfolded_type(g)"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (tbb::internal::fgt_multiinput_node<)",
    "insertText": "N(tbb::internal::FLOW_INDEXER_NODE, &this->my_graph, this->input_ports(), static_cast< sender< output_type > *>(this))"
  },
  {
    "label": "indexer_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "indexer_node(const indexer_node& other ) : unfolded_type(other)"
  },
  {
    "label": "internal_make_edge()",
    "kind": "Method",
    "detail": "Function (} # endif } ; # endif # if __TBB_PREVIEW_ASYNC_MSG void)",
    "insertText": "internal_make_edge(internal::untyped_sender &p, internal::untyped_receiver &s)"
  },
  {
    "label": "internal_make_edge()",
    "kind": "Method",
    "detail": "Function (# else template<T> void)",
    "insertText": "internal_make_edge(sender<T> &p, receiver<T> &s)"
  },
  {
    "label": "internal_add_built_predecessor()",
    "kind": "Method",
    "detail": "Function (# endif # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION s .)",
    "insertText": "internal_add_built_predecessor(p)"
  },
  {
    "label": "internal_add_built_successor()",
    "kind": "Method",
    "detail": "Function (p .)",
    "insertText": "internal_add_built_successor(s)"
  },
  {
    "label": "register_successor()",
    "kind": "Method",
    "detail": "Function (# endif p .)",
    "insertText": "register_successor(s)"
  },
  {
    "label": "fgt_make_edge()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_make_edge(&p, &s)"
  },
  {
    "label": "make_edge()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "make_edge(sender<T> &p, receiver<T> &s)"
  },
  {
    "label": "internal_make_edge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_make_edge(p, s)"
  },
  {
    "label": "make_edge()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_PREVIEW_ASYNC_MSG template<TS,TR,= tbb::internal::enable_if<tbb::internal::is_same_type<TS,internal::untyped_sender>::value | | tbb::internal::is_same_type<TR,internal::untyped_receiver>::value>::type> void)",
    "insertText": "make_edge(TS &p, TR &s)"
  },
  {
    "label": "make_edge()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "make_edge(sender<T> &p, receiver<typename T::async_msg_data_type> &s)"
  },
  {
    "label": "make_edge()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "make_edge(sender<typename T::async_msg_data_type> &p, receiver<T> &s)"
  },
  {
    "label": "make_edge()",
    "kind": "Method",
    "detail": "Function (} # endif # if __TBB_FLOW_GRAPH_CPP11_FEATURES template<T,V,= T::output_ports_type,= V::input_ports_type> void)",
    "insertText": "make_edge(T& output, V& input)"
  },
  {
    "label": "make_edge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "make_edge(get<0>(output.output_ports()), get<0>(input.input_ports()))"
  },
  {
    "label": "make_edge()",
    "kind": "Method",
    "detail": "Function (} template<T,R,= T::output_ports_type> void)",
    "insertText": "make_edge(T& output, receiver<R>& input)"
  },
  {
    "label": "make_edge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "make_edge(get<0>(output.output_ports()), input)"
  },
  {
    "label": "make_edge()",
    "kind": "Method",
    "detail": "Function (} template<S,V,= V::input_ports_type> void)",
    "insertText": "make_edge(sender<S>& output, V& input)"
  },
  {
    "label": "make_edge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "make_edge(output, get<0>(input.input_ports()))"
  },
  {
    "label": "internal_remove_edge()",
    "kind": "Method",
    "detail": "Function (} # endif # if __TBB_PREVIEW_ASYNC_MSG void)",
    "insertText": "internal_remove_edge(internal::untyped_sender &p, internal::untyped_receiver &s)"
  },
  {
    "label": "internal_remove_edge()",
    "kind": "Method",
    "detail": "Function (# else template<T> void)",
    "insertText": "internal_remove_edge(sender<T> &p, receiver<T> &s)"
  },
  {
    "label": "remove_successor()",
    "kind": "Method",
    "detail": "Function (# endif p .)",
    "insertText": "remove_successor(s)"
  },
  {
    "label": "internal_delete_built_successor()",
    "kind": "Method",
    "detail": "Function (# if TBB_DEPRECATED_FLOW_NODE_EXTRACTION p .)",
    "insertText": "internal_delete_built_successor(s)"
  },
  {
    "label": "internal_delete_built_predecessor()",
    "kind": "Method",
    "detail": "Function (s .)",
    "insertText": "internal_delete_built_predecessor(p)"
  },
  {
    "label": "fgt_remove_edge()",
    "kind": "Method",
    "detail": "Function (# endif tbb::)",
    "insertText": "fgt_remove_edge(&p, &s)"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "remove_edge(sender<T> &p, receiver<T> &s)"
  },
  {
    "label": "internal_remove_edge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_remove_edge(p, s)"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_PREVIEW_ASYNC_MSG template<TS,TR,= tbb::internal::enable_if<tbb::internal::is_same_type<TS,internal::untyped_sender>::value | | tbb::internal::is_same_type<TR,internal::untyped_receiver>::value>::type> void)",
    "insertText": "remove_edge(TS &p, TR &s)"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "remove_edge(sender<T> &p, receiver<typename T::async_msg_data_type> &s)"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "remove_edge(sender<typename T::async_msg_data_type> &p, receiver<T> &s)"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (} # endif # if __TBB_FLOW_GRAPH_CPP11_FEATURES template<T,V,= T::output_ports_type,= V::input_ports_type> void)",
    "insertText": "remove_edge(T& output, V& input)"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove_edge(get<0>(output.output_ports()), get<0>(input.input_ports()))"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (} template<T,R,= T::output_ports_type> void)",
    "insertText": "remove_edge(T& output, receiver<R>& input)"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove_edge(get<0>(output.output_ports()), input)"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (} template<S,V,= V::input_ports_type> void)",
    "insertText": "remove_edge(sender<S>& output, V& input)"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove_edge(output, get<0>(input.input_ports()))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (edge_list_type e = built_edges ;)",
    "insertText": "for(typename edge_list_type::iterator i = e.begin(); i != e.end(); ++i)"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove_edge(s, **i)"
  },
  {
    "label": "remove_edge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove_edge(**i, r)"
  },
  {
    "label": "copy_body()",
    "kind": "Method",
    "detail": "Function (} } # endif template<Body,Node> Body)",
    "insertText": "copy_body(Node &n)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_FLOW_GRAPH_CPP11_FEATURES template<InputTuple,OutputTuple> class composite_node ; template<. . . InputTypes,. . . OutputTypes> class composite_node<tbb::flow::tuple<InputTypes . . .>,tbb::flow::tuple<OutputTypes . . .>> : public graph_node { public : typedef tbb::flow::tuple<receiver<InputTypes>& . . .> input_ports_type ; typedef tbb::flow::tuple<sender<OutputTypes>& . . .> output_ports_type ; private : std::unique_ptr<input_ports_type> my_input_ports ; std::unique_ptr<output_ports_type> my_output_ports ; const size_t NUM_INPUTS =)",
    "insertText": "sizeof(InputTypes)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const size_t NUM_OUTPUTS =)",
    "insertText": "sizeof(OutputTypes)"
  },
  {
    "label": "reset_node()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "reset_node(reset_flags)"
  },
  {
    "label": "composite_node()",
    "kind": "Method",
    "detail": "Function (} public : # if TBB_PREVIEW_FLOW_GRAPH_TRACE)",
    "insertText": "composite_node(graph &g, const char *type_name = \"composite_node\" ) : graph_node(g)"
  },
  {
    "label": "fgt_multiinput_multioutput_node()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_multiinput_multioutput_node(tbb::internal::FLOW_COMPOSITE_NODE, this, &this->my_graph)"
  },
  {
    "label": "fgt_multiinput_multioutput_node_desc()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_multiinput_multioutput_node_desc(this, type_name)"
  },
  {
    "label": "composite_node()",
    "kind": "Method",
    "detail": "Function (} # else)",
    "insertText": "composite_node(graph &g ) : graph_node(g)"
  },
  {
    "label": "set_external_ports()",
    "kind": "Method",
    "detail": "Function (} # endif template<T1,T2> void)",
    "insertText": "set_external_ports(T1&& input_ports_tuple, T2&& output_ports_tuple)"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(NUM_INPUTS == tbb::flow::tuple_size<input_ports_type>::value, \"number of arguments does not match number of input ports\")"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(NUM_OUTPUTS == tbb::flow::tuple_size<output_ports_type>::value, \"number of arguments does not match number of output ports\")"
  },
  {
    "label": "input_ports_type()",
    "kind": "Method",
    "detail": "Function (my_input_ports = tbb::internal::make_unique<)",
    "insertText": "input_ports_type(std::forward<T1>(input_ports_tuple))"
  },
  {
    "label": "output_ports_type()",
    "kind": "Method",
    "detail": "Function (my_output_ports = tbb::internal::make_unique<)",
    "insertText": "output_ports_type(std::forward<T2>(output_ports_tuple))"
  },
  {
    "label": "alias_port()",
    "kind": "Method",
    "detail": "Function (tbb::internal::fgt_internal_input_alias_helper<T1,NUM_INPUTS)",
    "insertText": "alias_port(this, input_ports_tuple)"
  },
  {
    "label": "alias_port()",
    "kind": "Method",
    "detail": "Function (tbb::internal::fgt_internal_output_alias_helper<T2,NUM_OUTPUTS)",
    "insertText": "alias_port(this, output_ports_tuple)"
  },
  {
    "label": "add_visible_nodes()",
    "kind": "Method",
    "detail": "Function (} template<. . . NodeTypes> void)",
    "insertText": "add_visible_nodes(const NodeTypes&... n)"
  },
  {
    "label": "add_nodes_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add_nodes_impl(this, true, n...)"
  },
  {
    "label": "add_nodes()",
    "kind": "Method",
    "detail": "Function (} template<. . . NodeTypes> void)",
    "insertText": "add_nodes(const NodeTypes&... n)"
  },
  {
    "label": "add_nodes_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add_nodes_impl(this, false, n...)"
  },
  {
    "label": "fgt_multiinput_multioutput_node_desc()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_multiinput_multioutput_node_desc(this, name)"
  },
  {
    "label": "input_ports()",
    "kind": "Method",
    "detail": "Function (} # endif input_ports_type&)",
    "insertText": "input_ports()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_input_ports, \"input ports not set, call set_external_ports to set input ports\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_output_ports, \"output ports not set, call set_external_ports to set output ports\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(false, \"Current composite_node implementation does not support extract\")"
  },
  {
    "label": "composite_node()",
    "kind": "Method",
    "detail": "Function (} public : # if TBB_PREVIEW_FLOW_GRAPH_TRACE)",
    "insertText": "composite_node(graph &g, const char *type_name = \"composite_node\") : graph_node(g)"
  },
  {
    "label": "fgt_composite()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_composite(this, &g)"
  },
  {
    "label": "set_external_ports()",
    "kind": "Method",
    "detail": "Function (} # endif template<T> void)",
    "insertText": "set_external_ports(T&& input_ports_tuple)"
  },
  {
    "label": "input_ports_type()",
    "kind": "Method",
    "detail": "Function (my_input_ports = tbb::internal::make_unique<)",
    "insertText": "input_ports_type(std::forward<T>(input_ports_tuple))"
  },
  {
    "label": "alias_port()",
    "kind": "Method",
    "detail": "Function (tbb::internal::fgt_internal_input_alias_helper<T,NUM_INPUTS)",
    "insertText": "alias_port(this, std::forward<T>(input_ports_tuple))"
  },
  {
    "label": "set_external_ports()",
    "kind": "Method",
    "detail": "Function (} # endif template<T> void)",
    "insertText": "set_external_ports(T&& output_ports_tuple)"
  },
  {
    "label": "output_ports_type()",
    "kind": "Method",
    "detail": "Function (my_output_ports = tbb::internal::make_unique<)",
    "insertText": "output_ports_type(std::forward<T>(output_ports_tuple))"
  },
  {
    "label": "alias_port()",
    "kind": "Method",
    "detail": "Function (tbb::internal::fgt_internal_output_alias_helper<T,NUM_OUTPUTS)",
    "insertText": "alias_port(this, std::forward<T>(output_ports_tuple))"
  },
  {
    "label": "async_body_base()",
    "kind": "Method",
    "detail": "Function (} # endif } ; # endif namespace internal { template<Gateway> class async_body_base : tbb::internal::no_assign { public : typedef Gateway gateway_type ;)",
    "insertText": "async_body_base(gateway_type *gateway): my_gateway(gateway)"
  },
  {
    "label": "set_gateway()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_gateway(gateway_type *gateway)"
  },
  {
    "label": "async_body()",
    "kind": "Method",
    "detail": "Function (my_gateway = gateway ; } protected : gateway_type* my_gateway ; } ; template<Input,Ports,Gateway,Body> class async_body : public async_body_base<Gateway> { public : typedef async_body_base<Gateway> base_type ; typedef Gateway gateway_type ;)",
    "insertText": "async_body(const Body &body, gateway_type *gateway) : base_type(gateway), my_body(body)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()( const Input &v, Ports &)"
  },
  {
    "label": "my_body()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "my_body(v, *this->my_gateway)"
  },
  {
    "label": "get_body()",
    "kind": "Method",
    "detail": "Function (} Body)",
    "insertText": "get_body()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()()"
  },
  {
    "label": "try_put()",
    "kind": "Method",
    "detail": "Function (result = port ->)",
    "insertText": "try_put(*value)"
  },
  {
    "label": "receiver_gateway_impl()",
    "kind": "Method",
    "detail": "Function (} } ; class receiver_gateway_impl : public receiver_gateway<Output> { public :)",
    "insertText": "receiver_gateway_impl(async_node* node): my_node(node)"
  },
  {
    "label": "fgt_async_reserve()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_async_reserve(static_cast<typename async_node::receiver_type *>(my_node), &my_node->my_graph)"
  },
  {
    "label": "fgt_async_commit()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_async_commit(static_cast<typename async_node::receiver_type *>(my_node), &my_node->my_graph)"
  },
  {
    "label": "try_put()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "try_put(const Output &i)"
  },
  {
    "label": "self()",
    "kind": "Method",
    "detail": "Function (} private : async_node* my_node ; } my_gateway ; async_node*)",
    "insertText": "self()"
  },
  {
    "label": "output_port()",
    "kind": "Method",
    "detail": "Function (internal::multifunction_output<Output>& port_0 =)",
    "insertText": "output_port(*this)"
  },
  {
    "label": "fgt_async_try_put_begin()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_async_try_put_begin(this, &port_0)"
  },
  {
    "label": "gather_successful_try_puts()",
    "kind": "Method",
    "detail": "Function (task_list tasks ; bool is_at_least_one_put_successful = port_successors .)",
    "insertText": "gather_successful_try_puts(i, tasks)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(is_at_least_one_put_successful || tasks.empty(), \"Return status is inconsistent with the method operation.\")"
  },
  {
    "label": "enqueue_in_graph_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enqueue_in_graph_arena(this->my_graph, tasks.pop_front())"
  },
  {
    "label": "fgt_async_try_put_end()",
    "kind": "Method",
    "detail": "Function (} tbb::)",
    "insertText": "fgt_async_try_put_end(this, &port_0)"
  },
  {
    "label": "fgt_multioutput_node_with_body()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_multioutput_node_with_body(tbb::internal::FLOW_ASYNC_NODE, &this->my_graph, static_cast<receiver<input_type> *>(this), this->output_ports(), this->my_body)"
  },
  {
    "label": "async_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "async_node(const async_node &other ) : base_type(other), sender<Output>(), my_gateway(self())"
  },
  {
    "label": "async_body_base_type()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "async_body_base_type(this->my_body->get_body_ptr())->set_gateway(&my_gateway)"
  },
  {
    "label": "async_body_base_type()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "async_body_base_type(this->my_init_body->get_body_ptr())->set_gateway(&my_gateway)"
  },
  {
    "label": "gateway()",
    "kind": "Method",
    "detail": "Function (} gateway_type&)",
    "insertText": "gateway()"
  },
  {
    "label": "async_body_type()",
    "kind": "Method",
    "detail": "Function (typedef internal::multifunction_body<input_type,base_type::output_ports_type> mfn_body_type ; typedef internal::async_body<Input,base_type::output_ports_type,gateway_type,Body> async_body_type ; mfn_body_type& body_ref =* this -> my_body ; async_body_type ab =* static_cast<)",
    "insertText": "async_body_type(dynamic_cast< internal::multifunction_body_leaf<input_type, typename base_type::output_ports_type, async_body_type> & >(body_ref).get_body_ptr())"
  },
  {
    "label": "output_port()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "output_port(*this).internal_add_built_successor(r)"
  },
  {
    "label": "output_port()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "output_port(*this).internal_delete_built_successor(r)"
  },
  {
    "label": "copy_successors()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "copy_successors(successor_list_type &l)"
  },
  {
    "label": "output_port()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "output_port(*this).copy_successors(l)"
  },
  {
    "label": "overwrite_node()",
    "kind": "Method",
    "detail": "Function (} } ; # if __TBB_PREVIEW_STREAMING_NODE # include \" internal / _flow_graph_streaming_node . h \" # endif } namespace interface10a { using namespace interface10 ; namespace internal = interface10::internal ; template<T> class overwrite_node : public graph_node,public receiver<T>,public sender<T> { public : typedef T input_type ; typedef T output_type ; typedef receiver<input_type>::predecessor_type predecessor_type ; typedef sender<output_type>::successor_type successor_type ; # if TBB_DEPRECATED_FLOW_NODE_EXTRACTION typedef receiver<input_type>::built_predecessors_type built_predecessors_type ; typedef sender<output_type>::built_successors_type built_successors_type ; typedef receiver<input_type>::predecessor_list_type predecessor_list_type ; typedef sender<output_type>::successor_list_type successor_list_type ; # endif)",
    "insertText": "overwrite_node(graph &g) : graph_node(g), my_buffer_is_valid(false)"
  },
  {
    "label": "fgt_node()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node(tbb::internal::FLOW_OVERWRITE_NODE, &this->my_graph, static_cast<receiver<input_type> *>(this), static_cast<sender<output_type> *>(this))"
  },
  {
    "label": "overwrite_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "overwrite_node(const overwrite_node& src ) : graph_node(src.my_graph), receiver<T>(), sender<T>(), my_buffer_is_valid(false)"
  },
  {
    "label": "overwrite_node()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "overwrite_node()"
  },
  {
    "label": "register_successor()",
    "kind": "Method",
    "detail": "Function (} # endif bool)",
    "insertText": "register_successor(successor_type &s)"
  },
  {
    "label": "try_put()",
    "kind": "Method",
    "detail": "Function (bool ret = s .)",
    "insertText": "try_put(my_buffer)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} else { task* rtask =)",
    "insertText": "new(task::allocate_additional_child_of( *( my_graph.root_task() ) ) ) register_predecessor_task( *this, s)"
  },
  {
    "label": "spawn_in_graph_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "spawn_in_graph_arena(my_graph, *rtask)"
  },
  {
    "label": "remove_successor()",
    "kind": "Method",
    "detail": "Function (} return true ; } bool)",
    "insertText": "remove_successor(successor_type &s)"
  },
  {
    "label": "internal_add_built_successor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_add_built_successor(successor_type &s)"
  },
  {
    "label": "internal_delete_built_successor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_delete_built_successor(successor_type &s)"
  },
  {
    "label": "try_get()",
    "kind": "Method",
    "detail": "Function (} # endif bool)",
    "insertText": "try_get(input_type &v)"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (my_buffer_is_valid = false ; } protected : template<R,B> class run_and_put_task ; template<X,Y> class internal::broadcast_cache ; template<X,Y> class internal::round_robin_cache ; task*)",
    "insertText": "try_put_task(const input_type &v)"
  },
  {
    "label": "try_put_task_impl()",
    "kind": "Method",
    "detail": "Function (} task*)",
    "insertText": "try_put_task_impl(const input_type &v)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (my_buffer_is_valid = false ;)",
    "insertText": "if(f&rf_clear_edges)"
  },
  {
    "label": "write_once_node()",
    "kind": "Method",
    "detail": "Function (} } } ; template<T> class write_once_node : public overwrite_node<T> { public : typedef T input_type ; typedef T output_type ; typedef overwrite_node<T> base_type ; typedef receiver<input_type>::predecessor_type predecessor_type ; typedef sender<output_type>::successor_type successor_type ;)",
    "insertText": "write_once_node(graph& g) : base_type(g)"
  },
  {
    "label": "fgt_node()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "fgt_node(tbb::internal::FLOW_WRITE_ONCE_NODE, &(this->my_graph), static_cast<receiver<input_type> *>(this), static_cast<sender<output_type> *>(this))"
  },
  {
    "label": "write_once_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "write_once_node(const write_once_node& src ) : base_type(src)"
  },
  {
    "label": "try_put_task()",
    "kind": "Method",
    "detail": "Function (} # endif protected : template<R,B> class run_and_put_task ; template<X,Y> class internal::broadcast_cache ; template<X,Y> class internal::round_robin_cache ; task*)",
    "insertText": "try_put_task(const T &v)"
  },
  {
    "label": "l()",
    "kind": "Method",
    "detail": "Function (spin_mutex::scoped_lock)",
    "insertText": "l(this->my_mutex)"
  }
]