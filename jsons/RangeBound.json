[
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "TRangeBound",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRangeBound"
  },
  {
    "label": "FArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FArchive"
  },
  {
    "label": "Name",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Name"
  },
  {
    "label": "TIsBitwiseConstructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsBitwiseConstructible"
  },
  {
    "label": "TRangeBound()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / AssertionMacros . h \" # include \" Templates / TypeHash . h \" # include \" Containers / EnumAsByte . h \" # include \" Misc / FrameNumber . h \" # include \" Misc / DateTime . h \" namespace ERangeBoundTypes { enum Type { Exclusive,Inclusive,Open } ; } template<ElementType> class TRangeBound { public : typedef TCallTraits<ElementType>::ParamType ElementValueOrConstRef ;)",
    "insertText": "TRangeBound() : Type(ERangeBoundTypes::Open) , Value()"
  },
  {
    "label": "TRangeBound()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TRangeBound(ElementValueOrConstRef InValue) : Type(ERangeBoundTypes::Inclusive) , Value(InValue)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "operator(const TRangeBound& Other)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (} public : ElementValueOrConstRef)",
    "insertText": "GetValue()"
  },
  {
    "label": "IsClosed()",
    "kind": "Method",
    "detail": "Function (Value = NewValue ; } bool)",
    "insertText": "IsClosed()"
  },
  {
    "label": "IsExclusive()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsExclusive()"
  },
  {
    "label": "IsInclusive()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsInclusive()"
  },
  {
    "label": "IsOpen()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsOpen()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} public : class FArchive&)",
    "insertText": "operator(class FArchive& Ar, TRangeBound& Bound)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(const TRangeBound& Bound)"
  },
  {
    "label": "Exclusive()",
    "kind": "Method",
    "detail": "Function (} public : TRangeBound)",
    "insertText": "Exclusive(ElementValueOrConstRef Value)"
  },
  {
    "label": "Inclusive()",
    "kind": "Method",
    "detail": "Function (TRangeBound Result ; Result . Type = ERangeBoundTypes::Exclusive ; Result . Value = Value ; return Result ; } TRangeBound)",
    "insertText": "Inclusive(ElementValueOrConstRef Value)"
  },
  {
    "label": "Open()",
    "kind": "Method",
    "detail": "Function (TRangeBound Result ; Result . Type = ERangeBoundTypes::Inclusive ; Result . Value = Value ; return Result ; } TRangeBound)",
    "insertText": "Open()"
  },
  {
    "label": "FlipInclusion()",
    "kind": "Method",
    "detail": "Function (TRangeBound Result ; Result . Type = ERangeBoundTypes::Open ; return Result ; } public : TRangeBound)",
    "insertText": "FlipInclusion(const TRangeBound& Bound)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Bound.IsInclusive())"
  },
  {
    "label": "MaxLower()",
    "kind": "Method",
    "detail": "Function (} return Bound ; } const TRangeBound&)",
    "insertText": "MaxLower(const TRangeBound& A, const TRangeBound& B)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ private : \\ typedef TRangeBound<ElementType> Super ; \\ \\ public : \\)",
    "insertText": "Name() \\ : Super()"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (} \\ \\)",
    "insertText": "Name(const Super& Other) \\ : Super(Other)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (} \\ \\)",
    "insertText": "Name(const ElementType InValue) \\ : Super(InValue)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ return static_cast<const)",
    "insertText": "Name(Super::Exclusive(Value))"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ return static_cast<const)",
    "insertText": "Name(Super::Inclusive(Value))"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ return static_cast<const)",
    "insertText": "Name(Super::Open())"
  },
  {
    "label": "FlipInclusion()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\ Name)",
    "insertText": "FlipInclusion(const Name& Bound)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ return static_cast<const)",
    "insertText": "Name(Super::FlipInclusion(Bound))"
  },
  {
    "label": "MaxLower()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\ const Name&)",
    "insertText": "MaxLower(const Name& A, const Name& B)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ return static_cast<const)",
    "insertText": "Name(Super::MaxLower(A, B))"
  },
  {
    "label": "MaxUpper()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\ const Name&)",
    "insertText": "MaxUpper(const Name& A, const Name& B)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ return static_cast<const)",
    "insertText": "Name(Super::MaxUpper(A, B))"
  },
  {
    "label": "MinLower()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\ const Name&)",
    "insertText": "MinLower(const Name& A, const Name& B)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ return static_cast<const)",
    "insertText": "Name(Super::MinLower(A, B))"
  },
  {
    "label": "MinUpper()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\ const Name&)",
    "insertText": "MinUpper(const Name& A, const Name& B)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ return static_cast<const)",
    "insertText": "Name(Super::MinUpper(A, B))"
  }
]