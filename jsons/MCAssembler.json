[
  {
    "label": "raw_ostream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "raw_ostream"
  },
  {
    "label": "MCAsmLayout",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCAsmLayout"
  },
  {
    "label": "MCAssembler",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCAssembler"
  },
  {
    "label": "MCContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCContext"
  },
  {
    "label": "MCCodeEmitter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCCodeEmitter"
  },
  {
    "label": "MCExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCExpr"
  },
  {
    "label": "MCFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCFragment"
  },
  {
    "label": "MCObjectWriter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCObjectWriter"
  },
  {
    "label": "MCSection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCSection"
  },
  {
    "label": "MCSubtargetInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCSubtargetInfo"
  },
  {
    "label": "MCValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCValue"
  },
  {
    "label": "MCAsmBackend",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCAsmBackend"
  },
  {
    "label": "FragmentType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "FragmentType"
  },
  {
    "label": "ilist_sentinel_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ilist_sentinel_traits"
  },
  {
    "label": "MCEncodedFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCEncodedFragment"
  },
  {
    "label": "MCEncodedFragmentWithContents",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCEncodedFragmentWithContents"
  },
  {
    "label": "MCEncodedFragmentWithFixups",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCEncodedFragmentWithFixups"
  },
  {
    "label": "MCDataFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCDataFragment"
  },
  {
    "label": "MCCompactEncodedInstFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCCompactEncodedInstFragment"
  },
  {
    "label": "MCRelaxableFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCRelaxableFragment"
  },
  {
    "label": "MCAlignFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCAlignFragment"
  },
  {
    "label": "MCFillFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCFillFragment"
  },
  {
    "label": "MCOrgFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCOrgFragment"
  },
  {
    "label": "MCLEBFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCLEBFragment"
  },
  {
    "label": "MCDwarfLineAddrFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCDwarfLineAddrFragment"
  },
  {
    "label": "MCDwarfCallFrameFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCDwarfCallFrameFragment"
  },
  {
    "label": "MCSafeSEHFragment",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCSafeSEHFragment"
  },
  {
    "label": "IndirectSymbolData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IndirectSymbolData"
  },
  {
    "label": "DataRegionData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DataRegionData"
  },
  {
    "label": "KindTy",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "KindTy"
  },
  {
    "label": "MCFragment()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_MC_MCASSEMBLER_H # define LLVM_MC_MCASSEMBLER_H # include \" llvm / ADT / DenseMap . h \" # include \" llvm / ADT / DenseSet . h \" # include \" llvm / ADT / SmallPtrSet . h \" # include \" llvm / ADT / SmallString . h \" # include \" llvm / ADT / ilist . h \" # include \" llvm / ADT / ilist_node . h \" # include \" llvm / ADT / iterator . h \" # include \" llvm / MC / MCDirectives . h \" # include \" llvm / MC / MCFixup . h \" # include \" llvm / MC / MCInst . h \" # include \" llvm / MC / MCLinkerOptimizationHint . h \" # include \" llvm / MC / MCSection . h \" # include \" llvm / MC / MCSubtargetInfo . h \" # include \" llvm / Support / Casting . h \" # include \" llvm / Support / DataTypes . h \" # include<algorithm> # include<vector> namespace llvm { class raw_ostream ; class MCAsmLayout ; class MCAssembler ; class MCContext ; class MCCodeEmitter ; class MCExpr ; class MCFragment ; class MCObjectWriter ; class MCSection ; class MCSubtargetInfo ; class MCValue ; class MCAsmBackend ; class MCFragment : public ilist_node<MCFragment> { class MCAsmLayout ;)",
    "insertText": "MCFragment(const MCFragment &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const MCFragment &)"
  },
  {
    "label": "MCFragment()",
    "kind": "Method",
    "detail": "Function (public : enum FragmentType : uint8_t { FT_Align,FT_Data,FT_CompactEncodedInst,FT_Fill,FT_Relaxable,FT_Org,FT_Dwarf,FT_DwarfFrame,FT_LEB,FT_SafeSEH } ; private : FragmentType Kind ; protected : bool HasInstructions ; private : bool AlignToBundleEnd ; uint8_t BundlePadding ; unsigned LayoutOrder ; MCSection* Parent ; const MCSymbol* Atom ; uint64_t Offset ; protected :)",
    "insertText": "MCFragment(FragmentType Kind, bool HasInstructions, uint8_t BundlePadding, MCSection *Parent = nullptr)"
  },
  {
    "label": "MCFragment()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "MCFragment()"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "destroy()"
  },
  {
    "label": "getKind()",
    "kind": "Method",
    "detail": "Function (FragmentType)",
    "insertText": "getKind()"
  },
  {
    "label": "getAtom()",
    "kind": "Method",
    "detail": "Function (Parent = Value ; } const MCSymbol*)",
    "insertText": "getAtom()"
  },
  {
    "label": "getLayoutOrder()",
    "kind": "Method",
    "detail": "Function (Atom = Value ; } unsigned)",
    "insertText": "getLayoutOrder()"
  },
  {
    "label": "hasInstructions()",
    "kind": "Method",
    "detail": "Function (LayoutOrder = Value ; } bool)",
    "insertText": "hasInstructions()"
  },
  {
    "label": "getBundlePadding()",
    "kind": "Method",
    "detail": "Function (AlignToBundleEnd = V ; } uint8_t)",
    "insertText": "getBundlePadding()"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (BundlePadding = N ; } void)",
    "insertText": "dump()"
  },
  {
    "label": "MCEncodedFragment()",
    "kind": "Method",
    "detail": "Function (} ; class MCEncodedFragment : public MCFragment { protected :)",
    "insertText": "MCEncodedFragment(MCFragment::FragmentType FType, bool HasInstructions, MCSection *Sec) : MCFragment(FType, HasInstructions, 0, Sec)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "classof(const MCFragment *F)"
  },
  {
    "label": "MCEncodedFragmentWithContents()",
    "kind": "Method",
    "detail": "Function (default : return false ; case MCFragment::FT_Relaxable : case MCFragment::FT_CompactEncodedInst : case MCFragment::FT_Data : return true ; } } } ; template<unsigned ContentsSize> class MCEncodedFragmentWithContents : public MCEncodedFragment { SmallVector<char,ContentsSize> Contents ; protected :)",
    "insertText": "MCEncodedFragmentWithContents(MCFragment::FragmentType FType, bool HasInstructions, MCSection *Sec) : MCEncodedFragment(FType, HasInstructions, Sec)"
  },
  {
    "label": "getContents()",
    "kind": "Method",
    "detail": "Function (} public : SmallVectorImpl<char>&)",
    "insertText": "getContents()"
  },
  {
    "label": "getFixups()",
    "kind": "Method",
    "detail": "Function (} public : typedef SmallVectorImpl<MCFixup>::const_iterator const_fixup_iterator ; typedef SmallVectorImpl<MCFixup>::iterator fixup_iterator ; SmallVectorImpl<MCFixup>&)",
    "insertText": "getFixups()"
  },
  {
    "label": "fixup_begin()",
    "kind": "Method",
    "detail": "Function (} const_fixup_iterator)",
    "insertText": "fixup_begin()"
  },
  {
    "label": "fixup_end()",
    "kind": "Method",
    "detail": "Function (} fixup_iterator)",
    "insertText": "fixup_end()"
  },
  {
    "label": "setHasInstructions()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setHasInstructions(bool V)"
  },
  {
    "label": "MCCompactEncodedInstFragment()",
    "kind": "Method",
    "detail": "Function (} } ; class MCCompactEncodedInstFragment : public MCEncodedFragmentWithContents<4> { public :)",
    "insertText": "MCCompactEncodedInstFragment(MCSection *Sec = nullptr) : MCEncodedFragmentWithContents(FT_CompactEncodedInst, true, Sec)"
  },
  {
    "label": "MCRelaxableFragment()",
    "kind": "Method",
    "detail": "Function (} } ; class MCRelaxableFragment : public MCEncodedFragmentWithFixups<8,1> { MCInst Inst ; const MCSubtargetInfo STI ; public :)",
    "insertText": "MCRelaxableFragment(const MCInst &Inst, const MCSubtargetInfo &STI, MCSection *Sec = nullptr) : MCEncodedFragmentWithFixups(FT_Relaxable, true, Sec), Inst(Inst), STI(STI)"
  },
  {
    "label": "getInst()",
    "kind": "Method",
    "detail": "Function (} const MCInst&)",
    "insertText": "getInst()"
  },
  {
    "label": "getSubtargetInfo()",
    "kind": "Method",
    "detail": "Function (Inst = Value ; } const MCSubtargetInfo&)",
    "insertText": "getSubtargetInfo()"
  },
  {
    "label": "MCAlignFragment()",
    "kind": "Method",
    "detail": "Function (} } ; class MCAlignFragment : public MCFragment { unsigned Alignment ; bool EmitNops : 1 ; int64_t Value ; unsigned ValueSize ; unsigned MaxBytesToEmit ; public :)",
    "insertText": "MCAlignFragment(unsigned Alignment, int64_t Value, unsigned ValueSize, unsigned MaxBytesToEmit, MCSection *Sec = nullptr) : MCFragment(FT_Align, false, 0, Sec), Alignment(Alignment), EmitNops(false), Value(Value), ValueSize(ValueSize), MaxBytesToEmit(MaxBytesToEmit)"
  },
  {
    "label": "getAlignment()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getAlignment()"
  },
  {
    "label": "MCFillFragment()",
    "kind": "Method",
    "detail": "Function (} } ; class MCFillFragment : public MCFragment { int64_t Value ; unsigned ValueSize ; uint64_t Size ; public :)",
    "insertText": "MCFillFragment(int64_t Value, unsigned ValueSize, uint64_t Size, MCSection *Sec = nullptr) : MCFragment(FT_Fill, false, 0, Sec), Value(Value), ValueSize(ValueSize), Size(Size)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((!ValueSize || (Size % ValueSize) == 0) && \"Fill size must be a multiple of the value size!\")"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} int64_t)",
    "insertText": "getValue()"
  },
  {
    "label": "MCOrgFragment()",
    "kind": "Method",
    "detail": "Function (} } ; class MCOrgFragment : public MCFragment { const MCExpr* Offset ; int8_t Value ; public :)",
    "insertText": "MCOrgFragment(const MCExpr &Offset, int8_t Value, MCSection *Sec = nullptr) : MCFragment(FT_Org, false, 0, Sec), Offset(&Offset), Value(Value)"
  },
  {
    "label": "getOffset()",
    "kind": "Method",
    "detail": "Function (} const MCExpr&)",
    "insertText": "getOffset()"
  },
  {
    "label": "MCLEBFragment()",
    "kind": "Method",
    "detail": "Function (} } ; class MCLEBFragment : public MCFragment { const MCExpr* Value ; bool IsSigned ; SmallString<8> Contents ; public :)",
    "insertText": "MCLEBFragment(const MCExpr &Value_, bool IsSigned_, MCSection *Sec = nullptr) : MCFragment(FT_LEB, false, 0, Sec), Value(&Value_), IsSigned(IsSigned_)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Contents .)",
    "insertText": "push_back(0)"
  },
  {
    "label": "MCDwarfLineAddrFragment()",
    "kind": "Method",
    "detail": "Function (} } ; class MCDwarfLineAddrFragment : public MCFragment { int64_t LineDelta ; const MCExpr* AddrDelta ; SmallString<8> Contents ; public :)",
    "insertText": "MCDwarfLineAddrFragment(int64_t LineDelta, const MCExpr &AddrDelta, MCSection *Sec = nullptr) : MCFragment(FT_Dwarf, false, 0, Sec), LineDelta(LineDelta), AddrDelta(&AddrDelta)"
  },
  {
    "label": "getLineDelta()",
    "kind": "Method",
    "detail": "Function (} int64_t)",
    "insertText": "getLineDelta()"
  },
  {
    "label": "MCDwarfCallFrameFragment()",
    "kind": "Method",
    "detail": "Function (} } ; class MCDwarfCallFrameFragment : public MCFragment { const MCExpr* AddrDelta ; SmallString<8> Contents ; public :)",
    "insertText": "MCDwarfCallFrameFragment(const MCExpr &AddrDelta, MCSection *Sec = nullptr) : MCFragment(FT_DwarfFrame, false, 0, Sec), AddrDelta(&AddrDelta)"
  },
  {
    "label": "getAddrDelta()",
    "kind": "Method",
    "detail": "Function (} const MCExpr&)",
    "insertText": "getAddrDelta()"
  },
  {
    "label": "MCSafeSEHFragment()",
    "kind": "Method",
    "detail": "Function (} } ; class MCSafeSEHFragment : public MCFragment { const MCSymbol* Sym ; public :)",
    "insertText": "MCSafeSEHFragment(const MCSymbol *Sym, MCSection *Sec = nullptr) : MCFragment(FT_SafeSEH, false, 0, Sec), Sym(Sym)"
  },
  {
    "label": "getSymbol()",
    "kind": "Method",
    "detail": "Function (} const MCSymbol*)",
    "insertText": "getSymbol()"
  },
  {
    "label": "MCAssembler()",
    "kind": "Method",
    "detail": "Function (} } ; struct IndirectSymbolData { MCSymbol* Symbol ; MCSection* Section ; } ; struct DataRegionData { enum KindTy { Data = 1,JumpTable8,JumpTable16,JumpTable32 } Kind ; MCSymbol* Start ; MCSymbol* End ; } ; class MCAssembler { class MCAsmLayout ; public : typedef std::vector<MCSection*> SectionListType ; typedef std::vector<const MCSymbol*> SymbolDataListType ; typedef pointee_iterator<SectionListType::const_iterator> const_iterator ; typedef pointee_iterator<SectionListType::iterator> iterator ; typedef pointee_iterator<SymbolDataListType::const_iterator> const_symbol_iterator ; typedef pointee_iterator<SymbolDataListType::iterator> symbol_iterator ; typedef iterator_range<symbol_iterator> symbol_range ; typedef iterator_range<const_symbol_iterator> const_symbol_range ; typedef std::vector<IndirectSymbolData>::const_iterator const_indirect_symbol_iterator ; typedef std::vector<IndirectSymbolData>::iterator indirect_symbol_iterator ; typedef std::vector<DataRegionData>::const_iterator const_data_region_iterator ; typedef std::vector<DataRegionData>::iterator data_region_iterator ; typedef struct { MCVersionMinType Kind ; unsigned Major ; unsigned Minor ; unsigned Update ; } VersionMinInfoType ; private :)",
    "insertText": "MCAssembler(const MCAssembler &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const MCAssembler &)"
  },
  {
    "label": "evaluateFixup()",
    "kind": "Method",
    "detail": "Function (MCContext& Context ; MCAsmBackend& Backend ; MCCodeEmitter& Emitter ; MCObjectWriter& Writer ; raw_ostream& OS ; SectionListType Sections ; SymbolDataListType Symbols ; std::vector<IndirectSymbolData> IndirectSymbols ; std::vector<DataRegionData> DataRegions ; std::vector<std::vector<std::string>> LinkerOptions ; std::vector<std::string> FileNames ; SmallPtrSet<const MCSymbol*,6 4> ThumbFuncs ; unsigned BundleAlignSize ; unsigned RelaxAll : 1 ; unsigned SubsectionsViaSymbols : 1 ; unsigned ELFHeaderEFlags ; MCLOHContainer LOHContainer ; VersionMinInfoType VersionMinInfo ; private : bool)",
    "insertText": "evaluateFixup(const MCAsmLayout &Layout, const MCFixup &Fixup, const MCFragment *DF, MCValue &Target, uint64_t &Value)"
  },
  {
    "label": "fixupNeedsRelaxation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "fixupNeedsRelaxation(const MCFixup &Fixup, const MCRelaxableFragment *DF, const MCAsmLayout &Layout)"
  },
  {
    "label": "fragmentNeedsRelaxation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "fragmentNeedsRelaxation(const MCRelaxableFragment *IF, const MCAsmLayout &Layout)"
  },
  {
    "label": "layoutOnce()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "layoutOnce(MCAsmLayout &Layout)"
  },
  {
    "label": "layoutSectionOnce()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "layoutSectionOnce(MCAsmLayout &Layout, MCSection &Sec)"
  },
  {
    "label": "relaxInstruction()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "relaxInstruction(MCAsmLayout &Layout, MCRelaxableFragment &IF)"
  },
  {
    "label": "relaxLEB()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "relaxLEB(MCAsmLayout &Layout, MCLEBFragment &IF)"
  },
  {
    "label": "relaxDwarfLineAddr()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "relaxDwarfLineAddr(MCAsmLayout &Layout, MCDwarfLineAddrFragment &DF)"
  },
  {
    "label": "relaxDwarfCallFrameFragment()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "relaxDwarfCallFrameFragment(MCAsmLayout &Layout, MCDwarfCallFrameFragment &DF)"
  },
  {
    "label": "finishLayout()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "finishLayout(MCAsmLayout &Layout)"
  },
  {
    "label": "handleFixup()",
    "kind": "Method",
    "detail": "Function (std::pair<uint64_t,bool>)",
    "insertText": "handleFixup(const MCAsmLayout &Layout, MCFragment &F, const MCFixup &Fixup)"
  },
  {
    "label": "computeFragmentSize()",
    "kind": "Method",
    "detail": "Function (public : uint64_t)",
    "insertText": "computeFragmentSize(const MCAsmLayout &Layout, const MCFragment &F)"
  },
  {
    "label": "getAtom()",
    "kind": "Method",
    "detail": "Function (const MCSymbol*)",
    "insertText": "getAtom(const MCSymbol &S)"
  },
  {
    "label": "isSymbolLinkerVisible()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isSymbolLinkerVisible(const MCSymbol &SD)"
  },
  {
    "label": "writeSectionData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeSectionData(const MCSection *Section, const MCAsmLayout &Layout)"
  },
  {
    "label": "isThumbFunc()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isThumbFunc(const MCSymbol *Func)"
  },
  {
    "label": "setIsThumbFunc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setIsThumbFunc(const MCSymbol *Func)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (ThumbFuncs .)",
    "insertText": "insert(Func)"
  },
  {
    "label": "getELFHeaderEFlags()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getELFHeaderEFlags()"
  },
  {
    "label": "getVersionMinInfo()",
    "kind": "Method",
    "detail": "Function (ELFHeaderEFlags = Flags ; } const VersionMinInfoType&)",
    "insertText": "getVersionMinInfo()"
  },
  {
    "label": "MCAssembler()",
    "kind": "Method",
    "detail": "Function (VersionMinInfo . Kind = Kind ; VersionMinInfo . Major = Major ; VersionMinInfo . Minor = Minor ; VersionMinInfo . Update = Update ; } public :)",
    "insertText": "MCAssembler(MCContext &Context_, MCAsmBackend &Backend_, MCCodeEmitter &Emitter_, MCObjectWriter &Writer_, raw_ostream &OS)"
  },
  {
    "label": "MCAssembler()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "MCAssembler()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset()"
  },
  {
    "label": "getContext()",
    "kind": "Method",
    "detail": "Function (MCContext&)",
    "insertText": "getContext()"
  },
  {
    "label": "getSubsectionsViaSymbols()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "getSubsectionsViaSymbols()"
  },
  {
    "label": "getRelaxAll()",
    "kind": "Method",
    "detail": "Function (SubsectionsViaSymbols = Value ; } bool)",
    "insertText": "getRelaxAll()"
  },
  {
    "label": "isBundlingEnabled()",
    "kind": "Method",
    "detail": "Function (RelaxAll = Value ; } bool)",
    "insertText": "isBundlingEnabled()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((Size == 0 || !(Size & (Size - 1))) && \"Expect a power-of-two bundle align size\")"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (BundleAlignSize = Size ; } iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "size()"
  },
  {
    "label": "symbol_begin()",
    "kind": "Method",
    "detail": "Function (} symbol_iterator)",
    "insertText": "symbol_begin()"
  },
  {
    "label": "symbol_end()",
    "kind": "Method",
    "detail": "Function (} symbol_iterator)",
    "insertText": "symbol_end()"
  },
  {
    "label": "symbols()",
    "kind": "Method",
    "detail": "Function (} symbol_range)",
    "insertText": "symbols()"
  },
  {
    "label": "symbol_size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "symbol_size()"
  },
  {
    "label": "getIndirectSymbols()",
    "kind": "Method",
    "detail": "Function (} std::vector<IndirectSymbolData>&)",
    "insertText": "getIndirectSymbols()"
  },
  {
    "label": "indirect_symbol_begin()",
    "kind": "Method",
    "detail": "Function (} const_indirect_symbol_iterator)",
    "insertText": "indirect_symbol_begin()"
  },
  {
    "label": "indirect_symbol_end()",
    "kind": "Method",
    "detail": "Function (} indirect_symbol_iterator)",
    "insertText": "indirect_symbol_end()"
  },
  {
    "label": "indirect_symbol_size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "indirect_symbol_size()"
  },
  {
    "label": "getLinkerOptions()",
    "kind": "Method",
    "detail": "Function (} std::vector<std::vector<std::string>>&)",
    "insertText": "getLinkerOptions()"
  },
  {
    "label": "data_region_begin()",
    "kind": "Method",
    "detail": "Function (} const_data_region_iterator)",
    "insertText": "data_region_begin()"
  },
  {
    "label": "data_region_end()",
    "kind": "Method",
    "detail": "Function (} data_region_iterator)",
    "insertText": "data_region_end()"
  },
  {
    "label": "data_region_size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "data_region_size()"
  },
  {
    "label": "getLOHContainer()",
    "kind": "Method",
    "detail": "Function (} MCLOHContainer&)",
    "insertText": "getLOHContainer()"
  },
  {
    "label": "registerSection()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "registerSection(MCSection &Section)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Sections .)",
    "insertText": "push_back(&Section)"
  },
  {
    "label": "setIsRegistered()",
    "kind": "Method",
    "detail": "Function (Section .)",
    "insertText": "setIsRegistered(true)"
  },
  {
    "label": "getFileNames()",
    "kind": "Method",
    "detail": "Function (ArrayRef<std::string>)",
    "insertText": "getFileNames()"
  },
  {
    "label": "writeFragmentPadding()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "writeFragmentPadding(const MCFragment &F, uint64_t FSize, MCObjectWriter *OW)"
  },
  {
    "label": "computeBundlePadding()",
    "kind": "Method",
    "detail": "Function (} ; uint64_t)",
    "insertText": "computeBundlePadding(const MCAssembler &Assembler, const MCFragment *F, uint64_t FOffset, uint64_t FSize)"
  }
]