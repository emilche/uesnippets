[
  {
    "label": "t",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "t"
  },
  {
    "label": "nothing",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "nothing"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "scoped_guard",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scoped_guard"
  },
  {
    "label": "text",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "text"
  },
  {
    "label": "snippet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "snippet"
  },
  {
    "label": "parser_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "parser_base"
  },
  {
    "label": "syntaxes_t",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "syntaxes_t"
  },
  {
    "label": "capture_t",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "capture_t"
  },
  {
    "label": "block",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "block"
  },
  {
    "label": "value_t",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "value_t"
  },
  {
    "label": "error_t",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "error_t"
  },
  {
    "label": "result",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "result"
  },
  {
    "label": "u",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "u"
  },
  {
    "label": "t0",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "t0"
  },
  {
    "label": "encoding",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "encoding"
  },
  {
    "label": "token_set",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "token_set"
  },
  {
    "label": "token_info",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "token_info"
  },
  {
    "label": "token",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "token"
  },
  {
    "label": "parser",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "parser"
  },
  {
    "label": "cursor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cursor"
  },
  {
    "label": "point",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "point"
  },
  {
    "label": "context",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "context"
  },
  {
    "label": "gen_t",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "gen_t"
  },
  {
    "label": "trailing",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "trailing"
  },
  {
    "label": "block_t",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "block_t"
  },
  {
    "label": "expr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "expr"
  },
  {
    "label": "f",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "f"
  },
  {
    "label": "call",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "call"
  },
  {
    "label": "invoke",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "invoke"
  },
  {
    "label": "ins",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ins"
  },
  {
    "label": "when_expr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "when_expr"
  },
  {
    "label": "generate",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "generate"
  },
  {
    "label": "GRAMMAR_ASSERT()",
    "kind": "Method",
    "detail": "Function (# pragma once # define TIM 0 # if ! TIM # include<utility> # include<stdint . h> # endif namespace Verse { namespace Grammar { # ifndef VERSE_MAX_EXPR_DEPTH # define VERSE_MAX_EXPR_DEPTH 1 0 0 # endif # ifndef VERSE_MAX_INDCMT_DEPTH # define VERSE_MAX_INDCMT_DEPTH 3 # endif # if false # define)",
    "insertText": "GRAMMAR_ASSERT(c) (void)(0) #else #define GRAMMAR_ASSERT(c) ((c)? (void)0: Verse::Grammar::Err()) #endif #define GRAMMAR_RUN(e)"
  },
  {
    "label": "GrammarTemp()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "GrammarTemp(e)"
  },
  {
    "label": "GRAMMAR_SET()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "GRAMMAR_SET(r,e)"
  },
  {
    "label": "GRAMMAR_LET()",
    "kind": "Method",
    "detail": "Function (r =* GrammarTemp ; } # define)",
    "insertText": "GRAMMAR_LET(r,e) auto r##Let=(e)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (auto r =* r # # Let ; using int64 = long long ; using nat8 = unsigned char ; using nat16 = unsigned short ; using nat32 = unsigned int ; using nat64 = unsigned long long ; using nat = unsigned long long ; using char32 = char32_t ; # if)",
    "insertText": "defined(__cpp_char8_t)"
  },
  {
    "label": "ArraySize()",
    "kind": "Method",
    "detail": "Function (# else using char8 = char ; # endif template<class t,nat n> nat)",
    "insertText": "ArraySize(t(&)[n])"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_MSC_VER) while(true) __debugbreak()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "while(true) __builtin_trap()"
  },
  {
    "label": "scoped_guard()",
    "kind": "Method",
    "detail": "Function (# endif } struct nothing { } ; enum class prec : nat8 { Never,List,Commas,Expr,Fun,Def,Or,And,Not,Eq,NotEq,Less,Greater,Choose,To,Add,Mul,Prefix,Call,Base,Nothing } ; enum class assoc : nat8 { None,Postfix,InfixLeft,InfixRight } ; enum class form : nat8 { List,Commas } ; enum class punctuation : nat8 { None,Braces,Parens,Brackets,AngleBrackets,Qualifier,Dot,Colon,Ind } ; enum class place : nat16 { UTF8,Printable,BlockCmt,LineCmt,IndCmt,Space,String,Content } ; enum class mode { None,Open,Closed,With } ; template<t> struct scoped_guard {)",
    "insertText": "scoped_guard(t& _guard_variable, const t& new_value) : guard_variable(&_guard_variable) , old_value(_guard_variable)"
  },
  {
    "label": "scoped_guard()",
    "kind": "Method",
    "detail": "Function (* guard_variable = new_value ; } ~)",
    "insertText": "scoped_guard()"
  },
  {
    "label": "text()",
    "kind": "Method",
    "detail": "Function (} private : t* guard_variable ; t old_value ; } ; struct text { const char8* Start,* Stop ;)",
    "insertText": "text(): Start(nullptr), Stop(nullptr)"
  },
  {
    "label": "text()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "text(const char8* Start0,const char8* Stop0): Start(Start0), Stop(Stop0)"
  },
  {
    "label": "GRAMMAR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_ASSERT(Stop>=Start)"
  },
  {
    "label": "text()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "text(const char8* Start0): text(Start0,Start0)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(__cpp_char8_t) text(const char* Start0) : text(reinterpret_cast<const char8*>(Start0), (const char8*)Start0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif char8)",
    "insertText": "operator(nat i)"
  },
  {
    "label": "GRAMMAR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_ASSERT(Start+i<Stop)"
  },
  {
    "label": "snippet()",
    "kind": "Method",
    "detail": "Function (} struct snippet { text Text ; nat StartLine,StopLine ; nat StartColumn,StopColumn ;)",
    "insertText": "snippet(): Text(nullptr,nullptr), StartLine(0), StopLine(0), StartColumn(0), StopColumn(0)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "snippet()",
    "kind": "Method",
    "detail": "Function (} private : struct parser_base ;)",
    "insertText": "snippet(const char8* Start0,const char8* End0,nat StartLine0,nat StopLine0,nat StartColumn0,nat StopColumn0): Text(Start0,End0), StartLine(StartLine0), StopLine(StopLine0), StartColumn(StartColumn0), StopColumn(StopColumn0)"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (} } ; template<class syntaxes_t,class capture_t> struct block {)",
    "insertText": "block(const snippet& BlockSnippet0=snippet{},const syntaxes_t& Elements0=syntaxes_t(),form Form0=form::List): BlockSnippet(BlockSnippet0), Punctuation(punctuation::None), Form(Form0), Elements(Elements0)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} snippet BlockSnippet ; syntaxes_t Specifiers ; capture_t TokenLeading ; text Token ; capture_t PunctuationLeading ; punctuation Punctuation ; form Form ; syntaxes_t Elements ; capture_t ElementsTrailing ; capture_t PunctuationTrailing ; } ; template<class value_t,class error_t> struct result { template<class u,class =)",
    "insertText": "decltype(value_t(*(u*)nullptr))> result(const u& Value0): Value(Value0), Success(true)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} # if ! TIM template<class u,class =)",
    "insertText": "decltype(value_t(*(u*)nullptr))> result(u&& Value0) : Value(std::move(Value0)), Success(true)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} # endif template<class t0 = error_t,class =)",
    "insertText": "decltype(t0())> result(): Error(), Success(false)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "result(const error_t& Error0): Error(Error0), Success(false)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "result(const result& Other): Success(Other.Success)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "result()"
  },
  {
    "label": "value_t()",
    "kind": "Method",
    "detail": "Function (Value . ~)",
    "insertText": "value_t()"
  },
  {
    "label": "error_t()",
    "kind": "Method",
    "detail": "Function (} else { Error . ~)",
    "insertText": "error_t()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(this)result(R)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } const value_t&)",
    "insertText": "operator()"
  },
  {
    "label": "GRAMMAR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_ASSERT(Success)"
  },
  {
    "label": "GRAMMAR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_ASSERT(!Success)"
  },
  {
    "label": "IsDigit()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDigit(char8 c)"
  },
  {
    "label": "IsHex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsHex(char8 c)"
  },
  {
    "label": "DigitValue()",
    "kind": "Method",
    "detail": "Function (} nat8)",
    "insertText": "DigitValue(char8 c)"
  },
  {
    "label": "IsIdentifierQuotable()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsIdentifierQuotable(char8 c0,char8 c1)"
  },
  {
    "label": "c0()",
    "kind": "Method",
    "detail": "Function ('&& c0 ! = ' } '&& c0 ! = ' \" '&& c0 ! = ' \\ ' '&&)",
    "insertText": "c0(c0!='<'||c1!='#') && (c0!='#'||c1!='>')"
  },
  {
    "label": "IsStringBackslashLiteral()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsStringBackslashLiteral(char8 c0,char8 c1)"
  },
  {
    "label": "EncodedChar32()",
    "kind": "Method",
    "detail": "Function (' | | c0 = = ' } ' ; } char32)",
    "insertText": "EncodedChar32(const char8* s,nat Count)"
  },
  {
    "label": "Err()",
    "kind": "Method",
    "detail": "Function (default :)",
    "insertText": "Err()"
  },
  {
    "label": "EncodedLength()",
    "kind": "Method",
    "detail": "Function (} } template<place Place> nat)",
    "insertText": "EncodedLength(const char8* s)"
  },
  {
    "label": "nat8()",
    "kind": "Method",
    "detail": "Function (' : case ' = ' : case ' ? ' : case ' @ ' : case ' A ' : case ' B ' : case ' C ' : case ' D ' : case ' E ' : case ' F ' : case ' G ' : case ' H ' : case ' I ' : case ' J ' : case ' K ' : case ' L ' : case ' M ' : case ' N ' : case ' O ' : case ' P ' : case ' Q ' : case ' R ' : case ' S ' : case ' T ' : case ' U ' : case ' V ' : case ' W ' : case ' X ' : case ' Y ' : case ' Z ' : case ' [ ' : case ' ] ' : case ' ^ ' : case ' _ ' : case ' ` ' : case ' a ' : case ' b ' : case ' c ' : case ' d ' : case ' e ' : case ' f ' : case ' g ' : case ' h ' : case ' i ' : case ' j ' : case ' k ' : case ' l ' : case ' m ' : case ' n ' : case ' o ' : case ' p ' : case ' q ' : case ' r ' : case ' s ' : case ' t ' : case ' u ' : case ' v ' : case ' w ' : case ' x ' : case ' y ' : case ' z ' : case ' | ' : return Place ! = place::Space ? 1 : 0 ; case 0 x80 : case 0 x81 : case 0 x82 : case 0 x83 : case 0 x84 : case 0 x85 : case 0 x86 : case 0 x87 : case 0 x88 : case 0 x89 : case 0 x8A : case 0 x8B : case 0 x8C : case 0 x8D : case 0 x8E : case 0 x8F : case 0 x90 : case 0 x91 : case 0 x92 : case 0 x93 : case 0 x94 : case 0 x95 : case 0 x96 : case 0 x97 : case 0 x98 : case 0 x99 : case 0 x9A : case 0 x9B : case 0 x9C : case 0 x9D : case 0 x9E : case 0 x9F : case 0 xA0 : case 0 xA1 : case 0 xA2 : case 0 xA3 : case 0 xA4 : case 0 xA5 : case 0 xA6 : case 0 xA7 : case 0 xA8 : case 0 xA9 : case 0 xAA : case 0 xAB : case 0 xAC : case 0 xAD : case 0 xAE : case 0 xAF : case 0 xB0 : case 0 xB1 : case 0 xB2 : case 0 xB3 : case 0 xB4 : case 0 xB5 : case 0 xB6 : case 0 xB7 : case 0 xB8 : case 0 xB9 : case 0 xBA : case 0 xBB : case 0 xBC : case 0 xBD : case 0 xBE : case 0 xBF : case 0 xC0 : case 0 xC1 : case 0 xF5 : case 0 xF6 : case 0 xF7 : case 0 xF8 : case 0 xF9 : case 0 xFA : case 0 xFB : case 0 xFC : case 0 xFD : case 0 xFE : case 0 xFF : return 0 ; case 0 xC2 : return Place ! = place::Space&&)",
    "insertText": "nat8(s[1])>=0x80&&nat8(s[1])<=0xBF && (Place==place::UTF8 || nat8(s[1])>=0xA0)"
  },
  {
    "label": "encoding()",
    "kind": "Method",
    "detail": "Function (default : return 0 ; } ; } struct encoding { prec Prec ; bool AllowIn,FollowingIn ;)",
    "insertText": "encoding(prec Prec0=prec::List,bool AllowIn0=false,bool FollowingIn0=false): Prec(Prec0), AllowIn(AllowIn0), FollowingIn(FollowingIn0)"
  },
  {
    "label": "Fresh()",
    "kind": "Method",
    "detail": "Function (} encoding)",
    "insertText": "Fresh(prec Prec1,bool AllowIn1=false,bool FollowingIn0=false)"
  },
  {
    "label": "ParenthesizePrefix()",
    "kind": "Method",
    "detail": "Function (} } ; bool)",
    "insertText": "ParenthesizePrefix(const encoding& Encoding,prec StringPrec)"
  },
  {
    "label": "PostfixLeftEncoding()",
    "kind": "Method",
    "detail": "Function (} const struct token_set AllTokens,AllowLess,AllowNotEq ; struct token_info { const char8* Symbol ; prec PrefixPrec ; mode PrefixMode ; prec PostfixTokenPrec ; prec PostfixPrec ; assoc PostfixAssoc ; mode PostfixMode ; const token_set& PostfixAllowMask ; encoding)",
    "insertText": "PostfixLeftEncoding(const encoding& Encoding,bool Parens)"
  },
  {
    "label": "GRAMMAR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_ASSERT(PostfixAssoc==assoc::Postfix || PostfixAssoc==assoc::InfixLeft || PostfixAssoc==assoc::InfixRight)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool AllowIn = Encoding . AllowIn | | Encoding . Prec<= prec::Def | | Parens ;)",
    "insertText": "if(PostfixAssoc==assoc::Postfix || PostfixAssoc==assoc::InfixLeft) return Encoding.Fresh(PostfixPrec,AllowIn)"
  },
  {
    "label": "PostfixRightEncoding()",
    "kind": "Method",
    "detail": "Function (} encoding)",
    "insertText": "PostfixRightEncoding(const encoding& Encoding,bool Parens)"
  },
  {
    "label": "GRAMMAR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_ASSERT(PostfixAssoc==assoc::InfixLeft || PostfixAssoc==assoc::InfixRight)"
  },
  {
    "label": "PostfixRightPrec()",
    "kind": "Method",
    "detail": "Function (} prec)",
    "insertText": "PostfixRightPrec()"
  },
  {
    "label": "u8()",
    "kind": "Method",
    "detail": "Function (} } ; token_info Tokens [ ] = { { u8 \" \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" \",prec::Never,mode::None,prec::Call,prec::Call,assoc::None,mode::None,AllTokens },{ u8 \" \",prec::Base,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" \",prec::Base,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" alias \",prec::Def,mode::With,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" and \",prec::Base,mode::None,prec::And,prec::And,assoc::InfixRight,mode::With,AllTokens },{ u8 \" at \",prec::Base,mode::None,prec::Call,prec::Call,assoc::None,mode::Closed,AllTokens },{ u8 \" break \",prec::Def,mode::With,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" catch \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" const \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" continue \",prec::Def,mode::With,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" do \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" else \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" if \",prec::Base,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" in \",prec::Def,mode::With,prec::Def,prec::Choose,assoc::None,mode::None,AllTokens },{ u8 \" is \",prec::Never,mode::None,prec::Def,prec::Def,assoc::None,mode::None,AllTokens },{ u8 \" live \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" next \",prec::Base,mode::None,prec::Fun,prec::Fun,assoc::InfixRight,mode::None,AllTokens },{ u8 \" not \",prec::Not,mode::With,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" of \",prec::Base,mode::None,prec::Call,prec::Call,assoc::None,mode::Open,AllTokens },{ u8 \" or \",prec::Base,mode::None,prec::Or,prec::Or,assoc::InfixRight,mode::With,AllTokens },{ u8 \" over \",prec::Base,mode::None,prec::Fun,prec::Fun,assoc::InfixLeft,mode::With,AllTokens },{ u8 \" set \",prec::Def,mode::With,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" ref \",prec::Def,mode::With,prec::Never,prec::Never,assoc::None,mode::With,AllTokens },{ u8 \" return \",prec::Def,mode::With,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" then \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" to \",prec::Base,mode::None,prec::To,prec::To,assoc::InfixRight,mode::With,AllTokens },{ u8 \" until \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" when \",prec::Base,mode::None,prec::Fun,prec::Fun,assoc::InfixLeft,mode::With,AllTokens },{ u8 \" where \",prec::Never,mode::None,prec::Def,prec::Def,assoc::InfixRight,mode::With,AllTokens },{ u8 \" while \",prec::Base,mode::None,prec::Fun,prec::Fun,assoc::InfixLeft,mode::With,AllTokens },{ u8 \" with \",prec::Never,mode::None,prec::Call,prec::Call,assoc::None,mode::None,AllTokens },{ u8 \" yield \",prec::Def,mode::With,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" var \",prec::Def,mode::With,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \",\",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" ; \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" ! \",prec::Not,mode::With,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" \\ \" \",prec::Base,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \"& \",prec::Def,mode::None,prec::Mul,prec::Mul,assoc::InfixLeft,mode::With,AllTokens },{ u8 \" ' \",prec::Base,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{)",
    "insertText": "u8(\" , prec::Base , mode::None ,prec::Call ,prec::Call ,assoc::None ,mode::None , AllTokens }, {u8\")"
  },
  {
    "label": "token()",
    "kind": "Method",
    "detail": "Function (u8 \"* \",prec::Prefix,mode::Closed,prec::Mul,prec::Mul,assoc::InfixLeft,mode::Closed,AllTokens },{ u8 \"* = \",prec::Never,mode::None,prec::Def,prec::Def,assoc::InfixRight,mode::With,AllTokens },{ u8 \" + \",prec::Prefix,mode::Closed,prec::Add,prec::Add,assoc::InfixLeft,mode::Closed,AllTokens },{ u8 \" + = \",prec::Never,mode::None,prec::Def,prec::Def,assoc::InfixRight,mode::With,AllTokens },{ u8 \" - \",prec::Prefix,mode::Closed,prec::Add,prec::Add,assoc::InfixLeft,mode::Closed,AllTokens },{ u8 \" - = \",prec::Never,mode::None,prec::Def,prec::Def,assoc::InfixRight,mode::With,AllTokens },{ u8 \" -> \",prec::Never,mode::None,prec::To,prec::To,assoc::InfixRight,mode::With,AllTokens },{ u8 \" . \",prec::Never,mode::None,prec::Call,prec::Call,assoc::InfixLeft,mode::With,AllTokens },{ u8 \" . . \",prec::Def,mode::With,prec::To,prec::To,assoc::InfixRight,mode::With,AllTokens },{ u8 \" / \",prec::Base,mode::None,prec::Mul,prec::Mul,assoc::InfixLeft,mode::Closed,AllTokens },{ u8 \" / = \",prec::Never,mode::None,prec::Def,prec::Def,assoc::InfixRight,mode::With,AllTokens },{ u8 \" : \",prec::Def,mode::With,prec::Call,prec::Choose,assoc::None,mode::None,AllTokens },{ u8 \" : = \",prec::Never,mode::None,prec::Def,prec::Def,assoc::InfixRight,mode::With,AllTokens },{ u8 \" : ) \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" :> \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \"<\",prec::Base,mode::None,prec::Call,prec::Less,assoc::InfixRight,mode::Closed,AllowLess },{ u8 \"<= \",prec::Never,mode::None,prec::Less,prec::Less,assoc::InfixRight,mode::Closed,AllowLess },{ u8 \"<> \",prec::Never,mode::None,prec::NotEq,prec::NotEq,assoc::InfixLeft,mode::With,AllowNotEq },{ u8 \" = \",prec::Never,mode::None,prec::Eq,prec::Eq,assoc::InfixLeft,mode::With,AllTokens },{ u8 \" = = \",prec::Never,mode::None,prec::Eq,prec::Never,assoc::None,mode::Closed,AllTokens },{ u8 \" => \",prec::Never,mode::None,prec::Fun,prec::Fun,assoc::InfixRight,mode::With,AllTokens },{ u8 \"> \",prec::Never,mode::None,prec::Greater,prec::Greater,assoc::InfixRight,mode::Closed,AllTokens },{ u8 \"> = \",prec::Never,mode::None,prec::Greater,prec::Greater,assoc::InfixRight,mode::Closed,AllTokens },{ u8 \" ? \",prec::Prefix,mode::Closed,prec::Call,prec::Call,assoc::Postfix,mode::With,AllTokens },{ u8 \" @ \",prec::Expr,mode::None,prec::Expr,prec::Expr,assoc::None,mode::None,AllTokens },{ u8 \" [ \",prec::Prefix,mode::Closed,prec::Call,prec::Prefix,assoc::InfixRight,mode::Closed,AllTokens },{ u8 \" ] \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },{ u8 \" ^ \",prec::Prefix,mode::Closed,prec::Call,prec::Call,assoc::Postfix,mode::With,AllTokens },{ u8 \" { \",prec::Never,mode::None,prec::Call,prec::Call,assoc::None,mode::None,AllTokens },{ u8 \" | \",prec::Never,mode::None,prec::Choose,prec::Choose,assoc::InfixRight,mode::With,AllTokens },{ u8 \" } \",prec::Never,mode::None,prec::Never,prec::Never,assoc::None,mode::None,AllTokens },} ; struct token { nat8 Index ;)",
    "insertText": "token(nat8 Index0): Index(Index0)"
  },
  {
    "label": "token()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "token(const char8* Op): Index(nat8(ArraySize(Tokens)-1))"
  },
  {
    "label": "nat8()",
    "kind": "Method",
    "detail": "Function (Index = 0 ; } operator)",
    "insertText": "nat8()"
  },
  {
    "label": "End()",
    "kind": "Method",
    "detail": "Function (} token)",
    "insertText": "End()"
  },
  {
    "label": "NewLine()",
    "kind": "Method",
    "detail": "Function (} token)",
    "insertText": "NewLine()"
  },
  {
    "label": "Alpha()",
    "kind": "Method",
    "detail": "Function (} token)",
    "insertText": "Alpha()"
  },
  {
    "label": "Digit()",
    "kind": "Method",
    "detail": "Function (} token)",
    "insertText": "Digit()"
  },
  {
    "label": "FirstParse()",
    "kind": "Method",
    "detail": "Function (} token)",
    "insertText": "FirstParse()"
  },
  {
    "label": "token_set()",
    "kind": "Method",
    "detail": "Function (0,0 } { } template<class . . . ts>)",
    "insertText": "token_set(token T,ts... TS): token_set(TS...)"
  },
  {
    "label": "nat8()",
    "kind": "Method",
    "detail": "Function (Bits [)",
    "insertText": "nat8(T)/64]|=1LL<<(nat8(T)&63)"
  },
  {
    "label": "token_set()",
    "kind": "Method",
    "detail": "Function (} template<class . . . ts>)",
    "insertText": "token_set(const char8* S,ts... TS): token_set(token(S),TS...)"
  },
  {
    "label": "Has()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Has(token T)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} token_set)",
    "insertText": "operator(const token_set& Other)"
  },
  {
    "label": "token_set()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "token_set(nat64 Bits0,nat64 Bits1)"
  },
  {
    "label": "NewLine()",
    "kind": "Method",
    "detail": "Function (Bits0,Bits1 } { } nat64 Bits [ 2 ] ; } ; const token_set AllTokens = ~ token_set { } ; const token_set AllowLess = ~ token_set { u8 \"> \",u8 \"> = \" } ; const token_set AllowNotEq = ~ token_set { u8 \"> \",u8 \"> = \",u8 \"<\",u8 \"<= \" } ; const token_set InPrefixes = token_set { u8 \" : \",u8 \" in \" } ; const token_set StopList = token_set { u8 \" : ) \",u8 \" ) \",u8 \" ] \",u8 \" } \",)",
    "insertText": "NewLine(),token::End()"
  },
  {
    "label": "u8()",
    "kind": "Method",
    "detail": "Function (const token_set StopExpr = StopList | token_set { u8 \" ; \",u8 \",\" } ; const token_set StopFun = StopExpr | token_set { u8 \" @ \" } ; const token_set StopDef = StopFun | token_set { u8 \" => \",u8 \" next \",u8 \" over \",u8 \" when \",u8 \" while \" } ; const token_set BracePostfixes = token_set { u8 \" { \" } ; const token_set BlockPostfixes = token_set { u8 \" { \",u8 \" . \",u8 \" : \" } ; const token_set ParenPostfixes = token_set {)",
    "insertText": "u8(\"}; inline const token_set WithPostfixes = token_set{u8\"with\",u8\"<\"}; inline const token_set InvokePostfixes = BlockPostfixes | ParenPostfixes | WithPostfixes | token_set{u8\"in\",token::NewLine()}; inline const token_set MarkupPostfixes = token_set{u8\",\",u8\";\",u8\">\",u8\":>\"}; inline const token_set DefPostfixes = token_set{u8\"=\",u8\":=\",u8\"+=\",u8\"-=\",u8\"*=\",u8\"/=\"}; struct parser_base { private: template<class> friend struct parser; struct cursor { const char8* Pos; const char8* LineStart; const char8* NextLineStart; token Token; nat TokenSize; nat Line; char8 operator[](int64 Offset) const { return Pos[Offset]; } bool SnippedNewLine() const { return NextLineStart>Pos; } }; struct point { const char8* Pos; nat Line,Column; point(const char8* Pos0,nat Line0,nat Column0): Pos(Pos0), Line(Line0), Column(Column0) {} point(const cursor& Cursor): Pos (Cursor.SnippedNewLine()? Cursor.NextLineStart: Cursor.Pos), Line (Cursor.SnippedNewLine()? Cursor.Line+1: Cursor.Line), Column(Cursor.SnippedNewLine()? 1: nat(Cursor.Pos-Cursor.LineStart+1)) {} static point Start(const snippet& Snippet) {return point{Snippet.Text.Start,Snippet.StartLine,Snippet.StartColumn};} static point Stop (const snippet& Snippet) {return point{Snippet.Text.Stop,Snippet.StopLine,Snippet.StopColumn};} }; struct context { const char8* BlockInd; const char8* TrimInd; bool Nest; bool LinePrefix; context(): BlockInd{u8\"\"}, TrimInd{u8\"\"}, Nest(true), LinePrefix(true) {} }; nat8 FirstToken [256 ]; nat8 NextToken [ArraySize(Tokens)]; token ParseToken(const char8* Start,nat& Size) { if(Start[0]==0) return Size=0, token::End(); for(nat8 i=FirstToken[nat8(Start[0])]; i; i=NextToken[i]) { if(i<token::FirstParse()) return Size=0, token(i); auto Symbol = Tokens[i].Symbol; nat j; for(j=0; Symbol[j] && Start[j]==Symbol[j]; j++); if(Symbol[j] || (IsAlnum(Symbol[0])&&IsAlnum(Start[j]))) continue; return Size=j, token(i); } return Size=0, token::None(); } cursor Cursor; context Context; nat32 ExprDepth{0}; nat32 CommentDepth{0}; const nat InputLength; const char8* InputString; parser_base(nat InputLength0,const char8* InputString0,nat Line0=1): FirstToken{}, NextToken{}, Cursor{InputString0,InputString0,InputString0,token::None(),0,Line0}, InputLength(InputLength0), InputString(InputString0) { GRAMMAR_ASSERT(InputString[InputLength]==0); for(nat c=0u; c<128u; c++) FirstToken[c] = IsNewLine(char8(c))? token::NewLine(): IsEnding(char8(c))? token::End(): IsAlpha(char8(c))? token::Alpha(): IsDigit(char8(c))? token::Digit(): token::None(); for(auto Token=nat8(token::FirstParse()); Token<ArraySize(Tokens); Token++) { auto& First=FirstToken[nat(Tokens[Token].Symbol[0])]; if(First) NextToken[Token]=First; First=token(Token); } } void Next(nat n) { while(n--) GRAMMAR_ASSERT(Cursor[0]!=0), Cursor.Pos++; } bool Eat(const char8* s) { nat n; for(n=0; s[n]; n++) if(Cursor[n]!=s[n]) return false; return Cursor.Pos+=n, true; } void EatToken() { Cursor.Pos += Cursor.TokenSize; } static snippet Snip(const point& Start,const point& Stop) { return snippet{ Start.Pos, Stop.Pos, Start.Line, Stop.Line, Start.Column, Stop.Column }; } snippet Snip(const point& Start) const { return Snip(Start,Cursor); } snippet Snip() const { return Snip(Cursor,Cursor); } text CursorQuote() { static const text Quote[2]={u8\"\",u8\"\\\"\"}; const nat8 Cur0 = nat8(Cursor[0]); return Quote[Cur0>0x20 && Cur0!='\"' && Cur0<0x7F]; } text CursorText() { const nat8 Cur0 = nat8(Cursor[0]); if((Cur0=='#'&&Cursor[1]=='>') || (Cur0=='<'&&Cursor[1]=='#')) return text(Cursor.Pos,Cursor.Pos+2); if(IsAlpha(Cur0)) { nat n=1; while(IsAlnum(Cursor[n])) n++; return text(Cursor.Pos,Cursor.Pos+n); } if(Cur0>0x20 && Cur0<=0x7E) return text(Cursor.Pos,Cursor.Pos+1); if(Cur0=='\"') return u8\"'\\\"'\"; else if(Cur0>=128 && EncodedLength<place::Printable>(Cursor.Pos)) return u8\"unicode character\"; else if(Cur0>=128) return u8\"non-unicode character sequence\"; else if(Cur0=='\\r' || Cur0=='\\n') return u8\"end of line\"; else if(Cur0=='\\t') return u8\"tab\"; else if(Cur0==' ') return u8\"space\"; else if(Cur0==0) return u8\"end of file\"; else return u8\"ASCII control character\"; } }; template<class gen_t> struct parser: parser_base { private: using syntax_t = typename gen_t::syntax_t; using syntaxes_t = typename gen_t::syntaxes_t; using error_t = typename gen_t::error_t; using capture_t = typename gen_t::capture_t; template<class t> using result_t = result<t,error_t>; const gen_t& Gen; parser(const gen_t& Gen0,nat n,const char8* Source0,nat StartLine=1): parser_base(n,Source0?Source0:u8\"\", StartLine), Gen(Gen0) {} struct trailing { result<cursor,nothing> TrailingStart; capture_t TrailingCapture; explicit operator bool() const { return bool(TrailingStart); } void MoveFrom(trailing& Source) { GRAMMAR_ASSERT(!TrailingStart); TrailingStart = Source.TrailingStart; TrailingCapture = Source.TrailingCapture; Source.TrailingStart = nothing{}; } }; struct block_t: public block<syntaxes_t,capture_t> { using block<syntaxes_t,capture_t>::block; trailing BlockTrailing; }; struct expr { cursor Start; prec FinishPrec; result<cursor,nothing> Finished; expr* OuterExpr; token_set AllowPostfixes; result<syntax_t,nothing> ExprSyntax; capture_t ExprLeading; trailing Trailing; result<cursor,nothing> MarkupStart; bool MarkupFinished, ExprStop; struct expr* OuterMarkup; text MarkupTag; expr* QualIdentTarget; expr(prec FinishPrec0,const cursor& Start0,expr* OuterExpr0,token_set AllowPostfixes0=token_set{},expr* QualIdentTarget0=nullptr): Start(Start0), FinishPrec(FinishPrec0), OuterExpr(OuterExpr0), AllowPostfixes(AllowPostfixes0), MarkupFinished(false), ExprStop(false), OuterMarkup(nullptr), QualIdentTarget(QualIdentTarget0) {} syntax_t operator*() const { return *ExprSyntax; } virtual ~expr() {} virtual result_t<nothing> OnFinish(parser& ) { GRAMMAR_ASSERT(!Finished); GRAMMAR_ASSERT(!OuterExpr || !OuterExpr->Finished); GRAMMAR_ASSERT(Trailing); Finished = *Trailing.TrailingStart; return nothing{}; } }; void UpdateToken() { Cursor.Token=ParseToken(Cursor.Pos,Cursor.TokenSize); if(IsAlpha(Cursor.Token->Symbol[0])) { cursor KeyStart = Cursor; EatToken(); auto SpaceResult = Space(); auto IsIdentifier = Cursor.Token==token(u8\":=\"); Cursor = KeyStart; if(SpaceResult && IsIdentifier) Cursor.Token=token::Alpha(); } } bool CheckToken() { auto SavedToken=Cursor.Token; UpdateToken(); return Cursor.Token==SavedToken; } result_t<nothing> Require(const char8* Value,error_t(parser::*OnError)(text What)) { if(!Eat(Value)) return (this->*OnError)(Value); return nothing{}; } result_t<nothing> RequireClose(cursor Start,const char8* Open,const char8* Close,error_t(parser::*OnError)(text)) { if(Eat(Close)) return nothing{}; else if(!Ending()) return (this->*OnError)(Close); else return Cursor=Start, S80(Open); } snippet SnipFinished(const cursor& Start,const expr& End) { return Snip(Start,*End.Finished); } snippet SnipFinished(const cursor& Start,const block_t& End) { return Snip(Start,*End.BlockTrailing.TrailingStart); } result_t<nothing> SpaceTrailing(trailing& Trailing) { GRAMMAR_ASSERT(!Trailing); Trailing.TrailingStart=Cursor; GRAMMAR_RUN(Space(Trailing.TrailingCapture)); return nothing{}; } result_t<nothing> UpdateFrom(expr& Target,trailing& Source,const result_t<syntax_t>& SyntaxResult) { GRAMMAR_ASSERT(Source); GRAMMAR_ASSERT(!Target.Finished && !Target.Trailing); Target.Trailing.MoveFrom(Source); GRAMMAR_SET(Target.ExprSyntax,SyntaxResult); return nothing{}; } result_t<nothing> UpdateSpaceTrailing(expr& Target,const result_t<syntax_t>& SyntaxResult) { GRAMMAR_ASSERT(!Target.Finished); GRAMMAR_ASSERT(!Target.Trailing); GRAMMAR_SET(Target.ExprSyntax,SyntaxResult); GRAMMAR_RUN(SpaceTrailing(Target.Trailing)); return nothing{}; } syntax_t ApplyTrailing(expr& Target,bool FinishingNow=false) { GRAMMAR_ASSERT(!Target.Finished || FinishingNow); GRAMMAR_ASSERT(Target.Trailing); Target.ExprSyntax = Gen.Trailing(*Target,Target.Trailing.TrailingCapture); Target.Trailing = trailing{}; return *Target; } void ApplyTrailing(block_t& Block0,const point& TrailingEnd) { if(Block0.Punctuation!=punctuation::None) Gen.CaptureAppend(Block0.PunctuationTrailing,Block0.BlockTrailing.TrailingCapture); else Gen.CaptureAppend(Block0.ElementsTrailing,Block0.BlockTrailing.TrailingCapture); Block0.BlockSnippet = Snip(point::Start(Block0.BlockSnippet),TrailingEnd); Block0.BlockTrailing = trailing{}; } auto S01() {return Gen.Err(Snip(),\"S01\",\"Source must be ASCII or Unicode UTF-8 format\");} auto S02() {return Gen.Err(Snip(),\"S02\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" in block comment\");} auto S03() {return Gen.Err(Snip(),\"S03\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" in line comment\");} auto S04() {return Gen.Err(Snip(),\"S04\",\"Block comment beginning at \\\"<#\\\" never ends\");} auto S05() {return Gen.Err(Snip(),\"S05\",\"Ending \\\"#>\\\" is outside of block comment\");} auto S06() {return Gen.Err(Snip(),\"S06\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" in indented comment\");} auto S15() {return Gen.Err(Snip(),\"S15\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" following number.\");} auto S16() {return Gen.Err(Snip(),\"S15\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" following character.\");} auto S18() {return Gen.Err(Snip(),\"S18\",\"Character code unit octet must be 1-2 digits in the range 0o0 to 0oFF\");} auto S19() {return Gen.Err(Snip(),\"S19\",\"Unicode code point must be 1-6 digits in the range 0u0 to 0u10FFFF\");} auto S20(text What) {return Gen.Err(Snip(),\"S20\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" or missing identifier following \\\"\",What,\"\\\"\");} auto S23(text What) {return Gen.Err(Snip(),\"S23\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" or missing \\\"\",What,\"\\\" in qualifier\");} auto S24(text What) {return Gen.Err(Snip(),\"S24\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" or missing \\\"\",What,\"\\\" in quoted identifier\");} auto S25(text What) {return Gen.Err(Snip(),\"S25\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" or missing \\\"\",What,\"\\\" in path literal\");} auto S26(text What) {return Gen.Err(Snip(),\"S26\",\"Missing label in path following \\\"\",What,\"\\\"\");} auto S30() {return Gen.Err(Snip(),\"S30\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" in character literal\");} auto S31(text) {return Gen.Err(Snip(),\"S31\",\"Missing \\\"'\\\" in character literal\");} auto S32(text) {return Gen.Err(Snip(),\"S32\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" or missing end quote in string literal\");} auto S34() {return Gen.Err(Snip(),\"S34\",\"Bad character escape \\\"\\\\\\\" followed by \",CursorQuote(),CursorText(),CursorQuote());} auto S40() {return Gen.Err(Snip(),\"S40\",\"Missing markup tag preceding \",CursorQuote(),CursorText(),CursorQuote());} auto S41() {return Gen.Err(Snip(),\"S41\",\"Bad markup expression preceding \",CursorQuote(),CursorText(),CursorQuote());} auto S42() {return Gen.Err(Snip(),\"S42\",\"Unexpected markup end tag outside of markup\");} auto S43(text Tag,text Id) {return Gen.Err(Snip(),\"S43\",\"Markup started with \\\"<\",Tag,\">\\\" tag but ended in mismatched \\\"</\",Id,\">\\\" tag\");} auto S44(text What) {return Gen.Err(Snip(),\"S44\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" or missing \\\"\",What,\"\\\" in markup end tag\");} auto S46() {return Gen.Err(Snip(),\"S46\",\"Expected indented markup following \\\":>\\\" but got \",CursorQuote(),CursorText(),CursorQuote());} auto S51(text What) {return Gen.Err(Snip(),\"S51\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" or missing \\\"\",What,\"\\\" in markup\");} auto S52(text) {return Gen.Err(Snip(),\"S52\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" or missing markup end tag\");} auto S54() {return Gen.Err(Snip(),\"S54\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" in indented markup\");} auto S57() {return Gen.Err(Snip(),\"S57\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" or missing ending \\\";\\\" or newline following \\\"&\\\" markup escape expression\");} auto S58() {return Gen.Err(Snip(),\"S58\",\"Markup list separator \\\"~\\\" is only allowed in markup beginning with \\\"~\\\"; elsewhere escape it using \\\"\\\\~\\\"\");} auto S60(text What,text Op) {return Gen.Err(Snip(),\"S60\",\"Precedence doesn't allow \\\"\",Op,\"\\\" following \\\"\",What,\"\\\"\");} auto S61(text Op) {return Gen.Err(Snip(),\"S61\",\"Precedence doesn't allow \\\"\",Op,\"\\\" here\");} auto S62() {return Gen.Err(Snip(),\"S62\",\"Verse uses 'and', 'or', 'not' instead of '&&', '||', '!'.\");}; auto S64(text,text Op) {return Gen.Err(Snip(),\"S64\",\"Precedence doesn't allow \\\"\",Op,\"\\\" in markup tag expression\");} auto S65() {return Gen.Err(Snip(),\"S65\",\"Use a=b for comparison, not a==b\");} auto S66(text Op) {return Gen.Err(Snip(),\"S66\",\"Use 'set' before \\\"\",Op,\"\\\" to update variables\");} auto S67() {return Gen.Err(Snip(),\"S67\",\"Prefix attribute must be followed by identifier declaration\");} auto S68() {return Gen.Err(Snip(),\"S68\",\"Use # for line comment, not auto S70(text) {return Gen.Err(Snip(),\"S70\",\"Expected expression, got \",CursorQuote(),CursorText(),CursorQuote(),\" at top level of program\");} auto S71(text What) {return Gen.Err(Snip(),\"S71\",\"Expected expression, got \",CursorQuote(),CursorText(),CursorQuote(),\" following \\\"\",What,\"\\\"\");} auto S74(text) {return Gen.Err(Snip(),\"S74\",\"Expected markup tag expression, got \",CursorQuote(),CursorText(),CursorQuote());} auto S76(text What) {return Gen.Err(Snip(),\"S76\",\"Expected block, got \",CursorQuote(),CursorText(),CursorQuote(),\" following \\\"\",What,\"\\\"\");} auto S77() {return Gen.Err(Snip(),\"S77\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\" following expression\");} auto S78() {return Gen.Err(Snip(),\"S78\",\"Expected <specifier> following \\\"with\\\"\");} auto S79() {return Gen.Err(Snip(),\"S79\",\"Unexpected \",CursorQuote(),CursorText(),CursorQuote(),\"or missing \\\">\\\" following specifier\");} auto S80(text What) {return Gen.Err(Snip(),\"S80\",\"Block starting in \\\"\",What,\"\\\" never ends\");} auto S81(text What) {return Gen.Err(Snip(),\"S81\",\"Expected expression or \\\"\",What,\"\\\", got \",CursorQuote(),CursorText(),CursorQuote(),\" in parenthesis\");} auto S82(text What) {return Gen.Err(Snip(),\"S82\",\"Expected expression or \\\"\",What,\"\\\", got \",CursorQuote(),CursorText(),CursorQuote(),\" in parenthesized parameter list\");} auto S83(text What) {return Gen.Err(Snip(),\"S83\",\"Expected expression or \\\"\",What,\"\\\", got \",CursorQuote(),CursorText(),CursorQuote(),\" in bracketed parameters\");} auto S84(text What) {return Gen.Err(Snip(),\"S84\",\"Expected expression or \\\"\",What,\"\\\", got \",CursorQuote(),CursorText(),CursorQuote(),\" in braced block\");} auto S85(text What) {return Gen.Err(Snip(),\"S85\",\"Expected \\\"\",What,\"\\\", got \",CursorQuote(),CursorText(),CursorQuote(),\" in prefix brackets\");} auto S86(text What) {return Gen.Err(Snip(),\"S86\",\"Expected expression or \\\"\",What,\"\\\", got \",CursorQuote(),CursorText(),CursorQuote(),\" in string interpolation\");} auto S88(text) {return Gen.Err(Snip(),\"S88\",\"Expected expression, got \",CursorQuote(),CursorText(),CursorQuote(),\" in indented block\");} auto S88void() {return Gen.Err(Snip(),\"S88\",\"Expected expression, got \",CursorQuote(),CursorText(),CursorQuote(),\" in indented block\");} auto S89() {return Gen.Err(Snip(),\"S89\",\"Indentation mismatch: expected \",Context.BlockInd[point(Cursor).Column]==' '? \"space\": \"tab\",\", got \",CursorQuote(),CursorText(),CursorQuote());} auto S97() {return Gen.Err(Snip(),\"S97\",\"Unexpected error\");} auto S98() {return Gen.Err(Snip(),\"S98\",\"Feature is not currently supported\");} auto S99() {return Gen.Err(Snip(),\"S99\",\"Exceeded maximum expression depth\"); } void SnipNewLine(capture_t& Capture,place Place=place::Space) { if(!Cursor.SnippedNewLine() && (Cursor[0]==0x0D || Cursor[0]==0x0A)) { auto Start = Cursor; Cursor.NextLineStart = Cursor.Pos+1+(Cursor[0]==0x0D && Cursor[1]==0x0A); Gen.NewLine(Capture,Snip(Start),Place); } } bool NewLine(capture_t& Capture,place Place=place::Space) { SnipNewLine(Capture,Place); if(Cursor.SnippedNewLine()) { Cursor.Pos = Cursor.NextLineStart; Cursor.LineStart = Cursor.Pos; Cursor.Line++; return true; } return false; } bool Ending() { return Cursor.SnippedNewLine() || IsEnding(Cursor[0]); } result_t<nothing> Space(capture_t& Capture,place Place=place::Space,bool DoSnipNewLine=true) { GRAMMAR_RUN(Text<place::Space>(Capture,Place)); if(DoSnipNewLine) SnipNewLine(Capture,Place); return UpdateToken(), nothing{}; } result_t<capture_t> Space(place Place=place::Space) { capture_t Capture; GRAMMAR_RUN(Space(Capture,Place)); return Capture; } result_t<context> Ind() { GRAMMAR_ASSERT(Ending()); auto SavedContext = Context; Context.BlockInd = Cursor.LineStart; Context.TrimInd = Cursor.LineStart; Context.Nest = false; return SavedContext; } result_t<nothing> Ded(const context& SavedContext,error_t(parser::*OnError)()) { Context = SavedContext; if(!Ending()) return (this->*OnError)(); return UpdateToken(), nothing{}; } result_t<bool> Line(capture_t& Capture,place Place) { auto SavedLineEnd = Cursor; if(!NewLine(Capture,Place)) return false; auto SavedLineStart = Cursor; while(IsSpace(Cursor[0]) && Cursor[0]==Context.BlockInd[Cursor.Pos-SavedLineStart.Pos]) Next(1); bool HasMoreSpace = IsSpace(Cursor[0]); if((HasMoreSpace || Context.Nest) && !IsSpace(Context.BlockInd[Cursor.Pos-SavedLineStart.Pos])) { while(IsSpace(Cursor[0]) && Cursor[0]==Context.TrimInd[Cursor.Pos-SavedLineStart.Pos]) Next(1); Gen.Indent(Capture,Snip(SavedLineStart),Place); GRAMMAR_RUN(Space(Capture,Place)); return true; } else if(Ending()) { return Gen.BlankLine(Capture,Snip(SavedLineStart),Place), true; } else if(HasMoreSpace) { return S89(); } else { #if TIM return Cursor=SavedLineEnd, false; #else const uint32_t NewCommentDepth = Place == place::IndCmt || Place == place::BlockCmt ? CommentDepth + 1 : CommentDepth; scoped_guard CommentDepthGuard(CommentDepth, NewCommentDepth); if (CommentDepth > VERSE_MAX_INDCMT_DEPTH) { return Cursor=SavedLineEnd, false; } capture_t SpaceCapture = {}; GRAMMAR_RUN(Space(SpaceCapture,Place)); if(Cursor.SnippedNewLine()) { capture_t ScanCapture = {}; if (Scan(ScanCapture,Place) && Gen.CaptureLength(ScanCapture) == 0) { return Cursor=SavedLineEnd, false; } else { Gen.CaptureAppend(Capture, SpaceCapture); return true; } } else { return Cursor=SavedLineEnd, false; } #endif } } result_t<nothing> Scan(capture_t& Capture,place Place=place::Space) { GRAMMAR_RUN(Space(Capture,Place,false)); for(;;) { capture_t LineCapture; GRAMMAR_LET(GotLine,Line(LineCapture,Place)); if(!GotLine) return UpdateToken(), nothing{}; if(Place==place::Content && (Cursor[0]=='~' || (Cursor[0]=='<'&&Cursor[1]=='/'))) Gen.MarkupTrim(LineCapture); Gen.CaptureAppend(Capture,LineCapture); } } result_t<token> ScanKey(capture_t& Capture,token_set TokenSet) { auto ScanStart = Cursor; GRAMMAR_LET(More,Space()); bool Multiline = Ending(); GRAMMAR_RUN(Scan(More)); if(Context.LinePrefix && Multiline && Cursor.Token!=token(u8\"{\")) { auto LinePrefixStart=Cursor; if(Eat(u8\"&\")) { Gen.LinePrefix(More,Snip(LinePrefixStart)); GRAMMAR_RUN(Space(More)); if(TokenSet.Has(Cursor.Token)) return Gen.CaptureAppend(Capture,More), Cursor.Token; } } else if(TokenSet.Has(Cursor.Token)) return Gen.CaptureAppend(Capture,More), Cursor.Token; return Cursor=ScanStart, token::None(); } result_t<nat> ParseHex(nat MaxDigits,nat MaxValue,error_t(parser::*OnError)()) { nat i=0; while(IsHex(Cursor[0])) { if(MaxDigits-->0) { auto i0=i; i=i*16+DigitValue(Cursor[0]); if(i<=MaxValue && i/16==i0) { Next(1); continue; } } return (this->*OnError)(); } return i; } result_t<nothing> DisallowDotAlnum() { bool GotDot=Cursor[0]=='.'; if(IsAlnum(Cursor[GotDot])) return S15(); return nothing{}; } result_t<nothing> DisallowDotNum() { bool GotDot=Cursor[0]=='.'; if(IsDigit(Cursor[GotDot])) return S15(); return nothing{}; } result_t<syntax_t> Num() { auto Start=Cursor; GRAMMAR_ASSERT(IsDigit(Cursor[0])); if(Cursor[0]=='0' && Cursor[1]=='x' && IsHex(Cursor[2])) { GRAMMAR_ASSERT(Cursor[0]=='0'&&Cursor[1]=='x'&&IsHex(Cursor[2])); Next(2); do {Next(1);} while(IsHex(Cursor[0])); GRAMMAR_RUN(DisallowDotAlnum()); return Gen.NumHex(Snip(Start),text(Start.Pos+2,Cursor.Pos)); } while(IsDigit(Cursor[0])) Next(1); text Digits(Start.Pos,Cursor.Pos),FractionalDigits(Cursor.Pos+1,Cursor.Pos+1); if(Cursor[0]=='.' && IsDigit(Cursor[1])) { Next(2); while(IsDigit(Cursor[0])) Next(1); FractionalDigits.Stop=Cursor.Pos; } text ExponentSign,Exponent; if(Cursor[0]=='e' || Cursor[0]=='E') { int64 HasExponentSign = int64(Cursor[1]=='+' || Cursor[1]=='-'); if(IsDigit(Cursor[1+HasExponentSign])) { ExponentSign=text(Cursor.Pos+1,Cursor.Pos+1+HasExponentSign); Next(1+HasExponentSign); Exponent.Start=Cursor.Pos; while(IsDigit(Cursor[0])) Next(1); Exponent.Stop=Cursor.Pos; } } GRAMMAR_LET(Result,Gen.Num(Snip(Start),Digits,FractionalDigits,ExponentSign,Exponent)); if(IsAlpha(Cursor[0])) { auto Pos0=Cursor.Pos; do Next(1); while(IsAlnum(Cursor[0])); GRAMMAR_SET(Result,Gen.Units(Snip(Start),Result,text(Pos0,Cursor.Pos))); } GRAMMAR_RUN(DisallowDotNum()); return Result; } result_t<syntax_t> CharLit() { GRAMMAR_ASSERT(Cursor[0]=='\\''); auto Start=Cursor; Next(1); nat n=EncodedLength<place::Printable>(Cursor.Pos); if(!n) return S30(); auto Char32 = EncodedChar32(Cursor.Pos,n); auto Backslash = Cursor[0]=='\\\\' && Cursor[1] && Cursor[2]=='\\''; if(Backslash) { Next(1); if(IsStringBackslashLiteral(Cursor[0],Cursor[1])) { Char32=char32(Cursor[0]=='r'? '\\r': Cursor[0]=='n'? '\\n': Cursor[0]=='t'? '\\t': Cursor[0]); Backslash=1; Next(n); } else return S34(); } else Next(n); GRAMMAR_RUN(Require(u8\"'\",&parser::S31)); return Gen.Char32(Snip(Start),Char32,false,Backslash); } result_t<char8> Char8() { GRAMMAR_ASSERT(Cursor[0]=='0'&&Cursor[1]=='o'&&IsHex(Cursor[2])); Next(2); GRAMMAR_LET(n,ParseHex(2,0xFFULL,&parser::S18)); if(IsAlnum(Cursor[0])) return S16(); return char8(n); } result_t<char32> Char32() { GRAMMAR_ASSERT(Cursor[0]=='0'&&Cursor[1]=='u'&&IsHex(Cursor[2])); Next(2); GRAMMAR_LET(n,ParseHex(6,0x10FFFFULL,&parser::S19)); if(IsAlnum(Cursor[0])) return S16(); return char32(n); } result_t<text> Ident() { GRAMMAR_ASSERT(IsAlpha(Cursor[0])); auto Pos0=Cursor.Pos; do Next(1); while(IsAlnum(Cursor[0])); if(!Eat(u8\"'\")) return text(Pos0,Cursor.Pos); while((Cursor[0] != '\\0') && IsIdentifierQuotable(Cursor[0], Cursor[1])) Next(1); GRAMMAR_RUN(Require(u8\"'\",&parser::S24)); return text(Pos0,Cursor.Pos); } result_t<text> Path() { auto Start=Cursor; GRAMMAR_RUN(Require(u8\"/\",&parser::S25)); if(Cursor[0]=='/' || (Cursor[0]==' ' && Cursor.Pos>InputString && Cursor[-1]=='/')) return S68(); GRAMMAR_RUN(Label(u8\"/\")); if(Eat(u8\"@\")) GRAMMAR_RUN(Label(u8\"@\")); while(Eat(u8\"/\")) { text What=u8\"/\"; if(Eat(u8\"(\")) { GRAMMAR_RUN(Path()); GRAMMAR_RUN(Require(u8\":)\",&parser::S25)); What=u8\":)\"; } if(IsAlpha(Cursor[0])) { GRAMMAR_RUN(Ident()); continue; } return S20(What); } if(Cursor[0]!='/') return text(Start.Pos,Cursor.Pos); return S25(u8\"/\"); } result_t<text> Label(text What) { auto Pos0=Cursor.Pos; if(IsAlnum(Cursor[0])) { Next(1); while(IsAlnum(Cursor[0]) || Cursor[0]=='-' || Cursor[0]=='.') Next(1); return text(Pos0,Cursor.Pos); } return S26(What); } result_t<capture_t> LineCmt() { GRAMMAR_ASSERT(Cursor[0]=='#'); Next(1); capture_t Capture; GRAMMAR_RUN(Text<place::LineCmt>(Capture)); if(Ending()) return Capture; else return S03(); } result_t<capture_t> BlockCmt() { GRAMMAR_ASSERT(Cursor[0]=='<'&&Cursor[1]=='#'&&Cursor[2]!='>'); auto Start=Cursor; Next(2); capture_t Capture; GRAMMAR_RUN(Text<place::BlockCmt>(Capture)); if(Cursor[0]=='#' && Cursor[1]=='>') return Next(2), Capture; else if(Cursor[0]==0) return Cursor=Start, S04(); else return S02(); } result_t<capture_t> IndCmt() { GRAMMAR_ASSERT(Cursor[0]=='<'&&Cursor[1]=='#'&&Cursor[2]=='>'); Next(3); capture_t Capture; GRAMMAR_RUN(Text<place::LineCmt>(Capture)); if(Ending()) { GRAMMAR_LET(SavedContext,Ind()); GRAMMAR_RUN(Text<place::IndCmt>(Capture)); GRAMMAR_RUN(Ded(SavedContext,&parser::S06)); return Capture; } else return S06(); } template<place ParsePlace> result_t<nothing> Text(capture_t& Capture,place GenPlace=ParsePlace) { for(;;) { auto Start=Cursor; for(nat n; (n=EncodedLength<ParsePlace>(Cursor.Pos))!=0;) Next(n); if(Cursor.Pos!=Start.Pos) Gen.Text(Capture,Snip(Start),GenPlace); auto SpecialStart=Cursor; switch(Cursor[0]) { case '\\r': case '\\n': if constexpr(ParsePlace==place::Content || ParsePlace==place::IndCmt) { GRAMMAR_RUN(Scan(Capture,GenPlace)); if(Ending()) return nothing{}; continue; } else if constexpr(ParsePlace==place::BlockCmt) { NewLine(Capture,GenPlace); continue; } else return nothing{}; case '#': if(Cursor[1]!='>') { GRAMMAR_LET(Commentary,LineCmt()); Gen.LineCmt(Capture,Snip(SpecialStart),GenPlace,Commentary); continue; } else if constexpr(ParsePlace==place::BlockCmt) return nothing{}; else return S05(); case '<': if(Cursor[1]!='#') { return nothing{}; } else if(Cursor[2]!='>') { GRAMMAR_LET(Commentary,BlockCmt()); Gen.BlockCmt(Capture,Snip(SpecialStart),GenPlace,Commentary); continue; } else if constexpr(ParsePlace==place::Space || ParsePlace==place::Content || ParsePlace==place::IndCmt) { GRAMMAR_LET(Commentary,IndCmt()); Gen.IndCmt(Capture,Snip(SpecialStart),GenPlace,Commentary); continue; } else { Next(3); Gen.Text(Capture,Snip(SpecialStart),GenPlace); continue; } case '\\\\': if constexpr(ParsePlace==place::String || ParsePlace==place::Content) { Next(1); if(Cursor[0] && IsStringBackslashLiteral(Cursor[0],Cursor[1])) { auto Backslashed = Cursor[0]; Next(1); Gen.StringBackslash(Capture,Snip(SpecialStart),GenPlace,Backslashed); continue; } else return S34(); } default: return nothing{}; } } } result_t<block_t> Interp() { GRAMMAR_ASSERT(Cursor[0]=='{'); auto Start=Cursor; Next(1); GRAMMAR_LET(Block0,List(u8\"}\",&parser::S86,Cursor,capture_t(),punctuation::None,Cursor)); GRAMMAR_RUN(RequireClose(Start,u8\"{\",u8\"}\",&parser::S86)); return Block0; } result_t<block_t> Ampersand() { GRAMMAR_ASSERT(Cursor[0]=='&'); Next(1); auto ExprStart = Cursor; GRAMMAR_LET(Leading,Space()); auto SavedContext = Context; Context.LinePrefix = true; GRAMMAR_LET(Block0,WhenExpr(u8\"&\",prec::Def,prec::Def,nullptr,Leading,[&](expr& Expr)->result_t<block_t> { ApplyTrailing(Expr,true); auto SemicolonStart = Cursor; bool Semicolon = Eat(u8\";\"); auto Block0 = SingletonBlock(ExprStart,Expr); if(!Ending() && !Semicolon) return S57(); if(Semicolon) Gen.Semicolon(Block0.ElementsTrailing,Snip(SemicolonStart)); ApplyTrailing(Block0,Cursor); return Block0; },AllTokens)); Context = SavedContext; return Block0; } template<place Place> result_t<syntaxes_t> String(cursor TextStart,capture_t Leading=capture_t()) { syntaxes_t Splices; for(;;) { GRAMMAR_RUN(Text<Place>(Leading)); if(Cursor.Pos!=TextStart.Pos) { GRAMMAR_LET(S,Gen.StringLiteral(Snip(TextStart),Leading)); Gen.SyntaxesAppend(Splices,S); } auto SpecialStart=Cursor; switch(Cursor[0]) { case '{': { GRAMMAR_LET(Block0,Interp()); GRAMMAR_LET(S,Gen.StringInterpolate(Snip(SpecialStart),Place,1,Block0)); Gen.SyntaxesAppend(Splices,S); break; } case '&': { GRAMMAR_LET(Block0,Ampersand()); GRAMMAR_LET(S,Gen.StringInterpolate(Snip(SpecialStart),Place,0,Block0)); Gen.SyntaxesAppend(Splices,S); break; } case '<': if(Cursor[1]!='/') { GRAMMAR_LET(e,Markup()); Gen.SyntaxesAppend(Splices,e); break; } [[fallthrough]]; default: return Splices; } TextStart=Cursor; Leading=capture_t(); } } result_t<syntax_t> Contents(bool TrimLeading) { auto Start=Cursor; GRAMMAR_LET(Leading,Space(place::Content)); if(TrimLeading && Ending()) Gen.MarkupTrim(Leading); GRAMMAR_RUN(Scan(Leading,place::Content)); if(Cursor[0]!='~') { GRAMMAR_LET(Splices,String<place::Content>(Start,Leading)); if(Cursor[0]=='~') return S58(); return Gen.Content(Snip(Start),Splices); } else { Next(1); Gen.MarkupTrim(Leading); syntaxes_t Results; do { auto ElementStart=Cursor; GRAMMAR_LET(Splices,String<place::Content>(Cursor)); GRAMMAR_LET(S,Gen.Content(Snip(ElementStart),Splices)); Gen.SyntaxesAppend(Results,S); } while(Eat(u8\"~\")); return Gen.Contents(Snip(Start),Leading,Results); } } result_t<syntax_t> Trimmed(bool TrimLeading) { auto SavedContext = Context; Context.TrimInd = Cursor.LineStart; Context.Nest = true; GRAMMAR_LET(Result,Contents(TrimLeading)); Context = SavedContext; return Result; } block_t SingletonBlock(const snippet& Snippet,const syntax_t& Syntax,const capture_t& PunctuationLeading=capture_t(),punctuation Punctuation=punctuation::None) { block_t Block0(Snippet); Block0.PunctuationLeading = PunctuationLeading; Block0.Punctuation = Punctuation; Gen.SyntaxesAppend(Block0.Elements,Syntax); return Block0; } block_t SingletonBlock(const cursor& BlockStart,expr& Expr,const capture_t& PunctuationLeading=capture_t(),punctuation Punctuation=punctuation::None) { auto Block0=SingletonBlock(SnipFinished(BlockStart,Expr),*Expr,PunctuationLeading,Punctuation); Block0.BlockTrailing.MoveFrom(Expr.Trailing); return Block0; } result_t<block_t> IndList(cursor Start,const capture_t& PunctuationLeading,punctuation Punctuation,cursor LeadingStart,const capture_t& Leading=capture_t()) { GRAMMAR_LET(SavedContext,Ind()); GRAMMAR_LET(Block0,List(u8\"\",&parser::S88,Start,PunctuationLeading,Punctuation,LeadingStart,Leading)); GRAMMAR_RUN(Ded(SavedContext,&parser::S88void)); GRAMMAR_RUN(SpaceTrailing(Block0.BlockTrailing)); return Block0; } result_t<block_t> BlockHelper(text What,prec Prec,expr& OuterExpr,cursor BlockStart,capture_t PunctuationLeading, bool AllowOpen,bool AllowInd,bool AllowCommas,bool* Fails=nullptr) { switch(nat8(Cursor.Token)) { case token::NewLine(): case token::End(): { GRAMMAR_LET(ScanToken,ScanKey(PunctuationLeading,BracePostfixes)); if(!ScanToken) { if(AllowInd) return IndList(BlockStart,PunctuationLeading,punctuation::Ind,Cursor); goto bad; } [[fallthrough]]; } case token(u8\"{\"): { auto BraceStart=Cursor; EatToken(); GRAMMAR_LET(Block0,List(u8\"}\",&parser::S84,Cursor,PunctuationLeading,punctuation::Braces,Cursor)); GRAMMAR_RUN(RequireClose(BraceStart,u8\"{\",u8\"}\",&parser::S84)); Block0.BlockSnippet=Snip(BlockStart); GRAMMAR_RUN(SpaceTrailing(Block0.BlockTrailing)); return Block0; } case token(u8\".\"): { if(AllowOpen && (IsSpace(Cursor[1]) )) { EatToken(); GRAMMAR_LET(Middle,Space()); return WhenExpr(What,prec::Def,prec::Def,&OuterExpr,Middle,[&](expr& Right)->result_t<block_t> { return SingletonBlock(BlockStart,Right,PunctuationLeading,punctuation::Dot); }); } goto bad; } case token(u8\":\"): { if(AllowOpen) { auto ColonStart=Cursor; EatToken(); auto MiddleStart=Cursor; GRAMMAR_LET(Middle,Space()); if(Ending()) return IndList(BlockStart,PunctuationLeading,punctuation::Colon,MiddleStart,Middle); Cursor=ColonStart; } [[fallthrough]]; } default: if(Prec!=prec::Nothing) { if(AllowCommas) return Commas(What,Prec,BlockStart,PunctuationLeading,&parser::S71); else return WhenExpr(What,Prec,Prec,&OuterExpr,PunctuationLeading,[&](expr& Right)->result_t<block_t> { return SingletonBlock(BlockStart,Right); }); } bad: if(!Fails) return S71(What); else return *Fails=true, block_t{}; } } result_t<block_t> Block(text What,expr& OuterExpr,cursor BlockStart,const capture_t& PunctuationLeading,bool& Fails) { return BlockHelper(What,prec::Nothing,OuterExpr,BlockStart,PunctuationLeading,true,false,false,&Fails); } result_t<block_t> BraceInd(text What,prec Prec,expr& OuterExpr) { auto BlockStart=Cursor; GRAMMAR_LET(PunctuationLeading,Space()); return BlockHelper(What,Prec,OuterExpr,BlockStart,PunctuationLeading,false,true,false); } result_t<block_t> KeyBlock(prec Prec,expr& OuterExpr,cursor BlockStart,const capture_t& TokenLeading,text Token,const capture_t& PunctuationLeading) { GRAMMAR_LET(Block0,BlockHelper(Token,Prec,OuterExpr,BlockStart,PunctuationLeading,true,false,false)); Block0.Token = Token; Block0.TokenLeading = TokenLeading; return Block0; } result_t<block_t> KeyBlockDefs(expr& OuterExpr,cursor BlockStart,const capture_t& TokenLeading,text Token) { GRAMMAR_LET(PunctuationLeading,Space()); GRAMMAR_LET(Block0,BlockHelper(Token,prec::Def,OuterExpr,BlockStart,PunctuationLeading,true,false,true)); Block0.Token = Token; Block0.TokenLeading = TokenLeading; return Block0; } template<class f> result_t<nothing> WhenBraceCall(const char8* What,prec Prec,expr& OuterExpr,const f& F) { auto BlockStart=Cursor; GRAMMAR_LET(PunctuationLeading,Space()); if(Cursor.Token==token(u8\"{\") || Cursor.Token==token::NewLine()) { GRAMMAR_LET(RightBlock,BlockHelper(What,Prec,OuterExpr,BlockStart,PunctuationLeading,false,false,false)); return F(RightBlock); } else return WhenExpr(What,Prec,Prec,&OuterExpr,PunctuationLeading,[&](expr& RightExpr)->result_t<nothing> { auto RightBlock=SingletonBlock(BlockStart,RightExpr); return F(RightBlock); }); } result_t<syntax_t> QualIdentQualified(expr& Target,const cursor& Start,block_t& Block0) { GRAMMAR_RUN(Space(Block0.PunctuationTrailing)); Block0.BlockSnippet = Snip(Start); Block0.Punctuation = punctuation::Qualifier; if(IsAlpha(Cursor[0])) { GRAMMAR_LET(Id,Ident()); Target.MarkupTag=Id; return Gen.QualIdent(Snip(Start),Block0,Id); } else return S23(u8\":)\")"
  },
  {
    "label": "QualIdent()",
    "kind": "Method",
    "detail": "Function (} result_t<syntax_t>)",
    "insertText": "QualIdent(text What,expr& Target,bool AllowParenthesis)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (auto Start = Cursor ;)",
    "insertText": "if(IsAlpha(Cursor[0]))"
  },
  {
    "label": "GRAMMAR_LET()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_LET(Id,Ident())"
  },
  {
    "label": "Ident()",
    "kind": "Method",
    "detail": "Function (Target . MarkupTag = Id ; return Gen .)",
    "insertText": "Ident(Snip(Start),Id,u8\"\",u8\"\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Cursor[0]=='(') { EatToken(); GRAMMAR_LET(Block0,List(u8\")\",&parser::S81,Cursor,capture_t(),punctuation::Parens,Cursor))"
  },
  {
    "label": "GRAMMAR_RUN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_RUN(RequireClose(Start,u8\"(\",u8\")\",&parser::S81))"
  },
  {
    "label": "Snip()",
    "kind": "Method",
    "detail": "Function (Block0 . BlockSnippet =)",
    "insertText": "Snip(Start)"
  },
  {
    "label": "S23()",
    "kind": "Method",
    "detail": "Function (} else return)",
    "insertText": "S23(u8\":)\")"
  },
  {
    "label": "S20()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "S20(What)"
  },
  {
    "label": "invoke()",
    "kind": "Method",
    "detail": "Function (} struct call { text CallWhat ; cursor CallTrailingStop ; mode CallMode ; block_t& CallParameter ; call* OuterCall = nullptr ; } ; struct invoke : expr { text What ; token StartToken ; token_set InTokens,PostTokens ; call* FirstCall,* LastCall ; call* Of ; block_t* Clauses [ 3 ] ; block_t* PriorClause ;)",
    "insertText": "invoke(text What0,expr& OuterExpr0,cursor Start0,token StartToken0,token_set InTokens0,token_set PostTokens0,call* FirstCall0=nullptr,call* LastCall0=nullptr): expr(prec::Base,Start0,&OuterExpr0,OuterExpr0.MarkupStart? InvokePostfixes|MarkupPostfixes: InvokePostfixes), What(What0), StartToken(StartToken0), InTokens(InTokens0), PostTokens(PostTokens0), FirstCall(FirstCall0), LastCall(LastCall0), Of(nullptr)"
  },
  {
    "label": "PriorClause()",
    "kind": "Method",
    "detail": "Function (nullptr,nullptr,nullptr },)",
    "insertText": "PriorClause(nullptr)"
  },
  {
    "label": "UpdateLastCall()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UpdateLastCall(call* NewCall)"
  },
  {
    "label": "CheckToken()",
    "kind": "Method",
    "detail": "Function (Parser .)",
    "insertText": "CheckToken()"
  },
  {
    "label": "capture_t()",
    "kind": "Method",
    "detail": "Function (this -> Trailing = trailing { LastCall ?* LastCall -> CallParameter . BlockTrailing . TrailingStart : PriorClause ?* PriorClause -> BlockTrailing . TrailingStart : Parser . Cursor,)",
    "insertText": "capture_t()"
  },
  {
    "label": "GRAMMAR_RUN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_RUN(expr::OnFinish(Parser))"
  },
  {
    "label": "GRAMMAR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_ASSERT(PriorClause)"
  },
  {
    "label": "GRAMMAR_RUN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_RUN(Parser.UpdateFrom(*this->OuterExpr,PriorClause->BlockTrailing,Parser.Gen.Invoke( Parser.SnipFinished(this->Start,*PriorClause), Parser.ApplyTrailing(*this->OuterExpr), *Clauses[0],Clauses[1],Clauses[2])))"
  },
  {
    "label": "None()",
    "kind": "Method",
    "detail": "Function (} ; invoke NewTarget { u8 \" nested macro invocation \",* this -> OuterExpr,this -> Start,)",
    "insertText": "None()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (u8 \" do \" },token_set { u8 \" until \",u8 \" catch \" },FirstCall,LastCall } ;)",
    "insertText": "if(!this->ExprStop) return Parser.Invoke(NewTarget,Parser.Cursor,capture_t())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!StartToken)"
  },
  {
    "label": "Snip()",
    "kind": "Method",
    "detail": "Function (Call -> CallParameter . BlockSnippet =)",
    "insertText": "Snip(point::Start(Call->CallParameter.BlockSnippet),*Call->CallParameter.BlockTrailing.TrailingStart)"
  },
  {
    "label": "GRAMMAR_RUN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_RUN(Parser.UpdateFrom(*InsertCall,Call->CallParameter.BlockTrailing,Parser.Gen.Call( Snip(InsertCall->Start,point::Stop(Call->CallParameter.BlockSnippet)),Call->CallMode, Parser.ApplyTrailing(*InsertCall),Call->CallParameter)))"
  },
  {
    "label": "S76()",
    "kind": "Method",
    "detail": "Function (} return nothing { } ; } else return Parser .)",
    "insertText": "S76(What)"
  },
  {
    "label": "InvokeClause()",
    "kind": "Method",
    "detail": "Function (} } ; result_t<nothing>)",
    "insertText": "InvokeClause(invoke& Target,nat WhichClause,cursor BlockStart,block_t& Block0,cursor NextBlockStart,const capture_t& NextTokenLeading=capture_t())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (auto Specifiers = syntaxes_t { } ; const snippet* FirstSpecifier = nullptr ;)",
    "insertText": "while(auto Call=Target.FirstCall)"
  },
  {
    "label": "ApplyTrailing()",
    "kind": "Method",
    "detail": "Function (Target . FirstCall = Target . FirstCall -> OuterCall ;)",
    "insertText": "ApplyTrailing(Call->CallParameter,Call->CallTrailingStop)"
  },
  {
    "label": "GRAMMAR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_ASSERT(!Target.Clauses[0] && !Target.Clauses[1] && !Target.Clauses[2])"
  },
  {
    "label": "InvokeClause()",
    "kind": "Method",
    "detail": "Function (Call -> CallParameter . Specifiers = Specifiers ; Target . Clauses [ 0 ] =& Call -> CallParameter ; Target . Of = nullptr ; return)",
    "insertText": "InvokeClause(Target,WhichClause,BlockStart,Block0,NextBlockStart,NextTokenLeading)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Call->CallMode==mode::With)"
  },
  {
    "label": "GRAMMAR_LET()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_LET(E,Gen.Parenthesis(Call->CallParameter))"
  },
  {
    "label": "SyntaxesAppend()",
    "kind": "Method",
    "detail": "Function (Gen .)",
    "insertText": "SyntaxesAppend(Specifiers,E)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Target.PriorClause) ApplyTrailing(*Target.PriorClause,FirstSpecifier? point::Start(*FirstSpecifier): BlockStart)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Block0 . Specifiers = Specifiers ; Target . LastCall = nullptr ; Target . Clauses [ WhichClause ] =& Block0 ; Target . PriorClause = Block0 . BlockSnippet ?& Block0 : Target . PriorClause ;)",
    "insertText": "if(!Target.ExprStop) return Invoke(Target,NextBlockStart,NextTokenLeading)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (} ; result_t<nothing>)",
    "insertText": "Invoke(invoke& Target,cursor BlockStart,capture_t TokenLeading=capture_t())"
  },
  {
    "label": "GRAMMAR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_ASSERT(CheckToken())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (auto PostfixStart = Cursor ; auto PostfixToken = PostfixStart . Token ;)",
    "insertText": "if(!Target.AllowPostfixes.Has(PostfixToken)) return Target.OnFinish(*this)"
  },
  {
    "label": "GRAMMAR_LET()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_LET(InsertExpr,FinishExpr(token::None(),prec::Prefix,Target))"
  },
  {
    "label": "GRAMMAR_LET()",
    "kind": "Method",
    "detail": "Function (InsertExpr -> QualIdentTarget -> Start = PostfixStart ;)",
    "insertText": "GRAMMAR_LET(Id,QualIdentQualified(*InsertExpr,PostfixStart,Block0))"
  },
  {
    "label": "GRAMMAR_RUN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GRAMMAR_RUN(UpdateSpaceTrailing(*InsertExpr->QualIdentTarget,Id))"
  },
  {
    "label": "Snip()",
    "kind": "Method",
    "detail": "Function (Block0 . BlockSnippet =)",
    "insertText": "Snip(BlockStart)"
  }
]