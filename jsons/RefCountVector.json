[
  {
    "label": "FRefCountVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRefCountVector"
  },
  {
    "label": "BaseIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BaseIterator"
  },
  {
    "label": "IndexIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IndexIterator"
  },
  {
    "label": "IndexEnumerable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IndexEnumerable"
  },
  {
    "label": "MappedEnumerable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MappedEnumerable"
  },
  {
    "label": "FilteredEnumerable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FilteredEnumerable"
  },
  {
    "label": "FRefCountVector()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Util / DynamicVector . h \" # include \" Util / IteratorUtil . h \" namespace UE { namespace Geometry { class FRefCountVector { public : unsigned short INVALID_REF_COUNT = MAX_uint16 ;)",
    "insertText": "FRefCountVector()"
  },
  {
    "label": "FRefCountVector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRefCountVector(const FRefCountVector&)"
  },
  {
    "label": "FRefCountVector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRefCountVector(FRefCountVector&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FRefCountVector&)",
    "insertText": "operator(const FRefCountVector&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FRefCountVector&)",
    "insertText": "operator(FRefCountVector&&)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "IsDense()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDense()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid(int Index)"
  },
  {
    "label": "IsValidUnsafe()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValidUnsafe(int Index)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (int n = RefCounts [ Index ] ;)",
    "insertText": "return(n == INVALID_REF_COUNT)"
  },
  {
    "label": "GetRawRefCount()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetRawRefCount(int Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (UsedCount + + ;)",
    "insertText": "if(FreeIndices.IsEmpty())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (RefCounts .)",
    "insertText": "Add(1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} else { int iFree = INDEX_NONE ;)",
    "insertText": "while(iFree == INDEX_NONE && FreeIndices.IsEmpty() == false)"
  },
  {
    "label": "PopBack()",
    "kind": "Method",
    "detail": "Function (FreeIndices .)",
    "insertText": "PopBack()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(iFree != INDEX_NONE)"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (} } } int)",
    "insertText": "Increment(int Index, unsigned short IncrementCount = 1)"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (RefCounts [ Index ] + = IncrementCount ; return RefCounts [ Index ] ; } void)",
    "insertText": "Decrement(int Index, unsigned short DecrementCount = 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RefCounts [ Index ] - = DecrementCount ;)",
    "insertText": "if(RefCounts[Index] == 0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (FreeIndices .)",
    "insertText": "Add(Index)"
  },
  {
    "label": "AllocateAt()",
    "kind": "Method",
    "detail": "Function (RefCounts [ Index ] = INVALID_REF_COUNT ; UsedCount - - ; } } bool)",
    "insertText": "AllocateAt(int Index)"
  },
  {
    "label": "j()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "j(int)RefCounts.GetLength()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (unsigned short InvalidCount = INVALID_REF_COUNT ; RefCounts .)",
    "insertText": "Add(InvalidCount)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (FreeIndices .)",
    "insertText": "Add(j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (UsedCount + + ; return true ; } else {)",
    "insertText": "if(IsValidUnsafe(Index))"
  },
  {
    "label": "Back()",
    "kind": "Method",
    "detail": "Function (FreeIndices [ i ] = FreeIndices .)",
    "insertText": "Back()"
  },
  {
    "label": "AllocateAtUnsafe()",
    "kind": "Method",
    "detail": "Function (RefCounts [ Index ] = 1 ; UsedCount + + ; return true ; } } return false ; } } bool)",
    "insertText": "AllocateAtUnsafe(int Index)"
  },
  {
    "label": "Rebuild()",
    "kind": "Method",
    "detail": "Function (RefCounts [ Index ] = ToCount ; } template<IterateFunc,AllocateRefCountFunc,IncrementRefCountFunc> void)",
    "insertText": "Rebuild(unsigned int Num, IterateFunc&& Iterate, AllocateRefCountFunc&& AllocateRefCount, IncrementRefCountFunc&& IncrementRefCount)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (RefCounts .)",
    "insertText": "Resize(Num)"
  },
  {
    "label": "Fill()",
    "kind": "Method",
    "detail": "Function (RefCounts .)",
    "insertText": "Fill(INVALID_REF_COUNT)"
  },
  {
    "label": "IncrementRefCount()",
    "kind": "Method",
    "detail": "Function (UsedCount = 0 ; const auto UpdateRefCount = [ this,& AllocateRefCount,&)",
    "insertText": "IncrementRefCount(int32 Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned short& RefCount = RefCounts [ Index ] ;)",
    "insertText": "if(RefCount == INVALID_REF_COUNT)"
  },
  {
    "label": "AllocateRefCountFunc()",
    "kind": "Method",
    "detail": "Function (+ + UsedCount ; Forward<)",
    "insertText": "AllocateRefCountFunc(AllocateRefCount)(RefCount)"
  },
  {
    "label": "IncrementRefCountFunc()",
    "kind": "Method",
    "detail": "Function (} else { Forward<)",
    "insertText": "IncrementRefCountFunc(IncrementRefCount)(RefCount)"
  },
  {
    "label": "IterateFunc()",
    "kind": "Method",
    "detail": "Function (} } ; Forward<)",
    "insertText": "IterateFunc(Iterate)(UpdateRefCount)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (const unsigned int FreeIndicesNum = Num - UsedCount ; FreeIndices .)",
    "insertText": "SetNum(FreeIndicesNum)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (unsigned int FreeIndicesIndex = 0 ;)",
    "insertText": "for(unsigned int Index = 0; (Index < Num) & (FreeIndicesIndex < FreeIndicesNum); ++Index)"
  },
  {
    "label": "RebuildFreeList()",
    "kind": "Method",
    "detail": "Function (FreeIndices [ FreeIndicesIndex + + ] = Index ; } } } void)",
    "insertText": "RebuildFreeList()"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (FreeIndices .)",
    "insertText": "Clear()"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (UsedCount = 0 ; int)",
    "insertText": "N(int)RefCounts.GetLength()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (UsedCount + + ; } else { FreeIndices .)",
    "insertText": "Add(i)"
  },
  {
    "label": "Trim()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "Trim(int maxIndex)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (RefCounts .)",
    "insertText": "Resize(maxIndex)"
  },
  {
    "label": "BaseIterator()",
    "kind": "Method",
    "detail": "Function (UsedCount = 0 ; } class BaseIterator { public :)",
    "insertText": "BaseIterator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Vector = nullptr ; Index = 0 ; LastIndex = 0 ; } bool)",
    "insertText": "operator(const BaseIterator& Other)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Index + + ;)",
    "insertText": "while(Index < LastIndex && Vector->IsValidUnsafe(Index) == false)"
  },
  {
    "label": "BaseIterator()",
    "kind": "Method",
    "detail": "Function (Index + + ; } })",
    "insertText": "BaseIterator(const FRefCountVector* VectorIn, int IndexIn, int LastIn)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vector = VectorIn ; Index = IndexIn ; LastIndex = LastIn ;)",
    "insertText": "if(Index != LastIndex && Vector->IsValidUnsafe(Index) == false)"
  },
  {
    "label": "IndexIterator()",
    "kind": "Method",
    "detail": "Function (} } const FRefCountVector* Vector ; int Index ; int LastIndex ; class FRefCountVector ; } ; class IndexIterator : public BaseIterator { public :)",
    "insertText": "IndexIterator() : BaseIterator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "operator()"
  },
  {
    "label": "goto_next()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "goto_next()"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (IndexIterator)",
    "insertText": "copy(*this)"
  },
  {
    "label": "BeginIndices()",
    "kind": "Method",
    "detail": "Function (} class FRefCountVector ; } ; IndexIterator)",
    "insertText": "BeginIndices()"
  },
  {
    "label": "EndIndices()",
    "kind": "Method",
    "detail": "Function (} IndexIterator)",
    "insertText": "EndIndices()"
  },
  {
    "label": "IndexEnumerable()",
    "kind": "Method",
    "detail": "Function (} class IndexEnumerable { public : const FRefCountVector* Vector ;)",
    "insertText": "IndexEnumerable()"
  },
  {
    "label": "IndexEnumerable()",
    "kind": "Method",
    "detail": "Function (Vector = nullptr ; })",
    "insertText": "IndexEnumerable(const FRefCountVector* VectorIn)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (Vector = VectorIn ; } FRefCountVector::IndexIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} FRefCountVector::IndexIterator)",
    "insertText": "end()"
  },
  {
    "label": "Indices()",
    "kind": "Method",
    "detail": "Function (} } ; IndexEnumerable)",
    "insertText": "Indices()"
  },
  {
    "label": "ToType()",
    "kind": "Method",
    "detail": "Function (} template<ToType> class MappedEnumerable { public : TFunction<)",
    "insertText": "ToType(int)"
  },
  {
    "label": "MappedEnumerable()",
    "kind": "Method",
    "detail": "Function (IndexEnumerable enumerable ;)",
    "insertText": "MappedEnumerable(const IndexEnumerable& enumerable, TFunction<ToType(int)> MapFunc)"
  },
  {
    "label": "MappedIndices()",
    "kind": "Method",
    "detail": "Function (} } ; template<ToType> MappedEnumerable<ToType>)",
    "insertText": "MappedIndices(TFunction<ToType(int)> MapFunc)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} class FilteredEnumerable { public : TFunction<)",
    "insertText": "bool(int)"
  },
  {
    "label": "FilteredEnumerable()",
    "kind": "Method",
    "detail": "Function (IndexEnumerable enumerable ;)",
    "insertText": "FilteredEnumerable(const IndexEnumerable& enumerable, TFunction<bool(int)> FilterFuncIn)"
  },
  {
    "label": "FilteredIndices()",
    "kind": "Method",
    "detail": "Function (} } ; FilteredEnumerable)",
    "insertText": "FilteredIndices(TFunction<bool(int)> FilterFunc)"
  },
  {
    "label": "UsageStats()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "UsageStats()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FArchive&)",
    "insertText": "operator(FArchive& Ar, FRefCountVector& Vec)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Vec .)",
    "insertText": "Serialize(Ar, false, false)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FUE5MainStreamObjectVersion::GUID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<RefCounts ; Ar<<FreeIndices ; Ar<<UsedCount ; } else { Ar<<bCompactData ; Ar<<bUseCompression ; Ar<<UsedCount ;)",
    "insertText": "if(bUseCompression)"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (RefCounts . Serialize<true,)",
    "insertText": "true(Ar)"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (} else { RefCounts . Serialize<true,)",
    "insertText": "false(Ar)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(UsedCount == RefCounts.Num())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(bCompactData || bUseCompression)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const size_t NumFree = RefCounts .)",
    "insertText": "Num()"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (FreeIndices .)",
    "insertText": "Resize(NumFree)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t Index = 0 ;)",
    "insertText": "for(size_t i = 0, Num = RefCounts.Num(); (i < Num) & (Index < NumFree); ++i)"
  },
  {
    "label": "ensure()",
    "kind": "Method",
    "detail": "Function (FreeIndices [ Index + + ] = i ; } })",
    "insertText": "ensure(Index == NumFree)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } } } bool)",
    "insertText": "operator(const FRefCountVector& Lhs, const FRefCountVector& Rhs)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (const bool LhsIsValid = Lhs .)",
    "insertText": "IsValid(Idx)"
  }
]