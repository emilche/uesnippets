[
  {
    "label": "SameInternalConfig",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SameInternalConfig"
  },
  {
    "label": "InternalNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InternalNode"
  },
  {
    "label": "ValueConverter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueConverter"
  },
  {
    "label": "SameConfiguration",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SameConfiguration"
  },
  {
    "label": "ValueOn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueOn"
  },
  {
    "label": "ValueOff",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueOff"
  },
  {
    "label": "ValueAll",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueAll"
  },
  {
    "label": "ChildOn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChildOn"
  },
  {
    "label": "ChildOff",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChildOff"
  },
  {
    "label": "ChildAll",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChildAll"
  },
  {
    "label": "ChildIter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChildIter"
  },
  {
    "label": "ValueIter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValueIter"
  },
  {
    "label": "DenseIter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DenseIter"
  },
  {
    "label": "IteratorBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IteratorBase"
  },
  {
    "label": "VoxelizeActiveTiles",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VoxelizeActiveTiles"
  },
  {
    "label": "DeepCopy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DeepCopy"
  },
  {
    "label": "TopologyCopy1",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TopologyCopy1"
  },
  {
    "label": "TopologyCopy2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TopologyCopy2"
  },
  {
    "label": "TopologyUnion",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TopologyUnion"
  },
  {
    "label": "TopologyDifference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TopologyDifference"
  },
  {
    "label": "TopologyIntersection",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TopologyIntersection"
  },
  {
    "label": "A",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "A"
  },
  {
    "label": "B",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "B"
  },
  {
    "label": "NUM_VALUES()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TREE_INTERNALNODE_HAS_BEEN_INCLUDED # define OPENVDB_TREE_INTERNALNODE_HAS_BEEN_INCLUDED # include<openvdb / Platform . h> # include<openvdb / util / NodeMasks . h> # include<openvdb / io / Compression . h> # include<openvdb / math / Math . h> # include<openvdb / version . h> # include<openvdb / Types . h> # include \" Iterator . h \" # include \" NodeUnion . h \" # include<tbb / parallel_for . h> # include<memory> # include<type_traits> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tree { template<,Index,> struct SameInternalConfig ; template<_ChildNodeType,Index Log2Dim> class InternalNode { public : using ChildNodeType = _ChildNodeType ; using LeafNodeType = ChildNodeType::LeafNodeType ; using ValueType = ChildNodeType::ValueType ; using BuildType = ChildNodeType::BuildType ; using UnionType = NodeUnion<ValueType,ChildNodeType> ; using NodeMaskType = util::NodeMask<Log2Dim> ; const Index LOG2DIM = Log2Dim,TOTAL = Log2Dim + ChildNodeType::TOTAL,DIM = 1<<TOTAL,)",
    "insertText": "NUM_VALUES(3 * Log2Dim)"
  },
  {
    "label": "uint64_t()",
    "kind": "Method",
    "detail": "Function (const Index64 NUM_VOXELS =)",
    "insertText": "uint64_t(1) << (3 * TOTAL)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (template<OtherValueType> struct ValueConverter { using Type = InternalNode<ChildNodeType::template ValueConverter<OtherValueType>::Type,Log2Dim> ; } ; template<OtherNodeType> struct SameConfiguration { const bool value = SameInternalConfig<ChildNodeType,Log2Dim,OtherNodeType>::value ; } ;)",
    "insertText": "InternalNode()"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "InternalNode(const ValueType& offValue)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InternalNode(const Coord& origin, const ValueType& fillValue, bool active = false)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InternalNode(PartialCreate, const Coord&, const ValueType& fillValue, bool active = false)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InternalNode(const InternalNode&)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (template<OtherChildNodeType>)",
    "insertText": "InternalNode(const InternalNode<OtherChildNodeType, Log2Dim>& other)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (template<OtherChildNodeType>)",
    "insertText": "InternalNode(const InternalNode<OtherChildNodeType, Log2Dim>& other, const ValueType& background, TopologyCopy)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (template<OtherChildNodeType>)",
    "insertText": "InternalNode(const InternalNode<OtherChildNodeType, Log2Dim>& other, const ValueType& offValue, const ValueType& onValue, TopologyCopy)"
  },
  {
    "label": "ChildIter()",
    "kind": "Method",
    "detail": "Function (protected : using MaskOnIterator = NodeMaskType::OnIterator ; using MaskOffIterator = NodeMaskType::OffIterator ; using MaskDenseIterator = NodeMaskType::DenseIterator ; struct ValueOn { } ; struct ValueOff { } ; struct ValueAll { } ; struct ChildOn { } ; struct ChildOff { } ; struct ChildAll { } ; template<NodeT,ChildT,MaskIterT,TagT> struct ChildIter : public SparseIteratorBase<MaskIterT,ChildIter<NodeT,ChildT,MaskIterT,TagT>,NodeT,ChildT> {)",
    "insertText": "ChildIter()"
  },
  {
    "label": "ChildIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ChildIter(const MaskIterT& iter, NodeT* parent): SparseIteratorBase< MaskIterT, ChildIter<NodeT, ChildT, MaskIterT, TagT>, NodeT, ChildT>(iter, parent)"
  },
  {
    "label": "getItem()",
    "kind": "Method",
    "detail": "Function (} ChildT&)",
    "insertText": "getItem(Index pos)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(this->parent().isChildMaskOn(pos))"
  },
  {
    "label": "setItem()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setItem(Index pos, const ChildT& c)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "parent().resetChildNode(pos, &c)"
  },
  {
    "label": "ValueIter()",
    "kind": "Method",
    "detail": "Function (} } ; template<NodeT,ValueT,MaskIterT,TagT> struct ValueIter : public SparseIteratorBase<MaskIterT,ValueIter<NodeT,ValueT,MaskIterT,TagT>,NodeT,ValueT> {)",
    "insertText": "ValueIter()"
  },
  {
    "label": "ValueIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueIter(const MaskIterT& iter, NodeT* parent): SparseIteratorBase< MaskIterT, ValueIter<NodeT, ValueT, MaskIterT, TagT>, NodeT, ValueT>(iter, parent)"
  },
  {
    "label": "setItem()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setItem(Index pos, const ValueT& v)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "parent().mNodes[pos].setValue(v)"
  },
  {
    "label": "modifyItem()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyItem(Index pos, const ModifyOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(this->parent().mNodes[pos].getValue())"
  },
  {
    "label": "DenseIter()",
    "kind": "Method",
    "detail": "Function (} } ; template<NodeT,ChildT,ValueT,TagT> struct DenseIter : public DenseIteratorBase<MaskDenseIterator,DenseIter<NodeT,ChildT,ValueT,TagT>,NodeT,ChildT,ValueT> { using BaseT = DenseIteratorBase<MaskDenseIterator,DenseIter,NodeT,ChildT,ValueT> ; using NonConstValueT = BaseT::NonConstValueType ;)",
    "insertText": "DenseIter()"
  },
  {
    "label": "DenseIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DenseIter(const MaskDenseIterator& iter, NodeT* parent): DenseIteratorBase<MaskDenseIterator, DenseIter, NodeT, ChildT, ValueT>(iter, parent)"
  },
  {
    "label": "getItem()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "getItem(Index pos, ChildT*& child, NonConstValueT& value)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (child = this ->)",
    "insertText": "parent().getChildNode(pos)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "parent().resetChildNode(pos, child)"
  },
  {
    "label": "unsetItem()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "unsetItem(Index pos, const ValueT& value)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "parent().unsetChildNode(pos, value)"
  },
  {
    "label": "cbeginChildOn()",
    "kind": "Method",
    "detail": "Function (} } ; public : using ChildOnIter = ChildIter<InternalNode,ChildNodeType,MaskOnIterator,ChildOn> ; using ChildOnCIter = ChildIter<const InternalNode,const ChildNodeType,MaskOnIterator,ChildOn> ; using ChildOffIter = ValueIter<InternalNode,const ValueType,MaskOffIterator,ChildOff> ; using ChildOffCIter = ValueIter<const InternalNode,const ValueType,MaskOffIterator,ChildOff> ; using ChildAllIter = DenseIter<InternalNode,ChildNodeType,ValueType,ChildAll> ; using ChildAllCIter = DenseIter<const InternalNode,const ChildNodeType,ValueType,ChildAll> ; using ValueOnIter = ValueIter<InternalNode,const ValueType,MaskOnIterator,ValueOn> ; using ValueOnCIter = ValueIter<const InternalNode,const ValueType,MaskOnIterator,ValueOn> ; using ValueOffIter = ValueIter<InternalNode,const ValueType,MaskOffIterator,ValueOff> ; using ValueOffCIter = ValueIter<const InternalNode,const ValueType,MaskOffIterator,ValueOff> ; using ValueAllIter = ValueIter<InternalNode,const ValueType,MaskOffIterator,ValueAll> ; using ValueAllCIter = ValueIter<const InternalNode,const ValueType,MaskOffIterator,ValueAll> ; ChildOnCIter)",
    "insertText": "cbeginChildOn()"
  },
  {
    "label": "cbeginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "cbeginChildOff()"
  },
  {
    "label": "cbeginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "cbeginChildAll()"
  },
  {
    "label": "beginChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "beginChildOn()"
  },
  {
    "label": "beginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "beginChildOff()"
  },
  {
    "label": "beginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "beginChildAll()"
  },
  {
    "label": "cbeginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "cbeginValueOn()"
  },
  {
    "label": "cbeginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cbeginValueOff()"
  },
  {
    "label": "cbeginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cbeginValueAll()"
  },
  {
    "label": "beginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "beginValueOn()"
  },
  {
    "label": "beginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "beginValueOff()"
  },
  {
    "label": "beginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "beginValueAll()"
  },
  {
    "label": "dim()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "dim()"
  },
  {
    "label": "getChildDim()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "getChildDim()"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "offsetToLocalCoord(Index n, Coord& xyz)"
  },
  {
    "label": "offsetToGlobalCoord()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "offsetToGlobalCoord(Index n)"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (const Coord&)",
    "insertText": "origin()"
  },
  {
    "label": "leafCount()",
    "kind": "Method",
    "detail": "Function (mOrigin = origin ; } Index32)",
    "insertText": "leafCount()"
  },
  {
    "label": "nodeCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nodeCount(std::vector<Index32> &vec)"
  },
  {
    "label": "nonLeafCount()",
    "kind": "Method",
    "detail": "Function (Index32)",
    "insertText": "nonLeafCount()"
  },
  {
    "label": "childCount()",
    "kind": "Method",
    "detail": "Function (Index32)",
    "insertText": "childCount()"
  },
  {
    "label": "onVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "onVoxelCount()"
  },
  {
    "label": "offVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "offVoxelCount()"
  },
  {
    "label": "onLeafVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "onLeafVoxelCount()"
  },
  {
    "label": "offLeafVoxelCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "offLeafVoxelCount()"
  },
  {
    "label": "onTileCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "onTileCount()"
  },
  {
    "label": "memUsage()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "memUsage()"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalActiveBoundingBox(CoordBBox& bbox, bool visitVoxels = true)"
  },
  {
    "label": "getNodeBoundingBox()",
    "kind": "Method",
    "detail": "Function (CoordBBox)",
    "insertText": "getNodeBoundingBox()"
  },
  {
    "label": "isEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isEmpty()"
  },
  {
    "label": "isConstant()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isConstant(ValueType& firstValue, bool& state, const ValueType& tolerance = zeroVal<ValueType>())"
  },
  {
    "label": "isConstant()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isConstant(ValueType& minValue, ValueType& maxValue, bool& state, const ValueType& tolerance = zeroVal<ValueType>())"
  },
  {
    "label": "isInactive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isInactive()"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueOn(const Coord& xyz)"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isValueOn(Index offset)"
  },
  {
    "label": "hasActiveTiles()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasActiveTiles()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "getValue(const Coord& xyz)"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "probeValue(const Coord& xyz, ValueType& value)"
  },
  {
    "label": "getValueLevel()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "getValueLevel(const Coord& xyz)"
  },
  {
    "label": "getFirstValue()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "getFirstValue()"
  },
  {
    "label": "getLastValue()",
    "kind": "Method",
    "detail": "Function (const ValueType&)",
    "insertText": "getLastValue()"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setActiveState(const Coord& xyz, bool on)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOnly(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOn(const Coord& xyz)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOn(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOff(const Coord& xyz)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOff(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp> void)",
    "insertText": "modifyValue(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp> void)",
    "insertText": "modifyValueAndActiveState(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "getValueAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> const ValueType&)",
    "insertText": "getValueAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "isValueOnAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> bool)",
    "insertText": "isValueOnAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "setValueAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "setValueAndCache(const Coord& xyz, const ValueType& value, AccessorT&)"
  },
  {
    "label": "setValueOnlyAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "setValueOnlyAndCache(const Coord& xyz, const ValueType& value, AccessorT&)"
  },
  {
    "label": "modifyValueAndCache()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp,AccessorT> void)",
    "insertText": "modifyValueAndCache(const Coord& xyz, const ModifyOp& op, AccessorT&)"
  },
  {
    "label": "modifyValueAndActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (template<ModifyOp,AccessorT> void)",
    "insertText": "modifyValueAndActiveStateAndCache(const Coord& xyz, const ModifyOp& op, AccessorT&)"
  },
  {
    "label": "setValueOffAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "setValueOffAndCache(const Coord& xyz, const ValueType& value, AccessorT&)"
  },
  {
    "label": "setActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "setActiveStateAndCache(const Coord& xyz, bool on, AccessorT&)"
  },
  {
    "label": "probeValueAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> bool)",
    "insertText": "probeValueAndCache(const Coord& xyz, ValueType& value, AccessorT&)"
  },
  {
    "label": "getValueLevelAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> Index)",
    "insertText": "getValueLevelAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "setValuesOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValuesOn()"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeTopology(std::ostream&, bool toHalf = false)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readTopology(std::istream&, bool fromHalf = false)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(std::ostream&, bool toHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream&, bool fromHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream&, const CoordBBox&, bool fromHalf = false)"
  },
  {
    "label": "negate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "negate()"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "denseFill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "denseFill(const CoordBBox& bbox, const ValueType& value, bool active = true)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "voxelizeActiveTiles(bool threaded = true)"
  },
  {
    "label": "copyToDense()",
    "kind": "Method",
    "detail": "Function (template<DenseT> void)",
    "insertText": "copyToDense(const CoordBBox& bbox, DenseT& dense)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (template<MergePolicy Policy> void)",
    "insertText": "merge(InternalNode& other, const ValueType& background, const ValueType& otherBackground)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (template<MergePolicy Policy> void)",
    "insertText": "merge(const ValueType& tileValue, bool tileActive)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (template<OtherChildNodeType> void)",
    "insertText": "topologyUnion(const InternalNode<OtherChildNodeType, Log2Dim>& other, const bool preserveTiles = false)"
  },
  {
    "label": "topologyIntersection()",
    "kind": "Method",
    "detail": "Function (template<OtherChildNodeType> void)",
    "insertText": "topologyIntersection(const InternalNode<OtherChildNodeType, Log2Dim>& other, const ValueType& background)"
  },
  {
    "label": "topologyDifference()",
    "kind": "Method",
    "detail": "Function (template<OtherChildNodeType> void)",
    "insertText": "topologyDifference(const InternalNode<OtherChildNodeType, Log2Dim>& other, const ValueType& background)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (template<CombineOp> void)",
    "insertText": "combine(InternalNode& other, CombineOp&)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (template<CombineOp> void)",
    "insertText": "combine(const ValueType& value, bool valueIsActive, CombineOp&)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (template<CombineOp,OtherNodeType> void)",
    "insertText": "combine2(const InternalNode& other0, const OtherNodeType& other1, CombineOp&)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (template<CombineOp,OtherNodeType> void)",
    "insertText": "combine2(const ValueType& value, const OtherNodeType& other, bool valIsActive, CombineOp&)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (template<CombineOp,OtherValueType> void)",
    "insertText": "combine2(const InternalNode& other, const OtherValueType&, bool valIsActive, CombineOp&)"
  },
  {
    "label": "visitActiveBBox()",
    "kind": "Method",
    "detail": "Function (template<BBoxOp> void)",
    "insertText": "visitActiveBBox(BBoxOp&)"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (template<VisitorOp> void)",
    "insertText": "visit(VisitorOp&)"
  },
  {
    "label": "visit2Node()",
    "kind": "Method",
    "detail": "Function (template<OtherNodeType,VisitorOp> void)",
    "insertText": "visit2Node(OtherNodeType& other, VisitorOp&)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (template<IterT,VisitorOp> void)",
    "insertText": "visit2(IterT& otherIter, VisitorOp&, bool otherIsLHS = false)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clip(const CoordBBox&, const ValueType& background)"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prune(const ValueType& tolerance = zeroVal<ValueType>())"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addLeaf(LeafNodeType* leaf)"
  },
  {
    "label": "addLeafAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "addLeafAndCache(LeafNodeType* leaf, AccessorT&)"
  },
  {
    "label": "stealNode()",
    "kind": "Method",
    "detail": "Function (template<NodeT> NodeT*)",
    "insertText": "stealNode(const Coord& xyz, const ValueType& value, bool state)"
  },
  {
    "label": "addChild()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "addChild(ChildNodeType* child)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addTile(Index level, const Coord& xyz, const ValueType& value, bool state)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addTile(Index offset, const ValueType& value, bool state)"
  },
  {
    "label": "addTileAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "addTileAndCache(Index level, const Coord& xyz, const ValueType&, bool state, AccessorT&)"
  },
  {
    "label": "probeNode()",
    "kind": "Method",
    "detail": "Function (template<NodeType> NodeType*)",
    "insertText": "probeNode(const Coord& xyz)"
  },
  {
    "label": "probeConstNode()",
    "kind": "Method",
    "detail": "Function (template<NodeType> const NodeType*)",
    "insertText": "probeConstNode(const Coord& xyz)"
  },
  {
    "label": "probeNodeAndCache()",
    "kind": "Method",
    "detail": "Function (template<NodeType,AccessorT> NodeType*)",
    "insertText": "probeNodeAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "probeConstNodeAndCache()",
    "kind": "Method",
    "detail": "Function (template<NodeType,AccessorT> const NodeType*)",
    "insertText": "probeConstNodeAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (LeafNodeType*)",
    "insertText": "probeLeaf(const Coord& xyz)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (const LeafNodeType*)",
    "insertText": "probeConstLeaf(const Coord& xyz)"
  },
  {
    "label": "probeLeafAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> LeafNodeType*)",
    "insertText": "probeLeafAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "probeConstLeafAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> const LeafNodeType*)",
    "insertText": "probeConstLeafAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (LeafNodeType*)",
    "insertText": "touchLeaf(const Coord& xyz)"
  },
  {
    "label": "touchLeafAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> LeafNodeType*)",
    "insertText": "touchLeafAndCache(const Coord& xyz, AccessorT&)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (template<ArrayT> void)",
    "insertText": "getNodes(ArrayT& array)"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (template<ArrayT> void)",
    "insertText": "stealNodes(ArrayT& array, const ValueType& value, bool state)"
  },
  {
    "label": "resetBackground()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resetBackground(const ValueType& oldBackground, const ValueType& newBackground)"
  },
  {
    "label": "hasSameTopology()",
    "kind": "Method",
    "detail": "Function (template<OtherChildNodeType,Index OtherLog2Dim> bool)",
    "insertText": "hasSameTopology(const InternalNode<OtherChildNodeType, OtherLog2Dim>* other)"
  },
  {
    "label": "isValueMaskOn()",
    "kind": "Method",
    "detail": "Function (protected : class IteratorBase<MaskOnIterator,InternalNode> ; class IteratorBase<MaskOffIterator,InternalNode> ; class IteratorBase<MaskDenseIterator,InternalNode> ; template<,Index> class InternalNode ; public : bool)",
    "insertText": "isValueMaskOn(Index n)"
  },
  {
    "label": "isValueMaskOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueMaskOn()"
  },
  {
    "label": "isValueMaskOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueMaskOff(Index n)"
  },
  {
    "label": "isValueMaskOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueMaskOff()"
  },
  {
    "label": "isChildMaskOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isChildMaskOn(Index n)"
  },
  {
    "label": "isChildMaskOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isChildMaskOff(Index n)"
  },
  {
    "label": "isChildMaskOff()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isChildMaskOff()"
  },
  {
    "label": "getValueMask()",
    "kind": "Method",
    "detail": "Function (} const NodeMaskType&)",
    "insertText": "getValueMask()"
  },
  {
    "label": "toggle()",
    "kind": "Method",
    "detail": "Function (NodeMaskType mask = mValueMask ; mask | = mChildMask ; mask .)",
    "insertText": "toggle()"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(n, mChildMask.isOn(n) ? false : on)"
  },
  {
    "label": "makeChildNodeEmpty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "makeChildNodeEmpty(Index n, const ValueType& value)"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setChildNode(Index i, ChildNodeType* child)"
  },
  {
    "label": "resetChildNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resetChildNode(Index i, ChildNodeType* child)"
  },
  {
    "label": "unsetChildNode()",
    "kind": "Method",
    "detail": "Function (ChildNodeType*)",
    "insertText": "unsetChildNode(Index i, const ValueType& value)"
  },
  {
    "label": "doVisit()",
    "kind": "Method",
    "detail": "Function (template<NodeT,VisitorOp,ChildAllIterT> void)",
    "insertText": "doVisit(NodeT&, VisitorOp&)"
  },
  {
    "label": "doVisit2Node()",
    "kind": "Method",
    "detail": "Function (template<NodeT,OtherNodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void)",
    "insertText": "doVisit2Node(NodeT&, OtherNodeT&, VisitorOp&)"
  },
  {
    "label": "doVisit2()",
    "kind": "Method",
    "detail": "Function (template<NodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void)",
    "insertText": "doVisit2(NodeT&, OtherChildAllIterT&, VisitorOp&, bool otherIsLHS)"
  },
  {
    "label": "getChildNode()",
    "kind": "Method",
    "detail": "Function (ChildNodeType*)",
    "insertText": "getChildNode(Index n)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (struct VoxelizeActiveTiles ; template<OtherInternalNode> struct DeepCopy ; template<OtherInternalNode> struct TopologyCopy1 ; template<OtherInternalNode> struct TopologyCopy2 ; template<OtherInternalNode> struct TopologyUnion ; template<OtherInternalNode> struct TopologyDifference ; template<OtherInternalNode> struct TopologyIntersection ; UnionType mNodes [ NUM_VALUES ] ; NodeMaskType mChildMask,mValueMask ; Coord mOrigin ; } ; template<ChildT1,Index Dim1,NodeT2> struct SameInternalConfig { const bool value = false ; } ; template<ChildT1,Index Dim1,ChildT2> struct SameInternalConfig<ChildT1,Dim1,InternalNode<ChildT2,Dim1>> { const bool value = ChildT1::template SameConfiguration<ChildT2>::value ; } ; template<ChildT,Index Log2Dim> InternalNode<ChildT,Log2Dim)",
    "insertText": "InternalNode(const ValueType& background)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> InternalNode<ChildT,Log2Dim)",
    "insertText": "InternalNode(const Coord& origin, const ValueType& val, bool active): mOrigin(origin[0] & ~(DIM - 1), origin[1] & ~(DIM - 1), origin[2] & ~(DIM - 1))"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> InternalNode<ChildT,Log2Dim)",
    "insertText": "InternalNode(PartialCreate, const Coord& origin, const ValueType& val, bool active) : mOrigin(origin[0] & ~(DIM-1), origin[1] & ~(DIM-1), origin[2] & ~(DIM-1))"
  },
  {
    "label": "DeepCopy()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<OtherInternalNode> struct InternalNode<ChildT,Log2Dim>::DeepCopy {)",
    "insertText": "DeepCopy(const OtherInternalNode* source, InternalNode* target) : s(source), t(target)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<Index>(0, NUM_VALUES), *this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const tbb::blocked_range<Index> &r)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (t -> mNodes [ i ] .)",
    "insertText": "setValue(ValueType(s->mNodes[i].getValue()))"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (} else { t -> mNodes [ i ] .)",
    "insertText": "setChild(new ChildNodeType(*(s->mNodes[i].getChild())))"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (} } } const OtherInternalNode* s ; InternalNode* t ; } ; template<ChildT,Index Log2Dim> InternalNode<ChildT,Log2Dim)",
    "insertText": "InternalNode(const InternalNode& other): mChildMask(other.mChildMask), mValueMask(other.mValueMask), mOrigin(other.mOrigin)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (DeepCopy<InternalNode<ChildT,Log2Dim>>)",
    "insertText": "tmp(&other, this)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<OtherChildNodeType> InternalNode<ChildT,Log2Dim)",
    "insertText": "InternalNode(const InternalNode<OtherChildNodeType, Log2Dim>& other) : mChildMask(other.mChildMask) , mValueMask(other.mValueMask) , mOrigin(other.mOrigin)"
  },
  {
    "label": "TopologyCopy1()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<OtherInternalNode> struct InternalNode<ChildT,Log2Dim>::TopologyCopy1 {)",
    "insertText": "TopologyCopy1(const OtherInternalNode* source, InternalNode* target, const ValueType& background) : s(source), t(target), b(background)"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (t -> mNodes [ i ] .)",
    "insertText": "setChild(new ChildNodeType(*(s->mNodes[i].getChild()), b, TopologyCopy()))"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} else { t -> mNodes [ i ] .)",
    "insertText": "setValue(b)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (} } } const OtherInternalNode* s ; InternalNode* t ; const ValueType& b ; } ; template<ChildT,Index Log2Dim> template<OtherChildNodeType> InternalNode<ChildT,Log2Dim)",
    "insertText": "InternalNode(const InternalNode<OtherChildNodeType, Log2Dim>& other, const ValueType& background, TopologyCopy): mChildMask(other.mChildMask), mValueMask(other.mValueMask), mOrigin(other.mOrigin)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (TopologyCopy1<InternalNode<OtherChildNodeType,Log2Dim>>)",
    "insertText": "tmp(&other, this, background)"
  },
  {
    "label": "TopologyCopy2()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<OtherInternalNode> struct InternalNode<ChildT,Log2Dim>::TopologyCopy2 {)",
    "insertText": "TopologyCopy2(const OtherInternalNode* source, InternalNode* target, const ValueType& offValue, const ValueType& onValue) : s(source), t(target), offV(offValue), onV(onValue)"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (t -> mNodes [ i ] .)",
    "insertText": "setChild(new ChildNodeType(*(s->mNodes[i].getChild()), offV, onV, TopologyCopy()))"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} else { t -> mNodes [ i ] .)",
    "insertText": "setValue(s->isValueMaskOn(i) ? onV : offV)"
  },
  {
    "label": "InternalNode()",
    "kind": "Method",
    "detail": "Function (} } } const OtherInternalNode* s ; InternalNode* t ; const ValueType& offV,& onV ; } ; template<ChildT,Index Log2Dim> template<OtherChildNodeType> InternalNode<ChildT,Log2Dim)",
    "insertText": "InternalNode(const InternalNode<OtherChildNodeType, Log2Dim>& other, const ValueType& offValue, const ValueType& onValue, TopologyCopy): mChildMask(other.mChildMask), mValueMask(other.mValueMask), mOrigin(other.mOrigin)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (TopologyCopy2<InternalNode<OtherChildNodeType,Log2Dim>>)",
    "insertText": "tmp(&other, this, offValue, onValue)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (delete mNodes [ iter .)",
    "insertText": "pos()].getChild()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index32 sum = 0 ;)",
    "insertText": "for(ChildOnCIter iter = this->cbeginChildOn(); iter; ++iter)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(vec.size() > ChildNodeType::LEVEL)"
  },
  {
    "label": "countOn()",
    "kind": "Method",
    "detail": "Function (const auto count = mChildMask .)",
    "insertText": "countOn()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index32 sum = 1 ;)",
    "insertText": "if(ChildNodeType::getLevel() == 0)"
  },
  {
    "label": "NUM_VOXELS()",
    "kind": "Method",
    "detail": "Function (Index64 sum =)",
    "insertText": "NUM_VOXELS(NUM_VALUES-mValueMask.countOn()-mChildMask.countOn())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index64 sum = 0 ;)",
    "insertText": "for(ChildOnCIter iter = this->beginChildOn(); iter; ++iter)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (sum + = mNodes [ iter .)",
    "insertText": "pos()].getChild()->onLeafVoxelCount()"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (sum + = mNodes [ iter .)",
    "insertText": "pos()].getChild()->offLeafVoxelCount()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (Index64 sum = NUM_VALUES*)",
    "insertText": "sizeof(UnionType) + mChildMask.memUsage() + mValueMask.memUsage() + sizeof(mOrigin)"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (} return sum ; } template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "evalActiveBoundingBox(CoordBBox& bbox, bool visitVoxels)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "expand(i.getCoord(), ChildT::DIM)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(ChildOnCIter i = this->cbeginChildOn(); i; ++i)"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (i ->)",
    "insertText": "evalActiveBoundingBox(bbox, visitVoxels)"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (} } template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "prune(const ValueType& tolerance)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (bool state = false ; ValueType value = zeroVal<)",
    "insertText": "ValueType()"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (const Index i = iter .)",
    "insertText": "pos()"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (ChildT* child = mNodes [ i ] .)",
    "insertText": "getChild()"
  },
  {
    "label": "prune()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "prune(tolerance)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (delete child ; mChildMask .)",
    "insertText": "setOff(i)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(i, state)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (mNodes [ i ] .)",
    "insertText": "setValue(value)"
  },
  {
    "label": "coordToOffset()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN const Index n = this ->)",
    "insertText": "coordToOffset(xyz)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mChildMask .)",
    "insertText": "setOff(n)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(n, state)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(std::is_same<NodeT, ChildT>::value) ? reinterpret_cast<NodeT*>(child) : child->template stealNode<NodeT>(xyz, value, state)"
  },
  {
    "label": "probeNodeAndCache()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } template<ChildT,Index Log2Dim> template<NodeT,AccessorT> NodeT* InternalNode<ChildT,Log2Dim)",
    "insertText": "probeNodeAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (acc .)",
    "insertText": "insert(xyz, child)"
  },
  {
    "label": "probeConstNodeAndCache()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } template<ChildT,Index Log2Dim> template<NodeT,AccessorT> const NodeT* InternalNode<ChildT,Log2Dim)",
    "insertText": "probeConstNodeAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(leaf != nullptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ChildT* child = nullptr ;)",
    "insertText": "if(mChildMask.isOff(n))"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (child = new)",
    "insertText": "ChildT(xyz, mNodes[n].getValue(), mValueMask.isOn(n))"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (} else { child = reinterpret_cast<)",
    "insertText": "ChildT(leaf)"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (} this ->)",
    "insertText": "setChildNode(n, child)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(ChildT::LEVEL>0)"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ n ] .)",
    "insertText": "setChild(child)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (} } child ->)",
    "insertText": "addLeaf(leaf)"
  },
  {
    "label": "addLeafAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<AccessorT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "addLeafAndCache(LeafNodeType* leaf, AccessorT& acc)"
  },
  {
    "label": "addLeafAndCache()",
    "kind": "Method",
    "detail": "Function (} } child ->)",
    "insertText": "addLeafAndCache(leaf, acc)"
  },
  {
    "label": "addChild()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> bool InternalNode<ChildT,Log2Dim)",
    "insertText": "addChild(ChildT* child)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(child)"
  },
  {
    "label": "resetChildNode()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "resetChildNode(n, child)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(n < NUM_VALUES)"
  },
  {
    "label": "makeChildNodeEmpty()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "makeChildNodeEmpty(n, value)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "addTile(level, xyz, value, state)"
  },
  {
    "label": "addTileAndCache()",
    "kind": "Method",
    "detail": "Function (} } } } template<ChildT,Index Log2Dim> template<AccessorT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "addTileAndCache(Index level, const Coord& xyz, const ValueType& value, bool state, AccessorT& acc)"
  },
  {
    "label": "addTileAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "addTileAndCache(level, xyz, value, state, acc)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (} return child ->)",
    "insertText": "touchLeaf(xyz)"
  },
  {
    "label": "touchLeafAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<AccessorT> ChildT::LeafNodeType* InternalNode<ChildT,Log2Dim)",
    "insertText": "touchLeafAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setChildNode(n, new ChildNodeType(xyz, mNodes[n].getValue(), mValueMask.isOn(n)))"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} acc .)",
    "insertText": "insert(xyz, mNodes[n].getChild())"
  },
  {
    "label": "isConstant()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> bool InternalNode<ChildT,Log2Dim)",
    "insertText": "isConstant(ValueType& firstValue, bool& state, const ValueType& tolerance)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (firstValue = mNodes [ 0 ] .)",
    "insertText": "getValue()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (minValue = v ; } else)",
    "insertText": "if(v > maxValue)"
  },
  {
    "label": "isOff()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN const bool anyActiveTiles = ! mValueMask .)",
    "insertText": "isOff()"
  },
  {
    "label": "isValueOnAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<AccessorT> bool InternalNode<ChildT,Log2Dim)",
    "insertText": "isValueOnAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "getValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<AccessorT> const ChildT::ValueType& InternalNode<ChildT,Log2Dim)",
    "insertText": "getValueAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "getValueLevelAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<AccessorT> Index InternalNode<ChildT,Log2Dim)",
    "insertText": "getValueLevelAndCache(const Coord& xyz, AccessorT& acc)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (} return mNodes [ n ] .)",
    "insertText": "getChild()->probeValue(xyz, value)"
  },
  {
    "label": "probeValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<AccessorT> bool InternalNode<ChildT,Log2Dim)",
    "insertText": "probeValueAndCache(const Coord& xyz, ValueType& value, AccessorT& acc)"
  },
  {
    "label": "isChildMaskOn()",
    "kind": "Method",
    "detail": "Function (bool hasChild = this ->)",
    "insertText": "isChildMaskOn(n)"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (hasChild = true ; this ->)",
    "insertText": "setChildNode(n, new ChildNodeType(xyz, mNodes[n].getValue(), true))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(hasChild) mNodes[n].getChild()->setValueOff(xyz)"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (hasChild = true ; this ->)",
    "insertText": "setChildNode(n, new ChildNodeType(xyz, mNodes[n].getValue(), false))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(hasChild) mNodes[n].getChild()->setValueOn(xyz)"
  },
  {
    "label": "isValueMaskOn()",
    "kind": "Method",
    "detail": "Function (const bool active = this ->)",
    "insertText": "isValueMaskOn(n)"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (hasChild = true ; this ->)",
    "insertText": "setChildNode(n, new ChildNodeType(xyz, mNodes[n].getValue(), active))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(hasChild) mNodes[n].getChild()->setValueOff(xyz, value)"
  },
  {
    "label": "setValueOffAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<AccessorT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "setValueOffAndCache(const Coord& xyz, const ValueType& value, AccessorT& acc)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(hasChild)"
  },
  {
    "label": "setValueOffAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "setValueOffAndCache(xyz, value, acc)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(hasChild) mNodes[n].getChild()->setValueOn(xyz, value)"
  },
  {
    "label": "setValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<AccessorT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "setValueAndCache(const Coord& xyz, const ValueType& value, AccessorT& acc)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ n ] .)",
    "insertText": "getChild()->setValueAndCache(xyz, value, acc)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(hasChild) mNodes[n].getChild()->setValueOnly(xyz, value)"
  },
  {
    "label": "setValueOnlyAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<AccessorT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "setValueOnlyAndCache(const Coord& xyz, const ValueType& value, AccessorT& acc)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ n ] .)",
    "insertText": "getChild()->setValueOnlyAndCache(xyz, value, acc)"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (hasChild = true ; this ->)",
    "insertText": "setChildNode(n, new ChildNodeType(xyz, mNodes[n].getValue(), !on))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(hasChild) mNodes[n].getChild()->setActiveState(xyz, on)"
  },
  {
    "label": "setActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<AccessorT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "setActiveStateAndCache(const Coord& xyz, bool on, AccessorT& acc)"
  },
  {
    "label": "setActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "setActiveStateAndCache(xyz, on, acc)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (mValueMask = ! mChildMask ;)",
    "insertText": "for(ChildOnIter iter = this->beginChildOn(); iter; ++iter)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (mNodes [ iter .)",
    "insertText": "pos()].getChild()->setValuesOn()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool createChild = ! active ;)",
    "insertText": "if(!createChild)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (ValueType modifiedVal = tileVal ;)",
    "insertText": "op(modifiedVal)"
  },
  {
    "label": "isExactlyEqual()",
    "kind": "Method",
    "detail": "Function (createChild = !)",
    "insertText": "isExactlyEqual(tileVal, modifiedVal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(createChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(hasChild) mNodes[n].getChild()->modifyValue(xyz, op)"
  },
  {
    "label": "modifyValueAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<ModifyOp,AccessorT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "modifyValueAndCache(const Coord& xyz, const ModifyOp& op, AccessorT& acc)"
  },
  {
    "label": "modifyValueAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "modifyValueAndCache(xyz, op, acc)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (bool modifiedState = ! tileState ; ValueType modifiedVal = tileVal ;)",
    "insertText": "op(modifiedVal, modifiedState)"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (hasChild = true ; this ->)",
    "insertText": "setChildNode(n, new ChildNodeType(xyz, tileVal, tileState))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(hasChild) mNodes[n].getChild()->modifyValueAndActiveState(xyz, op)"
  },
  {
    "label": "modifyValueAndActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<ModifyOp,AccessorT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "modifyValueAndActiveStateAndCache(const Coord& xyz, const ModifyOp& op, AccessorT& acc)"
  },
  {
    "label": "modifyValueAndActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "modifyValueAndActiveStateAndCache(xyz, op, acc)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} } template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "clip(const CoordBBox& clipBBox, const ValueType& background)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "fill(nodeBBox, background, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(clipBBox.isInside(nodeBBox))"
  },
  {
    "label": "offsetToGlobalCoord()",
    "kind": "Method",
    "detail": "Function (const Coord xyz = this ->)",
    "insertText": "offsetToGlobalCoord(pos)"
  },
  {
    "label": "tileBBox()",
    "kind": "Method",
    "detail": "Function (CoordBBox)",
    "insertText": "tileBBox(xyz, xyz.offsetBy(ChildT::DIM - 1))"
  },
  {
    "label": "makeChildNodeEmpty()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "makeChildNodeEmpty(pos, background)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOff(pos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!clipBBox.isInside(tileBBox))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ pos ] .)",
    "insertText": "getChild()->clip(clipBBox, background)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (} else { tileBBox .)",
    "insertText": "intersect(clipBBox)"
  },
  {
    "label": "isValueMaskOn()",
    "kind": "Method",
    "detail": "Function (const bool on = this ->)",
    "insertText": "isValueMaskOn(pos)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (mNodes [ pos ] .)",
    "insertText": "setValue(background)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "fill(tileBBox, val, on)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} } else { } } } template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "fill(const CoordBBox& bbox, const ValueType& value, bool active)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (clippedBBox .)",
    "insertText": "intersect(bbox)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Coord xyz,tileMin,tileMax ;)",
    "insertText": "for(int x = clippedBBox.min().x(); x <= clippedBBox.max().x(); x = tileMax.x() + 1)"
  },
  {
    "label": "setX()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setX(x)"
  },
  {
    "label": "setY()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setY(y)"
  },
  {
    "label": "setZ()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setZ(z)"
  },
  {
    "label": "offsetToGlobalCoord()",
    "kind": "Method",
    "detail": "Function (tileMin = this ->)",
    "insertText": "offsetToGlobalCoord(n)"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (tileMax = tileMin .)",
    "insertText": "offsetBy(ChildT::DIM - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ChildT* child = nullptr ;)",
    "insertText": "if(this->isChildMaskOff(n))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (child = new ChildT { xyz,mNodes [ n ] .)",
    "insertText": "getValue(), this->isValueMaskOn(n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(child)"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (const Coord tmp =)",
    "insertText": "minComponent(clippedBBox.max(), tileMax)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "fill(CoordBBox(xyz, tmp), value, active)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(n, active)"
  },
  {
    "label": "denseFill()",
    "kind": "Method",
    "detail": "Function (} } } } } template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "denseFill(const CoordBBox& bbox, const ValueType& value, bool active)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ChildT* child = nullptr ;)",
    "insertText": "if(this->isChildMaskOn(n))"
  },
  {
    "label": "denseFill()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "denseFill(CoordBBox{xyz, clippedBBox.max()}, value, active)"
  },
  {
    "label": "xStride()",
    "kind": "Method",
    "detail": "Function (using DenseValueType = DenseT::ValueType ; const size_t xStride = dense .)",
    "insertText": "xStride(), yStride = dense.yStride(), zStride = dense.zStride()"
  },
  {
    "label": "bbox()",
    "kind": "Method",
    "detail": "Function (const Coord& min = dense .)",
    "insertText": "bbox().min()"
  },
  {
    "label": "offsetToGlobalCoord()",
    "kind": "Method",
    "detail": "Function (max = this ->)",
    "insertText": "offsetToGlobalCoord(n).offsetBy(ChildT::DIM-1)"
  },
  {
    "label": "sub()",
    "kind": "Method",
    "detail": "Function (CoordBBox)",
    "insertText": "sub(xyz, Coord::minComponent(bbox.max(), max))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ n ] .)",
    "insertText": "getChild()->copyToDense(sub, dense)"
  },
  {
    "label": "translate()",
    "kind": "Method",
    "detail": "Function (sub .)",
    "insertText": "translate(-min)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (DenseValueType* a0 = dense .)",
    "insertText": "data() + zStride*sub.min()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (DenseValueType* a1 = a0 + x* xStride ;)",
    "insertText": "for(Int32 y=sub.min()[1], ey=sub.max()[1]+1; y<ey; ++y)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (DenseValueType* a2 = a1 + y* yStride ;)",
    "insertText": "for(Int32 z = sub.min()[2], ez = sub.max()[2]+1; z < ez; ++z, a2 += zStride)"
  },
  {
    "label": "DenseValueType()",
    "kind": "Method",
    "detail": "Function (* a2 =)",
    "insertText": "DenseValueType(value)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (} } } } } } } } template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "writeTopology(std::ostream& os, bool toHalf)"
  },
  {
    "label": "save()",
    "kind": "Method",
    "detail": "Function (mChildMask .)",
    "insertText": "save(os)"
  },
  {
    "label": "valuePtr()",
    "kind": "Method",
    "detail": "Function ({ std::unique_ptr<ValueType [ ]>)",
    "insertText": "valuePtr(new ValueType[NUM_VALUES])"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (ValueType* values = valuePtr .)",
    "insertText": "get()"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (values [)",
    "insertText": "i(mChildMask.isOff(i) ? mNodes[i].getValue() : zero)"
  },
  {
    "label": "writeCompressedValues()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "writeCompressedValues(os, values, NUM_VALUES, mValueMask, mChildMask, toHalf)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (iter ->)",
    "insertText": "writeTopology(os, toHalf)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (} } template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "readTopology(std::istream& is, bool fromHalf)"
  },
  {
    "label": "background()",
    "kind": "Method",
    "detail": "Function (const ValueType)",
    "insertText": "background(!io::getGridBackgroundValuePtr(is) ? zeroVal<ValueType>() : *static_cast<const ValueType*>(io::getGridBackgroundValuePtr(is)))"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (mChildMask .)",
    "insertText": "load(is)"
  },
  {
    "label": "ChildNodeType()",
    "kind": "Method",
    "detail": "Function (ChildNodeType* child = new)",
    "insertText": "ChildNodeType(PartialCreate(), offsetToGlobalCoord(i), background)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "readTopology(is)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} else { ValueType value ; is .)",
    "insertText": "read(reinterpret_cast<char*>(&value), sizeof(ValueType))"
  },
  {
    "label": "oldVersion()",
    "kind": "Method",
    "detail": "Function (} } } else { const bool)",
    "insertText": "oldVersion(io::getFormatVersion(is) < OPENVDB_FILE_VERSION_NODE_MASK_COMPRESSION)"
  },
  {
    "label": "numValues()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "numValues(oldVersion ? mChildMask.countOff() : NUM_VALUES)"
  },
  {
    "label": "valuePtr()",
    "kind": "Method",
    "detail": "Function ({ std::unique_ptr<ValueType [ ]>)",
    "insertText": "valuePtr(new ValueType[numValues])"
  },
  {
    "label": "readCompressedValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readCompressedValues(is, values, numValues, mValueMask, fromHalf)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index n = 0 ;)",
    "insertText": "for(ValueAllIter iter = this->beginValueAll(); iter; ++iter)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (mNodes [ iter .)",
    "insertText": "pos()].setValue(values[n++])"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(n == numValues)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (mNodes [ iter .)",
    "insertText": "pos()].setValue(values[iter.pos()])"
  },
  {
    "label": "ChildNodeType()",
    "kind": "Method",
    "detail": "Function (ChildNodeType* child = new)",
    "insertText": "ChildNodeType(PartialCreate(), iter.getCoord(), background)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (mNodes [ iter .)",
    "insertText": "pos()].setChild(child)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "readTopology(is, fromHalf)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (const Index n = NUM_VALUES - 1 ;)",
    "insertText": "return(this->isChildMaskOn(n) ? mNodes[n].getChild()->getLastValue() : mNodes[n].getValue())"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ i ] .)",
    "insertText": "getChild()->negate()"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} else { mNodes [ i ] .)",
    "insertText": "setValue(math::negative(mNodes[i].getValue()))"
  },
  {
    "label": "VoxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (} } } template<ChildT,Index Log2Dim> struct InternalNode<ChildT,Log2Dim>::VoxelizeActiveTiles {)",
    "insertText": "VoxelizeActiveTiles(InternalNode &node) : mNode(&node)"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (node . mChildMask | = node . mValueMask ; node . mValueMask .)",
    "insertText": "setOff()"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNode -> mNodes [ i ] .)",
    "insertText": "getChild()->voxelizeActiveTiles(true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(mNode->mValueMask.isOn(i))"
  },
  {
    "label": "offsetToGlobalCoord()",
    "kind": "Method",
    "detail": "Function (const Coord& ijk = mNode ->)",
    "insertText": "offsetToGlobalCoord(i)"
  },
  {
    "label": "ChildNodeType()",
    "kind": "Method",
    "detail": "Function (ChildNodeType* child = new)",
    "insertText": "ChildNodeType(ijk, mNode->mNodes[i].getValue(), true)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "voxelizeActiveTiles(true)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (} } } InternalNode* mNode ; } ; template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "voxelizeActiveTiles(bool threaded)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (VoxelizeActiveTiles)",
    "insertText": "tmp(*this)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(ValueOnIter iter = this->beginValueOn(); iter; ++iter)"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setChildNode(iter.pos(), new ChildNodeType(iter.getCoord(), iter.getValue(), true))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(ChildOnIter iter = this->beginChildOn(); iter; ++iter) iter->voxelizeActiveTiles(false)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "switch(Policy)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ n ] .)",
    "insertText": "getChild()->template merge<MERGE_ACTIVE_STATES>(*iter, background, otherBackground)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(mValueMask.isOff(n))"
  },
  {
    "label": "resetBackground()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "resetBackground(otherBackground, background)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(ValueOnCIter iter = other.cbeginValueOn(); iter; ++iter)"
  },
  {
    "label": "makeChildNodeEmpty()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "makeChildNodeEmpty(n, iter.getValue())"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "setOn(n)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } break ; } case MERGE_NODES : {)",
    "insertText": "for(ChildOnIter iter = other.beginChildOn(); iter; ++iter)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ n ] .)",
    "insertText": "getChild()->template merge<Policy>(*iter, background, otherBackground)"
  },
  {
    "label": "Policy()",
    "kind": "Method",
    "detail": "Function (child -> template merge<)",
    "insertText": "Policy(mNodes[n].getValue(), true)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ n ] .)",
    "insertText": "getChild()->template merge<Policy>(iter.getValue(), true)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (mNodes [ n ] .)",
    "insertText": "setValue(iter.getValue())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(Policy != MERGE_ACTIVE_STATES_AND_NODES)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ n ] .)",
    "insertText": "getChild()->template merge<Policy>(tileValue, true)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} else { iter .)",
    "insertText": "setValue(tileValue)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } template<ChildT,Index Log2Dim> template<OtherInternalNode> struct InternalNode<ChildT,Log2Dim>::TopologyUnion { using W = NodeMaskType::Word ; struct A { void)",
    "insertText": "operator()(W &tV, const W& sV, const W& tC)"
  },
  {
    "label": "tV()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tV(tV | sV)"
  },
  {
    "label": "TopologyUnion()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "TopologyUnion(const OtherInternalNode* source, InternalNode* target, const bool preserveTiles) : s(source), t(target), mPreserveTiles(preserveTiles)"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (A op ; t -> mValueMask .)",
    "insertText": "foreach(s->mValueMask, t->mChildMask, op)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((t->mValueMask & t->mChildMask).isOff())"
  },
  {
    "label": "other()",
    "kind": "Method",
    "detail": "Function (const OtherInternalNode::ChildNodeType&)",
    "insertText": "other(s->mNodes[i].getChild())"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (t -> mNodes [ i ] .)",
    "insertText": "getChild()->topologyUnion(other, mPreserveTiles)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(!mPreserveTiles || t->mValueMask.isOff(i))"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (ChildT* child = new)",
    "insertText": "ChildT(other, t->mNodes[i].getValue(), TopologyCopy())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else)",
    "insertText": "if(s->mValueMask.isOn(i) && t->mChildMask.isOn(i))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (t -> mNodes [ i ] .)",
    "insertText": "getChild()->setValuesOn()"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (} } } const OtherInternalNode* s ; InternalNode* t ; const bool mPreserveTiles ; } ; template<ChildT,Index Log2Dim> template<OtherChildT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "topologyUnion(const InternalNode<OtherChildT, Log2Dim>& other, const bool preserveTiles)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (TopologyUnion<InternalNode<OtherChildT,Log2Dim>>)",
    "insertText": "tmp(&other, this, preserveTiles)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<OtherInternalNode> struct InternalNode<ChildT,Log2Dim>::TopologyIntersection { using W = NodeMaskType::Word ; struct A { void)",
    "insertText": "operator()(W &tC, const W& sC, const W& sV, const W& tV)"
  },
  {
    "label": "tC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tC(tC & (sC | sV)) | (tV & sC)"
  },
  {
    "label": "TopologyIntersection()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "TopologyIntersection(const OtherInternalNode* source, InternalNode* target, const ValueType& background) : s(source), t(target), b(background)"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (A op ; t -> mChildMask .)",
    "insertText": "foreach(s->mChildMask, s->mValueMask, t->mValueMask, op)"
  },
  {
    "label": "topologyIntersection()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "topologyIntersection(*(s->mNodes[i].getChild()), b)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(s->mValueMask.isOff(i))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(t->mValueMask.isOn(i) && s->mChildMask.isOn(i))"
  },
  {
    "label": "setChild()",
    "kind": "Method",
    "detail": "Function (t -> mNodes [ i ] .)",
    "insertText": "setChild(new ChildT(*(s->mNodes[i].getChild()), t->mNodes[i].getValue(), TopologyCopy()))"
  },
  {
    "label": "topologyIntersection()",
    "kind": "Method",
    "detail": "Function (} } } const OtherInternalNode* s ; InternalNode* t ; const ValueType& b ; } ; template<ChildT,Index Log2Dim> template<OtherChildT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "topologyIntersection(const InternalNode<OtherChildT, Log2Dim>& other, const ValueType& background)"
  },
  {
    "label": "tC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tC(tC & (sC | ~sV)) | (tV & sC)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; struct B { void)",
    "insertText": "operator()(W &tV, const W& sC, const W& sV, const W& tC)"
  },
  {
    "label": "tV()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tV((tC & sV) | (sC | sV))"
  },
  {
    "label": "TopologyDifference()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "TopologyDifference(const OtherInternalNode* source, InternalNode* target, const ValueType& background) : s(source), t(target), b(background)"
  },
  {
    "label": "oldChildMask()",
    "kind": "Method",
    "detail": "Function (const NodeMaskType)",
    "insertText": "oldChildMask(t->mChildMask)"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (A op1 ; t -> mChildMask .)",
    "insertText": "foreach(s->mChildMask, s->mValueMask, t->mValueMask, op1)"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (B op2 ; t -> mValueMask .)",
    "insertText": "foreach(t->mChildMask, s->mValueMask, oldChildMask, op2)"
  },
  {
    "label": "topologyDifference()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "topologyDifference(*(s->mNodes[i].getChild()), b)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(s->mValueMask.isOn(i))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(t->mValueMask.isOn(i))"
  },
  {
    "label": "ChildT()",
    "kind": "Method",
    "detail": "Function (ChildT* child = new)",
    "insertText": "ChildT(other.origin(), t->mNodes[i].getValue(), true)"
  },
  {
    "label": "topologyDifference()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "topologyDifference(other, b)"
  },
  {
    "label": "topologyDifference()",
    "kind": "Method",
    "detail": "Function (} } } } const OtherInternalNode* s ; InternalNode* t ; const ValueType& b ; } ; template<ChildT,Index Log2Dim> template<OtherChildT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "topologyDifference(const InternalNode<OtherChildT, Log2Dim>& other, const ValueType& background)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<CombineOp> void InternalNode<ChildT,Log2Dim)",
    "insertText": "combine(InternalNode& other, CombineOp& op)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (CombineArgs<ValueType> args ;)",
    "insertText": "for(Index i = 0; i < NUM_VALUES; ++i)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(mNodes[i].getValue()) .setAIsActive(isValueMaskOn(i)) .setBRef(other.mNodes[i].getValue()) .setBIsActive(other.isValueMaskOn(i)))"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (mNodes [ i ] .)",
    "insertText": "setValue(args.result())"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (mValueMask .)",
    "insertText": "set(i, args.resultIsActive())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->isChildMaskOn(i) && other.isChildMaskOff(i))"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "combine(other.mNodes[i].getValue(), other.isValueMaskOn(i), op)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(this->isChildMaskOff(i) && other.isChildMaskOn(i))"
  },
  {
    "label": "swappedOp()",
    "kind": "Method",
    "detail": "Function (SwappedCombineOp<ValueType,CombineOp>)",
    "insertText": "swappedOp(op)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "combine(mNodes[i].getValue(), isValueMaskOn(i), swappedOp)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (other . mNodes [ i ] .)",
    "insertText": "setValue(zero)"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setChildNode(i, child)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (} } else { ChildNodeType* child = mNodes [ i ] .)",
    "insertText": "getChild(), *otherChild = other.mNodes[i].getChild()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(otherChild)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "combine(*otherChild, op)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (} } } } template<ChildT,Index Log2Dim> template<CombineOp> void InternalNode<ChildT,Log2Dim)",
    "insertText": "combine(const ValueType& value, bool valueIsActive, CombineOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(mNodes[i].getValue()) .setAIsActive(isValueMaskOn(i)) .setBRef(value) .setBIsActive(valueIsActive))"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} } } template<ChildT,Index Log2Dim> template<CombineOp,OtherNodeType> void InternalNode<ChildT,Log2Dim)",
    "insertText": "combine2(const InternalNode& other0, const OtherNodeType& other1, CombineOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(other0.mNodes[i].getValue()) .setAIsActive(other0.isValueMaskOn(i)) .setBRef(other1.mNodes[i].getValue()) .setBIsActive(other1.isValueMaskOn(i)))"
  },
  {
    "label": "makeChildNodeEmpty()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "makeChildNodeEmpty(i, args.result())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(this->isChildMaskOff(i))"
  },
  {
    "label": "isChildMaskOn()",
    "kind": "Method",
    "detail": "Function (const Coord& childOrigin = other0 .)",
    "insertText": "isChildMaskOn(i) ? other0.mNodes[i].getChild()->origin() : other1.mNodes[i].getChild()->origin()"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setChildNode(i, new ChildNodeType(childOrigin, mNodes[i].getValue()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(other0.isChildMaskOff(i))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ i ] .)",
    "insertText": "getChild()->combine2(other0.mNodes[i].getValue(), *other1.mNodes[i].getChild(), other0.isValueMaskOn(i), op)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(other1.isChildMaskOff(i))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ i ] .)",
    "insertText": "getChild()->combine2(*other0.mNodes[i].getChild(), other1.mNodes[i].getValue(), other1.isValueMaskOn(i), op)"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (} else { mNodes [ i ] .)",
    "insertText": "getChild()->combine2(*other0.mNodes[i].getChild(), *other1.mNodes[i].getChild(), op)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} } } } template<ChildT,Index Log2Dim> template<CombineOp,OtherNodeType> void InternalNode<ChildT,Log2Dim)",
    "insertText": "combine2(const ValueType& value, const OtherNodeType& other, bool valueIsActive, CombineOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(value) .setAIsActive(valueIsActive) .setBRef(other.mNodes[i].getValue()) .setBIsActive(other.isValueMaskOn(i)))"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setChildNode(i, new ChildNodeType(*otherChild))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (} mNodes [ i ] .)",
    "insertText": "getChild()->combine2(value, *otherChild, valueIsActive, op)"
  },
  {
    "label": "combine2()",
    "kind": "Method",
    "detail": "Function (} } } template<ChildT,Index Log2Dim> template<CombineOp,OtherValueType> void InternalNode<ChildT,Log2Dim)",
    "insertText": "combine2(const InternalNode& other, const OtherValueType& value, bool valueIsActive, CombineOp& op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(args.setARef(other.mNodes[i].getValue()) .setAIsActive(other.isValueMaskOn(i)) .setBRef(value) .setBIsActive(valueIsActive))"
  },
  {
    "label": "setChildNode()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setChildNode(i, new ChildNodeType(otherChild->origin(), mNodes[i].getValue()))"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (} mNodes [ i ] .)",
    "insertText": "getChild()->combine2(*otherChild, value, valueIsActive, op)"
  },
  {
    "label": "visitActiveBBox()",
    "kind": "Method",
    "detail": "Function (} } } template<ChildT,Index Log2Dim> template<BBoxOp> void InternalNode<ChildT,Log2Dim)",
    "insertText": "visitActiveBBox(BBoxOp& op)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (op . template)",
    "insertText": "operator()<LEVEL>(CoordBBox::createCube(i.getCoord(), ChildNodeType::DIM))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(op.template descent<LEVEL>())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (op . template)",
    "insertText": "operator()<LEVEL>(i->getNodeBoundingBox())"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (} } } template<ChildT,Index Log2Dim> template<VisitorOp> void InternalNode<ChildT,Log2Dim)",
    "insertText": "visit(VisitorOp& op)"
  },
  {
    "label": "doVisit()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<NodeT,VisitorOp,ChildAllIterT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "doVisit(NodeT& self, VisitorOp& op)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (NodeT::ValueType val ;)",
    "insertText": "for(ChildAllIterT iter = self.beginChildAll(); iter; ++iter)"
  },
  {
    "label": "visit()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "visit(op)"
  },
  {
    "label": "visit2Node()",
    "kind": "Method",
    "detail": "Function (} } } template<ChildT,Index Log2Dim> template<OtherNodeType,VisitorOp> void InternalNode<ChildT,Log2Dim)",
    "insertText": "visit2Node(OtherNodeType& other, VisitorOp& op)"
  },
  {
    "label": "doVisit2Node()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<NodeT,OtherNodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "doVisit2Node(NodeT& self, OtherNodeT& other, VisitorOp& op)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (const size_t skipBranch = static_cast<)",
    "insertText": "size_t(op(iter, otherIter))"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (ChildAllIterT::ChildNodeType*)",
    "insertText": "child(skipBranch & 1U) ? nullptr : iter.probeChild(val)"
  },
  {
    "label": "otherChild()",
    "kind": "Method",
    "detail": "Function (OtherChildAllIterT::ChildNodeType*)",
    "insertText": "otherChild(skipBranch & 2U) ? nullptr : otherIter.probeChild(otherVal)"
  },
  {
    "label": "visit2Node()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "visit2Node(*otherChild, op)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(child != nullptr)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (child ->)",
    "insertText": "visit2(otherIter, op)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(otherChild != nullptr)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (otherChild ->)",
    "insertText": "visit2(iter, op, true)"
  },
  {
    "label": "visit2()",
    "kind": "Method",
    "detail": "Function (} } } template<ChildT,Index Log2Dim> template<OtherChildAllIterType,VisitorOp> void InternalNode<ChildT,Log2Dim)",
    "insertText": "visit2(OtherChildAllIterType& otherIter, VisitorOp& op, bool otherIsLHS)"
  },
  {
    "label": "doVisit2()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> template<NodeT,VisitorOp,ChildAllIterT,OtherChildAllIterT> void InternalNode<ChildT,Log2Dim)",
    "insertText": "doVisit2(NodeT& self, OtherChildAllIterT& otherIter, VisitorOp& op, bool otherIsLHS)"
  },
  {
    "label": "skipBitMask()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "skipBitMask(otherIsLHS ? 2U : 1U)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (const size_t skipBranch = static_cast<)",
    "insertText": "size_t(otherIsLHS ? op(otherIter, iter) : op(iter, otherIter))"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (ChildAllIterT::ChildNodeType*)",
    "insertText": "child(skipBranch & skipBitMask) ? nullptr : iter.probeChild(val)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (} } template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "writeBuffers(std::ostream& os, bool toHalf)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (iter ->)",
    "insertText": "writeBuffers(os, toHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} } template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "readBuffers(std::istream& is, bool fromHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (iter ->)",
    "insertText": "readBuffers(is, fromHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} } template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "readBuffers(std::istream& is, const CoordBBox& clipBBox, bool fromHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (iter ->)",
    "insertText": "readBuffers(is, clipBBox, fromHalf)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (background =* static_cast<const)",
    "insertText": "ValueType(bgPtr)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} this ->)",
    "insertText": "clip(clipBBox, background)"
  },
  {
    "label": "getNodeLog2Dims()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "getNodeLog2Dims(std::vector<Index>& dims)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (dims .)",
    "insertText": "push_back(Log2Dim)"
  },
  {
    "label": "getNodeLog2Dims()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getNodeLog2Dims(dims)"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> void InternalNode<ChildT,Log2Dim)",
    "insertText": "offsetToLocalCoord(Index n, Coord &xyz)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(n<(1<<3*Log2Dim))"
  },
  {
    "label": "setX()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setX(n >> 2*Log2Dim)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "n((1<<2*Log2Dim)-1)"
  },
  {
    "label": "setY()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setY(n >> Log2Dim)"
  },
  {
    "label": "setZ()",
    "kind": "Method",
    "detail": "Function (xyz .)",
    "insertText": "setZ(n & ((1<<Log2Dim)-1))"
  },
  {
    "label": "coordToOffset()",
    "kind": "Method",
    "detail": "Function (} template<ChildT,Index Log2Dim> Index InternalNode<ChildT,Log2Dim)",
    "insertText": "coordToOffset(const Coord& xyz)"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (Coord local ; this ->)",
    "insertText": "offsetToLocalCoord(n, local)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using T = ArrayT::value_type ;)",
    "insertText": "static_assert(std::is_pointer<T>::value, \"argument to getNodes() must be a pointer array\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(std::is_same<T, ArrayChildT*>::value)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (array .)",
    "insertText": "push_back(reinterpret_cast<T>(mNodes[iter.pos()].getChild()))"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (} else { iter ->)",
    "insertText": "getNodes(array)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(std::is_same<T, const ChildT*>::value)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using T = ArrayT::value_type ;)",
    "insertText": "static_assert(std::is_pointer<T>::value, \"argument to stealNodes() must be a pointer array\")"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (array .)",
    "insertText": "push_back(reinterpret_cast<T>(mNodes[n].getChild()))"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (} else { iter ->)",
    "insertText": "stealNodes(array, value, state)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(std::is_same<T, ArrayChildT*>::value) mChildMask.setOff()"
  },
  {
    "label": "getChild()",
    "kind": "Method",
    "detail": "Function (mNodes [ i ] .)",
    "insertText": "getChild()->resetBackground(oldBackground, newBackground)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->isValueMaskOff(i))"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (mNodes [ i ] .)",
    "insertText": "setValue(newBackground)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(math::isApproxEqual(mNodes[i].getValue(), math::negative(oldBackground)))"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (mNodes [ i ] .)",
    "insertText": "setValue(math::negative(newBackground))"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (} else { mChildMask .)",
    "insertText": "setOn(i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mChildMask.isOff(i))"
  },
  {
    "label": "unsetChildNode()",
    "kind": "Method",
    "detail": "Function (delete this ->)",
    "insertText": "unsetChildNode(n, value)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(this->isChildMaskOn(n))"
  }
]