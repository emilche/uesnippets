[
  {
    "label": "FLightMap2D",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLightMap2D"
  },
  {
    "label": "UInstancedStaticMeshComponent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UInstancedStaticMeshComponent"
  },
  {
    "label": "UMapBuildDataRegistry",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UMapBuildDataRegistry"
  },
  {
    "label": "UPrimitiveComponent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPrimitiveComponent"
  },
  {
    "label": "FQuantizedLightmapData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQuantizedLightmapData"
  },
  {
    "label": "UVirtualTexture",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UVirtualTexture"
  },
  {
    "label": "FShadowMapData2D",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FShadowMapData2D"
  },
  {
    "label": "FFourDistanceFieldSamples",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFourDistanceFieldSamples"
  },
  {
    "label": "FLightMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLightMap"
  },
  {
    "label": "FLightSample",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLightSample"
  },
  {
    "label": "FLightMapData2D",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLightMapData2D"
  },
  {
    "label": "FLightMapPendingTexture",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLightMapPendingTexture"
  },
  {
    "label": "FLegacyQuantizedDirectionalLightSample",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLegacyQuantizedDirectionalLightSample"
  },
  {
    "label": "FLegacyQuantizedSimpleLightSample",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLegacyQuantizedSimpleLightSample"
  },
  {
    "label": "FQuantizedDirectionalLightSample",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQuantizedDirectionalLightSample"
  },
  {
    "label": "FQuantizedSimpleLightSample",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQuantizedSimpleLightSample"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "QuantizedLightSampleType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "QuantizedLightSampleType"
  },
  {
    "label": "TQuantizedLightSampleBulkData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TQuantizedLightSampleBulkData"
  },
  {
    "label": "FLegacyLightMap1D",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLegacyLightMap1D"
  },
  {
    "label": "FSelectedLightmapSample",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSelectedLightmapSample"
  },
  {
    "label": "FDebugShadowRay",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDebugShadowRay"
  },
  {
    "label": "FLightMapCoefficients",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLightMapCoefficients"
  },
  {
    "label": "TMappingData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMappingData"
  },
  {
    "label": "FLightmapResourceCluster",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLightmapResourceCluster"
  },
  {
    "label": "IsTexelDebuggingEnabled()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Containers / ChunkedArray . h \" # include \" Misc / Guid . h \" # include \" Engine / EngineTypes . h \" # include \" RenderDeferredCleanup . h \" # include \" Serialization / BulkData . h \" # include \" SceneManagement . h \" # include \" Engine / LightMapTexture2D . h \" class FLightMap2D ; class UInstancedStaticMeshComponent ; class UMapBuildDataRegistry ; class UPrimitiveComponent ; struct FQuantizedLightmapData ; class UVirtualTexture ; class FShadowMapData2D ; class FFourDistanceFieldSamples ; bool GUseBilinearLightmaps ; bool GAllowLightmapPadding ; ELightingBuildQuality GLightingBuildQuality ; # if WITH_EDITOR FLightmassDebugOptions GLightmassDebugOptions ; # endif FColor GTexelSelectionColor ; bool)",
    "insertText": "IsTexelDebuggingEnabled()"
  },
  {
    "label": "FLightMap()",
    "kind": "Method",
    "detail": "Function (class FLightMap : private FDeferredCleanupInterface { public : enum { LMT_None = 0,LMT_1D = 1,LMT_2D = 2,} ; TArray<FGuid> LightGuids ;)",
    "insertText": "FLightMap()"
  },
  {
    "label": "ContainsLight()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ContainsLight(const FGuid& LightGuid)"
  },
  {
    "label": "AddReferencedObjects()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddReferencedObjects(FReferenceCollector& Collector)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "GetInteraction()",
    "kind": "Method",
    "detail": "Function (FLightMapInteraction)",
    "insertText": "GetInteraction(ERHIFeatureLevel::Type InFeatureLevel)"
  },
  {
    "label": "GetShadowInteraction()",
    "kind": "Method",
    "detail": "Function (FShadowMapInteraction)",
    "insertText": "GetShadowInteraction(ERHIFeatureLevel::Type InFeatureLevel)"
  },
  {
    "label": "GetLightMap2D()",
    "kind": "Method",
    "detail": "Function (} FLightMap2D*)",
    "insertText": "GetLightMap2D()"
  },
  {
    "label": "Release()",
    "kind": "Method",
    "detail": "Function (NumRefs + + ; } void)",
    "insertText": "Release()"
  },
  {
    "label": "Cleanup()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Cleanup()"
  },
  {
    "label": "AllowsHighQualityLightmaps()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "AllowsHighQualityLightmaps()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (private : int32 NumRefs ; } ; FArchive&)",
    "insertText": "operator(FArchive& Ar, FLightMap*& R)"
  },
  {
    "label": "FLightSample()",
    "kind": "Method",
    "detail": "Function (struct FLightSample { float Coefficients [ NUM_STORED_LIGHTMAP_COEF ] [ 3 ] ; bool bIsMapped ;)",
    "insertText": "FLightSample(): bIsMapped(false)"
  },
  {
    "label": "Memzero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memzero(Coefficients,sizeof(Coefficients))"
  },
  {
    "label": "FLightMapData2D()",
    "kind": "Method",
    "detail": "Function (} } ; class FLightMapData2D { public : TArray<FGuid> LightGuids ;)",
    "insertText": "FLightMapData2D(uint32 InSizeX,uint32 InSizeY): Data(InSizeX * InSizeY), SizeX(InSizeX), SizeY(InSizeY)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const FLightSample&)",
    "insertText": "operator()(uint32 X,uint32 Y)"
  },
  {
    "label": "GetSizeX()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetSizeX()"
  },
  {
    "label": "FLightMap2D()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FLightMap2D(bool InAllowHighQualityLightMaps)"
  },
  {
    "label": "GetTexture()",
    "kind": "Method",
    "detail": "Function (const UTexture2D*)",
    "insertText": "GetTexture(uint32 BasisIndex)"
  },
  {
    "label": "GetReferencedTextures()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetReferencedTextures(TArray<UTexture2D*>& OutTextures)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutTextures .)",
    "insertText": "Add(Textures[BasisIndex])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(GetSkyOcclusionTexture())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutTextures .)",
    "insertText": "Add(GetSkyOcclusionTexture())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(GetAOMaterialMaskTexture())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutTextures .)",
    "insertText": "Add(GetAOMaterialMaskTexture())"
  },
  {
    "label": "GetSkyOcclusionTexture()",
    "kind": "Method",
    "detail": "Function (} } UTexture2D*)",
    "insertText": "GetSkyOcclusionTexture()"
  },
  {
    "label": "GetAOMaterialMaskTexture()",
    "kind": "Method",
    "detail": "Function (UTexture2D*)",
    "insertText": "GetAOMaterialMaskTexture()"
  },
  {
    "label": "GetVirtualTexture()",
    "kind": "Method",
    "detail": "Function (ULightMapVirtualTexture2D*)",
    "insertText": "GetVirtualTexture(uint32 BasisIndex)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValid(uint32 BasisIndex)"
  },
  {
    "label": "GetCoordinateScale()",
    "kind": "Method",
    "detail": "Function (const FVector2D&)",
    "insertText": "GetCoordinateScale()"
  },
  {
    "label": "AllocateInstancedLightMap()",
    "kind": "Method",
    "detail": "Function (TRefCountPtr<FLightMap2D>)",
    "insertText": "AllocateInstancedLightMap(UObject* LightMapOuter, UInstancedStaticMeshComponent* Component, TArray<TUniquePtr<FQuantizedLightmapData>> SourceQuantizedData, TArray<TMap<ULightComponent*, TUniquePtr<FShadowMapData2D>>>&& InstancedShadowMapData, UMapBuildDataRegistry* Registry, FGuid MapBuildDataId, const FBoxSphereBounds& Bounds, ELightMapPaddingType InPaddingType, ELightMapFlags LightmapFlags)"
  },
  {
    "label": "EncodeTextures()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EncodeTextures(const FStaticLightingBuildContext* LightingContext, bool bLightingSuccessful, bool bMultithreadedEncode = false)"
  },
  {
    "label": "EncodeShadowTexture()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR int32)",
    "insertText": "EncodeShadowTexture(const FStaticLightingBuildContext* LightingContext, struct FLightMapPendingTexture& PendingTexture, TArray<TArray<FFourDistanceFieldSamples>>& MipData)"
  },
  {
    "label": "SetStatusUpdate()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "SetStatusUpdate(bool bInEnable)"
  },
  {
    "label": "GetStatusUpdate()",
    "kind": "Method",
    "detail": "Function (bUpdateStatus = bInEnable ; } bool)",
    "insertText": "GetStatusUpdate()"
  },
  {
    "label": "FLegacyLightMap1D()",
    "kind": "Method",
    "detail": "Function (bool bUpdateStatus ; } ; struct FLegacyQuantizedDirectionalLightSample { FColor Coefficients [ 2 ] ; } ; struct FLegacyQuantizedSimpleLightSample { FColor Coefficients [ 1 ] ; } ; struct FQuantizedDirectionalLightSample { FColor Coefficients [ NUM_HQ_LIGHTMAP_COEF ] ; } ; struct FQuantizedSimpleLightSample { FColor Coefficients [ NUM_LQ_LIGHTMAP_COEF ] ; } ; template<> struct TIsPODType<FQuantizedDirectionalLightSample> { enum { Value = true } ; } ; template<> struct TIsPODType<FQuantizedSimpleLightSample> { enum { Value = true } ; } ; template<class QuantizedLightSampleType> struct TQuantizedLightSampleBulkData : public TBulkData<QuantizedLightSampleType> { typedef QuantizedLightSampleType SampleType ; } ; class FLegacyLightMap1D : public FLightMap { public :)",
    "insertText": "FLegacyLightMap1D()"
  },
  {
    "label": "FSelectedLightmapSample()",
    "kind": "Method",
    "detail": "Function (} } ; struct FSelectedLightmapSample { UPrimitiveComponent* Component ; int32 NodeIndex ; FLightMapRef Lightmap ; FVector Position ; int32 LocalX ; int32 LocalY ; int32 MappingSizeX ; int32 MappingSizeY ;)",
    "insertText": "FSelectedLightmapSample() : Component(NULL), NodeIndex(INDEX_NONE), Lightmap(NULL), Position(FVector::ZeroVector), LocalX(-1), LocalY(-1), MappingSizeX(-1), MappingSizeY(-1)"
  },
  {
    "label": "FSelectedLightmapSample()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSelectedLightmapSample(UPrimitiveComponent* InComponent, int32 InNodeIndex, FLightMapRef& InLightmap, FVector InPosition, int32 InLocalX, int32 InLocalY, int32 InMappingSizeX, int32 InMappingSizeY) : Component(InComponent), NodeIndex(InNodeIndex), Lightmap(InLightmap), Position(InPosition), LocalX(InLocalX), LocalY(InLocalY), MappingSizeX(InMappingSizeX), MappingSizeY(InMappingSizeY)"
  },
  {
    "label": "FDebugShadowRay()",
    "kind": "Method",
    "detail": "Function (} } ; class FDebugShadowRay { public : FVector Start ; FVector End ; int32 bHit ;)",
    "insertText": "FDebugShadowRay(const FVector& InStart, const FVector& InEnd, bool bInHit) : Start(InStart), End(InEnd), bHit(bInHit)"
  },
  {
    "label": "FQuantizedLightmapData()",
    "kind": "Method",
    "detail": "Function (} } ; struct FLightMapCoefficients { uint8 Coverage ; uint8 Coefficients [ NUM_STORED_LIGHTMAP_COEF ] [ 4 ] ; uint8 SkyOcclusion [ 4 ] ; uint8 AOMaterialMask ; } ; struct FQuantizedLightmapData { uint32 SizeX ; uint32 SizeY ; TArray<FLightMapCoefficients> Data ; float Scale [ NUM_STORED_LIGHTMAP_COEF ] [ 4 ] ; float Add [ NUM_STORED_LIGHTMAP_COEF ] [ 4 ] ; TArray<FGuid> LightGuids ; bool bHasSkyShadowing ;)",
    "insertText": "FQuantizedLightmapData() : bHasSkyShadowing(false)"
  },
  {
    "label": "HasNonZeroData()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasNonZeroData()"
  },
  {
    "label": "IsTexelMapped()",
    "kind": "Method",
    "detail": "Function (} ; bool)",
    "insertText": "IsTexelMapped(const TArray<FLightMapCoefficients>& MappingData, int32 X, int32 Y, int32 Pitch)"
  },
  {
    "label": "bIsMapped()",
    "kind": "Method",
    "detail": "Function (const FLightMapCoefficients& Sample = MappingData [ Y* Pitch + X ] ; bool)",
    "insertText": "bIsMapped(Sample.Coverage > 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 StartX = 0 ; int32 StartY = 0 ; int32 EndX = SizeX ; int32 EndY = SizeY ; CroppedRect . Min . X = EndX ; CroppedRect . Min . Y = EndY ; CroppedRect . Max . X = StartX - 1 ; CroppedRect . Max . Y = StartY - 1 ;)",
    "insertText": "for(int32 Y = StartY; Y < EndY; ++Y)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bIsMappedRow = false ;)",
    "insertText": "for(int32 X = StartX; X < EndX; ++X)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (CroppedRect . Min . X = FMath::Min<)",
    "insertText": "int32(CroppedRect.Min.X, X)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bIsMappedRow = true ; break ; } })",
    "insertText": "for(int32 X = EndX-1; X > CroppedRect.Max.X; --X)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CroppedRect . Max . X = X ; break ; } })",
    "insertText": "if(bIsMappedRow)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (CroppedRect . Min . Y = FMath::Min<)",
    "insertText": "int32(CroppedRect.Min.Y, Y)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (CroppedRect . Max . Y = FMath::Max<)",
    "insertText": "int32(CroppedRect.Max.Y, Y)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (} } CroppedRect . Max . X = CroppedRect . Max . X + 1 ; CroppedRect . Max . Y = CroppedRect . Max . Y + 1 ; CroppedRect . Min . X = FMath::Min<)",
    "insertText": "int32(CroppedRect.Min.X, CroppedRect.Max.X)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (CroppedRect . Min . Y = FMath::Min<)",
    "insertText": "int32(CroppedRect.Min.Y, CroppedRect.Max.Y)"
  },
  {
    "label": "FLightmapResourceCluster()",
    "kind": "Method",
    "detail": "Function (} class FLightmapResourceCluster : public FRenderResource { public :)",
    "insertText": "FLightmapResourceCluster() : AllocatedVT(nullptr)"
  },
  {
    "label": "FLightmapResourceCluster()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FLightmapResourceCluster()"
  },
  {
    "label": "InitRHI()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitRHI(FRHICommandListBase& RHICmdList)"
  },
  {
    "label": "ReleaseRHI()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseRHI()"
  },
  {
    "label": "SetFeatureLevelAndInitialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFeatureLevelAndInitialize(const FStaticFeatureLevel InFeatureLevel)"
  },
  {
    "label": "TryInitializeUniformBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TryInitializeUniformBuffer()"
  },
  {
    "label": "UpdateUniformBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateUniformBuffer()"
  },
  {
    "label": "GetAllocatedVT()",
    "kind": "Method",
    "detail": "Function (const IAllocatedVirtualTexture*)",
    "insertText": "GetAllocatedVT()"
  },
  {
    "label": "ConditionalCreateAllocatedVT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConditionalCreateAllocatedVT()"
  },
  {
    "label": "ReleaseAllocatedVT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseAllocatedVT()"
  },
  {
    "label": "GetUseVirtualTexturing()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetUseVirtualTexturing()"
  }
]