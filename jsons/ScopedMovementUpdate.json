[
  {
    "label": "FHitResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHitResult"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "FScopedMovementUpdate",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FScopedMovementUpdate"
  },
  {
    "label": "UPrimitiveComponent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPrimitiveComponent"
  },
  {
    "label": "USceneComponent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "USceneComponent"
  },
  {
    "label": "FScopedMovementUpdate()",
    "kind": "Method",
    "detail": "Function (# pragma once # if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_4 # include \" CoreMinimal . h \" # include \" Engine / HitResult . h \" # endif # include \" Engine / OverlapInfo . h \" struct FHitResult ; enum class ETeleportType : uint8 ; namespace EScopedUpdate { enum Type { ImmediateUpdates,DeferredUpdates } ; } class FScopedMovementUpdate : private FNoncopyable { public : typedef TArray<FHitResult,TInlineAllocator<2>> TScopedBlockingHitArray ; typedef TArray<FOverlapInfo,TInlineAllocator<3>> TScopedOverlapInfoArray ;)",
    "insertText": "FScopedMovementUpdate(USceneComponent* Component, EScopedUpdate::Type ScopeBehavior = EScopedUpdate::DeferredUpdates, bool bRequireOverlapsEventFlagToQueueOverlaps = true)"
  },
  {
    "label": "FScopedMovementUpdate()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FScopedMovementUpdate()"
  },
  {
    "label": "GetOuterDeferredScope()",
    "kind": "Method",
    "detail": "Function (enum class EHasMovedTransformOption { eTestTransform,eIgnoreTransform } ; enum class EOverlapState { eUseParent,eUnknown,eIncludesOverlaps,eForceUpdate,} ; const FScopedMovementUpdate*)",
    "insertText": "GetOuterDeferredScope()"
  },
  {
    "label": "IsDeferringUpdates()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsDeferringUpdates()"
  },
  {
    "label": "RevertMove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RevertMove()"
  },
  {
    "label": "HasMoved()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasMoved(EHasMovedTransformOption CheckTransform)"
  },
  {
    "label": "IsTransformDirty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsTransformDirty()"
  },
  {
    "label": "HasPendingOverlaps()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasPendingOverlaps()"
  },
  {
    "label": "RequiresOverlapsEventFlag()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RequiresOverlapsEventFlag()"
  },
  {
    "label": "GetPendingOverlaps()",
    "kind": "Method",
    "detail": "Function (const TScopedOverlapInfoArray&)",
    "insertText": "GetPendingOverlaps()"
  },
  {
    "label": "GetPendingBlockingHits()",
    "kind": "Method",
    "detail": "Function (const TScopedBlockingHitArray&)",
    "insertText": "GetPendingBlockingHits()"
  },
  {
    "label": "AppendOverlapsAfterMove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendOverlapsAfterMove(const TOverlapArrayView& NewPendingOverlaps, bool bSweep, bool bIncludesOverlapsAtEnd)"
  },
  {
    "label": "KeepCurrentOverlapsAfterRotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "KeepCurrentOverlapsAfterRotation(bool bSweep)"
  },
  {
    "label": "AppendBlockingHitAfterMove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendBlockingHitAfterMove(const FHitResult& Hit)"
  },
  {
    "label": "InvalidateCurrentOverlaps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InvalidateCurrentOverlaps()"
  },
  {
    "label": "ForceOverlapUpdate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForceOverlapUpdate()"
  },
  {
    "label": "SetHasTeleported()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetHasTeleported(ETeleportType InTeleportType)"
  },
  {
    "label": "GetOverlapsAtEnd()",
    "kind": "Method",
    "detail": "Function (protected : TOptional<TOverlapArrayView>)",
    "insertText": "GetOverlapsAtEnd(class UPrimitiveComponent& PrimComponent, TInlineOverlapInfoArray& OutEndOverlaps, bool bTransformChanged)"
  },
  {
    "label": "SetWorldLocationAndRotation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SetWorldLocationAndRotation(FVector NewLocation, const FQuat& NewQuat, bool bNoPhysics, ETeleportType Teleport)"
  },
  {
    "label": "OnInnerScopeComplete()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "OnInnerScopeComplete(const FScopedMovementUpdate& InnerScope)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void* operator)",
    "insertText": "new(size_t)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (void operator)",
    "insertText": "delete(void *)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (void operator)",
    "insertText": "delete(void*)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (BlockingHits .)",
    "insertText": "Add(Hit)"
  },
  {
    "label": "TeleportType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TeleportType((InTeleportType > TeleportType) ? InTeleportType : TeleportType)"
  }
]