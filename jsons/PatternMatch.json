[
  {
    "label": "OneUse_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OneUse_match"
  },
  {
    "label": "class_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "class_match"
  },
  {
    "label": "match_combine_or",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "match_combine_or"
  },
  {
    "label": "match_combine_and",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "match_combine_and"
  },
  {
    "label": "match_zero",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "match_zero"
  },
  {
    "label": "match_neg_zero",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "match_neg_zero"
  },
  {
    "label": "apint_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "apint_match"
  },
  {
    "label": "constantint_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "constantint_match"
  },
  {
    "label": "cst_pred_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "cst_pred_ty"
  },
  {
    "label": "api_pred_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "api_pred_ty"
  },
  {
    "label": "is_one",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_one"
  },
  {
    "label": "is_all_ones",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_all_ones"
  },
  {
    "label": "is_sign_bit",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_sign_bit"
  },
  {
    "label": "is_power2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_power2"
  },
  {
    "label": "is_maxsignedvalue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_maxsignedvalue"
  },
  {
    "label": "bind_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "bind_ty"
  },
  {
    "label": "specificval_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "specificval_ty"
  },
  {
    "label": "specific_fpval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "specific_fpval"
  },
  {
    "label": "bind_const_intval_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "bind_const_intval_ty"
  },
  {
    "label": "specific_intval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "specific_intval"
  },
  {
    "label": "AnyBinaryOp_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AnyBinaryOp_match"
  },
  {
    "label": "BinaryOp_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BinaryOp_match"
  },
  {
    "label": "OverflowingBinaryOp_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OverflowingBinaryOp_match"
  },
  {
    "label": "BinOp2_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BinOp2_match"
  },
  {
    "label": "Exact_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Exact_match"
  },
  {
    "label": "CmpClass_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CmpClass_match"
  },
  {
    "label": "SelectClass_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SelectClass_match"
  },
  {
    "label": "CastClass_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CastClass_match"
  },
  {
    "label": "not_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "not_match"
  },
  {
    "label": "neg_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "neg_match"
  },
  {
    "label": "fneg_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "fneg_match"
  },
  {
    "label": "br_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "br_match"
  },
  {
    "label": "brc_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "brc_match"
  },
  {
    "label": "MaxMin_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaxMin_match"
  },
  {
    "label": "smax_pred_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "smax_pred_ty"
  },
  {
    "label": "smin_pred_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "smin_pred_ty"
  },
  {
    "label": "umax_pred_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "umax_pred_ty"
  },
  {
    "label": "umin_pred_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "umin_pred_ty"
  },
  {
    "label": "ofmax_pred_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ofmax_pred_ty"
  },
  {
    "label": "ofmin_pred_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ofmin_pred_ty"
  },
  {
    "label": "ufmax_pred_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ufmax_pred_ty"
  },
  {
    "label": "ufmin_pred_ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ufmin_pred_ty"
  },
  {
    "label": "UAddWithOverflow_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UAddWithOverflow_match"
  },
  {
    "label": "Argument_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Argument_match"
  },
  {
    "label": "IntrinsicID_match",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IntrinsicID_match"
  },
  {
    "label": "m_Intrinsic_Ty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "m_Intrinsic_Ty"
  },
  {
    "label": "match()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_IR_PATTERNMATCH_H # define LLVM_IR_PATTERNMATCH_H # include \" llvm / IR / CallSite . h \" # include \" llvm / IR / Constants . h \" # include \" llvm / IR / Instructions . h \" # include \" llvm / IR / Intrinsics . h \" # include \" llvm / IR / Operator . h \" namespace llvm { namespace PatternMatch { template<Val,Pattern> bool)",
    "insertText": "match(Val *V, const Pattern &P)"
  },
  {
    "label": "OneUse_match()",
    "kind": "Method",
    "detail": "Function (} template<SubPattern_t> struct OneUse_match { SubPattern_t SubPattern ;)",
    "insertText": "OneUse_match(const SubPattern_t &SP) : SubPattern(SP)"
  },
  {
    "label": "match()",
    "kind": "Method",
    "detail": "Function (} template<OpTy> bool)",
    "insertText": "match(OpTy *V)"
  },
  {
    "label": "m_OneUse()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> OneUse_match<T>)",
    "insertText": "m_OneUse(const T &SubPattern)"
  },
  {
    "label": "m_Value()",
    "kind": "Method",
    "detail": "Function (} } ; class_match<Value>)",
    "insertText": "m_Value()"
  },
  {
    "label": "m_BinOp()",
    "kind": "Method",
    "detail": "Function (} class_match<BinaryOperator>)",
    "insertText": "m_BinOp()"
  },
  {
    "label": "m_Cmp()",
    "kind": "Method",
    "detail": "Function (} class_match<CmpInst>)",
    "insertText": "m_Cmp()"
  },
  {
    "label": "m_ConstantInt()",
    "kind": "Method",
    "detail": "Function (} class_match<ConstantInt>)",
    "insertText": "m_ConstantInt()"
  },
  {
    "label": "m_Undef()",
    "kind": "Method",
    "detail": "Function (} class_match<UndefValue>)",
    "insertText": "m_Undef()"
  },
  {
    "label": "m_Constant()",
    "kind": "Method",
    "detail": "Function (} class_match<Constant>)",
    "insertText": "m_Constant()"
  },
  {
    "label": "match_combine_or()",
    "kind": "Method",
    "detail": "Function (} template<LTy,RTy> struct match_combine_or { LTy L ; RTy R ;)",
    "insertText": "match_combine_or(const LTy &Left, const RTy &Right) : L(Left), R(Right)"
  },
  {
    "label": "match()",
    "kind": "Method",
    "detail": "Function (} template<ITy> bool)",
    "insertText": "match(ITy *V)"
  },
  {
    "label": "m_CombineAnd()",
    "kind": "Method",
    "detail": "Function (} template<LTy,RTy> match_combine_and<LTy,RTy>)",
    "insertText": "m_CombineAnd(const LTy &L, const RTy &R)"
  },
  {
    "label": "m_AnyZero()",
    "kind": "Method",
    "detail": "Function (} match_combine_or<match_zero,match_neg_zero>)",
    "insertText": "m_AnyZero()"
  },
  {
    "label": "apint_match()",
    "kind": "Method",
    "detail": "Function (} struct apint_match { const APInt*& Res ;)",
    "insertText": "apint_match(const APInt *&R) : Res(R)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (Res =& CI ->)",
    "insertText": "getValue()"
  },
  {
    "label": "m_One()",
    "kind": "Method",
    "detail": "Function (} api_pred_ty<is_one>)",
    "insertText": "m_One(const APInt *&V)"
  },
  {
    "label": "m_AllOnes()",
    "kind": "Method",
    "detail": "Function (} } ; cst_pred_ty<is_all_ones>)",
    "insertText": "m_AllOnes()"
  },
  {
    "label": "m_AllOnes()",
    "kind": "Method",
    "detail": "Function (} api_pred_ty<is_all_ones>)",
    "insertText": "m_AllOnes(const APInt *&V)"
  },
  {
    "label": "m_SignBit()",
    "kind": "Method",
    "detail": "Function (} } ; cst_pred_ty<is_sign_bit>)",
    "insertText": "m_SignBit()"
  },
  {
    "label": "m_SignBit()",
    "kind": "Method",
    "detail": "Function (} api_pred_ty<is_sign_bit>)",
    "insertText": "m_SignBit(const APInt *&V)"
  },
  {
    "label": "m_Power2()",
    "kind": "Method",
    "detail": "Function (} } ; cst_pred_ty<is_power2>)",
    "insertText": "m_Power2()"
  },
  {
    "label": "m_Power2()",
    "kind": "Method",
    "detail": "Function (} api_pred_ty<is_power2>)",
    "insertText": "m_Power2(const APInt *&V)"
  },
  {
    "label": "m_MaxSignedValue()",
    "kind": "Method",
    "detail": "Function (} } ; cst_pred_ty<is_maxsignedvalue>)",
    "insertText": "m_MaxSignedValue()"
  },
  {
    "label": "m_MaxSignedValue()",
    "kind": "Method",
    "detail": "Function (} api_pred_ty<is_maxsignedvalue>)",
    "insertText": "m_MaxSignedValue(const APInt *&V)"
  },
  {
    "label": "m_Value()",
    "kind": "Method",
    "detail": "Function (VR = CV ; return true ; } return false ; } } ; bind_ty<Value>)",
    "insertText": "m_Value(Value *&V)"
  },
  {
    "label": "m_FPOne()",
    "kind": "Method",
    "detail": "Function (} specific_fpval)",
    "insertText": "m_FPOne()"
  },
  {
    "label": "bind_const_intval_ty()",
    "kind": "Method",
    "detail": "Function (} struct bind_const_intval_ty { uint64_t& VR ;)",
    "insertText": "bind_const_intval_ty(uint64_t &V) : VR(V)"
  },
  {
    "label": "getZExtValue()",
    "kind": "Method",
    "detail": "Function (VR = CV ->)",
    "insertText": "getZExtValue()"
  },
  {
    "label": "ConstantInt()",
    "kind": "Method",
    "detail": "Function (const auto* CI = dyn_cast<)",
    "insertText": "ConstantInt(V)"
  },
  {
    "label": "m_ConstantInt()",
    "kind": "Method",
    "detail": "Function (} bind_const_intval_ty)",
    "insertText": "m_ConstantInt(uint64_t &V)"
  },
  {
    "label": "BinaryOp_match()",
    "kind": "Method",
    "detail": "Function (} template<LHS_t,RHS_t,unsigned Opcode> struct BinaryOp_match { LHS_t L ; RHS_t R ;)",
    "insertText": "BinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS)"
  },
  {
    "label": "BinaryOperator()",
    "kind": "Method",
    "detail": "Function (auto* I = cast<)",
    "insertText": "BinaryOperator(V)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(auto *CE = dyn_cast<ConstantExpr>(V)) return CE->getOpcode() == Opcode && L.match(CE->getOperand(0)) && R.match(CE->getOperand(1))"
  },
  {
    "label": "m_FAdd()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::FAdd>)",
    "insertText": "m_FAdd(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_Sub()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::Sub>)",
    "insertText": "m_Sub(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_FSub()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::FSub>)",
    "insertText": "m_FSub(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_Mul()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::Mul>)",
    "insertText": "m_Mul(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_FMul()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::FMul>)",
    "insertText": "m_FMul(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_UDiv()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::UDiv>)",
    "insertText": "m_UDiv(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_SDiv()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::SDiv>)",
    "insertText": "m_SDiv(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_FDiv()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::FDiv>)",
    "insertText": "m_FDiv(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_URem()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::URem>)",
    "insertText": "m_URem(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_SRem()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::SRem>)",
    "insertText": "m_SRem(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_FRem()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::FRem>)",
    "insertText": "m_FRem(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_And()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::And>)",
    "insertText": "m_And(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_Or()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::Or>)",
    "insertText": "m_Or(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_Xor()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::Xor>)",
    "insertText": "m_Xor(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_Shl()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::Shl>)",
    "insertText": "m_Shl(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_LShr()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::LShr>)",
    "insertText": "m_LShr(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_AShr()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinaryOp_match<LHS,RHS,Instruction::AShr>)",
    "insertText": "m_AShr(const LHS &L, const RHS &R)"
  },
  {
    "label": "OverflowingBinaryOp_match()",
    "kind": "Method",
    "detail": "Function (} template<LHS_t,RHS_t,unsigned Opcode,unsigned WrapFlags = 0> struct OverflowingBinaryOp_match { LHS_t L ; RHS_t R ;)",
    "insertText": "OverflowingBinaryOp_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS)"
  },
  {
    "label": "m_NSWAdd()",
    "kind": "Method",
    "detail": "Function (} return false ; } } ; template<LHS,RHS> OverflowingBinaryOp_match<LHS,RHS,Instruction::Add,OverflowingBinaryOperator::NoSignedWrap>)",
    "insertText": "m_NSWAdd(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_NSWSub()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> OverflowingBinaryOp_match<LHS,RHS,Instruction::Sub,OverflowingBinaryOperator::NoSignedWrap>)",
    "insertText": "m_NSWSub(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_NSWMul()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> OverflowingBinaryOp_match<LHS,RHS,Instruction::Mul,OverflowingBinaryOperator::NoSignedWrap>)",
    "insertText": "m_NSWMul(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_NSWShl()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> OverflowingBinaryOp_match<LHS,RHS,Instruction::Shl,OverflowingBinaryOperator::NoSignedWrap>)",
    "insertText": "m_NSWShl(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_NUWAdd()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> OverflowingBinaryOp_match<LHS,RHS,Instruction::Add,OverflowingBinaryOperator::NoUnsignedWrap>)",
    "insertText": "m_NUWAdd(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_NUWSub()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> OverflowingBinaryOp_match<LHS,RHS,Instruction::Sub,OverflowingBinaryOperator::NoUnsignedWrap>)",
    "insertText": "m_NUWSub(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_NUWMul()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> OverflowingBinaryOp_match<LHS,RHS,Instruction::Mul,OverflowingBinaryOperator::NoUnsignedWrap>)",
    "insertText": "m_NUWMul(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_NUWShl()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> OverflowingBinaryOp_match<LHS,RHS,Instruction::Shl,OverflowingBinaryOperator::NoUnsignedWrap>)",
    "insertText": "m_NUWShl(const LHS &L, const RHS &R)"
  },
  {
    "label": "BinOp2_match()",
    "kind": "Method",
    "detail": "Function (} template<LHS_t,RHS_t,unsigned Opc1,unsigned Opc2> struct BinOp2_match { LHS_t L ; RHS_t R ;)",
    "insertText": "BinOp2_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(auto *CE = dyn_cast<ConstantExpr>(V)) return (CE->getOpcode() == Opc1 || CE->getOpcode() == Opc2) && L.match(CE->getOperand(0)) && R.match(CE->getOperand(1))"
  },
  {
    "label": "m_LogicalShift()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinOp2_match<LHS,RHS,Instruction::LShr,Instruction::Shl>)",
    "insertText": "m_LogicalShift(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_IDiv()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> BinOp2_match<LHS,RHS,Instruction::SDiv,Instruction::UDiv>)",
    "insertText": "m_IDiv(const LHS &L, const RHS &R)"
  },
  {
    "label": "Exact_match()",
    "kind": "Method",
    "detail": "Function (} template<SubPattern_t> struct Exact_match { SubPattern_t SubPattern ;)",
    "insertText": "Exact_match(const SubPattern_t &SP) : SubPattern(SP)"
  },
  {
    "label": "getPredicate()",
    "kind": "Method",
    "detail": "Function (Predicate = I ->)",
    "insertText": "getPredicate()"
  },
  {
    "label": "m_ICmp()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> CmpClass_match<LHS,RHS,ICmpInst,ICmpInst::Predicate>)",
    "insertText": "m_ICmp(ICmpInst::Predicate &Pred, const LHS &L, const RHS &R)"
  },
  {
    "label": "m_FCmp()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> CmpClass_match<LHS,RHS,FCmpInst,FCmpInst::Predicate>)",
    "insertText": "m_FCmp(FCmpInst::Predicate &Pred, const LHS &L, const RHS &R)"
  },
  {
    "label": "SelectClass_match()",
    "kind": "Method",
    "detail": "Function (} template<Cond_t,LHS_t,RHS_t> struct SelectClass_match { Cond_t C ; LHS_t L ; RHS_t R ;)",
    "insertText": "SelectClass_match(const Cond_t &Cond, const LHS_t &LHS, const RHS_t &RHS) : C(Cond), L(LHS), R(RHS)"
  },
  {
    "label": "m_SelectCst()",
    "kind": "Method",
    "detail": "Function (} template<int64_t L,int64_t R,Cond> SelectClass_match<Cond,constantint_match<L>,constantint_match<R>>)",
    "insertText": "m_SelectCst(const Cond &C)"
  },
  {
    "label": "CastClass_match()",
    "kind": "Method",
    "detail": "Function (} template<Op_t,unsigned Opcode> struct CastClass_match { Op_t Op ;)",
    "insertText": "CastClass_match(const Op_t &OpMatch) : Op(OpMatch)"
  },
  {
    "label": "m_PtrToInt()",
    "kind": "Method",
    "detail": "Function (} template<OpTy> CastClass_match<OpTy,Instruction::PtrToInt>)",
    "insertText": "m_PtrToInt(const OpTy &Op)"
  },
  {
    "label": "m_Trunc()",
    "kind": "Method",
    "detail": "Function (} template<OpTy> CastClass_match<OpTy,Instruction::Trunc>)",
    "insertText": "m_Trunc(const OpTy &Op)"
  },
  {
    "label": "m_SExt()",
    "kind": "Method",
    "detail": "Function (} template<OpTy> CastClass_match<OpTy,Instruction::SExt>)",
    "insertText": "m_SExt(const OpTy &Op)"
  },
  {
    "label": "m_ZExt()",
    "kind": "Method",
    "detail": "Function (} template<OpTy> CastClass_match<OpTy,Instruction::ZExt>)",
    "insertText": "m_ZExt(const OpTy &Op)"
  },
  {
    "label": "m_UIToFP()",
    "kind": "Method",
    "detail": "Function (} template<OpTy> CastClass_match<OpTy,Instruction::UIToFP>)",
    "insertText": "m_UIToFP(const OpTy &Op)"
  },
  {
    "label": "m_SIToFP()",
    "kind": "Method",
    "detail": "Function (} template<OpTy> CastClass_match<OpTy,Instruction::SIToFP>)",
    "insertText": "m_SIToFP(const OpTy &Op)"
  },
  {
    "label": "not_match()",
    "kind": "Method",
    "detail": "Function (} template<LHS_t> struct not_match { LHS_t L ;)",
    "insertText": "not_match(const LHS_t &LHS) : L(LHS)"
  },
  {
    "label": "m_Not()",
    "kind": "Method",
    "detail": "Function (} } ; template<LHS> not_match<LHS>)",
    "insertText": "m_Not(const LHS &L)"
  },
  {
    "label": "m_Neg()",
    "kind": "Method",
    "detail": "Function (} } ; template<LHS> neg_match<LHS>)",
    "insertText": "m_Neg(const LHS &L)"
  },
  {
    "label": "getSuccessor()",
    "kind": "Method",
    "detail": "Function (Succ = BI ->)",
    "insertText": "getSuccessor(0)"
  },
  {
    "label": "brc_match()",
    "kind": "Method",
    "detail": "Function (} template<Cond_t> struct brc_match { Cond_t Cond ; BasicBlock*& T,*& F ;)",
    "insertText": "brc_match(const Cond_t &C, BasicBlock *&t, BasicBlock *&f) : Cond(C), T(t), F(f)"
  },
  {
    "label": "getSuccessor()",
    "kind": "Method",
    "detail": "Function (F = BI ->)",
    "insertText": "getSuccessor(1)"
  },
  {
    "label": "MaxMin_match()",
    "kind": "Method",
    "detail": "Function (} template<CmpInst_t,LHS_t,RHS_t,Pred_t> struct MaxMin_match { LHS_t L ; RHS_t R ;)",
    "insertText": "MaxMin_match(const LHS_t &LHS, const RHS_t &RHS) : L(LHS), R(RHS)"
  },
  {
    "label": "SelectInst()",
    "kind": "Method",
    "detail": "Function (auto* SI = dyn_cast<)",
    "insertText": "SelectInst(V)"
  },
  {
    "label": "CmpInst_t()",
    "kind": "Method",
    "detail": "Function (auto* Cmp = dyn_cast<)",
    "insertText": "CmpInst_t(SI->getCondition())"
  },
  {
    "label": "getTrueValue()",
    "kind": "Method",
    "detail": "Function (Value* TrueVal = SI ->)",
    "insertText": "getTrueValue()"
  },
  {
    "label": "getFalseValue()",
    "kind": "Method",
    "detail": "Function (Value* FalseVal = SI ->)",
    "insertText": "getFalseValue()"
  },
  {
    "label": "getOperand()",
    "kind": "Method",
    "detail": "Function (Value* LHS = Cmp ->)",
    "insertText": "getOperand(0)"
  },
  {
    "label": "getOperand()",
    "kind": "Method",
    "detail": "Function (Value* RHS = Cmp ->)",
    "insertText": "getOperand(1)"
  },
  {
    "label": "getPredicate()",
    "kind": "Method",
    "detail": "Function (CmpInst_t::Predicate Pred = LHS = = TrueVal ? Cmp ->)",
    "insertText": "getPredicate() : Cmp->getSwappedPredicate()"
  },
  {
    "label": "match()",
    "kind": "Method",
    "detail": "Function (} } ; struct smax_pred_ty { bool)",
    "insertText": "match(ICmpInst::Predicate Pred)"
  },
  {
    "label": "m_SMin()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> MaxMin_match<ICmpInst,LHS,RHS,smin_pred_ty>)",
    "insertText": "m_SMin(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_UMax()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> MaxMin_match<ICmpInst,LHS,RHS,umax_pred_ty>)",
    "insertText": "m_UMax(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_UMin()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> MaxMin_match<ICmpInst,LHS,RHS,umin_pred_ty>)",
    "insertText": "m_UMin(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_OrdFMax()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> MaxMin_match<FCmpInst,LHS,RHS,ofmax_pred_ty>)",
    "insertText": "m_OrdFMax(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_OrdFMin()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> MaxMin_match<FCmpInst,LHS,RHS,ofmin_pred_ty>)",
    "insertText": "m_OrdFMin(const LHS &L, const RHS &R)"
  },
  {
    "label": "m_UnordFMax()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> MaxMin_match<FCmpInst,LHS,RHS,ufmax_pred_ty>)",
    "insertText": "m_UnordFMax(const LHS &L, const RHS &R)"
  },
  {
    "label": "UAddWithOverflow_match()",
    "kind": "Method",
    "detail": "Function (} template<LHS_t,RHS_t,Sum_t> struct UAddWithOverflow_match { LHS_t L ; RHS_t R ; Sum_t S ;)",
    "insertText": "UAddWithOverflow_match(const LHS_t &L, const RHS_t &R, const Sum_t &S) : L(L), R(R), S(S)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Value* ICmpLHS,* ICmpRHS ; ICmpInst::Predicate Pred ;)",
    "insertText": "if(!m_ICmp(Pred, m_Value(ICmpLHS), m_Value(ICmpRHS)).match(V))"
  },
  {
    "label": "m_Add()",
    "kind": "Method",
    "detail": "Function (Value* AddLHS,* AddRHS ; auto AddExpr =)",
    "insertText": "m_Add(m_Value(AddLHS), m_Value(AddRHS))"
  },
  {
    "label": "m_UnordFMin()",
    "kind": "Method",
    "detail": "Function (} template<LHS,RHS> MaxMin_match<FCmpInst,LHS,RHS,ufmin_pred_ty>)",
    "insertText": "m_UnordFMin(const LHS &L, const RHS &R)"
  },
  {
    "label": "Argument_match()",
    "kind": "Method",
    "detail": "Function (} template<Opnd_t> struct Argument_match { unsigned OpI ; Opnd_t Val ;)",
    "insertText": "Argument_match(unsigned OpIdx, const Opnd_t &V) : OpI(OpIdx), Val(V)"
  },
  {
    "label": "CS()",
    "kind": "Method",
    "detail": "Function (CallSite)",
    "insertText": "CS(V)"
  },
  {
    "label": "m_Argument()",
    "kind": "Method",
    "detail": "Function (} } ; template<unsigned OpI,Opnd_t> Argument_match<Opnd_t>)",
    "insertText": "m_Argument(const Opnd_t &Op)"
  },
  {
    "label": "IntrinsicID_match()",
    "kind": "Method",
    "detail": "Function (} struct IntrinsicID_match { unsigned ID ;)",
    "insertText": "IntrinsicID_match(Intrinsic::ID IntrID) : ID(IntrID)"
  },
  {
    "label": "m_Intrinsic()",
    "kind": "Method",
    "detail": "Function (} template<Intrinsic::ID IntrID,T0> m_Intrinsic_Ty<T0>::Ty)",
    "insertText": "m_Intrinsic(const T0 &Op0)"
  },
  {
    "label": "m_Intrinsic()",
    "kind": "Method",
    "detail": "Function (} template<Intrinsic::ID IntrID,T0,T1> m_Intrinsic_Ty<T0,T1>::Ty)",
    "insertText": "m_Intrinsic(const T0 &Op0, const T1 &Op1)"
  },
  {
    "label": "m_Intrinsic()",
    "kind": "Method",
    "detail": "Function (} template<Intrinsic::ID IntrID,T0,T1,T2> m_Intrinsic_Ty<T0,T1,T2>::Ty)",
    "insertText": "m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2)"
  },
  {
    "label": "m_Intrinsic()",
    "kind": "Method",
    "detail": "Function (} template<Intrinsic::ID IntrID,T0,T1,T2,T3> m_Intrinsic_Ty<T0,T1,T2,T3>::Ty)",
    "insertText": "m_Intrinsic(const T0 &Op0, const T1 &Op1, const T2 &Op2, const T3 &Op3)"
  },
  {
    "label": "m_BSwap()",
    "kind": "Method",
    "detail": "Function (} template<Opnd0> m_Intrinsic_Ty<Opnd0>::Ty)",
    "insertText": "m_BSwap(const Opnd0 &Op0)"
  },
  {
    "label": "m_FMin()",
    "kind": "Method",
    "detail": "Function (} template<Opnd0,Opnd1> m_Intrinsic_Ty<Opnd0,Opnd1>::Ty)",
    "insertText": "m_FMin(const Opnd0 &Op0, const Opnd1 &Op1)"
  },
  {
    "label": "m_FMax()",
    "kind": "Method",
    "detail": "Function (} template<Opnd0,Opnd1> m_Intrinsic_Ty<Opnd0,Opnd1>::Ty)",
    "insertText": "m_FMax(const Opnd0 &Op0, const Opnd1 &Op1)"
  }
]