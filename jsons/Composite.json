[
  {
    "label": "CSGOperation",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "CSGOperation"
  },
  {
    "label": "BuildPrimarySegment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BuildPrimarySegment"
  },
  {
    "label": "ProcessInternalNodes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ProcessInternalNodes"
  },
  {
    "label": "ProcessLeafNodes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ProcessLeafNodes"
  },
  {
    "label": "BuildSecondarySegment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BuildSecondarySegment"
  },
  {
    "label": "GridOrTreeConstructor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GridOrTreeConstructor"
  },
  {
    "label": "CopyOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CopyOp"
  },
  {
    "label": "Local",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Local"
  },
  {
    "label": "CompReplaceOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CompReplaceOp"
  },
  {
    "label": "csgUnion()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TOOLS_COMPOSITE_HAS_BEEN_INCLUDED # define OPENVDB_TOOLS_COMPOSITE_HAS_BEEN_INCLUDED # include<openvdb / Platform . h> # include<openvdb / Exceptions . h> # include<openvdb / Types . h> # include<openvdb / Grid . h> # include<openvdb / math / Math . h> # include \" Merge . h \" # include \" ValueTransformer . h \" # include \" Prune . h \" # include \" SignedFloodFill . h \" # include<tbb / blocked_range . h> # include<tbb / parallel_for . h> # include<tbb / parallel_reduce . h> # include<tbb / task_group . h> # include<tbb / task_scheduler_init . h> # include<type_traits> # include<functional> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tools { template<GridOrTreeT> void)",
    "insertText": "csgUnion(GridOrTreeT& a, GridOrTreeT& b, bool prune = true)"
  },
  {
    "label": "csgIntersection()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeT> void)",
    "insertText": "csgIntersection(GridOrTreeT& a, GridOrTreeT& b, bool prune = true)"
  },
  {
    "label": "csgDifference()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeT> void)",
    "insertText": "csgDifference(GridOrTreeT& a, GridOrTreeT& b, bool prune = true)"
  },
  {
    "label": "csgUnionCopy()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeT> GridOrTreeT::Ptr)",
    "insertText": "csgUnionCopy(const GridOrTreeT& a, const GridOrTreeT& b)"
  },
  {
    "label": "csgIntersectionCopy()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeT> GridOrTreeT::Ptr)",
    "insertText": "csgIntersectionCopy(const GridOrTreeT& a, const GridOrTreeT& b)"
  },
  {
    "label": "csgDifferenceCopy()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeT> GridOrTreeT::Ptr)",
    "insertText": "csgDifferenceCopy(const GridOrTreeT& a, const GridOrTreeT& b)"
  },
  {
    "label": "compMax()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeT> void)",
    "insertText": "compMax(GridOrTreeT& a, GridOrTreeT& b)"
  },
  {
    "label": "compMin()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeT> void)",
    "insertText": "compMin(GridOrTreeT& a, GridOrTreeT& b)"
  },
  {
    "label": "compSum()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeT> void)",
    "insertText": "compSum(GridOrTreeT& a, GridOrTreeT& b)"
  },
  {
    "label": "compMul()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeT> void)",
    "insertText": "compMul(GridOrTreeT& a, GridOrTreeT& b)"
  },
  {
    "label": "compDiv()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeT> void)",
    "insertText": "compDiv(GridOrTreeT& a, GridOrTreeT& b)"
  },
  {
    "label": "compReplace()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeT> void)",
    "insertText": "compReplace(GridOrTreeT& a, const GridOrTreeT& b)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (namespace composite { template<T> const std::enable_if<! VecTraits<T>::IsVec,T>::type&)",
    "insertText": "min(const T& a, const T& b)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (} template<T> const std::enable_if<! VecTraits<T>::IsVec,T>::type&)",
    "insertText": "max(const T& a, const T& b)"
  },
  {
    "label": "lengthSqr()",
    "kind": "Method",
    "detail": "Function (const T::ValueType aMag = a .)",
    "insertText": "lengthSqr(), bMag = b.lengthSqr()"
  },
  {
    "label": "divide()",
    "kind": "Method",
    "detail": "Function (} template<T> std::enable_if<! std::is_integral<T>::value,T>::type)",
    "insertText": "divide(const T& a, const T& b)"
  },
  {
    "label": "zero()",
    "kind": "Method",
    "detail": "Function (const T)",
    "insertText": "zero(0)"
  },
  {
    "label": "divide()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "divide(bool a, bool)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()()"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (std::vector<const LeafNodeType*> leafNodes ; { std::vector<const InternalNodeType*> internalNodes ; mLhsTree ->)",
    "insertText": "getNodes(internalNodes)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (ProcessInternalNodes)",
    "insertText": "op(internalNodes, *mRhsTree, *mSegment, leafNodes)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, internalNodes.size()), op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (} ProcessLeafNodes)",
    "insertText": "op(leafNodes, *mRhsTree, *mSegment)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, leafNodes.size()), op)"
  },
  {
    "label": "segment()",
    "kind": "Method",
    "detail": "Function (} TreePtrType&)",
    "insertText": "segment()"
  },
  {
    "label": "ProcessInternalNodes()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ProcessInternalNodes(ProcessInternalNodes& other, tbb::split) : mLhsNodes(other.mLhsNodes) , mRhsTree(other.mRhsTree) , mLocalTree(mRhsTree->background()) , mOutputTree(&mLocalTree) , mLocalLeafNodes() , mOutputLeafNodes(&mLocalLeafNodes)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "join(ProcessInternalNodes& other)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (mOutputTree ->)",
    "insertText": "merge(*other.mOutputTree)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mOutputLeafNodes ->)",
    "insertText": "insert(mOutputLeafNodes->end(), other.mOutputLeafNodes->begin(), other.mOutputLeafNodes->end())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const tbb::blocked_range<size_t>& range)"
  },
  {
    "label": "rhsAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const TreeType>)",
    "insertText": "rhsAcc(*mRhsTree)"
  },
  {
    "label": "outputAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<TreeType>)",
    "insertText": "outputAcc(*mOutputTree)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::vector<const LeafNodeType*> tmpLeafNodes ;)",
    "insertText": "for(size_t n = range.begin(), N = range.end(); n < N; ++n)"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (const InternalNodeType& lhsNode =* mLhsNodes [ n ] ; const Coord& ijk = lhsNode .)",
    "insertText": "origin()"
  },
  {
    "label": "InternalNodeType()",
    "kind": "Method",
    "detail": "Function (const InternalNodeType* rhsNode = rhsAcc . template probeConstNode<)",
    "insertText": "InternalNodeType(ijk)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (lhsNode .)",
    "insertText": "getNodes(*mOutputLeafNodes)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(Operation == CSG_INTERSECTION)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (tmpLeafNodes .)",
    "insertText": "clear()"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (lhsNode .)",
    "insertText": "getNodes(tmpLeafNodes)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (outputAcc .)",
    "insertText": "addLeaf(new LeafNodeType(*tmpLeafNodes[i]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "if(!(rhsAcc.getValue(ijk) < ValueType(0.0)))"
  },
  {
    "label": "ProcessLeafNodes()",
    "kind": "Method",
    "detail": "Function (} } } } } } InternalNodeType const* const* const mLhsNodes ; TreeType const* const mRhsTree ; TreeType mLocalTree ; TreeType* const mOutputTree ; std::vector<const LeafNodeType*> mLocalLeafNodes ; std::vector<const LeafNodeType*>* const mOutputLeafNodes ; } ; struct ProcessLeafNodes {)",
    "insertText": "ProcessLeafNodes(std::vector<const LeafNodeType*>& lhsNodes, const TreeType& rhsTree, TreeType& output) : mLhsNodes(lhsNodes.empty() ? nullptr : &lhsNodes.front()) , mRhsTree(&rhsTree) , mLocalTree(mRhsTree->background()) , mOutputTree(&output)"
  },
  {
    "label": "ProcessLeafNodes()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ProcessLeafNodes(ProcessLeafNodes& other, tbb::split) : mLhsNodes(other.mLhsNodes) , mRhsTree(other.mRhsTree) , mLocalTree(mRhsTree->background()) , mOutputTree(&mLocalTree)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "join(ProcessLeafNodes& rhs)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (mOutputTree ->)",
    "insertText": "merge(*rhs.mOutputTree)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (const LeafNodeType* rhsNodePt = rhsAcc .)",
    "insertText": "probeConstLeaf(ijk)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (LeafNodeType* outputNode = outputAcc .)",
    "insertText": "touchLeaf(ijk)"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (ValueType* outputData = outputNode ->)",
    "insertText": "buffer().data()"
  },
  {
    "label": "getValueMask()",
    "kind": "Method",
    "detail": "Function (NodeMaskType& outputMask = outputNode ->)",
    "insertText": "getValueMask()"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (const bool fromRhs = lhsData [ pos ]<rhsData [ pos ] ; outputData [ pos ] = fromRhs ? rhsData [ pos ] : lhsData [ pos ] ; outputMask .)",
    "insertText": "set(pos, fromRhs ? rhsMask.isOn(pos) : lhsMask.isOn(pos))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(Operation == CSG_DIFFERENCE)"
  },
  {
    "label": "negative()",
    "kind": "Method",
    "detail": "Function (const ValueType rhsVal =)",
    "insertText": "negative(rhsData[pos])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "for(Index pos = 0; pos < LeafNodeType::SIZE; ++pos)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (outputAcc .)",
    "insertText": "addLeaf(new LeafNodeType(lhsNode))"
  },
  {
    "label": "BuildSecondarySegment()",
    "kind": "Method",
    "detail": "Function (} } } } } LeafNodeType const* const* const mLhsNodes ; TreeType const* const mRhsTree ; TreeType mLocalTree ; TreeType* const mOutputTree ; } ; TreePtrType mSegment ; TreeType const* const mLhsTree ; TreeType const* const mRhsTree ; } ; template<TreeType,CSGOperation Operation> struct BuildSecondarySegment { using ValueType = TreeType::ValueType ; using TreePtrType = TreeType::Ptr ; using LeafNodeType = TreeType::LeafNodeType ; using NodeMaskType = LeafNodeType::NodeMaskType ; using RootNodeType = TreeType::RootNodeType ; using NodeChainType = RootNodeType::NodeChainType ; using InternalNodeType = NodeChainType::template Get<1> ;)",
    "insertText": "BuildSecondarySegment(const TreeType& lhs, const TreeType& rhs) : mSegment(new TreeType(lhs.background())) , mLhsTree(&lhs) , mRhsTree(&rhs)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (ProcessInternalNodes)",
    "insertText": "op(internalNodes, *mLhsTree, *mSegment, leafNodes)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (} ProcessLeafNodes)",
    "insertText": "op(leafNodes, *mLhsTree, *mSegment)"
  },
  {
    "label": "ProcessInternalNodes()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ProcessInternalNodes(ProcessInternalNodes& other, tbb::split) : mRhsNodes(other.mRhsNodes) , mLhsTree(other.mLhsTree) , mLocalTree(mLhsTree->background()) , mOutputTree(&mLocalTree) , mLocalLeafNodes() , mOutputLeafNodes(&mLocalLeafNodes)"
  },
  {
    "label": "lhsAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const TreeType>)",
    "insertText": "lhsAcc(*mLhsTree)"
  },
  {
    "label": "LeafNodeType()",
    "kind": "Method",
    "detail": "Function (LeafNodeType* outputNode = new)",
    "insertText": "LeafNodeType(*tmpLeafNodes[i])"
  },
  {
    "label": "negate()",
    "kind": "Method",
    "detail": "Function (outputNode ->)",
    "insertText": "negate()"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (outputAcc .)",
    "insertText": "addLeaf(outputNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "if(!(lhsAcc.getValue(ijk) < ValueType(0.0)))"
  },
  {
    "label": "ProcessLeafNodes()",
    "kind": "Method",
    "detail": "Function (} } } } } } InternalNodeType const* const* const mRhsNodes ; TreeType const* const mLhsTree ; TreeType mLocalTree ; TreeType* const mOutputTree ; std::vector<const LeafNodeType*> mLocalLeafNodes ; std::vector<const LeafNodeType*>* const mOutputLeafNodes ; } ; struct ProcessLeafNodes {)",
    "insertText": "ProcessLeafNodes(std::vector<const LeafNodeType*>& rhsNodes, const TreeType& lhsTree, TreeType& output) : mRhsNodes(rhsNodes.empty() ? nullptr : &rhsNodes.front()) , mLhsTree(&lhsTree) , mLocalTree(mLhsTree->background()) , mOutputTree(&output)"
  },
  {
    "label": "ProcessLeafNodes()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ProcessLeafNodes(ProcessLeafNodes& rhs, tbb::split) : mRhsNodes(rhs.mRhsNodes) , mLhsTree(rhs.mLhsTree) , mLocalTree(mLhsTree->background()) , mOutputTree(&mLocalTree)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (outputAcc .)",
    "insertText": "addLeaf(new LeafNodeType(rhsNode))"
  },
  {
    "label": "LeafNodeType()",
    "kind": "Method",
    "detail": "Function (LeafNodeType* outputNode = new)",
    "insertText": "LeafNodeType(rhsNode)"
  },
  {
    "label": "doCSGCopy()",
    "kind": "Method",
    "detail": "Function (} } } } } LeafNodeType const* const* const mRhsNodes ; TreeType const* const mLhsTree ; TreeType mLocalTree ; TreeType* const mOutputTree ; } ; TreePtrType mSegment ; TreeType const* const mLhsTree ; TreeType const* const mRhsTree ; } ; template<CSGOperation Operation,TreeType> TreeType::Ptr)",
    "insertText": "doCSGCopy(const TreeType& lhs, const TreeType& rhs)"
  },
  {
    "label": "primary()",
    "kind": "Method",
    "detail": "Function (BuildPrimarySegment<TreeType,Operation>)",
    "insertText": "primary(lhs, rhs)"
  },
  {
    "label": "secondary()",
    "kind": "Method",
    "detail": "Function (BuildSecondarySegment<TreeType,Operation>)",
    "insertText": "secondary(lhs, rhs)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (tbb::task_group tasks ; tasks .)",
    "insertText": "run(primary)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (tasks .)",
    "insertText": "run(secondary)"
  },
  {
    "label": "wait()",
    "kind": "Method",
    "detail": "Function (tasks .)",
    "insertText": "wait()"
  },
  {
    "label": "segment()",
    "kind": "Method",
    "detail": "Function (primary .)",
    "insertText": "segment()->merge(*secondary.segment())"
  },
  {
    "label": "signedFloodFill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "signedFloodFill(*primary.segment(), true, 1, 1)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} template<TreeType> struct GridOrTreeConstructor { using TreeTypePtr = TreeType::Ptr ; TreeTypePtr)",
    "insertText": "construct(const TreeType&, TreeTypePtr& tree)"
  },
  {
    "label": "maskGrid()",
    "kind": "Method",
    "detail": "Function (GridTypePtr)",
    "insertText": "maskGrid(GridType::create(tree))"
  },
  {
    "label": "setTransform()",
    "kind": "Method",
    "detail": "Function (maskGrid ->)",
    "insertText": "setTransform(grid.transform().copy())"
  },
  {
    "label": "insertMeta()",
    "kind": "Method",
    "detail": "Function (maskGrid ->)",
    "insertText": "insertMeta(grid)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (using LeafT = TreeT::LeafNodeType ; tree::ValueAccessor<TreeT>)",
    "insertText": "acc(dstTree)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::vector<LeafT*> srcLeafNodes ; srcLeafNodes .)",
    "insertText": "reserve(srcTree.leafCount())"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (srcTree .)",
    "insertText": "stealNodes(srcLeafNodes)"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (LeafT* dstLeaf = acc .)",
    "insertText": "probeLeaf(srcLeaf->origin())"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (overlapping .)",
    "insertText": "emplace_back(dstLeaf, srcLeaf)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (} else { acc .)",
    "insertText": "addLeaf(srcLeaf)"
  },
  {
    "label": "doCompActiveLeafVoxels()",
    "kind": "Method",
    "detail": "Function (} } } template<TreeT,OpT> std::enable_if<! std::is_same<TreeT::ValueType,bool>::value&& ! std::is_same<TreeT::BuildType,ValueMask>::value&& std::is_same<TreeT::LeafNodeType::Buffer::ValueType,TreeT::LeafNodeType::Buffer::StorageType>::value>::type)",
    "insertText": "doCompActiveLeafVoxels(TreeT &srcTree, TreeT &dstTree, OpT op)"
  },
  {
    "label": "transferLeafNodes()",
    "kind": "Method",
    "detail": "Function (using LeafT = TreeT::LeafNodeType ; LeafPairList<LeafT> overlapping ;)",
    "insertText": "transferLeafNodes(srcTree, dstTree, overlapping)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (using RangeT = tbb::blocked_range<size_t> ;)",
    "insertText": "parallel_for(RangeT(0, overlapping.size()), [op, &overlapping](const RangeT& r) { for (auto i = r.begin(); i != r.end(); ++i) { LeafT *dstLeaf = overlapping[i].first, *srcLeaf = overlapping[i].second; dstLeaf->getValueMask() |= srcLeaf->getValueMask(); auto *ptr = dstLeaf->buffer().data(); for (auto v = srcLeaf->cbeginValueOn(); v; ++v) op(ptr[v.pos()], *v); delete srcLeaf; } })"
  },
  {
    "label": "doCompActiveLeafVoxels()",
    "kind": "Method",
    "detail": "Function (} template<TreeT,OpT> std::enable_if<std::is_same<TreeT::BuildType,ValueMask>::value&& std::is_same<TreeT::ValueType,bool>::value>::type)",
    "insertText": "doCompActiveLeafVoxels(TreeT &srcTree, TreeT &dstTree, OpT)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (using RangeT = tbb::blocked_range<size_t> ;)",
    "insertText": "parallel_for(RangeT(0, overlapping.size()), [&overlapping](const RangeT& r) { for (auto i = r.begin(); i != r.end(); ++i) { overlapping[i].first->getValueMask() |= overlapping[i].second->getValueMask(); delete overlapping[i].second; } })"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (using RangeT = tbb::blocked_range<size_t> ; using WordT = LeafT::Buffer::WordType ;)",
    "insertText": "parallel_for(RangeT(0, overlapping.size()), [op, &overlapping](const RangeT& r) { for (auto i = r.begin(); i != r.end(); ++i) { LeafT *dstLeaf = overlapping[i].first, *srcLeaf = overlapping[i].second; WordT *w1 = dstLeaf->buffer().data(); const WordT *w2 = srcLeaf->buffer().data(); const WordT *w3 = &(srcLeaf->getValueMask().template getWord<WordT>(0)); for (Index32 n = LeafT::Buffer::WORD_COUNT; n--; ++w1) { WordT tmp = *w1, state = *w3++; op (tmp, *w2++); *w1 = (state & tmp) | (~state & *w1); } dstLeaf->getValueMask() |= srcLeaf->getValueMask(); delete srcLeaf; } })"
  },
  {
    "label": "CopyOp()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> struct CopyOp { using ValueT = TreeT::ValueType ;)",
    "insertText": "CopyOp()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator()(ValueT& dst, const ValueT& src)"
  },
  {
    "label": "validateLevelSet()",
    "kind": "Method",
    "detail": "Function (dst = src ; } } ; template<TreeT> void)",
    "insertText": "validateLevelSet(const TreeT& tree, const std::string& gridName = std::string(\"\"))"
  },
  {
    "label": "ValueT()",
    "kind": "Method",
    "detail": "Function (using ValueT = TreeT::ValueType ; const ValueT zero = zeroVal<)",
    "insertText": "ValueT()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (std::stringstream ss ; ss<<\" expected grid \" ;)",
    "insertText": "if(!gridName.empty())"
  },
  {
    "label": "background()",
    "kind": "Method",
    "detail": "Function (ss<<\" outside value> 0,got \"<<tree .)",
    "insertText": "background()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ValueError, ss.str())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!(-tree.background() < zero))"
  },
  {
    "label": "compMax()",
    "kind": "Method",
    "detail": "Function (} } } template<GridOrTreeT> void)",
    "insertText": "compMax(GridOrTreeT& aTree, GridOrTreeT& bTree)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (using Adapter = TreeAdapter<GridOrTreeT> ; using TreeT = Adapter::TreeType ; using ValueT = TreeT::ValueType ; struct Local { void)",
    "insertText": "op(CombineArgs<ValueT>& args)"
  },
  {
    "label": "setResult()",
    "kind": "Method",
    "detail": "Function (args .)",
    "insertText": "setResult(composite::max(args.a(), args.b()))"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "tree(aTree).combineExtended(Adapter::tree(bTree), Local::op, false)"
  },
  {
    "label": "compMin()",
    "kind": "Method",
    "detail": "Function (} template<GridOrTreeT> void)",
    "insertText": "compMin(GridOrTreeT& aTree, GridOrTreeT& bTree)"
  },
  {
    "label": "setResult()",
    "kind": "Method",
    "detail": "Function (args .)",
    "insertText": "setResult(composite::min(args.a(), args.b()))"
  },
  {
    "label": "compSum()",
    "kind": "Method",
    "detail": "Function (} template<GridOrTreeT> void)",
    "insertText": "compSum(GridOrTreeT& aTree, GridOrTreeT& bTree)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (using Adapter = TreeAdapter<GridOrTreeT> ; using TreeT = Adapter::TreeType ; struct Local { void)",
    "insertText": "op(CombineArgs<typename TreeT::ValueType>& args)"
  },
  {
    "label": "setResult()",
    "kind": "Method",
    "detail": "Function (args .)",
    "insertText": "setResult(args.a() + args.b())"
  },
  {
    "label": "compMul()",
    "kind": "Method",
    "detail": "Function (} template<GridOrTreeT> void)",
    "insertText": "compMul(GridOrTreeT& aTree, GridOrTreeT& bTree)"
  },
  {
    "label": "setResult()",
    "kind": "Method",
    "detail": "Function (args .)",
    "insertText": "setResult(args.a() * args.b())"
  },
  {
    "label": "compDiv()",
    "kind": "Method",
    "detail": "Function (} template<GridOrTreeT> void)",
    "insertText": "compDiv(GridOrTreeT& aTree, GridOrTreeT& bTree)"
  },
  {
    "label": "setResult()",
    "kind": "Method",
    "detail": "Function (args .)",
    "insertText": "setResult(composite::divide(args.a(), args.b()))"
  },
  {
    "label": "CompReplaceOp()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> struct CompReplaceOp { TreeT* const aTree ;)",
    "insertText": "CompReplaceOp(TreeT& _aTree): aTree(&_aTree)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const typename TreeT::ValueOnCIter& iter)"
  },
  {
    "label": "getBoundingBox()",
    "kind": "Method",
    "detail": "Function (CoordBBox bbox ; iter .)",
    "insertText": "getBoundingBox(bbox)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (aTree ->)",
    "insertText": "fill(bbox, *iter)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const typename TreeT::LeafCIter& leafIter)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<TreeT>)",
    "insertText": "acc(*aTree)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (acc .)",
    "insertText": "setValue(iter.getCoord(), *iter)"
  },
  {
    "label": "compReplace()",
    "kind": "Method",
    "detail": "Function (} } } ; template<GridOrTreeT> void)",
    "insertText": "compReplace(GridOrTreeT& aTree, const GridOrTreeT& bTree)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (using Adapter = TreeAdapter<GridOrTreeT> ; using TreeT = Adapter::TreeType ; using ValueOnCIterT = TreeT::ValueOnCIter ;)",
    "insertText": "tree(aTree).topologyUnion(Adapter::tree(bTree))"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (CompReplaceOp<TreeT>)",
    "insertText": "op(Adapter::tree(aTree))"
  },
  {
    "label": "cbeginValueOn()",
    "kind": "Method",
    "detail": "Function (ValueOnCIterT iter = bTree .)",
    "insertText": "cbeginValueOn()"
  },
  {
    "label": "setMaxDepth()",
    "kind": "Method",
    "detail": "Function (iter .)",
    "insertText": "setMaxDepth(iter.getLeafDepth() - 1)"
  },
  {
    "label": "csgUnion()",
    "kind": "Method",
    "detail": "Function (} template<GridOrTreeT> void)",
    "insertText": "csgUnion(GridOrTreeT& a, GridOrTreeT& b, bool prune)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (using Adapter = TreeAdapter<GridOrTreeT> ; using TreeT = Adapter::TreeType ; TreeT& aTree =)",
    "insertText": "tree(a), &bTree = Adapter::tree(b)"
  },
  {
    "label": "validateLevelSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "validateLevelSet(aTree, \"A\")"
  },
  {
    "label": "validateLevelSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "validateLevelSet(bTree, \"B\")"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (CsgUnionOp<TreeT>)",
    "insertText": "op(bTree, Steal())"
  },
  {
    "label": "nodeManager()",
    "kind": "Method",
    "detail": "Function (tree::DynamicNodeManager<TreeT>)",
    "insertText": "nodeManager(aTree)"
  },
  {
    "label": "foreachTopDown()",
    "kind": "Method",
    "detail": "Function (nodeManager .)",
    "insertText": "foreachTopDown(op)"
  },
  {
    "label": "csgIntersection()",
    "kind": "Method",
    "detail": "Function (} template<GridOrTreeT> void)",
    "insertText": "csgIntersection(GridOrTreeT& a, GridOrTreeT& b, bool prune)"
  },
  {
    "label": "csgDifference()",
    "kind": "Method",
    "detail": "Function (} template<GridOrTreeT> void)",
    "insertText": "csgDifference(GridOrTreeT& a, GridOrTreeT& b, bool prune)"
  },
  {
    "label": "CSG_UNION()",
    "kind": "Method",
    "detail": "Function (using Adapter = TreeAdapter<GridOrTreeT> ; using TreePtrT = Adapter::TreeType::Ptr ; TreePtrT output = composite::doCSGCopy<)",
    "insertText": "CSG_UNION(Adapter::tree(a), Adapter::tree(b))"
  },
  {
    "label": "CSG_INTERSECTION()",
    "kind": "Method",
    "detail": "Function (using Adapter = TreeAdapter<GridOrTreeT> ; using TreePtrT = Adapter::TreeType::Ptr ; TreePtrT output = composite::doCSGCopy<)",
    "insertText": "CSG_INTERSECTION(Adapter::tree(a), Adapter::tree(b))"
  },
  {
    "label": "CSG_DIFFERENCE()",
    "kind": "Method",
    "detail": "Function (using Adapter = TreeAdapter<GridOrTreeT> ; using TreePtrT = Adapter::TreeType::Ptr ; TreePtrT output = composite::doCSGCopy<)",
    "insertText": "CSG_DIFFERENCE(Adapter::tree(a), Adapter::tree(b))"
  },
  {
    "label": "compActiveLeafVoxels()",
    "kind": "Method",
    "detail": "Function (} template<TreeT,OpT = composite::CopyOp<TreeT>> void)",
    "insertText": "compActiveLeafVoxels(TreeT &srcTree, TreeT &dstTree, OpT op = composite::CopyOp<TreeT>())"
  },
  {
    "label": "OpT()",
    "kind": "Method",
    "detail": "Function (composite::doCompActiveLeafVoxels<TreeT,)",
    "insertText": "OpT(srcTree, dstTree, op)"
  }
]