[
  {
    "label": "FNamedValueArrayUtils",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNamedValueArrayUtils"
  },
  {
    "label": "TNamedValueArray",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TNamedValueArray"
  },
  {
    "label": "FElementSortPredicate",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FElementSortPredicate"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Algo / IsSorted . h \" # define ENABLE_ANIM_CURVE_PROFILING 0 # if ENABLE_ANIM_CURVE_PROFILING # include \" Stats / Stats . h \" # endif # if ENABLE_ANIM_CURVE_PROFILING # define)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(Stat) QUICK_SCOPE_CYCLE_COUNTER(Stat) #else #define CURVE_PROFILE_CYCLE_COUNTER(Stat)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (struct FNamedValueArrayUtils ; template<InAllocatorType,InElementType> struct TNamedValueArray { typedef InAllocatorType AllocatorType ; typedef InElementType ElementType ; struct FNamedValueArrayUtils ; template<. . . ArgTypes> void)",
    "insertText": "Add(ArgTypes&&... Args)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Emplace(Forward<ArgTypes>(Args)...)"
  },
  {
    "label": "CheckDuplicates()",
    "kind": "Method",
    "detail": "Function (bSorted = false ;)",
    "insertText": "CheckDuplicates()"
  },
  {
    "label": "AppendNames()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendNames(TConstArrayView<FName> InNameArray)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Reserve(Elements.Num() + InNameArray.Num())"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Emplace(Name)"
  },
  {
    "label": "AppendNames()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendNames(std::initializer_list<const FName> InInputArgs)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Reserve(Elements.Num() + InInputArgs.size())"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Empty()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Reset()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (bSorted = false ; } void)",
    "insertText": "Reserve(int32 InNumElements)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Reserve(InNumElements)"
  },
  {
    "label": "HasElement()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasElement(FName InName)"
  },
  {
    "label": "ForEachElement()",
    "kind": "Method",
    "detail": "Function (} template<PredicateType> void)",
    "insertText": "ForEachElement(PredicateType InPredicate)"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InPredicate(Element)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} } int32)",
    "insertText": "Num()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Max()"
  },
  {
    "label": "Shrink()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Shrink()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} protected : struct FElementSortPredicate { bool)",
    "insertText": "operator()(const ElementType& InElement0, const ElementType& InElement1)"
  },
  {
    "label": "SortElementsIfRequired()",
    "kind": "Method",
    "detail": "Function (} } ; void)",
    "insertText": "SortElementsIfRequired()"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(SortElementsIfRequired)"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Sort(Elements, FElementSortPredicate())"
  },
  {
    "label": "CheckSorted()",
    "kind": "Method",
    "detail": "Function (bSorted = true ; } } void)",
    "insertText": "CheckSorted()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if DO_ANIM_NAMED_VALUE_SORTING_CHECKS)",
    "insertText": "if(bSorted)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# if DO_ANIM_NAMED_VALUE_DUPLICATE_CHECKS)",
    "insertText": "for(int32 Index0 = 0; Index0 < Elements.Num(); ++Index0)"
  },
  {
    "label": "IndexOf()",
    "kind": "Method",
    "detail": "Function (} } } # endif } int32)",
    "insertText": "IndexOf(FName InName)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} const ElementType*)",
    "insertText": "Find(FName InName)"
  },
  {
    "label": "IndexOf()",
    "kind": "Method",
    "detail": "Function (const int32 ElementIndex =)",
    "insertText": "IndexOf(InName)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FNamedValueArrayUtils_Union2Params)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (int32 ReserveSize =)",
    "insertText": "Max(NumElements0, NumElements1)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (ReserveSize + = ReserveSize / 2 ; InOutValueArray0 .)",
    "insertText": "Reserve(ReserveSize)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 ElementIndex0 = 0 ; int32 ElementIndex1 = 0 ;)",
    "insertText": "while(true)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (InOutValueArray0 . Elements .)",
    "insertText": "Reserve(InOutValueArray0.Elements.Num() + (NumElements1 - ElementIndex1))"
  },
  {
    "label": "AddDefaulted_GetRef()",
    "kind": "Method",
    "detail": "Function (const ElementTypeParam* RESTRICT Element1 =& InValueArray1 . Elements [ ElementIndex1 ] ; ElementTypeResult* RESTRICT Element0 =& InOutValueArray0 . Elements .)",
    "insertText": "AddDefaulted_GetRef()"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (Element0 -> Name = Element1 -> Name ;)",
    "insertText": "InPredicate(*Element0, *Element1, UE::Anim::ENamedValueUnionFlags::ValidArg1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} break ; })",
    "insertText": "if(ElementIndex1 == NumElements1 && ElementIndex0 <= NumElements0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } ElementTypeResult* RESTRICT Element0 =& InOutValueArray0 . Elements [ ElementIndex0 ] ; const ElementTypeParam* RESTRICT Element1 =& InValueArray1 . Elements [ ElementIndex1 ] ;)",
    "insertText": "if(Element0->Name == Element1->Name)"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InPredicate(*Element0, *Element1, UE::Anim::ENamedValueUnionFlags::BothArgsValid)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + ElementIndex0 ; + + ElementIndex1 ; } else)",
    "insertText": "if(Element0->Name.FastLess(Element1->Name))"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (ElementTypeParam DefaultElement ; DefaultElement . Name = Element0 -> Name ;)",
    "insertText": "InPredicate(*Element0, DefaultElement, UE::Anim::ENamedValueUnionFlags::ValidArg0)"
  },
  {
    "label": "InsertDefaulted_GetRef()",
    "kind": "Method",
    "detail": "Function (+ + ElementIndex0 ; } else { ElementTypeResult* RESTRICT NewElement =& InOutValueArray0 . Elements .)",
    "insertText": "InsertDefaulted_GetRef(ElementIndex0++)"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (NewElement -> Name = Element1 -> Name ;)",
    "insertText": "InPredicate(*NewElement, *Element1, UE::Anim::ENamedValueUnionFlags::ValidArg1)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (} template<AllocatorTypeResult,ElementType,AllocatorTypeParam> void)",
    "insertText": "Union(TNamedValueArray<AllocatorTypeResult, ElementType>& InOutValueArray0, const TNamedValueArray<AllocatorTypeParam, ElementType>& InValueArray1)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (InOutValueArray0 . Elements = InValueArray1 . Elements ; InOutValueArray0 . bSorted = InValueArray1 . bSorted ; return ; })",
    "insertText": "Union(InOutValueArray0, InValueArray1, [](ElementType& Element0, const ElementType& Element1, UE::Anim::ENamedValueUnionFlags InFlags) { if(EnumHasAnyFlags(InFlags, UE::Anim::ENamedValueUnionFlags::ValidArg1)) { Element0 = Element1; } })"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (} template<PredicateType,AllocatorTypeResult,ElementTypeResult,AllocatorType0,ElementType0,AllocatorType1,ElementType1> void)",
    "insertText": "Union(TNamedValueArray<AllocatorTypeResult, ElementTypeResult>& OutResultValueArray, const TNamedValueArray<AllocatorType0, ElementType0>& InValueArray0, const TNamedValueArray<AllocatorType1, ElementType1>& InValueArray1, PredicateType InPredicate)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FNamedValueArrayUtils_Union3Params)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OutResultValueArray . Elements .)",
    "insertText": "Reserve(OutResultValueArray.Elements.Num() + (NumElements1 - ElementIndex1))"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (ResultElement -> Name = Element1 -> Name ;)",
    "insertText": "InPredicate(*ResultElement, DefaultElement0, *Element1, UE::Anim::ENamedValueUnionFlags::ValidArg1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} break ; })",
    "insertText": "if(ElementIndex1 == NumElements1)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OutResultValueArray . Elements .)",
    "insertText": "Reserve(OutResultValueArray.Elements.Num() + (NumElements0 - ElementIndex0))"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (ResultElement -> Name = Element0 -> Name ;)",
    "insertText": "InPredicate(OutResultValueArray.Elements[ResultIndex], *Element0, DefaultElement1, UE::Anim::ENamedValueUnionFlags::ValidArg0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} break ; } else)",
    "insertText": "if(ElementIndex0 == NumElements0)"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (NewResultElement -> Name = Element0 -> Name ;)",
    "insertText": "InPredicate(*NewResultElement, *Element0, *Element1, UE::Anim::ENamedValueUnionFlags::BothArgsValid)"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (NewResultElement -> Name = Element0 -> Name ; ElementType1 DefaultElement ; DefaultElement . Name = Element0 -> Name ;)",
    "insertText": "InPredicate(*NewResultElement, *Element0, DefaultElement, UE::Anim::ENamedValueUnionFlags::ValidArg0)"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (NewResultElement -> Name = Element1 -> Name ; ElementType0 DefaultElement ; DefaultElement . Name = Element1 -> Name ;)",
    "insertText": "InPredicate(*NewResultElement, DefaultElement, *Element1, UE::Anim::ENamedValueUnionFlags::ValidArg1)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (} template<PredicateType,AllocatorType0,ElementType0,AllocatorType1,ElementType1> void)",
    "insertText": "Union(const TNamedValueArray<AllocatorType0, ElementType0>& InValueArray0, const TNamedValueArray<AllocatorType1, ElementType1>& InValueArray1, PredicateType InPredicate)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FNamedValueArrayUtils_UnionPredicate)"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (const ElementType1* RESTRICT Element1 =& InValueArray1 . Elements [ ElementIndex1 ] ; ElementType0 DefaultElement0 ; DefaultElement0 . Name = Element1 -> Name ;)",
    "insertText": "InPredicate(DefaultElement0, *Element1, UE::Anim::ENamedValueUnionFlags::ValidArg1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} break ; } else)",
    "insertText": "if(ElementIndex1 == NumElements1 && ElementIndex0 < NumElements0)"
  },
  {
    "label": "InPredicate()",
    "kind": "Method",
    "detail": "Function (const ElementType0* RESTRICT Element0 =& InValueArray0 . Elements [ ElementIndex0 ] ; ElementType1 DefaultElement1 ; DefaultElement1 . Name = Element0 -> Name ;)",
    "insertText": "InPredicate(*Element0, DefaultElement1, UE::Anim::ENamedValueUnionFlags::ValidArg0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} break ; } else)",
    "insertText": "if(ElementIndex0 == NumElements0 && ElementIndex1 == NumElements1)"
  },
  {
    "label": "Intersection()",
    "kind": "Method",
    "detail": "Function (+ + ElementIndex1 ; } } } template<AllocatorType0,ElementType0,AllocatorType1,ElementType1,ValuePredicateType> void)",
    "insertText": "Intersection(const TNamedValueArray<AllocatorType0, ElementType0>& InNamedValues0, const TNamedValueArray<AllocatorType1, ElementType1>& InNamedValues1, ValuePredicateType InValuePredicate)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FNamedValueArrayUtils_Intersection)"
  },
  {
    "label": "InValuePredicate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InValuePredicate(*Element0, *Element1)"
  },
  {
    "label": "RemoveByPredicate()",
    "kind": "Method",
    "detail": "Function (+ + ElementIndex0 ; } else { + + ElementIndex1 ; } } } template<AllocatorType0,ElementType0,AllocatorType1,ElementType1,PredicateType> void)",
    "insertText": "RemoveByPredicate(TNamedValueArray<AllocatorType0, ElementType0>& InOutValueArray0, const TNamedValueArray<AllocatorType1, ElementType1>& InValueArray1, PredicateType InPredicate)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FNamedValueArrayUtils_RemoveByPredicate)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 ElementIndex0 = 0 ; int32 ElementIndex1 = 0 ;)",
    "insertText": "while(ElementIndex0 < InOutValueArray0.Num() && ElementIndex1 < InValueArray1.Num())"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (InOutValueArray0 . Elements .)",
    "insertText": "RemoveAt(ElementIndex0, EAllowShrinking::No)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (} } ; })",
    "insertText": "ENUM_CLASS_FLAGS(UE::Anim::ENamedValueUnionFlags)"
  }
]