[
  {
    "label": "FInstanceCullingManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FInstanceCullingManager"
  },
  {
    "label": "FComputeAndMarkRelevance",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FComputeAndMarkRelevance"
  },
  {
    "label": "FGPUOcclusion",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGPUOcclusion"
  },
  {
    "label": "FGPUOcclusionSerial",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGPUOcclusionSerial"
  },
  {
    "label": "FGPUOcclusionParallel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGPUOcclusionParallel"
  },
  {
    "label": "FGPUOcclusionParallelPacket",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGPUOcclusionParallelPacket"
  },
  {
    "label": "FRelevancePacket",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRelevancePacket"
  },
  {
    "label": "FVisibilityTaskData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVisibilityTaskData"
  },
  {
    "label": "FVirtualTextureUpdater",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVirtualTextureUpdater"
  },
  {
    "label": "TCommandPipe",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TCommandPipe"
  },
  {
    "label": "FPrimitiveRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPrimitiveRange"
  },
  {
    "label": "FDynamicPrimitive",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDynamicPrimitive"
  },
  {
    "label": "FDynamicPrimitiveIndex",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDynamicPrimitiveIndex"
  },
  {
    "label": "FDynamicPrimitiveIndexList",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDynamicPrimitiveIndexList"
  },
  {
    "label": "FDynamicPrimitiveIndexQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDynamicPrimitiveIndexQueue"
  },
  {
    "label": "FDynamicPrimitiveViewMasks",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDynamicPrimitiveViewMasks"
  },
  {
    "label": "FDynamicMeshElementContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDynamicMeshElementContext"
  },
  {
    "label": "FViewFamilyGroup",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FViewFamilyGroup"
  },
  {
    "label": "FViewMeshArrays",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FViewMeshArrays"
  },
  {
    "label": "FDynamicMeshElementContextContainer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDynamicMeshElementContextContainer"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FVisibilityTaskConfig",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVisibilityTaskConfig"
  },
  {
    "label": "FAlwaysVisible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAlwaysVisible"
  },
  {
    "label": "FFrustumCull",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFrustumCull"
  },
  {
    "label": "FOcclusionCull",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOcclusionCull"
  },
  {
    "label": "FView",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FView"
  },
  {
    "label": "FRelevance",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRelevance"
  },
  {
    "label": "FVisibilityViewPacket",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FVisibilityViewPacket"
  },
  {
    "label": "FTasks",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTasks"
  },
  {
    "label": "FDynamicMeshElements",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDynamicMeshElements"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "FRelevancePrimSet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRelevancePrimSet"
  },
  {
    "label": "TARRAY",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TARRAY"
  },
  {
    "label": "FFilterStaticMeshesForViewData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFilterStaticMeshesForViewData"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "FDrawCommandRelevancePacket",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDrawCommandRelevancePacket"
  },
  {
    "label": "FPrimitiveLODMask",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPrimitiveLODMask"
  },
  {
    "label": "FOcclusionBounds",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOcclusionBounds"
  },
  {
    "label": "FThrottledOcclusionQuery",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FThrottledOcclusionQuery"
  },
  {
    "label": "FOcclusionQuery",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOcclusionQuery"
  },
  {
    "label": "FOcclusionFeedbackEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOcclusionFeedbackEntry"
  },
  {
    "label": "FHZBBound",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHZBBound"
  },
  {
    "label": "FGPUOcclusionState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGPUOcclusionState"
  },
  {
    "label": "FOcclusionCullResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOcclusionCullResult"
  },
  {
    "label": "FGPUOcclusionPacket",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGPUOcclusionPacket"
  },
  {
    "label": "FRecordVisitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRecordVisitor"
  },
  {
    "label": "FProcessVisitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FProcessVisitor"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" SceneVisibility . h \" # include \" ScenePrivate . h \" # include \" Containers / ConsumeAllMpmcQueue . h \" # include \" DynamicPrimitiveDrawing . h \" # include \" Async / TaskGraphInterfaces . h \" # include \" Async / Mutex . h \" # include \" Async / UniqueLock . h \" class FInstanceCullingManager ; class FComputeAndMarkRelevance ; class FGPUOcclusion ; class FGPUOcclusionSerial ; class FGPUOcclusionParallel ; class FGPUOcclusionParallelPacket ; class FRelevancePacket ; class FVisibilityTaskData ; class FVirtualTextureUpdater ; template<CommandType> class TCommandPipe { public : using CommandFunctionType = TFunction<)",
    "insertText": "void(CommandType&&)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using EmptyFunctionType = TFunction<)",
    "insertText": "void()"
  },
  {
    "label": "TCommandPipe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TCommandPipe(const TCHAR* InName) : Pipe(InName)"
  },
  {
    "label": "TCommandPipe()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TCommandPipe()"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Wait()"
  },
  {
    "label": "SetCommandFunction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCommandFunction(CommandFunctionType&& InCommandFunction)"
  },
  {
    "label": "CommandFunctionType()",
    "kind": "Method",
    "detail": "Function (CommandFunction = Forward<)",
    "insertText": "CommandFunctionType(InCommandFunction)"
  },
  {
    "label": "SetEmptyFunction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetEmptyFunction(TFunction<void()>&& InEmptyFunction)"
  },
  {
    "label": "EmptyFunctionType()",
    "kind": "Method",
    "detail": "Function (EmptyFunction = Forward<)",
    "insertText": "EmptyFunctionType(InEmptyFunction)"
  },
  {
    "label": "SetPrerequisiteTask()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetPrerequisiteTask(const UE::Tasks::FTask& InPrerequisiteTask)"
  },
  {
    "label": "AddNumCommands()",
    "kind": "Method",
    "detail": "Function (PrerequisiteTask = InPrerequisiteTask ; } void)",
    "insertText": "AddNumCommands(int32 InNumCommands)"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (NumCommands .)",
    "insertText": "fetch_add(InNumCommands, std::memory_order_relaxed)"
  },
  {
    "label": "ReleaseNumCommands()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ReleaseNumCommands(int32 InNumCommands)"
  },
  {
    "label": "fetch_sub()",
    "kind": "Method",
    "detail": "Function (int32 FinalNumCommands = NumCommands .)",
    "insertText": "fetch_sub(InNumCommands, std::memory_order_acq_rel)"
  },
  {
    "label": "EmptyFunction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EmptyFunction()"
  },
  {
    "label": "EnqueueCommand()",
    "kind": "Method",
    "detail": "Function (} } } template<. . . ArgTypes> void)",
    "insertText": "EnqueueCommand(ArgTypes&&... Args)"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (QueueMutex .)",
    "insertText": "Lock()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (const bool bWasEmpty = Queue .)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (Queue .)",
    "insertText": "Emplace(Forward<ArgTypes>(Args)...)"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (QueueMutex .)",
    "insertText": "Unlock()"
  },
  {
    "label": "Launch()",
    "kind": "Method",
    "detail": "Function (Pipe .)",
    "insertText": "Launch(Pipe.GetDebugName(), [this] { FOptionalTaskTagScope Scope(ETaskTag::EParallelRenderingThread); SCOPED_NAMED_EVENT_TCHAR(Pipe.GetDebugName(), FColor::Magenta); TArray<CommandType, SceneRenderingAllocator> Commands; QueueMutex.Lock(); Commands = MoveTemp(Queue); QueueMutex.Unlock(); int32 NumProcessedCommands = 0; for (CommandType& Command : Commands) { CommandFunction(MoveTemp(Command)); NumProcessedCommands++; } if (NumProcessedCommands) { ReleaseNumCommands(NumProcessedCommands); } }, PrerequisiteTask)"
  },
  {
    "label": "WaitUntilEmpty()",
    "kind": "Method",
    "detail": "Function (Pipe .)",
    "insertText": "WaitUntilEmpty()"
  },
  {
    "label": "GetExtendedTaskPriority()",
    "kind": "Method",
    "detail": "Function (} private : UE::Tasks::FTask PrerequisiteTask ; CommandFunctionType CommandFunction ; EmptyFunctionType EmptyFunction ; UE::FMutex QueueMutex ; TArray<CommandType,SceneRenderingAllocator> Queue ; UE::Tasks::FPipe Pipe ; std::atomic_int32_t NumCommands { 0 } ; } ; UE::Tasks::EExtendedTaskPriority)",
    "insertText": "GetExtendedTaskPriority(bool bExecuteInParallel)"
  },
  {
    "label": "FDynamicPrimitiveIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FDynamicPrimitiveIndex(int32 InIndex, uint8 InViewMask) : Index(InIndex) , ViewMask(InViewMask)"
  },
  {
    "label": "FDynamicPrimitiveIndexQueue()",
    "kind": "Method",
    "detail": "Function (} FList Primitives ; # if WITH_EDITOR FList EditorPrimitives ; # endif } ; class FDynamicPrimitiveIndexQueue { public :)",
    "insertText": "FDynamicPrimitiveIndexQueue(FDynamicPrimitiveIndexList&& InList) : List(InList)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Pop(FDynamicPrimitiveIndex& PrimitiveIndex)"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (const int32 Index = NextIndex .)",
    "insertText": "fetch_add(1, std::memory_order_relaxed)"
  },
  {
    "label": "PopEditor()",
    "kind": "Method",
    "detail": "Function (PrimitiveIndex = List . Primitives [ Index ] ; return true ; } return false ; } # if WITH_EDITOR bool)",
    "insertText": "PopEditor(FDynamicPrimitiveIndex& PrimitiveIndex)"
  },
  {
    "label": "FDynamicMeshElementContext()",
    "kind": "Method",
    "detail": "Function (PrimitiveIndex = List . EditorPrimitives [ Index ] ; return true ; } return false ; } # endif private : FDynamicPrimitiveIndexList List ; std::atomic_int32_t NextIndex = { 0 } ; # if WITH_EDITOR std::atomic_int32_t NextEditorIndex = { 0 } ; # endif } ; struct FDynamicPrimitiveViewMasks { FPrimitiveViewMasks Primitives ; # if WITH_EDITOR FPrimitiveViewMasks EditorPrimitives ; # endif } ; class FDynamicMeshElementContext { public :)",
    "insertText": "FDynamicMeshElementContext(FSceneRenderer& SceneRenderer)"
  },
  {
    "label": "LaunchRenderThreadTask()",
    "kind": "Method",
    "detail": "Function (FGraphEventRef)",
    "insertText": "LaunchRenderThreadTask(FDynamicPrimitiveIndexList&& PrimitiveIndexList)"
  },
  {
    "label": "LaunchAsyncTask()",
    "kind": "Method",
    "detail": "Function (UE::Tasks::FTask)",
    "insertText": "LaunchAsyncTask(FDynamicPrimitiveIndexQueue* PrimitiveIndexQueue, UE::Tasks::ETaskPriority TaskPriority)"
  },
  {
    "label": "GatherDynamicMeshElementsForPrimitive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GatherDynamicMeshElementsForPrimitive(FPrimitiveSceneInfo* Primitive, uint8 ViewMask)"
  },
  {
    "label": "GatherDynamicMeshElementsForEditorPrimitive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GatherDynamicMeshElementsForEditorPrimitive(FPrimitiveSceneInfo* Primitive, uint8 ViewMask)"
  },
  {
    "label": "Finish()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "Finish()"
  },
  {
    "label": "FDynamicMeshElementContextContainer()",
    "kind": "Method",
    "detail": "Function (struct FViewFamilyGroup { const FSceneViewFamily* Family ; uint8 ViewSubsetMask ; } ; struct FViewMeshArrays { TArray<FMeshBatchAndRelevance,SceneRenderingAllocator> DynamicMeshElements ; FSimpleElementCollector SimpleElementCollector ; # if WITH_EDITOR TArray<FMeshBatchAndRelevance,SceneRenderingAllocator> DynamicEditorMeshElements ; FSimpleElementCollector EditorSimpleElementCollector ; # endif # if UE_ENABLE_DEBUG_DRAWING FSimpleElementCollector DebugSimpleElementCollector ; # endif } ; const FSceneViewFamily& FirstViewFamily ; TArrayView<FViewInfo*> Views ; TArrayView<FPrimitiveSceneInfo*> Primitives ; TArray<FViewFamilyGroup,TInlineAllocator<1>> ViewFamilyGroups ; TArray<FViewMeshArrays,TInlineAllocator<2>> ViewMeshArraysPerView ; TArray<FDynamicPrimitive,SceneRenderingAllocator> DynamicPrimitives ; FMeshElementCollector MeshCollector ; # if WITH_EDITOR FMeshElementCollector EditorMeshCollector ; # endif FRHICommandList* RHICmdList ; FGlobalDynamicVertexBuffer DynamicVertexBuffer ; FGlobalDynamicIndexBuffer DynamicIndexBuffer ; UE::Tasks::FPipe Pipe { UE_SOURCE_LOCATION } ; class FDynamicMeshElementContextContainer ; } ; class FDynamicMeshElementContextContainer { public : ~)",
    "insertText": "FDynamicMeshElementContextContainer()"
  },
  {
    "label": "GetNumAsyncContexts()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumAsyncContexts()"
  },
  {
    "label": "GetRenderThreadContext()",
    "kind": "Method",
    "detail": "Function (} FDynamicMeshElementContext*)",
    "insertText": "GetRenderThreadContext()"
  },
  {
    "label": "LaunchAsyncTask()",
    "kind": "Method",
    "detail": "Function (UE::Tasks::FTask)",
    "insertText": "LaunchAsyncTask(FDynamicPrimitiveIndexQueue* PrimitiveIndexQueue, int32 Index, UE::Tasks::ETaskPriority TaskPriority)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(FSceneRenderer& InSceneRenderer, int32 NumAsyncContexts)"
  },
  {
    "label": "MergeContexts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MergeContexts(TArray<FDynamicPrimitive, SceneRenderingAllocator>& OutDynamicPrimitives)"
  },
  {
    "label": "Submit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Submit(FRHICommandListImmediate& RHICmdList)"
  },
  {
    "label": "FVisibilityTaskConfig()",
    "kind": "Method",
    "detail": "Function (private : using FDynamicMeshElementContextArray = TArray<FDynamicMeshElementContext*> ; TArrayView<FViewInfo*> Views ; FDynamicMeshElementContextArray Contexts ; TArray<FRHICommandListImmediate::FQueuedCommandList,FConcurrentLinearArrayAllocator> CommandLists ; bool bFinished = false ; } ; enum class EVisibilityTaskSchedule { RenderThread,Parallel,} ; class FVisibilityTaskConfig { public :)",
    "insertText": "FVisibilityTaskConfig(const FScene& Scene, TConstArrayView<FViewInfo*> Views)"
  },
  {
    "label": "FVisibilityViewPacket()",
    "kind": "Method",
    "detail": "Function (EVisibilityTaskSchedule Schedule ; UE::Tasks::ETaskPriority TaskPriority = UE::Tasks::ETaskPriority::High ; uint32 NumVisiblePrimitives = 0 ; uint32 NumTestedPrimitives = 0 ; struct FAlwaysVisible { uint32 MinWordsPerTask = 3 2 ; const UE::Tasks::ETaskPriority TaskPriority = UE::Tasks::ETaskPriority::High ; uint32 NumTasks = 0 ; uint32 NumWordsPerTask = 0 ; uint32 NumPrimitivesPerTask = 0 ; } AlwaysVisible ; struct FFrustumCull { uint32 MinWordsPerTask = 3 2 ; const UE::Tasks::ETaskPriority TaskPriority = UE::Tasks::ETaskPriority::High ; uint32 NumTasks = 0 ; uint32 NumWordsPerTask = 0 ; uint32 NumPrimitivesPerTask = 0 ; std::atomic_uint32_t NumCulledPrimitives { 0 } ; } FrustumCull ; struct FOcclusionCull { uint32 MinQueriesPerTask = 6 4 ; const UE::Tasks::ETaskPriority TaskPriority = UE::Tasks::ETaskPriority::High ; const UE::Tasks::ETaskPriority FinalizeTaskPriority = UE::Tasks::ETaskPriority::Normal ; struct FView { uint32 MaxQueriesPerTask = 0 ; } ; TArray<FView,TInlineAllocator<2,SceneRenderingAllocator>> Views ; std::atomic_uint32_t NumCulledPrimitives { 0 } ; std::atomic_uint32_t NumTestedQueries { 0 } ; } OcclusionCull ; struct FRelevance { uint32 MinPrimitivesPerTask = 3 2 ; uint32 MaxPrimitivesPerTask = 2 0 4 8 ; const UE::Tasks::ETaskPriority ComputeRelevanceTaskPriority = UE::Tasks::ETaskPriority::High ; uint32 NumEstimatedPackets = 0 ; uint32 NumPrimitivesPerPacket = 0 ; uint32 NumPrimitivesProcessed = 0 ; } Relevance ; } ; class FVisibilityViewPacket { FVisibilityTaskData ; FGPUOcclusionParallel ; FGPUOcclusionParallelPacket ; public :)",
    "insertText": "FVisibilityViewPacket(FVisibilityTaskData& TaskData, FScene& InScene, FViewInfo& InView, int32 ViewIndex)"
  },
  {
    "label": "BeginInitVisibility()",
    "kind": "Method",
    "detail": "Function (FVisibilityTaskData& TaskData ; FVisibilityTaskConfig& TaskConfig ; FScene& Scene ; FViewInfo& View ; FSceneViewState* ViewState ; int32 ViewIndex ; FViewElementPDI ViewElementPDI ; private : void)",
    "insertText": "BeginInitVisibility()"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (struct FOcclusionCull { FGPUOcclusionSerial* ContextIfSerial = nullptr ; FGPUOcclusionParallel* ContextIfParallel = nullptr ; TCommandPipe<FPrimitiveRange> CommandPipe {)",
    "insertText": "TEXT(\"OcclusionCullPipe\")"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (} OcclusionCull ; struct FRelevance { FComputeAndMarkRelevance* Context = nullptr ; TCommandPipe<FPrimitiveIndexList> CommandPipe {)",
    "insertText": "TEXT(\"RelevancePipe\")"
  },
  {
    "label": "FVisibilityTaskData()",
    "kind": "Method",
    "detail": "Function (TCommandPipe<FPrimitiveIndexList>* PrimaryViewCommandPipe ; } Relevance ; struct FTasks { UE::Tasks::FTaskEvent AlwaysVisible { UE_SOURCE_LOCATION } ; UE::Tasks::FTaskEvent FrustumCull { UE_SOURCE_LOCATION } ; UE::Tasks::FTaskEvent OcclusionCull { UE_SOURCE_LOCATION } ; UE::Tasks::FTaskEvent ComputeRelevance { UE_SOURCE_LOCATION } ; UE::Tasks::FTaskEvent LightVisibility { UE_SOURCE_LOCATION } ; } Tasks ; } ; class FVisibilityTaskData : public IVisibilityTaskData { FVisibilityViewPacket ; FRelevancePacket ; FComputeAndMarkRelevance ; public :)",
    "insertText": "FVisibilityTaskData(FRHICommandListImmediate& RHICmdList, FSceneRenderer& SceneRenderer)"
  },
  {
    "label": "FVisibilityTaskData()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FVisibilityTaskData()"
  },
  {
    "label": "LaunchVisibilityTasks()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "LaunchVisibilityTasks(const UE::Tasks::FTask& BeginInitVisibilityPrerequisites)"
  },
  {
    "label": "ProcessRenderThreadTasks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessRenderThreadTasks()"
  },
  {
    "label": "StartGatherDynamicMeshElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartGatherDynamicMeshElements()"
  },
  {
    "label": "Trigger()",
    "kind": "Method",
    "detail": "Function (Tasks . DynamicMeshElementsPrerequisites .)",
    "insertText": "Trigger()"
  },
  {
    "label": "FinishGatherDynamicMeshElements()",
    "kind": "Method",
    "detail": "Function (Tasks . bDynamicMeshElementsPrerequisitesTriggered = true ; } } void)",
    "insertText": "FinishGatherDynamicMeshElements(FExclusiveDepthStencil::Type BasePassDepthStencilAccess, FInstanceCullingManager& InstanceCullingManager, FVirtualTextureUpdater* VirtualTextureUpdater)"
  },
  {
    "label": "GetViewCommandsPerView()",
    "kind": "Method",
    "detail": "Function (TArrayView<FViewCommands>)",
    "insertText": "GetViewCommandsPerView()"
  },
  {
    "label": "GatherDynamicMeshElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GatherDynamicMeshElements(FDynamicPrimitiveIndexList&& Primitives)"
  },
  {
    "label": "GatherDynamicMeshElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GatherDynamicMeshElements(const FDynamicPrimitiveViewMasks& Primitives)"
  },
  {
    "label": "SetupMeshPasses()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetupMeshPasses(FExclusiveDepthStencil::Type BasePassDepthStencilAccess, FInstanceCullingManager& InstanceCullingManager)"
  },
  {
    "label": "FRelevancePrimSet()",
    "kind": "Method",
    "detail": "Function (FRHICommandListImmediate& RHICmdList ; FSceneRenderer& SceneRenderer ; FScene& Scene ; TArrayView<FViewInfo*> Views ; FViewFamilyInfo& ViewFamily ; EShadingPath ShadingPath ; FSceneRenderingBulkObjectAllocator Allocator ; TArray<FVisibilityViewPacket,SceneRenderingAllocator> ViewPackets ; struct FDynamicMeshElements { TCommandPipe<FDynamicPrimitiveIndexList>* CommandPipe = nullptr ; FDynamicPrimitiveViewMasks* PrimitiveViewMasks = nullptr ; FDynamicMeshElementContextContainer ContextContainer ; TArray<FViewCommands,TInlineAllocator<4>> ViewCommandsPerView ; TArray<FDynamicPrimitive,SceneRenderingAllocator> DynamicPrimitives ; TArray<UE::Tasks::FPipe,SceneRenderingAllocator> DynamicPrimitiveTaskPipes ; } DynamicMeshElements ; struct FTasks { FGraphEventRef FrustumCullLegacyTask ; FGraphEventRef ComputeRelevanceLegacyTask ; FGraphEventRef DynamicMeshElementsPipe ; FGraphEventRef DynamicMeshElementsRenderThread ; UE::Tasks::FTaskEvent LightVisibility { UE_SOURCE_LOCATION } ; UE::Tasks::FTaskEvent BeginInitVisibility { UE_SOURCE_LOCATION } ; UE::Tasks::FTaskEvent FrustumCull { UE_SOURCE_LOCATION } ; UE::Tasks::FTaskEvent OcclusionCull { UE_SOURCE_LOCATION } ; UE::Tasks::FTaskEvent ComputeRelevance { UE_SOURCE_LOCATION } ; UE::Tasks::FTaskEvent DynamicMeshElementsPrerequisites { UE_SOURCE_LOCATION } ; UE::Tasks::FTaskEvent DynamicMeshElements { UE_SOURCE_LOCATION } ; UE::Tasks::FTask FinalizeRelevance ; UE::Tasks::FTask MeshPassSetup ; bool bDynamicMeshElementsPrerequisitesTriggered = false ; bool bWaitingAllowed = false ; } Tasks ; FVisibilityTaskConfig TaskConfig ; const bool bAddNaniteRelevance ; const bool bAddLightmapDensityCommands ; bool bFinished = false ; } ; template<class T,int TAmplifyFactor = 1> struct FRelevancePrimSet { TArray<T,SceneRenderingAllocator> Prims ; const int32 MaxOutputPrims ;)",
    "insertText": "FRelevancePrimSet(int32 InputPrimCount) : MaxOutputPrims(InputPrimCount* TAmplifyFactor)"
  },
  {
    "label": "AddPrim()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddPrim(T Prim)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Prims .)",
    "insertText": "Reserve(MaxOutputPrims)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} Prims .)",
    "insertText": "Add(Prim)"
  },
  {
    "label": "IsFull()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsFull()"
  },
  {
    "label": "AppendTo()",
    "kind": "Method",
    "detail": "Function (} template<class TARRAY> void)",
    "insertText": "AppendTo(TARRAY& DestArray)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (DestArray .)",
    "insertText": "Append(Prims)"
  },
  {
    "label": "FFilterStaticMeshesForViewData()",
    "kind": "Method",
    "detail": "Function (} } ; struct FFilterStaticMeshesForViewData { FVector ViewOrigin ; int32 ForcedLODLevel ; float LODScale ; float MinScreenRadiusForDepthPrepassSquared ; bool bFullEarlyZPass ;)",
    "insertText": "FFilterStaticMeshesForViewData(FViewInfo& View)"
  },
  {
    "label": "FDrawCommandRelevancePacket()",
    "kind": "Method",
    "detail": "Function (} ; namespace EMarkMaskBits { enum Type { StaticMeshVisibilityMapMask = 0 x2,StaticMeshFadeOutDitheredLODMapMask = 0 x10,StaticMeshFadeInDitheredLODMapMask = 0 x20,} ; } using FPassDrawCommandArray = TArray<FVisibleMeshDrawCommand> ; using FPassDrawCommandBuildRequestArray = TArray<const FStaticMeshBatch*> ; using FPassDrawCommandBuildFlagsArray = TArray<EMeshDrawCommandCullingPayloadFlags> ; struct FDrawCommandRelevancePacket {)",
    "insertText": "FDrawCommandRelevancePacket()"
  },
  {
    "label": "AddCommandsForMesh()",
    "kind": "Method",
    "detail": "Function (FPassDrawCommandArray VisibleCachedDrawCommands [ EMeshPass::Num ] ; FPassDrawCommandBuildRequestArray DynamicBuildRequests [ EMeshPass::Num ] ; FPassDrawCommandBuildFlagsArray DynamicBuildFlags [ EMeshPass::Num ] ; int32 NumDynamicBuildRequestElements [ EMeshPass::Num ] ; bool bUseCachedMeshDrawCommands ; void)",
    "insertText": "AddCommandsForMesh(int32 PrimitiveIndex, const FPrimitiveSceneInfo* InPrimitiveSceneInfo, const FStaticMeshBatchRelevance& RESTRICT StaticMeshRelevance, const FStaticMeshBatch& RESTRICT StaticMesh, EMeshDrawCommandCullingPayloadFlags CullingPayloadFlags, const FScene& Scene, bool bCanCache, EMeshPass::Type PassType)"
  },
  {
    "label": "FRelevancePacket()",
    "kind": "Method",
    "detail": "Function (} ; class FRelevancePacket : public FSceneRenderingAllocatorObject<FRelevancePacket> { public :)",
    "insertText": "FRelevancePacket(FVisibilityTaskData& InTaskData, const FViewInfo& InView, int32 InViewIndex, const FFilterStaticMeshesForViewData& InViewData, uint8* InMarkMasks, const UE::Tasks::FTask& PrerequisitesTask)"
  },
  {
    "label": "LaunchComputeRelevanceTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LaunchComputeRelevanceTask()"
  },
  {
    "label": "Finalize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Finalize()"
  },
  {
    "label": "ComputeRelevance()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "ComputeRelevance(FDynamicPrimitiveIndexList& DynamicPrimitiveIndexList)"
  },
  {
    "label": "FPrimitiveLODMask()",
    "kind": "Method",
    "detail": "Function (FComputeAndMarkRelevance ; const float CurrentWorldTime ; const float DeltaWorldTime ; FVisibilityTaskData& TaskData ; FVisibilityTaskConfig& TaskConfig ; const FScene& Scene ; const FViewInfo& View ; const FViewCommands& ViewCommands ; const uint8 ViewBit ; const FFilterStaticMeshesForViewData& ViewData ; FDynamicPrimitiveViewMasks* DynamicPrimitiveViewMasks ; uint8* RESTRICT MarkMasks ; UE::Tasks::FTask PrerequisitesTask ; FRelevancePrimSet<int32> Input ; FRelevancePrimSet<int32> NotDrawRelevant ; FRelevancePrimSet<int32> TranslucentSelfShadowPrimitives ; FRelevancePrimSet<FPrimitiveSceneInfo*> VisibleDynamicPrimitivesWithSimpleLights ; int32 NumVisibleDynamicPrimitives = 0 ; int32 NumVisibleDynamicEditorPrimitives = 0 ; FMeshPassMask VisibleDynamicMeshesPassMask ; FTranslucenyPrimCount TranslucentPrimCount ; FRelevancePrimSet<FPrimitiveSceneInfo*> DirtyIndirectLightingCacheBufferPrimitives ; # if WITH_EDITOR TArray<Nanite::FInstanceDraw> EditorVisualizeLevelInstancesNanite ; TArray<Nanite::FInstanceDraw> EditorSelectedInstancesNanite ; TArray<Nanite::FInstanceDraw> EditorOverlaidInstancesNanite ; TArray<uint32> EditorSelectedNaniteHitProxyIds ; # endif TArray<FVolumetricMeshBatch,SceneRenderingAllocator> VolumetricMeshBatches ; TArray<FVolumetricMeshBatch,SceneRenderingAllocator> HeterogeneousVolumesMeshBatches ; TArray<FSkyMeshBatch,SceneRenderingAllocator> SkyMeshBatches ; TArray<FSortedTrianglesMeshBatch,SceneRenderingAllocator> SortedTrianglesMeshBatches ; FDrawCommandRelevancePacket DrawCommandPacket ; TSet<uint32,DefaultKeyFuncs<uint32>,SceneRenderingSetAllocator> CustomDepthStencilValues ; FRelevancePrimSet<FPrimitiveInstanceRange> NaniteCustomDepthInstances ; struct FPrimitiveLODMask {)",
    "insertText": "FPrimitiveLODMask() : PrimitiveIndex(INDEX_NONE)"
  },
  {
    "label": "FPrimitiveLODMask()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FPrimitiveLODMask(const int32 InPrimitiveIndex, const FLODMask& InLODMask) : PrimitiveIndex(InPrimitiveIndex) , LODMask(InLODMask)"
  },
  {
    "label": "FComputeAndMarkRelevance()",
    "kind": "Method",
    "detail": "Function (} int32 PrimitiveIndex ; FLODMask LODMask ; } ; FRelevancePrimSet<FPrimitiveLODMask> PrimitivesLODMask ; UE::Tasks::FTask ComputeRelevanceTask ; uint16 CombinedShadingModelMask = 0 ; uint8 SubstrateUintPerPixel = 0 ; uint8 SubstrateClosureCountMask = 0 ; bool bUsesComplexSpecialRenderPath = false ; bool bHasDistortionPrimitives = false ; bool bHasCustomDepthPrimitives = false ; bool bUsesGlobalDistanceField = false ; bool bUsesLightingChannels = false ; bool bTranslucentSurfaceLighting = false ; bool bUsesCustomDepth = false ; bool bUsesCustomStencil = false ; bool bSceneHasSkyMaterial = false ; bool bHasSingleLayerWaterMaterial = false ; bool bUsesSecondStageDepthPass = false ; bool bAddLightmapDensityCommands = false ; bool bComputeRelevanceTaskLaunched = false ; } ; class FComputeAndMarkRelevance { public :)",
    "insertText": "FComputeAndMarkRelevance(FVisibilityTaskData& InTaskData, FScene& InScene, FViewInfo& InView, uint8 InViewIndex, const UE::Tasks::FTask& PreprequisitesTask)"
  },
  {
    "label": "FComputeAndMarkRelevance()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FComputeAndMarkRelevance()"
  },
  {
    "label": "AddPrimitives()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddPrimitives(FPrimitiveIndexList&& PrimitiveIndexList)"
  },
  {
    "label": "AddPrimitive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddPrimitive(int32 Index)"
  },
  {
    "label": "Finish()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Finish(UE::Tasks::FTaskEvent& ComputeRelevanceTaskEvent)"
  },
  {
    "label": "CreateRelevancePacket()",
    "kind": "Method",
    "detail": "Function (private : FRelevancePacket*)",
    "insertText": "CreateRelevancePacket()"
  },
  {
    "label": "FOcclusionBounds()",
    "kind": "Method",
    "detail": "Function (} FVisibilityTaskData& TaskData ; FScene& Scene ; FViewInfo& View ; FViewCommands& ViewCommands ; FSceneBitArray InstancedPrimitiveAddedMap ; int32 ViewIndex ; const FFilterStaticMeshesForViewData ViewData ; const uint32 NumMeshes ; const uint32 NumPrimitivesPerPacket ; uint8* MarkMasks ; TArray<FRelevancePacket*,SceneRenderingAllocator> Packets ; UE::Tasks::FTask PrerequisitesTask ; const bool bLaunchOnAddPrimitive ; bool bFinished = false ; bool bFinalized = false ; } ; struct FOcclusionBounds {)",
    "insertText": "FOcclusionBounds(FVector InOrigin, FVector& InExtent) : Origin(InOrigin) , Extent(InExtent)"
  },
  {
    "label": "FThrottledOcclusionQuery()",
    "kind": "Method",
    "detail": "Function (} const FVector Origin ; const FVector Extent ; } ; struct FThrottledOcclusionQuery {)",
    "insertText": "FThrottledOcclusionQuery(FPrimitiveOcclusionHistoryKey InPrimitiveOcclusionHistoryKey, FVector InBoundsOrigin, FVector InBoundsExtent, uint32 InLastQuerySubmitFrame) : PrimitiveOcclusionHistoryKey(InPrimitiveOcclusionHistoryKey) , Bounds(InBoundsOrigin, InBoundsExtent) , LastQuerySubmitFrame(InLastQuerySubmitFrame)"
  },
  {
    "label": "FOcclusionQuery()",
    "kind": "Method",
    "detail": "Function (} const FPrimitiveOcclusionHistoryKey PrimitiveOcclusionHistoryKey ; const FOcclusionBounds Bounds ; const uint32 LastQuerySubmitFrame ; } ; struct FOcclusionQuery {)",
    "insertText": "FOcclusionQuery(FPrimitiveOcclusionHistory* InPrimitiveOcclusionHistory, FVector InBoundsOrigin, FVector InBoundsExtent, bool bInGroupedQuery) : PrimitiveOcclusionHistory(InPrimitiveOcclusionHistory) , Bounds(InBoundsOrigin, InBoundsExtent) , bGroupedQuery(bInGroupedQuery)"
  },
  {
    "label": "FOcclusionFeedbackEntry()",
    "kind": "Method",
    "detail": "Function (} FPrimitiveOcclusionHistory* PrimitiveOcclusionHistory ; const FOcclusionBounds Bounds ; const bool bGroupedQuery ; } ; struct FOcclusionFeedbackEntry {)",
    "insertText": "FOcclusionFeedbackEntry(const FPrimitiveOcclusionHistoryKey& PrimitiveKey, FVector InBoundsOrigin, FVector InBoundsExtent) : PrimitiveKey(PrimitiveKey) , Bounds(InBoundsOrigin, InBoundsExtent)"
  },
  {
    "label": "FHZBBound()",
    "kind": "Method",
    "detail": "Function (} const FPrimitiveOcclusionHistoryKey PrimitiveKey ; const FOcclusionBounds Bounds ; } ; struct FHZBBound {)",
    "insertText": "FHZBBound(FPrimitiveOcclusionHistory* InTargetHistory, const FVector& InBoundsOrigin, const FVector& InBoundsExtent) : TargetHistory(InTargetHistory) , BoundsOrigin(InBoundsOrigin) , BoundsExtent(InBoundsExtent)"
  },
  {
    "label": "FGPUOcclusionPacket()",
    "kind": "Method",
    "detail": "Function (} FPrimitiveOcclusionHistory* const TargetHistory ; const FVector BoundsOrigin ; const FVector BoundsExtent ; } ; struct FGPUOcclusionState { int32 ReadBackLagTolerance = 0 ; int32 NumBufferedFrames = 0 ; int32 NumPrimitiveRangeTasks = 0 ; bool bSubmitQueries = false ; bool bHZBOcclusion = false ; bool bUseRoundRobinOcclusion = false ; bool bAllowSubQueries = false ; } ; struct FOcclusionCullResult { uint32 NumCulledPrimitives = 0 ; uint32 NumTestedQueries = 0 ; } ; class FGPUOcclusionPacket { public :)",
    "insertText": "FGPUOcclusionPacket(FVisibilityViewPacket& InViewPacket, const FGPUOcclusionState& InOcclusionState)"
  },
  {
    "label": "CanBeOccluded()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanBeOccluded(int32 PrimitiveIndex, EOcclusionFlags::Type& OutOcclusionFlags)"
  },
  {
    "label": "Type()",
    "kind": "Method",
    "detail": "Function (OutOcclusionFlags = static_cast<)",
    "insertText": "Type(Scene.PrimitiveOcclusionFlags[PrimitiveIndex])"
  },
  {
    "label": "EnumHasAnyFlags()",
    "kind": "Method",
    "detail": "Function (bool bCanBeOccluded =)",
    "insertText": "EnumHasAnyFlags(EOcclusionFlags::CanBeOccluded, OutOcclusionFlags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR)",
    "insertText": "if(GIsEditor)"
  },
  {
    "label": "RecordOcclusionCullResult()",
    "kind": "Method",
    "detail": "Function (bCanBeOccluded = false ; } } # endif return bCanBeOccluded ; } void)",
    "insertText": "RecordOcclusionCullResult(FOcclusionCullResult Result)"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (FVisibilityTaskConfig& TaskConfig = ViewPacket . TaskConfig ; TaskConfig . OcclusionCull . NumCulledPrimitives .)",
    "insertText": "fetch_add(Result.NumCulledPrimitives, std::memory_order_relaxed)"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (TaskConfig . OcclusionCull . NumTestedQueries .)",
    "insertText": "fetch_add(Result.NumTestedQueries, std::memory_order_relaxed)"
  },
  {
    "label": "OcclusionCullPrimitive()",
    "kind": "Method",
    "detail": "Function (} template<bool bIsParallel,VisitorType> bool)",
    "insertText": "OcclusionCullPrimitive(VisitorType& Visitor, FOcclusionCullResult& Result, int32 Index)"
  },
  {
    "label": "AddThrottledOcclusionQuery()",
    "kind": "Method",
    "detail": "Function (struct FRecordVisitor { void)",
    "insertText": "AddThrottledOcclusionQuery(const FThrottledOcclusionQuery& Query)"
  },
  {
    "label": "AddOcclusionHistory()",
    "kind": "Method",
    "detail": "Function (} FPrimitiveOcclusionHistory*)",
    "insertText": "AddOcclusionHistory(const FPrimitiveOcclusionHistory& History)"
  },
  {
    "label": "AddHZBBounds()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddHZBBounds(const FHZBBound& Bounds)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (HZBBounds .)",
    "insertText": "Emplace(Bounds)"
  },
  {
    "label": "AddOcclusionFeedback()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddOcclusionFeedback(const FOcclusionFeedbackEntry& Entry)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (OcclusionFeedbacks .)",
    "insertText": "Emplace(Entry)"
  },
  {
    "label": "AddVisualizeQuery()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddVisualizeQuery(const FBox& Box)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (VisualizeQueries .)",
    "insertText": "Emplace(Box)"
  },
  {
    "label": "AddOcclusionQuery()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddOcclusionQuery(const FOcclusionQuery& Query)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (OcclusionQueries .)",
    "insertText": "Emplace(Query)"
  },
  {
    "label": "FProcessVisitor()",
    "kind": "Method",
    "detail": "Function (} uint32 ArrayChunkSize = 1 0 2 4 ; TChunkedArray<FPrimitiveOcclusionHistory,ArrayChunkSize,SceneRenderingAllocator> OcclusionHistories ; TArray<FOcclusionQuery,SceneRenderingAllocator> OcclusionQueries ; TArray<FOcclusionFeedbackEntry,SceneRenderingAllocator> OcclusionFeedbacks ; TArray<FHZBBound,SceneRenderingAllocator> HZBBounds ; TArray<FBox,SceneRenderingAllocator> VisualizeQueries ; } ; struct FProcessVisitor {)",
    "insertText": "FProcessVisitor(FGPUOcclusionPacket& InPacket, FRHICommandList& InRHICmdList, FGlobalDynamicVertexBuffer& InDynamicVertexBuffer) : Packet(InPacket) , RHICmdList(InRHICmdList) , DynamicVertexBuffer(InDynamicVertexBuffer) , PrimitiveOcclusionHistorySet(Packet.ViewState.Occlusion.PrimitiveOcclusionHistorySet)"
  },
  {
    "label": "AddPrimitive()",
    "kind": "Method",
    "detail": "Function (Packet . OcclusionFeedback .)",
    "insertText": "AddPrimitive(Entry.PrimitiveKey, Entry.Bounds.Origin, Entry.Bounds.Extent, DynamicVertexBuffer)"
  },
  {
    "label": "DrawWireBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DrawWireBox(&Packet.ViewElementPDI, Box, FColor(50, 255, 50), SDPG_Foreground)"
  },
  {
    "label": "AddHZBBounds()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddHZBBounds(const FHZBBound& HZBBounds)"
  },
  {
    "label": "AddBounds()",
    "kind": "Method",
    "detail": "Function (HZBBounds . TargetHistory -> HZBTestIndex = Packet . HZBOcclusionTests .)",
    "insertText": "AddBounds(HZBBounds.BoundsOrigin, HZBBounds.BoundsExtent)"
  },
  {
    "label": "Replay()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Replay(const FRecordVisitor& RecordVisitor)"
  },
  {
    "label": "AddOcclusionFeedback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOcclusionFeedback(Entry)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(const FOcclusionQuery& Query : RecordVisitor.OcclusionQueries)"
  },
  {
    "label": "AddOcclusionQuery()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddOcclusionQuery(Query)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(const FBox& Box : RecordVisitor.VisualizeQueries)"
  },
  {
    "label": "AddVisualizeQuery()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddVisualizeQuery(Box)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(const FHZBBound& HZBBounds : RecordVisitor.HZBBounds)"
  },
  {
    "label": "AddHZBBounds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddHZBBounds(HZBBounds)"
  },
  {
    "label": "SubmitThrottledOcclusionQueries()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SubmitThrottledOcclusionQueries()"
  },
  {
    "label": "FGPUOcclusion()",
    "kind": "Method",
    "detail": "Function (FGPUOcclusionPacket& Packet ; FRHICommandList& RHICmdList ; FGlobalDynamicVertexBuffer& DynamicVertexBuffer ; TArray<FThrottledOcclusionQuery,SceneRenderingAllocator> ThrottledOcclusionQueries ; TSet<FPrimitiveOcclusionHistory,FPrimitiveOcclusionHistoryKeyFuncs>& PrimitiveOcclusionHistorySet ; } ; protected : uint32 SubIsOccludedPageSize = 1 0 2 4 ; FVisibilityViewPacket& ViewPacket ; FViewInfo& View ; FSceneViewState& ViewState ; FViewElementPDI& ViewElementPDI ; FHZBOcclusionTester& HZBOcclusionTests ; FOcclusionFeedback& OcclusionFeedback ; TSet<FPrimitiveOcclusionHistory,FPrimitiveOcclusionHistoryKeyFuncs>& PrimitiveOcclusionHistorySet ; TArray<bool>* SubIsOccluded = nullptr ; const FScene& Scene ; const FGPUOcclusionState& OcclusionState ; const FVector ViewOrigin ; const uint32 OcclusionFrameCounter ; const float PrimitiveProbablyVisibleTime ; const float CurrentRealTime ; const float NeverOcclusionTestDistanceSquared ; const bool bUseOcclusionFeedback ; const bool bNewlyConsideredBBoxExpandActive ; } ; class FGPUOcclusion { public : ~)",
    "insertText": "FGPUOcclusion()"
  },
  {
    "label": "FGPUOcclusion()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FGPUOcclusion(FVisibilityViewPacket& InViewPacket)"
  },
  {
    "label": "AddPrimitives()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddPrimitives(FPrimitiveRange PrimitiveRange)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Map(FRHICommandListImmediate& RHICmdList)"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unmap(FRHICommandListImmediate& RHICmdList)"
  },
  {
    "label": "WaitForLastOcclusionQuery()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "WaitForLastOcclusionQuery()"
  },
  {
    "label": "FGPUOcclusionParallelPacket()",
    "kind": "Method",
    "detail": "Function (FGlobalDynamicVertexBuffer DynamicVertexBuffer ; FVisibilityViewPacket& ViewPacket ; const FScene& Scene ; FViewInfo& View ; FSceneViewState& ViewState ; FGPUOcclusionState State ; } ; class FGPUOcclusionParallelPacket final : public FGPUOcclusionPacket,public FSceneRenderingAllocatorObject<FGPUOcclusionParallelPacket> { public :)",
    "insertText": "FGPUOcclusionParallelPacket(FVisibilityViewPacket& InViewPacket, const FGPUOcclusionState& InOcclusionState) : FGPUOcclusionPacket(InViewPacket, InOcclusionState) , MaxInputSubQueries(InViewPacket.TaskConfig.OcclusionCull.Views[InViewPacket.ViewIndex].MaxQueriesPerTask)"
  },
  {
    "label": "AddPrimitive()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "AddPrimitive(int32 PrimitiveIndex)"
  },
  {
    "label": "OcclusionCullTask()",
    "kind": "Method",
    "detail": "Function (private : FGPUOcclusionParallel ; FOcclusionCullResult)",
    "insertText": "OcclusionCullTask(FPrimitiveIndexList& PrimitiveIndexList)"
  },
  {
    "label": "FGPUOcclusionParallel()",
    "kind": "Method",
    "detail": "Function (uint32 ArrayChunkSize = 1 0 2 4 ; const uint32 MaxInputSubQueries ; uint32 NumInputSubQueries = 0 ; TChunkedArray<int32,ArrayChunkSize,SceneRenderingAllocator> Input ; FRecordVisitor RecordVisitor ; UE::Tasks::FTask Task ; bool bTaskLaunched = false ; } ; class FGPUOcclusionParallel final : public FGPUOcclusion { public :)",
    "insertText": "FGPUOcclusionParallel(FVisibilityViewPacket& InViewPacket) : FGPUOcclusion(InViewPacket) , MaxNonOccludedPrimitives(ViewPacket.TaskConfig.Relevance.NumPrimitivesPerPacket)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (NonOccludedPrimitives .)",
    "insertText": "Reserve(MaxNonOccludedPrimitives)"
  },
  {
    "label": "CreateOcclusionPacket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateOcclusionPacket()"
  },
  {
    "label": "FGPUOcclusionParallel()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FGPUOcclusionParallel()"
  },
  {
    "label": "Finish()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Finish(UE::Tasks::FTaskEvent& OcclusionCullTasks)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Map(FRHICommandListImmediate& RHICmdListImmediate)"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unmap(FRHICommandListImmediate& RHICmdListImmediate)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (Packets .)",
    "insertText": "Emplace(new FGPUOcclusionParallelPacket(ViewPacket, State))"
  },
  {
    "label": "FGPUOcclusionSerial()",
    "kind": "Method",
    "detail": "Function (} const uint32 MaxNonOccludedPrimitives ; TArray<FGPUOcclusionParallelPacket*,SceneRenderingAllocator> Packets ; FPrimitiveIndexList NonOccludedPrimitives ; FRHICommandList* RHICmdList = nullptr ; UE::Tasks::FTaskEvent FinalizeTask { UE_SOURCE_LOCATION } ; bool bFinished = false ; bool bFinalized = false ; } ; class FGPUOcclusionSerial final : public FGPUOcclusion { public :)",
    "insertText": "FGPUOcclusionSerial(FVisibilityViewPacket& InViewPacket) : FGPUOcclusion(InViewPacket) , Packet(InViewPacket, State) , ProcessVisitor(Packet, FRHICommandListExecutor::GetImmediateCommandList(), DynamicVertexBuffer)"
  }
]