[
  {
    "label": "LazilyDeallocatedDeque",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LazilyDeallocatedDeque"
  },
  {
    "label": "Ring",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Ring"
  },
  {
    "label": "Iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Iterator"
  },
  {
    "label": "TimeTicks()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TASK_SEQUENCE_MANAGER_LAZILY_DEALLOCATED_DEQUE_H_ # define BASE_TASK_SEQUENCE_MANAGER_LAZILY_DEALLOCATED_DEQUE_H_ # include<algorithm> # include<cmath> # include<memory> # include<utility> # include<vector> # include \" base / check . h \" # include \" base / check_op . h \" # include \" base / debug / alias . h \" # include \" base / gtest_prod_util . h \" # include \" base / memory / raw_ptr . h \" # include \" base / memory / raw_ptr_exclusion . h \" # include \" base / time / time . h \" namespace base { namespace sequence_manager { namespace internal { template<T,)",
    "insertText": "TimeTicks(*now_source)()"
  },
  {
    "label": "LazilyDeallocatedDeque()",
    "kind": "Method",
    "detail": "Function (public : enum { kMinimumRingSize = 4,kReclaimThreshold = 1 6,kMinimumShrinkIntervalInSeconds = 5 } ;)",
    "insertText": "LazilyDeallocatedDeque()"
  },
  {
    "label": "LazilyDeallocatedDeque()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LazilyDeallocatedDeque(const LazilyDeallocatedDeque&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (LazilyDeallocatedDeque&)",
    "insertText": "operator(const LazilyDeallocatedDeque&)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t capacity = 0 ;)",
    "insertText": "for(const Ring* iter = head_.get(); iter; iter = iter->next_.get())"
  },
  {
    "label": "capacity()",
    "kind": "Method",
    "detail": "Function (capacity + = iter ->)",
    "insertText": "capacity()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (head_ =)",
    "insertText": "move(head_->next_)"
  },
  {
    "label": "push_front()",
    "kind": "Method",
    "detail": "Function (} tail_ = nullptr ; size_ = 0 ; } void)",
    "insertText": "push_front(T t)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!tail_)"
  },
  {
    "label": "Ring()",
    "kind": "Method",
    "detail": "Function (head_ = std::make_unique<)",
    "insertText": "Ring(kMinimumRingSize)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (tail_ = head_ .)",
    "insertText": "get()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!head_->CanPush())"
  },
  {
    "label": "Alias()",
    "kind": "Method",
    "detail": "Function (size_t size = size_ ; base::)",
    "insertText": "Alias(&size)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (new_ring -> next_ =)",
    "insertText": "move(head_)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (head_ =)",
    "insertText": "move(new_ring)"
  },
  {
    "label": "push_front()",
    "kind": "Method",
    "detail": "Function (} head_ ->)",
    "insertText": "push_front(std::move(t))"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (max_size_ =)",
    "insertText": "max(max_size_, ++size_)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_back(T t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!tail_->CanPush())"
  },
  {
    "label": "Ring()",
    "kind": "Method",
    "detail": "Function (tail_ -> next_ = std::make_unique<)",
    "insertText": "Ring(2 + tail_->capacity() + (tail_->capacity() / 2))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} tail_ ->)",
    "insertText": "push_back(std::move(t))"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "front()"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(head_)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "back()"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(tail_)"
  },
  {
    "label": "pop_front()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pop_front()"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!head_->empty())"
  },
  {
    "label": "DCHECK_GT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_GT(size_, 0u)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} - - size_ ; } void)",
    "insertText": "swap(LazilyDeallocatedDeque& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(head_, other.head_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(tail_, other.tail_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(size_, other.size_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(max_size_, other.max_size_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(next_resize_time_, other.next_resize_time_)"
  },
  {
    "label": "MaybeShrinkQueue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MaybeShrinkQueue()"
  },
  {
    "label": "DCHECK_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_GE(max_size_, size_)"
  },
  {
    "label": "now_source()",
    "kind": "Method",
    "detail": "Function (TimeTicks current_time =)",
    "insertText": "now_source()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t new_capacity = max_size_ + 1 ;)",
    "insertText": "if(new_capacity < kMinimumRingSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (max_size_ = size_ ;)",
    "insertText": "if(new_capacity + kReclaimThreshold >= capacity())"
  },
  {
    "label": "SetCapacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCapacity(new_capacity)"
  },
  {
    "label": "Seconds()",
    "kind": "Method",
    "detail": "Function (next_resize_time_ = current_time +)",
    "insertText": "Seconds(kMinimumShrinkIntervalInSeconds)"
  },
  {
    "label": "SetCapacity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCapacity(size_t new_capacity)"
  },
  {
    "label": "Ring()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<Ring> new_ring = std::make_unique<)",
    "insertText": "Ring(new_capacity)"
  },
  {
    "label": "DCHECK_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_GE(new_capacity, size_ + 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (size_t real_size = size_ ;)",
    "insertText": "while(!empty())"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(new_ring->CanPush())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (new_ring ->)",
    "insertText": "push_back(std::move(head_->front()))"
  },
  {
    "label": "DCHECK_EQ()",
    "kind": "Method",
    "detail": "Function (} size_ = real_size ;)",
    "insertText": "DCHECK_EQ(head_.get(), tail_)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(LazilyDeallocatedDequeTest, RingPushFront)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(LazilyDeallocatedDequeTest, RingPushBack)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(LazilyDeallocatedDequeTest, RingCanPush)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(LazilyDeallocatedDequeTest, RingPushPopPushPop)"
  },
  {
    "label": "Ring()",
    "kind": "Method",
    "detail": "Function (struct Ring {)",
    "insertText": "Ring(size_t capacity) : capacity_(capacity), front_index_(0), back_index_(0), data_(reinterpret_cast<T*>(new char[sizeof(T) * capacity])), next_(nullptr)"
  },
  {
    "label": "DCHECK_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_GE(capacity_, kMinimumRingSize)"
  },
  {
    "label": "Ring()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Ring(const Ring&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ring&)",
    "insertText": "operator(const Ring&)"
  },
  {
    "label": "Ring()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "Ring()"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (} char* memory = reinterpret_cast<)",
    "insertText": "char(data_.get())"
  },
  {
    "label": "push_front()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_front(T&& t)"
  },
  {
    "label": "DCHECK_NE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_NE(CircularDecrement(front_index_), back_index_)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&data_[front_index_]) T(std::move(t))"
  },
  {
    "label": "CircularDecrement()",
    "kind": "Method",
    "detail": "Function (front_index_ =)",
    "insertText": "CircularDecrement(front_index_)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_back(T&& t)"
  },
  {
    "label": "CircularIncrement()",
    "kind": "Method",
    "detail": "Function (back_index_ =)",
    "insertText": "CircularIncrement(back_index_)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!empty())"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&data_[back_index_]) T(std::move(t))"
  },
  {
    "label": "CanPop()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CanPop()"
  },
  {
    "label": "CircularIncrement()",
    "kind": "Method",
    "detail": "Function (front_index_ =)",
    "insertText": "CircularIncrement(front_index_)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (data_ [ front_index_ ] . ~)",
    "insertText": "T()"
  },
  {
    "label": "DCHECK_LT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_LT(index, capacity_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + index ;)",
    "insertText": "if(index == capacity_)"
  },
  {
    "label": "CircularIncrement()",
    "kind": "Method",
    "detail": "Function (index_ = ring_ ? ring_ ->)",
    "insertText": "CircularIncrement(ring_->front_index_)"
  },
  {
    "label": "CircularIncrement()",
    "kind": "Method",
    "detail": "Function (} else { index_ = ring_ ->)",
    "insertText": "CircularIncrement(index_)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} return* this ; } operator)",
    "insertText": "bool()"
  },
  {
    "label": "CircularIncrement()",
    "kind": "Method",
    "detail": "Function (ring_ = nullptr ; index_ = 0 ; return ; } ring_ = ring ; index_ = ring_ ->)",
    "insertText": "CircularIncrement(ring->front_index_)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} raw_ptr<const Ring> ring_ ; size_t index_ ; class LazilyDeallocatedDeque ; } ; Iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} Iterator)",
    "insertText": "end()"
  }
]