[
  {
    "label": "PseudoIndexWrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PseudoIndexWrapper"
  },
  {
    "label": "hash",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "hash"
  },
  {
    "label": "Iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Iterator"
  },
  {
    "label": "NVCORE_CLASS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NVCORE_CLASS"
  },
  {
    "label": "Entry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Entry"
  },
  {
    "label": "NV_FOREACH()",
    "kind": "Method",
    "detail": "Function (# ifndef NV_CORE_CONTAINER_H # define NV_CORE_CONTAINER_H # include<nvcore / nvcore . h> # include<nvcore / Memory . h> # include<nvcore / Debug . h> # include<string . h> # include<new> # if NV_CC_GNUC # define)",
    "insertText": "NV_FOREACH(i, container) \\ typedef typeof(container) NV_STRING_JOIN2(cont,__LINE__)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "for(NV_STRING_JOIN2(cont,__LINE__)::PseudoIndex i((container).start()); !(container).isDone(i); (container).advance(i))"
  },
  {
    "label": "PseudoIndexWrapper()",
    "kind": "Method",
    "detail": "Function (template<T>)",
    "insertText": "PseudoIndexWrapper(const T & container)"
  },
  {
    "label": "nvStaticCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvStaticCheck(sizeof(typename T::PseudoIndex) <= sizeof(memory))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(memory) typename T::PseudoIndex(container.start())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> T::PseudoIndex&)",
    "insertText": "operator()(const T * container)"
  },
  {
    "label": "NV_FOREACH()",
    "kind": "Method",
    "detail": "Function (} uint8 memory [ 4 ] ; } ; # define)",
    "insertText": "NV_FOREACH(i, container) \\ for(PseudoIndexWrapper i(container); !(container).isDone(i(&(container))); (container).advance(i(&(container))))"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (template<T> const T&)",
    "insertText": "max(const T & a, const T & b)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "swap(T & a, T & b)"
  },
  {
    "label": "sdbm_hash()",
    "kind": "Method",
    "detail": "Function (T temp = a ; a = b ; b = temp ; } template<Key> struct hash { uint)",
    "insertText": "sdbm_hash(const void * data_in, uint size, uint h = 5381)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (const uint8*)",
    "insertText": "data(const uint8 *)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (uint i = 0 ;)",
    "insertText": "while(i < size)"
  },
  {
    "label": "h()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "h(h << 16) + (h << 6) - h + (uint)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return h ; } uint)",
    "insertText": "operator()(const Key & k)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct hash<int> { uint)",
    "insertText": "operator()(int x)"
  },
  {
    "label": "nextPowerOfTwo()",
    "kind": "Method",
    "detail": "Function (delete container [ i ] ; } } uint)",
    "insertText": "nextPowerOfTwo(uint x)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(x != 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# if 1 x - - ; x | = x>> 1 ; x | = x>> 2 ; x | = x>> 4 ; x | = x>> 8 ; x | = x>> 1 6 ; return x + 1 ; # else uint p = 1 ;)",
    "insertText": "while(x > p)"
  },
  {
    "label": "isPowerOfTwo()",
    "kind": "Method",
    "detail": "Function (p + = p ; } return p ; # endif } bool)",
    "insertText": "isPowerOfTwo(uint n)"
  },
  {
    "label": "advance()",
    "kind": "Method",
    "detail": "Function (} template<T> struct Iterator { void)",
    "insertText": "advance()"
  },
  {
    "label": "isDone()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isDone()"
  },
  {
    "label": "current()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "current()"
  },
  {
    "label": "Array()",
    "kind": "Method",
    "detail": "Function (} ; template<T> class NVCORE_CLASS Array { public :)",
    "insertText": "Array() : m_buffer(NULL), m_size(0), m_buffer_size(0)"
  },
  {
    "label": "Array()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Array(const Array & a ) : m_buffer(NULL), m_size(0), m_buffer_size(0)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(a.m_buffer, a.m_size)"
  },
  {
    "label": "Array()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Array(const T * ptr, int num ) : m_buffer(NULL), m_size(0), m_buffer_size(0)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(ptr, num)"
  },
  {
    "label": "Array()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Array(uint capacity) : m_buffer(NULL), m_size(0), m_buffer_size(0)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "allocate(capacity)"
  },
  {
    "label": "Array()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "Array()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "allocate(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const T&)",
    "insertText": "operator(uint index)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(index < m_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint new_size = m_size + 1 ;)",
    "insertText": "if(new_size > m_buffer_size)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (const T)",
    "insertText": "copy(val)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(new_size)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (m_buffer [ new_size - 1 ] = copy ; } else { m_size = new_size ;)",
    "insertText": "new(m_buffer+new_size-1) T(val)"
  },
  {
    "label": "pushBack()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "pushBack(const T & val)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "push_back(val)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "append(const T & val)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Array<T>&)",
    "insertText": "operator(T & t)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "push_back(t)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(m_size > 0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(m_size - 1)"
  },
  {
    "label": "popBack()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "popBack()"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pop_back()"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} const T&)",
    "insertText": "back()"
  },
  {
    "label": "removeAt()",
    "kind": "Method",
    "detail": "Function (} return false ; } void)",
    "insertText": "removeAt(uint index)"
  },
  {
    "label": "nvCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvCheck(index >= 0 && index < m_size)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else { m_buffer [ index ] . ~)",
    "insertText": "T()"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(m_buffer+index, m_buffer+index+1, sizeof(T) * (m_size - 1 - index))"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (m_size - - ; } } void)",
    "insertText": "remove(const T & element)"
  },
  {
    "label": "removeAt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "removeAt(i)"
  },
  {
    "label": "insertAt()",
    "kind": "Method",
    "detail": "Function (break ; } } void)",
    "insertText": "insertAt(uint index, const T & val = T())"
  },
  {
    "label": "nvCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvCheck(index >= 0 && index <= m_size)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(m_size + 1)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(m_buffer+index+1, m_buffer+index, sizeof(T) * (m_size - 1 - index))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "new(m_buffer+index) T(val)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "append(const Array<T> & other)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "append(other.m_buffer, other.m_size)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "append(const T other[], uint count)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (const uint old_size = m_size ;)",
    "insertText": "resize(m_size + count)"
  },
  {
    "label": "replaceWithLast()",
    "kind": "Method",
    "detail": "Function (m_buffer [ old_size + i ] = other [ i ] ; } } } void)",
    "insertText": "replaceWithLast(uint index)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_size - - ; } void)",
    "insertText": "resize(uint new_size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (uint i ; uint old_size = m_size ; m_size = new_size ;)",
    "insertText": "for(i = new_size; i < old_size; i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_size == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(m_size <= m_buffer_size)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(m_buffer != NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { uint new_buffer_size ;)",
    "insertText": "if(m_buffer_size == 0)"
  },
  {
    "label": "m_size()",
    "kind": "Method",
    "detail": "Function (new_buffer_size = m_size ; } else { new_buffer_size =)",
    "insertText": "m_size(m_size >> 2)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "allocate(new_buffer_size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = old_size; i < new_size; i++)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(m_buffer+i)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "resize(uint new_size, const T &elem)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(m_size <= m_buffer_size && m_size > m_buffer_size >> 1)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(m_buffer+i) T( elem)"
  },
  {
    "label": "tighten()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "tighten()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(0)"
  },
  {
    "label": "shrink()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "shrink()"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "allocate(m_size)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "reserve(uint desired_size)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "allocate(desired_size)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "copy(const T * ptr, uint num)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(num)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (m_buffer [ i ] = ptr [ i ] ; } } void)",
    "insertText": "operator(const Array<T> & a)"
  },
  {
    "label": "start()",
    "kind": "Method",
    "detail": "Function (} typedef uint PseudoIndex ; PseudoIndex)",
    "insertText": "start()"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(i <= this->m_size)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (i + + ; } # if NV_CC_MSVC T&)",
    "insertText": "operator(const PseudoIndexWrapper & i)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "swap(Array<T> & a, Array<T> & b)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(a.m_buffer, b.m_buffer)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(a.m_size, b.m_size)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(a.m_buffer_size, b.m_buffer_size)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "allocate(uint rsize)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(m_buffer)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_buffer = NULL ; } } else {)",
    "insertText": "if(m_buffer ) m_buffer = (T *) mem::realloc( m_buffer, sizeof(T) * m_buffer_size)"
  },
  {
    "label": "NV_FORBID_COPY()",
    "kind": "Method",
    "detail": "Function (} } private : T* m_buffer ; uint m_size ; uint m_buffer_size ; } ; template<T,U,hash_functor = hash<T>> class NVCORE_CLASS HashMap {)",
    "insertText": "NV_FORBID_COPY(HashMap) public: HashMap() : entry_count(0), size_mask(-1), table(NULL)"
  },
  {
    "label": "HashMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "HashMap(int size_hint) : entry_count(0), size_mask(-1), table(NULL)"
  },
  {
    "label": "setCapacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setCapacity(size_hint)"
  },
  {
    "label": "HashMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "HashMap()"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set(const T& key, const U& value)"
  },
  {
    "label": "findIndex()",
    "kind": "Method",
    "detail": "Function (int index =)",
    "insertText": "findIndex(key)"
  },
  {
    "label": "E()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "E(index)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "add(const T& key, const U& value)"
  },
  {
    "label": "nvCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvCheck(findIndex(key) == -1)"
  },
  {
    "label": "nvCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvCheck(table != NULL)"
  },
  {
    "label": "hash_functor()",
    "kind": "Method",
    "detail": "Function (entry_count + + ; const uint hash_value =)",
    "insertText": "hash_functor()(key)"
  },
  {
    "label": "natural_entry()",
    "kind": "Method",
    "detail": "Function (const int index = hash_value& size_mask ; Entry*)",
    "insertText": "natural_entry(E(index))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(natural_entry) Entry(key, value, -1, hash_value)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else { int blank_index = index ;)",
    "insertText": "for(;;)"
  },
  {
    "label": "blank_index()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "blank_index(blank_index + 1)"
  },
  {
    "label": "E()",
    "kind": "Method",
    "detail": "Function (} Entry* blank_entry =&)",
    "insertText": "E(blank_index)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(blank_entry) Entry(*natural_entry)"
  },
  {
    "label": "E()",
    "kind": "Method",
    "detail": "Function (Entry* e =&)",
    "insertText": "E(collided_index)"
  },
  {
    "label": "nvCheck()",
    "kind": "Method",
    "detail": "Function (e -> next_in_chain = blank_index ; break ; } collided_index = e -> next_in_chain ;)",
    "insertText": "nvCheck(collided_index >= 0 && collided_index <= size_mask)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (} natural_entry -> key = key ; natural_entry -> value = value ; natural_entry -> hash_value = hash_value ; natural_entry -> next_in_chain = - 1 ; } } } bool)",
    "insertText": "remove(const T& key)"
  },
  {
    "label": "E()",
    "kind": "Method",
    "detail": "Function (} else { Entry& next_entry =)",
    "insertText": "E(entry->next_in_chain)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(entry) Entry(next_entry)"
  },
  {
    "label": "E()",
    "kind": "Method",
    "detail": "Function (Entry* e =&)",
    "insertText": "E(i)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "free(table)"
  },
  {
    "label": "isEmpty()",
    "kind": "Method",
    "detail": "Function (table = NULL ; entry_count = 0 ; size_mask = - 1 ; } } bool)",
    "insertText": "isEmpty()"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (} return true ; } return false ; } bool)",
    "insertText": "contains(const T & key)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "size()"
  },
  {
    "label": "checkExpand()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "checkExpand()"
  },
  {
    "label": "setRawCapacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setRawCapacity(16)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(entry_count * 3 > (size_mask + 1) * 2)"
  },
  {
    "label": "setRawCapacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setRawCapacity(entry_count * 2)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "resize(int n)"
  },
  {
    "label": "setCapacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setCapacity(n)"
  },
  {
    "label": "setCapacity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setCapacity(int new_size)"
  },
  {
    "label": "new_raw_size()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "new_raw_size(new_size * 3)"
  },
  {
    "label": "Entry()",
    "kind": "Method",
    "detail": "Function (} struct Entry { int next_in_chain ; uint hash_value ; T key ; U value ;)",
    "insertText": "Entry() : next_in_chain(-2)"
  },
  {
    "label": "Entry()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Entry(const Entry& e) : next_in_chain(e.next_in_chain), hash_value(e.hash_value), key(e.key), value(e.value)"
  },
  {
    "label": "Entry()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Entry(const T& k, const U& v, int next, int hash) : next_in_chain(next), hash_value(hash), key(k), value(v)"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (value . ~)",
    "insertText": "U()"
  },
  {
    "label": "findNext()",
    "kind": "Method",
    "detail": "Function (PseudoIndex i = 0 ;)",
    "insertText": "findNext(i)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(i <= size_mask+1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # if NV_CC_GNUC Entry&)",
    "insertText": "operator(const PseudoIndex & i)"
  },
  {
    "label": "findIndex()",
    "kind": "Method",
    "detail": "Function (} # endif private : int)",
    "insertText": "findIndex(const T& key)"
  },
  {
    "label": "nvCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvCheck((e->hash_value & size_mask) == (hash_value & size_mask))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (index = e -> next_in_chain ;)",
    "insertText": "if(index == -1)"
  },
  {
    "label": "nvCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvCheck(index >= 0 && index <= size_mask)"
  },
  {
    "label": "nvCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvCheck(e->isEmpty() == false)"
  },
  {
    "label": "E()",
    "kind": "Method",
    "detail": "Function (} return - 1 ; } Entry&)",
    "insertText": "E(int index)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(table != NULL)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(index >= 0 && index <= size_mask)"
  },
  {
    "label": "table()",
    "kind": "Method",
    "detail": "Function (HashMap<T,U,hash_functor> new_hash ; new_hash .)",
    "insertText": "table(Entry *) mem::malloc(sizeof(Entry) * new_size)"
  },
  {
    "label": "nvDebugCheck()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "nvDebugCheck(new_hash.table != NULL)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (new_hash . entry_count = 0 ; new_hash . size_mask = new_size - 1 ;)",
    "insertText": "for(int i = 0; i < new_size; i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(table != NULL)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (new_hash .)",
    "insertText": "add(e->key, e->value)"
  },
  {
    "label": "findNext()",
    "kind": "Method",
    "detail": "Function (} entry_count = new_hash . entry_count ; size_mask = new_hash . size_mask ; table = new_hash . table ; new_hash . entry_count = 0 ; new_hash . size_mask = - 1 ; new_hash . table = NULL ; } void)",
    "insertText": "findNext(PseudoIndex & i)"
  }
]