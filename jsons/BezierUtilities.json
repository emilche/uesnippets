[
  {
    "label": "Eval()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Math / Vector . h \" # include \" Math / Box . h \" # include \" Math / UnrealMathUtility . h \" namespace UE { namespace CubicBezier { FVector)",
    "insertText": "Eval(const FVector& P0, const FVector& P1, const FVector& P2, const FVector& P3, const float t)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (const FVector P01 =)",
    "insertText": "Lerp(P0, P1, t)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (const FVector P12 =)",
    "insertText": "Lerp(P1, P2, t)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (const FVector P23 =)",
    "insertText": "Lerp(P2, P3, t)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (const FVector P012 =)",
    "insertText": "Lerp(P01, P12, t)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (const FVector P123 =)",
    "insertText": "Lerp(P12, P23, t)"
  },
  {
    "label": "EvalDerivate()",
    "kind": "Method",
    "detail": "Function (} FVector)",
    "insertText": "EvalDerivate(const FVector& P0, const FVector& P1, const FVector& P2, const FVector& P3, const float t)"
  },
  {
    "label": "SplitAt()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SplitAt(const FVector& P0, const FVector& P1, const FVector& P2, const FVector& P3, const float t, FVector OutResult[5])"
  },
  {
    "label": "CalcBounds()",
    "kind": "Method",
    "detail": "Function (FBox)",
    "insertText": "CalcBounds(const FVector& P0, const FVector& P1, const FVector& P2, const FVector& P3)"
  },
  {
    "label": "ClosestPointApproximate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClosestPointApproximate(const FVector& FromPoint, const FVector& P0, const FVector& P1, const FVector& P2, const FVector& P3, FVector& OutClosestPoint, float& OutClosestT, const int Steps = 16)"
  },
  {
    "label": "SegmentClosestPointApproximate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SegmentClosestPointApproximate(const FVector& SegStart, const FVector& SegEnd, const FVector& P0, const FVector& P1, const FVector& P2, const FVector& P3, FVector& OutClosestPoint, float& OutClosestT, const int Steps = 16)"
  },
  {
    "label": "ArcLengthApproximate()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "ArcLengthApproximate(const FVector& P0, const FVector& P1, const FVector& P2, const FVector& P3)"
  },
  {
    "label": "Tessellate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Tessellate(TArray<FVector>& Output, const FVector& P0, const FVector& P1, const FVector& P2, const FVector& P3, const float Tolerance, const int MaxLevel = 6)"
  }
]