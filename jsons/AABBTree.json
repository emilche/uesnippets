[
  {
    "label": "FAABBTreeCVars",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAABBTreeCVars"
  },
  {
    "label": "FAABBTreeDirtyGridCVars",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAABBTreeDirtyGridCVars"
  },
  {
    "label": "FAABBTimeSliceCVars",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAABBTimeSliceCVars"
  },
  {
    "label": "FChaosVDDataWrapperUtils",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosVDDataWrapperUtils"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "AABBTreeStatistics",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AABBTreeStatistics"
  },
  {
    "label": "AABBTreeExpensiveStatistics",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AABBTreeExpensiveStatistics"
  },
  {
    "label": "CIsUpdatableElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CIsUpdatableElement"
  },
  {
    "label": "TAABBTreeIntersectionHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAABBTreeIntersectionHelper"
  },
  {
    "label": "TBoundsWrapperHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TBoundsWrapperHelper"
  },
  {
    "label": "TAABBTreeLeafArray",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAABBTreeLeafArray"
  },
  {
    "label": "TLeafContainer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TLeafContainer"
  },
  {
    "label": "TAABBTreeNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAABBTreeNode"
  },
  {
    "label": "FAABBTreePayloadInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAABBTreePayloadInfo"
  },
  {
    "label": "DirtyGridHashEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DirtyGridHashEntry"
  },
  {
    "label": "TDefaultAABBTreeStorageTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TDefaultAABBTreeStorageTraits"
  },
  {
    "label": "TAABBTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TAABBTree"
  },
  {
    "label": "EmptyInit",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EmptyInit"
  },
  {
    "label": "FElementsCollection",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FElementsCollection"
  },
  {
    "label": "NodeAndLeafIndices",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NodeAndLeafIndices"
  },
  {
    "label": "FNodeQueueEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNodeQueueEntry"
  },
  {
    "label": "eTimeSlicePhase",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "eTimeSlicePhase"
  },
  {
    "label": "FSplitInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSplitInfo"
  },
  {
    "label": "FWorkSnapshot",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FWorkSnapshot"
  },
  {
    "label": "FSimpleVisitor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSimpleVisitor"
  },
  {
    "label": "CSV_DECLARE_CATEGORY_EXTERN()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / AABB . h \" # include \" Chaos / AABBVectorized . h \" # include \" Chaos / AABBVectorizedDouble . h \" # include \" Chaos / AABBTreeDirtyGridUtils . h \" # include \" Chaos / Defines . h \" # include \" Chaos / GeometryParticles . h \" # include \" Chaos / Transform . h \" # include \" ChaosLog . h \" # include \" Chaos / ISpatialAcceleration . h \" # include \" Templates / Models . h \" # include \" Chaos / BoundingVolume . h \" # include \" ProfilingDebugging / CsvProfiler . h \" # include \" ChaosStats . h \" # include \" Math / VectorRegister . h \" # include<type_traits> # ifndef CHAOS_DEBUG_NAME # define CHAOS_DEBUG_NAME 0 # endif)",
    "insertText": "CSV_DECLARE_CATEGORY_EXTERN(ChaosPhysicsTimers)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (struct FAABBTreeCVars { int32 UpdateDirtyElementPayloadData ; FAutoConsoleVariableRef CVarUpdateDirtyElementPayloadData ; int32 SplitAtAverageCenter ; FAutoConsoleVariableRef CVarSplitAtAverageCenter ; int32 SplitOnVarianceAxis ; FAutoConsoleVariableRef CVarSplitOnVarianceAxis ; float DynamicTreeBoundingBoxPadding ; FAutoConsoleVariableRef CVarDynamicTreeBoundingBoxPadding ; int32 DynamicTreeLeafCapacity ; FAutoConsoleVariableRef CVarDynamicTreeLeafCapacity ; } ; struct FAABBTreeDirtyGridCVars { int32 DirtyElementGridCellSize ; FAutoConsoleVariableRef CVarDirtyElementGridCellSize ; int32 DirtyElementMaxGridCellQueryCount ; FAutoConsoleVariableRef CVarDirtyElementMaxGridCellQueryCount ; int32 DirtyElementMaxPhysicalSizeInCells ; FAutoConsoleVariableRef CVarDirtyElementMaxPhysicalSizeInCells ; int32 DirtyElementMaxCellCapacity ; FAutoConsoleVariableRef CVarDirtyElementMaxCellCapacity ; } ; struct FAABBTimeSliceCVars { bool bUseTimeSliceMillisecondBudget ; FAutoConsoleVariableRef CVarUseTimeSliceByMillisecondBudget ; float MaxProcessingTimePerSliceSeconds ; FAutoConsoleVariableRef CVarMaxProcessingTimePerSlice ; int32 MinNodesChunkToProcessBetweenTimeChecks ; FAutoConsoleVariableRef CVarMinNodesChunkToProcessBetweenTimeChecks ; int32 MinDataChunkToProcessBetweenTimeChecks ; FAutoConsoleVariableRef CVarMinDataChunkToProcessBetweenTimeChecks ; } ; class FChaosVDDataWrapperUtils ; namespace Chaos { enum class EAABBQueryType { Raycast,Sweep,Overlap } ; struct AABBTreeStatistics { void)",
    "insertText": "Reset()"
  },
  {
    "label": "MergeStatistics()",
    "kind": "Method",
    "detail": "Function (StatNumNonEmptyCellsInGrid = 0 ; StatNumElementsTooLargeForGrid = 0 ; StatNumDirtyElements = 0 ; StatNumGridOverflowElements = 0 ; } AABBTreeStatistics&)",
    "insertText": "MergeStatistics(const AABBTreeStatistics& Rhs)"
  },
  {
    "label": "MergeStatistics()",
    "kind": "Method",
    "detail": "Function (StatMaxNumLeaves = 0 ; StatMaxDirtyElements = 0 ; StatMaxLeafSize = 0 ; StatMaxTreeDepth = 0 ; StatGlobalPayloadsSize = 0 ; } AABBTreeExpensiveStatistics&)",
    "insertText": "MergeStatistics(const AABBTreeExpensiveStatistics& Rhs)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (StatMaxNumLeaves =)",
    "insertText": "Max(StatMaxNumLeaves, Rhs.StatMaxNumLeaves)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (StatMaxDirtyElements =)",
    "insertText": "Max(StatMaxDirtyElements, Rhs.StatMaxDirtyElements)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (StatMaxLeafSize =)",
    "insertText": "Max(StatMaxLeafSize, Rhs.StatMaxLeafSize)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (StatMaxTreeDepth =)",
    "insertText": "Max(StatMaxTreeDepth, Rhs.StatMaxTreeDepth)"
  },
  {
    "label": "DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (StatGlobalPayloadsSize + = Rhs . StatGlobalPayloadsSize ; return* this ; } int32 StatMaxNumLeaves = 0 ; int32 StatMaxDirtyElements = 0 ; int32 StatMaxLeafSize = 0 ; int32 StatMaxTreeDepth = 0 ; int32 StatGlobalPayloadsSize = 0 ; } ;)",
    "insertText": "DECLARE_CYCLE_STAT(TEXT(\"AABBTreeGenerateTree\"), STAT_AABBTreeGenerateTree, STATGROUP_Chaos)"
  },
  {
    "label": "DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT(TEXT(\"AABBTreeTimeSliceSetup\"), STAT_AABBTreeTimeSliceSetup, STATGROUP_Chaos)"
  },
  {
    "label": "DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT(TEXT(\"AABBTreeInitialTimeSlice\"), STAT_AABBTreeInitialTimeSlice, STATGROUP_Chaos)"
  },
  {
    "label": "DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT(TEXT(\"AABBTreeProgressTimeSlice\"), STAT_AABBTreeProgressTimeSlice, STATGROUP_Chaos)"
  },
  {
    "label": "Requires()",
    "kind": "Method",
    "detail": "Function (struct CIsUpdatableElement { template<ElementT> auto)",
    "insertText": "Requires(ElementT& InElem, const ElementT& InOtherElem) -> decltype(InElem.UpdateFrom(InOtherElem))"
  },
  {
    "label": "UpdateElementHelper()",
    "kind": "Method",
    "detail": "Function (} ; template<T,TEnableIf<! TModels_V<CIsUpdatableElement,T>>::Type* = nullptr> void)",
    "insertText": "UpdateElementHelper(T& InElem, const T& InFrom)"
  },
  {
    "label": "UpdateFrom()",
    "kind": "Method",
    "detail": "Function (InElem .)",
    "insertText": "UpdateFrom(InFrom)"
  },
  {
    "label": "Intersects()",
    "kind": "Method",
    "detail": "Function (} } template<TQueryFastData,EAABBQueryType Query> struct TAABBTreeIntersectionHelper { bool)",
    "insertText": "Intersects(const FVec3& Start, TQueryFastData& QueryFastData, FReal& TOI, const FAABB3& Bounds, const FAABB3& QueryBounds, const FVec3& QueryHalfExtents, const FVec3& Dir, const FVec3 InvDir, const bool bParallel[3])"
  },
  {
    "label": "RaycastFast()",
    "kind": "Method",
    "detail": "Function (FReal TmpExitTime ; return Bounds .)",
    "insertText": "RaycastFast(Start, Dir, InvDir, bParallel, QueryFastData.CurrentLength, QueryFastData.InvCurrentLength, TOI, TmpExitTime)"
  },
  {
    "label": "Intersects()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct TAABBTreeIntersectionHelper<FQueryFastData,EAABBQueryType::Sweep> { bool)",
    "insertText": "Intersects(const FVec3& Start, FQueryFastData& QueryFastData, FReal& TOI, const FAABB3& Bounds, const FAABB3& QueryBounds, const FVec3& QueryHalfExtents, const FVec3& Dir, const FVec3 InvDir, const bool bParallel[3])"
  },
  {
    "label": "SweepBounds()",
    "kind": "Method",
    "detail": "Function (FAABB3)",
    "insertText": "SweepBounds(Bounds.Min() - QueryHalfExtents, Bounds.Max() + QueryHalfExtents)"
  },
  {
    "label": "Intersects()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct TAABBTreeIntersectionHelper<FQueryFastDataVoid,EAABBQueryType::Overlap> { bool)",
    "insertText": "Intersects(const FVec3& Start, FQueryFastDataVoid& QueryFastData, FReal& TOI, const FAABB3& Bounds, const FAABB3& QueryBounds, const FVec3& QueryHalfExtents, const FVec3& Dir, const FVec3 InvDir, const bool bParallel[3])"
  },
  {
    "label": "ComputeBounds()",
    "kind": "Method",
    "detail": "Function (} } ; template<TPayloadType,T,bool bComputeBounds> struct TBoundsWrapperHelper { } ; template<TPayloadType,T> struct TBoundsWrapperHelper<TPayloadType,T,true> { void)",
    "insertText": "ComputeBounds(const TArray<TPayloadBoundsElement<TPayloadType, T>>& Elems)"
  },
  {
    "label": "EmptyAABB()",
    "kind": "Method",
    "detail": "Function (Bounds = TAABB<T,3)",
    "insertText": "EmptyAABB()"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (Bounds .)",
    "insertText": "GrowToInclude(Elem.Bounds)"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (} } const TAABB<T,3>&)",
    "insertText": "GetBounds()"
  },
  {
    "label": "TAABBTreeLeafArray()",
    "kind": "Method",
    "detail": "Function (} } ; template<TPayloadType,bool bComputeBounds = true,T = FReal> struct TAABBTreeLeafArray : public TBoundsWrapperHelper<TPayloadType,T,bComputeBounds> {)",
    "insertText": "TAABBTreeLeafArray()"
  },
  {
    "label": "TAABBTreeLeafArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAABBTreeLeafArray(const TArray<TPayloadBoundsElement<TPayloadType, T>>& InElems) : Elems(InElems)"
  },
  {
    "label": "ComputeBounds()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "ComputeBounds(Elems)"
  },
  {
    "label": "GatherElements()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GatherElements(TArray<TPayloadBoundsElement<TPayloadType, T>>& OutElements)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (OutElements .)",
    "insertText": "Append(Elems)"
  },
  {
    "label": "GetReserveCount()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetReserveCount()"
  },
  {
    "label": "GetElementCount()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetElementCount()"
  },
  {
    "label": "RecomputeBounds()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RecomputeBounds()"
  },
  {
    "label": "IsLeafDirty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsLeafDirty()"
  },
  {
    "label": "RaycastFast()",
    "kind": "Method",
    "detail": "Function (bDirtyLeaf = bDirtyState ; } template<TSQVisitor,TQueryFastData> bool)",
    "insertText": "RaycastFast(const TVec3<T>& Start, TQueryFastData& QueryFastData, TSQVisitor& Visitor, const TVec3<T>& Dir, const TVec3<T>& InvDir, const bool bParallel[3])"
  },
  {
    "label": "RaycastFastSimd()",
    "kind": "Method",
    "detail": "Function (} template<TSQVisitor,TQueryFastData> bool)",
    "insertText": "RaycastFastSimd(const VectorRegister4Double& Start, TQueryFastData& QueryFastData, TSQVisitor& Visitor, const VectorRegister4Double& Dir, const VectorRegister4Double& InvDir, const VectorRegister4Double& Parallel, const VectorRegister4Double& Length)"
  },
  {
    "label": "SweepFast()",
    "kind": "Method",
    "detail": "Function (} template<TSQVisitor,TQueryFastData> bool)",
    "insertText": "SweepFast(const TVec3<T>& Start, TQueryFastData& QueryFastData, const TVec3<T>& QueryHalfExtents, TSQVisitor& Visitor, const TVec3<T>& Dir, const TVec3<T> InvDir, const bool bParallel[3])"
  },
  {
    "label": "OverlapFast()",
    "kind": "Method",
    "detail": "Function (} template<TSQVisitor> bool)",
    "insertText": "OverlapFast(const FAABB3& QueryBounds, TSQVisitor& Visitor)"
  },
  {
    "label": "PHYSICS_CSV_CUSTOM_VERY_EXPENSIVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PHYSICS_CSV_CUSTOM_VERY_EXPENSIVE(PhysicsCounters, MaxLeafSize, Elems.Num(), ECsvCustomStatOp::Max)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 NumElems = Elems .)",
    "insertText": "Num()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const int32 SimdIters = NumElems / 4 ;)",
    "insertText": "for(int32 SimdIter = 0; SimdIter < SimdIters; ++SimdIter)"
  },
  {
    "label": "MakeVectorRegisterDouble()",
    "kind": "Method",
    "detail": "Function (const int32 StartIndex = SimdIter* 4 ; VectorRegister4Double MinX =)",
    "insertText": "MakeVectorRegisterDouble(Elems[StartIndex].Bounds.Min()[0], Elems[StartIndex + 1].Bounds.Min()[0], Elems[StartIndex + 2].Bounds.Min()[0], Elems[StartIndex + 3].Bounds.Min()[0])"
  },
  {
    "label": "MakeVectorRegisterDouble()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double MaxX =)",
    "insertText": "MakeVectorRegisterDouble(Elems[StartIndex].Bounds.Max()[0], Elems[StartIndex + 1].Bounds.Max()[0], Elems[StartIndex + 2].Bounds.Max()[0], Elems[StartIndex + 3].Bounds.Max()[0])"
  },
  {
    "label": "MakeVectorRegisterDouble()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double MinY =)",
    "insertText": "MakeVectorRegisterDouble(Elems[StartIndex].Bounds.Min()[1], Elems[StartIndex + 1].Bounds.Min()[1], Elems[StartIndex + 2].Bounds.Min()[1], Elems[StartIndex + 3].Bounds.Min()[1])"
  },
  {
    "label": "MakeVectorRegisterDouble()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double MaxY =)",
    "insertText": "MakeVectorRegisterDouble(Elems[StartIndex].Bounds.Max()[1], Elems[StartIndex + 1].Bounds.Max()[1], Elems[StartIndex + 2].Bounds.Max()[1], Elems[StartIndex + 3].Bounds.Max()[1])"
  },
  {
    "label": "MakeVectorRegisterDouble()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double MinZ =)",
    "insertText": "MakeVectorRegisterDouble(Elems[StartIndex].Bounds.Min()[2], Elems[StartIndex + 1].Bounds.Min()[2], Elems[StartIndex + 2].Bounds.Min()[2], Elems[StartIndex + 3].Bounds.Min()[2])"
  },
  {
    "label": "MakeVectorRegisterDouble()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double MaxZ =)",
    "insertText": "MakeVectorRegisterDouble(Elems[StartIndex].Bounds.Max()[2], Elems[StartIndex + 1].Bounds.Max()[2], Elems[StartIndex + 2].Bounds.Max()[2], Elems[StartIndex + 3].Bounds.Max()[2])"
  },
  {
    "label": "VectorSetDouble1()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Double OtherMinX =)",
    "insertText": "VectorSetDouble1(QueryBounds.Min().X)"
  },
  {
    "label": "VectorSetDouble1()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Double OtherMinY =)",
    "insertText": "VectorSetDouble1(QueryBounds.Min().Y)"
  },
  {
    "label": "VectorSetDouble1()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Double OtherMinZ =)",
    "insertText": "VectorSetDouble1(QueryBounds.Min().Z)"
  },
  {
    "label": "VectorSetDouble1()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Double OtherMaxX =)",
    "insertText": "VectorSetDouble1(QueryBounds.Max().X)"
  },
  {
    "label": "VectorSetDouble1()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Double OtherMaxY =)",
    "insertText": "VectorSetDouble1(QueryBounds.Max().Y)"
  },
  {
    "label": "VectorSetDouble1()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Double OtherMaxZ =)",
    "insertText": "VectorSetDouble1(QueryBounds.Max().Z)"
  },
  {
    "label": "VectorBitwiseOr()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double IsFalseX =)",
    "insertText": "VectorBitwiseOr(VectorCompareGT(MinX, OtherMaxX), VectorCompareGT(OtherMinX, MaxX))"
  },
  {
    "label": "VectorBitwiseOr()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double IsFalseY =)",
    "insertText": "VectorBitwiseOr(VectorCompareGT(MinY, OtherMaxY), VectorCompareGT(OtherMinY, MaxY))"
  },
  {
    "label": "VectorBitwiseOr()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double IsFalseZ =)",
    "insertText": "VectorBitwiseOr(VectorCompareGT(MinZ, OtherMaxZ), VectorCompareGT(OtherMinZ, MaxZ))"
  },
  {
    "label": "VectorBitwiseOr()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double IsFalse =)",
    "insertText": "VectorBitwiseOr(VectorBitwiseOr(IsFalseX, IsFalseY), IsFalseZ)"
  },
  {
    "label": "VectorMaskBits()",
    "kind": "Method",
    "detail": "Function (int32 MaskBitFalse =)",
    "insertText": "VectorMaskBits(IsFalse)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const TPayloadBoundsElement<TPayloadType,T>& Elem = Elems [ StartIndex + MaskIndex ] ;)",
    "insertText": "if(PrePreFilterHelper(Elem.Payload, Visitor))"
  },
  {
    "label": "InstanceBounds()",
    "kind": "Method",
    "detail": "Function (continue ; } const FAABB3)",
    "insertText": "InstanceBounds(Elem.Bounds.Min(), Elem.Bounds.Max())"
  },
  {
    "label": "VisitData()",
    "kind": "Method",
    "detail": "Function (TSpatialVisitorData<TPayloadType>)",
    "insertText": "VisitData(Elem.Payload, true, InstanceBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(Elem.Bounds.Intersects(QueryBounds))"
  },
  {
    "label": "VisitData()",
    "kind": "Method",
    "detail": "Function (TSpatialVisitorData<TPayloadType>)",
    "insertText": "VisitData(Elem.Payload, true, FAABB3(Elem.Bounds.Min(), Elem.Bounds.Max()))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FReal TOI ;)",
    "insertText": "for(const auto& Elem : Elems)"
  },
  {
    "label": "bContinue()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bContinue(bSweep && Visitor.VisitSweep(VisitData, QueryFastData)) || (!bSweep && Visitor.VisitRaycast(VisitData, QueryFastData))"
  },
  {
    "label": "InstanceBounds()",
    "kind": "Method",
    "detail": "Function (const FAABBVectorizedDouble)",
    "insertText": "InstanceBounds(Elem.Bounds)"
  },
  {
    "label": "VisitRaycast()",
    "kind": "Method",
    "detail": "Function (const bool bContinue = Visitor .)",
    "insertText": "VisitRaycast(VisitData, QueryFastData)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (Elems .)",
    "insertText": "RemoveAtSwap(Idx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; })",
    "insertText": "if(UNLIKELY(!ensure(Idx != Elems.Num() - 1)))"
  },
  {
    "label": "UpdateElement()",
    "kind": "Method",
    "detail": "Function (} } bDirtyLeaf = true ; } void)",
    "insertText": "UpdateElement(const TPayloadType& Payload, const TAABB<T, 3>& NewBounds, bool bHasBounds)"
  },
  {
    "label": "UpdateElementHelper()",
    "kind": "Method",
    "detail": "Function (Elems [ Idx ] . Bounds = NewBounds ;)",
    "insertText": "UpdateElementHelper(Elems[Idx].Payload, Payload)"
  },
  {
    "label": "AddElement()",
    "kind": "Method",
    "detail": "Function (break ; } } bDirtyLeaf = true ; } void)",
    "insertText": "AddElement(const TPayloadBoundsElement<TPayloadType, T>& Element)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Elems .)",
    "insertText": "Add(Element)"
  },
  {
    "label": "DebugDrawLeaf()",
    "kind": "Method",
    "detail": "Function (bDirtyLeaf = false ; } # if ! UE_BUILD_SHIPPING void)",
    "insertText": "DebugDrawLeaf(ISpacialDebugDrawInterface<T>& InInterface, const FLinearColor& InLinearColor, float InThickness)"
  },
  {
    "label": "Alpha()",
    "kind": "Method",
    "detail": "Function (const float)",
    "insertText": "Alpha(float)Elems.Num()"
  },
  {
    "label": "Green()",
    "kind": "Method",
    "detail": "Function (const FLinearColor ColorByCount =)",
    "insertText": "Green(1.f - Alpha)"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (const FVec3 ColorAsVec = { ColorByCount . R,ColorByCount . G,ColorByCount . B } ; InInterface .)",
    "insertText": "Box(LeafBounds, ColorAsVec, InThickness)"
  },
  {
    "label": "Line()",
    "kind": "Method",
    "detail": "Function (InInterface .)",
    "insertText": "Line(LeafBounds.Center(), Elem.Bounds.Center(), ColorAsVec, InThickness)"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (InInterface .)",
    "insertText": "Box(Elem.Bounds, { (T)1.0, (T)0.2, (T)0.2 }, 1.0f)"
  },
  {
    "label": "PrintLeaf()",
    "kind": "Method",
    "detail": "Function (} } # endif void)",
    "insertText": "PrintLeaf()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (+ + ElemIndex ; } } void)",
    "insertText": "Serialize(FChaosArchive& Ar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ar<<Elems ; } TArray<TPayloadBoundsElement<TPayloadType,T>> Elems ; bool bDirtyLeaf = false ;::FChaosVDDataWrapperUtils ; } ; template<TPayloadType,bool bComputeBounds,T> FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, TAABBTreeLeafArray<TPayloadType, bComputeBounds, T>& LeafArray)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (LeafArray .)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "LeafType()",
    "kind": "Method",
    "detail": "Function (Ar<<* static_cast<TArray<)",
    "insertText": "LeafType(this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<> class TLeafContainer<TAABBTreeLeafArray<FAccelerationStructureHandle,true,FReal>> : private TArray<TAABBTreeLeafArray<FAccelerationStructureHandle,true,FReal>> { private : typedef TAABBTreeLeafArray<FAccelerationStructureHandle,true,FReal> FLeafType ; using FParent = TArray<FLeafType> ; public : using ElementType = FParent::ElementType ; FLeafType&)",
    "insertText": "operator(SizeType Index)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reserve(Number)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} NumOfValidElements = 0 ; } SizeType)",
    "insertText": "Add(const FLeafType& Item)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NumOfValidElements + + ;)",
    "insertText": "if(NumOfValidElements > FParent::Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(Item)"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "else(*this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : int32 NumOfValidElements = 0 ;::FChaosVDDataWrapperUtils ; } ; template<LeafType> FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, TLeafContainer<LeafType>& LeafArray)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TAABB<)",
    "insertText": "T() , TAABB<T, 3>()"
  },
  {
    "label": "ParentNode()",
    "kind": "Method",
    "detail": "Function (INDEX_NONE,INDEX_NONE },)",
    "insertText": "ParentNode(INDEX_NONE) , bLeaf(false) , bDirtyNode(false)"
  },
  {
    "label": "DebugDraw()",
    "kind": "Method",
    "detail": "Function (} TAABB<T,3> ChildrenBounds [ 2 ] ; int32 ChildrenNodes [ 2 ] ; int32 ParentNode ; bool bLeaf : 1 ; bool bDirtyNode : 1 ; # if ! UE_BUILD_SHIPPING void)",
    "insertText": "DebugDraw(ISpacialDebugDrawInterface<T>& InInterface, const TArray<TAABBTreeNode<T>>& Nodes, const FVec3& InLinearColor, float InThickness)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float ColorRatio = 0 . 7 5 f ; float LineThicknessRatio = 0 . 7 5 f ;)",
    "insertText": "if(!bLeaf)"
  },
  {
    "label": "MakeRandomColor()",
    "kind": "Method",
    "detail": "Function (FLinearColor ChildColor =)",
    "insertText": "MakeRandomColor()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 NodeIndex = ChildrenNodes [ ChildIndex ] ;)",
    "insertText": "if(NodeIndex > 0 && NodeIndex < Nodes.Num())"
  },
  {
    "label": "DebugDraw()",
    "kind": "Method",
    "detail": "Function (Nodes [ NodeIndex ] .)",
    "insertText": "DebugDraw(InInterface, Nodes, { ChildColor.R, ChildColor.G, ChildColor.B }, InThickness * LineThicknessRatio)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(int ChildIndex = 0; ChildIndex < 2; ++ChildIndex)"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (InInterface .)",
    "insertText": "Box(ChildrenBounds[ChildIndex], InLinearColor, InThickness)"
  },
  {
    "label": "SerializeAsAABB()",
    "kind": "Method",
    "detail": "Function (TBox<T,3)",
    "insertText": "SerializeAsAABB(Ar, Bounds)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(auto& Node : ChildrenNodes)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<Node ; } bool bLeafCopy = bLeaf ; Ar<<bLeafCopy ;)",
    "insertText": "if(Ar.IsLoading())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ParentNode = INDEX_NONE ; bLeaf = bLeafCopy ; } } } ; template<T> FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, TAABBTreeNode<T>& Node)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (NodeIdx = INDEX_NONE ; } } } ; FArchive&)",
    "insertText": "operator(FArchive& Ar, FAABBTreePayloadInfo& PayloadInfo)"
  },
  {
    "label": "DirtyGridHashEntry()",
    "kind": "Method",
    "detail": "Function (Index = 0 ; Count = 0 ; })",
    "insertText": "DirtyGridHashEntry(const DirtyGridHashEntry& Other)"
  },
  {
    "label": "InitPayloadToInfo()",
    "kind": "Method",
    "detail": "Function (Index = Other . Index ; Count = Other . Count ; } int32 Index ; int32 Count ; } ; template<PayloadType> struct TDefaultAABBTreeStorageTraits { using PayloadToInfoType = TArrayAsMap<PayloadType,FAABBTreePayloadInfo> ; void)",
    "insertText": "InitPayloadToInfo(PayloadToInfoType& PayloadToInfo)"
  },
  {
    "label": "AABBTree()",
    "kind": "Method",
    "detail": "Function (} } ; template<TPayloadType,TLeafType,bool bMutable = true,T = FReal,StorageTraits = TDefaultAABBTreeStorageTraits<TPayloadType>> class TAABBTree final : public ISpatialAcceleration<TPayloadType,T,3> { private : using FElement = TPayloadBoundsElement<TPayloadType,T> ; using FNode = TAABBTreeNode<T> ; public : using PayloadType = TPayloadType ; int D = 3 ; using TType = T ; T DefaultMaxPayloadBounds = 1 0 0 0 0 0 ; int32 DefaultMaxChildrenInLeaf = 1 2 ; int32 DefaultMaxTreeDepth = 1 6 ; int32 DefaultMaxNumToProcess = 0 ; ESpatialAcceleration StaticType = std::is_same_v<TAABBTreeLeafArray<TPayloadType>,TLeafType> ?)",
    "insertText": "AABBTree(std::is_same_v<TBoundingVolume<TPayloadType>, TLeafType> ? ESpatialAcceleration::AABBTreeBV : ESpatialAcceleration::Unknown)"
  },
  {
    "label": "TAABBTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TAABBTree() : ISpatialAcceleration<TPayloadType, T, 3>(StaticType) , bDynamicTree(false) , RootNode(INDEX_NONE) , FirstFreeInternalNode(INDEX_NONE) , FirstFreeLeafNode(INDEX_NONE) , MaxChildrenInLeaf(DefaultMaxChildrenInLeaf) , MaxTreeDepth(DefaultMaxTreeDepth) , MaxPayloadBounds(DefaultMaxPayloadBounds) , MaxNumToProcess(DefaultMaxNumToProcess) , bModifyingTreeMultiThreadingFastCheck(false) , bShouldRebuild(true) , bBuildOverlapCache(true)"
  },
  {
    "label": "GetCVars()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetCVars()"
  },
  {
    "label": "InitPayloadToInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitPayloadToInfo(PayloadToInfo)"
  },
  {
    "label": "SetAsyncTimeSlicingComplete()",
    "kind": "Method",
    "detail": "Function (bShouldRebuild = true ; RootNode = INDEX_NONE ; FirstFreeInternalNode = INDEX_NONE ; FirstFreeLeafNode = INDEX_NONE ; this ->)",
    "insertText": "SetAsyncTimeSlicingComplete(true)"
  },
  {
    "label": "ProgressAsyncTimeSlicing()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ProgressAsyncTimeSlicing(bool ForceBuildCompletion)"
  },
  {
    "label": "SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SCOPE_CYCLE_COUNTER(STAT_AABBTreeProgressTimeSlice)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MaxNumToProcess = 0 ; })",
    "insertText": "if(WorkStack.Num())"
  },
  {
    "label": "Seconds()",
    "kind": "Method",
    "detail": "Function (NumProcessedThisSlice = 0 ; StartSliceTimeStamp =)",
    "insertText": "Seconds()"
  },
  {
    "label": "SplitNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SplitNode()"
  },
  {
    "label": "TAABBTree()",
    "kind": "Method",
    "detail": "Function (} } template<TParticles>)",
    "insertText": "TAABBTree(const TParticles& Particles, int32 InMaxChildrenInLeaf = DefaultMaxChildrenInLeaf, int32 InMaxTreeDepth = DefaultMaxTreeDepth, T InMaxPayloadBounds = DefaultMaxPayloadBounds, int32 InMaxNumToProcess = DefaultMaxNumToProcess, bool bInDynamicTree = false, bool bInUseDirtyTree = false, bool bInBuildOverlapCache = true) : ISpatialAcceleration<TPayloadType, T, 3>(StaticType) , bDynamicTree(bInDynamicTree) , MaxChildrenInLeaf(InMaxChildrenInLeaf) , MaxTreeDepth(InMaxTreeDepth) , MaxPayloadBounds(InMaxPayloadBounds) , MaxNumToProcess(InMaxNumToProcess) , bModifyingTreeMultiThreadingFastCheck(false) , bShouldRebuild(true) , bBuildOverlapCache(bInBuildOverlapCache)"
  },
  {
    "label": "TAABBTree()",
    "kind": "Method",
    "detail": "Function (DirtyElementTree = TUniquePtr<)",
    "insertText": "TAABBTree(new TAABBTree())"
  },
  {
    "label": "SetTreeToDynamic()",
    "kind": "Method",
    "detail": "Function (DirtyElementTree ->)",
    "insertText": "SetTreeToDynamic()"
  },
  {
    "label": "GenerateTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GenerateTree(Particles)"
  },
  {
    "label": "TAABBTree()",
    "kind": "Method",
    "detail": "Function (} struct EmptyInit { } ;)",
    "insertText": "TAABBTree(EmptyInit, int32 InMaxChildrenInLeaf = DefaultMaxChildrenInLeaf, int32 InMaxTreeDepth = DefaultMaxTreeDepth, T InMaxPayloadBounds = DefaultMaxPayloadBounds, int32 InMaxNumToProcess = DefaultMaxNumToProcess, bool bInDynamicTree = false, bool bInUseDirtyTree = false, bool bInBuildOverlapCache = true) : ISpatialAcceleration<TPayloadType, T, 3>(StaticType) , bDynamicTree(bInDynamicTree) , MaxChildrenInLeaf(InMaxChildrenInLeaf) , MaxTreeDepth(InMaxTreeDepth) , MaxPayloadBounds(InMaxPayloadBounds) , MaxNumToProcess(InMaxNumToProcess) , bModifyingTreeMultiThreadingFastCheck(false) , bShouldRebuild(true) , bBuildOverlapCache(bInBuildOverlapCache)"
  },
  {
    "label": "Reinitialize()",
    "kind": "Method",
    "detail": "Function (} template<ParticleView> void)",
    "insertText": "Reinitialize(const ParticleView& Particles, int32 InMaxChildrenInLeaf = DefaultMaxChildrenInLeaf, int32 InMaxTreeDepth = DefaultMaxTreeDepth, T InMaxPayloadBounds = DefaultMaxPayloadBounds, int32 InMaxNumToProcess = DefaultMaxNumToProcess, bool bInDynamicTree = false, bool bInbBuildOverlapCache = true)"
  },
  {
    "label": "FindAllIntersections()",
    "kind": "Method",
    "detail": "Function (} TArray<TPayloadType>)",
    "insertText": "FindAllIntersections(const FAABB3& Box)"
  },
  {
    "label": "GetAsBoundsArray()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetAsBoundsArray(TArray<TAABB<T, 3>>& AllBounds, int32 NodeIdx, int32 ParentNode, TAABB<T, 3>& Bounds)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (AllBounds .)",
    "insertText": "Add(Bounds)"
  },
  {
    "label": "GetAsBoundsArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetAsBoundsArray(AllBounds, Nodes[NodeIdx].ChildrenNodes[1], NodeIdx, Nodes[NodeIdx].ChildrenBounds[0])"
  },
  {
    "label": "TAABBTree()",
    "kind": "Method",
    "detail": "Function (} return true ; } ~)",
    "insertText": "TAABBTree()"
  },
  {
    "label": "CopyFrom()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CopyFrom(const TAABBTree& Other)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (} TUniquePtr<ISpatialAcceleration<TPayloadType,T,3>>)",
    "insertText": "Copy()"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Raycast(const FVec3& Start, const FVec3& Dir, const FReal Length, ISpatialVisitor<TPayloadType, FReal>& Visitor)"
  },
  {
    "label": "ProxyVisitor()",
    "kind": "Method",
    "detail": "Function (TSpatialVisitor<TPayloadType,FReal>)",
    "insertText": "ProxyVisitor(Visitor)"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Raycast(Start, Dir, Length, ProxyVisitor)"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor> void)",
    "insertText": "Raycast(const FVec3& Start, const FVec3& Dir, const FReal Length, SQVisitor& Visitor)"
  },
  {
    "label": "QueryFastData()",
    "kind": "Method",
    "detail": "Function (FQueryFastData)",
    "insertText": "QueryFastData(Dir, Length)"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (QueryImp<)",
    "insertText": "Raycast(Start, QueryFastData, FVec3(), FAABB3(), Visitor, QueryFastData.Dir, QueryFastData.InvDir, QueryFastData.bParallel)"
  },
  {
    "label": "RaycastFast()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor> bool)",
    "insertText": "RaycastFast(const FVec3& Start, FQueryFastData& CurData, SQVisitor& Visitor, const FVec3& Dir, const FVec3 InvDir, const bool bParallel[3])"
  },
  {
    "label": "Sweep()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Sweep(const FVec3& Start, const FVec3& Dir, const FReal Length, const FVec3 QueryHalfExtents, ISpatialVisitor<TPayloadType, FReal>& Visitor)"
  },
  {
    "label": "Sweep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Sweep(Start, Dir, Length, QueryHalfExtents, ProxyVisitor)"
  },
  {
    "label": "Sweep()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor> void)",
    "insertText": "Sweep(const FVec3& Start, const FVec3& Dir, const FReal Length, const FVec3 QueryHalfExtents, SQVisitor& Visitor)"
  },
  {
    "label": "Sweep()",
    "kind": "Method",
    "detail": "Function (QueryImp<)",
    "insertText": "Sweep(Start, QueryFastData, QueryHalfExtents, FAABB3(), Visitor, QueryFastData.Dir, QueryFastData.InvDir, QueryFastData.bParallel)"
  },
  {
    "label": "SweepFast()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor> bool)",
    "insertText": "SweepFast(const FVec3& Start, FQueryFastData& CurData, const FVec3 QueryHalfExtents, SQVisitor& Visitor, const FVec3& Dir, const FVec3 InvDir, const bool bParallel[3])"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Overlap(const FAABB3& QueryBounds, ISpatialVisitor<TPayloadType, FReal>& Visitor)"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Overlap(QueryBounds, ProxyVisitor)"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor> void)",
    "insertText": "Overlap(const FAABB3& QueryBounds, SQVisitor& Visitor)"
  },
  {
    "label": "OverlapFast()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OverlapFast(QueryBounds, Visitor)"
  },
  {
    "label": "OverlapFast()",
    "kind": "Method",
    "detail": "Function (} template<SQVisitor> bool)",
    "insertText": "OverlapFast(const FAABB3& QueryBounds, SQVisitor& Visitor)"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (FQueryFastDataVoid VoidData ; return QueryImp<)",
    "insertText": "Overlap(FVec3(), VoidData, FVec3(), QueryBounds, Visitor, VoidData.Dir, VoidData.InvDir, VoidData.bParallel)"
  },
  {
    "label": "DirtyElementGridCellSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DirtyElementGridCellSize(T)"
  },
  {
    "label": "DirtyElementGridEnabled()",
    "kind": "Method",
    "detail": "Function (DirtyElementGridCellSizeInv = 1 . 0 f / DirtyElementGridCellSize ; } else { DirtyElementGridCellSizeInv = 1 . 0 f ; } DirtyElementMaxGridCellQueryCount = FAABBTreeDirtyGridCVars::DirtyElementMaxGridCellQueryCount ; DirtyElementMaxPhysicalSizeInCells = FAABBTreeDirtyGridCVars::DirtyElementMaxPhysicalSizeInCells ; DirtyElementMaxCellCapacity = FAABBTreeDirtyGridCVars::DirtyElementMaxCellCapacity ; } bool)",
    "insertText": "DirtyElementGridEnabled()"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (DirtyGridHashEntry* HashEntry = CellHashToFlatArray .)",
    "insertText": "Find(Hash)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} return true ; } } else { DirtyGridHashEntry& NewHashEntry = CellHashToFlatArray .)",
    "insertText": "Add(Hash)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (NewHashEntry . Count = 1 ; FlattenedCellArrayOfDirtyIndices .)",
    "insertText": "AddUninitialized(DirtyElementMaxCellCapacity)"
  },
  {
    "label": "DeleteDirtyParticleIndexFromGridCell()",
    "kind": "Method",
    "detail": "Function (FlattenedCellArrayOfDirtyIndices [ NewHashEntry . Index ] = NewDirtyIndex ; TreeStats . StatNumNonEmptyCellsInGrid + + ; return true ; } return false ; } bool)",
    "insertText": "DeleteDirtyParticleIndexFromGridCell(int32 Hash, int32 DirtyIndex)"
  },
  {
    "label": "ensure()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "ensure(DirtyElementsGridOverflow[DeleteDirtyGridOverflowIdx] == DeleteDirtyParticleIdx)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (auto LastOverflowPayload = DirtyElements [ DirtyElementsGridOverflow .)",
    "insertText": "Last()"
  },
  {
    "label": "FindChecked()",
    "kind": "Method",
    "detail": "Function (PayloadToInfo .)",
    "insertText": "FindChecked(LastOverflowPayload)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (} DirtyElementsGridOverflow .)",
    "insertText": "RemoveAtSwap(DeleteDirtyGridOverflowIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(DeleteDirtyParticleIdx + 1 < DirtyElements.Num())"
  },
  {
    "label": "FindChecked()",
    "kind": "Method",
    "detail": "Function (auto LastDirtyPayload = DirtyElements [ LastDirtyElementIndex ] . Payload ; int32 LastDirtyGridOverflowIdx = PayloadToInfo .)",
    "insertText": "FindChecked(LastDirtyPayload)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (} DirtyElements .)",
    "insertText": "RemoveAtSwap(DeleteDirtyParticleIdx)"
  },
  {
    "label": "AddDirtyElementToGrid()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "AddDirtyElementToGrid(const TAABB<T, 3>& NewBounds, int32 NewDirtyElement)"
  },
  {
    "label": "TooManyOverlapQueryCells()",
    "kind": "Method",
    "detail": "Function (bool bAddToGrid = !)",
    "insertText": "TooManyOverlapQueryCells(NewBounds, DirtyElementGridCellSizeInv, DirtyElementMaxPhysicalSizeInCells)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TreeStats . StatNumElementsTooLargeForGrid + + ; })",
    "insertText": "if(bAddToGrid)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { int32 NewOverflowIndex = DirtyElementsGridOverflow .)",
    "insertText": "Add(NewDirtyElement)"
  },
  {
    "label": "DoForOverlappedCellsExclude()",
    "kind": "Method",
    "detail": "Function (const TAABB<T,3>& OldBounds = DirtyElements [ DirtyElementIndex ] . Bounds ;)",
    "insertText": "DoForOverlappedCellsExclude(OldBounds, NewBounds, DirtyElementGridCellSize, DirtyElementGridCellSizeInv, [&](int32 Hash) -> bool { ensure(DeleteDirtyParticleIndexFromGridCell(Hash, DirtyElementIndex)); return true; })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (int32 NewOverflowIndex = DirtyElementsGridOverflow .)",
    "insertText": "Add(DirtyElementIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<FElement> AllElements ;)",
    "insertText": "for(int LeafIndex = 0; LeafIndex < Leaves.Num(); LeafIndex++)"
  },
  {
    "label": "GatherElements()",
    "kind": "Method",
    "detail": "Function (const TLeafType& Leaf = Leaves [ LeafIndex ] ; Leaf .)",
    "insertText": "GatherElements(AllElements)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} int32 MaxDepth = 0 ; int32 DepthTotal = 0 ;)",
    "insertText": "for(const FElement& Element : AllElements)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (const FAABBTreePayloadInfo* PayloadInfo = PayloadToInfo .)",
    "insertText": "Find(Element.Payload)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (continue ; } int32 Depth = 0 ; int32 Node = PayloadInfo -> NodeIdx ;)",
    "insertText": "while(Node != INDEX_NONE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Node = Nodes [ Node ] . ParentNode ;)",
    "insertText": "if(Node != INDEX_NONE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Depth + + ; } })",
    "insertText": "if(Depth > MaxDepth)"
  },
  {
    "label": "DynamicTreeDebugStats()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DynamicTreeDebugStats()"
  },
  {
    "label": "DebugGetElementsCollection()",
    "kind": "Method",
    "detail": "Function (const FElementsCollection ElemData =)",
    "insertText": "DebugGetElementsCollection()"
  },
  {
    "label": "CSV_CUSTOM_STAT()",
    "kind": "Method",
    "detail": "Function (# if ! WITH_EDITOR)",
    "insertText": "CSV_CUSTOM_STAT(ChaosPhysicsTimers, MaximumTreeDepth, ElemData.MaxDepth, ECsvCustomStatOp::Max)"
  },
  {
    "label": "CSV_CUSTOM_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CSV_CUSTOM_STAT(ChaosPhysicsTimers, AvgTreeDepth, ElemData.DepthTotal / ElemData.AllElements.Num(), ECsvCustomStatOp::Max)"
  },
  {
    "label": "CSV_CUSTOM_STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CSV_CUSTOM_STAT(ChaosPhysicsTimers, Dirty, ElemData.DirtyElementCount, ECsvCustomStatOp::Max)"
  },
  {
    "label": "DumpStats()",
    "kind": "Method",
    "detail": "Function (# endif } # if ! UE_BUILD_SHIPPING void)",
    "insertText": "DumpStats()"
  },
  {
    "label": "DumpStatsTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DumpStatsTo(*GLog)"
  },
  {
    "label": "DumpStatsTo()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DumpStatsTo(FOutputDevice& Ar)"
  },
  {
    "label": "Capacity()",
    "kind": "Method",
    "detail": "Function (const int32 PayloadMapCapacity = PayloadToInfo .)",
    "insertText": "Capacity()"
  },
  {
    "label": "PayloadAllocsize()",
    "kind": "Method",
    "detail": "Function (const uint64)",
    "insertText": "PayloadAllocsize(uint64)PayloadToInfo.GetAllocatedSize()"
  },
  {
    "label": "ElementsNum()",
    "kind": "Method",
    "detail": "Function (const float AvgDepth =)",
    "insertText": "ElementsNum(float)ElemData.DepthTotal / (float)"
  },
  {
    "label": "Logf()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Logf(ELogVerbosity::Log, TEXT(\"\\t\\tContains %d elements\"), ElementsNum)"
  },
  {
    "label": "Logf()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Logf(ELogVerbosity::Log, TEXT(\"\\t\\tMax depth is %d\"), ElemData.MaxDepth)"
  },
  {
    "label": "Logf()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Logf(ELogVerbosity::Log, TEXT(\"\\t\\tAvg depth is %.3f\"), AvgDepth)"
  },
  {
    "label": "Logf()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Logf(ELogVerbosity::Log, TEXT(\"\\t\\tDirty element count is %d\"), ElemData.DirtyElementCount)"
  },
  {
    "label": "Logf()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Logf(ELogVerbosity::Log, TEXT(\"\\t\\tPayload container size is %d elements\"), PayloadMapNum)"
  },
  {
    "label": "Logf()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Logf(ELogVerbosity::Log, TEXT(\"\\t\\tPayload container capacity is %d elements\"), PayloadMapCapacity)"
  },
  {
    "label": "Logf()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Logf(ELogVerbosity::Log, TEXT(\"\\t\\tAllocated size of payload container is %u bytes (%u per tree element)\"), PayloadAllocsize, ElementsNum > 0 ? PayloadAllocsize / (uint32)ElementsNum : 0)"
  },
  {
    "label": "Logf()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Logf(ELogVerbosity::Log, TEXT(\"\"))"
  },
  {
    "label": "Logf()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Logf(ELogVerbosity::Log, TEXT(\"\\t\\tDirty Tree:\"))"
  },
  {
    "label": "DumpStatsTo()",
    "kind": "Method",
    "detail": "Function (DirtyElementTree ->)",
    "insertText": "DumpStatsTo(Ar)"
  },
  {
    "label": "AllocateInternalNode()",
    "kind": "Method",
    "detail": "Function (} } # endif int32)",
    "insertText": "AllocateInternalNode()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 AllocatedNodeIdx = FirstFreeInternalNode ;)",
    "insertText": "if(FirstFreeInternalNode != INDEX_NONE)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (FirstFreeInternalNode = Nodes [ FirstFreeInternalNode ] . ChildrenNodes [ 1 ] ; } else { AllocatedNodeIdx = Nodes .)",
    "insertText": "AddUninitialized(1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (; Nodes [ AllocatedNodeIdx ] . bLeaf = false ; })",
    "insertText": "if(UNLIKELY(!ensure(Nodes[AllocatedNodeIdx].bLeaf == false)))"
  },
  {
    "label": "AllocateLeafNodeAndLeaf()",
    "kind": "Method",
    "detail": "Function (} return AllocatedNodeIdx ; } struct NodeAndLeafIndices { int32 NodeIdx ; int32 LeafIdx ; } ; NodeAndLeafIndices)",
    "insertText": "AllocateLeafNodeAndLeaf(const TPayloadType& Payload, const TAABB<T, 3>& NewBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 AllocatedNodeIdx = FirstFreeLeafNode ; int32 LeafIndex ;)",
    "insertText": "if(FirstFreeLeafNode != INDEX_NONE)"
  },
  {
    "label": "AddElement()",
    "kind": "Method",
    "detail": "Function (FirstFreeLeafNode = Nodes [ FirstFreeLeafNode ] . ChildrenNodes [ 1 ] ; LeafIndex = Nodes [ AllocatedNodeIdx ] . ChildrenNodes [ 0 ] ; FElement NewElement { Payload,NewBounds } ; Leaves [ LeafIndex ] .)",
    "insertText": "AddElement(NewElement)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Nodes [ AllocatedNodeIdx ] . ChildrenNodes [ 0 ] = LeafIndex ; Nodes [ AllocatedNodeIdx ] . bLeaf = true ; FElement NewElement { Payload,NewBounds } ; TArray<FElement> SingleElementArray ; SingleElementArray .)",
    "insertText": "Add(NewElement)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Leaves .)",
    "insertText": "Add(TLeafType{ SingleElementArray })"
  },
  {
    "label": "Thicken()",
    "kind": "Method",
    "detail": "Function (} TAABB<T,3> ExpandedBounds = NewBounds ; ExpandedBounds .)",
    "insertText": "Thicken(FAABBTreeCVars::DynamicTreeBoundingBoxPadding)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Nodes [ AllocatedNodeIdx ] . ChildrenBounds [ 0 ] = ExpandedBounds ; Nodes [ AllocatedNodeIdx ] . ParentNode = INDEX_NONE ;)",
    "insertText": "if(UNLIKELY(!ensure(Nodes[AllocatedNodeIdx].bLeaf == true)))"
  },
  {
    "label": "DeAllocateInternalNode()",
    "kind": "Method",
    "detail": "Function (} return NodeAndLeafIndices { AllocatedNodeIdx,LeafIndex } ; } void)",
    "insertText": "DeAllocateInternalNode(int32 NodeIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Nodes [ NodeIdx ] . ChildrenNodes [ 1 ] = FirstFreeInternalNode ; FirstFreeInternalNode = NodeIdx ;)",
    "insertText": "if(UNLIKELY(!ensure(Nodes[NodeIdx].bLeaf == false)))"
  },
  {
    "label": "DeAllocateLeafNode()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DeAllocateLeafNode(int32 NodeIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Nodes [ NodeIdx ] . ChildrenNodes [ 1 ] = FirstFreeLeafNode ; FirstFreeLeafNode = NodeIdx ;)",
    "insertText": "if(UNLIKELY(!ensure(Nodes[NodeIdx].bLeaf == true)))"
  },
  {
    "label": "WhichChildAmI()",
    "kind": "Method",
    "detail": "Function (} } int32)",
    "insertText": "WhichChildAmI(int32 NodeIdx)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (int32 ParentIdx = Nodes [ NodeIdx ] . ParentNode ;)",
    "insertText": "check(ParentIdx != INDEX_NONE)"
  },
  {
    "label": "GetSiblingIndex()",
    "kind": "Method",
    "detail": "Function (} return 1 ; } } int32)",
    "insertText": "GetSiblingIndex(int32 NodeIdx)"
  },
  {
    "label": "FindBestSibling()",
    "kind": "Method",
    "detail": "Function (} public : int32)",
    "insertText": "FindBestSibling(const TAABB<T, 3>& InNewBounds, bool& bOutAddToLeaf)"
  },
  {
    "label": "GetArea()",
    "kind": "Method",
    "detail": "Function (const FReal NewBoundsArea = NewBounds .)",
    "insertText": "GetArea()"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (int32 QIndex = 0 ; FNode& RNode = Nodes [ RootNode ] ; TAABB<T,3> WorkingAABB { NewBounds } ; WorkingAABB .)",
    "insertText": "GrowToInclude(RNode.ChildrenBounds[0])"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (WorkingAABB .)",
    "insertText": "GrowToInclude(RNode.ChildrenBounds[1])"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (PriorityQ .)",
    "insertText": "Emplace(RNode, RootNode, 0.0f)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (const FNodeIndexAndCost NodeAndCost = PriorityQ [ QIndex ] ; FNode& TestNode = NodeAndCost . template)",
    "insertText": "Get()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (QIndex + + ; bool bAddToLeaf = false ; WorkingAABB = TestNode . ChildrenBounds [ 0 ] ;)",
    "insertText": "if(!TestNode.bLeaf)"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (WorkingAABB .)",
    "insertText": "GrowToInclude(TestNode.ChildrenBounds[1])"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (WorkingAABB .)",
    "insertText": "GrowToInclude(NewBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FReal CostForChoosingNode = NewPotentialNodeArea + SumDeltaCost ;)",
    "insertText": "if(bAddToLeaf)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} const FReal NewDeltaCost = NewPotentialNodeArea - TestSiblingArea ;)",
    "insertText": "if(CostForChoosingNode < BestCost)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bOutAddToLeaf = bAddToLeaf ; } const FReal NewCost = NewDeltaCost + SumDeltaCost ; const FReal ChildCostLowerBound = NewBoundsArea + NewCost ;)",
    "insertText": "if(!TestNode.bLeaf && ChildCostLowerBound < BestCost)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (PriorityQ .)",
    "insertText": "Reserve(PriorityQ.Num() + 2)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (PriorityQ .)",
    "insertText": "Emplace(Nodes[TestNode.ChildrenNodes[0]], TestNode.ChildrenNodes[0], NewCost)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (PriorityQ .)",
    "insertText": "Emplace(Nodes[TestNode.ChildrenNodes[1]], TestNode.ChildrenNodes[1], NewCost)"
  },
  {
    "label": "RotateNode()",
    "kind": "Method",
    "detail": "Function (} } return BestSiblingIdx ; } void)",
    "insertText": "RotateNode(uint32 NodeIdx, bool debugAssert = false)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (int32 BestGrandChildToSwap = INDEX_NONE ; int32 BestAuntToSwap = INDEX_NONE ; FReal BestDeltaCost = 0 . 0 f ;)",
    "insertText": "check(!Nodes[NodeIdx].bLeaf)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 Aunt = Nodes [ NodeIdx ] . ChildrenNodes [ AuntLocalIdx ] ; int32 Mother = Nodes [ NodeIdx ] . ChildrenNodes [ AuntLocalIdx ^ 1 ] ;)",
    "insertText": "if(Nodes[Mother].bLeaf)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "for(int32 GrandChild : Nodes[Mother].ChildrenNodes)"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (TAABB<T,3> NewMotherAABB { Nodes [ NodeIdx ] . ChildrenBounds [ AuntLocalIdx ] } ; NewMotherAABB .)",
    "insertText": "GrowToInclude(Nodes[Mother].ChildrenBounds[GetSiblingIndex(GrandChild)])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FReal DeltaCost = MotherCostWithRotation - MotherCostWithoutRotation ;)",
    "insertText": "if(DeltaCost < BestDeltaCost)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BestDeltaCost = DeltaCost ; BestAuntToSwap = Aunt ; BestGrandChildToSwap = GrandChild ; } } })",
    "insertText": "if(BestGrandChildToSwap != INDEX_NONE)"
  },
  {
    "label": "WhichChildAmI()",
    "kind": "Method",
    "detail": "Function (} int32 AuntLocalChildIdx =)",
    "insertText": "WhichChildAmI(BestAuntToSwap)"
  },
  {
    "label": "WhichChildAmI()",
    "kind": "Method",
    "detail": "Function (int32 GrandChildLocalChildIdx =)",
    "insertText": "WhichChildAmI(BestGrandChildToSwap)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 MotherOfBestGrandChild = Nodes [ BestGrandChildToSwap ] . ParentNode ;)",
    "insertText": "if(UNLIKELY(!ensure(BestGrandChildToSwap != NodeIdx)))"
  },
  {
    "label": "InsertLeaf()",
    "kind": "Method",
    "detail": "Function (} } NodeAndLeafIndices)",
    "insertText": "InsertLeaf(const TPayloadType& Payload, const TAABB<T, 3>& NewBounds)"
  },
  {
    "label": "AllocateLeafNodeAndLeaf()",
    "kind": "Method",
    "detail": "Function (NodeAndLeafIndices NewIndices =)",
    "insertText": "AllocateLeafNodeAndLeaf(Payload, NewBounds)"
  },
  {
    "label": "FindBestSibling()",
    "kind": "Method",
    "detail": "Function (RootNode = NewIndices . NodeIdx ; return NewIndices ; } bool bAddToLeaf ; int32 BestSibling =)",
    "insertText": "FindBestSibling(NewBounds, bAddToLeaf)"
  },
  {
    "label": "AddElement()",
    "kind": "Method",
    "detail": "Function (const int32 LeafIdx = Nodes [ BestSibling ] . ChildrenNodes [ 0 ] ; Leaves [ LeafIdx ] .)",
    "insertText": "AddElement(TPayloadBoundsElement<TPayloadType, T>{Payload, NewBounds})"
  },
  {
    "label": "UpdateAncestorBounds()",
    "kind": "Method",
    "detail": "Function (Nodes [ BestSibling ] . ChildrenBounds [ 0 ] = ExpandedBounds ;)",
    "insertText": "UpdateAncestorBounds(BestSibling, true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FNode& NewParentNode = Nodes [ NewParent ] ;)",
    "insertText": "if(UNLIKELY(!ensure(NewParent != OldParent)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} NewParentNode . ParentNode = OldParent ; NewParentNode . ChildrenNodes [ 0 ] = BestSibling ; NewParentNode . ChildrenNodes [ 1 ] = NewLeafIndices . NodeIdx ; NewParentNode . ChildrenBounds [ 0 ] = Nodes [ BestSibling ] . ChildrenBounds [ 0 ] ;)",
    "insertText": "if(!Nodes[BestSibling].bLeaf)"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (NewParentNode . ChildrenBounds [ 0 ] .)",
    "insertText": "GrowToInclude(Nodes[BestSibling].ChildrenBounds[1])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} NewParentNode . ChildrenBounds [ 1 ] = Nodes [ NewLeafIndices . NodeIdx ] . ChildrenBounds [ 0 ] ;)",
    "insertText": "if(OldParent != INDEX_NONE)"
  },
  {
    "label": "WhichChildAmI()",
    "kind": "Method",
    "detail": "Function (const int32 ChildIdx =)",
    "insertText": "WhichChildAmI(BestSibling)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Nodes [ OldParent ] . ChildrenNodes [ ChildIdx ] = NewParent ; } else { RootNode = NewParent ; })",
    "insertText": "if(UNLIKELY(!ensure(BestSibling != NewParent)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} Nodes [ BestSibling ] . ParentNode = NewParent ;)",
    "insertText": "if(UNLIKELY(!ensure(NewLeafIndices.NodeIdx != NewParent)))"
  },
  {
    "label": "UpdateAncestorBounds()",
    "kind": "Method",
    "detail": "Function (} Nodes [ NewLeafIndices . NodeIdx ] . ParentNode = NewParent ;)",
    "insertText": "UpdateAncestorBounds(NewParent, true)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 CurrentNodeIdx = NodeIdx ; int32 ParentNodeIdx = Nodes [ NodeIdx ] . ParentNode ;)",
    "insertText": "while(ParentNodeIdx != INDEX_NONE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Nodes [ ParentNodeIdx ] . ChildrenBounds [ ChildIndex ] = Nodes [ CurrentNodeIdx ] . ChildrenBounds [ 0 ] ;)",
    "insertText": "if(!Nodes[CurrentNodeIdx].bLeaf)"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (Nodes [ ParentNodeIdx ] . ChildrenBounds [ ChildIndex ] .)",
    "insertText": "GrowToInclude(Nodes[CurrentNodeIdx].ChildrenBounds[1])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bDoRotation)"
  },
  {
    "label": "RotateNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RotateNode(ParentNodeIdx)"
  },
  {
    "label": "RemoveLeafNode()",
    "kind": "Method",
    "detail": "Function (} CurrentNodeIdx = ParentNodeIdx ; ParentNodeIdx = Nodes [ CurrentNodeIdx ] . ParentNode ; } } void)",
    "insertText": "RemoveLeafNode(int32 LeafNodeIdx, const TPayloadType& Payload)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} int32 LeafIdx = Nodes [ LeafNodeIdx ] . ChildrenNodes [ 0 ] ;)",
    "insertText": "if(Leaves[LeafIdx].GetElementCount() > 1)"
  },
  {
    "label": "RemoveElement()",
    "kind": "Method",
    "detail": "Function (Leaves [ LeafIdx ] .)",
    "insertText": "RemoveElement(Payload)"
  },
  {
    "label": "UpdateAncestorBounds()",
    "kind": "Method",
    "detail": "Function (Nodes [ LeafNodeIdx ] . ChildrenBounds [ 0 ] = ExpandedBounds ;)",
    "insertText": "UpdateAncestorBounds(LeafNodeIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} int32 ParentNodeIdx = Nodes [ LeafNodeIdx ] . ParentNode ;)",
    "insertText": "if(ParentNodeIdx != INDEX_NONE)"
  },
  {
    "label": "GetSiblingIndex()",
    "kind": "Method",
    "detail": "Function (int32 GrandParentNodeIdx = Nodes [ ParentNodeIdx ] . ParentNode ; int32 SiblingNodeLocalIdx =)",
    "insertText": "GetSiblingIndex(LeafNodeIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 SiblingNodeIdx = Nodes [ ParentNodeIdx ] . ChildrenNodes [ SiblingNodeLocalIdx ] ;)",
    "insertText": "if(GrandParentNodeIdx != INDEX_NONE)"
  },
  {
    "label": "WhichChildAmI()",
    "kind": "Method",
    "detail": "Function (int32 ChildLocalIdx =)",
    "insertText": "WhichChildAmI(ParentNodeIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Nodes [ GrandParentNodeIdx ] . ChildrenNodes [ ChildLocalIdx ] = SiblingNodeIdx ; } else { RootNode = SiblingNodeIdx ; })",
    "insertText": "if(UNLIKELY(!ensure(SiblingNodeIdx != GrandParentNodeIdx)))"
  },
  {
    "label": "UpdateAncestorBounds()",
    "kind": "Method",
    "detail": "Function (} Nodes [ SiblingNodeIdx ] . ParentNode = GrandParentNodeIdx ;)",
    "insertText": "UpdateAncestorBounds(SiblingNodeIdx)"
  },
  {
    "label": "DeAllocateInternalNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeAllocateInternalNode(ParentNodeIdx)"
  },
  {
    "label": "DeAllocateLeafNode()",
    "kind": "Method",
    "detail": "Function (} else { RootNode = INDEX_NONE ; })",
    "insertText": "DeAllocateLeafNode(LeafNodeIdx)"
  },
  {
    "label": "RemoveElement()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "RemoveElement(const TPayloadType& Payload)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} bModifyingTreeMultiThreadingFastCheck = true ;)",
    "insertText": "if(ensure(bMutable))"
  },
  {
    "label": "FindChecked()",
    "kind": "Method",
    "detail": "Function (GlobalPayloadIdx)",
    "insertText": "FindChecked(LastGlobalPayload)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (} GlobalPayloads .)",
    "insertText": "RemoveAtSwap(PayloadInfo->GlobalPayloadIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(PayloadInfo->DirtyPayloadIdx != INDEX_NONE)"
  },
  {
    "label": "RemoveLeafNode()",
    "kind": "Method",
    "detail": "Function (DirtyElementTree ->)",
    "insertText": "RemoveLeafNode(PayloadInfo->DirtyPayloadIdx, Payload)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(DirtyElementGridEnabled())"
  },
  {
    "label": "DeleteDirtyParticleEverywhere()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeleteDirtyParticleEverywhere(PayloadInfo->DirtyPayloadIdx, PayloadInfo->DirtyGridOverflowIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(PayloadInfo->DirtyPayloadIdx + 1 < DirtyElements.Num())"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (} DirtyElements .)",
    "insertText": "RemoveAtSwap(PayloadInfo->DirtyPayloadIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(ensure(PayloadInfo->LeafIdx != INDEX_NONE))"
  },
  {
    "label": "RemoveLeafNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveLeafNode(PayloadInfo->NodeIdx, Payload)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} } PayloadToInfo .)",
    "insertText": "Remove(Payload)"
  },
  {
    "label": "UpdateElement()",
    "kind": "Method",
    "detail": "Function (bShouldRebuild = true ; bModifyingTreeMultiThreadingFastCheck = false ; return true ; } } bModifyingTreeMultiThreadingFastCheck = false ; return false ; } bool)",
    "insertText": "UpdateElement(const TPayloadType& Payload, const TAABB<T, 3>& NewBounds, bool bInHasBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} bModifyingTreeMultiThreadingFastCheck = true ; # if ! WITH_EDITOR # endif bool bHasBounds = bInHasBounds ;)",
    "insertText": "if(bHasBounds && ValidateBounds(NewBounds) == false)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (bHasBounds = false ; # if CHAOS_DEBUG_NAME if)",
    "insertText": "constexpr(std::is_same_v<TPayloadType, FAccelerationStructureHandle>)"
  },
  {
    "label": "DebugName()",
    "kind": "Method",
    "detail": "Function (const TSharedPtr<FString,ESPMode::ThreadSafe>& DebugName = Particle ->)",
    "insertText": "DebugName()"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (FString DebugStr = DebugName ?* DebugName :)",
    "insertText": "TEXT(\"No Name\")"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (} } } # endif)",
    "insertText": "UE_LOG(LogChaos, Warning, TEXT(\"AABBTree encountered invalid bounds input.Forcing element to global payload. Min: %s Max: %s\"), *NewBounds.Min().ToString(), *NewBounds.Max().ToString())"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (FAABBTreePayloadInfo* PayloadInfo = PayloadToInfo .)",
    "insertText": "Find(Payload)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const TAABB<T,3>& LeafNodeBounds = Nodes [ PayloadInfo -> NodeIdx ] . ChildrenBounds [ 0 ] ;)",
    "insertText": "if(LeafNodeBounds.Contains(NewBounds.Min()) && LeafNodeBounds.Contains(NewBounds.Max()))"
  },
  {
    "label": "UpdateElement()",
    "kind": "Method",
    "detail": "Function (Leaves [ PayloadInfo -> LeafIdx ] .)",
    "insertText": "UpdateElement(Payload, NewBounds, bHasBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bModifyingTreeMultiThreadingFastCheck = false ; return bElementExisted ; } } })",
    "insertText": "if(bDynamicTree)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (PayloadInfo -> LeafIdx = INDEX_NONE ; } } } else { bElementExisted = false ; PayloadInfo =& PayloadToInfo .)",
    "insertText": "Add(Payload)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} bShouldRebuild = true ; bool bTooBig = false ;)",
    "insertText": "if(bHasBounds)"
  },
  {
    "label": "InsertLeaf()",
    "kind": "Method",
    "detail": "Function (NodeAndLeafIndices Indices =)",
    "insertText": "InsertLeaf(Payload, NewBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (PayloadInfo -> NodeIdx = Indices . NodeIdx ; PayloadInfo -> LeafIdx = Indices . LeafIdx ; } else {)",
    "insertText": "if(DirtyElementTree)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { PayloadInfo -> DirtyPayloadIdx = DirtyElements .)",
    "insertText": "Add(FElement{ Payload, NewBounds })"
  },
  {
    "label": "AddDirtyElementToGrid()",
    "kind": "Method",
    "detail": "Function (PayloadInfo -> DirtyGridOverflowIdx =)",
    "insertText": "AddDirtyElementToGrid(NewBounds, PayloadInfo->DirtyPayloadIdx)"
  },
  {
    "label": "RemoveLeafNode()",
    "kind": "Method",
    "detail": "Function (} else { DirtyElementTree ->)",
    "insertText": "RemoveLeafNode(DirtyElementIndex, Payload)"
  },
  {
    "label": "UpdateDirtyElementInGrid()",
    "kind": "Method",
    "detail": "Function (PayloadInfo -> DirtyGridOverflowIdx =)",
    "insertText": "UpdateDirtyElementInGrid(NewBounds, DirtyElementIndex, PayloadInfo->DirtyGridOverflowIdx)"
  },
  {
    "label": "UpdateElementHelper()",
    "kind": "Method",
    "detail": "Function (} DirtyElements [ DirtyElementIndex ] . Bounds = NewBounds ;)",
    "insertText": "UpdateElementHelper(DirtyElements[DirtyElementIndex].Payload, Payload)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(PayloadInfo->GlobalPayloadIdx != INDEX_NONE)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (PayloadInfo -> GlobalPayloadIdx = INDEX_NONE ; } } else { TAABB<T,3> GlobalBounds = bTooBig ? NewBounds : TAABB<)",
    "insertText": "T(TVec3<T>(TNumericLimits<T>::Lowest()), TVec3<T>(TNumericLimits<T>::Max()))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (PayloadInfo -> GlobalPayloadIdx = GlobalPayloads .)",
    "insertText": "Add(FElement{ Payload, GlobalBounds })"
  },
  {
    "label": "UpdateElementHelper()",
    "kind": "Method",
    "detail": "Function (} else { GlobalPayloads [ PayloadInfo -> GlobalPayloadIdx ] . Bounds = GlobalBounds ;)",
    "insertText": "UpdateElementHelper(GlobalPayloads[PayloadInfo->GlobalPayloadIdx].Payload, Payload)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } PayloadInfo -> DirtyPayloadIdx = INDEX_NONE ; PayloadInfo -> DirtyGridOverflowIdx = INDEX_NONE ; } } })",
    "insertText": "if(!DirtyElementTree && !bDynamicTree && DirtyElements.Num() > MaxDirtyElements)"
  },
  {
    "label": "ReoptimizeTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReoptimizeTree()"
  },
  {
    "label": "NumDirtyElements()",
    "kind": "Method",
    "detail": "Function (} bModifyingTreeMultiThreadingFastCheck = false ; return bElementExisted ; } int32)",
    "insertText": "NumDirtyElements()"
  },
  {
    "label": "GetAABBTreeStatistics()",
    "kind": "Method",
    "detail": "Function (} const AABBTreeStatistics&)",
    "insertText": "GetAABBTreeStatistics()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const TLeafType& Leaf = Leaves [ LeafIndex ] ; StatMaxLeafSize =)",
    "insertText": "Max(StatMaxLeafSize, (int32)Leaf.GetElementCount())"
  },
  {
    "label": "StatMaxTreeDepth()",
    "kind": "Method",
    "detail": "Function (} TreeExpensiveStats . StatMaxLeafSize = StatMaxLeafSize ; TreeExpensiveStats .)",
    "insertText": "StatMaxTreeDepth(Nodes.Num() == 0) ? 0 : GetSubtreeDepth(0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FNode& Node = Nodes [ NodeIdx ] ;)",
    "insertText": "if(Node.bLeaf)"
  },
  {
    "label": "GlobalObjects()",
    "kind": "Method",
    "detail": "Function (} } const TArray<TPayloadBoundsElement<TPayloadType,T>>&)",
    "insertText": "GlobalObjects()"
  },
  {
    "label": "IsTreeDynamic()",
    "kind": "Method",
    "detail": "Function (bShouldRebuild = false ; } bool)",
    "insertText": "IsTreeDynamic()"
  },
  {
    "label": "PrepareCopyTimeSliced()",
    "kind": "Method",
    "detail": "Function (bDynamicTree = true ; } void)",
    "insertText": "PrepareCopyTimeSliced(const ISpatialAcceleration<TPayloadType, T, 3>& InFrom)"
  },
  {
    "label": "TAABBTree()",
    "kind": "Method",
    "detail": "Function (const TAABBTree& From = static_cast<const)",
    "insertText": "TAABBTree(InFrom)"
  },
  {
    "label": "DeepAssign()",
    "kind": "Method",
    "detail": "Function (ISpatialAcceleration<TPayloadType,T,3)",
    "insertText": "DeepAssign(From)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (DirtyElementGridCellSize = From . DirtyElementGridCellSize ; DirtyElementGridCellSizeInv = From . DirtyElementGridCellSizeInv ; DirtyElementMaxGridCellQueryCount = From . DirtyElementMaxGridCellQueryCount ; DirtyElementMaxPhysicalSizeInCells = From . DirtyElementMaxPhysicalSizeInCells ; DirtyElementMaxCellCapacity = From . DirtyElementMaxCellCapacity ; MaxChildrenInLeaf = From . MaxChildrenInLeaf ; MaxTreeDepth = From . MaxTreeDepth ; MaxPayloadBounds = From . MaxPayloadBounds ; MaxNumToProcess = From . MaxNumToProcess ; NumProcessedThisSlice = From . NumProcessedThisSlice ; StartSliceTimeStamp = From . StartSliceTimeStamp ; bShouldRebuild = From . bShouldRebuild ; RootNode = From . RootNode ; FirstFreeInternalNode = From . FirstFreeInternalNode ; FirstFreeLeafNode = From . FirstFreeLeafNode ; Nodes .)",
    "insertText": "Reserve(From.Nodes.Num())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Leaves .)",
    "insertText": "Reserve(From.Leaves.Num())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (DirtyElements .)",
    "insertText": "Reserve(From.DirtyElements.Num())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (CellHashToFlatArray .)",
    "insertText": "Reserve(From.CellHashToFlatArray.Num())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (FlattenedCellArrayOfDirtyIndices .)",
    "insertText": "Reserve(From.FlattenedCellArrayOfDirtyIndices.Num())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (DirtyElementsGridOverflow .)",
    "insertText": "Reserve(From.DirtyElementsGridOverflow.Num())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (GlobalPayloads .)",
    "insertText": "Reserve(From.GlobalPayloads.Num())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (PayloadToInfo .)",
    "insertText": "Reserve(From.PayloadToInfo.Num())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OverlappingLeaves .)",
    "insertText": "Reserve(From.OverlappingLeaves.Num())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OverlappingOffsets .)",
    "insertText": "Reserve(From.OverlappingOffsets.Num())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OverlappingPairs .)",
    "insertText": "Reserve(From.OverlappingPairs.Num())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OverlappingCounts .)",
    "insertText": "Reserve(From.OverlappingCounts.Num())"
  },
  {
    "label": "SetAsyncTimeSlicingComplete()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "SetAsyncTimeSlicingComplete(false)"
  },
  {
    "label": "PrepareCopyTimeSliced()",
    "kind": "Method",
    "detail": "Function (} DirtyElementTree ->)",
    "insertText": "PrepareCopyTimeSliced(*(From.DirtyElementTree))"
  },
  {
    "label": "ProgressCopyTimeSliced()",
    "kind": "Method",
    "detail": "Function (} else { DirtyElementTree = nullptr ; } } void)",
    "insertText": "ProgressCopyTimeSliced(const ISpatialAcceleration<TPayloadType, T, 3>& InFrom, int MaximumBytesToCopy)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (int32 SizeToCopyLeft = MaximumBytesToCopy ;)",
    "insertText": "check(From.CellHashToFlatArray.Num() == 0)"
  },
  {
    "label": "this()",
    "kind": "Method",
    "detail": "Function (auto CanContinueCopyingDataCallback = [)",
    "insertText": "this(int32 MaxSizeToCopy, int32 CurrentCopiedSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bCanContinueCopy = true ; const bool bForceCopyAll = MaxSizeToCopy = = - 1 ;)",
    "insertText": "if(bForceCopyAll)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CurrentDataElementsCopiedSinceLastCheck + + ;)",
    "insertText": "if(CurrentDataElementsCopiedSinceLastCheck > FAABBTimeSliceCVars::MinDataChunkToProcessBetweenTimeChecks)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bCanContinueCopy = false ; } } else { bCanContinueCopy = MaxSizeToCopy<0 | | CurrentCopiedSize<MaxSizeToCopy ; } return bCanContinueCopy ; } ; int32 SizeCopiedSoFar = 0 ;)",
    "insertText": "if(!CanContinueCopyingDataCallback(MaximumBytesToCopy, SizeCopiedSoFar))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StartSliceTimeStamp = 0 . 0 ; return ; })",
    "insertText": "if(FMath::IsNearlyZero(StartSliceTimeStamp))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!ContinueTimeSliceCopy(From.Nodes, Nodes, SizeToCopyLeft, CanContinueCopyingDataCallback))"
  },
  {
    "label": "ProgressCopyTimeSliced()",
    "kind": "Method",
    "detail": "Function (DirtyElementTree ->)",
    "insertText": "ProgressCopyTimeSliced(*(From.DirtyElementTree), MaximumBytesToCopy)"
  },
  {
    "label": "ValidateBounds()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ValidateBounds(const TAABB<T, 3>& Bounds)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (const TVec3<T>& Min = Bounds .)",
    "insertText": "Min()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const TVec3<T>& Max = Bounds .)",
    "insertText": "Max()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const T& MinComponent = Min [ i ] ; const T& MaxComponent = Max [ i ] ;)",
    "insertText": "if(MinComponent > MaxComponent)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FExternalPhysicsCustomObjectVersion::GUID)"
  },
  {
    "label": "Dummy()",
    "kind": "Method",
    "detail": "Function (TAABB<T,3>)",
    "insertText": "Dummy(TVec3<T>((T)0), TVec3<T>((T)0))"
  },
  {
    "label": "SerializeAsAABB()",
    "kind": "Method",
    "detail": "Function (TBox<T,3)",
    "insertText": "SerializeAsAABB(Ar, Dummy)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} Ar<<Nodes ; Ar<<Leaves ; Ar<<DirtyElements ; Ar<<GlobalPayloads ; bool bSerializePayloadToInfo = ! bMutable ;)",
    "insertText": "if(Ar.CustomVer(FExternalPhysicsCustomObjectVersion::GUID) >= FExternalPhysicsCustomObjectVersion::ImmutableAABBTree)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<bSerializePayloadToInfo ; } else { bSerializePayloadToInfo = true ; })",
    "insertText": "if(bSerializePayloadToInfo)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<PayloadToInfo ;)",
    "insertText": "if(!bMutable)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (PayloadToInfo .)",
    "insertText": "Empty()"
  },
  {
    "label": "ensure()",
    "kind": "Method",
    "detail": "Function (bModifyingTreeMultiThreadingFastCheck = false ; bDynamicTree = false ; bBuildOverlapCache = true ; RootNode = INDEX_NONE ; FirstFreeInternalNode = INDEX_NONE ; FirstFreeLeafNode = INDEX_NONE ; } else {)",
    "insertText": "ensure(bDynamicTree == false)"
  },
  {
    "label": "FindOverlappingLeaf()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "FindOverlappingLeaf(const int32 FirstNode, const int32 LeafIndex, TArray<int32>& NodeStack)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (NodeStack .)",
    "insertText": "Add(FirstNode)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 NodeIndex = INDEX_NONE ;)",
    "insertText": "while(NodeStack.Num())"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (NodeIndex = NodeStack .)",
    "insertText": "Pop(EAllowShrinking::No)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OverlappingLeaves .)",
    "insertText": "Add(Node.ChildrenNodes[0])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "for(int32 ChildIndex = 0; ChildIndex < 2; ++ChildIndex)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (NodeStack .)",
    "insertText": "Add(Node.ChildrenNodes[ChildIndex])"
  },
  {
    "label": "AddNodesOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (} } } } } void)",
    "insertText": "AddNodesOverlappingLeaves(const TAABBTreeNode<T>& LeftNode, const TAABB<T, 3>& LeftBounds, const TAABBTreeNode<T>& RightNode, const TAABB<T, 3>& RightBounds, const bool bDirtyFilter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 LeftLeaf = LeftNode . ChildrenNodes [ 0 ] ; const int32 RightLeaf = RightNode . ChildrenNodes [ 0 ] ;)",
    "insertText": "if(!bDirtyFilter || (bDirtyFilter && (Leaves[LeftLeaf].IsLeafDirty() || Leaves[RightLeaf].IsLeafDirty())))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OverlappingPairs .)",
    "insertText": "Add(FIntVector2(LeftLeaf, RightLeaf))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + OverlappingCounts [ LeftLeaf ] ; + + OverlappingCounts [ RightLeaf ] ; } } } else)",
    "insertText": "if(LeftNode.bLeaf)"
  },
  {
    "label": "AddNodesOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddNodesOverlappingLeaves(LeftNode, LeftBounds, Nodes[RightNode.ChildrenNodes[0]], RightNode.ChildrenBounds[0], bDirtyFilter)"
  },
  {
    "label": "AddNodesOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddNodesOverlappingLeaves(LeftNode, LeftBounds, Nodes[RightNode.ChildrenNodes[1]], RightNode.ChildrenBounds[1], bDirtyFilter)"
  },
  {
    "label": "AddNodesOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "AddNodesOverlappingLeaves(Nodes[LeftNode.ChildrenNodes[0]], LeftNode.ChildrenBounds[0], RightNode, RightBounds, bDirtyFilter)"
  },
  {
    "label": "AddNodesOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddNodesOverlappingLeaves(Nodes[LeftNode.ChildrenNodes[1]], LeftNode.ChildrenBounds[1], RightNode, RightBounds, bDirtyFilter)"
  },
  {
    "label": "AddRootOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "AddRootOverlappingLeaves(const TAABBTreeNode<T>& TreeNode, const bool bDirtyFilter)"
  },
  {
    "label": "AddRootOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRootOverlappingLeaves(Nodes[TreeNode.ChildrenNodes[0]], bDirtyFilter)"
  },
  {
    "label": "AddRootOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRootOverlappingLeaves(Nodes[TreeNode.ChildrenNodes[1]], bDirtyFilter)"
  },
  {
    "label": "AddNodesOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddNodesOverlappingLeaves(Nodes[TreeNode.ChildrenNodes[0]], TreeNode.ChildrenBounds[0], Nodes[TreeNode.ChildrenNodes[1]], TreeNode.ChildrenBounds[1], bDirtyFilter)"
  },
  {
    "label": "FillPersistentOverlappingPairs()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "FillPersistentOverlappingPairs()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 NumOverlaps = 0 ;)",
    "insertText": "if(!Leaves[LeafIndex].IsLeafDirty())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OverlappingPairs .)",
    "insertText": "Add(FIntVector2(LeafIndex, OverlappingLeaves[OverlappingIndex]))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(LeafIndex != OverlappingLeaves[OverlappingIndex])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (+ + NumOverlaps ; } } } } OverlappingPairs .)",
    "insertText": "Add(FIntVector2(LeafIndex, LeafIndex))"
  },
  {
    "label": "PropagateLeavesDirtyFlag()",
    "kind": "Method",
    "detail": "Function (+ + NumOverlaps ; OverlappingCounts [ LeafIndex ] = NumOverlaps ; } } void)",
    "insertText": "PropagateLeavesDirtyFlag()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 NodeParent = Nodes [ NodeIndex ] . ParentNode ;)",
    "insertText": "while(NodeParent != INDEX_NONE && !Nodes[NodeParent].bDirtyNode)"
  },
  {
    "label": "ComputeOverlappingCacheFromRoot()",
    "kind": "Method",
    "detail": "Function (Nodes [ NodeParent ] . bDirtyNode = true ; NodeParent = Nodes [ NodeParent ] . ParentNode ; } } } } } void)",
    "insertText": "ComputeOverlappingCacheFromRoot(const bool bDirtyFilter)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (OverlappingOffsets .)",
    "insertText": "SetNum(Leaves.Num()+1, EAllowShrinking::No)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (OverlappingCounts .)",
    "insertText": "SetNum(Leaves.Num(), EAllowShrinking::No)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(int32 LeafIndex = 0, NumLeaves = Leaves.Num(); LeafIndex < NumLeaves; ++LeafIndex)"
  },
  {
    "label": "AddRootOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (OverlappingCounts [ LeafIndex ] = 1 ; } })",
    "insertText": "AddRootOverlappingLeaves(Nodes[RootNode], bDirtyFilter)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (OverlappingOffsets [ LeafIndex + 1 ] = OverlappingOffsets [ LeafIndex ] + OverlappingCounts [ LeafIndex ] ; OverlappingCounts [ LeafIndex ] = OverlappingOffsets [ LeafIndex ] ; } OverlappingLeaves .)",
    "insertText": "SetNum(OverlappingOffsets.Last(), EAllowShrinking::No)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OverlappingLeaves [ OverlappingCounts [ OverlappingPair [ 0 ] ] + + ] = OverlappingPair [ 1 ] ; OverlappingLeaves [ OverlappingCounts [ OverlappingPair [ 1 ] ] + + ] = OverlappingPair [ 0 ] ; } else { OverlappingLeaves [ OverlappingCounts [ OverlappingPair [ 0 ] ] + + ] = OverlappingPair [ 0 ] ; } })",
    "insertText": "if(bDirtyFilter)"
  },
  {
    "label": "SetDirtyState()",
    "kind": "Method",
    "detail": "Function (Leaves [ LeafIndex ] .)",
    "insertText": "SetDirtyState(false)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 NodeIndex = 0, NumNodes = Nodes.Num(); NodeIndex < NumNodes; ++NodeIndex)"
  },
  {
    "label": "ComputeOverlappingCacheFromLeaf()",
    "kind": "Method",
    "detail": "Function (Nodes [ NodeIndex ] . bDirtyNode = false ; } } } void)",
    "insertText": "ComputeOverlappingCacheFromLeaf()"
  },
  {
    "label": "FindOverlappingLeaf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindOverlappingLeaf(FirstNode, LeafIndex, NodeStack)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (} OverlappingOffsets .)",
    "insertText": "Last() = OverlappingLeaves.Num()"
  },
  {
    "label": "CacheOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CacheOverlappingLeaves()"
  },
  {
    "label": "ComputeOverlappingCacheFromRoot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeOverlappingCacheFromRoot(bDirtyFilter)"
  },
  {
    "label": "PrintOverlappingLeaves()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "PrintOverlappingLeaves()"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (auto& Leaf = Leaves [ LeafIndex ] ;)",
    "insertText": "UE_LOG(LogChaos, Log, TEXT(\"Overlapping Count[%d] = %d with bounds = %f %f %f | %f %f %f\"), LeafIndex, OverlappingOffsets[LeafIndex+1] - OverlappingOffsets[LeafIndex], Leaf.GetBounds().Min()[0], Leaf.GetBounds().Min()[1], Leaf.GetBounds().Min()[2], Leaf.GetBounds().Max()[0], Leaf.GetBounds().Max()[1], Leaf.GetBounds().Max()[2])"
  },
  {
    "label": "GetNodes()",
    "kind": "Method",
    "detail": "Function (} } } const TArray<TAABBTreeNode<T>>&)",
    "insertText": "GetNodes()"
  },
  {
    "label": "TRACE_CPUPROFILER_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_CPUPROFILER_EVENT_SCOPE(TAABBTree::ReoptimizeTree)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (TArray<FElement> AllElements ; int32 ReserveCount = DirtyElements .)",
    "insertText": "Num() + GlobalPayloads.Num()"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (const TLeafType& Leaf = Leaves [ LeafIndex ] ; ReserveCount + = static_cast<)",
    "insertText": "int32(Leaf.GetReserveCount())"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} AllElements .)",
    "insertText": "Reserve(ReserveCount)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (AllElements .)",
    "insertText": "Append(DirtyElements)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (AllElements .)",
    "insertText": "Append(GlobalPayloads)"
  },
  {
    "label": "NewTree()",
    "kind": "Method",
    "detail": "Function (} TAABBTree)",
    "insertText": "NewTree(AllElements)"
  },
  {
    "label": "DoForHitGridCellsAndOverflow()",
    "kind": "Method",
    "detail": "Function (* this = NewTree ; bShouldRebuild = true ; } template<FunctionType> bool)",
    "insertText": "DoForHitGridCellsAndOverflow(TArray<DirtyGridHashEntry>& HashEntryForOverlappedCells, FunctionType Function)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bool DoneWithGridElements = false ; bool DoneWithNonGridElements = false ; int NonGridElementIter = 0 ;)",
    "insertText": "while(!DoneWithGridElements || !DoneWithNonGridElements)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 SmallestDirtyParticleIndex = INT_MAX ;)",
    "insertText": "if(!DoneWithGridElements)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 Count = HashEntry . Count ;)",
    "insertText": "if(Count > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 DirtyParticleIndex = FlattenedCellArrayOfDirtyIndices [ HashEntry . Index ] ;)",
    "insertText": "if(DirtyParticleIndex < SmallestDirtyParticleIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 DirtyParticleIndex = FlattenedCellArrayOfDirtyIndices [ HashEntry . Index ] ;)",
    "insertText": "if(DirtyParticleIndex == SmallestDirtyParticleIndex)"
  },
  {
    "label": "ensure()",
    "kind": "Method",
    "detail": "Function (SmallestDirtyParticleIndex = DirtyElementsGridOverflow [ NonGridElementIter ] ; + + NonGridElementIter ; })",
    "insertText": "ensure(DoneWithGridElements || PayloadToInfo.Find(DirtyElements[SmallestDirtyParticleIndex].Payload)->DirtyGridOverflowIdx == INDEX_NONE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 Index = SmallestDirtyParticleIndex ; const auto& Elem = DirtyElements [ Index ] ;)",
    "insertText": "if(!Function(Elem))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bCouldUseCache = false ; bOverlapResult = true ;)",
    "insertText": "if(Query == EAABBQueryType::Overlap && Visitor.GetQueryPayload())"
  },
  {
    "label": "TPayloadType()",
    "kind": "Method",
    "detail": "Function (const TPayloadType& QueryPayload =* static_cast<const)",
    "insertText": "TPayloadType(Visitor.GetQueryPayload())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int32 LeafIndex = QueryInfo -> LeafIdx ;)",
    "insertText": "if(LeafIndex != INDEX_NONE && LeafIndex < (OverlappingOffsets.Num()-1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const TLeafType& OverlappingLeaf = Leaves [ OverlappingLeaves [ OverlappingIndex ] ] ;)",
    "insertText": "if(OverlappingLeaf.OverlapFast(QueryBounds, Visitor) == false)"
  },
  {
    "label": "QueryImp()",
    "kind": "Method",
    "detail": "Function (bOverlapResult = false ; break ; } } bCouldUseCache = true ; } } } return bCouldUseCache ; } template<EAABBQueryType Query,TQueryFastData,SQVisitor> bool)",
    "insertText": "QueryImp(const FVec3& RESTRICT Start, TQueryFastData& CurData, const FVec3& QueryHalfExtents, const FAABB3& QueryBounds, SQVisitor& Visitor, const FVec3& Dir, const FVec3& InvDir, const bool bParallel[3])"
  },
  {
    "label": "PHYSICS_CSV_CUSTOM_VERY_EXPENSIVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PHYSICS_CSV_CUSTOM_VERY_EXPENSIVE(PhysicsCounters, MaxDirtyElements, DirtyElements.Num(), ECsvCustomStatOp::Max)"
  },
  {
    "label": "PHYSICS_CSV_CUSTOM_VERY_EXPENSIVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PHYSICS_CSV_CUSTOM_VERY_EXPENSIVE(PhysicsCounters, MaxNumLeaves, Leaves.Num(), ECsvCustomStatOp::Max)"
  },
  {
    "label": "PHYSICS_CSV_SCOPED_VERY_EXPENSIVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PHYSICS_CSV_SCOPED_VERY_EXPENSIVE(PhysicsVerbose, QueryImp)"
  },
  {
    "label": "PHYSICS_CSV_SCOPED_VERY_EXPENSIVE()",
    "kind": "Method",
    "detail": "Function (# if ! WITH_EDITOR # endif FReal TOI = 0 ; {)",
    "insertText": "PHYSICS_CSV_SCOPED_VERY_EXPENSIVE(PhysicsVerbose, QueryImp_Global)"
  },
  {
    "label": "VisitData()",
    "kind": "Method",
    "detail": "Function (TSpatialVisitorData<TPayloadType>)",
    "insertText": "VisitData(Elem.Payload,true, InstanceBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bContinue ;)",
    "insertText": "if(Query == EAABBQueryType::Overlap)"
  },
  {
    "label": "VisitOverlap()",
    "kind": "Method",
    "detail": "Function (bContinue = Visitor .)",
    "insertText": "VisitOverlap(VisitData)"
  },
  {
    "label": "VisitSweep()",
    "kind": "Method",
    "detail": "Function (} else { bContinue = Query = = EAABBQueryType::Sweep ? Visitor .)",
    "insertText": "VisitSweep(VisitData,CurData) : Visitor.VisitRaycast(VisitData,CurData)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!bContinue)"
  },
  {
    "label": "IntersectAndVisit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IntersectAndVisit(const FElement& Elem)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (bool bContinue ; if)",
    "insertText": "constexpr(Query == EAABBQueryType::Overlap)"
  },
  {
    "label": "VisitSweep()",
    "kind": "Method",
    "detail": "Function (} else { bContinue = Query = = EAABBQueryType::Sweep ? Visitor .)",
    "insertText": "VisitSweep(VisitData, CurData) : Visitor.VisitRaycast(VisitData, CurData)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bUseGrid = false ;)",
    "insertText": "if(DirtyElementGridEnabled() && CellHashToFlatArray.Num() > 0)"
  },
  {
    "label": "TooManyOverlapQueryCells()",
    "kind": "Method",
    "detail": "Function (bUseGrid = !)",
    "insertText": "TooManyOverlapQueryCells(QueryBounds, DirtyElementGridCellSizeInv, DirtyElementMaxGridCellQueryCount)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(Query == EAABBQueryType::Raycast)"
  },
  {
    "label": "TooManyRaycastQueryCells()",
    "kind": "Method",
    "detail": "Function (bUseGrid = !)",
    "insertText": "TooManyRaycastQueryCells(Start, CurData.Dir, CurData.CurrentLength, DirtyElementGridCellSizeInv, DirtyElementMaxGridCellQueryCount)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(Query == EAABBQueryType::Sweep)"
  },
  {
    "label": "TooManySweepQueryCells()",
    "kind": "Method",
    "detail": "Function (bUseGrid = !)",
    "insertText": "TooManySweepQueryCells(QueryHalfExtents, Start, CurData.Dir, CurData.CurrentLength, DirtyElementGridCellSizeInv, DirtyElementMaxGridCellQueryCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(bUseGrid)"
  },
  {
    "label": "PHYSICS_CSV_SCOPED_VERY_EXPENSIVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PHYSICS_CSV_SCOPED_VERY_EXPENSIVE(PhysicsVerbose, QueryImp_DirtyElementsGrid)"
  },
  {
    "label": "AddHashEntry()",
    "kind": "Method",
    "detail": "Function (TArray<DirtyGridHashEntry> HashEntryForOverlappedCells ; auto)",
    "insertText": "AddHashEntry(int32 QueryCellHash)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (const DirtyGridHashEntry* HashEntry = CellHashToFlatArray .)",
    "insertText": "Find(QueryCellHash)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (HashEntryForOverlappedCells .)",
    "insertText": "Add(*HashEntry)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!DoForHitGridCellsAndOverflow(HashEntryForOverlappedCells, IntersectAndVisit))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bOverlapResult = true ;)",
    "insertText": "if(OverlapCached<Query, SQVisitor>(QueryBounds, Visitor, bOverlapResult))"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (NodeStack .)",
    "insertText": "Emplace(FNodeQueueEntry{RootNode, 0})"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(Nodes.Num())"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (NodeStack .)",
    "insertText": "Emplace(FNodeQueueEntry{ 0, 0 })"
  },
  {
    "label": "VectorLoadDouble3()",
    "kind": "Method",
    "detail": "Function (StartSimd =)",
    "insertText": "VectorLoadDouble3(&Start.X)"
  },
  {
    "label": "VectorLoadDouble3()",
    "kind": "Method",
    "detail": "Function (DirSimd =)",
    "insertText": "VectorLoadDouble3(&Dir.X)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (Parallel =)",
    "insertText": "VectorCompareGT(GlobalVectorConstants::DoubleSmallNumber, VectorAbs(DirSimd))"
  },
  {
    "label": "VectorBitwiseNotAnd()",
    "kind": "Method",
    "detail": "Function (InvDirSimd =)",
    "insertText": "VectorBitwiseNotAnd(Parallel, VectorDivide(VectorOne(), DirSimd))"
  },
  {
    "label": "VectorSetDouble1()",
    "kind": "Method",
    "detail": "Function (LengthSimd =)",
    "insertText": "VectorSetDouble1(CurData.CurrentLength)"
  },
  {
    "label": "PHYSICS_CSV_SCOPED_VERY_EXPENSIVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PHYSICS_CSV_SCOPED_VERY_EXPENSIVE(PhysicsVerbose, QueryImp_NodeTraverse)"
  },
  {
    "label": "PHYSICS_CSV_SCOPED_VERY_EXPENSIVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PHYSICS_CSV_SCOPED_VERY_EXPENSIVE(PhysicsVerbose, NodeTraverse_Leaf)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (int32 Idx = 0 ; if)",
    "insertText": "constexpr(Query != EAABBQueryType::Overlap)"
  },
  {
    "label": "AABBVectorized()",
    "kind": "Method",
    "detail": "Function (FAABBVectorizedDouble)",
    "insertText": "AABBVectorized(Node.ChildrenBounds[0])"
  },
  {
    "label": "RaycastFast()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Double TOISimd ; bIntersect0 = AABBVectorized .)",
    "insertText": "RaycastFast(StartSimd, InvDirSimd, Parallel, LengthSimd, TOISimd)"
  },
  {
    "label": "VectorStoreDouble1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreDouble1(TOISimd, &TOI0)"
  },
  {
    "label": "FAABBVectorizedDouble()",
    "kind": "Method",
    "detail": "Function (AABBVectorized =)",
    "insertText": "FAABBVectorizedDouble(Node.ChildrenBounds[1])"
  },
  {
    "label": "VectorStoreDouble1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreDouble1(TOISimd, &TOI1)"
  },
  {
    "label": "AABB0()",
    "kind": "Method",
    "detail": "Function (} else { FAABB3)",
    "insertText": "AABB0(Node.ChildrenBounds[0].Min(), Node.ChildrenBounds[0].Max())"
  },
  {
    "label": "Intersects()",
    "kind": "Method",
    "detail": "Function (bIntersect0 = TAABBTreeIntersectionHelper<TQueryFastData,Query)",
    "insertText": "Intersects(Start, CurData, TOI0, AABB0, QueryBounds, QueryHalfExtents, Dir, InvDir, bParallel)"
  },
  {
    "label": "AABB1()",
    "kind": "Method",
    "detail": "Function (FAABB3)",
    "insertText": "AABB1(Node.ChildrenBounds[1].Min(), Node.ChildrenBounds[1].Max())"
  },
  {
    "label": "Intersects()",
    "kind": "Method",
    "detail": "Function (bIntersect1 = TAABBTreeIntersectionHelper<TQueryFastData,Query)",
    "insertText": "Intersects(Start, CurData, TOI1, AABB1, QueryBounds, QueryHalfExtents, Dir, InvDir, bParallel)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bIntersect0 && bIntersect1)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (NodeStack .)",
    "insertText": "Emplace(FNodeQueueEntry{Node.ChildrenNodes[1], TOI1})"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (NodeStack .)",
    "insertText": "Emplace(FNodeQueueEntry{Node.ChildrenNodes[0], TOI0})"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (NodeStack .)",
    "insertText": "Emplace(FNodeQueueEntry{ Node.ChildrenNodes[1], TOI1 })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(bIntersect0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(bIntersect1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "for(const TAABB<T, 3>&AABB : Node.ChildrenBounds)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (NodeStack .)",
    "insertText": "Emplace(FNodeQueueEntry{ Node.ChildrenNodes[Idx], TOI })"
  },
  {
    "label": "GetNewWorkSnapshot()",
    "kind": "Method",
    "detail": "Function (} + + Idx ; } } } } return true ; } int32)",
    "insertText": "GetNewWorkSnapshot()"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (} else { return WorkPool .)",
    "insertText": "AddDefaulted(1)"
  },
  {
    "label": "FreeWorkSnapshot()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "FreeWorkSnapshot(int32 WorkSnapshotIdx)"
  },
  {
    "label": "FWorkSnapshot()",
    "kind": "Method",
    "detail": "Function (WorkPool [ WorkSnapshotIdx ] =)",
    "insertText": "FWorkSnapshot()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (WorkPoolFreeList .)",
    "insertText": "Add(WorkSnapshotIdx)"
  },
  {
    "label": "GenerateTree()",
    "kind": "Method",
    "detail": "Function (} template<TParticles> void)",
    "insertText": "GenerateTree(const TParticles& Particles)"
  },
  {
    "label": "SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SCOPE_CYCLE_COUNTER(STAT_AABBTreeGenerateTree)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (int32 NumParticles = 0 ; bool bIsValidParticleArray = ! std::is_same_v<TParticles,std::nullptr_t> ; if)",
    "insertText": "constexpr(bIsValidParticleArray)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} const int32 ExpectedNumLeaves = NumParticles / MaxChildrenInLeaf ; const int32 ExpectedNumNodes = ExpectedNumLeaves ; WorkStack .)",
    "insertText": "Reserve(ExpectedNumNodes)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (FWorkSnapshot& WorkSnapshot = WorkPool [ CurIdx ] ; WorkSnapshot . Elems .)",
    "insertText": "Reserve(NumParticles)"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (bool bHasBoundingBox =)",
    "insertText": "HasBoundingBox(Particle)"
  },
  {
    "label": "TPayloadType()",
    "kind": "Method",
    "detail": "Function (auto Payload = Particle . template GetPayload<)",
    "insertText": "TPayloadType(Idx)"
  },
  {
    "label": "ComputeWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (TAABB<T,3> ElemBounds =)",
    "insertText": "ComputeWorldSpaceBoundingBox(Particle, false, (T)0)"
  },
  {
    "label": "UpdateElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateElement(Payload, ElemBounds, bHasBoundingBox)"
  },
  {
    "label": "SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "SCOPE_CYCLE_COUNTER(STAT_AABBTreeTimeSliceSetup)"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (WorkSnapshot . AverageCenter =)",
    "insertText": "FVec3(0)"
  },
  {
    "label": "CenterSum()",
    "kind": "Method",
    "detail": "Function (int32 Idx = 0 ; TVec3<T>)",
    "insertText": "CenterSum(0)"
  },
  {
    "label": "ensureMsgf()",
    "kind": "Method",
    "detail": "Function (bHasBoundingBox = false ;)",
    "insertText": "ensureMsgf(false, TEXT(\"AABBTree encountered invalid bounds input. Forcing element to global payload. Min: %s Max: %s.\"), *ElemBounds.Min().ToString(), *ElemBounds.Max().ToString())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bHasBoundingBox)"
  },
  {
    "label": "NumElems()",
    "kind": "Method",
    "detail": "Function (bHasBoundingBox = false ; } else { FReal)",
    "insertText": "NumElems(FReal)(WorkSnapshot.Elems.Add(FElement{ Payload, ElemBounds }) + 1)"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (WorkSnapshot . Bounds .)",
    "insertText": "GrowToInclude(ElemBounds)"
  },
  {
    "label": "Center()",
    "kind": "Method",
    "detail": "Function (TVec3<T> CenterDelta = ElemBounds .)",
    "insertText": "Center()"
  },
  {
    "label": "CenterDelta()",
    "kind": "Method",
    "detail": "Function (WorkSnapshot . AverageCenter + =)",
    "insertText": "CenterDelta(T)"
  },
  {
    "label": "ScaledCenterVariance()",
    "kind": "Method",
    "detail": "Function (WorkSnapshot .)",
    "insertText": "ScaledCenterVariance(ElemBounds.Center() - WorkSnapshot.AverageCenter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!bHasBoundingBox)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (PayloadToInfo .)",
    "insertText": "Add(Payload, FAABBTreePayloadInfo{ GlobalPayloads.Num(), INDEX_NONE, INDEX_NONE, INDEX_NONE })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} GlobalPayloads .)",
    "insertText": "Add(FElement{ Payload, ElemBounds })"
  },
  {
    "label": "SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (} + + Idx ; } } } NumProcessedThisSlice = NumParticles ; {)",
    "insertText": "SCOPE_CYCLE_COUNTER(STAT_AABBTreeInitialTimeSlice)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (WorkSnapshot . NewNodeIdx = 0 ; WorkSnapshot . NodeLevel = 0 ; WorkStack .)",
    "insertText": "Add(CurIdx)"
  },
  {
    "label": "FWorkSnapshot()",
    "kind": "Method",
    "detail": "Function (} } enum eTimeSlicePhase { PreFindBestBounds,DuringFindBestBounds,ProcessingChildren } ; struct FSplitInfo { TAABB<T,3> RealBounds ; int32 WorkSnapshotIdx ; } ; struct FWorkSnapshot {)",
    "insertText": "FWorkSnapshot() : TimeslicePhase(eTimeSlicePhase::PreFindBestBounds)"
  },
  {
    "label": "GetLastIndexToProcess()",
    "kind": "Method",
    "detail": "Function (} eTimeSlicePhase TimeslicePhase ; TAABB<T,3> Bounds ; TArray<FElement> Elems ; TVec3<T> AverageCenter ; TVec3<T> ScaledCenterVariance ; int32 NodeLevel ; int32 NewNodeIdx ; int32 BestBoundsCurIdx ; FSplitInfo SplitInfos [ 2 ] ; } ; int32)",
    "insertText": "GetLastIndexToProcess(int32 CurrentIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 LastNodeToProcessIndex = 0 ;)",
    "insertText": "if(FAABBTimeSliceCVars::bUseTimeSliceMillisecondBudget)"
  },
  {
    "label": "WeAreTimeslicing()",
    "kind": "Method",
    "detail": "Function (} else { const bool)",
    "insertText": "WeAreTimeslicing(MaxNumToProcess > 0)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (const int32 NumWeCanProcess = MaxNumToProcess - NumProcessedThisSlice ; LastNodeToProcessIndex = WeAreTimeslicing ?)",
    "insertText": "Min(WorkPool[CurrentIndex].BestBoundsCurIdx + NumWeCanProcess, WorkPool[CurrentIndex].Elems.Num()) : WorkPool[CurrentIndex].Elems.Num()"
  },
  {
    "label": "CanContinueProcessingNodes()",
    "kind": "Method",
    "detail": "Function (} return LastNodeToProcessIndex ; } bool)",
    "insertText": "CanContinueProcessingNodes(bool bOnlyUseTimeStampCheck = true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bCheckIfHasAvailableTime = false ;)",
    "insertText": "if(bOnlyUseTimeStampCheck)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bCheckIfHasAvailableTime = true ; } else { CurrentProcessedNodesSinceChecked + + ;)",
    "insertText": "if(CurrentProcessedNodesSinceChecked > FAABBTimeSliceCVars::MinNodesChunkToProcessBetweenTimeChecks)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CurrentProcessedNodesSinceChecked = 0 ; bCheckIfHasAvailableTime = true ; } })",
    "insertText": "if(bCheckIfHasAvailableTime)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const bool WeAreTimeslicing = FAABBTimeSliceCVars::MaxProcessingTimePerSliceSeconds> 0&& MaxNumToProcess> 0 ;)",
    "insertText": "if(WeAreTimeslicing && !FMath::IsNearlyZero(StartSliceTimeStamp) && ElapsedTime > FAABBTimeSliceCVars::MaxProcessingTimePerSliceSeconds)"
  },
  {
    "label": "FindBestBounds()",
    "kind": "Method",
    "detail": "Function (bCanDoWork = false ; } } return bCanDoWork ; } void)",
    "insertText": "FindBestBounds(const int32 StartElemIdx, int32& InOutLastElem, FWorkSnapshot& CurrentSnapshot, int32 MaxAxis, const TVec3<T>& SplitCenter)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const T SplitVal = SplitCenter [ MaxAxis ] ;)",
    "insertText": "for(int32 ElemIdx = StartElemIdx; ElemIdx < InOutLastElem; ++ElemIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T CenterVal = ElemCenter [ 0 ] ;)",
    "insertText": "if(MaxAxis == 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CenterVal = ElemCenter [ 1 ] ; } else)",
    "insertText": "if(MaxAxis == 2)"
  },
  {
    "label": "NumElems()",
    "kind": "Method",
    "detail": "Function (CenterVal = ElemCenter [ 2 ] ; } const int32 MinBoxIdx = CenterVal<= SplitVal ? 0 : 1 ; FSplitInfo& SplitInfo = CurrentSnapshot . SplitInfos [ MinBoxIdx ] ; FWorkSnapshot& WorkSnapshot = WorkPool [ SplitInfo . WorkSnapshotIdx ] ; T)",
    "insertText": "NumElems(T)(WorkSnapshot.Elems.Add(Elem) + 1)"
  },
  {
    "label": "ScaledCenterVariance()",
    "kind": "Method",
    "detail": "Function (TVec3<T> CenterDelta = ElemCenter - WorkSnapshot . AverageCenter ; WorkSnapshot . AverageCenter + = CenterDelta / NumElems ; WorkSnapshot .)",
    "insertText": "ScaledCenterVariance(ElemCenter - WorkSnapshot.AverageCenter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bOnlyUSeTimeStampCheck = false ;)",
    "insertText": "if(!CanContinueProcessingNodes(bOnlyUSeTimeStampCheck))"
  },
  {
    "label": "FreeWorkSnapshot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeWorkSnapshot(CurIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } const int32 NewNodeIdx = WorkPool [ CurIdx ] . NewNodeIdx ;)",
    "insertText": "if(NewNodeIdx >= Nodes.Num())"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (Nodes .)",
    "insertText": "AddDefaulted((1 + NewNodeIdx) - Nodes.Num())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!CanContinueProcessingNodes())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (PayloadToInfoRef .)",
    "insertText": "Add(Elem.Payload, FAABBTreePayloadInfo{ INDEX_NONE, INDEX_NONE, LeavesRef.Num() })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} } NodesRef [ NewNodeIdx ] . bLeaf = true ; NodesRef [ NewNodeIdx ] . ChildrenNodes [ 0 ] = LeavesRef .)",
    "insertText": "Add(TLeafType{ WorkPoolRef[CurIdx].Elems })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "if(WorkPool[CurIdx].Elems.Num() <= MaxChildrenInLeaf || WorkPool[CurIdx].NodeLevel >= MaxTreeDepth)"
  },
  {
    "label": "MakeLeaf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MakeLeaf()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(WorkPool[CurIdx].TimeslicePhase == eTimeSlicePhase::PreFindBestBounds)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (WorkPool [ CurIdx ] . SplitInfos [ 0 ] . WorkSnapshotIdx = FirstChildIdx ; WorkPool [ CurIdx ] . SplitInfos [ 1 ] . WorkSnapshotIdx = SecondChildIdx ;)",
    "insertText": "for(FSplitInfo& SplitInfo : WorkPool[CurIdx].SplitInfos)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function ({ WorkPool [ FirstChildIdx ] . Elems .)",
    "insertText": "Reserve(ExpectedNumPerChild)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (WorkPool [ FirstChildIdx ] . AverageCenter = TVec3<)",
    "insertText": "T(0)"
  },
  {
    "label": "GetLastIndexToProcess()",
    "kind": "Method",
    "detail": "Function (int32 LastIdxToProcess =)",
    "insertText": "GetLastIndexToProcess(CurIdx)"
  },
  {
    "label": "MaxAxis()",
    "kind": "Method",
    "detail": "Function (const int32)",
    "insertText": "MaxAxis(FAABBTreeCVars::SplitOnVarianceAxis != 1) ? WorkPool[CurIdx].Bounds.LargestAxis() : (WorkPool[CurIdx].ScaledCenterVariance[0] > WorkPool[CurIdx].ScaledCenterVariance[1] ? (WorkPool[CurIdx].ScaledCenterVariance[0] > WorkPool[CurIdx].ScaledCenterVariance[2] ? 0 : 2) : (WorkPool[CurIdx].ScaledCenterVariance[1] > WorkPool[CurIdx].ScaledCenterVariance[2] ? 1 : 2))"
  },
  {
    "label": "Center()",
    "kind": "Method",
    "detail": "Function (const TVec3<T>&)",
    "insertText": "Center(FAABBTreeCVars::SplitAtAverageCenter != 1) ? WorkPool[CurIdx].Bounds.Center()"
  },
  {
    "label": "FindBestBounds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindBestBounds(WorkPool[CurIdx].BestBoundsCurIdx, LastIdxToProcess, WorkPool[CurIdx], MaxAxis, Center)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (WorkPool [ FirstChildIdx ] . NodeLevel = WorkPool [ CurIdx ] . NodeLevel + 1 ; WorkPool [ SecondChildIdx ] . NodeLevel = WorkPool [ CurIdx ] . NodeLevel + 1 ; WorkPool [ FirstChildIdx ] . NewNodeIdx = Nodes [ NewNodeIdx ] . ChildrenNodes [ 0 ] ; WorkPool [ SecondChildIdx ] . NewNodeIdx = Nodes [ NewNodeIdx ] . ChildrenNodes [ 1 ] ; WorkStack .)",
    "insertText": "Add(SecondChildIdx)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (WorkStack .)",
    "insertText": "Add(FirstChildIdx)"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (const int32 HighestNodeIdx = Nodes [ NewNodeIdx ] . ChildrenNodes [ 1 ] ; Nodes .)",
    "insertText": "AddDefaulted((1 + HighestNodeIdx) - Nodes.Num())"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "check(WorkStack.Num() == 0)"
  },
  {
    "label": "FindAllIntersectionsImp()",
    "kind": "Method",
    "detail": "Function (} TArray<TPayloadType>)",
    "insertText": "FindAllIntersectionsImp(const FAABB3& Intersection)"
  },
  {
    "label": "FSimpleVisitor()",
    "kind": "Method",
    "detail": "Function (struct FSimpleVisitor {)",
    "insertText": "FSimpleVisitor(TArray<TPayloadType>& InResults) : CollectedResults(InResults)"
  },
  {
    "label": "VisitOverlap()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "VisitOverlap(const TSpatialVisitorData<TPayloadType>& Instance)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (CollectedResults .)",
    "insertText": "Add(Instance.Payload)"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Overlap(Intersection, Collector)"
  },
  {
    "label": "AddFrom()",
    "kind": "Method",
    "detail": "Function (ContainerTo .)",
    "insertText": "AddFrom(ContainerFrom, Index)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(std::is_same_v<ContainerType, TSQMap<TPayloadType, FAABBTreePayloadInfo>>)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { ContainerTo .)",
    "insertText": "Add(ContainerFrom[Index])"
  },
  {
    "label": "ContainerElementSizeHelper()",
    "kind": "Method",
    "detail": "Function (} } template<ContainerType> int32)",
    "insertText": "ContainerElementSizeHelper(const ContainerType& Container, int32 Index)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(std::is_same_v<ContainerType, TArray<TAABBTreeLeafArray<TPayloadType, false>>>)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "sizeof(typename ContainerType::ElementType)"
  },
  {
    "label": "ContinueTimeSliceCopy()",
    "kind": "Method",
    "detail": "Function (} } template<ContainerType,TCanContinueCallback> bool)",
    "insertText": "ContinueTimeSliceCopy(const ContainerType& ContainerFrom, ContainerType& ContainerTo, int32& InOutMaxSize, const TCanContinueCallback& CanContinueCallback)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 SizeCopied = 0 ;)",
    "insertText": "for(int32 Index = ContainerTo.Num(); Index < ContainerFrom.Num() && CanContinueCallback(InOutMaxSize, SizeCopied); Index++)"
  },
  {
    "label": "AddToContainerHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddToContainerHelper(ContainerFrom, ContainerTo, Index)"
  },
  {
    "label": "ContainerElementSizeHelper()",
    "kind": "Method",
    "detail": "Function (SizeCopied + =)",
    "insertText": "ContainerElementSizeHelper(ContainerFrom, Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InOutMaxSize > 0)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (InOutMaxSize = 0 ; } else { InOutMaxSize - = SizeCopied ; } } bool Done = ContainerTo .)",
    "insertText": "Num() == ContainerFrom.Num()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 RootNodeIndex = bDynamicTree ? RootNode : 0 ;)",
    "insertText": "if(Nodes.Num() > 0 && Nodes.IsValidIndex(RootNodeIndex))"
  },
  {
    "label": "DebugDraw()",
    "kind": "Method",
    "detail": "Function (Nodes [ RootNodeIndex ] .)",
    "insertText": "DebugDraw(*InInterface, Nodes, { 1.f, 1.f, 1.f }, 5.f)"
  },
  {
    "label": "DebugDrawLeaf()",
    "kind": "Method",
    "detail": "Function (const TLeafType& Leaf = Leaves [ LeafIndex ] ; Leaf .)",
    "insertText": "DebugDrawLeaf(*InInterface, FLinearColor::MakeRandomColor(), 10.f)"
  },
  {
    "label": "TAABBTree()",
    "kind": "Method",
    "detail": "Function (} } } # endif)",
    "insertText": "TAABBTree(const TAABBTree& Other) : ISpatialAcceleration<TPayloadType, T, 3>(StaticType) , Nodes(Other.Nodes) , Leaves(Other.Leaves) , DirtyElements(Other.DirtyElements) , bDynamicTree(Other.bDynamicTree) , RootNode(Other.RootNode) , FirstFreeInternalNode(Other.FirstFreeInternalNode) , FirstFreeLeafNode(Other.FirstFreeLeafNode) , CellHashToFlatArray(Other.CellHashToFlatArray) , FlattenedCellArrayOfDirtyIndices(Other.FlattenedCellArrayOfDirtyIndices) , DirtyElementsGridOverflow(Other.DirtyElementsGridOverflow) , DirtyElementTree(nullptr) , DirtyElementGridCellSize(Other.DirtyElementGridCellSize) , DirtyElementGridCellSizeInv(Other.DirtyElementGridCellSizeInv) , DirtyElementMaxGridCellQueryCount(Other.DirtyElementMaxGridCellQueryCount) , DirtyElementMaxPhysicalSizeInCells(Other.DirtyElementMaxPhysicalSizeInCells) , DirtyElementMaxCellCapacity(Other.DirtyElementMaxCellCapacity) , TreeStats(Other.TreeStats) , TreeExpensiveStats(Other.TreeExpensiveStats) , GlobalPayloads(Other.GlobalPayloads) , PayloadToInfo(Other.PayloadToInfo) , MaxChildrenInLeaf(Other.MaxChildrenInLeaf) , MaxTreeDepth(Other.MaxTreeDepth) , MaxPayloadBounds(Other.MaxPayloadBounds) , MaxNumToProcess(Other.MaxNumToProcess) , NumProcessedThisSlice(Other.NumProcessedThisSlice) , StartSliceTimeStamp(Other.StartSliceTimeStamp) , bModifyingTreeMultiThreadingFastCheck(Other.bModifyingTreeMultiThreadingFastCheck) , bShouldRebuild(Other.bShouldRebuild) , bBuildOverlapCache(Other.bBuildOverlapCache) , OverlappingLeaves(Other.OverlappingLeaves) , OverlappingOffsets(Other.OverlappingOffsets) , OverlappingPairs(Other.OverlappingPairs) , OverlappingCounts(Other.OverlappingCounts)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (PriorityQ .)",
    "insertText": "Reserve(32)"
  },
  {
    "label": "TAABBTree()",
    "kind": "Method",
    "detail": "Function (DirtyElementTree = TUniquePtr<)",
    "insertText": "TAABBTree(new TAABBTree(*(Other.DirtyElementTree)))"
  },
  {
    "label": "DeepAssign()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DeepAssign(const ISpatialAcceleration<TPayloadType, T, 3>& Other)"
  },
  {
    "label": "TAABBTree()",
    "kind": "Method",
    "detail": "Function (* this = static_cast<const)",
    "insertText": "TAABBTree(Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TAABBTree&)",
    "insertText": "operator(const TAABBTree& Rhs)"
  },
  {
    "label": "DeepAssign()",
    "kind": "Method",
    "detail": "Function (ISpatialAcceleration<TPayloadType,T,3)",
    "insertText": "DeepAssign(Rhs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Nodes = Rhs . Nodes ; Leaves = Rhs . Leaves ; DirtyElements = Rhs . DirtyElements ; bDynamicTree = Rhs . bDynamicTree ; RootNode = Rhs . RootNode ; FirstFreeInternalNode = Rhs . FirstFreeInternalNode ; FirstFreeLeafNode = Rhs . FirstFreeLeafNode ; CellHashToFlatArray = Rhs . CellHashToFlatArray ; FlattenedCellArrayOfDirtyIndices = Rhs . FlattenedCellArrayOfDirtyIndices ; DirtyElementsGridOverflow = Rhs . DirtyElementsGridOverflow ; TreeStats = Rhs . TreeStats ; TreeExpensiveStats = Rhs . TreeExpensiveStats ; DirtyElementGridCellSize = Rhs . DirtyElementGridCellSize ; DirtyElementGridCellSizeInv = Rhs . DirtyElementGridCellSizeInv ; DirtyElementMaxGridCellQueryCount = Rhs . DirtyElementMaxGridCellQueryCount ; DirtyElementMaxPhysicalSizeInCells = Rhs . DirtyElementMaxPhysicalSizeInCells ; DirtyElementMaxCellCapacity = Rhs . DirtyElementMaxCellCapacity ; GlobalPayloads = Rhs . GlobalPayloads ; PayloadToInfo = Rhs . PayloadToInfo ; MaxChildrenInLeaf = Rhs . MaxChildrenInLeaf ; MaxTreeDepth = Rhs . MaxTreeDepth ; MaxPayloadBounds = Rhs . MaxPayloadBounds ; MaxNumToProcess = Rhs . MaxNumToProcess ; NumProcessedThisSlice = Rhs . NumProcessedThisSlice ; StartSliceTimeStamp = Rhs . StartSliceTimeStamp ; bModifyingTreeMultiThreadingFastCheck = Rhs . bModifyingTreeMultiThreadingFastCheck ; bShouldRebuild = Rhs . bShouldRebuild ; bBuildOverlapCache = Rhs . bBuildOverlapCache ;)",
    "insertText": "if(Rhs.DirtyElementTree)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (}* DirtyElementTree =* Rhs . DirtyElementTree ; } else { DirtyElementTree = nullptr ; } } return* this ; } TArray<FNode> Nodes ; TLeafContainer<TLeafType> Leaves ; TArray<FElement> DirtyElements ; bool bDynamicTree = false ; int32 RootNode = INDEX_NONE ; int32 FirstFreeInternalNode = INDEX_NONE ; int32 FirstFreeLeafNode = INDEX_NONE ; TMap<int32,DirtyGridHashEntry> CellHashToFlatArray ; TArray<int32> FlattenedCellArrayOfDirtyIndices ; TArray<int32> DirtyElementsGridOverflow ; TUniquePtr<TAABBTree> DirtyElementTree ; T DirtyElementGridCellSize ; T DirtyElementGridCellSizeInv ; int32 DirtyElementMaxGridCellQueryCount ; int32 DirtyElementMaxPhysicalSizeInCells ; int32 DirtyElementMaxCellCapacity ; AABBTreeStatistics TreeStats ; AABBTreeExpensiveStatistics TreeExpensiveStats ; TArray<FElement> GlobalPayloads ; StorageTraits::PayloadToInfoType PayloadToInfo ; int32 MaxChildrenInLeaf ; int32 MaxTreeDepth ; T MaxPayloadBounds ; int32 MaxNumToProcess ; int32 NumProcessedThisSlice ; double StartSliceTimeStamp = 0 . 0 ; int32 CurrentProcessedNodesSinceChecked = 0 ; int32 CurrentDataElementsCopiedSinceLastCheck = 0 ; TArray<int32> WorkStack ; TArray<int32> WorkPoolFreeList ; TArray<FWorkSnapshot> WorkPool ; bool bModifyingTreeMultiThreadingFastCheck ; bool bShouldRebuild ; bool bBuildOverlapCache ; TArray<int32> OverlappingLeaves ; TArray<int32> OverlappingOffsets ; TArray<FIntVector2> OverlappingPairs ; TArray<int32> OverlappingCounts ; using FNodeIndexAndCost = TTuple<FNode&,int32,FReal> ; TArray<FNodeIndexAndCost> PriorityQ ;::FChaosVDDataWrapperUtils ; } ; template<TPayloadType,TLeafType,bool bMutable,T,StorageTraits> FArchive&)",
    "insertText": "operator(FChaosArchive& Ar, TAABBTree<TPayloadType, TLeafType, bMutable, T, StorageTraits>& AABBTree)"
  }
]