[
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "LockFreeAddressHashSetTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LockFreeAddressHashSetTest"
  },
  {
    "label": "Node",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Node"
  },
  {
    "label": "LockFreeAddressHashSet()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_SAMPLING_HEAP_PROFILER_LOCK_FREE_ADDRESS_HASH_SET_H_ # define BASE_SAMPLING_HEAP_PROFILER_LOCK_FREE_ADDRESS_HASH_SET_H_ # include<atomic> # include<cstdint> # include<vector> # include \" base / base_export . h \" # include \" base / check_op . h \" # include \" base / compiler_specific . h \" namespace base { class BASE_EXPORT LockFreeAddressHashSet { public :)",
    "insertText": "LockFreeAddressHashSet(size_t buckets_count)"
  },
  {
    "label": "LockFreeAddressHashSet()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "LockFreeAddressHashSet()"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (ALWAYS_INLINE bool)",
    "insertText": "Contains(void* key)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (ALWAYS_INLINE void)",
    "insertText": "Remove(void* key)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Insert(void* key)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Copy(const LockFreeAddressHashSet& other)"
  },
  {
    "label": "buckets_count()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "buckets_count()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "size()"
  },
  {
    "label": "Node()",
    "kind": "Method",
    "detail": "Function (} private : class LockFreeAddressHashSetTest ; struct Node { ALWAYS_INLINE)",
    "insertText": "Node(void* key, Node* next)"
  },
  {
    "label": "Hash()",
    "kind": "Method",
    "detail": "Function (std::atomic<void*> key ; Node* next ; } ; ALWAYS_INLINE uint32_t)",
    "insertText": "Hash(void* key)"
  },
  {
    "label": "FindNode()",
    "kind": "Method",
    "detail": "Function (ALWAYS_INLINE Node*)",
    "insertText": "FindNode(void* key)"
  },
  {
    "label": "Node()",
    "kind": "Method",
    "detail": "Function (std::vector<std::atomic<Node*>> buckets_ ; size_t size_ = 0 ; const size_t bucket_mask_ ; } ; ALWAYS_INLINE LockFreeAddressHashSet::)",
    "insertText": "Node(void* key, Node* next) : next(next)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (this -> key .)",
    "insertText": "store(key, std::memory_order_relaxed)"
  },
  {
    "label": "FindNode()",
    "kind": "Method",
    "detail": "Function (Node* node =)",
    "insertText": "FindNode(key)"
  },
  {
    "label": "DCHECK_NE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_NE(node, nullptr)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (node -> key .)",
    "insertText": "store(nullptr, std::memory_order_relaxed)"
  },
  {
    "label": "DCHECK_NE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_NE(key, nullptr)"
  },
  {
    "label": "Hash()",
    "kind": "Method",
    "detail": "Function (const std::atomic<Node*>& bucket = buckets_ [)",
    "insertText": "Hash(key)"
  },
  {
    "label": "uintptr_t()",
    "kind": "Method",
    "detail": "Function (uintptr_t random_bits = static_cast<)",
    "insertText": "uintptr_t(0x4bfdb9df5a6f243b)"
  },
  {
    "label": "uintptr_t()",
    "kind": "Method",
    "detail": "Function (uint64_t k = reinterpret_cast<)",
    "insertText": "uintptr_t(key)"
  }
]