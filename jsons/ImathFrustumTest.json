[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "IMATH_EXPORT_TEMPLATE_TYPE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMATH_EXPORT_TEMPLATE_TYPE"
  },
  {
    "label": "FrustumTest()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHFRUSTUMTEST_H # define INCLUDED_IMATHFRUSTUMTEST_H # include \" ImathExport . h \" # include \" ImathNamespace . h \" # include \" ImathBox . h \" # include \" ImathFrustum . h \" # include \" ImathMatrix . h \" # include \" ImathSphere . h \" # include \" ImathVec . h \" IMATH_INTERNAL_NAMESPACE_HEADER_ENTER template<class T> class IMATH_EXPORT_TEMPLATE_TYPE FrustumTest { public :)",
    "insertText": "FrustumTest()"
  },
  {
    "label": "makeIdentity()",
    "kind": "Method",
    "detail": "Function (Frustum<T> frust ; Matrix44<T> cameraMat ; cameraMat .)",
    "insertText": "makeIdentity()"
  },
  {
    "label": "setFrustum()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setFrustum(frust, cameraMat)"
  },
  {
    "label": "FrustumTest()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FrustumTest(const Frustum<T>& frustum, const Matrix44<T>& cameraMat)"
  },
  {
    "label": "setFrustum()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setFrustum(frustum, cameraMat)"
  },
  {
    "label": "setFrustum()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setFrustum(const Frustum<T>& frustum, const Matrix44<T>& cameraMat)"
  },
  {
    "label": "isVisible()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isVisible(const Sphere3<T>& sphere)"
  },
  {
    "label": "isVisible()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isVisible(const Box<Vec3<T>>& box)"
  },
  {
    "label": "isVisible()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isVisible(const Vec3<T>& vec)"
  },
  {
    "label": "completelyContains()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "completelyContains(const Sphere3<T>& sphere)"
  },
  {
    "label": "completelyContains()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "completelyContains(const Box<Vec3<T>>& box)"
  },
  {
    "label": "cameraMat()",
    "kind": "Method",
    "detail": "Function (IMATH_INTERNAL_NAMESPACE::Matrix44<T>)",
    "insertText": "cameraMat()"
  },
  {
    "label": "planes()",
    "kind": "Method",
    "detail": "Function (Plane3<T> frustumPlanes [ 6 ] ; frustum .)",
    "insertText": "planes(frustumPlanes, cameraMat)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (int index = i* 3 ; planeNormX [ i ] = Vec3<)",
    "insertText": "T(frustumPlanes[index + 0].normal.x, frustumPlanes[index + 1].normal.x, frustumPlanes[index + 2].normal.x)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (planeNormY [ i ] = Vec3<)",
    "insertText": "T(frustumPlanes[index + 0].normal.y, frustumPlanes[index + 1].normal.y, frustumPlanes[index + 2].normal.y)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (planeNormZ [ i ] = Vec3<)",
    "insertText": "T(frustumPlanes[index + 0].normal.z, frustumPlanes[index + 1].normal.z, frustumPlanes[index + 2].normal.z)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (planeNormAbsX [ i ] = Vec3<)",
    "insertText": "T(std::abs (planeNormX[i].x), std::abs (planeNormX[i].y), std::abs (planeNormX[i].z))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (planeNormAbsY [ i ] = Vec3<)",
    "insertText": "T(std::abs (planeNormY[i].x), std::abs (planeNormY[i].y), std::abs (planeNormY[i].z))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (planeNormAbsZ [ i ] = Vec3<)",
    "insertText": "T(std::abs (planeNormZ[i].x), std::abs (planeNormZ[i].y), std::abs (planeNormZ[i].z))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (planeOffsetVec [ i ] = Vec3<)",
    "insertText": "T(frustumPlanes[index + 0].distance, frustumPlanes[index + 1].distance, frustumPlanes[index + 2].distance)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> center = sphere . center ; Vec3<T> radiusVec = Vec3<)",
    "insertText": "T(sphere.radius, sphere.radius, sphere.radius)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3<T> d0 = planeNormX [ 0 ]* center . x + planeNormY [ 0 ]* center . y + planeNormZ [ 0 ]* center . z - radiusVec - planeOffsetVec [ 0 ] ;)",
    "insertText": "if(d0.x >= 0 || d0.y >= 0 || d0.z >= 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3<T> d1 = planeNormX [ 1 ]* center . x + planeNormY [ 1 ]* center . y + planeNormZ [ 1 ]* center . z - radiusVec - planeOffsetVec [ 1 ] ;)",
    "insertText": "if(d1.x >= 0 || d1.y >= 0 || d1.z >= 0)"
  },
  {
    "label": "center()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "center(box.min + box.max)"
  },
  {
    "label": "extent()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "extent(box.max - center)"
  },
  {
    "label": "d0()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "d0(planeNormX[0] * vec.x) + (planeNormY[0] * vec.y) + (planeNormZ[0] * vec.z)"
  },
  {
    "label": "d1()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "d1(planeNormX[1] * vec.x) + (planeNormY[1] * vec.y) + (planeNormZ[1] * vec.z)"
  }
]