[
  {
    "label": "Unit_T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Unit_T"
  },
  {
    "label": "UnitBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnitBase"
  },
  {
    "label": "RelativeUnit_T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RelativeUnit_T"
  },
  {
    "label": "RelativeUnit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RelativeUnit"
  },
  {
    "label": "UnitBase()",
    "kind": "Method",
    "detail": "Function (# ifndef RTC_BASE_UNITS_UNIT_BASE_H_ # define RTC_BASE_UNITS_UNIT_BASE_H_ # include<stdint . h> # include<algorithm> # include<cmath> # include<limits> # include<type_traits> # include \" rtc_base / checks . h \" # include \" rtc_base / numerics / safe_conversions . h \" namespace webrtc { namespace rtc_units_impl { template<class Unit_T> class UnitBase { public :)",
    "insertText": "UnitBase()"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (Unit_T)",
    "insertText": "Zero()"
  },
  {
    "label": "PlusInfinity()",
    "kind": "Method",
    "detail": "Function (} Unit_T)",
    "insertText": "PlusInfinity()"
  },
  {
    "label": "MinusInfinity()",
    "kind": "Method",
    "detail": "Function (} Unit_T)",
    "insertText": "MinusInfinity()"
  },
  {
    "label": "IsZero()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsZero()"
  },
  {
    "label": "IsInfinite()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsInfinite()"
  },
  {
    "label": "IsPlusInfinity()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsPlusInfinity()"
  },
  {
    "label": "IsMinusInfinity()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsMinusInfinity()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const UnitBase<Unit_T>& other)"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(IsFinite())"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(resolution.IsFinite())"
  },
  {
    "label": "RTC_DCHECK_GT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_GT(resolution.value_, 0)"
  },
  {
    "label": "RoundUpTo()",
    "kind": "Method",
    "detail": "Function (} Unit_T)",
    "insertText": "RoundUpTo(const Unit_T& resolution)"
  },
  {
    "label": "RoundDownTo()",
    "kind": "Method",
    "detail": "Function (} Unit_T)",
    "insertText": "RoundDownTo(const Unit_T& resolution)"
  },
  {
    "label": "FromValue()",
    "kind": "Method",
    "detail": "Function (} protected : template<T,std::enable_if<std::is_integral<T>::value>::type* = nullptr> Unit_T)",
    "insertText": "FromValue(T value)"
  },
  {
    "label": "RTC_DCHECK_GT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_GT(value, MinusInfinityVal())"
  },
  {
    "label": "RTC_DCHECK_LT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_LT(value, PlusInfinityVal())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(value == -std::numeric_limits<T>::infinity())"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "RTC_DCHECK(!std::isnan(value))"
  },
  {
    "label": "FromFraction()",
    "kind": "Method",
    "detail": "Function (} } template<T,std::enable_if<std::is_integral<T>::value>::type* = nullptr> Unit_T)",
    "insertText": "FromFraction(int64_t denominator, T value)"
  },
  {
    "label": "RTC_DCHECK_GT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_GT(value, MinusInfinityVal() / denominator)"
  },
  {
    "label": "RTC_DCHECK_LT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_LT(value, PlusInfinityVal() / denominator)"
  },
  {
    "label": "ToValue()",
    "kind": "Method",
    "detail": "Function (} template<T = int64_t> std::enable_if<std::is_integral<T>::value,T>::type)",
    "insertText": "ToValue()"
  },
  {
    "label": "ToValueOr()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "ToValueOr(T fallback_value)"
  },
  {
    "label": "ToFraction()",
    "kind": "Method",
    "detail": "Function (} template<int64_t Denominator,T = int64_t> std::enable_if<std::is_integral<T>::value,T>::type)",
    "insertText": "ToFraction()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else { return rtc::dchecked_cast<)",
    "insertText": "T(DivRoundToNearest(value_, Denominator))"
  },
  {
    "label": "ToFractionOr()",
    "kind": "Method",
    "detail": "Function (} template<int64_t Denominator> int64_t)",
    "insertText": "ToFractionOr(int64_t fallback_value)"
  },
  {
    "label": "ToMultiple()",
    "kind": "Method",
    "detail": "Function (} template<int64_t Factor,T = int64_t> std::enable_if<std::is_integral<T>::value,T>::type)",
    "insertText": "ToMultiple()"
  },
  {
    "label": "RTC_DCHECK_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_GE(ToValue(), std::numeric_limits<T>::min() / Factor)"
  },
  {
    "label": "RTC_DCHECK_LE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_LE(ToValue(), std::numeric_limits<T>::max() / Factor)"
  },
  {
    "label": "UnitBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UnitBase(int64_t value) : value_(value)"
  },
  {
    "label": "PlusInfinityVal()",
    "kind": "Method",
    "detail": "Function (} private : template<class RelativeUnit_T> class RelativeUnit ; int64_t)",
    "insertText": "PlusInfinityVal()"
  },
  {
    "label": "MinusInfinityVal()",
    "kind": "Method",
    "detail": "Function (} int64_t)",
    "insertText": "MinusInfinityVal()"
  },
  {
    "label": "AsSubClassRef()",
    "kind": "Method",
    "detail": "Function (} Unit_T&)",
    "insertText": "AsSubClassRef()"
  },
  {
    "label": "DivRoundPositiveToNearest()",
    "kind": "Method",
    "detail": "Function (} int64_t)",
    "insertText": "DivRoundPositiveToNearest(int64_t n, int64_t d)"
  },
  {
    "label": "DivRoundToNearest()",
    "kind": "Method",
    "detail": "Function (} int64_t)",
    "insertText": "DivRoundToNearest(int64_t n, int64_t d)"
  },
  {
    "label": "Clamped()",
    "kind": "Method",
    "detail": "Function (} int64_t value_ ; } ; template<class Unit_T> class RelativeUnit : public UnitBase<Unit_T> { public : Unit_T)",
    "insertText": "Clamped(Unit_T min_value, Unit_T max_value)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Clamp(Unit_T min_value, Unit_T max_value)"
  },
  {
    "label": "Clamped()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "Clamped(min_value, max_value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Unit_T)",
    "insertText": "operator(const Unit_T other)"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(!this->IsMinusInfinity())"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(!other.IsMinusInfinity())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->IsMinusInfinity() || other.IsMinusInfinity())"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(!this->IsPlusInfinity())"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(!other.IsPlusInfinity())"
  },
  {
    "label": "FromValue()",
    "kind": "Method",
    "detail": "Function (} return UnitBase<Unit_T)",
    "insertText": "FromValue(this->ToValue() + other.ToValue())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->IsMinusInfinity() || other.IsPlusInfinity())"
  },
  {
    "label": "FromValue()",
    "kind": "Method",
    "detail": "Function (} return UnitBase<Unit_T)",
    "insertText": "FromValue(this->ToValue() - other.ToValue())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,std::enable_if_t<std::is_floating_point_v<T>>* = nullptr> Unit_T)",
    "insertText": "operator(T scalar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Unit_T)",
    "insertText": "operator(double scalar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Unit_T)",
    "insertText": "operator(int64_t scalar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Unit_T)",
    "insertText": "operator(int32_t scalar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Unit_T)",
    "insertText": "operator(size_t scalar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} protected : using UnitBase<Unit_T>::UnitBase ; } ; template<class Unit_T> Unit_T)",
    "insertText": "operator(double scalar, RelativeUnit<Unit_T> other)"
  }
]