[
  {
    "label": "traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "traits"
  },
  {
    "label": "enable_if_ref",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "enable_if_ref"
  },
  {
    "label": "PartialPivLU",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PartialPivLU"
  },
  {
    "label": "SolverBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SolverBase"
  },
  {
    "label": "partial_lu_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "partial_lu_impl"
  },
  {
    "label": "Assignment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Assignment"
  },
  {
    "label": "EIGEN_GENERIC_PUBLIC_INTERFACE()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_PARTIALLU_H # define EIGEN_PARTIALLU_H namespace Eigen { namespace internal { template<_MatrixType> struct traits<PartialPivLU<_MatrixType>> : traits<_MatrixType> { typedef MatrixXpr XprKind ; typedef SolverStorage StorageKind ; typedef int StorageIndex ; typedef traits<_MatrixType> BaseTraits ; enum { Flags = BaseTraits::Flags& RowMajorBit,CoeffReadCost = Dynamic } ; } ; template<T,Derived> struct enable_if_ref ; template<T,Derived> struct enable_if_ref<Ref<T>,Derived> { typedef Derived type ; } ; } template<_MatrixType> class PartialPivLU : public SolverBase<PartialPivLU<_MatrixType>> { public : typedef _MatrixType MatrixType ; typedef SolverBase<PartialPivLU> Base ; class SolverBase<PartialPivLU> ;)",
    "insertText": "EIGEN_GENERIC_PUBLIC_INTERFACE(PartialPivLU)"
  },
  {
    "label": "PartialPivLU()",
    "kind": "Method",
    "detail": "Function (MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime } ; typedef PermutationMatrix<RowsAtCompileTime,MaxRowsAtCompileTime> PermutationType ; typedef Transpositions<RowsAtCompileTime,MaxRowsAtCompileTime> TranspositionType ; typedef MatrixType::PlainObject PlainObject ;)",
    "insertText": "PartialPivLU()"
  },
  {
    "label": "PartialPivLU()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PartialPivLU(Index size)"
  },
  {
    "label": "PartialPivLU()",
    "kind": "Method",
    "detail": "Function (template<InputType>)",
    "insertText": "PartialPivLU(const EigenBase<InputType>& matrix)"
  },
  {
    "label": "PartialPivLU()",
    "kind": "Method",
    "detail": "Function (template<InputType>)",
    "insertText": "PartialPivLU(EigenBase<InputType>& matrix)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (template<InputType> PartialPivLU&)",
    "insertText": "compute(const EigenBase<InputType>& matrix)"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (m_lu = matrix .)",
    "insertText": "derived()"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized && \"PartialPivLU is not initialized.\")"
  },
  {
    "label": "rcond()",
    "kind": "Method",
    "detail": "Function (# endif RealScalar)",
    "insertText": "rcond()"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (} const Inverse<PartialPivLU>)",
    "insertText": "inverse()"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (} Scalar)",
    "insertText": "determinant()"
  },
  {
    "label": "reconstructedMatrix()",
    "kind": "Method",
    "detail": "Function (MatrixType)",
    "insertText": "reconstructedMatrix()"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (EIGEN_CONSTEXPR Index)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} EIGEN_CONSTEXPR Index)",
    "insertText": "cols()"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (} # ifndef EIGEN_PARSED_BY_DOXYGEN template<RhsType,DstType> EIGEN_DEVICE_FUNC void)",
    "insertText": "_solve_impl(const RhsType &rhs, DstType &dst)"
  },
  {
    "label": "permutationP()",
    "kind": "Method",
    "detail": "Function (dst =)",
    "insertText": "permutationP()"
  },
  {
    "label": "UnitLower()",
    "kind": "Method",
    "detail": "Function (m_lu . template triangularView<)",
    "insertText": "UnitLower().solveInPlace(dst)"
  },
  {
    "label": "Upper()",
    "kind": "Method",
    "detail": "Function (m_lu . template triangularView<)",
    "insertText": "Upper().solveInPlace(dst)"
  },
  {
    "label": "_solve_impl_transposed()",
    "kind": "Method",
    "detail": "Function (} template<bool Conjugate,RhsType,DstType> EIGEN_DEVICE_FUNC void)",
    "insertText": "_solve_impl_transposed(const RhsType &rhs, DstType &dst)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(rhs.rows() == m_lu.cols())"
  },
  {
    "label": "Upper()",
    "kind": "Method",
    "detail": "Function (dst = m_lu . template triangularView<)",
    "insertText": "Upper().transpose() .template conjugateIf<Conjugate>().solve(rhs)"
  },
  {
    "label": "UnitLower()",
    "kind": "Method",
    "detail": "Function (m_lu . template triangularView<)",
    "insertText": "UnitLower().transpose() .template conjugateIf<Conjugate>().solveInPlace(dst)"
  },
  {
    "label": "permutationP()",
    "kind": "Method",
    "detail": "Function (dst =)",
    "insertText": "permutationP().transpose()"
  },
  {
    "label": "check_template_parameters()",
    "kind": "Method",
    "detail": "Function (} # endif protected : void)",
    "insertText": "check_template_parameters()"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_NON_INTEGER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)"
  },
  {
    "label": "PartialPivLU()",
    "kind": "Method",
    "detail": "Function (MatrixType m_lu ; PermutationType m_p ; TranspositionType m_rowsTranspositions ; RealScalar m_l1_norm ; signed char m_det_p ; bool m_isInitialized ; } ; template<MatrixType> PartialPivLU<MatrixType)",
    "insertText": "PartialPivLU() : m_lu(), m_p(), m_rowsTranspositions(), m_l1_norm(0), m_det_p(0), m_isInitialized(false)"
  },
  {
    "label": "PartialPivLU()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> PartialPivLU<MatrixType)",
    "insertText": "PartialPivLU(Index size) : m_lu(size, size), m_p(size), m_rowsTranspositions(size), m_l1_norm(0), m_det_p(0), m_isInitialized(false)"
  },
  {
    "label": "PartialPivLU()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> template<InputType> PartialPivLU<MatrixType)",
    "insertText": "PartialPivLU(const EigenBase<InputType>& matrix) : m_lu(matrix.rows(),matrix.cols()), m_p(matrix.rows()), m_rowsTranspositions(matrix.rows()), m_l1_norm(0), m_det_p(0), m_isInitialized(false)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(matrix.derived())"
  },
  {
    "label": "PartialPivLU()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> template<InputType> PartialPivLU<MatrixType)",
    "insertText": "PartialPivLU(EigenBase<InputType>& matrix) : m_lu(matrix.derived()), m_p(matrix.rows()), m_rowsTranspositions(matrix.rows()), m_l1_norm(0), m_det_p(0), m_isInitialized(false)"
  },
  {
    "label": "unblocked_lu()",
    "kind": "Method",
    "detail": "Function (} namespace internal { template<Scalar,int StorageOrder,PivIndex,int SizeAtCompileTime = Dynamic> struct partial_lu_impl { const int UnBlockedBound = 1 6 ; const bool UnBlockedAtCompileTime = SizeAtCompileTime ! = Dynamic&& SizeAtCompileTime<= UnBlockedBound ; const int ActualSizeAtCompileTime = UnBlockedAtCompileTime ? SizeAtCompileTime : Dynamic ; const int RRows = SizeAtCompileTime = = 2 ? 1 : Dynamic ; const int RCols = SizeAtCompileTime = = 2 ? 1 : Dynamic ; typedef Matrix<Scalar,ActualSizeAtCompileTime,ActualSizeAtCompileTime,StorageOrder> MatrixType ; typedef Ref<MatrixType> MatrixTypeRef ; typedef Ref<Matrix<Scalar,Dynamic,Dynamic,StorageOrder>> BlockType ; typedef MatrixType::RealScalar RealScalar ; Index)",
    "insertText": "unblocked_lu(MatrixTypeRef& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "size(std::min)(rows,cols)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const Index endk = UnBlockedAtCompileTime ? size - 1 : size ; nb_transpositions = 0 ; Index first_zero_pivot = - 1 ;)",
    "insertText": "for(Index k = 0; k < endk; ++k)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int rrows = internal::convert_index<)",
    "insertText": "int(rows-k-1)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (int rcols = internal::convert_index<)",
    "insertText": "int(cols-k-1)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (Index row_of_biggest_in_col ; Score biggest_in_corner = lu .)",
    "insertText": "col(k).tail(rows-k).unaryExpr(Scoring()).maxCoeff(&row_of_biggest_in_col)"
  },
  {
    "label": "PivIndex()",
    "kind": "Method",
    "detail": "Function (row_of_biggest_in_col + = k ; row_transpositions [ k ] =)",
    "insertText": "PivIndex(row_of_biggest_in_col)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (lu .)",
    "insertText": "row(k).swap(lu.row(row_of_biggest_in_col))"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (+ + nb_transpositions ; } lu .)",
    "insertText": "col(k).tail(fix<RRows>(rrows)) /= lu.coeff(k,k)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(first_zero_pivot==-1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (first_zero_pivot = k ; })",
    "insertText": "if(k<rows-1) lu.bottomRightCorner(fix<RRows>(rrows),fix<RCols>(rcols)).noalias() -= lu.col(k).tail(fix<RRows>(rrows)) * lu.row(k).tail(fix<RCols>(rcols))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(UnBlockedAtCompileTime)"
  },
  {
    "label": "PivIndex()",
    "kind": "Method",
    "detail": "Function (Index k = endk ; row_transpositions [ k ] =)",
    "insertText": "PivIndex(k)"
  },
  {
    "label": "blocked_lu()",
    "kind": "Method",
    "detail": "Function (} return first_zero_pivot ; } Index)",
    "insertText": "blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (MatrixTypeRef lu =)",
    "insertText": "Map(lu_data,rows, cols, OuterStride<>(luStride))"
  },
  {
    "label": "blockSize()",
    "kind": "Method",
    "detail": "Function (} Index blockSize ; { blockSize = size / 8 ;)",
    "insertText": "blockSize(blockSize/16)"
  },
  {
    "label": "blockSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "blockSize(std::min)((std::max)(blockSize,Index(8)), maxBlockSize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} nb_transpositions = 0 ; Index first_zero_pivot = - 1 ;)",
    "insertText": "for(Index k = 0; k < size; k+=blockSize)"
  },
  {
    "label": "bs()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "bs(std::min)(size-k,blockSize)"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (Index trows = rows - k - bs ; Index tsize = size - k - bs ; BlockType A_0 = lu .)",
    "insertText": "block(0,0,rows,k)"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (BlockType A_2 = lu .)",
    "insertText": "block(0,k+bs,rows,tsize)"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (BlockType A11 = lu .)",
    "insertText": "block(k,k,bs,bs)"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (BlockType A12 = lu .)",
    "insertText": "block(k,k+bs,bs,tsize)"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (BlockType A21 = lu .)",
    "insertText": "block(k+bs,k,trows,bs)"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (BlockType A22 = lu .)",
    "insertText": "block(k+bs,k+bs,trows,tsize)"
  },
  {
    "label": "blocked_lu()",
    "kind": "Method",
    "detail": "Function (PivIndex nb_transpositions_in_panel ; Index ret =)",
    "insertText": "blocked_lu(trows+bs, bs, &lu.coeffRef(k,k), luStride, row_transpositions+k, nb_transpositions_in_panel, 16)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (nb_transpositions + = nb_transpositions_in_panel ;)",
    "insertText": "for(Index i=k; i<k+bs; ++i)"
  },
  {
    "label": "piv()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "piv(row_transpositions[i] += internal::convert_index<PivIndex>(k))"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (A_0 .)",
    "insertText": "row(i).swap(A_0.row(piv))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(trows)"
  },
  {
    "label": "UnitLower()",
    "kind": "Method",
    "detail": "Function (A11 . template triangularView<)",
    "insertText": "UnitLower().solveInPlace(A12)"
  },
  {
    "label": "noalias()",
    "kind": "Method",
    "detail": "Function (A22 .)",
    "insertText": "noalias()"
  },
  {
    "label": "partial_lu_inplace()",
    "kind": "Method",
    "detail": "Function (} } return first_zero_pivot ; } } ; template<MatrixType,TranspositionType> void)",
    "insertText": "partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::StorageIndex& nb_transpositions)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (nb_transpositions = 0 ; return ; })",
    "insertText": "eigen_assert(lu.cols() == row_transpositions.size())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(row_transpositions.size() < 2 || (&row_transpositions.coeffRef(1)-&row_transpositions.coeffRef(0)) == 1)"
  },
  {
    "label": "EIGEN_SIZE_MIN_PREFER_FIXED()",
    "kind": "Method",
    "detail": "Function (partial_lu_impl<MatrixType::Scalar,MatrixType::Flags& RowMajorBit ? RowMajor : ColMajor,TranspositionType::StorageIndex,)",
    "insertText": "EIGEN_SIZE_MIN_PREFER_FIXED(MatrixType::RowsAtCompileTime,MatrixType::ColsAtCompileTime)> ::blocked_lu(lu.rows(), lu.cols(), &lu.coeffRef(0,0), lu.outerStride(), &row_transpositions.coeffRef(0), nb_transpositions)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_lu.rows()<NumTraits<int>::highest())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_lu.rows() == m_lu.cols() && \"PartialPivLU is only for square (and moreover invertible) matrices\")"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_rowsTranspositions .)",
    "insertText": "resize(size)"
  },
  {
    "label": "partial_lu_inplace()",
    "kind": "Method",
    "detail": "Function (TranspositionType::StorageIndex nb_transpositions ;)",
    "insertText": "partial_lu_inplace(m_lu, m_rowsTranspositions, nb_transpositions)"
  },
  {
    "label": "m_det_p()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_det_p(nb_transpositions%2)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized && \"LU is not initialized.\")"
  },
  {
    "label": "UnitLower()",
    "kind": "Method",
    "detail": "Function (MatrixType res = m_lu . template triangularView<)",
    "insertText": "UnitLower().toDenseMatrix() * m_lu.template triangularView<Upper>()"
  },
  {
    "label": "nestedExpression()",
    "kind": "Method",
    "detail": "Function (dst = src .)",
    "insertText": "nestedExpression().solve(MatrixType::Identity(src.rows(), src.cols()))"
  },
  {
    "label": "partialPivLu()",
    "kind": "Method",
    "detail": "Function (} } ; } template<Derived> const PartialPivLU<MatrixBase<Derived>::PlainObject> MatrixBase<Derived)",
    "insertText": "partialPivLu()"
  },
  {
    "label": "lu()",
    "kind": "Method",
    "detail": "Function (} template<Derived> const PartialPivLU<MatrixBase<Derived>::PlainObject> MatrixBase<Derived)",
    "insertText": "lu()"
  }
]