[
  {
    "label": "UPrimitiveComponent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPrimitiveComponent"
  },
  {
    "label": "AdvanceOneTimeStepTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AdvanceOneTimeStepTask"
  },
  {
    "label": "IPhysicsReplication",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IPhysicsReplication"
  },
  {
    "label": "FPhysicsReplicationCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsReplicationCache"
  },
  {
    "label": "FPhysInterface_Chaos",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysInterface_Chaos"
  },
  {
    "label": "FChaosSolversModule",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosSolversModule"
  },
  {
    "label": "FForceFieldProxy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FForceFieldProxy"
  },
  {
    "label": "FSolverStateStorage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSolverStateStorage"
  },
  {
    "label": "FSkeletalMeshPhysicsProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSkeletalMeshPhysicsProxy"
  },
  {
    "label": "FStaticMeshPhysicsProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStaticMeshPhysicsProxy"
  },
  {
    "label": "FPerSolverFieldSystem",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPerSolverFieldSystem"
  },
  {
    "label": "IPhysicsProxyBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IPhysicsProxyBase"
  },
  {
    "label": "UWorld",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UWorld"
  },
  {
    "label": "UChaosEventRelay",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UChaosEventRelay"
  },
  {
    "label": "AWorldSettings",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AWorldSettings"
  },
  {
    "label": "FPhysicsReplicationFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsReplicationFactory"
  },
  {
    "label": "FContactModifyCallbackFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FContactModifyCallbackFactory"
  },
  {
    "label": "FConstraintInstanceBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConstraintInstanceBase"
  },
  {
    "label": "FPhysicsProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsProxy"
  },
  {
    "label": "FClusterUnionPhysicsProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FClusterUnionPhysicsProxy"
  },
  {
    "label": "FCollisionEventData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCollisionEventData"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "TRawEventHandler",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRawEventHandler"
  },
  {
    "label": "FAccelerationStructureHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAccelerationStructureHandle"
  },
  {
    "label": "ISpatialAcceleration",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ISpatialAcceleration"
  },
  {
    "label": "ISpatialAccelerationCollection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ISpatialAccelerationCollection"
  },
  {
    "label": "TArrayCollectionArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TArrayCollectionArray"
  },
  {
    "label": "FConstraintBrokenDelegateWrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConstraintBrokenDelegateWrapper"
  },
  {
    "label": "FConstraintViolatedDelegateWrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConstraintViolatedDelegateWrapper"
  },
  {
    "label": "FPlasticDeformationDelegateWrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPlasticDeformationDelegateWrapper"
  },
  {
    "label": "FPhysScene_Chaos",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysScene_Chaos"
  },
  {
    "label": "at",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "at"
  },
  {
    "label": "OwnerType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OwnerType"
  },
  {
    "label": "UE_DEPRECATED",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UE_DEPRECATED"
  },
  {
    "label": "FUniqueContactPairKey",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUniqueContactPairKey"
  },
  {
    "label": "FDeferredKinematicUpdateInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDeferredKinematicUpdateInfo"
  },
  {
    "label": "FAsyncPhysicsTickCallback",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAsyncPhysicsTickCallback"
  },
  {
    "label": "ChaosInterface",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ChaosInterface"
  },
  {
    "label": "FScopedSceneLock_Chaos",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FScopedSceneLock_Chaos"
  },
  {
    "label": "FConstraintBrokenDelegateWrapper()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Tickable . h \" # include \" EventsData . h \" # include \" Physics / PhysScene . h \" # include \" Physics / Experimental / ChaosEventType . h \" # include \" GameFramework / Actor . h \" # include \" PhysicsPublic . h \" # include \" PhysInterface_Chaos . h \" # include \" Physics / PhysicsInterfaceUtils . h \" # include \" Chaos / ChaosScene . h \" # include \" Chaos / ContactModification . h \" # include \" Chaos / Real . h \" # include \" Chaos / AsyncInitBodyHelper . h \" # include \" UObject / ObjectKey . h \" # ifndef CHAOS_WITH_PAUSABLE_SOLVER # define CHAOS_WITH_PAUSABLE_SOLVER 1 # endif # define XGE_FIXED 0 class UPrimitiveComponent ; class AdvanceOneTimeStepTask ; class IPhysicsReplication ; class FPhysicsReplicationCache ; class FPhysInterface_Chaos ; class FChaosSolversModule ; struct FForceFieldProxy ; struct FSolverStateStorage ; class FSkeletalMeshPhysicsProxy ; class FStaticMeshPhysicsProxy ; class FPerSolverFieldSystem ; class IPhysicsProxyBase ; class UWorld ; class UChaosEventRelay ; class AWorldSettings ; class FPhysicsReplicationFactory ; class FContactModifyCallbackFactory ; struct FConstraintInstanceBase ; namespace Chaos { class FPhysicsProxy ; class FClusterUnionPhysicsProxy ; struct FCollisionEventData ; enum class EEventType : int32 ; template<PayloadType,HandlerType> class TRawEventHandler ; class FAccelerationStructureHandle ; template<TPayload,T,int d> class ISpatialAcceleration ; template<TPayload,T,int d> class ISpatialAccelerationCollection ; template<T> class TArrayCollectionArray ; } int32 GEnableKinematicDeferralStartPhysicsCondition ; struct FConstraintBrokenDelegateWrapper {)",
    "insertText": "FConstraintBrokenDelegateWrapper(FConstraintInstanceBase* ConstraintInstance)"
  },
  {
    "label": "DispatchOnBroken()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DispatchOnBroken()"
  },
  {
    "label": "FConstraintViolatedDelegateWrapper()",
    "kind": "Method",
    "detail": "Function (FOnConstraintBroken OnConstraintBrokenDelegate ; int32 ConstraintIndex ; } ; struct FConstraintViolatedDelegateWrapper {)",
    "insertText": "FConstraintViolatedDelegateWrapper(FConstraintInstanceBase* ConstraintInstance)"
  },
  {
    "label": "DispatchOnViolated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DispatchOnViolated(float LinearViolation, float AngularViolation)"
  },
  {
    "label": "FPlasticDeformationDelegateWrapper()",
    "kind": "Method",
    "detail": "Function (FOnConstraintViolated OnConstraintViolatedDelegate ; int32 ConstraintIndex ; } ; struct FPlasticDeformationDelegateWrapper {)",
    "insertText": "FPlasticDeformationDelegateWrapper(FConstraintInstanceBase* ConstraintInstance)"
  },
  {
    "label": "DispatchPlasticDeformation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DispatchPlasticDeformation()"
  },
  {
    "label": "FPhysScene_Chaos()",
    "kind": "Method",
    "detail": "Function (FOnPlasticDeformation OnPlasticDeformationDelegate ; int32 ConstraintIndex ; } ; class FPhysScene_Chaos : public FChaosScene { public : using Super = FChaosScene ;)",
    "insertText": "FPhysScene_Chaos(AActor* InSolverActor=nullptr #if CHAOS_DEBUG_NAME , const FName& DebugName=NAME_None #endif)"
  },
  {
    "label": "FPhysScene_Chaos()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FPhysScene_Chaos()"
  },
  {
    "label": "GetSolverActor()",
    "kind": "Method",
    "detail": "Function (AActor*)",
    "insertText": "GetSolverActor()"
  },
  {
    "label": "RegisterForCollisionEvents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterForCollisionEvents(UPrimitiveComponent* Component)"
  },
  {
    "label": "UnRegisterForCollisionEvents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnRegisterForCollisionEvents(UPrimitiveComponent* Component)"
  },
  {
    "label": "RegisterForGlobalCollisionEvents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterForGlobalCollisionEvents(UPrimitiveComponent* Component)"
  },
  {
    "label": "UnRegisterForGlobalCollisionEvents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnRegisterForGlobalCollisionEvents(UPrimitiveComponent* Component)"
  },
  {
    "label": "RegisterForGlobalRemovalEvents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterForGlobalRemovalEvents(UPrimitiveComponent* Component)"
  },
  {
    "label": "UnRegisterForGlobalRemovalEvents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnRegisterForGlobalRemovalEvents(UPrimitiveComponent* Component)"
  },
  {
    "label": "RegisterAsyncPhysicsTickComponent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterAsyncPhysicsTickComponent(UActorComponent* Component)"
  },
  {
    "label": "UnregisterAsyncPhysicsTickComponent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterAsyncPhysicsTickComponent(UActorComponent* Component)"
  },
  {
    "label": "RegisterAsyncPhysicsTickActor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterAsyncPhysicsTickActor(AActor* Actor)"
  },
  {
    "label": "UnregisterAsyncPhysicsTickActor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterAsyncPhysicsTickActor(AActor* Actor)"
  },
  {
    "label": "EnqueueAsyncPhysicsCommand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnqueueAsyncPhysicsCommand(int32 PhysicsStep, UObject* OwningObject, const TFunction<void()>& Command, const bool bEnableResim = false)"
  },
  {
    "label": "AddObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddObject(UPrimitiveComponent* Component, FSkeletalMeshPhysicsProxy* InObject)"
  },
  {
    "label": "AddObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddObject(UPrimitiveComponent* Component, FStaticMeshPhysicsProxy* InObject)"
  },
  {
    "label": "AddObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddObject(UPrimitiveComponent* Component, Chaos::FSingleParticlePhysicsProxy* InObject)"
  },
  {
    "label": "AddObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddObject(UPrimitiveComponent* Component, FGeometryCollectionPhysicsProxy* InObject)"
  },
  {
    "label": "AddObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddObject(UPrimitiveComponent* Component, Chaos::FClusterUnionPhysicsProxy* InObject)"
  },
  {
    "label": "AddToComponentMaps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddToComponentMaps(UPrimitiveComponent* Component, IPhysicsProxyBase* InObject)"
  },
  {
    "label": "RemoveFromComponentMaps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveFromComponentMaps(IPhysicsProxyBase* InObject)"
  },
  {
    "label": "RemoveObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveObject(FSkeletalMeshPhysicsProxy* InObject)"
  },
  {
    "label": "RemoveObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveObject(FStaticMeshPhysicsProxy* InObject)"
  },
  {
    "label": "RemoveObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveObject(Chaos::FSingleParticlePhysicsProxy* InObject)"
  },
  {
    "label": "RemoveObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveObject(FGeometryCollectionPhysicsProxy* InObject)"
  },
  {
    "label": "RemoveObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveObject(Chaos::FClusterUnionPhysicsProxy* InObject)"
  },
  {
    "label": "GetPhysicsReplication()",
    "kind": "Method",
    "detail": "Function (IPhysicsReplication*)",
    "insertText": "GetPhysicsReplication()"
  },
  {
    "label": "CreatePhysicsReplication()",
    "kind": "Method",
    "detail": "Function (IPhysicsReplication*)",
    "insertText": "CreatePhysicsReplication()"
  },
  {
    "label": "AddReferencedObjects()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddReferencedObjects(FReferenceCollector& Collector)"
  },
  {
    "label": "GetOwningComponent()",
    "kind": "Method",
    "detail": "Function (template<class OwnerType> OwnerType*)",
    "insertText": "GetOwningComponent(const IPhysicsProxyBase* PhysicsProxy)"
  },
  {
    "label": "UE_CHAOS_ASYNC_INITBODY_READSCOPELOCK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_CHAOS_ASYNC_INITBODY_READSCOPELOCK(PhysicsProxyComponentMapsLock)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (auto* CompPtr = PhysicsProxyToComponentMap .)",
    "insertText": "Find(PhysicsProxy)"
  },
  {
    "label": "GetOwnedPhysicsProxies()",
    "kind": "Method",
    "detail": "Function (const TArray<IPhysicsProxyBase*>*)",
    "insertText": "GetOwnedPhysicsProxies(UPrimitiveComponent* Comp)"
  },
  {
    "label": "GetBodyInstanceFromProxy()",
    "kind": "Method",
    "detail": "Function (} FBodyInstance*)",
    "insertText": "GetBodyInstanceFromProxy(const IPhysicsProxyBase* PhysicsProxy)"
  },
  {
    "label": "GetBodyInstanceFromProxyAndShape()",
    "kind": "Method",
    "detail": "Function (const FBodyInstance*)",
    "insertText": "GetBodyInstanceFromProxyAndShape(IPhysicsProxyBase* InProxy, int32 InShapeIndex)"
  },
  {
    "label": "OnWorldEndPlay()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnWorldEndPlay()"
  },
  {
    "label": "OnWorldBeginPlay()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnWorldBeginPlay()"
  },
  {
    "label": "AddAggregateToScene()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAggregateToScene(const FPhysicsAggregateHandle& InAggregate)"
  },
  {
    "label": "SetOwningWorld()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOwningWorld(UWorld* InOwningWorld)"
  },
  {
    "label": "GetOwningWorld()",
    "kind": "Method",
    "detail": "Function (UWorld*)",
    "insertText": "GetOwningWorld()"
  },
  {
    "label": "ResimNFrames()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResimNFrames(int32 NumFrames)"
  },
  {
    "label": "RemoveBodyInstanceFromPendingLists_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveBodyInstanceFromPendingLists_AssumesLocked(FBodyInstance* BodyInstance, int32 SceneType)"
  },
  {
    "label": "AddCustomPhysics_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomPhysics_AssumesLocked(FBodyInstance* BodyInstance, FCalculateCustomPhysics& CalculateCustomPhysics)"
  },
  {
    "label": "AddForce_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddForce_AssumesLocked(FBodyInstance* BodyInstance, const FVector& Force, bool bAllowSubstepping, bool bAccelChange)"
  },
  {
    "label": "AddForceAtPosition_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddForceAtPosition_AssumesLocked(FBodyInstance* BodyInstance, const FVector& Force, const FVector& Position, bool bAllowSubstepping, bool bIsLocalForce = false)"
  },
  {
    "label": "AddRadialForceToBody_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRadialForceToBody_AssumesLocked(FBodyInstance* BodyInstance, const FVector& Origin, const float Radius, const float Strength, const uint8 Falloff, bool bAccelChange, bool bAllowSubstepping)"
  },
  {
    "label": "ClearForces_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearForces_AssumesLocked(FBodyInstance* BodyInstance, bool bAllowSubstepping)"
  },
  {
    "label": "AddTorque_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTorque_AssumesLocked(FBodyInstance* BodyInstance, const FVector& Torque, bool bAllowSubstepping, bool bAccelChange)"
  },
  {
    "label": "ClearTorques_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearTorques_AssumesLocked(FBodyInstance* BodyInstance, bool bAllowSubstepping)"
  },
  {
    "label": "SetKinematicTarget_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetKinematicTarget_AssumesLocked(FBodyInstance* BodyInstance, const FTransform& TargetTM, bool bAllowSubstepping)"
  },
  {
    "label": "GetKinematicTarget_AssumesLocked()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetKinematicTarget_AssumesLocked(const FBodyInstance* BodyInstance, FTransform& OutTM)"
  },
  {
    "label": "MarkForPreSimKinematicUpdate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MarkForPreSimKinematicUpdate(USkeletalMeshComponent* InSkelComp, ETeleportType InTeleport, bool bNeedsSkinning)"
  },
  {
    "label": "ClearPreSimKinematicUpdate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearPreSimKinematicUpdate(USkeletalMeshComponent* InSkelComp)"
  },
  {
    "label": "AddPendingOnConstraintBreak()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddPendingOnConstraintBreak(FConstraintInstance* ConstraintInstance, int32 SceneType)"
  },
  {
    "label": "AddPendingSleepingEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddPendingSleepingEvent(FBodyInstance* BI, ESleepEvent SleepEventType, int32 SceneType)"
  },
  {
    "label": "DirtyElementCount()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "DirtyElementCount(Chaos::ISpatialAccelerationCollection<Chaos::FAccelerationStructureHandle, Chaos::FReal, 3>& Collection)"
  },
  {
    "label": "GetPendingCollisionNotifies()",
    "kind": "Method",
    "detail": "Function (TArray<FCollisionNotifyInfo>&)",
    "insertText": "GetPendingCollisionNotifies(int32 SceneType)"
  },
  {
    "label": "SupportsOriginShifting()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SupportsOriginShifting()"
  },
  {
    "label": "ApplyWorldOffset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyWorldOffset(FVector InOffset)"
  },
  {
    "label": "OnStartFrame()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "OnStartFrame(float InDeltaTime)"
  },
  {
    "label": "HandleExecCommands()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HandleExecCommands(const TCHAR* Cmd, FOutputDevice* Ar)"
  },
  {
    "label": "ListAwakeRigidBodies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ListAwakeRigidBodies(bool bIncludeKinematic)"
  },
  {
    "label": "GetNumAwakeBodies()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumAwakeBodies()"
  },
  {
    "label": "StartAsync()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<IPhysicsReplicationFactory> PhysicsReplicationFactory ; void)",
    "insertText": "StartAsync()"
  },
  {
    "label": "HasAsyncScene()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasAsyncScene()"
  },
  {
    "label": "SetPhysXTreeRebuildRate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPhysXTreeRebuildRate(int32 RebuildRate)"
  },
  {
    "label": "EnsureCollisionTreeIsBuilt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnsureCollisionTreeIsBuilt(UWorld* World)"
  },
  {
    "label": "KillVisualDebugger()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "KillVisualDebugger()"
  },
  {
    "label": "DECLARE_MULTICAST_DELEGATE_TwoParams()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_MULTICAST_DELEGATE_TwoParams(FOnPhysScenePreTick, FPhysScene_Chaos*, float)"
  },
  {
    "label": "DECLARE_MULTICAST_DELEGATE_TwoParams()",
    "kind": "Method",
    "detail": "Function (FOnPhysScenePreTick OnPhysScenePreTick ;)",
    "insertText": "DECLARE_MULTICAST_DELEGATE_TwoParams(FOnPhysSceneStep, FPhysScene_Chaos*, float)"
  },
  {
    "label": "ExecPxVis()",
    "kind": "Method",
    "detail": "Function (FOnPhysSceneStep OnPhysSceneStep ; bool)",
    "insertText": "ExecPxVis(uint32 SceneType, const TCHAR* Cmd, FOutputDevice* Ar)"
  },
  {
    "label": "ExecApexVis()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExecApexVis(uint32 SceneType, const TCHAR* Cmd, FOutputDevice* Ar)"
  },
  {
    "label": "DeferPhysicsStateCreation()",
    "kind": "Method",
    "detail": "Function (Chaos::FCollisionModifierCallback CollisionModifierCallback ; void)",
    "insertText": "DeferPhysicsStateCreation(UPrimitiveComponent* Component)"
  },
  {
    "label": "RemoveDeferredPhysicsStateCreation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveDeferredPhysicsStateCreation(UPrimitiveComponent* Component)"
  },
  {
    "label": "ProcessDeferredCreatePhysicsState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessDeferredCreatePhysicsState()"
  },
  {
    "label": "GetChaosEventRelay()",
    "kind": "Method",
    "detail": "Function (UChaosEventRelay*)",
    "insertText": "GetChaosEventRelay()"
  },
  {
    "label": "GetStateFromReplicationCache()",
    "kind": "Method",
    "detail": "Function (} const FRigidBodyState*)",
    "insertText": "GetStateFromReplicationCache(UPrimitiveComponent* RootComponent, int& ServerFrame)"
  },
  {
    "label": "RegisterForReplicationCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterForReplicationCache(UPrimitiveComponent* RootComponent)"
  },
  {
    "label": "GetPhysicsReplicationCache()",
    "kind": "Method",
    "detail": "Function (} FPhysicsReplicationCache*)",
    "insertText": "GetPhysicsReplicationCache()"
  },
  {
    "label": "CreatePhysicsReplicationCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreatePhysicsReplicationCache()"
  },
  {
    "label": "FReplicationCacheData()",
    "kind": "Method",
    "detail": "Function (PRAGMA_DISABLE_DEPRECATION_WARNINGS)",
    "insertText": "FReplicationCacheData()"
  },
  {
    "label": "FReplicationCacheData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FReplicationCacheData(UPrimitiveComponent * InRootComponent, Chaos::FReal InAccessTime)"
  },
  {
    "label": "FReplicationCacheData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FReplicationCacheData(const FReplicationCacheData&)"
  },
  {
    "label": "FReplicationCacheData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FReplicationCacheData(FReplicationCacheData&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FReplicationCacheData&)",
    "insertText": "operator(const FReplicationCacheData&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FReplicationCacheData&)",
    "insertText": "operator(FReplicationCacheData&&)"
  },
  {
    "label": "GetRootComponent()",
    "kind": "Method",
    "detail": "Function (PRAGMA_ENABLE_DEPRECATION_WARNINGS PRAGMA_DISABLE_DEPRECATION_WARNINGS UPrimitiveComponent*)",
    "insertText": "GetRootComponent()"
  },
  {
    "label": "GetState()",
    "kind": "Method",
    "detail": "Function (} FRigidBodyState&)",
    "insertText": "GetState()"
  },
  {
    "label": "GetAccessTime()",
    "kind": "Method",
    "detail": "Function (AccessTime = Time ; } Chaos::FReal)",
    "insertText": "GetAccessTime()"
  },
  {
    "label": "IsCached()",
    "kind": "Method",
    "detail": "Function (bValidStateCached = InIsCached ; } bool)",
    "insertText": "IsCached()"
  },
  {
    "label": "FPrimitiveComponentReplicationCache()",
    "kind": "Method",
    "detail": "Function (PRAGMA_DISABLE_DEPRECATION_WARNINGS)",
    "insertText": "FPrimitiveComponentReplicationCache()"
  },
  {
    "label": "FPrimitiveComponentReplicationCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPrimitiveComponentReplicationCache(const FPrimitiveComponentReplicationCache&)"
  },
  {
    "label": "FPrimitiveComponentReplicationCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPrimitiveComponentReplicationCache(FPrimitiveComponentReplicationCache&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPrimitiveComponentReplicationCache&)",
    "insertText": "operator(const FPrimitiveComponentReplicationCache&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPrimitiveComponentReplicationCache&)",
    "insertText": "operator(FPrimitiveComponentReplicationCache&&)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (PRAGMA_ENABLE_DEPRECATION_WARNINGS PRAGMA_DISABLE_DEPRECATION_WARNINGS int32 ServerFrame = 0 ; TMap<FObjectKey,FReplicationCacheData> Map ; void)",
    "insertText": "Reset()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} PRAGMA_ENABLE_DEPRECATION_WARNINGS } ; private : TUniquePtr<FPhysicsReplicationCache> PhysicsReplicationCache ; TSet<UPrimitiveComponent*> CollisionEventRegistrations ; TSet<UPrimitiveComponent*> GlobalCollisionEventRegistrations ; TSet<UPrimitiveComponent*> GlobalRemovalEventRegistrations ; struct FUniqueContactPairKey { const void* Body0 ; const void* Body1 ; bool)",
    "insertText": "operator(const FUniqueContactPairKey& Lhs, const FUniqueContactPairKey& Rhs)"
  },
  {
    "label": "GetPendingCollisionForContactPair()",
    "kind": "Method",
    "detail": "Function (} } ; FCollisionNotifyInfo&)",
    "insertText": "GetPendingCollisionForContactPair(const void* P0, const void* P1, Chaos::FReal SolverTime, bool& bNewEntry)"
  },
  {
    "label": "HandleEachCollisionEvent()",
    "kind": "Method",
    "detail": "Function (TMultiMap<FUniqueContactPairKey,int32> ContactPairToPendingNotifyMap ; TArray<FCollisionNotifyInfo> PendingCollisionNotifies ; void)",
    "insertText": "HandleEachCollisionEvent(const TArray<int32>& CollisionIndices, IPhysicsProxyBase* PhysicsProxy0, UPrimitiveComponent* const Comp0, Chaos::FCollisionDataArray const& CollisionData, Chaos::FReal MinDeltaVelocityThreshold)"
  },
  {
    "label": "HandleGlobalCollisionEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleGlobalCollisionEvent(Chaos::FCollisionDataArray const& CollisionData)"
  },
  {
    "label": "HandleCollisionEvents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleCollisionEvents(const Chaos::FCollisionEventData& CollisionData)"
  },
  {
    "label": "DispatchPendingCollisionNotifies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DispatchPendingCollisionNotifies()"
  },
  {
    "label": "HandleBreakingEvents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleBreakingEvents(const Chaos::FBreakingEventData& Event)"
  },
  {
    "label": "HandleRemovalEvents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleRemovalEvents(const Chaos::FRemovalEventData& Event)"
  },
  {
    "label": "HandleCrumblingEvents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleCrumblingEvents(const Chaos::FCrumblingEventData& Event)"
  },
  {
    "label": "OnUpdateWorldPause()",
    "kind": "Method",
    "detail": "Function (TUniquePtr<IPhysicsReplication> PhysicsReplication ; # if CHAOS_WITH_PAUSABLE_SOLVER void)",
    "insertText": "OnUpdateWorldPause()"
  },
  {
    "label": "IsOwningWorldEditor()",
    "kind": "Method",
    "detail": "Function (# endif # if WITH_EDITOR bool)",
    "insertText": "IsOwningWorldEditor()"
  },
  {
    "label": "OnSyncBodies()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "OnSyncBodies(Chaos::FPhysicsSolverBase* Solver)"
  },
  {
    "label": "EnableAsyncPhysicsTickCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnableAsyncPhysicsTickCallback()"
  },
  {
    "label": "SetKinematicTransform()",
    "kind": "Method",
    "detail": "Function (# if 0 void)",
    "insertText": "SetKinematicTransform(FPhysicsActorHandle& InActorReference,const Chaos::TRigidTransform<float,3>& NewTransform)"
  },
  {
    "label": "EnableCollisionPair()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EnableCollisionPair(const TTuple<int32,int32>& CollisionPair)"
  },
  {
    "label": "DisableCollisionPair()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DisableCollisionPair(const TTuple<int32,int32>& CollisionPair)"
  },
  {
    "label": "AddSpringConstraint()",
    "kind": "Method",
    "detail": "Function (} # endif FPhysicsConstraintHandle)",
    "insertText": "AddSpringConstraint(const TArray< TPair<FPhysicsActorHandle,FPhysicsActorHandle> >& Constraint)"
  },
  {
    "label": "RemoveSpringConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveSpringConstraint(const FPhysicsConstraintHandle& Constraint)"
  },
  {
    "label": "AddForce()",
    "kind": "Method",
    "detail": "Function (# if 0 void)",
    "insertText": "AddForce(const Chaos::FVec3& Force,FPhysicsActorHandle& Handle)"
  },
  {
    "label": "AddTorque()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddTorque(const Chaos::FVec3& Torque,FPhysicsActorHandle& Handle)"
  },
  {
    "label": "UpdateKinematicsOnDeferredSkelMeshes()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "UpdateKinematicsOnDeferredSkelMeshes()"
  }
]