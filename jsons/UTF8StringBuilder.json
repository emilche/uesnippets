[
  {
    "label": "AllocatorType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AllocatorType"
  },
  {
    "label": "TUTF8StringBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TUTF8StringBuilder"
  },
  {
    "label": "OtherAllocatorType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OtherAllocatorType"
  },
  {
    "label": "CUTF8StringView()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" uLang / Common / Memory / Allocator . h \" # include \" uLang / Common / Text / UTF8String . h \" # include<stdio . h> # include<cstring> namespace uLang { const char* DefaultIndentCString = \" \" ; const uint32_t DefaultIndentCStringByteCount = 4 u ; const uint32_t DefaultIndentEffectiveSpaceCount = 4 u ; const CUTF8StringView DefaultIndentString =)",
    "insertText": "CUTF8StringView(DefaultIndentCString)"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (template<class AllocatorType,. . . AllocatorArgsType> class TUTF8StringBuilder { public : using StringType = TUTF8String<AllocatorType,AllocatorArgsType . . .> ;)",
    "insertText": "TUTF8StringBuilder(uint32_t ReserveBytes = 0) : _AllocatedBytes(0)"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TUTF8StringBuilder(const char* NullTerminatedString, AllocatorArgsType&&... AllocatorArgs)"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TUTF8StringBuilder(const CUTF8StringView& StringView, AllocatorArgsType&&... AllocatorArgs)"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (template<. . . FormatterArgsType>)",
    "insertText": "TUTF8StringBuilder(AllocatorArgsType&&... AllocatorArgs, const char* NullTerminatedFormat, FormatterArgsType&&... FormatterArgs)"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TUTF8StringBuilder(const TUTF8StringBuilder& Other)"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TUTF8StringBuilder(TUTF8StringBuilder&& Other)"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "TUTF8StringBuilder()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "EnsureAllocatedExtra()",
    "kind": "Method",
    "detail": "Function (_String . _String . _End = _String . _String . _Begin ; } void)",
    "insertText": "EnsureAllocatedExtra(size_t ExtraBytes)"
  },
  {
    "label": "ByteLen()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE int32_t)",
    "insertText": "ByteLen()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "IsFilled()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE bool)",
    "insertText": "IsFilled()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE const UTF8Char&)",
    "insertText": "operator(int32_t ByteIndex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class OtherAllocatorType,. . . OtherAllocatorArgsType> ULANG_FORCEINLINE bool)",
    "insertText": "operator(const TUTF8StringBuilder<OtherAllocatorType, OtherAllocatorArgsType...>& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TUTF8StringBuilder&)",
    "insertText": "operator(TUTF8StringBuilder&& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TUTF8StringBuilder&)",
    "insertText": "operator(const CUTF8StringView& StringView)"
  },
  {
    "label": "CUTF8StringView()",
    "kind": "Method",
    "detail": "Function (ULANG_FORCEINLINE operator const)",
    "insertText": "CUTF8StringView()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE const char*)",
    "insertText": "operator()"
  },
  {
    "label": "MoveToString()",
    "kind": "Method",
    "detail": "Function (} StringType)",
    "insertText": "MoveToString()"
  },
  {
    "label": "CopyToString()",
    "kind": "Method",
    "detail": "Function (StringType)",
    "insertText": "CopyToString()"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (TUTF8StringBuilder&)",
    "insertText": "Append(const CUTF8StringView& String)"
  },
  {
    "label": "AppendFormat()",
    "kind": "Method",
    "detail": "Function (template<. . . FormatterArgsType> TUTF8StringBuilder&)",
    "insertText": "AppendFormat(const char* NullTerminatedFormat, FormatterArgsType&&... FormatterArgs)"
  },
  {
    "label": "AppendBuffer()",
    "kind": "Method",
    "detail": "Function (UTF8Char*)",
    "insertText": "AppendBuffer(size_t ByteSize)"
  },
  {
    "label": "TrimEnd()",
    "kind": "Method",
    "detail": "Function (TUTF8StringBuilder&)",
    "insertText": "TrimEnd(UTF8Char Ch)"
  },
  {
    "label": "ReplaceRange()",
    "kind": "Method",
    "detail": "Function (TUTF8StringBuilder&)",
    "insertText": "ReplaceRange(SIdxRange ToBeReplaced, const CUTF8StringView& Replacement)"
  },
  {
    "label": "ReplaceAt()",
    "kind": "Method",
    "detail": "Function (TUTF8StringBuilder&)",
    "insertText": "ReplaceAt(int32_t Index, const UTF8Char Replacement)"
  },
  {
    "label": "ReplaceAll()",
    "kind": "Method",
    "detail": "Function (TUTF8StringBuilder&)",
    "insertText": "ReplaceAll(const UTF8Char Search, const UTF8Char Replacement)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (TUTF8StringBuilder&)",
    "insertText": "InsertAt(int32_t Index, const CUTF8StringView& StringToInsert)"
  },
  {
    "label": "LineIndentEditor()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "LineIndentEditor(int32_t Idx = 0, int32_t SpanCount = -1, int32_t SpaceCount = DefaultIndentEffectiveSpaceCount)"
  },
  {
    "label": "InputByteIdxToDirectIdx()",
    "kind": "Method",
    "detail": "Function (protected : ULANG_FORCEINLINE int32_t)",
    "insertText": "InputByteIdxToDirectIdx(int32_t InIdx)"
  },
  {
    "label": "InputByteIdxSpan()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE bool)",
    "insertText": "InputByteIdxSpan(int32_t& InOutIdx, int32_t& InOutSpan)"
  },
  {
    "label": "CalculateBytesToAllocate()",
    "kind": "Method",
    "detail": "Function (} private : ULANG_FORCEINLINE size_t)",
    "insertText": "CalculateBytesToAllocate(size_t RequestedBytes)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (size_t Alignment = 1<<1 1 ;)",
    "insertText": "return(RequestedBytes + (Alignment - 1)) & ~(Alignment - 1)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE void)",
    "insertText": "Construct(const UTF8Char* String, size_t ByteLength, const AllocatorType& Allocator)"
  },
  {
    "label": "CalculateBytesToAllocate()",
    "kind": "Method",
    "detail": "Function (size_t BytesToAllocate =)",
    "insertText": "CalculateBytesToAllocate(ByteLength + 1)"
  },
  {
    "label": "Memory()",
    "kind": "Method",
    "detail": "Function (UTF8Char*)",
    "insertText": "Memory(UTF8Char*)Allocator.Allocate(BytesToAllocate)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (_String . _String . _Begin = Memory ; _String . _String . _End = Memory + ByteLength ;)",
    "insertText": "if(ByteLength)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(Memory, String, ByteLength)"
  },
  {
    "label": "GetAllocator()",
    "kind": "Method",
    "detail": "Function (} Memory [ ByteLength ] = 0 ; _String .)",
    "insertText": "GetAllocator()"
  },
  {
    "label": "uint32_t()",
    "kind": "Method",
    "detail": "Function (_AllocatedBytes =)",
    "insertText": "uint32_t(BytesToAllocate)"
  },
  {
    "label": "EnsureAllocated()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE void)",
    "insertText": "EnsureAllocated(size_t BytesNeeded)"
  },
  {
    "label": "CalculateBytesToAllocate()",
    "kind": "Method",
    "detail": "Function (BytesNeeded =)",
    "insertText": "CalculateBytesToAllocate(BytesNeeded)"
  },
  {
    "label": "Memory()",
    "kind": "Method",
    "detail": "Function (UTF8Char*)",
    "insertText": "Memory(UTF8Char*)_String.GetAllocator().Reallocate((void*)_String._String._Begin, BytesNeeded)"
  },
  {
    "label": "uint32_t()",
    "kind": "Method",
    "detail": "Function (_String . _String . _Begin = Memory ; _AllocatedBytes =)",
    "insertText": "uint32_t(BytesNeeded)"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (} } StringType _String ; uint32_t _AllocatedBytes ; } ; using CUTF8StringBuilder = TUTF8StringBuilder<CHeapRawAllocator> ; using CUTF8StringBuilderA = TUTF8StringBuilder<CInstancedRawAllocator,CAllocatorInstance*> ; template<class AllocatorType,. . . AllocatorArgsType> ULANG_FORCEINLINE TUTF8StringBuilder<AllocatorType,AllocatorArgsType . . .)",
    "insertText": "TUTF8StringBuilder(const char* NullTerminatedString, AllocatorArgsType&&... AllocatorArgs) : _String(NoInit)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Construct((const UTF8Char*)NullTerminatedString, ::strlen(NullTerminatedString), AllocatorType(uLang::ForwardArg<AllocatorArgsType>(AllocatorArgs)...))"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (} template<class AllocatorType,. . . AllocatorArgsType> ULANG_FORCEINLINE TUTF8StringBuilder<AllocatorType,AllocatorArgsType . . .)",
    "insertText": "TUTF8StringBuilder(const CUTF8StringView& StringView, AllocatorArgsType&&... AllocatorArgs) : _String(NoInit)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Construct(StringView._Begin, StringView.ByteLen(), AllocatorType(uLang::ForwardArg<AllocatorArgsType>(AllocatorArgs)...))"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (} ULANG_SILENCE_SECURITY_WARNING_START template<class AllocatorType,. . . AllocatorArgsType> template<. . . FormatterArgsType> ULANG_FORCEINLINE TUTF8StringBuilder<AllocatorType,AllocatorArgsType . . .)",
    "insertText": "TUTF8StringBuilder(AllocatorArgsType&&... AllocatorArgs, const char* NullTerminatedFormat, FormatterArgsType&&... FormatterArgs) : _String(NoInit)"
  },
  {
    "label": "snprintf()",
    "kind": "Method",
    "detail": "Function (size_t ByteLength)",
    "insertText": "snprintf(nullptr, 0, NullTerminatedFormat, FormatterArgs...)"
  },
  {
    "label": "Allocator()",
    "kind": "Method",
    "detail": "Function (AllocatorType)",
    "insertText": "Allocator(AllocatorArgs...)"
  },
  {
    "label": "Text()",
    "kind": "Method",
    "detail": "Function (UTF8Char*)",
    "insertText": "Text(UTF8Char*)Allocator.Allocate(BytesToAllocate)"
  },
  {
    "label": "snprintf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "snprintf((char*)Text, BytesToAllocate, NullTerminatedFormat, FormatterArgs...)"
  },
  {
    "label": "CUTF8StringView()",
    "kind": "Method",
    "detail": "Function (_String . _String =)",
    "insertText": "CUTF8StringView(Text, Text + ByteLength)"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (} ULANG_SILENCE_SECURITY_WARNING_END template<class AllocatorType,. . . AllocatorArgsType> ULANG_FORCEINLINE TUTF8StringBuilder<AllocatorType,AllocatorArgsType . . .)",
    "insertText": "TUTF8StringBuilder(const TUTF8StringBuilder& Other) : _String(NoInit)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Construct(Other._String._String._Begin, Other.ByteLen(), Other._String.GetAllocator())"
  },
  {
    "label": "TUTF8StringBuilder()",
    "kind": "Method",
    "detail": "Function (} template<class AllocatorType,. . . AllocatorArgsType> ULANG_FORCEINLINE TUTF8StringBuilder<AllocatorType,AllocatorArgsType . . .)",
    "insertText": "TUTF8StringBuilder(TUTF8StringBuilder&& Other) : _String(ForwardArg<StringType>(Other._String)) , _AllocatedBytes(Other._AllocatedBytes)"
  },
  {
    "label": "String()",
    "kind": "Method",
    "detail": "Function (StringType)",
    "insertText": "String(NoInit)"
  },
  {
    "label": "Memory()",
    "kind": "Method",
    "detail": "Function (UTF8Char*)",
    "insertText": "Memory(UTF8Char*)_String.GetAllocator().Reallocate((void*)_String._String._Begin, ByteLength + 1)"
  },
  {
    "label": "GetAllocator()",
    "kind": "Method",
    "detail": "Function (} String .)",
    "insertText": "GetAllocator() = _String.GetAllocator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (_AllocatedBytes = 0 ; return String ; } template<class AllocatorType,. . . AllocatorArgsType> ULANG_FORCEINLINE TUTF8StringBuilder<AllocatorType,AllocatorArgsType . . .>& TUTF8StringBuilder<AllocatorType,AllocatorArgsType . . .)",
    "insertText": "operator(const TUTF8StringBuilder& Other)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(const_cast<UTF8Char*>(_String._String._Begin), Other._String._String._Begin, ByteLen + 1u)"
  },
  {
    "label": "_End()",
    "kind": "Method",
    "detail": "Function (} _String . _String .)",
    "insertText": "_End(UTF8Char*)"
  },
  {
    "label": "GetAllocator()",
    "kind": "Method",
    "detail": "Function (_String .)",
    "insertText": "GetAllocator() = Other._String.GetAllocator()"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (_String =)",
    "insertText": "Move(Other._String)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy((UTF8Char*)_String._String._Begin, StringView._Begin, ByteLen)"
  },
  {
    "label": "WritableEnd()",
    "kind": "Method",
    "detail": "Function (UTF8Char*)",
    "insertText": "WritableEnd(UTF8Char*)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(WritableEnd, String._Begin, OtherLength)"
  },
  {
    "label": "snprintf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "snprintf((char*)_String._String._End, _AllocatedBytes, NullTerminatedFormat, FormatterArgs...)"
  },
  {
    "label": "BufferStart()",
    "kind": "Method",
    "detail": "Function (UTF8Char*)",
    "insertText": "BufferStart(UTF8Char*)"
  },
  {
    "label": "NewEnd()",
    "kind": "Method",
    "detail": "Function (UTF8Char*)",
    "insertText": "NewEnd(UTF8Char*)( ((uint8_t*)BufferStart) + ByteSize)"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(ToBeReplaced._Begin <= uint32_t(ByteLen()) && ToBeReplaced._End <= uint32_t(ByteLen()) && ToBeReplaced._Begin <= ToBeReplaced._End, \"Malformed index range.\")"
  },
  {
    "label": "ByteLen()",
    "kind": "Method",
    "detail": "Function (size_t NewLength =)",
    "insertText": "ByteLen() - ToBeReplaced.GetLength() + Replacement.ByteLen()"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(const_cast<UTF8Char*>(_String._String._Begin) + ToBeReplaced._Begin + Replacement.ByteLen(), _String._String._Begin + ToBeReplaced._End, ByteLen() + 1 - ToBeReplaced._End)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(const_cast<UTF8Char*>(_String._String._Begin) + ToBeReplaced._Begin, Replacement._Begin, Replacement.ByteLen())"
  },
  {
    "label": "ULANG_ASSERTF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ULANG_ASSERTF(Index >= 0 && Index <= ByteLen(), \"Out-of-bounds index.\")"
  },
  {
    "label": "UTF8Char()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "UTF8Char(_String._String._Begin)"
  },
  {
    "label": "ByteLen()",
    "kind": "Method",
    "detail": "Function (size_t NewLength =)",
    "insertText": "ByteLen() + StringToInsert.ByteLen()"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(const_cast<UTF8Char*>(_String._String._Begin) + Index + StringToInsert.ByteLen(), _String._String._Begin + Index, ByteLen() - Index)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(const_cast<UTF8Char*>(_String._String._Begin) + Index, StringToInsert._Begin, StringToInsert.ByteLen())"
  },
  {
    "label": "LineIndentEditor()",
    "kind": "Method",
    "detail": "Function (} return* this ; } template<class AllocatorType,. . . AllocatorArgsType> int32_t TUTF8StringBuilder<AllocatorType,AllocatorArgsType . . .)",
    "insertText": "LineIndentEditor(int32_t Idx, int32_t SpanCount, int32_t SpaceCount)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (UTF8Char* CStrEnd = CStr + SpanCount ; int32_t LineCount = 1 ; int32_t IndentCount = 0 ; bool bNonWS = false ;)",
    "insertText": "while(CStr < CStrEnd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (IndentCount + + ; bNonWS = false ; } LineCount + + ; break ; case ' ' : case ' \\ t ' : case ' \\ r ' : break ; default : bNonWS = true ; } CStr + + ; })",
    "insertText": "if(bNonWS)"
  },
  {
    "label": "EnsureAllocatedExtra()",
    "kind": "Method",
    "detail": "Function (IndentCount + + ; } int32_t ExtraBytes = IndentCount* SpaceCount ;)",
    "insertText": "EnsureAllocatedExtra(ExtraBytes)"
  },
  {
    "label": "ByteLen()",
    "kind": "Method",
    "detail": "Function (size_t Bytes =)",
    "insertText": "ByteLen() - (Idx + SpanCount)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (CStrEnd = CStrStart + Idx + SpanCount ; UTF8Char* CStrDest = CStrEnd + ExtraBytes ;)",
    "insertText": "memmove(CStrDest, CStrEnd, Bytes)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (UTF8Char* CStrResume ; UTF8Char* CStrBegin = CStrStart + Idx ; CStr = CStrEnd - 1 ; do { bNonWS = false ;)",
    "insertText": "while((CStr > CStrBegin) && (*CStr != '\\n'))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bNonWS = true ; } CStr - - ; } CStrResume = CStr ;)",
    "insertText": "if(*CStr == '\\n')"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (CStr + + ; } Bytes =)",
    "insertText": "size_t(CStrEnd - CStr)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (CStrDest - = Bytes ; CStrEnd - = Bytes ;)",
    "insertText": "memmove(CStrDest, CStr, Bytes)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CStrDest - = SpaceCount ;)",
    "insertText": "if(SpaceCount)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(CStrDest, ' ', SpaceCount)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} } CStr = CStrResume - 1 ; })",
    "insertText": "while(CStr >= CStrBegin)"
  }
]