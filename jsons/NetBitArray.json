[
  {
    "label": "FNetBitArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNetBitArray"
  },
  {
    "label": "FNetBitArrayView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNetBitArrayView"
  },
  {
    "label": "FNetBitArrayRangedForConstIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNetBitArrayRangedForConstIterator"
  },
  {
    "label": "FNetBitArrayBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNetBitArrayBase"
  },
  {
    "label": "ENoResetNoValidateType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ENoResetNoValidateType"
  },
  {
    "label": "EResetOnInitType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EResetOnInitType"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" HAL / Platform . h \" # include \" HAL / PlatformMath . h \" # include \" HAL / PlatformMemory . h \" # include \" Misc / AssertionMacros . h \" # include<type_traits> namespace UE::Net { class FNetBitArray ; class FNetBitArrayView ; namespace Private { class FNetBitArrayRangedForConstIterator ; } } # ifndef UE_NETBITARRAY_VALIDATE #)",
    "insertText": "if(UE_BUILD_SHIPPING || UE_BUILD_TEST) # define UE_NETBITARRAY_VALIDATE 0 #else # define UE_NETBITARRAY_VALIDATE 1 #endif #endif #if UE_NETBITARRAY_VALIDATE # define UE_NETBITARRAY_CHECK(x) check(x) #else # define UE_NETBITARRAY_CHECK(...) #endif #define UE_NETBITARRAY_VALIDATE_BOTH_COMPATIBLE(lhs,rhs) UE_NETBITARRAY_CHECK((lhs).GetData() != (rhs).GetData() && (lhs).GetNumBits() == (rhs).GetNumBits())"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (class FNetBitArrayBase { public : enum ENoResetNoValidateType { NoResetNoValidate } ; enum EResetOnInitType { ResetOnInit } ; typedef uint32 StorageWordType ; uint32 WordBitCount =)",
    "insertText": "sizeof(StorageWordType)"
  },
  {
    "label": "AndOp()",
    "kind": "Method",
    "detail": "Function (uint32 InvalidIndex = ~ 0 U ; StorageWordType)",
    "insertText": "AndOp(StorageWordType A, StorageWordType B)"
  },
  {
    "label": "FNetBitArray()",
    "kind": "Method",
    "detail": "Function (} } ; class FNetBitArray : public FNetBitArrayBase { public :)",
    "insertText": "FNetBitArray()"
  },
  {
    "label": "FNetBitArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FNetBitArray(uint32 BitCount)"
  },
  {
    "label": "FNetBitArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FNetBitArray(uint32 BitCountIn, const ENoResetNoValidateType)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const FNetBitArray& Other)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(uint32 BitCount)"
  },
  {
    "label": "InitAndCopy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitAndCopy(const FNetBitArray& Source)"
  },
  {
    "label": "InitAndCopy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitAndCopy(const FNetBitArrayView& Source)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "SetNumBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNumBits(uint32 BitCount)"
  },
  {
    "label": "AddBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddBits(uint32 BitCount)"
  },
  {
    "label": "GetNumBits()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetNumBits()"
  },
  {
    "label": "GetNumWords()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetNumWords()"
  },
  {
    "label": "GetDataChecked()",
    "kind": "Method",
    "detail": "Function (} StorageWordType*)",
    "insertText": "GetDataChecked(uint32 MaxWordIterationCount)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} const StorageWordType*)",
    "insertText": "GetData()"
  },
  {
    "label": "GetWord()",
    "kind": "Method",
    "detail": "Function (} StorageWordType)",
    "insertText": "GetWord(uint32 WordIndex)"
  },
  {
    "label": "ClearAllBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearAllBits()"
  },
  {
    "label": "SetAllBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAllBits()"
  },
  {
    "label": "IsBitSet()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsBitSet(uint32 Index)"
  },
  {
    "label": "IsAnyBitSet()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsAnyBitSet()"
  },
  {
    "label": "IsAnyBitSet()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAnyBitSet(uint32 StartIndex, uint32 Count)"
  },
  {
    "label": "IsNoBitSet()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsNoBitSet()"
  },
  {
    "label": "SetBit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetBit(uint32 Index)"
  },
  {
    "label": "SetBitValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetBitValue(uint32 Index, bool bValue)"
  },
  {
    "label": "SetBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetBits(uint32 StartIndex, uint32 Count)"
  },
  {
    "label": "ClearBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearBits(uint32 StartIndex, uint32 Count)"
  },
  {
    "label": "ClearBit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearBit(uint32 Index)"
  },
  {
    "label": "GetBit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetBit(uint32 Index)"
  },
  {
    "label": "FindFirstZero()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "FindFirstZero()"
  },
  {
    "label": "FindFirstOne()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "FindFirstOne()"
  },
  {
    "label": "FindFirstZero()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "FindFirstZero(uint32 StartIndex)"
  },
  {
    "label": "FindFirstOne()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "FindFirstOne(uint32 StartIndex)"
  },
  {
    "label": "FindLastZero()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "FindLastZero()"
  },
  {
    "label": "FindLastOne()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "FindLastOne()"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ToString()"
  },
  {
    "label": "GetSetBitIndices()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetSetBitIndices(uint32 StartIndex, uint32 Count, uint32* OutIndices, uint32 OutIndicesCapacity)"
  },
  {
    "label": "CountSetBits()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "CountSetBits(uint32 StartIndex = 0, uint32 Count = ~0U)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Copy(const FNetBitArray& Other)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Copy(const FNetBitArrayView& Other)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (template<WordOpFunctor> void)",
    "insertText": "Set(const FNetBitArray& First, WordOpFunctor&& WordOp, const FNetBitArray& Second)"
  },
  {
    "label": "Combine()",
    "kind": "Method",
    "detail": "Function (template<WordOpFunctor> void)",
    "insertText": "Combine(const FNetBitArray& Other, WordOpFunctor&& WordOp)"
  },
  {
    "label": "CombineMultiple()",
    "kind": "Method",
    "detail": "Function (template<WordOpFunctor1,WordOpFunctor2> void)",
    "insertText": "CombineMultiple(WordOpFunctor1&& Op, const FNetBitArray& ArrayA, WordOpFunctor2&& Op2, const FNetBitArray& ArrayB)"
  },
  {
    "label": "ForAllSetBits()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "ForAllSetBits(T&& Functor)"
  },
  {
    "label": "ForAllSetBits()",
    "kind": "Method",
    "detail": "Function (template<T,V> void)",
    "insertText": "ForAllSetBits(const FNetBitArray& A, const FNetBitArray& B, T&& WordOpFunctor, V&& Functor)"
  },
  {
    "label": "ForAllExclusiveBits()",
    "kind": "Method",
    "detail": "Function (template<T,V> void)",
    "insertText": "ForAllExclusiveBits(const FNetBitArray& A, const FNetBitArray& B, T&& FunctorA, V&& FunctorB)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (Private::FNetBitArrayRangedForConstIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (Private::FNetBitArrayRangedForConstIterator)",
    "insertText": "end()"
  },
  {
    "label": "GetLastWordMask()",
    "kind": "Method",
    "detail": "Function (private : StorageWordType)",
    "insertText": "GetLastWordMask()"
  },
  {
    "label": "ClearPaddingBits()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearPaddingBits()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reserve(uint32 BitCount)"
  },
  {
    "label": "FNetBitArrayView()",
    "kind": "Method",
    "detail": "Function (TArray<StorageWordType> Storage ; uint32 BitCount ; } ; class FNetBitArrayView : public FNetBitArrayBase { public :)",
    "insertText": "FNetBitArrayView()"
  },
  {
    "label": "FNetBitArrayView()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FNetBitArrayView(StorageWordType* StorageIn, uint32 BitCountIn, const ENoResetNoValidateType)"
  },
  {
    "label": "FNetBitArrayView()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FNetBitArrayView(StorageWordType* StorageIn, uint32 BitCountIn, const EResetOnInitType)"
  },
  {
    "label": "FNetBitArrayView()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FNetBitArrayView(StorageWordType* StorageIn, uint32 BitCountIn)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const FNetBitArrayView& Other)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (template<WordOpFunctor> void)",
    "insertText": "Set(const FNetBitArrayView& First, WordOpFunctor&& WordOp, const FNetBitArrayView& Second)"
  },
  {
    "label": "Combine()",
    "kind": "Method",
    "detail": "Function (template<WordOpFunctor> void)",
    "insertText": "Combine(const FNetBitArrayView& Other, WordOpFunctor&& WordOp)"
  },
  {
    "label": "CombineMultiple()",
    "kind": "Method",
    "detail": "Function (template<WordOpFunctor1,WordOpFunctor2> void)",
    "insertText": "CombineMultiple(WordOpFunctor1&& Op, const FNetBitArrayView& ArrayA, WordOpFunctor2&& Op2, const FNetBitArrayView& ArrayB)"
  },
  {
    "label": "ForAllSetBits()",
    "kind": "Method",
    "detail": "Function (template<T,V> void)",
    "insertText": "ForAllSetBits(const FNetBitArrayView& A, const FNetBitArrayView& B, T&& WordOpFunctor, V&& Functor)"
  },
  {
    "label": "ForAllExclusiveBits()",
    "kind": "Method",
    "detail": "Function (template<T,V> void)",
    "insertText": "ForAllExclusiveBits(const FNetBitArrayView& A, const FNetBitArrayView& B, T&& FunctorA, V&& FunctorB)"
  },
  {
    "label": "CalculateRequiredWordCount()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "CalculateRequiredWordCount(uint32 BitCount)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} StorageWordType* Storage ; uint32 WordCount ; uint32 BitCount ; } ; / uint32)",
    "insertText": "operator()"
  },
  {
    "label": "FNetBitArrayRangedForConstIterator()",
    "kind": "Method",
    "detail": "Function (private : FNetBitArray ; FNetBitArrayView ; enum class ERangeStart : unsigned { Begin,End } ;)",
    "insertText": "FNetBitArrayRangedForConstIterator(const FNetBitArrayBase::StorageWordType* InData UE_LIFETIMEBOUND, uint32 BitCount, ERangeStart RangeStart)"
  },
  {
    "label": "AdvanceToNextSetBit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AdvanceToNextSetBit()"
  },
  {
    "label": "MakeNetBitArrayView()",
    "kind": "Method",
    "detail": "Function (const FNetBitArrayBase::StorageWordType* Data = nullptr ; uint32 BitCount = 0 ; uint32 WordCount = 0 ; uint32 CurrentBitIndex = 0 ; uint32 CurrentWord = 0 ; } ; } / FNetBitArrayView)",
    "insertText": "MakeNetBitArrayView(const FNetBitArrayView::StorageWordType* Storage, uint32 BitCount)"
  },
  {
    "label": "MakeNetBitArrayView()",
    "kind": "Method",
    "detail": "Function (} FNetBitArrayView)",
    "insertText": "MakeNetBitArrayView(const FNetBitArrayView::StorageWordType* Storage, uint32 BitCount, const FNetBitArrayBase::ENoResetNoValidateType)"
  },
  {
    "label": "MakeNetBitArrayView()",
    "kind": "Method",
    "detail": "Function (} FNetBitArrayView)",
    "insertText": "MakeNetBitArrayView(const FNetBitArray& BitArray)"
  },
  {
    "label": "MakeNetBitArrayView()",
    "kind": "Method",
    "detail": "Function (} FNetBitArrayView)",
    "insertText": "MakeNetBitArrayView(FNetBitArray& BitArray, const FNetBitArrayBase::ENoResetNoValidateType)"
  },
  {
    "label": "FNetBitArrayRangedForConstIterator()",
    "kind": "Method",
    "detail": "Function (} } namespace UE::Net::Private {)",
    "insertText": "FNetBitArrayRangedForConstIterator()"
  },
  {
    "label": "FNetBitArrayRangedForConstIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FNetBitArrayRangedForConstIterator(const FNetBitArrayBase::StorageWordType* InData UE_LIFETIMEBOUND, uint32 InBitCount, FNetBitArrayRangedForConstIterator::ERangeStart RangeStart) : Data(InData) , BitCount(InBitCount) , WordCount(FNetBitArrayView::CalculateRequiredWordCount(BitCount)) , CurrentBitIndex(RangeStart == ERangeStart::Begin ? 0 : BitCount)"
  },
  {
    "label": "UE_NETBITARRAY_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_NETBITARRAY_CHECK(InData != nullptr || InBitCount == 0)"
  },
  {
    "label": "CurrentWord()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CurrentWord(CurrentBitIndex < BitCount ? Data[0] : FNetBitArrayBase::StorageWordType(0))"
  },
  {
    "label": "UE_NETBITARRAY_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_NETBITARRAY_CHECK(this->Data == It.Data)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (using SignedWordType = std::make_signed<FNetBitArrayBase::StorageWordType>::type ; uint32 WordIt = CurrentBitIndex / FNetBitArrayBase::WordBitCount ;)",
    "insertText": "while(CurrentWord == 0U)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + WordIt ;)",
    "insertText": "if(WordIt >= WordCount)"
  },
  {
    "label": "NewBitIndex()",
    "kind": "Method",
    "detail": "Function (CurrentBitIndex = BitCount ; return ; } CurrentWord = Data [ WordIt ] ; CurrentBitIndex + = FNetBitArrayBase::WordBitCount ; } const uint32)",
    "insertText": "NewBitIndex(CurrentBitIndex & ~(FNetBitArrayBase::WordBitCount - 1U)) + FPlatformMath::CountTrailingZeros(CurrentWord)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (CurrentBitIndex =)",
    "insertText": "Min(NewBitIndex, BitCount)"
  },
  {
    "label": "StorageWordType()",
    "kind": "Method",
    "detail": "Function (const FNetBitArrayBase::StorageWordType LeastSignificantBit = CurrentWord&)",
    "insertText": "StorageWordType(-SignedWordType(CurrentWord))"
  }
]