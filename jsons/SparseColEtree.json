[
  {
    "label": "etree_find()",
    "kind": "Method",
    "detail": "Function (# ifndef SPARSE_COLETREE_H # define SPARSE_COLETREE_H namespace Eigen { namespace internal { template<Index,IndexVector> Index)",
    "insertText": "etree_find(Index i, IndexVector& pp)"
  },
  {
    "label": "pp()",
    "kind": "Method",
    "detail": "Function (Index p =)",
    "insertText": "pp(i)"
  },
  {
    "label": "pp()",
    "kind": "Method",
    "detail": "Function (Index gp =)",
    "insertText": "pp(p)"
  },
  {
    "label": "coletree()",
    "kind": "Method",
    "detail": "Function (} return p ; } template<MatrixType,IndexVector> int)",
    "insertText": "coletree(const MatrixType& mat, IndexVector& parent, IndexVector& firstRowElt, typename MatrixType::StorageIndex *perm=0)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (typedef MatrixType::StorageIndex StorageIndex ; StorageIndex nc = convert_index<)",
    "insertText": "StorageIndex(mat.cols())"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (StorageIndex m = convert_index<)",
    "insertText": "StorageIndex(mat.rows())"
  },
  {
    "label": "diagSize()",
    "kind": "Method",
    "detail": "Function (StorageIndex)",
    "insertText": "diagSize(std::min)(nc,m)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "root(nc)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (root .)",
    "insertText": "setZero()"
  },
  {
    "label": "pp()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "pp(nc)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (parent .)",
    "insertText": "resize(mat.cols())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (firstRowElt .)",
    "insertText": "resize(m)"
  },
  {
    "label": "setConstant()",
    "kind": "Method",
    "detail": "Function (firstRowElt .)",
    "insertText": "setConstant(nc)"
  },
  {
    "label": "segment()",
    "kind": "Method",
    "detail": "Function (firstRowElt .)",
    "insertText": "segment(0, diagSize).setLinSpaced(diagSize, 0, diagSize-1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool found_diag ;)",
    "insertText": "for(StorageIndex col = 0; col < nc; col++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StorageIndex pcol = col ;)",
    "insertText": "if(perm)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (Index row = it .)",
    "insertText": "row()"
  },
  {
    "label": "firstRowElt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "firstRowElt(row) = (std::min)(firstRowElt(row), col)"
  },
  {
    "label": "pp()",
    "kind": "Method",
    "detail": "Function (found_diag = col> = m ;)",
    "insertText": "pp(col)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (cset = col ;)",
    "insertText": "root(cset)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parent(col)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index i = col ;)",
    "insertText": "if(it) i = it.index()"
  },
  {
    "label": "firstRowElt()",
    "kind": "Method",
    "detail": "Function (StorageIndex row =)",
    "insertText": "firstRowElt(i)"
  },
  {
    "label": "etree_find()",
    "kind": "Method",
    "detail": "Function (rset =)",
    "insertText": "etree_find(row, pp)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (rroot =)",
    "insertText": "root(rset)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parent(rroot)"
  },
  {
    "label": "pp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pp(cset)"
  },
  {
    "label": "nr_etdfs()",
    "kind": "Method",
    "detail": "Function (} } } return 0 ; } template<IndexVector> void)",
    "insertText": "nr_etdfs(typename IndexVector::Scalar n, IndexVector& parent, IndexVector& first_kid, IndexVector& next_kid, IndexVector& post, typename IndexVector::Scalar postnum)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (typedef IndexVector::Scalar StorageIndex ; StorageIndex current = n,first,next ;)",
    "insertText": "while(postnum != n)"
  },
  {
    "label": "first_kid()",
    "kind": "Method",
    "detail": "Function (first =)",
    "insertText": "first_kid(current)"
  },
  {
    "label": "post()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "post(current)"
  },
  {
    "label": "next_kid()",
    "kind": "Method",
    "detail": "Function (next =)",
    "insertText": "next_kid(current)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (current =)",
    "insertText": "parent(current)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(postnum == n+1)"
  },
  {
    "label": "treePostorder()",
    "kind": "Method",
    "detail": "Function (current = next ; } else { current = first ; } } } template<IndexVector> void)",
    "insertText": "treePostorder(typename IndexVector::Scalar n, IndexVector& parent, IndexVector& post)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (typedef IndexVector::Scalar StorageIndex ; IndexVector first_kid,next_kid ; StorageIndex postnum ; first_kid .)",
    "insertText": "resize(n+1)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (next_kid .)",
    "insertText": "setZero(n+1)"
  },
  {
    "label": "setConstant()",
    "kind": "Method",
    "detail": "Function (first_kid .)",
    "insertText": "setConstant(-1)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (StorageIndex dad =)",
    "insertText": "parent(v)"
  },
  {
    "label": "next_kid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "next_kid(v) = first_kid(dad)"
  },
  {
    "label": "first_kid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "first_kid(dad)"
  },
  {
    "label": "nr_etdfs()",
    "kind": "Method",
    "detail": "Function (} postnum = 0 ;)",
    "insertText": "nr_etdfs(n, parent, first_kid, next_kid, post, postnum)"
  }
]