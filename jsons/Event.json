[
  {
    "label": "Event",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Event"
  },
  {
    "label": "WinSystemEvent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "WinSystemEvent"
  },
  {
    "label": "ConditionVariableEvent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConditionVariableEvent"
  },
  {
    "label": "ScopedAllowBaseSyncPrimitives",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScopedAllowBaseSyncPrimitives"
  },
  {
    "label": "ScopedAllowBaseSyncPrimitivesForTesting",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScopedAllowBaseSyncPrimitivesForTesting"
  },
  {
    "label": "ScopedDisallowWait",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScopedDisallowWait"
  },
  {
    "label": "DisallowYieldHandler",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DisallowYieldHandler"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef RTC_BASE_EVENT_H_ # define RTC_BASE_EVENT_H_ # include \" api / units / time_delta . h \" # if)",
    "insertText": "defined(WEBRTC_WIN) #include <windows.h> #include <condition_variable> #include <mutex> #include <variant> #include <thread> #include <deque> #elif defined(WEBRTC_POSIX)"
  },
  {
    "label": "RTC_DISALLOW_WAIT()",
    "kind": "Method",
    "detail": "Function (# if RTC_DCHECK_IS_ON # define)",
    "insertText": "RTC_DISALLOW_WAIT() ScopedDisallowWait disallow_wait_##__LINE__ #else #define RTC_DISALLOW_WAIT()"
  },
  {
    "label": "PlusInfinity()",
    "kind": "Method",
    "detail": "Function (public : webrtc::TimeDelta kForever = webrtc::)",
    "insertText": "PlusInfinity()"
  },
  {
    "label": "Event()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Event()"
  },
  {
    "label": "Event()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Event(bool manual_reset, bool initially_signaled)"
  },
  {
    "label": "Event()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Event(const Event&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Event&)",
    "insertText": "operator(const Event&)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Wait(webrtc::TimeDelta give_up_after, webrtc::TimeDelta warn_after)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Wait(webrtc::TimeDelta give_up_after)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} private : # if)",
    "insertText": "defined(WEBRTC_WIN)"
  },
  {
    "label": "WinSystemEvent()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "WinSystemEvent(HANDLE event_handle)"
  },
  {
    "label": "WinSystemEvent()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "WinSystemEvent()"
  },
  {
    "label": "ConditionVariableEvent()",
    "kind": "Method",
    "detail": "Function (private : HANDLE event_handle_ ; } ; class ConditionVariableEvent { public :)",
    "insertText": "ConditionVariableEvent(bool manual_reset, bool initially_signaled)"
  },
  {
    "label": "ConditionVariableEvent()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ConditionVariableEvent()"
  },
  {
    "label": "GetDefaultValue()",
    "kind": "Method",
    "detail": "Function (private : const bool manual_reset_ ; bool event_status_ ; std::deque<std::thread::id> waiting_threads_ ; std::mutex mutex_ ; std::condition_variable condition_variable_ ; } ; using EventImplType = std::variant<WinSystemEvent,ConditionVariableEvent> ; template<T> T)",
    "insertText": "GetDefaultValue()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<Callable>)",
    "insertText": "decltype(auto) Visit(Callable&& callable)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ConditionVariableEvent* event = std::get_if<ConditionVariableEvent>(&event_impl_))"
  },
  {
    "label": "RTC_CHECK()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "RTC_CHECK(false)"
  },
  {
    "label": "CreateEvent()",
    "kind": "Method",
    "detail": "Function (} } EventImplType)",
    "insertText": "CreateEvent(bool manual_reset, bool initially_signaled)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (EventImplType event_impl_ ; # elif)",
    "insertText": "defined(WEBRTC_POSIX)"
  },
  {
    "label": "ScopedAllowBaseSyncPrimitives()",
    "kind": "Method",
    "detail": "Function (pthread_cond_t event_cond_ ; const bool is_manual_reset_ ; std::atomic<bool> event_status_ ; # endif } ; class ScopedAllowBaseSyncPrimitives { public :)",
    "insertText": "ScopedAllowBaseSyncPrimitives()"
  },
  {
    "label": "ScopedAllowBaseSyncPrimitivesForTesting()",
    "kind": "Method",
    "detail": "Function (} } ; class ScopedAllowBaseSyncPrimitivesForTesting { public :)",
    "insertText": "ScopedAllowBaseSyncPrimitivesForTesting()"
  },
  {
    "label": "ScopedDisallowWait()",
    "kind": "Method",
    "detail": "Function (} } ; # if RTC_DCHECK_IS_ON class ScopedDisallowWait { public :)",
    "insertText": "ScopedDisallowWait()"
  },
  {
    "label": "YieldExecution()",
    "kind": "Method",
    "detail": "Function (private : class DisallowYieldHandler : public YieldInterface { public : void)",
    "insertText": "YieldExecution()"
  },
  {
    "label": "RTC_DCHECK_NOTREACHED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_NOTREACHED()"
  }
]