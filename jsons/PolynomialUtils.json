[
  {
    "label": "poly_eval_horner()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_POLYNOMIAL_UTILS_H # define EIGEN_POLYNOMIAL_UTILS_H namespace Eigen { template<Polynomials,T> T)",
    "insertText": "poly_eval_horner(const Polynomials& poly, const T& x)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (T val = poly [ poly .)",
    "insertText": "size()"
  },
  {
    "label": "poly_eval()",
    "kind": "Method",
    "detail": "Function (val = val* x + poly [ i ] ; } return val ; } template<Polynomials,T> T)",
    "insertText": "poly_eval(const Polynomials& poly, const T& x)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (typedef NumTraits<T>::Real Real ;)",
    "insertText": "if(numext::abs2( x ) <= Real(1))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else { T val = poly [ 0 ] ; T inv_x =)",
    "insertText": "T(1)"
  },
  {
    "label": "pow()",
    "kind": "Method",
    "detail": "Function (val = val* inv_x + poly [ i ] ; } return)",
    "insertText": "pow(x,(T)(poly.size()-1))"
  },
  {
    "label": "cauchy_max_bound()",
    "kind": "Method",
    "detail": "Function (} } template<Polynomial> NumTraits<Polynomial::Scalar>::Real)",
    "insertText": "cauchy_max_bound(const Polynomial& poly)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (using std::abs ; typedef Polynomial::Scalar Scalar ; typedef NumTraits<Scalar>::Real Real ;)",
    "insertText": "eigen_assert(Scalar(0) != poly[poly.size()-1])"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (const Scalar inv_leading_coeff =)",
    "insertText": "Scalar(1)/poly[poly.size()"
  },
  {
    "label": "cb()",
    "kind": "Method",
    "detail": "Function (Real)",
    "insertText": "cb(0)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (cb + =)",
    "insertText": "abs(poly[i]*inv_leading_coeff)"
  },
  {
    "label": "Real()",
    "kind": "Method",
    "detail": "Function (} return cb +)",
    "insertText": "Real(1)"
  },
  {
    "label": "cauchy_min_bound()",
    "kind": "Method",
    "detail": "Function (} template<Polynomial> NumTraits<Polynomial::Scalar>::Real)",
    "insertText": "cauchy_min_bound(const Polynomial& poly)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (using std::abs ; typedef Polynomial::Scalar Scalar ; typedef NumTraits<Scalar>::Real Real ; DenseIndex i = 0 ;)",
    "insertText": "while(i<poly.size()-1 && Scalar(0) == poly(i))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + i ; })",
    "insertText": "if(poly.size()-1 == i)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (} const Scalar inv_min_coeff =)",
    "insertText": "Scalar(1)"
  },
  {
    "label": "cb()",
    "kind": "Method",
    "detail": "Function (Real)",
    "insertText": "cb(1)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (cb + =)",
    "insertText": "abs(poly[j]*inv_min_coeff)"
  },
  {
    "label": "roots_to_monicPolynomial()",
    "kind": "Method",
    "detail": "Function (} template<RootVector,Polynomial> void)",
    "insertText": "roots_to_monicPolynomial(const RootVector& rv, Polynomial& poly)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (typedef Polynomial::Scalar Scalar ; poly .)",
    "insertText": "setZero(rv.size()+1)"
  }
]