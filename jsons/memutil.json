[
  {
    "label": "memcat()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_STRINGS_INTERNAL_MEMUTIL_H_ # define ABSL_STRINGS_INTERNAL_MEMUTIL_H_ # include<cstddef> # include<cstring> # include \" absl / base / port . h \" # include \" absl / strings / ascii . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace strings_internal { char*)",
    "insertText": "memcat(char* dest, size_t destlen, const char* src, size_t srclen)"
  },
  {
    "label": "memcasecmp()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "memcasecmp(const char* s1, const char* s2, size_t len)"
  },
  {
    "label": "memdup()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "memdup(const char* s, size_t slen)"
  },
  {
    "label": "memrchr()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "memrchr(const char* s, int c, size_t slen)"
  },
  {
    "label": "memspn()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "memspn(const char* s, size_t slen, const char* accept)"
  },
  {
    "label": "memcspn()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "memcspn(const char* s, size_t slen, const char* reject)"
  },
  {
    "label": "mempbrk()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "mempbrk(const char* s, size_t slen, const char* accept)"
  },
  {
    "label": "int_memmatch()",
    "kind": "Method",
    "detail": "Function (template<bool case_sensitive> const char*)",
    "insertText": "int_memmatch(const char* haystack, size_t haylen, const char* needle, size_t neelen)"
  },
  {
    "label": "ascii_tolower()",
    "kind": "Method",
    "detail": "Function (char hay = case_sensitive ?* haystack :)",
    "insertText": "ascii_tolower(static_cast<unsigned char>(*haystack))"
  },
  {
    "label": "ascii_tolower()",
    "kind": "Method",
    "detail": "Function (char nee = case_sensitive ?* needle :)",
    "insertText": "ascii_tolower(static_cast<unsigned char>(*needle))"
  },
  {
    "label": "memstr()",
    "kind": "Method",
    "detail": "Function (haystack - = needle - needlestart ; needle = needlestart ; } } return nullptr ; } const char*)",
    "insertText": "memstr(const char* phaystack, size_t haylen, const char* pneedle)"
  },
  {
    "label": "memcasestr()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "memcasestr(const char* phaystack, size_t haylen, const char* pneedle)"
  },
  {
    "label": "memmem()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "memmem(const char* phaystack, size_t haylen, const char* pneedle, size_t needlelen)"
  },
  {
    "label": "memcasemem()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "memcasemem(const char* phaystack, size_t haylen, const char* pneedle, size_t needlelen)"
  },
  {
    "label": "memmatch()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "memmatch(const char* phaystack, size_t haylen, const char* pneedle, size_t neelen)"
  }
]