[
  {
    "label": "EGBufferSlot",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EGBufferSlot"
  },
  {
    "label": "EGBufferCompression",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EGBufferCompression"
  },
  {
    "label": "EGBufferType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EGBufferType"
  },
  {
    "label": "EGBufferChecker",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EGBufferChecker"
  },
  {
    "label": "EGBufferLayout",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EGBufferLayout"
  },
  {
    "label": "FGBufferCompressionInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGBufferCompressionInfo"
  },
  {
    "label": "FGBufferPacking",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGBufferPacking"
  },
  {
    "label": "FGBufferItem",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGBufferItem"
  },
  {
    "label": "FGBufferTarget",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGBufferTarget"
  },
  {
    "label": "FGBufferBinding",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGBufferBinding"
  },
  {
    "label": "FGBufferBindings",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGBufferBindings"
  },
  {
    "label": "FGBufferInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGBufferInfo"
  },
  {
    "label": "FGBufferParams",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGBufferParams"
  },
  {
    "label": "FGBufferPacking()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / UnrealString . h \" # include \" CoreMinimal . h \" # include \" HAL / Platform . h \" # include \" PixelFormat . h \" # include \" RHIDefinitions . h \" # include \" RHIShaderPlatform . h \" enum EGBufferSlot { GBS_Invalid,GBS_SceneColor,GBS_WorldNormal,GBS_PerObjectGBufferData,GBS_Metallic,GBS_Specular,GBS_Roughness,GBS_ShadingModelId,GBS_SelectiveOutputMask,GBS_BaseColor,GBS_GenericAO,GBS_IndirectIrradiance,GBS_AO,GBS_Velocity,GBS_PrecomputedShadowFactor,GBS_WorldTangent,GBS_Anisotropy,GBS_CustomData,GBS_SubsurfaceColor,GBS_Opacity,GBS_SubsurfaceProfile,GBS_ClearCoat,GBS_ClearCoatRoughness,GBS_HairSecondaryWorldNormal,GBS_HairBacklit,GBS_Cloth,GBS_SubsurfaceProfileX,GBS_IrisNormal,GBS_SeparatedMainDirLight,GBS_Num } ; enum EGBufferCompression { GBC_Invalid,GBC_Raw_Float_16_16_16_16,GBC_Raw_Float_16_16_16,GBC_Raw_Float_11_11_10,GBC_Raw_Float_10_10_10,GBC_Raw_Unorm_8_8_8_8,GBC_Raw_Unorm_8_8_8,GBC_Raw_Unorm_8_8,GBC_Raw_Unorm_8,GBC_Raw_Unorm_2,GBC_Raw_Float_16_16,GBC_Raw_Float_16,GBC_Bits_4,GBC_Bits_2,GBC_Packed_Normal_Octahedral_8_8,GBC_EncodeNormal_Normal_16_16_16,GBC_EncodeNormal_Normal_10_10_10,GBC_EncodeNormal_Normal_8_8_8,GBC_Packed_Color_5_6_5,GBC_Packed_Color_5_6_5_Sqrt,GBC_Packed_Color_4_4_4,GBC_Packed_Color_4_4_4_Sqrt,GBC_Packed_Color_3_3_2,GBC_Packed_Color_3_3_2_Sqrt,GBC_Packed_Quantized_6,GBC_Packed_Quantized_4,GBC_Packed_Quantized_2,GBC_Num } ; enum EGBufferType { GBT_Invalid,GBT_Unorm_16_16,GBT_Unorm_8_8_8_8,GBT_Unorm_11_11_10,GBT_Unorm_10_10_10_2,GBT_Unorm_16_16_16_16,GBT_Float_16_16,GBT_Float_16_16_16_16,GBT_Float_32,GBT_Num } ; enum EGBufferChecker { GBCH_Invalid,GBCH_Even,GBCH_Odd,GBCH_Both,GBCH_Num } ; enum EGBufferLayout { GBL_Default,GBL_ForceVelocity,GBL_Num } ; struct FGBufferCompressionInfo { EGBufferCompression Type ; int32 SrcNumChan ; int32 DstNumChan ; int32 ChanBits [ 4 ] ; bool bIsPackedBits ; bool bIsConversion ; const TCHAR* EncodeFuncName ; const TCHAR* DecodeFuncName ; } ; struct FGBufferPacking {)",
    "insertText": "FGBufferPacking()"
  },
  {
    "label": "FGBufferPacking()",
    "kind": "Method",
    "detail": "Function (bIsValid = false ; bFull = false ; TargetIndex = - 1 ; DstChannelIndex = - 1 ; SrcChannelIndex = - 1 ; DstBitStart = - 1 ; SrcBitStart = - 1 ; BitNum = - 1 ; })",
    "insertText": "FGBufferPacking(int32 InTargetIndex, int32 InSrcChannelIndex, int32 InDstChannelIndex)"
  },
  {
    "label": "FGBufferPacking()",
    "kind": "Method",
    "detail": "Function (bIsValid = true ; bFull = true ; TargetIndex = InTargetIndex ; DstChannelIndex = InDstChannelIndex ; SrcChannelIndex = InSrcChannelIndex ; DstBitStart = - 1 ; SrcBitStart = - 1 ; BitNum = - 1 ; })",
    "insertText": "FGBufferPacking(int32 InTargetIndex, int32 InSrcChannelIndex, int32 InDstChannelIndex, int32 InSrcBitStart, int32 InDstBitStart, int32 InBitNum)"
  },
  {
    "label": "FGBufferItem()",
    "kind": "Method",
    "detail": "Function (bIsValid = true ; bFull = false ; TargetIndex = InTargetIndex ; DstChannelIndex = InDstChannelIndex ; SrcChannelIndex = InSrcChannelIndex ; DstBitStart = InDstBitStart ; SrcBitStart = InSrcBitStart ; BitNum = InBitNum ; } bool bIsValid ; bool bFull ; int32 TargetIndex ; int32 DstChannelIndex ; int32 DstBitStart ; int32 SrcChannelIndex ; int32 SrcBitStart ; int32 BitNum ; } ; struct FGBufferItem {)",
    "insertText": "FGBufferItem()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bIsValid = false ; bQuantizationBias = false ; BufferSlot = GBS_Invalid ; Compression = GBC_Invalid ; Checker = GBCH_Invalid ;)",
    "insertText": "for(int32 I = 0; I < 4; I++)"
  },
  {
    "label": "FGBufferItem()",
    "kind": "Method",
    "detail": "Function (Packing [ I ] = { } ; } })",
    "insertText": "FGBufferItem(EGBufferSlot InBufferSlot, EGBufferCompression InCompression, EGBufferChecker InChecker)"
  },
  {
    "label": "FGBufferTarget()",
    "kind": "Method",
    "detail": "Function (Packing [ I ] = { } ; } } const int MaxPacking = 8 ; bool bIsValid ; bool bQuantizationBias ; EGBufferSlot BufferSlot ; EGBufferCompression Compression ; EGBufferChecker Checker ; FGBufferPacking Packing [ MaxPacking ] ; } ; struct FGBufferTarget {)",
    "insertText": "FGBufferTarget()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TargetType = GBT_Invalid ; bIsSrgb = false ; bIsRenderTargetable = false ; bIsShaderResource = false ; bIsUsingExtraFlags = false ; } bool)",
    "insertText": "operator(const FGBufferTarget & Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TargetType = InTargetType ; TargetName = InTargetName ; bIsSrgb = bInIsSrgb ; bIsRenderTargetable = bInIsRenderTargetable ; bIsShaderResource = bInIsShaderResource ; bIsUsingExtraFlags = bInIsUsingExtraFlags ; } EGBufferType TargetType ; FString TargetName ; bool bIsSrgb ; bool bIsRenderTargetable ; bool bIsShaderResource ; bool bIsUsingExtraFlags ; } ; struct FGBufferBinding { int32 Index = - 1 ; EPixelFormat Format = PF_Unknown ; ETextureCreateFlags Flags = TexCreate_None ; } ; struct FGBufferBindings { FGBufferBinding GBufferA ; FGBufferBinding GBufferB ; FGBufferBinding GBufferC ; FGBufferBinding GBufferD ; FGBufferBinding GBufferE ; FGBufferBinding GBufferVelocity ; } ; struct FGBufferInfo { const int MaxTargets = 8 ; int32 NumTargets ; FGBufferTarget Targets [ MaxTargets ] ; FGBufferItem Slots [ GBS_Num ] ; } ; struct FGBufferParams { EShaderPlatform ShaderPlatform = SP_NumPlatforms ; int32 LegacyFormatIndex = 0 ; bool bHasVelocity = false ; bool bHasTangent = false ; bool bHasPrecShadowFactor = false ; bool bUsesVelocityDepth = false ; bool bHasSingleLayerWaterSeparatedMainLight = false ; bool)",
    "insertText": "operator(const FGBufferParams& RHS)"
  },
  {
    "label": "FindGBufferTargetByName()",
    "kind": "Method",
    "detail": "Function (} } ; int32)",
    "insertText": "FindGBufferTargetByName(const FGBufferInfo& GBufferInfo, const FString& Name)"
  },
  {
    "label": "FindGBufferBindingByName()",
    "kind": "Method",
    "detail": "Function (FGBufferBinding)",
    "insertText": "FindGBufferBindingByName(const FGBufferInfo& GBufferInfo, const FString& Name, EShaderPlatform ShaderPlatform)"
  },
  {
    "label": "FetchFullGBufferInfo()",
    "kind": "Method",
    "detail": "Function (} FGBufferInfo)",
    "insertText": "FetchFullGBufferInfo(const FGBufferParams& Params)"
  },
  {
    "label": "IsGBufferInfoEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsGBufferInfoEqual(const FGBufferInfo& Lhs, const FGBufferInfo& Rhs)"
  }
]