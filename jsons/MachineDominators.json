[
  {
    "label": "DomTreeNodeBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DomTreeNodeBase"
  },
  {
    "label": "DominatorTreeBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DominatorTreeBase"
  },
  {
    "label": "MachineDominatorTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineDominatorTree"
  },
  {
    "label": "CriticalEdge",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CriticalEdge"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "GraphTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GraphTraits"
  },
  {
    "label": "addRoot()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_CODEGEN_MACHINEDOMINATORS_H # define LLVM_CODEGEN_MACHINEDOMINATORS_H # include \" llvm / ADT / SmallSet . h \" # include \" llvm / CodeGen / MachineBasicBlock . h \" # include \" llvm / CodeGen / MachineFunction . h \" # include \" llvm / CodeGen / MachineFunctionPass . h \" # include \" llvm / Support / GenericDomTree . h \" # include \" llvm / Support / GenericDomTreeConstruction . h \" namespace llvm { template<> void DominatorTreeBase<MachineBasicBlock)",
    "insertText": "addRoot(MachineBasicBlock* MBB)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (this -> Roots .)",
    "insertText": "push_back(MBB)"
  },
  {
    "label": "applySplitCriticalEdges()",
    "kind": "Method",
    "detail": "Function (} template class DomTreeNodeBase<MachineBasicBlock> ; template class DominatorTreeBase<MachineBasicBlock> ; typedef DomTreeNodeBase<MachineBasicBlock> MachineDomTreeNode ; class MachineDominatorTree : public MachineFunctionPass { struct CriticalEdge { MachineBasicBlock* FromBB ; MachineBasicBlock* ToBB ; MachineBasicBlock* NewBB ; } ; SmallVector<CriticalEdge,3 2> CriticalEdgesToSplit ; SmallSet<MachineBasicBlock*,3 2> NewBBs ; void)",
    "insertText": "applySplitCriticalEdges()"
  },
  {
    "label": "MachineDominatorTree()",
    "kind": "Method",
    "detail": "Function (public : char ID ; DominatorTreeBase<MachineBasicBlock>* DT ;)",
    "insertText": "MachineDominatorTree()"
  },
  {
    "label": "getRoots()",
    "kind": "Method",
    "detail": "Function (const std::vector<MachineBasicBlock*>&)",
    "insertText": "getRoots()"
  },
  {
    "label": "getRoot()",
    "kind": "Method",
    "detail": "Function (} MachineBasicBlock*)",
    "insertText": "getRoot()"
  },
  {
    "label": "getRootNode()",
    "kind": "Method",
    "detail": "Function (} MachineDomTreeNode*)",
    "insertText": "getRootNode()"
  },
  {
    "label": "runOnMachineFunction()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "runOnMachineFunction(MachineFunction &F)"
  },
  {
    "label": "dominates()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "dominates(const MachineDomTreeNode* A, const MachineDomTreeNode* B)"
  },
  {
    "label": "dominates()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "dominates(const MachineBasicBlock* A, const MachineBasicBlock* B)"
  },
  {
    "label": "dominates()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "dominates(const MachineInstr *A, const MachineInstr *B)"
  },
  {
    "label": "getParent()",
    "kind": "Method",
    "detail": "Function (const MachineBasicBlock* BBA = A ->)",
    "insertText": "getParent(), *BBB = B->getParent()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (MachineBasicBlock::const_iterator I = BBA ->)",
    "insertText": "begin()"
  },
  {
    "label": "properlyDominates()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "properlyDominates(const MachineBasicBlock* A, const MachineBasicBlock* B)"
  },
  {
    "label": "findNearestCommonDominator()",
    "kind": "Method",
    "detail": "Function (} MachineBasicBlock*)",
    "insertText": "findNearestCommonDominator(MachineBasicBlock *A, MachineBasicBlock *B)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} MachineDomTreeNode*)",
    "insertText": "operator(MachineBasicBlock *BB)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (} MachineDomTreeNode*)",
    "insertText": "getNode(MachineBasicBlock *BB)"
  },
  {
    "label": "addNewBlock()",
    "kind": "Method",
    "detail": "Function (} MachineDomTreeNode*)",
    "insertText": "addNewBlock(MachineBasicBlock *BB, MachineBasicBlock *DomBB)"
  },
  {
    "label": "changeImmediateDominator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "changeImmediateDominator(MachineBasicBlock *N, MachineBasicBlock* NewIDom)"
  },
  {
    "label": "changeImmediateDominator()",
    "kind": "Method",
    "detail": "Function (DT ->)",
    "insertText": "changeImmediateDominator(N, NewIDom)"
  },
  {
    "label": "changeImmediateDominator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "changeImmediateDominator(MachineDomTreeNode *N, MachineDomTreeNode* NewIDom)"
  },
  {
    "label": "eraseNode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "eraseNode(MachineBasicBlock *BB)"
  },
  {
    "label": "eraseNode()",
    "kind": "Method",
    "detail": "Function (DT ->)",
    "insertText": "eraseNode(BB)"
  },
  {
    "label": "splitBlock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "splitBlock(MachineBasicBlock* NewBB)"
  },
  {
    "label": "splitBlock()",
    "kind": "Method",
    "detail": "Function (DT ->)",
    "insertText": "splitBlock(NewBB)"
  },
  {
    "label": "isReachableFromEntry()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isReachableFromEntry(const MachineBasicBlock *A)"
  },
  {
    "label": "releaseMemory()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "releaseMemory()"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS, const Module*)"
  },
  {
    "label": "recordSplitCriticalEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "recordSplitCriticalEdge(MachineBasicBlock *FromBB, MachineBasicBlock *ToBB, MachineBasicBlock *NewBB)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (bool Inserted = NewBBs .)",
    "insertText": "insert(NewBB)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Inserted && \"A basic block inserted via edge splitting cannot appear twice\")"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (CriticalEdgesToSplit .)",
    "insertText": "push_back({FromBB, ToBB, NewBB})"
  },
  {
    "label": "getEntryNode()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T> struct GraphTraits ; template<> struct GraphTraits<MachineDomTreeNode*> { typedef MachineDomTreeNode NodeType ; typedef NodeType::iterator ChildIteratorType ; NodeType*)",
    "insertText": "getEntryNode(NodeType *N)"
  },
  {
    "label": "child_end()",
    "kind": "Method",
    "detail": "Function (} ChildIteratorType)",
    "insertText": "child_end(NodeType* N)"
  },
  {
    "label": "getEntryNode()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct GraphTraits<MachineDominatorTree*> : public GraphTraits<MachineDomTreeNode*> { NodeType*)",
    "insertText": "getEntryNode(MachineDominatorTree *DT)"
  }
]