[
  {
    "label": "Surface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Surface"
  },
  {
    "label": "PointDescriptor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PointDescriptor"
  },
  {
    "label": "SurfaceFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SurfaceFactory"
  },
  {
    "label": "PointDescriptor()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENSUBDIV3_BFR_SURFACE_H # define OPENSUBDIV3_BFR_SURFACE_H # include \" . . / version . h \" # include \" . . / bfr / surfaceData . h \" # include \" . . / bfr / parameterization . h \" # include \" . . / vtr / array . h \" namespace OpenSubdiv { namespace OPENSUBDIV_VERSION { namespace Bfr { template<REAL> class Surface { public : struct PointDescriptor {)",
    "insertText": "PointDescriptor() : size(0), stride(0)"
  },
  {
    "label": "PointDescriptor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PointDescriptor(int n) : size(n), stride(n)"
  },
  {
    "label": "PointDescriptor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PointDescriptor(int n, int m) : size(n), stride(m)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} int size,stride ; } ; typedef int Index ; public : bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Clear()"
  },
  {
    "label": "reinitialize()",
    "kind": "Method",
    "detail": "Function (_data .)",
    "insertText": "reinitialize()"
  },
  {
    "label": "Surface()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Surface()"
  },
  {
    "label": "Surface()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Surface(Surface const & src)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Surface&)",
    "insertText": "operator(Surface const & src)"
  },
  {
    "label": "GetParameterization()",
    "kind": "Method",
    "detail": "Function (Parameterization)",
    "insertText": "GetParameterization()"
  },
  {
    "label": "GetFaceSize()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetFaceSize()"
  },
  {
    "label": "IsRegular()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsRegular()"
  },
  {
    "label": "IsLinear()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsLinear()"
  },
  {
    "label": "GetNumControlPoints()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetNumControlPoints()"
  },
  {
    "label": "GetControlPointIndices()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetControlPointIndices(Index meshPointIndices[])"
  },
  {
    "label": "GatherControlPoints()",
    "kind": "Method",
    "detail": "Function (template<REAL_MESH> void)",
    "insertText": "GatherControlPoints(REAL_MESH const meshPoints[], PointDescriptor const & meshPointDesc, REAL controlPoints[], PointDescriptor const & controlPointDesc)"
  },
  {
    "label": "BoundControlPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BoundControlPoints(REAL const controlPoints[], PointDescriptor const & controlPointDesc, REAL minExtent[], REAL maxExtent[])"
  },
  {
    "label": "BoundControlPointsFromMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BoundControlPointsFromMesh(REAL const meshPoints[], PointDescriptor const & meshPointDesc, REAL minExtent[], REAL maxExtent[])"
  },
  {
    "label": "GetNumPatchPoints()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetNumPatchPoints()"
  },
  {
    "label": "PreparePatchPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PreparePatchPoints(REAL const meshPoints[], PointDescriptor const & meshPointDesc, REAL patchPoints[], PointDescriptor const & patchPointDesc)"
  },
  {
    "label": "ComputePatchPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputePatchPoints(REAL patchPoints[], PointDescriptor const & patchPointDesc)"
  },
  {
    "label": "Evaluate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Evaluate(REAL const uv[2], REAL const patchPoints[], PointDescriptor const & pointDesc, REAL P[])"
  },
  {
    "label": "Evaluate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Evaluate(REAL const uv[2], REAL const patchPoints[], PointDescriptor const & pointDesc, REAL P[], REAL Du[], REAL Dv[])"
  },
  {
    "label": "Evaluate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Evaluate(REAL const uv[2], REAL const patchPoints[], PointDescriptor const & pointDesc, REAL P[], REAL Du[], REAL Dv[], REAL Duu[], REAL Duv[], REAL Dvv[])"
  },
  {
    "label": "EvaluateStencil()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "EvaluateStencil(REAL const uv[2], REAL sP[])"
  },
  {
    "label": "EvaluateStencil()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "EvaluateStencil(REAL const uv[2], REAL sP[], REAL sDu[], REAL sDv[])"
  },
  {
    "label": "EvaluateStencil()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "EvaluateStencil(REAL const uv[2], REAL sP[], REAL sDu[], REAL sDv[], REAL sDuu[], REAL sDuv[], REAL sDvv[])"
  },
  {
    "label": "ApplyStencil()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyStencil(REAL const stencil[], REAL const controlPoints[], PointDescriptor const &, REAL result[])"
  },
  {
    "label": "ApplyStencilFromMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyStencilFromMesh(REAL const stencil[], REAL const meshPoints[], PointDescriptor const &, REAL result[])"
  },
  {
    "label": "evaluateDerivs()",
    "kind": "Method",
    "detail": "Function (private : typedef Vtr::ConstArray<int> IndexArray ; void)",
    "insertText": "evaluateDerivs(REAL const uv[2], REAL const patchPoints[], PointDescriptor const &, REAL * derivs[])"
  },
  {
    "label": "evalRegularDerivs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalRegularDerivs(REAL const uv[2], REAL const patchPoints[], PointDescriptor const &, REAL * derivs[])"
  },
  {
    "label": "evalIrregularDerivs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalIrregularDerivs(REAL const uv[2], REAL const patchPoints[], PointDescriptor const &, REAL * derivs[])"
  },
  {
    "label": "evalMultiLinearDerivs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalMultiLinearDerivs(REAL const uv[2], REAL const patchPoints[], PointDescriptor const &, REAL * derivs[])"
  },
  {
    "label": "evalRegularBasis()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalRegularBasis(REAL const uv[2], REAL * wDeriv[])"
  },
  {
    "label": "evalIrregularBasis()",
    "kind": "Method",
    "detail": "Function (IndexArray)",
    "insertText": "evalIrregularBasis(REAL const uv[2], REAL * wDeriv[])"
  },
  {
    "label": "evalMultiLinearBasis()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "evalMultiLinearBasis(REAL const uv[2], REAL * wDeriv[])"
  },
  {
    "label": "evaluateStencils()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "evaluateStencils(REAL const uv[2], REAL * sDeriv[])"
  },
  {
    "label": "evalRegularStencils()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "evalRegularStencils(REAL const uv[2], REAL * sDeriv[])"
  },
  {
    "label": "evalIrregularStencils()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "evalIrregularStencils(REAL const uv[2], REAL * sDeriv[])"
  },
  {
    "label": "evalMultiLinearStencils()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "evalMultiLinearStencils(REAL const uv[2], REAL * sDeriv[])"
  },
  {
    "label": "computeLinearPatchPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeLinearPatchPoints(REAL p[], PointDescriptor const &)"
  },
  {
    "label": "computeIrregularPatchPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeIrregularPatchPoints(REAL p[], PointDescriptor const &)"
  },
  {
    "label": "getRegPatchType()",
    "kind": "Method",
    "detail": "Function (unsigned char)",
    "insertText": "getRegPatchType()"
  },
  {
    "label": "getRegPatchMask()",
    "kind": "Method",
    "detail": "Function (} unsigned char)",
    "insertText": "getRegPatchMask()"
  },
  {
    "label": "getIrregPatch()",
    "kind": "Method",
    "detail": "Function (} internal::IrregularPatchType const&)",
    "insertText": "getIrregPatch()"
  },
  {
    "label": "getSurfaceData()",
    "kind": "Method",
    "detail": "Function (private : class SurfaceFactory ; internal::SurfaceData&)",
    "insertText": "getSurfaceData()"
  },
  {
    "label": "computeLinearPatchPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeLinearPatchPoints(points, pointDesc)"
  },
  {
    "label": "computeIrregularPatchPoints()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "computeIrregularPatchPoints(points, pointDesc)"
  },
  {
    "label": "GatherControlPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GatherControlPoints(meshPoints, meshPointDesc, patchPoints, patchPointDesc)"
  },
  {
    "label": "ComputePatchPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputePatchPoints(patchPoints, patchPointDesc)"
  },
  {
    "label": "evaluateDerivs()",
    "kind": "Method",
    "detail": "Function (} template<REAL> void Surface<REAL)",
    "insertText": "evaluateDerivs(REAL const uv[2], REAL const patchPoints[], PointDescriptor const & pointDesc, REAL * derivatives[])"
  },
  {
    "label": "evalRegularDerivs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalRegularDerivs(uv, patchPoints, pointDesc, derivatives)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(IsLinear())"
  },
  {
    "label": "evalMultiLinearDerivs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalMultiLinearDerivs(uv, patchPoints, pointDesc, derivatives)"
  },
  {
    "label": "evalIrregularDerivs()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "evalIrregularDerivs(uv, patchPoints, pointDesc, derivatives)"
  },
  {
    "label": "evaluateDerivs()",
    "kind": "Method",
    "detail": "Function (REAL* derivatives [ 6 ] = { P,0,0,0,0,0 } ;)",
    "insertText": "evaluateDerivs(uv, patchPoints, pointDesc, derivatives)"
  },
  {
    "label": "evalIrregularStencils()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "evalIrregularStencils(uv, sDeriv)"
  },
  {
    "label": "evaluateStencils()",
    "kind": "Method",
    "detail": "Function (REAL* derivativeStencils [ 6 ] = { sP,0,0,0,0,0 } ; return)",
    "insertText": "evaluateStencils(uv, derivativeStencils)"
  }
]