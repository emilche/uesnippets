[
  {
    "label": "AscendingSeqNumComp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AscendingSeqNumComp"
  },
  {
    "label": "DescendingSeqNumComp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DescendingSeqNumComp"
  },
  {
    "label": "SeqNumUnwrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SeqNumUnwrapper"
  },
  {
    "label": "enable_if()",
    "kind": "Method",
    "detail": "Function (# ifndef RTC_BASE_NUMERICS_SEQUENCE_NUMBER_UTIL_H_ # define RTC_BASE_NUMERICS_SEQUENCE_NUMBER_UTIL_H_ # include<stdint . h> # include<limits> # include<type_traits> # include \" absl / types / optional . h \" # include \" rtc_base / checks . h \" # include \" rtc_base / numerics / mod_ops . h \" namespace webrtc { template<T,T M>)",
    "insertText": "enable_if(M > 0), bool>::type AheadOrAt(T a, T b)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const T maxDist = M / 2 ;)",
    "insertText": "if(!(M & 1) && MinDiff<T, M>(a, b) == maxDist)"
  },
  {
    "label": "enable_if()",
    "kind": "Method",
    "detail": "Function (} template<T,T M>)",
    "insertText": "enable_if(M == 0), bool>::type AheadOrAt(T a, T b)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (const T maxDist = std::numeric_limits<T)",
    "insertText": "max() / 2 + T(1)"
  },
  {
    "label": "AheadOrAt()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "AheadOrAt(T a, T b)"
  },
  {
    "label": "AheadOf()",
    "kind": "Method",
    "detail": "Function (} template<T,T M = 0> bool)",
    "insertText": "AheadOf(T a, T b)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,T M = 0> struct AscendingSeqNumComp { bool)",
    "insertText": "operator()(T a, T b)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,T M = 0> class SeqNumUnwrapper {)",
    "insertText": "static_assert(std::is_unsigned<T>::value && std::numeric_limits<T>::max() < std::numeric_limits<int64_t>::max(), \"Type unwrapped must be an unsigned integer smaller than int64_t.\")"
  },
  {
    "label": "Unwrap()",
    "kind": "Method",
    "detail": "Function (public : int64_t)",
    "insertText": "Unwrap(T value)"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (last_unwrapped_ = { value } ; } else { last_unwrapped_ + = ForwardDiff<T,)",
    "insertText": "M(*last_value_, value)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (int64_t kBackwardAdjustment = M = = 0 ? int64_t { std::numeric_limits<T)",
    "insertText": "max()"
  },
  {
    "label": "UnwrapForward()",
    "kind": "Method",
    "detail": "Function (last_unwrapped_ - = kBackwardAdjustment ; } } last_value_ = value ; return last_unwrapped_ ; } int64_t)",
    "insertText": "UnwrapForward(T value)"
  },
  {
    "label": "UnwrapBackwards()",
    "kind": "Method",
    "detail": "Function (} last_value_ = value ; return last_unwrapped_ ; } int64_t)",
    "insertText": "UnwrapBackwards(T value)"
  }
]