[
  {
    "label": "ST_DLL_LINK",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ST_DLL_LINK"
  },
  {
    "label": "pack()",
    "kind": "Method",
    "detail": "Function (# pragma once # include<stddef . h> # include<assert . h> # include<stdio . h> # include<string . h> # define ST_SETS_PACKING_INTERNALLY # ifdef ST_SETS_PACKING_INTERNALLY # pragma)",
    "insertText": "pack(push, 4) #endif #ifndef ST_INLINE #define ST_INLINE inline #endif #ifndef ST_FORCE_INLINE #ifdef NDEBUG #ifdef __GNUC__ #define ST_FORCE_INLINE inline __attribute__ ((always_inline)) #else #define ST_FORCE_INLINE __forceinline #endif #else #define ST_FORCE_INLINE inline #endif #endif #define ST_UNREF_PARAM(x) (void)(x) #define ST_PREVENT_INSTNATIATION(a) private: a()"
  },
  {
    "label": "ST_PREVENT_COPY()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "ST_PREVENT_COPY(a) private: a(const a&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (a&)",
    "insertText": "operator(const a&)"
  },
  {
    "label": "ST_ASSERT_ON_COMPILE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "ST_ASSERT_ON_COMPILE(expr) extern char AssertOnCompile[(expr)"
  },
  {
    "label": "st_float16()",
    "kind": "Method",
    "detail": "Function (typedef bool st_bool ; typedef char st_int8 ; typedef char st_char ; typedef wchar_t st_wchar ; typedef short st_int16 ; typedef int st_int32 ; typedef long long st_int64 ; typedef unsigned char st_uint8 ; typedef unsigned char st_byte ; typedef unsigned char st_uchar ; typedef unsigned short st_uint16 ; typedef unsigned int st_uint32 ; typedef float st_float32 ; typedef double st_float64 ; class ST_DLL_LINK st_float16 { public :)",
    "insertText": "st_float16()"
  },
  {
    "label": "st_float16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "st_float16(st_float32 fSinglePrecision)"
  },
  {
    "label": "st_float16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "st_float16(const st_float16& hfCopy)"
  },
  {
    "label": "st_float32()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "st_float32(void)"
  },
  {
    "label": "ST_ASSERT_ON_COMPILE()",
    "kind": "Method",
    "detail": "Function (private : st_uint16 m_uiValue ; } ;)",
    "insertText": "ST_ASSERT_ON_COMPILE(sizeof(st_int8) == 1)"
  },
  {
    "label": "ST_ASSERT_ON_COMPILE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ST_ASSERT_ON_COMPILE(sizeof(st_int16) == 2)"
  },
  {
    "label": "ST_ASSERT_ON_COMPILE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ST_ASSERT_ON_COMPILE(sizeof(st_int32) == 4)"
  },
  {
    "label": "ST_ASSERT_ON_COMPILE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ST_ASSERT_ON_COMPILE(sizeof(st_int64) == 8)"
  },
  {
    "label": "ST_ASSERT_ON_COMPILE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ST_ASSERT_ON_COMPILE(sizeof(st_uint8) == 1)"
  },
  {
    "label": "ST_ASSERT_ON_COMPILE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ST_ASSERT_ON_COMPILE(sizeof(st_uint16) == 2)"
  },
  {
    "label": "ST_ASSERT_ON_COMPILE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ST_ASSERT_ON_COMPILE(sizeof(st_uint32) == 4)"
  },
  {
    "label": "ST_ASSERT_ON_COMPILE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ST_ASSERT_ON_COMPILE(sizeof(st_float16) == 2)"
  },
  {
    "label": "ST_ASSERT_ON_COMPILE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ST_ASSERT_ON_COMPILE(sizeof(st_float32) == 4)"
  },
  {
    "label": "ST_ASSERT_ON_COMPILE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ST_ASSERT_ON_COMPILE(sizeof(st_float64) == 8)"
  },
  {
    "label": "st_assert()",
    "kind": "Method",
    "detail": "Function (# ifndef NDEBUG # define)",
    "insertText": "st_assert(condition, explanation) assert((condition) && (explanation)) #else #define st_assert(condition, explanation) #endif #if defined(_XBOX)"
  }
]