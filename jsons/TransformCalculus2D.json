[
  {
    "label": "TMatrix2x2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMatrix2x2"
  },
  {
    "label": "TScale2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TScale2"
  },
  {
    "label": "ConcatenateRules",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConcatenateRules"
  },
  {
    "label": "TShear2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TShear2"
  },
  {
    "label": "TQuat2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TQuat2"
  },
  {
    "label": "TTransform2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TTransform2"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "TIsTransform2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsTransform2"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / AssertionMacros . h \" # include \" Math / UnrealMathUtility . h \" # include \" Math / Vector2D . h \" # include \" Math / TransformCalculus . h \" # include<type_traits> template<T> class TMatrix2x2 ; namespace UE { namespace Math { template<T> UE::Math::TVector2<T>)",
    "insertText": "Concatenate(const UE::Math::TVector2<T>& LHS, const UE::Math::TVector2<T>& RHS)"
  },
  {
    "label": "TScale2()",
    "kind": "Method",
    "detail": "Function (public : using FReal = T ; using Vector2Type = UE::Math::TVector2<T> ;)",
    "insertText": "TScale2() : Scale(1.0f, 1.0f)"
  },
  {
    "label": "TScale2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TScale2(T InScale) :Scale(InScale, InScale)"
  },
  {
    "label": "TScale2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TScale2(T InScaleX, T InScaleY) :Scale(InScaleX, InScaleY)"
  },
  {
    "label": "TScale2()",
    "kind": "Method",
    "detail": "Function (} template<ArgType>)",
    "insertText": "TScale2(const UE::Math::TVector2<ArgType>& InScale) :Scale(InScale)"
  },
  {
    "label": "TransformPoint()",
    "kind": "Method",
    "detail": "Function (} template<ArgType> UE::Math::TVector2<ArgType>)",
    "insertText": "TransformPoint(const UE::Math::TVector2<ArgType>& Point)"
  },
  {
    "label": "TransformVector()",
    "kind": "Method",
    "detail": "Function (} template<ArgType> UE::Math::TVector2<ArgType>)",
    "insertText": "TransformVector(const UE::Math::TVector2<ArgType>& Vector)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} TScale2)",
    "insertText": "Concatenate(const TScale2& RHS)"
  },
  {
    "label": "Inverse()",
    "kind": "Method",
    "detail": "Function (} TScale2)",
    "insertText": "Inverse()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TScale2& Other)"
  },
  {
    "label": "GetVector()",
    "kind": "Method",
    "detail": "Function (} const Vector2Type&)",
    "insertText": "GetVector()"
  },
  {
    "label": "TShear2()",
    "kind": "Method",
    "detail": "Function (public : using FReal = T ; using Vector2Type = UE::Math::TVector2<T> ;)",
    "insertText": "TShear2() :Shear(0, 0)"
  },
  {
    "label": "TShear2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TShear2(T ShearX, T ShearY) :Shear(ShearX, ShearY)"
  },
  {
    "label": "TShear2()",
    "kind": "Method",
    "detail": "Function (} template<VType>)",
    "insertText": "TShear2(const UE::Math::TVector2<VType>& InShear) :Shear((Vector2Type)InShear)"
  },
  {
    "label": "FromShearAngles()",
    "kind": "Method",
    "detail": "Function (} template<VType> TShear2)",
    "insertText": "FromShearAngles(const UE::Math::TVector2<VType>& InShearAngles)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (T ShearX = InShearAngles .)",
    "insertText": "X(1.0f / FMath::Tan(FMath::DegreesToRadians(90 - FMath::Clamp<T>((T)InShearAngles.X, -89.0f, 89.0f))))"
  },
  {
    "label": "Y()",
    "kind": "Method",
    "detail": "Function (T ShearY = InShearAngles .)",
    "insertText": "Y(1.0f / FMath::Tan(FMath::DegreesToRadians(90 - FMath::Clamp<T>((T)InShearAngles.Y, -89.0f, 89.0f))))"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} TMatrix2x2<T>)",
    "insertText": "Concatenate(const TShear2& RHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const TShear2& Other)"
  },
  {
    "label": "TQuat2()",
    "kind": "Method",
    "detail": "Function (public : using FReal = T ; using Vector2Type = UE::Math::TVector2<T> ;)",
    "insertText": "TQuat2() :Rot(1.0f, 0.0f)"
  },
  {
    "label": "TQuat2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TQuat2(T RotRadians) :Rot(FMath::Cos(RotRadians), FMath::Sin(RotRadians))"
  },
  {
    "label": "TQuat2()",
    "kind": "Method",
    "detail": "Function (} template<VType>)",
    "insertText": "TQuat2(const UE::Math::TVector2<VType>& InRot) :Rot((Vector2Type)InRot)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} TQuat2)",
    "insertText": "Concatenate(const TQuat2& RHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TQuat2& Other)"
  },
  {
    "label": "TMatrix2x2()",
    "kind": "Method",
    "detail": "Function (public : using FReal = T ; using Vector2Type = UE::Math::TVector2<T> ;)",
    "insertText": "TMatrix2x2()"
  },
  {
    "label": "TMatrix2x2()",
    "kind": "Method",
    "detail": "Function (M [ 0 ] [ 0 ] = 1 ; M [ 0 ] [ 1 ] = 0 ; M [ 1 ] [ 0 ] = 0 ; M [ 1 ] [ 1 ] = 1 ; })",
    "insertText": "TMatrix2x2(T m00, T m01, T m10, T m11)"
  },
  {
    "label": "DiagnosticCheckNaN()",
    "kind": "Method",
    "detail": "Function (M [ 0 ] [ 0 ] = m00 ; M [ 0 ] [ 1 ] = m01 ; M [ 1 ] [ 0 ] = m10 ; M [ 1 ] [ 1 ] = m11 ;)",
    "insertText": "DiagnosticCheckNaN()"
  },
  {
    "label": "TMatrix2x2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TMatrix2x2(T UniformScale)"
  },
  {
    "label": "TMatrix2x2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TMatrix2x2(const TScale2<T>& Scale)"
  },
  {
    "label": "ScaleX()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "ScaleX(T)Scale.GetVector()"
  },
  {
    "label": "ScaleY()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "ScaleY(T)Scale.GetVector()"
  },
  {
    "label": "TMatrix2x2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TMatrix2x2(const TShear2<T>& Shear)"
  },
  {
    "label": "XX()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "XX(T)Shear.GetVector()"
  },
  {
    "label": "YY()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "YY(T)Shear.GetVector()"
  },
  {
    "label": "TMatrix2x2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TMatrix2x2(const TQuat2<T>& Rotation)"
  },
  {
    "label": "CosAngle()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "CosAngle(T)Rotation.GetVector()"
  },
  {
    "label": "SinAngle()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "SinAngle(T)Rotation.GetVector()"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} TMatrix2x2)",
    "insertText": "Concatenate(const TMatrix2x2& RHS)"
  },
  {
    "label": "GetMatrix()",
    "kind": "Method",
    "detail": "Function (T A,B,C,D ;)",
    "insertText": "GetMatrix(A, B, C, D)"
  },
  {
    "label": "GetMatrix()",
    "kind": "Method",
    "detail": "Function (T E,F,G,H ; RHS .)",
    "insertText": "GetMatrix(E, F, G, H)"
  },
  {
    "label": "TMatrix2x2()",
    "kind": "Method",
    "detail": "Function (TMatrix2x2 Result =)",
    "insertText": "TMatrix2x2(A*E + B*G, A*F + B*H, C*E + D*G, C*F + D*H)"
  },
  {
    "label": "InverseDeterminant()",
    "kind": "Method",
    "detail": "Function (T InvDet =)",
    "insertText": "InverseDeterminant()"
  },
  {
    "label": "TMatrix2x2()",
    "kind": "Method",
    "detail": "Function (TMatrix2x2 Result =)",
    "insertText": "TMatrix2x2(D*InvDet, -B*InvDet, -C*InvDet, A*InvDet)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TMatrix2x2& Other)"
  },
  {
    "label": "GetMatrix()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetMatrix(float& A, float& B, float& C, float& D)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "A(float)"
  },
  {
    "label": "B()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "B(float)"
  },
  {
    "label": "C()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "C(float)"
  },
  {
    "label": "D()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "D(float)"
  },
  {
    "label": "GetMatrix()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetMatrix(double& A, double& B, double& C, double& D)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "A(double)"
  },
  {
    "label": "B()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "B(double)"
  },
  {
    "label": "C()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "C(double)"
  },
  {
    "label": "D()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "D(double)"
  },
  {
    "label": "Determinant()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "Determinant()"
  },
  {
    "label": "GetScale()",
    "kind": "Method",
    "detail": "Function (} TScale2<T>)",
    "insertText": "GetScale()"
  },
  {
    "label": "GetScaleSquared()",
    "kind": "Method",
    "detail": "Function (TScale2<T> ScaleSquared =)",
    "insertText": "GetScaleSquared()"
  },
  {
    "label": "GetRotationAngle()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetRotationAngle()"
  },
  {
    "label": "IsIdentity()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsIdentity()"
  },
  {
    "label": "ContainsNaN()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ContainsNaN()"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"Matrix2x2 contains NaN\"))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (* const_cast<TMatrix2x2<)",
    "insertText": "T(static_cast<const TMatrix2x2<T>*>(this)) = TMatrix2x2<T>(ForceInitToZero)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} # endif private : T M [ 2 ] [ 2 ] ; } ; typedef TMatrix2x2<float> FMatrix2x2f ; typedef TMatrix2x2<double> FMatrix2x2d ; typedef FMatrix2x2f FMatrix2x2 ; template<T> TMatrix2x2<T> TShear2<T)",
    "insertText": "Concatenate(const TShear2<T>& RHS)"
  },
  {
    "label": "XXA()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "XXA(T)"
  },
  {
    "label": "YYA()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "YYA(T)"
  },
  {
    "label": "XXB()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "XXB(T)"
  },
  {
    "label": "YYB()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "YYB(T)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T InvDet = 1 . 0 f /)",
    "insertText": "T(1.0f - Shear.X*Shear.Y)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} template<T> struct ConcatenateRules<float,TMatrix2x2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<double,TMatrix2x2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TScale2<T>,TMatrix2x2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TShear2<T>,TMatrix2x2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TQuat2<T>,TMatrix2x2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TMatrix2x2<T>,float> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TMatrix2x2<T>,double> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TMatrix2x2<T>,TScale2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TMatrix2x2<T>,TShear2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TMatrix2x2<T>,TQuat2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TScale2<T>,TShear2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TScale2<T>,TQuat2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TShear2<T>,TScale2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TQuat2<T>,TScale2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TShear2<T>,TQuat2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> struct ConcatenateRules<TQuat2<T>,TShear2<T>> { typedef TMatrix2x2<T> ResultType ; } ; template<T> class TTransform2 {)",
    "insertText": "static_assert(std::is_floating_point_v<T>, \"T must be floating point\")"
  },
  {
    "label": "TTransform2()",
    "kind": "Method",
    "detail": "Function (public : using FReal = T ; using Vector2Type = UE::Math::TVector2<T> ; using Matrix2Type = TMatrix2x2<T> ; template<VType = float>)",
    "insertText": "TTransform2(const UE::Math::TVector2<VType>& Translation = UE::Math::TVector2<VType>(0.f, 0.f)) : Trans((Vector2Type)Translation)"
  },
  {
    "label": "TTransform2()",
    "kind": "Method",
    "detail": "Function (} template<VType = float>)",
    "insertText": "TTransform2(T UniformScale, const UE::Math::TVector2<VType>& Translation = UE::Math::TVector2<VType>(0.f, 0.f)) : M(TScale2<T>(UniformScale)), Trans((Vector2Type)Translation)"
  },
  {
    "label": "TTransform2()",
    "kind": "Method",
    "detail": "Function (} template<VType = float>)",
    "insertText": "TTransform2(const TScale2<T>& Scale, const UE::Math::TVector2<VType>& Translation = UE::Math::TVector2<VType>(0.f, 0.f)) : M(Scale), Trans((Vector2Type)Translation)"
  },
  {
    "label": "TTransform2()",
    "kind": "Method",
    "detail": "Function (} template<VType = float>)",
    "insertText": "TTransform2(const TShear2<T>& Shear, const UE::Math::TVector2<VType>& Translation = UE::Math::TVector2<VType>(0.f, 0.f)) : M(Shear), Trans((Vector2Type)Translation)"
  },
  {
    "label": "TTransform2()",
    "kind": "Method",
    "detail": "Function (} template<VType = float>)",
    "insertText": "TTransform2(const TQuat2<T>& Rot, const UE::Math::TVector2<VType>& Translation = UE::Math::TVector2<VType>(0.f, 0.f)) : M(Rot), Trans((Vector2Type)Translation)"
  },
  {
    "label": "TTransform2()",
    "kind": "Method",
    "detail": "Function (} template<VType = float>)",
    "insertText": "TTransform2(const TMatrix2x2<T>& Transform, const UE::Math::TVector2<VType>& Translation = UE::Math::TVector2<VType>(0.f, 0.f)) : M(Transform), Trans((Vector2Type)Translation)"
  },
  {
    "label": "TransformPoint()",
    "kind": "Method",
    "detail": "Function (} template<VType> UE::Math::TVector2<VType>)",
    "insertText": "TransformPoint(const UE::Math::TVector2<VType>& Point)"
  },
  {
    "label": "TransformVector()",
    "kind": "Method",
    "detail": "Function (} template<VType> UE::Math::TVector2<VType>)",
    "insertText": "TransformVector(const UE::Math::TVector2<VType>& Vector)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} TTransform2)",
    "insertText": "Concatenate(const TTransform2& RHS)"
  },
  {
    "label": "Inverse()",
    "kind": "Method",
    "detail": "Function (Matrix2Type InvM)",
    "insertText": "Inverse(M)"
  },
  {
    "label": "TransformPoint()",
    "kind": "Method",
    "detail": "Function (Vector2Type InvTrans)",
    "insertText": "TransformPoint(InvM, ::Inverse(Trans))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TTransform2& Other)"
  },
  {
    "label": "GetMatrix()",
    "kind": "Method",
    "detail": "Function (} const Matrix2Type&)",
    "insertText": "GetMatrix()"
  },
  {
    "label": "SetTranslation()",
    "kind": "Method",
    "detail": "Function (} template<VType> void)",
    "insertText": "SetTranslation(const UE::Math::TVector2<VType>& InTrans)"
  },
  {
    "label": "Trans()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Trans(Vector2Type)"
  },
  {
    "label": "To3DMatrix()",
    "kind": "Method",
    "detail": "Function (} UE::Math::TMatrix<T>)",
    "insertText": "To3DMatrix()"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} private : Matrix2Type M ; Vector2Type Trans ; } ; typedef TTransform2<float> FTransform2f ; typedef TTransform2<double> FTransform2d ; typedef FTransform2f FTransform2D ; template<> struct TIsPODType<FTransform2f> { enum { Value = true } ; } ; template<> struct TIsPODType<FTransform2d> { enum { Value = true } ; } ; template<T,V> TTransform2<T>)",
    "insertText": "Concatenate(const TScale2<T>& Scale, const UE::Math::TVector2<V>& Translation)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} template<T,V> TTransform2<T>)",
    "insertText": "Concatenate(const TShear2<T>& Shear, const UE::Math::TVector2<V>& Translation)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} template<T,V> TTransform2<T>)",
    "insertText": "Concatenate(const TQuat2<T>& Rot, const UE::Math::TVector2<V>& Translation)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} template<T,V> TTransform2<T>)",
    "insertText": "Concatenate(const TMatrix2x2<T>& Transform, const UE::Math::TVector2<V>& Translation)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} template<T,V> TTransform2<T>)",
    "insertText": "Concatenate(const TTransform2<T>& Transform, const UE::Math::TVector2<V>& Translation)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} template<T,V> TTransform2<T>)",
    "insertText": "Concatenate(const UE::Math::TVector2<V>& Translation, const TScale2<T>& Scale)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} template<T,V> TTransform2<T>)",
    "insertText": "Concatenate(const UE::Math::TVector2<V>& Translation, const TShear2<T>& Shear)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} template<T,V> TTransform2<T>)",
    "insertText": "Concatenate(const UE::Math::TVector2<V>& Translation, const TQuat2<T>& Rot)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} template<T,V> TTransform2<T>)",
    "insertText": "Concatenate(const UE::Math::TVector2<V>& Translation, const TMatrix2x2<T>& Transform)"
  },
  {
    "label": "Concatenate()",
    "kind": "Method",
    "detail": "Function (} template<T,V> TTransform2<T>)",
    "insertText": "Concatenate(const UE::Math::TVector2<V>& Translation, const TTransform2<T>& Transform)"
  }
]