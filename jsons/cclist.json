[
  {
    "label": "exec_node",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "exec_node"
  },
  {
    "label": "exec_list",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "exec_list"
  },
  {
    "label": "iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "iterator"
  },
  {
    "label": "exec_list_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "exec_list_iterator"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (# pragma once # ifndef LIST_CONTAINER_H # define LIST_CONTAINER_H # include \" ralloc . h \" struct exec_node { struct exec_node* next ; struct exec_node* prev ; # ifdef __cplusplus void* operator)",
    "insertText": "new(size_t size, void *ctx)"
  },
  {
    "label": "ralloc_size()",
    "kind": "Method",
    "detail": "Function (void* node ; node =)",
    "insertText": "ralloc_size(ctx, size)"
  },
  {
    "label": "ralloc_free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ralloc_free(node)"
  },
  {
    "label": "exec_node()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "exec_node() : next(nullptr), prev(nullptr)"
  },
  {
    "label": "get_next()",
    "kind": "Method",
    "detail": "Function (} const exec_node*)",
    "insertText": "get_next()"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (next -> prev = prev ;)",
    "insertText": "check(prev)"
  },
  {
    "label": "self_link()",
    "kind": "Method",
    "detail": "Function (prev -> next = next ; next = nullptr ; prev = nullptr ; } void)",
    "insertText": "self_link()"
  },
  {
    "label": "insert_after()",
    "kind": "Method",
    "detail": "Function (next = this ; prev = this ; } void)",
    "insertText": "insert_after(exec_node *after)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (after -> next = this -> next ; after -> prev = this ;)",
    "insertText": "check(this->next)"
  },
  {
    "label": "insert_before()",
    "kind": "Method",
    "detail": "Function (this -> next -> prev = after ; this -> next = after ; } void)",
    "insertText": "insert_before(exec_node *before)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (before -> next = this ; before -> prev = this -> prev ;)",
    "insertText": "check(this->prev)"
  },
  {
    "label": "insert_before()",
    "kind": "Method",
    "detail": "Function (this -> prev -> next = before ; this -> prev = before ; } void)",
    "insertText": "insert_before(struct exec_list *before)"
  },
  {
    "label": "replace_with()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replace_with(exec_node *replacement)"
  },
  {
    "label": "is_tail_sentinel()",
    "kind": "Method",
    "detail": "Function (this -> next -> prev = replacement ; } bool)",
    "insertText": "is_tail_sentinel()"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (class iterator { public : void)",
    "insertText": "next()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "get()"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (node = _next ; _next = node -> next ; } void)",
    "insertText": "remove()"
  },
  {
    "label": "exec_list()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "exec_list()"
  },
  {
    "label": "make_empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "make_empty()"
  },
  {
    "label": "head()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "head(exec_node *)"
  },
  {
    "label": "tail_pred()",
    "kind": "Method",
    "detail": "Function (tail = nullptr ;)",
    "insertText": "tail_pred(exec_node *)"
  },
  {
    "label": "is_empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_empty()"
  },
  {
    "label": "get_head()",
    "kind": "Method",
    "detail": "Function (} const exec_node*)",
    "insertText": "get_head()"
  },
  {
    "label": "get_tail()",
    "kind": "Method",
    "detail": "Function (} const exec_node*)",
    "insertText": "get_tail()"
  },
  {
    "label": "push_head()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_head(exec_node *n)"
  },
  {
    "label": "prev()",
    "kind": "Method",
    "detail": "Function (n -> next = head ; n ->)",
    "insertText": "prev(exec_node *)"
  },
  {
    "label": "push_tail()",
    "kind": "Method",
    "detail": "Function (n -> next -> prev = n ; head = n ; } void)",
    "insertText": "push_tail(exec_node *n)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (n ->)",
    "insertText": "next(exec_node *)"
  },
  {
    "label": "push_degenerate_list_at_head()",
    "kind": "Method",
    "detail": "Function (n -> prev = tail_pred ; n -> prev -> next = n ; tail_pred = n ; } void)",
    "insertText": "push_degenerate_list_at_head(exec_node *n)"
  },
  {
    "label": "pop_head()",
    "kind": "Method",
    "detail": "Function (head = n ; } exec_node*)",
    "insertText": "pop_head()"
  },
  {
    "label": "append_list()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "append_list(exec_list *source)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} exec_list_iterator)",
    "insertText": "iterator()"
  },
  {
    "label": "insert_before()",
    "kind": "Method",
    "detail": "Function (} # endif } ; # ifdef __cplusplus void)",
    "insertText": "insert_before(exec_list *before)"
  },
  {
    "label": "foreach_list_safe()",
    "kind": "Method",
    "detail": "Function (} # endif # define)",
    "insertText": "foreach_list_safe(__node, __list) \\ for (exec_node * __node = (__list)->head, * __next = __node->next \\ ; __next != nullptr \\ ; __node = __next, __next = __next->next) #define foreach_list(__node, __list) \\ for (exec_node * __node = (__list)->head \\ ; (__node)->next != nullptr \\ ; (__node) = (__node)->next) #define foreach_list_const(__node, __list) \\ for (const exec_node * __node = (__list)->head \\ ; (__node)->next != nullptr \\ ; (__node) = (__node)->next) #define foreach_list_typed(__type, __node, __field, __list) \\ for (__type * __node = \\ exec_node_data(__type, (__list)->head, __field); \\ (__node)->__field.next != nullptr; \\ (__node) = exec_node_data(__type, (__node)->__field.next, __field)) #define foreach_list_typed_const(__type, __node, __field, __list) \\ for (const __type * __node = \\ exec_node_data(__type, (__list)->head, __field); \\ (__node)->__field.next != nullptr; \\ (__node) = exec_node_data(__type, (__node)->__field.next, __field)) inline bool check_list_integrity(exec_list* list)"
  },
  {
    "label": "node()",
    "kind": "Method",
    "detail": "Function (exec_node*)",
    "insertText": "node(exec_node *)iter.get()"
  }
]