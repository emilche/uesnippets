[
  {
    "label": "Symbol",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Symbol"
  },
  {
    "label": "NegateExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NegateExpr"
  },
  {
    "label": "AddExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AddExpr"
  },
  {
    "label": "ProductExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ProductExpr"
  },
  {
    "label": "QuotientExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "QuotientExpr"
  },
  {
    "label": "ValueExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueExpr"
  },
  {
    "label": "BaseExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BaseExpr"
  },
  {
    "label": "is_symbolic",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_symbolic"
  },
  {
    "label": "SymbolValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SymbolValue"
  },
  {
    "label": "SymbolExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SymbolExpr"
  },
  {
    "label": "ValueExpr()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_SYMBOLIC_INDEX_H # define EIGEN_SYMBOLIC_INDEX_H namespace Eigen { namespace symbolic { template<Tag> class Symbol ; template<Arg0> class NegateExpr ; template<Arg1,Arg2> class AddExpr ; template<Arg1,Arg2> class ProductExpr ; template<Arg1,Arg2> class QuotientExpr ; template<IndexType = Index> class ValueExpr { public :)",
    "insertText": "ValueExpr(IndexType val) : m_value(val)"
  },
  {
    "label": "eval_impl()",
    "kind": "Method",
    "detail": "Function (} template<T> IndexType)",
    "insertText": "eval_impl(const T&)"
  },
  {
    "label": "eval()",
    "kind": "Method",
    "detail": "Function (} template<T> Index)",
    "insertText": "eval(const T& values)"
  },
  {
    "label": "eval()",
    "kind": "Method",
    "detail": "Function (} # if EIGEN_HAS_CXX14 template<. . . Types> Index)",
    "insertText": "eval(Types&&... values)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif NegateExpr<Derived>)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} AddExpr<Derived,ValueExpr<>>)",
    "insertText": "operator(Index b)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} AddExpr<Derived,ValueExpr<>>)",
    "insertText": "operator(Index a)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} AddExpr<Derived,ValueExpr<>>)",
    "insertText": "operator(Index a, const BaseExpr& b)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<int N> AddExpr<Derived,ValueExpr<internal::FixedInt<N>>>)",
    "insertText": "operator(internal::FixedInt<N>)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<int N> AddExpr<Derived,ValueExpr<internal::FixedInt<N>>>)",
    "insertText": "operator(internal::FixedInt<N>, const BaseExpr& b)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} #)",
    "insertText": "if(!EIGEN_HAS_CXX14) template<int N> AddExpr<Derived,ValueExpr<internal::FixedInt<N> > > operator+(internal::FixedInt<N> (*)())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<int N> AddExpr<Derived,ValueExpr<internal::FixedInt<- N>>>)",
    "insertText": "operator(internal::FixedInt<N> (*)())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<int N> AddExpr<Derived,ValueExpr<internal::FixedInt<N>>>)",
    "insertText": "operator(internal::FixedInt<N> (*)(), const BaseExpr& b)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif template<OtherDerived> AddExpr<Derived,OtherDerived>)",
    "insertText": "operator(const BaseExpr<OtherDerived> &b)"
  },
  {
    "label": "SymbolValue()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct is_symbolic { enum { value = internal::is_convertible<T,BaseExpr<T>>::value } ; } ; template<Tag> class SymbolValue { public :)",
    "insertText": "SymbolValue(Index val) : m_value(val)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "value()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} SymbolValue<Tag>)",
    "insertText": "operator(Index val)"
  },
  {
    "label": "eval_impl()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "eval_impl(const SymbolValue<Tag> &values)"
  },
  {
    "label": "eval_impl()",
    "kind": "Method",
    "detail": "Function (} # if EIGEN_HAS_CXX14 template<. . . Types> Index)",
    "insertText": "eval_impl(const std::tuple<Types...>& values)"
  },
  {
    "label": "NegateExpr()",
    "kind": "Method",
    "detail": "Function (} # endif } ; template<Arg0> class NegateExpr : public BaseExpr<NegateExpr<Arg0>> { public :)",
    "insertText": "NegateExpr(const Arg0& arg0) : m_arg0(arg0)"
  },
  {
    "label": "eval_impl()",
    "kind": "Method",
    "detail": "Function (} template<T> Index)",
    "insertText": "eval_impl(const T& values)"
  },
  {
    "label": "AddExpr()",
    "kind": "Method",
    "detail": "Function (} protected : Arg0 m_arg0 ; } ; template<Arg0,Arg1> class AddExpr : public BaseExpr<AddExpr<Arg0,Arg1>> { public :)",
    "insertText": "AddExpr(const Arg0& arg0, const Arg1& arg1) : m_arg0(arg0), m_arg1(arg1)"
  },
  {
    "label": "ProductExpr()",
    "kind": "Method",
    "detail": "Function (} protected : Arg0 m_arg0 ; Arg1 m_arg1 ; } ; template<Arg0,Arg1> class ProductExpr : public BaseExpr<ProductExpr<Arg0,Arg1>> { public :)",
    "insertText": "ProductExpr(const Arg0& arg0, const Arg1& arg1) : m_arg0(arg0), m_arg1(arg1)"
  },
  {
    "label": "QuotientExpr()",
    "kind": "Method",
    "detail": "Function (} protected : Arg0 m_arg0 ; Arg1 m_arg1 ; } ; template<Arg0,Arg1> class QuotientExpr : public BaseExpr<QuotientExpr<Arg0,Arg1>> { public :)",
    "insertText": "QuotientExpr(const Arg0& arg0, const Arg1& arg1) : m_arg0(arg0), m_arg1(arg1)"
  }
]