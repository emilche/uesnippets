[
  {
    "label": "FPBDWeightMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDWeightMap"
  },
  {
    "label": "DECLARE_CYCLE_STAT()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" # include \" Chaos / PBDSoftsEvolutionFwd . h \" # include \" Containers / ArrayView . h \" # include \" Containers / ContainersFwd . h \" # include \" ChaosStats . h \")",
    "insertText": "DECLARE_CYCLE_STAT(TEXT(\"Chaos PBD WeightMap Apply Values\"), STAT_PBD_WeightMapApplyValues, STATGROUP_Chaos)"
  },
  {
    "label": "FPBDWeightMap()",
    "kind": "Method",
    "detail": "Function (namespace Chaos::Softs { class FPBDWeightMap { public :)",
    "insertText": "FPBDWeightMap(const FSolverVec2& InWeightedValue, const TConstArrayView<FRealSingle>& Multipliers = TConstArrayView<FRealSingle>(), int32 ParticleCount = 0, int32 TableSize = 16)"
  },
  {
    "label": "FPBDWeightMap()",
    "kind": "Method",
    "detail": "Function (template<int32 Valence>)",
    "insertText": "FPBDWeightMap(const FSolverVec2& InWeightedValue, const TConstArrayView<FRealSingle>& Multipliers = TConstArrayView<FRealSingle>(), const TConstArrayView<TVector<int32, Valence>>& Constraints = TConstArrayView<TVector<int32, Valence>>(), int32 ParticleOffset = INDEX_NONE, int32 ParticleCount = 0, int32 TableSize = 16, typename TEnableIf<Valence >= 2 && Valence <= 4>::Type* = nullptr)"
  },
  {
    "label": "FPBDWeightMap()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FPBDWeightMap()"
  },
  {
    "label": "FPBDWeightMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPBDWeightMap(const FPBDWeightMap&)"
  },
  {
    "label": "FPBDWeightMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPBDWeightMap(FPBDWeightMap&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPBDWeightMap&)",
    "insertText": "operator(const FPBDWeightMap&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPBDWeightMap&)",
    "insertText": "operator(FPBDWeightMap&&)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Num()"
  },
  {
    "label": "HasWeightMap()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasWeightMap()"
  },
  {
    "label": "SetWeightedValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetWeightedValue(const FSolverVec2& InWeightedValue)"
  },
  {
    "label": "GetWeightedValue()",
    "kind": "Method",
    "detail": "Function (bIsDirty | = WeightedValue ! = InWeightedValue ; WeightedValue = InWeightedValue ; } const FSolverVec2&)",
    "insertText": "GetWeightedValue()"
  },
  {
    "label": "ApplyValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyValues([](FSolverReal Value)->FSolverReal { return Value; }, bOutUpdated)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "FSolverReal()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "FSolverReal()"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "GetValue(int32 Index)"
  },
  {
    "label": "GetLow()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "GetLow()"
  },
  {
    "label": "GetIndices()",
    "kind": "Method",
    "detail": "Function (} TConstArrayView<uint8>)",
    "insertText": "GetIndices()"
  },
  {
    "label": "GetTable()",
    "kind": "Method",
    "detail": "Function (} TConstArrayView<FSolverReal>)",
    "insertText": "GetTable()"
  },
  {
    "label": "ReorderIndices()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ReorderIndices(const TArray<int32>& OrigToReorderedIndices)"
  },
  {
    "label": "ApplyValues()",
    "kind": "Method",
    "detail": "Function (protected : template<FunctorType> void)",
    "insertText": "ApplyValues(FunctorType&& MappingFunction, bool* bOutUpdated = nullptr)"
  },
  {
    "label": "FPBDWeightMap()",
    "kind": "Method",
    "detail": "Function (TArray<uint8> Indices ; TArray<FSolverReal> Table ; FSolverVec2 WeightedValue ; bool bIsDirty = true ; } ;)",
    "insertText": "FPBDWeightMap(const FSolverVec2& InWeightedValue, const TConstArrayView<FRealSingle>& Multipliers, int32 ParticleCount, int32 TableSize) : WeightedValue(InWeightedValue)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (Indices .)",
    "insertText": "AddUninitialized(ParticleCount)"
  },
  {
    "label": "TableScale()",
    "kind": "Method",
    "detail": "Function (const FRealSingle)",
    "insertText": "TableScale(FRealSingle)(TableSize - 1)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (Indices [)",
    "insertText": "Index(uint8)(FMath::Clamp(Multipliers[Index], (FRealSingle)0., (FRealSingle)1.) * TableScale)"
  },
  {
    "label": "AddZeroed()",
    "kind": "Method",
    "detail": "Function (} Table .)",
    "insertText": "AddZeroed(TableSize)"
  },
  {
    "label": "AddZeroed()",
    "kind": "Method",
    "detail": "Function (} else { Indices .)",
    "insertText": "AddZeroed(1)"
  },
  {
    "label": "FPBDWeightMap()",
    "kind": "Method",
    "detail": "Function (} } template<int32 Valence>)",
    "insertText": "FPBDWeightMap(const FSolverVec2& InWeightedValue, const TConstArrayView<FRealSingle>& Multipliers, const TConstArrayView<TVector<int32, Valence>>& Constraints, int32 ParticleOffset, int32 ParticleCount, int32 TableSize, typename TEnableIf<Valence >= 2 && Valence <= 4>::Type*) : WeightedValue(InWeightedValue)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (Indices .)",
    "insertText": "AddUninitialized(ConstraintCount)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const TVector<int32,Valence>& Constraint = Constraints [ ConstraintIndex ] ; FRealSingle Weight = 0 . f ;)",
    "insertText": "for(int32 Index = 0; Index < Valence; ++Index)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (Weight + =)",
    "insertText": "Clamp(Multipliers[Constraint[Index] - ParticleOffset], (FRealSingle)0., (FRealSingle)1.)"
  },
  {
    "label": "Weight()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Weight(FRealSingle)"
  },
  {
    "label": "ConstraintIndex()",
    "kind": "Method",
    "detail": "Function (Indices [)",
    "insertText": "ConstraintIndex(uint8)(Weight * TableScale)"
  },
  {
    "label": "ApplyValues()",
    "kind": "Method",
    "detail": "Function (} } template<FunctorType> void)",
    "insertText": "ApplyValues(FunctorType&& MappingFunction, bool* bOutUpdated)"
  },
  {
    "label": "SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SCOPE_CYCLE_COUNTER(STAT_PBD_WeightMapApplyValues)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* bOutUpdated = true ; })",
    "insertText": "if(bIsDirty)"
  },
  {
    "label": "WeightIncrement()",
    "kind": "Method",
    "detail": "Function (const FSolverReal)",
    "insertText": "WeightIncrement(TableSize > 1) ? (FSolverReal)1. / (FSolverReal)(TableSize - 1) : (FSolverReal)"
  },
  {
    "label": "Weight()",
    "kind": "Method",
    "detail": "Function (const FSolverReal)",
    "insertText": "Weight(FSolverReal)"
  },
  {
    "label": "MappingFunction()",
    "kind": "Method",
    "detail": "Function (Table [ Index ] =)",
    "insertText": "MappingFunction(Offset + Weight * Range)"
  },
  {
    "label": "ReorderIndices()",
    "kind": "Method",
    "detail": "Function (} bIsDirty = false ; } } void)",
    "insertText": "ReorderIndices(const TArray<int32>& OrigToReorderedConstraintIndices)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<uint8> ReorderedIndices ; ReorderedIndices .)",
    "insertText": "SetNumUninitialized(Indices.Num())"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (const int32 ReorderedConstraintIndex = OrigToReorderedConstraintIndices [ OrigConstraintIndex ] ; ReorderedIndices [ ReorderedConstraintIndex ] = Indices [ OrigConstraintIndex ] ; } Indices =)",
    "insertText": "MoveTemp(ReorderedIndices)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "check(Indices.Num() == 1)"
  }
]