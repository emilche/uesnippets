[
  {
    "label": "PrimvarRefinerReal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PrimvarRefinerReal"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "U",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U"
  },
  {
    "label": "U1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U1"
  },
  {
    "label": "U2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U2"
  },
  {
    "label": "Mask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mask"
  },
  {
    "label": "PrimvarRefiner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PrimvarRefiner"
  },
  {
    "label": "PrimvarRefinerReal()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENSUBDIV3_FAR_PRIMVAR_REFINER_H # define OPENSUBDIV3_FAR_PRIMVAR_REFINER_H # include \" . . / version . h \" # include \" . . / sdc / types . h \" # include \" . . / sdc / options . h \" # include \" . . / sdc / bilinearScheme . h \" # include \" . . / sdc / catmarkScheme . h \" # include \" . . / sdc / loopScheme . h \" # include \" . . / vtr / level . h \" # include \" . . / vtr / fvarLevel . h \" # include \" . . / vtr / refinement . h \" # include \" . . / vtr / fvarRefinement . h \" # include \" . . / vtr / stackBuffer . h \" # include \" . . / vtr / componentInterfaces . h \" # include \" . . / far / types . h \" # include \" . . / far / error . h \" # include \" . . / far / topologyLevel . h \" # include \" . . / far / topologyRefiner . h \" # include<cassert> namespace OpenSubdiv { namespace OPENSUBDIV_VERSION { namespace Far { template<REAL> class PrimvarRefinerReal { public :)",
    "insertText": "PrimvarRefinerReal(TopologyRefiner const & refiner) : _refiner(refiner)"
  },
  {
    "label": "PrimvarRefinerReal()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "PrimvarRefinerReal()"
  },
  {
    "label": "GetTopologyRefiner()",
    "kind": "Method",
    "detail": "Function (} TopologyRefiner const&)",
    "insertText": "GetTopologyRefiner()"
  },
  {
    "label": "InterpolateVarying()",
    "kind": "Method",
    "detail": "Function (template<class T,class U> void)",
    "insertText": "InterpolateVarying(int level, T const & src, U & dst)"
  },
  {
    "label": "InterpolateFaceUniform()",
    "kind": "Method",
    "detail": "Function (template<class T,class U> void)",
    "insertText": "InterpolateFaceUniform(int level, T const & src, U & dst)"
  },
  {
    "label": "InterpolateFaceVarying()",
    "kind": "Method",
    "detail": "Function (template<class T,class U> void)",
    "insertText": "InterpolateFaceVarying(int level, T const & src, U & dst, int channel = 0)"
  },
  {
    "label": "Limit()",
    "kind": "Method",
    "detail": "Function (template<class T,class U> void)",
    "insertText": "Limit(T const & src, U & dstPos)"
  },
  {
    "label": "Limit()",
    "kind": "Method",
    "detail": "Function (template<class T,class U,class U1,class U2> void)",
    "insertText": "Limit(T const & src, U & dstPos, U1 & dstTan1, U2 & dstTan2)"
  },
  {
    "label": "LimitFaceVarying()",
    "kind": "Method",
    "detail": "Function (template<class T,class U> void)",
    "insertText": "LimitFaceVarying(T const & src, U & dst, int channel = 0)"
  },
  {
    "label": "PrimvarRefinerReal()",
    "kind": "Method",
    "detail": "Function (private : typedef REAL Weight ;)",
    "insertText": "PrimvarRefinerReal(PrimvarRefinerReal const & src) : _refiner(src._refiner)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} PrimvarRefinerReal&)",
    "insertText": "operator(PrimvarRefinerReal const &)"
  },
  {
    "label": "interpFromEdges()",
    "kind": "Method",
    "detail": "Function (template<Sdc::SchemeType SCHEME,class T,class U> void)",
    "insertText": "interpFromEdges(int, T const &, U &)"
  },
  {
    "label": "interpFromVerts()",
    "kind": "Method",
    "detail": "Function (template<Sdc::SchemeType SCHEME,class T,class U> void)",
    "insertText": "interpFromVerts(int, T const &, U &)"
  },
  {
    "label": "interpFVarFromFaces()",
    "kind": "Method",
    "detail": "Function (template<Sdc::SchemeType SCHEME,class T,class U> void)",
    "insertText": "interpFVarFromFaces(int, T const &, U &, int)"
  },
  {
    "label": "interpFVarFromEdges()",
    "kind": "Method",
    "detail": "Function (template<Sdc::SchemeType SCHEME,class T,class U> void)",
    "insertText": "interpFVarFromEdges(int, T const &, U &, int)"
  },
  {
    "label": "interpFVarFromVerts()",
    "kind": "Method",
    "detail": "Function (template<Sdc::SchemeType SCHEME,class T,class U> void)",
    "insertText": "interpFVarFromVerts(int, T const &, U &, int)"
  },
  {
    "label": "limit()",
    "kind": "Method",
    "detail": "Function (template<Sdc::SchemeType SCHEME,class T,class U,class U1,class U2> void)",
    "insertText": "limit(T const & src, U & pos, U1 * tan1, U2 * tan2)"
  },
  {
    "label": "limitFVar()",
    "kind": "Method",
    "detail": "Function (template<Sdc::SchemeType SCHEME,class T,class U> void)",
    "insertText": "limitFVar(T const & src, U & dst, int channel)"
  },
  {
    "label": "Mask()",
    "kind": "Method",
    "detail": "Function (private : TopologyRefiner const& _refiner ; private : class Mask { public : typedef REAL Weight ; public :)",
    "insertText": "Mask(Weight* v, Weight* e, Weight* f) : _vertWeights(v), _edgeWeights(e), _faceWeights(f), _vertCount(0), _edgeCount(0), _faceCount(0), _faceWeightsForFaceCenters(false)"
  },
  {
    "label": "Mask()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "Mask()"
  },
  {
    "label": "GetNumVertexWeights()",
    "kind": "Method",
    "detail": "Function (} public : int)",
    "insertText": "GetNumVertexWeights()"
  },
  {
    "label": "SetNumEdgeWeights()",
    "kind": "Method",
    "detail": "Function (_vertCount = count ; } void)",
    "insertText": "SetNumEdgeWeights(int count)"
  },
  {
    "label": "SetNumFaceWeights()",
    "kind": "Method",
    "detail": "Function (_edgeCount = count ; } void)",
    "insertText": "SetNumFaceWeights(int count)"
  },
  {
    "label": "VertexWeight()",
    "kind": "Method",
    "detail": "Function (_faceCount = count ; } Weight const&)",
    "insertText": "VertexWeight(int index)"
  },
  {
    "label": "Interpolate()",
    "kind": "Method",
    "detail": "Function (_faceWeightsForFaceCenters = on ; } private : Weight* _vertWeights ; Weight* _edgeWeights ; Weight* _faceWeights ; int _vertCount ; int _edgeCount ; int _faceCount ; bool _faceWeightsForFaceCenters ; } ; } ; template<REAL> template<class T,class U> void PrimvarRefinerReal<REAL)",
    "insertText": "Interpolate(int level, T const & src, U & dst)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(level>0 && level<=(int)_refiner._refinements.size())"
  },
  {
    "label": "SCHEME_CATMARK()",
    "kind": "Method",
    "detail": "Function (interpFromEdges<)",
    "insertText": "SCHEME_CATMARK(level, src, dst)"
  },
  {
    "label": "SCHEME_LOOP()",
    "kind": "Method",
    "detail": "Function (break ; case Sdc::SCHEME_LOOP : interpFromFaces<)",
    "insertText": "SCHEME_LOOP(level, src, dst)"
  },
  {
    "label": "SCHEME_BILINEAR()",
    "kind": "Method",
    "detail": "Function (break ; case Sdc::SCHEME_BILINEAR : interpFromFaces<)",
    "insertText": "SCHEME_BILINEAR(level, src, dst)"
  },
  {
    "label": "InterpolateFaceVarying()",
    "kind": "Method",
    "detail": "Function (break ; } } template<REAL> template<class T,class U> void PrimvarRefinerReal<REAL)",
    "insertText": "InterpolateFaceVarying(int level, T const & src, U & dst, int channel)"
  },
  {
    "label": "SCHEME_CATMARK()",
    "kind": "Method",
    "detail": "Function (interpFVarFromEdges<)",
    "insertText": "SCHEME_CATMARK(level, src, dst, channel)"
  },
  {
    "label": "SCHEME_LOOP()",
    "kind": "Method",
    "detail": "Function (break ; case Sdc::SCHEME_LOOP : interpFVarFromFaces<)",
    "insertText": "SCHEME_LOOP(level, src, dst, channel)"
  },
  {
    "label": "SCHEME_BILINEAR()",
    "kind": "Method",
    "detail": "Function (break ; case Sdc::SCHEME_BILINEAR : interpFVarFromFaces<)",
    "insertText": "SCHEME_BILINEAR(level, src, dst, channel)"
  },
  {
    "label": "Limit()",
    "kind": "Method",
    "detail": "Function (break ; } } template<REAL> template<class T,class U> void PrimvarRefinerReal<REAL)",
    "insertText": "Limit(T const & src, U & dst)"
  },
  {
    "label": "Error()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Error(FAR_RUNTIME_ERROR, \"Failure in PrimvarRefiner::Limit() -- \" \"last level of refinement does not include full topology.\")"
  },
  {
    "label": "SCHEME_LOOP()",
    "kind": "Method",
    "detail": "Function (break ; case Sdc::SCHEME_LOOP : limit<)",
    "insertText": "SCHEME_LOOP(src, dst, (U*)0, (U*)0)"
  },
  {
    "label": "SCHEME_BILINEAR()",
    "kind": "Method",
    "detail": "Function (break ; case Sdc::SCHEME_BILINEAR : limit<)",
    "insertText": "SCHEME_BILINEAR(src, dst, (U*)0, (U*)0)"
  },
  {
    "label": "SCHEME_LOOP()",
    "kind": "Method",
    "detail": "Function (break ; case Sdc::SCHEME_LOOP : limit<)",
    "insertText": "SCHEME_LOOP(src, dstPos, &dstTan1, &dstTan2)"
  },
  {
    "label": "SCHEME_BILINEAR()",
    "kind": "Method",
    "detail": "Function (break ; case Sdc::SCHEME_BILINEAR : limit<)",
    "insertText": "SCHEME_BILINEAR(src, dstPos, &dstTan1, &dstTan2)"
  },
  {
    "label": "LimitFaceVarying()",
    "kind": "Method",
    "detail": "Function (break ; } } template<REAL> template<class T,class U> void PrimvarRefinerReal<REAL)",
    "insertText": "LimitFaceVarying(T const & src, U & dst, int channel)"
  },
  {
    "label": "Error()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Error(FAR_RUNTIME_ERROR, \"Failure in PrimvarRefiner::LimitFaceVarying() -- \" \"last level of refinement does not include full topology.\")"
  },
  {
    "label": "SCHEME_LOOP()",
    "kind": "Method",
    "detail": "Function (break ; case Sdc::SCHEME_LOOP : limitFVar<)",
    "insertText": "SCHEME_LOOP(src, dst, channel)"
  },
  {
    "label": "SCHEME_BILINEAR()",
    "kind": "Method",
    "detail": "Function (break ; case Sdc::SCHEME_BILINEAR : limitFVar<)",
    "insertText": "SCHEME_BILINEAR(src, dst, channel)"
  },
  {
    "label": "getRefinement()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::Refinement const& refinement = _refiner .)",
    "insertText": "getRefinement(level-1)"
  },
  {
    "label": "child()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::Level const& child = refinement .)",
    "insertText": "child()"
  },
  {
    "label": "getChildFaceParentFace()",
    "kind": "Method",
    "detail": "Function (Vtr::Index pFace = refinement .)",
    "insertText": "getChildFaceParentFace(cFace)"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::Level const& parent = refinement .)",
    "insertText": "parent()"
  },
  {
    "label": "getFaceChildVertex()",
    "kind": "Method",
    "detail": "Function (Vtr::Index cVert = refinement .)",
    "insertText": "getFaceChildVertex(face)"
  },
  {
    "label": "getFaceVertices()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray fVerts = parent .)",
    "insertText": "getFaceVertices(face)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (Weight fVaryingWeight = 1 . 0)",
    "insertText": "f(Weight) fVerts.size()"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (dst [ cVert ] .)",
    "insertText": "Clear()"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVert ] .)",
    "insertText": "AddWithWeight(src[fVerts[i]], fVaryingWeight)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } } })",
    "insertText": "for(int edge = 0; edge < parent.getNumEdges(); ++edge)"
  },
  {
    "label": "getEdgeChildVertex()",
    "kind": "Method",
    "detail": "Function (Vtr::Index cVert = refinement .)",
    "insertText": "getEdgeChildVertex(edge)"
  },
  {
    "label": "getEdgeVertices()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray eVerts = parent .)",
    "insertText": "getEdgeVertices(edge)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVert ] .)",
    "insertText": "AddWithWeight(src[eVerts[0]], 0.5f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVert ] .)",
    "insertText": "AddWithWeight(src[eVerts[1]], 0.5f)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(int vert = 0; vert < parent.getNumVertices(); ++vert)"
  },
  {
    "label": "getVertexChildVertex()",
    "kind": "Method",
    "detail": "Function (Vtr::Index cVert = refinement .)",
    "insertText": "getVertexChildVertex(vert)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVert ] .)",
    "insertText": "AddWithWeight(src[vert], 1.0f)"
  },
  {
    "label": "interpFromFaces()",
    "kind": "Method",
    "detail": "Function (} } } template<REAL> template<Sdc::SchemeType SCHEME,class T,class U> void PrimvarRefinerReal<REAL)",
    "insertText": "interpFromFaces(int level, T const & src, U & dst)"
  },
  {
    "label": "scheme()",
    "kind": "Method",
    "detail": "Function (Sdc::Scheme<SCHEME>)",
    "insertText": "scheme(_refiner._subdivOptions)"
  },
  {
    "label": "fVertWeights()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::StackBuffer<Weight,1 6>)",
    "insertText": "fVertWeights(parent.getMaxValence())"
  },
  {
    "label": "fMask()",
    "kind": "Method",
    "detail": "Function (Mask)",
    "insertText": "fMask(fVertWeights, 0, 0)"
  },
  {
    "label": "fHood()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::FaceInterface)",
    "insertText": "fHood(fVerts.size())"
  },
  {
    "label": "ComputeFaceVertexMask()",
    "kind": "Method",
    "detail": "Function (scheme .)",
    "insertText": "ComputeFaceVertexMask(fHood, fMask)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVert ] .)",
    "insertText": "AddWithWeight(src[fVerts[i]], fVertWeights[i])"
  },
  {
    "label": "interpFromEdges()",
    "kind": "Method",
    "detail": "Function (} } } template<REAL> template<Sdc::SchemeType SCHEME,class T,class U> void PrimvarRefinerReal<REAL)",
    "insertText": "interpFromEdges(int level, T const & src, U & dst)"
  },
  {
    "label": "eHood()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::EdgeInterface)",
    "insertText": "eHood(parent)"
  },
  {
    "label": "eFaceWeights()",
    "kind": "Method",
    "detail": "Function (Weight eVertWeights [ 2 ] ; Vtr::internal::StackBuffer<Weight,8>)",
    "insertText": "eFaceWeights(parent.getMaxEdgeFaces())"
  },
  {
    "label": "getEdgeVertices()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray eVerts = parent .)",
    "insertText": "getEdgeVertices(edge), eFaces = parent.getEdgeFaces(edge)"
  },
  {
    "label": "eMask()",
    "kind": "Method",
    "detail": "Function (Mask)",
    "insertText": "eMask(eVertWeights, 0, eFaceWeights)"
  },
  {
    "label": "SetIndex()",
    "kind": "Method",
    "detail": "Function (eHood .)",
    "insertText": "SetIndex(edge)"
  },
  {
    "label": "pRule()",
    "kind": "Method",
    "detail": "Function (Sdc::Crease::Rule)",
    "insertText": "pRule(parent.getEdgeSharpness(edge) > 0.0f)"
  },
  {
    "label": "getVertexRule()",
    "kind": "Method",
    "detail": "Function (Sdc::Crease::Rule cRule = child .)",
    "insertText": "getVertexRule(cVert)"
  },
  {
    "label": "ComputeEdgeVertexMask()",
    "kind": "Method",
    "detail": "Function (scheme .)",
    "insertText": "ComputeEdgeVertexMask(eHood, eMask, pRule, cRule)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVert ] .)",
    "insertText": "AddWithWeight(src[eVerts[0]], eVertWeights[0])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVert ] .)",
    "insertText": "AddWithWeight(src[eVerts[1]], eVertWeights[1])"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(refinement.getNumChildVerticesFromFaces() > 0)"
  },
  {
    "label": "getFaceChildVertex()",
    "kind": "Method",
    "detail": "Function (Vtr::Index cVertOfFace = refinement .)",
    "insertText": "getFaceChildVertex(eFaces[i])"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Vtr::IndexIsValid(cVertOfFace))"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVert ] .)",
    "insertText": "AddWithWeight(dst[cVertOfFace], eFaceWeights[i])"
  },
  {
    "label": "getFaceEdges()",
    "kind": "Method",
    "detail": "Function (} else { Vtr::Index pFace = eFaces [ i ] ; ConstIndexArray pFaceEdges = parent .)",
    "insertText": "getFaceEdges(pFace), pFaceVerts = parent.getFaceVertices(pFace)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int eInFace = 0 ;)",
    "insertText": "for(; pFaceEdges[eInFace] != edge; ++eInFace)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int vInFace = eInFace + 2 ;)",
    "insertText": "if(vInFace >= pFaceVerts.size()) vInFace -= pFaceVerts.size()"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (Vtr::Index pVertNext = pFaceVerts [ vInFace ] ; dst [ cVert ] .)",
    "insertText": "AddWithWeight(src[pVertNext], eFaceWeights[i])"
  },
  {
    "label": "interpFromVerts()",
    "kind": "Method",
    "detail": "Function (} } } } } template<REAL> template<Sdc::SchemeType SCHEME,class T,class U> void PrimvarRefinerReal<REAL)",
    "insertText": "interpFromVerts(int level, T const & src, U & dst)"
  },
  {
    "label": "vHood()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::VertexInterface)",
    "insertText": "vHood(parent, child)"
  },
  {
    "label": "weightBuffer()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::StackBuffer<Weight,3 2>)",
    "insertText": "weightBuffer(2*parent.getMaxValence())"
  },
  {
    "label": "getVertexEdges()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray vEdges = parent .)",
    "insertText": "getVertexEdges(vert), vFaces = parent.getVertexFaces(vert)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (Weight vVertWeight,* vEdgeWeights = weightBuffer,* vFaceWeights = vEdgeWeights + vEdges .)",
    "insertText": "size()"
  },
  {
    "label": "vMask()",
    "kind": "Method",
    "detail": "Function (Mask)",
    "insertText": "vMask(&vVertWeight, vEdgeWeights, vFaceWeights)"
  },
  {
    "label": "SetIndex()",
    "kind": "Method",
    "detail": "Function (vHood .)",
    "insertText": "SetIndex(vert, cVert)"
  },
  {
    "label": "getVertexRule()",
    "kind": "Method",
    "detail": "Function (Sdc::Crease::Rule pRule = parent .)",
    "insertText": "getVertexRule(vert)"
  },
  {
    "label": "ComputeVertexVertexMask()",
    "kind": "Method",
    "detail": "Function (scheme .)",
    "insertText": "ComputeVertexVertexMask(vHood, vMask, pRule, cRule)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(vMask.AreFaceWeightsForFaceCenters())"
  },
  {
    "label": "getFaceChildVertex()",
    "kind": "Method",
    "detail": "Function (Vtr::Index cVertOfFace = refinement .)",
    "insertText": "getFaceChildVertex(vFaces[i])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVert ] .)",
    "insertText": "AddWithWeight(dst[cVertOfFace], vFaceWeights[i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(vMask.GetNumEdgeWeights() > 0)"
  },
  {
    "label": "getEdgeVertices()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray eVerts = parent .)",
    "insertText": "getEdgeVertices(vEdges[i])"
  },
  {
    "label": "pVertOppositeEdge()",
    "kind": "Method",
    "detail": "Function (Vtr::Index)",
    "insertText": "pVertOppositeEdge(eVerts[0] == vert)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVert ] .)",
    "insertText": "AddWithWeight(src[pVertOppositeEdge], vEdgeWeights[i])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (} } dst [ cVert ] .)",
    "insertText": "AddWithWeight(src[vert], vVertWeight)"
  },
  {
    "label": "interpFVarFromFaces()",
    "kind": "Method",
    "detail": "Function (} } template<REAL> template<Sdc::SchemeType SCHEME,class T,class U> void PrimvarRefinerReal<REAL)",
    "insertText": "interpFVarFromFaces(int level, T const & src, U & dst, int channel)"
  },
  {
    "label": "getFVarLevel()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::FVarLevel const& parentFVar = parentLevel .)",
    "insertText": "getFVarLevel(channel)"
  },
  {
    "label": "fValueWeights()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::StackBuffer<Weight,1 6>)",
    "insertText": "fValueWeights(parentLevel.getMaxValence())"
  },
  {
    "label": "getVertexValueOffset()",
    "kind": "Method",
    "detail": "Function (Vtr::Index cVertValue = childFVar .)",
    "insertText": "getVertexValueOffset(cVert)"
  },
  {
    "label": "getFaceValues()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray fValues = parentFVar .)",
    "insertText": "getFaceValues(face)"
  },
  {
    "label": "fMask()",
    "kind": "Method",
    "detail": "Function (Mask)",
    "insertText": "fMask(fValueWeights, 0, 0)"
  },
  {
    "label": "fHood()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::FaceInterface)",
    "insertText": "fHood(fValues.size())"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[fValues[i]], fValueWeights[i])"
  },
  {
    "label": "interpFVarFromEdges()",
    "kind": "Method",
    "detail": "Function (} } } template<REAL> template<Sdc::SchemeType SCHEME,class T,class U> void PrimvarRefinerReal<REAL)",
    "insertText": "interpFVarFromEdges(int level, T const & src, U & dst, int channel)"
  },
  {
    "label": "getFVarRefinement()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::FVarRefinement const& refineFVar = refinement .)",
    "insertText": "getFVarRefinement(channel)"
  },
  {
    "label": "eFaceWeights()",
    "kind": "Method",
    "detail": "Function (Weight eVertWeights [ 2 ] ; Vtr::internal::StackBuffer<Weight,8>)",
    "insertText": "eFaceWeights(parentLevel.getMaxEdgeFaces())"
  },
  {
    "label": "isLinear()",
    "kind": "Method",
    "detail": "Function (bool isLinearFVar = parentFVar .)",
    "insertText": "isLinear() || (_refiner._subdivType == Sdc::SCHEME_BILINEAR)"
  },
  {
    "label": "SetNumVertexWeights()",
    "kind": "Method",
    "detail": "Function (eMask .)",
    "insertText": "SetNumVertexWeights(2)"
  },
  {
    "label": "SetNumEdgeWeights()",
    "kind": "Method",
    "detail": "Function (eMask .)",
    "insertText": "SetNumEdgeWeights(0)"
  },
  {
    "label": "SetNumFaceWeights()",
    "kind": "Method",
    "detail": "Function (eMask .)",
    "insertText": "SetNumFaceWeights(0)"
  },
  {
    "label": "eHood()",
    "kind": "Method",
    "detail": "Function (eVertWeights [ 0 ] = 0 . 5 f ; eVertWeights [ 1 ] = 0 . 5 f ; } Vtr::internal::EdgeInterface)",
    "insertText": "eHood(parentLevel)"
  },
  {
    "label": "getVertexValues()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray cVertValues = childFVar .)",
    "insertText": "getVertexValues(cVert)"
  },
  {
    "label": "valueTopologyMatches()",
    "kind": "Method",
    "detail": "Function (bool fvarEdgeVertMatchesVertex = childFVar .)",
    "insertText": "valueTopologyMatches(cVertValues[0])"
  },
  {
    "label": "pRule()",
    "kind": "Method",
    "detail": "Function (Sdc::Crease::Rule)",
    "insertText": "pRule(parentLevel.getEdgeSharpness(edge) > 0.0f)"
  },
  {
    "label": "getEdgeFaceValues()",
    "kind": "Method",
    "detail": "Function (} Vtr::Index eVertValues [ 2 ] ; parentFVar .)",
    "insertText": "getEdgeFaceValues(edge, 0, eVertValues)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[eVertValues[0]], eVertWeights[0])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[eVertValues[1]], eVertWeights[1])"
  },
  {
    "label": "getEdgeFaces()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray eFaces = parentLevel .)",
    "insertText": "getEdgeFaces(edge)"
  },
  {
    "label": "getVertexValueOffset()",
    "kind": "Method",
    "detail": "Function (Vtr::Index cValueOfFace = childFVar .)",
    "insertText": "getVertexValueOffset(cVertOfFace)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(dst[cValueOfFace], eFaceWeights[i])"
  },
  {
    "label": "getFaceEdges()",
    "kind": "Method",
    "detail": "Function (} else { Vtr::Index pFace = eFaces [ i ] ; ConstIndexArray pFaceEdges = parentLevel .)",
    "insertText": "getFaceEdges(pFace), pFaceVerts = parentLevel.getFaceVertices(pFace)"
  },
  {
    "label": "getFaceValues()",
    "kind": "Method",
    "detail": "Function (Vtr::Index pValueNext = parentFVar .)",
    "insertText": "getFaceValues(pFace)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[pValueNext], eFaceWeights[i])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } } } else {)",
    "insertText": "for(int i = 0; i < cVertValues.size(); ++i)"
  },
  {
    "label": "getChildValueParentSource()",
    "kind": "Method",
    "detail": "Function (Vtr::Index eVertValues [ 2 ] ; int eFaceIndex = refineFVar .)",
    "insertText": "getChildValueParentSource(cVert, i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(eFaceIndex == i)"
  },
  {
    "label": "getEdgeFaceValues()",
    "kind": "Method",
    "detail": "Function (parentFVar .)",
    "insertText": "getEdgeFaceValues(edge, eFaceIndex, eVertValues)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[eVertValues[0]], 0.5)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[eVertValues[1]], 0.5)"
  },
  {
    "label": "interpFVarFromVerts()",
    "kind": "Method",
    "detail": "Function (} } } } template<REAL> template<Sdc::SchemeType SCHEME,class T,class U> void PrimvarRefinerReal<REAL)",
    "insertText": "interpFVarFromVerts(int level, T const & src, U & dst, int channel)"
  },
  {
    "label": "weightBuffer()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::StackBuffer<Weight,3 2>)",
    "insertText": "weightBuffer(2*parentLevel.getMaxValence())"
  },
  {
    "label": "vEdgeValues()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::StackBuffer<Vtr::Index,1 6>)",
    "insertText": "vEdgeValues(parentLevel.getMaxValence())"
  },
  {
    "label": "vHood()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::VertexInterface)",
    "insertText": "vHood(parentLevel, childLevel)"
  },
  {
    "label": "getVertexValues()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray pVertValues = parentFVar .)",
    "insertText": "getVertexValues(vert), cVertValues = childFVar.getVertexValues(cVert)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValues [ 0 ] ] .)",
    "insertText": "AddWithWeight(src[pVertValues[0]], 1.0f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(fvarVertVertMatchesVertex)"
  },
  {
    "label": "getVertexEdges()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray vEdges = parentLevel .)",
    "insertText": "getVertexEdges(vert)"
  },
  {
    "label": "getVertexFaces()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray vFaces = parentLevel .)",
    "insertText": "getVertexFaces(vert)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(dst[cValueOfFace], vFaceWeights[i])"
  },
  {
    "label": "getVertexEdgeValues()",
    "kind": "Method",
    "detail": "Function (parentFVar .)",
    "insertText": "getVertexEdgeValues(vert, vEdgeValues)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[vEdgeValues[i]], vEdgeWeights[i])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (} } dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[pVertValue], vVertWeight)"
  },
  {
    "label": "getVertexValueTags()",
    "kind": "Method",
    "detail": "Function (} else { Vtr::internal::FVarLevel::ConstValueTagArray pValueTags = parentFVar .)",
    "insertText": "getVertexValueTags(vert)"
  },
  {
    "label": "getVertexValueTags()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::FVarLevel::ConstValueTagArray cValueTags = childFVar .)",
    "insertText": "getVertexValueTags(cVert)"
  },
  {
    "label": "getChildValueParentSource()",
    "kind": "Method",
    "detail": "Function (int pSiblingIndex = refineFVar .)",
    "insertText": "getChildValueParentSource(cVert, cSiblingIndex)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(pSiblingIndex == cSiblingIndex)"
  },
  {
    "label": "cSibling()",
    "kind": "Method",
    "detail": "Function (typedef Vtr::internal::FVarLevel::Sibling SiblingIntType ; SiblingIntType)",
    "insertText": "cSibling(SiblingIntType)"
  },
  {
    "label": "pSibling()",
    "kind": "Method",
    "detail": "Function (SiblingIntType)",
    "insertText": "pSibling(SiblingIntType)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[pVertValue], 1.0f)"
  },
  {
    "label": "getVertexCreaseEndValues()",
    "kind": "Method",
    "detail": "Function (} else { Index pEndValues [ 2 ] ; parentFVar .)",
    "insertText": "getVertexCreaseEndValues(vert, pSibling, pEndValues)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Weight vWeight = 0 . 7 5 f ; Weight eWeight = 0 . 1 2 5 f ;)",
    "insertText": "if(pValueTags[pSibling].isSemiSharp())"
  },
  {
    "label": "isDepSharp()",
    "kind": "Method",
    "detail": "Function (Weight wCorner = pValueTags [ pSibling ] .)",
    "insertText": "isDepSharp() ? refineFVar.getFractionalWeight(vert, !pSibling, cVert, !cSibling) : refineFVar.getFractionalWeight(vert, pSibling, cVert, cSibling)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (Weight wCrease = 1 . 0 f - wCorner ; vWeight = wCrease* 0 . 7 5 f + wCorner ; eWeight = wCrease* 0 . 1 2 5 f ; } dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[pEndValues[0]], eWeight)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[pEndValues[1]], eWeight)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ cVertValue ] .)",
    "insertText": "AddWithWeight(src[pVertValue], vWeight)"
  },
  {
    "label": "limit()",
    "kind": "Method",
    "detail": "Function (} } } } } template<REAL> template<Sdc::SchemeType SCHEME,class T,class U,class U1,class U2> void PrimvarRefinerReal<REAL)",
    "insertText": "limit(T const & src, U & dstPos, U1 * dstTan1Ptr, U2 * dstTan2Ptr)"
  },
  {
    "label": "getLevel()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::Level const& level = _refiner .)",
    "insertText": "getLevel(_refiner.GetMaxLevel())"
  },
  {
    "label": "getMaxValence()",
    "kind": "Method",
    "detail": "Function (int maxWeightsPerMask = 1 + 2* level .)",
    "insertText": "getMaxValence()"
  },
  {
    "label": "hasTangents()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasTangents(dstTan1Ptr && dstTan2Ptr)"
  },
  {
    "label": "numMasks()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "numMasks(hasTangents ? 2 : 0)"
  },
  {
    "label": "indexBuffer()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::StackBuffer<Index,3 3>)",
    "insertText": "indexBuffer(maxWeightsPerMask)"
  },
  {
    "label": "weightBuffer()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::StackBuffer<Weight,9 9>)",
    "insertText": "weightBuffer(numMasks * maxWeightsPerMask)"
  },
  {
    "label": "posMask()",
    "kind": "Method",
    "detail": "Function (Weight* vTan1Weights = vPosWeights + maxWeightsPerMask,* eTan1Weights = ePosWeights + maxWeightsPerMask,* fTan1Weights = fPosWeights + maxWeightsPerMask ; Weight* vTan2Weights = vTan1Weights + maxWeightsPerMask,* eTan2Weights = eTan1Weights + maxWeightsPerMask,* fTan2Weights = fTan1Weights + maxWeightsPerMask ; Mask)",
    "insertText": "posMask(vPosWeights, ePosWeights, fPosWeights)"
  },
  {
    "label": "tan1Mask()",
    "kind": "Method",
    "detail": "Function (Mask)",
    "insertText": "tan1Mask(vTan1Weights, eTan1Weights, fTan1Weights)"
  },
  {
    "label": "tan2Mask()",
    "kind": "Method",
    "detail": "Function (Mask)",
    "insertText": "tan2Mask(vTan2Weights, eTan2Weights, fTan2Weights)"
  },
  {
    "label": "vHood()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::VertexInterface)",
    "insertText": "vHood(level, level)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dstPos [ vert ] .)",
    "insertText": "AddWithWeight(src[vert], 1.0)"
  },
  {
    "label": "SetIndex()",
    "kind": "Method",
    "detail": "Function (vHood .)",
    "insertText": "SetIndex(vert, vert)"
  },
  {
    "label": "ComputeVertexLimitMask()",
    "kind": "Method",
    "detail": "Function (scheme .)",
    "insertText": "ComputeVertexLimitMask(vHood, posMask, tan1Mask, tan2Mask, vRule)"
  },
  {
    "label": "ComputeVertexLimitMask()",
    "kind": "Method",
    "detail": "Function (} else { scheme .)",
    "insertText": "ComputeVertexLimitMask(vHood, posMask, vRule)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (eIndices [)",
    "insertText": "i(eVerts[0] == vert)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(posMask.GetNumFaceWeights() || (hasTangents && tan1Mask.GetNumFaceWeights()))"
  },
  {
    "label": "getVertexFaceLocalIndices()",
    "kind": "Method",
    "detail": "Function (ConstLocalIndexArray vInFace = level .)",
    "insertText": "getVertexFaceLocalIndices(vert)"
  },
  {
    "label": "getFaceVertices()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray fVerts = level .)",
    "insertText": "getFaceVertices(vFaces[i])"
  },
  {
    "label": "vOppInFace()",
    "kind": "Method",
    "detail": "Function (LocalIndex)",
    "insertText": "vOppInFace(vInFace[i] + 2)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dstPos [ vert ] .)",
    "insertText": "AddWithWeight(src[fIndices[i]], fPosWeights[i])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int i = 0; i < posMask.GetNumEdgeWeights(); ++i)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dstPos [ vert ] .)",
    "insertText": "AddWithWeight(src[eIndices[i]], ePosWeights[i])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (} dstPos [ vert ] .)",
    "insertText": "AddWithWeight(src[vert], vPosWeights[0])"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(tan1Mask.GetNumFaceWeights() == tan2Mask.GetNumFaceWeights())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(tan1Mask.GetNumEdgeWeights() == tan2Mask.GetNumEdgeWeights())"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dstTan1 [ vert ] .)",
    "insertText": "AddWithWeight(src[fIndices[i]], fTan1Weights[i])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dstTan2 [ vert ] .)",
    "insertText": "AddWithWeight(src[fIndices[i]], fTan2Weights[i])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int i = 0; i < tan1Mask.GetNumEdgeWeights(); ++i)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dstTan1 [ vert ] .)",
    "insertText": "AddWithWeight(src[eIndices[i]], eTan1Weights[i])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dstTan2 [ vert ] .)",
    "insertText": "AddWithWeight(src[eIndices[i]], eTan2Weights[i])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (} dstTan1 [ vert ] .)",
    "insertText": "AddWithWeight(src[vert], vTan1Weights[0])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dstTan2 [ vert ] .)",
    "insertText": "AddWithWeight(src[vert], vTan2Weights[0])"
  },
  {
    "label": "weightBuffer()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::StackBuffer<Weight,3 3>)",
    "insertText": "weightBuffer(maxWeightsPerMask)"
  },
  {
    "label": "vEdgeBuffer()",
    "kind": "Method",
    "detail": "Function (Vtr::internal::StackBuffer<Index,1 6>)",
    "insertText": "vEdgeBuffer(level.getMaxValence())"
  },
  {
    "label": "getVertexValues()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray vValues = fvarChannel .)",
    "insertText": "getVertexValues(vert)"
  },
  {
    "label": "isIncomplete()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isIncomplete(level.getVertexTag(vert)._incomplete || (vEdges.size() == 0))"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ vValue ] .)",
    "insertText": "AddWithWeight(src[vValue], 1.0f)"
  },
  {
    "label": "valueTopologyMatches()",
    "kind": "Method",
    "detail": "Function (} continue ; } bool fvarVertMatchesVertex = fvarChannel .)",
    "insertText": "valueTopologyMatches(vValues[0])"
  },
  {
    "label": "vMask()",
    "kind": "Method",
    "detail": "Function (Mask)",
    "insertText": "vMask(vWeights, eWeights, fWeights)"
  },
  {
    "label": "ComputeVertexLimitMask()",
    "kind": "Method",
    "detail": "Function (scheme .)",
    "insertText": "ComputeVertexLimitMask(vHood, vMask, level.getVertexRule(vert))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!vMask.AreFaceWeightsForFaceCenters())"
  },
  {
    "label": "getFaceValues()",
    "kind": "Method",
    "detail": "Function (ConstIndexArray faceValues = fvarChannel .)",
    "insertText": "getFaceValues(vFaces[i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (LocalIndex vOppInFace = vInFace [ i ] + 2 ;)",
    "insertText": "if(vOppInFace >= faceValues.size()) vOppInFace -= faceValues.size()"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (Index vValueOppositeFace = faceValues [ vOppInFace ] ; dst [ vValue ] .)",
    "insertText": "AddWithWeight(src[vValueOppositeFace], fWeights[i])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ vValue ] .)",
    "insertText": "AddWithWeight(src[vEdgeValues[i]], eWeights[i])"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (} } dst [ vValue ] .)",
    "insertText": "AddWithWeight(src[vValue], vWeights[0])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(int i = 0; i < vValues.size(); ++i)"
  },
  {
    "label": "getVertexCreaseEndValues()",
    "kind": "Method",
    "detail": "Function (} else { Index vEndValues [ 2 ] ; fvarChannel .)",
    "insertText": "getVertexCreaseEndValues(vert, i, vEndValues)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ vValue ] .)",
    "insertText": "AddWithWeight(src[vEndValues[0]], 1.0f/6.0f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ vValue ] .)",
    "insertText": "AddWithWeight(src[vEndValues[1]], 1.0f/6.0f)"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (dst [ vValue ] .)",
    "insertText": "AddWithWeight(src[vValue], 2.0f/3.0f)"
  },
  {
    "label": "PrimvarRefiner()",
    "kind": "Method",
    "detail": "Function (} } } } } class PrimvarRefiner : public PrimvarRefinerReal<float> { public :)",
    "insertText": "PrimvarRefiner(TopologyRefiner const & refiner) : PrimvarRefinerReal<float>(refiner)"
  }
]