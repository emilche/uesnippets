[
  {
    "label": "TRotator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TRotator"
  },
  {
    "label": "UPackageMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPackageMap"
  },
  {
    "label": "TCanBulkSerialize",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCanBulkSerialize"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "TIsUECoreVariant",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsUECoreVariant"
  },
  {
    "label": "TCustomLerp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCustomLerp"
  },
  {
    "label": "U",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Math / UnrealMathUtility . h \" # include \" Containers / UnrealString . h \" # include \" Misc / Parse . h \" # include \" Misc / LargeWorldCoordinatesSerializer . h \" # include \" Logging / LogMacros . h \" # include \" Math / Vector . h \" # include \" Math / VectorRegister . h \" # include \" UObject / ObjectVersion . h \" namespace UE { namespace Math { template<T> struct TRotator {)",
    "insertText": "static_assert(std::is_floating_point_v<T>, \"TRotator only supports float and double types.\")"
  },
  {
    "label": "DiagnosticCheckNaN()",
    "kind": "Method",
    "detail": "Function (public : using FReal = T ; T Pitch ; T Yaw ; T Roll ; public : const TRotator<T> ZeroRotator ; public : # if ENABLE_NAN_DIAGNOSTIC void)",
    "insertText": "DiagnosticCheckNaN()"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"TRotator contains NaN: %s\"), *ToString())"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (* const_cast<TRotator<)",
    "insertText": "T(this)"
  },
  {
    "label": "DiagnosticCheckNaN()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DiagnosticCheckNaN(const TCHAR* Message)"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"%s: TRotator contains NaN: %s\"), Message, *ToString())"
  },
  {
    "label": "TRotator()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "TRotator()"
  },
  {
    "label": "TRotator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRotator(T InF)"
  },
  {
    "label": "TRotator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRotator(EForceInit)"
  },
  {
    "label": "TRotator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRotator(const TQuat<T>& Quat)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (public : TRotator)",
    "insertText": "operator(const TRotator<T>& R)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<FArg)",
    "insertText": "UE_REQUIRES(std::is_arithmetic_v<FArg>)> FORCEINLINE TRotator operator*( FArg Scale)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<FArg)",
    "insertText": "UE_REQUIRES(std::is_arithmetic_v<FArg>)> FORCEINLINE TRotator operator*=( FArg Scale)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const TRotator<T>& V)"
  },
  {
    "label": "IsNearlyZero()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "IsNearlyZero(T Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "IsZero()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsZero()"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Equals(const TRotator<T>& R, T Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "EqualsOrientation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EqualsOrientation(const TRotator<T>& R, T Tolerance = UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TRotator)",
    "insertText": "Add(T DeltaPitch, T DeltaYaw, T DeltaRoll)"
  },
  {
    "label": "GetInverse()",
    "kind": "Method",
    "detail": "Function (TRotator)",
    "insertText": "GetInverse()"
  },
  {
    "label": "GridSnap()",
    "kind": "Method",
    "detail": "Function (TRotator)",
    "insertText": "GridSnap(const TRotator<T>& RotGrid)"
  },
  {
    "label": "Vector()",
    "kind": "Method",
    "detail": "Function (TVector<T>)",
    "insertText": "Vector()"
  },
  {
    "label": "Quaternion()",
    "kind": "Method",
    "detail": "Function (TQuat<T>)",
    "insertText": "Quaternion()"
  },
  {
    "label": "Euler()",
    "kind": "Method",
    "detail": "Function (TVector<T>)",
    "insertText": "Euler()"
  },
  {
    "label": "RotateVector()",
    "kind": "Method",
    "detail": "Function (TVector<T>)",
    "insertText": "RotateVector(const UE::Math::TVector<T>& V)"
  },
  {
    "label": "UnrotateVector()",
    "kind": "Method",
    "detail": "Function (TVector<T>)",
    "insertText": "UnrotateVector(const UE::Math::TVector<T>& V)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (TRotator<T>)",
    "insertText": "Clamp()"
  },
  {
    "label": "GetNormalized()",
    "kind": "Method",
    "detail": "Function (TRotator<T>)",
    "insertText": "GetNormalized()"
  },
  {
    "label": "GetDenormalized()",
    "kind": "Method",
    "detail": "Function (TRotator<T>)",
    "insertText": "GetDenormalized()"
  },
  {
    "label": "GetComponentForAxis()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "GetComponentForAxis(EAxis::Type Axis)"
  },
  {
    "label": "SetComponentForAxis()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetComponentForAxis(EAxis::Type Axis, T Component)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Normalize()"
  },
  {
    "label": "GetWindingAndRemainder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetWindingAndRemainder(TRotator<T>& Winding, TRotator<T>& Remainder)"
  },
  {
    "label": "GetManhattanDistance()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "GetManhattanDistance(const TRotator<T> & Rotator)"
  },
  {
    "label": "GetEquivalentRotator()",
    "kind": "Method",
    "detail": "Function (TRotator)",
    "insertText": "GetEquivalentRotator()"
  },
  {
    "label": "SetClosestToMe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetClosestToMe(TRotator& MakeClosest)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ToString()"
  },
  {
    "label": "ToCompactString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ToCompactString()"
  },
  {
    "label": "InitFromString()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "InitFromString(const FString& InSourceString)"
  },
  {
    "label": "ContainsNaN()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ContainsNaN()"
  },
  {
    "label": "SerializeCompressed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SerializeCompressed(FArchive& Ar)"
  },
  {
    "label": "SerializeCompressedShort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SerializeCompressedShort(FArchive& Ar)"
  },
  {
    "label": "NetSerialize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess)"
  },
  {
    "label": "ClampAxis()",
    "kind": "Method",
    "detail": "Function (public : T)",
    "insertText": "ClampAxis(T Angle)"
  },
  {
    "label": "NormalizeAxis()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "NormalizeAxis(T Angle)"
  },
  {
    "label": "CompressAxisToByte()",
    "kind": "Method",
    "detail": "Function (uint8)",
    "insertText": "CompressAxisToByte(T Angle)"
  },
  {
    "label": "DecompressAxisFromByte()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "DecompressAxisFromByte(uint8 Angle)"
  },
  {
    "label": "CompressAxisToShort()",
    "kind": "Method",
    "detail": "Function (uint16)",
    "insertText": "CompressAxisToShort(T Angle)"
  },
  {
    "label": "DecompressAxisFromShort()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "DecompressAxisFromShort(uint16 Angle)"
  },
  {
    "label": "MakeFromEuler()",
    "kind": "Method",
    "detail": "Function (TRotator)",
    "insertText": "MakeFromEuler(const TVector<T>& Euler)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "SerializeFromMismatchedTag()",
    "kind": "Method",
    "detail": "Function (Ar<<* this ; return true ; } bool)",
    "insertText": "SerializeFromMismatchedTag(FName StructTag, FArchive& Ar)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<FArg)",
    "insertText": "UE_REQUIRES(!std::is_same_v<T, FArg>)> explicit TRotator(const TRotator<FArg>& From) : TRotator<T>((T)From.Pitch, (T)From.Yaw, (T)From.Roll)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # if !)",
    "insertText": "defined(_MSC_VER) || defined(__clang__)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<> const FRotator3d FRotator3d::ZeroRotator ; # endif FArchive&)",
    "insertText": "operator(FArchive& Ar, TRotator<float>& R)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ar<<R . Pitch<<R . Yaw<<R . Roll ; return Ar ; } FArchive&)",
    "insertText": "operator(FArchive& Ar, TRotator<double>& R)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (Ar<<R . Pitch<<R . Yaw<<R . Roll ; } else {)",
    "insertText": "checkf(Ar.IsLoading(), TEXT(\"float -> double conversion applied outside of load!\"))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (float Pitch,Yaw,Roll ; Ar<<Pitch<<Yaw<<Roll ; R = TRotator<)",
    "insertText": "double(Pitch, Yaw, Roll)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} return Ar ; } template<T,FArg)",
    "insertText": "UE_REQUIRES(std::is_arithmetic_v<FArg>)> FORCEINLINE TRotator<T> operator*(FArg Scale, const TRotator<T>& R)"
  },
  {
    "label": "TRotator()",
    "kind": "Method",
    "detail": "Function (} template<T> TRotator<T)",
    "insertText": "TRotator(T InF ) : Pitch(InF), Yaw(InF), Roll(InF)"
  },
  {
    "label": "TRotator()",
    "kind": "Method",
    "detail": "Function (} template<T> TRotator<T)",
    "insertText": "TRotator(T InPitch, T InYaw, T InRoll ) : Pitch(InPitch), Yaw(InYaw), Roll(InRoll)"
  },
  {
    "label": "TRotator()",
    "kind": "Method",
    "detail": "Function (} template<T> TRotator<T)",
    "insertText": "TRotator(EForceInit) : Pitch(0), Yaw(0), Roll(0)"
  },
  {
    "label": "VectorLoadFloat3_W0()",
    "kind": "Method",
    "detail": "Function (# if PLATFORM_ENABLE_VECTORINTRINSICS const TVectorRegisterType<T> RegA =)",
    "insertText": "VectorLoadFloat3_W0(this)"
  },
  {
    "label": "VectorNormalizeRotator()",
    "kind": "Method",
    "detail": "Function (const TVectorRegisterType<T> Norm =)",
    "insertText": "VectorNormalizeRotator(RegA)"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (const TVectorRegisterType<T> AbsNorm =)",
    "insertText": "VectorAbs(Norm)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "Abs(NormalizeAxis(Pitch))<=Tolerance && FMath::Abs(NormalizeAxis(Yaw))<=Tolerance && FMath::Abs(NormalizeAxis(Roll))"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (} template<T> bool TRotator<T)",
    "insertText": "Equals(const TRotator<T>& R, T Tolerance)"
  },
  {
    "label": "VectorLoadFloat3_W0()",
    "kind": "Method",
    "detail": "Function (const TVectorRegisterType<T> RegB =)",
    "insertText": "VectorLoadFloat3_W0(&R)"
  },
  {
    "label": "VectorNormalizeRotator()",
    "kind": "Method",
    "detail": "Function (const TVectorRegisterType<T> NormDelta =)",
    "insertText": "VectorNormalizeRotator(VectorSubtract(RegA, RegB))"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (const TVectorRegisterType<T> AbsNormDelta =)",
    "insertText": "VectorAbs(NormDelta)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "return(FMath::Abs(NormalizeAxis(Pitch - R.Pitch)) <= Tolerance) && (FMath::Abs(NormalizeAxis(Yaw - R.Yaw)) <= Tolerance) && (FMath::Abs(NormalizeAxis(Roll - R.Roll)) <= Tolerance)"
  },
  {
    "label": "EqualsOrientation()",
    "kind": "Method",
    "detail": "Function (# endif } template<T> bool TRotator<T)",
    "insertText": "EqualsOrientation(const TRotator<T>& R, T Tolerance)"
  },
  {
    "label": "Fmod()",
    "kind": "Method",
    "detail": "Function (Angle =)",
    "insertText": "Fmod(Angle, (T)360.0)"
  },
  {
    "label": "Angle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Angle(T)"
  },
  {
    "label": "ClampAxis()",
    "kind": "Method",
    "detail": "Function (Angle =)",
    "insertText": "ClampAxis(Angle)"
  },
  {
    "label": "ClampAxis()",
    "kind": "Method",
    "detail": "Function (TRotator Rot =* this ; Rot . Pitch =)",
    "insertText": "ClampAxis(Rot.Pitch)"
  },
  {
    "label": "ClampAxis()",
    "kind": "Method",
    "detail": "Function (Rot . Yaw =)",
    "insertText": "ClampAxis(Rot.Yaw)"
  },
  {
    "label": "ClampAxis()",
    "kind": "Method",
    "detail": "Function (Rot . Roll =)",
    "insertText": "ClampAxis(Rot.Roll)"
  },
  {
    "label": "VectorNormalizeRotator()",
    "kind": "Method",
    "detail": "Function (VRotator =)",
    "insertText": "VectorNormalizeRotator(VRotator)"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreFloat3(VRotator, this)"
  },
  {
    "label": "NormalizeAxis()",
    "kind": "Method",
    "detail": "Function (# else Pitch =)",
    "insertText": "NormalizeAxis(Pitch)"
  },
  {
    "label": "NormalizeAxis()",
    "kind": "Method",
    "detail": "Function (Yaw =)",
    "insertText": "NormalizeAxis(Yaw)"
  },
  {
    "label": "NormalizeAxis()",
    "kind": "Method",
    "detail": "Function (Roll =)",
    "insertText": "NormalizeAxis(Roll)"
  },
  {
    "label": "ReturnString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ReturnString(TEXT(\"R(\")); bool bIsEmptyString = true; if( !FMath::IsNearlyZero(Pitch) ) { ReturnString += FString::Printf(TEXT(\"P=%.2f\"), Pitch); bIsEmptyString = false; } if( !FMath::IsNearlyZero(Yaw) ) { if( !bIsEmptyString ) { ReturnString += FString(TEXT(\", \")); } ReturnString += FString::Printf(TEXT(\"Y=%.2f\"), Yaw); bIsEmptyString = false; } if( !FMath::IsNearlyZero(Roll) ) { if( !bIsEmptyString ) { ReturnString += FString(TEXT(\", \")); } ReturnString += FString::Printf(TEXT(\"R=%.2f\"), Roll); bIsEmptyString = false; } ReturnString += FString(TEXT(\")\"))"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (Pitch = Yaw = Roll = 0 ; const bool bSuccessful =)",
    "insertText": "Value(*InSourceString, TEXT(\"P=\") , Pitch ) && FParse::Value( *InSourceString, TEXT(\"Y=\"), Yaw ) && FParse::Value( *InSourceString, TEXT(\"R=\"), Roll)"
  },
  {
    "label": "GetManhattanDistance()",
    "kind": "Method",
    "detail": "Function (T FirstDiff =)",
    "insertText": "GetManhattanDistance(MakeClosest)"
  },
  {
    "label": "GetManhattanDistance()",
    "kind": "Method",
    "detail": "Function (T SecondDiff =)",
    "insertText": "GetManhattanDistance(OtherChoice)"
  },
  {
    "label": "UE_DECLARE_LWC_TYPE()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "UE_DECLARE_LWC_TYPE(Rotator, 3)"
  },
  {
    "label": "DECLARE_INTRINSIC_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (template<> struct TCanBulkSerialize<FRotator3f> { enum { Value = false } ; } ; template<> struct TIsPODType<FRotator3f> { enum { Value = true } ; } ; template<> struct TIsUECoreVariant<FRotator3f> { enum { Value = true } ; } ;)",
    "insertText": "DECLARE_INTRINSIC_TYPE_LAYOUT(FRotator3f)"
  },
  {
    "label": "DECLARE_INTRINSIC_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (template<> struct TCanBulkSerialize<FRotator3d> { enum { Value = false } ; } ; template<> struct TIsPODType<FRotator3d> { enum { Value = true } ; } ; template<> struct TIsUECoreVariant<FRotator3d> { enum { Value = true } ; } ;)",
    "insertText": "DECLARE_INTRINSIC_TYPE_LAYOUT(FRotator3d)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (} template<T> struct TCustomLerp<UE::Math::TRotator<T>> { bool Value = true ; using RotatorType = UE::Math::TRotator<T> ; template<class U> RotatorType)",
    "insertText": "Lerp(const RotatorType& A, const RotatorType& B, const U& Alpha)"
  },
  {
    "label": "LerpRange()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,U> UE::Math::TRotator<T>)",
    "insertText": "LerpRange(const UE::Math::TRotator<T>& A, const UE::Math::TRotator<T>& B, U Alpha)"
  },
  {
    "label": "ClampAngle()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "ClampAngle(T AngleDegrees, T MinAngleDegrees, T MaxAngleDegrees)"
  },
  {
    "label": "ClampAxis()",
    "kind": "Method",
    "detail": "Function (const T MaxDelta = UE::Math::TRotator<T)",
    "insertText": "ClampAxis(MaxAngleDegrees - MinAngleDegrees)"
  },
  {
    "label": "ClampAxis()",
    "kind": "Method",
    "detail": "Function (const T RangeCenter = UE::Math::TRotator<T)",
    "insertText": "ClampAxis(MinAngleDegrees + MaxDelta)"
  },
  {
    "label": "NormalizeAxis()",
    "kind": "Method",
    "detail": "Function (const T DeltaFromCenter = UE::Math::TRotator<T)",
    "insertText": "NormalizeAxis(AngleDegrees - RangeCenter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(DeltaFromCenter < -MaxDelta)"
  },
  {
    "label": "NormalizeAxis()",
    "kind": "Method",
    "detail": "Function (} return UE::Math::TRotator<T)",
    "insertText": "NormalizeAxis(AngleDegrees)"
  }
]