[
  {
    "label": "ParseSigned()",
    "kind": "Method",
    "detail": "Function (# ifndef RTC_BASE_STRING_TO_NUMBER_H_ # define RTC_BASE_STRING_TO_NUMBER_H_ # include<limits> # include<string> # include<type_traits> # include \" absl / strings / string_view . h \" # include \" absl / types / optional . h \" namespace rtc { namespace string_to_number_internal { using unsigned_type = unsigned long long ; using signed_type = long long ; absl::optional<signed_type>)",
    "insertText": "ParseSigned(absl::string_view str, int base)"
  },
  {
    "label": "ParseUnsigned()",
    "kind": "Method",
    "detail": "Function (absl::optional<unsigned_type>)",
    "insertText": "ParseUnsigned(absl::string_view str, int base)"
  },
  {
    "label": "ParseFloatingPoint()",
    "kind": "Method",
    "detail": "Function (template<T> absl::optional<T>)",
    "insertText": "ParseFloatingPoint(absl::string_view str)"
  },
  {
    "label": "StringToNumber()",
    "kind": "Method",
    "detail": "Function (} template<T> std::enable_if<std::is_integral<T>::value&& std::is_signed<T>::value,absl::optional<T>>::type)",
    "insertText": "StringToNumber(absl::string_view str, int base = 10)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using string_to_number_internal::signed_type ;)",
    "insertText": "static_assert(std::numeric_limits<T>::max() <= std::numeric_limits<signed_type>::max() && std::numeric_limits<T>::lowest() >= std::numeric_limits<signed_type>::lowest(), \"StringToNumber only supports signed integers as large as long long int\")"
  },
  {
    "label": "ParseSigned()",
    "kind": "Method",
    "detail": "Function (absl::optional<signed_type> value =)",
    "insertText": "ParseSigned(str, base)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using string_to_number_internal::unsigned_type ;)",
    "insertText": "static_assert(std::numeric_limits<T>::max() <= std::numeric_limits<unsigned_type>::max(), \"StringToNumber only supports unsigned integers as large as \" \"unsigned long long int\")"
  },
  {
    "label": "ParseUnsigned()",
    "kind": "Method",
    "detail": "Function (absl::optional<unsigned_type> value =)",
    "insertText": "ParseUnsigned(str, base)"
  }
]