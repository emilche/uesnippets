[
  {
    "label": "FAnimPhys",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhys"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FAnimPhysShape",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimPhysShape"
  },
  {
    "label": "FAnimPhysPose",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimPhysPose"
  },
  {
    "label": "FAnimPhysState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhysState"
  },
  {
    "label": "FAnimPhysWindData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimPhysWindData"
  },
  {
    "label": "FAnimPhysRigidBody",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhysRigidBody"
  },
  {
    "label": "FAnimPhysLimit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhysLimit"
  },
  {
    "label": "FAnimPhysAngularLimit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhysAngularLimit"
  },
  {
    "label": "FAnimPhysLinearLimit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhysLinearLimit"
  },
  {
    "label": "FAnimPhysSpring",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimPhysSpring"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Stats / Stats . h \" # include \" UObject / ObjectMacros . h \" # include \" AnimPhysicsSolver . generated . h \")",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Anim Dynamics Physics Update\"), STAT_AnimDynamicsUpdate, STATGROUP_Physics, ENGINE_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Linear Limit Pre-Update\"), STAT_AnimDynamicsLinearPre, STATGROUP_Physics, ENGINE_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Linear Limit Post-Update\"), STAT_AnimDynamicsLinearPost, STATGROUP_Physics, ENGINE_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Angular Limit Pre-Update\"), STAT_AnimDynamicsAngularPre, STATGROUP_Physics, ENGINE_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Angular Limit Post-Update\"), STAT_AnimDynamicsAngularPost, STATGROUP_Physics, ENGINE_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Velocity Init\"), STAT_AnimDynamicsVelocityInit, STATGROUP_Physics, ENGINE_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Pose Update\"), STAT_AnimDynamicsPoseUpdate, STATGROUP_Physics, ENGINE_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"Limits Update\"), STAT_AnimDynamicsLimitUpdate, STATGROUP_Physics, ENGINE_API)"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (class FAnimPhys ; namespace AnimPhysicsConstants { const float JointBiasFactor = 0 . 3 f ; const float LinearDamping = 0 . 7 f ; const float AngularDamping = 0 . 7 f ; const float DefaultSpringConstantLinear = 1 2 . 0 f ; const float DefaultSpringConstantAngular = 4 . 0 f ; })",
    "insertText": "UENUM()"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (CoM)",
    "insertText": "UMETA(DisplayName=\"CoM\", DisplayValue=\"CoM\", ToolTip=\"Only limit the center of mass from crossing planes.\"), CustomSphere UMETA(ToolTip=\"Use the specified sphere radius to collide with planes.\"), InnerSphere UMETA(ToolTip=\"Use the largest sphere that fits entirely within the body extents to collide with planes.\"), OuterSphere UMETA(ToolTip=\"Use the smallest sphere that wholely contains the body extents to collide with planes.\")"
  },
  {
    "label": "MakeBox()",
    "kind": "Method",
    "detail": "Function (struct FAnimPhysShape { FAnimPhysShape)",
    "insertText": "MakeBox(const FVector& Extents)"
  },
  {
    "label": "FAnimPhysShape()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAnimPhysShape()"
  },
  {
    "label": "FAnimPhysShape()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAnimPhysShape(TArray<FVector>& InVertices, TArray<FIntVector>& InTriangles)"
  },
  {
    "label": "TransformVerts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TransformVerts(FTransform& InTransform)"
  },
  {
    "label": "FAnimPhysPose()",
    "kind": "Method",
    "detail": "Function (TArray<FVector> Vertices ; TArray<FIntVector> Triangles ; float Volume ; FVector CenterOfMass ; } ; struct FAnimPhysPose { FVector Position ; FQuat Orientation ;)",
    "insertText": "FAnimPhysPose(const FVector& InPosition, const FQuat& InOrient) : Position(InPosition) , Orientation(InOrient)"
  },
  {
    "label": "FAnimPhysPose()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAnimPhysPose() : Position(FVector::ZeroVector) , Orientation(FQuat::Identity)"
  },
  {
    "label": "Inverse()",
    "kind": "Method",
    "detail": "Function (} FAnimPhysPose)",
    "insertText": "Inverse()"
  },
  {
    "label": "FAnimPhysPose()",
    "kind": "Method",
    "detail": "Function (FVector InversePosition = InverseOrient* Position ; return)",
    "insertText": "FAnimPhysPose(InversePosition, InverseOrient)"
  },
  {
    "label": "Matrix()",
    "kind": "Method",
    "detail": "Function (} FMatrix)",
    "insertText": "Matrix()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FVector)",
    "insertText": "operator(const FVector& InPoint)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FAnimPhysPose)",
    "insertText": "operator(const FAnimPhysPose& InPose)"
  },
  {
    "label": "TransformPlane()",
    "kind": "Method",
    "detail": "Function (} FPlane)",
    "insertText": "TransformPlane(const FPlane& InPlane)"
  },
  {
    "label": "NewNormal()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "NewNormal(InPlane.X, InPlane.Y, InPlane.Z)"
  },
  {
    "label": "FPlane()",
    "kind": "Method",
    "detail": "Function (NewNormal = Orientation* NewNormal ; return)",
    "insertText": "FPlane(NewNormal, InPlane.W - FVector::DotProduct(Position, NewNormal))"
  },
  {
    "label": "FAnimPhysState()",
    "kind": "Method",
    "detail": "Function (} } ; class FAnimPhysState { public :)",
    "insertText": "FAnimPhysState()"
  },
  {
    "label": "FAnimPhysState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAnimPhysState(const FVector& InPosition, const FQuat& InOrient, const FVector& InLinearMomentum, const FVector& InAngularMomentum)"
  },
  {
    "label": "GetPose()",
    "kind": "Method",
    "detail": "Function (FAnimPhysPose Pose ; FVector LinearMomentum ; FVector AngularMomentum ; FAnimPhysPose&)",
    "insertText": "GetPose()"
  },
  {
    "label": "Spin()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "Spin()"
  },
  {
    "label": "FAnimPhysLimit()",
    "kind": "Method",
    "detail": "Function (float Mass ; float InverseMass ; FMatrix InverseTensorWithoutMass ; FMatrix InverseWorldSpaceTensor ; FVector NextPosition ; FQuat NextOrientation ; FVector PreviousPosition ; FQuat PreviousOrientation ; FVector StartPosition ; FQuat StartOrientation ; bool bWindEnabled ; FAnimPhysWindData WindData ; bool bAngularDampingOverriden ; float AngularDamping ; bool bLinearDampingOverriden ; float LinearDamping ; float GravityScale ; bool bUseGravityOverride ; FVector GravityOverride ; FAnimPhysState PreviousState ; FVector CenterOfMass ; AnimPhysCollisionType CollisionType ; float SphereCollisionRadius ; TArray<FAnimPhysShape> Shapes ; } ; class FAnimPhysLimit { public : FAnimPhysRigidBody* Bodies [ 2 ] ;)",
    "insertText": "FAnimPhysLimit(FAnimPhysRigidBody* InFirstBody, FAnimPhysRigidBody* InSecondBody)"
  },
  {
    "label": "FAnimPhysAngularLimit()",
    "kind": "Method",
    "detail": "Function (} ; class FAnimPhysAngularLimit : public FAnimPhysLimit { public : FVector WorldSpaceAxis ; float Torque ; float TargetSpin ; float MinimumTorque ; float MaximumTorque ; float CachedSpinToTorque ;)",
    "insertText": "FAnimPhysAngularLimit()"
  },
  {
    "label": "FAnimPhysAngularLimit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAnimPhysAngularLimit(FAnimPhysRigidBody* InFirstBody, FAnimPhysRigidBody* InSecondBody, const FVector& InWorldSpaceAxis, float InTargetSpin = 0, float InMinimumTorque = -MAX_flt, float InMaximumTorque = MAX_flt)"
  },
  {
    "label": "RemoveBias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveBias()"
  },
  {
    "label": "Iter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Iter(float DeltaTime)"
  },
  {
    "label": "UpdateCachedData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateCachedData()"
  },
  {
    "label": "FAnimPhysLinearLimit()",
    "kind": "Method",
    "detail": "Function (} ; class FAnimPhysLinearLimit : public FAnimPhysLimit { public : FVector FirstPosition ; FVector SecondPosition ; FVector LimitNormal ; float TargetSpeed ; float TargetSpeedWithoutBias ; float MinimumForce ; float Maximumforce ; float SumImpulses ; float InverseInertiaImpulse ; FVector WorldSpacePosition0 ; FVector WorldSpacePosition1 ;)",
    "insertText": "FAnimPhysLinearLimit()"
  },
  {
    "label": "FAnimPhysLinearLimit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAnimPhysLinearLimit(FAnimPhysRigidBody* InFirstBody, FAnimPhysRigidBody* InSecondBody, const FVector& InFirstPosition, const FVector& InSecondPosition, const FVector& InNormal = FVector(0.0f, 0.0f, 1.0f), float InTargetSpeed = 0.0f, float InTargetSpeedWithoutBias = 0.0f, const FVector2D& InForceRange = FVector2D(-MAX_flt, MAX_flt))"
  },
  {
    "label": "Iter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Iter(float DetlaTime)"
  },
  {
    "label": "ApplyForces()",
    "kind": "Method",
    "detail": "Function (} ; struct FAnimPhysSpring { FAnimPhysRigidBody* Body0 ; FAnimPhysRigidBody* Body1 ; FQuat TargetOrientationOffset ; FVector AngularTarget ; AnimPhysTwistAxis AngularTargetAxis ; FVector Anchor0 ; FVector Anchor1 ; float SpringConstantLinear ; float SpringConstantAngular ; bool bApplyLinear ; bool bApplyAngular ; void)",
    "insertText": "ApplyForces(float DeltaTime)"
  },
  {
    "label": "CalculateVolume()",
    "kind": "Method",
    "detail": "Function (} ; class FAnimPhys { public : bool bEnableDetailedStats ; float)",
    "insertText": "CalculateVolume(const TArray<FVector>& InVertices, const TArray<FIntVector>& InTriangles)"
  },
  {
    "label": "CalculateVolume()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "CalculateVolume(const TArray<FAnimPhysShape>& InShapes)"
  },
  {
    "label": "CalculateCenterOfMass()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "CalculateCenterOfMass(const TArray<FVector>& InVertices, const TArray<FIntVector>& InTriangles)"
  },
  {
    "label": "CalculateCenterOfMass()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "CalculateCenterOfMass(const TArray<FAnimPhysShape>& InShapes)"
  },
  {
    "label": "CalculateInertia()",
    "kind": "Method",
    "detail": "Function (FMatrix)",
    "insertText": "CalculateInertia(const TArray<FVector>& InVertices, const TArray<FIntVector>& InTriangles, const FVector& InCenterOfMass)"
  },
  {
    "label": "CalculateInertia()",
    "kind": "Method",
    "detail": "Function (FMatrix)",
    "insertText": "CalculateInertia(const TArray<FAnimPhysShape>& InShapes, const FVector& InCenterOfMass)"
  },
  {
    "label": "ScaleRigidBodyMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScaleRigidBodyMass(FAnimPhysRigidBody* InOutRigidBody, float Scale)"
  },
  {
    "label": "ApplyImpulse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyImpulse(FAnimPhysRigidBody* InOutRigidBody, const FVector& InWorldOrientedImpactPoint, const FVector& InImpulse)"
  },
  {
    "label": "PhysicsUpdate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PhysicsUpdate(float DeltaTime, TArray<FAnimPhysRigidBody*>& Bodies, TArray<FAnimPhysLinearLimit>& LinearLimits, TArray<FAnimPhysAngularLimit>& AngularLimits, TArray<FAnimPhysSpring>& Springs, const FVector& GravityDirection, const FVector& ExternalForce, const FVector& ExternalLinearAcc, int32 NumPreIterations = 8, int32 NumPostIterations = 2)"
  },
  {
    "label": "ConstrainAlongDirection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainAlongDirection(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody *FirstBody, const FVector& FirstPosition, FAnimPhysRigidBody *SecondBody, const FVector& SecondPosition, const FVector& AxisToConstrain, const FVector2D Limits, float MinimumForce = -MAX_flt, float MaximumForce = MAX_flt)"
  },
  {
    "label": "ConstrainPositionNailed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainPositionNailed(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody *FirstBody, const FVector& FirstPosition, FAnimPhysRigidBody *SecondBody, const FVector& SecondPosition)"
  },
  {
    "label": "ConstrainPositionPrismatic()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainPositionPrismatic(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody* FirstBody, const FVector& FirstPosition, FAnimPhysRigidBody* SecondBody, const FVector& SecondPosition, const FQuat& PrismRotation, const FVector& LimitsMin, const FVector& LimitsMax)"
  },
  {
    "label": "ConstrainAngularRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainAngularRange(float DeltaTime, TArray<FAnimPhysAngularLimit>& LimitContainer, FAnimPhysRigidBody *FirstBody, FAnimPhysRigidBody *SecondBody, const FQuat& JointFrame, AnimPhysTwistAxis TwistAxis, const FVector& JointLimitMin, const FVector& JointLimitMax, float InJointBias)"
  },
  {
    "label": "ConstrainConeAngle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainConeAngle(float DeltaTime, TArray<FAnimPhysAngularLimit>& LimitContainer, FAnimPhysRigidBody* FirstBody, const FVector& Normal0, FAnimPhysRigidBody* SecondBody, const FVector& Normal1, float LimitAngle, float InJointBias)"
  },
  {
    "label": "ConstrainPlanar()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainPlanar(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody* Body, const FTransform& PlaneTransform)"
  },
  {
    "label": "ConstrainSphericalInner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainSphericalInner(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody* Body, const FTransform& SphereTransform, float SphereRadius)"
  },
  {
    "label": "ConstrainSphericalOuter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainSphericalOuter(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody* Body, const FTransform& SphereTransform, float SphereRadius)"
  },
  {
    "label": "CreateSpring()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateSpring(TArray<FAnimPhysSpring>& SpringContainer, FAnimPhysRigidBody* Body0, FVector Position0, FAnimPhysRigidBody* Body1, FVector Position1)"
  },
  {
    "label": "DiffQ()",
    "kind": "Method",
    "detail": "Function (private : FQuat)",
    "insertText": "DiffQ(const FQuat& InOrientation, const FMatrix &InInverseTensor, const FVector& InAngularMomentum)"
  },
  {
    "label": "UpdateOrientRK()",
    "kind": "Method",
    "detail": "Function (FQuat)",
    "insertText": "UpdateOrientRK(const FQuat& InOrient, const FMatrix& InInverseTensor, const FVector& InAngularMomentum, float InDeltaTime)"
  },
  {
    "label": "InitializeBodyVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeBodyVelocity(float DeltaTime, FAnimPhysRigidBody *InBody, const FVector& GravityDirection)"
  },
  {
    "label": "CalculateNextPose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculateNextPose(float DeltaTime, FAnimPhysRigidBody* InBody)"
  },
  {
    "label": "UpdatePose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdatePose(FAnimPhysRigidBody* InBody)"
  },
  {
    "label": "ConstrainAngularRangeInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainAngularRangeInternal(float DeltaTime, TArray<FAnimPhysAngularLimit>& LimitContainer, FAnimPhysRigidBody *FirstBody, const FQuat& JointFrame0, FAnimPhysRigidBody *SecondBody, const FQuat& JointFrame1, AnimPhysTwistAxis TwistAxis, const FVector& InJointLimitMin, const FVector& InJointLimitMax, float InJointBias)"
  }
]