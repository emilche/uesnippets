[
  {
    "label": "FAnimPhys",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhys"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FAnimPhysShape",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimPhysShape"
  },
  {
    "label": "FAnimPhysPose",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimPhysPose"
  },
  {
    "label": "FAnimPhysState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhysState"
  },
  {
    "label": "holding",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "holding"
  },
  {
    "label": "FAnimPhysWindData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimPhysWindData"
  },
  {
    "label": "FAnimPhysRigidBody",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhysRigidBody"
  },
  {
    "label": "for",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "for"
  },
  {
    "label": "FAnimPhysLimit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhysLimit"
  },
  {
    "label": "FAnimPhysAngularLimit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhysAngularLimit"
  },
  {
    "label": "FAnimPhysLinearLimit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhysLinearLimit"
  },
  {
    "label": "FAnimPhysSpring",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimPhysSpring"
  },
  {
    "label": "FAnimPhys",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAnimPhys"
  },
  {
    "label": "MakeBox()",
    "kind": "Method",
    "detail": "Function (FAnimPhysShape)",
    "insertText": "MakeBox(const FVector& Extents)"
  },
  {
    "label": "FAnimPhysShape()",
    "kind": "Method",
    "detail": "Function (ENGINE_API)",
    "insertText": "FAnimPhysShape()"
  },
  {
    "label": "FAnimPhysShape()",
    "kind": "Method",
    "detail": "Function (ENGINE_API)",
    "insertText": "FAnimPhysShape(TArray<FVector>& InVertices, TArray<FIntVector>& InTriangles)"
  },
  {
    "label": "TransformVerts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TransformVerts(FTransform& InTransform)"
  },
  {
    "label": "FAnimPhysPose()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "FAnimPhysPose(InversePosition, InverseOrient)"
  },
  {
    "label": "FAnimPhysPose()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "FAnimPhysPose(*this *InPose.Position, Orientation * InPose.Orientation)"
  },
  {
    "label": "NewNormal()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "NewNormal(InPlane.X, InPlane.Y, InPlane.Z)"
  },
  {
    "label": "FAnimPhysState()",
    "kind": "Method",
    "detail": "Function (ENGINE_API)",
    "insertText": "FAnimPhysState()"
  },
  {
    "label": "FAnimPhysState()",
    "kind": "Method",
    "detail": "Function (ENGINE_API)",
    "insertText": "FAnimPhysState(const FVector& InPosition, const FQuat& InOrient, const FVector& InLinearMomentum, const FVector& InAngularMomentum)"
  },
  {
    "label": "FAnimPhysRigidBody()",
    "kind": "Method",
    "detail": "Function (ENGINE_API)",
    "insertText": "FAnimPhysRigidBody(TArray<FAnimPhysShape>& InShapes, const FVector& InPosition)"
  },
  {
    "label": "Spin()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "Spin()"
  },
  {
    "label": "FAnimPhysLimit()",
    "kind": "Method",
    "detail": "Function (ENGINE_API)",
    "insertText": "FAnimPhysLimit(FAnimPhysRigidBody* InFirstBody, FAnimPhysRigidBody* InSecondBody)"
  },
  {
    "label": "FAnimPhysAngularLimit()",
    "kind": "Method",
    "detail": "Function (ENGINE_API)",
    "insertText": "FAnimPhysAngularLimit()"
  },
  {
    "label": "FAnimPhysAngularLimit()",
    "kind": "Method",
    "detail": "Function (ENGINE_API)",
    "insertText": "FAnimPhysAngularLimit(FAnimPhysRigidBody* InFirstBody, FAnimPhysRigidBody* InSecondBody, const FVector& InWorldSpaceAxis, float InTargetSpin = 0, float InMinimumTorque = -MAX_flt, float InMaximumTorque = MAX_flt)"
  },
  {
    "label": "RemoveBias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveBias()"
  },
  {
    "label": "Iter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Iter(float DeltaTime)"
  },
  {
    "label": "UpdateCachedData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateCachedData()"
  },
  {
    "label": "FAnimPhysLinearLimit()",
    "kind": "Method",
    "detail": "Function (ENGINE_API)",
    "insertText": "FAnimPhysLinearLimit()"
  },
  {
    "label": "RemoveBias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveBias()"
  },
  {
    "label": "Iter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Iter(float DetlaTime)"
  },
  {
    "label": "UpdateCachedData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateCachedData()"
  },
  {
    "label": "ApplyForces()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyForces(float DeltaTime)"
  },
  {
    "label": "CalculateVolume()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "CalculateVolume(const TArray<FVector>& InVertices, const TArray<FIntVector>& InTriangles)"
  },
  {
    "label": "CalculateVolume()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "CalculateVolume(const TArray<FAnimPhysShape>& InShapes)"
  },
  {
    "label": "CalculateCenterOfMass()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "CalculateCenterOfMass(const TArray<FVector>& InVertices, const TArray<FIntVector>& InTriangles)"
  },
  {
    "label": "CalculateCenterOfMass()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "CalculateCenterOfMass(const TArray<FAnimPhysShape>& InShapes)"
  },
  {
    "label": "CalculateInertia()",
    "kind": "Method",
    "detail": "Function (FMatrix)",
    "insertText": "CalculateInertia(const TArray<FVector>& InVertices, const TArray<FIntVector>& InTriangles, const FVector& InCenterOfMass)"
  },
  {
    "label": "CalculateInertia()",
    "kind": "Method",
    "detail": "Function (FMatrix)",
    "insertText": "CalculateInertia(const TArray<FAnimPhysShape>& InShapes, const FVector& InCenterOfMass)"
  },
  {
    "label": "ScaleRigidBodyMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScaleRigidBodyMass(FAnimPhysRigidBody* InOutRigidBody, float Scale)"
  },
  {
    "label": "ApplyImpulse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyImpulse(FAnimPhysRigidBody* InOutRigidBody, const FVector& InWorldOrientedImpactPoint, const FVector& InImpulse)"
  },
  {
    "label": "PhysicsUpdate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PhysicsUpdate(float DeltaTime, TArray<FAnimPhysRigidBody*>& Bodies, TArray<FAnimPhysLinearLimit>& LinearLimits, TArray<FAnimPhysAngularLimit>& AngularLimits, TArray<FAnimPhysSpring>& Springs, const FVector& GravityDirection, const FVector& ExternalForce, const FVector& ExternalLinearAcc, int32 NumPreIterations = 8, int32 NumPostIterations = 2)"
  },
  {
    "label": "ConstrainAlongDirection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainAlongDirection(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody *FirstBody, const FVector& FirstPosition, FAnimPhysRigidBody *SecondBody, const FVector& SecondPosition, const FVector& AxisToConstrain, const FVector2D Limits, float MinimumForce = -MAX_flt, float MaximumForce = MAX_flt)"
  },
  {
    "label": "ConstrainPositionNailed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainPositionNailed(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody *FirstBody, const FVector& FirstPosition, FAnimPhysRigidBody *SecondBody, const FVector& SecondPosition)"
  },
  {
    "label": "ConstrainPositionPrismatic()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainPositionPrismatic(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody* FirstBody, const FVector& FirstPosition, FAnimPhysRigidBody* SecondBody, const FVector& SecondPosition, const FQuat& PrismRotation, const FVector& LimitsMin, const FVector& LimitsMax)"
  },
  {
    "label": "ConstrainAngularRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainAngularRange(float DeltaTime, TArray<FAnimPhysAngularLimit>& LimitContainer, FAnimPhysRigidBody *FirstBody, FAnimPhysRigidBody *SecondBody, const FQuat& JointFrame, AnimPhysTwistAxis TwistAxis, const FVector& JointLimitMin, const FVector& JointLimitMax, float InJointBias)"
  },
  {
    "label": "ConstrainConeAngle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainConeAngle(float DeltaTime, TArray<FAnimPhysAngularLimit>& LimitContainer, FAnimPhysRigidBody* FirstBody, const FVector& Normal0, FAnimPhysRigidBody* SecondBody, const FVector& Normal1, float LimitAngle, float InJointBias)"
  },
  {
    "label": "ConstrainPlanar()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainPlanar(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody* Body, const FTransform& PlaneTransform)"
  },
  {
    "label": "ConstrainSphericalInner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainSphericalInner(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody* Body, const FTransform& SphereTransform, float SphereRadius)"
  },
  {
    "label": "ConstrainSphericalOuter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainSphericalOuter(float DeltaTime, TArray<FAnimPhysLinearLimit>& LimitContainer, FAnimPhysRigidBody* Body, const FTransform& SphereTransform, float SphereRadius)"
  },
  {
    "label": "CreateSpring()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateSpring(TArray<FAnimPhysSpring>& SpringContainer, FAnimPhysRigidBody* Body0, FVector Position0, FAnimPhysRigidBody* Body1, FVector Position1)"
  },
  {
    "label": "DiffQ()",
    "kind": "Method",
    "detail": "Function (FQuat)",
    "insertText": "DiffQ(const FQuat& InOrientation, const FMatrix &InInverseTensor, const FVector& InAngularMomentum)"
  },
  {
    "label": "UpdateOrientRK()",
    "kind": "Method",
    "detail": "Function (FQuat)",
    "insertText": "UpdateOrientRK(const FQuat& InOrient, const FMatrix& InInverseTensor, const FVector& InAngularMomentum, float InDeltaTime)"
  },
  {
    "label": "InitializeBodyVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeBodyVelocity(float DeltaTime, FAnimPhysRigidBody *InBody, const FVector& GravityDirection)"
  },
  {
    "label": "CalculateNextPose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculateNextPose(float DeltaTime, FAnimPhysRigidBody* InBody)"
  },
  {
    "label": "UpdatePose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdatePose(FAnimPhysRigidBody* InBody)"
  },
  {
    "label": "ConstrainAngularRangeInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstrainAngularRangeInternal(float DeltaTime, TArray<FAnimPhysAngularLimit>& LimitContainer, FAnimPhysRigidBody *FirstBody, const FQuat& JointFrame0, FAnimPhysRigidBody *SecondBody, const FQuat& JointFrame1, AnimPhysTwistAxis TwistAxis, const FVector& InJointLimitMin, const FVector& InJointLimitMax, float InJointBias)"
  }
]