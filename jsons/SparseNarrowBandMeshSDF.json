[
  {
    "label": "TriangleMeshType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TriangleMeshType"
  },
  {
    "label": "TSparseNarrowBandMeshSDF",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSparseNarrowBandMeshSDF"
  },
  {
    "label": "EComputeModes",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EComputeModes"
  },
  {
    "label": "EInsideModes",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EInsideModes"
  },
  {
    "label": "FScatterCounter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FScatterCounter"
  },
  {
    "label": "FTriIDBlockGrid",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTriIDBlockGrid"
  },
  {
    "label": "FTriBBox",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTriBBox"
  },
  {
    "label": "FAtomicGrid3i",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAtomicGrid3i"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" MathUtil . h \" # include \" MeshQueries . h \" # include \" Util / IndexUtil . h \" # include \" Spatial / MeshAABBTree3 . h \" # include \" Spatial / BlockedLayout3 . h \" # include \" Spatial / BlockedDenseGrid3 . h \" # include \" Async / ParallelFor . h \" # include \" Implicit / GridInterpolant . h \" # include \" Implicit / SDFCalculationUtils . h \" # include \" Containers / StaticArray . h \" # include<atomic> namespace UE { namespace Geometry { template<class TriangleMeshType> class TSparseNarrowBandMeshSDF { public : const TriangleMeshType* Mesh = nullptr ; TMeshAABBTree3<TriangleMeshType>* Spatial = nullptr ; TUniqueFunction<)",
    "insertText": "bool(const FVector3d&)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (float CellSize ; int ExactBandWidth = 1 ; FVector3d ExpandBounds =)",
    "insertText": "Zero()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (bool bUseParallel = true ; int ApproxMaxCellsPerDimension = 4 0 9 6 ; enum EComputeModes { NarrowBandOnly = 1,NarrowBand_SpatialFloodFill = 2 } ; EComputeModes ComputeMode = EComputeModes::NarrowBandOnly ; double NarrowBandMaxDistance = 0 ; bool bComputeSigns = true ; enum EInsideModes { CrossingCount = 0,WindingCount = 1 } ; EInsideModes InsideMode = EInsideModes::WindingCount ; bool bWantClosestTriGrid = false ; bool bWantIntersectionsGrid = true ; TFunction<)",
    "insertText": "bool()> CancelF = []()"
  },
  {
    "label": "GetBlockDimensions()",
    "kind": "Method",
    "detail": "Function (const FVector3i BlockDims =)",
    "insertText": "GetBlockDimensions()"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (const int32 NumBlocks = BlockDims [ 0 ]* BlockDims [ 1 ]* BlockDims [ 2 ] ; NumObjectsPerBlock .)",
    "insertText": "SetNum(NumBlocks)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (std::atomic<int>* PerBlock = NumObjectsPerBlock .)",
    "insertText": "GetData()"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(NumBlocks, [PerBlock](int32 id) { PerBlock[id] = 0; }, !bInitParallel)"
  },
  {
    "label": "AtomicIncrement()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AtomicIncrement(const int32 BlockIndex)"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (NumObjects .)",
    "insertText": "fetch_add(1, std::memory_order_relaxed)"
  },
  {
    "label": "FTriIDBlockGrid()",
    "kind": "Method",
    "detail": "Function (} TArray<std::atomic<int>> NumObjectsPerBlock ; } ; struct FTriIDBlockGrid : public TBlockedGrid3Layout<FBlockedGrid3f::BlockSize> { typedef TBlockedGrid3Layout<FBlockedGrid3f::BlockSize> MyLayout ;)",
    "insertText": "FTriIDBlockGrid(const FScatterCounter& TriCounter, bool bInitParallel) : MyLayout(TriCounter.GetDimensions())"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(NumBlocks, [this, SizePerBlock, PerBlockCounted, &TriCounter](int32 id) { TArray<int32>& Tris = TrisInBlock[id]; const int32 n = PerBlockCounted[id]; Tris.AddUninitialized(n); SizePerBlock[id] = 0; }, !bInitParallel)"
  },
  {
    "label": "AddTriID()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddTriID(const int32& BlockIndex, const int32& TriId)"
  },
  {
    "label": "GetOccupiedBlockIDs()",
    "kind": "Method",
    "detail": "Function (} TArray<int32>)",
    "insertText": "GetOccupiedBlockIDs()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 NumBlocks = TrisInBlock .)",
    "insertText": "Num()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 NumBlocksWithTris = 0 ;)",
    "insertText": "for(int32 i = 0; i < NumBlocks; ++i)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (NumBlocksWithTris + + ; } } TArray<int32> TmpArray ; TmpArray .)",
    "insertText": "Reserve(NumBlocksWithTris)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TmpArray .)",
    "insertText": "Add(i)"
  },
  {
    "label": "FVector3i()",
    "kind": "Method",
    "detail": "Function (} } return TmpArray ; } ; TArray<std::atomic<int>> PerBlockNum ; TArray<TArray<int32>> TrisInBlock ; } ; struct FTriBBox { FVector3i BoxMin =)",
    "insertText": "FVector3i(INT32_MAX, INT32_MAX, INT32_MAX)"
  },
  {
    "label": "FVector3i()",
    "kind": "Method",
    "detail": "Function (FVector3i BoxMax =)",
    "insertText": "FVector3i(INT32_MIN, INT32_MIN, INT32_MIN)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Clamp(const FVector3i& OtherMin, const FVector3i& OtherMax)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BoxMin [ 0 ] =)",
    "insertText": "Clamp(BoxMin[0], OtherMin[0], OtherMax[0])"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BoxMin [ 1 ] =)",
    "insertText": "Clamp(BoxMin[1], OtherMin[1], OtherMax[1])"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BoxMin [ 2 ] =)",
    "insertText": "Clamp(BoxMin[2], OtherMin[2], OtherMax[2])"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BoxMax [ 0 ] =)",
    "insertText": "Clamp(BoxMax[0], OtherMin[0], OtherMax[0])"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BoxMax [ 1 ] =)",
    "insertText": "Clamp(BoxMax[1], OtherMin[1], OtherMax[1])"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BoxMax [ 2 ] =)",
    "insertText": "Clamp(BoxMax[2], OtherMin[2], OtherMax[2])"
  },
  {
    "label": "TSparseNarrowBandMeshSDF()",
    "kind": "Method",
    "detail": "Function (} } ; public :)",
    "insertText": "TSparseNarrowBandMeshSDF(const TriangleMeshType* Mesh = nullptr, float CellSize = 1.f, TMeshAABBTree3<TriangleMeshType>* Spatial = nullptr ) : Mesh(Mesh), Spatial(Spatial), CellSize(CellSize)"
  },
  {
    "label": "MakeInterpolant()",
    "kind": "Method",
    "detail": "Function (} TTriLinearGridInterpolant<TSparseNarrowBandMeshSDF>)",
    "insertText": "MakeInterpolant()"
  },
  {
    "label": "ShouldUseSpatial()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ShouldUseSpatial(int32 ExactCells, double CellSize, double AvgEdgeLen)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (ExactBandWidth =)",
    "insertText": "Max(ApproxMaxCellsPerDimension/2-1, 1)"
  },
  {
    "label": "MaxElement()",
    "kind": "Method",
    "detail": "Function (} double MaxDim =)",
    "insertText": "MaxElement(Bounds.Max - Bounds.Min + ExpandBounds * 2.0)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (CellSize =)",
    "insertText": "float(MaxDim / (ApproxMaxCellsPerDimension - 2 * ExactBandWidth))"
  },
  {
    "label": "fBufferWidth()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fBufferWidth(float)FMath::Max(fBufferWidth, float(NarrowBandMaxDistance))"
  },
  {
    "label": "GridOrigin()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "GridOrigin(FVector3f)Bounds.Min - fBufferWidth * FVector3f::One() - (FVector3f)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (FVector3f)",
    "insertText": "max(FVector3f)Bounds.Max + fBufferWidth * FVector3f::One() + (FVector3f)"
  },
  {
    "label": "NI()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "NI(int32)((max.X - GridOrigin.X) / CellSize)"
  },
  {
    "label": "NJ()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "NJ(int32)((max.Y - GridOrigin.Y) / CellSize)"
  },
  {
    "label": "NK()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "NK(int32)((max.Z - GridOrigin.Z) / CellSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(Spatial != nullptr)"
  },
  {
    "label": "make_level_set3_parallel_spatial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "make_level_set3_parallel_spatial(GridOrigin, CellSize, NI, NJ, NK, Grid, ExactBandWidth)"
  },
  {
    "label": "make_level_set3_parallel()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "make_level_set3_parallel(GridOrigin, CellSize, NI, NJ, NK, Grid, ExactBandWidth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(bComputeSigns)"
  },
  {
    "label": "update_signs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "update_signs(GridOrigin, CellSize, NI, NJ, NK, Grid, IntersectionsGrid)"
  },
  {
    "label": "CleanupUnwanted()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CleanupUnwanted()"
  },
  {
    "label": "Dimensions()",
    "kind": "Method",
    "detail": "Function (} FVector3i)",
    "insertText": "Dimensions()"
  },
  {
    "label": "GetClosestTriGrid()",
    "kind": "Method",
    "detail": "Function (} const FBlockedGrid3i&)",
    "insertText": "GetClosestTriGrid()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "operator(const FVector3i& ijk)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetValue(const FVector3i& ijk)"
  },
  {
    "label": "CellCenter()",
    "kind": "Method",
    "detail": "Function (} FVector3f)",
    "insertText": "CellCenter(int32 I, int32 J, int32 K)"
  },
  {
    "label": "inclusive_loop_3d()",
    "kind": "Method",
    "detail": "Function (} private : template<FunctorType> void)",
    "insertText": "inclusive_loop_3d(const FVector3i& start, const FVector3i& inclusive_end, FunctorType func)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FVector3i ijk ;)",
    "insertText": "for(ijk[2] = start[2]; ijk[2] <= inclusive_end[2]; ++ijk[2])"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "func(ijk)"
  },
  {
    "label": "cell_center()",
    "kind": "Method",
    "detail": "Function (} } } } FVector3f)",
    "insertText": "cell_center(const FVector3i& IJK)"
  },
  {
    "label": "upper_bound()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "upper_bound(const FVector3i& GridDimensions, float DX)"
  },
  {
    "label": "update_signs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "update_signs(const FVector3f Origin, float DX, int32 NI, int32 NJ, int32 NK, FBlockedGrid3f& Distances, FBlockedGrid3i& IntersectionCountGrid)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (typedef FBlockedGrid3f::BlockData3Type FloatBlockData3Type ;)",
    "insertText": "if(IsInsideFunction)"
  },
  {
    "label": "GetAllocatedBlocks()",
    "kind": "Method",
    "detail": "Function (TArray<FloatBlockData3Type*> DistanceBlocks = Distances .)",
    "insertText": "GetAllocatedBlocks()"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(NumBlocksAllocated, [this, &DistanceBlocks, &Distances, Origin, DX](int32 AllocatedBlockIdx) { FloatBlockData3Type& DistanceBlock = *DistanceBlocks[AllocatedBlockIdx]; const FVector3i BlockIJK = Distances.BlockIndexToBlockIJK(DistanceBlock.Id); const FVector3i BlockOrigin = FloatBlockData3Type::BlockSize * BlockIJK; const int32 ElemCount = FloatBlockData3Type::ElemCount; for (int32 LocalIndex = 0; LocalIndex < ElemCount; ++LocalIndex) { const FVector3i GridCoord = DistanceBlock.ToLocalIJK(LocalIndex) + BlockOrigin; const FVector3d Pos((float)GridCoord.X * DX + Origin[0], (float)GridCoord.Y * DX + Origin[1], (float)GridCoord.Z * DX + Origin[2]); if (this->IsInsideFunction(Pos)) { float& dist = DistanceBlock.At(LocalIndex); dist *= -1; } } }, !this->bUseParallel)"
  },
  {
    "label": "BlockCenter()",
    "kind": "Method",
    "detail": "Function (const FVector3d)",
    "insertText": "BlockCenter(0.5 * DX * (double)FloatBlockData3Type::BlockSize)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(NumBlocks, [this, &Distances, Origin, DX, BlockCenter](int32 BlockIndex) { const FVector3i BlockIJK = Distances.BlockIndexToBlockIJK(BlockIndex); if (!Distances.IsBlockAllocated(BlockIJK)) { const FVector3i BlockOrigin = FloatBlockData3Type::BlockSize * BlockIJK; const FVector3d BlockOriginPos((float)BlockOrigin.X * DX + Origin.X, (float)BlockOrigin.Y * DX + Origin.Y, (float)BlockOrigin.Z * DX + Origin.Z); const FVector3d Pos = BlockOriginPos + BlockCenter; if (this->IsInsideFunction(Pos)) { Distances.ProcessBlockDefaultValue(BlockIJK, [](float& value) {value = -value; }); } } }, !this->bUseParallel)"
  },
  {
    "label": "compute_intersections()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "compute_intersections(Origin, DX, NI, NJ, NK, Distances, IntersectionCountGrid)"
  },
  {
    "label": "compute_tri_bboxes()",
    "kind": "Method",
    "detail": "Function (} } TArray<FTriBBox>)",
    "insertText": "compute_tri_bboxes(FVector3f Origin, float DX, int32 NI, int32 NJ, int32 NK, int32 ExactBand)"
  },
  {
    "label": "org()",
    "kind": "Method",
    "detail": "Function (const double invdx = 1 . 0 / DX ; const FVector3d)",
    "insertText": "org((double)Origin[0], (double)Origin[1], (double)Origin[2])"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<FTriBBox> TriBBoxes ; TriBBoxes .)",
    "insertText": "SetNum(Mesh->MaxTriangleID())"
  },
  {
    "label": "org()",
    "kind": "Method",
    "detail": "Function (auto ComputeTriBoundingBox = [ this,ExactBand,NI,NJ,NK,invdx,)",
    "insertText": "org(const int32 TID, FVector3i& BBMin, FVector3i& BBMax)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (FVector3d xp =)",
    "insertText": "Zero(), xq = FVector3d::Zero(), xr = FVector3d::Zero()"
  },
  {
    "label": "GetTriVertices()",
    "kind": "Method",
    "detail": "Function (Mesh ->)",
    "insertText": "GetTriVertices(TID, xp, xq, xr)"
  },
  {
    "label": "fp()",
    "kind": "Method",
    "detail": "Function (const FVector3d)",
    "insertText": "fp(xp - org)"
  },
  {
    "label": "fq()",
    "kind": "Method",
    "detail": "Function (const FVector3d)",
    "insertText": "fq(xq - org)"
  },
  {
    "label": "fr()",
    "kind": "Method",
    "detail": "Function (const FVector3d)",
    "insertText": "fr(xr - org)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BBMin [ 0 ] =)",
    "insertText": "Clamp(((int)FMath::Min3(fp[0], fq[0], fr[0])) - ExactBand, 0, NI - 1)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BBMin [ 1 ] =)",
    "insertText": "Clamp(((int)FMath::Min3(fp[1], fq[1], fr[1])) - ExactBand, 0, NJ - 1)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BBMin [ 2 ] =)",
    "insertText": "Clamp(((int)FMath::Min3(fp[2], fq[2], fr[2])) - ExactBand, 0, NK - 1)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BBMax [ 0 ] =)",
    "insertText": "Clamp(((int)FMath::Max3(fp[0], fq[0], fr[0])) + ExactBand + 1, 0, NI - 1)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BBMax [ 1 ] =)",
    "insertText": "Clamp(((int)FMath::Max3(fp[1], fq[1], fr[1])) + ExactBand + 1, 0, NJ - 1)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BBMax [ 2 ] =)",
    "insertText": "Clamp(((int)FMath::Max3(fp[2], fq[2], fr[2])) + ExactBand + 1, 0, NK - 1)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "ParallelFor(Mesh->MaxTriangleID(), [this, &ComputeTriBoundingBox, &TriBBoxes](int TID) { if (!Mesh->IsTriangle(TID)) return; FVector3i& BoxMin = TriBBoxes.GetData()[TID].BoxMin; FVector3i& BoxMax = TriBBoxes.GetData()[TID].BoxMax; ComputeTriBoundingBox(TID, BoxMin, BoxMax); })"
  },
  {
    "label": "TriCounter()",
    "kind": "Method",
    "detail": "Function (bool bCancel = false ; FScatterCounter)",
    "insertText": "TriCounter(FVector3i(NI, NJ, NK), this->bUseParallel)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(NumBBoxes, [this, &TriBBoxes, &TriCounter, &bCancel](const int32 TID) { constexpr int32 BlockSize = FBlockedGrid3f::BlockSize; const FTriBBox& TriBBox = TriBBoxes.GetData()[TID]; if (!TriBBox.IsValid()) { return; } if (TID % 100 == 0) { bCancel = this->CancelF(); } if (bCancel) { return; } FVector3i box_min(TriBBox.BoxMin[0] / BlockSize, TriBBox.BoxMin[1] / BlockSize, TriBBox.BoxMin[2] / BlockSize); FVector3i box_max(TriBBox.BoxMax[0] / BlockSize, TriBBox.BoxMax[1] / BlockSize, TriBBox.BoxMax[2] / BlockSize); inclusive_loop_3d(box_min, box_max, [&TriCounter](const FVector3i& block_ijk) { const int32 BlockIndex = TriCounter.BlockIJKToBlockIndex(block_ijk); TriCounter.AtomicIncrement(BlockIndex); }); }, !this->bUseParallel)"
  },
  {
    "label": "TriIDBlockGrid()",
    "kind": "Method",
    "detail": "Function (} FTriIDBlockGrid)",
    "insertText": "TriIDBlockGrid(TriCounter, this->bUseParallel)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(NumBBoxes, [this, &TriBBoxes, &TriIDBlockGrid, &bCancel](const int32 TID) { constexpr int32 BlockSize = FBlockedGrid3f::BlockSize; const FTriBBox& TriBBox = TriBBoxes.GetData()[TID]; if (!TriBBox.IsValid()) { return; } if (TID % 100 == 0) { bCancel = this->CancelF(); } if (bCancel) { return; } FVector3i box_min(TriBBox.BoxMin[0] / BlockSize, TriBBox.BoxMin[1] / BlockSize, TriBBox.BoxMin[2] / BlockSize); FVector3i box_max(TriBBox.BoxMax[0] / BlockSize, TriBBox.BoxMax[1] / BlockSize, TriBBox.BoxMax[2] / BlockSize); inclusive_loop_3d(box_min, box_max, [&TriIDBlockGrid, TID](const FVector3i& block_ijk) { const int32 BlockIndex = TriIDBlockGrid.BlockIJKToBlockIndex(block_ijk); TriIDBlockGrid.AddTriID(BlockIndex, TID); }); }, !this->bUseParallel)"
  },
  {
    "label": "make_level_set3_parallel()",
    "kind": "Method",
    "detail": "Function (} return TriIDBlockGrid ; } void)",
    "insertText": "make_level_set3_parallel(const FVector3f Origin, float DX, int32 NI, int32 NJ, int32 NK, FBlockedGrid3f& DistanceGrid, int32 ExactBand)"
  },
  {
    "label": "upper_bound()",
    "kind": "Method",
    "detail": "Function (const float upper_bound_value =)",
    "insertText": "upper_bound(FVector3i(NI, NJ, NK), DX)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (DistanceGrid .)",
    "insertText": "Reset(NI, NJ, NK, upper_bound_value)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (ClosestTriGrid .)",
    "insertText": "Reset(NI, NJ, NK, -1)"
  },
  {
    "label": "compute_tri_bboxes()",
    "kind": "Method",
    "detail": "Function (const TArray<FTriBBox> TriBBoxes =)",
    "insertText": "compute_tri_bboxes(Origin, DX, NI, NJ, NK, ExactBand)"
  },
  {
    "label": "scatter_tris()",
    "kind": "Method",
    "detail": "Function (const FTriIDBlockGrid TIDBlockGrid =)",
    "insertText": "scatter_tris(TriBBoxes, NI, NJ, NK)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(NumOccupied, [this, &TriBBoxes, &OccupiedBlocks, &TIDBlockGrid, &DistanceGrid, ExactBand, org, invdx, DX](const int32& OccupiedId) { const FVector3i GridDimensions = DistanceGrid.GetDimensions(); const int32 BlockIndex = OccupiedBlocks.GetData()[OccupiedId]; const TArray<int32>& TrisToRasterize = TIDBlockGrid.TrisInBlock[BlockIndex]; const FVector3i BlockIJK = DistanceGrid.BlockIndexToBlockIJK(BlockIndex); FBlockedGrid3f::BlockData3Type& DistanceBlock = DistanceGrid.TouchBlockData(BlockIJK); FBlockedGrid3i::BlockData3Type& ClosestTriBlock = ClosestTriGrid.TouchBlockData(BlockIJK); const FVector3i BlockMin = FBlockedGrid3f::BlockSize * BlockIJK; const FVector3i BlockMax( FMath::Min(BlockMin[0] + FBlockedGrid3f::BlockSize, GridDimensions[0]) -1, FMath::Min(BlockMin[1] + FBlockedGrid3f::BlockSize, GridDimensions[1]) -1, FMath::Min(BlockMin[2] + FBlockedGrid3f::BlockSize, GridDimensions[2]) -1); for (const int32 TID : TrisToRasterize) { FVector3d xp = FVector3d::Zero(), xq = FVector3d::Zero(), xr = FVector3d::Zero(); Mesh->GetTriVertices(TID, xp, xq, xr); const FVector3d fp = (xp - org) * invdx; const FVector3d fq = (xq - org) * invdx; const FVector3d fr = (xr - org) * invdx; FTriBBox tri_bbox = TriBBoxes.GetData()[TID]; tri_bbox.Clamp(BlockMin, BlockMax); inclusive_loop_3d(tri_bbox.BoxMin, tri_bbox.BoxMax, [&](const FVector3i& ijk) { const FVector3i local_coords = ijk - BlockMin; const int32 local_index = DistanceBlock.ToLinear(local_coords[0], local_coords[1], local_coords[2]); const FVector3d cellpos((double)ijk[0], (double)ijk[1], (double)ijk[2]); float d = float(DX * PointTriangleDistance(cellpos, fp, fq, fr)); float& grid_dist = DistanceBlock.At(local_index); if (d < grid_dist) { grid_dist = d; ClosestTriBlock.At(local_index) = TID; } }); } }, !this->bUseParallel)"
  },
  {
    "label": "make_level_set3_parallel_spatial()",
    "kind": "Method",
    "detail": "Function (} ; } void)",
    "insertText": "make_level_set3_parallel_spatial(FVector3f Origin, float DX, int32 NI, int32 NJ, int32 NK, FBlockedGrid3f& DistanceGrid, int32 ExactBand)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(NumOccupied, [this, &Origin, &OccupiedBlocks, &TIDBlockGrid, &DistanceGrid, &TriBBoxes, DX, upper_bound_value, max_dist](const int32& OccupiedId) { const FVector3i GridDimensions = DistanceGrid.GetDimensions(); const int32 BlockIndex = OccupiedBlocks.GetData()[OccupiedId]; const TArray<int32>& TrisToRasterize = TIDBlockGrid.TrisInBlock[BlockIndex]; const FVector3i BlockIJK = DistanceGrid.BlockIndexToBlockIJK(BlockIndex); const FVector3i BlockOrigin = FBlockedGrid3f::BlockData3Type::BlockSize * BlockIJK; FBlockedGrid3f::BlockData3Type& DistanceBlock = DistanceGrid.TouchBlockData(BlockIJK); FBlockedGrid3i::BlockData3Type& ClosestTriBlock = ClosestTriGrid.TouchBlockData(BlockIJK); FBlockedGrid3b::BlockData3Type BitBlock(false, -1); const FVector3i BlockMin = FBlockedGrid3f::BlockSize * BlockIJK; const FVector3i BlockMax( FMath::Min(BlockMin[0] + FBlockedGrid3f::BlockSize, GridDimensions[0]) - 1, FMath::Min(BlockMin[1] + FBlockedGrid3f::BlockSize, GridDimensions[1]) - 1, FMath::Min(BlockMin[2] + FBlockedGrid3f::BlockSize, GridDimensions[2]) - 1); for (const int32 TID : TrisToRasterize) { FVector3d xp = FVector3d::Zero(), xq = FVector3d::Zero(), xr = FVector3d::Zero(); Mesh->GetTriVertices(TID, xp, xq, xr); FTriBBox tri_bbox = TriBBoxes.GetData()[TID]; tri_bbox.Clamp(BlockMin, BlockMax); inclusive_loop_3d(tri_bbox.BoxMin, tri_bbox.BoxMax, [&](const FVector3i& ijk) { const FVector3i local_coords = ijk - BlockMin; const int32 local_index = DistanceBlock.ToLinear(local_coords[0], local_coords[1], local_coords[2]); BitBlock.At(local_index) = true; }); } for (int32 local_index = 0; local_index < FBlockedGrid3f::BlockData3Type::ElemCount; ++local_index) { if (BitBlock.At(local_index) == true) { const FVector3i GridCoord = DistanceBlock.ToLocalIJK(local_index) + BlockOrigin; const FVector3d Pos((float)GridCoord.X* DX + Origin[0], (float)GridCoord.Y* DX + Origin[1], (float)GridCoord.Z* DX + Origin[2]); double dsqr; int near_tid = this->Spatial->FindNearestTriangle(Pos, dsqr, max_dist); if (near_tid == IndexConstants::InvalidID) { DistanceBlock.At(local_index) = upper_bound_value; } else { const float dist = (float)FMath::Sqrt(dsqr); DistanceBlock.At(local_index) = dist; ClosestTriBlock.At(local_index) = near_tid; } } } }, !this->bUseParallel)"
  },
  {
    "label": "make_level_set3_parallel_floodfill()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "make_level_set3_parallel_floodfill(FVector3f Origin, float DX, int32 NI, int32 NJ, int32 NK, FBlockedGrid3f& DistanceGrid, double NarrowBandWidth)"
  },
  {
    "label": "ox()",
    "kind": "Method",
    "detail": "Function (typedef FBlockedGrid3f::BlockData3Type FloatBlockData3Type ; typedef FBlockedGrid3b::BlockData3Type BoolBlockData3Type ; typedef FBlockedGrid3i::BlockData3Type IntBlockData3Type ; typedef BoolBlockData3Type::BitArrayConstIterator BitArrayConstIter ; const double)",
    "insertText": "ox(double)Origin[0], oy = (double)Origin[1], oz = (double)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<FCriticalSection> BlockLocks ; BlockLocks .)",
    "insertText": "SetNum(DistanceGrid.GetNumBlocks())"
  },
  {
    "label": "BlockLocks()",
    "kind": "Method",
    "detail": "Function (FCriticalSection&)",
    "insertText": "BlockLocks(int32 block_id)"
  },
  {
    "label": "VisitedGrid()",
    "kind": "Method",
    "detail": "Function (} ; { FBlockedGrid3b)",
    "insertText": "VisitedGrid(NI, NJ, NK, false)"
  },
  {
    "label": "FBlockedGrid3b()",
    "kind": "Method",
    "detail": "Function (int32 CurCandidateID = 0 ; FBlockedGrid3b CandidateGrids [ 2 ] = {)",
    "insertText": "FBlockedGrid3b(NI, NJ, NK, false), FBlockedGrid3b(NI, NJ, NK, false)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function ({ FBlockedGrid3b& CandidateGrid = CandidateGrids [ CurCandidateID ] ; bool bCancel = false ;)",
    "insertText": "ParallelFor(Mesh->MaxVertexID(), [this, &bCancel, &CandidateGrid, &BlockLockProvider, NI, NJ, NK, Origin, DX](const int32 VID) { const double ox = (double)Origin[0], oy = (double)Origin[1], oz = (double)Origin[2]; const double invdx = 1.0 / DX; if (!Mesh->IsVertex(VID)) { return; } if (VID % 1000 == 0) { bCancel = this->CancelF(); } if (bCancel) { return; } const FVector3d v = Mesh->GetVertex(VID); const double fi = (v.X - ox) * invdx, fj = (v.Y - oy) * invdx, fk = (v.Z - oz) * invdx; const FVector3i Idx( FMath::Clamp((int32)fi, 0, NI - 1), FMath::Clamp((int32)fj, 0, NJ - 1), FMath::Clamp((int32)fk, 0, NK - 1)); CandidateGrid.SetValueWithLock(Idx.X, Idx.Y, Idx.Z, true, BlockLockProvider); }, !this->bUseParallel)"
  },
  {
    "label": "GetAllocatedBlocks()",
    "kind": "Method",
    "detail": "Function (int32 NumCandidateBlocks = CandidateGrids [ CurCandidateID ] .)",
    "insertText": "GetAllocatedBlocks().Num()"
  },
  {
    "label": "PreAllocateFromSourceGrid()",
    "kind": "Method",
    "detail": "Function (const FBlockedGrid3b& CandidateGrid = CandidateGrids [ CurCandidateID ] ; FBlockedGrid3b& NextCandidateGrid = CandidateGrids [ 1 - CurCandidateID ] ; VisitedGrid .)",
    "insertText": "PreAllocateFromSourceGrid(CandidateGrid)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (NextCandidateGrid .)",
    "insertText": "Reset(NI, NJ, NK, false)"
  },
  {
    "label": "GetAllocatedConstBlocks()",
    "kind": "Method",
    "detail": "Function (TArray<const BoolBlockData3Type*> CandidateBlocks = CandidateGrid .)",
    "insertText": "GetAllocatedConstBlocks()"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(NumCandidateBlocks, [this, max_query_dist, &BlockLockProvider, &VisitedGrid, &DistanceGrid, &NextCandidateGrid, &CandidateBlocks](const int32 cb) { const BoolBlockData3Type& CandidateBlock = *CandidateBlocks[cb]; const int32 BlockIdx = CandidateBlock.Id; FloatBlockData3Type& DistanceBlock = *DistanceGrid.GetBlockData(BlockIdx); IntBlockData3Type& ClosestTriBlock = *ClosestTriGrid.GetBlockData(BlockIdx); BoolBlockData3Type& VistedBlock = *VisitedGrid.GetBlockData(BlockIdx); const FVector3i BlockIJK = DistanceGrid.BlockIndexToBlockIJK(BlockIdx); const FVector3i BlockOrigin = FloatBlockData3Type::BlockSize * BlockIJK; BoolBlockData3Type::BlockDataBitMask Mask = CandidateBlock.BitArray; Mask.CombineWithBitwiseXOR(VistedBlock.BitArray, EBitwiseOperatorFlags::MaintainSize); Mask.CombineWithBitwiseAND(CandidateBlock.BitArray, EBitwiseOperatorFlags::MaintainSize); TArray<FVector3i> SeedLocalCoords; for (BitArrayConstIter CIter(Mask); CIter; ++CIter) { const int32 LocalIndex = CIter.GetIndex(); VistedBlock.BitArray[LocalIndex] = true; const FVector3i LocalCoords = DistanceBlock.ToLocalIJK(LocalIndex); const FVector3i GridCoords = LocalCoords + BlockOrigin; const FVector3d Pos(cell_center(GridCoords)); double dsqr; const int32 near_tid = this->Spatial->FindNearestTriangle(Pos, dsqr, max_query_dist); if (near_tid != IndexConstants::InvalidID) { const float dist = (float)FMath::Sqrt(dsqr); DistanceBlock.At(LocalIndex) = dist; ClosestTriBlock.At(LocalIndex) = near_tid; SeedLocalCoords.Add(LocalCoords); } } auto IsInBlock = [](const FVector3i& LocalCoords) { bool bInBlock = true; bInBlock = LocalCoords.X > -1 && LocalCoords.Y > -1 && LocalCoords.Z > -1; bInBlock = bInBlock && LocalCoords.X < FloatBlockData3Type::BlockSize&& LocalCoords.Y < FloatBlockData3Type::BlockSize && LocalCoords.Z < FloatBlockData3Type::BlockSize; return bInBlock; }; while(SeedLocalCoords.Num() > 0) { const FVector3i Seed = SeedLocalCoords.Pop(EAllowShrinking::No); for (const FVector3i& idx_offset : IndexUtil::GridOffsets26) { const FVector3i LocalCoords = Seed + idx_offset; const FVector3i GridCoords = LocalCoords + BlockOrigin; if (IsInBlock(LocalCoords)) { const int32 local_index = FloatBlockData3Type::ToLinear(LocalCoords.X, LocalCoords.Y, LocalCoords.Z); if ((bool)VistedBlock.BitArray[local_index] == false) { VistedBlock.BitArray[local_index] = true; const FVector3d Pos(cell_center(GridCoords)); double dsqr; const int32 near_tid = this->Spatial->FindNearestTriangle(Pos, dsqr, max_query_dist); if (near_tid != IndexConstants::InvalidID) { const float dist = (float)FMath::Sqrt(dsqr); DistanceBlock.At(local_index) = dist; ClosestTriBlock.At(local_index) = near_tid; SeedLocalCoords.Add(LocalCoords); } } } else { if (NextCandidateGrid.IsValidIJK(GridCoords)) { const bool bIsCanidate = true; NextCandidateGrid.SetValueWithLock(GridCoords.X, GridCoords.Y, GridCoords.Z, bIsCanidate, BlockLockProvider); } } } } }, !this->bUseParallel)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (ClosestTriGrid .)",
    "insertText": "Reset()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!bWantIntersectionsGrid)"
  },
  {
    "label": "compute_intersections()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "compute_intersections(FVector3f Origin, float DX, int32 NI, int32 NJ, int32 NK, const FBlockedGrid3f& DistanceGrid, FBlockedGrid3i& IntersectionCountGrid)"
  },
  {
    "label": "FAtomicGrid3i()",
    "kind": "Method",
    "detail": "Function (struct FAtomicGrid3i : public TBlockedGrid3Layout<FBlockedGrid3f::BlockSize> { typedef TStaticArray<std::atomic<int32>,FBlockedGrid3f::BlockElemCount> BlockAtomicData ; typedef TBlockedGrid3Layout<FBlockedGrid3f::BlockSize> MyLayout ;)",
    "insertText": "FAtomicGrid3i(const FBlockedGrid3f& Grid3f, const bool bThreadedBuild) : MyLayout(Grid3f.GetDimensions())"
  },
  {
    "label": "GetNumBlocks()",
    "kind": "Method",
    "detail": "Function (const int32 NumBlocks = Grid3f .)",
    "insertText": "GetNumBlocks()"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(NumBlocks, [this, &Grid3f](int32 i) { if (Grid3f.GetBlockData(i).IsValid()) { Blocks[i] = MakeUnique<BlockAtomicData>(); BlockAtomicData& Data= *Blocks[i]; for (int32 j = 0; j < FBlockedGrid3i::BlockElemCount; ++j) { Data[j] = 0; } } }, !bThreadedBuild)"
  },
  {
    "label": "AtomicGrid3i()",
    "kind": "Method",
    "detail": "Function (} TArray<TUniquePtr<BlockAtomicData>> Blocks ; })",
    "insertText": "AtomicGrid3i(DistanceGrid, this->bUseParallel)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (bool bCancel = false ;)",
    "insertText": "ParallelFor(Mesh->MaxTriangleID(), [this, Origin, DX, NI, NJ, NK, &IntersectionCountGrid, &AtomicGrid3i, &bCancel](int32 TID) { double ox = (double)Origin[0], oy = (double)Origin[1], oz = (double)Origin[2]; double invdx = 1.0 / DX; if (!Mesh->IsTriangle(TID)) { return; } if (TID % 100 == 0 && CancelF() == true) { bCancel = true; } if (bCancel) { return; } FVector3d xp = FVector3d::Zero(), xq = FVector3d::Zero(), xr = FVector3d::Zero(); Mesh->GetTriVertices(TID, xp, xq, xr); bool neg_x = false; if (InsideMode == EInsideModes::WindingCount) { FVector3d n = VectorUtil::NormalDirection(xp, xq, xr); neg_x = n.X > 0; } double fip = (xp[0] - ox) * invdx, fjp = (xp[1] - oy) * invdx, fkp = (xp[2] - oz) * invdx; double fiq = (xq[0] - ox) * invdx, fjq = (xq[1] - oy) * invdx, fkq = (xq[2] - oz) * invdx; double fir = (xr[0] - ox) * invdx, fjr = (xr[1] - oy) * invdx, fkr = (xr[2] - oz) * invdx; int32 j0 = FMath::Clamp(FMath::CeilToInt32(FMath::Min3(fjp, fjq, fjr)), 0, NJ - 1); int32 j1 = FMath::Clamp(FMath::FloorToInt32(FMath::Max3(fjp, fjq, fjr)), 0, NJ - 1); int32 k0 = FMath::Clamp(FMath::CeilToInt32(FMath::Min3(fkp, fkq, fkr)), 0, NK - 1); int32 k1 = FMath::Clamp(FMath::FloorToInt32(FMath::Max3(fkp, fkq, fkr)), 0, NK - 1); auto AtomicIncDec = [&AtomicGrid3i, neg_x](const int32 i, const int32 j, const int32 k) { int32 BlockIndex, LocalIndex; AtomicGrid3i.GetBlockAndLocalIndex(i, j, k, BlockIndex, LocalIndex); auto& ABlock = *AtomicGrid3i.Blocks[BlockIndex]; std::atomic<int32>& value = ABlock[LocalIndex]; if (neg_x) { value.fetch_sub(1, std::memory_order_relaxed); } else { value.fetch_add(1, std::memory_order_relaxed); } }; for (int K = k0; K <= k1; ++K) { for (int J = j0; J <= j1; ++J) { double A, B, C; if (PointInTriangle2d(J, K, fjp, fkp, fjq, fkq, fjr, fkr, A, B, C)) { double fi = A * fip + B * fiq + C * fir; int i_interval = FMath::CeilToInt32(fi); if (i_interval < 0) { AtomicIncDec(0, J, K); } else if (i_interval < NI) { AtomicIncDec(i_interval, J, K); } else { } } } } }, !this->bUseParallel)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (IntersectionCountGrid .)",
    "insertText": "Reset(NI, NJ, NK, 0)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(NumBlocks, [&IntersectionCountGrid, &AtomicGrid3i](const int32 blockid) { TUniquePtr<typename FAtomicGrid3i::BlockAtomicData>& AtomicBlockPtr = AtomicGrid3i.Blocks[blockid]; if (AtomicBlockPtr.IsValid()) { FVector3i BlockIJK = AtomicGrid3i.BlockIndexToBlockIJK(blockid); FBlockedGrid3i::BlockData3Type& BlockData = IntersectionCountGrid.TouchBlockData(BlockIJK); const typename FAtomicGrid3i::BlockAtomicData& AtomicBlockData = *AtomicBlockPtr; for (int32 j = 0; j < FBlockedGrid3i::BlockElemCount; ++j) { const int32 Count = AtomicBlockData[j]; BlockData.At(j) = Count; } AtomicBlockPtr.Reset(); } }, !this->bUseParallel)"
  },
  {
    "label": "compute_signs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "compute_signs(int32 NI, int32 NJ, int32 NK, const FBlockedGrid3i& IntersectionCountGrid, FBlockedGrid3f& Distances)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(BlockDims.Y * BlockDims.Z, [this, BlockDims, &Distances, &IntersectionCountGrid, &bCancel](int32 BlockRowID) { const FVector3i GridDims = Distances.GetDimensions(); if (BlockRowID % 10 == 0 && CancelF() == true) { bCancel = true; } if (bCancel) { return; } constexpr int32 BlockSize = FBlockedGrid3f::BlockSize; TStaticArray<int32, BlockSize*BlockSize> BlockCrossSection; for (int32 i = 0, I = BlockSize * BlockSize; i < I; ++i) { BlockCrossSection[i] = 0; } const int32 BlockJ = BlockRowID % BlockDims[1]; const int32 BlockK = BlockRowID / BlockDims[1]; FVector3i BlockIJK(0, BlockJ, BlockK); for ( BlockIJK[0] = 0; BlockIJK[0] < BlockDims[0]; ++BlockIJK[0]) { if (Distances.IsBlockAllocated(BlockIJK)) { checkSlow(IntersectionCountGrid.IsBlockAllocated(BlockIJK)); FBlockedGrid3f::BlockData3Type& DistanceBlockData = Distances.TouchBlockData(BlockIJK); const FBlockedGrid3i::BlockData3Type& IntersectionCountBlockData = *IntersectionCountGrid.GetBlockData(BlockIJK); for (int32 k = 0; k < BlockSize; ++k) { for (int32 j = 0; j < BlockSize; ++j) { int32& total_count = BlockCrossSection[j + k * BlockSize]; for (int32 i = 0; i < BlockSize; ++i) { const int32 LocalIndex = TBlockData3Layout<BlockSize>::ToLinear(i, j, k); total_count += IntersectionCountBlockData.At(LocalIndex); if ( (InsideMode == EInsideModes::WindingCount && total_count > 0) || (InsideMode == EInsideModes::CrossingCount && total_count % 2 == 1) ) { float& d = DistanceBlockData.At(LocalIndex); d = -FMath::Abs(d); } } } } } else { checkSlow(!IntersectionCountGrid.IsBlockAllocated(BlockIJK)); int32 NumInsideCells = 0; { for (int32 index = 0, IndexMax = BlockSize * BlockSize; index < IndexMax; ++index) { const int32 total_count = BlockCrossSection[index]; if ( (InsideMode == EInsideModes::WindingCount && total_count > 0) || (InsideMode == EInsideModes::CrossingCount && total_count % 2 == 1) ) { NumInsideCells++; } } } switch (NumInsideCells) { case 0: { break; } case (BlockSize * BlockSize): { Distances.ProcessBlockDefaultValue(BlockIJK, [](float& value) {value = -FMath::Abs(value); }); break; } default: { FBlockedGrid3f::BlockData3Type& DistanceBlockData = Distances.TouchBlockData(BlockIJK); for (int32 k = 0; k < BlockSize; ++k) { for (int32 j = 0; j < BlockSize; ++j) { const int32 total_count = BlockCrossSection[j + k * BlockSize]; for (int32 i = 0; i < BlockSize; ++i) { const int32 LocalIndex = TBlockData3Layout<BlockSize>::ToLinear(i, j, k); if ( (InsideMode == EInsideModes::WindingCount && total_count > 0) || (InsideMode == EInsideModes::CrossingCount && total_count % 2 == 1) ) { float& d = DistanceBlockData.At(LocalIndex); d = -FMath::Abs(d); } } } } break; } } } } }, !this->bUseParallel)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(int K = 0; K < NK; ++K)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int total_count = 0 ;)",
    "insertText": "for(int I = 0; I < NI; ++I)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (total_count + = IntersectionCountGrid .)",
    "insertText": "GetValue(I, J, K)"
  },
  {
    "label": "ProcessValue()",
    "kind": "Method",
    "detail": "Function (Distances .)",
    "insertText": "ProcessValue(I, J, K, [](float& value){value = -value;})"
  }
]