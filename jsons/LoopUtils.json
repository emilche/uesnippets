[
  {
    "label": "AliasAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AliasAnalysis"
  },
  {
    "label": "AliasSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AliasSet"
  },
  {
    "label": "AliasSetTracker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AliasSetTracker"
  },
  {
    "label": "AssumptionCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AssumptionCache"
  },
  {
    "label": "BasicBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BasicBlock"
  },
  {
    "label": "DataLayout",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DataLayout"
  },
  {
    "label": "DominatorTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DominatorTree"
  },
  {
    "label": "Loop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Loop"
  },
  {
    "label": "LoopInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopInfo"
  },
  {
    "label": "Pass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Pass"
  },
  {
    "label": "PredIteratorCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PredIteratorCache"
  },
  {
    "label": "ScalarEvolution",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScalarEvolution"
  },
  {
    "label": "TargetLibraryInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetLibraryInfo"
  },
  {
    "label": "LICMSafetyInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LICMSafetyInfo"
  },
  {
    "label": "holds",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "holds"
  },
  {
    "label": "RecurrenceDescriptor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RecurrenceDescriptor"
  },
  {
    "label": "represents",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "represents"
  },
  {
    "label": "RecurrenceKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "RecurrenceKind"
  },
  {
    "label": "represents",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "represents"
  },
  {
    "label": "MinMaxRecurrenceKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "MinMaxRecurrenceKind"
  },
  {
    "label": "holds",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "holds"
  },
  {
    "label": "InstDesc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InstDesc"
  },
  {
    "label": "describing",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "describing"
  },
  {
    "label": "describing",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "describing"
  },
  {
    "label": "isRecurrenceInstr()",
    "kind": "Method",
    "detail": "Function (InstDesc)",
    "insertText": "isRecurrenceInstr(Instruction *I, RecurrenceKind Kind,\n                                    InstDesc &Prev, bool HasFunNoNaNAttr)"
  },
  {
    "label": "hasMultipleUsesOf()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasMultipleUsesOf(Instruction *I,\n                                SmallPtrSetImpl<Instruction *> &Insts)"
  },
  {
    "label": "areAllUsesIn()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "areAllUsesIn(Instruction *I, SmallPtrSetImpl<Instruction *> &Set)"
  },
  {
    "label": "isMinMaxSelectCmpPattern()",
    "kind": "Method",
    "detail": "Function (InstDesc)",
    "insertText": "isMinMaxSelectCmpPattern(Instruction *I, InstDesc &Prev)"
  },
  {
    "label": "getRecurrenceBinOp()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getRecurrenceBinOp(RecurrenceKind Kind)"
  },
  {
    "label": "AddReductionVar()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AddReductionVar(PHINode *Phi, RecurrenceKind Kind, Loop *TheLoop,\n                              bool HasFunNoNaNAttr,\n                              RecurrenceDescriptor &RedDes)"
  },
  {
    "label": "isReductionPHI()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isReductionPHI(PHINode *Phi, Loop *TheLoop,\n                             RecurrenceDescriptor &RedDes)"
  },
  {
    "label": "simplifyLoop()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "simplifyLoop(Loop *L, DominatorTree *DT, LoopInfo *LI, Pass *PP,\n                  AliasAnalysis *AA = nullptr, ScalarEvolution *SE = nullptr,\n                  AssumptionCache *AC = nullptr)"
  },
  {
    "label": "formLCSSA()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "formLCSSA(Loop &L, DominatorTree &DT, LoopInfo *LI,\n               ScalarEvolution *SE = nullptr)"
  },
  {
    "label": "formLCSSARecursively()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "formLCSSARecursively(Loop &L, DominatorTree &DT, LoopInfo *LI,\n                          ScalarEvolution *SE = nullptr)"
  },
  {
    "label": "sinkRegion()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "sinkRegion(DomTreeNode *, AliasAnalysis *, LoopInfo *, DominatorTree *,\n                TargetLibraryInfo *, Loop *, AliasSetTracker *,\n                LICMSafetyInfo *)"
  },
  {
    "label": "hoistRegion()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hoistRegion(DomTreeNode *, AliasAnalysis *, LoopInfo *, DominatorTree *,\n                 TargetLibraryInfo *, Loop *, AliasSetTracker *,\n                 LICMSafetyInfo *)"
  },
  {
    "label": "promoteLoopAccessesToScalars()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "promoteLoopAccessesToScalars(AliasSet &, SmallVectorImpl<BasicBlock*> &,\n                                  SmallVectorImpl<Instruction*> &,\n                                  PredIteratorCache &, LoopInfo *,\n                                  DominatorTree *, Loop *, AliasSetTracker *,\n                                  LICMSafetyInfo *)"
  },
  {
    "label": "computeLICMSafetyInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeLICMSafetyInfo(LICMSafetyInfo *, Loop *)"
  },
  {
    "label": "isInductionPHI()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isInductionPHI(PHINode *, ScalarEvolution *, ConstantInt *&)"
  }
]