[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "circular_deque",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "circular_deque"
  },
  {
    "label": "circular_deque_const_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "circular_deque_const_iterator"
  },
  {
    "label": "circular_deque_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "circular_deque_iterator"
  },
  {
    "label": "InputIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InputIterator"
  },
  {
    "label": "Value",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Value"
  },
  {
    "label": "Predicate",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Predicate"
  },
  {
    "label": "circular_deque_const_iterator()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_CONTAINERS_CIRCULAR_DEQUE_H_ # define BASE_CONTAINERS_CIRCULAR_DEQUE_H_ # include<algorithm> # include<cstddef> # include<iterator> # include<type_traits> # include<utility> # include \" base / check . h \" # include \" base / containers / vector_buffer . h \" # include \" base / dcheck_is_on . h \" # include \" base / memory / raw_ptr_exclusion . h \" # include \" base / ranges / algorithm . h \" # include \" base / template_util . h \" namespace base { template<class T> class circular_deque ; namespace internal { size_t kCircularBufferInitialCapacity = 3 ; template<T> class circular_deque_const_iterator { public : using difference_type = std::ptrdiff_t ; using value_type = T ; using pointer = const T* ; using reference = const T& ; using iterator_category = std::random_access_iterator_tag ;)",
    "insertText": "circular_deque_const_iterator() : parent_deque_(nullptr), index_(0)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif } const T&)",
    "insertText": "operator()"
  },
  {
    "label": "CheckValidIndex()",
    "kind": "Method",
    "detail": "Function (parent_deque_ ->)",
    "insertText": "CheckValidIndex(index_)"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Increment()"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Decrement()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (circular_deque_const_iterator ret = iter ; ret .)",
    "insertText": "Add(offset)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (circular_deque_const_iterator ret = iter ; ret .)",
    "insertText": "Add(-offset)"
  },
  {
    "label": "CheckComparable()",
    "kind": "Method",
    "detail": "Function (lhs .)",
    "insertText": "CheckComparable(rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const circular_deque_const_iterator& lhs, const circular_deque_const_iterator& rhs)"
  },
  {
    "label": "circular_deque_const_iterator()",
    "kind": "Method",
    "detail": "Function (} protected : class circular_deque<T> ;)",
    "insertText": "circular_deque_const_iterator(const circular_deque<T>* parent, size_t index) : parent_deque_(parent), index_(index)"
  },
  {
    "label": "OffsetFromBegin()",
    "kind": "Method",
    "detail": "Function (# endif } size_t)",
    "insertText": "OffsetFromBegin()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (index_ + + ;)",
    "insertText": "if(index_ == parent_deque_->buffer_.capacity())"
  },
  {
    "label": "CheckValidIndexOrEnd()",
    "kind": "Method",
    "detail": "Function (parent_deque_ ->)",
    "insertText": "CheckValidIndexOrEnd(index_)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() if (delta <= 0) parent_deque_->CheckValidIndexOrEnd(index_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(delta == 0)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(new_offset >= 0 && new_offset <= static_cast<difference_type>(parent_deque_->size()))"
  },
  {
    "label": "index_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "index_(new_offset + parent_deque_->begin_) % parent_deque_->buffer_.capacity()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "DCHECK_IS_ON() void CheckUnstableUsage()"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(parent_deque_)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(created_generation_ == parent_deque_->generation_)"
  },
  {
    "label": "CheckComparable()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CheckComparable(const circular_deque_const_iterator& other)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(parent_deque_ == other.parent_deque_)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(created_generation_ == other.created_generation_)"
  },
  {
    "label": "CheckUnstableUsage()",
    "kind": "Method",
    "detail": "Function (} # else void)",
    "insertText": "CheckUnstableUsage()"
  },
  {
    "label": "CheckComparable()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CheckComparable(const circular_deque_const_iterator&)"
  },
  {
    "label": "circular_deque_iterator()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<T> class circular_deque_iterator : public circular_deque_const_iterator<T> { using base = circular_deque_const_iterator<T> ; public : class circular_deque<T> ; using difference_type = std::ptrdiff_t ; using value_type = T ; using pointer = T* ; using reference = T& ; using iterator_category = std::random_access_iterator_tag ;)",
    "insertText": "circular_deque_iterator() : circular_deque_const_iterator<T>()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "operator(difference_type i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} circular_deque_iterator)",
    "insertText": "operator(const circular_deque_iterator& iter, difference_type offset)"
  },
  {
    "label": "circular_deque()",
    "kind": "Method",
    "detail": "Function (} } ; } template<T> class circular_deque { private : using VectorBuffer = internal::VectorBuffer<T> ; public : using value_type = T ; using size_type = std::size_t ; using difference_type = std::ptrdiff_t ; using reference = value_type& ; using const_reference = const value_type& ; using pointer = value_type* ; using const_pointer = const value_type* ; using iterator = internal::circular_deque_iterator<T> ; using const_iterator = internal::circular_deque_const_iterator<T> ; using reverse_iterator = std::reverse_iterator<iterator> ; using const_reverse_iterator = std::reverse_iterator<const_iterator> ;)",
    "insertText": "circular_deque()"
  },
  {
    "label": "circular_deque()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "circular_deque(size_type count)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(count)"
  },
  {
    "label": "circular_deque()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "circular_deque(size_type count, const T& value)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(count, value)"
  },
  {
    "label": "circular_deque()",
    "kind": "Method",
    "detail": "Function (} template<class InputIterator>)",
    "insertText": "circular_deque(InputIterator first, InputIterator last)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assign(first, last)"
  },
  {
    "label": "circular_deque()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "circular_deque(const circular_deque& other) : buffer_(other.size() + 1)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assign(other.begin(), other.end())"
  },
  {
    "label": "circular_deque()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "circular_deque(circular_deque&& other) noexcept : buffer_(std::move(other.buffer_)), begin_(other.begin_), end_(other.end_)"
  },
  {
    "label": "circular_deque()",
    "kind": "Method",
    "detail": "Function (other . begin_ = 0 ; other . end_ = 0 ; })",
    "insertText": "circular_deque(std::initializer_list<value_type> init)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assign(init)"
  },
  {
    "label": "DestructRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructRange(begin_, end_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} circular_deque&)",
    "insertText": "operator(const circular_deque& other)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(other.size())"
  },
  {
    "label": "ClearRetainCapacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearRetainCapacity()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (buffer_ =)",
    "insertText": "move(other.buffer_)"
  },
  {
    "label": "IncrementGeneration()",
    "kind": "Method",
    "detail": "Function (begin_ = other . begin_ ; end_ = other . end_ ; other . begin_ = 0 ; other . end_ = 0 ;)",
    "insertText": "IncrementGeneration()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(ilist.size())"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assign(std::begin(ilist), std::end(ilist))"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(count)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (} template<InputIterator> std::enable_if<::base::internal::is_iterator<InputIterator>::value,void>::type)",
    "insertText": "assign(InputIterator first, InputIterator last)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "assign(std::initializer_list<value_type> value)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(std::distance(value.begin(), value.end()))"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assign(value.begin(), value.end())"
  },
  {
    "label": "at()",
    "kind": "Method",
    "detail": "Function (} const value_type&)",
    "insertText": "at(size_type i)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(i < size())"
  },
  {
    "label": "capacity()",
    "kind": "Method",
    "detail": "Function (size_t right_size = buffer_ .)",
    "insertText": "capacity()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} value_type&)",
    "insertText": "operator(size_type i)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (} value_type&)",
    "insertText": "front()"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(!empty())"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} const value_type&)",
    "insertText": "back()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "begin()"
  },
  {
    "label": "cbegin()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "cbegin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "cend()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "cend()"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rbegin()"
  },
  {
    "label": "crbegin()",
    "kind": "Method",
    "detail": "Function (} const_reverse_iterator)",
    "insertText": "crbegin()"
  },
  {
    "label": "rend()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rend()"
  },
  {
    "label": "crend()",
    "kind": "Method",
    "detail": "Function (} const_reverse_iterator)",
    "insertText": "crend()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reserve(size_type new_capacity)"
  },
  {
    "label": "shrink_to_fit()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "shrink_to_fit()"
  },
  {
    "label": "SetCapacityTo()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "SetCapacityTo(size())"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "clear()"
  },
  {
    "label": "VectorBuffer()",
    "kind": "Method",
    "detail": "Function (buffer_ =)",
    "insertText": "VectorBuffer()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resize(size_type count)"
  },
  {
    "label": "ExpandCapacityIfNecessary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpandCapacityIfNecessary(count - size())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(count < size())"
  },
  {
    "label": "new_end()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "new_end(begin_ + count) % buffer_.capacity()"
  },
  {
    "label": "DestructRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructRange(new_end, end_)"
  },
  {
    "label": "ShrinkCapacityIfNecessary()",
    "kind": "Method",
    "detail": "Function (end_ = new_end ;)",
    "insertText": "ShrinkCapacityIfNecessary()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resize(size_type count, const value_type& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "insert(const_iterator pos, size_type count, const T& value)"
  },
  {
    "label": "ValidateIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateIterator(pos)"
  },
  {
    "label": "ExpandCapacityIfNecessary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpandCapacityIfNecessary(count)"
  },
  {
    "label": "MakeRoomFor()",
    "kind": "Method",
    "detail": "Function (iterator insert_end ;)",
    "insertText": "MakeRoomFor(count, &insert_cur, &insert_end)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&buffer_[insert_cur.index_]) T(value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} template<class InputIterator> std::enable_if<::base::internal::is_iterator<InputIterator>::value,void>::type)",
    "insertText": "insert(const_iterator pos, InputIterator first, InputIterator last)"
  },
  {
    "label": "distance()",
    "kind": "Method",
    "detail": "Function (const difference_type inserted_items_signed =)",
    "insertText": "distance(first, last)"
  },
  {
    "label": "size_type()",
    "kind": "Method",
    "detail": "Function (const size_type inserted_items = static_cast<)",
    "insertText": "size_type(inserted_items_signed)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (iterator insert_cur ; iterator insert_end ;)",
    "insertText": "if(pos == begin())"
  },
  {
    "label": "ExpandCapacityIfNecessary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpandCapacityIfNecessary(inserted_items)"
  },
  {
    "label": "begin_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "begin_(begin_ + buffer_.capacity() - inserted_items) % buffer_.capacity()"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} else { insert_cur =)",
    "insertText": "iterator(this, pos.index_)"
  },
  {
    "label": "MakeRoomFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MakeRoomFor(inserted_items, &insert_cur, &insert_end)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(insert_cur < insert_end)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&buffer_[insert_cur.index_]) T(*first)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(const_iterator pos, const T& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(const_iterator pos, T&& value)"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Args> iterator)",
    "insertText": "emplace(const_iterator pos, Args&&... args)"
  },
  {
    "label": "emplace_front()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "emplace_front(std::forward<Args>(args)...)"
  },
  {
    "label": "insert_begin()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "insert_begin(this, pos.index_)"
  },
  {
    "label": "MakeRoomFor()",
    "kind": "Method",
    "detail": "Function (iterator insert_end ;)",
    "insertText": "MakeRoomFor(1, &insert_begin, &insert_end)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&buffer_[insert_begin.index_]) T(std::forward<Args>(args)...)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "erase(const_iterator first, const_iterator last)"
  },
  {
    "label": "ValidateIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateIterator(first)"
  },
  {
    "label": "ValidateIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateIterator(last)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(first.index_ < last.index_)"
  },
  {
    "label": "DestructRange()",
    "kind": "Method",
    "detail": "Function (buffer_ .)",
    "insertText": "DestructRange(&buffer_[first.index_], &buffer_[last.index_])"
  },
  {
    "label": "DestructRange()",
    "kind": "Method",
    "detail": "Function (} else { buffer_ .)",
    "insertText": "DestructRange(&buffer_[first.index_], &buffer_[buffer_.capacity()])"
  },
  {
    "label": "DestructRange()",
    "kind": "Method",
    "detail": "Function (buffer_ .)",
    "insertText": "DestructRange(&buffer_[0], &buffer_[last.index_])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(first.index_ == begin_)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (begin_ = last . index_ ; return)",
    "insertText": "iterator(this, last.index_)"
  },
  {
    "label": "move_src()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "move_src(this, last.index_)"
  },
  {
    "label": "move_dest()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "move_dest(this, first.index_)"
  },
  {
    "label": "MoveRange()",
    "kind": "Method",
    "detail": "Function (buffer_ .)",
    "insertText": "MoveRange(&buffer_[move_src.index_], &buffer_[move_src.index_ + 1], &buffer_[move_dest.index_])"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} end_ = move_dest . index_ ; return)",
    "insertText": "iterator(this, first.index_)"
  },
  {
    "label": "push_front()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_front(const T& value)"
  },
  {
    "label": "emplace_front()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "emplace_front(value)"
  },
  {
    "label": "push_front()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_front(T&& value)"
  },
  {
    "label": "emplace_front()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "emplace_front(std::move(value))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_back(const T& value)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "emplace_back(value)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_back(T&& value)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "emplace_back(std::move(value))"
  },
  {
    "label": "emplace_front()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Args> reference)",
    "insertText": "emplace_front(Args&&... args)"
  },
  {
    "label": "ExpandCapacityIfNecessary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpandCapacityIfNecessary(1)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&buffer_[begin_]) T(std::forward<Args>(args)...)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Args> reference)",
    "insertText": "emplace_back(Args&&... args)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&buffer_[end_]) T(std::forward<Args>(args)...)"
  },
  {
    "label": "pop_front()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pop_front()"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(size())"
  },
  {
    "label": "DestructRange()",
    "kind": "Method",
    "detail": "Function (buffer_ .)",
    "insertText": "DestructRange(&buffer_[begin_], &buffer_[begin_ + 1])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (begin_ + + ;)",
    "insertText": "if(begin_ == buffer_.capacity())"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pop_back()"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(circular_deque& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(buffer_, other.buffer_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(begin_, other.begin_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(end_, other.end_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(circular_deque& lhs, circular_deque& rhs)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (lhs .)",
    "insertText": "swap(rhs)"
  },
  {
    "label": "MoveBuffer()",
    "kind": "Method",
    "detail": "Function (} private : internal::circular_deque_iterator<T> ; internal::circular_deque_const_iterator<T> ; void)",
    "insertText": "MoveBuffer(VectorBuffer& from_buf, size_t from_begin, size_t from_end, VectorBuffer* to_buf, size_t* to_begin, size_t* to_end)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* to_begin = 0 ;)",
    "insertText": "if(from_begin < from_end)"
  },
  {
    "label": "MoveRange()",
    "kind": "Method",
    "detail": "Function (from_buf .)",
    "insertText": "MoveRange(&from_buf[from_begin], &from_buf[from_end], to_buf->begin())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* to_end = from_end - from_begin ; } else)",
    "insertText": "if(from_begin > from_end)"
  },
  {
    "label": "MoveRange()",
    "kind": "Method",
    "detail": "Function (from_buf .)",
    "insertText": "MoveRange(&from_buf[from_begin], &from_buf[from_capacity], to_buf->begin())"
  },
  {
    "label": "MoveRange()",
    "kind": "Method",
    "detail": "Function (size_t right_size = from_capacity - from_begin ; from_buf .)",
    "insertText": "MoveRange(&from_buf[0], &from_buf[from_end], &(*to_buf)[right_size])"
  },
  {
    "label": "SetCapacityTo()",
    "kind": "Method",
    "detail": "Function (* to_end = right_size + from_end ; } else {* to_end = 0 ; } } void)",
    "insertText": "SetCapacityTo(size_t new_capacity)"
  },
  {
    "label": "new_buffer()",
    "kind": "Method",
    "detail": "Function (VectorBuffer)",
    "insertText": "new_buffer(new_capacity + 1)"
  },
  {
    "label": "MoveBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MoveBuffer(buffer_, begin_, end_, &new_buffer, &begin_, &end_)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (buffer_ =)",
    "insertText": "move(new_buffer)"
  },
  {
    "label": "ExpandCapacityIfNecessary()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExpandCapacityIfNecessary(size_t additional_elts)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_t min_new_capacity =)",
    "insertText": "size()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (min_new_capacity =)",
    "insertText": "max(min_new_capacity, internal::kCircularBufferInitialCapacity)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (size_t new_capacity =)",
    "insertText": "max(min_new_capacity, capacity() + capacity() / 4)"
  },
  {
    "label": "SetCapacityTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCapacityTo(new_capacity)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (size_t new_capacity =)",
    "insertText": "max(internal::kCircularBufferInitialCapacity, sz + sz / 4)"
  },
  {
    "label": "DestructRange()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DestructRange(size_t begin, size_t end)"
  },
  {
    "label": "DestructRange()",
    "kind": "Method",
    "detail": "Function (buffer_ .)",
    "insertText": "DestructRange(&buffer_[begin], &buffer_[end])"
  },
  {
    "label": "DestructRange()",
    "kind": "Method",
    "detail": "Function (} else { buffer_ .)",
    "insertText": "DestructRange(&buffer_[begin], &buffer_[buffer_.capacity()])"
  },
  {
    "label": "DestructRange()",
    "kind": "Method",
    "detail": "Function (buffer_ .)",
    "insertText": "DestructRange(&buffer_[0], &buffer_[end])"
  },
  {
    "label": "MakeRoomFor()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "MakeRoomFor(size_t count, iterator* insert_begin, iterator* insert_end)"
  },
  {
    "label": "index_()",
    "kind": "Method",
    "detail": "Function (insert_begin ->)",
    "insertText": "index_(begin_ + begin_offset) % buffer_.capacity()"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (* insert_end =)",
    "insertText": "iterator(this, (insert_begin->index_ + count) % buffer_.capacity())"
  },
  {
    "label": "end_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "end_(end_ + count) % buffer_.capacity()"
  },
  {
    "label": "MoveRange()",
    "kind": "Method",
    "detail": "Function (- - src ; - - dest ; buffer_ .)",
    "insertText": "MoveRange(&buffer_[src.index_], &buffer_[src.index_ + 1], &buffer_[dest.index_])"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (} } # if)",
    "insertText": "DCHECK_IS_ON() void CheckValidIndex(size_t i)"
  },
  {
    "label": "CheckValidIndexOrEnd()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CheckValidIndexOrEnd(size_t i)"
  },
  {
    "label": "ValidateIterator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ValidateIterator(const const_iterator& i)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(i.parent_deque_ == this)"
  },
  {
    "label": "CheckValidIndex()",
    "kind": "Method",
    "detail": "Function (generation_ + + ; } # else void)",
    "insertText": "CheckValidIndex(size_t)"
  },
  {
    "label": "CheckValidIndexOrEnd()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CheckValidIndexOrEnd(size_t)"
  },
  {
    "label": "Erase()",
    "kind": "Method",
    "detail": "Function (# endif } ; template<class T,class Value> size_t)",
    "insertText": "Erase(circular_deque<T>& container, const Value& value)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (auto it =)",
    "insertText": "remove(container, value)"
  },
  {
    "label": "distance()",
    "kind": "Method",
    "detail": "Function (size_t removed =)",
    "insertText": "distance(it, container.end())"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (container .)",
    "insertText": "erase(it, container.end())"
  },
  {
    "label": "remove_if()",
    "kind": "Method",
    "detail": "Function (auto it =)",
    "insertText": "remove_if(container, pred)"
  }
]