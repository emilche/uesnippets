[
  {
    "label": "Quat",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Quat"
  },
  {
    "label": "slerp()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_QUAT_H_HAS_BEEN_INCLUDED # define OPENVDB_MATH_QUAT_H_HAS_BEEN_INCLUDED # include \" Mat . h \" # include \" Mat3 . h \" # include \" Math . h \" # include \" Vec3 . h \" # include<openvdb / Exceptions . h> # include<cmath> # include<iostream> # include<sstream> # include<string> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { template<T> class Quat ; template<T> Quat<T>)",
    "insertText": "slerp(const Quat<T> &q1, const Quat<T> &q2, T t, T tolerance=0.00001)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (T qdot,angle,sineAngle ; qdot = q1 .)",
    "insertText": "dot(q2)"
  },
  {
    "label": "acos()",
    "kind": "Method",
    "detail": "Function (angle = 0 ; sineAngle = 0 ; } else { angle =)",
    "insertText": "acos(qdot)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (sineAngle =)",
    "insertText": "sin(angle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(sineAngle <= tolerance)"
  },
  {
    "label": "qtemp()",
    "kind": "Method",
    "detail": "Function (T s = 1 . 0 - t ; Quat<T>)",
    "insertText": "qtemp(s * q1[0] + t * q2[0], s * q1[1] + t * q2[1], s * q1[2] + t * q2[2], s * q1[3] + t * q2[3])"
  },
  {
    "label": "qtemp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "qtemp(t < 0.5)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (} else { qtemp* = 1 . 0 /)",
    "insertText": "sqrt(lengthSquared)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (} return qtemp ; } else { T sine = 1 . 0 / sineAngle ; T a =)",
    "insertText": "sin((1.0 - t) * angle)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (T b =)",
    "insertText": "sin(t * angle)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (} } template<T> class Quat { public : using value_type = T ; using ValueType = T ; const int size = 4 ; # if OPENVDB_ABI_VERSION_NUMBER> = 8)",
    "insertText": "Quat()"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Quat(const Quat &q)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = q . mm [ 0 ] ; mm [ 1 ] = q . mm [ 1 ] ; mm [ 2 ] = q . mm [ 2 ] ; mm [ 3 ] = q . mm [ 3 ] ; } Quat&)",
    "insertText": "operator(const Quat &q)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = q . mm [ 0 ] ; mm [ 1 ] = q . mm [ 1 ] ; mm [ 2 ] = q . mm [ 2 ] ; mm [ 3 ] = q . mm [ 3 ] ; return* this ; } # endif)",
    "insertText": "Quat(T x, T y, T z, T w)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = x ; mm [ 1 ] = y ; mm [ 2 ] = z ; mm [ 3 ] = w ; })",
    "insertText": "Quat(T *a)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = a [ 0 ] ; mm [ 1 ] = a [ 1 ] ; mm [ 2 ] = a [ 2 ] ; mm [ 3 ] = a [ 3 ] ; })",
    "insertText": "Quat(const Vec3<T> &axis, T angle)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T s =)",
    "insertText": "T(sin(angle*T(0.5)))"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = axis .)",
    "insertText": "x()"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (mm [ 1 ] = axis .)",
    "insertText": "y()"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (mm [ 2 ] = axis .)",
    "insertText": "z()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (mm [ 3 ] =)",
    "insertText": "T(cos(angle*T(0.5)))"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Quat(math::Axis axis, T angle)"
  },
  {
    "label": "mm()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mm(axis==math::X_AXIS)"
  },
  {
    "label": "mm()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mm(axis==math::Y_AXIS)"
  },
  {
    "label": "mm()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mm(axis==math::Z_AXIS)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (} template<T1>)",
    "insertText": "Quat(const Mat3<T1> &rot)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"A non-rotation matrix can not be used to construct a quaternion\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!isApproxEqual(rot.det(), T1(1)))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"A reflection matrix can not be used to construct a quaternion\")"
  },
  {
    "label": "trace()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "trace(rot.trace())"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (T q_w = 0 . 5*)",
    "insertText": "sqrt(trace+1)"
  },
  {
    "label": "factor()",
    "kind": "Method",
    "detail": "Function (T factor = 0 . 2 5 / q_w ; mm [ 0 ] =)",
    "insertText": "factor(rot(1,2) - rot(2,1))"
  },
  {
    "label": "factor()",
    "kind": "Method",
    "detail": "Function (mm [ 1 ] =)",
    "insertText": "factor(rot(2,0) - rot(0,2))"
  },
  {
    "label": "factor()",
    "kind": "Method",
    "detail": "Function (mm [ 2 ] =)",
    "insertText": "factor(rot(0,1) - rot(1,0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mm [ 3 ] = q_w ; } else)",
    "insertText": "if(rot(0,0) > rot(1,1) && rot(0,0) > rot(2,2))"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (T q_x = 0 . 5*)",
    "insertText": "sqrt(rot(0,0)- rot(1,1)-rot(2,2)+1)"
  },
  {
    "label": "factor()",
    "kind": "Method",
    "detail": "Function (T factor = 0 . 2 5 / q_x ; mm [ 0 ] = q_x ; mm [ 1 ] =)",
    "insertText": "factor(rot(0,1) + rot(1,0))"
  },
  {
    "label": "factor()",
    "kind": "Method",
    "detail": "Function (mm [ 2 ] =)",
    "insertText": "factor(rot(2,0) + rot(0,2))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(rot(1,1) > rot(2,2))"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (T q_y = 0 . 5*)",
    "insertText": "sqrt(rot(1,1)-rot(0,0)-rot(2,2)+1)"
  },
  {
    "label": "factor()",
    "kind": "Method",
    "detail": "Function (mm [ 1 ] = q_y ; mm [ 2 ] =)",
    "insertText": "factor(rot(1,2) + rot(2,1))"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (} else { T q_z = 0 . 5*)",
    "insertText": "sqrt(rot(2,2)-rot(0,0)-rot(1,1)+1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T sqrLength = mm [ 0 ]* mm [ 0 ] + mm [ 1 ]* mm [ 1 ] + mm [ 2 ]* mm [ 2 ] ;)",
    "insertText": "if(sqrLength > 1.0e-8)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "T(0.0)"
  },
  {
    "label": "axis()",
    "kind": "Method",
    "detail": "Function (} } Vec3<T>)",
    "insertText": "axis()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T invLength =)",
    "insertText": "T(T(1)/sqrt(sqrLength))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else { return Vec3<)",
    "insertText": "T(1,0,0)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} } Quat&)",
    "insertText": "init(T x, T y, T z, T w)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = x ; mm [ 1 ] = y ; mm [ 2 ] = z ; mm [ 3 ] = w ; return* this ; } Quat&)",
    "insertText": "init()"
  },
  {
    "label": "setAxisAngle()",
    "kind": "Method",
    "detail": "Function (} Quat&)",
    "insertText": "setAxisAngle(const Vec3<T>& axis, T angle)"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = mm [ 1 ] = mm [ 2 ] = mm [ 3 ] = 0 ; return* this ; } Quat&)",
    "insertText": "setIdentity()"
  },
  {
    "label": "eulerAngles()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = mm [ 1 ] = mm [ 2 ] = 0 ; mm [ 3 ] = 1 ; return* this ; } Vec3<T>)",
    "insertText": "eulerAngles(RotationOrder rotationOrder)"
  },
  {
    "label": "eq()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "eq(const Quat &q, T eps=1.0e-7)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] - = q . mm [ 0 ] ; mm [ 1 ] - = q . mm [ 1 ] ; mm [ 2 ] - = q . mm [ 2 ] ; mm [ 3 ] - = q . mm [ 3 ] ; return* this ; } Quat&)",
    "insertText": "operator(T scalar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Quat)",
    "insertText": "operator()"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} Quat&)",
    "insertText": "add(const Quat &q1, const Quat &q2)"
  },
  {
    "label": "sub()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = q1 . mm [ 0 ] + q2 . mm [ 0 ] ; mm [ 1 ] = q1 . mm [ 1 ] + q2 . mm [ 1 ] ; mm [ 2 ] = q1 . mm [ 2 ] + q2 . mm [ 2 ] ; mm [ 3 ] = q1 . mm [ 3 ] + q2 . mm [ 3 ] ; return* this ; } Quat&)",
    "insertText": "sub(const Quat &q1, const Quat &q2)"
  },
  {
    "label": "mult()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = q1 . mm [ 0 ] - q2 . mm [ 0 ] ; mm [ 1 ] = q1 . mm [ 1 ] - q2 . mm [ 1 ] ; mm [ 2 ] = q1 . mm [ 2 ] - q2 . mm [ 2 ] ; mm [ 3 ] = q1 . mm [ 3 ] - q2 . mm [ 3 ] ; return* this ; } Quat&)",
    "insertText": "mult(const Quat &q1, const Quat &q2)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = q1 . mm [ 3 ]* q2 . mm [ 0 ] + q1 . mm [ 0 ]* q2 . mm [ 3 ] + q1 . mm [ 1 ]* q2 . mm [ 2 ] - q1 . mm [ 2 ]* q2 . mm [ 1 ] ; mm [ 1 ] = q1 . mm [ 3 ]* q2 . mm [ 1 ] + q1 . mm [ 1 ]* q2 . mm [ 3 ] + q1 . mm [ 2 ]* q2 . mm [ 0 ] - q1 . mm [ 0 ]* q2 . mm [ 2 ] ; mm [ 2 ] = q1 . mm [ 3 ]* q2 . mm [ 2 ] + q1 . mm [ 2 ]* q2 . mm [ 3 ] + q1 . mm [ 0 ]* q2 . mm [ 1 ] - q1 . mm [ 1 ]* q2 . mm [ 0 ] ; mm [ 3 ] = q1 . mm [ 3 ]* q2 . mm [ 3 ] - q1 . mm [ 0 ]* q2 . mm [ 0 ] - q1 . mm [ 1 ]* q2 . mm [ 1 ] - q1 . mm [ 2 ]* q2 . mm [ 2 ] ; return* this ; } Quat&)",
    "insertText": "scale(T scale, const Quat &q)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (mm [ 0 ] = scale* q . mm [ 0 ] ; mm [ 1 ] = scale* q . mm [ 1 ] ; mm [ 2 ] = scale* q . mm [ 2 ] ; mm [ 3 ] = scale* q . mm [ 3 ] ; return* this ; } T)",
    "insertText": "dot(const Quat &q)"
  },
  {
    "label": "derivative()",
    "kind": "Method",
    "detail": "Function (} Quat)",
    "insertText": "derivative(const Vec3<T>& omega)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "normalize(T eps = T(1.0e-8))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T d =)",
    "insertText": "T(sqrt(mm[0]*mm[0] + mm[1]*mm[1] + mm[2]*mm[2] + mm[3]*mm[3]))"
  },
  {
    "label": "this()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "this(T(1)/d)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (T d =)",
    "insertText": "sqrt(mm[0]*mm[0] + mm[1]*mm[1] + mm[2]*mm[2] + mm[3]*mm[3])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T d = mm [ 0 ]* mm [ 0 ] + mm [ 1 ]* mm [ 1 ] + mm [ 2 ]* mm [ 2 ] + mm [ 3 ]* mm [ 3 ] ;)",
    "insertText": "if(isApproxEqual(d, T(0.0), tolerance) ) OPENVDB_THROW(ArithmeticError, \"Cannot invert degenerate quaternion\")"
  },
  {
    "label": "conjugate()",
    "kind": "Method",
    "detail": "Function (Quat result =* this / - d ; result . mm [ 3 ] = - result . mm [ 3 ] ; return result ; } Quat)",
    "insertText": "conjugate()"
  },
  {
    "label": "rotateVector()",
    "kind": "Method",
    "detail": "Function (} Vec3<T>)",
    "insertText": "rotateVector(const Vec3<T> &v)"
  },
  {
    "label": "m()",
    "kind": "Method",
    "detail": "Function (Mat3<T>)",
    "insertText": "m(*this)"
  },
  {
    "label": "zero()",
    "kind": "Method",
    "detail": "Function (} Quat)",
    "insertText": "zero()"
  },
  {
    "label": "identity()",
    "kind": "Method",
    "detail": "Function (} Quat)",
    "insertText": "identity()"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "str()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::ostringstream buffer ; buffer<<\" [ \" ;)",
    "insertText": "for(unsigned j(0); j < 4; j++)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} std::ostream&)",
    "insertText": "operator(std::ostream &stream, const Quat &q)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "write(std::ostream& os)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(static_cast<char*>(&mm), sizeof(T) * 4)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "read(std::istream& is)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(static_cast<char*>(&mm), sizeof(T) * 4)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} protected : T mm [ 4 ] ; } ; template<S,T> Quat<T>)",
    "insertText": "operator(S scalar, const Quat<T> &q)"
  },
  {
    "label": "q1()",
    "kind": "Method",
    "detail": "Function (using MatType = Mat3<T> ; Quat<T>)",
    "insertText": "q1(m1)"
  },
  {
    "label": "q2()",
    "kind": "Method",
    "detail": "Function (Quat<T>)",
    "insertText": "q2(m2)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Quat<T> qslerp = slerp<)",
    "insertText": "T(q1, q2, static_cast<T>(t))"
  },
  {
    "label": "MatType()",
    "kind": "Method",
    "detail": "Function (MatType m = rotation<)",
    "insertText": "MatType(qslerp)"
  },
  {
    "label": "slerp()",
    "kind": "Method",
    "detail": "Function (Mat3<T> m00,m01,m02,m10,m11 ; m00 =)",
    "insertText": "slerp(m1, m2, t)"
  },
  {
    "label": "slerp()",
    "kind": "Method",
    "detail": "Function (m01 =)",
    "insertText": "slerp(m2, m3, t)"
  },
  {
    "label": "slerp()",
    "kind": "Method",
    "detail": "Function (m02 =)",
    "insertText": "slerp(m3, m4, t)"
  },
  {
    "label": "slerp()",
    "kind": "Method",
    "detail": "Function (m10 =)",
    "insertText": "slerp(m00, m01, t)"
  },
  {
    "label": "slerp()",
    "kind": "Method",
    "detail": "Function (m11 =)",
    "insertText": "slerp(m01, m02, t)"
  },
  {
    "label": "OPENVDB_IS_POD()",
    "kind": "Method",
    "detail": "Function (} using Quats = Quat<float> ; using Quatd = Quat<double> ; # if OPENVDB_ABI_VERSION_NUMBER> = 8)",
    "insertText": "OPENVDB_IS_POD(Quats) OPENVDB_IS_POD(Quatd) #endif } template<> inline math::Quats zeroVal<math::Quats >()"
  },
  {
    "label": "Quatd()",
    "kind": "Method",
    "detail": "Function (} template<> math::Quatd zeroVal<)",
    "insertText": "Quatd()"
  }
]