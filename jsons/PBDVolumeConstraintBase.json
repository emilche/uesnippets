[
  {
    "label": "FPBDVolumeConstraintBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDVolumeConstraintBase"
  },
  {
    "label": "FPBDVolumeConstraintBase()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / PBDSoftsEvolutionFwd . h \" # include \" Chaos / Array . h \" # include \" Chaos / PBDParticles . h \" # include \" Chaos / ParticleRule . h \" namespace Chaos::Softs { class FPBDVolumeConstraintBase { public :)",
    "insertText": "FPBDVolumeConstraintBase(const FSolverParticles& InParticles, TArray<TVec3<int32>>&& InConstraints, const FSolverReal InStiffness = (FSolverReal)1.) : Constraints(InConstraints), Stiffness(InStiffness)"
  },
  {
    "label": "FSolverVec3()",
    "kind": "Method",
    "detail": "Function (FSolverVec3 Com =)",
    "insertText": "FSolverVec3(0.)"
  },
  {
    "label": "GetX()",
    "kind": "Method",
    "detail": "Function (Com + = InParticles .)",
    "insertText": "GetX(i)"
  },
  {
    "label": "Com()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Com(FSolverReal)InParticles.Size()"
  },
  {
    "label": "RefVolume()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefVolume(FSolverReal)"
  },
  {
    "label": "GetX()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3& P1 = InParticles .)",
    "insertText": "GetX(Constraint[0])"
  },
  {
    "label": "GetX()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3& P2 = InParticles .)",
    "insertText": "GetX(Constraint[1])"
  },
  {
    "label": "GetX()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3& P3 = InParticles .)",
    "insertText": "GetX(Constraint[2])"
  },
  {
    "label": "GetVolume()",
    "kind": "Method",
    "detail": "Function (RefVolume + =)",
    "insertText": "GetVolume(P1, P2, P3, Com)"
  },
  {
    "label": "FPBDVolumeConstraintBase()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FPBDVolumeConstraintBase()"
  },
  {
    "label": "GetWeights()",
    "kind": "Method",
    "detail": "Function (} TArray<FSolverReal>)",
    "insertText": "GetWeights(const FSolverParticles& InParticles, const FSolverReal Alpha)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<FSolverReal> W ; W .)",
    "insertText": "SetNum(InParticles.Size())"
  },
  {
    "label": "OneMinusAlpha()",
    "kind": "Method",
    "detail": "Function (const FSolverReal)",
    "insertText": "OneMinusAlpha(FSolverReal)"
  },
  {
    "label": "Wg()",
    "kind": "Method",
    "detail": "Function (const FSolverReal)",
    "insertText": "Wg(FSolverReal)1. / (FSolverReal)InParticles.Size()"
  },
  {
    "label": "WlDenom()",
    "kind": "Method",
    "detail": "Function (FSolverReal)",
    "insertText": "WlDenom(FSolverReal)"
  },
  {
    "label": "WlDenom()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WlDenom(InParticles.P(i) - InParticles.GetX(i)).Size()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(uint32 i = 0; i < InParticles.Size(); ++i)"
  },
  {
    "label": "Wl()",
    "kind": "Method",
    "detail": "Function (const FSolverReal)",
    "insertText": "Wl(InParticles.P(i) - InParticles.GetX(i)).Size()"
  },
  {
    "label": "GetGradients()",
    "kind": "Method",
    "detail": "Function (W [ i ] = OneMinusAlpha* Wl + Alpha* Wg ; } return W ; } TArray<FSolverVec3>)",
    "insertText": "GetGradients(const FSolverParticles& InParticles)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (Com + = InParticles .)",
    "insertText": "P(i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 i = 0; i < Constraints.Num(); ++i)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (const TVec3<int32>& Constraint = Constraints [ i ] ; const int32 i1 = Constraint [ 0 ] ; const int32 i2 = Constraint [ 1 ] ; const int32 i3 = Constraint [ 2 ] ; const FSolverVec3& P1 = InParticles .)",
    "insertText": "P(i1)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3& P2 = InParticles .)",
    "insertText": "P(i2)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3& P3 = InParticles .)",
    "insertText": "P(i3)"
  },
  {
    "label": "GetArea()",
    "kind": "Method",
    "detail": "Function (const FSolverReal Area =)",
    "insertText": "GetArea(P1, P2, P3)"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 Normal =)",
    "insertText": "GetNormal(P1, P2, P3, Com)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Grads [ i1 ] + = Area* Normal ; Grads [ i2 ] + = Area* Normal ; Grads [ i3 ] + = Area* Normal ; })",
    "insertText": "for(FSolverVec3& Elem : Grads)"
  },
  {
    "label": "Elem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Elem(FSolverReal)1. / (FSolverReal)"
  },
  {
    "label": "GetScalingFactor()",
    "kind": "Method",
    "detail": "Function (} return Grads ; } FSolverReal)",
    "insertText": "GetScalingFactor(const FSolverParticles& InParticles, const TArray<FSolverVec3>& Grads, const TArray<FSolverReal>& W)"
  },
  {
    "label": "Volume()",
    "kind": "Method",
    "detail": "Function (FSolverReal)",
    "insertText": "Volume(FSolverReal)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3& P1 = InParticles .)",
    "insertText": "P(Constraint[0])"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3& P2 = InParticles .)",
    "insertText": "P(Constraint[1])"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3& P3 = InParticles .)",
    "insertText": "P(Constraint[2])"
  },
  {
    "label": "Denom()",
    "kind": "Method",
    "detail": "Function (FSolverReal)",
    "insertText": "Denom(FSolverReal)"
  },
  {
    "label": "SizeSquared()",
    "kind": "Method",
    "detail": "Function (Denom + = W [ i ]* Grads [ i ] .)",
    "insertText": "SizeSquared()"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (} const FSolverReal)",
    "insertText": "S(Volume - RefVolume)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (Stiffness =)",
    "insertText": "Clamp(InStiffness, (FSolverReal)0., (FSolverReal)1.)"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (} protected : TArray<TVec3<int32>> Constraints ; private : FSolverVec3)",
    "insertText": "GetNormal(const FSolverVec3 P1, const FSolverVec3& P2, const FSolverVec3& P3, const FSolverVec3& Com)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 Normal =)",
    "insertText": "CrossProduct(P2 - P1, P3 - P1).GetSafeNormal()"
  },
  {
    "label": "B()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3)",
    "insertText": "B(P2 - P1).GetSafeNormal()"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 H =)",
    "insertText": "DotProduct(B, P3 - P1)"
  },
  {
    "label": "GetVolume()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "GetVolume(const FSolverVec3& P1, const FSolverVec3& P2, const FSolverVec3& P3, const FSolverVec3& Com)"
  }
]