[
  {
    "label": "FSurfaceAreaHeuristic",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSurfaceAreaHeuristic"
  },
  {
    "label": "FIgnoreDirty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIgnoreDirty"
  },
  {
    "label": "FTrackDirty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTrackDirty"
  },
  {
    "label": "FSingleRoot",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSingleRoot"
  },
  {
    "label": "FRoot",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRoot"
  },
  {
    "label": "FRootForest",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRootForest"
  },
  {
    "label": "FLowestCostList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLowestCostList"
  },
  {
    "label": "FDynamicBVH",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDynamicBVH"
  },
  {
    "label": "FNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNode"
  },
  {
    "label": "FMortonArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMortonArray"
  },
  {
    "label": "FRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRange"
  },
  {
    "label": "FSortPair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSortPair"
  },
  {
    "label": "FCreateNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCreateNode"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Misc / AutomationTest . h \" # include \" Math / Bounds . h \" struct FSurfaceAreaHeuristic { float)",
    "insertText": "operator()( const FBounds3f& Bounds)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (FVector3f Extent = Bounds . Max - Bounds . Min ; return Extent . X* Extent . Y + Extent . X* Extent . Z + Extent . Y* Extent . Z ; } } ; struct FIgnoreDirty { int32)",
    "insertText": "Num()"
  },
  {
    "label": "Mark()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Mark(uint32 Index)"
  },
  {
    "label": "ForAll()",
    "kind": "Method",
    "detail": "Function (} template<FFuncType> void)",
    "insertText": "ForAll(const FFuncType& Func)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Add(uint32 Index)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (NodeIsDirty .)",
    "insertText": "Add(true)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (DirtyNodes .)",
    "insertText": "Add(Index)"
  },
  {
    "label": "Func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Func(Index)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (NodeIsDirty [ Index ] = false ; } DirtyNodes .)",
    "insertText": "Reset()"
  },
  {
    "label": "ToRelative()",
    "kind": "Method",
    "detail": "Function (} } ; struct FSingleRoot { struct FRoot { FBounds3f Bounds ; uint32 FirstChild = ~ 0 u ; const FVector3f&)",
    "insertText": "ToRelative(const FVector3f& Position)"
  },
  {
    "label": "Func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Func(Root)"
  },
  {
    "label": "ToRelative()",
    "kind": "Method",
    "detail": "Function (} } ; struct FRootForest { struct FRoot { FVector3d Offset ; FBounds3f Bounds ; uint32 FirstChild ; template<T> FVector3f)",
    "insertText": "ToRelative(const UE::Math::TVector<T>& Position)"
  },
  {
    "label": "ToRelative()",
    "kind": "Method",
    "detail": "Function (} template<T> FBounds3f)",
    "insertText": "ToRelative(const TBounds<T>& Other)"
  },
  {
    "label": "ToAbsolute()",
    "kind": "Method",
    "detail": "Function (} FBounds3d)",
    "insertText": "ToAbsolute(const FBounds3f& Other)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} } ; TArray<FRoot> Roots ; template<T> FRoot&)",
    "insertText": "FindOrAdd(const TBounds<T>& Bounds)"
  },
  {
    "label": "GetCenter()",
    "kind": "Method",
    "detail": "Function (double TileSize = 1 0 2 4 . 0* 1 0 2 4 . 0 ; UE::Math::TVector<T> RootOffset = Bounds .)",
    "insertText": "GetCenter()"
  },
  {
    "label": "RoundToZero()",
    "kind": "Method",
    "detail": "Function (RootOffset . X =)",
    "insertText": "RoundToZero(RootOffset.X)"
  },
  {
    "label": "RoundToZero()",
    "kind": "Method",
    "detail": "Function (RootOffset . Y =)",
    "insertText": "RoundToZero(RootOffset.Y)"
  },
  {
    "label": "RoundToZero()",
    "kind": "Method",
    "detail": "Function (RootOffset . Z =)",
    "insertText": "RoundToZero(RootOffset.Z)"
  },
  {
    "label": "FindByPredicate()",
    "kind": "Method",
    "detail": "Function (RootOffset* = TileSize ; FRoot* Root = Roots .)",
    "insertText": "FindByPredicate([ &RootOffset ]( FRoot& Root ) { return Root.Offset == RootOffset; })"
  },
  {
    "label": "AddDefaulted_GetRef()",
    "kind": "Method",
    "detail": "Function (Root =& Roots .)",
    "insertText": "AddDefaulted_GetRef()"
  },
  {
    "label": "FindChecked()",
    "kind": "Method",
    "detail": "Function (Root -> Offset = RootOffset ; Root -> FirstChild = ~ 0 u ; } return* Root ; } FRoot&)",
    "insertText": "FindChecked(uint32 RootFirstChild)"
  },
  {
    "label": "FindByPredicate()",
    "kind": "Method",
    "detail": "Function (FRoot* Root = Roots .)",
    "insertText": "FindByPredicate([ RootFirstChild ]( FRoot& Root ) { return Root.FirstChild == RootFirstChild; })"
  },
  {
    "label": "RemoveAllSwap()",
    "kind": "Method",
    "detail": "Function (Roots .)",
    "insertText": "RemoveAllSwap([ RootFirstChild ]( FRoot& Root ) { return Root.FirstChild == RootFirstChild; }, EAllowShrinking::No)"
  },
  {
    "label": "ConstLog2()",
    "kind": "Method",
    "detail": "Function (} } } ; uint32)",
    "insertText": "ConstLog2(uint32 x)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (NumZeros = 0 ; } void)",
    "insertText": "Add(float NodeCost, uint32 NodeIndex)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ZeroCostNodes [ NumZeros + + ] = NodeIndex ; } else { Candidates .)",
    "insertText": "Add(FCandidate( NodeCost, NodeIndex ))"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "GetNext(float BestCost, float& NodeCost, uint32& NodeIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (float SmallestCost = Candidates [ CandidateHead ] . Key ; int32 SmallestIndex = CandidateHead ;)",
    "insertText": "for(int32 i = CandidateHead + 1; i < Num; i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float Cost = Candidates [ i ] . Key ;)",
    "insertText": "if(Cost < SmallestCost)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (SmallestCost = Cost ; SmallestIndex = i ; } } NodeCost = SmallestCost ; NodeIndex = Candidates [ SmallestIndex ] . Value ; Candidates .)",
    "insertText": "RemoveAtSwap(SmallestIndex, EAllowShrinking::No)"
  },
  {
    "label": "FDynamicBVH()",
    "kind": "Method",
    "detail": "Function (} return true ; } private : TArray<FCandidate> Candidates ; int32 CandidateHead ; uint32 MaxZeros = 3 2 ; uint32 NumZeros = 0 ; uint32 ZeroCostNodes [ MaxZeros ] ; } ; template<uint32 MaxChildren,FRootPolicy = FSingleRoot,FDirtyPolicy = FIgnoreDirty,FCostMetric = FSurfaceAreaHeuristic> class FDynamicBVH { using FRoot = FRootPolicy::FRoot ; FRootPolicy Roots ; FDirtyPolicy DirtyPolicy ; FCostMetric CostMetric ; public :)",
    "insertText": "FDynamicBVH()"
  },
  {
    "label": "GetNumNodes()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumNodes()"
  },
  {
    "label": "GetNumLeaves()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetNumLeaves()"
  },
  {
    "label": "GetNumDirty()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetNumDirty()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "Add(const TBounds<T>& Bounds, uint32 Index)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "Update(const TBounds<T>& Bounds, uint32 Index)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Remove(uint32 Index)"
  },
  {
    "label": "IsPresent()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPresent(uint32 Index)"
  },
  {
    "label": "AddDefaulted()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddDefaulted()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Leaves .)",
    "insertText": "Add(~0u)"
  },
  {
    "label": "SwapIndexes()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SwapIndexes(uint32 Index0, uint32 Index1)"
  },
  {
    "label": "Build()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Build(const TArray< FBounds3f >& BoundsArray, uint32 FirstIndex)"
  },
  {
    "label": "ForAll()",
    "kind": "Method",
    "detail": "Function (template<T,FFuncType> void)",
    "insertText": "ForAll(const TBounds<T>& Bounds, const FFuncType& Func)"
  },
  {
    "label": "ForAll()",
    "kind": "Method",
    "detail": "Function (template<FPredicate,FFuncType> void)",
    "insertText": "ForAll(const FPredicate& Predicate, const FFuncType& Func)"
  },
  {
    "label": "ForAllDirty()",
    "kind": "Method",
    "detail": "Function (template<FFuncType> void)",
    "insertText": "ForAllDirty(const FFuncType& Func)"
  },
  {
    "label": "FindClosest()",
    "kind": "Method",
    "detail": "Function (template<T,FFuncType> uint32)",
    "insertText": "FindClosest(const UE::Math::TVector<T>& Position, const FFuncType& LeafDistSqr)"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (const FBounds3f&)",
    "insertText": "GetBounds(uint32 Index)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (uint32 NodeIndex = Leaves [ Index ] ; return)",
    "insertText": "GetNode(NodeIndex ).GetBounds( NodeIndex)"
  },
  {
    "label": "GetTotalCost()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetTotalCost()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (float TotalCost = 0 . 0 f ;)",
    "insertText": "for(auto& Node : Nodes)"
  },
  {
    "label": "Check()",
    "kind": "Method",
    "detail": "Function (} } return TotalCost ; } bool)",
    "insertText": "Check()"
  },
  {
    "label": "ConstLog2()",
    "kind": "Method",
    "detail": "Function (} } return true ; } uint32 NumTested = 0 ; protected : uint32 IndexShift =)",
    "insertText": "ConstLog2(MaxChildren)"
  },
  {
    "label": "MaxChildren4()",
    "kind": "Method",
    "detail": "Function (uint32 ChildMask = MaxChildren - 1 ; uint32)",
    "insertText": "MaxChildren4(MaxChildren + 3)"
  },
  {
    "label": "GetFirstChild()",
    "kind": "Method",
    "detail": "Function (struct FNode { uint32 ParentIndex ; uint32 NumChildren ; uint32 ChildIndexes [ MaxChildren ] ; FBounds3f ChildBounds [ MaxChildren ] ; uint32)",
    "insertText": "GetFirstChild(uint32 NodeIndex)"
  },
  {
    "label": "IsFull()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsFull()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FBounds3f Bounds ;)",
    "insertText": "for(uint32 i = 0; i < NumChildren; i++)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (Bounds + = ChildBounds [ i ] ; } return Bounds ; } } ; TArray<FNode> Nodes ; TArray<uint32> Leaves ; uint32 FreeHead = ~ 0 u ; FLowestCostList Candidates ; protected : FNode&)",
    "insertText": "GetNode(uint32 NodeIndex)"
  },
  {
    "label": "Mark()",
    "kind": "Method",
    "detail": "Function (DirtyPolicy .)",
    "insertText": "Mark(NodeIndex >> IndexShift)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(uint32 NodeIndex, const FBounds3f& Bounds, uint32 FirstChild)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetNode(NodeIndex)"
  },
  {
    "label": "SetFirstChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFirstChild(NodeIndex, FirstChild)"
  },
  {
    "label": "SetBounds()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetBounds(uint32 NodeIndex, const FBounds3f& Bounds)"
  },
  {
    "label": "MarkDirty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MarkDirty(NodeIndex)"
  },
  {
    "label": "SetFirstChild()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetFirstChild(uint32 NodeIndex, uint32 FirstChild)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (Leaves [ FirstChild>> 1 ] = NodeIndex ; } else {)",
    "insertText": "GetNode(FirstChild)"
  },
  {
    "label": "MarkDirty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MarkDirty(FirstChild)"
  },
  {
    "label": "FindBestInsertion_BranchAndBound()",
    "kind": "Method",
    "detail": "Function (} } uint32)",
    "insertText": "FindBestInsertion_BranchAndBound(uint32 NodeIndex, const FBounds3f& RESTRICT Bounds)"
  },
  {
    "label": "FindBestInsertion_Greedy()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "FindBestInsertion_Greedy(uint32 NodeIndex, const FBounds3f& RESTRICT Bounds)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "Insert(FRoot& RESTRICT Root, const FBounds3f& RESTRICT Bounds, uint32 NodeIndex)"
  },
  {
    "label": "Extract()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Extract(uint32 NodeIndex)"
  },
  {
    "label": "RemoveAndSwap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAndSwap(uint32 NodeIndex)"
  },
  {
    "label": "RecursivePromoteChild()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RecursivePromoteChild(uint32 NodeIndex)"
  },
  {
    "label": "PromoteChild()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "PromoteChild(uint32 NodeIndex)"
  },
  {
    "label": "Rotate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rotate(uint32 NodeIndex)"
  },
  {
    "label": "AllocNode()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "AllocNode()"
  },
  {
    "label": "FreeNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeNode(uint32 NodeIndex)"
  },
  {
    "label": "CheckNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckNode(uint32 NodeIndex)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (int32 First = Leaves .)",
    "insertText": "AddUninitialized(Count)"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memset(&Leaves[ First ], 0xff, Count * sizeof( uint32 ))"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (} FRoot& Root = Roots .)",
    "insertText": "FindOrAdd(Bounds)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetNode(Root.FirstChild)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(Leaves[ Index ] == ~0u)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (Leaves [ Index ] =)",
    "insertText": "Insert(Root, Root.ToRelative( Bounds ), ( Index << 1 ) | 1)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Remove(Index)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(Bounds, Index)"
  },
  {
    "label": "Extract()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Extract(Leaves[ Index ])"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(Leaves[ Index0 ], Leaves[ Index1 ])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32 NodeIndex0 = Leaves [ Index0 ] ; uint32 NodeIndex1 = Leaves [ Index1 ] ;)",
    "insertText": "if(NodeIndex0 != ~0u)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetNode(NodeIndex0 ).ChildIndexes[ NodeIndex0 & ChildMask ] = (Index0 << 1)"
  },
  {
    "label": "MarkDirty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MarkDirty(NodeIndex0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(NodeIndex1 != ~0u)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetNode(NodeIndex1 ).ChildIndexes[ NodeIndex1 & ChildMask ] = (Index1 << 1)"
  },
  {
    "label": "MarkDirty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MarkDirty(NodeIndex1)"
  },
  {
    "label": "CostMetric()",
    "kind": "Method",
    "detail": "Function (float MinAddedCost = MaxChildren> 2 ? 0 . 0 f :)",
    "insertText": "CostMetric(Bounds)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (float InducedCost = 0 . 0 f ;)",
    "insertText": "while(true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NumTested + + ;)",
    "insertText": "if(Node.IsFull())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FVector4f TotalCost ; FVector4f ChildCost ; uint32 Four = MaxChildren<4 ? MaxChildren : 4 ;)",
    "insertText": "for(uint32 j = 0; j < Four; j++)"
  },
  {
    "label": "CostMetric()",
    "kind": "Method",
    "detail": "Function (const FBounds3f& RESTRICT NodeBounds = Node . ChildBounds [ i + j ] ; float DirectCost =)",
    "insertText": "CostMetric(Bounds + NodeBounds)"
  },
  {
    "label": "CostMetric()",
    "kind": "Method",
    "detail": "Function (TotalCost [ j ] = InducedCost + DirectCost ; ChildCost [ j ] = TotalCost [ j ] -)",
    "insertText": "CostMetric(NodeBounds)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(uint32 j = 0; j < 4 && i + j < Node.NumChildren; j++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BestCost = TotalCost [ j ] ; BestIndex = NodeIndex + i + j ; } uint32 FirstChild = Node . ChildIndexes [ i + j ] ; bool bIsLeaf = FirstChild& 1 ;)",
    "insertText": "if(!bIsLeaf)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Candidates .)",
    "insertText": "Add(ChildCost[j], FirstChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } } } else {)",
    "insertText": "if(InducedCost < BestCost)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (float BestChildDist = MAX_flt ; uint32 BestChildIndex = 0 ;)",
    "insertText": "for(uint32 i = 0; i < Node.NumChildren; i += 4)"
  },
  {
    "label": "Delta()",
    "kind": "Method",
    "detail": "Function (const FBounds3f& RESTRICT NodeBounds = Node . ChildBounds [ i + j ] ; FVector3f)",
    "insertText": "Delta(Bounds.Min - NodeBounds.Min ) + ( Bounds.Max - NodeBounds.Max)"
  },
  {
    "label": "GetAbs()",
    "kind": "Method",
    "detail": "Function (Delta = Delta .)",
    "insertText": "GetAbs()"
  },
  {
    "label": "CostMetric()",
    "kind": "Method",
    "detail": "Function (BestChildDist = Dist [ j ] ; BestChildIndex = i + j ; } } } const FBounds3f& RESTRICT ClosestBounds = Node . ChildBounds [ BestChildIndex ] ; float DirectCost =)",
    "insertText": "CostMetric(Bounds + ClosestBounds)"
  },
  {
    "label": "CostMetric()",
    "kind": "Method",
    "detail": "Function (float TotalCost = InducedCost + DirectCost ; float ChildCost = TotalCost -)",
    "insertText": "CostMetric(ClosestBounds)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BestCost = TotalCost ; BestIndex = NodeIndex + BestChildIndex ; } uint32 FirstChild = Node . ChildIndexes [ BestChildIndex ] ; bool bIsLeaf = FirstChild& 1 ;)",
    "insertText": "if(bIsLeaf)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (InducedCost = ChildCost ; NodeIndex = FirstChild ; } else { return Node . ParentIndex ; })",
    "insertText": "if(InducedCost + MinAddedCost >= BestCost)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (break ; } })",
    "insertText": "while(NodeIndex != ~0u)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (uint32 NodeIndex = Root . FirstChild + RootNode . NumChildren + + ;)",
    "insertText": "Set(NodeIndex, Bounds, Index)"
  },
  {
    "label": "FindBestInsertion_Greedy()",
    "kind": "Method",
    "detail": "Function (Root . Bounds + = Bounds ; return NodeIndex ; } uint32 BestIndex =)",
    "insertText": "FindBestInsertion_Greedy(Root.FirstChild, Bounds)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (uint32 NodeIndex =)",
    "insertText": "GetNode(BestIndex ).GetFirstChild( BestIndex)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (bool bIsLeaf = NodeIndex& 1 ; bool bAddLevel = bIsLeaf | |)",
    "insertText": "GetNode(NodeIndex ).IsFull()"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (FNode& NewNode =)",
    "insertText": "GetNode(NewNodeIndex)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (NewNode . NumChildren = 1 ;)",
    "insertText": "Set(NewNodeIndex, GetNode( BestIndex ).GetBounds( BestIndex ), GetNode( BestIndex ).GetFirstChild( BestIndex ))"
  },
  {
    "label": "SetFirstChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFirstChild(BestIndex, NewNodeIndex)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (FBounds3f PathBounds = Bounds ; uint32 PathIndex = BestIndex ;)",
    "insertText": "while(PathIndex != ~0u)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (FNode& PathNode =)",
    "insertText": "GetNode(PathIndex)"
  },
  {
    "label": "SetBounds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetBounds(PathIndex, PathNode.GetBounds( PathIndex ) + PathBounds)"
  },
  {
    "label": "Rotate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rotate(PathIndex)"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (PathBounds = PathNode .)",
    "insertText": "GetBounds(PathIndex)"
  },
  {
    "label": "RemoveAndSwap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAndSwap(NodeIndex)"
  },
  {
    "label": "UnionBounds()",
    "kind": "Method",
    "detail": "Function (FBounds3f PathBounds = Node .)",
    "insertText": "UnionBounds()"
  },
  {
    "label": "SetBounds()",
    "kind": "Method",
    "detail": "Function (RootIndex = PathIndex ;)",
    "insertText": "SetBounds(PathIndex, PathBounds)"
  },
  {
    "label": "FindChecked()",
    "kind": "Method",
    "detail": "Function (PathIndex = PathNode . ParentIndex ; } Roots .)",
    "insertText": "FindChecked(RootIndex & ~ChildMask)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(Node.ParentIndex, Node.ChildBounds[0], Node.ChildIndexes[0])"
  },
  {
    "label": "FreeNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeNode(NodeIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Node.IsRoot() && Node.NumChildren == 0)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (Roots .)",
    "insertText": "Remove(NodeIndex & ~ChildMask)"
  },
  {
    "label": "RecursivePromoteChild()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "RecursivePromoteChild(NodeIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32 LastChild = - - Node . NumChildren ;)",
    "insertText": "if(( NodeIndex & ChildMask ) < LastChild)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(NodeIndex, Node.GetBounds( LastChild ), Node.GetFirstChild( LastChild ))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (float BestCost = 0 . 0 f ; uint32 BestIndex = ~ 0 u ;)",
    "insertText": "for(uint32 i = 0; i < PathNode.NumChildren; i++)"
  },
  {
    "label": "CostMetric()",
    "kind": "Method",
    "detail": "Function (float Cost =)",
    "insertText": "CostMetric(PathNode.ChildBounds[i])"
  },
  {
    "label": "BestIndex()",
    "kind": "Method",
    "detail": "Function (BestCost = Cost ;)",
    "insertText": "BestIndex(NodeIndex & ~ChildMask)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(BestIndex == ~0u)"
  },
  {
    "label": "PromoteChild()",
    "kind": "Method",
    "detail": "Function (NodeIndex =)",
    "insertText": "PromoteChild(BestIndex)"
  },
  {
    "label": "GetFirstChild()",
    "kind": "Method",
    "detail": "Function (uint32 FirstChild = Node .)",
    "insertText": "GetFirstChild(NodeIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FBounds3f Excluded [ MaxChildren ] ; FBounds3f Forward ; FBounds3f Back ;)",
    "insertText": "for(uint32 i = 0; i < Children.NumChildren; i++)"
  },
  {
    "label": "CostMetric()",
    "kind": "Method",
    "detail": "Function (float Cost =)",
    "insertText": "CostMetric(Excluded[i])"
  },
  {
    "label": "CA_SUPPRESS()",
    "kind": "Method",
    "detail": "Function (BestCost = Cost ; BestIndex = FirstChild | i ; } })",
    "insertText": "CA_SUPPRESS(6385)"
  },
  {
    "label": "SetBounds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetBounds(NodeIndex, Excluded[ BestIndex & ChildMask ])"
  },
  {
    "label": "SiblingIndex()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "SiblingIndex(NodeIndex & ~ChildMask)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(SiblingIndex, Children.GetBounds( BestIndex ), Children.GetFirstChild( BestIndex ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Node . NumChildren + + ; uint32 LastChild = - - Children . NumChildren ;)",
    "insertText": "if(Children.NumChildren == 1)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (uint32 OtherChild = ~ BestIndex& 1 ;)",
    "insertText": "Set(NodeIndex, Children.ChildBounds[ OtherChild ], Children.ChildIndexes[ OtherChild ])"
  },
  {
    "label": "FreeNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeNode(BestIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BestIndex = ~ 0 u ; } else)",
    "insertText": "if(( BestIndex & ChildMask ) != LastChild)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(BestIndex, Children.GetBounds( LastChild ), Children.GetFirstChild( LastChild ))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FBounds3f ExcludedBounds ;)",
    "insertText": "for(uint32 i = 0; i < Node.NumChildren; i++)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (} FNode& ParentNode =)",
    "insertText": "GetNode(Node.ParentIndex)"
  },
  {
    "label": "CostMetric()",
    "kind": "Method",
    "detail": "Function (float BestCost =)",
    "insertText": "CostMetric(ParentNode.GetBounds( Node.ParentIndex ))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (uint32 BestIndex = ~ 0 u ;)",
    "insertText": "for(uint32 i = 0; i < ParentNode.NumChildren; i++)"
  },
  {
    "label": "CostMetric()",
    "kind": "Method",
    "detail": "Function (float Cost =)",
    "insertText": "CostMetric(ExcludedBounds + ParentNode.ChildBounds[i])"
  },
  {
    "label": "BestIndex()",
    "kind": "Method",
    "detail": "Function (BestCost = Cost ;)",
    "insertText": "BestIndex(Node.ParentIndex & ~ChildMask)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(BestIndex != ~0u)"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (FBounds3f Bounds = Node .)",
    "insertText": "GetBounds(NodeIndex)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(NodeIndex, ParentNode.GetBounds( BestIndex ), ParentNode.GetFirstChild( BestIndex ))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(BestIndex, Bounds, FirstChild)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (FreeHead = NextIndex ; NextIndex = ~ 0 u ; return NodeIndex ; } else { DirtyPolicy .)",
    "insertText": "Add(Nodes.Num())"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "check(( FirstChild & ChildMask ) == 0)"
  },
  {
    "label": "ForAll()",
    "kind": "Method",
    "detail": "Function (TArray<uint32,TInlineAllocator<2 5 6>> Stack ; Roots .)",
    "insertText": "ForAll([ this, &Stack, &Bounds, &Func ]( const FRoot& Root ) { FBounds3f RelativeBounds = Root.ToRelative( Bounds ); if( !RelativeBounds.Intersect( Root.Bounds ) ) return; uint32 NodeIndex = Root.FirstChild; while( true ) { const FNode& RESTRICT Node = GetNode( NodeIndex ); for( uint32 i = 0; i < Node.NumChildren; i++ ) { if( RelativeBounds.Intersect( Node.ChildBounds[i] ) ) { uint32 FirstChild = Node.ChildIndexes[i]; if( FirstChild & 1 ) { Func( FirstChild >> 1 ); } else { Stack.Push( FirstChild ); } } } if( Stack.Num() == 0 ) break; NodeIndex = Stack.Pop( EAllowShrinking::No ); } })"
  },
  {
    "label": "ForAll()",
    "kind": "Method",
    "detail": "Function (TArray<uint32,TInlineAllocator<2 5 6>> Stack ; Roots .)",
    "insertText": "ForAll([ this, &Stack, &Predicate, &Func ]( const FRoot& Root ) { if( !Predicate( Root.ToAbsolute( Root.Bounds ) ) ) return; uint32 NodeIndex = Root.FirstChild; while( true ) { const FNode& RESTRICT Node = GetNode( NodeIndex ); for( uint32 i = 0; i < Node.NumChildren; i++ ) { if( Predicate( Root.ToAbsolute( Node.ChildBounds[i] ) ) ) { uint32 FirstChild = Node.ChildIndexes[i]; if( FirstChild & 1 ) { Func( FirstChild >> 1 ); } else { Stack.Push( FirstChild ); } } } if( Stack.Num() == 0 ) break; NodeIndex = Stack.Pop( EAllowShrinking::No ); } })"
  },
  {
    "label": "ForAll()",
    "kind": "Method",
    "detail": "Function (DirtyPolicy .)",
    "insertText": "ForAll([&]( uint32 Index ) { Func( Index, GetNode( Index << IndexShift ) ); })"
  },
  {
    "label": "ForAll()",
    "kind": "Method",
    "detail": "Function (Roots .)",
    "insertText": "ForAll([ this, &Position, &LeafDistSqr, &ClosestDistSqr, &ClosestIndex ]( const FRoot& Root ) { FVector3f RelativePosition = Root.ToRelative( Position ); float NodeDistSqr = Root.Bounds.DistSqr( RelativePosition ); uint32 NodeIndex = Root.FirstChild; while( NodeDistSqr < ClosestDistSqr ) { const FNode& RESTRICT Node = GetNode( NodeIndex ); for( uint32 i = 0; i < Node.NumChildren; i += 4 ) { FVector4f ChildDistSqr; constexpr uint32 Four = MaxChildren < 4 ? MaxChildren : 4; for( uint32 j = 0; j < Four; j++ ) { const FBounds3f& RESTRICT NodeBounds = Node.ChildBounds[ i + j ]; ChildDistSqr[j] = NodeBounds.DistSqr( RelativePosition ); } for( uint32 j = 0; j < 4 && i + j < Node.NumChildren; j++ ) { if( ChildDistSqr[j] < ClosestDistSqr ) { uint32 FirstChild = Node.ChildIndexes[ i + j ]; if( FirstChild & 1 ) { uint32 Index = FirstChild >> 1; float DistSqr = LeafDistSqr( Position, Index ); if( DistSqr < ClosestDistSqr ) { ClosestDistSqr = DistSqr; ClosestIndex = Index; } } else { Candidates.Add( ChildDistSqr[j], FirstChild ); } } } } if( !Candidates.GetNext( ClosestDistSqr, NodeDistSqr, NodeIndex ) ) break; } })"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetIndex(int32 i)"
  },
  {
    "label": "RegenerateCodes()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "RegenerateCodes(const FRange& Range)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (struct FSortPair { uint32 Code ; uint32 Index ; bool)",
    "insertText": "operator(const FSortPair& Other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32 Code0 = Sorted [ Range . Begin ] . Code ; uint32 Code1 = Sorted [ Range . End - 1 ] . Code ; uint32 Diff = Code0 ^ Code1 ;)",
    "insertText": "if(Diff == 0)"
  },
  {
    "label": "RegenerateCodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegenerateCodes(Range)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Code0 = Sorted [ Range . Begin ] . Code ; Code1 = Sorted [ Range . End - 1 ] . Code ; Diff = Code0 ^ Code1 ;)",
    "insertText": "if(Diff == 0 ) return ( Range.Begin + Range.End)"
  },
  {
    "label": "FloorLog2()",
    "kind": "Method",
    "detail": "Function (} uint32 HighestBitDiff =)",
    "insertText": "FloorLog2(Diff)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (uint32 Mask = 1<<HighestBitDiff ; int32 Min = Range . Begin ; int32 Max = Range . End ;)",
    "insertText": "while(Min + 1 != Max)"
  },
  {
    "label": "Mid()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Mid(Min + Max)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32 Count = FirstIndex + BoundsArray .)",
    "insertText": "Num() - Leaves.Num()"
  },
  {
    "label": "MortonArray()",
    "kind": "Method",
    "detail": "Function (} FMortonArray)",
    "insertText": "MortonArray(BoundsArray)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (using FRange = FMortonArray::FRange ; FRoot& Root = Roots .)",
    "insertText": "FindOrAdd(FBounds3f( { FVector3f::ZeroVector, FVector3f::ZeroVector } ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Node . ParentIndex = ParentIndex ;)",
    "insertText": "if(ParentIndex != ~0u ) SetFirstChild( ParentIndex, NodeIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Node . NumChildren = NumLeaves ;)",
    "insertText": "for(int32 i = 0; i < NumLeaves; i++)"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (uint32 Index = MortonArray .)",
    "insertText": "GetIndex(Range.Begin + i)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(NodeIndex + i, BoundsArray[ Index ], ( ( FirstIndex + Index ) << 1 ) | 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (PathIndex = PathNode . ParentIndex ; })",
    "insertText": "if(Stack.Num() == 0)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (ParentIndex = Stack .)",
    "insertText": "Last()"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (Stack .)",
    "insertText": "Pop(EAllowShrinking::No)"
  },
  {
    "label": "Split()",
    "kind": "Method",
    "detail": "Function (} else { FRange Children [ MaxChildren ] ; Children [ 0 ] = Range ; int32 NumChildren = 1 ; int32 SplitIndex = 0 ; do { FRange Child = Children [ SplitIndex ] ; uint32 Middle = MortonArray .)",
    "insertText": "Split(Child)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Children [ SplitIndex ] . Begin = Child . Begin ; Children [ SplitIndex ] . End = Middle ; Children [ NumChildren ] . Begin = Middle ; Children [ NumChildren ] . End = Child . End ; NumChildren + + ; int32 LargestNum = 0 ; int32 LargestIndex = - 1 ;)",
    "insertText": "for(int32 i = 0; i < NumChildren; i++)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (LargestNum = Num ; LargestIndex = i ; } } SplitIndex = LargestIndex ; })",
    "insertText": "while(NumChildren < MaxChildren && SplitIndex >= 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Node . NumChildren = NumChildren ;)",
    "insertText": "for(int32 Front = 0, Back = NumChildren - 1; Front < Back;)"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (NumLeaves + + ; uint32 Index = MortonArray .)",
    "insertText": "GetIndex(Children[i].Begin)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(NumLeaves < NumChildren)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 Last = NumChildren - NumLeaves - 1 ;)",
    "insertText": "for(int32 i = 0; i < Last; i++)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (Stack .)",
    "insertText": "Push({ NodeIndex + i, Children[i] })"
  }
]