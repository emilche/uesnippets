[
  {
    "label": "FunctionWrapperWithNotification",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FunctionWrapperWithNotification"
  },
  {
    "label": "FunctionWrapperWithBarrier",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FunctionWrapperWithBarrier"
  },
  {
    "label": "Allocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Allocator"
  },
  {
    "label": "ThreadPoolDevice",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ThreadPoolDevice"
  },
  {
    "label": "Function",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Function"
  },
  {
    "label": "ParallelForAsyncContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ParallelForAsyncContext"
  },
  {
    "label": "ParallelForBlock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ParallelForBlock"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(EIGEN_USE_THREADS) && !defined(EIGEN_CXX11_TENSOR_TENSOR_DEVICE_THREAD_POOL_H)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (template<Function,. . . Args> struct FunctionWrapperWithNotification { void)",
    "insertText": "run(Notification* n, Function f, Args... args)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "f(args...)"
  },
  {
    "label": "Notify()",
    "kind": "Method",
    "detail": "Function (n ->)",
    "insertText": "Notify()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } } ; template<Function,. . . Args> struct FunctionWrapperWithBarrier { void)",
    "insertText": "run(Barrier* b, Function f, Args... args)"
  },
  {
    "label": "wait_until_ready()",
    "kind": "Method",
    "detail": "Function (} } } ; template<SyncType> EIGEN_STRONG_INLINE void)",
    "insertText": "wait_until_ready(SyncType* n)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (n ->)",
    "insertText": "Wait()"
  },
  {
    "label": "Allocator()",
    "kind": "Method",
    "detail": "Function (} } class Allocator { public : ~)",
    "insertText": "Allocator()"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "allocate(size_t num_bytes)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deallocate(void* buffer)"
  },
  {
    "label": "ThreadPoolDevice()",
    "kind": "Method",
    "detail": "Function (} ; struct ThreadPoolDevice {)",
    "insertText": "ThreadPoolDevice(ThreadPoolInterface* pool, int num_cores, Allocator* allocator = nullptr) : pool_(pool), num_threads_(num_cores), allocator_(allocator)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (allocator_ ->)",
    "insertText": "deallocate(buffer)"
  },
  {
    "label": "aligned_free()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "aligned_free(buffer)"
  },
  {
    "label": "allocate_temp()",
    "kind": "Method",
    "detail": "Function (} } EIGEN_STRONG_INLINE void*)",
    "insertText": "allocate_temp(size_t num_bytes)"
  },
  {
    "label": "deallocate_temp()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "deallocate_temp(void* buffer)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<Type> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Type)",
    "insertText": "get(Type data)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (# ifdef)",
    "insertText": "memcpy(dst, src, n)"
  },
  {
    "label": "numThreads()",
    "kind": "Method",
    "detail": "Function (# else const size_t kMinBlockSize = 3 2 7 6 8 ; const size_t num_threads =)",
    "insertText": "numThreads(n, TensorOpCost(1.0, 1.0, 0), 4)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (} else { const char* src_ptr = static_cast<const)",
    "insertText": "char(src)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (char* dst_ptr = static_cast<)",
    "insertText": "char(dst)"
  },
  {
    "label": "blocksize()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "blocksize(n + (num_threads - 1))"
  },
  {
    "label": "barrier()",
    "kind": "Method",
    "detail": "Function (Barrier)",
    "insertText": "barrier(static_cast<int>(num_threads - 1))"
  },
  {
    "label": "enqueue_with_barrier()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enqueue_with_barrier(&barrier, [n, i, src_ptr, dst_ptr, blocksize] { ::memcpy(dst_ptr + i * blocksize, src_ptr + i * blocksize, numext::mini(blocksize, n - (i * blocksize))); })"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(dst_ptr, src_ptr, blocksize)"
  },
  {
    "label": "memcpyHostToDevice()",
    "kind": "Method",
    "detail": "Function (} # endif } EIGEN_STRONG_INLINE void)",
    "insertText": "memcpyHostToDevice(void* dst, const void* src, size_t n)"
  },
  {
    "label": "memcpyDeviceToHost()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "memcpyDeviceToHost(void* dst, const void* src, size_t n)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "memset(void* buffer, int c, size_t n)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(buffer, c, n)"
  },
  {
    "label": "numThreads()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE int)",
    "insertText": "numThreads()"
  },
  {
    "label": "firstLevelCacheSize()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE size_t)",
    "insertText": "firstLevelCacheSize()"
  },
  {
    "label": "lastLevelCacheSize()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE size_t)",
    "insertText": "lastLevelCacheSize()"
  },
  {
    "label": "majorDeviceVersion()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int)",
    "insertText": "majorDeviceVersion()"
  },
  {
    "label": "Notification()",
    "kind": "Method",
    "detail": "Function (Notification* n = new)",
    "insertText": "Notification()"
  },
  {
    "label": "Schedule()",
    "kind": "Method",
    "detail": "Function (pool_ ->)",
    "insertText": "Schedule(std::bind(&FunctionWrapperWithNotification<Function, Args...>::run, n, std::move(f), args...))"
  },
  {
    "label": "Schedule()",
    "kind": "Method",
    "detail": "Function (pool_ ->)",
    "insertText": "Schedule(std::bind(&FunctionWrapperWithBarrier<Function, Args...>::run, b, std::move(f), args...))"
  },
  {
    "label": "enqueueNoNotification()",
    "kind": "Method",
    "detail": "Function (} template<class Function,class . . . Args> EIGEN_STRONG_INLINE void)",
    "insertText": "enqueueNoNotification(Function&& f, Args&&... args)"
  },
  {
    "label": "Schedule()",
    "kind": "Method",
    "detail": "Function (pool_ ->)",
    "insertText": "Schedule(std::bind(std::move(f), args...))"
  },
  {
    "label": "Schedule()",
    "kind": "Method",
    "detail": "Function (} else { pool_ ->)",
    "insertText": "Schedule(std::move(f))"
  },
  {
    "label": "currentThreadId()",
    "kind": "Method",
    "detail": "Function (} } EIGEN_STRONG_INLINE int)",
    "insertText": "currentThreadId()"
  },
  {
    "label": "parallelFor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "parallelFor(Index n, const TensorOpCost& cost, std::function<Index(Index)> block_align, std::function<void(Index, Index)> f)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "f(0, n)"
  },
  {
    "label": "barrier()",
    "kind": "Method",
    "detail": "Function (Barrier)",
    "insertText": "barrier(static_cast<unsigned int>(block.count))"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (std::function<)",
    "insertText": "void(Index, Index)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (handleRange = [ =,& handleRange,& barrier,&)",
    "insertText": "f(Index firstIdx, Index lastIdx)"
  },
  {
    "label": "divup()",
    "kind": "Method",
    "detail": "Function (const Index midIdx = firstIdx +)",
    "insertText": "divup((lastIdx - firstIdx) / 2, block.size)"
  },
  {
    "label": "Schedule()",
    "kind": "Method",
    "detail": "Function (pool_ ->)",
    "insertText": "Schedule([=, &handleRange]() { handleRange(midIdx, lastIdx); })"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (lastIdx = midIdx ; })",
    "insertText": "f(firstIdx, lastIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "if(block.count <= numThreads())"
  },
  {
    "label": "handleRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "handleRange(0, n)"
  },
  {
    "label": "Schedule()",
    "kind": "Method",
    "detail": "Function (} else { pool_ ->)",
    "insertText": "Schedule([=, &handleRange]() { handleRange(0, n); })"
  },
  {
    "label": "parallelFor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "parallelFor(Index n, const TensorOpCost& cost, std::function<void(Index, Index)> f)"
  },
  {
    "label": "parallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallelFor(n, cost, nullptr, std::move(f))"
  },
  {
    "label": "parallelForAsync()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "parallelForAsync(Index n, const TensorOpCost& cost, std::function<Index(Index)> block_align, std::function<void(Index, Index)> f, std::function<void()> done)"
  },
  {
    "label": "ParallelForAsyncContext()",
    "kind": "Method",
    "detail": "Function (ParallelForAsyncContext* const ctx = new)",
    "insertText": "ParallelForAsyncContext(block.count, std::move(f), std::move(done))"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (ctx -> handle_range = [ this,ctx,)",
    "insertText": "block(Index firstIdx, Index lastIdx)"
  },
  {
    "label": "Schedule()",
    "kind": "Method",
    "detail": "Function (pool_ ->)",
    "insertText": "Schedule([ctx, midIdx, lastIdx]() { ctx->handle_range(midIdx, lastIdx); })"
  },
  {
    "label": "handle_range()",
    "kind": "Method",
    "detail": "Function (ctx ->)",
    "insertText": "handle_range(0, n)"
  },
  {
    "label": "Schedule()",
    "kind": "Method",
    "detail": "Function (} else { pool_ ->)",
    "insertText": "Schedule([ctx, n]() { ctx->handle_range(0, n); })"
  },
  {
    "label": "parallelForAsync()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "parallelForAsync(Index n, const TensorOpCost& cost, std::function<void(Index, Index)> f, std::function<void()> done)"
  },
  {
    "label": "parallelForAsync()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallelForAsync(n, cost, nullptr, std::move(f), std::move(done))"
  },
  {
    "label": "getPool()",
    "kind": "Method",
    "detail": "Function (} ThreadPoolInterface*)",
    "insertText": "getPool()"
  },
  {
    "label": "ParallelForAsyncContext()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ParallelForAsyncContext()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (std::function<)",
    "insertText": "void()"
  },
  {
    "label": "CalculateParallelForBlock()",
    "kind": "Method",
    "detail": "Function (} ; struct ParallelForBlock { Index size ; Index count ; } ; ParallelForBlock)",
    "insertText": "CalculateParallelForBlock(const Index n, const TensorOpCost& cost, std::function<Index(Index)> block_align)"
  },
  {
    "label": "taskSize()",
    "kind": "Method",
    "detail": "Function (const double block_size_f = 1 . 0 /)",
    "insertText": "taskSize(1, cost)"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (const Index max_oversharding_factor = 4 ; Index block_size =)",
    "insertText": "mini(n, numext::maxi<Index>( divup<Index>(n, max_oversharding_factor * numThreads()), block_size_f))"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (const Index max_block_size =)",
    "insertText": "mini(n, 2 * block_size)"
  },
  {
    "label": "block_align()",
    "kind": "Method",
    "detail": "Function (Index new_block_size =)",
    "insertText": "block_align(block_size)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(new_block_size >= block_size)"
  },
  {
    "label": "mini()",
    "kind": "Method",
    "detail": "Function (block_size =)",
    "insertText": "mini(n, new_block_size)"
  },
  {
    "label": "divup()",
    "kind": "Method",
    "detail": "Function (} Index block_count =)",
    "insertText": "divup(n, block_size)"
  },
  {
    "label": "divup()",
    "kind": "Method",
    "detail": "Function (Index coarser_block_size =)",
    "insertText": "divup(n, prev_block_count - 1)"
  },
  {
    "label": "block_align()",
    "kind": "Method",
    "detail": "Function (Index new_block_size =)",
    "insertText": "block_align(coarser_block_size)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(new_block_size >= coarser_block_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(coarser_block_size > max_block_size)"
  },
  {
    "label": "divup()",
    "kind": "Method",
    "detail": "Function (break ; } const Index coarser_block_count =)",
    "insertText": "divup(n, coarser_block_size)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(coarser_block_count < prev_block_count)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (prev_block_count = coarser_block_count ; const double coarser_efficiency = static_cast<)",
    "insertText": "double(coarser_block_count) / (divup<int>(coarser_block_count, numThreads()) * numThreads())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (block_size = coarser_block_size ; block_count = coarser_block_count ;)",
    "insertText": "if(max_efficiency < coarser_efficiency)"
  }
]