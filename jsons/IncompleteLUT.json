[
  {
    "label": "IncompleteLUT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IncompleteLUT"
  },
  {
    "label": "keep_diag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "keep_diag"
  },
  {
    "label": "QuickSplit()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_INCOMPLETE_LUT_H # define EIGEN_INCOMPLETE_LUT_H namespace Eigen { namespace internal { template<VectorV,VectorI> Index)",
    "insertText": "QuickSplit(VectorV &row, VectorI &ind, Index ncut)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (typedef VectorV::RealScalar RealScalar ; using std::swap ; using std::abs ; Index mid ; Index n = row .)",
    "insertText": "size()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index first,last ; ncut - - ; first = 0 ; last = n - 1 ;)",
    "insertText": "if(ncut < first || ncut > last)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (+ + mid ;)",
    "insertText": "swap(row(mid), row(j))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(ind(mid), ind(j))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "swap(row(mid), row(first))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(ind(mid), ind(first))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(mid != ncut)"
  },
  {
    "label": "IncompleteLUT()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType>)",
    "insertText": "IncompleteLUT(const MatrixType& mat, const RealScalar& droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10) : m_droptol(droptol),m_fillfactor(fillfactor), m_analysisIsOk(false),m_factorizationIsOk(false)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(fillfactor != 0)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(mat)"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (} EIGEN_CONSTEXPR Index)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} EIGEN_CONSTEXPR Index)",
    "insertText": "cols()"
  },
  {
    "label": "info()",
    "kind": "Method",
    "detail": "Function (} ComputationInfo)",
    "insertText": "info()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized && \"IncompleteLUT is not initialized.\")"
  },
  {
    "label": "factorize()",
    "kind": "Method",
    "detail": "Function (template<MatrixType> void)",
    "insertText": "factorize(const MatrixType& amat)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (template<MatrixType> IncompleteLUT&)",
    "insertText": "compute(const MatrixType& amat)"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "analyzePattern(amat)"
  },
  {
    "label": "factorize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "factorize(amat)"
  },
  {
    "label": "setFillfactor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setFillfactor(int fillfactor)"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (template<Rhs,Dest> void)",
    "insertText": "_solve_impl(const Rhs& b, Dest& x)"
  },
  {
    "label": "UnitLower()",
    "kind": "Method",
    "detail": "Function (x = m_Pinv* b ; x = m_lu . template triangularView<)",
    "insertText": "UnitLower().solve(x)"
  },
  {
    "label": "Upper()",
    "kind": "Method",
    "detail": "Function (x = m_lu . template triangularView<)",
    "insertText": "Upper().solve(x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (x = m_P* x ; } protected : struct keep_diag { bool)",
    "insertText": "operator() (const Index& row, const Index& col, const Scalar&)"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (this -> m_fillfactor = fillfactor ; } template<Scalar,StorageIndex> template<_MatrixType> void IncompleteLUT<Scalar,StorageIndex)",
    "insertText": "analyzePattern(const _MatrixType& amat)"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (SparseMatrix<Scalar,ColMajor,StorageIndex> mat1 = amat ; SparseMatrix<Scalar,ColMajor,StorageIndex> mat2 = amat .)",
    "insertText": "transpose()"
  },
  {
    "label": "ordering()",
    "kind": "Method",
    "detail": "Function (SparseMatrix<Scalar,ColMajor,StorageIndex> AtA = mat2 + mat1 ; AMDOrdering<StorageIndex> ordering ;)",
    "insertText": "ordering(AtA,m_P)"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (m_Pinv = m_P .)",
    "insertText": "inverse()"
  },
  {
    "label": "factorize()",
    "kind": "Method",
    "detail": "Function (m_analysisIsOk = true ; m_factorizationIsOk = false ; m_isInitialized = true ; } template<Scalar,StorageIndex> template<_MatrixType> void IncompleteLUT<Scalar,StorageIndex)",
    "insertText": "factorize(const _MatrixType& amat)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (using std::sqrt ; using std::swap ; using std::abs ; using internal::convert_index ;)",
    "insertText": "eigen_assert((amat.rows() == amat.cols()) && \"The factorization should be done on a square matrix\")"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_lu .)",
    "insertText": "resize(n,n)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (Vector)",
    "insertText": "u(n)"
  },
  {
    "label": "ju()",
    "kind": "Method",
    "detail": "Function (VectorI)",
    "insertText": "ju(n)"
  },
  {
    "label": "jr()",
    "kind": "Method",
    "detail": "Function (VectorI)",
    "insertText": "jr(n)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_analysisIsOk && \"You must first call analyzePattern()\")"
  },
  {
    "label": "twistedBy()",
    "kind": "Method",
    "detail": "Function (SparseMatrix<Scalar,RowMajor,StorageIndex> mat ; mat = amat .)",
    "insertText": "twistedBy(m_Pinv)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (jr .)",
    "insertText": "fill(-1)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (ju .)",
    "insertText": "fill(0)"
  },
  {
    "label": "fill_in()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "fill_in(amat.nonZeros()*m_fillfactor)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (Index nnzL = fill_in / 2 ; Index nnzU = nnzL ; m_lu .)",
    "insertText": "reserve(n * (nnzL + nnzU + 1))"
  },
  {
    "label": "ju()",
    "kind": "Method",
    "detail": "Function (Index sizeu = 1 ; Index sizel = 0 ;)",
    "insertText": "ju(ii) = convert_index<StorageIndex>(ii)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "u(ii)"
  },
  {
    "label": "jr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "jr(ii) = convert_index<StorageIndex>(ii)"
  },
  {
    "label": "j_it()",
    "kind": "Method",
    "detail": "Function (RealScalar rownorm = 0 ; FactorType::InnerIterator)",
    "insertText": "j_it(mat, ii)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (Index k = j_it .)",
    "insertText": "index()"
  },
  {
    "label": "ju()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ju(sizel) = convert_index<StorageIndex>(k)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "u(sizel) = j_it.value()"
  },
  {
    "label": "jr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "jr(k) = convert_index<StorageIndex>(sizel)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + sizel ; } else)",
    "insertText": "if(k == ii)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "u(ii) = j_it.value()"
  },
  {
    "label": "ju()",
    "kind": "Method",
    "detail": "Function (} else { Index jpos = ii + sizeu ;)",
    "insertText": "ju(jpos) = convert_index<StorageIndex>(k)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "u(jpos) = j_it.value()"
  },
  {
    "label": "jr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "jr(k) = convert_index<StorageIndex>(jpos)"
  },
  {
    "label": "abs2()",
    "kind": "Method",
    "detail": "Function (+ + sizeu ; } rownorm + =)",
    "insertText": "abs2(j_it.value())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(rownorm==0)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (m_info = NumericalIssue ; return ; } rownorm =)",
    "insertText": "sqrt(rownorm)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Index jj = 0 ; Index len = 0 ;)",
    "insertText": "while(jj < sizel)"
  },
  {
    "label": "segment()",
    "kind": "Method",
    "detail": "Function (Index k ; Index minrow = ju .)",
    "insertText": "segment(jj,sizel-jj).minCoeff(&k)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (k + = jj ;)",
    "insertText": "if(minrow != ju(jj))"
  },
  {
    "label": "ju()",
    "kind": "Method",
    "detail": "Function (Index j =)",
    "insertText": "ju(jj)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(ju(jj), ju(k))"
  },
  {
    "label": "jr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "jr(minrow) = convert_index<StorageIndex>(jj)"
  },
  {
    "label": "jr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "jr(j) = convert_index<StorageIndex>(k)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(u(jj), u(k))"
  },
  {
    "label": "jr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "jr(minrow)"
  },
  {
    "label": "ki_it()",
    "kind": "Method",
    "detail": "Function (FactorType::InnerIterator)",
    "insertText": "ki_it(m_lu, minrow)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(ki_it && ki_it.col()==minrow)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (Scalar fact =)",
    "insertText": "u(jj) / ki_it.value()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (jj + + ; continue ; } + + ki_it ;)",
    "insertText": "for(; ki_it; ++ki_it)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (Scalar prod = fact* ki_it .)",
    "insertText": "value()"
  },
  {
    "label": "jr()",
    "kind": "Method",
    "detail": "Function (Index jpos =)",
    "insertText": "jr(j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index newpos ;)",
    "insertText": "if(j >= ii)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (newpos = ii + sizeu ; sizeu + + ;)",
    "insertText": "eigen_internal_assert(sizeu<=n)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (} else { newpos = sizel ; sizel + + ;)",
    "insertText": "eigen_internal_assert(sizel<=ii)"
  },
  {
    "label": "ju()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ju(newpos) = convert_index<StorageIndex>(j)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "u(newpos)"
  },
  {
    "label": "jr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "jr(j) = convert_index<StorageIndex>(newpos)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "u(jpos)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "u(len)"
  },
  {
    "label": "ju()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ju(len) = convert_index<StorageIndex>(minrow)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (+ + len ; jj + + ; })",
    "insertText": "for(Index k = 0; k <sizeu; k++) jr(ju(ii+k))"
  },
  {
    "label": "len()",
    "kind": "Method",
    "detail": "Function (sizel = len ;)",
    "insertText": "len(std::min)(sizel, nnzL)"
  },
  {
    "label": "ul()",
    "kind": "Method",
    "detail": "Function (Vector::SegmentReturnType)",
    "insertText": "ul(u.segment(0, sizel))"
  },
  {
    "label": "jul()",
    "kind": "Method",
    "detail": "Function (VectorI::SegmentReturnType)",
    "insertText": "jul(ju.segment(0, sizel))"
  },
  {
    "label": "QuickSplit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "QuickSplit(ul, jul, len)"
  },
  {
    "label": "startVec()",
    "kind": "Method",
    "detail": "Function (m_lu .)",
    "insertText": "startVec(ii)"
  },
  {
    "label": "insertBackByOuterInnerUnordered()",
    "kind": "Method",
    "detail": "Function (m_lu .)",
    "insertText": "insertBackByOuterInnerUnordered(ii, ii) = u(ii)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (len = 0 ;)",
    "insertText": "for(Index k = 1; k < sizeu; k++)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (+ + len ;)",
    "insertText": "u(ii + len) = u(ii + k)"
  },
  {
    "label": "ju()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ju(ii + len) = ju(ii + k)"
  },
  {
    "label": "len()",
    "kind": "Method",
    "detail": "Function (} } sizeu = len + 1 ;)",
    "insertText": "len(std::min)(sizeu, nnzU)"
  },
  {
    "label": "uu()",
    "kind": "Method",
    "detail": "Function (Vector::SegmentReturnType)",
    "insertText": "uu(u.segment(ii+1, sizeu-1))"
  },
  {
    "label": "juu()",
    "kind": "Method",
    "detail": "Function (VectorI::SegmentReturnType)",
    "insertText": "juu(ju.segment(ii+1, sizeu-1))"
  },
  {
    "label": "QuickSplit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "QuickSplit(uu, juu, len)"
  },
  {
    "label": "finalize()",
    "kind": "Method",
    "detail": "Function (} m_lu .)",
    "insertText": "finalize()"
  },
  {
    "label": "makeCompressed()",
    "kind": "Method",
    "detail": "Function (m_lu .)",
    "insertText": "makeCompressed()"
  }
]