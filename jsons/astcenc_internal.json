[
  {
    "label": "endpoint_formats",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "endpoint_formats"
  },
  {
    "label": "quant_method",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "quant_method"
  },
  {
    "label": "partition_metrics",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "partition_metrics"
  },
  {
    "label": "partition_lines3",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "partition_lines3"
  },
  {
    "label": "partition_info",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "partition_info"
  },
  {
    "label": "decimation_info",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "decimation_info"
  },
  {
    "label": "block_mode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "block_mode"
  },
  {
    "label": "decimation_mode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "decimation_mode"
  },
  {
    "label": "block_size_descriptor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "block_size_descriptor"
  },
  {
    "label": "image_block",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "image_block"
  },
  {
    "label": "endpoints",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "endpoints"
  },
  {
    "label": "endpoints_and_weights",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "endpoints_and_weights"
  },
  {
    "label": "encoding_choice_errors",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "encoding_choice_errors"
  },
  {
    "label": "alignas",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "alignas"
  },
  {
    "label": "dt_init_working_buffers",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "dt_init_working_buffers"
  },
  {
    "label": "quant_and_transfer_table",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "quant_and_transfer_table"
  },
  {
    "label": "symbolic_compressed_block",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "symbolic_compressed_block"
  },
  {
    "label": "physical_compressed_block",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "physical_compressed_block"
  },
  {
    "label": "pixel_region_args",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "pixel_region_args"
  },
  {
    "label": "avg_args",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "avg_args"
  },
  {
    "label": "TraceLog",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TraceLog"
  },
  {
    "label": "astcenc_contexti",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "astcenc_contexti"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef ASTCENC_INTERNAL_INCLUDED # define ASTCENC_INTERNAL_INCLUDED # include<algorithm> # include<cstddef> # include<cstdint> # if)",
    "insertText": "defined(ASTCENC_DIAGNOSTICS) #include <cstdio> #endif #include <cstdlib> #include \"astcenc.h\" #include \"astcenc_mathlib.h\" #include \"astcenc_vecmathlib.h\" #if defined(NDEBUG) #if !defined(__clang__) && defined(_MSC_VER) #define promise(cond) __assume(cond) #elif defined(__clang__) #if __has_builtin(__builtin_assume) #define promise(cond) __builtin_assume(cond) #elif __has_builtin(__builtin_unreachable) #define promise(cond) if (!(cond))"
  },
  {
    "label": "__builtin_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__builtin_unreachable()"
  },
  {
    "label": "promise()",
    "kind": "Method",
    "detail": "Function (} # else # define)",
    "insertText": "promise(cond) #endif #else #define promise(cond) if (!(cond))"
  },
  {
    "label": "promise()",
    "kind": "Method",
    "detail": "Function (} # endif # else # define)",
    "insertText": "promise(cond) assert(cond) #endif #if !defined(ASTCENC_BLOCK_MAX_TEXELS)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (ASTCENC_BLOCK_MAX_TEXELS } ; unsigned int BLOCK_MAX_COMPONENTS { 4 } ; unsigned int BLOCK_MAX_PARTITIONS { 4 } ; unsigned int BLOCK_MAX_PARTITIONINGS { 1 0 2 4 } ; uint8_t BLOCK_MAX_KMEANS_TEXELS { 6 4 } ; unsigned int BLOCK_MAX_WEIGHTS { 6 4 } ; unsigned int BLOCK_MAX_WEIGHTS_2PLANE { BLOCK_MAX_WEIGHTS / 2 } ; unsigned int BLOCK_MIN_WEIGHT_BITS { 2 4 } ; unsigned int BLOCK_MAX_WEIGHT_BITS { 9 6 } ; uint16_t BLOCK_BAD_BLOCK_MODE { 0 xFFFFu } ; uint16_t BLOCK_BAD_PARTITIONING { 0 xFFFFu } ; unsigned int PARTITION_INDEX_BITS { 1 0 } ; unsigned int WEIGHTS_PLANE2_OFFSET { BLOCK_MAX_WEIGHTS_2PLANE } ; float WEIGHTS_TEXEL_SUM { 1 6 . 0 f } ; unsigned int WEIGHTS_MAX_BLOCK_MODES { 2 0 4 8 } ; unsigned int WEIGHTS_MAX_DECIMATION_MODES { 8 7 } ; float ERROR_CALC_DEFAULT { 1 e30f } ; unsigned int TUNE_MIN_TEXELS_MODE0_FASTPATH { 2 4 } ; unsigned int TUNE_MAX_TRIAL_CANDIDATES { 8 } ; unsigned int TUNE_MAX_PARTITIIONING_CANDIDATES { 3 2 } ; unsigned int TUNE_MAX_ANGULAR_QUANT { 7 } ;)",
    "insertText": "static_assert((BLOCK_MAX_TEXELS % ASTCENC_SIMD_WIDTH) == 0, \"BLOCK_MAX_TEXELS must be multiple of ASTCENC_SIMD_WIDTH\")"
  },
  {
    "label": "get_quant_level()",
    "kind": "Method",
    "detail": "Function (enum endpoint_formats { FMT_LUMINANCE = 0,FMT_LUMINANCE_DELTA = 1,FMT_HDR_LUMINANCE_LARGE_RANGE = 2,FMT_HDR_LUMINANCE_SMALL_RANGE = 3,FMT_LUMINANCE_ALPHA = 4,FMT_LUMINANCE_ALPHA_DELTA = 5,FMT_RGB_SCALE = 6,FMT_HDR_RGB_SCALE = 7,FMT_RGB = 8,FMT_RGB_DELTA = 9,FMT_RGB_SCALE_ALPHA = 1 0,FMT_HDR_RGB = 1 1,FMT_RGBA = 1 2,FMT_RGBA_DELTA = 1 3,FMT_HDR_RGB_LDR_ALPHA = 1 4,FMT_HDR_RGBA = 1 5 } ; enum quant_method { QUANT_2 = 0,QUANT_3 = 1,QUANT_4 = 2,QUANT_5 = 3,QUANT_6 = 4,QUANT_8 = 5,QUANT_10 = 6,QUANT_12 = 7,QUANT_16 = 8,QUANT_20 = 9,QUANT_24 = 1 0,QUANT_32 = 1 1,QUANT_40 = 1 2,QUANT_48 = 1 3,QUANT_64 = 1 4,QUANT_80 = 1 5,QUANT_96 = 1 6,QUANT_128 = 1 7,QUANT_160 = 1 8,QUANT_192 = 1 9,QUANT_256 = 2 0 } ; unsigned int)",
    "insertText": "get_quant_level(quant_method method)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (uint8_t weight_texel_count [ BLOCK_MAX_WEIGHTS ] ; uint8_t weight_texel [ BLOCK_MAX_TEXELS ] [ BLOCK_MAX_WEIGHTS ] ;)",
    "insertText": "alignas(ASTCENC_VECALIGN)"
  },
  {
    "label": "get_weight_quant_mode()",
    "kind": "Method",
    "detail": "Function (uint8_t texel_weights_texel [ BLOCK_MAX_WEIGHTS ] [ BLOCK_MAX_TEXELS ] [ 4 ] ; float texel_weights_float_texel [ BLOCK_MAX_WEIGHTS ] [ BLOCK_MAX_TEXELS ] [ 4 ] ; } ; struct block_mode { uint16_t mode_index ; uint8_t decimation_mode ; uint8_t quant_mode ; uint8_t weight_bits ; uint8_t is_dual_plane : 1 ; quant_method)",
    "insertText": "get_weight_quant_mode()"
  },
  {
    "label": "set_ref_1_plane()",
    "kind": "Method",
    "detail": "Function (} } ; struct decimation_mode { int8_t maxprec_1plane ; int8_t maxprec_2planes ; uint16_t refprec_1_plane ; uint16_t refprec_2_planes ; void)",
    "insertText": "set_ref_1_plane(quant_method weight_quant)"
  },
  {
    "label": "refprec_1_plane()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "refprec_1_plane(1 << weight_quant)"
  },
  {
    "label": "is_ref_1_plane()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_ref_1_plane(quant_method max_weight_quant)"
  },
  {
    "label": "uint16_t()",
    "kind": "Method",
    "detail": "Function (uint16_t mask = static_cast<)",
    "insertText": "uint16_t((1 << (max_weight_quant + 1)) - 1)"
  },
  {
    "label": "set_ref_2_plane()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_ref_2_plane(quant_method weight_quant)"
  },
  {
    "label": "uint16_t()",
    "kind": "Method",
    "detail": "Function (refprec_2_planes | = static_cast<)",
    "insertText": "uint16_t(1 << weight_quant)"
  },
  {
    "label": "is_ref_2_plane()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_ref_2_plane(quant_method max_weight_quant)"
  },
  {
    "label": "partitionings()",
    "kind": "Method",
    "detail": "Function (uint16_t block_mode_packed_index [ WEIGHTS_MAX_BLOCK_MODES ] ; block_mode block_modes [ WEIGHTS_MAX_BLOCK_MODES ] ; partition_info)",
    "insertText": "partitionings(3 * BLOCK_MAX_PARTITIONINGS)"
  },
  {
    "label": "get_block_mode()",
    "kind": "Method",
    "detail": "Function (uint16_t partitioning_packed_index [ 3 ] [ BLOCK_MAX_PARTITIONINGS ] ; uint8_t kmeans_texels [ BLOCK_MAX_KMEANS_TEXELS ] ; uint64_t coverage_bitmaps_2 [ BLOCK_MAX_PARTITIONINGS ] [ 2 ] ; uint64_t coverage_bitmaps_3 [ BLOCK_MAX_PARTITIONINGS ] [ 3 ] ; uint64_t coverage_bitmaps_4 [ BLOCK_MAX_PARTITIONINGS ] [ 4 ] ; const block_mode&)",
    "insertText": "get_block_mode(unsigned int block_mode)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (unsigned int packed_index = this -> block_mode_packed_index [ block_mode ] ;)",
    "insertText": "assert(packed_index != BLOCK_BAD_BLOCK_MODE && packed_index < this->block_mode_count_all)"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (partition_count = 5 ; } unsigned int)",
    "insertText": "index(partition_count - 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned int packed_index = 0 ;)",
    "insertText": "if(partition_count >= 2)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (packed_index = this -> partitioning_packed_index [ partition_count - 2 ] [ index ] ; })",
    "insertText": "assert(packed_index != BLOCK_BAD_PARTITIONING && packed_index < this->partitioning_count_all[partition_count - 1])"
  },
  {
    "label": "get_partition_table()",
    "kind": "Method",
    "detail": "Function (auto& result =)",
    "insertText": "get_partition_table(partition_count)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(index == result.partition_index)"
  },
  {
    "label": "texel()",
    "kind": "Method",
    "detail": "Function (uint8_t texel_count ; vfloat4 origin_texel ; vfloat4 data_min ; vfloat4 data_mean ; vfloat4 data_max ; vfloat4 channel_weight ; bool grayscale ; uint8_t rgb_lns [ BLOCK_MAX_TEXELS ] ; uint8_t alpha_lns [ BLOCK_MAX_TEXELS ] ; unsigned int xpos ; unsigned int ypos ; unsigned int zpos ; vfloat4)",
    "insertText": "texel(unsigned int index)"
  },
  {
    "label": "texel3()",
    "kind": "Method",
    "detail": "Function (} vfloat4)",
    "insertText": "texel3(unsigned int index)"
  },
  {
    "label": "get_default_alpha()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "get_default_alpha()"
  },
  {
    "label": "is_constant_channel()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_constant_channel(int channel)"
  },
  {
    "label": "lane_id()",
    "kind": "Method",
    "detail": "Function (vmask4 lane_mask =)",
    "insertText": "lane_id() == vint4(channel)"
  },
  {
    "label": "any()",
    "kind": "Method",
    "detail": "Function (vmask4 color_mask = this -> data_min = = this -> data_max ; return)",
    "insertText": "any(lane_mask & color_mask)"
  },
  {
    "label": "is_luminance()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_luminance()"
  },
  {
    "label": "alpha1()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "alpha1(this->data_min.lane<3>() == default_alpha) && (this->data_max.lane<3>() == default_alpha)"
  },
  {
    "label": "get_color_quant_mode()",
    "kind": "Method",
    "detail": "Function (uint8_t best_quant_levels [ WEIGHTS_MAX_BLOCK_MODES ] ; uint8_t best_quant_levels_mod [ WEIGHTS_MAX_BLOCK_MODES ] ; uint8_t best_ep_formats [ WEIGHTS_MAX_BLOCK_MODES ] [ BLOCK_MAX_PARTITIONS ] ; int8_t qwt_bitcounts [ WEIGHTS_MAX_BLOCK_MODES ] ; float qwt_errors [ WEIGHTS_MAX_BLOCK_MODES ] ; float weight_low_value1 [ WEIGHTS_MAX_BLOCK_MODES ] ; float weight_high_value1 [ WEIGHTS_MAX_BLOCK_MODES ] ; float weight_low_values1 [ WEIGHTS_MAX_DECIMATION_MODES ] [ TUNE_MAX_ANGULAR_QUANT + 1 ] ; float weight_high_values1 [ WEIGHTS_MAX_DECIMATION_MODES ] [ TUNE_MAX_ANGULAR_QUANT + 1 ] ; float weight_low_value2 [ WEIGHTS_MAX_BLOCK_MODES ] ; float weight_high_value2 [ WEIGHTS_MAX_BLOCK_MODES ] ; float weight_low_values2 [ WEIGHTS_MAX_DECIMATION_MODES ] [ TUNE_MAX_ANGULAR_QUANT + 1 ] ; float weight_high_values2 [ WEIGHTS_MAX_DECIMATION_MODES ] [ TUNE_MAX_ANGULAR_QUANT + 1 ] ; } ; struct dt_init_working_buffers { uint8_t weight_count_of_texel [ BLOCK_MAX_TEXELS ] ; uint8_t grid_weights_of_texel [ BLOCK_MAX_TEXELS ] [ 4 ] ; uint8_t weights_of_texel [ BLOCK_MAX_TEXELS ] [ 4 ] ; uint8_t texel_count_of_weight [ BLOCK_MAX_WEIGHTS ] ; uint8_t texels_of_weight [ BLOCK_MAX_WEIGHTS ] [ BLOCK_MAX_TEXELS ] ; uint8_t texel_weights_of_weight [ BLOCK_MAX_WEIGHTS ] [ BLOCK_MAX_TEXELS ] ; } ; struct quant_and_transfer_table { quant_method method ; int8_t quant_to_unquant [ 3 2 ] ; int8_t scramble_map [ 3 2 ] ; int8_t unscramble_and_unquant_map [ 3 2 ] ; uint16_t prev_next_values [ 6 5 ] ; } ; const quant_and_transfer_table quant_and_xfer_tables [ 1 2 ] ; uint8_t SYM_BTYPE_ERROR { 0 } ; uint8_t SYM_BTYPE_CONST_F16 { 1 } ; uint8_t SYM_BTYPE_CONST_U16 { 2 } ; uint8_t SYM_BTYPE_NONCONST { 3 } ; struct symbolic_compressed_block { uint8_t block_type ; uint8_t partition_count ; uint8_t color_formats_matched ; int8_t plane2_component ; uint16_t block_mode ; uint16_t partition_index ; uint8_t color_formats [ BLOCK_MAX_PARTITIONS ] ; quant_method quant_mode ; float errorval ; union { int constant_color [ BLOCK_MAX_COMPONENTS ] ; uint8_t color_values [ BLOCK_MAX_PARTITIONS ] [ 8 ] ; } ; uint8_t weights [ BLOCK_MAX_WEIGHTS ] ; quant_method)",
    "insertText": "get_color_quant_mode()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif struct astcenc_contexti { astcenc_config config ; unsigned int thread_count ; block_size_descriptor* bsd ; float* input_alpha_averages ; compression_working_buffers* working_buffers ; # if !)",
    "insertText": "defined(ASTCENC_DECOMPRESS_ONLY)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "defined(ASTCENC_DIAGNOSTICS)"
  },
  {
    "label": "init_block_size_descriptor()",
    "kind": "Method",
    "detail": "Function (# endif } ; void)",
    "insertText": "init_block_size_descriptor(unsigned int x_texels, unsigned int y_texels, unsigned int z_texels, bool can_omit_modes, unsigned int partition_count_cutoff, float mode_cutoff, block_size_descriptor& bsd)"
  },
  {
    "label": "init_partition_tables()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init_partition_tables(block_size_descriptor& bsd, bool can_omit_partitionings, unsigned int partition_count_cutoff)"
  },
  {
    "label": "get_2d_percentile_table()",
    "kind": "Method",
    "detail": "Function (const float*)",
    "insertText": "get_2d_percentile_table(unsigned int xdim, unsigned int ydim)"
  },
  {
    "label": "is_legal_2d_block_size()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_legal_2d_block_size(unsigned int xdim, unsigned int ydim)"
  },
  {
    "label": "is_legal_3d_block_size()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_legal_3d_block_size(unsigned int xdim, unsigned int ydim, unsigned int zdim)"
  },
  {
    "label": "encode_ise()",
    "kind": "Method",
    "detail": "Function (const uint8_t color_quant_tables [ 1 7 ] [ 2 5 6 ] ; const uint8_t color_unquant_tables [ 1 7 ] [ 2 5 6 ] ; const int8_t quant_mode_table [ 1 0 ] [ 1 2 8 ] ; void)",
    "insertText": "encode_ise(quant_method quant_level, unsigned int character_count, const uint8_t* input_data, uint8_t* output_data, unsigned int bit_offset)"
  },
  {
    "label": "decode_ise()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decode_ise(quant_method quant_level, unsigned int character_count, const uint8_t* input_data, uint8_t* output_data, unsigned int bit_offset)"
  },
  {
    "label": "get_ise_sequence_bitcount()",
    "kind": "Method",
    "detail": "Function (unsigned int)",
    "insertText": "get_ise_sequence_bitcount(unsigned int character_count, quant_method quant_level)"
  },
  {
    "label": "compute_avgs_and_dirs_2_comp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_avgs_and_dirs_2_comp(const partition_info& pi, const image_block& blk, unsigned int component1, unsigned int component2, partition_metrics pm[BLOCK_MAX_PARTITIONS])"
  },
  {
    "label": "compute_avgs_and_dirs_3_comp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_avgs_and_dirs_3_comp(const partition_info& pi, const image_block& blk, unsigned int omitted_component, partition_metrics pm[BLOCK_MAX_PARTITIONS])"
  },
  {
    "label": "compute_avgs_and_dirs_3_comp_rgb()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_avgs_and_dirs_3_comp_rgb(const partition_info& pi, const image_block& blk, partition_metrics pm[BLOCK_MAX_PARTITIONS])"
  },
  {
    "label": "compute_avgs_and_dirs_4_comp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_avgs_and_dirs_4_comp(const partition_info& pi, const image_block& blk, partition_metrics pm[BLOCK_MAX_PARTITIONS])"
  },
  {
    "label": "compute_error_squared_rgb()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_error_squared_rgb(const partition_info& pi, const image_block& blk, partition_lines3 plines[BLOCK_MAX_PARTITIONS], float& uncor_error, float& samec_error)"
  },
  {
    "label": "compute_error_squared_rgba()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_error_squared_rgba(const partition_info& pi, const image_block& blk, const processed_line4 uncor_plines[BLOCK_MAX_PARTITIONS], const processed_line4 samec_plines[BLOCK_MAX_PARTITIONS], float uncor_lengths[BLOCK_MAX_PARTITIONS], float samec_lengths[BLOCK_MAX_PARTITIONS], float& uncor_error, float& samec_error)"
  },
  {
    "label": "find_best_partition_candidates()",
    "kind": "Method",
    "detail": "Function (unsigned int)",
    "insertText": "find_best_partition_candidates(const block_size_descriptor& bsd, const image_block& blk, unsigned int partition_count, unsigned int partition_search_limit, unsigned int best_partitions[TUNE_MAX_PARTITIIONING_CANDIDATES], unsigned int requested_candidates)"
  },
  {
    "label": "init_compute_averages()",
    "kind": "Method",
    "detail": "Function (unsigned int)",
    "insertText": "init_compute_averages(const astcenc_image& img, unsigned int alpha_kernel_radius, const astcenc_swizzle& swz, avg_args& ag)"
  },
  {
    "label": "compute_pixel_region_variance()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_pixel_region_variance(astcenc_contexti& ctx, const pixel_region_args& arg)"
  },
  {
    "label": "load_image_block()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "load_image_block(astcenc_profile decode_mode, const astcenc_image& img, image_block& blk, const block_size_descriptor& bsd, unsigned int xpos, unsigned int ypos, unsigned int zpos, const astcenc_swizzle& swz)"
  },
  {
    "label": "load_image_block_fast_ldr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "load_image_block_fast_ldr(astcenc_profile decode_mode, const astcenc_image& img, image_block& blk, const block_size_descriptor& bsd, unsigned int xpos, unsigned int ypos, unsigned int zpos, const astcenc_swizzle& swz)"
  },
  {
    "label": "store_image_block()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "store_image_block(astcenc_image& img, const image_block& blk, const block_size_descriptor& bsd, unsigned int xpos, unsigned int ypos, unsigned int zpos, const astcenc_swizzle& swz)"
  },
  {
    "label": "compute_ideal_colors_and_weights_1plane()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_ideal_colors_and_weights_1plane(const image_block& blk, const partition_info& pi, endpoints_and_weights& ei)"
  },
  {
    "label": "compute_ideal_colors_and_weights_2planes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_ideal_colors_and_weights_2planes(const block_size_descriptor& bsd, const image_block& blk, unsigned int plane2_component, endpoints_and_weights& ei1, endpoints_and_weights& ei2)"
  },
  {
    "label": "compute_ideal_weights_for_decimation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_ideal_weights_for_decimation(const endpoints_and_weights& ei, const decimation_info& di, float* dec_weight_ideal_value)"
  },
  {
    "label": "compute_quantized_weights_for_decimation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_quantized_weights_for_decimation(const decimation_info& di, float low_bound, float high_bound, const float* dec_weight_ideal_value, float* dec_weight_quant_uvalue, uint8_t* dec_weight_uquant, quant_method quant_level)"
  },
  {
    "label": "compute_error_of_weight_set_1plane()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "compute_error_of_weight_set_1plane(const endpoints_and_weights& eai, const decimation_info& di, const float* dec_weight_quant_uvalue)"
  },
  {
    "label": "compute_error_of_weight_set_2planes()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "compute_error_of_weight_set_2planes(const endpoints_and_weights& eai1, const endpoints_and_weights& eai2, const decimation_info& di, const float* dec_weight_quant_uvalue_plane1, const float* dec_weight_quant_uvalue_plane2)"
  },
  {
    "label": "pack_color_endpoints()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "pack_color_endpoints(vfloat4 color0, vfloat4 color1, vfloat4 rgbs_color, vfloat4 rgbo_color, int format, uint8_t* output, quant_method quant_level)"
  },
  {
    "label": "unpack_color_endpoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unpack_color_endpoints(astcenc_profile decode_mode, int format, quant_method quant_level, const uint8_t* input, bool& rgb_hdr, bool& alpha_hdr, vint4& output0, vint4& output1)"
  },
  {
    "label": "unpack_weights()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unpack_weights(const block_size_descriptor& bsd, const symbolic_compressed_block& scb, const decimation_info& di, bool is_dual_plane, int weights_plane1[BLOCK_MAX_TEXELS], int weights_plane2[BLOCK_MAX_TEXELS])"
  },
  {
    "label": "compute_ideal_endpoint_formats()",
    "kind": "Method",
    "detail": "Function (unsigned int)",
    "insertText": "compute_ideal_endpoint_formats(const partition_info& pi, const image_block& blk, const endpoints& ep, const int8_t* qwt_bitcounts, const float* qwt_errors, unsigned int tune_candidate_limit, unsigned int start_block_mode, unsigned int end_block_mode, uint8_t partition_format_specifiers[TUNE_MAX_TRIAL_CANDIDATES][BLOCK_MAX_PARTITIONS], int block_mode[TUNE_MAX_TRIAL_CANDIDATES], quant_method quant_level[TUNE_MAX_TRIAL_CANDIDATES], quant_method quant_level_mod[TUNE_MAX_TRIAL_CANDIDATES], compression_working_buffers& tmpbuf)"
  },
  {
    "label": "recompute_ideal_colors_1plane()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "recompute_ideal_colors_1plane(const image_block& blk, const partition_info& pi, const decimation_info& di, const uint8_t* dec_weights_uquant, endpoints& ep, vfloat4 rgbs_vectors[BLOCK_MAX_PARTITIONS], vfloat4 rgbo_vectors[BLOCK_MAX_PARTITIONS])"
  },
  {
    "label": "recompute_ideal_colors_2planes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "recompute_ideal_colors_2planes(const image_block& blk, const block_size_descriptor& bsd, const decimation_info& di, const uint8_t* dec_weights_uquant_plane1, const uint8_t* dec_weights_uquant_plane2, endpoints& ep, vfloat4& rgbs_vector, vfloat4& rgbo_vector, int plane2_component)"
  },
  {
    "label": "prepare_angular_tables()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prepare_angular_tables()"
  },
  {
    "label": "compute_angular_endpoints_1plane()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_angular_endpoints_1plane(bool only_always, const block_size_descriptor& bsd, const float* dec_weight_ideal_value, unsigned int max_weight_quant, compression_working_buffers& tmpbuf)"
  },
  {
    "label": "compute_angular_endpoints_2planes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_angular_endpoints_2planes(const block_size_descriptor& bsd, const float* dec_weight_ideal_value, unsigned int max_weight_quant, compression_working_buffers& tmpbuf)"
  },
  {
    "label": "compress_block()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compress_block(const astcenc_contexti& ctx, const image_block& blk, physical_compressed_block& pcb, compression_working_buffers& tmpbuf)"
  },
  {
    "label": "decompress_symbolic_block()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decompress_symbolic_block(astcenc_profile decode_mode, const block_size_descriptor& bsd, int xpos, int ypos, int zpos, const symbolic_compressed_block& scb, image_block& blk)"
  },
  {
    "label": "compute_symbolic_block_difference_2plane()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "compute_symbolic_block_difference_2plane(const astcenc_config& config, const block_size_descriptor& bsd, const symbolic_compressed_block& scb, const image_block& blk)"
  },
  {
    "label": "compute_symbolic_block_difference_1plane()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "compute_symbolic_block_difference_1plane(const astcenc_config& config, const block_size_descriptor& bsd, const symbolic_compressed_block& scb, const image_block& blk)"
  },
  {
    "label": "compute_symbolic_block_difference_1plane_1partition()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "compute_symbolic_block_difference_1plane_1partition(const astcenc_config& config, const block_size_descriptor& bsd, const symbolic_compressed_block& scb, const image_block& blk)"
  },
  {
    "label": "symbolic_to_physical()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "symbolic_to_physical(const block_size_descriptor& bsd, const symbolic_compressed_block& scb, physical_compressed_block& pcb)"
  },
  {
    "label": "physical_to_symbolic()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "physical_to_symbolic(const block_size_descriptor& bsd, const physical_compressed_block& pcb, symbolic_compressed_block& scb)"
  },
  {
    "label": "cpu_supports_popcnt()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "cpu_supports_popcnt()"
  },
  {
    "label": "cpu_supports_f16c()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "cpu_supports_f16c()"
  },
  {
    "label": "cpu_supports_sse41()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "cpu_supports_sse41()"
  },
  {
    "label": "cpu_supports_avx2()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "cpu_supports_avx2()"
  },
  {
    "label": "aligned_malloc()",
    "kind": "Method",
    "detail": "Function (template<T> T*)",
    "insertText": "aligned_malloc(size_t size, size_t align)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (void* ptr ; int error = 0 ; # if)",
    "insertText": "defined(_WIN32) ptr = _aligned_malloc(size, align)"
  },
  {
    "label": "posix_memalign()",
    "kind": "Method",
    "detail": "Function (# else error =)",
    "insertText": "posix_memalign(&ptr, align, size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(error || (!ptr))"
  },
  {
    "label": "aligned_free()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "aligned_free(T* ptr)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_WIN32) _aligned_free(reinterpret_cast<void*>(ptr))"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "free(reinterpret_cast<void*>(ptr))"
  }
]