[
  {
    "label": "concurrent_hash_map",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "concurrent_hash_map"
  },
  {
    "label": "hash_map_node_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "hash_map_node_base"
  },
  {
    "label": "hash_map_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_map_base"
  },
  {
    "label": "bucket",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "bucket"
  },
  {
    "label": "enable_segment_failsafe",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "enable_segment_failsafe"
  },
  {
    "label": "hash_map_range",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_map_range"
  },
  {
    "label": "hash_map_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_map_iterator"
  },
  {
    "label": "interface5",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "interface5"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "const_accessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "const_accessor"
  },
  {
    "label": "node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "node"
  },
  {
    "label": "node_scoped_guard",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "node_scoped_guard"
  },
  {
    "label": "bucket_accessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "bucket_accessor"
  },
  {
    "label": "call_clear_on_leave",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "call_clear_on_leave"
  },
  {
    "label": "accessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "accessor"
  },
  {
    "label": "accessor_not_used",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "accessor_not_used"
  },
  {
    "label": "hash_map_node_base()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_concurrent_hash_map_H # define __TBB_concurrent_hash_map_H # include \" tbb_stddef . h \" # include<iterator> # include<utility> # include<cstring> # include __TBB_STD_SWAP_HEADER # include \" tbb_allocator . h \" # include \" spin_rw_mutex . h \" # include \" atomic . h \" # include \" tbb_exception . h \" # include \" tbb_profiling . h \" # include \" aligned_space . h \" # include \" internal / _tbb_hash_compare_impl . h \" # include \" internal / _template_helpers . h \" # include \" internal / _allocator_traits . h \" # if __TBB_INITIALIZER_LISTS_PRESENT # include<initializer_list> # endif # if TBB_USE_PERFORMANCE_WARNINGS | | __TBB_STATISTICS # include<typeinfo> # endif # if __TBB_STATISTICS # include<stdio . h> # endif # if __TBB_CPP11_RVALUE_REF_PRESENT&& __TBB_CPP11_VARIADIC_TEMPLATES_PRESENT&& __TBB_CPP11_TUPLE_PRESENT # include<tuple> # endif namespace tbb { namespace interface5 { template<Key,T,HashCompare = tbb_hash_compare<Key>,A = tbb_allocator<std::pair<const Key,T>>> class concurrent_hash_map ; namespace internal { using namespace tbb::internal ; typedef size_t hashcode_t ; struct hash_map_node_base : tbb::internal::no_copy { typedef spin_rw_mutex mutex_t ; typedef mutex_t::scoped_lock scoped_t ; hash_map_node_base* next ; mutex_t mutex ; } ; hash_map_node_base* const rehash_req = reinterpret_cast<)",
    "insertText": "hash_map_node_base(size_t(3))"
  },
  {
    "label": "hash_map_node_base()",
    "kind": "Method",
    "detail": "Function (hash_map_node_base* const empty_rehashed = reinterpret_cast<)",
    "insertText": "hash_map_node_base(size_t(0))"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (class hash_map_base { public : typedef size_t size_type ; typedef size_t hashcode_t ; typedef size_t segment_index_t ; typedef hash_map_node_base node_base ; struct bucket : tbb::internal::no_copy { typedef spin_rw_mutex mutex_t ; typedef mutex_t::scoped_lock scoped_t ; mutex_t mutex ; node_base* node_list ; } ; size_type const embedded_block = 1 ; size_type const embedded_buckets = 1<<embedded_block ; size_type const first_block = 8 ; size_type const pointers_per_table =)",
    "insertText": "sizeof(segment_index_t)"
  },
  {
    "label": "hash_map_base()",
    "kind": "Method",
    "detail": "Function (typedef bucket* segment_ptr_t ; typedef segment_ptr_t segments_table_t [ pointers_per_table ] ; atomic<hashcode_t> my_mask ; segments_table_t my_table ; atomic<size_type> my_size ; bucket my_embedded_segment [ embedded_buckets ] ; # if __TBB_STATISTICS atomic<unsigned> my_info_resizes ; atomic<unsigned> my_info_restarts ; atomic<unsigned> my_info_rehashes ; # endif)",
    "insertText": "hash_map_base()"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(this, 0, pointers_per_table*sizeof(segment_ptr_t) + sizeof(my_size) + sizeof(my_mask) + embedded_buckets*sizeof(bucket))"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (my_mask = embedded_buckets - 1 ;)",
    "insertText": "__TBB_ASSERT(embedded_block <= first_block, \"The first block number must include embedded blocks\")"
  },
  {
    "label": "segment_index_of()",
    "kind": "Method",
    "detail": "Function (# if __TBB_STATISTICS my_info_resizes = 0 ; my_info_restarts = 0 ; my_info_rehashes = 0 ; # endif } segment_index_t)",
    "insertText": "segment_index_of(size_type index)"
  },
  {
    "label": "segment_base()",
    "kind": "Method",
    "detail": "Function (} segment_index_t)",
    "insertText": "segment_base(segment_index_t k)"
  },
  {
    "label": "segment_size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "segment_size(segment_index_t k)"
  },
  {
    "label": "is_valid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_valid(void *ptr)"
  },
  {
    "label": "init_buckets()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "init_buckets(segment_ptr_t ptr, size_type sz, bool is_initial)"
  },
  {
    "label": "intptr_t()",
    "kind": "Method",
    "detail": "Function (* reinterpret_cast<)",
    "insertText": "intptr_t(&ptr->mutex)"
  },
  {
    "label": "add_to_bucket()",
    "kind": "Method",
    "detail": "Function (ptr -> node_list = rehash_req ; } } void)",
    "insertText": "add_to_bucket(bucket *b, node_base *n)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(b->node_list != rehash_req, NULL)"
  },
  {
    "label": "enable_segment_failsafe()",
    "kind": "Method",
    "detail": "Function (n -> next = b -> node_list ; b -> node_list = n ; } struct enable_segment_failsafe : tbb::internal::no_copy { segment_ptr_t* my_segment_ptr ;)",
    "insertText": "enable_segment_failsafe(segments_table_t &table, segment_index_t k) : my_segment_ptr(&table[k])"
  },
  {
    "label": "enable_segment_failsafe()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "enable_segment_failsafe()"
  },
  {
    "label": "enable_segment()",
    "kind": "Method",
    "detail": "Function (} } ; template<Allocator> void)",
    "insertText": "enable_segment(segment_index_t k, const Allocator& allocator, bool is_initial = false)"
  },
  {
    "label": "bucket_allocator()",
    "kind": "Method",
    "detail": "Function (typedef tbb::internal::allocator_rebind<Allocator,bucket>::type bucket_allocator_type ; typedef tbb::internal::allocator_traits<bucket_allocator_type> bucket_allocator_traits ; bucket_allocator_type)",
    "insertText": "bucket_allocator(allocator)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(k, \"Zero segment must be embedded\")"
  },
  {
    "label": "watchdog()",
    "kind": "Method",
    "detail": "Function (enable_segment_failsafe)",
    "insertText": "watchdog(my_table, k)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (size_type sz ;)",
    "insertText": "__TBB_ASSERT(!is_valid(my_table[k]), \"Wrong concurrent assignment\")"
  },
  {
    "label": "segment_size()",
    "kind": "Method",
    "detail": "Function (sz =)",
    "insertText": "segment_size(k)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (segment_ptr_t ptr =)",
    "insertText": "allocate(bucket_allocator, sz)"
  },
  {
    "label": "init_buckets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init_buckets(ptr, sz, is_initial)"
  },
  {
    "label": "itt_hide_store_word()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "itt_hide_store_word(my_table[k], ptr)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (sz<<= 1 ; } else {)",
    "insertText": "__TBB_ASSERT(k == embedded_block, \"Wrong segment index\")"
  },
  {
    "label": "segment_size()",
    "kind": "Method",
    "detail": "Function (sz =)",
    "insertText": "segment_size(first_block)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (segment_ptr_t ptr =)",
    "insertText": "allocate(bucket_allocator, sz - embedded_buckets)"
  },
  {
    "label": "init_buckets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init_buckets(ptr, sz - embedded_buckets, is_initial)"
  },
  {
    "label": "segment_base()",
    "kind": "Method",
    "detail": "Function (ptr - =)",
    "insertText": "segment_base(embedded_block)"
  },
  {
    "label": "itt_store_word_with_release()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "itt_store_word_with_release(my_mask, sz-1)"
  },
  {
    "label": "delete_segment()",
    "kind": "Method",
    "detail": "Function (watchdog . my_segment_ptr = 0 ; } template<Allocator> void)",
    "insertText": "delete_segment(segment_index_t s, const Allocator& allocator)"
  },
  {
    "label": "segment_size()",
    "kind": "Method",
    "detail": "Function (segment_ptr_t buckets_ptr = my_table [ s ] ; size_type sz =)",
    "insertText": "segment_size(s ? s : 1)"
  },
  {
    "label": "get_bucket()",
    "kind": "Method",
    "detail": "Function (} bucket*)",
    "insertText": "get_bucket(hashcode_t h ) const throw()"
  },
  {
    "label": "segment_index_of()",
    "kind": "Method",
    "detail": "Function (segment_index_t s =)",
    "insertText": "segment_index_of(h)"
  },
  {
    "label": "segment_base()",
    "kind": "Method",
    "detail": "Function (h - =)",
    "insertText": "segment_base(s)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (segment_ptr_t seg = my_table [ s ] ;)",
    "insertText": "__TBB_ASSERT(is_valid(seg), \"hashcode must be cut by valid mask for allocated segments\")"
  },
  {
    "label": "mark_rehashed_levels()",
    "kind": "Method",
    "detail": "Function (seg [ h ] . node_list = empty_rehashed ;)",
    "insertText": "mark_rehashed_levels(h + ((hashcode_t)1<<s))"
  },
  {
    "label": "check_mask_race()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "check_mask_race(const hashcode_t h, hashcode_t &m)"
  },
  {
    "label": "m_now()",
    "kind": "Method",
    "detail": "Function (hashcode_t m_now,m_old = m ;)",
    "insertText": "m_now(hashcode_t) itt_load_word_with_acquire( my_mask)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(m_old != m, NULL)"
  },
  {
    "label": "m_old()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_old(m_old<<1)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT((m_old&(m_old+1))==0 && m_old <= m, NULL)"
  },
  {
    "label": "insert_new_node()",
    "kind": "Method",
    "detail": "Function (# if __TBB_STATISTICS my_info_restarts + + ; # endif return true ; } } return false ; } segment_index_t)",
    "insertText": "insert_new_node(bucket *b, node_base *n, hashcode_t mask)"
  },
  {
    "label": "add_to_bucket()",
    "kind": "Method",
    "detail": "Function (size_type sz = + + my_size ;)",
    "insertText": "add_to_bucket(b, n)"
  },
  {
    "label": "__TBB_Log2()",
    "kind": "Method",
    "detail": "Function (segment_index_t new_seg =)",
    "insertText": "__TBB_Log2(mask+1)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(is_valid(my_table[new_seg-1]), \"new allocations must not publish new mask until segment has allocated\")"
  },
  {
    "label": "is_allocating()",
    "kind": "Method",
    "detail": "Function (const segment_ptr_t)",
    "insertText": "is_allocating(segment_ptr_t)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} return 0 ; } template<Allocator> void)",
    "insertText": "reserve(size_type buckets, const Allocator& allocator)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool is_initial = ! my_size ;)",
    "insertText": "for(size_type m = my_mask; buckets > m; m = my_mask ) enable_segment( segment_index_of( m+1 ), allocator, is_initial)"
  },
  {
    "label": "internal_swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_swap(hash_map_base &table)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "swap(this->my_mask, table.my_mask)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(this->my_size, table.my_size)"
  },
  {
    "label": "internal_move()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT void)",
    "insertText": "internal_move(hash_map_base&& other)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (my_mask = other . my_mask ; other . my_mask = embedded_buckets - 1 ; my_size = other . my_size ; other . my_size = 0 ;)",
    "insertText": "for(size_type i = 0; i < embedded_buckets; ++i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (my_embedded_segment [ i ] . node_list = other . my_embedded_segment [ i ] . node_list ; other . my_embedded_segment [ i ] . node_list = NULL ; })",
    "insertText": "for(size_type i = embedded_block; i < pointers_per_table; ++i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (my_table [ i ] = other . my_table [ i ] ; other . my_table [ i ] = NULL ; } } # endif } ; template<Iterator> class hash_map_range ; template<Container,Value> class hash_map_iterator : public std::iterator<std::forward_iterator_tag,Value> { typedef Container map_type ; typedef Container::node node ; typedef hash_map_base::node_base node_base ; typedef hash_map_base::bucket bucket ; template<C,T,U> bool)",
    "insertText": "operator(const hash_map_iterator<C,T>& i, const hash_map_iterator<C,U>& j)"
  },
  {
    "label": "advance_to_next_bucket()",
    "kind": "Method",
    "detail": "Function (template<C,U> class hash_map_iterator ; template<I> class hash_map_range ; void)",
    "insertText": "advance_to_next_bucket()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (size_t k = my_index + 1 ;)",
    "insertText": "__TBB_ASSERT(my_bucket, \"advancing an invalid iterator?\")"
  },
  {
    "label": "node()",
    "kind": "Method",
    "detail": "Function (my_node = static_cast<)",
    "insertText": "node(my_bucket->node_list)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (my_index = k ; return ; } + + k ; } my_bucket = 0 ; my_node = 0 ; my_index = k ; } # if !)",
    "insertText": "defined(_MSC_VER) || defined(__INTEL_COMPILER)"
  },
  {
    "label": "hash_map_iterator()",
    "kind": "Method",
    "detail": "Function (# else public : # endif const Container* my_map ; size_t my_index ; const bucket* my_bucket ; node* my_node ;)",
    "insertText": "hash_map_iterator(const Container &map, size_t index, const bucket *b, node_base *n)"
  },
  {
    "label": "hash_map_iterator()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "hash_map_iterator(): my_map(), my_index(), my_bucket(), my_node()"
  },
  {
    "label": "hash_map_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "hash_map_iterator(const hash_map_iterator<Container,typename Container::value_type> &other ) : my_map(other.my_map), my_index(other.my_index), my_bucket(other.my_bucket), my_node(other.my_node)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Value&)",
    "insertText": "operator()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(hash_map_base::is_valid(my_node), \"iterator uninitialized or at end of container?\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (hash_map_iterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "old()",
    "kind": "Method",
    "detail": "Function (hash_map_iterator)",
    "insertText": "old(*this)"
  },
  {
    "label": "node()",
    "kind": "Method",
    "detail": "Function (my_node = static_cast<)",
    "insertText": "node(my_node->next)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (template<U> class hash_map_range ; public : typedef std::size_t size_type ; typedef Iterator::value_type value_type ; typedef Iterator::reference reference ; typedef Iterator::difference_type difference_type ; typedef Iterator iterator ; bool)",
    "insertText": "empty()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (r . my_end = my_begin = r . my_midpoint ;)",
    "insertText": "__TBB_ASSERT(!empty(), \"Splitting despite the range is not divisible\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!r.empty(), \"Splitting despite the range is not divisible\")"
  },
  {
    "label": "set_midpoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_midpoint()"
  },
  {
    "label": "hash_map_range()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "hash_map_range(hash_map_range<U>& r) : my_begin(r.my_begin), my_end(r.my_end), my_midpoint(r.my_midpoint), my_grainsize(r.my_grainsize)"
  },
  {
    "label": "hash_map_range()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "hash_map_range(const map_type &map, size_type grainsize_ = 1 ) : my_begin( Iterator( map, 0, map.my_embedded_segment, map.my_embedded_segment->node_list ) ), my_end( Iterator( map, map.my_mask + 1, 0, 0 ) ), my_grainsize( grainsize_)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(grainsize_>0, \"grainsize must be positive\")"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} const Iterator&)",
    "insertText": "begin()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t m = my_end . my_index - my_begin . my_index ;)",
    "insertText": "if(m > my_grainsize)"
  },
  {
    "label": "get_bucket()",
    "kind": "Method",
    "detail": "Function (m = my_begin . my_index + m / 2 u ; hash_map_base::bucket* b = my_begin . my_map ->)",
    "insertText": "get_bucket(m)"
  },
  {
    "label": "Iterator()",
    "kind": "Method",
    "detail": "Function (my_midpoint =)",
    "insertText": "Iterator(*my_begin.my_map,m,b,b->node_list)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else { my_midpoint = my_end ; })",
    "insertText": "__TBB_ASSERT(my_begin.my_index <= my_midpoint.my_index, \"my_begin is after my_midpoint\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_midpoint.my_index <= my_end.my_index, \"my_midpoint is after my_end\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_begin != my_midpoint || my_begin == my_end, \"[my_begin, my_midpoint) range should not be empty\")"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } # if _MSC_VER&& !)",
    "insertText": "defined(__INTEL_COMPILER) #pragma warning( push ) #pragma warning( disable: 4127)"
  },
  {
    "label": "storage()",
    "kind": "Method",
    "detail": "Function (template<Container,Value> class internal::hash_map_iterator ; template<I> class internal::hash_map_range ; public : typedef Key key_type ; typedef T mapped_type ; typedef std::pair<const Key,T> value_type ; typedef hash_map_base::size_type size_type ; typedef ptrdiff_t difference_type ; typedef value_type* pointer ; typedef const value_type* const_pointer ; typedef value_type& reference ; typedef const value_type& const_reference ; typedef internal::hash_map_iterator<concurrent_hash_map,value_type> iterator ; typedef internal::hash_map_iterator<concurrent_hash_map,const value_type> const_iterator ; typedef internal::hash_map_range<iterator> range_type ; typedef internal::hash_map_range<const_iterator> const_range_type ; typedef Allocator allocator_type ; protected : class const_accessor ; class node ; typedef tbb::internal::allocator_rebind<Allocator,node>::type node_allocator_type ; typedef tbb::internal::allocator_traits<node_allocator_type> node_allocator_traits ; node_allocator_type my_allocator ; HashCompare my_hash_compare ; class node : public node_base { tbb::aligned_space<value_type> my_value ; public : value_type*)",
    "insertText": "storage()"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} value_type&)",
    "insertText": "value()"
  },
  {
    "label": "delete_node()",
    "kind": "Method",
    "detail": "Function (} } ; void)",
    "insertText": "delete_node(node_base *n)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy(my_allocator, static_cast<node*>(n)->storage())"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy(my_allocator, static_cast<node*>(n))"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deallocate(my_allocator, static_cast<node*>(n), 1)"
  },
  {
    "label": "node_scoped_guard()",
    "kind": "Method",
    "detail": "Function (} struct node_scoped_guard : tbb::internal::no_copy { node* my_node ; node_allocator_type& my_alloc ;)",
    "insertText": "node_scoped_guard(node* n, node_allocator_type& alloc) : my_node(n), my_alloc(alloc)"
  },
  {
    "label": "node_scoped_guard()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "node_scoped_guard()"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy(my_alloc, my_node)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deallocate(my_alloc, my_node, 1)"
  },
  {
    "label": "dismiss()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "dismiss()"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (my_node = NULL ; } } ; # if __TBB_CPP11_RVALUE_REF_PRESENT&& __TBB_CPP11_VARIADIC_TEMPLATES_PRESENT template<. . . Args> node*)",
    "insertText": "create_node(node_allocator_type& allocator, Args&&... args) #else template<typename Arg1, typename Arg2> static node* create_node(node_allocator_type& allocator, __TBB_FORWARDING_REF(Arg1) arg1, __TBB_FORWARDING_REF(Arg2) arg2)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (node* node_ptr =)",
    "insertText": "allocate(allocator, 1)"
  },
  {
    "label": "guard()",
    "kind": "Method",
    "detail": "Function (node_scoped_guard)",
    "insertText": "guard(node_ptr, allocator)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "construct(allocator, node_ptr)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (# if __TBB_CPP11_RVALUE_REF_PRESENT&& __TBB_CPP11_VARIADIC_TEMPLATES_PRESENT)",
    "insertText": "construct(allocator, node_ptr->storage(), std::forward<Args>(args)...)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "construct(allocator, node_ptr->storage(), tbb::internal::forward<Arg1>(arg1), tbb::internal::forward<Arg2>(arg2))"
  },
  {
    "label": "allocate_node_move_construct()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT node*)",
    "insertText": "allocate_node_move_construct(node_allocator_type& allocator, const Key &key, const T * t)"
  },
  {
    "label": "allocate_node_default_construct()",
    "kind": "Method",
    "detail": "Function (} # endif node*)",
    "insertText": "allocate_node_default_construct(node_allocator_type& allocator, const Key &key, const T *)"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (# if __TBB_CPP11_RVALUE_REF_PRESENT&& __TBB_CPP11_VARIADIC_TEMPLATES_PRESENT&& __TBB_CPP11_TUPLE_PRESENT return)",
    "insertText": "create_node(allocator, std::piecewise_construct, std::forward_as_tuple(key), std::forward_as_tuple())"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (# else T obj ; return)",
    "insertText": "create_node(allocator, key, tbb::internal::move(obj))"
  },
  {
    "label": "do_not_allocate_node()",
    "kind": "Method",
    "detail": "Function (# endif } node*)",
    "insertText": "do_not_allocate_node(node_allocator_type& , const Key &, const T *)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(false,\"this dummy function should not be called\")"
  },
  {
    "label": "node()",
    "kind": "Method",
    "detail": "Function (node* n = static_cast<)",
    "insertText": "node(b->node_list)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(n != internal::rehash_req, \"Search can be executed only for rehashed bucket\")"
  },
  {
    "label": "acquire()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "acquire(base, h, writer)"
  },
  {
    "label": "acquire()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "acquire(concurrent_hash_map *base, const hashcode_t h, bool writer = false)"
  },
  {
    "label": "get_bucket()",
    "kind": "Method",
    "detail": "Function (my_b = base ->)",
    "insertText": "get_bucket(h)"
  },
  {
    "label": "acquire()",
    "kind": "Method",
    "detail": "Function (} else bucket::)",
    "insertText": "acquire(my_b->mutex, writer)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_b->node_list != internal::rehash_req, NULL)"
  },
  {
    "label": "is_writer()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_writer()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(*(intptr_t*)(&b_new->mutex), \"b_new must be locked (for write)\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(h > 1, \"The lowermost buckets can't be rehashed\")"
  },
  {
    "label": "__TBB_store_with_release()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_store_with_release(b_new->node_list, internal::empty_rehashed)"
  },
  {
    "label": "mask()",
    "kind": "Method",
    "detail": "Function (hashcode_t)",
    "insertText": "mask(1u<<__TBB_Log2( h ))"
  },
  {
    "label": "b_old()",
    "kind": "Method",
    "detail": "Function (# if __TBB_STATISTICS my_info_rehashes + + ; # endif bucket_accessor)",
    "insertText": "b_old(this, h & mask)"
  },
  {
    "label": "mask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mask(mask<<1)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT((mask&(mask+1))==0 && (h & mask) == h, NULL)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (restart :)",
    "insertText": "for(node_base **p = &b_old()->node_list, *n = __TBB_load_with_acquire(*p); is_valid(n); n = *p)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (hashcode_t c = my_hash_compare .)",
    "insertText": "hash(static_cast<node*>(n)->value().first)"
  },
  {
    "label": "h()",
    "kind": "Method",
    "detail": "Function (# if TBB_USE_ASSERT hashcode_t bmask =)",
    "insertText": "h(mask>>1)"
  },
  {
    "label": "bmask()",
    "kind": "Method",
    "detail": "Function (bmask =)",
    "insertText": "bmask(1u<<(__TBB_Log2( bmask )+1 ))"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT((c & bmask) == (h & bmask), \"hash() function changed for key in table\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if((c & mask) == h)"
  },
  {
    "label": "call_clear_on_leave()",
    "kind": "Method",
    "detail": "Function (} else p =& n -> next ; } } struct call_clear_on_leave { concurrent_hash_map* my_ch_map ;)",
    "insertText": "call_clear_on_leave(concurrent_hash_map* a_ch_map ) : my_ch_map(a_ch_map)"
  },
  {
    "label": "call_clear_on_leave()",
    "kind": "Method",
    "detail": "Function (my_ch_map = 0 ; } ~)",
    "insertText": "call_clear_on_leave()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (my_ch_map ->)",
    "insertText": "clear()"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (node::)",
    "insertText": "release()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_node, \"attempt to dereference empty accessor\")"
  },
  {
    "label": "const_accessor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "const_accessor() : my_node(NULL)"
  },
  {
    "label": "const_accessor()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "const_accessor()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(this->my_node, \"attempt to dereference empty accessor\")"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "concurrent_hash_map(const allocator_type &a = allocator_type() ) : internal::hash_map_base(), my_allocator(a)"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "concurrent_hash_map(const HashCompare& compare, const allocator_type& a = allocator_type() ) : internal::hash_map_base(), my_allocator(a), my_hash_compare(compare)"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "concurrent_hash_map(size_type n, const allocator_type &a = allocator_type() ) : internal::hash_map_base(), my_allocator(a)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(n, my_allocator)"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "concurrent_hash_map(size_type n, const HashCompare& compare, const allocator_type& a = allocator_type() ) : internal::hash_map_base(), my_allocator(a), my_hash_compare(compare)"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "concurrent_hash_map(const concurrent_hash_map &table ) : internal::hash_map_base(), my_allocator(node_allocator_traits::select_on_container_copy_construction(table.get_allocator()))"
  },
  {
    "label": "scope_guard()",
    "kind": "Method",
    "detail": "Function (call_clear_on_leave)",
    "insertText": "scope_guard(this)"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_copy(table)"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "concurrent_hash_map(const concurrent_hash_map &table, const allocator_type &a) : internal::hash_map_base(), my_allocator(a)"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT)",
    "insertText": "concurrent_hash_map(concurrent_hash_map &&table ) : internal::hash_map_base(), my_allocator(std::move(table.get_allocator()))"
  },
  {
    "label": "internal_move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_move(std::move(table))"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "concurrent_hash_map(concurrent_hash_map &&table, const allocator_type &a ) : internal::hash_map_base(), my_allocator(a)"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_copy(std::make_move_iterator(table.begin()), std::make_move_iterator(table.end()), table.size())"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (} } # endif template<I>)",
    "insertText": "concurrent_hash_map(I first, I last, const allocator_type &a = allocator_type() ) : internal::hash_map_base(), my_allocator(a)"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_copy(first, last, std::distance(first, last))"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (} template<I>)",
    "insertText": "concurrent_hash_map(I first, I last, const HashCompare& compare, const allocator_type& a = allocator_type() ) : internal::hash_map_base(), my_allocator(a), my_hash_compare(compare)"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_INITIALIZER_LISTS_PRESENT)",
    "insertText": "concurrent_hash_map(std::initializer_list<value_type> il, const allocator_type &a = allocator_type() ) : internal::hash_map_base(), my_allocator(a)"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_copy(il.begin(), il.end(), il.size())"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "concurrent_hash_map(std::initializer_list<value_type> il, const HashCompare& compare, const allocator_type& a = allocator_type() ) : internal::hash_map_base(), my_allocator(a), my_hash_compare(compare)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif concurrent_hash_map&)",
    "insertText": "operator(const concurrent_hash_map &table)"
  },
  {
    "label": "allocator_copy_assignment()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "allocator_copy_assignment(my_allocator, table.my_allocator, pocca_type())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } # if __TBB_CPP11_RVALUE_REF_PRESENT concurrent_hash_map&)",
    "insertText": "operator(concurrent_hash_map &&table)"
  },
  {
    "label": "internal_move_assign()",
    "kind": "Method",
    "detail": "Function (typedef node_allocator_traits::propagate_on_container_move_assignment pocma_type ;)",
    "insertText": "internal_move_assign(std::move(table), pocma_type())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } # endif # if __TBB_INITIALIZER_LISTS_PRESENT concurrent_hash_map&)",
    "insertText": "operator(std::initializer_list<value_type> il)"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "concurrent_hash_map()"
  },
  {
    "label": "range()",
    "kind": "Method",
    "detail": "Function (} range_type)",
    "insertText": "range(size_type grainsize=1)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "equal_range()",
    "kind": "Method",
    "detail": "Function (} std::pair<iterator,iterator>)",
    "insertText": "equal_range(const Key& key)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "size()"
  },
  {
    "label": "bucket_count()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "bucket_count()"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (size_type)",
    "insertText": "count(const Key &key)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "find(const_accessor &result, const Key &key)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "find(accessor &result, const Key &key)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "insert(const_accessor &result, const Key &key)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "insert(accessor &result, const Key &key)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "insert(const_accessor &result, const value_type &value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "insert(accessor &result, const value_type &value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "insert(const value_type &value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT bool)",
    "insertText": "insert(const_accessor &result, value_type && value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "insert(accessor &result, value_type && value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "insert(value_type && value)"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_VARIADIC_TEMPLATES_PRESENT template<. . . Args> bool)",
    "insertText": "emplace(const_accessor &result, Args&&... args)"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (} template<. . . Args> bool)",
    "insertText": "emplace(accessor &result, Args&&... args)"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (} template<. . . Args> bool)",
    "insertText": "emplace(Args&&... args)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} # endif # endif template<I> void)",
    "insertText": "insert(I first, I last)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_INITIALIZER_LISTS_PRESENT void)",
    "insertText": "insert(std::initializer_list<value_type> il)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(il.begin(), il.end())"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} # endif bool)",
    "insertText": "erase(const Key& key)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "erase(const_accessor& item_accessor)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "erase(accessor& item_accessor)"
  },
  {
    "label": "lookup()",
    "kind": "Method",
    "detail": "Function (} protected : bool)",
    "insertText": "lookup(bool op_insert, const Key &key, const T *t, const_accessor *result, bool write, node* (*allocate_node)(node_allocator_type& , const Key &, const T * ), node *tmp_n = 0)"
  },
  {
    "label": "accessor_location()",
    "kind": "Method",
    "detail": "Function (} } ; const_accessor*)",
    "insertText": "accessor_location(accessor_not_used const&)"
  },
  {
    "label": "generic_emplace()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_VARIADIC_TEMPLATES_PRESENT template<Accessor,. . . Args> bool)",
    "insertText": "generic_emplace(Accessor && result, Args &&... args)"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (node* node_ptr =)",
    "insertText": "create_node(my_allocator, std::forward<Args>(args)...)"
  },
  {
    "label": "exclude()",
    "kind": "Method",
    "detail": "Function (} # endif # endif bool)",
    "insertText": "exclude(const_accessor &item_accessor)"
  },
  {
    "label": "internal_equal_range()",
    "kind": "Method",
    "detail": "Function (template<I> std::pair<I,I>)",
    "insertText": "internal_equal_range(const Key& key, I end)"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_copy(const concurrent_hash_map& source)"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (template<I> void)",
    "insertText": "internal_copy(I first, I last, size_type reserve_size)"
  },
  {
    "label": "internal_move_assign()",
    "kind": "Method",
    "detail": "Function (# if __TBB_CPP11_RVALUE_REF_PRESENT void)",
    "insertText": "internal_move_assign(concurrent_hash_map&& other, tbb::internal::traits_true_type)"
  },
  {
    "label": "allocator_move_assignment()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "allocator_move_assignment(my_allocator, other.my_allocator, tbb::internal::traits_true_type())"
  },
  {
    "label": "internal_move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_move(std::move(other))"
  },
  {
    "label": "internal_move_assign()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_move_assign(concurrent_hash_map&& other, tbb::internal::traits_false_type)"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "internal_copy(std::make_move_iterator(other.begin()), std::make_move_iterator(other.end()), other.size())"
  },
  {
    "label": "internal_fast_find()",
    "kind": "Method",
    "detail": "Function (} } # endif const_pointer)",
    "insertText": "internal_fast_find(const Key& key)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (hashcode_t h = my_hash_compare .)",
    "insertText": "hash(key)"
  },
  {
    "label": "m()",
    "kind": "Method",
    "detail": "Function (hashcode_t)",
    "insertText": "m(hashcode_t) itt_load_word_with_acquire( my_mask)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (node* n ; restart :)",
    "insertText": "__TBB_ASSERT((m&(m+1))==0, \"data structure is invalid\")"
  },
  {
    "label": "get_bucket()",
    "kind": "Method",
    "detail": "Function (bucket* b =)",
    "insertText": "get_bucket(h & m)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bucket::scoped_t lock ;)",
    "insertText": "if(lock.try_acquire( b->mutex, true ))"
  },
  {
    "label": "acquire()",
    "kind": "Method",
    "detail": "Function (} else lock .)",
    "insertText": "acquire(b->mutex, false)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(b->node_list!=internal::rehash_req,NULL)"
  },
  {
    "label": "search_bucket()",
    "kind": "Method",
    "detail": "Function (} n =)",
    "insertText": "search_bucket(key, b)"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (internal::hash_map_t<concurrent_hash_map, internal::iterator_key_t<I>,internal::iterator_mapped_t<I>, Args...>)",
    "insertText": "concurrent_hash_map(I, I, Args...)"
  },
  {
    "label": "concurrent_hash_map()",
    "kind": "Method",
    "detail": "Function (internal::hash_map_t<concurrent_hash_map, Key, T, CompareOrAllocator>)",
    "insertText": "concurrent_hash_map(std::initializer_list<std::pair<const Key, T>>, CompareOrAllocator)"
  },
  {
    "label": "lookup()",
    "kind": "Method",
    "detail": "Function (# endif template<Key,T,HashCompare,A> bool concurrent_hash_map<Key,T,HashCompare,A)",
    "insertText": "lookup(bool op_insert, const Key &key, const T *t, const_accessor *result, bool write, node* (*allocate_node)(node_allocator_type& , const Key&, const T*), node *tmp_n)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!result || !result->my_node, NULL)"
  },
  {
    "label": "search_bucket()",
    "kind": "Method",
    "detail": "Function (n =)",
    "insertText": "search_bucket(key, b())"
  },
  {
    "label": "allocate_node()",
    "kind": "Method",
    "detail": "Function (tmp_n =)",
    "insertText": "allocate_node(my_allocator, key, t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!b.is_writer() && !b.upgrade_to_writer())"
  },
  {
    "label": "downgrade_to_reader()",
    "kind": "Method",
    "detail": "Function (b .)",
    "insertText": "downgrade_to_reader()"
  },
  {
    "label": "insert_new_node()",
    "kind": "Method",
    "detail": "Function (grow_segment =)",
    "insertText": "insert_new_node(b(), n = tmp_n, m)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (tmp_n = 0 ; return_value = true ; } } else {)",
    "insertText": "if(!n)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!op_insert || !return_value, \"Can't acquire new item in locked bucket?\")"
  },
  {
    "label": "__TBB_Yield()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_Yield()"
  },
  {
    "label": "enable_segment()",
    "kind": "Method",
    "detail": "Function (# if __TBB_STATISTICS my_info_resizes + + ; # endif)",
    "insertText": "enable_segment(grow_segment, my_allocator)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(tmp_n ) delete_node( tmp_n)"
  },
  {
    "label": "m()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m(1u<<__TBB_Log2( h ))"
  },
  {
    "label": "get_bucket()",
    "kind": "Method",
    "detail": "Function (b =)",
    "insertText": "get_bucket(h &= m)"
  },
  {
    "label": "lower()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "lower(*this, h, b, n), upper(lower)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(item_accessor.my_node, NULL)"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (node_list)",
    "insertText": "b()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (* p = n -> next ; my_size - - ; break ; })",
    "insertText": "while(true)"
  },
  {
    "label": "delete_node()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "delete_node(n)"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (restart : { bucket_accessor)",
    "insertText": "b(this, h & m)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (n =* p ;)",
    "insertText": "while(is_valid(n) && !my_hash_compare.equal(key, static_cast<node*>(n)->value().first ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (typedef node_allocator_traits::propagate_on_container_swap pocs_type ;)",
    "insertText": "if(this != &table && (pocs_type::value || my_allocator == table.my_allocator))"
  },
  {
    "label": "allocator_swap()",
    "kind": "Method",
    "detail": "Function (using std::swap ; tbb::)",
    "insertText": "allocator_swap(this->my_allocator, table.my_allocator, pocs_type())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(this->my_hash_compare, table.my_hash_compare)"
  },
  {
    "label": "internal_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_swap(table)"
  },
  {
    "label": "rehash()",
    "kind": "Method",
    "detail": "Function (} } template<Key,T,HashCompare,A> void concurrent_hash_map<Key,T,HashCompare,A)",
    "insertText": "rehash(size_type sz)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(sz, my_allocator)"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (hashcode_t mask = my_mask ; hashcode_t)",
    "insertText": "b(mask+1)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT((b&(b-1))==0, NULL)"
  },
  {
    "label": "get_bucket()",
    "kind": "Method",
    "detail": "Function (bucket* bp =)",
    "insertText": "get_bucket(b)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (node_base* n = bp -> node_list ;)",
    "insertText": "__TBB_ASSERT(is_valid(n) || n == internal::empty_rehashed || n == internal::rehash_req, \"Broken internal structure\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(*reinterpret_cast<intptr_t*>(&bp->mutex) == 0, \"concurrent or unexpectedly terminated operation during rehash() execution\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(b_old->node_list == internal::rehash_req)"
  },
  {
    "label": "mark_rehashed_levels()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mark_rehashed_levels(h)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (hashcode_t c = my_hash_compare .)",
    "insertText": "hash(static_cast<node*>(q)->value().first)"
  },
  {
    "label": "get_bucket()",
    "kind": "Method",
    "detail": "Function (* p = q -> next ; bucket* b_new =)",
    "insertText": "get_bucket(c & mask)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(b_new->node_list != internal::rehash_req, \"hash() function changed for key in table or internal error\")"
  },
  {
    "label": "add_to_bucket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add_to_bucket(b_new, q)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} else p =& q -> next ; } } } # if TBB_USE_PERFORMANCE_WARNINGS int current_size =)",
    "insertText": "int(my_size), buckets = int(mask)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool reported = false ; # endif # if TBB_USE_ASSERT | | TBB_USE_PERFORMANCE_WARNINGS)",
    "insertText": "for(b = 0; b <= mask; b++)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(is_valid(n) || n == internal::empty_rehashed, \"Broken internal structure\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if TBB_USE_PERFORMANCE_WARNINGS)",
    "insertText": "if(n == internal::empty_rehashed)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# endif # if TBB_USE_ASSERT)",
    "insertText": "for(; is_valid(n); n = n->next)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(h == b, \"hash() function changed for key in table or internal error\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif } # endif # if TBB_USE_PERFORMANCE_WARNINGS)",
    "insertText": "if(buckets > current_size)"
  },
  {
    "label": "runtime_warning()",
    "kind": "Method",
    "detail": "Function (tbb::)",
    "insertText": "runtime_warning(\"Performance is not optimal because the hash function produces bad randomness in lower bits in %s.\\nSize: %d Empties: %d Overlaps: %d\", #if __TBB_USE_OPTIONAL_RTTI typeid(*this).name(), #else \"concurrent_hash_map\", #endif current_size, empty_buckets, overpopulated_buckets)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (# if TBB_USE_ASSERT | | TBB_USE_PERFORMANCE_WARNINGS | | __TBB_STATISTICS # if TBB_USE_PERFORMANCE_WARNINGS | | __TBB_STATISTICS int current_size =)",
    "insertText": "int(my_size), buckets = int(m)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool reported = false ; # endif bucket* bp = 0 ;)",
    "insertText": "for(segment_index_t b = 0; b <= m; b++)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(*reinterpret_cast<intptr_t*>(&bp->mutex) == 0, \"concurrent or unexpectedly terminated operation during clear() execution\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (h& = m ;)",
    "insertText": "__TBB_ASSERT(h == b || get_bucket(h)->node_list == internal::rehash_req, \"hash() function changed for key in table or internal error\")"
  },
  {
    "label": "printf()",
    "kind": "Method",
    "detail": "Function (} # endif } # if TBB_USE_PERFORMANCE_WARNINGS | | __TBB_STATISTICS # if __TBB_STATISTICS)",
    "insertText": "printf(\"items=%d buckets: capacity=%d rehashed=%d empty=%d overpopulated=%d\" \" concurrent: resizes=%u rehashes=%u restarts=%u\\n\", current_size, int(m+1), buckets, empty_buckets, overpopulated_buckets, unsigned(my_info_resizes), unsigned(my_info_rehashes), unsigned(my_info_restarts))"
  },
  {
    "label": "segment_index_of()",
    "kind": "Method",
    "detail": "Function (reported = true ; } # endif # endif my_size = 0 ; segment_index_t s =)",
    "insertText": "segment_index_of(m)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(s+1 == pointers_per_table || !my_table[s+1], \"wrong mask or concurrent grow\")"
  },
  {
    "label": "delete_segment()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "delete_segment(s, my_allocator)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(s-- > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (hashcode_t mask = source . my_mask ;)",
    "insertText": "if(my_mask == mask)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(source.my_size, my_allocator)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bucket* dst = 0,* src = 0 ; bool rehash_required = false ;)",
    "insertText": "for(hashcode_t k = 0; k <= mask; k++)"
  },
  {
    "label": "get_bucket()",
    "kind": "Method",
    "detail": "Function (src = source .)",
    "insertText": "get_bucket(k)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "__TBB_ASSERT(dst->node_list != internal::rehash_req, \"Invalid bucket in destination table\")"
  },
  {
    "label": "node()",
    "kind": "Method",
    "detail": "Function (node* n = static_cast<)",
    "insertText": "node(src->node_list)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (rehash_required = true ; dst -> node_list = internal::rehash_req ; } else)",
    "insertText": "for(; n; n = static_cast<node*>( n->next ))"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (node* node_ptr =)",
    "insertText": "create_node(my_allocator, n->value().first, n->value().second)"
  },
  {
    "label": "add_to_bucket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add_to_bucket(dst, node_ptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + my_size ; } })",
    "insertText": "if(rehash_required ) rehash()"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "internal_copy(source.begin(), source.end(), source.my_size)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(reserve_size, my_allocator)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (hashcode_t m = my_mask ;)",
    "insertText": "for(; first != last; ++first)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (hashcode_t h = my_hash_compare .)",
    "insertText": "hash((*first).first)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(b->node_list != internal::rehash_req, \"Invalid bucket in destination table\")"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (node* node_ptr =)",
    "insertText": "create_node(my_allocator, (*first).first, (*first).second)"
  },
  {
    "label": "add_to_bucket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add_to_bucket(b, node_ptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + my_size ; } } } using interface5::concurrent_hash_map ; template<Key,T,HashCompare,A1,A2> bool)",
    "insertText": "operator(const concurrent_hash_map<Key, T, HashCompare, A1> &a, const concurrent_hash_map<Key, T, HashCompare, A2> &b)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (concurrent_hash_map<Key,T,HashCompare,A1>::const_iterator)",
    "insertText": "i(a.begin()), i_end(a.end())"
  },
  {
    "label": "j_end()",
    "kind": "Method",
    "detail": "Function (concurrent_hash_map<Key,T,HashCompare,A2>::const_iterator j,)",
    "insertText": "j_end(b.end())"
  },
  {
    "label": "equal_range()",
    "kind": "Method",
    "detail": "Function (j = b .)",
    "insertText": "equal_range(i->first)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} template<Key,T,HashCompare,A> void)",
    "insertText": "swap(concurrent_hash_map<Key, T, HashCompare, A> &a, concurrent_hash_map<Key, T, HashCompare, A> &b)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (a .)",
    "insertText": "swap(b)"
  }
]