[
  {
    "label": "concurrent_hash_map",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "concurrent_hash_map"
  },
  {
    "label": "hash_map_node_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "hash_map_node_base"
  },
  {
    "label": "of",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "of"
  },
  {
    "label": "hash_map_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_map_base"
  },
  {
    "label": "bucket",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "bucket"
  },
  {
    "label": "enable_segment_failsafe",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "enable_segment_failsafe"
  },
  {
    "label": "hash_map_range",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_map_range"
  },
  {
    "label": "hash_map_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_map_iterator"
  },
  {
    "label": "hash_map_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_map_iterator"
  },
  {
    "label": "hash_map_range",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_map_range"
  },
  {
    "label": "size_t",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "size_t"
  },
  {
    "label": "interface5",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "interface5"
  },
  {
    "label": "used",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "used"
  },
  {
    "label": "hash_map_range",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_map_range"
  },
  {
    "label": "hash_map_range",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_map_range"
  },
  {
    "label": "meets",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "meets"
  },
  {
    "label": "concurrent_hash_map",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "concurrent_hash_map"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "const_accessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "const_accessor"
  },
  {
    "label": "node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "node"
  },
  {
    "label": "node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "node"
  },
  {
    "label": "node_scoped_guard",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "node_scoped_guard"
  },
  {
    "label": "bucket_accessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "bucket_accessor"
  },
  {
    "label": "call_clear_on_leave",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "call_clear_on_leave"
  },
  {
    "label": "accessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "accessor"
  },
  {
    "label": "const_accessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "const_accessor"
  },
  {
    "label": "concurrent_hash_map",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "concurrent_hash_map"
  },
  {
    "label": "accessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "accessor"
  },
  {
    "label": "accessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "accessor"
  },
  {
    "label": "accessor_not_used",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "accessor_not_used"
  },
  {
    "label": "bucket_allocator()",
    "kind": "Method",
    "detail": "Function (bucket_allocator_type)",
    "insertText": "bucket_allocator(allocator)"
  },
  {
    "label": "watchdog()",
    "kind": "Method",
    "detail": "Function (enable_segment_failsafe)",
    "insertText": "watchdog( my_table, k )"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (block)",
    "insertText": "__TBB_ASSERT( k == embedded_block, \"Wrong segment index\" )"
  },
  {
    "label": "bucket_allocator()",
    "kind": "Method",
    "detail": "Function (bucket_allocator_type)",
    "insertText": "bucket_allocator(allocator)"
  },
  {
    "label": "check_rehashing_collision()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "check_rehashing_collision( h, m_old, m = m_now )"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (instruction)",
    "insertText": "for( ++m_old; !(h & m_old)"
  },
  {
    "label": "add_to_bucket()",
    "kind": "Method",
    "detail": "Function (inserted)",
    "insertText": "add_to_bucket( b, n )"
  },
  {
    "label": "old()",
    "kind": "Method",
    "detail": "Function (hash_map_iterator)",
    "insertText": "old(*this)"
  },
  {
    "label": "guard()",
    "kind": "Method",
    "detail": "Function (node_scoped_guard)",
    "insertText": "guard(node_ptr, allocator)"
  },
  {
    "label": "create_node()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "create_node(allocator, key, *t)"
  },
  {
    "label": "b_old()",
    "kind": "Method",
    "detail": "Function (bucket_accessor)",
    "insertText": "b_old( this, h & mask )"
  },
  {
    "label": "add_to_bucket()",
    "kind": "Method",
    "detail": "Function (b_old)",
    "insertText": "add_to_bucket( b_new, n )"
  },
  {
    "label": "scope_guard()",
    "kind": "Method",
    "detail": "Function (call_clear_on_leave)",
    "insertText": "scope_guard(this)"
  },
  {
    "label": "scope_guard()",
    "kind": "Method",
    "detail": "Function (call_clear_on_leave)",
    "insertText": "scope_guard(this)"
  },
  {
    "label": "scope_guard()",
    "kind": "Method",
    "detail": "Function (call_clear_on_leave)",
    "insertText": "scope_guard(this)"
  },
  {
    "label": "scope_guard()",
    "kind": "Method",
    "detail": "Function (call_clear_on_leave)",
    "insertText": "scope_guard(this)"
  },
  {
    "label": "scope_guard()",
    "kind": "Method",
    "detail": "Function (call_clear_on_leave)",
    "insertText": "scope_guard(this)"
  },
  {
    "label": "scope_guard()",
    "kind": "Method",
    "detail": "Function (call_clear_on_leave)",
    "insertText": "scope_guard(this)"
  },
  {
    "label": "scope_guard()",
    "kind": "Method",
    "detail": "Function (call_clear_on_leave)",
    "insertText": "scope_guard(this)"
  },
  {
    "label": "rehash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rehash(size_type n = 0)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "range_type()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "range_type( *this, grainsize )"
  },
  {
    "label": "const_range_type()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "const_range_type( *this, grainsize )"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "iterator( *this, 0, my_embedded_segment, my_embedded_segment->node_list )"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "iterator( *this, 0, 0, 0 )"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "const_iterator( *this, 0, my_embedded_segment, my_embedded_segment->node_list )"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "const_iterator( *this, 0, 0, 0 )"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap( concurrent_hash_map &table )"
  },
  {
    "label": "lookup()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "lookup(/*insert*/false, key, NULL, &result, /*write=*/true, &do_not_allocate_node )"
  },
  {
    "label": "lookup()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "lookup(/*insert*/true, key, NULL, &result, /*write=*/false, &allocate_node_default_construct )"
  },
  {
    "label": "lookup()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "lookup(/*insert*/true, key, NULL, &result, /*write=*/true, &allocate_node_default_construct )"
  },
  {
    "label": "lookup()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "lookup(/*insert*/true, value.first, &value.second, &result, /*write=*/false, &allocate_node_copy_construct )"
  },
  {
    "label": "lookup()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "lookup(/*insert*/true, value.first, &value.second, &result, /*write=*/true, &allocate_node_copy_construct )"
  },
  {
    "label": "lookup()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "lookup(/*insert*/true, value.first, &value.second, NULL, /*write=*/false, &allocate_node_copy_construct )"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "erase( const Key& key )"
  },
  {
    "label": "exclude()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "exclude( item_accessor )"
  },
  {
    "label": "exclude()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "exclude( item_accessor )"
  },
  {
    "label": "exclude()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "exclude( const_accessor &item_accessor )"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_copy( const concurrent_hash_map& source )"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_copy( I first, I last, size_type reserve_size )"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (bucket_accessor)",
    "insertText": "b( this, h & m )"
  },
  {
    "label": "backoff()",
    "kind": "Method",
    "detail": "Function (tbb::internal::atomic_backoff)",
    "insertText": "backoff(true)"
  },
  {
    "label": "enable_segment()",
    "kind": "Method",
    "detail": "Function (endif)",
    "insertText": "enable_segment( grow_segment, my_allocator )"
  },
  {
    "label": "delete_node()",
    "kind": "Method",
    "detail": "Function (only)",
    "insertText": "delete_node( tmp_n )"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (bucket_accessor)",
    "insertText": "b( this, h & m, /*writer=*/true )"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (bucket_accessor)",
    "insertText": "b( this, h & m )"
  },
  {
    "label": "item_locker()",
    "kind": "Method",
    "detail": "Function (node::scoped_t)",
    "insertText": "item_locker( n->mutex, /*write=*/true )"
  },
  {
    "label": "mark_rehashed_levels()",
    "kind": "Method",
    "detail": "Function (b_old)",
    "insertText": "mark_rehashed_levels( h )"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (segments)",
    "insertText": "for( node_base **p = &b_old->node_list, *q = *p; is_valid(q)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TBB_USE_ASSERT)",
    "insertText": "for( ; is_valid(n)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (__TBB_EXTRA_DEBUG)",
    "insertText": "for(; is_valid(n)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (version)",
    "insertText": "reserve( source.my_size, my_allocator )"
  }
]