[
  {
    "label": "SpyHashStateImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SpyHashStateImpl"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "UnorderedCombinerCallback",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnorderedCombinerCallback"
  },
  {
    "label": "OdrUse",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OdrUse"
  },
  {
    "label": "RunOnStartup",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RunOnStartup"
  },
  {
    "label": "SpyHashStateImpl()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_HASH_INTERNAL_SPY_HASH_STATE_H_ # define ABSL_HASH_INTERNAL_SPY_HASH_STATE_H_ # include<algorithm> # include<ostream> # include<string> # include<vector> # include \" absl / hash / hash . h \" # include \" absl / strings / match . h \" # include \" absl / strings / str_format . h \" # include \" absl / strings / str_join . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace hash_internal { template<T> class SpyHashStateImpl : public HashStateBase<SpyHashStateImpl<T>> { public :)",
    "insertText": "SpyHashStateImpl() : error_(std::make_shared<absl::optional<std::string>>())"
  },
  {
    "label": "SpyHashStateImpl()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SpyHashStateImpl(const SpyHashStateImpl&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (SpyHashStateImpl&)",
    "insertText": "operator(const SpyHashStateImpl&)"
  },
  {
    "label": "SpyHashStateImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SpyHashStateImpl(SpyHashStateImpl&& other)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "move(other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} SpyHashStateImpl&)",
    "insertText": "operator(SpyHashStateImpl&& other)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (hash_representation_ =)",
    "insertText": "move(other.hash_representation_)"
  },
  {
    "label": "SpyHashStateImpl()",
    "kind": "Method",
    "detail": "Function (error_ = other . error_ ; moved_from_ = other . moved_from_ ; other . moved_from_ = true ; return* this ; } template<U>)",
    "insertText": "SpyHashStateImpl(SpyHashStateImpl<U>&& other)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (error_ = other . error_ ; moved_from_ = other . moved_from_ ; other . moved_from_ = true ; } template<A,. . . Args> SpyHashStateImpl)",
    "insertText": "combine(SpyHashStateImpl s, const A& a, const Args&... args)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (s = SpyHashStateImpl<A>::)",
    "insertText": "combine(std::move(s), a)"
  },
  {
    "label": "combine()",
    "kind": "Method",
    "detail": "Function (} SpyHashStateImpl)",
    "insertText": "combine(SpyHashStateImpl s)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* s . error_ = \" AbslHashValue should not be invoked directly . \" ; } else)",
    "insertText": "if(s.moved_from_)"
  },
  {
    "label": "SetDirectAbslHashValueError()",
    "kind": "Method",
    "detail": "Function (* s . error_ = \" Used moved - from instance of the hash state object . \" ; } return s ; } void)",
    "insertText": "SetDirectAbslHashValueError()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (direct_absl_hash_value_error_ = true ; } bool)",
    "insertText": "operator(const SpyHashStateImpl& lhs, const SpyHashStateImpl& rhs)"
  },
  {
    "label": "Compare()",
    "kind": "Method",
    "detail": "Function (} enum class CompareResult { kEqual,kASuffixB,kBSuffixA,kUnequal,} ; CompareResult)",
    "insertText": "Compare(const SpyHashStateImpl& a, const SpyHashStateImpl& b)"
  },
  {
    "label": "StrJoin()",
    "kind": "Method",
    "detail": "Function (const std::string a_flat =)",
    "insertText": "StrJoin(a.hash_representation_, \"\")"
  },
  {
    "label": "StrJoin()",
    "kind": "Method",
    "detail": "Function (const std::string b_flat =)",
    "insertText": "StrJoin(b.hash_representation_, \"\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (out<<\" [ \\ n \" ;)",
    "insertText": "for(auto& s : hash_state.hash_representation_)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t offset = 0 ;)",
    "insertText": "for(char c : s)"
  },
  {
    "label": "StreamFormat()",
    "kind": "Method",
    "detail": "Function (out<<)",
    "insertText": "StreamFormat(\"\\n0x%04x: \", offset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(offset % 2 == 0)"
  },
  {
    "label": "StreamFormat()",
    "kind": "Method",
    "detail": "Function (out<<\" \" ; } out<<)",
    "insertText": "StreamFormat(\"%02x\", c)"
  },
  {
    "label": "combine_contiguous()",
    "kind": "Method",
    "detail": "Function (+ + offset ; } out<<\" \\ n \" ; } return out<<\" ] \" ; } SpyHashStateImpl)",
    "insertText": "combine_contiguous(SpyHashStateImpl hash_state, const unsigned char* begin, size_t size)"
  },
  {
    "label": "PiecewiseChunkSize()",
    "kind": "Method",
    "detail": "Function (const size_t large_chunk_stride =)",
    "insertText": "PiecewiseChunkSize()"
  },
  {
    "label": "combine_contiguous()",
    "kind": "Method",
    "detail": "Function (hash_state =)",
    "insertText": "combine_contiguous(std::move(hash_state), begin, large_chunk_stride)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (begin + = large_chunk_stride ; size - = large_chunk_stride ; } } hash_state . hash_representation_ .)",
    "insertText": "emplace_back(reinterpret_cast<const char*>(begin), size)"
  },
  {
    "label": "combiner()",
    "kind": "Method",
    "detail": "Function (UnorderedCombinerCallback cb ;)",
    "insertText": "combiner(SpyHashStateImpl<void>{}, std::ref(cb))"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort(cb.element_hash_representations.begin(), cb.element_hash_representations.end())"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (state . hash_representation_ .)",
    "insertText": "insert(state.hash_representation_.end(), cb.element_hash_representations.begin(), cb.element_hash_representations.end())"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (state . error_ =)",
    "insertText": "move(cb.error)"
  },
  {
    "label": "error()",
    "kind": "Method",
    "detail": "Function (} return state ; } absl::optional<std::string>)",
    "insertText": "error()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (element_hash_representations .)",
    "insertText": "push_back(absl::StrJoin(inner.hash_representation_, \"\"))"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (error =)",
    "insertText": "move(inner.error_)"
  },
  {
    "label": "OdrUse()",
    "kind": "Method",
    "detail": "Function (} inner = SpyHashStateImpl<void> { } ; } } ; bool direct_absl_hash_value_error_ ; std::vector<std::string> hash_representation_ ; std::shared_ptr<absl::optional<std::string>> error_ ; bool moved_from_ = false ; } ; template<T> bool SpyHashStateImpl<T>::direct_absl_hash_value_error_ ; template<bool& B> struct OdrUse {)",
    "insertText": "OdrUse()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} bool& b = B ; } ; template<)",
    "insertText": "void(*)()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (bool run ; OdrUse<run> kOdrUse { } ; } ; template<)",
    "insertText": "void(*f)()> bool RunOnStartup<f>::run = (f(), true)"
  },
  {
    "label": "AbslHashValue()",
    "kind": "Method",
    "detail": "Function (template<T,U,= absl::enable_if_t<! std::is_same<T,U>::value>,int = RunOnStartup<SpyHashStateImpl<T>::SetDirectAbslHashValueError>::run> void)",
    "insertText": "AbslHashValue(SpyHashStateImpl<T>, const U&)"
  }
]