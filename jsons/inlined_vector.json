[
  {
    "label": "TypeIdentity",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TypeIdentity"
  },
  {
    "label": "DestroyAdapter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DestroyAdapter"
  },
  {
    "label": "Allocation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Allocation"
  },
  {
    "label": "MallocAdapter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MallocAdapter"
  },
  {
    "label": "StorageView",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StorageView"
  },
  {
    "label": "IteratorValueAdapter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IteratorValueAdapter"
  },
  {
    "label": "CopyValueAdapter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CopyValueAdapter"
  },
  {
    "label": "DefaultValueAdapter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DefaultValueAdapter"
  },
  {
    "label": "AllocationTransaction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AllocationTransaction"
  },
  {
    "label": "ConstructionTransaction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstructionTransaction"
  },
  {
    "label": "Storage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Storage"
  },
  {
    "label": "MemcpyPolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MemcpyPolicy"
  },
  {
    "label": "ElementwiseAssignPolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ElementwiseAssignPolicy"
  },
  {
    "label": "ElementwiseSwapPolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ElementwiseSwapPolicy"
  },
  {
    "label": "ElementwiseConstructPolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ElementwiseConstructPolicy"
  },
  {
    "label": "Allocated",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Allocated"
  },
  {
    "label": "Inlined",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Inlined"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_CONTAINER_INTERNAL_INLINED_VECTOR_H_ # define ABSL_CONTAINER_INTERNAL_INLINED_VECTOR_H_ # include<algorithm> # include<cstddef> # include<cstring> # include<iterator> # include<limits> # include<memory> # include<new> # include<type_traits> # include<utility> # include \" absl / base / attributes . h \" # include \" absl / base / macros . h \" # include \" absl / container / internal / compressed_tuple . h \" # include \" absl / memory / memory . h \" # include \" absl / meta / type_traits . h \" # include \" absl / types / span . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace inlined_vector_internal { # if !)",
    "insertText": "defined(__clang__) && defined(__GNUC__)"
  },
  {
    "label": "DestroyElements()",
    "kind": "Method",
    "detail": "Function (template<A> using ValueType = AllocatorTraits<A>::value_type ; template<A> using SizeType = AllocatorTraits<A>::size_type ; template<A> using Pointer = AllocatorTraits<A>::pointer ; template<A> using ConstPointer = AllocatorTraits<A>::const_pointer ; template<A> using SizeType = AllocatorTraits<A>::size_type ; template<A> using DifferenceType = AllocatorTraits<A>::difference_type ; template<A> using Reference = ValueType<A>& ; template<A> using ConstReference = const ValueType<A>& ; template<A> using Iterator = Pointer<A> ; template<A> using ConstIterator = ConstPointer<A> ; template<A> using ReverseIterator = std::reverse_iterator<Iterator<A>> ; template<A> using ConstReverseIterator = std::reverse_iterator<ConstIterator<A>> ; template<A> using MoveIterator = std::move_iterator<Iterator<A>> ; template<Iterator> using IsAtLeastForwardIterator = std::is_convertible<std::iterator_traits<Iterator>::iterator_category,std::forward_iterator_tag> ; template<A> using IsMemcpyOk = absl::conjunction<std::is_same<A,std::allocator<ValueType<A>>>,absl::is_trivially_copy_constructible<ValueType<A>>,absl::is_trivially_copy_assignable<ValueType<A>>,absl::is_trivially_destructible<ValueType<A>>> ; template<A> using IsMoveAssignOk = std::is_move_assignable<ValueType<A>> ; template<A> using IsSwapOk = absl::type_traits_internal::IsSwappable<ValueType<A>> ; template<T> struct TypeIdentity { using type = T ; } ; template<T> using NoTypeDeduction = TypeIdentity<T>::type ; template<A,bool IsTriviallyDestructible = absl::is_trivially_destructible<ValueType<A>>::value> struct DestroyAdapter ; template<A> struct DestroyAdapter<A,false> { void)",
    "insertText": "DestroyElements(A& allocator, Pointer<A> destroy_first, SizeType<A> destroy_size)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (- - i ; AllocatorTraits<A)",
    "insertText": "destroy(allocator, destroy_first + i)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "void(allocator)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "void(destroy_first)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "void(destroy_size)"
  },
  {
    "label": "IsOverAligned()",
    "kind": "Method",
    "detail": "Function (} } ; template<A> struct Allocation { Pointer<A> data ; SizeType<A> capacity ; } ; template<A,bool)",
    "insertText": "IsOverAligned(alignof(ValueType<A>) > ABSL_INTERNAL_DEFAULT_NEW_ALIGNMENT)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (Allocation<A>)",
    "insertText": "Allocate(A& allocator, SizeType<A> requested_capacity)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Deallocate(A& allocator, Pointer<A> pointer, SizeType<A> capacity)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (AllocatorTraits<A)",
    "insertText": "deallocate(allocator, pointer, capacity)"
  },
  {
    "label": "ConstructElements()",
    "kind": "Method",
    "detail": "Function (} } ; template<A,ValueAdapter> void)",
    "insertText": "ConstructElements(NoTypeDeduction<A>& allocator, Pointer<A> construct_first, ValueAdapter& values, SizeType<A> construct_size)"
  },
  {
    "label": "ConstructNext()",
    "kind": "Method",
    "detail": "Function (ABSL_INTERNAL_TRY { values .)",
    "insertText": "ConstructNext(allocator, construct_first + i)"
  },
  {
    "label": "DestroyElements()",
    "kind": "Method",
    "detail": "Function (} ABSL_INTERNAL_CATCH_ANY { DestroyAdapter<A)",
    "insertText": "DestroyElements(allocator, construct_first, i)"
  },
  {
    "label": "AssignElements()",
    "kind": "Method",
    "detail": "Function (ABSL_INTERNAL_RETHROW ; } } } template<A,ValueAdapter> void)",
    "insertText": "AssignElements(Pointer<A> assign_first, ValueAdapter& values, SizeType<A> assign_size)"
  },
  {
    "label": "AssignNext()",
    "kind": "Method",
    "detail": "Function (values .)",
    "insertText": "AssignNext(assign_first + i)"
  },
  {
    "label": "IteratorValueAdapter()",
    "kind": "Method",
    "detail": "Function (} } template<A> struct StorageView { Pointer<A> data ; SizeType<A> size ; SizeType<A> capacity ; } ; template<A,Iterator> class IteratorValueAdapter { public :)",
    "insertText": "IteratorValueAdapter(const Iterator& it) : it_(it)"
  },
  {
    "label": "ConstructNext()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ConstructNext(A& allocator, Pointer<A> construct_at)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (AllocatorTraits<A)",
    "insertText": "construct(allocator, construct_at, *it_)"
  },
  {
    "label": "AssignNext()",
    "kind": "Method",
    "detail": "Function (+ + it_ ; } void)",
    "insertText": "AssignNext(Pointer<A> assign_at)"
  },
  {
    "label": "CopyValueAdapter()",
    "kind": "Method",
    "detail": "Function (* assign_at =* it_ ; + + it_ ; } private : Iterator it_ ; } ; template<A> class CopyValueAdapter { public :)",
    "insertText": "CopyValueAdapter(ConstPointer<A> p) : ptr_(p)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (AllocatorTraits<A)",
    "insertText": "construct(allocator, construct_at, *ptr_)"
  },
  {
    "label": "DefaultValueAdapter()",
    "kind": "Method",
    "detail": "Function (* assign_at =* ptr_ ; } private : ConstPointer<A> ptr_ ; } ; template<A> class DefaultValueAdapter { public :)",
    "insertText": "DefaultValueAdapter()"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (AllocatorTraits<A)",
    "insertText": "construct(allocator, construct_at)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (* assign_at = ValueType<)",
    "insertText": "A()"
  },
  {
    "label": "AllocationTransaction()",
    "kind": "Method",
    "detail": "Function (} } ; template<A> class AllocationTransaction { public :)",
    "insertText": "AllocationTransaction(A& allocator) : allocator_data_(allocator, nullptr), capacity_(0)"
  },
  {
    "label": "AllocationTransaction()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "AllocationTransaction()"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (MallocAdapter<A)",
    "insertText": "Deallocate(GetAllocator(), GetData(), GetCapacity())"
  },
  {
    "label": "AllocationTransaction()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "AllocationTransaction(const AllocationTransaction&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const AllocationTransaction&)"
  },
  {
    "label": "GetAllocator()",
    "kind": "Method",
    "detail": "Function (A&)",
    "insertText": "GetAllocator()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} Pointer<A>&)",
    "insertText": "GetData()"
  },
  {
    "label": "GetCapacity()",
    "kind": "Method",
    "detail": "Function (} SizeType<A>&)",
    "insertText": "GetCapacity()"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (} Pointer<A>)",
    "insertText": "Allocate(SizeType<A> requested_capacity)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (Allocation<A> result = MallocAdapter<A)",
    "insertText": "Allocate(GetAllocator(), requested_capacity)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (Allocation<A> result = {)",
    "insertText": "GetData(), GetCapacity()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "ConstructionTransaction()",
    "kind": "Method",
    "detail": "Function (} container_internal::CompressedTuple<A,Pointer<A>> allocator_data_ ; SizeType<A> capacity_ ; } ; template<A> class ConstructionTransaction { public :)",
    "insertText": "ConstructionTransaction(A& allocator) : allocator_data_(allocator, nullptr), size_(0)"
  },
  {
    "label": "ConstructionTransaction()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ConstructionTransaction()"
  },
  {
    "label": "DestroyElements()",
    "kind": "Method",
    "detail": "Function (DestroyAdapter<A)",
    "insertText": "DestroyElements(GetAllocator(), GetData(), GetSize())"
  },
  {
    "label": "ConstructionTransaction()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "ConstructionTransaction(const ConstructionTransaction&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const ConstructionTransaction&)"
  },
  {
    "label": "GetSize()",
    "kind": "Method",
    "detail": "Function (} SizeType<A>&)",
    "insertText": "GetSize()"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (} template<ValueAdapter> void)",
    "insertText": "Construct(Pointer<A> data, ValueAdapter& values, SizeType<A> size)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (ConstructElements<)",
    "insertText": "A(GetAllocator(), data, values, size)"
  },
  {
    "label": "Commit()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Commit()"
  },
  {
    "label": "NextCapacity()",
    "kind": "Method",
    "detail": "Function (} private : container_internal::CompressedTuple<A,Pointer<A>> allocator_data_ ; SizeType<A> size_ ; } ; template<T,size_t N,A> class Storage { public : struct MemcpyPolicy { } ; struct ElementwiseAssignPolicy { } ; struct ElementwiseSwapPolicy { } ; struct ElementwiseConstructPolicy { } ; using MoveAssignmentPolicy = absl::conditional_t<IsMemcpyOk<A>::value,MemcpyPolicy,absl::conditional_t<IsMoveAssignOk<A>::value,ElementwiseAssignPolicy,ElementwiseConstructPolicy>> ; using SwapPolicy = absl::conditional_t<IsMemcpyOk<A>::value,MemcpyPolicy,absl::conditional_t<IsSwapOk<A>::value,ElementwiseSwapPolicy,ElementwiseConstructPolicy>> ; SizeType<A>)",
    "insertText": "NextCapacity(SizeType<A> current_capacity)"
  },
  {
    "label": "Storage()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Storage() : metadata_(A(), 0u)"
  },
  {
    "label": "Storage()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Storage(const A& allocator) : metadata_(allocator, 0u)"
  },
  {
    "label": "Storage()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "Storage()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(IsMemcpyOk<A>::value)"
  },
  {
    "label": "DeallocateIfAllocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeallocateIfAllocated()"
  },
  {
    "label": "DestroyContents()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "DestroyContents()"
  },
  {
    "label": "GetSizeAndIsAllocated()",
    "kind": "Method",
    "detail": "Function (} } SizeType<A>&)",
    "insertText": "GetSizeAndIsAllocated()"
  },
  {
    "label": "GetIsAllocated()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetIsAllocated()"
  },
  {
    "label": "GetAllocatedData()",
    "kind": "Method",
    "detail": "Function (} Pointer<A>)",
    "insertText": "GetAllocatedData()"
  },
  {
    "label": "GetInlinedData()",
    "kind": "Method",
    "detail": "Function (} ConstPointer<A>)",
    "insertText": "GetInlinedData()"
  },
  {
    "label": "GetAllocatedCapacity()",
    "kind": "Method",
    "detail": "Function (} SizeType<A>)",
    "insertText": "GetAllocatedCapacity()"
  },
  {
    "label": "MakeStorageView()",
    "kind": "Method",
    "detail": "Function (} StorageView<A>)",
    "insertText": "MakeStorageView()"
  },
  {
    "label": "GetAllocatedData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetAllocatedData(), GetSize(), GetAllocatedCapacity()"
  },
  {
    "label": "GetInlinedData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetInlinedData(), GetSize(), GetInlinedCapacity()"
  },
  {
    "label": "InitFrom()",
    "kind": "Method",
    "detail": "Function (} ABSL_ATTRIBUTE_NOINLINE void)",
    "insertText": "InitFrom(const Storage& other)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (template<ValueAdapter> void)",
    "insertText": "Initialize(ValueAdapter values, SizeType<A> new_size)"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (template<ValueAdapter> void)",
    "insertText": "Assign(ValueAdapter values, SizeType<A> new_size)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (template<ValueAdapter> void)",
    "insertText": "Resize(ValueAdapter values, SizeType<A> new_size)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (template<ValueAdapter> Iterator<A>)",
    "insertText": "Insert(ConstIterator<A> pos, ValueAdapter values, SizeType<A> insert_count)"
  },
  {
    "label": "EmplaceBack()",
    "kind": "Method",
    "detail": "Function (template<. . . Args> Reference<A>)",
    "insertText": "EmplaceBack(Args&&... args)"
  },
  {
    "label": "Erase()",
    "kind": "Method",
    "detail": "Function (Iterator<A>)",
    "insertText": "Erase(ConstIterator<A> from, ConstIterator<A> to)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reserve(SizeType<A> requested_capacity)"
  },
  {
    "label": "ShrinkToFit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ShrinkToFit()"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(Storage* other_storage_ptr)"
  },
  {
    "label": "SetIsAllocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetIsAllocated()"
  },
  {
    "label": "GetSizeAndIsAllocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSizeAndIsAllocated() |= static_cast<SizeType<A>>(1)"
  },
  {
    "label": "UnsetIsAllocated()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UnsetIsAllocated()"
  },
  {
    "label": "GetSizeAndIsAllocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSizeAndIsAllocated() &= ((std::numeric_limits<SizeType<A>>::max)() - 1)"
  },
  {
    "label": "SetSize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSize(SizeType<A> size)"
  },
  {
    "label": "GetSizeAndIsAllocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSizeAndIsAllocated() = (size << 1) | static_cast<SizeType<A>>(GetIsAllocated())"
  },
  {
    "label": "SetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAllocatedSize(SizeType<A> size)"
  },
  {
    "label": "GetSizeAndIsAllocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSizeAndIsAllocated() = (size << 1) | static_cast<SizeType<A>>(1)"
  },
  {
    "label": "SetInlinedSize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetInlinedSize(SizeType<A> size)"
  },
  {
    "label": "GetSizeAndIsAllocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSizeAndIsAllocated() = size << static_cast<SizeType<A>>(1)"
  },
  {
    "label": "AddSize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddSize(SizeType<A> count)"
  },
  {
    "label": "GetSizeAndIsAllocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSizeAndIsAllocated() += count << static_cast<SizeType<A>>(1)"
  },
  {
    "label": "SubtractSize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SubtractSize(SizeType<A> count)"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(count <= GetSize())"
  },
  {
    "label": "GetSizeAndIsAllocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSizeAndIsAllocated() -= count << static_cast<SizeType<A>>(1)"
  },
  {
    "label": "SetAllocation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAllocation(Allocation<A> allocation)"
  },
  {
    "label": "MemcpyFrom()",
    "kind": "Method",
    "detail": "Function (data_ . allocated . allocated_data = allocation . data ; data_ . allocated . allocated_capacity = allocation . capacity ; } void)",
    "insertText": "MemcpyFrom(const Storage& other_storage)"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(IsMemcpyOk<A>::value || other_storage.GetIsAllocated())"
  },
  {
    "label": "GetSizeAndIsAllocated()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSizeAndIsAllocated() = other_storage.GetSizeAndIsAllocated()"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (MallocAdapter<A)",
    "insertText": "Deallocate(GetAllocator(), GetAllocatedData(), GetAllocatedCapacity())"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (using Metadata = container_internal::CompressedTuple<A,SizeType<A>> ; struct Allocated { Pointer<A> allocated_data ; SizeType<A> allocated_capacity ; } ; struct Inlined {)",
    "insertText": "alignas(ValueType<A>) char inlined_data[sizeof(ValueType<A>[N])"
  },
  {
    "label": "SwapN()",
    "kind": "Method",
    "detail": "Function (} ; union Data { Allocated allocated ; Inlined inlined ; } ; void)",
    "insertText": "SwapN(ElementwiseSwapPolicy, Storage* other, SizeType<A> n)"
  },
  {
    "label": "SwapN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapN(ElementwiseConstructPolicy, Storage* other, SizeType<A> n)"
  },
  {
    "label": "SwapInlinedElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapInlinedElements(MemcpyPolicy, Storage* other)"
  },
  {
    "label": "SwapInlinedElements()",
    "kind": "Method",
    "detail": "Function (template<NotMemcpyPolicy> void)",
    "insertText": "SwapInlinedElements(NotMemcpyPolicy, Storage* other)"
  },
  {
    "label": "EmplaceBackSlow()",
    "kind": "Method",
    "detail": "Function (template<. . . Args> ABSL_ATTRIBUTE_NOINLINE Reference<A>)",
    "insertText": "EmplaceBackSlow(Args&&... args)"
  },
  {
    "label": "GetIsAllocated()",
    "kind": "Method",
    "detail": "Function (Pointer<A> data =)",
    "insertText": "GetIsAllocated() ? GetAllocatedData() : GetInlinedData()"
  },
  {
    "label": "DestroyElements()",
    "kind": "Method",
    "detail": "Function (DestroyAdapter<A)",
    "insertText": "DestroyElements(GetAllocator(), data, GetSize())"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(n > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ConstPointer<A> src ; Pointer<A> dst ;)",
    "insertText": "if(!other.GetIsAllocated())"
  },
  {
    "label": "ComputeCapacity()",
    "kind": "Method",
    "detail": "Function (} else { SizeType<A> requested_capacity =)",
    "insertText": "ComputeCapacity(GetInlinedCapacity(), n)"
  },
  {
    "label": "SetAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAllocation(allocation)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(reinterpret_cast<char*>(dst), reinterpret_cast<const char*>(src), n * sizeof(ValueType<A>))"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (} else { auto values = IteratorValueAdapter<A,ConstPointer<)",
    "insertText": "A(src)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (ConstructElements<)",
    "insertText": "A(GetAllocator(), dst, values, n)"
  },
  {
    "label": "GetSizeAndIsAllocated()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "GetSizeAndIsAllocated() = other.GetSizeAndIsAllocated()"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(!GetIsAllocated())"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(GetSize() == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Pointer<A> construct_data ;)",
    "insertText": "if(new_size > GetInlinedCapacity())"
  },
  {
    "label": "ComputeCapacity()",
    "kind": "Method",
    "detail": "Function (SizeType<A> requested_capacity =)",
    "insertText": "ComputeCapacity(GetInlinedCapacity(), new_size)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (} ConstructElements<)",
    "insertText": "A(GetAllocator(), construct_data, values, new_size)"
  },
  {
    "label": "AddSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddSize(new_size)"
  },
  {
    "label": "allocation_tx()",
    "kind": "Method",
    "detail": "Function (AllocationTransaction<A>)",
    "insertText": "allocation_tx(GetAllocator())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (absl::Span<ValueType<A>> assign_loop ; absl::Span<ValueType<A>> construct_loop ; absl::Span<ValueType<A>> destroy_loop ;)",
    "insertText": "if(new_size > storage_view.capacity)"
  },
  {
    "label": "ComputeCapacity()",
    "kind": "Method",
    "detail": "Function (SizeType<A> requested_capacity =)",
    "insertText": "ComputeCapacity(storage_view.capacity, new_size)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (construct_loop = { allocation_tx .)",
    "insertText": "Allocate(requested_capacity)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (destroy_loop = { storage_view . data,storage_view . size } ; } else)",
    "insertText": "if(new_size > storage_view.size)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (assign_loop = { storage_view . data,storage_view . size } ; construct_loop = { storage_view . data + storage_view . size,new_size - storage_view . size } ; } else { assign_loop = { storage_view . data,new_size } ; destroy_loop = { storage_view . data + new_size,storage_view . size - new_size } ; } AssignElements<)",
    "insertText": "A(assign_loop.data(), values, assign_loop.size())"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (ConstructElements<)",
    "insertText": "A(GetAllocator(), construct_loop.data(), values, construct_loop.size())"
  },
  {
    "label": "DestroyElements()",
    "kind": "Method",
    "detail": "Function (DestroyAdapter<A)",
    "insertText": "DestroyElements(GetAllocator(), destroy_loop.data(), destroy_loop.size())"
  },
  {
    "label": "SetAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAllocation(std::move(allocation_tx).Release())"
  },
  {
    "label": "SetSize()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SetSize(new_size)"
  },
  {
    "label": "DestroyElements()",
    "kind": "Method",
    "detail": "Function (DestroyAdapter<A)",
    "insertText": "DestroyElements(alloc, base + new_size, size - new_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(new_size <= storage_view.capacity)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (ConstructElements<)",
    "insertText": "A(alloc, base + size, values, new_size - size)"
  },
  {
    "label": "allocation_tx()",
    "kind": "Method",
    "detail": "Function (} else { AllocationTransaction<A>)",
    "insertText": "allocation_tx(alloc)"
  },
  {
    "label": "construction_tx()",
    "kind": "Method",
    "detail": "Function (ConstructionTransaction<A>)",
    "insertText": "construction_tx(alloc)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (construction_tx .)",
    "insertText": "Construct(new_data + size, values, new_size - size)"
  },
  {
    "label": "move_values()",
    "kind": "Method",
    "detail": "Function (IteratorValueAdapter<A,MoveIterator<A>>)",
    "insertText": "move_values((MoveIterator<A>(base)))"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (ConstructElements<)",
    "insertText": "A(alloc, new_data, move_values, size)"
  },
  {
    "label": "DestroyElements()",
    "kind": "Method",
    "detail": "Function (DestroyAdapter<A)",
    "insertText": "DestroyElements(alloc, base, size)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "move(construction_tx).Commit()"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (auto insert_index = static_cast<SizeType<)",
    "insertText": "A(std::distance(ConstIterator<A>(storage_view.data), pos))"
  },
  {
    "label": "construction_tx()",
    "kind": "Method",
    "detail": "Function (ConstructionTransaction<A>)",
    "insertText": "construction_tx(GetAllocator())"
  },
  {
    "label": "move_construction_tx()",
    "kind": "Method",
    "detail": "Function (ConstructionTransaction<A>)",
    "insertText": "move_construction_tx(GetAllocator())"
  },
  {
    "label": "move_values()",
    "kind": "Method",
    "detail": "Function (IteratorValueAdapter<A,MoveIterator<A>>)",
    "insertText": "move_values(MoveIterator<A>(storage_view.data))"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (construction_tx .)",
    "insertText": "Construct(new_data + insert_index, values, insert_count)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (move_construction_tx .)",
    "insertText": "Construct(new_data, move_values, insert_index)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (ConstructElements<)",
    "insertText": "A(GetAllocator(), new_data + insert_end_index, move_values, storage_view.size - insert_index)"
  },
  {
    "label": "DestroyElements()",
    "kind": "Method",
    "detail": "Function (DestroyAdapter<A)",
    "insertText": "DestroyElements(GetAllocator(), storage_view.data, storage_view.size)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "move(move_construction_tx).Commit()"
  },
  {
    "label": "SetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAllocatedSize(new_size)"
  },
  {
    "label": "move_construction_destination_index()",
    "kind": "Method",
    "detail": "Function (} else { SizeType<A>)",
    "insertText": "move_construction_destination_index(std::max)(insert_end_index, storage_view.size)"
  },
  {
    "label": "move_construction_values()",
    "kind": "Method",
    "detail": "Function (IteratorValueAdapter<A,MoveIterator<A>>)",
    "insertText": "move_construction_values(MoveIterator<A>(storage_view.data + (move_construction_destination_index - insert_count)))"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (absl::Span<ValueType<A>> move_construction = { storage_view . data + move_construction_destination_index,new_size - move_construction_destination_index } ; Pointer<A> move_assignment_values = storage_view . data + insert_index ; absl::Span<ValueType<A>> move_assignment = { storage_view . data + insert_end_index,move_construction_destination_index - insert_end_index } ; absl::Span<ValueType<A>> insert_assignment = { move_assignment_values,move_construction .)",
    "insertText": "size()"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (absl::Span<ValueType<A>> insert_construction = { insert_assignment .)",
    "insertText": "data() + insert_assignment.size(), insert_count - insert_assignment.size()"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (move_construction_tx .)",
    "insertText": "Construct(move_construction.data(), move_construction_values, move_construction.size())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - destination ; - - source ;)",
    "insertText": "if(destination < last_destination)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (* destination =)",
    "insertText": "move(*source)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (} AssignElements<)",
    "insertText": "A(insert_assignment.data(), values, insert_assignment.size())"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (ConstructElements<)",
    "insertText": "A(GetAllocator(), insert_construction.data(), values, insert_construction.size())"
  },
  {
    "label": "AddSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddSize(insert_count)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const SizeType<A> n = storage_view . size ;)",
    "insertText": "if(ABSL_PREDICT_TRUE(n != storage_view.capacity))"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (Pointer<A> last_ptr = storage_view . data + n ; AllocatorTraits<A)",
    "insertText": "construct(GetAllocator(), last_ptr, std::forward<Args>(args)...)"
  },
  {
    "label": "AddSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddSize(1)"
  },
  {
    "label": "NextCapacity()",
    "kind": "Method",
    "detail": "Function (SizeType<A> requested_capacity =)",
    "insertText": "NextCapacity(storage_view.capacity)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (ABSL_INTERNAL_TRY { ConstructElements<)",
    "insertText": "A(GetAllocator(), allocation_tx.GetData(), move_values, storage_view.size)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (} ABSL_INTERNAL_CATCH_ANY { AllocatorTraits<A)",
    "insertText": "destroy(GetAllocator(), last_ptr)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (auto erase_size = static_cast<SizeType<)",
    "insertText": "A(std::distance(from, to))"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (auto erase_index = static_cast<SizeType<)",
    "insertText": "A(std::distance(ConstIterator<A>(storage_view.data), from))"
  },
  {
    "label": "move_values()",
    "kind": "Method",
    "detail": "Function (SizeType<A> erase_end_index = erase_index + erase_size ; IteratorValueAdapter<A,MoveIterator<A>>)",
    "insertText": "move_values(MoveIterator<A>(storage_view.data + erase_end_index))"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (AssignElements<)",
    "insertText": "A(storage_view.data + erase_index, move_values, storage_view.size - erase_end_index)"
  },
  {
    "label": "DestroyElements()",
    "kind": "Method",
    "detail": "Function (DestroyAdapter<A)",
    "insertText": "DestroyElements(GetAllocator(), storage_view.data + (storage_view.size - erase_size), erase_size)"
  },
  {
    "label": "SubtractSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubtractSize(erase_size)"
  },
  {
    "label": "ComputeCapacity()",
    "kind": "Method",
    "detail": "Function (SizeType<A> new_requested_capacity =)",
    "insertText": "ComputeCapacity(storage_view.capacity, requested_capacity)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (Pointer<A> new_data = allocation_tx .)",
    "insertText": "Allocate(new_requested_capacity)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (ConstructElements<)",
    "insertText": "A(GetAllocator(), new_data, move_values, storage_view.size)"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(GetIsAllocated())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Pointer<A> construct_data ;)",
    "insertText": "if(storage_view.size > GetInlinedCapacity())"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (} ABSL_INTERNAL_TRY { ConstructElements<)",
    "insertText": "A(GetAllocator(), construct_data, move_values, storage_view.size)"
  },
  {
    "label": "SetAllocation()",
    "kind": "Method",
    "detail": "Function (} ABSL_INTERNAL_CATCH_ANY {)",
    "insertText": "SetAllocation({storage_view.data, storage_view.capacity})"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (MallocAdapter<A)",
    "insertText": "Deallocate(GetAllocator(), storage_view.data, storage_view.capacity)"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "ABSL_HARDENING_ASSERT(this != other_storage_ptr)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(data_.allocated, other_storage_ptr->data_.allocated)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!GetIsAllocated() && !other_storage_ptr->GetIsAllocated())"
  },
  {
    "label": "SwapInlinedElements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapInlinedElements(SwapPolicy{}, other_storage_ptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { Storage* allocated_ptr = this ; Storage* inlined_ptr = other_storage_ptr ;)",
    "insertText": "if(!allocated_ptr->GetIsAllocated()) swap(allocated_ptr, inlined_ptr)"
  },
  {
    "label": "GetAllocatedData()",
    "kind": "Method",
    "detail": "Function (StorageView<A> allocated_storage_view { allocated_ptr ->)",
    "insertText": "GetAllocatedData(), allocated_ptr->GetSize(), allocated_ptr->GetAllocatedCapacity()"
  },
  {
    "label": "move_values()",
    "kind": "Method",
    "detail": "Function (IteratorValueAdapter<A,MoveIterator<A>>)",
    "insertText": "move_values(MoveIterator<A>(inlined_ptr->GetInlinedData()))"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (ABSL_INTERNAL_TRY { ConstructElements<)",
    "insertText": "A(inlined_ptr->GetAllocator(), allocated_ptr->GetInlinedData(), move_values, inlined_ptr->GetSize())"
  },
  {
    "label": "SetAllocation()",
    "kind": "Method",
    "detail": "Function (} ABSL_INTERNAL_CATCH_ANY { allocated_ptr ->)",
    "insertText": "SetAllocation(Allocation<A>{ allocated_storage_view.data, allocated_storage_view.capacity})"
  },
  {
    "label": "DestroyElements()",
    "kind": "Method",
    "detail": "Function (ABSL_INTERNAL_RETHROW ; } DestroyAdapter<A)",
    "insertText": "DestroyElements(inlined_ptr->GetAllocator(), inlined_ptr->GetInlinedData(), inlined_ptr->GetSize())"
  },
  {
    "label": "SetAllocation()",
    "kind": "Method",
    "detail": "Function (inlined_ptr ->)",
    "insertText": "SetAllocation(Allocation<A>{allocated_storage_view.data, allocated_storage_view.capacity})"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "swap(GetSizeAndIsAllocated(), other_storage_ptr->GetSizeAndIsAllocated())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(GetAllocator(), other_storage_ptr->GetAllocator())"
  },
  {
    "label": "swap_ranges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap_ranges(GetInlinedData(), GetInlinedData() + n, other->GetInlinedData())"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (ValueType<A>)",
    "insertText": "tmp(std::move(*a))"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (AllocatorTraits<A)",
    "insertText": "destroy(allocator_a, a)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (AllocatorTraits<A)",
    "insertText": "construct(allocator_b, a, std::move(*b))"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (AllocatorTraits<A)",
    "insertText": "destroy(allocator_b, b)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (AllocatorTraits<A)",
    "insertText": "construct(allocator_a, b, std::move(tmp))"
  },
  {
    "label": "SwapInlinedElements()",
    "kind": "Method",
    "detail": "Function (Data tmp = data_ ; data_ = other -> data_ ; other -> data_ = tmp ; } template<T,size_t N,A> template<NotMemcpyPolicy> void Storage<T,N,A)",
    "insertText": "SwapInlinedElements(NotMemcpyPolicy policy, Storage* other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Storage* small_ptr = this ; Storage* large_ptr = other ;)",
    "insertText": "if(small_ptr->GetSize() > large_ptr->GetSize())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(small_ptr, large_ptr)"
  },
  {
    "label": "SwapN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapN(policy, other, small_size)"
  },
  {
    "label": "move_values()",
    "kind": "Method",
    "detail": "Function (IteratorValueAdapter<A,MoveIterator<A>>)",
    "insertText": "move_values(MoveIterator<A>(large_ptr->GetInlinedData() + small_size))"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (ConstructElements<)",
    "insertText": "A(large_ptr->GetAllocator(), small_ptr->GetInlinedData() + small_size, move_values, diff)"
  },
  {
    "label": "DestroyElements()",
    "kind": "Method",
    "detail": "Function (DestroyAdapter<A)",
    "insertText": "DestroyElements(large_ptr->GetAllocator(), large_ptr->GetInlinedData() + small_size, diff)"
  }
]