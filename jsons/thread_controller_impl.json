[
  {
    "label": "SequenceManagerImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SequenceManagerImpl"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "MainSequenceOnly",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MainSequenceOnly"
  },
  {
    "label": "ThreadControllerImpl()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TASK_SEQUENCE_MANAGER_THREAD_CONTROLLER_IMPL_H_ # define BASE_TASK_SEQUENCE_MANAGER_THREAD_CONTROLLER_IMPL_H_ # include<memory> # include \" base / base_export . h \" # include \" base / cancelable_callback . h \" # include \" base / dcheck_is_on . h \" # include \" base / memory / raw_ptr . h \" # include \" base / memory / weak_ptr . h \" # include \" base / run_loop . h \" # include \" base / sequence_checker . h \" # include \" base / task / common / task_annotator . h \" # include \" base / task / sequence_manager / thread_controller . h \" # include \" base / task / sequence_manager / work_deduplicator . h \" # include \" base / task / single_thread_task_runner . h \" # include \" build / build_config . h \" namespace base { namespace sequence_manager { namespace internal { class SequenceManagerImpl ; class BASE_EXPORT ThreadControllerImpl : public ThreadController,public RunLoop::NestingObserver { public :)",
    "insertText": "ThreadControllerImpl(const ThreadControllerImpl&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ThreadControllerImpl&)",
    "insertText": "operator(const ThreadControllerImpl&)"
  },
  {
    "label": "ThreadControllerImpl()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ThreadControllerImpl()"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<ThreadControllerImpl>)",
    "insertText": "Create(SequenceManagerImpl* funneled_sequence_manager, const TickClock* time_source)"
  },
  {
    "label": "SetWorkBatchSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetWorkBatchSize(int work_batch_size)"
  },
  {
    "label": "WillQueueTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WillQueueTask(PendingTask* pending_task)"
  },
  {
    "label": "ScheduleWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScheduleWork()"
  },
  {
    "label": "BindToCurrentThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BindToCurrentThread(std::unique_ptr<MessagePump> message_pump)"
  },
  {
    "label": "SetNextDelayedDoWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNextDelayedDoWork(LazyNow* lazy_now, absl::optional<WakeUp> wake_up)"
  },
  {
    "label": "SetSequencedTaskSource()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSequencedTaskSource(SequencedTaskSource* sequence)"
  },
  {
    "label": "SetTimerSlack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTimerSlack(TimerSlack timer_slack)"
  },
  {
    "label": "RunsTasksInCurrentSequence()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RunsTasksInCurrentSequence()"
  },
  {
    "label": "SetDefaultTaskRunner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDefaultTaskRunner(scoped_refptr<SingleThreadTaskRunner>)"
  },
  {
    "label": "GetDefaultTaskRunner()",
    "kind": "Method",
    "detail": "Function (scoped_refptr<SingleThreadTaskRunner>)",
    "insertText": "GetDefaultTaskRunner()"
  },
  {
    "label": "RestoreDefaultTaskRunner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RestoreDefaultTaskRunner()"
  },
  {
    "label": "AddNestingObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddNestingObserver(RunLoop::NestingObserver* observer)"
  },
  {
    "label": "RemoveNestingObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveNestingObserver(RunLoop::NestingObserver* observer)"
  },
  {
    "label": "SetTaskExecutionAllowed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTaskExecutionAllowed(bool allowed)"
  },
  {
    "label": "IsTaskExecutionAllowed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsTaskExecutionAllowed()"
  },
  {
    "label": "GetBoundMessagePump()",
    "kind": "Method",
    "detail": "Function (MessagePump*)",
    "insertText": "GetBoundMessagePump()"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_IOS) || BUILDFLAG(IS_ANDROID) void AttachToMessagePump()"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "BUILDFLAG(IS_IOS) void DetachFromMessagePump()"
  },
  {
    "label": "PrioritizeYieldingToNative()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "PrioritizeYieldingToNative(base::TimeTicks prioritize_until)"
  },
  {
    "label": "EnablePeriodicYieldingToNative()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnablePeriodicYieldingToNative(base::TimeDelta delta)"
  },
  {
    "label": "ShouldQuitRunLoopWhenIdle()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldQuitRunLoopWhenIdle()"
  },
  {
    "label": "OnBeginNestedRunLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnBeginNestedRunLoop()"
  },
  {
    "label": "OnExitNestedRunLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnExitNestedRunLoop()"
  },
  {
    "label": "ThreadControllerImpl()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "ThreadControllerImpl(SequenceManagerImpl* sequence_manager, scoped_refptr<SingleThreadTaskRunner> task_runner, const TickClock* time_source)"
  },
  {
    "label": "DoWork()",
    "kind": "Method",
    "detail": "Function (raw_ptr<SequenceManagerImpl> funneled_sequence_manager_ ; scoped_refptr<SingleThreadTaskRunner> task_runner_ ; raw_ptr<RunLoop::NestingObserver> nesting_observer_ = nullptr ; private : enum class WorkType { kImmediate,kDelayed } ; void)",
    "insertText": "DoWork(WorkType work_type)"
  },
  {
    "label": "MainSequenceOnly()",
    "kind": "Method",
    "detail": "Function (struct MainSequenceOnly {)",
    "insertText": "MainSequenceOnly()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (int work_batch_size_ = 1 ; TimeTicks next_delayed_do_work =)",
    "insertText": "Max()"
  },
  {
    "label": "main_sequence_only()",
    "kind": "Method",
    "detail": "Function (} ; MainSequenceOnly main_sequence_only_ ; MainSequenceOnly&)",
    "insertText": "main_sequence_only()"
  },
  {
    "label": "DCHECK_CALLED_ON_VALID_SEQUENCE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_CALLED_ON_VALID_SEQUENCE(associated_thread_->sequence_checker)"
  }
]