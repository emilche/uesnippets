[
  {
    "label": "BoundaryOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BoundaryOp"
  },
  {
    "label": "BoundaryOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BoundaryOp"
  },
  {
    "label": "DirichletBoundaryOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DirichletBoundaryOp"
  },
  {
    "label": "LeafCountOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LeafCountOp"
  },
  {
    "label": "LeafIndexOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LeafIndexOp"
  },
  {
    "label": "CopyToVecOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CopyToVecOp"
  },
  {
    "label": "CopyFromVecOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CopyFromVecOp"
  },
  {
    "label": "ISStaggeredLaplacianOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISStaggeredLaplacianOp"
  },
  {
    "label": "ISLaplacianOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISLaplacianOp"
  },
  {
    "label": "source()",
    "kind": "Method",
    "detail": "Function (FloatTree)",
    "insertText": "source(/*background=*/0.0f)"
  },
  {
    "label": "source()",
    "kind": "Method",
    "detail": "Function (DoubleTree)",
    "insertText": "source(/*background=*/0.0)"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (TreeType::Ptr)",
    "insertText": "solve(const TreeType&, math::pcg::State&, bool staggered = false)"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (TreeType::Ptr)",
    "insertText": "solve(const TreeType&, math::pcg::State&, Interrupter&, bool staggered = false)"
  },
  {
    "label": "solveWithBoundaryConditions()",
    "kind": "Method",
    "detail": "Function (TreeType::Ptr)",
    "insertText": "solveWithBoundaryConditions(\n    const TreeType&,\n    const BoundaryOp&,\n    math::pcg::State&,\n    Interrupter&,\n    bool staggered = false)"
  },
  {
    "label": "solveWithBoundaryConditionsAndPreconditioner()",
    "kind": "Method",
    "detail": "Function (TreeType::Ptr)",
    "insertText": "solveWithBoundaryConditionsAndPreconditioner(\n    const TreeType&,\n    const BoundaryOp&,\n    math::pcg::State&,\n    Interrupter&,\n    bool staggered = false)"
  },
  {
    "label": "solveWithBoundaryConditionsAndPreconditioner()",
    "kind": "Method",
    "detail": "Function (TreeType::Ptr)",
    "insertText": "solveWithBoundaryConditionsAndPreconditioner(\n    const TreeType&,\n    const DomainTreeType&,\n    const BoundaryOp&,\n    math::pcg::State&,\n    Interrupter&,\n    bool staggered = false)"
  },
  {
    "label": "populateIndexTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "populateIndexTree(VIndexTreeType&)"
  },
  {
    "label": "createIndexTree()",
    "kind": "Method",
    "detail": "Function (ValueConverter<VIndex>::Type::Ptr)",
    "insertText": "createIndexTree(const TreeType&)"
  },
  {
    "label": "createVectorFromTree()",
    "kind": "Method",
    "detail": "Function (math::pcg::Vector<VectorValueType>::Ptr)",
    "insertText": "createVectorFromTree(\n    const SourceTreeType& source,\n    const typename SourceTreeType::template ValueConverter<VIndex>::Type& index)"
  },
  {
    "label": "createTreeFromVector()",
    "kind": "Method",
    "detail": "Function (ValueConverter<TreeValueType>::Type::Ptr)",
    "insertText": "createTreeFromVector(\n    const math::pcg::Vector<VectorValueType>& values,\n    const VIndexTreeType& index,\n    const TreeValueType& background)"
  },
  {
    "label": "createISLaplacian()",
    "kind": "Method",
    "detail": "Function (LaplacianMatrix::Ptr)",
    "insertText": "createISLaplacian(\n    const typename BoolTreeType::template ValueConverter<VIndex>::Type& vectorIndexTree,\n    const BoolTreeType& interiorMask,\n    bool staggered = false)"
  },
  {
    "label": "createISLaplacianWithBoundaryConditions()",
    "kind": "Method",
    "detail": "Function (LaplacianMatrix::Ptr)",
    "insertText": "createISLaplacianWithBoundaryConditions(\n    const typename BoolTreeType::template ValueConverter<VIndex>::Type& vectorIndexTree,\n    const BoolTreeType& interiorMask,\n    const BoundaryOp& boundaryOp,\n    typename math::pcg::Vector<LaplacianMatrix::ValueType>& source,\n    bool staggered = false)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (LeafMgrT)",
    "insertText": "leafManager(result)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (VIdxLeafMgrT)",
    "insertText": "leafManager(idxTree)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (VIdxLeafMgrT)",
    "insertText": "leafManager(idxTree)"
  },
  {
    "label": "interior()",
    "kind": "Method",
    "detail": "Function (BoolTreeType>)",
    "insertText": "interior(*interiorMask)"
  },
  {
    "label": "vectorIdx()",
    "kind": "Method",
    "detail": "Function (VIdxTreeT>)",
    "insertText": "vectorIdx(*idxTree)"
  },
  {
    "label": "vectorIdx()",
    "kind": "Method",
    "detail": "Function (VIdxTreeT>)",
    "insertText": "vectorIdx(*idxTree)"
  },
  {
    "label": "createISLaplacianWithBoundaryConditions()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "createISLaplacianWithBoundaryConditions(idxTree, interiorMask, op, unused, staggered)"
  },
  {
    "label": "idxLeafManager()",
    "kind": "Method",
    "detail": "Function (VIdxLeafMgrT)",
    "insertText": "idxLeafManager(idxTree)"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "solve(inTree, state, interrupter, staggered)"
  },
  {
    "label": "solveWithBoundaryConditions()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "solveWithBoundaryConditions(inTree, boundaryOp, state, interrupter, staggered)"
  }
]