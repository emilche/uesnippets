[
  {
    "label": "FastSweeping",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FastSweeping"
  },
  {
    "label": "MaskKernel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskKernel"
  },
  {
    "label": "InitExt",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InitExt"
  },
  {
    "label": "InitSdf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InitSdf"
  },
  {
    "label": "DilateKernel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DilateKernel"
  },
  {
    "label": "MinMaxKernel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MinMaxKernel"
  },
  {
    "label": "SweepingKernel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SweepingKernel"
  },
  {
    "label": "NN",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NN"
  },
  {
    "label": "fogToSdf()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TOOLS_FASTSWEEPING_HAS_BEEN_INCLUDED # define OPENVDB_TOOLS_FASTSWEEPING_HAS_BEEN_INCLUDED # include<type_traits> # include<cmath> # include<limits> # include<deque> # include<unordered_map> # include<utility> # include<tbb / parallel_for . h> # include<tbb / enumerable_thread_specific . h> # include<tbb / task_group . h> # include<openvdb / math / Math . h> # include<openvdb / math / Stencils . h> # include<openvdb / tree / LeafManager . h> # include \" LevelSetUtil . h \" # include \" Morphology . h \" # include \" Statistics . h \" # ifdef BENCHMARK_FAST_SWEEPING # include<openvdb / util / CpuTimer . h> # endif namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tools { template<GridT> GridT::Ptr)",
    "insertText": "fogToSdf(const GridT &fogGrid, typename GridT::ValueType isoValue, int nIter = 1)"
  },
  {
    "label": "sdfToSdf()",
    "kind": "Method",
    "detail": "Function (template<GridT> GridT::Ptr)",
    "insertText": "sdfToSdf(const GridT &sdfGrid, typename GridT::ValueType isoValue = 0, int nIter = 1)"
  },
  {
    "label": "fogToExt()",
    "kind": "Method",
    "detail": "Function (template<FogGridT,ExtOpT,ExtValueT> FogGridT::template ValueConverter<ExtValueT>::Type::Ptr)",
    "insertText": "fogToExt(const FogGridT &fogGrid, const ExtOpT &op, const ExtValueT& background, typename FogGridT::ValueType isoValue, int nIter = 1)"
  },
  {
    "label": "sdfToExt()",
    "kind": "Method",
    "detail": "Function (template<SdfGridT,ExtOpT,ExtValueT> SdfGridT::template ValueConverter<ExtValueT>::Type::Ptr)",
    "insertText": "sdfToExt(const SdfGridT &sdfGrid, const ExtOpT &op, const ExtValueT &background, typename SdfGridT::ValueType isoValue = 0, int nIter = 1)"
  },
  {
    "label": "fogToSdfAndExt()",
    "kind": "Method",
    "detail": "Function (template<FogGridT,ExtOpT,ExtValueT> std::pair<FogGridT::Ptr,FogGridT::template ValueConverter<ExtValueT>::Type::Ptr>)",
    "insertText": "fogToSdfAndExt(const FogGridT &fogGrid, const ExtOpT &op, const ExtValueT &background, typename FogGridT::ValueType isoValue, int nIter = 1)"
  },
  {
    "label": "sdfToSdfAndExt()",
    "kind": "Method",
    "detail": "Function (template<SdfGridT,ExtOpT,ExtValueT> std::pair<SdfGridT::Ptr,SdfGridT::template ValueConverter<ExtValueT>::Type::Ptr>)",
    "insertText": "sdfToSdfAndExt(const SdfGridT &sdfGrid, const ExtOpT &op, const ExtValueT &background, typename SdfGridT::ValueType isoValue = 0, int nIter = 1)"
  },
  {
    "label": "dilateSdf()",
    "kind": "Method",
    "detail": "Function (template<GridT> GridT::Ptr)",
    "insertText": "dilateSdf(const GridT &sdfGrid, int dilation, NearestNeighbors nn = NN_FACE, int nIter = 1)"
  },
  {
    "label": "maskSdf()",
    "kind": "Method",
    "detail": "Function (template<GridT,MaskTreeT> GridT::Ptr)",
    "insertText": "maskSdf(const GridT &sdfGrid, const Grid<MaskTreeT> &mask, bool ignoreActiveTiles = false, int nIter = 1)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (template<SdfGridT,ExtValueT = SdfGridT::ValueType> class FastSweeping {)",
    "insertText": "static_assert(std::is_floating_point<typename SdfGridT::ValueType>::value, \"FastSweeping requires SdfGridT to have floating-point values\")"
  },
  {
    "label": "FastSweeping()",
    "kind": "Method",
    "detail": "Function (using SdfValueT = SdfGridT::ValueType ; using SdfTreeT = SdfGridT::TreeType ; using SdfAccT = tree::ValueAccessor<SdfTreeT,false> ; using ExtGridT = SdfGridT::template ValueConverter<ExtValueT>::Type ; using ExtTreeT = ExtGridT::TreeType ; using ExtAccT = tree::ValueAccessor<ExtTreeT,false> ; using SweepMaskTreeT = SdfTreeT::template ValueConverter<ValueMask>::Type ; using SweepMaskAccT = tree::ValueAccessor<SweepMaskTreeT,false> ; public :)",
    "insertText": "FastSweeping()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "clear()"
  },
  {
    "label": "FastSweeping()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FastSweeping(const FastSweeping&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FastSweeping&)",
    "insertText": "operator(const FastSweeping&)"
  },
  {
    "label": "sdfGrid()",
    "kind": "Method",
    "detail": "Function (SdfGridT::Ptr)",
    "insertText": "sdfGrid()"
  },
  {
    "label": "initExt()",
    "kind": "Method",
    "detail": "Function (template<ExtOpT> bool)",
    "insertText": "initExt(const SdfGridT &sdfGrid, const ExtOpT &op, const ExtValueT &background, SdfValueT isoValue, bool isInputSdf)"
  },
  {
    "label": "initDilate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "initDilate(const SdfGridT &sdfGrid, int dilation, NearestNeighbors nn = NN_FACE)"
  },
  {
    "label": "initMask()",
    "kind": "Method",
    "detail": "Function (template<MaskTreeT> bool)",
    "insertText": "initMask(const SdfGridT &sdfGrid, const Grid<MaskTreeT> &mask, bool ignoreActiveTiles = false)"
  },
  {
    "label": "sweep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sweep(int nIter = 1, bool finalize = true)"
  },
  {
    "label": "sweepingVoxelCount()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "sweepingVoxelCount()"
  },
  {
    "label": "FastSweeping()",
    "kind": "Method",
    "detail": "Function (template<> struct MaskKernel ; template<> struct InitExt ; struct InitSdf ; struct DilateKernel ; struct MinMaxKernel ; struct SweepingKernel ; const Coord mOffset [ 6 ] ; SdfGridT::Ptr mSdfGrid ; ExtGridT::Ptr mExtGrid ; SweepMaskTreeT mSweepMask ; std::vector<Coord> mSweepMaskLeafOrigins ; size_t mSweepingVoxelCount,mBoundaryVoxelCount ; } ; template<SdfGridT,ExtValueT> const Coord FastSweeping<SdfGridT,ExtValueT>::mOffset [ 6 ] = { { - 1,0,0 },{ 1,0,0 },{ 0,- 1,0 },{ 0,1,0 },{ 0,0,- 1 },{ 0,0,1 } } ; template<SdfGridT,ExtValueT> FastSweeping<SdfGridT,ExtValueT)",
    "insertText": "FastSweeping() : mSdfGrid(nullptr), mExtGrid(nullptr), mSweepingVoxelCount(0), mBoundaryVoxelCount(0)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mSdfGrid .)",
    "insertText": "reset()"
  },
  {
    "label": "computeSweepMaskLeafOrigins()",
    "kind": "Method",
    "detail": "Function (mSweepingVoxelCount = mBoundaryVoxelCount = 0 ; } template<SdfGridT,ExtValueT> void FastSweeping<SdfGridT,ExtValueT)",
    "insertText": "computeSweepMaskLeafOrigins()"
  },
  {
    "label": "pruneInactive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pruneInactive(mSweepMask)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (mSweepMask .)",
    "insertText": "voxelizeActiveTiles()"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (using LeafManagerT = tree::LeafManager<SweepMaskTreeT> ; using LeafT = SweepMaskTreeT::LeafNodeType ; LeafManagerT)",
    "insertText": "leafManager(mSweepMask)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (mSweepMaskLeafOrigins .)",
    "insertText": "resize(leafManager.leafCount())"
  },
  {
    "label": "kernel()",
    "kind": "Method",
    "detail": "Function (std::atomic<size_t> sweepingVoxelCount { 0 } ; auto)",
    "insertText": "kernel(const LeafT& leaf, size_t leafIdx)"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (mSweepMaskLeafOrigins [ leafIdx ] = leaf .)",
    "insertText": "origin()"
  },
  {
    "label": "onVoxelCount()",
    "kind": "Method",
    "detail": "Function (sweepingVoxelCount + = leaf .)",
    "insertText": "onVoxelCount()"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (} ; leafManager .)",
    "insertText": "foreach(kernel, true, 1024)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mBoundaryVoxelCount = 0 ; mSweepingVoxelCount = sweepingVoxelCount ;)",
    "insertText": "if(mSdfGrid)"
  },
  {
    "label": "constTree()",
    "kind": "Method",
    "detail": "Function (const size_t totalCount = mSdfGrid ->)",
    "insertText": "constTree().activeVoxelCount()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(totalCount >= mSweepingVoxelCount)"
  },
  {
    "label": "initSdf()",
    "kind": "Method",
    "detail": "Function (mBoundaryVoxelCount = totalCount - mSweepingVoxelCount ; } } template<SdfGridT,ExtValueT> bool FastSweeping<SdfGridT,ExtValueT)",
    "insertText": "initSdf(const SdfGridT &fogGrid, SdfValueT isoValue, bool isInputSdf)"
  },
  {
    "label": "deepCopy()",
    "kind": "Method",
    "detail": "Function (mSdfGrid = fogGrid .)",
    "insertText": "deepCopy()"
  },
  {
    "label": "kernel()",
    "kind": "Method",
    "detail": "Function (InitSdf)",
    "insertText": "kernel(*this)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (kernel .)",
    "insertText": "run(isoValue, isInputSdf)"
  },
  {
    "label": "initExt()",
    "kind": "Method",
    "detail": "Function (} template<SdfGridT,ExtValueT> template<OpT> bool FastSweeping<SdfGridT,ExtValueT)",
    "insertText": "initExt(const SdfGridT &fogGrid, const OpT &op, const ExtValueT &background, SdfValueT isoValue, bool isInputSdf)"
  },
  {
    "label": "ExtGridT()",
    "kind": "Method",
    "detail": "Function (mExtGrid = createGrid<)",
    "insertText": "ExtGridT(background)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (mExtGrid ->)",
    "insertText": "topologyUnion(*mSdfGrid)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (kernel .)",
    "insertText": "run(isoValue, op, isInputSdf)"
  },
  {
    "label": "initDilate()",
    "kind": "Method",
    "detail": "Function (} template<SdfGridT,ExtValueT> bool FastSweeping<SdfGridT,ExtValueT)",
    "insertText": "initDilate(const SdfGridT &sdfGrid, int dilate, NearestNeighbors nn)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (kernel .)",
    "insertText": "run(dilate, nn)"
  },
  {
    "label": "initMask()",
    "kind": "Method",
    "detail": "Function (} template<SdfGridT,ExtValueT> template<MaskTreeT> bool FastSweeping<SdfGridT,ExtValueT)",
    "insertText": "initMask(const SdfGridT &sdfGrid, const Grid<MaskTreeT> &mask, bool ignoreActiveTiles)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(RuntimeError, \"FastSweeping: Mask not aligned with the grid!\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(mask.getGridClass() == GRID_LEVEL_SET)"
  },
  {
    "label": "sdfInteriorMask()",
    "kind": "Method",
    "detail": "Function (using T = MaskTreeT::template ValueConverter<bool>::Type ; Grid<T>::Ptr tmp =)",
    "insertText": "sdfInteriorMask(mask)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (tmp ->)",
    "insertText": "tree().voxelizeActiveTiles()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (kernel .)",
    "insertText": "run(tmp->tree())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(ignoreActiveTiles || !mask.tree().hasActiveTiles())"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (kernel .)",
    "insertText": "run(mask.tree())"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (} else { using T = MaskTreeT::template ValueConverter<ValueMask>::Type ; T)",
    "insertText": "tmp(mask.tree(), false, TopologyCopy())"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (tmp .)",
    "insertText": "voxelizeActiveTiles(true)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (kernel .)",
    "insertText": "run(tmp)"
  },
  {
    "label": "isValid()",
    "kind": "Method",
    "detail": "Function (} } return this ->)",
    "insertText": "isValid()"
  },
  {
    "label": "sweep()",
    "kind": "Method",
    "detail": "Function (} template<SdfGridT,ExtValueT> void FastSweeping<SdfGridT,ExtValueT)",
    "insertText": "sweep(int nIter, bool finalize)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(RuntimeError, \"FastSweeping::sweep called before initialization\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(this->boundaryVoxelCount() == 0)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(RuntimeError, \"FastSweeping: No boundary voxels found!\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->sweepingVoxelCount() == 0)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(RuntimeError, \"FastSweeping: No computing voxels found!\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} std::deque<SweepingKernel> kernels ;)",
    "insertText": "for(int i = 0; i < 4; i++) kernels.emplace_back(*this)"
  },
  {
    "label": "timer()",
    "kind": "Method",
    "detail": "Function ({ # ifdef BENCHMARK_FAST_SWEEPING util::CpuTimer)",
    "insertText": "timer(\"Computing voxel slices\")"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (# endif tbb::task_group tasks ; tasks .)",
    "insertText": "run([&] { kernels[0].computeVoxelSlices([](const Coord &a){ return a[0]+a[1]+a[2]; }); })"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (tasks .)",
    "insertText": "run([&] { kernels[1].computeVoxelSlices([](const Coord &a){ return a[0]+a[1]-a[2]; }); })"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (tasks .)",
    "insertText": "run([&] { kernels[2].computeVoxelSlices([](const Coord &a){ return a[0]-a[1]+a[2]; }); })"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (tasks .)",
    "insertText": "run([&] { kernels[3].computeVoxelSlices([](const Coord &a){ return a[0]-a[1]-a[2]; }); })"
  },
  {
    "label": "wait()",
    "kind": "Method",
    "detail": "Function (tasks .)",
    "insertText": "wait()"
  },
  {
    "label": "stop()",
    "kind": "Method",
    "detail": "Function (# ifdef BENCHMARK_FAST_SWEEPING timer .)",
    "insertText": "stop()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# endif })",
    "insertText": "for(int i = 0; i < nIter; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(finalize)"
  },
  {
    "label": "timer()",
    "kind": "Method",
    "detail": "Function (# ifdef BENCHMARK_FAST_SWEEPING util::CpuTimer)",
    "insertText": "timer(\"Computing extrema values\")"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (# endif MinMaxKernel kernel ; auto e = kernel .)",
    "insertText": "run(*mSdfGrid)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (# ifdef BENCHMARK_FAST_SWEEPING std::cerr<<\" Min = \"<<e .)",
    "insertText": "min() << \" Max = \" << e.max()"
  },
  {
    "label": "restart()",
    "kind": "Method",
    "detail": "Function (timer .)",
    "insertText": "restart(\"Changing asymmetric background value\")"
  },
  {
    "label": "changeAsymmetricLevelSetBackground()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "changeAsymmetricLevelSetBackground(mSdfGrid->tree(), e.max(), e.min())"
  },
  {
    "label": "MinMaxKernel()",
    "kind": "Method",
    "detail": "Function (# endif } } template<SdfGridT,ExtValueT> struct FastSweeping<SdfGridT,ExtValueT>::MinMaxKernel { using LeafMgr = tree::LeafManager<const SdfTreeT> ; using LeafRange = LeafMgr::LeafRange ;)",
    "insertText": "MinMaxKernel() : mMin(std::numeric_limits<SdfValueT>::max()), mMax(-mMin)"
  },
  {
    "label": "MinMaxKernel()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MinMaxKernel(MinMaxKernel& other, tbb::split) : mMin(other.mMin), mMax(other.mMax)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} math::MinMax<SdfValueT>)",
    "insertText": "run(const SdfGridT &grid)"
  },
  {
    "label": "mgr()",
    "kind": "Method",
    "detail": "Function (LeafMgr)",
    "insertText": "mgr(grid.tree())"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(mgr.leafRange(), *this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const LeafRange& r)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const SdfValueT v =* voxelIter ;)",
    "insertText": "if(v < mMin)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "join(const MinMaxKernel& other)"
  },
  {
    "label": "DilateKernel()",
    "kind": "Method",
    "detail": "Function (} SdfValueT mMin,mMax ; } ; template<SdfGridT,ExtValueT> struct FastSweeping<SdfGridT,ExtValueT>::DilateKernel { using LeafRange = tree::LeafManager<SdfTreeT>::LeafRange ;)",
    "insertText": "DilateKernel(FastSweeping &parent) : mParent(&parent), mBackground(parent.mSdfGrid->background())"
  },
  {
    "label": "DilateKernel()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DilateKernel(const DilateKernel &parent)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (DilateKernel&)",
    "insertText": "operator(const DilateKernel&)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "run(int dilation, NearestNeighbors nn)"
  },
  {
    "label": "timer()",
    "kind": "Method",
    "detail": "Function (# ifdef BENCHMARK_FAST_SWEEPING util::CpuTimer)",
    "insertText": "timer(\"Construct LeafManager\")"
  },
  {
    "label": "mgr()",
    "kind": "Method",
    "detail": "Function (# endif tree::LeafManager<SdfTreeT>)",
    "insertText": "mgr(mParent->mSdfGrid->tree())"
  },
  {
    "label": "restart()",
    "kind": "Method",
    "detail": "Function (# ifdef BENCHMARK_FAST_SWEEPING timer .)",
    "insertText": "restart(\"Changing background value\")"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (# endif const SdfValueT Unknown = std::numeric_limits<SdfValueT)",
    "insertText": "max()"
  },
  {
    "label": "changeLevelSetBackground()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "changeLevelSetBackground(mgr, Unknown)"
  },
  {
    "label": "restart()",
    "kind": "Method",
    "detail": "Function (# ifdef BENCHMARK_FAST_SWEEPING timer .)",
    "insertText": "restart(\"Dilating and updating mgr (parallel)\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# endif const int delta = 5 ;)",
    "insertText": "for(int i=0, d = dilation/delta; i<d; ++i) dilateActiveValues(mgr, delta, nn, IGNORE_TILES)"
  },
  {
    "label": "dilateActiveValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dilateActiveValues(mgr, dilation % delta, nn, IGNORE_TILES)"
  },
  {
    "label": "restart()",
    "kind": "Method",
    "detail": "Function (# ifdef BENCHMARK_FAST_SWEEPING timer .)",
    "insertText": "restart(\"Initializing grid and sweep mask\")"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (mParent -> mSweepMask .)",
    "insertText": "topologyUnion(mParent->mSdfGrid->constTree())"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (using LeafManagerT = tree::LeafManager<SdfGridT::TreeType> ; using LeafT = SdfGridT::TreeType::LeafNodeType ; LeafManagerT)",
    "insertText": "leafManager(mParent->mSdfGrid->tree())"
  },
  {
    "label": "kernel()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "kernel(LeafT& leaf, size_t)"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (const SdfValueT background = mBackground ; auto* maskLeaf = mParent -> mSweepMask .)",
    "insertText": "probeLeaf(leaf.origin())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(maskLeaf)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const SdfValueT value =* voxelIter ;)",
    "insertText": "if(math::Abs(value) < background)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (maskLeaf ->)",
    "insertText": "setValueOff(voxelIter.pos())"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} else { voxelIter .)",
    "insertText": "setValue(value > 0 ? Unknown : -Unknown)"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (} } } ; leafManager .)",
    "insertText": "foreach(kernel)"
  },
  {
    "label": "InitSdf()",
    "kind": "Method",
    "detail": "Function (# endif } FastSweeping* mParent ; const SdfValueT mBackground ; } ; template<SdfGridT,ExtValueT> struct FastSweeping<SdfGridT,ExtValueT>::InitSdf { using LeafRange = tree::LeafManager<SdfTreeT>::LeafRange ;)",
    "insertText": "InitSdf(FastSweeping &parent): mParent(&parent), mSdfGrid(parent.mSdfGrid.get()), mIsoValue(0), mAboveSign(0)"
  },
  {
    "label": "InitSdf()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "InitSdf(const InitSdf&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (InitSdf&)",
    "insertText": "operator(const InitSdf&)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "run(SdfValueT isoValue, bool isInputSdf)"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (mIsoValue = isoValue ; mAboveSign = isInputSdf ?)",
    "insertText": "SdfValueT(1) : SdfValueT(-1)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (SdfTreeT& tree = mSdfGrid ->)",
    "insertText": "tree()"
  },
  {
    "label": "hasActiveTiles()",
    "kind": "Method",
    "detail": "Function (const bool hasActiveTiles = tree .)",
    "insertText": "hasActiveTiles()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(RuntimeError, \"FastSweeping: A SDF should not have active tiles!\")"
  },
  {
    "label": "timer()",
    "kind": "Method",
    "detail": "Function (} # ifdef BENCHMARK_FAST_SWEEPING util::CpuTimer)",
    "insertText": "timer(\"Initialize voxels\")"
  },
  {
    "label": "mgr()",
    "kind": "Method",
    "detail": "Function ({ tree::LeafManager<SdfTreeT>)",
    "insertText": "mgr(tree, 1)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(mgr.leafRange(32), *this)"
  },
  {
    "label": "swapLeafBuffer()",
    "kind": "Method",
    "detail": "Function (mgr .)",
    "insertText": "swapLeafBuffer(1)"
  },
  {
    "label": "restart()",
    "kind": "Method",
    "detail": "Function (} # ifdef BENCHMARK_FAST_SWEEPING timer .)",
    "insertText": "restart(\"Initialize tiles - new\")"
  },
  {
    "label": "mgr()",
    "kind": "Method",
    "detail": "Function (# endif tree::NodeManager<SdfTreeT,SdfTreeT::RootNodeType::LEVEL - 1>)",
    "insertText": "mgr(tree)"
  },
  {
    "label": "foreachBottomUp()",
    "kind": "Method",
    "detail": "Function (mgr .)",
    "insertText": "foreachBottomUp(*this)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (tree .)",
    "insertText": "root().setBackground(std::numeric_limits<SdfValueT>::max(), false)"
  },
  {
    "label": "sweepMaskAcc()",
    "kind": "Method",
    "detail": "Function (SweepMaskAccT)",
    "insertText": "sweepMaskAcc(mParent->mSweepMask)"
  },
  {
    "label": "stencil()",
    "kind": "Method",
    "detail": "Function (math::GradStencil<SdfGridT,false>)",
    "insertText": "stencil(*mSdfGrid)"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (const SdfValueT h = mAboveSign* static_cast<)",
    "insertText": "SdfValueT(mSdfGrid->voxelSize()[0])"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (SdfValueT* sdf = leafIter .)",
    "insertText": "buffer(1).data()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const SdfValueT value =* voxelIter ; const bool isAbove = value> isoValue ;)",
    "insertText": "if(!voxelIter.isValueOn())"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (sdf [ voxelIter .)",
    "insertText": "pos()"
  },
  {
    "label": "getCoord()",
    "kind": "Method",
    "detail": "Function (} else { const Coord ijk = voxelIter .)",
    "insertText": "getCoord()"
  },
  {
    "label": "moveTo()",
    "kind": "Method",
    "detail": "Function (stencil .)",
    "insertText": "moveTo(ijk, value)"
  },
  {
    "label": "intersectionMask()",
    "kind": "Method",
    "detail": "Function (const auto mask = stencil .)",
    "insertText": "intersectionMask(isoValue)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} else { sweepMaskAcc .)",
    "insertText": "setValueOff(ijk)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const SdfValueT delta = value - isoValue ;)",
    "insertText": "if(math::isApproxZero(delta))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else { SdfValueT sum = 0 ;)",
    "insertText": "for(int i=0; i<6;)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (d2 =)",
    "insertText": "Abs(delta/(value-stencil.getValue(i)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(d < std::numeric_limits<SdfValueT>::max()) sum += 1/(d*d)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (} sdf [ voxelIter .)",
    "insertText": "pos()] = isAbove ? h / math::Sqrt(sum) : -h / math::Sqrt(sum)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } } } } } template<RootOrInternalNodeT> void)",
    "insertText": "operator()(const RootOrInternalNodeT& node)"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (SdfValueT& v = const_cast<)",
    "insertText": "SdfValueT(*it)"
  },
  {
    "label": "InitExt()",
    "kind": "Method",
    "detail": "Function (v = v> isoValue ? above : - above ; } } FastSweeping* mParent ; SdfGridT* mSdfGrid ; SdfValueT mIsoValue ; SdfValueT mAboveSign ; } ; template<SdfGridT,ExtValueT> template<OpT> struct FastSweeping<SdfGridT,ExtValueT>::InitExt { using LeafRange = tree::LeafManager<SdfTreeT>::LeafRange ; using OpPoolT = tbb::enumerable_thread_specific<OpT> ;)",
    "insertText": "InitExt(FastSweeping &parent) : mParent(&parent), mOpPool(nullptr), mSdfGrid(parent.mSdfGrid.get()), mExtGrid(parent.mExtGrid.get()), mIsoValue(0), mAboveSign(0)"
  },
  {
    "label": "InitExt()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "InitExt(const InitExt&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (InitExt&)",
    "insertText": "operator(const InitExt&)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "run(SdfValueT isoValue, const OpT &opPrototype, bool isInputSdf)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(RuntimeError, \"FastSweeping::InitExt expected an extension grid!\")"
  },
  {
    "label": "opPool()",
    "kind": "Method",
    "detail": "Function ({ OpPoolT)",
    "insertText": "opPool(opPrototype)"
  },
  {
    "label": "mgr()",
    "kind": "Method",
    "detail": "Function (mOpPool =& opPool ; tree::LeafManager<SdfTreeT>)",
    "insertText": "mgr(tree1, 1)"
  },
  {
    "label": "restart()",
    "kind": "Method",
    "detail": "Function (} # ifdef BENCHMARK_FAST_SWEEPING timer .)",
    "insertText": "restart(\"Initialize tiles\")"
  },
  {
    "label": "mgr()",
    "kind": "Method",
    "detail": "Function (# endif { tree::NodeManager<SdfTreeT,SdfTreeT::RootNodeType::LEVEL - 1>)",
    "insertText": "mgr(tree1)"
  },
  {
    "label": "restart()",
    "kind": "Method",
    "detail": "Function (# ifdef BENCHMARK_FAST_SWEEPING timer .)",
    "insertText": "restart(\"Voxelizing active tiles\")"
  },
  {
    "label": "sumHelper()",
    "kind": "Method",
    "detail": "Function (# endif } template<ExtT = ExtValueT,SdfT = SdfValueT,std::enable_if<std::is_same<ExtT,int>::value,int>::type = 0> void)",
    "insertText": "sumHelper(ExtT& sum2, ExtT ext, bool update, const SdfT&)"
  },
  {
    "label": "sumHelper()",
    "kind": "Method",
    "detail": "Function (} template<ExtT = ExtValueT,SdfT = SdfValueT,std::enable_if<! std::is_same<ExtT,int>::value,int>::type = 0> void)",
    "insertText": "sumHelper(ExtT& sum2, ExtT ext, bool , const SdfT& d2)"
  },
  {
    "label": "ExtValueT()",
    "kind": "Method",
    "detail": "Function (sum2 + = static_cast<)",
    "insertText": "ExtValueT(d2 * ext)"
  },
  {
    "label": "extValHelper()",
    "kind": "Method",
    "detail": "Function (} template<ExtT = ExtValueT,SdfT = SdfValueT,std::enable_if<std::is_same<ExtT,int>::value,int>::type = 0> ExtT)",
    "insertText": "extValHelper(ExtT extSum, const SdfT&)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (ExtAccT)",
    "insertText": "acc(mExtGrid->tree())"
  },
  {
    "label": "transform()",
    "kind": "Method",
    "detail": "Function (const math::Transform& xform = mExtGrid ->)",
    "insertText": "transform()"
  },
  {
    "label": "local()",
    "kind": "Method",
    "detail": "Function (OpPoolT::reference op = mOpPool ->)",
    "insertText": "local()"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (ExtValueT* ext = acc .)",
    "insertText": "probeLeaf(leafIter->origin())->buffer().data()"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (ext [ voxelIter .)",
    "insertText": "pos()] = ExtValueT(op(xform.indexToWorld(ijk)))"
  },
  {
    "label": "ExtValueT()",
    "kind": "Method",
    "detail": "Function (} else { SdfValueT sum1 = 0 ; ExtValueT sum2 = zeroVal<)",
    "insertText": "ExtValueT()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (n = i - 1 ; })",
    "insertText": "if(mask.test(i++))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (d = d2 ; n = i - 1 ; } })",
    "insertText": "if(d < std::numeric_limits<SdfValueT>::max())"
  },
  {
    "label": "d2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "d2(d*d)"
  },
  {
    "label": "xyz()",
    "kind": "Method",
    "detail": "Function (sum1 + = d2 ; const Vec3R)",
    "insertText": "xyz(static_cast<SdfValueT>(ijk[0])+d*static_cast<SdfValueT>(FastSweeping::mOffset[n][0]), static_cast<SdfValueT>(ijk[1])+d*static_cast<SdfValueT>(FastSweeping::mOffset[n][1]), static_cast<SdfValueT>(ijk[2])+d*static_cast<SdfValueT>(FastSweeping::mOffset[n][2]))"
  },
  {
    "label": "sumHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sumHelper(sum2, ExtValueT(op(xform.indexToWorld(xyz))), d < minD, d2)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (} } ext [ voxelIter .)",
    "insertText": "pos()] = extValHelper(sum2, sum1)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (sdf [ voxelIter .)",
    "insertText": "pos()] = isAbove ? h / math::Sqrt(sum1) : -h / math::Sqrt(sum1)"
  },
  {
    "label": "MaskKernel()",
    "kind": "Method",
    "detail": "Function (v = v> isoValue ? above : - above ; } } FastSweeping* mParent ; OpPoolT* mOpPool ; SdfGridT* mSdfGrid ; ExtGridT* mExtGrid ; SdfValueT mIsoValue ; SdfValueT mAboveSign ; } ; template<SdfGridT,ExtValueT> template<MaskTreeT> struct FastSweeping<SdfGridT,ExtValueT>::MaskKernel { using LeafRange = tree::LeafManager<const MaskTreeT>::LeafRange ;)",
    "insertText": "MaskKernel(FastSweeping &parent) : mParent(&parent), mSdfGrid(parent.mSdfGrid.get())"
  },
  {
    "label": "MaskKernel()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MaskKernel(const MaskKernel &parent)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MaskKernel&)",
    "insertText": "operator(const MaskKernel&)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "run(const MaskTreeT &mask)"
  },
  {
    "label": "changeLevelSetBackground()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "changeLevelSetBackground(lsTree, Unknown)"
  },
  {
    "label": "restart()",
    "kind": "Method",
    "detail": "Function (# ifdef BENCHMARK_FAST_SWEEPING timer .)",
    "insertText": "restart(\"Union with mask\")"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (# endif lsTree .)",
    "insertText": "topologyUnion(mask)"
  },
  {
    "label": "mgr()",
    "kind": "Method",
    "detail": "Function (tree::LeafManager<const MaskTreeT>)",
    "insertText": "mgr(mask)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (using LeafManagerT = tree::LeafManager<SweepMaskTreeT> ; using LeafT = SweepMaskTreeT::LeafNodeType ; LeafManagerT)",
    "insertText": "leafManager(mParent->mSweepMask)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (SdfAccT)",
    "insertText": "acc(mSdfGrid->tree())"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (SdfValueT* data = acc .)",
    "insertText": "probeLeaf(leaf.origin())->buffer().data()"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (voxelIter .)",
    "insertText": "setValue(false)"
  },
  {
    "label": "SweepingKernel()",
    "kind": "Method",
    "detail": "Function (# endif } FastSweeping* mParent ; SdfGridT* mSdfGrid ; } ; template<SdfGridT,ExtValueT> struct FastSweeping<SdfGridT,ExtValueT>::SweepingKernel {)",
    "insertText": "SweepingKernel(FastSweeping &parent) : mParent(&parent)"
  },
  {
    "label": "SweepingKernel()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SweepingKernel(const SweepingKernel&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (SweepingKernel&)",
    "insertText": "operator(const SweepingKernel&)"
  },
  {
    "label": "computeVoxelSlices()",
    "kind": "Method",
    "detail": "Function (template<HashOp> void)",
    "insertText": "computeVoxelSlices(HashOp hash)"
  },
  {
    "label": "leafManager()",
    "kind": "Method",
    "detail": "Function (# ifdef BENCHMARK_FAST_SWEEPING util::CpuTimer timer ; # endif const SweepMaskTreeT& maskTree = mParent -> mSweepMask ; using LeafManagerT = tree::LeafManager<const SweepMaskTreeT> ; using LeafT = SweepMaskTreeT::LeafNodeType ; LeafManagerT)",
    "insertText": "leafManager(maskTree)"
  },
  {
    "label": "leafSliceMasks()",
    "kind": "Method",
    "detail": "Function (int maskOffset = LeafT::DIM* 3 ; int maskRange = maskOffset* 2 ; std::vector<int8_t>)",
    "insertText": "leafSliceMasks(leafManager.leafCount()*maskRange)"
  },
  {
    "label": "kernel1()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "kernel1(const LeafT& leaf, size_t leafIdx)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const size_t leafOffset = leafIdx* maskRange ;)",
    "insertText": "for(auto voxelIter = leaf.cbeginValueOn(); voxelIter; ++voxelIter)"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (const Coord ijk =)",
    "insertText": "offsetToLocalCoord(voxelIter.pos())"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (leafSliceMasks [ leafOffset +)",
    "insertText": "hash(ijk) + maskOffset] = uint8_t(1)"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (} } ; leafManager .)",
    "insertText": "foreach(kernel1)"
  },
  {
    "label": "kernel2()",
    "kind": "Method",
    "detail": "Function (using ThreadLocalMap = std::unordered_map<int64_t,std::deque<size_t>> ; tbb::enumerable_thread_specific<ThreadLocalMap> pool ; auto)",
    "insertText": "kernel2(const LeafT& leaf, size_t leafIdx)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (const int64_t leafKey =)",
    "insertText": "hash(origin)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const size_t leafOffset = leafIdx* maskRange ;)",
    "insertText": "for(int sliceIdx = 0; sliceIdx < maskRange; sliceIdx++)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (const int64_t voxelSliceKey = leafKey + sliceIdx - maskOffset ; map [ voxelSliceKey ] .)",
    "insertText": "emplace_back(leafIdx)"
  },
  {
    "label": "foreach()",
    "kind": "Method",
    "detail": "Function (} } } ; leafManager .)",
    "insertText": "foreach(kernel2)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const ThreadLocalMap& map =* poolIt ;)",
    "insertText": "for(const auto& it : map)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (mVoxelSliceMap [ it . first ] .)",
    "insertText": "emplace_back(leafIdx, NodeMaskPtrT())"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} } } mVoxelSliceKeys .)",
    "insertText": "reserve(mVoxelSliceMap.size())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mVoxelSliceKeys .)",
    "insertText": "push_back(it.first)"
  },
  {
    "label": "kernel3()",
    "kind": "Method",
    "detail": "Function (} auto)",
    "insertText": "kernel3(tbb::blocked_range<size_t>& range)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const int64_t key = mVoxelSliceKeys [ i ] ;)",
    "insertText": "for(auto& it : mVoxelSliceMap[key])"
  },
  {
    "label": "NodeMaskT()",
    "kind": "Method",
    "detail": "Function (it . second = std::make_unique<)",
    "insertText": "NodeMaskT()"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (} } } ;)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, mVoxelSliceKeys.size()), kernel3)"
  },
  {
    "label": "kernel4()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "kernel4(tbb::blocked_range<size_t>& range)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const int64_t voxelSliceKey = mVoxelSliceKeys [ i ] ; LeafSliceArray& leafSliceArray = mVoxelSliceMap [ voxelSliceKey ] ;)",
    "insertText": "for(LeafSlice& leafSlice : leafSliceArray)"
  },
  {
    "label": "leaf()",
    "kind": "Method",
    "detail": "Function (const size_t leafIdx = leafSlice . first ; NodeMaskPtrT& nodeMask = leafSlice . second ; const LeafT& leaf = leafManager .)",
    "insertText": "leaf(leafIdx)"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (const Coord ijk =)",
    "insertText": "offsetToLocalCoord(voxelIdx)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (const int64_t key = leafKey +)",
    "insertText": "hash(ijk)"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (nodeMask ->)",
    "insertText": "setOn(voxelIdx)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (} } } } } ;)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, mVoxelSliceKeys.size()), kernel4)"
  },
  {
    "label": "ijk()",
    "kind": "Method",
    "detail": "Function (} struct NN { SdfValueT v ; int n ; Coord)",
    "insertText": "ijk(const Coord &p, int i)"
  },
  {
    "label": "NN()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NN(const SdfAccT &a, const Coord &p, int i) : v(math::Abs(a.getValue(ijk(p,i)))), n(i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "operator()(const Coord &p)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const NN &rhs)"
  },
  {
    "label": "twoNghbr()",
    "kind": "Method",
    "detail": "Function (} } ; template<ExtT = ExtValueT,SdfT = SdfValueT,std::enable_if<std::is_same<ExtT,int>::value,int>::type = 0> ExtT)",
    "insertText": "twoNghbr(const NN& d1, const NN& d2, const SdfT& , const ExtT& v1, const ExtT& v2)"
  },
  {
    "label": "threeNghbr()",
    "kind": "Method",
    "detail": "Function (} template<ExtT = ExtValueT,SdfT = SdfValueT,std::enable_if<std::is_same<ExtT,int>::value,int>::type = 0> ExtT)",
    "insertText": "threeNghbr(const NN& d1, const NN& d2, const NN& d3, const SdfT& , const ExtT& v1, const ExtT& v2, const ExtT& v3)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (math::Vec3<SdfT>)",
    "insertText": "d(d1.v, d2.v, d3.v)"
  },
  {
    "label": "v()",
    "kind": "Method",
    "detail": "Function (math::Vec3<ExtT>)",
    "insertText": "v(v1, v2, v3)"
  },
  {
    "label": "threeNghbr()",
    "kind": "Method",
    "detail": "Function (} template<ExtT = ExtValueT,SdfT = SdfValueT,std::enable_if<! std::is_same<ExtT,int>::value,int>::type = 0> ExtT)",
    "insertText": "threeNghbr(const NN& d1, const NN& d2, const NN& d3, const SdfT& w, const ExtT& v1, const ExtT& v2, const ExtT& v3)"
  },
  {
    "label": "sweep()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "sweep()"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (const SdfValueT h = static_cast<)",
    "insertText": "SdfValueT(mParent->mSdfGrid->voxelSize()[0])"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (const SdfValueT sqrt2h =)",
    "insertText": "Sqrt(SdfValueT(2))"
  },
  {
    "label": "voxelSliceIndex()",
    "kind": "Method",
    "detail": "Function (const std::vector<Coord>& leafNodeOrigins = mParent -> mSweepMaskLeafOrigins ; int64_t)",
    "insertText": "voxelSliceIndex(0)"
  },
  {
    "label": "kernel()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "kernel(const tbb::blocked_range<size_t>& range)"
  },
  {
    "label": "acc1()",
    "kind": "Method",
    "detail": "Function (using LeafT = SdfGridT::TreeType::LeafNodeType ; SdfAccT)",
    "insertText": "acc1(mParent->mSdfGrid->tree())"
  },
  {
    "label": "ExtAccT()",
    "kind": "Method",
    "detail": "Function (auto acc2 = std::unique_ptr<)",
    "insertText": "ExtAccT(tree2 ? new ExtAccT(*tree2) : nullptr)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (SdfValueT absV,sign,update,D ; NN d1,d2,d3 ; const LeafSliceArray& leafSliceArray = mVoxelSliceMap [ voxelSliceIndex ] ;)",
    "insertText": "for(size_t i = range.begin(); i < range.end(); ++i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const LeafSlice& leafSlice = leafSliceArray [ i ] ; const size_t leafIdx = leafSlice . first ; const NodeMaskPtrT& nodeMask = leafSlice . second ; const Coord& origin = leafNodeOrigins [ leafIdx ] ; Coord ijk ;)",
    "insertText": "for(auto indexIter = nodeMask->beginOn(); indexIter; ++indexIter)"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (ijk = origin +)",
    "insertText": "offsetToLocalCoord(indexIter.pos())"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (d1 =)",
    "insertText": "min(NN(acc1, ijk, 0), NN(acc1, ijk, 1))"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (d2 =)",
    "insertText": "min(NN(acc1, ijk, 2), NN(acc1, ijk, 3))"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (d3 =)",
    "insertText": "min(NN(acc1, ijk, 4), NN(acc1, ijk, 5))"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (SdfValueT& value = const_cast<)",
    "insertText": "SdfValueT(acc1.getValue(ijk))"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (sign = value> =)",
    "insertText": "SdfValueT(0) ? SdfValueT(1) : SdfValueT(-1)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (absV =)",
    "insertText": "Abs(value)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (update = d1 . v + h ;)",
    "insertText": "if(update <= d2.v)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (value = sign* update ;)",
    "insertText": "if(acc2) acc2->setValue(ijk, acc2->getValue(d1(ijk)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} continue ; })",
    "insertText": "if(d2.v <= sqrt2h + d1.v)"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (D =)",
    "insertText": "SdfValueT(2) * h * h - math::Pow2(d1.v - d2.v)"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (update =)",
    "insertText": "SdfValueT(0.5) * (d1.v + d2.v + std::sqrt(D))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (value = sign* update ;)",
    "insertText": "if(acc2)"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (d1 . v - = update ; d2 . v - = update ; const SdfValueT w =)",
    "insertText": "SdfValueT(1)/(d1.v+d2.v)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ExtValueT v1 = acc2 ->)",
    "insertText": "getValue(d1(ijk))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ExtValueT v2 = acc2 ->)",
    "insertText": "getValue(d2(ijk))"
  },
  {
    "label": "twoNghbr()",
    "kind": "Method",
    "detail": "Function (const ExtValueT extVal =)",
    "insertText": "twoNghbr(d1, d2, w, v1, v2)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (acc2 ->)",
    "insertText": "setValue(ijk, extVal)"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (} } continue ; } } const SdfValueT d123 = d1 . v + d2 . v + d3 . v ; D = d123* d123 -)",
    "insertText": "SdfValueT(3)*(d1.v*d1.v + d2.v*d2.v + d3.v*d3.v - h * h)"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (update =)",
    "insertText": "SdfValueT(1.0/3.0) * (d123 + std::sqrt(D))"
  },
  {
    "label": "SdfValueT()",
    "kind": "Method",
    "detail": "Function (d1 . v - = update ; d2 . v - = update ; d3 . v - = update ; const SdfValueT w =)",
    "insertText": "SdfValueT(1)/(d1.v+d2.v+d3.v)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ExtValueT v3 = acc2 ->)",
    "insertText": "getValue(d3(ijk))"
  },
  {
    "label": "threeNghbr()",
    "kind": "Method",
    "detail": "Function (const ExtValueT extVal =)",
    "insertText": "threeNghbr(d1, d2, d3, w, v1, v2, v3)"
  },
  {
    "label": "timer()",
    "kind": "Method",
    "detail": "Function (} } } } } } ; # ifdef BENCHMARK_FAST_SWEEPING util::CpuTimer)",
    "insertText": "timer(\"Forward sweep\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "for(size_t i = 0; i < mVoxelSliceKeys.size(); i++)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (voxelSliceIndex = mVoxelSliceKeys [ i ] ;)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, mVoxelSliceMap[voxelSliceIndex].size()), kernel)"
  },
  {
    "label": "restart()",
    "kind": "Method",
    "detail": "Function (} # ifdef BENCHMARK_FAST_SWEEPING timer .)",
    "insertText": "restart(\"Backward sweeps\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "for(size_t i = mVoxelSliceKeys.size(); i > 0; i--)"
  },
  {
    "label": "fogToSdf()",
    "kind": "Method",
    "detail": "Function (# endif } private : using NodeMaskT = SweepMaskTreeT::LeafNodeType::NodeMaskType ; using NodeMaskPtrT = std::unique_ptr<NodeMaskT> ; using LeafSlice = std::pair<size_t,NodeMaskPtrT> ; using LeafSliceArray = std::deque<LeafSlice> ; using VoxelSliceMap = std::map<int64_t,LeafSliceArray> ; FastSweeping* mParent ; VoxelSliceMap mVoxelSliceMap ; std::vector<int64_t> mVoxelSliceKeys ; } ; template<GridT> GridT::Ptr)",
    "insertText": "fogToSdf(const GridT &fogGrid, typename GridT::ValueType isoValue, int nIter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FastSweeping<GridT> fs ;)",
    "insertText": "if(fs.initSdf(fogGrid, isoValue, false)) fs.sweep(nIter)"
  },
  {
    "label": "sdfToSdf()",
    "kind": "Method",
    "detail": "Function (} template<GridT> GridT::Ptr)",
    "insertText": "sdfToSdf(const GridT &sdfGrid, typename GridT::ValueType isoValue, int nIter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FastSweeping<GridT> fs ;)",
    "insertText": "if(fs.initSdf(sdfGrid, isoValue, true)) fs.sweep(nIter)"
  },
  {
    "label": "fogToExt()",
    "kind": "Method",
    "detail": "Function (} template<FogGridT,ExtOpT,ExtValueT> FogGridT::template ValueConverter<ExtValueT>::Type::Ptr)",
    "insertText": "fogToExt(const FogGridT &fogGrid, const ExtOpT &op, const ExtValueT& background, typename FogGridT::ValueType isoValue, int nIter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FastSweeping<FogGridT,ExtValueT> fs ;)",
    "insertText": "if(fs.initExt(fogGrid, op, background, isoValue, false)) fs.sweep(nIter)"
  },
  {
    "label": "sdfToExt()",
    "kind": "Method",
    "detail": "Function (} template<SdfGridT,OpT,ExtValueT> SdfGridT::template ValueConverter<ExtValueT>::Type::Ptr)",
    "insertText": "sdfToExt(const SdfGridT &sdfGrid, const OpT &op, const ExtValueT &background, typename SdfGridT::ValueType isoValue, int nIter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FastSweeping<SdfGridT,ExtValueT> fs ;)",
    "insertText": "if(fs.initExt(sdfGrid, op, background, isoValue, true)) fs.sweep(nIter)"
  },
  {
    "label": "fogToSdfAndExt()",
    "kind": "Method",
    "detail": "Function (} template<FogGridT,ExtOpT,ExtValueT> std::pair<FogGridT::Ptr,FogGridT::template ValueConverter<ExtValueT>::Type::Ptr>)",
    "insertText": "fogToSdfAndExt(const FogGridT &fogGrid, const ExtOpT &op, const ExtValueT &background, typename FogGridT::ValueType isoValue, int nIter)"
  },
  {
    "label": "sdfToSdfAndExt()",
    "kind": "Method",
    "detail": "Function (} template<SdfGridT,ExtOpT,ExtValueT> std::pair<SdfGridT::Ptr,SdfGridT::template ValueConverter<ExtValueT>::Type::Ptr>)",
    "insertText": "sdfToSdfAndExt(const SdfGridT &sdfGrid, const ExtOpT &op, const ExtValueT &background, typename SdfGridT::ValueType isoValue, int nIter)"
  },
  {
    "label": "dilateSdf()",
    "kind": "Method",
    "detail": "Function (} template<GridT> GridT::Ptr)",
    "insertText": "dilateSdf(const GridT &sdfGrid, int dilation, NearestNeighbors nn, int nIter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FastSweeping<GridT> fs ;)",
    "insertText": "if(fs.initDilate(sdfGrid, dilation, nn)) fs.sweep(nIter)"
  },
  {
    "label": "maskSdf()",
    "kind": "Method",
    "detail": "Function (} template<GridT,MaskTreeT> GridT::Ptr)",
    "insertText": "maskSdf(const GridT &sdfGrid, const Grid<MaskTreeT> &mask, bool ignoreActiveTiles, int nIter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FastSweeping<GridT> fs ;)",
    "insertText": "if(fs.initMask(sdfGrid, mask, ignoreActiveTiles)) fs.sweep(nIter)"
  }
]