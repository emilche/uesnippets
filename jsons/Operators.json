[
  {
    "label": "is_vec3d",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_vec3d"
  },
  {
    "label": "is_double",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_double"
  },
  {
    "label": "MapAdapter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MapAdapter"
  },
  {
    "label": "ISOpMagnitude",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISOpMagnitude"
  },
  {
    "label": "OpMagnitude",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OpMagnitude"
  },
  {
    "label": "ReturnValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ReturnValue"
  },
  {
    "label": "ISGradient",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISGradient"
  },
  {
    "label": "BIAS_SCHEME",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BIAS_SCHEME"
  },
  {
    "label": "ISStencil",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISStencil"
  },
  {
    "label": "ISGradientBiased",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISGradientBiased"
  },
  {
    "label": "ISGradientNormSqrd",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISGradientNormSqrd"
  },
  {
    "label": "GetValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GetValue"
  },
  {
    "label": "ISLaplacian",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISLaplacian"
  },
  {
    "label": "ISDivergence",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISDivergence"
  },
  {
    "label": "ISCurl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISCurl"
  },
  {
    "label": "ISMeanCurvature",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISMeanCurvature"
  },
  {
    "label": "Gradient",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Gradient"
  },
  {
    "label": "GradientBiased",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GradientBiased"
  },
  {
    "label": "GradientNormSqrd",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GradientNormSqrd"
  },
  {
    "label": "Divergence",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Divergence"
  },
  {
    "label": "Curl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Curl"
  },
  {
    "label": "Laplacian",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Laplacian"
  },
  {
    "label": "CPT",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CPT"
  },
  {
    "label": "CPT_RANGE",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CPT_RANGE"
  },
  {
    "label": "MeanCurvature",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MeanCurvature"
  },
  {
    "label": "GenericMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GenericMap"
  },
  {
    "label": "MapAdapter()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_OPERATORS_HAS_BEEN_INCLUDED # define OPENVDB_MATH_OPERATORS_HAS_BEEN_INCLUDED # include \" FiniteDifference . h \" # include \" Stencils . h \" # include \" Maps . h \" # include \" Transform . h \" # include<cmath> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { template<Vec3T> struct is_vec3d { const bool value = false ; } ; template<> struct is_vec3d<Vec3d> { const bool value = true ; } ; template<T> struct is_double { const bool value = false ; } ; template<> struct is_double<double> { const bool value = true ; } ; template<MapType,OpType,ResultType> struct MapAdapter {)",
    "insertText": "MapAdapter(const MapType& m): map(m)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<AccessorType> ResultType)",
    "insertText": "result(const AccessorType& grid, const Coord& ijk)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilType> ResultType)",
    "insertText": "result(const StencilType& stencil)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; template<OpType,MapT> struct OpMagnitude { template<AccessorType> double)",
    "insertText": "result(const MapT& map, const AccessorType& grid, const Coord& ijk)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilType> double)",
    "insertText": "result(const MapT& map, const StencilType& stencil)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; namespace internal { template<T> struct ReturnValue { using ValueType = T::ValueType ; using Vec3Type = math::Vec3<ValueType> ; } ; } template<DScheme DiffScheme> struct ISGradient { template<Accessor> Vec3<Accessor::ValueType>)",
    "insertText": "result(const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "Vec3Type()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; using Vec3Type = Vec3<ValueType> ; return)",
    "insertText": "Vec3Type(D1<DiffScheme>::inX(grid, ijk), D1<DiffScheme>::inY(grid, ijk), D1<DiffScheme>::inZ(grid, ijk))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> Vec3<StencilT::ValueType>)",
    "insertText": "result(const StencilT& stencil)"
  },
  {
    "label": "Vec3Type()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; using Vec3Type = Vec3<ValueType> ; return)",
    "insertText": "Vec3Type(D1<DiffScheme>::inX(stencil), D1<DiffScheme>::inY(stencil), D1<DiffScheme>::inZ(stencil))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; template<BiasedGradientScheme bgs> struct BIAS_SCHEME { const DScheme FD = FD_1ST ; const DScheme BD = BD_1ST ; template<GridType,bool IsSafe = true> struct ISStencil { using StencilType = SevenPointStencil<GridType,IsSafe> ; } ; } ; template<> struct BIAS_SCHEME<FIRST_BIAS> { const DScheme FD = FD_1ST ; const DScheme BD = BD_1ST ; template<GridType,bool IsSafe = true> struct ISStencil { using StencilType = SevenPointStencil<GridType,IsSafe> ; } ; } ; template<> struct BIAS_SCHEME<SECOND_BIAS> { const DScheme FD = FD_2ND ; const DScheme BD = BD_2ND ; template<GridType,bool IsSafe = true> struct ISStencil { using StencilType = ThirteenPointStencil<GridType,IsSafe> ; } ; } ; template<> struct BIAS_SCHEME<THIRD_BIAS> { const DScheme FD = FD_3RD ; const DScheme BD = BD_3RD ; template<GridType,bool IsSafe = true> struct ISStencil { using StencilType = NineteenPointStencil<GridType,IsSafe> ; } ; } ; template<> struct BIAS_SCHEME<WENO5_BIAS> { const DScheme FD = FD_WENO5 ; const DScheme BD = BD_WENO5 ; template<GridType,bool IsSafe = true> struct ISStencil { using StencilType = NineteenPointStencil<GridType,IsSafe> ; } ; } ; template<> struct BIAS_SCHEME<HJWENO5_BIAS> { const DScheme FD = FD_HJWENO5 ; const DScheme BD = BD_HJWENO5 ; template<GridType,bool IsSafe = true> struct ISStencil { using StencilType = NineteenPointStencil<GridType,IsSafe> ; } ; } ; template<BiasedGradientScheme GradScheme,Vec3Bias> struct ISGradientBiased { const DScheme FD = BIAS_SCHEME<GradScheme>::FD ; const DScheme BD = BIAS_SCHEME<GradScheme>::BD ; template<Accessor> Vec3<Accessor::ValueType>)",
    "insertText": "result(const Accessor& grid, const Coord& ijk, const Vec3Bias& V)"
  },
  {
    "label": "Vec3Type()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; using Vec3Type = Vec3<ValueType> ; return)",
    "insertText": "Vec3Type(V[0]<0 ? D1<FD>::inX(grid,ijk) : D1<BD>::inX(grid,ijk), V[1]<0 ? D1<FD>::inY(grid,ijk) : D1<BD>::inY(grid,ijk), V[2]<0 ? D1<FD>::inZ(grid,ijk) : D1<BD>::inZ(grid,ijk))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> Vec3<StencilT::ValueType>)",
    "insertText": "result(const StencilT& stencil, const Vec3Bias& V)"
  },
  {
    "label": "Vec3Type()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; using Vec3Type = Vec3<ValueType> ; return)",
    "insertText": "Vec3Type(V[0]<0 ? D1<FD>::inX(stencil) : D1<BD>::inX(stencil), V[1]<0 ? D1<FD>::inY(stencil) : D1<BD>::inY(stencil), V[2]<0 ? D1<FD>::inZ(stencil) : D1<BD>::inZ(stencil))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; using Vec3Type = math::Vec3<ValueType> ; Vec3Type up = ISGradient<FD)",
    "insertText": "result(grid, ijk)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; using Vec3Type = math::Vec3<ValueType> ; Vec3Type up = ISGradient<FD)",
    "insertText": "result(stencil)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (struct GetValue { const Accessor& acc ;)",
    "insertText": "GetValue(const Accessor& acc_): acc(acc_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} simd::Float4::value_type)",
    "insertText": "operator()(const Coord& ijk_)"
  },
  {
    "label": "valueAt()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "valueAt(grid)"
  },
  {
    "label": "v1()",
    "kind": "Method",
    "detail": "Function (const simd::Float4)",
    "insertText": "v1(valueAt(ijk.offsetBy(-2, 0, 0)) - valueAt(ijk.offsetBy(-3, 0, 0)), valueAt(ijk.offsetBy( 0,-2, 0)) - valueAt(ijk.offsetBy( 0,-3, 0)), valueAt(ijk.offsetBy( 0, 0,-2)) - valueAt(ijk.offsetBy( 0, 0,-3)), 0), v2(valueAt(ijk.offsetBy(-1, 0, 0)) - valueAt(ijk.offsetBy(-2, 0, 0)), valueAt(ijk.offsetBy( 0,-1, 0)) - valueAt(ijk.offsetBy( 0,-2, 0)), valueAt(ijk.offsetBy( 0, 0,-1)) - valueAt(ijk.offsetBy( 0, 0,-2)), 0), v3(valueAt(ijk ) - valueAt(ijk.offsetBy(-1, 0, 0)), valueAt(ijk ) - valueAt(ijk.offsetBy( 0,-1, 0)), valueAt(ijk ) - valueAt(ijk.offsetBy( 0, 0,-1)), 0), v4(valueAt(ijk.offsetBy( 1, 0, 0)) - valueAt(ijk ), valueAt(ijk.offsetBy( 0, 1, 0)) - valueAt(ijk ), valueAt(ijk.offsetBy( 0, 0, 1)) - valueAt(ijk ), 0), v5(valueAt(ijk.offsetBy( 2, 0, 0)) - valueAt(ijk.offsetBy( 1, 0, 0)), valueAt(ijk.offsetBy( 0, 2, 0)) - valueAt(ijk.offsetBy( 0, 1, 0)), valueAt(ijk.offsetBy( 0, 0, 2)) - valueAt(ijk.offsetBy( 0, 0, 1)), 0), v6(valueAt(ijk.offsetBy( 3, 0, 0)) - valueAt(ijk.offsetBy( 2, 0, 0)), valueAt(ijk.offsetBy( 0, 3, 0)) - valueAt(ijk.offsetBy( 0, 2, 0)), valueAt(ijk.offsetBy( 0, 0, 3)) - valueAt(ijk.offsetBy( 0, 0, 2)), 0), down = math::WENO5(v1, v2, v3, v4, v5), up = math::WENO5(v6, v5, v4, v3, v2)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> StencilT::ValueType)",
    "insertText": "result(const StencilT& s)"
  },
  {
    "label": "v1()",
    "kind": "Method",
    "detail": "Function (using F4Val = simd::Float4::value_type ; const simd::Float4)",
    "insertText": "v1(F4Val(s.template getValue<-2, 0, 0>()) - F4Val(s.template getValue<-3, 0, 0>()), F4Val(s.template getValue< 0,-2, 0>()) - F4Val(s.template getValue< 0,-3, 0>()), F4Val(s.template getValue< 0, 0,-2>()) - F4Val(s.template getValue< 0, 0,-3>()), 0), v2(F4Val(s.template getValue<-1, 0, 0>()) - F4Val(s.template getValue<-2, 0, 0>()), F4Val(s.template getValue< 0,-1, 0>()) - F4Val(s.template getValue< 0,-2, 0>()), F4Val(s.template getValue< 0, 0,-1>()) - F4Val(s.template getValue< 0, 0,-2>()), 0), v3(F4Val(s.template getValue< 0, 0, 0>()) - F4Val(s.template getValue<-1, 0, 0>()), F4Val(s.template getValue< 0, 0, 0>()) - F4Val(s.template getValue< 0,-1, 0>()), F4Val(s.template getValue< 0, 0, 0>()) - F4Val(s.template getValue< 0, 0,-1>()), 0), v4(F4Val(s.template getValue< 1, 0, 0>()) - F4Val(s.template getValue< 0, 0, 0>()), F4Val(s.template getValue< 0, 1, 0>()) - F4Val(s.template getValue< 0, 0, 0>()), F4Val(s.template getValue< 0, 0, 1>()) - F4Val(s.template getValue< 0, 0, 0>()), 0), v5(F4Val(s.template getValue< 2, 0, 0>()) - F4Val(s.template getValue< 1, 0, 0>()), F4Val(s.template getValue< 0, 2, 0>()) - F4Val(s.template getValue< 0, 1, 0>()), F4Val(s.template getValue< 0, 0, 2>()) - F4Val(s.template getValue< 0, 0, 1>()), 0), v6(F4Val(s.template getValue< 3, 0, 0>()) - F4Val(s.template getValue< 2, 0, 0>()), F4Val(s.template getValue< 0, 3, 0>()) - F4Val(s.template getValue< 0, 2, 0>()), F4Val(s.template getValue< 0, 0, 3>()) - F4Val(s.template getValue< 0, 0, 2>()), 0), down = math::WENO5(v1, v2, v3, v4, v5), up = math::WENO5(v6, v5, v4, v3, v2)"
  },
  {
    "label": "ValueT()",
    "kind": "Method",
    "detail": "Function (using ValueT = Accessor::ValueType ; return static_cast<)",
    "insertText": "ValueT((-1./12.)*( grid.getValue(ijk.offsetBy(2,0,0)) + grid.getValue(ijk.offsetBy(-2, 0, 0)) + grid.getValue(ijk.offsetBy(0,2,0)) + grid.getValue(ijk.offsetBy( 0,-2, 0)) + grid.getValue(ijk.offsetBy(0,0,2)) + grid.getValue(ijk.offsetBy( 0, 0,-2)) ) + (4./3.)*( grid.getValue(ijk.offsetBy(1,0,0)) + grid.getValue(ijk.offsetBy(-1, 0, 0)) + grid.getValue(ijk.offsetBy(0,1,0)) + grid.getValue(ijk.offsetBy( 0,-1, 0)) + grid.getValue(ijk.offsetBy(0,0,1)) + grid.getValue(ijk.offsetBy( 0, 0,-1)) ) - 7.5*grid.getValue(ijk))"
  },
  {
    "label": "ValueT()",
    "kind": "Method",
    "detail": "Function (using ValueT = StencilT::ValueType ; return static_cast<)",
    "insertText": "ValueT((-1./12.)*( stencil.template getValue< 2, 0, 0>() + stencil.template getValue<-2, 0, 0>() + stencil.template getValue< 0, 2, 0>() + stencil.template getValue< 0,-2, 0>() + stencil.template getValue< 0, 0, 2>() + stencil.template getValue< 0, 0,-2>() ) + (4./3.)*( stencil.template getValue< 1, 0, 0>() + stencil.template getValue<-1, 0, 0>() + stencil.template getValue< 0, 1, 0>() + stencil.template getValue< 0,-1, 0>() + stencil.template getValue< 0, 0, 1>() + stencil.template getValue< 0, 0,-1>() ) - 7.5*stencil.template getValue< 0, 0, 0>())"
  },
  {
    "label": "ValueT()",
    "kind": "Method",
    "detail": "Function (using ValueT = Accessor::ValueType ; return static_cast<)",
    "insertText": "ValueT((1./90.)*( grid.getValue(ijk.offsetBy(3,0,0)) + grid.getValue(ijk.offsetBy(-3, 0, 0)) + grid.getValue(ijk.offsetBy(0,3,0)) + grid.getValue(ijk.offsetBy( 0,-3, 0)) + grid.getValue(ijk.offsetBy(0,0,3)) + grid.getValue(ijk.offsetBy( 0, 0,-3)) ) - (3./20.)*( grid.getValue(ijk.offsetBy(2,0,0)) + grid.getValue(ijk.offsetBy(-2, 0, 0)) + grid.getValue(ijk.offsetBy(0,2,0)) + grid.getValue(ijk.offsetBy( 0,-2, 0)) + grid.getValue(ijk.offsetBy(0,0,2)) + grid.getValue(ijk.offsetBy( 0, 0,-2)) ) + 1.5 *( grid.getValue(ijk.offsetBy(1,0,0)) + grid.getValue(ijk.offsetBy(-1, 0, 0)) + grid.getValue(ijk.offsetBy(0,1,0)) + grid.getValue(ijk.offsetBy( 0,-1, 0)) + grid.getValue(ijk.offsetBy(0,0,1)) + grid.getValue(ijk.offsetBy( 0, 0,-1)) ) - (3*49/18.)*grid.getValue(ijk))"
  },
  {
    "label": "ValueT()",
    "kind": "Method",
    "detail": "Function (using ValueT = StencilT::ValueType ; return static_cast<)",
    "insertText": "ValueT((1./90.)*( stencil.template getValue< 3, 0, 0>() + stencil.template getValue<-3, 0, 0>() + stencil.template getValue< 0, 3, 0>() + stencil.template getValue< 0,-3, 0>() + stencil.template getValue< 0, 0, 3>() + stencil.template getValue< 0, 0,-3>() ) - (3./20.)*( stencil.template getValue< 2, 0, 0>() + stencil.template getValue<-2, 0, 0>() + stencil.template getValue< 0, 2, 0>() + stencil.template getValue< 0,-2, 0>() + stencil.template getValue< 0, 0, 2>() + stencil.template getValue< 0, 0,-2>() ) + 1.5 *( stencil.template getValue< 1, 0, 0>() + stencil.template getValue<-1, 0, 0>() + stencil.template getValue< 0, 1, 0>() + stencil.template getValue< 0,-1, 0>() + stencil.template getValue< 0, 0, 1>() + stencil.template getValue< 0, 0,-1>() ) - (3*49/18.)*stencil.template getValue< 0, 0, 0>())"
  },
  {
    "label": "Vec3Type()",
    "kind": "Method",
    "detail": "Function (using Vec3Type = Accessor::ValueType ; return)",
    "insertText": "Vec3Type(D1Vec<DiffScheme>::inY(grid, ijk, 2) - D1Vec<DiffScheme>::inZ(grid, ijk, 1), D1Vec<DiffScheme>::inZ(grid, ijk, 0) - D1Vec<DiffScheme>::inX(grid, ijk, 2), D1Vec<DiffScheme>::inX(grid, ijk, 1) - D1Vec<DiffScheme>::inY(grid, ijk, 0))"
  },
  {
    "label": "Vec3Type()",
    "kind": "Method",
    "detail": "Function (using Vec3Type = StencilT::ValueType ; return)",
    "insertText": "Vec3Type(D1Vec<DiffScheme>::inY(stencil, 2) - D1Vec<DiffScheme>::inZ(stencil, 1), D1Vec<DiffScheme>::inZ(stencil, 0) - D1Vec<DiffScheme>::inX(stencil, 2), D1Vec<DiffScheme>::inX(stencil, 1) - D1Vec<DiffScheme>::inY(stencil, 0))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; template<DDScheme DiffScheme2,DScheme DiffScheme1> struct ISMeanCurvature { template<Accessor> bool)",
    "insertText": "result(const Accessor& grid, const Coord& ijk, typename Accessor::ValueType& alpha, typename Accessor::ValueType& beta)"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; const ValueType Dx = D1<DiffScheme1)",
    "insertText": "inX(grid, ijk)"
  },
  {
    "label": "inY()",
    "kind": "Method",
    "detail": "Function (const ValueType Dy = D1<DiffScheme1)",
    "insertText": "inY(grid, ijk)"
  },
  {
    "label": "inZ()",
    "kind": "Method",
    "detail": "Function (const ValueType Dz = D1<DiffScheme1)",
    "insertText": "inZ(grid, ijk)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const ValueType Dx2 = Dx* Dx ; const ValueType Dy2 = Dy* Dy ; const ValueType Dz2 = Dz* Dz ; const ValueType normGrad = Dx2 + Dy2 + Dz2 ;)",
    "insertText": "if(normGrad <= math::Tolerance<ValueType>::value())"
  },
  {
    "label": "inXandY()",
    "kind": "Method",
    "detail": "Function (const ValueType Dxy = D2<DiffScheme2)",
    "insertText": "inXandY(grid, ijk)"
  },
  {
    "label": "inYandZ()",
    "kind": "Method",
    "detail": "Function (const ValueType Dyz = D2<DiffScheme2)",
    "insertText": "inYandZ(grid, ijk)"
  },
  {
    "label": "inXandZ()",
    "kind": "Method",
    "detail": "Function (const ValueType Dxz = D2<DiffScheme2)",
    "insertText": "inXandZ(grid, ijk)"
  },
  {
    "label": "alpha()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alpha(Dx2*(Dyy+Dzz)+Dy2*(Dxx+Dzz)+Dz2*(Dxx+Dyy)-2*(Dx*(Dy*Dxy+Dz*Dxz)+Dy*Dz*Dyz))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (beta =)",
    "insertText": "ValueType(std::sqrt(double(normGrad)))"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; const ValueType Dx = D1<DiffScheme1)",
    "insertText": "inX(stencil)"
  },
  {
    "label": "inY()",
    "kind": "Method",
    "detail": "Function (const ValueType Dy = D1<DiffScheme1)",
    "insertText": "inY(stencil)"
  },
  {
    "label": "inZ()",
    "kind": "Method",
    "detail": "Function (const ValueType Dz = D1<DiffScheme1)",
    "insertText": "inZ(stencil)"
  },
  {
    "label": "inXandY()",
    "kind": "Method",
    "detail": "Function (const ValueType Dxy = D2<DiffScheme2)",
    "insertText": "inXandY(stencil)"
  },
  {
    "label": "inYandZ()",
    "kind": "Method",
    "detail": "Function (const ValueType Dyz = D2<DiffScheme2)",
    "insertText": "inYandZ(stencil)"
  },
  {
    "label": "inXandZ()",
    "kind": "Method",
    "detail": "Function (const ValueType Dxz = D2<DiffScheme2)",
    "insertText": "inXandZ(stencil)"
  },
  {
    "label": "iGradient()",
    "kind": "Method",
    "detail": "Function (using Vec3Type = internal::ReturnValue<Accessor>::Vec3Type ; Vec3d)",
    "insertText": "iGradient(ISGradient<DiffScheme>::result(grid, ijk))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> internal::ReturnValue<StencilT>::Vec3Type)",
    "insertText": "result(const MapType& map, const StencilT& stencil)"
  },
  {
    "label": "iGradient()",
    "kind": "Method",
    "detail": "Function (using Vec3Type = internal::ReturnValue<StencilT>::Vec3Type ; Vec3d)",
    "insertText": "iGradient(ISGradient<DiffScheme>::result(stencil))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; template<DScheme DiffScheme> struct Gradient<TranslationMap,DiffScheme> { template<Accessor> internal::ReturnValue<Accessor>::Vec3Type)",
    "insertText": "result(const TranslationMap&, const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> internal::ReturnValue<StencilT>::Vec3Type)",
    "insertText": "result(const TranslationMap&, const StencilT& stencil)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct Gradient<UniformScaleMap,CD_2ND> { template<Accessor> internal::ReturnValue<Accessor>::Vec3Type)",
    "insertText": "result(const UniformScaleMap& map, const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "iGradient()",
    "kind": "Method",
    "detail": "Function (using ValueType = internal::ReturnValue<Accessor>::ValueType ; using Vec3Type = internal::ReturnValue<Accessor>::Vec3Type ; Vec3Type)",
    "insertText": "iGradient(ISGradient<CD_2NDT>::result(grid, ijk))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType inv2dx =)",
    "insertText": "ValueType(map.getInvTwiceScale()[0])"
  },
  {
    "label": "iGradient()",
    "kind": "Method",
    "detail": "Function (using ValueType = internal::ReturnValue<StencilT>::ValueType ; using Vec3Type = internal::ReturnValue<StencilT>::Vec3Type ; Vec3Type)",
    "insertText": "iGradient(ISGradient<CD_2NDT>::result(stencil))"
  },
  {
    "label": "getInvTwiceScale()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN const auto gradient0 = iGradient [ 0 ]* map .)",
    "insertText": "getInvTwiceScale()"
  },
  {
    "label": "Vec3Type()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_TYPE_CONVERSION_WARNING_END return)",
    "insertText": "Vec3Type(ValueType(gradient0), ValueType(gradient1), ValueType(gradient2))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> internal::ReturnValue<StencilT>::Vec3Type)",
    "insertText": "result(const ScaleMap& map, const StencilT& stencil)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct Gradient<ScaleTranslateMap,CD_2ND> { template<Accessor> internal::ReturnValue<Accessor>::Vec3Type)",
    "insertText": "result(const ScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> internal::ReturnValue<StencilT>::Vec3Type)",
    "insertText": "result(const ScaleTranslateMap& map, const StencilT& stencil)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; template<MapType,BiasedGradientScheme GradScheme> struct GradientBiased { template<Accessor> math::Vec3<Accessor::ValueType>)",
    "insertText": "result(const MapType& map, const Accessor& grid, const Coord& ijk, const Vec3<typename Accessor::ValueType>& V)"
  },
  {
    "label": "iGradient()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; using Vec3Type = math::Vec3<ValueType> ; Vec3d)",
    "insertText": "iGradient(ISGradientBiased<GradScheme, Vec3Type>::result(grid, ijk, V))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> math::Vec3<StencilT::ValueType>)",
    "insertText": "result(const MapType& map, const StencilT& stencil, const Vec3<typename StencilT::ValueType>& V)"
  },
  {
    "label": "iGradient()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; using Vec3Type = math::Vec3<ValueType> ; Vec3d)",
    "insertText": "iGradient(ISGradientBiased<GradScheme, Vec3Type>::result(stencil, V))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; template<MapType,BiasedGradientScheme GradScheme> struct GradientNormSqrd { const DScheme FD = BIAS_SCHEME<GradScheme>::FD ; const DScheme BD = BIAS_SCHEME<GradScheme>::BD ; template<Accessor> Accessor::ValueType)",
    "insertText": "result(const MapType& map, const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; using Vec3Type = math::Vec3<ValueType> ; Vec3Type up = Gradient<MapType,FD)",
    "insertText": "result(map, grid, ijk)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; using Vec3Type = math::Vec3<ValueType> ; Vec3Type up = Gradient<MapType,FD)",
    "insertText": "result(map, stencil)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; ValueType invdxdx =)",
    "insertText": "ValueType(map.getInvScaleSqr()[0])"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> StencilT::ValueType)",
    "insertText": "result(const UniformScaleMap& map, const StencilT& stencil)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; template<BiasedGradientScheme GradScheme> struct GradientNormSqrd<UniformScaleTranslateMap,GradScheme> { template<Accessor> Accessor::ValueType)",
    "insertText": "result(const UniformScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> StencilT::ValueType)",
    "insertText": "result(const UniformScaleTranslateMap& map, const StencilT& stencil)"
  },
  {
    "label": "div()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType::value_type ; ValueType)",
    "insertText": "div(0)"
  },
  {
    "label": "vec()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "vec(D1Vec<DiffScheme>::inX(grid, ijk, i), D1Vec<DiffScheme>::inY(grid, ijk, i), D1Vec<DiffScheme>::inZ(grid, ijk, i))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (div + =)",
    "insertText": "ValueType(map.applyIJT(vec, ijk.asVec3d())[i])"
  },
  {
    "label": "vec()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "vec(D1Vec<DiffScheme>::inX(stencil, i), D1Vec<DiffScheme>::inY(stencil, i), D1Vec<DiffScheme>::inZ(stencil, i))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (div + =)",
    "insertText": "ValueType(map.applyIJT(vec, stencil.getCenterCoord().asVec3d())[i])"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType invdx =)",
    "insertText": "ValueType(map.getInvScale()[0])"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType::value_type ; ValueType div =)",
    "insertText": "ValueType(D1Vec<DiffScheme>::inX(grid, ijk, 0) * (map.getInvScale()[0]) + D1Vec<DiffScheme>::inY(grid, ijk, 1) * (map.getInvScale()[1]) + D1Vec<DiffScheme>::inZ(grid, ijk, 2) * (map.getInvScale()[2]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (div =)",
    "insertText": "ValueType(D1Vec<DiffScheme>::inX(stencil, 0) * (map.getInvScale()[0]) + D1Vec<DiffScheme>::inY(stencil, 1) * (map.getInvScale()[1]) + D1Vec<DiffScheme>::inZ(stencil, 2) * (map.getInvScale()[2]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType::value_type ; ValueType div =)",
    "insertText": "ValueType(D1Vec<CD_2NDT>::inX(grid, ijk, 0) * (map.getInvTwiceScale()[0]) + D1Vec<CD_2NDT>::inY(grid, ijk, 1) * (map.getInvTwiceScale()[1]) + D1Vec<CD_2NDT>::inZ(grid, ijk, 2) * (map.getInvTwiceScale()[2]))"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType::value_type ; ValueType div =)",
    "insertText": "ValueType(D1Vec<CD_2NDT>::inX(stencil, 0) * (map.getInvTwiceScale()[0]) + D1Vec<CD_2NDT>::inY(stencil, 1) * (map.getInvTwiceScale()[1]) + D1Vec<CD_2NDT>::inZ(stencil, 2) * (map.getInvTwiceScale()[2]))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (using Vec3Type = Accessor::ValueType ; Vec3Type mat [ 3 ] ;)",
    "insertText": "for(int i = 0; i < 3; i++)"
  },
  {
    "label": "Vec3Type()",
    "kind": "Method",
    "detail": "Function (mat [ i ] =)",
    "insertText": "Vec3Type(map.applyIJT(vec, ijk.asVec3d()))"
  },
  {
    "label": "Vec3Type()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "Vec3Type(mat[2][1] - mat[1][2], mat[0][2] - mat[2][0], mat[1][0] - mat[0][1])"
  },
  {
    "label": "Vec3Type()",
    "kind": "Method",
    "detail": "Function (mat [ i ] =)",
    "insertText": "Vec3Type(map.applyIJT(vec, stencil.getCenterCoord().asVec3d()))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using Vec3Type = Accessor::ValueType ; using ValueType = Vec3Type::value_type ; return ISCurl<DiffScheme)",
    "insertText": "result(grid, ijk) * ValueType(map.getInvScale()[0])"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using Vec3Type = StencilT::ValueType ; using ValueType = Vec3Type::value_type ; return ISCurl<DiffScheme)",
    "insertText": "result(stencil) * ValueType(map.getInvScale()[0])"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using Vec3Type = Accessor::ValueType ; using ValueType = Vec3Type::value_type ; return ISCurl<CD_2NDT)",
    "insertText": "result(grid, ijk) * ValueType(map.getInvTwiceScale()[0])"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using Vec3Type = StencilT::ValueType ; using ValueType = Vec3Type::value_type ; return ISCurl<CD_2NDT)",
    "insertText": "result(stencil) * ValueType(map.getInvTwiceScale()[0])"
  },
  {
    "label": "d2_is()",
    "kind": "Method",
    "detail": "Function (Mat3d)",
    "insertText": "d2_is(iddx, iddxy, iddxz, iddxy, iddy, iddyz, iddxz, iddyz, iddz)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Mat3d d2_rs ;)",
    "insertText": "if(is_linear<MapType>::value)"
  },
  {
    "label": "applyIJC()",
    "kind": "Method",
    "detail": "Function (d2_rs = map .)",
    "insertText": "applyIJC(d2_is)"
  },
  {
    "label": "d1_is()",
    "kind": "Method",
    "detail": "Function (} else { Vec3d)",
    "insertText": "d1_is(static_cast<double>(D1<CD_2ND>::inX(grid, ijk)), static_cast<double>(D1<CD_2ND>::inY(grid, ijk)), static_cast<double>(D1<CD_2ND>::inZ(grid, ijk)))"
  },
  {
    "label": "applyIJC()",
    "kind": "Method",
    "detail": "Function (d2_rs = map .)",
    "insertText": "applyIJC(d2_is, d1_is, ijk.asVec3d())"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "ValueType(d2_rs(0,0) + d2_rs(1,1) + d2_rs(2,2))"
  },
  {
    "label": "d1_is()",
    "kind": "Method",
    "detail": "Function (} else { Vec3d)",
    "insertText": "d1_is(D1<CD_2ND>::inX(stencil), D1<CD_2ND>::inY(stencil), D1<CD_2ND>::inZ(stencil))"
  },
  {
    "label": "applyIJC()",
    "kind": "Method",
    "detail": "Function (d2_rs = map .)",
    "insertText": "applyIJC(d2_is, d1_is, stencil.getCenterCoord().asVec3d())"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; template<DDScheme DiffScheme> struct Laplacian<UnitaryMap,DiffScheme> { template<Accessor> Accessor::ValueType)",
    "insertText": "result(const UnitaryMap&, const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> StencilT::ValueType)",
    "insertText": "result(const UnitaryMap&, const StencilT& stencil)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} } ; template<DDScheme DiffScheme> struct Laplacian<ScaleMap,DiffScheme> { template<Accessor> Accessor::ValueType)",
    "insertText": "result(const ScaleMap& map, const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "getInvScaleSqr()",
    "kind": "Method",
    "detail": "Function (const Vec3d& invScaleSqr = map .)",
    "insertText": "getInvScaleSqr()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; using Vec3Type = Vec3<ValueType> ; ValueType d = grid .)",
    "insertText": "getValue(ijk)"
  },
  {
    "label": "vectorFromSurface()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "vectorFromSurface(d*Gradient<MapType,DiffScheme>::result(map, grid, ijk))"
  },
  {
    "label": "asVec3d()",
    "kind": "Method",
    "detail": "Function (Vec3d result = ijk .)",
    "insertText": "asVec3d() - map.applyInverseMap(vectorFromSurface)"
  },
  {
    "label": "applyMap()",
    "kind": "Method",
    "detail": "Function (} else { Vec3d location = map .)",
    "insertText": "applyMap(ijk.asVec3d())"
  },
  {
    "label": "applyInverseMap()",
    "kind": "Method",
    "detail": "Function (Vec3d result = map .)",
    "insertText": "applyInverseMap(location - vectorFromSurface)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; using Vec3Type = Vec3<ValueType> ; ValueType d = stencil . template)",
    "insertText": "getValue()"
  },
  {
    "label": "vectorFromSurface()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "vectorFromSurface(d*Gradient<MapType, DiffScheme>::result(map, stencil))"
  },
  {
    "label": "getCenterCoord()",
    "kind": "Method",
    "detail": "Function (Vec3d result = stencil .)",
    "insertText": "getCenterCoord().asVec3d() - map.applyInverseMap(vectorFromSurface)"
  },
  {
    "label": "applyMap()",
    "kind": "Method",
    "detail": "Function (} else { Vec3d location = map .)",
    "insertText": "applyMap(stencil.getCenterCoord().asVec3d())"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (} } ; template<MapType,DDScheme DiffScheme2,DScheme DiffScheme1> struct MeanCurvature { template<Accessor> bool)",
    "insertText": "compute(const MapType& map, const Accessor& grid, const Coord& ijk, double& alpha, double& beta)"
  },
  {
    "label": "d1_is()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; Vec3d)",
    "insertText": "d1_is(static_cast<double>(D1<DiffScheme1>::inX(grid, ijk)), static_cast<double>(D1<DiffScheme1>::inY(grid, ijk)), static_cast<double>(D1<DiffScheme1>::inZ(grid, ijk)))"
  },
  {
    "label": "applyIJT()",
    "kind": "Method",
    "detail": "Function (d1_ws = map .)",
    "insertText": "applyIJT(d1_is)"
  },
  {
    "label": "applyIJT()",
    "kind": "Method",
    "detail": "Function (} else { d1_ws = map .)",
    "insertText": "applyIJT(d1_is, ijk.asVec3d())"
  },
  {
    "label": "d1_ws()",
    "kind": "Method",
    "detail": "Function (} const double Dx2 =)",
    "insertText": "d1_ws(0)*d1_ws(0)"
  },
  {
    "label": "d1_ws()",
    "kind": "Method",
    "detail": "Function (const double Dy2 =)",
    "insertText": "d1_ws(1)*d1_ws(1)"
  },
  {
    "label": "d1_ws()",
    "kind": "Method",
    "detail": "Function (const double Dz2 =)",
    "insertText": "d1_ws(2)*d1_ws(2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const double normGrad = Dx2 + Dy2 + Dz2 ;)",
    "insertText": "if(normGrad <= math::Tolerance<double>::value())"
  },
  {
    "label": "alpha()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "alpha(Dx2*(d2_ws(1,1)+d2_ws(2,2))+Dy2*(d2_ws(0,0)+d2_ws(2,2)) +Dz2*(d2_ws(0,0)+d2_ws(1,1)) -2*(d1_ws(0)*(d1_ws(1)*d2_ws(0,1)+d1_ws(2)*d2_ws(0,2)) +d1_ws(1)*d1_ws(2)*d2_ws(1,2)))"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (beta =)",
    "insertText": "sqrt(normGrad)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; double alpha,beta ; return)",
    "insertText": "compute(map, grid, ijk, alpha, beta) ? ValueType(alpha/(2. *math::Pow3(beta)))"
  },
  {
    "label": "normGrad()",
    "kind": "Method",
    "detail": "Function (} template<Accessor> Accessor::ValueType)",
    "insertText": "normGrad(const MapType& map, const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; double alpha,beta ; return)",
    "insertText": "compute(map, grid, ijk, alpha, beta) ? ValueType(alpha/(2. *math::Pow2(beta)))"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> bool)",
    "insertText": "compute(const MapType& map, const StencilT& stencil, double& alpha, double& beta)"
  },
  {
    "label": "d1_is()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; Vec3d)",
    "insertText": "d1_is(D1<DiffScheme1>::inX(stencil), D1<DiffScheme1>::inY(stencil), D1<DiffScheme1>::inZ(stencil))"
  },
  {
    "label": "applyIJT()",
    "kind": "Method",
    "detail": "Function (} else { d1_ws = map .)",
    "insertText": "applyIJT(d1_is, stencil.getCenterCoord().asVec3d())"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; double alpha,beta ; return)",
    "insertText": "compute(map, stencil, alpha, beta) ? ValueType(alpha/(2*math::Pow3(beta)))"
  },
  {
    "label": "normGrad()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> StencilT::ValueType)",
    "insertText": "normGrad(const MapType& map, const StencilT stencil)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; double alpha,beta ; return)",
    "insertText": "compute(map, stencil, alpha, beta) ? ValueType(alpha/(2*math::Pow2(beta)))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; ValueType alpha,beta ; return ISMeanCurvature<DiffScheme2,DiffScheme1)",
    "insertText": "result(grid, ijk, alpha, beta) ? ValueType(alpha /(2*math::Pow3(beta)))"
  },
  {
    "label": "normGrad()",
    "kind": "Method",
    "detail": "Function (} template<Accessor> Accessor::ValueType)",
    "insertText": "normGrad(const TranslationMap&, const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; ValueType alpha,beta ; return ISMeanCurvature<DiffScheme2,DiffScheme1)",
    "insertText": "result(grid, ijk, alpha, beta) ? ValueType(alpha/(2*math::Pow2(beta)))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; ValueType alpha,beta ; return ISMeanCurvature<DiffScheme2,DiffScheme1)",
    "insertText": "result(stencil, alpha, beta) ? ValueType(alpha /(2*math::Pow3(beta)))"
  },
  {
    "label": "normGrad()",
    "kind": "Method",
    "detail": "Function (} template<StencilT> StencilT::ValueType)",
    "insertText": "normGrad(const TranslationMap&, const StencilT& stencil)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; ValueType alpha,beta ; return ISMeanCurvature<DiffScheme2,DiffScheme1)",
    "insertText": "result(stencil, alpha, beta) ? ValueType(alpha/(2*math::Pow2(beta)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; ValueType alpha,beta ;)",
    "insertText": "if(ISMeanCurvature<DiffScheme2, DiffScheme1>::result(grid, ijk, alpha, beta))"
  },
  {
    "label": "normGrad()",
    "kind": "Method",
    "detail": "Function (} return 0 ; } template<Accessor> Accessor::ValueType)",
    "insertText": "normGrad(const UniformScaleMap& map, const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using ValueType = StencilT::ValueType ; ValueType alpha,beta ;)",
    "insertText": "if(ISMeanCurvature<DiffScheme2, DiffScheme1>::result(stencil, alpha, beta))"
  },
  {
    "label": "normGrad()",
    "kind": "Method",
    "detail": "Function (} return 0 ; } template<StencilT> StencilT::ValueType)",
    "insertText": "normGrad(const UniformScaleMap& map, const StencilT& stencil)"
  },
  {
    "label": "normGrad()",
    "kind": "Method",
    "detail": "Function (} return 0 ; } template<Accessor> Accessor::ValueType)",
    "insertText": "normGrad(const UniformScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "normGrad()",
    "kind": "Method",
    "detail": "Function (} return 0 ; } template<StencilT> StencilT::ValueType)",
    "insertText": "normGrad(const UniformScaleTranslateMap& map, const StencilT& stencil)"
  },
  {
    "label": "GenericMap()",
    "kind": "Method",
    "detail": "Function (} return 0 ; } } ; class GenericMap { public : template<GridType>)",
    "insertText": "GenericMap(const GridType& g): mMap(g.transform().baseMap())"
  },
  {
    "label": "GenericMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "GenericMap(const Transform& t): mMap(t.baseMap())"
  },
  {
    "label": "GenericMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "GenericMap(MapBase::Ptr map): mMap(ConstPtrCast<const MapBase>(map))"
  },
  {
    "label": "GenericMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "GenericMap(MapBase::ConstPtr map): mMap(map)"
  },
  {
    "label": "GenericMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "GenericMap()"
  },
  {
    "label": "applyMap()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "applyMap(const Vec3d& in)"
  },
  {
    "label": "applyInverseMap()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "applyInverseMap(const Vec3d& in)"
  },
  {
    "label": "applyIJT()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "applyIJT(const Vec3d& in)"
  },
  {
    "label": "applyIJT()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "applyIJT(const Vec3d& in, const Vec3d& pos)"
  },
  {
    "label": "applyIJC()",
    "kind": "Method",
    "detail": "Function (} Mat3d)",
    "insertText": "applyIJC(const Mat3d& m)"
  },
  {
    "label": "applyIJC()",
    "kind": "Method",
    "detail": "Function (} Mat3d)",
    "insertText": "applyIJC(const Mat3d& m, const Vec3d& v, const Vec3d& pos)"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "determinant()"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "determinant(const Vec3d& in)"
  },
  {
    "label": "voxelSize()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "voxelSize()"
  },
  {
    "label": "voxelSize()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "voxelSize(const Vec3d&v)"
  }
]