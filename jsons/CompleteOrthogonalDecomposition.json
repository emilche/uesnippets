[
  {
    "label": "traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "traits"
  },
  {
    "label": "CompleteOrthogonalDecomposition",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CompleteOrthogonalDecomposition"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "internal"
  },
  {
    "label": "Assignment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Assignment"
  },
  {
    "label": "EIGEN_GENERIC_PUBLIC_INTERFACE()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_COMPLETEORTHOGONALDECOMPOSITION_H # define EIGEN_COMPLETEORTHOGONALDECOMPOSITION_H namespace Eigen { namespace internal { template<_MatrixType> struct traits<CompleteOrthogonalDecomposition<_MatrixType>> : traits<_MatrixType> { typedef MatrixXpr XprKind ; typedef SolverStorage StorageKind ; typedef int StorageIndex ; enum { Flags = 0 } ; } ; } template<_MatrixType> class CompleteOrthogonalDecomposition : public SolverBase<CompleteOrthogonalDecomposition<_MatrixType>> { public : typedef _MatrixType MatrixType ; typedef SolverBase<CompleteOrthogonalDecomposition> Base ; template<Derived> struct internal::solve_assertion ;)",
    "insertText": "EIGEN_GENERIC_PUBLIC_INTERFACE(CompleteOrthogonalDecomposition)"
  },
  {
    "label": "CompleteOrthogonalDecomposition()",
    "kind": "Method",
    "detail": "Function (MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime } ; typedef internal::plain_diag_type<MatrixType>::type HCoeffsType ; typedef PermutationMatrix<ColsAtCompileTime,MaxColsAtCompileTime> PermutationType ; typedef internal::plain_row_type<MatrixType,Index>::type IntRowVectorType ; typedef internal::plain_row_type<MatrixType>::type RowVectorType ; typedef internal::plain_row_type<MatrixType,RealScalar>::type RealRowVectorType ; typedef HouseholderSequence<MatrixType,internal::remove_all<HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType ; typedef MatrixType::PlainObject PlainObject ; private : typedef PermutationType::Index PermIndexType ; public :)",
    "insertText": "CompleteOrthogonalDecomposition() : m_cpqr(), m_zCoeffs(), m_temp()"
  },
  {
    "label": "CompleteOrthogonalDecomposition()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CompleteOrthogonalDecomposition(Index rows, Index cols) : m_cpqr(rows, cols), m_zCoeffs((std::min)(rows, cols)), m_temp(cols)"
  },
  {
    "label": "CompleteOrthogonalDecomposition()",
    "kind": "Method",
    "detail": "Function (} template<InputType>)",
    "insertText": "CompleteOrthogonalDecomposition(const EigenBase<InputType>& matrix) : m_cpqr(matrix.rows(), matrix.cols()), m_zCoeffs((std::min)(matrix.rows(), matrix.cols())), m_temp(matrix.cols())"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(matrix.derived())"
  },
  {
    "label": "CompleteOrthogonalDecomposition()",
    "kind": "Method",
    "detail": "Function (} template<InputType>)",
    "insertText": "CompleteOrthogonalDecomposition(EigenBase<InputType>& matrix) : m_cpqr(matrix.derived()), m_zCoeffs((std::min)(matrix.rows(), matrix.cols())), m_temp(matrix.cols())"
  },
  {
    "label": "computeInPlace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeInPlace()"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (} # ifdef EIGEN_PARSED_BY_DOXYGEN template<Rhs> const Solve<CompleteOrthogonalDecomposition,Rhs>)",
    "insertText": "solve(const MatrixBase<Rhs>& b)"
  },
  {
    "label": "householderQ()",
    "kind": "Method",
    "detail": "Function (# endif HouseholderSequenceType)",
    "insertText": "householderQ(void)"
  },
  {
    "label": "matrixQ()",
    "kind": "Method",
    "detail": "Function (HouseholderSequenceType)",
    "insertText": "matrixQ(void)"
  },
  {
    "label": "matrixZ()",
    "kind": "Method",
    "detail": "Function (} MatrixType)",
    "insertText": "matrixZ()"
  },
  {
    "label": "Identity()",
    "kind": "Method",
    "detail": "Function (MatrixType Z =)",
    "insertText": "Identity(m_cpqr.cols(), m_cpqr.cols())"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (applyZOnTheLeftInPlace<)",
    "insertText": "false(Z)"
  },
  {
    "label": "matrixT()",
    "kind": "Method",
    "detail": "Function (} const MatrixType&)",
    "insertText": "matrixT()"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (} template<InputType> CompleteOrthogonalDecomposition&)",
    "insertText": "compute(const EigenBase<InputType>& matrix)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (m_cpqr .)",
    "insertText": "compute(matrix)"
  },
  {
    "label": "absDeterminant()",
    "kind": "Method",
    "detail": "Function (} MatrixType::RealScalar)",
    "insertText": "absDeterminant()"
  },
  {
    "label": "logAbsDeterminant()",
    "kind": "Method",
    "detail": "Function (MatrixType::RealScalar)",
    "insertText": "logAbsDeterminant()"
  },
  {
    "label": "rank()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "rank()"
  },
  {
    "label": "dimensionOfKernel()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "dimensionOfKernel()"
  },
  {
    "label": "isInjective()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isInjective()"
  },
  {
    "label": "isSurjective()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isSurjective()"
  },
  {
    "label": "isInvertible()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isInvertible()"
  },
  {
    "label": "pseudoInverse()",
    "kind": "Method",
    "detail": "Function (} const Inverse<CompleteOrthogonalDecomposition>)",
    "insertText": "pseudoInverse()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_cpqr.m_isInitialized && \"CompleteOrthogonalDecomposition is not initialized.\")"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "cols()"
  },
  {
    "label": "hCoeffs()",
    "kind": "Method",
    "detail": "Function (} const HCoeffsType&)",
    "insertText": "hCoeffs()"
  },
  {
    "label": "zCoeffs()",
    "kind": "Method",
    "detail": "Function (} const HCoeffsType&)",
    "insertText": "zCoeffs()"
  },
  {
    "label": "setThreshold()",
    "kind": "Method",
    "detail": "Function (m_cpqr .)",
    "insertText": "setThreshold(threshold)"
  },
  {
    "label": "setThreshold()",
    "kind": "Method",
    "detail": "Function (m_cpqr .)",
    "insertText": "setThreshold(Default)"
  },
  {
    "label": "nonzeroPivots()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "nonzeroPivots()"
  },
  {
    "label": "maxPivot()",
    "kind": "Method",
    "detail": "Function (} RealScalar)",
    "insertText": "maxPivot()"
  },
  {
    "label": "info()",
    "kind": "Method",
    "detail": "Function (} ComputationInfo)",
    "insertText": "info()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_cpqr.m_isInitialized && \"Decomposition is not initialized.\")"
  },
  {
    "label": "_solve_impl_transposed()",
    "kind": "Method",
    "detail": "Function (template<bool Conjugate,RhsType,DstType> void)",
    "insertText": "_solve_impl_transposed(const RhsType &rhs, DstType &dst)"
  },
  {
    "label": "check_template_parameters()",
    "kind": "Method",
    "detail": "Function (# endif protected : void)",
    "insertText": "check_template_parameters()"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_NON_INTEGER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)"
  },
  {
    "label": "_check_solve_assertion()",
    "kind": "Method",
    "detail": "Function (} template<bool Transpose_,Rhs> void)",
    "insertText": "_check_solve_assertion(const Rhs& b)"
  },
  {
    "label": "EIGEN_ONLY_USED_FOR_DEBUG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ONLY_USED_FOR_DEBUG(b)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert((Transpose_?derived().cols():derived().rows())==b.rows() && \"CompleteOrthogonalDecomposition::solve(): invalid number of rows of the right hand side matrix b\")"
  },
  {
    "label": "applyZOnTheLeftInPlace()",
    "kind": "Method",
    "detail": "Function (template<bool Conjugate,Rhs> void)",
    "insertText": "applyZOnTheLeftInPlace(Rhs& rhs)"
  },
  {
    "label": "applyZAdjointOnTheLeftInPlace()",
    "kind": "Method",
    "detail": "Function (template<Rhs> void)",
    "insertText": "applyZAdjointOnTheLeftInPlace(Rhs& rhs)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_cpqr.cols() <= NumTraits<int>::highest())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_zCoeffs .)",
    "insertText": "resize((std::min)(rows, cols))"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_temp .)",
    "insertText": "resize(cols)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (m_cpqr . m_qr .)",
    "insertText": "col(k).head(k + 1).swap( m_cpqr.m_qr.col(rank - 1).head(k + 1))"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (} RealScalar beta ; m_cpqr . m_qr .)",
    "insertText": "row(k) .tail(cols - rank + 1) .makeHouseholderInPlace(m_zCoeffs(k), beta)"
  },
  {
    "label": "m_qr()",
    "kind": "Method",
    "detail": "Function (m_cpqr .)",
    "insertText": "m_qr(k, rank - 1)"
  },
  {
    "label": "topRightCorner()",
    "kind": "Method",
    "detail": "Function (m_cpqr . m_qr .)",
    "insertText": "topRightCorner(k, cols - rank + 1) .applyHouseholderOnTheRight( m_cpqr.m_qr.row(k).tail(cols - rank).adjoint(), m_zCoeffs(k), &m_temp(0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(k != rank - 1)"
  },
  {
    "label": "temp()",
    "kind": "Method",
    "detail": "Function (Matrix<Rhs::Scalar,Dynamic,1>)",
    "insertText": "temp((std::max)(cols, nrhs))"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (rhs .)",
    "insertText": "row(k).swap(rhs.row(rank - 1))"
  },
  {
    "label": "middleRows()",
    "kind": "Method",
    "detail": "Function (} rhs .)",
    "insertText": "middleRows(rank - 1, cols - rank + 1) .applyHouseholderOnTheLeft( matrixQTZ().row(k).tail(cols - rank).transpose().template conjugateIf<!Conjugate>(), zCoeffs().template conjugateIf<Conjugate>()(k), &temp(0))"
  },
  {
    "label": "middleRows()",
    "kind": "Method",
    "detail": "Function (} rhs .)",
    "insertText": "middleRows(rank - 1, cols - rank + 1) .applyHouseholderOnTheLeft( matrixQTZ().row(k).tail(cols - rank).adjoint(), zCoeffs()(k), &temp(0))"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (} } } # ifndef EIGEN_PARSED_BY_DOXYGEN template<_MatrixType> template<RhsType,DstType> void CompleteOrthogonalDecomposition<_MatrixType)",
    "insertText": "_solve_impl(const RhsType& rhs, DstType& dst)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "setZero()"
  },
  {
    "label": "applyOnTheLeft()",
    "kind": "Method",
    "detail": "Function (c .)",
    "insertText": "applyOnTheLeft(matrixQ().setLength(rank).adjoint())"
  },
  {
    "label": "topRows()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "topRows(rank) = matrixT() .topLeftCorner(rank, rank) .template triangularView<Upper>() .solve(c.topRows(rank))"
  },
  {
    "label": "bottomRows()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "bottomRows(cols - rank).setZero()"
  },
  {
    "label": "applyZAdjointOnTheLeftInPlace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applyZAdjointOnTheLeftInPlace(dst)"
  },
  {
    "label": "colsPermutation()",
    "kind": "Method",
    "detail": "Function (} dst =)",
    "insertText": "colsPermutation()"
  },
  {
    "label": "Conjugate()",
    "kind": "Method",
    "detail": "Function (applyZOnTheLeftInPlace<!)",
    "insertText": "Conjugate(c)"
  },
  {
    "label": "matrixT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "matrixT().topLeftCorner(rank, rank) .template triangularView<Upper>() .transpose().template conjugateIf<Conjugate>() .solveInPlace(c.topRows(rank))"
  },
  {
    "label": "topRows()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "topRows(rank) = c.topRows(rank)"
  },
  {
    "label": "bottomRows()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "bottomRows(rows()-rank).setZero()"
  },
  {
    "label": "applyOnTheLeft()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "applyOnTheLeft(householderQ().setLength(rank).template conjugateIf<!Conjugate>())"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} # endif namespace internal { template<MatrixType> struct traits<Inverse<CompleteOrthogonalDecomposition<MatrixType>>> : traits<Transpose<MatrixType::PlainObject>::PlainObject> { enum { Flags = 0 } ; } ; template<DstXprType,MatrixType> struct Assignment<DstXprType,Inverse<CompleteOrthogonalDecomposition<MatrixType>>,internal::assign_op<DstXprType::Scalar,CompleteOrthogonalDecomposition<MatrixType>::Scalar>,Dense2Dense> { typedef CompleteOrthogonalDecomposition<MatrixType> CodType ; typedef Inverse<CodType> SrcXprType ; void)",
    "insertText": "run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename CodType::Scalar> &)"
  },
  {
    "label": "nestedExpression()",
    "kind": "Method",
    "detail": "Function (typedef Matrix<CodType::Scalar,CodType::RowsAtCompileTime,CodType::RowsAtCompileTime,0,CodType::MaxRowsAtCompileTime,CodType::MaxRowsAtCompileTime> IdentityMatrixType ; dst = src .)",
    "insertText": "nestedExpression().solve(IdentityMatrixType::Identity(src.cols(), src.cols()))"
  },
  {
    "label": "householderQ()",
    "kind": "Method",
    "detail": "Function (} } ; } template<MatrixType> CompleteOrthogonalDecomposition<MatrixType>::HouseholderSequenceType CompleteOrthogonalDecomposition<MatrixType)",
    "insertText": "householderQ()"
  },
  {
    "label": "completeOrthogonalDecomposition()",
    "kind": "Method",
    "detail": "Function (} template<Derived> const CompleteOrthogonalDecomposition<MatrixBase<Derived>::PlainObject> MatrixBase<Derived)",
    "insertText": "completeOrthogonalDecomposition()"
  }
]