[
  {
    "label": "alignas",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "alignas"
  },
  {
    "label": "SeedSequence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SeedSequence"
  },
  {
    "label": "CharT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CharT"
  },
  {
    "label": "Traits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Traits"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_RANDOM_INTERNAL_RANDEN_ENGINE_H_ # define ABSL_RANDOM_INTERNAL_RANDEN_ENGINE_H_ # include<algorithm> # include<cinttypes> # include<cstdlib> # include<iostream> # include<iterator> # include<limits> # include<type_traits> # include \" absl / base / internal / endian . h \" # include \" absl / meta / type_traits . h \" # include \" absl / random / internal / iostream_state_saver . h \" # include \" absl / random / internal / randen . h \" namespace absl { ABSL_NAMESPACE_BEGIN namespace random_internal { template<T> class)",
    "insertText": "alignas(8)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (public : using result_type = T ;)",
    "insertText": "static_assert(std::is_unsigned<result_type>::value, \"randen_engine template argument must be a built-in unsigned \" \"integer type\")"
  },
  {
    "label": "result_type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "result_type(min)()"
  },
  {
    "label": "result_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "result_type(max)()"
  },
  {
    "label": "randen_engine()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "randen_engine() : randen_engine(0)"
  },
  {
    "label": "randen_engine()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "randen_engine(result_type seed_value)"
  },
  {
    "label": "seed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "seed(seed_value)"
  },
  {
    "label": "randen_engine()",
    "kind": "Method",
    "detail": "Function (} template<class SeedSequence,= absl::enable_if_t<! std::is_same<SeedSequence,randen_engine>::value>>)",
    "insertText": "randen_engine(SeedSequence&& seq)"
  },
  {
    "label": "seed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "seed(seq)"
  },
  {
    "label": "randen_engine()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "randen_engine(const randen_engine& other) : next_(other.next_), impl_(other.impl_)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(state(), other.state(), kStateSizeT * sizeof(result_type))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} randen_engine&)",
    "insertText": "operator(const randen_engine& other)"
  },
  {
    "label": "state()",
    "kind": "Method",
    "detail": "Function (auto* begin =)",
    "insertText": "state()"
  },
  {
    "label": "Generate()",
    "kind": "Method",
    "detail": "Function (next_ = kCapacityT ; impl_ .)",
    "insertText": "Generate(begin)"
  },
  {
    "label": "ToHost()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "ToHost(begin[next_++])"
  },
  {
    "label": "seed()",
    "kind": "Method",
    "detail": "Function (} template<class SeedSequence> absl::enable_if_t<! std::is_convertible<SeedSequence,result_type>::value>)",
    "insertText": "seed(SeedSequence&& seq)"
  },
  {
    "label": "seed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "seed()"
  },
  {
    "label": "reseed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reseed(seq)"
  },
  {
    "label": "seed()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "seed(result_type seed_value = 0)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(begin, begin + kCapacityT, 0)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(begin + kCapacityT, begin + kStateSizeT, seed_value)"
  },
  {
    "label": "reseed()",
    "kind": "Method",
    "detail": "Function (} template<class SeedSequence> void)",
    "insertText": "reseed(SeedSequence& seq)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using sequence_result_type = SeedSequence::result_type ;)",
    "insertText": "static_assert(sizeof(sequence_result_type) == 4, \"SeedSequence::result_type must be 32-bit\")"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (size_t kBufferSize = Randen::kSeedBytes /)",
    "insertText": "sizeof(sequence_result_type)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alignas(16)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (const size_t entropy_size = seq .)",
    "insertText": "size()"
  },
  {
    "label": "requested_entropy()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "requested_entropy(entropy_size == 0)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(buffer + requested_entropy, buffer + kBufferSize, 0)"
  },
  {
    "label": "generate()",
    "kind": "Method",
    "detail": "Function (seq .)",
    "insertText": "generate(buffer, buffer + requested_entropy)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_IS_BIG_ENDIAN)",
    "insertText": "for(sequence_result_type& e : buffer)"
  },
  {
    "label": "FromHost()",
    "kind": "Method",
    "detail": "Function (e = absl::)",
    "insertText": "FromHost(e)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} # endif size_t dst = kBufferSize ;)",
    "insertText": "while(dst > 7)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (dst - = 4 ; size_t src = dst>> 1 ;)",
    "insertText": "swap(buffer[--dst], buffer[--src])"
  },
  {
    "label": "generate()",
    "kind": "Method",
    "detail": "Function (} } else { seq .)",
    "insertText": "generate(buffer, buffer + kBufferSize)"
  },
  {
    "label": "Absorb()",
    "kind": "Method",
    "detail": "Function (} impl_ .)",
    "insertText": "Absorb(buffer, state())"
  },
  {
    "label": "discard()",
    "kind": "Method",
    "detail": "Function (next_ = kStateSizeT ; } void)",
    "insertText": "discard(uint64_t count)"
  },
  {
    "label": "uint64_t()",
    "kind": "Method",
    "detail": "Function (uint64_t step = std::min<)",
    "insertText": "uint64_t(kStateSizeT - next_, count)"
  },
  {
    "label": "Generate()",
    "kind": "Method",
    "detail": "Function (next_ = kCapacityT ; impl_ .)",
    "insertText": "Generate(*reinterpret_cast<result_type(*)[kStateSizeT]>(begin))"
  },
  {
    "label": "uint64_t()",
    "kind": "Method",
    "detail": "Function (step = std::min<)",
    "insertText": "uint64_t(kRateT, count)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class CharT,class Traits> std::basic_ostream<CharT,Traits>&)",
    "insertText": "operator(std::basic_ostream<CharT, Traits>& os, const randen_engine<T>& engine)"
  },
  {
    "label": "make_ostream_state_saver()",
    "kind": "Method",
    "detail": "Function (using numeric_type = random_internal::stream_format_type<result_type>::type ; auto saver =)",
    "insertText": "make_ostream_state_saver(os)"
  },
  {
    "label": "numeric_type()",
    "kind": "Method",
    "detail": "Function (os<<static_cast<)",
    "insertText": "numeric_type(little_endian::FromHost(*it)) << os.fill()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} os<<engine . next_ ; return os ; } template<class CharT,class Traits> std::basic_istream<CharT,Traits>&)",
    "insertText": "operator(std::basic_istream<CharT, Traits>& is, randen_engine<T>& engine)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (using numeric_type = random_internal::stream_format_type<result_type>::type ; result_type state [ kStateSizeT ] ; size_t next ;)",
    "insertText": "for(auto& elem : state)"
  },
  {
    "label": "ToHost()",
    "kind": "Method",
    "detail": "Function (numeric_type value ; is>> value ; elem =)",
    "insertText": "ToHost(static_cast<result_type>(value))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} is>> next ;)",
    "insertText": "if(is.fail())"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (engine . next_ = next ; return is ; } private : size_t kStateSizeT = Randen::kStateBytes /)",
    "insertText": "sizeof(result_type)"
  }
]