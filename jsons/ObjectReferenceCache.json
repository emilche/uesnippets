[
  {
    "label": "FStringTokenStore",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStringTokenStore"
  },
  {
    "label": "FNetTokenStore",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNetTokenStore"
  },
  {
    "label": "FNetSerializationContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNetSerializationContext"
  },
  {
    "label": "FNetRefHandleManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNetRefHandleManager"
  },
  {
    "label": "FNetExportContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNetExportContext"
  },
  {
    "label": "FPendingBatches",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPendingBatches"
  },
  {
    "label": "FObjectReferenceCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FObjectReferenceCache"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FCachedNetObjectReference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCachedNetObjectReference"
  },
  {
    "label": "FQueuedBatchObjectReference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQueuedBatchObjectReference"
  },
  {
    "label": "FPendingAsyncLoadRequest",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPendingAsyncLoadRequest"
  },
  {
    "label": "FObjectReferenceCache()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Iris / Core / NetObjectReference . h \" # include \" Iris / ReplicationSystem / NetRefHandle . h \" # include \" Iris / ReplicationSystem / ReplicationSystemTypes . h \" # include \" UObject / WeakObjectPtr . h \" # include \" Containers / Map . h \" # include \" ObjectReferenceCacheFwd . h \" # include \" UObject / ObjectPtr . h \" namespace UE::Net { class FStringTokenStore ; class FNetTokenStore ; class FNetSerializationContext ; namespace Private { class FNetRefHandleManager ; class FNetExportContext ; struct FPendingBatches ; typedef uint32 FInternalNetRefIndex ; } } namespace UE::Net::Private { class FObjectReferenceCache { public :)",
    "insertText": "FObjectReferenceCache()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(UReplicationSystem* ReplicationSystem)"
  },
  {
    "label": "IsDynamicObject()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsDynamicObject(const UObject* Object)"
  },
  {
    "label": "IsAuthority()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAuthority()"
  },
  {
    "label": "CreateObjectReferenceHandle()",
    "kind": "Method",
    "detail": "Function (FNetRefHandle)",
    "insertText": "CreateObjectReferenceHandle(const UObject* Object)"
  },
  {
    "label": "GetObjectReferenceHandleFromObject()",
    "kind": "Method",
    "detail": "Function (FNetRefHandle)",
    "insertText": "GetObjectReferenceHandleFromObject(const UObject* Object, EGetRefHandleFlags GetRefHandleFlags = EGetRefHandleFlags::None)"
  },
  {
    "label": "GetObjectFromReferenceHandle()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "GetObjectFromReferenceHandle(FNetRefHandle RefHandle)"
  },
  {
    "label": "ResolveObjectReferenceHandle()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "ResolveObjectReferenceHandle(FNetRefHandle RefHandle, const FNetObjectResolveContext& ResolveContext)"
  },
  {
    "label": "ResolveObjectReference()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "ResolveObjectReference(const FNetObjectReference& ObjectRef, const FNetObjectResolveContext& ResolveContext)"
  },
  {
    "label": "ResolveObjectReference()",
    "kind": "Method",
    "detail": "Function (ENetObjectReferenceResolveResult)",
    "insertText": "ResolveObjectReference(const FNetObjectReference& ObjectRef, const FNetObjectResolveContext& ResolveContext, UObject*& OutResolvedObject)"
  },
  {
    "label": "IsNetRefHandleBroken()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsNetRefHandleBroken(FNetRefHandle Handle, bool bMustBeRegistered)"
  },
  {
    "label": "IsNetRefHandlePending()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsNetRefHandlePending(FNetRefHandle NetRefHandle, const FPendingBatches& PendingBatches)"
  },
  {
    "label": "GetReplicatedOuter()",
    "kind": "Method",
    "detail": "Function (FNetObjectReference)",
    "insertText": "GetReplicatedOuter(const FNetObjectReference& Reference)"
  },
  {
    "label": "GetOrCreateObjectReference()",
    "kind": "Method",
    "detail": "Function (FNetObjectReference)",
    "insertText": "GetOrCreateObjectReference(const UObject* Instance)"
  },
  {
    "label": "GetOrCreateObjectReference()",
    "kind": "Method",
    "detail": "Function (FNetObjectReference)",
    "insertText": "GetOrCreateObjectReference(const FString& ObjectPath, const UObject* Outer)"
  },
  {
    "label": "AddRemoteReference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRemoteReference(FNetRefHandle RefHandle, const UObject* Object)"
  },
  {
    "label": "RemoveReference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveReference(FNetRefHandle RefHandle, const UObject* Object)"
  },
  {
    "label": "WriteFullReference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteFullReference(FNetSerializationContext& Context, FNetObjectReference Ref)"
  },
  {
    "label": "ReadFullReference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReadFullReference(FNetSerializationContext& Context, FNetObjectReference& OutRef)"
  },
  {
    "label": "WriteReference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteReference(FNetSerializationContext& Context, FNetObjectReference Ref)"
  },
  {
    "label": "ReadReference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReadReference(FNetSerializationContext& Context, FNetObjectReference& OutRef)"
  },
  {
    "label": "AddPendingExports()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddPendingExports(FNetSerializationContext& Context, TArrayView<const FNetObjectReference> ExportsView)"
  },
  {
    "label": "AddPendingExport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddPendingExport(FNetExportContext& ExportContext, const FNetObjectReference& Reference)"
  },
  {
    "label": "WritePendingExports()",
    "kind": "Method",
    "detail": "Function (enum class EWriteExportsResult : unsigned { WroteExports,BitStreamOverflow,NoExports,} ; EWriteExportsResult)",
    "insertText": "WritePendingExports(FNetSerializationContext& Context, FInternalNetRefIndex ObjectIndex)"
  },
  {
    "label": "ReadExports()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReadExports(FNetSerializationContext& Context, TArray<FNetRefHandle>* MustBeMappedExports)"
  },
  {
    "label": "MakeNetObjectReference()",
    "kind": "Method",
    "detail": "Function (FNetObjectReference)",
    "insertText": "MakeNetObjectReference(FNetRefHandle Handle)"
  },
  {
    "label": "SetAsyncLoadMode()",
    "kind": "Method",
    "detail": "Function (enum class EAsyncLoadMode : uint8 { UseCVar = 0,ForceDisable = 1,ForceEnable = 2,} ; void)",
    "insertText": "SetAsyncLoadMode(const EAsyncLoadMode NewMode)"
  },
  {
    "label": "ShouldAsyncLoad()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldAsyncLoad()"
  },
  {
    "label": "AsyncPackageCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AsyncPackageCallback(const FName& PackageName, UPackage* Package, EAsyncLoadingResult::Type Result)"
  },
  {
    "label": "AddReferencedObjects()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddReferencedObjects(FReferenceCollector& ReferenceCollector)"
  },
  {
    "label": "AddTrackedQueuedBatchObjectReference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTrackedQueuedBatchObjectReference(const FNetRefHandle InHandle, const UObject* InObject)"
  },
  {
    "label": "UpdateTrackedQueuedBatchObjectReference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateTrackedQueuedBatchObjectReference(const FNetRefHandle InHandle, const UObject* NewObject)"
  },
  {
    "label": "RemoveTrackedQueuedBatchObjectReference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveTrackedQueuedBatchObjectReference(const FNetRefHandle InHandle)"
  },
  {
    "label": "DescribeObjectReference()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "DescribeObjectReference(const FNetObjectReference Ref, const FNetObjectResolveContext& ResolveContext)"
  },
  {
    "label": "FPendingAsyncLoadRequest()",
    "kind": "Method",
    "detail": "Function (private : struct FCachedNetObjectReference { TWeakObjectPtr<UObject> Object ; const UObject* ObjectKey = nullptr ; FNetRefHandle NetRefHandle ; FNetToken RelativePath ; FNetRefHandle OuterNetRefHandle ; uint8 bNoLoad : 1 ; uint8 bIgnoreWhenMissing : 1 ; uint8 bIsPackage : 1 ; uint8 bIsBroken : 1 ; uint8 bIsPending : 1 ; } ; struct FQueuedBatchObjectReference { TObjectPtr<const UObject> Object = nullptr ; uint32 RefCount = 0 U ; } ; struct FPendingAsyncLoadRequest {)",
    "insertText": "FPendingAsyncLoadRequest(FNetRefHandle InNetRefHandle, double InRequestStartTime)"
  },
  {
    "label": "Merge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Merge(const FPendingAsyncLoadRequest& Other)"
  },
  {
    "label": "Merge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Merge(FNetRefHandle InNetRefHandle)"
  },
  {
    "label": "CreateObjectReferenceInternal()",
    "kind": "Method",
    "detail": "Function (TArray<FNetRefHandle,TInlineAllocator<4>> NetRefHandles ; double RequestStartTime ; } ; bool)",
    "insertText": "CreateObjectReferenceInternal(const UObject* Object, FNetObjectReference& OutReference)"
  },
  {
    "label": "ReadFullReferenceInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReadFullReferenceInternal(FNetSerializationContext& Context, FNetObjectReference& OutRef, uint32 RecursionCount)"
  },
  {
    "label": "WriteFullReferenceInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteFullReferenceInternal(FNetSerializationContext& Context, const FNetObjectReference& Ref)"
  },
  {
    "label": "ResolveObjectReferenceHandleInternal()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "ResolveObjectReferenceHandleInternal(FNetRefHandle RefHandle, const FNetObjectResolveContext& ResolveContext, bool& bOutMustBeMapped)"
  },
  {
    "label": "IsDynamicInternal()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsDynamicInternal(const UObject* Object)"
  },
  {
    "label": "SupportsObjectInternal()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SupportsObjectInternal(const UObject* Object)"
  },
  {
    "label": "CanClientLoadObjectInternal()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanClientLoadObjectInternal(const UObject* Object, bool bIsDynamic)"
  },
  {
    "label": "ShouldIgnoreWhenMissing()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldIgnoreWhenMissing(FNetRefHandle RefHandle)"
  },
  {
    "label": "RenamePathForPie()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RenamePathForPie(uint32 ConnectionId, FString& Str, bool bReading)"
  },
  {
    "label": "FullPath()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "FullPath(FNetRefHandle RefHandle, const FNetObjectResolveContext& ResolveContext)"
  },
  {
    "label": "GenerateFullPath_r()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GenerateFullPath_r(FNetRefHandle RefHandle, const FNetObjectResolveContext& ResolveContext, FString& OutFullPath)"
  },
  {
    "label": "GetDynamicRoot()",
    "kind": "Method",
    "detail": "Function (FNetRefHandle)",
    "insertText": "GetDynamicRoot(const FNetRefHandle Handle)"
  },
  {
    "label": "MakeNetObjectReference()",
    "kind": "Method",
    "detail": "Function (FNetObjectReference)",
    "insertText": "MakeNetObjectReference(FNetRefHandle RefHandle, FNetToken RelativePath)"
  },
  {
    "label": "MakeNetObjectReference()",
    "kind": "Method",
    "detail": "Function (FNetObjectReference)",
    "insertText": "MakeNetObjectReference(const FCachedNetObjectReference& CachedReference)"
  },
  {
    "label": "WriteMustBeMappedExports()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "WriteMustBeMappedExports(FNetSerializationContext& Context, FInternalNetRefIndex ObjectIndex, TArrayView<const FNetObjectReference> ExportsView)"
  },
  {
    "label": "ReadMustBeMappedExports()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReadMustBeMappedExports(FNetSerializationContext& Context, TArray<FNetRefHandle>* MustBeMappedExports)"
  },
  {
    "label": "StartAsyncLoadingPackage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartAsyncLoadingPackage(FCachedNetObjectReference& Object, FName PackagePath, const FNetRefHandle RefHandle, const bool bWasAlreadyAsyncLoading)"
  },
  {
    "label": "ValidateAsyncLoadingPackage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateAsyncLoadingPackage(FCachedNetObjectReference& Object, FName PackagePath, const FNetRefHandle RefHandle)"
  },
  {
    "label": "ResolveObjectReferenceHandleInternal()",
    "kind": "Method",
    "detail": "Function (bool bMustBeMapped ; return)",
    "insertText": "ResolveObjectReferenceHandleInternal(RefHandle, ResolveContext, bMustBeMapped)"
  },
  {
    "label": "ResolveObjectReference()",
    "kind": "Method",
    "detail": "Function (UObject* ResolvedObject = nullptr ;)",
    "insertText": "ResolveObjectReference(ObjectRef, ResolveContext, ResolvedObject)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (const ENetObjectReferenceTraits Traits = RelativePath .)",
    "insertText": "IsValid()"
  }
]