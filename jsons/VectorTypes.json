[
  {
    "label": "DotPerp()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Math / Vector . h \" # include \" Math / Vector4 . h \" # include \" MathUtil . h \" # include \" Serialization / Archive . h \" # include \" Templates / UnrealTypeTraits . h \" # include<sstream> namespace UE { namespace Geometry { template<T> T)",
    "insertText": "DotPerp(const UE::Math::TVector2<T>& V1, const UE::Math::TVector2<T>& V2)"
  },
  {
    "label": "Orient()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "Orient(const UE::Math::TVector2<T>& A, const UE::Math::TVector2<T>& B, const UE::Math::TVector2<T>& C)"
  },
  {
    "label": "IsNormalized()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "IsNormalized(const UE::Math::TVector2<T>& Vector, const T Tolerance = TMathUtil<T>::ZeroTolerance)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "Normalize(UE::Math::TVector2<T>& Vector, const T Epsilon = 0)"
  },
  {
    "label": "Length()",
    "kind": "Method",
    "detail": "Function (T length = Vector .)",
    "insertText": "Length()"
  },
  {
    "label": "invLength()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "invLength((T)1)"
  },
  {
    "label": "Y()",
    "kind": "Method",
    "detail": "Function (Vector . X* = invLength ; Vector . Y* = invLength ; return length ; } Vector . X = Vector .)",
    "insertText": "Y(T)"
  },
  {
    "label": "Normalized()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector2<T>)",
    "insertText": "Normalized(const UE::Math::TVector2<T>& Vector, const T Epsilon = 0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} return UE::Math::TVector2<)",
    "insertText": "T((T)0, (T)0)"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "Distance(const UE::Math::TVector2<T>& V1, const UE::Math::TVector2<T>& V2)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (T dx = V2 . X - V1 . X ; T dy = V2 . Y - V1 . Y ; return TMathUtil<T)",
    "insertText": "Sqrt(dx * dx + dy * dy)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "DistanceSquared(const UE::Math::TVector2<T>& V1, const UE::Math::TVector2<T>& V2)"
  },
  {
    "label": "AngleD()",
    "kind": "Method",
    "detail": "Function (T dx = V2 . X - V1 . X ; T dy = V2 . Y - V1 . Y ; return dx* dx + dy* dy ; } template<T> T)",
    "insertText": "AngleD(const UE::Math::TVector2<T>& V1, const UE::Math::TVector2<T>& V2)"
  },
  {
    "label": "Dot()",
    "kind": "Method",
    "detail": "Function (T DotVal = V1 .)",
    "insertText": "Dot(V2)"
  },
  {
    "label": "ClampedDot()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "ClampedDot(DotVal < (T)-1) ? (T)-1 : ((DotVal > (T)1) ? (T)1 : DotVal)"
  },
  {
    "label": "AngleR()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "AngleR(const UE::Math::TVector2<T>& V1, const UE::Math::TVector2<T>& V2)"
  },
  {
    "label": "SignedAngleR()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "SignedAngleR(const UE::Math::TVector2<T>& V1, const UE::Math::TVector2<T>& V2)"
  },
  {
    "label": "DotPerp()",
    "kind": "Method",
    "detail": "Function (T Direction =)",
    "insertText": "DotPerp(V1, V2)"
  },
  {
    "label": "Direction()",
    "kind": "Method",
    "detail": "Function (} else { T Sign =)",
    "insertText": "Direction(T)-1 : (T)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (} } template<T> UE::Math::TVector2<T>)",
    "insertText": "Lerp(const UE::Math::TVector2<T>& A, const UE::Math::TVector2<T>& B, T Alpha)"
  },
  {
    "label": "OneMinusAlpha()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "OneMinusAlpha(T)"
  },
  {
    "label": "MakeUnitVector3()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector<T>)",
    "insertText": "MakeUnitVector3(int32 Axis)"
  },
  {
    "label": "UnitVec()",
    "kind": "Method",
    "detail": "Function (UE::Math::TVector<T>)",
    "insertText": "UnitVec((T)0, (T)0, (T)0)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (UnitVec [)",
    "insertText": "Clamp(Axis, 0, 2)] = (T)"
  },
  {
    "label": "SquaredLength()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "SquaredLength(const UE::Math::TVector<T>& V)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "Normalize(UE::Math::TVector<T>& Vector, const T Epsilon = 0)"
  },
  {
    "label": "Z()",
    "kind": "Method",
    "detail": "Function (Vector . X* = invLength ; Vector . Y* = invLength ; Vector . Z* = invLength ; return length ; } Vector . X = Vector . Y = Vector .)",
    "insertText": "Z(T)"
  },
  {
    "label": "Normalized()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector<T>)",
    "insertText": "Normalized(const UE::Math::TVector<T>& Vector, const T Epsilon = 0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} return UE::Math::TVector<)",
    "insertText": "T((T)0, (T)0, (T)0)"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "Distance(const UE::Math::TVector<T>& V1, const UE::Math::TVector<T>& V2)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (T dx = V2 . X - V1 . X ; T dy = V2 . Y - V1 . Y ; T dz = V2 . Z - V1 . Z ; return TMathUtil<T)",
    "insertText": "Sqrt(dx * dx + dy * dy + dz * dz)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "DistanceSquared(const UE::Math::TVector<T>& V1, const UE::Math::TVector<T>& V2)"
  },
  {
    "label": "Dot()",
    "kind": "Method",
    "detail": "Function (T dx = V2 . X - V1 . X ; T dy = V2 . Y - V1 . Y ; T dz = V2 . Z - V1 . Z ; return dx* dx + dy* dy + dz* dz ; } template<T> T)",
    "insertText": "Dot(const UE::Math::TVector<T>& V1, const UE::Math::TVector<T>& V2)"
  },
  {
    "label": "UnitCross()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector<T>)",
    "insertText": "UnitCross(const UE::Math::TVector<T>& V1, const UE::Math::TVector<T>& V2)"
  },
  {
    "label": "Cross()",
    "kind": "Method",
    "detail": "Function (UE::Math::TVector<T> N = V1 .)",
    "insertText": "Cross(V2)"
  },
  {
    "label": "AngleD()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "AngleD(const UE::Math::TVector<T>& V1, const UE::Math::TVector<T>& V2)"
  },
  {
    "label": "AngleR()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "AngleR(const UE::Math::TVector<T>& V1, const UE::Math::TVector<T>& V2)"
  },
  {
    "label": "GetXY()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector2<T>)",
    "insertText": "GetXY(const UE::Math::TVector<T>& V)"
  },
  {
    "label": "GetXZ()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector2<T>)",
    "insertText": "GetXZ(const UE::Math::TVector<T>& V)"
  },
  {
    "label": "GetYZ()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector2<T>)",
    "insertText": "GetYZ(const UE::Math::TVector<T>& V)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector<T>)",
    "insertText": "Min(const UE::Math::TVector<T>& V0, const UE::Math::TVector<T>& V1)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector<T>)",
    "insertText": "Max(const UE::Math::TVector<T>& V0, const UE::Math::TVector<T>& V1)"
  },
  {
    "label": "MaxElement()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "MaxElement(const UE::Math::TVector<T>& Vector)"
  },
  {
    "label": "MaxElementIndex()",
    "kind": "Method",
    "detail": "Function (} template<T> int32)",
    "insertText": "MaxElementIndex(const UE::Math::TVector<T>& Vector)"
  },
  {
    "label": "MinElement()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "MinElement(const UE::Math::TVector<T>& Vector)"
  },
  {
    "label": "MinElementIndex()",
    "kind": "Method",
    "detail": "Function (} template<T> int32)",
    "insertText": "MinElementIndex(const UE::Math::TVector<T>& Vector)"
  },
  {
    "label": "MaxAbsElement()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "MaxAbsElement(const UE::Math::TVector<T>& Vector)"
  },
  {
    "label": "MaxAbsElementIndex()",
    "kind": "Method",
    "detail": "Function (} template<T> int32)",
    "insertText": "MaxAbsElementIndex(const UE::Math::TVector<T>& Vector)"
  },
  {
    "label": "MinAbsElement()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "MinAbsElement(const UE::Math::TVector<T>& Vector)"
  },
  {
    "label": "MinAbsElementIndex()",
    "kind": "Method",
    "detail": "Function (} template<T> int32)",
    "insertText": "MinAbsElementIndex(const UE::Math::TVector<T>& Vector)"
  },
  {
    "label": "ToLinearColor()",
    "kind": "Method",
    "detail": "Function (} template<T> FLinearColor)",
    "insertText": "ToLinearColor(const UE::Math::TVector<T>& Vector)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector<T>)",
    "insertText": "Lerp(const UE::Math::TVector<T>& A, const UE::Math::TVector<T>& B, T Alpha)"
  },
  {
    "label": "Blend3()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector<T>)",
    "insertText": "Blend3(const UE::Math::TVector<T>& A, const UE::Math::TVector<T>& B, const UE::Math::TVector<T>& C, const T& WeightA, const T& WeightB, const T& WeightC)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<RealType> std::ostream&)",
    "insertText": "operator(std::ostream& os, const UE::Math::TVector<RealType>& Vec)"
  },
  {
    "label": "ToLinearColor()",
    "kind": "Method",
    "detail": "Function (os<<Vec . X<<\" \"<<Vec . Y<<\" \"<<Vec . Z ; return os ; } template<T> FLinearColor)",
    "insertText": "ToLinearColor(const UE::Math::TVector4<T>& V)"
  },
  {
    "label": "ToVector4()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector4<T>)",
    "insertText": "ToVector4(const FLinearColor& Color)"
  },
  {
    "label": "ToFColor()",
    "kind": "Method",
    "detail": "Function (} template<T> FColor)",
    "insertText": "ToFColor(const UE::Math::TVector4<T>& Vector)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (} template<T> UE::Math::TVector4<T>)",
    "insertText": "Lerp(const UE::Math::TVector4<T>& A, const UE::Math::TVector4<T>& B, T Alpha)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } namespace Math { template<RealType> std::ostream&)",
    "insertText": "operator(std::ostream& os, const TVector2<RealType>& Vec)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (os<<Vec . X<<\" \"<<Vec . Y ; return os ; } template<RealType> std::ostream&)",
    "insertText": "operator(std::ostream& os, const TVector4<RealType>& Vec)"
  }
]