[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FMarchingCubes",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMarchingCubes"
  },
  {
    "label": "FGridCell",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGridCell"
  },
  {
    "label": "FIndexedVertex",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIndexedVertex"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Async / ParallelFor . h \" # include \" BoxTypes . h \" # include \" CompGeom / PolygonTriangulation . h \" # include \" Containers / Array . h \" # include \" Containers / ArrayView . h \" # include \" Containers / ContainerAllocationPolicies . h \" # include \" Containers / Map . h \" # include \" HAL / CriticalSection . h \" # include \" IndexTypes . h \" # include \" IntBoxTypes . h \" # include \" IntVectorTypes . h \" # include \" Math / UnrealMathSSE . h \" # include \" Math / UnrealMathUtility . h \" # include \" Math / Vector . h \" # include \" MathUtil . h \" # include \" MeshShapeGenerator . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / ScopeLock . h \" # include \" ProfilingDebugging / CpuProfilerTrace . h \" # include \" Spatial / BlockedDenseGrid3 . h \" # include \" Spatial / DenseGrid3 . h \" # include \" Templates / Function . h \" # include \" Templates / TypeHash . h \" # include \" Templates / UnrealTemplate . h \" # include \" Util / IndexUtil . h \" # include \" VectorTypes . h \" # include<atomic> namespace UE { namespace Geometry { using namespace UE::Math ; enum class ERootfindingModes { SingleLerp,LerpSteps,Bisection } ; class FMarchingCubes : public FMeshShapeGenerator { public : TFunction<)",
    "insertText": "double(TVector<double>)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (Bounds = TAxisAlignedBox3<)",
    "insertText": "double(TVector<double>::Zero(), 8)"
  },
  {
    "label": "FMarchingCubes()",
    "kind": "Method",
    "detail": "Function (CubeSize = 0 . 2 5 ; } ~)",
    "insertText": "FMarchingCubes()"
  },
  {
    "label": "Validate()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Validate()"
  },
  {
    "label": "Generate()",
    "kind": "Method",
    "detail": "Function (} FMeshShapeGenerator&)",
    "insertText": "Generate()"
  },
  {
    "label": "TRACE_CPUPROFILER_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_CPUPROFILER_EVENT_SCOPE(Geometry_MCMesh_Generate)"
  },
  {
    "label": "FAxisAlignedBox3i()",
    "kind": "Method",
    "detail": "Function (GridBounds =)",
    "insertText": "FAxisAlignedBox3i(FVector3i::Zero(), CellDimensions - FVector3i(1,1,1))"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (BlockedCornerValuesGrid .)",
    "insertText": "Reset(CellDimensions.X + 1, CellDimensions.Y + 1, CellDimensions.Z + 1, FMathf::MaxReal)"
  },
  {
    "label": "InitHashTables()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "InitHashTables()"
  },
  {
    "label": "ResetMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetMesh()"
  },
  {
    "label": "generate_parallel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "generate_parallel()"
  },
  {
    "label": "generate_basic()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "generate_basic()"
  },
  {
    "label": "BuildMesh()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "BuildMesh()"
  },
  {
    "label": "TRACE_CPUPROFILER_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_CPUPROFILER_EVENT_SCOPE(Geometry_MCMesh_GenerateContinuation)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bParallelCompute)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (BlockedDoneCells .)",
    "insertText": "Reset(CellDimensions.X, CellDimensions.Y, CellDimensions.Z, 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(bEnableValueCaching)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (BlockedCornerValuesGrid .)",
    "insertText": "Resize(CellDimensions.X + 1, CellDimensions.Y + 1, CellDimensions.Z + 1)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (BlockedDoneCells .)",
    "insertText": "Resize(CellDimensions.X, CellDimensions.Y, CellDimensions.Z)"
  },
  {
    "label": "generate_continuation_parallel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "generate_continuation_parallel(Seeds)"
  },
  {
    "label": "generate_continuation()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "generate_continuation(Seeds)"
  },
  {
    "label": "SetDimensions()",
    "kind": "Method",
    "detail": "Function (LastGridBounds = GridBounds ; return* this ; } protected : FAxisAlignedBox3i GridBounds ; FAxisAlignedBox3i LastGridBounds ; struct FGridCell { FVector3i i [ 8 ] ; double f [ 8 ] ; } ; void)",
    "insertText": "SetDimensions()"
  },
  {
    "label": "NX()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "NX(int)(Bounds.Width() / CubeSize)"
  },
  {
    "label": "NY()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "NY(int)(Bounds.Height() / CubeSize)"
  },
  {
    "label": "NZ()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "NZ(int)(Bounds.Depth() / CubeSize)"
  },
  {
    "label": "Max3()",
    "kind": "Method",
    "detail": "Function (int MaxDim =)",
    "insertText": "Max3(NX, NY, NZ)"
  },
  {
    "label": "MaxDim()",
    "kind": "Method",
    "detail": "Function (CubeSize = Bounds .)",
    "insertText": "MaxDim() / double(SafetyMaxDimension - 1)"
  },
  {
    "label": "FVector3i()",
    "kind": "Method",
    "detail": "Function (} CellDimensions =)",
    "insertText": "FVector3i(NX, NY, NZ)"
  },
  {
    "label": "corner_pos()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "corner_pos(const FVector3i& IJK, TVector<double>& Pos)"
  },
  {
    "label": "corner_pos()",
    "kind": "Method",
    "detail": "Function (Pos . X = Bounds . Min . X + CubeSize* IJK . X ; Pos . Y = Bounds . Min . Y + CubeSize* IJK . Y ; Pos . Z = Bounds . Min . Z + CubeSize* IJK . Z ; } TVector<double>)",
    "insertText": "corner_pos(const FVector3i& IJK)"
  },
  {
    "label": "cell_index()",
    "kind": "Method",
    "detail": "Function (} FVector3i)",
    "insertText": "cell_index(const TVector<double>& Pos)"
  },
  {
    "label": "corner_hash()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "corner_hash(const FVector3i& Idx)"
  },
  {
    "label": "corner_hash()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "corner_hash(int X, int Y, int Z)"
  },
  {
    "label": "int64()",
    "kind": "Method",
    "detail": "Function (} const int64 EDGE_X =)",
    "insertText": "int64(1)"
  },
  {
    "label": "edge_hash()",
    "kind": "Method",
    "detail": "Function (int64)",
    "insertText": "edge_hash(const FVector3i& Idx1, const FVector3i& Idx2)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (int xlo =)",
    "insertText": "Min(Idx1.X, Idx2.X)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Idx1.Y != Idx2.Y)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (int ylo =)",
    "insertText": "Min(Idx1.Y, Idx2.Y)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (} else { int zlo =)",
    "insertText": "Min(Idx1.Z, Idx2.Z)"
  },
  {
    "label": "FindVertexID()",
    "kind": "Method",
    "detail": "Function (} } const int64 NumEdgeVertexSections = 6 4 ; TArray<TMap<int64,int>> EdgeVertexSections ; TArray<FCriticalSection> EdgeVertexSectionLocks ; int)",
    "insertText": "FindVertexID(int64 hash)"
  },
  {
    "label": "SectionIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "SectionIndex(int32)(hash % (NumEdgeVertexSections - 1))"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "Lock(&EdgeVertexSectionLocks[SectionIndex])"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (int* Found = EdgeVertexSections [ SectionIndex ] .)",
    "insertText": "Find(hash)"
  },
  {
    "label": "AppendOrFindVertexID()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "AppendOrFindVertexID(int64 hash, TVector<double> Pos)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (EdgeVertexSections [ SectionIndex ] .)",
    "insertText": "Add(hash, NewVID)"
  },
  {
    "label": "edge_hash()",
    "kind": "Method",
    "detail": "Function (int64 hash =)",
    "insertText": "edge_hash(Idx1, Idx2)"
  },
  {
    "label": "FindVertexID()",
    "kind": "Method",
    "detail": "Function (int foundvid =)",
    "insertText": "FindVertexID(hash)"
  },
  {
    "label": "corner_pos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "corner_pos(Idx1, pa)"
  },
  {
    "label": "corner_pos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "corner_pos(Idx2, pb)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (TVector<double> Pos = TVector<double)",
    "insertText": "Zero()"
  },
  {
    "label": "find_iso()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "find_iso(pa, pb, F1, F2, Pos)"
  },
  {
    "label": "corner_value_grid_parallel()",
    "kind": "Method",
    "detail": "Function (} FBlockedDenseGrid3f BlockedCornerValuesGrid ; double)",
    "insertText": "corner_value_grid_parallel(const FVector3i& Idx)"
  },
  {
    "label": "GetValueThreadSafe()",
    "kind": "Method",
    "detail": "Function (float CurrentValue = BlockedCornerValuesGrid .)",
    "insertText": "GetValueThreadSafe(Idx.X, Idx.Y, Idx.Z)"
  },
  {
    "label": "corner_pos()",
    "kind": "Method",
    "detail": "Function (} TVector<double> V =)",
    "insertText": "corner_pos(Idx)"
  },
  {
    "label": "CurrentValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CurrentValue(float)Implicit(V)"
  },
  {
    "label": "SetValueThreadSafe()",
    "kind": "Method",
    "detail": "Function (BlockedCornerValuesGrid .)",
    "insertText": "SetValueThreadSafe(Idx.X, Idx.Y, Idx.Z, CurrentValue)"
  },
  {
    "label": "corner_value_grid()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "corner_value_grid(const FVector3i& Idx)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (} float CurrentValue = BlockedCornerValuesGrid .)",
    "insertText": "GetValue(Idx.X, Idx.Y, Idx.Z)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (BlockedCornerValuesGrid .)",
    "insertText": "SetValue(Idx.X, Idx.Y, Idx.Z, CurrentValue)"
  },
  {
    "label": "initialize_cell_values_grid()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "initialize_cell_values_grid(FGridCell& Cell, bool Shift)"
  },
  {
    "label": "corner_value_grid()",
    "kind": "Method",
    "detail": "Function (Cell . f [ 1 ] =)",
    "insertText": "corner_value_grid(Cell.i[1])"
  },
  {
    "label": "corner_value_grid()",
    "kind": "Method",
    "detail": "Function (Cell . f [ 2 ] =)",
    "insertText": "corner_value_grid(Cell.i[2])"
  },
  {
    "label": "corner_value_grid()",
    "kind": "Method",
    "detail": "Function (Cell . f [ 5 ] =)",
    "insertText": "corner_value_grid(Cell.i[5])"
  },
  {
    "label": "corner_value_grid()",
    "kind": "Method",
    "detail": "Function (Cell . f [ 6 ] =)",
    "insertText": "corner_value_grid(Cell.i[6])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(int i = 0; i < 8; ++i)"
  },
  {
    "label": "corner_value_grid()",
    "kind": "Method",
    "detail": "Function (Cell . f [ i ] =)",
    "insertText": "corner_value_grid(Cell.i[i])"
  },
  {
    "label": "corner_value_nohash()",
    "kind": "Method",
    "detail": "Function (} } } double)",
    "insertText": "corner_value_nohash(const FVector3i& Idx)"
  },
  {
    "label": "initialize_cell_values_nohash()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "initialize_cell_values_nohash(FGridCell& Cell, bool Shift)"
  },
  {
    "label": "corner_value_nohash()",
    "kind": "Method",
    "detail": "Function (Cell . f [ 1 ] =)",
    "insertText": "corner_value_nohash(Cell.i[1])"
  },
  {
    "label": "corner_value_nohash()",
    "kind": "Method",
    "detail": "Function (Cell . f [ 2 ] =)",
    "insertText": "corner_value_nohash(Cell.i[2])"
  },
  {
    "label": "corner_value_nohash()",
    "kind": "Method",
    "detail": "Function (Cell . f [ 5 ] =)",
    "insertText": "corner_value_nohash(Cell.i[5])"
  },
  {
    "label": "corner_value_nohash()",
    "kind": "Method",
    "detail": "Function (Cell . f [ 6 ] =)",
    "insertText": "corner_value_nohash(Cell.i[6])"
  },
  {
    "label": "corner_value_nohash()",
    "kind": "Method",
    "detail": "Function (Cell . f [ i ] =)",
    "insertText": "corner_value_nohash(Cell.i[i])"
  },
  {
    "label": "initialize_cell()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "initialize_cell(FGridCell& Cell, const FVector3i& Idx)"
  },
  {
    "label": "FVector3i()",
    "kind": "Method",
    "detail": "Function (Cell . i [ 0 ] =)",
    "insertText": "FVector3i(Idx.X + 0, Idx.Y + 0, Idx.Z + 0)"
  },
  {
    "label": "FVector3i()",
    "kind": "Method",
    "detail": "Function (Cell . i [ 1 ] =)",
    "insertText": "FVector3i(Idx.X + 1, Idx.Y + 0, Idx.Z + 0)"
  },
  {
    "label": "FVector3i()",
    "kind": "Method",
    "detail": "Function (Cell . i [ 2 ] =)",
    "insertText": "FVector3i(Idx.X + 1, Idx.Y + 0, Idx.Z + 1)"
  },
  {
    "label": "FVector3i()",
    "kind": "Method",
    "detail": "Function (Cell . i [ 3 ] =)",
    "insertText": "FVector3i(Idx.X + 0, Idx.Y + 0, Idx.Z + 1)"
  },
  {
    "label": "FVector3i()",
    "kind": "Method",
    "detail": "Function (Cell . i [ 4 ] =)",
    "insertText": "FVector3i(Idx.X + 0, Idx.Y + 1, Idx.Z + 0)"
  },
  {
    "label": "FVector3i()",
    "kind": "Method",
    "detail": "Function (Cell . i [ 5 ] =)",
    "insertText": "FVector3i(Idx.X + 1, Idx.Y + 1, Idx.Z + 0)"
  },
  {
    "label": "FVector3i()",
    "kind": "Method",
    "detail": "Function (Cell . i [ 6 ] =)",
    "insertText": "FVector3i(Idx.X + 1, Idx.Y + 1, Idx.Z + 1)"
  },
  {
    "label": "FVector3i()",
    "kind": "Method",
    "detail": "Function (Cell . i [ 7 ] =)",
    "insertText": "FVector3i(Idx.X + 0, Idx.Y + 1, Idx.Z + 1)"
  },
  {
    "label": "initialize_cell_values_grid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initialize_cell_values_grid(Cell, false)"
  },
  {
    "label": "initialize_cell_values_nohash()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "initialize_cell_values_nohash(Cell, false)"
  },
  {
    "label": "shift_cell_x()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "shift_cell_x(FGridCell& Cell, int XIdx)"
  },
  {
    "label": "initialize_cell_values_grid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initialize_cell_values_grid(Cell, true)"
  },
  {
    "label": "initialize_cell_values_nohash()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "initialize_cell_values_nohash(Cell, true)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (EdgeVertexSections .)",
    "insertText": "Reset()"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (EdgeVertexSections .)",
    "insertText": "SetNum((int32)NumEdgeVertexSections)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (parallel_mesh_access = true ;)",
    "insertText": "ParallelFor(CellDimensions.Z, [this](int32 ZIdx) { FGridCell Cell; int vertTArray[12]; for (int yi = 0; yi < CellDimensions.Y; ++yi) { if (CancelF()) { return; } FVector3i Idx(0, yi, ZIdx); initialize_cell(Cell, Idx); polygonize_cell(Cell, vertTArray); for (int XIdx = 1; XIdx < CellDimensions.X; ++XIdx) { shift_cell_x(Cell, XIdx); polygonize_cell(Cell, vertTArray); } } })"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FGridCell Cell ; int vertTArray [ 1 2 ] ;)",
    "insertText": "for(int ZIdx = 0; ZIdx < CellDimensions.Z; ++ZIdx)"
  },
  {
    "label": "initialize_cell()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initialize_cell(Cell, Idx)"
  },
  {
    "label": "polygonize_cell()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "polygonize_cell(Cell, vertTArray)"
  },
  {
    "label": "shift_cell_x()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "shift_cell_x(Cell, XIdx)"
  },
  {
    "label": "generate_continuation()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "generate_continuation(TArrayView<const FVector3d> Seeds)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<FVector3i> stack ;)",
    "insertText": "for(FVector3d seed : Seeds)"
  },
  {
    "label": "cell_index()",
    "kind": "Method",
    "detail": "Function (FVector3i seed_idx =)",
    "insertText": "cell_index(seed)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (continue ; } stack .)",
    "insertText": "Add(seed_idx)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (BlockedDoneCells .)",
    "insertText": "SetValue(seed_idx.X, seed_idx.Y, seed_idx.Z, 1)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (FVector3i Idx = stack [ stack .)",
    "insertText": "Num()"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (stack .)",
    "insertText": "RemoveAt(stack.Num()-1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FVector3i nbr_idx = Idx + o ;)",
    "insertText": "if(GridBounds.Contains(nbr_idx) && BlockedDoneCells.GetValue(nbr_idx.X, nbr_idx.Y, nbr_idx.Z) == 0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (stack .)",
    "insertText": "Add(nbr_idx)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (BlockedDoneCells .)",
    "insertText": "SetValue(nbr_idx.X, nbr_idx.Y, nbr_idx.Z, 1)"
  },
  {
    "label": "generate_continuation_parallel()",
    "kind": "Method",
    "detail": "Function (} } } } } } void)",
    "insertText": "generate_continuation_parallel(TArrayView<const FVector3d> Seeds)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (parallel_mesh_access = true ; int MaxNeighboursPerActiveCell = 1 0 0 ; TArray<FVector3i> ActiveCells ;)",
    "insertText": "for(FVector3d Seed : Seeds)"
  },
  {
    "label": "cell_index()",
    "kind": "Method",
    "detail": "Function (FVector3i seed_idx =)",
    "insertText": "cell_index(Seed)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} } TArray<FVector3i> NewActiveCells ; FCriticalSection NewActiveCellsLock ;)",
    "insertText": "while(ActiveCells.Num() > 0)"
  },
  {
    "label": "ParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParallelFor(ActiveCells.Num(), [&](int32 Idx) { FVector3i InitialCellIndex = ActiveCells[Idx]; if (CancelF()) { return; } FGridCell TempCell; int TempArray[12]; TArray<FVector3i, TInlineAllocator<64>> LocalStack; LocalStack.Add(InitialCellIndex); int32 CellsProcessed = 0; while (LocalStack.Num() > 0 && CellsProcessed++ < MaxNeighboursPerActiveCell) { FVector3i CellIndex = LocalStack.Pop(EAllowShrinking::No); initialize_cell(TempCell, CellIndex); if (polygonize_cell(TempCell, TempArray)) { for (FVector3i GridOffset : IndexUtil::GridOffsets6) { FVector3i NbrCellIndex = CellIndex + GridOffset; if (GridBounds.Contains(NbrCellIndex)) { if (set_cell_if_not_done(NbrCellIndex) == true) { LocalStack.Add(NbrCellIndex); } } } } } if (LocalStack.Num() > 0) { NewActiveCellsLock.Lock(); NewActiveCells.Append(LocalStack); NewActiveCellsLock.Unlock(); } })"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(ActiveCells, NewActiveCells)"
  },
  {
    "label": "set_cell_if_not_done()",
    "kind": "Method",
    "detail": "Function (} } parallel_mesh_access = false ; } FBlockedDenseGrid3i BlockedDoneCells ; bool)",
    "insertText": "set_cell_if_not_done(const FVector3i& Idx)"
  },
  {
    "label": "ProcessValueThreadSafe()",
    "kind": "Method",
    "detail": "Function (bool was_set = false ; { BlockedDoneCells .)",
    "insertText": "ProcessValueThreadSafe(Idx.X, Idx.Y, Idx.Z, [&](int& CellValue) { if (CellValue == 0) { CellValue = 1; was_set = true; } })"
  },
  {
    "label": "polygonize_cell()",
    "kind": "Method",
    "detail": "Function (} return was_set ; } bool)",
    "insertText": "polygonize_cell(FGridCell& Cell, int VertIndexArray[])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cubeindex | = Shift ; } Shift<<= 1 ; })",
    "insertText": "if(EdgeTable[cubeindex] == 0)"
  },
  {
    "label": "edge_vertex_id()",
    "kind": "Method",
    "detail": "Function (int a = EdgeIndices [ i ] [ 0 ],b = EdgeIndices [ i ] [ 1 ] ; VertIndexArray [ i ] =)",
    "insertText": "edge_vertex_id(Cell.i[a], Cell.i[b], Cell.f[a], Cell.f[b])"
  },
  {
    "label": "corner_hash()",
    "kind": "Method",
    "detail": "Function (} Shift<<= 1 ; } int64 CellHash =)",
    "insertText": "corner_hash(Cell.i[0])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int tri_count = 0 ;)",
    "insertText": "for(int i = 0; TriTable[cubeindex][i] != -1; i += 3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int ta = TriTable [ cubeindex ] [ i ] ; int tb = TriTable [ cubeindex ] [ i + 1 ] ; int tc = TriTable [ cubeindex ] [ i + 2 ] ; int a = VertIndexArray [ ta ],b = VertIndexArray [ tb ],c = VertIndexArray [ tc ] ;)",
    "insertText": "if(!ensure(a != b && a != c && b != c))"
  },
  {
    "label": "append_triangle()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "append_triangle(a, b, c, CellHash)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (tri_count + + ; })",
    "insertText": "return(tri_count > 0)"
  },
  {
    "label": "GetVertexSectionIndex()",
    "kind": "Method",
    "detail": "Function (} struct FIndexedVertex { int32 Index ; FVector3d Position ; } ; std::atomic<int32> VertexCounter ; int64 NumVertexSections = 6 4 ; TArray<FCriticalSection> VertexSectionLocks ; TArray<TArray<FIndexedVertex>> VertexSectionLists ; int)",
    "insertText": "GetVertexSectionIndex(int64 hash)"
  },
  {
    "label": "append_vertex()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "append_vertex(TVector<double> V, int64 CellHash)"
  },
  {
    "label": "GetVertexSectionIndex()",
    "kind": "Method",
    "detail": "Function (int SectionIndex =)",
    "insertText": "GetVertexSectionIndex(CellHash)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 NewIndex = VertexCounter + + ;)",
    "insertText": "if(parallel_mesh_access)"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "Lock(&VertexSectionLocks[SectionIndex])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertexSectionLists [ SectionIndex ] .)",
    "insertText": "Add(FIndexedVertex{ NewIndex, V })"
  },
  {
    "label": "GetTriangleSectionIndex()",
    "kind": "Method",
    "detail": "Function (} return NewIndex ; } int64 NumTriangleSections = 6 4 ; TArray<FCriticalSection> TriangleSectionLocks ; TArray<TArray<FIndex3i>> TriangleSectionLists ; int)",
    "insertText": "GetTriangleSectionIndex(int64 hash)"
  },
  {
    "label": "append_triangle()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "append_triangle(int A, int B, int C, int64 CellHash)"
  },
  {
    "label": "GetTriangleSectionIndex()",
    "kind": "Method",
    "detail": "Function (int SectionIndex =)",
    "insertText": "GetTriangleSectionIndex(CellHash)"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "Lock(&TriangleSectionLocks[SectionIndex])"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TriangleSectionLists [ SectionIndex ] .)",
    "insertText": "Add(FIndex3i(A, B, C))"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (VertexSectionLocks .)",
    "insertText": "SetNum((int32)NumVertexSections)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (VertexCounter = 0 ; TriangleSectionLocks .)",
    "insertText": "SetNum((int32)NumTriangleSections)"
  },
  {
    "label": "TRACE_CPUPROFILER_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_CPUPROFILER_EVENT_SCOPE(Geometry_MCMesh_BuildMesh)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (int32 NumVertices = VertexCounter ; TArray<FVector3d> VertexBuffer ; VertexBuffer .)",
    "insertText": "SetNum(NumVertices)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (VertexBuffer [ Vtx . Index ] = Vtx . Position ; } })",
    "insertText": "for(int32 k = 0; k < NumVertices; ++k)"
  },
  {
    "label": "AppendVertex()",
    "kind": "Method",
    "detail": "Function (int32 vid =)",
    "insertText": "AppendVertex(VertexBuffer[k])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(const TArray<FIndex3i>& TriangleList : TriangleSectionLists)"
  },
  {
    "label": "AppendTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendTriangle(Tri.A, Tri.B, Tri.C)"
  },
  {
    "label": "find_iso()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "find_iso(const TVector<double>& P1, const TVector<double>& P2, double ValP1, double ValP2, TVector<double>& PIso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const double dt = 0 . 9 9 9 9 9 9 ;)",
    "insertText": "if(FMath::Abs(ValP1 - ValP2) < 0.00001)"
  },
  {
    "label": "PIso()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PIso(P1 + P2)"
  },
  {
    "label": "P1()",
    "kind": "Method",
    "detail": "Function (PIso = dt*)",
    "insertText": "P1(1.0 - dt)"
  },
  {
    "label": "PIso()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PIso(dt) * P2 + (1.0 - dt)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (a = P2 ; b = P1 ; fb = ValP1 ; fa = ValP2 ; })",
    "insertText": "if(RootMode == ERootfindingModes::Bisection)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (PIso .)",
    "insertText": "X(a.X + b.X)"
  },
  {
    "label": "Y()",
    "kind": "Method",
    "detail": "Function (PIso .)",
    "insertText": "Y(a.Y + b.Y)"
  },
  {
    "label": "Z()",
    "kind": "Method",
    "detail": "Function (PIso .)",
    "insertText": "Z(a.Z + b.Z)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (a = PIso ; fa = mid_f ; } else { b = PIso ; fb = mid_f ; } } PIso =)",
    "insertText": "Lerp(a, b, 0.5)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { double mu = 0 ;)",
    "insertText": "if(RootMode == ERootfindingModes::LerpSteps)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (mu =)",
    "insertText": "Clamp((IsoValue - fa) / (fb - fa), 0.0, 1.0)"
  },
  {
    "label": "mu()",
    "kind": "Method",
    "detail": "Function (PIso . X = a . X +)",
    "insertText": "mu(b.X - a.X)"
  },
  {
    "label": "mu()",
    "kind": "Method",
    "detail": "Function (PIso . Y = a . Y +)",
    "insertText": "mu(b.Y - a.Y)"
  },
  {
    "label": "mu()",
    "kind": "Method",
    "detail": "Function (PIso . Z = a . Z +)",
    "insertText": "mu(b.Z - a.Z)"
  }
]