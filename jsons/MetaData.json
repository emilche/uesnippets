[
  {
    "label": "LLVMContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LLVMContext"
  },
  {
    "label": "Module",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Module"
  },
  {
    "label": "ModuleSlotTracker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ModuleSlotTracker"
  },
  {
    "label": "SymbolTableListTraits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SymbolTableListTraits"
  },
  {
    "label": "LLVMConstants",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "LLVMConstants"
  },
  {
    "label": "Metadata",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Metadata"
  },
  {
    "label": "ReplaceableMetadataImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ReplaceableMetadataImpl"
  },
  {
    "label": "StorageType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "StorageType"
  },
  {
    "label": "MetadataKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "MetadataKind"
  },
  {
    "label": "CLASS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CLASS"
  },
  {
    "label": "isa_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "isa_impl"
  },
  {
    "label": "MetadataAsValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MetadataAsValue"
  },
  {
    "label": "LLVMContextImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LLVMContextImpl"
  },
  {
    "label": "MetadataTracking",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MetadataTracking"
  },
  {
    "label": "ValueAsMetadata",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueAsMetadata"
  },
  {
    "label": "ConstantAsMetadata",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstantAsMetadata"
  },
  {
    "label": "LocalAsMetadata",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LocalAsMetadata"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "Result",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Result"
  },
  {
    "label": "HasDereference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HasDereference"
  },
  {
    "label": "SFINAE",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SFINAE"
  },
  {
    "label": "U",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U"
  },
  {
    "label": "V",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "V"
  },
  {
    "label": "M",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "M"
  },
  {
    "label": "IsValidPointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsValidPointer"
  },
  {
    "label": "IsValidReference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsValidReference"
  },
  {
    "label": "X",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "X"
  },
  {
    "label": "Y",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Y"
  },
  {
    "label": "MDString",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MDString"
  },
  {
    "label": "StringMapEntry",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StringMapEntry"
  },
  {
    "label": "AAMDNodes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AAMDNodes"
  },
  {
    "label": "DenseMapInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DenseMapInfo"
  },
  {
    "label": "MDOperand",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MDOperand"
  },
  {
    "label": "simplify_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "simplify_type"
  },
  {
    "label": "ContextAndReplaceableUses",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ContextAndReplaceableUses"
  },
  {
    "label": "TempMDNodeDeleter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TempMDNodeDeleter"
  },
  {
    "label": "MDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MDNode"
  },
  {
    "label": "StoreT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StoreT"
  },
  {
    "label": "NodeTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NodeTy"
  },
  {
    "label": "HasCachedHash",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HasCachedHash"
  },
  {
    "label": "MDTuple",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MDTuple"
  },
  {
    "label": "TypedMDOperandIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypedMDOperandIterator"
  },
  {
    "label": "MDTupleTypedArrayWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MDTupleTypedArrayWrapper"
  },
  {
    "label": "NamedMDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NamedMDNode"
  },
  {
    "label": "ilist_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ilist_traits"
  },
  {
    "label": "T1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T1"
  },
  {
    "label": "T2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T2"
  },
  {
    "label": "op_iterator_impl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "op_iterator_impl"
  },
  {
    "label": "Metadata()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_IR_METADATA_H # define LLVM_IR_METADATA_H # include \" llvm / ADT / ArrayRef . h \" # include \" llvm / ADT / DenseMap . h \" # include \" llvm / ADT / ilist_node . h \" # include \" llvm / ADT / iterator_range . h \" # include \" llvm / IR / Constant . h \" # include \" llvm / IR / MetadataTracking . h \" # include \" llvm / IR / Value . h \" # include \" llvm / Support / ErrorHandling . h \" # include<type_traits> namespace llvm { class LLVMContext ; class Module ; class ModuleSlotTracker ; template<ValueSubClass,ItemParentClass> class SymbolTableListTraits ; enum LLVMConstants : uint32_t { DEBUG_METADATA_VERSION = 3 } ; class Metadata { class ReplaceableMetadataImpl ; const unsigned char SubclassID ; protected : enum StorageType { Uniqued,Distinct,Temporary } ; unsigned Storage : 2 ; unsigned short SubclassData16 ; unsigned SubclassData32 ; public : enum MetadataKind { MDTupleKind,DILocationKind,GenericDINodeKind,DISubrangeKind,DIEnumeratorKind,DIBasicTypeKind,DIDerivedTypeKind,DICompositeTypeKind,DISubroutineTypeKind,DIFileKind,DICompileUnitKind,DISubprogramKind,DILexicalBlockKind,DILexicalBlockFileKind,DINamespaceKind,DIModuleKind,DITemplateTypeParameterKind,DITemplateValueParameterKind,DIGlobalVariableKind,DILocalVariableKind,DIExpressionKind,DIObjCPropertyKind,DIImportedEntityKind,ConstantAsMetadataKind,LocalAsMetadataKind,MDStringKind } ; protected :)",
    "insertText": "Metadata(unsigned ID, StorageType Storage) : SubclassID(ID), Storage(Storage), SubclassData16(0), SubclassData32(0)"
  },
  {
    "label": "Metadata()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "Metadata()"
  },
  {
    "label": "handleChangedOperand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "handleChangedOperand(void *, Metadata *)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Unimplemented in Metadata subclass\")"
  },
  {
    "label": "getMetadataID()",
    "kind": "Method",
    "detail": "Function (} public : unsigned)",
    "insertText": "getMetadataID()"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dump(const Module *M)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS, const Module *M = nullptr)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS, ModuleSlotTracker &MST, const Module *M = nullptr)"
  },
  {
    "label": "printAsOperand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printAsOperand(raw_ostream &OS, const Module *M = nullptr)"
  },
  {
    "label": "printAsOperand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printAsOperand(raw_ostream &OS, ModuleSlotTracker &MST, const Module *M = nullptr)"
  },
  {
    "label": "HANDLE_METADATA()",
    "kind": "Method",
    "detail": "Function (} ; # define)",
    "insertText": "HANDLE_METADATA(CLASS)"
  },
  {
    "label": "HANDLE_METADATA_LEAF()",
    "kind": "Method",
    "detail": "Function (# include \" llvm / IR / Metadata . def \" # define)",
    "insertText": "HANDLE_METADATA_LEAF(CLASS)"
  },
  {
    "label": "doit()",
    "kind": "Method",
    "detail": "Function (\\ bool)",
    "insertText": "doit(const Metadata &MD)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } ; # include \" llvm / IR / Metadata . def \" raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const Metadata &MD)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (MD .)",
    "insertText": "print(OS)"
  },
  {
    "label": "MetadataAsValue()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "MetadataAsValue()"
  },
  {
    "label": "dropUse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dropUse()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (MD = nullptr ; } public : MetadataAsValue*)",
    "insertText": "get(LLVMContext &Context, Metadata *MD)"
  },
  {
    "label": "getIfExists()",
    "kind": "Method",
    "detail": "Function (MetadataAsValue*)",
    "insertText": "getIfExists(LLVMContext &Context, Metadata *MD)"
  },
  {
    "label": "getMetadata()",
    "kind": "Method",
    "detail": "Function (Metadata*)",
    "insertText": "getMetadata()"
  },
  {
    "label": "handleChangedMetadata()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "handleChangedMetadata(Metadata *MD)"
  },
  {
    "label": "track()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "track()"
  },
  {
    "label": "untrack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "untrack()"
  },
  {
    "label": "ReplaceableMetadataImpl()",
    "kind": "Method",
    "detail": "Function (} ; class ReplaceableMetadataImpl { class MetadataTracking ; public : typedef MetadataTracking::OwnerTy OwnerTy ; private : LLVMContext& Context ; uint64_t NextIndex ; SmallDenseMap<void*,std::pair<OwnerTy,uint64_t>,4> UseMap ; public :)",
    "insertText": "ReplaceableMetadataImpl(LLVMContext &Context) : Context(Context), NextIndex(0)"
  },
  {
    "label": "ReplaceableMetadataImpl()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ReplaceableMetadataImpl()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(UseMap.empty() && \"Cannot destroy in-use replaceable metadata\")"
  },
  {
    "label": "getContext()",
    "kind": "Method",
    "detail": "Function (} LLVMContext&)",
    "insertText": "getContext()"
  },
  {
    "label": "resolveAllUses()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resolveAllUses(bool ResolveUsers = true)"
  },
  {
    "label": "addRef()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "addRef(void *Ref, OwnerTy Owner)"
  },
  {
    "label": "dropRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dropRef(void *Ref)"
  },
  {
    "label": "moveRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "moveRef(void *Ref, void *New, const Metadata &MD)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (ReplaceableMetadataImpl*)",
    "insertText": "get(Metadata &MD)"
  },
  {
    "label": "dropUsers()",
    "kind": "Method",
    "detail": "Function (} ; class ValueAsMetadata : public Metadata,ReplaceableMetadataImpl { class ReplaceableMetadataImpl ; class LLVMContextImpl ; Value* V ; void)",
    "insertText": "dropUsers()"
  },
  {
    "label": "resolveAllUses()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resolveAllUses(false)"
  },
  {
    "label": "ValueAsMetadata()",
    "kind": "Method",
    "detail": "Function (} protected :)",
    "insertText": "ValueAsMetadata(unsigned ID, Value *V) : Metadata(ID, Uniqued), ReplaceableMetadataImpl(V->getContext()), V(V)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(V && \"Expected valid value\")"
  },
  {
    "label": "ValueAsMetadata()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ValueAsMetadata()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (public : ValueAsMetadata*)",
    "insertText": "get(Value *V)"
  },
  {
    "label": "getConstant()",
    "kind": "Method",
    "detail": "Function (ConstantAsMetadata*)",
    "insertText": "getConstant(Value *C)"
  },
  {
    "label": "getLocal()",
    "kind": "Method",
    "detail": "Function (} LocalAsMetadata*)",
    "insertText": "getLocal(Value *Local)"
  },
  {
    "label": "getIfExists()",
    "kind": "Method",
    "detail": "Function (} ValueAsMetadata*)",
    "insertText": "getIfExists(Value *V)"
  },
  {
    "label": "getConstantIfExists()",
    "kind": "Method",
    "detail": "Function (ConstantAsMetadata*)",
    "insertText": "getConstantIfExists(Value *C)"
  },
  {
    "label": "getLocalIfExists()",
    "kind": "Method",
    "detail": "Function (} LocalAsMetadata*)",
    "insertText": "getLocalIfExists(Value *Local)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "getValue()"
  },
  {
    "label": "handleDeletion()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "handleDeletion(Value *V)"
  },
  {
    "label": "handleRAUW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "handleRAUW(Value *From, Value *To)"
  },
  {
    "label": "replaceAllUsesWith()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "replaceAllUsesWith(Metadata *MD)"
  },
  {
    "label": "replaceAllUsesWith()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replaceAllUsesWith(MD)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "classof(const Metadata *MD)"
  },
  {
    "label": "ConstantAsMetadata()",
    "kind": "Method",
    "detail": "Function (} } ; class ConstantAsMetadata : public ValueAsMetadata { class ValueAsMetadata ;)",
    "insertText": "ConstantAsMetadata(Constant *C) : ValueAsMetadata(ConstantAsMetadataKind, C)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} public : ConstantAsMetadata*)",
    "insertText": "get(Constant *C)"
  },
  {
    "label": "getIfExists()",
    "kind": "Method",
    "detail": "Function (} ConstantAsMetadata*)",
    "insertText": "getIfExists(Constant *C)"
  },
  {
    "label": "LocalAsMetadata()",
    "kind": "Method",
    "detail": "Function (} } ; class LocalAsMetadata : public ValueAsMetadata { class ValueAsMetadata ;)",
    "insertText": "LocalAsMetadata(Value *Local) : ValueAsMetadata(LocalAsMetadataKind, Local)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isa<Constant>(Local) && \"Expected local value\")"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} public : LocalAsMetadata*)",
    "insertText": "get(Value *Local)"
  },
  {
    "label": "getIfExists()",
    "kind": "Method",
    "detail": "Function (} LocalAsMetadata*)",
    "insertText": "getIfExists(Value *Local)"
  },
  {
    "label": "make()",
    "kind": "Method",
    "detail": "Function (} } ; namespace mdconst { namespace detail { template<class T> T&)",
    "insertText": "make()"
  },
  {
    "label": "hasDereference()",
    "kind": "Method",
    "detail": "Function (template<class T,class Result> struct HasDereference { typedef char Yes [ 1 ] ; typedef char No [ 2 ] ; template<size_t N> struct SFINAE { } ; template<class U,class V> Yes&)",
    "insertText": "hasDereference(SFINAE<sizeof(static_cast<V>(*make<U>()))> * = 0)"
  },
  {
    "label": "hasDereference()",
    "kind": "Method",
    "detail": "Function (template<class U,class V> No&)",
    "insertText": "hasDereference(...)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const bool value =)",
    "insertText": "sizeof(hasDereference<T, Result>(nullptr)) == sizeof(Yes)"
  },
  {
    "label": "hasa()",
    "kind": "Method",
    "detail": "Function (} ; template<class V,class M> struct IsValidPointer { const bool value = std::is_base_of<Constant,V>::value&& HasDereference<M,const Metadata&>::value ; } ; template<class V,class M> struct IsValidReference { const bool value = std::is_base_of<Constant,V>::value&& std::is_convertible<M,const Metadata&>::value ; } ; } template<class X,class Y> std::enable_if<detail::IsValidPointer<X,Y>::value,bool>::type)",
    "insertText": "hasa(Y &&MD)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(MD && \"Null pointer sent into hasa\")"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (} template<class X,class Y> std::enable_if<detail::IsValidPointer<X,Y>::value,X*>::type)",
    "insertText": "extract(Y &&MD)"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (} template<class X,class Y> std::enable_if<detail::IsValidReference<X,Y&>::value,X*>::type)",
    "insertText": "extract(Y &MD)"
  },
  {
    "label": "extract_or_null()",
    "kind": "Method",
    "detail": "Function (} template<class X,class Y> std::enable_if<detail::IsValidPointer<X,Y>::value,X*>::type)",
    "insertText": "extract_or_null(Y &&MD)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MDString&)",
    "insertText": "operator(MDString &&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MDString&)",
    "insertText": "operator(const MDString &)"
  },
  {
    "label": "MDString()",
    "kind": "Method",
    "detail": "Function (StringMapEntry<MDString>* Entry ;)",
    "insertText": "MDString() : Metadata(MDStringKind, Uniqued), Entry(nullptr)"
  },
  {
    "label": "MDString()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MDString(MDString &&) : Metadata(MDStringKind, Uniqued)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} public : MDString*)",
    "insertText": "get(LLVMContext &Context, StringRef Str)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (MDString*)",
    "insertText": "get(LLVMContext &Context, const char *Str)"
  },
  {
    "label": "getString()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "getString()"
  },
  {
    "label": "getLength()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getLength()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} typedef StringRef::iterator iterator ; iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "bytes_begin()",
    "kind": "Method",
    "detail": "Function (} const unsigned char*)",
    "insertText": "bytes_begin()"
  },
  {
    "label": "bytes_end()",
    "kind": "Method",
    "detail": "Function (} const unsigned char*)",
    "insertText": "bytes_end()"
  },
  {
    "label": "AAMDNodes()",
    "kind": "Method",
    "detail": "Function (} } ; struct AAMDNodes {)",
    "insertText": "AAMDNodes(MDNode *T = nullptr, MDNode *S = nullptr, MDNode *N = nullptr) : TBAA(T), Scope(S), NoAlias(N)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const AAMDNodes &A)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "getTombstoneKey()",
    "kind": "Method",
    "detail": "Function (} AAMDNodes)",
    "insertText": "getTombstoneKey()"
  },
  {
    "label": "getHashValue()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getHashValue(const AAMDNodes &Val)"
  },
  {
    "label": "isEqual()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isEqual(const AAMDNodes &LHS, const AAMDNodes &RHS)"
  },
  {
    "label": "MDOperand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MDOperand(const MDOperand &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MDOperand&)",
    "insertText": "operator(MDOperand &&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MDOperand&)",
    "insertText": "operator(const MDOperand &)"
  },
  {
    "label": "MDOperand()",
    "kind": "Method",
    "detail": "Function (Metadata* MD ; public :)",
    "insertText": "MDOperand() : MD(nullptr)"
  },
  {
    "label": "MDOperand()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "MDOperand()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} Metadata*)",
    "insertText": "get()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Metadata*)",
    "insertText": "operator()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reset()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (MD = nullptr ; } void)",
    "insertText": "reset(Metadata *MD, Metadata *Owner)"
  },
  {
    "label": "track()",
    "kind": "Method",
    "detail": "Function (this -> MD = MD ;)",
    "insertText": "track(Owner)"
  },
  {
    "label": "track()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "track(Metadata *Owner)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(static_cast<void *>(this) == &MD && \"Expected same address\")"
  },
  {
    "label": "getSimplifiedValue()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct simplify_type<MDOperand> { typedef Metadata* SimpleType ; SimpleType)",
    "insertText": "getSimplifiedValue(MDOperand &MD)"
  },
  {
    "label": "getSimplifiedValue()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct simplify_type<const MDOperand> { typedef Metadata* SimpleType ; SimpleType)",
    "insertText": "getSimplifiedValue(const MDOperand &MD)"
  },
  {
    "label": "ContextAndReplaceableUses()",
    "kind": "Method",
    "detail": "Function (} } ; class ContextAndReplaceableUses { PointerUnion<LLVMContext*,ReplaceableMetadataImpl*> Ptr ;)",
    "insertText": "ContextAndReplaceableUses()"
  },
  {
    "label": "ContextAndReplaceableUses()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ContextAndReplaceableUses(ContextAndReplaceableUses &&)"
  },
  {
    "label": "ContextAndReplaceableUses()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ContextAndReplaceableUses(const ContextAndReplaceableUses &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ContextAndReplaceableUses&)",
    "insertText": "operator(ContextAndReplaceableUses &&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ContextAndReplaceableUses&)",
    "insertText": "operator(const ContextAndReplaceableUses &)"
  },
  {
    "label": "ContextAndReplaceableUses()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "ContextAndReplaceableUses(LLVMContext &Context) : Ptr(&Context)"
  },
  {
    "label": "ContextAndReplaceableUses()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ContextAndReplaceableUses(std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses) : Ptr(ReplaceableUses.release())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getReplaceableUses() && \"Expected non-null replaceable uses\")"
  },
  {
    "label": "getReplaceableUses()",
    "kind": "Method",
    "detail": "Function (delete)",
    "insertText": "getReplaceableUses()"
  },
  {
    "label": "LLVMContext()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "LLVMContext()"
  },
  {
    "label": "hasReplaceableUses()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasReplaceableUses()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(ReplaceableUses && \"Expected non-null replaceable uses\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(&ReplaceableUses->getContext() == &getContext() && \"Expected same context\")"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (Ptr = ReplaceableUses .)",
    "insertText": "release()"
  },
  {
    "label": "takeReplaceableUses()",
    "kind": "Method",
    "detail": "Function (} std::unique_ptr<ReplaceableMetadataImpl>)",
    "insertText": "takeReplaceableUses()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(hasReplaceableUses() && \"Expected to own replaceable uses\")"
  },
  {
    "label": "ReplaceableUses()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<ReplaceableMetadataImpl>)",
    "insertText": "ReplaceableUses(getReplaceableUses())"
  },
  {
    "label": "HANDLE_MDNODE_LEAF()",
    "kind": "Method",
    "detail": "Function (} ; # define)",
    "insertText": "HANDLE_MDNODE_LEAF(CLASS)"
  },
  {
    "label": "HANDLE_MDNODE_BRANCH()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "HANDLE_MDNODE_BRANCH(CLASS) HANDLE_MDNODE_LEAF(CLASS)"
  },
  {
    "label": "MDNode()",
    "kind": "Method",
    "detail": "Function (class ReplaceableMetadataImpl ; class LLVMContextImpl ;)",
    "insertText": "MDNode(const MDNode &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const MDNode &)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void* operator)",
    "insertText": "new(size_t)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (unsigned NumOperands ; unsigned NumUnresolved ; protected : ContextAndReplaceableUses Context ; void* operator)",
    "insertText": "new(size_t Size, unsigned NumOps)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (void operator)",
    "insertText": "delete(void *Mem)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (void operator)",
    "insertText": "delete(void *Mem, unsigned)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (MDNode::operator)",
    "insertText": "delete(Mem)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (} void operator)",
    "insertText": "delete(void *, unsigned, bool)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Constructor throws?\")"
  },
  {
    "label": "MDNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MDNode(LLVMContext &Context, unsigned ID, StorageType Storage, ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None)"
  },
  {
    "label": "MDNode()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "MDNode()"
  },
  {
    "label": "dropAllReferences()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dropAllReferences()"
  },
  {
    "label": "mutable_begin()",
    "kind": "Method",
    "detail": "Function (MDOperand*)",
    "insertText": "mutable_begin()"
  },
  {
    "label": "mutable_end()",
    "kind": "Method",
    "detail": "Function (} MDOperand*)",
    "insertText": "mutable_end()"
  },
  {
    "label": "mutable_operands()",
    "kind": "Method",
    "detail": "Function (} typedef iterator_range<MDOperand*> mutable_op_range ; mutable_op_range)",
    "insertText": "mutable_operands()"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} public : MDTuple*)",
    "insertText": "get(LLVMContext &Context, ArrayRef<Metadata *> MDs)"
  },
  {
    "label": "getIfExists()",
    "kind": "Method",
    "detail": "Function (MDTuple*)",
    "insertText": "getIfExists(LLVMContext &Context, ArrayRef<Metadata *> MDs)"
  },
  {
    "label": "getDistinct()",
    "kind": "Method",
    "detail": "Function (MDTuple*)",
    "insertText": "getDistinct(LLVMContext &Context, ArrayRef<Metadata *> MDs)"
  },
  {
    "label": "getTemporary()",
    "kind": "Method",
    "detail": "Function (TempMDTuple)",
    "insertText": "getTemporary(LLVMContext &Context, ArrayRef<Metadata *> MDs)"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (TempMDNode)",
    "insertText": "clone()"
  },
  {
    "label": "deleteTemporary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deleteTemporary(MDNode *N)"
  },
  {
    "label": "replaceOperandWith()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "replaceOperandWith(unsigned I, Metadata *New)"
  },
  {
    "label": "isResolved()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isResolved()"
  },
  {
    "label": "isUniqued()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isUniqued()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isTemporary() && \"Expected temporary node\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isResolved() && \"Expected RAUW support\")"
  },
  {
    "label": "getReplaceableUses()",
    "kind": "Method",
    "detail": "Function (Context .)",
    "insertText": "getReplaceableUses()->replaceAllUsesWith(MD)"
  },
  {
    "label": "resolveCycles()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resolveCycles()"
  },
  {
    "label": "replaceWithPermanent()",
    "kind": "Method",
    "detail": "Function (template<class T> std::enable_if<std::is_base_of<MDNode,T>::value,T*>::type)",
    "insertText": "replaceWithPermanent(std::unique_ptr<T, TempMDNodeDeleter> N)"
  },
  {
    "label": "replaceWithUniqued()",
    "kind": "Method",
    "detail": "Function (} template<class T> std::enable_if<std::is_base_of<MDNode,T>::value,T*>::type)",
    "insertText": "replaceWithUniqued(std::unique_ptr<T, TempMDNodeDeleter> N)"
  },
  {
    "label": "replaceWithDistinct()",
    "kind": "Method",
    "detail": "Function (} template<class T> std::enable_if<std::is_base_of<MDNode,T>::value,T*>::type)",
    "insertText": "replaceWithDistinct(std::unique_ptr<T, TempMDNodeDeleter> N)"
  },
  {
    "label": "replaceWithPermanentImpl()",
    "kind": "Method",
    "detail": "Function (} private : MDNode*)",
    "insertText": "replaceWithPermanentImpl()"
  },
  {
    "label": "replaceWithUniquedImpl()",
    "kind": "Method",
    "detail": "Function (MDNode*)",
    "insertText": "replaceWithUniquedImpl()"
  },
  {
    "label": "replaceWithDistinctImpl()",
    "kind": "Method",
    "detail": "Function (MDNode*)",
    "insertText": "replaceWithDistinctImpl()"
  },
  {
    "label": "setOperand()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "setOperand(unsigned I, Metadata *New)"
  },
  {
    "label": "storeDistinctInContext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "storeDistinctInContext()"
  },
  {
    "label": "storeImpl()",
    "kind": "Method",
    "detail": "Function (template<class T,class StoreT> T*)",
    "insertText": "storeImpl(T *N, StorageType Storage, StoreT &Store)"
  },
  {
    "label": "handleChangedOperand()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "handleChangedOperand(void *Ref, Metadata *New)"
  },
  {
    "label": "resolve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resolve()"
  },
  {
    "label": "resolveAfterOperandChange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resolveAfterOperandChange(Metadata *Old, Metadata *New)"
  },
  {
    "label": "decrementUnresolvedOperandCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decrementUnresolvedOperandCount()"
  },
  {
    "label": "countUnresolvedOperands()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "countUnresolvedOperands()"
  },
  {
    "label": "makeUniqued()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "makeUniqued()"
  },
  {
    "label": "makeDistinct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "makeDistinct()"
  },
  {
    "label": "deleteAsSubclass()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "deleteAsSubclass()"
  },
  {
    "label": "uniquify()",
    "kind": "Method",
    "detail": "Function (private : MDNode*)",
    "insertText": "uniquify()"
  },
  {
    "label": "eraseFromStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eraseFromStore()"
  },
  {
    "label": "dispatchRecalculateHash()",
    "kind": "Method",
    "detail": "Function (template<class NodeTy> struct HasCachedHash ; template<class NodeTy> void)",
    "insertText": "dispatchRecalculateHash(NodeTy *N, std::true_type)"
  },
  {
    "label": "recalculateHash()",
    "kind": "Method",
    "detail": "Function (N ->)",
    "insertText": "recalculateHash()"
  },
  {
    "label": "dispatchRecalculateHash()",
    "kind": "Method",
    "detail": "Function (} template<class NodeTy> void)",
    "insertText": "dispatchRecalculateHash(NodeTy *N, std::false_type)"
  },
  {
    "label": "dispatchResetHash()",
    "kind": "Method",
    "detail": "Function (} template<class NodeTy> void)",
    "insertText": "dispatchResetHash(NodeTy *N, std::true_type)"
  },
  {
    "label": "setHash()",
    "kind": "Method",
    "detail": "Function (N ->)",
    "insertText": "setHash(0)"
  },
  {
    "label": "dispatchResetHash()",
    "kind": "Method",
    "detail": "Function (} template<class NodeTy> void)",
    "insertText": "dispatchResetHash(NodeTy *N, std::false_type)"
  },
  {
    "label": "op_begin()",
    "kind": "Method",
    "detail": "Function (} public : typedef const MDOperand* op_iterator ; typedef iterator_range<op_iterator> op_range ; op_iterator)",
    "insertText": "op_begin()"
  },
  {
    "label": "op_end()",
    "kind": "Method",
    "detail": "Function (} op_iterator)",
    "insertText": "op_end()"
  },
  {
    "label": "operands()",
    "kind": "Method",
    "detail": "Function (} op_range)",
    "insertText": "operands()"
  },
  {
    "label": "getOperand()",
    "kind": "Method",
    "detail": "Function (} const MDOperand&)",
    "insertText": "getOperand(unsigned I)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(I < NumOperands && \"Out of range\")"
  },
  {
    "label": "getNumOperands()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getNumOperands()"
  },
  {
    "label": "isTBAAVtableAccess()",
    "kind": "Method",
    "detail": "Function (# include \" llvm / IR / Metadata . def \" } } bool)",
    "insertText": "isTBAAVtableAccess()"
  },
  {
    "label": "concatenate()",
    "kind": "Method",
    "detail": "Function (MDNode*)",
    "insertText": "concatenate(MDNode *A, MDNode *B)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (MDNode*)",
    "insertText": "intersect(MDNode *A, MDNode *B)"
  },
  {
    "label": "getMostGenericTBAA()",
    "kind": "Method",
    "detail": "Function (MDNode*)",
    "insertText": "getMostGenericTBAA(MDNode *A, MDNode *B)"
  },
  {
    "label": "getMostGenericFPMath()",
    "kind": "Method",
    "detail": "Function (MDNode*)",
    "insertText": "getMostGenericFPMath(MDNode *A, MDNode *B)"
  },
  {
    "label": "getMostGenericRange()",
    "kind": "Method",
    "detail": "Function (MDNode*)",
    "insertText": "getMostGenericRange(MDNode *A, MDNode *B)"
  },
  {
    "label": "getMostGenericAliasScope()",
    "kind": "Method",
    "detail": "Function (MDNode*)",
    "insertText": "getMostGenericAliasScope(MDNode *A, MDNode *B)"
  },
  {
    "label": "printAsBody()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printAsBody(raw_ostream &OS, const Module *M = nullptr)"
  },
  {
    "label": "printAsBody()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printAsBody(raw_ostream &OS, ModuleSlotTracker &MST, const Module *M = nullptr)"
  },
  {
    "label": "MDTuple()",
    "kind": "Method",
    "detail": "Function (} ; class MDTuple : public MDNode { class LLVMContextImpl ; class MDNode ;)",
    "insertText": "MDTuple(LLVMContext &C, StorageType Storage, unsigned Hash, ArrayRef<Metadata *> Vals) : MDNode(C, MDTupleKind, Storage, Vals)"
  },
  {
    "label": "setHash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setHash(Hash)"
  },
  {
    "label": "MDTuple()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "MDTuple()"
  },
  {
    "label": "setHash()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setHash(unsigned Hash)"
  },
  {
    "label": "getImpl()",
    "kind": "Method",
    "detail": "Function (MDTuple*)",
    "insertText": "getImpl(LLVMContext &Context, ArrayRef<Metadata *> MDs, StorageType Storage, bool ShouldCreate = true)"
  },
  {
    "label": "cloneImpl()",
    "kind": "Method",
    "detail": "Function (TempMDTuple)",
    "insertText": "cloneImpl()"
  },
  {
    "label": "getHash()",
    "kind": "Method",
    "detail": "Function (} public : unsigned)",
    "insertText": "getHash()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(MDNode *Node)"
  },
  {
    "label": "deleteTemporary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deleteTemporary(Node)"
  },
  {
    "label": "TypedMDOperandIterator()",
    "kind": "Method",
    "detail": "Function (} template<class T> class TypedMDOperandIterator { MDNode::op_iterator I = nullptr ; public : using iterator_category = std::input_iterator_tag ; using value_type = T* ; using difference_type = std::ptrdiff_t ; using pointer = void ; using reference = T* ;)",
    "insertText": "TypedMDOperandIterator()"
  },
  {
    "label": "TypedMDOperandIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TypedMDOperandIterator(MDNode::op_iterator I) : I(I)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + I ; return* this ; } TypedMDOperandIterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "Temp()",
    "kind": "Method",
    "detail": "Function (TypedMDOperandIterator)",
    "insertText": "Temp(*this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + I ; return Temp ; } bool)",
    "insertText": "operator(const TypedMDOperandIterator &X)"
  },
  {
    "label": "MDTupleTypedArrayWrapper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MDTupleTypedArrayWrapper(const MDTuple *N) : N(N)"
  },
  {
    "label": "MDTupleTypedArrayWrapper()",
    "kind": "Method",
    "detail": "Function (} template<class U>)",
    "insertText": "MDTupleTypedArrayWrapper(const MDTupleTypedArrayWrapper<U> &Other, typename std::enable_if<std::is_convertible<U *, T *>::value>::type * = nullptr) : N(Other.get())"
  },
  {
    "label": "MDTupleTypedArrayWrapper()",
    "kind": "Method",
    "detail": "Function (} template<class U>)",
    "insertText": "MDTupleTypedArrayWrapper(const MDTupleTypedArrayWrapper<U> &Other, typename std::enable_if<!std::is_convertible<U *, T *>::value>::type * = nullptr) : N(Other.get())"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "size()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "operator(unsigned I)"
  },
  {
    "label": "NamedMDNode()",
    "kind": "Method",
    "detail": "Function (# include \" llvm / IR / Metadata . def \" class NamedMDNode : public ilist_node<NamedMDNode> { class SymbolTableListTraits<NamedMDNode,Module> ; struct ilist_traits<NamedMDNode> ; class LLVMContextImpl ; class Module ;)",
    "insertText": "NamedMDNode(const NamedMDNode &)"
  },
  {
    "label": "setParent()",
    "kind": "Method",
    "detail": "Function (std::string Name ; Module* Parent ; void* Operands ; void)",
    "insertText": "setParent(Module *M)"
  },
  {
    "label": "NamedMDNode()",
    "kind": "Method",
    "detail": "Function (Parent = M ; })",
    "insertText": "NamedMDNode(const Twine &N)"
  },
  {
    "label": "op_iterator_impl()",
    "kind": "Method",
    "detail": "Function (template<class T1,class T2> class op_iterator_impl { const NamedMDNode* Node ; unsigned Idx ;)",
    "insertText": "op_iterator_impl(const NamedMDNode *N, unsigned i) : Node(N), Idx(i)"
  },
  {
    "label": "op_iterator_impl()",
    "kind": "Method",
    "detail": "Function (} class NamedMDNode ; public : using iterator_category = std::bidirectional_iterator_tag ; using value_type = T2 ; using difference_type = std::ptrdiff_t ; using pointer = value_type* ; using reference = value_type& ;)",
    "insertText": "op_iterator_impl() : Node(nullptr), Idx(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const op_iterator_impl &o)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (op_iterator_impl)",
    "insertText": "tmp(*this)"
  },
  {
    "label": "eraseFromParent()",
    "kind": "Method",
    "detail": "Function (} } ; public : void)",
    "insertText": "eraseFromParent()"
  },
  {
    "label": "NamedMDNode()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "NamedMDNode()"
  },
  {
    "label": "getParent()",
    "kind": "Method",
    "detail": "Function (Module*)",
    "insertText": "getParent()"
  },
  {
    "label": "addOperand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addOperand(MDNode *M)"
  },
  {
    "label": "setOperand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOperand(unsigned I, MDNode *New)"
  },
  {
    "label": "getName()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "getName()"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &ROS)"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dump()"
  }
]