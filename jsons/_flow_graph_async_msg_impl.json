[
  {
    "label": "async_storage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "async_storage"
  },
  {
    "label": "async_msg",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "async_msg"
  },
  {
    "label": "receiver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "receiver"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "internal"
  },
  {
    "label": "async_storage()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB__flow_graph_async_msg_impl_H # define __TBB__flow_graph_async_msg_impl_H # ifndef __TBB_flow_graph_H # error Do not # include this internal file directly ; use public TBB headers instead . # endif namespace internal { template<T> class async_storage { public : typedef receiver<T> async_storage_client ;)",
    "insertText": "async_storage() : my_graph(nullptr)"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (my_data_ready . store<)",
    "insertText": "relaxed(false)"
  },
  {
    "label": "async_storage()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "async_storage()"
  },
  {
    "label": "release_wait()",
    "kind": "Method",
    "detail": "Function (my_graph ->)",
    "insertText": "release_wait()"
  },
  {
    "label": "async_storage()",
    "kind": "Method",
    "detail": "Function (my_graph = nullptr ; } } template<C>)",
    "insertText": "async_storage(C&& data) : my_graph(nullptr), my_data( std::forward<C>(data))"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (using namespace tbb::internal ;)",
    "insertText": "__TBB_STATIC_ASSERT((is_same_type<typename strip<C>::type, typename strip<T>::type>::value), \"incoming type must be T\")"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (my_data_ready . store<)",
    "insertText": "relaxed(true)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} template<C> bool)",
    "insertText": "set(C&& data)"
  },
  {
    "label": "locker()",
    "kind": "Method",
    "detail": "Function ({ tbb::spin_mutex::scoped_lock)",
    "insertText": "locker(my_mutex)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(false, \"double set() call\")"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (my_data_ready . store<)",
    "insertText": "release(true)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(typename subscriber_list_type::iterator it = my_clients.begin(); it != my_clients.end(); ++it)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(my_graph)"
  },
  {
    "label": "subscribe()",
    "kind": "Method",
    "detail": "Function (my_graph = nullptr ; } return true ; } task*)",
    "insertText": "subscribe(async_storage_client& client, graph& g)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(*it != &client, \"unexpected double subscription\")"
  },
  {
    "label": "reserve_wait()",
    "kind": "Method",
    "detail": "Function (} # endif my_graph =& g ; my_graph ->)",
    "insertText": "reserve_wait()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (my_clients .)",
    "insertText": "push_back(&client)"
  },
  {
    "label": "async_msg()",
    "kind": "Method",
    "detail": "Function (} private : graph* my_graph ; tbb::spin_mutex my_mutex ; tbb::atomic<bool> my_data_ready ; T my_data ; typedef std::vector<async_storage_client*> subscriber_list_type ; subscriber_list_type my_clients ; } ; } template<T> class async_msg { template<> class receiver ; template<,> struct internal::async_helpers ; public : typedef T async_msg_data_type ;)",
    "insertText": "async_msg() : my_storage(std::make_shared< internal::async_storage<T> >())"
  },
  {
    "label": "async_msg()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "async_msg(const T& t) : my_storage(std::make_shared< internal::async_storage<T> >(t))"
  },
  {
    "label": "async_msg()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "async_msg(T&& t) : my_storage(std::make_shared< internal::async_storage<T> >( std::move(t) ))"
  },
  {
    "label": "async_msg()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "async_msg()"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set(const T& t)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (my_storage ->)",
    "insertText": "set(t)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set(T&& t)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (my_storage ->)",
    "insertText": "set(std::move(t))"
  },
  {
    "label": "finalize()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "finalize()"
  }
]