[
  {
    "label": "covar()",
    "kind": "Method",
    "detail": "Function (namespace Eigen { namespace internal { template<Scalar> void)",
    "insertText": "covar(Matrix< Scalar, Dynamic, Dynamic > &r, const VectorXi &ipvt, Scalar tol = std::sqrt(NumTraits<Scalar>::epsilon()))"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (using std::abs ; typedef DenseIndex Index ; Index i,j,k,l,ii,jj ; bool sing ; Scalar temp ; const Index n = r .)",
    "insertText": "cols()"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (const Scalar tolr = tol*)",
    "insertText": "abs(r(0,0))"
  },
  {
    "label": "wa()",
    "kind": "Method",
    "detail": "Function (Matrix<Scalar,Dynamic,1>)",
    "insertText": "wa(n)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(ipvt.size()==n)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (l = - 1 ;)",
    "insertText": "for(k = 0; k < n; ++k) if (abs(r(k,k)) > tolr)"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "r(k,k) = 1. / r(k,k)"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (temp =)",
    "insertText": "r(k,k) * r(j,k)"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "r(j,k)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (r .)",
    "insertText": "col(k).head(j+1) -= r.col(j).head(j+1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} l = k ; })",
    "insertText": "for(k = 0; k <= l; ++k)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (r .)",
    "insertText": "col(k).head(k+1) *= r(k,k)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(j = 0; j < n; ++j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (jj = ipvt [ j ] ; sing = j> l ;)",
    "insertText": "for(i = 0; i <= j; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ii = ipvt [ i ] ;)",
    "insertText": "if(ii > jj) r(ii,jj) = r(i,j)"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (} wa [ jj ] =)",
    "insertText": "r(j,j)"
  },
  {
    "label": "topLeftCorner()",
    "kind": "Method",
    "detail": "Function (} r .)",
    "insertText": "topLeftCorner(n,n).template triangularView<StrictlyUpper>() = r.topLeftCorner(n,n).transpose()"
  },
  {
    "label": "diagonal()",
    "kind": "Method",
    "detail": "Function (r .)",
    "insertText": "diagonal()"
  }
]