[
  {
    "label": "storage_kind_to_evaluator_kind",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "storage_kind_to_evaluator_kind"
  },
  {
    "label": "storage_kind_to_shape",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "storage_kind_to_shape"
  },
  {
    "label": "ternary_evaluator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ternary_evaluator"
  },
  {
    "label": "binary_evaluator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "binary_evaluator"
  },
  {
    "label": "unary_evaluator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "unary_evaluator"
  },
  {
    "label": "evaluator_traits_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "evaluator_traits_base"
  },
  {
    "label": "evaluator_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "evaluator_traits"
  },
  {
    "label": "evaluator_assume_aliasing",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "evaluator_assume_aliasing"
  },
  {
    "label": "evaluator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "evaluator"
  },
  {
    "label": "evaluator_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "evaluator_base"
  },
  {
    "label": "plainobjectbase_evaluator_data",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "plainobjectbase_evaluator_data"
  },
  {
    "label": "nullary_wrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "nullary_wrapper"
  },
  {
    "label": "nullary_wrapper_workaround_msvc",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "nullary_wrapper_workaround_msvc"
  },
  {
    "label": "Data",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Data"
  },
  {
    "label": "mapbase_evaluator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "mapbase_evaluator"
  },
  {
    "label": "block_evaluator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "block_evaluator"
  },
  {
    "label": "evaluator_wrapper_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "evaluator_wrapper_base"
  },
  {
    "label": "reverse_packet_cond",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "reverse_packet_cond"
  },
  {
    "label": "EvalToTemp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "EvalToTemp"
  },
  {
    "label": "traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "traits"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_COREEVALUATORS_H # define EIGEN_COREEVALUATORS_H namespace Eigen { namespace internal { template<StorageKind> struct storage_kind_to_evaluator_kind { typedef IndexBased Kind ; } ; template<StorageKind> struct storage_kind_to_shape ; template<> struct storage_kind_to_shape<Dense> { typedef DenseShape Shape ; } ; template<> struct storage_kind_to_shape<SolverStorage> { typedef SolverShape Shape ; } ; template<> struct storage_kind_to_shape<PermutationStorage> { typedef PermutationShape Shape ; } ; template<> struct storage_kind_to_shape<TranspositionsStorage> { typedef TranspositionsShape Shape ; } ; template<T,Arg1Kind = evaluator_traits<T::Arg1>::Kind,Arg2Kind = evaluator_traits<T::Arg2>::Kind,Arg3Kind = evaluator_traits<T::Arg3>::Kind,Arg1Scalar = traits<T::Arg1>::Scalar,Arg2Scalar = traits<T::Arg2>::Scalar,Arg3Scalar = traits<T::Arg3>::Scalar> struct ternary_evaluator ; template<T,LhsKind = evaluator_traits<T::Lhs>::Kind,RhsKind = evaluator_traits<T::Rhs>::Kind,LhsScalar = traits<T::Lhs>::Scalar,RhsScalar = traits<T::Rhs>::Scalar> struct binary_evaluator ; template<T,Kind = evaluator_traits<T::NestedExpression>::Kind,Scalar = T::Scalar> struct unary_evaluator ; template<T> struct evaluator_traits_base { typedef storage_kind_to_evaluator_kind<traits<T>::StorageKind>::Kind Kind ; typedef storage_kind_to_shape<traits<T>::StorageKind>::Shape Shape ; } ; template<T> struct evaluator_traits : public evaluator_traits_base<T> { } ; template<T,Shape = evaluator_traits<T>::Shape> struct evaluator_assume_aliasing { const bool value = false ; } ; template<T> struct evaluator : public unary_evaluator<T> { typedef unary_evaluator<T> Base ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator(const T& xpr) : Base(xpr)"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct evaluator<const T> : evaluator<T> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator(const T& xpr) : evaluator<T>(xpr)"
  },
  {
    "label": "evaluator_base()",
    "kind": "Method",
    "detail": "Function (} } ; template<ExpressionType> struct evaluator_base { typedef traits<ExpressionType> ExpressionTraits ; enum { Alignment = 0 } ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator_base()"
  },
  {
    "label": "evaluator_base()",
    "kind": "Method",
    "detail": "Function (} private : EIGEN_DEVICE_FUNC)",
    "insertText": "evaluator_base(const evaluator_base&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC const evaluator_base&)",
    "insertText": "operator(const evaluator_base&)"
  },
  {
    "label": "plainobjectbase_evaluator_data()",
    "kind": "Method",
    "detail": "Function (} ; template<Scalar,int OuterStride> class plainobjectbase_evaluator_data { public : EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "plainobjectbase_evaluator_data(const Scalar* ptr, Index outerStride) : data(ptr)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_INTERNAL_DEBUGGING)",
    "insertText": "EIGEN_UNUSED_VARIABLE(outerStride)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "eigen_internal_assert(outerStride==OuterStride)"
  },
  {
    "label": "outerStride()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR Index)",
    "insertText": "outerStride()"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator() : m_d(0,OuterStrideAtCompileTime)"
  },
  {
    "label": "EIGEN_INTERNAL_CHECK_COST_VALUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost)"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator(const PlainObjectType& m) : m_d(m.data(),IsVectorAtCompileTime ? 0 : m.outerStride())"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType)",
    "insertText": "coeff(Index row, Index col)"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType)",
    "insertText": "coeff(Index index)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar&)",
    "insertText": "coeffRef(Index index)"
  },
  {
    "label": "packet()",
    "kind": "Method",
    "detail": "Function (} template<int LoadMode,PacketType> EIGEN_STRONG_INLINE PacketType)",
    "insertText": "packet(Index row, Index col)"
  },
  {
    "label": "packet()",
    "kind": "Method",
    "detail": "Function (} template<int LoadMode,PacketType> EIGEN_STRONG_INLINE PacketType)",
    "insertText": "packet(Index index)"
  },
  {
    "label": "writePacket()",
    "kind": "Method",
    "detail": "Function (} template<int StoreMode,PacketType> EIGEN_STRONG_INLINE void)",
    "insertText": "writePacket(Index row, Index col, const PacketType& x)"
  },
  {
    "label": "writePacket()",
    "kind": "Method",
    "detail": "Function (} template<int StoreMode,PacketType> EIGEN_STRONG_INLINE void)",
    "insertText": "writePacket(Index index, const PacketType& x)"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (} protected : plainobjectbase_evaluator_data<Scalar,OuterStrideAtCompileTime> m_d ; } ; template<Scalar,int Rows,int Cols,int Options,int MaxRows,int MaxCols> struct evaluator<Matrix<Scalar,Rows,Cols,Options,MaxRows,MaxCols>> : evaluator<PlainObjectBase<Matrix<Scalar,Rows,Cols,Options,MaxRows,MaxCols>>> { typedef Matrix<Scalar,Rows,Cols,Options,MaxRows,MaxCols> XprType ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator()"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator(const XprType& m) : evaluator<PlainObjectBase<XprType> >(m)"
  },
  {
    "label": "unary_evaluator()",
    "kind": "Method",
    "detail": "Function (} } ; template<ArgType> struct unary_evaluator<Transpose<ArgType>,IndexBased> : evaluator_base<Transpose<ArgType>> { typedef Transpose<ArgType> XprType ; enum { CoeffReadCost = evaluator<ArgType>::CoeffReadCost,Flags = evaluator<ArgType>::Flags ^ RowMajorBit,Alignment = evaluator<ArgType>::Alignment } ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "unary_evaluator(const XprType& t) : m_argImpl(t.nestedExpression())"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar&)",
    "insertText": "coeffRef(Index row, Index col)"
  },
  {
    "label": "PacketType()",
    "kind": "Method",
    "detail": "Function (m_argImpl . template writePacket<StoreMode,)",
    "insertText": "PacketType(col, row, x)"
  },
  {
    "label": "PacketType()",
    "kind": "Method",
    "detail": "Function (m_argImpl . template writePacket<StoreMode,)",
    "insertText": "PacketType(index, x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} protected : evaluator<ArgType> m_argImpl ; } ; template<Scalar,NullaryOp,bool has_nullary = has_nullary_operator<NullaryOp>::value,bool has_unary = has_unary_operator<NullaryOp>::value,bool has_binary = has_binary_operator<NullaryOp>::value> struct nullary_wrapper { template<IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "operator()(const NullaryOp& op, IndexType i, IndexType j)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "operator()(const NullaryOp& op, IndexType i)"
  },
  {
    "label": "packetOp()",
    "kind": "Method",
    "detail": "Function (} template<T,IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T)",
    "insertText": "packetOp(const NullaryOp& op, IndexType i, IndexType j)"
  },
  {
    "label": "packetOp()",
    "kind": "Method",
    "detail": "Function (} template<T,IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T)",
    "insertText": "packetOp(const NullaryOp& op, IndexType i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar,NullaryOp> struct nullary_wrapper<Scalar,NullaryOp,true,false,false> { template<IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "operator()(const NullaryOp& op, IndexType=0, IndexType=0)"
  },
  {
    "label": "packetOp()",
    "kind": "Method",
    "detail": "Function (} template<T,IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T)",
    "insertText": "packetOp(const NullaryOp& op, IndexType=0, IndexType=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar,NullaryOp> struct nullary_wrapper<Scalar,NullaryOp,false,false,true> { template<IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar)",
    "insertText": "operator()(const NullaryOp& op, IndexType i, IndexType j=0)"
  },
  {
    "label": "packetOp()",
    "kind": "Method",
    "detail": "Function (} template<T,IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T)",
    "insertText": "packetOp(const NullaryOp& op, IndexType i, IndexType j=0)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(i==0 || j==0)"
  },
  {
    "label": "nullary_wrapper_workaround_msvc()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar,NullaryOp> struct nullary_wrapper<Scalar,NullaryOp,false,false,false> { } ; # if 0&& EIGEN_COMP_MSVC> 0 template<T> struct nullary_wrapper_workaround_msvc {)",
    "insertText": "nullary_wrapper_workaround_msvc(const T&)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (operator)",
    "insertText": "T()"
  },
  {
    "label": "Flags()",
    "kind": "Method",
    "detail": "Function (} } ; # endif template<NullaryOp,PlainObjectType> struct evaluator<CwiseNullaryOp<NullaryOp,PlainObjectType>> : evaluator_base<CwiseNullaryOp<NullaryOp,PlainObjectType>> { typedef CwiseNullaryOp<NullaryOp,PlainObjectType> XprType ; typedef internal::remove_all<PlainObjectType>::type PlainObjectTypeCleaned ; enum { CoeffReadCost = internal::functor_traits<NullaryOp>::Cost,)",
    "insertText": "Flags(evaluator<PlainObjectTypeCleaned>::Flags & ( HereditaryBits | (functor_has_linear_access<NullaryOp>::ret ? LinearAccessBit : 0) | (functor_traits<NullaryOp>::PacketAccess ? PacketAccessBit : 0))) | (functor_traits<NullaryOp>::IsRepeatable ? 0 : EvalBeforeNestingBit)"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC)",
    "insertText": "evaluator(const XprType& n) : m_functor(n.functor()), m_wrapper()"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (} typedef XprType::CoeffReturnType CoeffReturnType ; template<IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType)",
    "insertText": "coeff(IndexType row, IndexType col)"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (} template<IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType)",
    "insertText": "coeff(IndexType index)"
  },
  {
    "label": "packet()",
    "kind": "Method",
    "detail": "Function (} template<int LoadMode,PacketType,IndexType> EIGEN_STRONG_INLINE PacketType)",
    "insertText": "packet(IndexType row, IndexType col)"
  },
  {
    "label": "packet()",
    "kind": "Method",
    "detail": "Function (} template<int LoadMode,PacketType,IndexType> EIGEN_STRONG_INLINE PacketType)",
    "insertText": "packet(IndexType index)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} protected : const NullaryOp m_functor ; const internal::nullary_wrapper<CoeffReturnType,NullaryOp> m_wrapper ; } ; template<UnaryOp,ArgType> struct unary_evaluator<CwiseUnaryOp<UnaryOp,ArgType>,IndexBased> : evaluator_base<CwiseUnaryOp<UnaryOp,ArgType>> { typedef CwiseUnaryOp<UnaryOp,ArgType> XprType ; enum { CoeffReadCost =)",
    "insertText": "int(evaluator<ArgType>::CoeffReadCost) + int(functor_traits<UnaryOp>::Cost), Flags = evaluator<ArgType>::Flags & (HereditaryBits | LinearAccessBit | (functor_traits<UnaryOp>::PacketAccess ? PacketAccessBit : 0))"
  },
  {
    "label": "unary_evaluator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "unary_evaluator(const XprType& op) : m_d(op)"
  },
  {
    "label": "EIGEN_INTERNAL_CHECK_COST_VALUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<UnaryOp>::Cost)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (} protected : struct Data { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "Data(const XprType& xpr) : op(xpr.functor()), argImpl(xpr.nestedExpression())"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const UnaryOp&)",
    "insertText": "func()"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} } ; template<TernaryOp,Arg1,Arg2,Arg3> struct ternary_evaluator<CwiseTernaryOp<TernaryOp,Arg1,Arg2,Arg3>,IndexBased,IndexBased> : evaluator_base<CwiseTernaryOp<TernaryOp,Arg1,Arg2,Arg3>> { typedef CwiseTernaryOp<TernaryOp,Arg1,Arg2,Arg3> XprType ; enum { CoeffReadCost =)",
    "insertText": "int(evaluator<Arg1>::CoeffReadCost) + int(evaluator<Arg2>::CoeffReadCost) + int(evaluator<Arg3>::CoeffReadCost) + int(functor_traits<TernaryOp>::Cost), Arg1Flags = evaluator<Arg1>::Flags, Arg2Flags = evaluator<Arg2>::Flags, Arg3Flags = evaluator<Arg3>::Flags, SameType = is_same<typename Arg1::Scalar,typename Arg2::Scalar>::value && is_same<typename Arg1::Scalar,typename Arg3::Scalar>::value, StorageOrdersAgree = (int(Arg1Flags)&RowMajorBit)==(int(Arg2Flags)&RowMajorBit) && (int(Arg1Flags)&RowMajorBit)==(int(Arg3Flags)&RowMajorBit), Flags0 = (int(Arg1Flags) | int(Arg2Flags) | int(Arg3Flags)) & ( HereditaryBits | (int(Arg1Flags) & int(Arg2Flags) & int(Arg3Flags) & ( (StorageOrdersAgree ? LinearAccessBit : 0) | (functor_traits<TernaryOp>::PacketAccess && StorageOrdersAgree && SameType ? PacketAccessBit : 0) ) ) ), Flags = (Flags0 & ~RowMajorBit) | (Arg1Flags & RowMajorBit), Alignment = EIGEN_PLAIN_ENUM_MIN( EIGEN_PLAIN_ENUM_MIN(evaluator<Arg1>::Alignment, evaluator<Arg2>::Alignment), evaluator<Arg3>::Alignment)"
  },
  {
    "label": "ternary_evaluator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC)",
    "insertText": "ternary_evaluator(const XprType& xpr) : m_d(xpr)"
  },
  {
    "label": "EIGEN_INTERNAL_CHECK_COST_VALUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<TernaryOp>::Cost)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (} protected : struct Data { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "Data(const XprType& xpr) : op(xpr.functor()), arg1Impl(xpr.arg1()), arg2Impl(xpr.arg2()), arg3Impl(xpr.arg3())"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} } ; template<BinaryOp,Lhs,Rhs> struct binary_evaluator<CwiseBinaryOp<BinaryOp,Lhs,Rhs>,IndexBased,IndexBased> : evaluator_base<CwiseBinaryOp<BinaryOp,Lhs,Rhs>> { typedef CwiseBinaryOp<BinaryOp,Lhs,Rhs> XprType ; enum { CoeffReadCost =)",
    "insertText": "int(evaluator<Lhs>::CoeffReadCost) + int(evaluator<Rhs>::CoeffReadCost) + int(functor_traits<BinaryOp>::Cost), LhsFlags = evaluator<Lhs>::Flags, RhsFlags = evaluator<Rhs>::Flags, SameType = is_same<typename Lhs::Scalar,typename Rhs::Scalar>::value, StorageOrdersAgree = (int(LhsFlags)&RowMajorBit)==(int(RhsFlags)&RowMajorBit), Flags0 = (int(LhsFlags) | int(RhsFlags)) & ( HereditaryBits | (int(LhsFlags) & int(RhsFlags) & ( (StorageOrdersAgree ? LinearAccessBit : 0) | (functor_traits<BinaryOp>::PacketAccess && StorageOrdersAgree && SameType ? PacketAccessBit : 0) ) ) ), Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit), Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<Lhs>::Alignment,evaluator<Rhs>::Alignment)"
  },
  {
    "label": "binary_evaluator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "binary_evaluator(const XprType& xpr) : m_d(xpr)"
  },
  {
    "label": "EIGEN_INTERNAL_CHECK_COST_VALUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<BinaryOp>::Cost)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (} protected : struct Data { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "Data(const XprType& xpr) : op(xpr.functor()), lhsImpl(xpr.lhs()), rhsImpl(xpr.rhs())"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT(EIGEN_IMPLIES(evaluator<Derived>::Flags&PacketAccessBit, internal::inner_stride_at_compile_time<Derived>::ret==1), PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1)"
  },
  {
    "label": "rowStride()",
    "kind": "Method",
    "detail": "Function (PointerType ptr = m_data + row*)",
    "insertText": "rowStride() + col * colStride()"
  },
  {
    "label": "StoreMode()",
    "kind": "Method",
    "detail": "Function (internal::pstoret<Scalar,PacketType,)",
    "insertText": "StoreMode(m_data + index * m_innerStride.value(), x)"
  },
  {
    "label": "rowStride()",
    "kind": "Method",
    "detail": "Function (} protected : EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR Index)",
    "insertText": "rowStride()"
  },
  {
    "label": "colStride()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR Index)",
    "insertText": "colStride()"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} PointerType m_data ; const internal::variable_if_dynamic<Index,XprType::InnerStrideAtCompileTime> m_innerStride ; const internal::variable_if_dynamic<Index,XprType::OuterStrideAtCompileTime> m_outerStride ; } ; template<PlainObjectType,int MapOptions,StrideType> struct evaluator<Map<PlainObjectType,MapOptions,StrideType>> : public mapbase_evaluator<Map<PlainObjectType,MapOptions,StrideType>,PlainObjectType> { typedef Map<PlainObjectType,MapOptions,StrideType> XprType ; typedef XprType::Scalar Scalar ; typedef packet_traits<Scalar>::type PacketScalar ; enum { InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime = = 0 ?)",
    "insertText": "int(PlainObjectType::InnerStrideAtCompileTime) : int(StrideType::InnerStrideAtCompileTime), OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0 ? int(PlainObjectType::OuterStrideAtCompileTime) : int(StrideType::OuterStrideAtCompileTime), HasNoInnerStride = InnerStrideAtCompileTime == 1, HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0, HasNoStride = HasNoInnerStride && HasNoOuterStride, IsDynamicSize = PlainObjectType::SizeAtCompileTime==Dynamic, PacketAccessMask = bool(HasNoInnerStride) ? ~int(0) : ~int(PacketAccessBit), LinearAccessMask = bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime) ? ~int(0) : ~int(LinearAccessBit), Flags = int( evaluator<PlainObjectType>::Flags) & (LinearAccessMask&PacketAccessMask), Alignment = int(MapOptions)&int(AlignedMask)"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC)",
    "insertText": "evaluator(const XprType& map) : mapbase_evaluator<XprType, PlainObjectType>(map)"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (} } ; template<PlainObjectType,int RefOptions,StrideType> struct evaluator<Ref<PlainObjectType,RefOptions,StrideType>> : public mapbase_evaluator<Ref<PlainObjectType,RefOptions,StrideType>,PlainObjectType> { typedef Ref<PlainObjectType,RefOptions,StrideType> XprType ; enum { Flags = evaluator<Map<PlainObjectType,RefOptions,StrideType>>::Flags,Alignment = evaluator<Map<PlainObjectType,RefOptions,StrideType>>::Alignment } ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator(const XprType& ref) : mapbase_evaluator<XprType, PlainObjectType>(ref)"
  },
  {
    "label": "ArgTypeIsRowMajor()",
    "kind": "Method",
    "detail": "Function (} } ; template<ArgType,int BlockRows,int BlockCols,bool InnerPanel,bool HasDirectAccess = internal::has_direct_access<ArgType>::ret> struct block_evaluator ; template<ArgType,int BlockRows,int BlockCols,bool InnerPanel> struct evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>> : block_evaluator<ArgType,BlockRows,BlockCols,InnerPanel> { typedef Block<ArgType,BlockRows,BlockCols,InnerPanel> XprType ; typedef XprType::Scalar Scalar ; typedef packet_traits<Scalar>::type PacketScalar ; enum { CoeffReadCost = evaluator<ArgType>::CoeffReadCost,RowsAtCompileTime = traits<XprType>::RowsAtCompileTime,ColsAtCompileTime = traits<XprType>::ColsAtCompileTime,MaxRowsAtCompileTime = traits<XprType>::MaxRowsAtCompileTime,MaxColsAtCompileTime = traits<XprType>::MaxColsAtCompileTime,)",
    "insertText": "ArgTypeIsRowMajor(int(evaluator<ArgType>::Flags)&RowMajorBit) != 0, IsRowMajor = (MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) ? 1 : (MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1) ? 0 : ArgTypeIsRowMajor, HasSameStorageOrderAsArgType = (IsRowMajor == ArgTypeIsRowMajor), InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime), InnerStrideAtCompileTime = HasSameStorageOrderAsArgType ? int(inner_stride_at_compile_time<ArgType>::ret) : int(outer_stride_at_compile_time<ArgType>::ret), OuterStrideAtCompileTime = HasSameStorageOrderAsArgType ? int(outer_stride_at_compile_time<ArgType>::ret) : int(inner_stride_at_compile_time<ArgType>::ret), MaskPacketAccessBit = (InnerStrideAtCompileTime == 1 || HasSameStorageOrderAsArgType) ? PacketAccessBit : 0, FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1 || (InnerPanel && (evaluator<ArgType>::Flags&LinearAccessBit))) ? LinearAccessBit : 0, FlagsRowMajorBit = XprType::Flags&RowMajorBit, Flags0 = evaluator<ArgType>::Flags & ( (HereditaryBits & ~RowMajorBit) | DirectAccessBit | MaskPacketAccessBit), Flags = Flags0 | FlagsLinearAccessBit | FlagsRowMajorBit, PacketAlignment = unpacket_traits<PacketScalar>::alignment, Alignment0 = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic) && (OuterStrideAtCompileTime!=0) && (((OuterStrideAtCompileTime * int(sizeof(Scalar))) % int(PacketAlignment)) == 0)) ? int(PacketAlignment) : 0, Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<ArgType>::Alignment, Alignment0)"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (typedef block_evaluator<ArgType,BlockRows,BlockCols,InnerPanel> block_evaluator_type ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator(const XprType& block) : block_evaluator_type(block)"
  },
  {
    "label": "block_evaluator()",
    "kind": "Method",
    "detail": "Function (} } ; template<ArgType,int BlockRows,int BlockCols,bool InnerPanel> struct block_evaluator<ArgType,BlockRows,BlockCols,InnerPanel,false> : unary_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>> { typedef Block<ArgType,BlockRows,BlockCols,InnerPanel> XprType ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "block_evaluator(const XprType& block) : unary_evaluator<XprType>(block)"
  },
  {
    "label": "unary_evaluator()",
    "kind": "Method",
    "detail": "Function (} } ; template<ArgType,int BlockRows,int BlockCols,bool InnerPanel> struct unary_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>,IndexBased> : evaluator_base<Block<ArgType,BlockRows,BlockCols,InnerPanel>> { typedef Block<ArgType,BlockRows,BlockCols,InnerPanel> XprType ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "unary_evaluator(const XprType& block) : m_argImpl(block.nestedExpression()), m_startRow(block.startRow()), m_startCol(block.startCol()), m_linear_offset(ForwardLinearAccess?(ArgType::IsRowMajor ? block.startRow()*block.nestedExpression().cols() + block.startCol() : block.startCol()*block.nestedExpression().rows() + block.startRow()):0)"
  },
  {
    "label": "ForwardLinearAccess()",
    "kind": "Method",
    "detail": "Function (} typedef XprType::Scalar Scalar ; typedef XprType::CoeffReturnType CoeffReturnType ; enum { RowsAtCompileTime = XprType::RowsAtCompileTime,)",
    "insertText": "ForwardLinearAccess(InnerPanel || int(XprType::IsRowMajor)==int(ArgType::IsRowMajor)) && bool(evaluator<ArgType>::Flags&LinearAccessBit)"
  },
  {
    "label": "linear_coeff_impl()",
    "kind": "Method",
    "detail": "Function (} protected : EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType)",
    "insertText": "linear_coeff_impl(Index index, internal::true_type)"
  },
  {
    "label": "linear_coeff_impl()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType)",
    "insertText": "linear_coeff_impl(Index index, internal::false_type)"
  },
  {
    "label": "linear_coeffRef_impl()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar&)",
    "insertText": "linear_coeffRef_impl(Index index, internal::true_type)"
  },
  {
    "label": "linear_coeffRef_impl()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar&)",
    "insertText": "linear_coeffRef_impl(Index index, internal::false_type)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (} evaluator<ArgType> m_argImpl ; const variable_if_dynamic<)",
    "insertText": "Index(ArgType::RowsAtCompileTime == 1 && BlockRows==1)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (const variable_if_dynamic<)",
    "insertText": "Index(ArgType::ColsAtCompileTime == 1 && BlockCols==1)"
  },
  {
    "label": "block_evaluator()",
    "kind": "Method",
    "detail": "Function (const variable_if_dynamic<Index,ForwardLinearAccess ? Dynamic : 0> m_linear_offset ; } ; template<ArgType,int BlockRows,int BlockCols,bool InnerPanel> struct block_evaluator<ArgType,BlockRows,BlockCols,InnerPanel,true> : mapbase_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>,Block<ArgType,BlockRows,BlockCols,InnerPanel>::PlainObject> { typedef Block<ArgType,BlockRows,BlockCols,InnerPanel> XprType ; typedef XprType::Scalar Scalar ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "block_evaluator(const XprType& block) : mapbase_evaluator<XprType, typename XprType::PlainObject>(block)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(((internal::UIntPtr(block.data()) % EIGEN_PLAIN_ENUM_MAX(1,evaluator<XprType>::Alignment)) == 0) && \"data is not aligned\")"
  },
  {
    "label": "EIGEN_PLAIN_ENUM_MAX()",
    "kind": "Method",
    "detail": "Function (} } ; template<ConditionMatrixType,ThenMatrixType,ElseMatrixType> struct evaluator<Select<ConditionMatrixType,ThenMatrixType,ElseMatrixType>> : evaluator_base<Select<ConditionMatrixType,ThenMatrixType,ElseMatrixType>> { typedef Select<ConditionMatrixType,ThenMatrixType,ElseMatrixType> XprType ; enum { CoeffReadCost = evaluator<ConditionMatrixType>::CoeffReadCost +)",
    "insertText": "EIGEN_PLAIN_ENUM_MAX(evaluator<ThenMatrixType>::CoeffReadCost, evaluator<ElseMatrixType>::CoeffReadCost), Flags = (unsigned int)evaluator<ThenMatrixType>::Flags & evaluator<ElseMatrixType>::Flags & HereditaryBits, Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<ThenMatrixType>::Alignment, evaluator<ElseMatrixType>::Alignment)"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator(const XprType& select) : m_conditionImpl(select.conditionMatrix()), m_thenImpl(select.thenMatrix()), m_elseImpl(select.elseMatrix())"
  },
  {
    "label": "Factor()",
    "kind": "Method",
    "detail": "Function (} protected : evaluator<ConditionMatrixType> m_conditionImpl ; evaluator<ThenMatrixType> m_thenImpl ; evaluator<ElseMatrixType> m_elseImpl ; } ; template<ArgType,int RowFactor,int ColFactor> struct unary_evaluator<Replicate<ArgType,RowFactor,ColFactor>> : evaluator_base<Replicate<ArgType,RowFactor,ColFactor>> { typedef Replicate<ArgType,RowFactor,ColFactor> XprType ; typedef XprType::CoeffReturnType CoeffReturnType ; enum {)",
    "insertText": "Factor(RowFactor==Dynamic || ColFactor==Dynamic)"
  },
  {
    "label": "Flags()",
    "kind": "Method",
    "detail": "Function (typedef internal::nested_eval<ArgType,Factor>::type ArgTypeNested ; typedef internal::remove_all<ArgTypeNested>::type ArgTypeNestedCleaned ; enum { CoeffReadCost = evaluator<ArgTypeNestedCleaned>::CoeffReadCost,LinearAccessMask = XprType::IsVectorAtCompileTime ? LinearAccessBit : 0,)",
    "insertText": "Flags(evaluator<ArgTypeNestedCleaned>::Flags & (HereditaryBits|LinearAccessMask) & ~RowMajorBit) | (traits<XprType>::Flags & RowMajorBit)"
  },
  {
    "label": "unary_evaluator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "unary_evaluator(const XprType& replicate) : m_arg(replicate.nestedExpression()), m_argImpl(m_arg), m_rows(replicate.nestedExpression().rows()), m_cols(replicate.nestedExpression().cols())"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (const Index actual_row = internal::traits<XprType>::RowsAtCompileTime = = 1 ? 0 : RowFactor = = 1 ? row : row % m_rows .)",
    "insertText": "value()"
  },
  {
    "label": "RowsAtCompileTime()",
    "kind": "Method",
    "detail": "Function (const Index actual_index = internal::traits<XprType)",
    "insertText": "RowsAtCompileTime(ColFactor==1 ? index : index%m_cols.value()) : (RowFactor==1 ? index : index%m_rows.value())"
  },
  {
    "label": "evaluator_wrapper_base()",
    "kind": "Method",
    "detail": "Function (} protected : const ArgTypeNested m_arg ; evaluator<ArgTypeNestedCleaned> m_argImpl ; const variable_if_dynamic<Index,ArgType::RowsAtCompileTime> m_rows ; const variable_if_dynamic<Index,ArgType::ColsAtCompileTime> m_cols ; } ; template<XprType> struct evaluator_wrapper_base : evaluator_base<XprType> { typedef remove_all<XprType::NestedExpressionType>::type ArgType ; enum { CoeffReadCost = evaluator<ArgType>::CoeffReadCost,Flags = evaluator<ArgType>::Flags,Alignment = evaluator<ArgType>::Alignment } ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator_wrapper_base(const ArgType& arg) : m_argImpl(arg)"
  },
  {
    "label": "StoreMode()",
    "kind": "Method",
    "detail": "Function (m_argImpl . template writePacket<)",
    "insertText": "StoreMode(row, col, x)"
  },
  {
    "label": "StoreMode()",
    "kind": "Method",
    "detail": "Function (m_argImpl . template writePacket<)",
    "insertText": "StoreMode(index, x)"
  },
  {
    "label": "unary_evaluator()",
    "kind": "Method",
    "detail": "Function (} protected : evaluator<ArgType> m_argImpl ; } ; template<TArgType> struct unary_evaluator<MatrixWrapper<TArgType>> : evaluator_wrapper_base<MatrixWrapper<TArgType>> { typedef MatrixWrapper<TArgType> XprType ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "unary_evaluator(const XprType& wrapper) : evaluator_wrapper_base<MatrixWrapper<TArgType> >(wrapper.nestedExpression())"
  },
  {
    "label": "unary_evaluator()",
    "kind": "Method",
    "detail": "Function (} } ; template<TArgType> struct unary_evaluator<ArrayWrapper<TArgType>> : evaluator_wrapper_base<ArrayWrapper<TArgType>> { typedef ArrayWrapper<TArgType> XprType ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "unary_evaluator(const XprType& wrapper) : evaluator_wrapper_base<ArrayWrapper<TArgType> >(wrapper.nestedExpression())"
  },
  {
    "label": "ReverseRow()",
    "kind": "Method",
    "detail": "Function (} } ; template<PacketType,bool ReversePacket> struct reverse_packet_cond ; template<ArgType,int Direction> struct unary_evaluator<Reverse<ArgType,Direction>> : evaluator_base<Reverse<ArgType,Direction>> { typedef Reverse<ArgType,Direction> XprType ; typedef XprType::Scalar Scalar ; typedef XprType::CoeffReturnType CoeffReturnType ; enum { IsRowMajor = XprType::IsRowMajor,IsColMajor = ! IsRowMajor,)",
    "insertText": "ReverseRow(Direction == Vertical) || (Direction == BothDirections), ReverseCol = (Direction == Horizontal) || (Direction == BothDirections), ReversePacket = (Direction == BothDirections) || ((Direction == Vertical) && IsColMajor) || ((Direction == Horizontal) && IsRowMajor), CoeffReadCost = evaluator<ArgType>::CoeffReadCost, Flags0 = evaluator<ArgType>::Flags, LinearAccess = ( (Direction==BothDirections) && (int(Flags0)&PacketAccessBit) ) || ((ReverseRow && XprType::ColsAtCompileTime==1) || (ReverseCol && XprType::RowsAtCompileTime==1)) ? LinearAccessBit : 0, Flags = int(Flags0) & (HereditaryBits | PacketAccessBit | LinearAccess)"
  },
  {
    "label": "unary_evaluator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "unary_evaluator(const XprType& reverse) : m_argImpl(reverse.nestedExpression()), m_rows(ReverseRow ? reverse.nestedExpression().rows() : 1), m_cols(ReverseCol ? reverse.nestedExpression().cols() : 1)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (enum { PacketSize = unpacket_traits<PacketType>::size,OffsetRow = ReverseRow&& IsColMajor ? PacketSize : 1,OffsetCol = ReverseCol&& IsRowMajor ? PacketSize : 1 } ; typedef internal::reverse_packet_cond<PacketType,ReversePacket> reverse_packet ; return)",
    "insertText": "run(m_argImpl.template packet<LoadMode,PacketType>( ReverseRow ? m_rows.value() - row - OffsetRow : row, ReverseCol ? m_cols.value() - col - OffsetCol : col))"
  },
  {
    "label": "preverse()",
    "kind": "Method",
    "detail": "Function (enum { PacketSize = unpacket_traits<PacketType>::size } ; return)",
    "insertText": "preverse(m_argImpl.template packet<LoadMode,PacketType>(m_rows.value() * m_cols.value() - index - PacketSize))"
  },
  {
    "label": "LoadMode()",
    "kind": "Method",
    "detail": "Function (enum { PacketSize = unpacket_traits<PacketType>::size,OffsetRow = ReverseRow&& IsColMajor ? PacketSize : 1,OffsetCol = ReverseCol&& IsRowMajor ? PacketSize : 1 } ; typedef internal::reverse_packet_cond<PacketType,ReversePacket> reverse_packet ; m_argImpl . template writePacket<)",
    "insertText": "LoadMode(ReverseRow ? m_rows.value() - row - OffsetRow : row, ReverseCol ? m_cols.value() - col - OffsetCol : col, reverse_packet::run(x))"
  },
  {
    "label": "LoadMode()",
    "kind": "Method",
    "detail": "Function (enum { PacketSize = unpacket_traits<PacketType>::size } ; m_argImpl . template writePacket<)",
    "insertText": "LoadMode(m_rows.value() * m_cols.value() - index - PacketSize, preverse(x))"
  },
  {
    "label": "Flags()",
    "kind": "Method",
    "detail": "Function (} protected : evaluator<ArgType> m_argImpl ; const variable_if_dynamic<Index,ReverseRow ? ArgType::RowsAtCompileTime : 1> m_rows ; const variable_if_dynamic<Index,ReverseCol ? ArgType::ColsAtCompileTime : 1> m_cols ; } ; template<ArgType,int DiagIndex> struct evaluator<Diagonal<ArgType,DiagIndex>> : evaluator_base<Diagonal<ArgType,DiagIndex>> { typedef Diagonal<ArgType,DiagIndex> XprType ; enum { CoeffReadCost = evaluator<ArgType>::CoeffReadCost,)",
    "insertText": "Flags(unsigned int)(evaluator<ArgType>::Flags & (HereditaryBits | DirectAccessBit) & ~RowMajorBit)"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator(const XprType& diagonal) : m_argImpl(diagonal.nestedExpression()), m_index(diagonal.index())"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (} typedef XprType::Scalar Scalar ; typedef XprType::CoeffReturnType CoeffReturnType ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType)",
    "insertText": "coeff(Index row, Index)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar&)",
    "insertText": "coeffRef(Index row, Index)"
  },
  {
    "label": "rowOffset()",
    "kind": "Method",
    "detail": "Function (} protected : evaluator<ArgType> m_argImpl ; const internal::variable_if_dynamicindex<Index,XprType::DiagIndex> m_index ; private : EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR Index)",
    "insertText": "rowOffset()"
  },
  {
    "label": "colOffset()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR Index)",
    "insertText": "colOffset()"
  },
  {
    "label": "EIGEN_GENERIC_PUBLIC_INTERFACE()",
    "kind": "Method",
    "detail": "Function (} } ; template<ArgType> class EvalToTemp ; template<ArgType> struct traits<EvalToTemp<ArgType>> : public traits<ArgType> { } ; template<ArgType> class EvalToTemp : public dense_xpr_base<EvalToTemp<ArgType>>::type { public : typedef dense_xpr_base<EvalToTemp>::type Base ;)",
    "insertText": "EIGEN_GENERIC_PUBLIC_INTERFACE(EvalToTemp) explicit EvalToTemp(const ArgType& arg) : m_arg(arg)"
  },
  {
    "label": "arg()",
    "kind": "Method",
    "detail": "Function (} const ArgType&)",
    "insertText": "arg()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} EIGEN_CONSTEXPR Index)",
    "insertText": "cols()"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (} private : const ArgType& m_arg ; } ; template<ArgType> struct evaluator<EvalToTemp<ArgType>> : public evaluator<ArgType::PlainObject> { typedef EvalToTemp<ArgType> XprType ; typedef ArgType::PlainObject PlainObject ; typedef evaluator<PlainObject> Base ; EIGEN_DEVICE_FUNC)",
    "insertText": "evaluator(const XprType& xpr) : m_result(xpr.arg())"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(static_cast<Base*>(this)) Base(m_result)"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "evaluator(const ArgType& arg) : m_result(arg)"
  }
]