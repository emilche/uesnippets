[
  {
    "label": "TraceCategoryTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TraceCategoryTest"
  },
  {
    "label": "TraceLog",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TraceLog"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "Range",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Range"
  },
  {
    "label": "Range()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TRACE_EVENT_CATEGORY_REGISTRY_H_ # define BASE_TRACE_EVENT_CATEGORY_REGISTRY_H_ # include<stddef . h> # include<stdint . h> # include<atomic> # include \" base / base_export . h \" # include \" base / check_op . h \" # include \" base / memory / raw_ptr . h \" # include \" base / trace_event / builtin_categories . h \" # include \" base / trace_event / common / trace_event_common . h \" # include \" base / trace_event / trace_category . h \" # include \" build / build_config . h \" namespace base { namespace trace_event { class TraceCategoryTest ; class TraceLog ; class BASE_EXPORT CategoryRegistry { public : class Range { public :)",
    "insertText": "Range(TraceCategory* begin, TraceCategory* end) : begin_(begin), end_(end)"
  },
  {
    "label": "DCHECK_LE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_LE(begin, end)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} TraceCategory*)",
    "insertText": "begin()"
  },
  {
    "label": "GetCategoryByName()",
    "kind": "Method",
    "detail": "Function (TraceCategory*)",
    "insertText": "GetCategoryByName(const char* category_name)"
  },
  {
    "label": "GetBuiltinCategoryByName()",
    "kind": "Method",
    "detail": "Function (TraceCategory*)",
    "insertText": "GetBuiltinCategoryByName(const char* category_group)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_WIN) && defined(COMPONENT_BUILD)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "for(size_t i = 0; i < BuiltinCategories::Size(); ++i)"
  },
  {
    "label": "IsMetaCategory()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; # endif } bool)",
    "insertText": "IsMetaCategory(const TraceCategory* category)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (private : class TraceCategoryTest ; class TraceLog ; using CategoryInitializerFn =)",
    "insertText": "void(*)(TraceCategory*)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (size_t kMaxCategories = 3 5 0 ;)",
    "insertText": "static_assert(BuiltinCategories::Size() <= kMaxCategories, \"kMaxCategories must be greater than kNumBuiltinCategories\")"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize()"
  },
  {
    "label": "ResetForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetForTesting()"
  },
  {
    "label": "GetOrCreateCategoryLocked()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetOrCreateCategoryLocked(const char* category_name, CategoryInitializerFn, TraceCategory**)"
  },
  {
    "label": "GetAllCategories()",
    "kind": "Method",
    "detail": "Function (Range)",
    "insertText": "GetAllCategories()"
  },
  {
    "label": "IsValidCategoryPtr()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValidCategoryPtr(const TraceCategory* category)"
  }
]