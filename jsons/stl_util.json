[
  {
    "label": "A",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "A"
  },
  {
    "label": "ExposedAdapter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExposedAdapter"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "Collection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Collection"
  },
  {
    "label": "IsNotIn",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IsNotIn"
  },
  {
    "label": "GetUnderlyingContainer()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_STL_UTIL_H_ # define BASE_STL_UTIL_H_ # include<algorithm> # include<forward_list> # include<iterator> # include<type_traits> # include \" base / check . h \" # include \" base / ranges / algorithm . h \" namespace base { namespace internal { template<Iter> bool IsRandomAccessIter = std::is_same<std::iterator_traits<Iter>::iterator_category,std::random_access_iterator_tag>::value ; } template<class A> const A::container_type&)",
    "insertText": "GetUnderlyingContainer(const A& adapter)"
  },
  {
    "label": "STLClearObject()",
    "kind": "Method",
    "detail": "Function (struct ExposedAdapter : A { using A::c ; } ; return adapter .*& ExposedAdapter::c ; } template<class T> void)",
    "insertText": "STLClearObject(T* obj)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (T tmp ; tmp .)",
    "insertText": "swap(*obj)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (obj ->)",
    "insertText": "reserve(0)"
  },
  {
    "label": "ConstCastIterator()",
    "kind": "Method",
    "detail": "Function (} template<Container,ConstIter,std::enable_if_t<! internal::IsRandomAccessIter<ConstIter>>* = nullptr> auto)",
    "insertText": "ConstCastIterator(Container& c, ConstIter it)"
  },
  {
    "label": "ConstCastIterator()",
    "kind": "Method",
    "detail": "Function (} template<T,Allocator> auto)",
    "insertText": "ConstCastIterator(std::forward_list<T, Allocator>& c, typename std::forward_list<T, Allocator>::const_iterator it)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(__GLIBCXX__) return c.insert_after(it, {})"
  },
  {
    "label": "erase_after()",
    "kind": "Method",
    "detail": "Function (# else return c .)",
    "insertText": "erase_after(it, it)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (using std::begin ; using std::cbegin ; return)",
    "insertText": "begin(c) + (it - cbegin(c))"
  },
  {
    "label": "STLSetDifference()",
    "kind": "Method",
    "detail": "Function (} template<ResultType,Arg1,Arg2> ResultType)",
    "insertText": "STLSetDifference(const Arg1& a1, const Arg2& a2)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(ranges::is_sorted(a1))"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(ranges::is_sorted(a2))"
  },
  {
    "label": "set_difference()",
    "kind": "Method",
    "detail": "Function (ResultType difference ;)",
    "insertText": "set_difference(a1.begin(), a1.end(), a2.begin(), a2.end(), std::inserter(difference, difference.end()))"
  },
  {
    "label": "set_union()",
    "kind": "Method",
    "detail": "Function (ResultType result ;)",
    "insertText": "set_union(a1.begin(), a1.end(), a2.begin(), a2.end(), std::inserter(result, result.end()))"
  },
  {
    "label": "set_intersection()",
    "kind": "Method",
    "detail": "Function (ResultType result ;)",
    "insertText": "set_intersection(a1.begin(), a1.end(), a2.begin(), a2.end(), std::inserter(result, result.end()))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator()(const typename Collection::value_type& x)"
  }
]