[
  {
    "label": "ALEMBIC_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ALEMBIC_EXPORT"
  },
  {
    "label": "AcyclicFlag",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "AcyclicFlag"
  },
  {
    "label": "AcyclicNumSamples()",
    "kind": "Method",
    "detail": "Function (# ifndef Alembic_AbcCoreAbstract_TimeSamplingType_h # define Alembic_AbcCoreAbstract_TimeSamplingType_h # include<Alembic / Util / Export . h> # include<Alembic / AbcCoreAbstract / Foundation . h> namespace Alembic { namespace AbcCoreAbstract { namespace ALEMBIC_VERSION_NS { class ALEMBIC_EXPORT TimeSamplingType { public : uint32_t)",
    "insertText": "AcyclicNumSamples()"
  },
  {
    "label": "AcyclicTimePerCycle()",
    "kind": "Method",
    "detail": "Function (chrono_t)",
    "insertText": "AcyclicTimePerCycle()"
  },
  {
    "label": "TimeSamplingType()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TimeSamplingType() : m_numSamplesPerCycle( 1 ), m_timePerCycle( 1.0)"
  },
  {
    "label": "TimeSamplingType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TimeSamplingType(chrono_t iTimePerCycle ) : m_numSamplesPerCycle( 1 ) , m_timePerCycle( iTimePerCycle)"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(m_timePerCycle > 0.0 && m_timePerCycle < AcyclicTimePerCycle(), \"Time per cycle must be greater than 0 \" << \"and can not be ACYCLIC_TIME_PER_CYCLE.\")"
  },
  {
    "label": "TimeSamplingType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TimeSamplingType(uint32_t iNumSamplesPerCycle, chrono_t iTimePerCycle ) : m_numSamplesPerCycle( iNumSamplesPerCycle ) , m_timePerCycle( iTimePerCycle)"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(( m_timePerCycle == AcyclicTimePerCycle() && m_numSamplesPerCycle == AcyclicNumSamples() ) || ( m_timePerCycle > 0.0 && m_timePerCycle < AcyclicTimePerCycle() && m_numSamplesPerCycle > 0 && m_numSamplesPerCycle < AcyclicNumSamples() ), \"Invalid Time Sampling Type, time per cycle: \" << m_timePerCycle << \" samples per cycle: \" << m_numSamplesPerCycle)"
  },
  {
    "label": "TimeSamplingType()",
    "kind": "Method",
    "detail": "Function (} enum AcyclicFlag { kAcyclic } ;)",
    "insertText": "TimeSamplingType(AcyclicFlag)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TimeSamplingType & iRhs)"
  },
  {
    "label": "isUniform()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isUniform()"
  },
  {
    "label": "isAcyclic()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isAcyclic()"
  },
  {
    "label": "getNumSamplesPerCycle()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "getNumSamplesPerCycle()"
  }
]