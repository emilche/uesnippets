[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TSleepData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TSleepData"
  },
  {
    "label": "FRigidParticleCoreData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRigidParticleCoreData"
  },
  {
    "label": "TRigidParticles",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRigidParticles"
  },
  {
    "label": "FLegacyData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLegacyData"
  },
  {
    "label": "TSleepData()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Queue . h \" # include \" Chaos / ArrayCollectionArray . h \" # include \" Chaos / Collision / CollisionConstraintFlags . h \" # include \" Chaos / BVHParticles . h \" # include \" Chaos / GeometryParticles . h \" # include \" Chaos / ImplicitObject . h \" # include \" Chaos / KinematicGeometryParticles . h \" # include \" Chaos / Matrix . h \" # include \" Chaos / Particles . h \" # include \" Chaos / Rotation . h \" # include \" Chaos / RigidParticleControlFlags . h \" # include \" HAL / LowLevelMemTracker . h \" # include \" Chaos / Evolution / IterationSettings . h \" # include \" UObject / FortniteMainBranchObjectVersion . h \" namespace Chaos { enum class ESleepType : uint8 { MaterialSleep,NeverSleep } ; template<class T,int d> struct TSleepData {)",
    "insertText": "TSleepData() : Particle(nullptr) , Sleeping(true)"
  },
  {
    "label": "TSleepData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSleepData(TGeometryParticleHandle<T, d>* InParticle, bool InSleeping) : Particle(InParticle) , Sleeping(InSleeping)"
  },
  {
    "label": "NumBitsNeeded()",
    "kind": "Method",
    "detail": "Function (} TGeometryParticleHandle<T,d>* Particle ; bool Sleeping ; } ; int8)",
    "insertText": "NumBitsNeeded(const int8 MaxValue)"
  },
  {
    "label": "LowBitsMask()",
    "kind": "Method",
    "detail": "Function (} int8)",
    "insertText": "LowBitsMask(const int8 NumBits)"
  },
  {
    "label": "NumBitsNeeded()",
    "kind": "Method",
    "detail": "Function (} int8 ObjectStateBitCount =)",
    "insertText": "NumBitsNeeded((int8)EObjectStateType::Count - (int8)1)"
  },
  {
    "label": "TRigidParticles()",
    "kind": "Method",
    "detail": "Function (struct FRigidParticleCoreData { int32 CollisionGroup ; uint32 CollisionConstraintFlags ; FRigidParticleControlFlags ControlFlags ; FRigidParticleTransientFlags TransientFlags ; EObjectStateType ObjectState ; EObjectStateType PreObjectState ; bool bDisabled ; } ; template<class T,int d> class TRigidParticles : public TKinematicGeometryParticles<T,d> { public : using TArrayCollection::Size ; using TParticles<T,d>::X ; using TGeometryParticles<T,d>::R ;)",
    "insertText": "TRigidParticles() : TKinematicGeometryParticles<T, d>()"
  },
  {
    "label": "RegisterArrays()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterArrays()"
  },
  {
    "label": "TRigidParticles()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TRigidParticles(const TRigidParticles<T, d>& Other)"
  },
  {
    "label": "TRigidParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRigidParticles(TRigidParticles<T, d>&& Other) : TKinematicGeometryParticles<T, d>(MoveTemp(Other)) , CoreData(MoveTemp(Other.CoreData)) , MVSmooth(MoveTemp(Other.MVSmooth)) , MWSmooth(MoveTemp(Other.MWSmooth)) , MAcceleration(MoveTemp(Other.MAcceleration)) , MAngularAcceleration(MoveTemp(Other.MAngularAcceleration)) , MLinearImpulseVelocity(MoveTemp(Other.MLinearImpulseVelocity)) , MAngularImpulseVelocity(MoveTemp(Other.MAngularImpulseVelocity)) , MI(MoveTemp(Other.MI)) , MInvI(MoveTemp(Other.MInvI)) , MInvIConditioning(MoveTemp(Other.MInvIConditioning)) , MM(MoveTemp(Other.MM)) , MInvM(MoveTemp(Other.MInvM)) , MCenterOfMass(MoveTemp(Other.MCenterOfMass)) , MRotationOfMass(MoveTemp(Other.MRotationOfMass)) , MLinearEtherDrag(MoveTemp(Other.MLinearEtherDrag)) , MAngularEtherDrag(MoveTemp(Other.MAngularEtherDrag)) , MaxLinearSpeedsSq(MoveTemp(Other.MaxLinearSpeedsSq)) , MaxAngularSpeedsSq(MoveTemp(Other.MaxAngularSpeedsSq)) , MInitialOverlapDepenetrationVelocity(MoveTemp(Other.MInitialOverlapDepenetrationVelocity)) , MSleepThresholdMultiplier(MoveTemp(Other.MSleepThresholdMultiplier)) , MCollisionParticles(MoveTemp(Other.MCollisionParticles)) , MSleepType(MoveTemp(Other.MSleepType)) , MSleepCounter(MoveTemp(Other.MSleepCounter)) , MDisableCounter(MoveTemp(Other.MDisableCounter)) , MParticleIterationCounts(MoveTemp(Other.MParticleIterationCounts))"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&CoreData)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MVSmooth)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MWSmooth)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MAcceleration)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MAngularAcceleration)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MLinearImpulseVelocity)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MAngularImpulseVelocity)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MI)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MInvI)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MInvIConditioning)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MM)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MInvM)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MCenterOfMass)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MRotationOfMass)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MLinearEtherDrag)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MAngularEtherDrag)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MaxLinearSpeedsSq)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MaxAngularSpeedsSq)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MInitialOverlapDepenetrationVelocity)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MSleepThresholdMultiplier)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MCollisionParticles)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MSleepType)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MSleepCounter)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MDisableCounter)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MParticleIterationCounts)"
  },
  {
    "label": "TRigidParticles()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TRigidParticles()"
  },
  {
    "label": "VSmooth()",
    "kind": "Method",
    "detail": "Function (} const TVector<T,d>&)",
    "insertText": "VSmooth(const int32 Index)"
  },
  {
    "label": "CollisionParticlesInitIfNeeded()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CollisionParticlesInitIfNeeded(const int32 Index)"
  },
  {
    "label": "SetCollisionParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCollisionParticles(const int32 Index, TParticles<T, d>&& Particles)"
  },
  {
    "label": "AddCollisionConstraintFlag()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddCollisionConstraintFlag(const ECollisionConstraintFlags Flag, const int32 Index)"
  },
  {
    "label": "CollisionConstraintFlags()",
    "kind": "Method",
    "detail": "Function (CoreData [ Index ] .)",
    "insertText": "CollisionConstraintFlags(uint32)"
  },
  {
    "label": "RemoveCollisionConstraintFlag()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveCollisionConstraintFlag(const ECollisionConstraintFlags Flag, const int32 Index)"
  },
  {
    "label": "SetCollisionConstraintFlags()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCollisionConstraintFlags(const int32 Index, const uint32 Flags)"
  },
  {
    "label": "CollisionConstraintFlags()",
    "kind": "Method",
    "detail": "Function (CoreData [ Index ] . CollisionConstraintFlags = Flags ; } uint32)",
    "insertText": "CollisionConstraintFlags(const int32 Index)"
  },
  {
    "label": "ControlFlags()",
    "kind": "Method",
    "detail": "Function (CoreData [ Index ] . bDisabled = InDisabled ; } const FRigidParticleControlFlags&)",
    "insertText": "ControlFlags(const int32 Index)"
  },
  {
    "label": "WriteLock()",
    "kind": "Method",
    "detail": "Function (TSleepData<T,d> SleepData ; SleepData . Particle = Particle ; SleepData . Sleeping = Sleeping ; SleepDataLock .)",
    "insertText": "WriteLock()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (MSleepData .)",
    "insertText": "Add(SleepData)"
  },
  {
    "label": "WriteUnlock()",
    "kind": "Method",
    "detail": "Function (SleepDataLock .)",
    "insertText": "WriteUnlock()"
  },
  {
    "label": "ClearSleepData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearSleepData()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (MSleepData .)",
    "insertText": "Empty()"
  },
  {
    "label": "GetSleepDataLock()",
    "kind": "Method",
    "detail": "Function (} FRWLock&)",
    "insertText": "GetSleepDataLock()"
  },
  {
    "label": "Sleeping()",
    "kind": "Method",
    "detail": "Function (} const bool)",
    "insertText": "Sleeping(const int32 Index)"
  },
  {
    "label": "HasInfiniteMass()",
    "kind": "Method",
    "detail": "Function (} const bool)",
    "insertText": "HasInfiniteMass(const int32 Index)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ToString(int32 Index)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (FString BaseString = TKinematicGeometryParticles<T,d)",
    "insertText": "ToString(Index)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Serialize(FChaosArchive& Ar)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (TKinematicGeometryParticles<T,d)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FLegacyData LegacyData ; TArrayCollectionArray<int32> LegacyIslandIndex ;)",
    "insertText": "if(!Ar.IsLoading())"
  },
  {
    "label": "CopyFromCoreData()",
    "kind": "Method",
    "detail": "Function (LegacyData .)",
    "insertText": "CopyFromCoreData(CoreData)"
  },
  {
    "label": "SetNumZeroed()",
    "kind": "Method",
    "detail": "Function (LegacyIslandIndex .)",
    "insertText": "SetNumZeroed(MCollisionParticles.Num())"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (} Ar .)",
    "insertText": "UsingCustomVersion(FExternalPhysicsCustomObjectVersion::GUID)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar<<MCenterOfMass ; Ar<<MRotationOfMass ; } Ar<<MAcceleration<<MAngularAcceleration<<MLinearImpulseVelocity<<MAngularImpulseVelocity ; Ar .)",
    "insertText": "UsingCustomVersion(FFortniteMainBranchObjectVersion::GUID)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FUE5ReleaseStreamObjectVersion::GUID)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<PMatrix<T,d,d>> IArray ; TArray<PMatrix<T,d,d>> InvIArray ; Ar<<IArray<<InvIArray ;)",
    "insertText": "for(int32 Idx = 0; Idx < IArray.Num(); ++Idx)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (MI .)",
    "insertText": "Add(IArray[Idx].GetDiagonal())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (MInvI .)",
    "insertText": "Add(InvIArray[Idx].GetDiagonal())"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (} } else { Ar<<MI<<MInvI ; } MInvIConditioning .)",
    "insertText": "Resize(MInvI.Num())"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (MInvIConditioning [ Index ] = TVec3<)",
    "insertText": "FRealSingle(1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<MLinearEtherDrag<<MAngularEtherDrag ; } Ar<<MCollisionParticles<<LegacyData . MCollisionGroup<<LegacyIslandIndex<<LegacyData . MDisabled<<LegacyData . MObjectState<<MSleepType ;)",
    "insertText": "if(Ar.IsLoading())"
  },
  {
    "label": "CopyToCoreData()",
    "kind": "Method",
    "detail": "Function (LegacyData .)",
    "insertText": "CopyToCoreData(CoreData)"
  },
  {
    "label": "CopyFromCoreData()",
    "kind": "Method",
    "detail": "Function (int32 Dummy = INDEX_NONE ; return Dummy ; } private : struct FLegacyData { TArrayCollectionArray<int32> MCollisionGroup ; TArrayCollectionArray<EObjectStateType> MObjectState ; TArrayCollectionArray<bool> MDisabled ; void)",
    "insertText": "CopyFromCoreData(const TArrayCollectionArray<FRigidParticleCoreData>& Source)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (MCollisionGroup .)",
    "insertText": "Resize(Source.Num())"
  },
  {
    "label": "CopyToCoreData()",
    "kind": "Method",
    "detail": "Function (MCollisionGroup [ Index ] = Source [ Index ] . CollisionGroup ; MObjectState [ Index ] = Source [ Index ] . ObjectState ; MDisabled [ Index ] = Source [ Index ] . bDisabled ; } } void)",
    "insertText": "CopyToCoreData(TArrayCollectionArray<FRigidParticleCoreData>& Dest)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (Dest .)",
    "insertText": "Resize(MCollisionGroup.Num())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Dest [ Index ] . CollisionGroup = MCollisionGroup [ Index ] ; Dest [ Index ] . ObjectState = MObjectState [ Index ] ; Dest [ Index ] . bDisabled = MDisabled [ Index ] ; } } } ; TArrayCollectionArray<FRigidParticleCoreData> CoreData ; TArrayCollectionArray<TVector<T,d>> MVSmooth ; TArrayCollectionArray<TVector<T,d>> MWSmooth ; TArrayCollectionArray<TVector<T,d>> MAcceleration ; TArrayCollectionArray<TVector<T,d>> MAngularAcceleration ; TArrayCollectionArray<TVector<T,d>> MLinearImpulseVelocity ; TArrayCollectionArray<TVector<T,d>> MAngularImpulseVelocity ; TArrayCollectionArray<TVec3<FRealSingle>> MI ; TArrayCollectionArray<TVec3<FRealSingle>> MInvI ; TArrayCollectionArray<TVec3<FRealSingle>> MInvIConditioning ; TArrayCollectionArray<T> MM ; TArrayCollectionArray<T> MInvM ; TArrayCollectionArray<TVector<T,d>> MCenterOfMass ; TArrayCollectionArray<TRotation<T,d>> MRotationOfMass ; TArrayCollectionArray<T> MLinearEtherDrag ; TArrayCollectionArray<T> MAngularEtherDrag ; TArrayCollectionArray<T> MaxLinearSpeedsSq ; TArrayCollectionArray<T> MaxAngularSpeedsSq ; TArrayCollectionArray<FRealSingle> MInitialOverlapDepenetrationVelocity ; TArrayCollectionArray<FRealSingle> MSleepThresholdMultiplier ; TArrayCollectionArray<TUniquePtr<TBVHParticles<T,d>>> MCollisionParticles ; TArrayCollectionArray<ESleepType> MSleepType ; TArrayCollectionArray<int8> MSleepCounter ; TArrayCollectionArray<int8> MDisableCounter ; TArrayCollectionArray<Private::FIterationSettings> MParticleIterationCounts ; TArray<TSleepData<T,d>> MSleepData ; FRWLock SleepDataLock ; } ; template<T,int d> FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, TRigidParticles<T, d>& Particles)"
  }
]