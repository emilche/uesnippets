[
  {
    "label": "UAnimStreamable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimStreamable"
  },
  {
    "label": "FAnimationStreamingManager",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimationStreamingManager"
  },
  {
    "label": "FLoadedAnimationChunk",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLoadedAnimationChunk"
  },
  {
    "label": "IBulkDataIORequest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IBulkDataIORequest"
  },
  {
    "label": "FStreamingAnimationData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStreamingAnimationData"
  },
  {
    "label": "ULevel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ULevel"
  },
  {
    "label": "FLoadedAnimationChunk()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" HAL / ThreadSafeCounter . h \" # include \" Containers / IndirectArray . h \" # include \" Containers / Queue . h \" # include \" Stats / Stats . h \" # include \" ContentStreaming . h \" # include \" Async / AsyncWork . h \" # include \" Async / AsyncFileHandle . h \" # include \" Templates / Atomic . h \" class UAnimStreamable ; struct FAnimationStreamingManager ; struct FLoadedAnimationChunk { TAtomic<FCompressedAnimSequence*> CompressedAnimData ; class IBulkDataIORequest* IORequest ; double RequestStart ; uint32 Index ; bool bOwnsCompressedData ;)",
    "insertText": "FLoadedAnimationChunk() : CompressedAnimData(nullptr) , IORequest(nullptr) , RequestStart(-1.0) , Index(0) , bOwnsCompressedData(false)"
  },
  {
    "label": "FLoadedAnimationChunk()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FLoadedAnimationChunk()"
  },
  {
    "label": "CleanUpIORequest()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CleanUpIORequest()"
  },
  {
    "label": "FStreamingAnimationData()",
    "kind": "Method",
    "detail": "Function (} ; struct FStreamingAnimationData final {)",
    "insertText": "FStreamingAnimationData()"
  },
  {
    "label": "FreeResources()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeResources()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Initialize(UAnimStreamable* InStreamableAnim, FAnimationStreamingManager* InAnimationStreamingManager)"
  },
  {
    "label": "UpdateStreamingStatus()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UpdateStreamingStatus()"
  },
  {
    "label": "HasPendingRequests()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasPendingRequests(TArray<uint32>& IndicesToLoad, TArray<uint32>& IndicesToFree)"
  },
  {
    "label": "BeginPendingRequests()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginPendingRequests(const TArray<uint32>& IndicesToLoad, const TArray<uint32>& IndicesToFree)"
  },
  {
    "label": "BlockTillAllRequestsFinished()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "BlockTillAllRequestsFinished(float TimeLimit = 0.0f)"
  },
  {
    "label": "GetMemorySize()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetMemorySize()"
  },
  {
    "label": "FStreamingAnimationData()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "FStreamingAnimationData(const FStreamingAnimationData& that)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FStreamingAnimationData&)",
    "insertText": "operator(FStreamingAnimationData const&)"
  },
  {
    "label": "AddNewLoadedChunk()",
    "kind": "Method",
    "detail": "Function (FLoadedAnimationChunk&)",
    "insertText": "AddNewLoadedChunk(uint32 ChunkIndex, FCompressedAnimSequence* ExistingData)"
  },
  {
    "label": "FreeLoadedChunk()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeLoadedChunk(FLoadedAnimationChunk& LoadedChunk)"
  },
  {
    "label": "ResetRequestedChunks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetRequestedChunks()"
  },
  {
    "label": "FAnimationStreamingManager()",
    "kind": "Method",
    "detail": "Function (public : UAnimStreamable* StreamableAnim ; TArray<FLoadedAnimationChunk> LoadedChunks ; FCriticalSection LoadedChunksCritcalSection ; TArray<uint32> LoadedChunkIndices ; TArray<uint32> RequestedChunks ; TArray<uint32> LoadFailedChunks ; FAnimationStreamingManager* AnimationStreamingManager ; } ; struct FAnimationStreamingManager : public IAnimationStreamingManager {)",
    "insertText": "FAnimationStreamingManager()"
  },
  {
    "label": "UpdateResourceStreaming()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateResourceStreaming(float DeltaTime, bool bProcessEverything=false)"
  },
  {
    "label": "BlockTillAllRequestsFinished()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "BlockTillAllRequestsFinished(float TimeLimit = 0.0f, bool bLogResults = false)"
  },
  {
    "label": "CancelForcedResources()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CancelForcedResources()"
  },
  {
    "label": "NotifyLevelChange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NotifyLevelChange()"
  },
  {
    "label": "SetDisregardWorldResourcesForFrames()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDisregardWorldResourcesForFrames(int32 NumFrames)"
  },
  {
    "label": "AddLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddLevel(class ULevel* Level)"
  },
  {
    "label": "RemoveLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveLevel(class ULevel* Level)"
  },
  {
    "label": "NotifyLevelOffset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NotifyLevelOffset(class ULevel* Level, const FVector& Offset)"
  },
  {
    "label": "AddStreamingAnim()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddStreamingAnim(UAnimStreamable* Anim)"
  },
  {
    "label": "RemoveStreamingAnim()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemoveStreamingAnim(UAnimStreamable* Anim)"
  },
  {
    "label": "GetMemorySizeForAnim()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetMemorySizeForAnim(const UAnimStreamable* Anim)"
  },
  {
    "label": "GetLoadedChunk()",
    "kind": "Method",
    "detail": "Function (const FCompressedAnimSequence*)",
    "insertText": "GetLoadedChunk(const UAnimStreamable* Anim, uint32 ChunkIndex, bool bTrackAsRequested)"
  },
  {
    "label": "OnAsyncFileCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnAsyncFileCallback(FStreamingAnimationData* StreamingAnimData, int32 ChunkIndex, int64 ReadSize, IBulkDataIORequest* ReadRequest, bool bWasCancelled)"
  }
]