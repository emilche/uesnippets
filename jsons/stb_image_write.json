[
  {
    "label": "stbi_write_png()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDE_STB_IMAGE_WRITE_H # define INCLUDE_STB_IMAGE_WRITE_H # include<stdlib . h> # ifndef STBIWDEF # ifdef STB_IMAGE_WRITE_STATIC # define STBIWDEF # else # ifdef __cplusplus # define STBIWDEF \" C \" # else # define STBIWDEF # endif # endif # endif # ifndef STB_IMAGE_WRITE_STATIC int stbi_write_tga_with_rle ; int stbi_write_png_compression_level ; int stbi_write_force_png_filter ; # endif # ifndef STBI_WRITE_NO_STDIO STBIWDEF int)",
    "insertText": "stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes)"
  },
  {
    "label": "stbi_write_bmp()",
    "kind": "Method",
    "detail": "Function (STBIWDEF int)",
    "insertText": "stbi_write_bmp(char const *filename, int w, int h, int comp, const void *data)"
  },
  {
    "label": "stbi_write_tga()",
    "kind": "Method",
    "detail": "Function (STBIWDEF int)",
    "insertText": "stbi_write_tga(char const *filename, int w, int h, int comp, const void *data)"
  },
  {
    "label": "stbi_write_hdr()",
    "kind": "Method",
    "detail": "Function (STBIWDEF int)",
    "insertText": "stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data)"
  },
  {
    "label": "stbi_write_jpg()",
    "kind": "Method",
    "detail": "Function (STBIWDEF int)",
    "insertText": "stbi_write_jpg(char const *filename, int x, int y, int comp, const void *data, int quality)"
  },
  {
    "label": "stbiw_convert_wchar_to_utf8()",
    "kind": "Method",
    "detail": "Function (# ifdef STBI_WINDOWS_UTF8 STBIWDEF int)",
    "insertText": "stbiw_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)"
  },
  {
    "label": "stbi_write_func()",
    "kind": "Method",
    "detail": "Function (# endif # endif typedef void)",
    "insertText": "stbi_write_func(void *context, void *data, int size)"
  },
  {
    "label": "stbi_write_png_to_func()",
    "kind": "Method",
    "detail": "Function (STBIWDEF int)",
    "insertText": "stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void *data, int stride_in_bytes)"
  },
  {
    "label": "stbi_write_bmp_to_func()",
    "kind": "Method",
    "detail": "Function (STBIWDEF int)",
    "insertText": "stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void *data)"
  },
  {
    "label": "stbi_write_tga_to_func()",
    "kind": "Method",
    "detail": "Function (STBIWDEF int)",
    "insertText": "stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void *data)"
  },
  {
    "label": "stbi_write_hdr_to_func()",
    "kind": "Method",
    "detail": "Function (STBIWDEF int)",
    "insertText": "stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data)"
  },
  {
    "label": "stbi_write_jpg_to_func()",
    "kind": "Method",
    "detail": "Function (STBIWDEF int)",
    "insertText": "stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality)"
  },
  {
    "label": "stbi_flip_vertically_on_write()",
    "kind": "Method",
    "detail": "Function (STBIWDEF void)",
    "insertText": "stbi_flip_vertically_on_write(int flip_boolean)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # ifdef STB_IMAGE_WRITE_IMPLEMENTATION # ifdef _WIN32 # ifndef _CRT_SECURE_NO_WARNINGS # define _CRT_SECURE_NO_WARNINGS # endif # ifndef _CRT_NONSTDC_NO_DEPRECATE # define _CRT_NONSTDC_NO_DEPRECATE # endif # endif # ifndef STBI_WRITE_NO_STDIO # include<stdio . h> # endif # include<stdarg . h> # include<stdlib . h> # include<string . h> # include<math . h> # if)",
    "insertText": "defined(STBIW_MALLOC) && defined(STBIW_FREE) && (defined(STBIW_REALLOC) || defined(STBIW_REALLOC_SIZED)) #elif !defined(STBIW_MALLOC) && !defined(STBIW_FREE) && !defined(STBIW_REALLOC) && !defined(STBIW_REALLOC_SIZED) #else #error \"Must define all or none of STBIW_MALLOC, STBIW_FREE, and STBIW_REALLOC (or STBIW_REALLOC_SIZED).\" #endif #ifndef STBIW_MALLOC #define STBIW_MALLOC(sz) malloc(sz) #define STBIW_REALLOC(p,newsz) realloc(p,newsz) #define STBIW_FREE(p) free(p) #endif #ifndef STBIW_REALLOC_SIZED #define STBIW_REALLOC_SIZED(p,oldsz,newsz) STBIW_REALLOC(p,newsz) #endif #ifndef STBIW_MEMMOVE #define STBIW_MEMMOVE(a,b,sz) memmove(a,b,sz) #endif #ifndef STBIW_ASSERT #include <assert.h> #define STBIW_ASSERT(x) assert(x) #endif #define STBIW_UCHAR(x) (unsigned char) ((x) & 0xff)"
  },
  {
    "label": "stbi_flip_vertically_on_write()",
    "kind": "Method",
    "detail": "Function (int stbi_write_png_compression_level = 8 ; int stbi_write_tga_with_rle = 1 ; int stbi_write_force_png_filter = - 1 ; # else int stbi_write_png_compression_level = 8 ; int stbi__flip_vertically_on_write = 0 ; int stbi_write_tga_with_rle = 1 ; int stbi_write_force_png_filter = - 1 ; # endif STBIWDEF void)",
    "insertText": "stbi_flip_vertically_on_write(int flag)"
  },
  {
    "label": "stbi__start_write_callbacks()",
    "kind": "Method",
    "detail": "Function (stbi__flip_vertically_on_write = flag ; } typedef struct { stbi_write_func* func ; void* context ; } stbi__write_context ; void)",
    "insertText": "stbi__start_write_callbacks(stbi__write_context *s, stbi_write_func *c, void *context)"
  },
  {
    "label": "stbi__stdio_write()",
    "kind": "Method",
    "detail": "Function (s -> func = c ; s -> context = context ; } # ifndef STBI_WRITE_NO_STDIO void)",
    "insertText": "stbi__stdio_write(void *context, void *data, int size)"
  },
  {
    "label": "fwrite()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fwrite(data,1,size,(FILE*) context)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8) #ifdef __cplusplus #define STBIW_EXTERN extern \"C\" #else #define STBIW_EXTERN extern #endif STBIW_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide)"
  },
  {
    "label": "__declspec()",
    "kind": "Method",
    "detail": "Function (STBIW_EXTERN)",
    "insertText": "__declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default)"
  },
  {
    "label": "stbiw__fopen()",
    "kind": "Method",
    "detail": "Function (} # endif FILE*)",
    "insertText": "stbiw__fopen(char const *filename, char const *mode)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (FILE* f ; # if)",
    "insertText": "defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (wchar_t wFilename [ 1 0 2 4 ] ;)",
    "insertText": "if(0 == MultiByteToWideChar(65001 , 0, filename, -1, wFilename, sizeof(wFilename)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if _MSC_VER> = 1 4 0 0)",
    "insertText": "if(0 != _wfopen_s(&f, wFilename, wMode))"
  },
  {
    "label": "_wfopen()",
    "kind": "Method",
    "detail": "Function (# else f =)",
    "insertText": "_wfopen(wFilename, wMode)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # elif)",
    "insertText": "defined(_MSC_VER) && _MSC_VER >= 1400 if (0 != fopen_s(&f, filename, mode))"
  },
  {
    "label": "fopen()",
    "kind": "Method",
    "detail": "Function (# else f =)",
    "insertText": "fopen(filename, mode)"
  },
  {
    "label": "stbi__start_write_file()",
    "kind": "Method",
    "detail": "Function (# endif return f ; } int)",
    "insertText": "stbi__start_write_file(stbi__write_context *s, const char *filename)"
  },
  {
    "label": "stbiw__fopen()",
    "kind": "Method",
    "detail": "Function (FILE* f =)",
    "insertText": "stbiw__fopen(filename, \"wb\")"
  },
  {
    "label": "stbi__start_write_callbacks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbi__start_write_callbacks(s, stbi__stdio_write, (void *) f)"
  },
  {
    "label": "fclose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fclose((FILE *)s->context)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} # endif typedef unsigned int stbiw_uint32 ; typedef int stb_image_write_test [)",
    "insertText": "sizeof(stbiw_uint32)"
  },
  {
    "label": "stbiw__writefv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__writefv(stbi__write_context *s, const char *fmt, va_list v)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context,&x,1)"
  },
  {
    "label": "va_arg()",
    "kind": "Method",
    "detail": "Function (break ; } case ' 2 ' : { int x =)",
    "insertText": "va_arg(v,int)"
  },
  {
    "label": "STBIW_UCHAR()",
    "kind": "Method",
    "detail": "Function (unsigned char b [ 2 ] ; b [ 0 ] =)",
    "insertText": "STBIW_UCHAR(x)"
  },
  {
    "label": "STBIW_UCHAR()",
    "kind": "Method",
    "detail": "Function (b [ 1 ] =)",
    "insertText": "STBIW_UCHAR(x>>8)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context,b,2)"
  },
  {
    "label": "STBIW_UCHAR()",
    "kind": "Method",
    "detail": "Function (b [ 2 ] =)",
    "insertText": "STBIW_UCHAR(x>>16)"
  },
  {
    "label": "STBIW_UCHAR()",
    "kind": "Method",
    "detail": "Function (b [ 3 ] =)",
    "insertText": "STBIW_UCHAR(x>>24)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context,b,4)"
  },
  {
    "label": "STBIW_ASSERT()",
    "kind": "Method",
    "detail": "Function (break ; } default :)",
    "insertText": "STBIW_ASSERT(0)"
  },
  {
    "label": "va_start()",
    "kind": "Method",
    "detail": "Function (va_list v ;)",
    "insertText": "va_start(v, fmt)"
  },
  {
    "label": "stbiw__writefv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__writefv(s, fmt, v)"
  },
  {
    "label": "va_end()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "va_end(v)"
  },
  {
    "label": "stbiw__putc()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbiw__putc(stbi__write_context *s, unsigned char c)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, &c, 1)"
  },
  {
    "label": "stbiw__write3()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbiw__write3(stbi__write_context *s, unsigned char a, unsigned char b, unsigned char c)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (unsigned char arr [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; s ->)",
    "insertText": "func(s->context, arr, 3)"
  },
  {
    "label": "stbiw__write_pixel()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbiw__write_pixel(stbi__write_context *s, int rgb_dir, int comp, int write_alpha, int expand_mono, unsigned char *d)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned char bg [ 3 ] = { 2 5 5,0,2 5 5 },px [ 3 ] ; int k ;)",
    "insertText": "if(write_alpha < 0) s->func(s->context, &d[comp - 1], 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case 4 :)",
    "insertText": "if(!write_alpha)"
  },
  {
    "label": "stbiw__write3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__write3(s, px[1 - rgb_dir], px[1], px[1 + rgb_dir])"
  },
  {
    "label": "stbiw__write3()",
    "kind": "Method",
    "detail": "Function (break ; } case 3 :)",
    "insertText": "stbiw__write3(s, d[1 - rgb_dir], d[1], d[1 + rgb_dir])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; })",
    "insertText": "if(write_alpha > 0) s->func(s->context, &d[comp - 1], 1)"
  },
  {
    "label": "stbiw__write_pixels()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbiw__write_pixels(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad, int expand_mono)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (stbiw_uint32 zero = 0 ; int i,j,j_end ;)",
    "insertText": "if(y <= 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (j_end = - 1 ; j = y - 1 ; } else { j_end = y ; j = 0 ; })",
    "insertText": "for(; j != j_end; j += vdir)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (unsigned char*)",
    "insertText": "d(unsigned char *) data + (j*x+i)"
  },
  {
    "label": "stbiw__write_pixel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__write_pixel(s, rgb_dir, comp, write_alpha, expand_mono, d)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (} s ->)",
    "insertText": "func(s->context, &zero, scanline_pad)"
  },
  {
    "label": "stbiw__outfile()",
    "kind": "Method",
    "detail": "Function (} } int)",
    "insertText": "stbiw__outfile(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, int expand_mono, void *data, int alpha, int pad, const char *fmt, ...)"
  },
  {
    "label": "stbiw__write_pixels()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__write_pixels(s,rgb_dir,vdir,x,y,comp,data,alpha,pad, expand_mono)"
  },
  {
    "label": "pad()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "pad(-x*3)"
  },
  {
    "label": "stbi_write_bmp_to_func()",
    "kind": "Method",
    "detail": "Function (} STBIWDEF int)",
    "insertText": "stbi_write_bmp_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)"
  },
  {
    "label": "stbi__start_write_callbacks()",
    "kind": "Method",
    "detail": "Function (stbi__write_context s ;)",
    "insertText": "stbi__start_write_callbacks(&s, func, context)"
  },
  {
    "label": "stbi_write_bmp()",
    "kind": "Method",
    "detail": "Function (} # ifndef STBI_WRITE_NO_STDIO STBIWDEF int)",
    "insertText": "stbi_write_bmp(char const *filename, int x, int y, int comp, const void *data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (stbi__write_context s ;)",
    "insertText": "if(stbi__start_write_file(&s,filename))"
  },
  {
    "label": "stbi_write_bmp_core()",
    "kind": "Method",
    "detail": "Function (int r =)",
    "insertText": "stbi_write_bmp_core(&s, x, y, comp, data)"
  },
  {
    "label": "stbi__end_write_file()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbi__end_write_file(&s)"
  },
  {
    "label": "has_alpha()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "has_alpha(comp == 2 || comp == 4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int colorbytes = has_alpha ? comp - 1 : comp ; int format = colorbytes<2 ? 3 : 2 ;)",
    "insertText": "if(y < 0 || x < 0)"
  },
  {
    "label": "stbiw__writef()",
    "kind": "Method",
    "detail": "Function (} else { int i,j,k ; int jend,jdir ;)",
    "insertText": "stbiw__writef(s, \"111 221 2222 11\", 0,0,format+8, 0,0,0, 0,0,x,y, (colorbytes + has_alpha) * 8, has_alpha * 8)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (j = 0 ; jend = y ; jdir = 1 ; } else { j = y - 1 ; jend = - 1 ; jdir = - 1 ; })",
    "insertText": "for(; j != jend; j += jdir)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (unsigned char*)",
    "insertText": "row(unsigned char *)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int len ;)",
    "insertText": "for(i = 0; i < x; i += len)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned char* begin = row + i* comp ; int diff = 1 ; len = 1 ;)",
    "insertText": "if(i < x - 1)"
  },
  {
    "label": "memcmp()",
    "kind": "Method",
    "detail": "Function (+ + len ; diff =)",
    "insertText": "memcmp(begin, row + (i + 1) * comp, comp)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const unsigned char* prev = begin ;)",
    "insertText": "for(k = i + 2; k < x && len < 128; ++k)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + len ; } else { break ; } } } })",
    "insertText": "if(diff)"
  },
  {
    "label": "STBIW_UCHAR()",
    "kind": "Method",
    "detail": "Function (unsigned char header =)",
    "insertText": "STBIW_UCHAR(len - 1)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, &header, 1)"
  },
  {
    "label": "stbiw__write_pixel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin + k * comp)"
  },
  {
    "label": "STBIW_UCHAR()",
    "kind": "Method",
    "detail": "Function (} } else { unsigned char header =)",
    "insertText": "STBIW_UCHAR(len - 129)"
  },
  {
    "label": "stbiw__write_pixel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin)"
  },
  {
    "label": "stbi_write_tga_to_func()",
    "kind": "Method",
    "detail": "Function (} } } } return 1 ; } STBIWDEF int)",
    "insertText": "stbi_write_tga_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)"
  },
  {
    "label": "stbi_write_tga()",
    "kind": "Method",
    "detail": "Function (} # ifndef STBI_WRITE_NO_STDIO STBIWDEF int)",
    "insertText": "stbi_write_tga(char const *filename, int x, int y, int comp, const void *data)"
  },
  {
    "label": "stbi_write_tga_core()",
    "kind": "Method",
    "detail": "Function (int r =)",
    "insertText": "stbi_write_tga_core(&s, x, y, comp, (void *) data)"
  },
  {
    "label": "stbiw__max()",
    "kind": "Method",
    "detail": "Function (int exponent ; float maxcomp =)",
    "insertText": "stbiw__max(linear[0], stbiw__max(linear[1], linear[2]))"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (rgbe [ 0 ] = rgbe [ 1 ] = rgbe [ 2 ] = rgbe [ 3 ] = 0 ; } else { float)",
    "insertText": "normalize(float) frexp(maxcomp, &exponent)"
  },
  {
    "label": "rgbe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rgbe(unsigned char)(linear[0] * normalize)"
  },
  {
    "label": "rgbe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rgbe(unsigned char)(linear[1] * normalize)"
  },
  {
    "label": "rgbe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rgbe(unsigned char)(linear[2] * normalize)"
  },
  {
    "label": "rgbe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rgbe(unsigned char)(exponent + 128)"
  },
  {
    "label": "stbiw__write_run_data()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "stbiw__write_run_data(stbi__write_context *s, int length, unsigned char databyte)"
  },
  {
    "label": "STBIW_UCHAR()",
    "kind": "Method",
    "detail": "Function (unsigned char lengthbyte =)",
    "insertText": "STBIW_UCHAR(length+128)"
  },
  {
    "label": "STBIW_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_ASSERT(length+128 <= 255)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, &lengthbyte, 1)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, &databyte, 1)"
  },
  {
    "label": "stbiw__write_dump_data()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbiw__write_dump_data(stbi__write_context *s, int length, unsigned char *data)"
  },
  {
    "label": "STBIW_UCHAR()",
    "kind": "Method",
    "detail": "Function (unsigned char lengthbyte =)",
    "insertText": "STBIW_UCHAR(length)"
  },
  {
    "label": "STBIW_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_ASSERT(length <= 128)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, data, length)"
  },
  {
    "label": "stbiw__write_hdr_scanline()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbiw__write_hdr_scanline(stbi__write_context *s, int width, int ncomp, unsigned char *scratch, float *scanline)"
  },
  {
    "label": "scanlineheader()",
    "kind": "Method",
    "detail": "Function (unsigned char scanlineheader [ 4 ] = { 2,2,0,0 } ; unsigned char rgbe [ 4 ] ; float linear [ 3 ] ; int x ;)",
    "insertText": "scanlineheader(width&0xff00)"
  },
  {
    "label": "scanlineheader()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "scanlineheader(width&0x00ff)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, rgbe, 4)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } else { int c,r ;)",
    "insertText": "for(x=0; x < width; x++)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (scratch [ x + width* 0 ] = rgbe [ 0 ] ; scratch [ x + width* 1 ] = rgbe [ 1 ] ; scratch [ x + width* 2 ] = rgbe [ 2 ] ; scratch [ x + width* 3 ] = rgbe [ 3 ] ; } s ->)",
    "insertText": "func(s->context, scanlineheader, 4)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (unsigned char* comp =& scratch [ width* c ] ; x = 0 ;)",
    "insertText": "while(x < width)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (r = x ;)",
    "insertText": "while(r+2 < width)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + r ; })",
    "insertText": "if(r+2 >= width)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int len = r - x ;)",
    "insertText": "if(len > 128)"
  },
  {
    "label": "stbiw__write_dump_data()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__write_dump_data(s, len, &comp[x])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (x + = len ; })",
    "insertText": "if(r+2 < width)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int len = r - x ;)",
    "insertText": "if(len > 127)"
  },
  {
    "label": "stbiw__write_run_data()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__write_run_data(s, len, comp[x])"
  },
  {
    "label": "stbi_write_hdr_core()",
    "kind": "Method",
    "detail": "Function (x + = len ; } } } } } } int)",
    "insertText": "stbi_write_hdr_core(stbi__write_context *s, int x, int y, int comp, float *data)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (int i,len ; char buffer [ 1 2 8 ] ; char header [ ] = \" # ? RADIANCE \\ n # Written by stb_image_write . h \\ nFORMAT = 3 2 - bit_rle_rgbe \\ n \" ; s ->)",
    "insertText": "func(s->context, header, sizeof(header)-1)"
  },
  {
    "label": "sprintf_s()",
    "kind": "Method",
    "detail": "Function (# ifdef __STDC_WANT_SECURE_LIB__ len =)",
    "insertText": "sprintf_s(buffer, sizeof(buffer), \"EXPOSURE= 1.0000000000000\\n\\n-Y %d +X %d\\n\", y, x)"
  },
  {
    "label": "sprintf()",
    "kind": "Method",
    "detail": "Function (# else len =)",
    "insertText": "sprintf(buffer, \"EXPOSURE= 1.0000000000000\\n\\n-Y %d +X %d\\n\", y, x)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (# endif s ->)",
    "insertText": "func(s->context, buffer, len)"
  },
  {
    "label": "STBIW_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_FREE(scratch)"
  },
  {
    "label": "stbi_write_hdr()",
    "kind": "Method",
    "detail": "Function (} # ifndef STBI_WRITE_NO_STDIO STBIWDEF int)",
    "insertText": "stbi_write_hdr(char const *filename, int x, int y, int comp, const float *data)"
  },
  {
    "label": "stbi_write_hdr_core()",
    "kind": "Method",
    "detail": "Function (int r =)",
    "insertText": "stbi_write_hdr_core(&s, x, y, comp, (float *) data)"
  },
  {
    "label": "stbiw__sbm()",
    "kind": "Method",
    "detail": "Function (int m =* arr ? 2*)",
    "insertText": "stbiw__sbm(*arr)"
  },
  {
    "label": "STBIW_REALLOC_SIZED()",
    "kind": "Method",
    "detail": "Function (void* p =)",
    "insertText": "STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2)"
  },
  {
    "label": "STBIW_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_ASSERT(p)"
  },
  {
    "label": "arr()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "arr(void *) ((int *) p + 2)"
  },
  {
    "label": "stbiw__zlib_flushf()",
    "kind": "Method",
    "detail": "Function (} return* arr ; } unsigned char*)",
    "insertText": "stbiw__zlib_flushf(unsigned char *data, unsigned int *bitbuffer, int *bitcount)"
  },
  {
    "label": "stbiw__sbpush()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer))"
  },
  {
    "label": "stbiw__zlib_bitrev()",
    "kind": "Method",
    "detail": "Function (* bitbuffer>> = 8 ;* bitcount - = 8 ; } return data ; } int)",
    "insertText": "stbiw__zlib_bitrev(int code, int codebits)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int res = 0 ;)",
    "insertText": "while(codebits--)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(res << 1) | (code & 1)"
  },
  {
    "label": "stbiw__zlib_countm()",
    "kind": "Method",
    "detail": "Function (code>> = 1 ; } return res ; } unsigned int)",
    "insertText": "stbiw__zlib_countm(unsigned char *a, unsigned char *b, int limit)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int i ;)",
    "insertText": "for(i=0; i < limit && i < 258; ++i) if (a[i] != b[i])"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (stbiw_uint32 hash =)",
    "insertText": "data(data[1] << 8) + (data[2] << 16)"
  },
  {
    "label": "stbiw__zlib_flush()",
    "kind": "Method",
    "detail": "Function (hash ^ = hash<<3 ; hash + = hash>> 5 ; hash ^ = hash<<4 ; hash + = hash>> 1 7 ; hash ^ = hash<<2 5 ; hash + = hash>> 6 ; return hash ; } # define)",
    "insertText": "stbiw__zlib_flush() (out = stbiw__zlib_flushf(out, &bitbuf, &bitcount)) #define stbiw__zlib_add(code,codebits) \\ (bitbuf |= (code) << bitcount, bitcount += (codebits), stbiw__zlib_flush()) #define stbiw__zlib_huffa(b,c) stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c) #define stbiw__zlib_huff1(n) stbiw__zlib_huffa(0x30 + (n), 8) #define stbiw__zlib_huff2(n) stbiw__zlib_huffa(0x190 + (n)-144, 9) #define stbiw__zlib_huff3(n) stbiw__zlib_huffa(0 + (n)-256,7) #define stbiw__zlib_huff4(n) stbiw__zlib_huffa(0xc0 + (n)-280,8) #define stbiw__zlib_huff(n) ((n) <= 143 ? stbiw__zlib_huff1(n) : (n) <= 255 ? stbiw__zlib_huff2(n) : (n) <= 279 ? stbiw__zlib_huff3(n) : stbiw__zlib_huff4(n)) #define stbiw__zlib_huffb(n) ((n) <= 143 ? stbiw__zlib_huff1(n) : stbiw__zlib_huff2(n)) #define stbiw__ZHASH 16384 #endif STBIWDEF unsigned char * stbi_zlib_compress(unsigned char *data, int data_len, int *out_len, int quality)"
  },
  {
    "label": "STBIW_ZLIB_COMPRESS()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIW_ZLIB_COMPRESS return)",
    "insertText": "STBIW_ZLIB_COMPRESS(data, data_len, out_len, quality)"
  },
  {
    "label": "hash_table()",
    "kind": "Method",
    "detail": "Function (# else unsigned short lengthc [ ] = { 3,4,5,6,7,8,9,1 0,1 1,1 3,1 5,1 7,1 9,2 3,2 7,3 1,3 5,4 3,5 1,5 9,6 7,8 3,9 9,1 1 5,1 3 1,1 6 3,1 9 5,2 2 7,2 5 8,2 5 9 } ; unsigned char lengtheb [ ] = { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0 } ; unsigned short distc [ ] = { 1,2,3,4,5,7,9,1 3,1 7,2 5,3 3,4 9,6 5,9 7,1 2 9,1 9 3,2 5 7,3 8 5,5 1 3,7 6 9,1 0 2 5,1 5 3 7,2 0 4 9,3 0 7 3,4 0 9 7,6 1 4 5,8 1 9 3,1 2 2 8 9,1 6 3 8 5,2 4 5 7 7,3 2 7 6 8 } ; unsigned char disteb [ ] = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,1 0,1 0,1 1,1 1,1 2,1 2,1 3,1 3 } ; unsigned int bitbuf = 0 ; int i,j,bitcount = 0 ; unsigned char* out = NULL ; unsigned char***)",
    "insertText": "hash_table(unsigned char***) STBIW_MALLOC(stbiw__ZHASH * sizeof(unsigned char**))"
  },
  {
    "label": "stbiw__sbpush()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__sbpush(out, 0x78)"
  },
  {
    "label": "stbiw__sbpush()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__sbpush(out, 0x5e)"
  },
  {
    "label": "stbiw__zlib_add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__zlib_add(1,1)"
  },
  {
    "label": "stbiw__zlib_add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__zlib_add(1,2)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (i = 0 ;)",
    "insertText": "while(i < data_len-3)"
  },
  {
    "label": "stbiw__zhash()",
    "kind": "Method",
    "detail": "Function (int h =)",
    "insertText": "stbiw__zhash(data+i)&(stbiw__ZHASH-1)"
  },
  {
    "label": "stbiw__sbcount()",
    "kind": "Method",
    "detail": "Function (unsigned char* bestloc = 0 ; unsigned char** hlist = hash_table [ h ] ; int n =)",
    "insertText": "stbiw__sbcount(hlist)"
  },
  {
    "label": "stbiw__zlib_countm()",
    "kind": "Method",
    "detail": "Function (int d =)",
    "insertText": "stbiw__zlib_countm(hlist[j], data+i, data_len-i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (best = d ; bestloc = hlist [ j ] ; } } })",
    "insertText": "if(hash_table[h] && stbiw__sbn(hash_table[h]) == 2*quality)"
  },
  {
    "label": "STBIW_MEMMOVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_MEMMOVE(hash_table[h], hash_table[h]+quality, sizeof(hash_table[h][0])*quality)"
  },
  {
    "label": "stbiw__sbn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__sbn(hash_table[h])"
  },
  {
    "label": "stbiw__sbpush()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "stbiw__sbpush(hash_table[h],data+i)"
  },
  {
    "label": "stbiw__zhash()",
    "kind": "Method",
    "detail": "Function (h =)",
    "insertText": "stbiw__zhash(data+i+1)&(stbiw__ZHASH-1)"
  },
  {
    "label": "stbiw__zlib_countm()",
    "kind": "Method",
    "detail": "Function (int e =)",
    "insertText": "stbiw__zlib_countm(hlist[j], data+i+1, data_len-i-1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bestloc = NULL ; break ; } } } })",
    "insertText": "if(bestloc)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "d(int) (data+i - bestloc)"
  },
  {
    "label": "STBIW_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_ASSERT(d <= 32767 && best <= 258)"
  },
  {
    "label": "stbiw__zlib_huff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__zlib_huff(j+257)"
  },
  {
    "label": "stbiw__zlib_add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__zlib_add(stbiw__zlib_bitrev(j,5),5)"
  },
  {
    "label": "stbiw__zlib_huffb()",
    "kind": "Method",
    "detail": "Function (i + = best ; } else {)",
    "insertText": "stbiw__zlib_huffb(data[i])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (+ + i ; } })",
    "insertText": "for(;i < data_len; ++i) stbiw__zlib_huffb(data[i])"
  },
  {
    "label": "stbiw__zlib_huff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__zlib_huff(256)"
  },
  {
    "label": "STBIW_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_FREE(hash_table)"
  },
  {
    "label": "blocklen()",
    "kind": "Method",
    "detail": "Function ({ unsigned int s1 = 1,s2 = 0 ; int)",
    "insertText": "blocklen(int) (data_len % 5552)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (j = 0 ;)",
    "insertText": "while(j < data_len)"
  },
  {
    "label": "stbiw__sbpush()",
    "kind": "Method",
    "detail": "Function (s1 + = data [ j + i ] ; s2 + = s1 ; } s1 % = 6 5 5 2 1 ; s2 % = 6 5 5 2 1 ; j + = blocklen ; blocklen = 5 5 5 2 ; })",
    "insertText": "stbiw__sbpush(out, STBIW_UCHAR(s2 >> 8))"
  },
  {
    "label": "stbiw__sbpush()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__sbpush(out, STBIW_UCHAR(s2))"
  },
  {
    "label": "stbiw__sbpush()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__sbpush(out, STBIW_UCHAR(s1 >> 8))"
  },
  {
    "label": "stbiw__sbpush()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__sbpush(out, STBIW_UCHAR(s1))"
  },
  {
    "label": "stbiw__sbn()",
    "kind": "Method",
    "detail": "Function (}* out_len =)",
    "insertText": "stbiw__sbn(out)"
  },
  {
    "label": "STBIW_MEMMOVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len)"
  },
  {
    "label": "stbiw__crc32()",
    "kind": "Method",
    "detail": "Function (# endif } unsigned int)",
    "insertText": "stbiw__crc32(unsigned char *buffer, int len)"
  },
  {
    "label": "STBIW_CRC32()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIW_CRC32 return)",
    "insertText": "STBIW_CRC32(buffer, len)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# else unsigned int crc_table [ 2 5 6 ] = { 0 x00000000,0 x77073096,0 xEE0E612C,0 x990951BA,0 x076DC419,0 x706AF48F,0 xE963A535,0 x9E6495A3,0 x0eDB8832,0 x79DCB8A4,0 xE0D5E91E,0 x97D2D988,0 x09B64C2B,0 x7EB17CBD,0 xE7B82D07,0 x90BF1D91,0 x1DB71064,0 x6AB020F2,0 xF3B97148,0 x84BE41DE,0 x1ADAD47D,0 x6DDDE4EB,0 xF4D4B551,0 x83D385C7,0 x136C9856,0 x646BA8C0,0 xFD62F97A,0 x8A65C9EC,0 x14015C4F,0 x63066CD9,0 xFA0F3D63,0 x8D080DF5,0 x3B6E20C8,0 x4C69105E,0 xD56041E4,0 xA2677172,0 x3C03E4D1,0 x4B04D447,0 xD20D85FD,0 xA50AB56B,0 x35B5A8FA,0 x42B2986C,0 xDBBBC9D6,0 xACBCF940,0 x32D86CE3,0 x45DF5C75,0 xDCD60DCF,0 xABD13D59,0 x26D930AC,0 x51DE003A,0 xC8D75180,0 xBFD06116,0 x21B4F4B5,0 x56B3C423,0 xCFBA9599,0 xB8BDA50F,0 x2802B89E,0 x5F058808,0 xC60CD9B2,0 xB10BE924,0 x2F6F7C87,0 x58684C11,0 xC1611DAB,0 xB6662D3D,0 x76DC4190,0 x01DB7106,0 x98D220BC,0 xEFD5102A,0 x71B18589,0 x06B6B51F,0 x9FBFE4A5,0 xE8B8D433,0 x7807C9A2,0 x0F00F934,0 x9609A88E,0 xE10E9818,0 x7F6A0DBB,0 x086D3D2D,0 x91646C97,0 xE6635C01,0 x6B6B51F4,0 x1C6C6162,0 x856530D8,0 xF262004E,0 x6C0695ED,0 x1B01A57B,0 x8208F4C1,0 xF50FC457,0 x65B0D9C6,0 x12B7E950,0 x8BBEB8EA,0 xFCB9887C,0 x62DD1DDF,0 x15DA2D49,0 x8CD37CF3,0 xFBD44C65,0 x4DB26158,0 x3AB551CE,0 xA3BC0074,0 xD4BB30E2,0 x4ADFA541,0 x3DD895D7,0 xA4D1C46D,0 xD3D6F4FB,0 x4369E96A,0 x346ED9FC,0 xAD678846,0 xDA60B8D0,0 x44042D73,0 x33031DE5,0 xAA0A4C5F,0 xDD0D7CC9,0 x5005713C,0 x270241AA,0 xBE0B1010,0 xC90C2086,0 x5768B525,0 x206F85B3,0 xB966D409,0 xCE61E49F,0 x5EDEF90E,0 x29D9C998,0 xB0D09822,0 xC7D7A8B4,0 x59B33D17,0 x2EB40D81,0 xB7BD5C3B,0 xC0BA6CAD,0 xEDB88320,0 x9ABFB3B6,0 x03B6E20C,0 x74B1D29A,0 xEAD54739,0 x9DD277AF,0 x04DB2615,0 x73DC1683,0 xE3630B12,0 x94643B84,0 x0D6D6A3E,0 x7A6A5AA8,0 xE40ECF0B,0 x9309FF9D,0 x0A00AE27,0 x7D079EB1,0 xF00F9344,0 x8708A3D2,0 x1E01F268,0 x6906C2FE,0 xF762575D,0 x806567CB,0 x196C3671,0 x6E6B06E7,0 xFED41B76,0 x89D32BE0,0 x10DA7A5A,0 x67DD4ACC,0 xF9B9DF6F,0 x8EBEEFF9,0 x17B7BE43,0 x60B08ED5,0 xD6D6A3E8,0 xA1D1937E,0 x38D8C2C4,0 x4FDFF252,0 xD1BB67F1,0 xA6BC5767,0 x3FB506DD,0 x48B2364B,0 xD80D2BDA,0 xAF0A1B4C,0 x36034AF6,0 x41047A60,0 xDF60EFC3,0 xA867DF55,0 x316E8EEF,0 x4669BE79,0 xCB61B38C,0 xBC66831A,0 x256FD2A0,0 x5268E236,0 xCC0C7795,0 xBB0B4703,0 x220216B9,0 x5505262F,0 xC5BA3BBE,0 xB2BD0B28,0 x2BB45A92,0 x5CB36A04,0 xC2D7FFA7,0 xB5D0CF31,0 x2CD99E8B,0 x5BDEAE1D,0 x9B64C2B0,0 xEC63F226,0 x756AA39C,0 x026D930A,0 x9C0906A9,0 xEB0E363F,0 x72076785,0 x05005713,0 x95BF4A82,0 xE2B87A14,0 x7BB12BAE,0 x0CB61B38,0 x92D28E9B,0 xE5D5BE0D,0 x7CDCEFB7,0 x0BDBDF21,0 x86D3D2D4,0 xF1D4E242,0 x68DDB3F8,0 x1FDA836E,0 x81BE16CD,0 xF6B9265B,0 x6FB077E1,0 x18B74777,0 x88085AE6,0 xFF0F6A70,0 x66063BCA,0 x11010B5C,0 x8F659EFF,0 xF862AE69,0 x616BFFD3,0 x166CCF45,0 xA00AE278,0 xD70DD2EE,0 x4E048354,0 x3903B3C2,0 xA7672661,0 xD06016F7,0 x4969474D,0 x3E6E77DB,0 xAED16A4A,0 xD9D65ADC,0 x40DF0B66,0 x37D83BF0,0 xA9BCAE53,0 xDEBB9EC5,0 x47B2CF7F,0 x30B5FFE9,0 xBDBDF21C,0 xCABAC28A,0 x53B39330,0 x24B4A3A6,0 xBAD03605,0 xCDD70693,0 x54DE5729,0 x23D967BF,0 xB3667A2E,0 xC4614AB8,0 x5D681B02,0 x2A6F2B94,0 xB40BBE37,0 xC30C8EA1,0 x5A05DF1B,0 x2D02EF8D } ; unsigned int crc = ~ 0 u ; int i ;)",
    "insertText": "for(i=0; i < len; ++i) crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)"
  },
  {
    "label": "stbiw__wptag()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbiw__wptag(data,s) stbiw__wpng4(data, s[0],s[1],s[2],s[3]) static void stbiw__wpcrc(unsigned char **data, int len)"
  },
  {
    "label": "stbiw__crc32()",
    "kind": "Method",
    "detail": "Function (unsigned int crc =)",
    "insertText": "stbiw__crc32(*data - len - 4, len+4)"
  },
  {
    "label": "stbiw__wp32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__wp32(*data, crc)"
  },
  {
    "label": "stbiw__paeth()",
    "kind": "Method",
    "detail": "Function (} unsigned char)",
    "insertText": "stbiw__paeth(int a, int b, int c)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (int p = a + b - c,pa =)",
    "insertText": "abs(p-a), pb = abs(p-b), pc = abs(p-c)"
  },
  {
    "label": "stbiw__encode_png_line()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbiw__encode_png_line(unsigned char *pixels, int stride_bytes, int width, int height, int y, int n, int filter_type, signed char *line_buffer)"
  },
  {
    "label": "mymap()",
    "kind": "Method",
    "detail": "Function (int mapping [ ] = { 0,1,2,3,4 } ; int firstmap [ ] = { 0,1,0,5,6 } ; int*)",
    "insertText": "mymap(y != 0)"
  },
  {
    "label": "stride_bytes()",
    "kind": "Method",
    "detail": "Function (int i ; int type = mymap [ filter_type ] ; unsigned char* z = pixels +)",
    "insertText": "stride_bytes(stbi__flip_vertically_on_write ? height-1-y : y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int signed_stride = stbi__flip_vertically_on_write ? - stride_bytes : stride_bytes ;)",
    "insertText": "if(type==0)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(line_buffer, z, width*n)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (break ; case 4 : line_buffer [)",
    "insertText": "i(signed char) (z[i] - stbiw__paeth(0,z[i-signed_stride],0))"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (break ; case 5 : line_buffer [ i ] = z [ i ] ; break ; case 6 : line_buffer [ i ] = z [ i ] ; break ; } })",
    "insertText": "switch(type)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (break ; case 2 :)",
    "insertText": "for(i=n; i < width*n; ++i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (break ; case 3 :)",
    "insertText": "for(i=n; i < width*n; ++i) line_buffer[i] = z[i] - ((z[i-n] + z[i-signed_stride])>>1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (break ; case 4 :)",
    "insertText": "for(i=n; i < width*n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i-n], z[i-signed_stride], z[i-signed_stride-n])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (break ; case 5 :)",
    "insertText": "for(i=n; i < width*n; ++i) line_buffer[i] = z[i] - (z[i-n]>>1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (break ; case 6 :)",
    "insertText": "for(i=n; i < width*n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i-n], 0,0)"
  },
  {
    "label": "stbi_write_png_to_mem()",
    "kind": "Method",
    "detail": "Function (break ; } } STBIWDEF unsigned char*)",
    "insertText": "stbi_write_png_to_mem(const unsigned char *pixels, int stride_bytes, int x, int y, int n, int *out_len)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int force_filter = stbi_write_force_png_filter ; int ctype [ 5 ] = { - 1,0,4,2,6 } ; unsigned char sig [ 8 ] = { 1 3 7,8 0,7 8,7 1,1 3,1 0,2 6,1 0 } ; unsigned char* out,* o,* filt,* zlib ; signed char* line_buffer ; int j,zlen ;)",
    "insertText": "if(stride_bytes == 0)"
  },
  {
    "label": "line_buffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "line_buffer(signed char *) STBIW_MALLOC(x * n)"
  },
  {
    "label": "STBIW_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_FREE(filt)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int filter_type ;)",
    "insertText": "if(force_filter > -1)"
  },
  {
    "label": "stbiw__encode_png_line()",
    "kind": "Method",
    "detail": "Function (filter_type = force_filter ;)",
    "insertText": "stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, force_filter, line_buffer)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else { int best_filter = 0,best_filter_val = 0 x7fffffff,est,i ;)",
    "insertText": "for(filter_type = 0; filter_type < 5; filter_type++)"
  },
  {
    "label": "stbiw__encode_png_line()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, filter_type, line_buffer)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (est = 0 ;)",
    "insertText": "for(i = 0; i < x*n; ++i)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (est + =)",
    "insertText": "abs((signed char) line_buffer[i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(est < best_filter_val)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (best_filter_val = est ; best_filter = filter_type ; } })",
    "insertText": "if(filter_type != best_filter)"
  },
  {
    "label": "stbiw__encode_png_line()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, best_filter, line_buffer)"
  },
  {
    "label": "j()",
    "kind": "Method",
    "detail": "Function (filter_type = best_filter ; } } filt [)",
    "insertText": "j(x*n+1)] = (unsigned char)"
  },
  {
    "label": "STBIW_MEMMOVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_MEMMOVE(filt+j*(x*n+1)+1, line_buffer, x*n)"
  },
  {
    "label": "STBIW_FREE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "STBIW_FREE(line_buffer)"
  },
  {
    "label": "stbi_zlib_compress()",
    "kind": "Method",
    "detail": "Function (zlib =)",
    "insertText": "stbi_zlib_compress(filt, y*( x*n+1), &zlen, stbi_write_png_compression_level)"
  },
  {
    "label": "out()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "out(unsigned char *) STBIW_MALLOC(8 + 12+13 + 12+zlen + 12)"
  },
  {
    "label": "STBIW_MEMMOVE()",
    "kind": "Method",
    "detail": "Function (* out_len = 8 + 1 2 + 1 3 + 1 2 + zlen + 1 2 ; o = out ;)",
    "insertText": "STBIW_MEMMOVE(o,sig,8)"
  },
  {
    "label": "stbiw__wp32()",
    "kind": "Method",
    "detail": "Function (o + = 8 ;)",
    "insertText": "stbiw__wp32(o, 13)"
  },
  {
    "label": "stbiw__wptag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__wptag(o, \"IHDR\")"
  },
  {
    "label": "stbiw__wp32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__wp32(o, x)"
  },
  {
    "label": "stbiw__wp32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__wp32(o, y)"
  },
  {
    "label": "STBIW_UCHAR()",
    "kind": "Method",
    "detail": "Function (* o + + = 8 ;* o + + =)",
    "insertText": "STBIW_UCHAR(ctype[n])"
  },
  {
    "label": "stbiw__wpcrc()",
    "kind": "Method",
    "detail": "Function (* o + + = 0 ;* o + + = 0 ;* o + + = 0 ;)",
    "insertText": "stbiw__wpcrc(&o,13)"
  },
  {
    "label": "stbiw__wp32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__wp32(o, zlen)"
  },
  {
    "label": "stbiw__wptag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__wptag(o, \"IDAT\")"
  },
  {
    "label": "STBIW_MEMMOVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_MEMMOVE(o, zlib, zlen)"
  },
  {
    "label": "STBIW_FREE()",
    "kind": "Method",
    "detail": "Function (o + = zlen ;)",
    "insertText": "STBIW_FREE(zlib)"
  },
  {
    "label": "stbiw__wpcrc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__wpcrc(&o, zlen)"
  },
  {
    "label": "stbiw__wp32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__wp32(o,0)"
  },
  {
    "label": "stbiw__wptag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__wptag(o, \"IEND\")"
  },
  {
    "label": "stbiw__wpcrc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__wpcrc(&o,0)"
  },
  {
    "label": "STBIW_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_ASSERT(o == out + *out_len)"
  },
  {
    "label": "stbi_write_png_to_mem()",
    "kind": "Method",
    "detail": "Function (FILE* f ; int len ; unsigned char* png =)",
    "insertText": "stbi_write_png_to_mem((const unsigned char *) data, stride_bytes, x, y, comp, &len)"
  },
  {
    "label": "STBIW_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIW_FREE(png)"
  },
  {
    "label": "fclose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fclose(f)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "func(context, png, len)"
  },
  {
    "label": "bs()",
    "kind": "Method",
    "detail": "Function (int bitBuf =* bitBufP,bitCnt =* bitCntP ; bitCnt + = bs [ 1 ] ; bitBuf | =)",
    "insertText": "bs(24 - bitCnt)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (unsigned char)",
    "insertText": "c(bitBuf >> 16)"
  },
  {
    "label": "stbiw__putc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__putc(s, c)"
  },
  {
    "label": "stbiw__putc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__putc(s, 0)"
  },
  {
    "label": "stbiw__jpg_DCT()",
    "kind": "Method",
    "detail": "Function (} bitBuf<<= 8 ; bitCnt - = 8 ; }* bitBufP = bitBuf ;* bitCntP = bitCnt ; } void)",
    "insertText": "stbiw__jpg_DCT(float *d0p, float *d1p, float *d2p, float *d3p, float *d4p, float *d5p, float *d6p, float *d7p)"
  },
  {
    "label": "z1()",
    "kind": "Method",
    "detail": "Function (float d0 =* d0p,d1 =* d1p,d2 =* d2p,d3 =* d3p,d4 =* d4p,d5 =* d5p,d6 =* d6p,d7 =* d7p ; float z1,z2,z3,z4,z5,z11,z13 ; float tmp0 = d0 + d7 ; float tmp7 = d0 - d7 ; float tmp1 = d1 + d6 ; float tmp6 = d1 - d6 ; float tmp2 = d2 + d5 ; float tmp5 = d2 - d5 ; float tmp3 = d3 + d4 ; float tmp4 = d3 - d4 ; float tmp10 = tmp0 + tmp3 ; float tmp13 = tmp0 - tmp3 ; float tmp11 = tmp1 + tmp2 ; float tmp12 = tmp1 - tmp2 ; d0 = tmp10 + tmp11 ; d4 = tmp10 - tmp11 ;)",
    "insertText": "z1(tmp12 + tmp13)"
  },
  {
    "label": "z5()",
    "kind": "Method",
    "detail": "Function (d2 = tmp13 + z1 ; d6 = tmp13 - z1 ; tmp10 = tmp4 + tmp5 ; tmp11 = tmp5 + tmp6 ; tmp12 = tmp6 + tmp7 ;)",
    "insertText": "z5(tmp10 - tmp12)"
  },
  {
    "label": "stbiw__jpg_calcBits()",
    "kind": "Method",
    "detail": "Function (z2 = tmp10* 0 . 5 4 1 1 9 6 1 0 0 f + z5 ; z4 = tmp12* 1 . 3 0 6 5 6 2 9 6 5 f + z5 ; z3 = tmp11* 0 . 7 0 7 1 0 6 7 8 1 f ; z11 = tmp7 + z3 ; z13 = tmp7 - z3 ;* d5p = z13 + z2 ;* d3p = z13 - z2 ;* d1p = z11 + z4 ;* d7p = z11 - z4 ;* d0p = d0 ;* d2p = d2 ;* d4p = d4 ;* d6p = d6 ; } void)",
    "insertText": "stbiw__jpg_calcBits(int val, unsigned short bits[2])"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int tmp1 = val<0 ? - val : val ; val = val<0 ? val - 1 : val ; bits [ 1 ] = 1 ;)",
    "insertText": "while(tmp1 >>= 1)"
  },
  {
    "label": "val()",
    "kind": "Method",
    "detail": "Function (+ + bits [ 1 ] ; } bits [ 0 ] =)",
    "insertText": "val((1<<bits[1])-1)"
  },
  {
    "label": "stbiw__jpg_processDU()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "stbiw__jpg_processDU(stbi__write_context *s, int *bitBuf, int *bitCnt, float *CDU, float *fdtbl, int DC, const unsigned short HTDC[256][2], const unsigned short HTAC[256][2])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const unsigned short EOB [ 2 ] = { HTAC [ 0 x00 ] [ 0 ],HTAC [ 0 x00 ] [ 1 ] } ; const unsigned short M16zeroes [ 2 ] = { HTAC [ 0 xF0 ] [ 0 ],HTAC [ 0 xF0 ] [ 1 ] } ; int dataOff,i,diff,end0pos ; int DU [ 6 4 ] ;)",
    "insertText": "for(dataOff=0; dataOff<64; dataOff+=8)"
  },
  {
    "label": "stbiw__jpg_DCT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+1], &CDU[dataOff+2], &CDU[dataOff+3], &CDU[dataOff+4], &CDU[dataOff+5], &CDU[dataOff+6], &CDU[dataOff+7])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(dataOff=0; dataOff<8; ++dataOff)"
  },
  {
    "label": "stbiw__jpg_DCT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+8], &CDU[dataOff+16], &CDU[dataOff+24], &CDU[dataOff+32], &CDU[dataOff+40], &CDU[dataOff+48], &CDU[dataOff+56])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i=0; i<64; ++i)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (float v = CDU [ i ]* fdtbl [ i ] ; DU [ stbiw__jpg_ZigZag [)",
    "insertText": "i(int)(v < 0 ? v - 0.5f : v + 0.5f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} diff = DU [ 0 ] - DC ;)",
    "insertText": "if(diff == 0)"
  },
  {
    "label": "stbiw__jpg_writeBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[0])"
  },
  {
    "label": "stbiw__jpg_calcBits()",
    "kind": "Method",
    "detail": "Function (} else { unsigned short bits [ 2 ] ;)",
    "insertText": "stbiw__jpg_calcBits(diff, bits)"
  },
  {
    "label": "stbiw__jpg_writeBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[bits[1]])"
  },
  {
    "label": "stbiw__jpg_writeBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} end0pos = 6 3 ;)",
    "insertText": "for(; (end0pos>0)&&(DU[end0pos]==0); --end0pos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(end0pos == 0)"
  },
  {
    "label": "stbiw__jpg_writeBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int startpos = i ; int nrzeroes ; unsigned short bits [ 2 ] ;)",
    "insertText": "for(; DU[i]==0 && i<=end0pos; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} nrzeroes = i - startpos ;)",
    "insertText": "if(nrzeroes >= 16)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int lng = nrzeroes>> 4 ; int nrmarker ;)",
    "insertText": "for(nrmarker=1; nrmarker <= lng; ++nrmarker) stbiw__jpg_writeBits(s, bitBuf, bitCnt, M16zeroes)"
  },
  {
    "label": "stbiw__jpg_calcBits()",
    "kind": "Method",
    "detail": "Function (nrzeroes& = 1 5 ; })",
    "insertText": "stbiw__jpg_calcBits(DU[i], bits)"
  },
  {
    "label": "stbiw__jpg_writeBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTAC[(nrzeroes<<4)+bits[1]])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(end0pos != 63)"
  },
  {
    "label": "stbi_write_jpg_core()",
    "kind": "Method",
    "detail": "Function (} return DU [ 0 ] ; } int)",
    "insertText": "stbi_write_jpg_core(stbi__write_context *s, int width, int height, int comp, const void* data, int quality)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const unsigned char std_dc_luminance_nrcodes [ ] = { 0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0 } ; const unsigned char std_dc_luminance_values [ ] = { 0,1,2,3,4,5,6,7,8,9,1 0,1 1 } ; const unsigned char std_ac_luminance_nrcodes [ ] = { 0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0 x7d } ; const unsigned char std_ac_luminance_values [ ] = { 0 x01,0 x02,0 x03,0 x00,0 x04,0 x11,0 x05,0 x12,0 x21,0 x31,0 x41,0 x06,0 x13,0 x51,0 x61,0 x07,0 x22,0 x71,0 x14,0 x32,0 x81,0 x91,0 xa1,0 x08,0 x23,0 x42,0 xb1,0 xc1,0 x15,0 x52,0 xd1,0 xf0,0 x24,0 x33,0 x62,0 x72,0 x82,0 x09,0 x0a,0 x16,0 x17,0 x18,0 x19,0 x1a,0 x25,0 x26,0 x27,0 x28,0 x29,0 x2a,0 x34,0 x35,0 x36,0 x37,0 x38,0 x39,0 x3a,0 x43,0 x44,0 x45,0 x46,0 x47,0 x48,0 x49,0 x4a,0 x53,0 x54,0 x55,0 x56,0 x57,0 x58,0 x59,0 x5a,0 x63,0 x64,0 x65,0 x66,0 x67,0 x68,0 x69,0 x6a,0 x73,0 x74,0 x75,0 x76,0 x77,0 x78,0 x79,0 x7a,0 x83,0 x84,0 x85,0 x86,0 x87,0 x88,0 x89,0 x8a,0 x92,0 x93,0 x94,0 x95,0 x96,0 x97,0 x98,0 x99,0 x9a,0 xa2,0 xa3,0 xa4,0 xa5,0 xa6,0 xa7,0 xa8,0 xa9,0 xaa,0 xb2,0 xb3,0 xb4,0 xb5,0 xb6,0 xb7,0 xb8,0 xb9,0 xba,0 xc2,0 xc3,0 xc4,0 xc5,0 xc6,0 xc7,0 xc8,0 xc9,0 xca,0 xd2,0 xd3,0 xd4,0 xd5,0 xd6,0 xd7,0 xd8,0 xd9,0 xda,0 xe1,0 xe2,0 xe3,0 xe4,0 xe5,0 xe6,0 xe7,0 xe8,0 xe9,0 xea,0 xf1,0 xf2,0 xf3,0 xf4,0 xf5,0 xf6,0 xf7,0 xf8,0 xf9,0 xfa } ; const unsigned char std_dc_chrominance_nrcodes [ ] = { 0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0 } ; const unsigned char std_dc_chrominance_values [ ] = { 0,1,2,3,4,5,6,7,8,9,1 0,1 1 } ; const unsigned char std_ac_chrominance_nrcodes [ ] = { 0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0 x77 } ; const unsigned char std_ac_chrominance_values [ ] = { 0 x00,0 x01,0 x02,0 x03,0 x11,0 x04,0 x05,0 x21,0 x31,0 x06,0 x12,0 x41,0 x51,0 x07,0 x61,0 x71,0 x13,0 x22,0 x32,0 x81,0 x08,0 x14,0 x42,0 x91,0 xa1,0 xb1,0 xc1,0 x09,0 x23,0 x33,0 x52,0 xf0,0 x15,0 x62,0 x72,0 xd1,0 x0a,0 x16,0 x24,0 x34,0 xe1,0 x25,0 xf1,0 x17,0 x18,0 x19,0 x1a,0 x26,0 x27,0 x28,0 x29,0 x2a,0 x35,0 x36,0 x37,0 x38,0 x39,0 x3a,0 x43,0 x44,0 x45,0 x46,0 x47,0 x48,0 x49,0 x4a,0 x53,0 x54,0 x55,0 x56,0 x57,0 x58,0 x59,0 x5a,0 x63,0 x64,0 x65,0 x66,0 x67,0 x68,0 x69,0 x6a,0 x73,0 x74,0 x75,0 x76,0 x77,0 x78,0 x79,0 x7a,0 x82,0 x83,0 x84,0 x85,0 x86,0 x87,0 x88,0 x89,0 x8a,0 x92,0 x93,0 x94,0 x95,0 x96,0 x97,0 x98,0 x99,0 x9a,0 xa2,0 xa3,0 xa4,0 xa5,0 xa6,0 xa7,0 xa8,0 xa9,0 xaa,0 xb2,0 xb3,0 xb4,0 xb5,0 xb6,0 xb7,0 xb8,0 xb9,0 xba,0 xc2,0 xc3,0 xc4,0 xc5,0 xc6,0 xc7,0 xc8,0 xc9,0 xca,0 xd2,0 xd3,0 xd4,0 xd5,0 xd6,0 xd7,0 xd8,0 xd9,0 xda,0 xe2,0 xe3,0 xe4,0 xe5,0 xe6,0 xe7,0 xe8,0 xe9,0 xea,0 xf2,0 xf3,0 xf4,0 xf5,0 xf6,0 xf7,0 xf8,0 xf9,0 xfa } ; const unsigned short YDC_HT [ 2 5 6 ] [ 2 ] = { { 0,2 },{ 2,3 },{ 3,3 },{ 4,3 },{ 5,3 },{ 6,3 },{ 1 4,4 },{ 3 0,5 },{ 6 2,6 },{ 1 2 6,7 },{ 2 5 4,8 },{ 5 1 0,9 } } ; const unsigned short UVDC_HT [ 2 5 6 ] [ 2 ] = { { 0,2 },{ 1,2 },{ 2,2 },{ 6,3 },{ 1 4,4 },{ 3 0,5 },{ 6 2,6 },{ 1 2 6,7 },{ 2 5 4,8 },{ 5 1 0,9 },{ 1 0 2 2,1 0 },{ 2 0 4 6,1 1 } } ; const unsigned short YAC_HT [ 2 5 6 ] [ 2 ] = { { 1 0,4 },{ 0,2 },{ 1,2 },{ 4,3 },{ 1 1,4 },{ 2 6,5 },{ 1 2 0,7 },{ 2 4 8,8 },{ 1 0 1 4,1 0 },{ 6 5 4 1 0,1 6 },{ 6 5 4 1 1,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 1 2,4 },{ 2 7,5 },{ 1 2 1,7 },{ 5 0 2,9 },{ 2 0 3 8,1 1 },{ 6 5 4 1 2,1 6 },{ 6 5 4 1 3,1 6 },{ 6 5 4 1 4,1 6 },{ 6 5 4 1 5,1 6 },{ 6 5 4 1 6,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 2 8,5 },{ 2 4 9,8 },{ 1 0 1 5,1 0 },{ 4 0 8 4,1 2 },{ 6 5 4 1 7,1 6 },{ 6 5 4 1 8,1 6 },{ 6 5 4 1 9,1 6 },{ 6 5 4 2 0,1 6 },{ 6 5 4 2 1,1 6 },{ 6 5 4 2 2,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 5 8,6 },{ 5 0 3,9 },{ 4 0 8 5,1 2 },{ 6 5 4 2 3,1 6 },{ 6 5 4 2 4,1 6 },{ 6 5 4 2 5,1 6 },{ 6 5 4 2 6,1 6 },{ 6 5 4 2 7,1 6 },{ 6 5 4 2 8,1 6 },{ 6 5 4 2 9,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 5 9,6 },{ 1 0 1 6,1 0 },{ 6 5 4 3 0,1 6 },{ 6 5 4 3 1,1 6 },{ 6 5 4 3 2,1 6 },{ 6 5 4 3 3,1 6 },{ 6 5 4 3 4,1 6 },{ 6 5 4 3 5,1 6 },{ 6 5 4 3 6,1 6 },{ 6 5 4 3 7,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 1 2 2,7 },{ 2 0 3 9,1 1 },{ 6 5 4 3 8,1 6 },{ 6 5 4 3 9,1 6 },{ 6 5 4 4 0,1 6 },{ 6 5 4 4 1,1 6 },{ 6 5 4 4 2,1 6 },{ 6 5 4 4 3,1 6 },{ 6 5 4 4 4,1 6 },{ 6 5 4 4 5,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 1 2 3,7 },{ 4 0 8 6,1 2 },{ 6 5 4 4 6,1 6 },{ 6 5 4 4 7,1 6 },{ 6 5 4 4 8,1 6 },{ 6 5 4 4 9,1 6 },{ 6 5 4 5 0,1 6 },{ 6 5 4 5 1,1 6 },{ 6 5 4 5 2,1 6 },{ 6 5 4 5 3,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 2 5 0,8 },{ 4 0 8 7,1 2 },{ 6 5 4 5 4,1 6 },{ 6 5 4 5 5,1 6 },{ 6 5 4 5 6,1 6 },{ 6 5 4 5 7,1 6 },{ 6 5 4 5 8,1 6 },{ 6 5 4 5 9,1 6 },{ 6 5 4 6 0,1 6 },{ 6 5 4 6 1,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 5 0 4,9 },{ 3 2 7 0 4,1 5 },{ 6 5 4 6 2,1 6 },{ 6 5 4 6 3,1 6 },{ 6 5 4 6 4,1 6 },{ 6 5 4 6 5,1 6 },{ 6 5 4 6 6,1 6 },{ 6 5 4 6 7,1 6 },{ 6 5 4 6 8,1 6 },{ 6 5 4 6 9,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 5 0 5,9 },{ 6 5 4 7 0,1 6 },{ 6 5 4 7 1,1 6 },{ 6 5 4 7 2,1 6 },{ 6 5 4 7 3,1 6 },{ 6 5 4 7 4,1 6 },{ 6 5 4 7 5,1 6 },{ 6 5 4 7 6,1 6 },{ 6 5 4 7 7,1 6 },{ 6 5 4 7 8,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 5 0 6,9 },{ 6 5 4 7 9,1 6 },{ 6 5 4 8 0,1 6 },{ 6 5 4 8 1,1 6 },{ 6 5 4 8 2,1 6 },{ 6 5 4 8 3,1 6 },{ 6 5 4 8 4,1 6 },{ 6 5 4 8 5,1 6 },{ 6 5 4 8 6,1 6 },{ 6 5 4 8 7,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 1 0 1 7,1 0 },{ 6 5 4 8 8,1 6 },{ 6 5 4 8 9,1 6 },{ 6 5 4 9 0,1 6 },{ 6 5 4 9 1,1 6 },{ 6 5 4 9 2,1 6 },{ 6 5 4 9 3,1 6 },{ 6 5 4 9 4,1 6 },{ 6 5 4 9 5,1 6 },{ 6 5 4 9 6,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 1 0 1 8,1 0 },{ 6 5 4 9 7,1 6 },{ 6 5 4 9 8,1 6 },{ 6 5 4 9 9,1 6 },{ 6 5 5 0 0,1 6 },{ 6 5 5 0 1,1 6 },{ 6 5 5 0 2,1 6 },{ 6 5 5 0 3,1 6 },{ 6 5 5 0 4,1 6 },{ 6 5 5 0 5,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 2 0 4 0,1 1 },{ 6 5 5 0 6,1 6 },{ 6 5 5 0 7,1 6 },{ 6 5 5 0 8,1 6 },{ 6 5 5 0 9,1 6 },{ 6 5 5 1 0,1 6 },{ 6 5 5 1 1,1 6 },{ 6 5 5 1 2,1 6 },{ 6 5 5 1 3,1 6 },{ 6 5 5 1 4,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 6 5 5 1 5,1 6 },{ 6 5 5 1 6,1 6 },{ 6 5 5 1 7,1 6 },{ 6 5 5 1 8,1 6 },{ 6 5 5 1 9,1 6 },{ 6 5 5 2 0,1 6 },{ 6 5 5 2 1,1 6 },{ 6 5 5 2 2,1 6 },{ 6 5 5 2 3,1 6 },{ 6 5 5 2 4,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 2 0 4 1,1 1 },{ 6 5 5 2 5,1 6 },{ 6 5 5 2 6,1 6 },{ 6 5 5 2 7,1 6 },{ 6 5 5 2 8,1 6 },{ 6 5 5 2 9,1 6 },{ 6 5 5 3 0,1 6 },{ 6 5 5 3 1,1 6 },{ 6 5 5 3 2,1 6 },{ 6 5 5 3 3,1 6 },{ 6 5 5 3 4,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 } } ; const unsigned short UVAC_HT [ 2 5 6 ] [ 2 ] = { { 0,2 },{ 1,2 },{ 4,3 },{ 1 0,4 },{ 2 4,5 },{ 2 5,5 },{ 5 6,6 },{ 1 2 0,7 },{ 5 0 0,9 },{ 1 0 1 4,1 0 },{ 4 0 8 4,1 2 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 1 1,4 },{ 5 7,6 },{ 2 4 6,8 },{ 5 0 1,9 },{ 2 0 3 8,1 1 },{ 4 0 8 5,1 2 },{ 6 5 4 1 6,1 6 },{ 6 5 4 1 7,1 6 },{ 6 5 4 1 8,1 6 },{ 6 5 4 1 9,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 2 6,5 },{ 2 4 7,8 },{ 1 0 1 5,1 0 },{ 4 0 8 6,1 2 },{ 3 2 7 0 6,1 5 },{ 6 5 4 2 0,1 6 },{ 6 5 4 2 1,1 6 },{ 6 5 4 2 2,1 6 },{ 6 5 4 2 3,1 6 },{ 6 5 4 2 4,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 2 7,5 },{ 2 4 8,8 },{ 1 0 1 6,1 0 },{ 4 0 8 7,1 2 },{ 6 5 4 2 5,1 6 },{ 6 5 4 2 6,1 6 },{ 6 5 4 2 7,1 6 },{ 6 5 4 2 8,1 6 },{ 6 5 4 2 9,1 6 },{ 6 5 4 3 0,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 5 8,6 },{ 5 0 2,9 },{ 6 5 4 3 1,1 6 },{ 6 5 4 3 2,1 6 },{ 6 5 4 3 3,1 6 },{ 6 5 4 3 4,1 6 },{ 6 5 4 3 5,1 6 },{ 6 5 4 3 6,1 6 },{ 6 5 4 3 7,1 6 },{ 6 5 4 3 8,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 5 9,6 },{ 1 0 1 7,1 0 },{ 6 5 4 3 9,1 6 },{ 6 5 4 4 0,1 6 },{ 6 5 4 4 1,1 6 },{ 6 5 4 4 2,1 6 },{ 6 5 4 4 3,1 6 },{ 6 5 4 4 4,1 6 },{ 6 5 4 4 5,1 6 },{ 6 5 4 4 6,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 1 2 1,7 },{ 2 0 3 9,1 1 },{ 6 5 4 4 7,1 6 },{ 6 5 4 4 8,1 6 },{ 6 5 4 4 9,1 6 },{ 6 5 4 5 0,1 6 },{ 6 5 4 5 1,1 6 },{ 6 5 4 5 2,1 6 },{ 6 5 4 5 3,1 6 },{ 6 5 4 5 4,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 1 2 2,7 },{ 2 0 4 0,1 1 },{ 6 5 4 5 5,1 6 },{ 6 5 4 5 6,1 6 },{ 6 5 4 5 7,1 6 },{ 6 5 4 5 8,1 6 },{ 6 5 4 5 9,1 6 },{ 6 5 4 6 0,1 6 },{ 6 5 4 6 1,1 6 },{ 6 5 4 6 2,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 2 4 9,8 },{ 6 5 4 6 3,1 6 },{ 6 5 4 6 4,1 6 },{ 6 5 4 6 5,1 6 },{ 6 5 4 6 6,1 6 },{ 6 5 4 6 7,1 6 },{ 6 5 4 6 8,1 6 },{ 6 5 4 6 9,1 6 },{ 6 5 4 7 0,1 6 },{ 6 5 4 7 1,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 5 0 3,9 },{ 6 5 4 7 2,1 6 },{ 6 5 4 7 3,1 6 },{ 6 5 4 7 4,1 6 },{ 6 5 4 7 5,1 6 },{ 6 5 4 7 6,1 6 },{ 6 5 4 7 7,1 6 },{ 6 5 4 7 8,1 6 },{ 6 5 4 7 9,1 6 },{ 6 5 4 8 0,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 5 0 4,9 },{ 6 5 4 8 1,1 6 },{ 6 5 4 8 2,1 6 },{ 6 5 4 8 3,1 6 },{ 6 5 4 8 4,1 6 },{ 6 5 4 8 5,1 6 },{ 6 5 4 8 6,1 6 },{ 6 5 4 8 7,1 6 },{ 6 5 4 8 8,1 6 },{ 6 5 4 8 9,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 5 0 5,9 },{ 6 5 4 9 0,1 6 },{ 6 5 4 9 1,1 6 },{ 6 5 4 9 2,1 6 },{ 6 5 4 9 3,1 6 },{ 6 5 4 9 4,1 6 },{ 6 5 4 9 5,1 6 },{ 6 5 4 9 6,1 6 },{ 6 5 4 9 7,1 6 },{ 6 5 4 9 8,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 5 0 6,9 },{ 6 5 4 9 9,1 6 },{ 6 5 5 0 0,1 6 },{ 6 5 5 0 1,1 6 },{ 6 5 5 0 2,1 6 },{ 6 5 5 0 3,1 6 },{ 6 5 5 0 4,1 6 },{ 6 5 5 0 5,1 6 },{ 6 5 5 0 6,1 6 },{ 6 5 5 0 7,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 2 0 4 1,1 1 },{ 6 5 5 0 8,1 6 },{ 6 5 5 0 9,1 6 },{ 6 5 5 1 0,1 6 },{ 6 5 5 1 1,1 6 },{ 6 5 5 1 2,1 6 },{ 6 5 5 1 3,1 6 },{ 6 5 5 1 4,1 6 },{ 6 5 5 1 5,1 6 },{ 6 5 5 1 6,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 1 6 3 5 2,1 4 },{ 6 5 5 1 7,1 6 },{ 6 5 5 1 8,1 6 },{ 6 5 5 1 9,1 6 },{ 6 5 5 2 0,1 6 },{ 6 5 5 2 1,1 6 },{ 6 5 5 2 2,1 6 },{ 6 5 5 2 3,1 6 },{ 6 5 5 2 4,1 6 },{ 6 5 5 2 5,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 1 0 1 8,1 0 },{ 3 2 7 0 7,1 5 },{ 6 5 5 2 6,1 6 },{ 6 5 5 2 7,1 6 },{ 6 5 5 2 8,1 6 },{ 6 5 5 2 9,1 6 },{ 6 5 5 3 0,1 6 },{ 6 5 5 3 1,1 6 },{ 6 5 5 3 2,1 6 },{ 6 5 5 3 3,1 6 },{ 6 5 5 3 4,1 6 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 },{ 0,0 } } ; const int YQT [ ] = { 1 6,1 1,1 0,1 6,2 4,4 0,5 1,6 1,1 2,1 2,1 4,1 9,2 6,5 8,6 0,5 5,1 4,1 3,1 6,2 4,4 0,5 7,6 9,5 6,1 4,1 7,2 2,2 9,5 1,8 7,8 0,6 2,1 8,2 2,3 7,5 6,6 8,1 0 9,1 0 3,7 7,2 4,3 5,5 5,6 4,8 1,1 0 4,1 1 3,9 2,4 9,6 4,7 8,8 7,1 0 3,1 2 1,1 2 0,1 0 1,7 2,9 2,9 5,9 8,1 1 2,1 0 0,1 0 3,9 9 } ; const int UVQT [ ] = { 1 7,1 8,2 4,4 7,9 9,9 9,9 9,9 9,1 8,2 1,2 6,6 6,9 9,9 9,9 9,9 9,2 4,2 6,5 6,9 9,9 9,9 9,9 9,9 9,4 7,6 6,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9,9 9 } ; const float aasf [ ] = { 1 . 0 f* 2 . 8 2 8 4 2 7 1 2 5 f,1 . 3 8 7 0 3 9 8 4 5 f* 2 . 8 2 8 4 2 7 1 2 5 f,1 . 3 0 6 5 6 2 9 6 5 f* 2 . 8 2 8 4 2 7 1 2 5 f,1 . 1 7 5 8 7 5 6 0 2 f* 2 . 8 2 8 4 2 7 1 2 5 f,1 . 0 f* 2 . 8 2 8 4 2 7 1 2 5 f,0 . 7 8 5 6 9 4 9 5 8 f* 2 . 8 2 8 4 2 7 1 2 5 f,0 . 5 4 1 1 9 6 1 0 0 f* 2 . 8 2 8 4 2 7 1 2 5 f,0 . 2 7 5 8 9 9 3 7 9 f* 2 . 8 2 8 4 2 7 1 2 5 f } ; int row,col,i,k ; float fdtbl_Y [ 6 4 ],fdtbl_UV [ 6 4 ] ; unsigned char YTable [ 6 4 ],UVTable [ 6 4 ] ;)",
    "insertText": "if(!data || !width || !height || comp > 4 || comp < 1)"
  },
  {
    "label": "yti()",
    "kind": "Method",
    "detail": "Function (int uvti,)",
    "insertText": "yti(YQT[i]*quality+50)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (YTable [ stbiw__jpg_ZigZag [)",
    "insertText": "i(unsigned char) (yti < 1 ? 1 : yti > 255 ? 255 : yti)"
  },
  {
    "label": "uvti()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uvti(UVQT[i]*quality+50)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (UVTable [ stbiw__jpg_ZigZag [)",
    "insertText": "i(unsigned char) (uvti < 1 ? 1 : uvti > 255 ? 255 : uvti)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(row = 0, k = 0; row < 8; ++row)"
  },
  {
    "label": "k()",
    "kind": "Method",
    "detail": "Function (fdtbl_Y [)",
    "insertText": "k(YTable [stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col])"
  },
  {
    "label": "k()",
    "kind": "Method",
    "detail": "Function (fdtbl_UV [)",
    "insertText": "k(UVTable[stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col])"
  },
  {
    "label": "x11()",
    "kind": "Method",
    "detail": "Function (} } { const unsigned char head0 [ ] = { 0 xFF,0 xD8,0 xFF,0 xE0,0,0 x10,' J ',' F ',' I ',' F ',0,1,1,0,0,1,0,1,0,0,0 xFF,0 xDB,0,0 x84,0 } ; const unsigned char head2 [ ] = { 0 xFF,0 xDA,0,0 xC,3,1,0,2,0 x11,3,0 x11,0,0 x3F,0 } ; const unsigned char head1 [ ] = { 0 xFF,0 xC0,0,0)",
    "insertText": "x11(unsigned char)(height>>8),STBIW_UCHAR(height),(unsigned char)(width>>8),STBIW_UCHAR(width)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)head0, sizeof(head0))"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)YTable, sizeof(YTable))"
  },
  {
    "label": "stbiw__putc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__putc(s, 1)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, UVTable, sizeof(UVTable))"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)head1, sizeof(head1))"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)(std_dc_luminance_nrcodes+1), sizeof(std_dc_luminance_nrcodes)-1)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)std_dc_luminance_values, sizeof(std_dc_luminance_values))"
  },
  {
    "label": "stbiw__putc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__putc(s, 0x10)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)(std_ac_luminance_nrcodes+1), sizeof(std_ac_luminance_nrcodes)-1)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)std_ac_luminance_values, sizeof(std_ac_luminance_values))"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)(std_dc_chrominance_nrcodes+1), sizeof(std_dc_chrominance_nrcodes)-1)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)std_dc_chrominance_values, sizeof(std_dc_chrominance_values))"
  },
  {
    "label": "stbiw__putc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__putc(s, 0x11)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)(std_ac_chrominance_nrcodes+1), sizeof(std_ac_chrominance_nrcodes)-1)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)std_ac_chrominance_values, sizeof(std_ac_chrominance_values))"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (s ->)",
    "insertText": "func(s->context, (void*)head2, sizeof(head2))"
  },
  {
    "label": "imageData()",
    "kind": "Method",
    "detail": "Function (} { const unsigned short fillBits [ ] = { 0 x7F,7 } ; const unsigned char*)",
    "insertText": "imageData(const unsigned char *)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int DCY = 0,DCU = 0,DCV = 0 ; int bitBuf = 0,bitCnt = 0 ; int ofsG = comp> 2 ? 1 : 0,ofsB = comp> 2 ? 2 : 0 ; int x,y,pos ;)",
    "insertText": "for(y = 0; y < height; y += 8)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (float YDU [ 6 4 ],UDU [ 6 4 ],VDU [ 6 4 ] ;)",
    "insertText": "for(row = y, pos = 0; row < y+8; ++row)"
  },
  {
    "label": "clamped_row()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "clamped_row(row < height)"
  },
  {
    "label": "base_p()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "base_p(stbi__flip_vertically_on_write ? (height-1-clamped_row) : clamped_row)"
  },
  {
    "label": "base_p()",
    "kind": "Method",
    "detail": "Function (float r,g,b ; int p =)",
    "insertText": "base_p((col < width) ? col : (width-1))"
  },
  {
    "label": "stbiw__jpg_processDU()",
    "kind": "Method",
    "detail": "Function (r = imageData [ p + 0 ] ; g = imageData [ p + ofsG ] ; b = imageData [ p + ofsB ] ; YDU [ pos ] = + 0 . 2 9 9 0 0 f* r + 0 . 5 8 7 0 0 f* g + 0 . 1 1 4 0 0 f* b - 1 2 8 ; UDU [ pos ] = - 0 . 1 6 8 7 4 f* r - 0 . 3 3 1 2 6 f* g + 0 . 5 0 0 0 0 f* b ; VDU [ pos ] = + 0 . 5 0 0 0 0 f* r - 0 . 4 1 8 6 9 f* g - 0 . 0 8 1 3 1 f* b ; } } DCY =)",
    "insertText": "stbiw__jpg_processDU(s, &bitBuf, &bitCnt, YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT)"
  },
  {
    "label": "stbiw__jpg_processDU()",
    "kind": "Method",
    "detail": "Function (DCU =)",
    "insertText": "stbiw__jpg_processDU(s, &bitBuf, &bitCnt, UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT)"
  },
  {
    "label": "stbiw__jpg_processDU()",
    "kind": "Method",
    "detail": "Function (DCV =)",
    "insertText": "stbiw__jpg_processDU(s, &bitBuf, &bitCnt, VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT)"
  },
  {
    "label": "stbiw__jpg_writeBits()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "stbiw__jpg_writeBits(s, &bitBuf, &bitCnt, fillBits)"
  },
  {
    "label": "stbiw__putc()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "stbiw__putc(s, 0xFF)"
  },
  {
    "label": "stbiw__putc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbiw__putc(s, 0xD9)"
  },
  {
    "label": "stbi_write_jpg_core()",
    "kind": "Method",
    "detail": "Function (int r =)",
    "insertText": "stbi_write_jpg_core(&s, x, y, comp, data, quality)"
  }
]