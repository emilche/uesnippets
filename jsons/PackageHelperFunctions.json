[
  {
    "label": "Error",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Error"
  },
  {
    "label": "EPackageNormalizationFlags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EPackageNormalizationFlags"
  },
  {
    "label": "FContentHelper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FContentHelper"
  },
  {
    "label": "AssetSetPolicy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AssetSetPolicy"
  },
  {
    "label": "DECLARE_LOG_CATEGORY_EXTERN()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Misc / Paths . h \" # include \" HAL / FileManager . h \" # include \" Misc / PackageName . h \" # include \" Commandlets / Commandlet . h \" # include \" Misc / FeedbackContext . h \" # include \" FileHelpers . h \" # include \" CollectionManagerTypes . h \" class Error ;)",
    "insertText": "DECLARE_LOG_CATEGORY_EXTERN(LogPackageHelperFunctions, Log, All)"
  },
  {
    "label": "SearchDirectoryRecursive()",
    "kind": "Method",
    "detail": "Function (enum EPackageNormalizationFlags { NORMALIZE_ResetExistingLoaders = 0 x01,NORMALIZE_ExcludeMapPackages = 0 x02,NORMALIZE_ExcludeContentPackages = 0 x04,NORMALIZE_ExcludeDeveloperPackages = 0 x08,NORMALIZE_ExcludeNonDeveloperPackages = 0 x10,NORMALIZE_ExcludeEnginePackages = 0 x20,NORMALIZE_ExcludeNoRedistPackages = 0 x40,NORMALIZE_ExcludeLocalizedPackages = 0 x80,NORMALIZE_DefaultFlags = NORMALIZE_ResetExistingLoaders,} ; void)",
    "insertText": "SearchDirectoryRecursive(const FString& SearchPathMask, TArray<FString>& out_PackageNames, TArray<FString>& out_PackageFilenames)"
  },
  {
    "label": "NormalizePackageNames()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "NormalizePackageNames(TArray<FString> PackageNames, TArray<FString>& PackagePathNames, const FString& PackageWildcard=FString(TEXT(\"*.*\")), uint8 PackageFilter=NORMALIZE_DefaultFlags)"
  },
  {
    "label": "SavePackageHelper()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SavePackageHelper(UPackage* Package, FString Filename, EObjectFlags KeepObjectFlags = RF_Standalone, FOutputDevice* ErrorDevice=GWarn, ESaveFlags SaveFlags = SAVE_None)"
  },
  {
    "label": "FContentHelper()",
    "kind": "Method",
    "detail": "Function (class FContentHelper { public :)",
    "insertText": "FContentHelper() : bInitialized(false)"
  },
  {
    "label": "FContentHelper()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FContentHelper()"
  },
  {
    "label": "Shutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Shutdown()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "Initialize()"
  },
  {
    "label": "CreateCollection()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CreateCollection(FName CollectionName, ECollectionShareType::Type InType)"
  },
  {
    "label": "ClearCollection()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ClearCollection(FName InCollectionName, ECollectionShareType::Type InType)"
  },
  {
    "label": "SetCollection()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SetCollection(FName InCollectionName, ECollectionShareType::Type InType, const TArray<FSoftObjectPath>& InAssetList)"
  },
  {
    "label": "UpdateCollection()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UpdateCollection(FName InCollectionName, ECollectionShareType::Type InType, const TArray<FSoftObjectPath>& InAddList, const TArray<FSoftObjectPath>& InRemoveList)"
  },
  {
    "label": "QueryAssetsInCollection()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "QueryAssetsInCollection(FName InCollectionName, ECollectionShareType::Type InType, TArray<FSoftObjectPath>& OutAssetPaths)"
  },
  {
    "label": "CreateAssetSet()",
    "kind": "Method",
    "detail": "Function (protected : template<class AssetSetPolicy> bool)",
    "insertText": "CreateAssetSet(FName InSetName, ECollectionShareType::Type InSetType)"
  },
  {
    "label": "ClearAssetSet()",
    "kind": "Method",
    "detail": "Function (template<class AssetSetPolicy> bool)",
    "insertText": "ClearAssetSet(FName InSetName, ECollectionShareType::Type InSetType)"
  },
  {
    "label": "AssignSetContent()",
    "kind": "Method",
    "detail": "Function (template<class AssetSetPolicy> bool)",
    "insertText": "AssignSetContent(FName InSetName, ECollectionShareType::Type InType, const TArray<FSoftObjectPath>& InAssetList)"
  },
  {
    "label": "UpdateSetContent()",
    "kind": "Method",
    "detail": "Function (template<class AssetSetPolicy> bool)",
    "insertText": "UpdateSetContent(FName InSetName, ECollectionShareType::Type InType, const TArray<FSoftObjectPath>& InAddList, const TArray<FSoftObjectPath>& InRemoveList)"
  },
  {
    "label": "QuerySetContent()",
    "kind": "Method",
    "detail": "Function (template<class AssetSetPolicy> bool)",
    "insertText": "QuerySetContent(FName InCollectionName, ECollectionShareType::Type InType, TArray<FSoftObjectPath>& OutAssetPaths)"
  },
  {
    "label": "DoActionToAllPackages()",
    "kind": "Method",
    "detail": "Function (bool bInitialized ; } ; template<OBJECTYPE,FUNCTOR> void)",
    "insertText": "DoActionToAllPackages(UCommandlet* Commandlet, const FString& Params)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (TArray<FString> Tokens ; TArray<FString> Switches ;)",
    "insertText": "UE_LOG(LogPackageHelperFunctions, Warning, TEXT(\"%s\"), *Params)"
  },
  {
    "label": "ParseCommandLine()",
    "kind": "Method",
    "detail": "Function (const TCHAR* Parms =* Params ;)",
    "insertText": "ParseCommandLine(Parms, Tokens, Switches)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (const bool bVerbose = Switches .)",
    "insertText": "Contains(TEXT(\"VERBOSE\"))"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (const bool bLoadMaps = Switches .)",
    "insertText": "Contains(TEXT(\"LOADMAPS\"))"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (const bool bOverrideLoadMaps = Switches .)",
    "insertText": "Contains(TEXT(\"OVERRIDELOADMAPS\"))"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (const bool bOnlyLoadMaps = Switches .)",
    "insertText": "Contains(TEXT(\"ONLYLOADMAPS\"))"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (const bool bSkipReadOnly = Switches .)",
    "insertText": "Contains(TEXT(\"SKIPREADONLY\"))"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (const bool bOverrideSkipOnly = Switches .)",
    "insertText": "Contains(TEXT(\"OVERRIDEREADONLY\"))"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (const bool bGCEveryPackage = Switches .)",
    "insertText": "Contains(TEXT(\"GCEVERYPACKAGE\"))"
  },
  {
    "label": "FindAllPackageFiles()",
    "kind": "Method",
    "detail": "Function (TArray<FString> FilesInPath ;)",
    "insertText": "FindAllPackageFiles(FilesInPath)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 GCIndex = 0 ;)",
    "insertText": "for(int32 FileIndex = 0; FileIndex < FilesInPath.Num(); FileIndex++)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (const FString& Filename = FilesInPath [ FileIndex ] ; const bool bIsAutoSave = Filename .)",
    "insertText": "Contains(TEXT(\"AUTOSAVES\"))"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (const bool bIsReadOnly =)",
    "insertText": "Get().IsReadOnly( *Filename)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } })",
    "insertText": "if(((!bLoadMaps && !bOnlyLoadMaps) || bOverrideLoadMaps) && ( FPaths::GetExtension(Filename, true) == FPackageName::GetMapPackageExtension() ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(( bOnlyLoadMaps == true ) && ( FPaths::GetExtension(Filename, true) != FPackageName::GetMapPackageExtension() ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(bVerbose == true)"
  },
  {
    "label": "LoadPackage()",
    "kind": "Method",
    "detail": "Function (} UPackage* Package =)",
    "insertText": "LoadPackage(NULL, *Filename, LOAD_None)"
  },
  {
    "label": "OBJECTYPE()",
    "kind": "Method",
    "detail": "Function (FUNCTOR TheFunctor ; TheFunctor . template DoIt<)",
    "insertText": "OBJECTYPE(Commandlet, Package, Tokens, Switches)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "UE_LOG(LogPackageHelperFunctions, Error, TEXT(\"Error loading %s!\"), *Filename)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(( (++GCIndex % 10) == 0 ) || ( bGCEveryPackage == true ))"
  },
  {
    "label": "CollectGarbage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CollectGarbage(RF_NoFlags)"
  }
]