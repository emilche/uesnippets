[
  {
    "label": "Bucket",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Bucket"
  },
  {
    "label": "HistogramSamples",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HistogramSamples"
  },
  {
    "label": "HistogramTester",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HistogramTester"
  },
  {
    "label": "HistogramTester()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TEST_METRICS_HISTOGRAM_TESTER_H_ # define BASE_TEST_METRICS_HISTOGRAM_TESTER_H_ # include<functional> # include<map> # include<memory> # include<ostream> # include<string> # include<type_traits> # include<utility> # include<vector> # include \" base / metrics / histogram . h \" # include \" base / metrics / histogram_base . h \" # include \" base / strings / string_piece . h \" # include \" base / time / time . h \" # include \" testing / gmock / include / gmock / gmock . h \" namespace base { struct Bucket ; class HistogramSamples ; class HistogramTester { public : using CountsMap = std::map<std::string,HistogramBase::Count,std::less<>> ;)",
    "insertText": "HistogramTester()"
  },
  {
    "label": "HistogramTester()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HistogramTester(const HistogramTester&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (HistogramTester&)",
    "insertText": "operator(const HistogramTester&)"
  },
  {
    "label": "ExpectUniqueSample()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectUniqueSample(StringPiece name, HistogramBase::Sample sample, HistogramBase::Count expected_bucket_count)"
  },
  {
    "label": "ExpectUniqueSample()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "ExpectUniqueSample(StringPiece name, T sample, HistogramBase::Count expected_bucket_count)"
  },
  {
    "label": "ExpectUniqueSample()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectUniqueSample(name, static_cast<HistogramBase::Sample>(sample), expected_bucket_count)"
  },
  {
    "label": "ExpectUniqueTimeSample()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExpectUniqueTimeSample(StringPiece name, TimeDelta sample, HistogramBase::Count expected_bucket_count)"
  },
  {
    "label": "ExpectBucketCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectBucketCount(StringPiece name, HistogramBase::Sample sample, HistogramBase::Count expected_count)"
  },
  {
    "label": "ExpectBucketCount()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "ExpectBucketCount(StringPiece name, T sample, HistogramBase::Count expected_count)"
  },
  {
    "label": "ExpectBucketCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectBucketCount(name, static_cast<HistogramBase::Sample>(sample), expected_count)"
  },
  {
    "label": "ExpectTotalCount()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExpectTotalCount(StringPiece name, HistogramBase::Count count)"
  },
  {
    "label": "ExpectTimeBucketCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectTimeBucketCount(StringPiece name, TimeDelta sample, HistogramBase::Count count)"
  },
  {
    "label": "GetTotalSum()",
    "kind": "Method",
    "detail": "Function (int64_t)",
    "insertText": "GetTotalSum(StringPiece name)"
  },
  {
    "label": "GetAllSamples()",
    "kind": "Method",
    "detail": "Function (std::vector<Bucket>)",
    "insertText": "GetAllSamples(StringPiece name)"
  },
  {
    "label": "GetBucketCount()",
    "kind": "Method",
    "detail": "Function (HistogramBase::Count)",
    "insertText": "GetBucketCount(StringPiece name, HistogramBase::Sample sample)"
  },
  {
    "label": "GetBucketCount()",
    "kind": "Method",
    "detail": "Function (template<T> HistogramBase::Count)",
    "insertText": "GetBucketCount(StringPiece name, T sample)"
  },
  {
    "label": "GetTotalCountsForPrefix()",
    "kind": "Method",
    "detail": "Function (} CountsMap)",
    "insertText": "GetTotalCountsForPrefix(StringPiece prefix)"
  },
  {
    "label": "GetHistogramSamplesSinceCreation()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<HistogramSamples>)",
    "insertText": "GetHistogramSamplesSinceCreation(StringPiece histogram_name)"
  },
  {
    "label": "GetAllHistogramsRecorded()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "GetAllHistogramsRecorded()"
  },
  {
    "label": "CheckBucketCount()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "CheckBucketCount(StringPiece name, HistogramBase::Sample sample, Histogram::Count expected_count, const HistogramSamples& samples)"
  },
  {
    "label": "GetTotalCountForSamples()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetTotalCountForSamples(StringPiece name, const HistogramSamples& samples)"
  },
  {
    "label": "CheckTotalCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckTotalCount(StringPiece name, Histogram::Count expected_count, const HistogramSamples& samples)"
  },
  {
    "label": "GetBucketCountForSamples()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetBucketCountForSamples(StringPiece name, HistogramBase::Sample sample, const HistogramSamples& samples, HistogramBase::Count* count)"
  },
  {
    "label": "Bucket()",
    "kind": "Method",
    "detail": "Function (std::map<std::string,std::unique_ptr<HistogramSamples>,std::less<>> histograms_snapshot_ ; } ; struct Bucket {)",
    "insertText": "Bucket(HistogramBase::Sample min, HistogramBase::Count count) : min(min), count(count)"
  },
  {
    "label": "Bucket()",
    "kind": "Method",
    "detail": "Function (} template<MetricEnum,= std::enable_if_t<std::is_enum_v<MetricEnum>>>)",
    "insertText": "Bucket(MetricEnum min, HistogramBase::Count count) : Bucket(static_cast<std::underlying_type_t<MetricEnum>>(min), count)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const Bucket& other)"
  },
  {
    "label": "PrintTo()",
    "kind": "Method",
    "detail": "Function (HistogramBase::Sample min ; HistogramBase::Count count ; } ; void)",
    "insertText": "PrintTo(const Bucket& value, std::ostream* os)"
  },
  {
    "label": "BucketsAreArray()",
    "kind": "Method",
    "detail": "Function (template<BucketArray> auto)",
    "insertText": "BucketsAreArray(BucketArray buckets)"
  },
  {
    "label": "EraseIf()",
    "kind": "Method",
    "detail": "Function (auto non_empty_buckets = buckets ;)",
    "insertText": "EraseIf(non_empty_buckets, [](Bucket b) { return b.count == 0; })"
  },
  {
    "label": "BucketsAre()",
    "kind": "Method",
    "detail": "Function (} template<. . . BucketTypes> auto)",
    "insertText": "BucketsAre(BucketTypes... buckets)"
  },
  {
    "label": "BucketsIncludeArray()",
    "kind": "Method",
    "detail": "Function (} template<BucketArray> auto)",
    "insertText": "BucketsIncludeArray(const BucketArray& buckets)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::vector<HistogramBase::Sample> empty_buckets ; std::vector<Bucket> non_empty_buckets ;)",
    "insertText": "for(const Bucket& b : buckets)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (empty_buckets .)",
    "insertText": "push_back(b.min)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} else { non_empty_buckets .)",
    "insertText": "push_back(b)"
  },
  {
    "label": "AllOf()",
    "kind": "Method",
    "detail": "Function (} } using::testing::AllOf ; using::testing::AnyOfArray ; using::testing::Each ; using::testing::Field ; using::testing::IsSupersetOf ; using::testing::Not ; return)",
    "insertText": "AllOf(IsSupersetOf(non_empty_buckets), Each(Field(\"Bucket::min\", &Bucket::min, Not(AnyOfArray(empty_buckets)))))"
  },
  {
    "label": "BucketsInclude()",
    "kind": "Method",
    "detail": "Function (} template<. . . BucketTypes> auto)",
    "insertText": "BucketsInclude(BucketTypes... buckets)"
  }
]