[
  {
    "label": "FRHIGPUMemoryReadback",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRHIGPUMemoryReadback"
  },
  {
    "label": "FRHIGPUBufferReadback",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRHIGPUBufferReadback"
  },
  {
    "label": "FRHIGPUTextureReadback",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRHIGPUTextureReadback"
  },
  {
    "label": "FRHIGPUMemoryReadback()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" RHI . h \" # include \" DynamicRHI . h \" # include \" RHICommandList . h \" class FRHIGPUMemoryReadback { public :)",
    "insertText": "FRHIGPUMemoryReadback(FName RequestName)"
  },
  {
    "label": "RHICreateGPUFence()",
    "kind": "Method",
    "detail": "Function (Fence =)",
    "insertText": "RHICreateGPUFence(RequestName)"
  },
  {
    "label": "FRHIGPUMemoryReadback()",
    "kind": "Method",
    "detail": "Function (LastLockGPUIndex = 0 ; } ~)",
    "insertText": "FRHIGPUMemoryReadback()"
  },
  {
    "label": "IsReady()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsReady()"
  },
  {
    "label": "IsReady()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsReady(FRHIGPUMask GPUMask)"
  },
  {
    "label": "EnqueueCopy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EnqueueCopy(FRHICommandList& RHICmdList, FRHIBuffer* SourceBuffer, uint32 NumBytes = 0)"
  },
  {
    "label": "unimplemented()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unimplemented()"
  },
  {
    "label": "EnqueueCopy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EnqueueCopy(FRHICommandList& RHICmdList, FRHITexture* SourceTexture, const FIntVector& SourcePosition, uint32 SourceSlice, const FIntVector& Size)"
  },
  {
    "label": "EnqueueCopy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EnqueueCopy(FRHICommandList& RHICmdList, FRHITexture* SourceTexture, FResolveRect Rect = FResolveRect())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FIntVector SourcePosition,Size ;)",
    "insertText": "if(Rect.IsValid())"
  },
  {
    "label": "FIntVector()",
    "kind": "Method",
    "detail": "Function (SourcePosition =)",
    "insertText": "FIntVector(Rect.X1, Rect.Y1, 0)"
  },
  {
    "label": "FIntVector()",
    "kind": "Method",
    "detail": "Function (Size =)",
    "insertText": "FIntVector(Rect.X2 - Rect.X1, Rect.Y2 - Rect.Y1, 1)"
  },
  {
    "label": "EnqueueCopy()",
    "kind": "Method",
    "detail": "Function (} else { SourcePosition = FIntVector::ZeroValue ; Size = FIntVector::ZeroValue ; })",
    "insertText": "EnqueueCopy(RHICmdList, SourceTexture, SourcePosition, 0, Size)"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "Lock(uint32 NumBytes)"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unlock()"
  },
  {
    "label": "FRHIGPUBufferReadback()",
    "kind": "Method",
    "detail": "Function (} protected : FGPUFenceRHIRef Fence ; FRHIGPUMask LastCopyGPUMask ; uint32 LastLockGPUIndex ; } ; class FRHIGPUBufferReadback final : public FRHIGPUMemoryReadback { public :)",
    "insertText": "FRHIGPUBufferReadback(FName RequestName)"
  },
  {
    "label": "GetGPUSizeBytes()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "GetGPUSizeBytes()"
  },
  {
    "label": "FRHIGPUTextureReadback()",
    "kind": "Method",
    "detail": "Function (private : # if WITH_MGPU FStagingBufferRHIRef DestinationStagingBuffers [ MAX_NUM_GPUS ] ; # else FStagingBufferRHIRef DestinationStagingBuffers [ 1 ] ; # endif } ; class FRHIGPUTextureReadback final : public FRHIGPUMemoryReadback { public :)",
    "insertText": "FRHIGPUTextureReadback(FName RequestName)"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "Lock(int32& OutRowPitchInPixels, int32* OutBufferHeight = nullptr)"
  }
]