[
  {
    "label": "Type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Type"
  },
  {
    "label": "TDynamicVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TDynamicVector"
  },
  {
    "label": "FIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FIterator"
  },
  {
    "label": "FConstIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConstIterator"
  },
  {
    "label": "TBlockVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TBlockVector"
  },
  {
    "label": "TDynamicVectorN",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TDynamicVectorN"
  },
  {
    "label": "ElementVectorN",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ElementVectorN"
  },
  {
    "label": "TDynamicVector()",
    "kind": "Method",
    "detail": "Function (# pragma once # include<CoreMinimal . h> # include \" Containers / StaticArray . h \" # include \" Serialization / Archive . h \" # include<UObject / UE5MainStreamObjectVersion . h> # include \" VectorTypes . h \" # include \" IndexTypes . h \" # include \" Math / NumericLimits . h \" namespace UE { namespace Geometry { using namespace UE::Math ; template<class Type> class TDynamicVector { public : uint32 MaxSize = MAX_uint32 ;)",
    "insertText": "TDynamicVector()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Blocks .)",
    "insertText": "Add(new BlockType())"
  },
  {
    "label": "TDynamicVector()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TDynamicVector(const TDynamicVector& Copy)"
  },
  {
    "label": "TDynamicVector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDynamicVector(TDynamicVector&& Moved)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Blocks =)",
    "insertText": "MoveTemp(Moved.Blocks)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (CurBlock =)",
    "insertText": "MoveTemp(Moved.CurBlock)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (CurBlockUsed =)",
    "insertText": "MoveTemp(Moved.CurBlockUsed)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Moved . CurBlock = 0 ; Moved . CurBlockUsed = 0 ; } TDynamicVector&)",
    "insertText": "operator(const TDynamicVector& Copy)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TDynamicVector&)",
    "insertText": "operator(TDynamicVector&& Moved)"
  },
  {
    "label": "TDynamicVector()",
    "kind": "Method",
    "detail": "Function (Moved . CurBlock = 0 ; Moved . CurBlockUsed = 0 ; return* this ; })",
    "insertText": "TDynamicVector(const TArray<Type>& Array)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNum((unsigned int) Array.Num())"
  },
  {
    "label": "TDynamicVector()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TDynamicVector(TArrayView<const Type> Array)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Clear()"
  },
  {
    "label": "Fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Fill(const Type& Value)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Resize(unsigned int Count)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Resize(unsigned int Count, const Type& InitValue)"
  },
  {
    "label": "SetMinimumSize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SetMinimumSize(unsigned int Count, const Type& InitValue)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNum(unsigned int Count)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Resize(Count)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "GetBlockSize()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetBlockSize()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Add(const Type& Data)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(const TDynamicVector& Data)"
  },
  {
    "label": "PopBack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopBack()"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertAt(const Type& Data, unsigned int Index)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertAt(const Type& Data, unsigned int Index, const Type& InitValue)"
  },
  {
    "label": "ElementAt()",
    "kind": "Method",
    "detail": "Function (Type&)",
    "insertText": "ElementAt(unsigned int Index, Type InitialValue = Type{})"
  },
  {
    "label": "Front()",
    "kind": "Method",
    "detail": "Function (const Type&)",
    "insertText": "Front()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(FArchive& Ar, TDynamicVector& Vec)"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (Vec . Serialize<false,)",
    "insertText": "false(Ar)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FUE5MainStreamObjectVersion::GUID)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const SIZE_T CountBytes = 3*)",
    "insertText": "sizeof(uint32) + Blocks.Num() * BlockSize * sizeof(Type)"
  },
  {
    "label": "CountBytes()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "CountBytes(CountBytes, CountBytes)"
  },
  {
    "label": "Serialize_LegacyLoad()",
    "kind": "Method",
    "detail": "Function (Ar<<CurBlock ; Ar<<CurBlockUsed ; Blocks .)",
    "insertText": "Serialize_LegacyLoad(Ar)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const SIZE_T Count =)",
    "insertText": "Num()"
  },
  {
    "label": "SetCurBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCurBlock(Count)"
  },
  {
    "label": "Truncate()",
    "kind": "Method",
    "detail": "Function (Blocks .)",
    "insertText": "Truncate(int32(Count / BlockSize), EAllowShrinking::No)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const SIZE_T CountBytes =)",
    "insertText": "sizeof(uint32) + SerializeNum * sizeof(Type)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<SerializeNum ;)",
    "insertText": "if(SerializeNum == 0 && Ar.IsLoading())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(SerializeNum > 0)"
  },
  {
    "label": "SetCurBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCurBlock(SerializeNum)"
  },
  {
    "label": "bUseCompression()",
    "kind": "Method",
    "detail": "Function (Blocks . template Serialize<bForceBulkSerialization,)",
    "insertText": "bUseCompression(Ar, SerializeNum)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } } public : class FIterator { public : const Type&)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Idx + + ; return* this ; } FIterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (FIterator)",
    "insertText": "Copy(*this)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Idx + + ; return Copy ; } bool)",
    "insertText": "operator(const FIterator& Itr2)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} TDynamicVector* DVector { } ; unsigned int Idx { 0 } ; } ; FIterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (this,0 } ; } FIterator)",
    "insertText": "end()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Idx + + ; return Copy ; } bool)",
    "insertText": "operator(const FConstIterator& Itr2)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} private : int nShiftBits = 9 ; int BlockSize = 1<<nShiftBits ; int BlockIndexBitmask = BlockSize - 1 ;)",
    "insertText": "static_assert(BlockSize && ((BlockSize & (BlockSize - 1)) == 0), \"DynamicVector: BlockSize must be a power of two\")"
  },
  {
    "label": "TBlockVector()",
    "kind": "Method",
    "detail": "Function (unsigned int MaxBlockCount = MaxSize / BlockSize + 1 ; unsigned int CurBlock { 0 } ; unsigned int CurBlockUsed { 0 } ; using BlockType = TStaticArray<Type,BlockSize> ; template<ArrayType> class TBlockVector { protected : TArray<ArrayType*> Elements ; public :)",
    "insertText": "TBlockVector()"
  },
  {
    "label": "TBlockVector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TBlockVector(TBlockVector&& Moved)"
  },
  {
    "label": "TBlockVector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TBlockVector(const TBlockVector& Copy)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Reserve(N)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Add(new ArrayType(*Copy.Elements[k]))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } TBlockVector&)",
    "insertText": "operator(const TBlockVector& Copy)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty(N)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } return* this ; } TBlockVector&)",
    "insertText": "operator(TBlockVector&& Moved)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty()"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Elements =)",
    "insertText": "MoveTemp(Moved.Elements)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # if UE_BUILD_DEBUG ArrayType&)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "Add(ArrayType* NewElement)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "Add(NewElement)"
  },
  {
    "label": "Truncate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Truncate(int32 NewElementCount, EAllowShrinking AllowShrinking)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (delete Elements [ k ] ; Elements [ k ] = nullptr ; } Elements .)",
    "insertText": "RemoveAt(NewElementCount, Elements.Num() - NewElementCount, AllowShrinking)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Empty(int32 NewReservedSize = 0)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (delete Elements [ k ] ; } Elements .)",
    "insertText": "Empty(NewReservedSize)"
  },
  {
    "label": "Serialize_LegacyLoad()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Serialize_LegacyLoad(FArchive& Ar)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (bool bIsLWCBulkSerializedDoubleType = std::is_same_v<Type,FVector2d> | | std::is_same_v<Type,FVector3d> | | std::is_same_v<Type,FVector4d> | | std::is_same_v<Type,FQuat4d> | | std::is_same_v<Type,FTransform3d> ; const bool bUseBulkSerialization = TCanBulkSerialize<Type)",
    "insertText": "Value(bIsLWCBulkSerializedDoubleType && Ar.UEVer() < EUnrealEngineObjectUE5Version::LARGE_WORLD_COORDINATES)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (const auto SerializeElement = bUseBulkSerialization ? static_cast<)",
    "insertText": "void(*)(FArchive&, ArrayType*)>([](FArchive& Archive, ArrayType* Element) { Archive.Serialize(Element->GetData(), Element->Num() * sizeof(Type)); }) : static_cast<void(*)(FArchive&, ArrayType*)>([](FArchive& Archive, ArrayType* Element) { Archive << *Element; })"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (Ar<<BlockNum ;)",
    "insertText": "Empty(BlockNum)"
  },
  {
    "label": "SerializeElement()",
    "kind": "Method",
    "detail": "Function (ArrayType* NewElement = new ArrayType ;)",
    "insertText": "SerializeElement(Ar, NewElement)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} } } template<bool bForceBulkSerialization,bool bUseCompression> void)",
    "insertText": "Serialize(FArchive& Ar, uint32 Num)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (bool bUseBulkSerialization = bForceBulkSerialization | | TCanBulkSerialize<Type>::Value | |)",
    "insertText": "sizeof(Type)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bUseCompressionForBulkSerialization = bUseBulkSerialization&& bUseCompression ; Ar<<bUseCompressionForBulkSerialization ; const bool bNumIsNotMultipleOfBlockSize = Num % BlockSize ! = 0 ; const uint32 NumBlocks = Num / BlockSize + bNumIsNotMultipleOfBlockSize ;)",
    "insertText": "if(bUseCompressionForBulkSerialization)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<Type> Buffer ; Buffer .)",
    "insertText": "SetNumUninitialized(Num)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (Type* BufferPtr = Buffer .)",
    "insertText": "GetData()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SIZE_T NumCopyRemaining = Num ;)",
    "insertText": "if(!Ar.IsLoading())"
  },
  {
    "label": "SIZE_T()",
    "kind": "Method",
    "detail": "Function (const SIZE_T NumCopy = FMath::template Min<)",
    "insertText": "SIZE_T(NumCopyRemaining, (SIZE_T)BlockSize)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(BufferPtr, Elements[Index]->GetData(), NumCopy * sizeof(Type))"
  },
  {
    "label": "SerializeCompressedNew()",
    "kind": "Method",
    "detail": "Function (BufferPtr + = NumCopy ; NumCopyRemaining - = BlockSize ; } } Ar .)",
    "insertText": "SerializeCompressedNew(Buffer.GetData(), Num * sizeof(Type), NAME_Oodle, NAME_Oodle, COMPRESS_NoFlags, false, nullptr)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Empty(NumBlocks)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(NewElement->GetData(), BufferPtr, NumCopy * sizeof(Type))"
  },
  {
    "label": "bUseBulkSerialization()",
    "kind": "Method",
    "detail": "Function (BufferPtr + = NumCopy ; NumCopyRemaining - = BlockSize ; } } } else { const auto SerializeElement = [& Ar,)",
    "insertText": "bUseBulkSerialization(ArrayType* Element, uint32 ElementNum)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Serialize(Element->GetData(), ElementNum * sizeof(Type))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(uint32 Index = 0; Index < ElementNum; ++Index)"
  },
  {
    "label": "Ar()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Ar(*Element)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } ;)",
    "insertText": "if(Ar.IsLoading())"
  },
  {
    "label": "SerializeElement()",
    "kind": "Method",
    "detail": "Function (ArrayType* const NewElement = new ArrayType ;)",
    "insertText": "SerializeElement(NewElement, FMath::template Min<uint32>(Num, BlockSize))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Num - = BlockSize ; } } else {)",
    "insertText": "for(uint32 Index = 0; Index < NumBlocks; ++Index)"
  },
  {
    "label": "SerializeElement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SerializeElement(&(*this)[Index], FMath::template Min<uint32>(Num, BlockSize))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Num - = BlockSize ; } } } } } ; bool)",
    "insertText": "operator(const TDynamicVector& Lhs, const TDynamicVector& Rhs)"
  },
  {
    "label": "SetCurBlock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCurBlock(SIZE_T Count)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (const int32 LastItemIndex =)",
    "insertText": "int32(Count - 1)"
  },
  {
    "label": "Count()",
    "kind": "Method",
    "detail": "Function (CurBlock = Count ! = 0 ? LastItemIndex>> nShiftBits : 0 ; CurBlockUsed =)",
    "insertText": "Count(LastItemIndex & BlockIndexBitmask)"
  },
  {
    "label": "TDynamicVectorN()",
    "kind": "Method",
    "detail": "Function (} TBlockVector<BlockType> Blocks ; } ; template<class Type,int N> class TDynamicVectorN { public :)",
    "insertText": "TDynamicVectorN()"
  },
  {
    "label": "TDynamicVectorN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDynamicVectorN(const TDynamicVectorN& Copy)"
  },
  {
    "label": "TDynamicVectorN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TDynamicVectorN(TDynamicVectorN&& Moved)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TDynamicVectorN&)",
    "insertText": "operator(const TDynamicVectorN& Copy)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TDynamicVectorN&)",
    "insertText": "operator(TDynamicVectorN&& Moved)"
  },
  {
    "label": "Fill()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "Fill(Value)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "Resize(Count * N)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "Resize(Count * N, InitValue)"
  },
  {
    "label": "GetLength()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "GetLength()"
  },
  {
    "label": "GetByteCount()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "GetByteCount()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} struct ElementVectorN { Type Data [ N ] ; } ; void)",
    "insertText": "Add(const ElementVectorN& AddData)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "Add(AddData.Data[i])"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "InsertAt(const ElementVectorN& AddData, unsigned int Index)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "InsertAt(AddData.Data[N - i], N * (Index + 1) - i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } Type&)",
    "insertText": "operator()(unsigned int TopIndex, unsigned int SubIndex)"
  },
  {
    "label": "SetVector3()",
    "kind": "Method",
    "detail": "Function (unsigned int i = TopIndex* N ; Data [ i ] = V . X ; Data [ i + 1 ] = V . Y ; } void)",
    "insertText": "SetVector3(unsigned int TopIndex, const TVector<Type>& V)"
  },
  {
    "label": "AsVector2()",
    "kind": "Method",
    "detail": "Function (unsigned int i = TopIndex* N ; Data [ i ] = V . X ; Data [ i + 1 ] = V . Y ; Data [ i + 2 ] = V . Z ; } TVector2<Type>)",
    "insertText": "AsVector2(unsigned int TopIndex)"
  },
  {
    "label": "AsVector3()",
    "kind": "Method",
    "detail": "Function (} TVector<Type>)",
    "insertText": "AsVector3(unsigned int TopIndex)"
  },
  {
    "label": "AsIndex2()",
    "kind": "Method",
    "detail": "Function (} FIndex2i)",
    "insertText": "AsIndex2(unsigned int TopIndex)"
  },
  {
    "label": "AsIndex3()",
    "kind": "Method",
    "detail": "Function (} FIndex3i)",
    "insertText": "AsIndex3(unsigned int TopIndex)"
  },
  {
    "label": "AsIndex4()",
    "kind": "Method",
    "detail": "Function (} FIndex4i)",
    "insertText": "AsIndex4(unsigned int TopIndex)"
  },
  {
    "label": "Truncate()",
    "kind": "Method",
    "detail": "Function (Blocks .)",
    "insertText": "Truncate(1, EAllowShrinking::No)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CurBlock = 0 ; CurBlockUsed = 0 ;)",
    "insertText": "if(Blocks.Num() == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + NumBlocksCurrent ; })",
    "insertText": "if(NumBlocksCurrent > NumBlocksNeeded)"
  },
  {
    "label": "Truncate()",
    "kind": "Method",
    "detail": "Function (Blocks .)",
    "insertText": "Truncate(NumBlocksNeeded, EAllowShrinking::No)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "operator(Index)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} return true ; } template<class Type> void TDynamicVector<Type)",
    "insertText": "Add(const Type& Value)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} CurBlock + + ; CurBlockUsed = 0 ; } Blocks [ CurBlock ] [ CurBlockUsed ] = Value ; CurBlockUsed + + ; } template<class Type> void TDynamicVector<Type)",
    "insertText": "Add(const TDynamicVector<Type>& AddData)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(AddData[k])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CurBlockUsed - - ; })",
    "insertText": "if(CurBlockUsed == 0 && CurBlock > 0)"
  },
  {
    "label": "ElementAt()",
    "kind": "Method",
    "detail": "Function (CurBlock - - ; CurBlockUsed = BlockSize ; } } template<class Type> Type& TDynamicVector<Type)",
    "insertText": "ElementAt(unsigned int Index, Type InitialValue)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(InitialValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Index > s)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Resize(Index)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (} template<class Type> void TDynamicVector<Type)",
    "insertText": "InsertAt(const Type& AddData, unsigned int Index)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(AddData)"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "else(*this)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (} } template<class Type> void TDynamicVector<Type)",
    "insertText": "InsertAt(const Type& AddData, unsigned int Index, const Type& InitValue)"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertAt(AddData, Index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "operator(i)"
  },
  {
    "label": "Apply()",
    "kind": "Method",
    "detail": "Function (} } template<Type> template<Func> void TDynamicVector<Type)",
    "insertText": "Apply(const Func& applyF)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (auto block = Blocks [ bi ] ;)",
    "insertText": "for(int k = 0; k < BlockSize; ++k)"
  },
  {
    "label": "applyF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applyF(block[k], k)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } auto lastblock = Blocks [ CurBlock ] ;)",
    "insertText": "for(int k = 0; k < CurBlockUsed; ++k)"
  },
  {
    "label": "applyF()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applyF(lastblock[k], k)"
  }
]