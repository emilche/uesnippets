[
  {
    "label": "traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "traits"
  },
  {
    "label": "FullPivLU",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FullPivLU"
  },
  {
    "label": "SolverBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SolverBase"
  },
  {
    "label": "kernel_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "kernel_retval"
  },
  {
    "label": "image_retval",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "image_retval"
  },
  {
    "label": "Assignment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Assignment"
  },
  {
    "label": "EIGEN_GENERIC_PUBLIC_INTERFACE()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_LU_H # define EIGEN_LU_H namespace Eigen { namespace internal { template<_MatrixType> struct traits<FullPivLU<_MatrixType>> : traits<_MatrixType> { typedef MatrixXpr XprKind ; typedef SolverStorage StorageKind ; typedef int StorageIndex ; enum { Flags = 0 } ; } ; } template<_MatrixType> class FullPivLU : public SolverBase<FullPivLU<_MatrixType>> { public : typedef _MatrixType MatrixType ; typedef SolverBase<FullPivLU> Base ; class SolverBase<FullPivLU> ;)",
    "insertText": "EIGEN_GENERIC_PUBLIC_INTERFACE(FullPivLU)"
  },
  {
    "label": "FullPivLU()",
    "kind": "Method",
    "detail": "Function (MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime } ; typedef internal::plain_row_type<MatrixType,StorageIndex>::type IntRowVectorType ; typedef internal::plain_col_type<MatrixType,StorageIndex>::type IntColVectorType ; typedef PermutationMatrix<ColsAtCompileTime,MaxColsAtCompileTime> PermutationQType ; typedef PermutationMatrix<RowsAtCompileTime,MaxRowsAtCompileTime> PermutationPType ; typedef MatrixType::PlainObject PlainObject ;)",
    "insertText": "FullPivLU()"
  },
  {
    "label": "FullPivLU()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FullPivLU(Index rows, Index cols)"
  },
  {
    "label": "FullPivLU()",
    "kind": "Method",
    "detail": "Function (template<InputType>)",
    "insertText": "FullPivLU(const EigenBase<InputType>& matrix)"
  },
  {
    "label": "FullPivLU()",
    "kind": "Method",
    "detail": "Function (template<InputType>)",
    "insertText": "FullPivLU(EigenBase<InputType>& matrix)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (template<InputType> FullPivLU&)",
    "insertText": "compute(const EigenBase<InputType>& matrix)"
  },
  {
    "label": "derived()",
    "kind": "Method",
    "detail": "Function (m_lu = matrix .)",
    "insertText": "derived()"
  },
  {
    "label": "computeInPlace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeInPlace()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized && \"LU is not initialized.\")"
  },
  {
    "label": "image()",
    "kind": "Method",
    "detail": "Function (} const internal::image_retval<FullPivLU>)",
    "insertText": "image(const MatrixType& originalMatrix)"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (} # ifdef EIGEN_PARSED_BY_DOXYGEN template<Rhs> const Solve<FullPivLU,Rhs>)",
    "insertText": "solve(const MatrixBase<Rhs>& b)"
  },
  {
    "label": "rcond()",
    "kind": "Method",
    "detail": "Function (# endif RealScalar)",
    "insertText": "rcond()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized && \"PartialPivLU is not initialized.\")"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (} internal::traits<MatrixType>::Scalar)",
    "insertText": "determinant()"
  },
  {
    "label": "setThreshold()",
    "kind": "Method",
    "detail": "Function (FullPivLU&)",
    "insertText": "setThreshold(const RealScalar& threshold)"
  },
  {
    "label": "setThreshold()",
    "kind": "Method",
    "detail": "Function (m_usePrescribedThreshold = true ; m_prescribedThreshold = threshold ; return* this ; } FullPivLU&)",
    "insertText": "setThreshold(Default_t)"
  },
  {
    "label": "threshold()",
    "kind": "Method",
    "detail": "Function (m_usePrescribedThreshold = false ; return* this ; } RealScalar)",
    "insertText": "threshold()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized || m_usePrescribedThreshold)"
  },
  {
    "label": "rank()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "rank()"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (RealScalar premultiplied_threshold =)",
    "insertText": "abs(m_maxpivot) * threshold()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index result = 0 ;)",
    "insertText": "for(Index i = 0; i < m_nonzero_pivots; ++i) result += (abs(m_lu.coeff(i,i)) > premultiplied_threshold)"
  },
  {
    "label": "isInjective()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isInjective()"
  },
  {
    "label": "isSurjective()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isSurjective()"
  },
  {
    "label": "isInvertible()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isInvertible()"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (} const Inverse<FullPivLU>)",
    "insertText": "inverse()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_lu.rows() == m_lu.cols() && \"You can't take the inverse of a non-square matrix!\")"
  },
  {
    "label": "reconstructedMatrix()",
    "kind": "Method",
    "detail": "Function (} MatrixType)",
    "insertText": "reconstructedMatrix()"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index)",
    "insertText": "cols()"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (} # ifndef EIGEN_PARSED_BY_DOXYGEN template<RhsType,DstType> void)",
    "insertText": "_solve_impl(const RhsType &rhs, DstType &dst)"
  },
  {
    "label": "_solve_impl_transposed()",
    "kind": "Method",
    "detail": "Function (template<bool Conjugate,RhsType,DstType> void)",
    "insertText": "_solve_impl_transposed(const RhsType &rhs, DstType &dst)"
  },
  {
    "label": "check_template_parameters()",
    "kind": "Method",
    "detail": "Function (# endif protected : void)",
    "insertText": "check_template_parameters()"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_NON_INTEGER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)"
  },
  {
    "label": "FullPivLU()",
    "kind": "Method",
    "detail": "Function (MatrixType m_lu ; PermutationPType m_p ; PermutationQType m_q ; IntColVectorType m_rowsTranspositions ; IntRowVectorType m_colsTranspositions ; Index m_nonzero_pivots ; RealScalar m_l1_norm ; RealScalar m_maxpivot,m_prescribedThreshold ; signed char m_det_pq ; bool m_isInitialized,m_usePrescribedThreshold ; } ; template<MatrixType> FullPivLU<MatrixType)",
    "insertText": "FullPivLU() : m_isInitialized(false), m_usePrescribedThreshold(false)"
  },
  {
    "label": "FullPivLU()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> FullPivLU<MatrixType)",
    "insertText": "FullPivLU(Index rows, Index cols) : m_lu(rows, cols), m_p(rows), m_q(cols), m_rowsTranspositions(rows), m_colsTranspositions(cols), m_isInitialized(false), m_usePrescribedThreshold(false)"
  },
  {
    "label": "FullPivLU()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> template<InputType> FullPivLU<MatrixType)",
    "insertText": "FullPivLU(const EigenBase<InputType>& matrix) : m_lu(matrix.rows(), matrix.cols()), m_p(matrix.rows()), m_q(matrix.cols()), m_rowsTranspositions(matrix.rows()), m_colsTranspositions(matrix.cols()), m_isInitialized(false), m_usePrescribedThreshold(false)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(matrix.derived())"
  },
  {
    "label": "FullPivLU()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> template<InputType> FullPivLU<MatrixType)",
    "insertText": "FullPivLU(EigenBase<InputType>& matrix) : m_lu(matrix.derived()), m_p(matrix.rows()), m_q(matrix.cols()), m_rowsTranspositions(matrix.rows()), m_colsTranspositions(matrix.cols()), m_isInitialized(false), m_usePrescribedThreshold(false)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_lu.rows()<=NumTraits<int>::highest() && m_lu.cols()<=NumTraits<int>::highest())"
  },
  {
    "label": "cwiseAbs()",
    "kind": "Method",
    "detail": "Function (m_l1_norm = m_lu .)",
    "insertText": "cwiseAbs().colwise().sum().maxCoeff()"
  },
  {
    "label": "diagonalSize()",
    "kind": "Method",
    "detail": "Function (const Index size = m_lu .)",
    "insertText": "diagonalSize()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_rowsTranspositions .)",
    "insertText": "resize(m_lu.rows())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_colsTranspositions .)",
    "insertText": "resize(m_lu.cols())"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (Index number_of_transpositions = 0 ; m_nonzero_pivots = size ; m_maxpivot =)",
    "insertText": "RealScalar(0)"
  },
  {
    "label": "bottomRightCorner()",
    "kind": "Method",
    "detail": "Function (Index row_of_biggest_in_corner,col_of_biggest_in_corner ; typedef internal::scalar_score_coeff_op<Scalar> Scoring ; typedef Scoring::result_type Score ; Score biggest_in_corner ; biggest_in_corner = m_lu .)",
    "insertText": "bottomRightCorner(rows-k, cols-k) .unaryExpr(Scoring()) .maxCoeff(&row_of_biggest_in_corner, &col_of_biggest_in_corner)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (row_of_biggest_in_corner + = k ; col_of_biggest_in_corner + = k ;)",
    "insertText": "if(biggest_in_corner==Score(0))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (m_nonzero_pivots = k ;)",
    "insertText": "for(Index i = k; i < size; ++i)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (m_rowsTranspositions .)",
    "insertText": "coeffRef(i) = internal::convert_index<StorageIndex>(i)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (} break ; } RealScalar abs_pivot = internal::abs_knowing_score<)",
    "insertText": "Scalar()(m_lu(row_of_biggest_in_corner, col_of_biggest_in_corner), biggest_in_corner)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (m_rowsTranspositions .)",
    "insertText": "coeffRef(k) = internal::convert_index<StorageIndex>(row_of_biggest_in_corner)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (m_colsTranspositions .)",
    "insertText": "coeffRef(k) = internal::convert_index<StorageIndex>(col_of_biggest_in_corner)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (m_lu .)",
    "insertText": "row(k).swap(m_lu.row(row_of_biggest_in_corner))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + number_of_transpositions ; })",
    "insertText": "if(k != col_of_biggest_in_corner)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (m_lu .)",
    "insertText": "col(k).swap(m_lu.col(col_of_biggest_in_corner))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + number_of_transpositions ; })",
    "insertText": "if(k<rows-1) m_lu.col(k).tail(rows-k-1) /= m_lu.coeff(k,k)"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (} m_p .)",
    "insertText": "setIdentity(rows)"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (m_q .)",
    "insertText": "setIdentity(cols)"
  },
  {
    "label": "m_det_pq()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_det_pq(number_of_transpositions%2)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_lu.rows() == m_lu.cols() && \"You can't take the determinant of a non-square matrix!\")"
  },
  {
    "label": "smalldim()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "smalldim(std::min)(m_lu.rows(), m_lu.cols())"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (MatrixType)",
    "insertText": "res(m_lu.rows(),m_lu.cols())"
  },
  {
    "label": "leftCols()",
    "kind": "Method",
    "detail": "Function (res = m_lu .)",
    "insertText": "leftCols(smalldim) .template triangularView<UnitLower>().toDenseMatrix() * m_lu.topRows(smalldim) .template triangularView<Upper>().toDenseMatrix()"
  },
  {
    "label": "EIGEN_SIZE_MIN_PREFER_FIXED()",
    "kind": "Method",
    "detail": "Function (MaxSmallDimAtCompileTime =)",
    "insertText": "EIGEN_SIZE_MIN_PREFER_FIXED(MatrixType::MaxColsAtCompileTime, MatrixType::MaxRowsAtCompileTime)"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (template<Dest> void)",
    "insertText": "evalTo(Dest& dst)"
  },
  {
    "label": "dec()",
    "kind": "Method",
    "detail": "Function (using std::abs ; const Index cols =)",
    "insertText": "dec().matrixLU().cols(), dimker = cols - rank()"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "setZero()"
  },
  {
    "label": "dec()",
    "kind": "Method",
    "detail": "Function (RealScalar premultiplied_threshold =)",
    "insertText": "dec().maxPivot() * dec().threshold()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index p = 0 ;)",
    "insertText": "for(Index i = 0; i < dec().nonzeroPivots(); ++i) if(abs(dec().matrixLU().coeff(i,i)) > premultiplied_threshold) pivots.coeffRef(p++)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(p == rank())"
  },
  {
    "label": "m()",
    "kind": "Method",
    "detail": "Function (Matrix<MatrixType::Scalar,Dynamic,Dynamic,MatrixType::Options,MaxSmallDimAtCompileTime,MatrixType::MaxColsAtCompileTime>)",
    "insertText": "m(dec().matrixLU().block(0, 0, rank(), cols))"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (m .)",
    "insertText": "row(i).tail(cols-i) = dec().matrixLU().row(pivots.coeff(i)).tail(cols-i)"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (} m .)",
    "insertText": "block(0, 0, rank(), rank())"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (m .)",
    "insertText": "block(0, 0, rank(), rank()).template triangularView<StrictlyLower>().setZero()"
  },
  {
    "label": "topLeftCorner()",
    "kind": "Method",
    "detail": "Function (m .)",
    "insertText": "topLeftCorner(rank(), rank()) .template triangularView<Upper>().solveInPlace( m.topRightCorner(rank(), dimker))"
  },
  {
    "label": "EIGEN_MAKE_IMAGE_HELPERS()",
    "kind": "Method",
    "detail": "Function (} } ; template<_MatrixType> struct image_retval<FullPivLU<_MatrixType>> : image_retval_base<FullPivLU<_MatrixType>> {)",
    "insertText": "EIGEN_MAKE_IMAGE_HELPERS(FullPivLU<_MatrixType>)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using std::abs ;)",
    "insertText": "if(rank() == 0)"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (const Index rows = this ->)",
    "insertText": "rows(), cols = this->cols(), nonzero_pivots = this->rank()"
  },
  {
    "label": "smalldim()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "smalldim(std::min)(rows, cols)"
  },
  {
    "label": "permutationP()",
    "kind": "Method",
    "detail": "Function (c =)",
    "insertText": "permutationP()"
  },
  {
    "label": "topLeftCorner()",
    "kind": "Method",
    "detail": "Function (m_lu .)",
    "insertText": "topLeftCorner(smalldim,smalldim) .template triangularView<UnitLower>() .solveInPlace(c.topRows(smalldim))"
  },
  {
    "label": "topLeftCorner()",
    "kind": "Method",
    "detail": "Function (m_lu .)",
    "insertText": "topLeftCorner(nonzero_pivots, nonzero_pivots) .template triangularView<Upper>() .solveInPlace(c.topRows(nonzero_pivots))"
  },
  {
    "label": "permutationQ()",
    "kind": "Method",
    "detail": "Function (c =)",
    "insertText": "permutationQ().inverse()"
  },
  {
    "label": "topLeftCorner()",
    "kind": "Method",
    "detail": "Function (m_lu .)",
    "insertText": "topLeftCorner(nonzero_pivots, nonzero_pivots) .template triangularView<Upper>() .transpose() .template conjugateIf<Conjugate>() .solveInPlace(c.topRows(nonzero_pivots))"
  },
  {
    "label": "topLeftCorner()",
    "kind": "Method",
    "detail": "Function (m_lu .)",
    "insertText": "topLeftCorner(smalldim, smalldim) .template triangularView<UnitLower>() .transpose() .template conjugateIf<Conjugate>() .solveInPlace(c.topRows(smalldim))"
  },
  {
    "label": "permutationP()",
    "kind": "Method",
    "detail": "Function (PermutationPType invp =)",
    "insertText": "permutationP().inverse().eval()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} # endif namespace internal { template<DstXprType,MatrixType> struct Assignment<DstXprType,Inverse<FullPivLU<MatrixType>>,internal::assign_op<DstXprType::Scalar,FullPivLU<MatrixType>::Scalar>,Dense2Dense> { typedef FullPivLU<MatrixType> LuType ; typedef Inverse<LuType> SrcXprType ; void)",
    "insertText": "run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename MatrixType::Scalar> &)"
  },
  {
    "label": "nestedExpression()",
    "kind": "Method",
    "detail": "Function (dst = src .)",
    "insertText": "nestedExpression().solve(MatrixType::Identity(src.rows(), src.cols()))"
  },
  {
    "label": "fullPivLu()",
    "kind": "Method",
    "detail": "Function (} } ; } template<Derived> const FullPivLU<MatrixBase<Derived>::PlainObject> MatrixBase<Derived)",
    "insertText": "fullPivLu()"
  }
]