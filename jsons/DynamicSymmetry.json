[
  {
    "label": "DynamicSGroup",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DynamicSGroup"
  },
  {
    "label": "GroupElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GroupElement"
  },
  {
    "label": "Generator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Generator"
  },
  {
    "label": "DynamicSGroupFromTemplateArgs",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DynamicSGroupFromTemplateArgs"
  },
  {
    "label": "DynamicSGroup()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_CXX11_TENSORSYMMETRY_DYNAMICSYMMETRY_H # define EIGEN_CXX11_TENSORSYMMETRY_DYNAMICSYMMETRY_H namespace Eigen { class DynamicSGroup { public :)",
    "insertText": "DynamicSGroup() : m_numIndices(1), m_elements(), m_generators(), m_globalFlags(0)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (m_elements .)",
    "insertText": "push_back(ge(Generator(0, 0, 0)))"
  },
  {
    "label": "DynamicSGroup()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DynamicSGroup(const DynamicSGroup& o) : m_numIndices(o.m_numIndices), m_elements(o.m_elements), m_generators(o.m_generators), m_globalFlags(o.m_globalFlags)"
  },
  {
    "label": "DynamicSGroup()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DynamicSGroup(DynamicSGroup&& o) : m_numIndices(o.m_numIndices), m_elements(), m_generators(o.m_generators), m_globalFlags(o.m_globalFlags)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_elements, o.m_elements)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} DynamicSGroup&)",
    "insertText": "operator(const DynamicSGroup& o)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (m_numIndices = o . m_numIndices ; m_elements = o . m_elements ; m_generators = o . m_generators ; m_globalFlags = o . m_globalFlags ; return* this ; } DynamicSGroup&)",
    "insertText": "operator(DynamicSGroup&& o)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (m_generators = o . m_generators ; m_globalFlags = o . m_globalFlags ; return* this ; } void)",
    "insertText": "add(int one, int two, int flags = 0)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (template<Gen_> void)",
    "insertText": "add(Gen_)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(Gen_::One, Gen_::Two, Gen_::Flags)"
  },
  {
    "label": "addSymmetry()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addSymmetry(int one, int two)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(one, two, 0)"
  },
  {
    "label": "addAntiSymmetry()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addAntiSymmetry(int one, int two)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(one, two, NegationFlag)"
  },
  {
    "label": "addHermiticity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addHermiticity(int one, int two)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(one, two, ConjugationFlag)"
  },
  {
    "label": "addAntiHermiticity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addAntiHermiticity(int one, int two)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(one, two, NegationFlag | ConjugationFlag)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (} template<Op,RV,Index,std::size_t N,. . . Args> RV)",
    "insertText": "apply(const std::array<Index, N>& idx, RV initial, Args&&... args)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(N >= m_numIndices && \"Can only apply symmetry group to objects that have at least the required amount of indices.\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(idx.size() >= m_numIndices && \"Can only apply symmetry group to objects that have at least the required amount of indices.\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Tensor_,. . . IndexTypes> internal::tensor_symmetry_value_setter<Tensor_,DynamicSGroup>)",
    "insertText": "operator()(Tensor_& tensor, typename Tensor_::Index firstIndex, IndexTypes... otherIndices)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Tensor_> internal::tensor_symmetry_value_setter<Tensor_,DynamicSGroup>)",
    "insertText": "operator()(Tensor_& tensor, std::array<typename Tensor_::Index, Tensor_::NumIndices> const& indices)"
  },
  {
    "label": "isId()",
    "kind": "Method",
    "detail": "Function (} private : struct GroupElement { std::vector<int> representation ; int flags ; bool)",
    "insertText": "isId()"
  },
  {
    "label": "h_permute()",
    "kind": "Method",
    "detail": "Function (} } ; std::size_t m_numIndices ; std::vector<GroupElement> m_elements ; std::vector<Generator> m_generators ; int m_globalFlags ; template<Index,std::size_t N,int . . . n> std::array<Index,N>)",
    "insertText": "h_permute(std::size_t which, const std::array<Index, N>& idx, internal::numeric_list<int, n...>)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::vector<Index> result ; result .)",
    "insertText": "reserve(idx.size())"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (GroupElement result ; result . representation .)",
    "insertText": "reserve(m_numIndices)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (result . flags = g . flags ;)",
    "insertText": "for(std::size_t k = 0; k < m_numIndices; k++)"
  },
  {
    "label": "mul()",
    "kind": "Method",
    "detail": "Function (} return result ; } GroupElement)",
    "insertText": "mul(GroupElement, GroupElement)"
  },
  {
    "label": "mul()",
    "kind": "Method",
    "detail": "Function (GroupElement)",
    "insertText": "mul(Generator g1, GroupElement g2)"
  },
  {
    "label": "mul()",
    "kind": "Method",
    "detail": "Function (} GroupElement)",
    "insertText": "mul(GroupElement g1, Generator g2)"
  },
  {
    "label": "mul()",
    "kind": "Method",
    "detail": "Function (} GroupElement)",
    "insertText": "mul(Generator g1, Generator g2)"
  },
  {
    "label": "findElement()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "findElement(GroupElement e)"
  },
  {
    "label": "updateGlobalFlags()",
    "kind": "Method",
    "detail": "Function (} return - 1 ; } void)",
    "insertText": "updateGlobalFlags(int flagDiffOfSameGenerator)"
  },
  {
    "label": "DynamicSGroupFromTemplateArgs()",
    "kind": "Method",
    "detail": "Function (} ; template<. . . Gen> class DynamicSGroupFromTemplateArgs : public DynamicSGroup { public :)",
    "insertText": "DynamicSGroupFromTemplateArgs() : DynamicSGroup()"
  },
  {
    "label": "add_all()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add_all(internal::type_list<Gen...>())"
  },
  {
    "label": "DynamicSGroupFromTemplateArgs()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DynamicSGroupFromTemplateArgs(DynamicSGroupFromTemplateArgs const& other) : DynamicSGroup(other)"
  },
  {
    "label": "DynamicSGroupFromTemplateArgs()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DynamicSGroupFromTemplateArgs(DynamicSGroupFromTemplateArgs&& other) : DynamicSGroup(other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} DynamicSGroupFromTemplateArgs<Gen . . .>&)",
    "insertText": "operator(const DynamicSGroupFromTemplateArgs<Gen...>& o)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(o)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(Gen1())"
  },
  {
    "label": "add_all()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add_all(internal::type_list<GenNext...>())"
  },
  {
    "label": "add_all()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "add_all(internal::type_list<>)"
  },
  {
    "label": "mul()",
    "kind": "Method",
    "detail": "Function (} } ; DynamicSGroup::GroupElement)",
    "insertText": "mul(GroupElement g1, GroupElement g2)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(g1.representation.size() == m_numIndices)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(g2.representation.size() == m_numIndices)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (int v = g2 . representation [ g1 . representation [ i ] ] ;)",
    "insertText": "eigen_assert(v >= 0)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (result . representation .)",
    "insertText": "push_back(v)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} result . flags = g1 . flags ^ g2 . flags ; return result ; } void)",
    "insertText": "add(int one, int two, int flags)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(one >= 0)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(two >= 0)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(one != two)"
  },
  {
    "label": "newNumIndices()",
    "kind": "Method",
    "detail": "Function (std::size_t)",
    "insertText": "newNumIndices(one > two)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (gelem . representation .)",
    "insertText": "reserve(newNumIndices)"
  },
  {
    "label": "ge()",
    "kind": "Method",
    "detail": "Function (} m_numIndices = newNumIndices ; } Generator g { one,two,flags } ; GroupElement e =)",
    "insertText": "ge(g)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (m_elements .)",
    "insertText": "push_back(e)"
  },
  {
    "label": "mul()",
    "kind": "Method",
    "detail": "Function (e =)",
    "insertText": "mul(e, g)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(e.flags > 0) updateGlobalFlags(e.flags)"
  },
  {
    "label": "updateGlobalFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateGlobalFlags(p)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (m_generators .)",
    "insertText": "push_back(g)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::size_t coset_rep = coset_order ; do {)",
    "insertText": "for(auto g : m_generators)"
  },
  {
    "label": "mul()",
    "kind": "Method",
    "detail": "Function (e =)",
    "insertText": "mul(m_elements[coset_rep], g)"
  },
  {
    "label": "findElement()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "findElement(e)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(p > 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} } coset_rep + = coset_order ; })",
    "insertText": "while(coset_rep < m_elements.size())"
  }
]