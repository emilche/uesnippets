[
  {
    "label": "traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "traits"
  },
  {
    "label": "LLT_Traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LLT_Traits"
  },
  {
    "label": "LLT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LLT"
  },
  {
    "label": "SolverBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SolverBase"
  },
  {
    "label": "llt_inplace",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "llt_inplace"
  },
  {
    "label": "EIGEN_GENERIC_PUBLIC_INTERFACE()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_LLT_H # define EIGEN_LLT_H namespace Eigen { namespace internal { template<_MatrixType,int _UpLo> struct traits<LLT<_MatrixType,_UpLo>> : traits<_MatrixType> { typedef MatrixXpr XprKind ; typedef SolverStorage StorageKind ; typedef int StorageIndex ; enum { Flags = 0 } ; } ; template<MatrixType,int UpLo> struct LLT_Traits ; } template<_MatrixType,int _UpLo> class LLT : public SolverBase<LLT<_MatrixType,_UpLo>> { public : typedef _MatrixType MatrixType ; typedef SolverBase<LLT> Base ; class SolverBase<LLT> ;)",
    "insertText": "EIGEN_GENERIC_PUBLIC_INTERFACE(LLT)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime } ; enum { PacketSize = internal::packet_traits<Scalar>::size,AlignmentMask =)",
    "insertText": "int(PacketSize)"
  },
  {
    "label": "LLT()",
    "kind": "Method",
    "detail": "Function (typedef internal::LLT_Traits<MatrixType,UpLo> Traits ;)",
    "insertText": "LLT() : m_matrix(), m_isInitialized(false)"
  },
  {
    "label": "LLT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "LLT(Index size) : m_matrix(size, size), m_isInitialized(false)"
  },
  {
    "label": "LLT()",
    "kind": "Method",
    "detail": "Function (} template<InputType>)",
    "insertText": "LLT(const EigenBase<InputType>& matrix) : m_matrix(matrix.rows(), matrix.cols()), m_isInitialized(false)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(matrix.derived())"
  },
  {
    "label": "LLT()",
    "kind": "Method",
    "detail": "Function (} template<InputType>)",
    "insertText": "LLT(EigenBase<InputType>& matrix) : m_matrix(matrix.derived()), m_isInitialized(false)"
  },
  {
    "label": "matrixU()",
    "kind": "Method",
    "detail": "Function (} Traits::MatrixU)",
    "insertText": "matrixU()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized && \"LLT is not initialized.\")"
  },
  {
    "label": "matrixL()",
    "kind": "Method",
    "detail": "Function (} Traits::MatrixL)",
    "insertText": "matrixL()"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (} # ifdef EIGEN_PARSED_BY_DOXYGEN template<Rhs> const Solve<LLT,Rhs>)",
    "insertText": "solve(const MatrixBase<Rhs>& b)"
  },
  {
    "label": "solveInPlace()",
    "kind": "Method",
    "detail": "Function (# endif template<Derived> void)",
    "insertText": "solveInPlace(const MatrixBase<Derived> &bAndX)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (template<InputType> LLT&)",
    "insertText": "compute(const EigenBase<InputType>& matrix)"
  },
  {
    "label": "rcond()",
    "kind": "Method",
    "detail": "Function (RealScalar)",
    "insertText": "rcond()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_info == Success && \"LLT failed because matrix appears to be negative\")"
  },
  {
    "label": "matrixLLT()",
    "kind": "Method",
    "detail": "Function (} const MatrixType&)",
    "insertText": "matrixLLT()"
  },
  {
    "label": "info()",
    "kind": "Method",
    "detail": "Function (ComputationInfo)",
    "insertText": "info()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} EIGEN_CONSTEXPR Index)",
    "insertText": "cols()"
  },
  {
    "label": "rankUpdate()",
    "kind": "Method",
    "detail": "Function (} template<VectorType> LLT&)",
    "insertText": "rankUpdate(const VectorType& vec, const RealScalar& sigma = 1)"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_PARSED_BY_DOXYGEN template<RhsType,DstType> void)",
    "insertText": "_solve_impl(const RhsType &rhs, DstType &dst)"
  },
  {
    "label": "_solve_impl_transposed()",
    "kind": "Method",
    "detail": "Function (template<bool Conjugate,RhsType,DstType> void)",
    "insertText": "_solve_impl_transposed(const RhsType &rhs, DstType &dst)"
  },
  {
    "label": "check_template_parameters()",
    "kind": "Method",
    "detail": "Function (# endif protected : void)",
    "insertText": "check_template_parameters()"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_NON_INTEGER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)"
  },
  {
    "label": "llt_rank_update_lower()",
    "kind": "Method",
    "detail": "Function (} MatrixType m_matrix ; RealScalar m_l1_norm ; bool m_isInitialized ; ComputationInfo m_info ; } ; namespace internal { template<Scalar,int UpLo> struct llt_inplace ; template<MatrixType,VectorType> Index)",
    "insertText": "llt_rank_update_lower(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(mat.rows()==n && vec.size()==n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TempVectorType temp ;)",
    "insertText": "if(sigma>0)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (temp =)",
    "insertText": "sqrt(sigma)"
  },
  {
    "label": "makeGivens()",
    "kind": "Method",
    "detail": "Function (JacobiRotation<Scalar> g ; g .)",
    "insertText": "makeGivens(mat(i,i), -temp(i), &mat(i,i))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index rs = n - i - 1 ;)",
    "insertText": "if(rs>0)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (ColXprSegment)",
    "insertText": "x(mat.col(i).tail(rs))"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (TempVecSegment)",
    "insertText": "y(temp.tail(rs))"
  },
  {
    "label": "apply_rotation_in_the_plane()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "apply_rotation_in_the_plane(x, y, g)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } } else { temp = vec ; RealScalar beta = 1 ;)",
    "insertText": "for(Index j=0; j<n; ++j)"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (RealScalar Ljj =)",
    "insertText": "real(mat.coeff(j,j))"
  },
  {
    "label": "abs2()",
    "kind": "Method",
    "detail": "Function (RealScalar dj =)",
    "insertText": "abs2(Ljj)"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (Scalar wj = temp .)",
    "insertText": "coeff(j)"
  },
  {
    "label": "abs2()",
    "kind": "Method",
    "detail": "Function (RealScalar swj2 = sigma*)",
    "insertText": "abs2(wj)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RealScalar gamma = dj* beta + swj2 ; RealScalar x = dj + swj2 / beta ;)",
    "insertText": "if(x<=RealScalar(0))"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (RealScalar nLjj =)",
    "insertText": "sqrt(x)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (mat .)",
    "insertText": "coeffRef(j,j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (beta + = swj2 / dj ; Index rs = n - j - 1 ;)",
    "insertText": "if(rs)"
  },
  {
    "label": "tail()",
    "kind": "Method",
    "detail": "Function (temp .)",
    "insertText": "tail(rs) -= (wj/Ljj) * mat.col(j).tail(rs)"
  },
  {
    "label": "unblocked()",
    "kind": "Method",
    "detail": "Function (} } } return - 1 ; } template<Scalar> struct llt_inplace<Scalar,Lower> { typedef NumTraits<Scalar>::Real RealScalar ; template<MatrixType> Index)",
    "insertText": "unblocked(MatrixType& mat)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (using std::sqrt ;)",
    "insertText": "eigen_assert(mat.rows()==mat.cols())"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (const Index size = mat .)",
    "insertText": "rows()"
  },
  {
    "label": "A21()",
    "kind": "Method",
    "detail": "Function (Index rs = size - k - 1 ; Block<MatrixType,Dynamic,1>)",
    "insertText": "A21(mat,k+1,k,rs,1)"
  },
  {
    "label": "A10()",
    "kind": "Method",
    "detail": "Function (Block<MatrixType,1,Dynamic>)",
    "insertText": "A10(mat,k,0,1,k)"
  },
  {
    "label": "A20()",
    "kind": "Method",
    "detail": "Function (Block<MatrixType,Dynamic,Dynamic>)",
    "insertText": "A20(mat,k+1,0,rs,k)"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (RealScalar x =)",
    "insertText": "real(mat.coeff(k,k))"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (mat .)",
    "insertText": "coeffRef(k,k) = x = sqrt(x)"
  },
  {
    "label": "blocked()",
    "kind": "Method",
    "detail": "Function (} return - 1 ; } template<MatrixType> Index)",
    "insertText": "blocked(MatrixType& m)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m.rows()==m.cols())"
  },
  {
    "label": "blockSize()",
    "kind": "Method",
    "detail": "Function (Index blockSize = size / 8 ;)",
    "insertText": "blockSize(blockSize/16)"
  },
  {
    "label": "blockSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "blockSize(std::min)((std::max)(blockSize,Index(8)), Index(128))"
  },
  {
    "label": "bs()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "bs(std::min)(blockSize, size-k)"
  },
  {
    "label": "A11()",
    "kind": "Method",
    "detail": "Function (Index rs = size - k - bs ; Block<MatrixType,Dynamic,Dynamic>)",
    "insertText": "A11(m,k, k, bs,bs)"
  },
  {
    "label": "A21()",
    "kind": "Method",
    "detail": "Function (Block<MatrixType,Dynamic,Dynamic>)",
    "insertText": "A21(m,k+bs,k, rs,bs)"
  },
  {
    "label": "A22()",
    "kind": "Method",
    "detail": "Function (Block<MatrixType,Dynamic,Dynamic>)",
    "insertText": "A22(m,k+bs,k+bs,rs,rs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index ret ;)",
    "insertText": "if((ret=unblocked(A11))>=0)"
  },
  {
    "label": "rankUpdate()",
    "kind": "Method",
    "detail": "Function (} return - 1 ; } template<MatrixType,VectorType> Index)",
    "insertText": "rankUpdate(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)"
  },
  {
    "label": "matt()",
    "kind": "Method",
    "detail": "Function (Transpose<MatrixType>)",
    "insertText": "matt(mat)"
  },
  {
    "label": "blocked()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> EIGEN_STRONG_INLINE Index)",
    "insertText": "blocked(MatrixType& mat)"
  },
  {
    "label": "getL()",
    "kind": "Method",
    "detail": "Function (} } ; template<MatrixType> struct LLT_Traits<MatrixType,Lower> { typedef const TriangularView<const MatrixType,Lower> MatrixL ; typedef const TriangularView<const MatrixType::AdjointReturnType,Upper> MatrixU ; MatrixL)",
    "insertText": "getL(const MatrixType& m)"
  },
  {
    "label": "getU()",
    "kind": "Method",
    "detail": "Function (} MatrixU)",
    "insertText": "getU(const MatrixType& m)"
  },
  {
    "label": "inplace_decomposition()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "inplace_decomposition(MatrixType& m)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (} } ; } template<MatrixType,int _UpLo> template<InputType> LLT<MatrixType,_UpLo>& LLT<MatrixType,_UpLo)",
    "insertText": "compute(const EigenBase<InputType>& a)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(a.rows()==a.cols())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_matrix .)",
    "insertText": "resize(size, size)"
  },
  {
    "label": "RealScalar()",
    "kind": "Method",
    "detail": "Function (m_l1_norm =)",
    "insertText": "RealScalar(0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RealScalar abs_col_sum ;)",
    "insertText": "if(_UpLo == Lower) abs_col_sum = m_matrix.col(col).tail(size - col).template lpNorm<1>() + m_matrix.row(col).head(col).template lpNorm<1>()"
  },
  {
    "label": "inplace_decomposition()",
    "kind": "Method",
    "detail": "Function (} m_isInitialized = true ; bool ok =)",
    "insertText": "inplace_decomposition(m_matrix)"
  },
  {
    "label": "rankUpdate()",
    "kind": "Method",
    "detail": "Function (m_info = ok ? Success : NumericalIssue ; return* this ; } template<_MatrixType,int _UpLo> template<VectorType> LLT<_MatrixType,_UpLo>& LLT<_MatrixType,_UpLo)",
    "insertText": "rankUpdate(const VectorType& v, const RealScalar& sigma)"
  },
  {
    "label": "EIGEN_STATIC_ASSERT_VECTOR_ONLY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_STATIC_ASSERT_VECTOR_ONLY(VectorType)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(v.size()==m_matrix.cols())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized)"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (_solve_impl_transposed<)",
    "insertText": "true(rhs, dst)"
  },
  {
    "label": "matrixL()",
    "kind": "Method",
    "detail": "Function (dst = rhs ;)",
    "insertText": "matrixL().template conjugateIf<!Conjugate>().solveInPlace(dst)"
  },
  {
    "label": "matrixU()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "matrixU().template conjugateIf<!Conjugate>().solveInPlace(dst)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_matrix.rows()==bAndX.rows())"
  },
  {
    "label": "matrixL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "matrixL().solveInPlace(bAndX)"
  },
  {
    "label": "matrixU()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "matrixU().solveInPlace(bAndX)"
  },
  {
    "label": "reconstructedMatrix()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType,int _UpLo> MatrixType LLT<MatrixType,_UpLo)",
    "insertText": "reconstructedMatrix()"
  },
  {
    "label": "llt()",
    "kind": "Method",
    "detail": "Function (} template<Derived> const LLT<MatrixBase<Derived>::PlainObject> MatrixBase<Derived)",
    "insertText": "llt()"
  }
]