[
  {
    "label": "Vec",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Vec"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHVECALGO_H # define INCLUDED_IMATHVECALGO_H # include \" ImathNamespace . h \" # include \" ImathVec . h \" IMATH_INTERNAL_NAMESPACE_HEADER_ENTER template<class Vec,)",
    "insertText": "IMATH_ENABLE_IF(!std::is_integral<typename Vec::BaseType>::value)> IMATH_CONSTEXPR14 inline Vec project (const Vec& s, const Vec& t)"
  },
  {
    "label": "normalized()",
    "kind": "Method",
    "detail": "Function (Vec sNormalized = s .)",
    "insertText": "normalized()"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (} template<class Vec,)",
    "insertText": "IMATH_ENABLE_IF(!std::is_integral<typename Vec::BaseType>::value)> constexpr inline Vec orthogonal (const Vec& s, const Vec& t)"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (} template<class Vec,)",
    "insertText": "IMATH_ENABLE_IF(!std::is_integral<typename Vec::BaseType>::value)> constexpr inline Vec reflect (const Vec& s, const Vec& t)"
  },
  {
    "label": "closestVertex()",
    "kind": "Method",
    "detail": "Function (} template<class Vec> IMATH_CONSTEXPR14 Vec)",
    "insertText": "closestVertex(const Vec& v0, const Vec& v1, const Vec& v2, const Vec& p)"
  },
  {
    "label": "neardot()",
    "kind": "Method",
    "detail": "Function (Vec nearest = v0 ; Vec::BaseType)",
    "insertText": "neardot(v0 - p).length2()"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (Vec::BaseType)",
    "insertText": "tmp(v1 - p).length2()"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (neardot = tmp ; nearest = v1 ; })",
    "insertText": "tmp(v2 - p).length2()"
  }
]