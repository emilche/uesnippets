[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FArchiveReferenceMarker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FArchiveReferenceMarker"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / Object . h \" # include \" Serialization / ArchiveUObject . h \" enum class EArchiveReferenceMarkerFlags : uint32 { None = 0,SkipCompilingAssets = 1 } ;)",
    "insertText": "ENUM_CLASS_FLAGS(EArchiveReferenceMarkerFlags)"
  },
  {
    "label": "FArchiveReferenceMarker()",
    "kind": "Method",
    "detail": "Function (class FArchiveReferenceMarker : public FArchiveUObject { public :)",
    "insertText": "FArchiveReferenceMarker(TArray<UObject*>& SourceObjects, EArchiveReferenceMarkerFlags InFlags = EArchiveReferenceMarkerFlags::None)"
  },
  {
    "label": "SetShouldSkipCompilingAssets()",
    "kind": "Method",
    "detail": "Function (ArIsObjectReferenceCollector = true ; ArIgnoreOuterRef = true ;)",
    "insertText": "SetShouldSkipCompilingAssets((InFlags & EArchiveReferenceMarkerFlags::SkipCompilingAssets) != EArchiveReferenceMarkerFlags::None)"
  },
  {
    "label": "Mark()",
    "kind": "Method",
    "detail": "Function (UObject* Object = SourceObjects [ ObjectIndex ] ; Object ->)",
    "insertText": "Mark(OBJECTMARK_TagImp)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Object ->)",
    "insertText": "Serialize(*this)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 ObjectIndex = 0; ObjectIndex < SourceObjects.Num(); ObjectIndex++)"
  },
  {
    "label": "UnMark()",
    "kind": "Method",
    "detail": "Function (UObject* Object = SourceObjects [ ObjectIndex ] ; Object ->)",
    "insertText": "UnMark(OBJECTMARK_TagImp)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } FArchive&)",
    "insertText": "operator(UObject*& Object)"
  },
  {
    "label": "Mark()",
    "kind": "Method",
    "detail": "Function (Object ->)",
    "insertText": "Mark(OBJECTMARK_TagExp)"
  },
  {
    "label": "HasAnyMarks()",
    "kind": "Method",
    "detail": "Function (const bool bIgnoreObject = Object ->)",
    "insertText": "HasAnyMarks(OBJECTMARK_TagImp)"
  }
]