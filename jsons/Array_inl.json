[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "CArrayPointerSwap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CArrayPointerSwap"
  },
  {
    "label": "CArrayPointerMemorySwap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CArrayPointerMemorySwap"
  },
  {
    "label": "CArrayPointerCopy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CArrayPointerCopy"
  },
  {
    "label": "CArrayPointerMemoryCopy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CArrayPointerMemoryCopy"
  },
  {
    "label": "CompareFunctor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CompareFunctor"
  },
  {
    "label": "SwapFunctor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SwapFunctor"
  },
  {
    "label": "CopyFunctor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CopyFunctor"
  },
  {
    "label": "CArray()",
    "kind": "Method",
    "detail": "Function (template<class T,bool bUseCustomAllocator> ST_INLINE CArray<T,bUseCustomAllocator)",
    "insertText": "CArray() : m_pData(NULL), m_uiSize(0), m_uiDataSize(0), m_pHeapDesc(NULL), m_bExternalMemory(false)"
  },
  {
    "label": "CArray()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> ST_INLINE CArray<T,bUseCustomAllocator)",
    "insertText": "CArray(size_t uiSize, const T& tDefault) : m_pData(NULL), m_uiSize(0), m_uiDataSize(0), m_pHeapDesc(NULL), m_bExternalMemory(false)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(uiSize, tDefault)"
  },
  {
    "label": "CArray()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> ST_INLINE CArray<T,bUseCustomAllocator)",
    "insertText": "CArray(const CArray<T, bUseCustomAllocator>& cCopy) : m_pData(NULL), m_uiSize(0), m_uiDataSize(0), m_bExternalMemory(false)"
  },
  {
    "label": "CArray()",
    "kind": "Method",
    "detail": "Function (* this = cCopy ; } template<class T,bool bUseCustomAllocator> ST_INLINE CArray<T,bUseCustomAllocator>::~)",
    "insertText": "CArray()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> ST_INLINE void CArray<T,bUseCustomAllocator)",
    "insertText": "clear(void)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (m_uiSize = 0 ; } else {)",
    "insertText": "Deallocate(m_pData)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (m_pData = NULL ; m_uiSize = m_uiDataSize = 0 ; } } template<class T,bool bUseCustomAllocator> ST_INLINE bool CArray<T,bUseCustomAllocator)",
    "insertText": "empty(void)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_uiSize = uiSize ; return true ; } m_uiSize = m_uiDataSize ; return false ; } template<class T,bool bUseCustomAllocator> ST_INLINE bool CArray<T,bUseCustomAllocator)",
    "insertText": "resize(size_t uiSize, const T& tDefault)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bReturn = false ; size_t uiEnd = m_uiDataSize ;)",
    "insertText": "if(reserve(uiSize))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (uiEnd = uiSize ; bReturn = true ; })",
    "insertText": "for(size_t i = m_uiSize; i < uiEnd; ++i)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (m_uiSize = uiEnd ; return bReturn ; } template<class T,bool bUseCustomAllocator> ST_INLINE bool CArray<T,bUseCustomAllocator)",
    "insertText": "reserve(size_t uiSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(uiSize > m_uiDataSize)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (T* pNewData =)",
    "insertText": "Allocate(uiSize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T* pNew = pNewData ; T* pOld = m_pData ;)",
    "insertText": "for(size_t i = 0; i < m_uiSize; ++pNew, ++pOld, ++i)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (m_pData = pNewData ; m_uiDataSize = uiSize ; } return true ; } template<class T,bool bUseCustomAllocator> ST_INLINE bool CArray<T,bUseCustomAllocator)",
    "insertText": "push_back(const T& tNew)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bReturn = true ;)",
    "insertText": "if(m_bExternalMemory)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(m_uiDataSize * 2 + 1)"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (} m_pData [ m_uiSize + + ] = tNew ; } return bReturn ; } template<class T,bool bUseCustomAllocator> ST_INLINE void CArray<T,bUseCustomAllocator)",
    "insertText": "pop_back(void)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> ST_INLINE void CArray<T,bUseCustomAllocator)",
    "insertText": "clip(void)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (T* pNewData =)",
    "insertText": "Allocate(m_uiSize)"
  },
  {
    "label": "erase_all()",
    "kind": "Method",
    "detail": "Function (} } template<class T,bool bUseCustomAllocator> ST_INLINE void CArray<T,bUseCustomAllocator)",
    "insertText": "erase_all(const T& tErase)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (iterator iterTest = m_pData + m_uiSize ;)",
    "insertText": "while(--iterTest >= m_pData)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (} } } template<class T,bool bUseCustomAllocator> ST_INLINE T& CArray<T,bUseCustomAllocator)",
    "insertText": "front(void)"
  },
  {
    "label": "st_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "st_assert(uiIndex < m_uiSize, \"CArray index out of range\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_uiSize = cRight . m_uiSize ;)",
    "insertText": "if(m_uiSize > m_uiDataSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(cRight.m_uiSize > m_uiDataSize)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (T* pNewData =)",
    "insertText": "Allocate(cRight.m_uiSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_pData = pNewData ; m_uiDataSize = cRight . m_uiSize ; } m_uiSize = cRight . m_uiSize ; })",
    "insertText": "if(m_uiSize > 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T* pNew = m_pData ; T* pOld = cRight . m_pData ;)",
    "insertText": "for(size_t i = 0; i < size_t(m_uiSize); ++pNew, ++pOld, ++i)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} return* this ; } template<class T,bool bUseCustomAllocator> ST_INLINE T* CArray<T,bUseCustomAllocator)",
    "insertText": "begin(void)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> ST_INLINE CArray<T,bUseCustomAllocator>::iterator CArray<T,bUseCustomAllocator)",
    "insertText": "erase(iterator iterWhere)"
  },
  {
    "label": "st_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "st_assert(m_pData != NULL, \"CArray::erase() called before CArray was propertly initialized\")"
  },
  {
    "label": "st_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "st_assert(iterWhere >= m_pData && iterWhere < m_pData + m_uiSize, \"CArray iterator out of bounds\")"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (- - m_uiSize ; } else { char achTemp [)",
    "insertText": "sizeof(T)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(achTemp, iterWhere, sizeof(T))"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(iterWhere, iterWhere + 1, (m_uiSize - (iterWhere - m_pData) - 1) * sizeof(T))"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (- - m_uiSize ;)",
    "insertText": "memmove(m_pData + m_uiSize, achTemp, sizeof(T))"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} return iterWhere ; } template<class T,bool bUseCustomAllocator> ST_INLINE CArray<T,bUseCustomAllocator>::iterator CArray<T,bUseCustomAllocator)",
    "insertText": "insert(iterator iterWhere, const T& tData)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# ifdef SPEEDTREE_ITERATOR_DEBUGGING)",
    "insertText": "assert((m_pData != NULL && iterWhere != NULL) || (m_pData == NULL && iterWhere == NULL))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(iterWhere >= m_pData)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(iterWhere < m_pData + m_uiSize + 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif size_t uiIndex = iterWhere - m_pData ;)",
    "insertText": "if(push_back(tData))"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(achTemp, static_cast<void*>(m_pData + m_uiSize - 1), sizeof(T))"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(static_cast<void*>(m_pData + uiIndex + 1), static_cast<void*>(m_pData + uiIndex), (m_uiSize - uiIndex - 1) * sizeof(T))"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(static_cast<void*>(m_pData + uiIndex), achTemp, sizeof(T))"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(m_pData + uiIndex)"
  },
  {
    "label": "lower()",
    "kind": "Method",
    "detail": "Function (} return NULL ; } template<class T,bool bUseCustomAllocator> ST_INLINE CArray<T,bUseCustomAllocator>::iterator CArray<T,bUseCustomAllocator)",
    "insertText": "lower(const T& tData)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (size_t uiWidth = m_uiSize / 2 ; iterator iterStart = m_pData ; iterator iterEnd = m_pData + m_uiSize ;)",
    "insertText": "while(uiWidth > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (iterator iterMiddle = iterStart + uiWidth ;)",
    "insertText": "if(tData < *iterMiddle)"
  },
  {
    "label": "higher()",
    "kind": "Method",
    "detail": "Function (} return iterStart ; } template<class T,bool bUseCustomAllocator> ST_INLINE CArray<T,bUseCustomAllocator>::iterator CArray<T,bUseCustomAllocator)",
    "insertText": "higher(const T& tData)"
  },
  {
    "label": "lower()",
    "kind": "Method",
    "detail": "Function (iterator iterBound =)",
    "insertText": "lower(tData)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(*iterBound < tData)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (iterHigher = iterLower ;)",
    "insertText": "if(iterHigher == end( ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(*iterHigher < tData)"
  },
  {
    "label": "insert_sorted()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> ST_INLINE CArray<T,bUseCustomAllocator>::iterator CArray<T,bUseCustomAllocator)",
    "insertText": "insert_sorted(const T& tData)"
  },
  {
    "label": "insert_sorted_unique()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> ST_INLINE CArray<T,bUseCustomAllocator>::iterator CArray<T,bUseCustomAllocator)",
    "insertText": "insert_sorted_unique(const T& tData)"
  },
  {
    "label": "lower_and_higher()",
    "kind": "Method",
    "detail": "Function (iterator iterLower ; iterator iterHigher ;)",
    "insertText": "lower_and_higher(tData, iterLower, iterHigher)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (* pTemp =* pOne ;* pOne =* pTwo ;* pTwo =* pTemp ; } } ; class CArrayPointerMemorySwap { public : template<class T> void)",
    "insertText": "operator() (T* pOne, T* pTwo, T* pTemp)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(pTemp, pOne, sizeof(T))"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(pOne, pTwo, sizeof(T))"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(pTwo, pTemp, sizeof(T))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; class CArrayPointerCopy { public : template<class T> void)",
    "insertText": "operator() (T* pDest, T* pSrc)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(pDest, pSrc, sizeof(T))"
  },
  {
    "label": "ArrayQuickSort()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T,class CompareFunctor,class SwapFunctor,class CopyFunctor> void)",
    "insertText": "ArrayQuickSort(T* pBegin, T* pEnd, const CompareFunctor& Compare, const SwapFunctor& Swap, const CopyFunctor& Copy, T* pTemp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t uiSize = pEnd - pBegin + 1 ;)",
    "insertText": "if(pEnd - pBegin < 16)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Copy(pTemp, &pBegin[i])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t j = i ;)",
    "insertText": "for(; j > 0 && Compare(*pTemp, pBegin[j - 1]); --j) Copy(&pBegin[j], &pBegin[j - 1])"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Copy(&pBegin[j], pTemp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else { T* pMiddle = pBegin + uiSize / 2 ;)",
    "insertText": "if(Compare(*pMiddle, *pBegin)) Swap(pMiddle, pBegin, pTemp)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (T* pPivot = pEnd - 1 ;)",
    "insertText": "Swap(pMiddle, pPivot, pTemp)"
  },
  {
    "label": "pLow()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "pLow(pBegin)"
  },
  {
    "label": "pHigh()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "pHigh(pPivot)"
  },
  {
    "label": "ArrayQuickSort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ArrayQuickSort(pBegin, pLow - 1, Compare, Swap, Copy, pTemp)"
  },
  {
    "label": "ArrayQuickSort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ArrayQuickSort(pLow + 1, pEnd, Compare, Swap, Copy, pTemp)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (} } template<class T,bool bUseCustomAllocator> template<class CompareFunctor> ST_INLINE void CArray<T,bUseCustomAllocator)",
    "insertText": "sort(const CompareFunctor& Compare, bool bMemorySwap)"
  },
  {
    "label": "ArrayQuickSort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ArrayQuickSort(m_pData, m_pData + m_uiSize - 1, Compare, CArrayPointerMemorySwap( ), CArrayPointerMemoryCopy( ), (T*)achTemp)"
  },
  {
    "label": "ArrayQuickSort()",
    "kind": "Method",
    "detail": "Function (} else { T tTemp ;)",
    "insertText": "ArrayQuickSort(m_pData, m_pData + m_uiSize - 1, Compare, CArrayPointerSwap( ), CArrayPointerCopy( ), &tTemp)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (} } template<class T,bool bUseCustomAllocator> ST_INLINE void CArray<T,bUseCustomAllocator)",
    "insertText": "sort(bool bMemorySwap)"
  },
  {
    "label": "ArrayQuickSort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ArrayQuickSort(m_pData, m_pData + m_uiSize - 1, CDefaultArraySort( ), CArrayPointerMemorySwap( ), CArrayPointerMemoryCopy( ), (T*)achTemp)"
  },
  {
    "label": "ArrayQuickSort()",
    "kind": "Method",
    "detail": "Function (} else { T tTemp ;)",
    "insertText": "ArrayQuickSort(m_pData, m_pData + m_uiSize - 1, CDefaultArraySort( ), CArrayPointerSwap( ), CArrayPointerCopy( ), &tTemp)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (} } template<class T,bool bUseCustomAllocator> ST_INLINE T* CArray<T,bUseCustomAllocator)",
    "insertText": "Allocate(size_t uiSize)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!m_bExternalMemory)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> ST_INLINE void CArray<T,bUseCustomAllocator)",
    "insertText": "Deallocate(T* pData)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (# ifndef SPEEDTREE_NO_ALLOCATORS bUseCustomAllocator ? st_delete_array<)",
    "insertText": "T(pData)"
  },
  {
    "label": "SetExternalMemory()",
    "kind": "Method",
    "detail": "Function (} template<class T,bool bUseCustomAllocator> ST_INLINE void CArray<T,bUseCustomAllocator)",
    "insertText": "SetExternalMemory(unsigned char* pMemory, size_t uiSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_uiDataSize = 0 ; m_pData = NULL ; })",
    "insertText": "if(pMemory == NULL)"
  },
  {
    "label": "m_pData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_pData(T*)"
  },
  {
    "label": "SetHeapDescription()",
    "kind": "Method",
    "detail": "Function (m_bExternalMemory = true ; } } template<class T,bool bUseCustomAllocator> ST_INLINE void CArray<T,bUseCustomAllocator)",
    "insertText": "SetHeapDescription(const char* pDesc)"
  }
]