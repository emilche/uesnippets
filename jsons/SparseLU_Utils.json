[
  {
    "label": "countnz()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_SPARSELU_UTILS_H # define EIGEN_SPARSELU_UTILS_H namespace Eigen { namespace internal { template<Scalar,StorageIndex> void SparseLUImpl<Scalar,StorageIndex)",
    "insertText": "countnz(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu)"
  },
  {
    "label": "nnzU()",
    "kind": "Method",
    "detail": "Function (nnzL = 0 ;)",
    "insertText": "nnzU(glu.xusub)(n)"
  },
  {
    "label": "nsuper()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "nsuper(glu.supno)(n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index jlen ; Index i,j,fsupc ;)",
    "insertText": "if(n <= 0)"
  },
  {
    "label": "xsup()",
    "kind": "Method",
    "detail": "Function (fsupc = glu .)",
    "insertText": "xsup(i)"
  },
  {
    "label": "xlsub()",
    "kind": "Method",
    "detail": "Function (jlen = glu .)",
    "insertText": "xlsub(fsupc+1) - glu.xlsub(fsupc)"
  },
  {
    "label": "fixupL()",
    "kind": "Method",
    "detail": "Function (nnzL + = jlen ; nnzU + = j - fsupc + 1 ; jlen - - ; } } } template<Scalar,StorageIndex> void SparseLUImpl<Scalar,StorageIndex)",
    "insertText": "fixupL(const Index n, const IndexVector& perm_r, GlobalLU_t& glu)"
  },
  {
    "label": "xlsub()",
    "kind": "Method",
    "detail": "Function (jstart = glu .)",
    "insertText": "xlsub(fsupc)"
  },
  {
    "label": "lsub()",
    "kind": "Method",
    "detail": "Function (glu .)",
    "insertText": "lsub(nextl) = perm_r(glu.lsub(j))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (nextl + + ; })",
    "insertText": "for(k = fsupc+1; k < glu.xsup(i+1); k++) glu.xlsub(k)"
  },
  {
    "label": "xlsub()",
    "kind": "Method",
    "detail": "Function (} glu .)",
    "insertText": "xlsub(n)"
  }
]