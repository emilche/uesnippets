[
  {
    "label": "list",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "list"
  },
  {
    "label": "EIGEN_DEFINE_STL_LIST_SPECIALIZATION()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_STDLIST_H # define EIGEN_STDLIST_H # include \" details . h \" # define)",
    "insertText": "EIGEN_DEFINE_STL_LIST_SPECIALIZATION(...)"
  },
  {
    "label": "list()",
    "kind": "Method",
    "detail": "Function (\\ template<> \\ class list<__VA_ARGS__,std::allocator<__VA_ARGS__>> \\ : public list<__VA_ARGS__,EIGEN_ALIGNED_ALLOCATOR<__VA_ARGS__>> \\ { \\ typedef list<__VA_ARGS__,EIGEN_ALIGNED_ALLOCATOR<__VA_ARGS__>> list_base ; \\ public : \\ typedef __VA_ARGS__ value_type ; \\ typedef list_base::allocator_type allocator_type ; \\ typedef list_base::size_type size_type ; \\ typedef list_base::iterator iterator ; \\)",
    "insertText": "list(const allocator_type& a = allocator_type()) : list_base(a)"
  },
  {
    "label": "list()",
    "kind": "Method",
    "detail": "Function (} \\ template<InputIterator> \\)",
    "insertText": "list(InputIterator first, InputIterator last, const allocator_type& a = allocator_type()) : list_base(first, last, a)"
  },
  {
    "label": "list()",
    "kind": "Method",
    "detail": "Function (} \\)",
    "insertText": "list(const list& c) : list_base(c)"
  },
  {
    "label": "list()",
    "kind": "Method",
    "detail": "Function (} \\)",
    "insertText": "list(size_type num, const value_type& val = value_type()) : list_base(num, val)"
  },
  {
    "label": "list()",
    "kind": "Method",
    "detail": "Function (} \\)",
    "insertText": "list(iterator start_, iterator end_) : list_base(start_, end_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} \\ list&)",
    "insertText": "operator(const list& x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "operator(x)"
  },
  {
    "label": "EIGEN_HAS_CXX11_CONTAINERS()",
    "kind": "Method",
    "detail": "Function (\\ return* this ; \\ } \\ } ; \\ } # if !)",
    "insertText": "EIGEN_HAS_CXX11_CONTAINERS(defined(_GLIBCXX_LIST) && (!EIGEN_GNUC_AT_LEAST(4,1)))"
  },
  {
    "label": "list()",
    "kind": "Method",
    "detail": "Function (} \\ template<InputIterator> \\)",
    "insertText": "list(InputIterator first, InputIterator last, const allocator_type& a = allocator_type()) \\ : list_base(first, last, a)"
  },
  {
    "label": "EIGEN_WORKAROUND_MSVC_STL_SUPPORT()",
    "kind": "Method",
    "detail": "Function (\\ return* this ; \\ } template<T> class list<T,EIGEN_ALIGNED_ALLOCATOR<T>> : public list<)",
    "insertText": "EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T), Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (EIGEN_STD_LIST_SPECIALIZATION_BODY void)",
    "insertText": "resize(size_type new_size)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(new_size, T())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resize(size_type new_size, const value_type& x)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(_LIST_) void push_back(const value_type& x)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "push_back(x)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} using list_base::insert ; iterator)",
    "insertText": "insert(const_iterator position, const value_type& x)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "insert(const_iterator position, size_type new_size, const value_type& x)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(position, new_size, x)"
  }
]