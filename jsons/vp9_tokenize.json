[
  {
    "label": "vp9_token",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "vp9_token"
  },
  {
    "label": "VP9_COMP",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VP9_COMP"
  },
  {
    "label": "ThreadData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ThreadData"
  },
  {
    "label": "vp9_is_skippable_in_plane()",
    "kind": "Method",
    "detail": "Function (# ifndef VPX_VP9_ENCODER_VP9_TOKENIZE_H_ # define VPX_VP9_ENCODER_VP9_TOKENIZE_H_ # include \" vp9 / common / vp9_entropy . h \" # include \" vp9 / encoder / vp9_block . h \" # include \" vp9 / encoder / vp9_treewriter . h \" # ifdef __cplusplus \" C \" { # endif # define EOSB_TOKEN 1 2 7 # if CONFIG_VP9_HIGHBITDEPTH typedef int32_t EXTRABIT ; # else typedef int16_t EXTRABIT ; # endif typedef struct { int16_t token ; EXTRABIT extra ; } TOKENVALUE ; typedef struct { const vpx_prob* context_tree ; int16_t token ; EXTRABIT extra ; } TOKENEXTRA ; const vpx_tree_index vp9_coef_tree [ ] ; const vpx_tree_index vp9_coef_con_tree [ ] ; const struct vp9_token vp9_coef_encodings [ ] ; int)",
    "insertText": "vp9_is_skippable_in_plane(MACROBLOCK *x, BLOCK_SIZE bsize, int plane)"
  },
  {
    "label": "vp9_has_high_freq_in_plane()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "vp9_has_high_freq_in_plane(MACROBLOCK *x, BLOCK_SIZE bsize, int plane)"
  },
  {
    "label": "vp9_tokenize_sb()",
    "kind": "Method",
    "detail": "Function (struct VP9_COMP ; struct ThreadData ; void)",
    "insertText": "vp9_tokenize_sb(struct VP9_COMP *cpi, struct ThreadData *td, TOKENEXTRA **t, int dry_run, int seg_skip, BLOCK_SIZE bsize)"
  },
  {
    "label": "vp9_get_high_cost_table()",
    "kind": "Method",
    "detail": "Function (typedef struct { const vpx_prob* prob ; int len ; int base_val ; const int16_t* cost ; } vp9_extra_bit ; const vp9_extra_bit vp9_extra_bits [ ENTROPY_TOKENS ] ; # if CONFIG_VP9_HIGHBITDEPTH const vp9_extra_bit vp9_extra_bits_high10 [ ENTROPY_TOKENS ] ; const vp9_extra_bit vp9_extra_bits_high12 [ ENTROPY_TOKENS ] ; # endif const int16_t* vp9_dct_value_cost_ptr ; const TOKENVALUE* vp9_dct_value_tokens_ptr ; const TOKENVALUE* vp9_dct_cat_lt_10_value_tokens ; const int* vp9_dct_cat_lt_10_value_cost ; const int16_t vp9_cat6_low_cost [ 2 5 6 ] ; const uint16_t vp9_cat6_high_cost [ 6 4 ] ; const uint16_t vp9_cat6_high10_high_cost [ 2 5 6 ] ; const uint16_t vp9_cat6_high12_high_cost [ 1 0 2 4 ] ; # if CONFIG_VP9_HIGHBITDEPTH const uint16_t*)",
    "insertText": "vp9_get_high_cost_table(int bit_depth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* token = CATEGORY6_TOKEN ;)",
    "insertText": "if(v >= CAT6_MIN_VAL)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (EXTRABIT extrabits ;* token = CATEGORY6_TOKEN ; extrabits =)",
    "insertText": "abs(v)"
  }
]