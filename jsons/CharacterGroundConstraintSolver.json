[
  {
    "label": "FCharacterGroundConstraintSolver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCharacterGroundConstraintSolver"
  },
  {
    "label": "FBodyData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBodyData"
  },
  {
    "label": "FImpulseData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FImpulseData"
  },
  {
    "label": "FConstraintData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConstraintData"
  },
  {
    "label": "SetBodies()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Chaos / Evolution / SolverBody . h \" # include \" Chaos / ParticleHandleFwd . h \" # include \" Chaos / Character / CharacterGroundConstraintSettings . h \" # include \" Chaos / Utilities . h \" namespace Chaos { namespace Private { class FCharacterGroundConstraintSolver { public : void)",
    "insertText": "SetBodies(FSolverBody* CharacterSolverBody, FSolverBody* GroundSolverBody = nullptr)"
  },
  {
    "label": "GatherInput()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GatherInput(FReal Dt, const FCharacterGroundConstraintSettings& Settings, const FCharacterGroundConstraintDynamicData& Data)"
  },
  {
    "label": "SolvePosition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolvePosition()"
  },
  {
    "label": "ScatterOutput()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScatterOutput(const FReal Dt, FVec3& OutSolverAppliedForce, FVec3& OutSolverAppliedTorque)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "GetLinearImpulse()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "GetLinearImpulse(FReal Dt)"
  },
  {
    "label": "GetAngularImpulse()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "GetAngularImpulse(FReal Dt)"
  },
  {
    "label": "ProjectOntoPlane()",
    "kind": "Method",
    "detail": "Function (private : FSolverVec3)",
    "insertText": "ProjectOntoPlane(const FSolverVec3& Vector, const FSolverVec3& PlaneNormal)"
  },
  {
    "label": "ClampMagnitude()",
    "kind": "Method",
    "detail": "Function (FSolverVec3)",
    "insertText": "ClampMagnitude(const FSolverVec3& Vector, const FSolverReal& Max)"
  },
  {
    "label": "ClampAbs()",
    "kind": "Method",
    "detail": "Function (FSolverReal)",
    "insertText": "ClampAbs(const FSolverReal& Value, const FSolverReal& Max)"
  },
  {
    "label": "FBodyData()",
    "kind": "Method",
    "detail": "Function (struct FBodyData {)",
    "insertText": "FBodyData()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(FSolverBody* InCharacterBody, FSolverBody* InGroundBody)"
  },
  {
    "label": "IsTwoBody()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsTwoBody()"
  },
  {
    "label": "FImpulseData()",
    "kind": "Method",
    "detail": "Function (FConstraintSolverBody CharacterBody ; FConstraintSolverBody GroundBody ; } BodyData ; struct FImpulseData {)",
    "insertText": "FImpulseData()"
  },
  {
    "label": "FConstraintData()",
    "kind": "Method",
    "detail": "Function (FSolverVec3 LinearPositionImpulse ; FSolverVec3 AngularSwingImpulse ; FSolverReal AngularImpulse ; FSolverReal LinearCorrectionImpulse ; } ImpulseData ; struct FConstraintData {)",
    "insertText": "FConstraintData()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (FSolverMatrix33 CharacterInvI ; FSolverMatrix33 GroundInvI ; FSolverVec3 GroundOffset ; FSolverVec3 InitialError ; FSolverVec3 InitialProjectedError ; FSolverVec3 Normal ; FSolverVec3 VerticalAxis ; FSolverVec3 CharacterVerticalAxis ; FSolverVec3 MotionTargetError ; FSolverReal MotionTargetAngularError ; FSolverReal CharacterInvM ; FSolverReal CharacterInvIZ ; FSolverReal GroundInvM ; FSolverReal TwoBodyEffectiveMass ; FSolverReal SingleBodyEffectiveMass ; FSolverReal EffectiveInertia ; FSolverReal AngularImpulseLimit ; FSolverReal AngularSwingImpulseLimit ; FSolverReal RadialImpulseLimit ; FSolverReal AssumedOnGroundHeight ; } ConstraintData ; using FSolveFunctionType =)",
    "insertText": "void(*)(const FConstraintData& ConstraintData, FBodyData& BodyData, FImpulseData& ImpulseData)"
  },
  {
    "label": "SolveCorrectionSingleBody()",
    "kind": "Method",
    "detail": "Function (FSolveFunctionType PositionSolveFunction ; FSolveFunctionType CorrectionSolveFunction ; void)",
    "insertText": "SolveCorrectionSingleBody(const FConstraintData& ConstraintData, FBodyData& BodyData, FImpulseData& ImpulseData)"
  },
  {
    "label": "SolvePositionSingleBody()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolvePositionSingleBody(const FConstraintData& ConstraintData, FBodyData& BodyData, FImpulseData& ImpulseData)"
  },
  {
    "label": "SolvePositionTwoBody()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolvePositionTwoBody(const FConstraintData& ConstraintData, FBodyData& BodyData, FImpulseData& ImpulseData)"
  },
  {
    "label": "NoSolve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NoSolve(const FConstraintData&, FBodyData&, FImpulseData&)"
  },
  {
    "label": "SizeSquared()",
    "kind": "Method",
    "detail": "Function (const FSolverReal MagSq = Vector .)",
    "insertText": "SizeSquared()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FSolverReal MaxSq = Max* Max ;)",
    "insertText": "if(MagSq > MaxSq)"
  },
  {
    "label": "Dot()",
    "kind": "Method",
    "detail": "Function (const FSolverReal Error = ConstraintData . Normal .)",
    "insertText": "Dot(BodyData.CharacterBody.CP() + ConstraintData.InitialError)"
  },
  {
    "label": "ApplyPositionCorrectionDelta()",
    "kind": "Method",
    "detail": "Function (const FSolverReal Delta = - ConstraintData . SingleBodyEffectiveMass* Error ; ImpulseData . LinearCorrectionImpulse + = Delta ; BodyData . CharacterBody .)",
    "insertText": "ApplyPositionCorrectionDelta(FSolverVec3(ConstraintData.CharacterInvM * Delta * ConstraintData.Normal))"
  },
  {
    "label": "Dot()",
    "kind": "Method",
    "detail": "Function (const FSolverReal Error = ConstraintData . Normal .)",
    "insertText": "Dot(BodyData.CharacterBody.DP() + ConstraintData.InitialProjectedError)"
  },
  {
    "label": "ApplyPositionDelta()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 Delta = - ConstraintData . SingleBodyEffectiveMass* Error* ConstraintData . Normal ; ImpulseData . LinearPositionImpulse + = Delta ; BodyData . CharacterBody .)",
    "insertText": "ApplyPositionDelta(FSolverVec3(ConstraintData.CharacterInvM * Delta))"
  },
  {
    "label": "DQ()",
    "kind": "Method",
    "detail": "Function (} FSolverVec3 NewCharacterVerticalAxis = ConstraintData . CharacterVerticalAxis + BodyData . CharacterBody .)",
    "insertText": "DQ().Cross(ConstraintData.CharacterVerticalAxis)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (NewCharacterVerticalAxis .)",
    "insertText": "Normalize()"
  },
  {
    "label": "Cross()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 CrossProd = NewCharacterVerticalAxis .)",
    "insertText": "Cross(ConstraintData.VerticalAxis)"
  },
  {
    "label": "InvSqrt()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 AngAxis = CrossProd*)",
    "insertText": "InvSqrt(SizeSq)"
  },
  {
    "label": "FSolverReal()",
    "kind": "Method",
    "detail": "Function (const FSolverReal AngResistance =)",
    "insertText": "FSolverReal(1.0f) / (ConstraintData.CharacterInvI * AngAxis).Dot(AngAxis)"
  },
  {
    "label": "ClampMagnitude()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 NewSwingImpulse =)",
    "insertText": "ClampMagnitude(ImpulseData.AngularSwingImpulse + AngResistance * FMath::Asin(FMath::Sqrt(SizeSq)) * AngAxis, ConstraintData.AngularSwingImpulseLimit)"
  },
  {
    "label": "ApplyRotationDelta()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 Delta = NewSwingImpulse - ImpulseData . AngularSwingImpulse ; ImpulseData . AngularSwingImpulse = NewSwingImpulse ; BodyData . CharacterBody .)",
    "insertText": "ApplyRotationDelta(FSolverVec3(ConstraintData.CharacterInvI * Delta))"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (} const FSolverReal NormalImpulse =)",
    "insertText": "DotProduct(ImpulseData.LinearPositionImpulse, ConstraintData.Normal)"
  },
  {
    "label": "MinNormalImpulse()",
    "kind": "Method",
    "detail": "Function (const FSolverReal)",
    "insertText": "MinNormalImpulse(0.0f)"
  },
  {
    "label": "ProjectOntoPlane()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 MotionTargetError =)",
    "insertText": "ProjectOntoPlane(ConstraintData.MotionTargetError + BodyData.CharacterBody.DP(), ConstraintData.Normal)"
  },
  {
    "label": "ProjectOntoPlane()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3 InitialMotionTargetImpulse =)",
    "insertText": "ProjectOntoPlane(ImpulseData.LinearPositionImpulse, ConstraintData.Normal)"
  },
  {
    "label": "ClampMagnitude()",
    "kind": "Method",
    "detail": "Function (FSolverVec3 NewMotionTargetImpulse =)",
    "insertText": "ClampMagnitude(InitialMotionTargetImpulse - ConstraintData.SingleBodyEffectiveMass * MotionTargetError, ConstraintData.RadialImpulseLimit)"
  },
  {
    "label": "Dot()",
    "kind": "Method",
    "detail": "Function (const FSolverReal MotionTargetAngularError = ConstraintData . MotionTargetAngularError + ConstraintData . VerticalAxis .)",
    "insertText": "Dot(BodyData.CharacterBody.DQ())"
  },
  {
    "label": "ClampAbs()",
    "kind": "Method",
    "detail": "Function (const FSolverReal NewAngularImpulse =)",
    "insertText": "ClampAbs(ImpulseData.AngularImpulse - ConstraintData.EffectiveInertia * MotionTargetAngularError, ConstraintData.AngularImpulseLimit)"
  },
  {
    "label": "ApplyRotationDelta()",
    "kind": "Method",
    "detail": "Function (const FSolverReal AngularDelta = NewAngularImpulse - ImpulseData . AngularImpulse ; ImpulseData . AngularImpulse + = AngularDelta ; BodyData . CharacterBody .)",
    "insertText": "ApplyRotationDelta(FSolverVec3(ConstraintData.CharacterInvI * AngularDelta * ConstraintData.VerticalAxis))"
  },
  {
    "label": "Dot()",
    "kind": "Method",
    "detail": "Function (const FSolverReal Error = ConstraintData . Normal .)",
    "insertText": "Dot(ConstraintData.InitialProjectedError + BodyData.CharacterBody.DP() - BodyData.GroundBody.DP() - BodyData.GroundBody.DQ().Cross(ConstraintData.GroundOffset))"
  },
  {
    "label": "ApplyPositionDelta()",
    "kind": "Method",
    "detail": "Function (BodyData . GroundBody .)",
    "insertText": "ApplyPositionDelta(FSolverVec3(-ConstraintData.GroundInvM * Delta))"
  },
  {
    "label": "ApplyRotationDelta()",
    "kind": "Method",
    "detail": "Function (BodyData . GroundBody .)",
    "insertText": "ApplyRotationDelta(FSolverVec3(-ConstraintData.GroundInvI * ConstraintData.GroundOffset.Cross(Delta)))"
  },
  {
    "label": "DP()",
    "kind": "Method",
    "detail": "Function (FSolverVec3 MotionTargetError = ConstraintData . MotionTargetError + BodyData . CharacterBody .)",
    "insertText": "DP() - BodyData.GroundBody.DP()"
  },
  {
    "label": "DQ()",
    "kind": "Method",
    "detail": "Function (MotionTargetError - = BodyData . GroundBody .)",
    "insertText": "DQ().Cross(MotionTargetError)"
  },
  {
    "label": "ProjectOntoPlane()",
    "kind": "Method",
    "detail": "Function (MotionTargetError =)",
    "insertText": "ProjectOntoPlane(MotionTargetError, ConstraintData.Normal)"
  },
  {
    "label": "Dot()",
    "kind": "Method",
    "detail": "Function (const FSolverReal MotionTargetAngularError = ConstraintData . MotionTargetAngularError + ConstraintData . VerticalAxis .)",
    "insertText": "Dot(BodyData.CharacterBody.DQ() - BodyData.GroundBody.DQ())"
  }
]