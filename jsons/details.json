[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "aligned_allocator_indirection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "aligned_allocator_indirection"
  },
  {
    "label": "U",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U"
  },
  {
    "label": "rebind",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "rebind"
  },
  {
    "label": "workaround_msvc_stl_support",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "workaround_msvc_stl_support"
  },
  {
    "label": "aligned_allocator_indirection()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_STL_DETAILS_H # define EIGEN_STL_DETAILS_H # ifndef EIGEN_ALIGNED_ALLOCATOR # define EIGEN_ALIGNED_ALLOCATOR Eigen::aligned_allocator # endif namespace Eigen { template<class T> class aligned_allocator_indirection : public EIGEN_ALIGNED_ALLOCATOR<T> { public : typedef std::size_t size_type ; typedef std::ptrdiff_t difference_type ; typedef T* pointer ; typedef const T* const_pointer ; typedef T& reference ; typedef const T& const_reference ; typedef T value_type ; template<class U> struct rebind { typedef aligned_allocator_indirection<U> other ; } ;)",
    "insertText": "aligned_allocator_indirection()"
  },
  {
    "label": "aligned_allocator_indirection()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "aligned_allocator_indirection(const aligned_allocator_indirection& ) : EIGEN_ALIGNED_ALLOCATOR<T>()"
  },
  {
    "label": "aligned_allocator_indirection()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<T>&)"
  },
  {
    "label": "aligned_allocator_indirection()",
    "kind": "Method",
    "detail": "Function (} template<class U>)",
    "insertText": "aligned_allocator_indirection(const aligned_allocator_indirection<U>&)"
  },
  {
    "label": "aligned_allocator_indirection()",
    "kind": "Method",
    "detail": "Function (} template<class U>)",
    "insertText": "aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<U>&)"
  },
  {
    "label": "EIGEN_WORKAROUND_MSVC_STL_SUPPORT()",
    "kind": "Method",
    "detail": "Function (} } ; # if EIGEN_COMP_MSVC # define)",
    "insertText": "EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)"
  },
  {
    "label": "workaround_msvc_stl_support()",
    "kind": "Method",
    "detail": "Function (template<T> struct workaround_msvc_stl_support : public T {)",
    "insertText": "workaround_msvc_stl_support() : T()"
  },
  {
    "label": "workaround_msvc_stl_support()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "workaround_msvc_stl_support(const T& other) : T(other)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "T()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<OtherT> T&)",
    "insertText": "operator(const OtherT& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(other)"
  }
]