[
  {
    "label": "GetElementPtrInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GetElementPtrInst"
  },
  {
    "label": "BinaryOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BinaryOperator"
  },
  {
    "label": "ConstantExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstantExpr"
  },
  {
    "label": "Operator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Operator"
  },
  {
    "label": "OverflowingBinaryOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OverflowingBinaryOperator"
  },
  {
    "label": "PossiblyExactOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PossiblyExactOperator"
  },
  {
    "label": "FastMathFlags",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FastMathFlags"
  },
  {
    "label": "FPMathOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPMathOperator"
  },
  {
    "label": "Instruction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Instruction"
  },
  {
    "label": "ConcreteOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConcreteOperator"
  },
  {
    "label": "AddOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AddOperator"
  },
  {
    "label": "SubOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SubOperator"
  },
  {
    "label": "MulOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MulOperator"
  },
  {
    "label": "ShlOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ShlOperator"
  },
  {
    "label": "SDivOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SDivOperator"
  },
  {
    "label": "UDivOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UDivOperator"
  },
  {
    "label": "AShrOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AShrOperator"
  },
  {
    "label": "LShrOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LShrOperator"
  },
  {
    "label": "ZExtOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ZExtOperator"
  },
  {
    "label": "GEPOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GEPOperator"
  },
  {
    "label": "PtrToIntOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PtrToIntOperator"
  },
  {
    "label": "PtrToInt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PtrToInt"
  },
  {
    "label": "BitCastOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BitCastOperator"
  },
  {
    "label": "BitCastInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BitCastInst"
  },
  {
    "label": "AddrSpaceCastOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AddrSpaceCastOperator"
  },
  {
    "label": "AddrSpaceCastInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AddrSpaceCastInst"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_IR_OPERATOR_H # define LLVM_IR_OPERATOR_H # include \" llvm / IR / Constants . h \" # include \" llvm / IR / DataLayout . h \" # include \" llvm / IR / DerivedTypes . h \" # include \" llvm / IR / Instruction . h \" # include \" llvm / IR / Type . h \" namespace llvm { class GetElementPtrInst ; class BinaryOperator ; class ConstantExpr ; class Operator : public User { private : void* operator)",
    "insertText": "new(size_t, unsigned)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void* operator)",
    "insertText": "new(size_t s)"
  },
  {
    "label": "Operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Operator()"
  },
  {
    "label": "getOpcode()",
    "kind": "Method",
    "detail": "Function (public : unsigned)",
    "insertText": "getOpcode()"
  },
  {
    "label": "getOpcode()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getOpcode(const Value *V)"
  },
  {
    "label": "NoUnsignedWrap()",
    "kind": "Method",
    "detail": "Function (} } ; class OverflowingBinaryOperator : public Operator { public : enum {)",
    "insertText": "NoUnsignedWrap(1 << 0), NoSignedWrap = (1 << 1)"
  },
  {
    "label": "setHasNoUnsignedWrap()",
    "kind": "Method",
    "detail": "Function (private : class BinaryOperator ; class ConstantExpr ; void)",
    "insertText": "setHasNoUnsignedWrap(bool B)"
  },
  {
    "label": "SubclassOptionalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubclassOptionalData(SubclassOptionalData & ~NoUnsignedWrap) | (B ? NoUnsignedWrap : 0)"
  },
  {
    "label": "setHasNoSignedWrap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setHasNoSignedWrap(bool B)"
  },
  {
    "label": "SubclassOptionalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubclassOptionalData(SubclassOptionalData & ~NoSignedWrap) | (B ? NoSignedWrap : 0)"
  },
  {
    "label": "hasNoUnsignedWrap()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "hasNoUnsignedWrap()"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const Instruction *I)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const ConstantExpr *CE)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const Value *V)"
  },
  {
    "label": "IsExact()",
    "kind": "Method",
    "detail": "Function (} } ; class PossiblyExactOperator : public Operator { public : enum {)",
    "insertText": "IsExact(1 << 0)"
  },
  {
    "label": "setIsExact()",
    "kind": "Method",
    "detail": "Function (private : class BinaryOperator ; class ConstantExpr ; void)",
    "insertText": "setIsExact(bool B)"
  },
  {
    "label": "SubclassOptionalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubclassOptionalData(SubclassOptionalData & ~IsExact) | (B ? IsExact : 0)"
  },
  {
    "label": "isExact()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "isExact()"
  },
  {
    "label": "FastMathFlags()",
    "kind": "Method",
    "detail": "Function (} } ; class FastMathFlags { private : class FPMathOperator ; unsigned Flags ;)",
    "insertText": "FastMathFlags(unsigned F) : Flags(F)"
  },
  {
    "label": "UnsafeAlgebra()",
    "kind": "Method",
    "detail": "Function (} public : enum {)",
    "insertText": "UnsafeAlgebra(1 << 0), NoNaNs = (1 << 1), NoInfs = (1 << 2), NoSignedZeros = (1 << 3), AllowReciprocal = (1 << 4)"
  },
  {
    "label": "FastMathFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FastMathFlags() : Flags(0)"
  },
  {
    "label": "any()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "any()"
  },
  {
    "label": "noNaNs()",
    "kind": "Method",
    "detail": "Function (Flags = 0 ; } bool)",
    "insertText": "noNaNs()"
  },
  {
    "label": "noInfs()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "noInfs()"
  },
  {
    "label": "noSignedZeros()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "noSignedZeros()"
  },
  {
    "label": "allowReciprocal()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "allowReciprocal()"
  },
  {
    "label": "unsafeAlgebra()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "unsafeAlgebra()"
  },
  {
    "label": "setNoNaNs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setNoNaNs()"
  },
  {
    "label": "setNoInfs()",
    "kind": "Method",
    "detail": "Function (Flags | = NoNaNs ; } void)",
    "insertText": "setNoInfs()"
  },
  {
    "label": "setNoSignedZeros()",
    "kind": "Method",
    "detail": "Function (Flags | = NoInfs ; } void)",
    "insertText": "setNoSignedZeros()"
  },
  {
    "label": "setAllowReciprocal()",
    "kind": "Method",
    "detail": "Function (Flags | = NoSignedZeros ; } void)",
    "insertText": "setAllowReciprocal()"
  },
  {
    "label": "setUnsafeAlgebra()",
    "kind": "Method",
    "detail": "Function (Flags | = AllowReciprocal ; } void)",
    "insertText": "setUnsafeAlgebra()"
  },
  {
    "label": "setUnsafeAlgebraHLSL()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setUnsafeAlgebraHLSL()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator(const FastMathFlags &OtherFlags)"
  },
  {
    "label": "setHasUnsafeAlgebra()",
    "kind": "Method",
    "detail": "Function (Flags& = OtherFlags . Flags ; } } ; class FPMathOperator : public Operator { private : class Instruction ; void)",
    "insertText": "setHasUnsafeAlgebra(bool B)"
  },
  {
    "label": "SubclassOptionalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubclassOptionalData(SubclassOptionalData & ~FastMathFlags::UnsafeAlgebra) | (B ? FastMathFlags::UnsafeAlgebra : 0)"
  },
  {
    "label": "setHasNoNaNs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setHasNoNaNs(true)"
  },
  {
    "label": "setHasNoInfs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setHasNoInfs(true)"
  },
  {
    "label": "setHasNoSignedZeros()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setHasNoSignedZeros(true)"
  },
  {
    "label": "setHasAllowReciprocal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setHasAllowReciprocal(true)"
  },
  {
    "label": "setHasNoNaNs()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "setHasNoNaNs(bool B)"
  },
  {
    "label": "SubclassOptionalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubclassOptionalData(SubclassOptionalData & ~FastMathFlags::NoNaNs) | (B ? FastMathFlags::NoNaNs : 0)"
  },
  {
    "label": "setHasNoInfs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setHasNoInfs(bool B)"
  },
  {
    "label": "SubclassOptionalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubclassOptionalData(SubclassOptionalData & ~FastMathFlags::NoInfs) | (B ? FastMathFlags::NoInfs : 0)"
  },
  {
    "label": "setHasNoSignedZeros()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setHasNoSignedZeros(bool B)"
  },
  {
    "label": "SubclassOptionalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubclassOptionalData(SubclassOptionalData & ~FastMathFlags::NoSignedZeros) | (B ? FastMathFlags::NoSignedZeros : 0)"
  },
  {
    "label": "setHasAllowReciprocal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setHasAllowReciprocal(bool B)"
  },
  {
    "label": "SubclassOptionalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubclassOptionalData(SubclassOptionalData & ~FastMathFlags::AllowReciprocal) | (B ? FastMathFlags::AllowReciprocal : 0)"
  },
  {
    "label": "setFastMathFlags()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setFastMathFlags(FastMathFlags FMF)"
  },
  {
    "label": "copyFastMathFlags()",
    "kind": "Method",
    "detail": "Function (SubclassOptionalData | = FMF . Flags ; } void)",
    "insertText": "copyFastMathFlags(FastMathFlags FMF)"
  },
  {
    "label": "hasUnsafeAlgebra()",
    "kind": "Method",
    "detail": "Function (SubclassOptionalData = FMF . Flags ; } public : bool)",
    "insertText": "hasUnsafeAlgebra()"
  },
  {
    "label": "hasNoNaNs()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasNoNaNs()"
  },
  {
    "label": "hasNoInfs()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasNoInfs()"
  },
  {
    "label": "hasNoSignedZeros()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasNoSignedZeros()"
  },
  {
    "label": "hasAllowReciprocal()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasAllowReciprocal()"
  },
  {
    "label": "getFastMathFlags()",
    "kind": "Method",
    "detail": "Function (} FastMathFlags)",
    "insertText": "getFastMathFlags()"
  },
  {
    "label": "getFPAccuracy()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "getFPAccuracy()"
  },
  {
    "label": "IsInBounds()",
    "kind": "Method",
    "detail": "Function (} } ; class AddOperator : public ConcreteOperator<OverflowingBinaryOperator,Instruction::Add> { } ; class SubOperator : public ConcreteOperator<OverflowingBinaryOperator,Instruction::Sub> { } ; class MulOperator : public ConcreteOperator<OverflowingBinaryOperator,Instruction::Mul> { } ; class ShlOperator : public ConcreteOperator<OverflowingBinaryOperator,Instruction::Shl> { } ; class SDivOperator : public ConcreteOperator<PossiblyExactOperator,Instruction::SDiv> { } ; class UDivOperator : public ConcreteOperator<PossiblyExactOperator,Instruction::UDiv> { } ; class AShrOperator : public ConcreteOperator<PossiblyExactOperator,Instruction::AShr> { } ; class LShrOperator : public ConcreteOperator<PossiblyExactOperator,Instruction::LShr> { } ; class ZExtOperator : public ConcreteOperator<Operator,Instruction::ZExt> { } ; class GEPOperator : public ConcreteOperator<Operator,Instruction::GetElementPtr> { enum {)",
    "insertText": "IsInBounds(1 << 0)"
  },
  {
    "label": "setIsInBounds()",
    "kind": "Method",
    "detail": "Function (class GetElementPtrInst ; class ConstantExpr ; void)",
    "insertText": "setIsInBounds(bool B)"
  },
  {
    "label": "SubclassOptionalData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubclassOptionalData(SubclassOptionalData & ~IsInBounds) | (B * IsInBounds)"
  },
  {
    "label": "isInBounds()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "isInBounds()"
  },
  {
    "label": "idx_begin()",
    "kind": "Method",
    "detail": "Function (} const_op_iterator)",
    "insertText": "idx_begin()"
  },
  {
    "label": "idx_end()",
    "kind": "Method",
    "detail": "Function (} op_iterator)",
    "insertText": "idx_end()"
  },
  {
    "label": "getPointerOperand()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "getPointerOperand()"
  },
  {
    "label": "getPointerOperandIndex()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getPointerOperandIndex()"
  },
  {
    "label": "getSourceElementType()",
    "kind": "Method",
    "detail": "Function (} Type*)",
    "insertText": "getSourceElementType()"
  },
  {
    "label": "getPointerAddressSpace()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getPointerAddressSpace()"
  },
  {
    "label": "getNumIndices()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getNumIndices()"
  },
  {
    "label": "hasIndices()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasIndices()"
  },
  {
    "label": "hasAllZeroIndices()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasAllZeroIndices()"
  },
  {
    "label": "accumulateConstantOffset()",
    "kind": "Method",
    "detail": "Function (} return true ; } bool)",
    "insertText": "accumulateConstantOffset(const DataLayout &DL, APInt &Offset)"
  },
  {
    "label": "getSrcTy()",
    "kind": "Method",
    "detail": "Function (} } ; class BitCastOperator : public ConcreteOperator<Operator,Instruction::BitCast> { class BitCastInst ; class ConstantExpr ; public : Type*)",
    "insertText": "getSrcTy()"
  },
  {
    "label": "getDestTy()",
    "kind": "Method",
    "detail": "Function (} Type*)",
    "insertText": "getDestTy()"
  },
  {
    "label": "getSrcAddressSpace()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getSrcAddressSpace()"
  },
  {
    "label": "getDestAddressSpace()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getDestAddressSpace()"
  }
]