[
  {
    "label": "DataType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DataType"
  },
  {
    "label": "OptionValueCopy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OptionValueCopy"
  },
  {
    "label": "OptionValueBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OptionValueBase"
  },
  {
    "label": "OptionValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OptionValue"
  },
  {
    "label": "DT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DT"
  },
  {
    "label": "boolOrDefault",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "boolOrDefault"
  },
  {
    "label": "ValuesClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValuesClass"
  },
  {
    "label": "Opt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Opt"
  },
  {
    "label": "generic_parser_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "generic_parser_base"
  },
  {
    "label": "GenericOptionInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GenericOptionInfo"
  },
  {
    "label": "AnyOptionValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AnyOptionValue"
  },
  {
    "label": "ValueExpected",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ValueExpected"
  },
  {
    "label": "parser",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "parser"
  },
  {
    "label": "OptionInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OptionInfo"
  },
  {
    "label": "basic_parser_impl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "basic_parser_impl"
  },
  {
    "label": "basic_parser",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "basic_parser"
  },
  {
    "label": "ParserClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ParserClass"
  },
  {
    "label": "ParserDT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ParserDT"
  },
  {
    "label": "ValDT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValDT"
  },
  {
    "label": "OptionDiffPrinter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OptionDiffPrinter"
  },
  {
    "label": "Mod",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mod"
  },
  {
    "label": "applicator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "applicator"
  },
  {
    "label": "opt_storage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opt_storage"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "opt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "opt"
  },
  {
    "label": "StorageClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StorageClass"
  },
  {
    "label": "list_storage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "list_storage"
  },
  {
    "label": "list",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "list"
  },
  {
    "label": "multi_val",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "multi_val"
  },
  {
    "label": "bits_storage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "bits_storage"
  },
  {
    "label": "exceeds",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "exceeds"
  },
  {
    "label": "Storage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Storage"
  },
  {
    "label": "bits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "bits"
  },
  {
    "label": "alias",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "alias"
  },
  {
    "label": "aliasopt",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "aliasopt"
  },
  {
    "label": "extrahelp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "extrahelp"
  },
  {
    "label": "compare()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "compare(const DataType &)"
  },
  {
    "label": "OptionValueCopy()",
    "kind": "Method",
    "detail": "Function (} ; template<class DataType> class OptionValueCopy : public GenericOptionValue { DataType Value ; bool Valid ; protected : ~)",
    "insertText": "OptionValueCopy()"
  },
  {
    "label": "OptionValueCopy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OptionValueCopy(const OptionValueCopy&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (OptionValueCopy&)",
    "insertText": "operator(const OptionValueCopy&)"
  },
  {
    "label": "OptionValueCopy()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "OptionValueCopy() : Valid(false)"
  },
  {
    "label": "hasValue()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasValue()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Valid && \"invalid option value\")"
  },
  {
    "label": "compare()",
    "kind": "Method",
    "detail": "Function (Valid = true ; Value = V ; } bool)",
    "insertText": "compare(const DataType &V)"
  },
  {
    "label": "compare()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "compare(const GenericOptionValue &V)"
  },
  {
    "label": "DataType()",
    "kind": "Method",
    "detail": "Function (const OptionValueCopy<DataType>& VC = static_cast<const OptionValueCopy<)",
    "insertText": "DataType(V)"
  },
  {
    "label": "OptionValueBase()",
    "kind": "Method",
    "detail": "Function (} } ; template<class DataType> struct OptionValueBase<DataType,false> : OptionValueCopy<DataType> { typedef DataType WrapperType ; protected : ~)",
    "insertText": "OptionValueBase()"
  },
  {
    "label": "OptionValueBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OptionValueBase(const OptionValueBase&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (OptionValueBase&)",
    "insertText": "operator(const OptionValueBase&)"
  },
  {
    "label": "OptionValue()",
    "kind": "Method",
    "detail": "Function (} ; template<class DataType> struct OptionValue final : OptionValueBase<DataType,std::is_class<DataType>::value> {)",
    "insertText": "OptionValue()"
  },
  {
    "label": "OptionValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OptionValue(const DataType &V)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValue(V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class DT> OptionValue<DataType>&)",
    "insertText": "operator(const DT &V)"
  },
  {
    "label": "OptionValue()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "OptionValue(const cl::boolOrDefault &V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} OptionValue<cl::boolOrDefault>&)",
    "insertText": "operator(const cl::boolOrDefault &V)"
  },
  {
    "label": "OptionValue()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "OptionValue(const std::string &V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} OptionValue<std::string>&)",
    "insertText": "operator(const std::string &V)"
  },
  {
    "label": "clEnumVal()",
    "kind": "Method",
    "detail": "Function (} ; # define)",
    "insertText": "clEnumVal(ENUMVAL, DESC) #ENUMVAL, int(ENUMVAL), DESC #define clEnumValN(ENUMVAL, FLAGNAME, DESC) FLAGNAME, int(ENUMVAL), DESC #define clEnumValEnd (reinterpret_cast<void *>(0))"
  },
  {
    "label": "processValues()",
    "kind": "Method",
    "detail": "Function (SmallVector<std::pair<const char*,std::pair<int,const char*>>,4> Values ; void)",
    "insertText": "processValues(va_list Vals)"
  },
  {
    "label": "ValuesClass()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "ValuesClass(const char *EnumName, DataType Val, const char *Desc, va_list ValueArgs)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Values .)",
    "insertText": "push_back(std::make_pair(EnumName, std::make_pair(Val, Desc)))"
  },
  {
    "label": "DataType()",
    "kind": "Method",
    "detail": "Function (DataType EnumVal = static_cast<)",
    "insertText": "DataType(va_arg(ValueArgs, int))"
  },
  {
    "label": "va_arg()",
    "kind": "Method",
    "detail": "Function (const char* EnumDesc =)",
    "insertText": "va_arg(ValueArgs, const char *)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Values .)",
    "insertText": "push_back(std::make_pair(enumName, std::make_pair(EnumVal, EnumDesc)))"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (} } template<class Opt> void)",
    "insertText": "apply(Opt &O)"
  },
  {
    "label": "values()",
    "kind": "Method",
    "detail": "Function (} } ; template<class DataType> ValuesClass<DataType> LLVM_END_WITH_NULL)",
    "insertText": "values(const char *Arg, DataType Val, const char *Desc, ...)"
  },
  {
    "label": "va_start()",
    "kind": "Method",
    "detail": "Function (va_list ValueArgs ;)",
    "insertText": "va_start(ValueArgs, Desc)"
  },
  {
    "label": "Vals()",
    "kind": "Method",
    "detail": "Function (ValuesClass<DataType>)",
    "insertText": "Vals(Arg, Val, Desc, ValueArgs)"
  },
  {
    "label": "va_end()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "va_end(ValueArgs)"
  },
  {
    "label": "generic_parser_base()",
    "kind": "Method",
    "detail": "Function (} const char* Name ; const char* HelpStr ; } ; public :)",
    "insertText": "generic_parser_base(Option &O) : Owner(O)"
  },
  {
    "label": "generic_parser_base()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "generic_parser_base()"
  },
  {
    "label": "getNumOptions()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getNumOptions()"
  },
  {
    "label": "getOption()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "getOption(unsigned N)"
  },
  {
    "label": "getDescription()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "getDescription(unsigned N)"
  },
  {
    "label": "getOptionWidth()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "getOptionWidth(const Option &O)"
  },
  {
    "label": "getOptionValue()",
    "kind": "Method",
    "detail": "Function (const GenericOptionValue&)",
    "insertText": "getOptionValue(unsigned N)"
  },
  {
    "label": "printOptionInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printOptionInfo(const Option &O, size_t GlobalWidth)"
  },
  {
    "label": "printGenericOptionDiff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printGenericOptionDiff(const Option &O, const GenericOptionValue &V, const GenericOptionValue &Default, size_t GlobalWidth)"
  },
  {
    "label": "printOptionDiff()",
    "kind": "Method",
    "detail": "Function (template<class AnyOptionValue> void)",
    "insertText": "printOptionDiff(const Option &O, const AnyOptionValue &V, const AnyOptionValue &Default, size_t GlobalWidth)"
  },
  {
    "label": "printGenericOptionDiff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printGenericOptionDiff(O, V, Default, GlobalWidth)"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "initialize()"
  },
  {
    "label": "getExtraOptionNames()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "getExtraOptionNames(SmallVectorImpl<const char *> &OptionNames)"
  },
  {
    "label": "getValueExpectedFlagDefault()",
    "kind": "Method",
    "detail": "Function (} enum ValueExpected)",
    "insertText": "getValueExpectedFlagDefault()"
  },
  {
    "label": "OptionInfo()",
    "kind": "Method",
    "detail": "Function (protected : Option& Owner ; } ; template<class DataType> class parser : public generic_parser_base { protected : class OptionInfo : public GenericOptionInfo { public :)",
    "insertText": "OptionInfo(const char *name, DataType v, const char *helpStr) : GenericOptionInfo(name, helpStr), V(v)"
  },
  {
    "label": "parser()",
    "kind": "Method",
    "detail": "Function (} OptionValue<DataType> V ; } ; SmallVector<OptionInfo,8> Values ; public :)",
    "insertText": "parser(Option &O) : generic_parser_base(O)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StringRef ArgVal ;)",
    "insertText": "if(Owner.hasArgStr())"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V = Values [ i ] . V .)",
    "insertText": "getValue()"
  },
  {
    "label": "addLiteralOption()",
    "kind": "Method",
    "detail": "Function (} template<class DT> void)",
    "insertText": "addLiteralOption(const char *Name, const DT &V, const char *HelpStr)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(findOption(Name) == Values.size() && \"Option already exists!\")"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (OptionInfo)",
    "insertText": "X(Name, static_cast<DataType>(V), HelpStr)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Values .)",
    "insertText": "push_back(X)"
  },
  {
    "label": "AddLiteralOption()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddLiteralOption(Owner, Name)"
  },
  {
    "label": "removeLiteralOption()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "removeLiteralOption(const char *Name)"
  },
  {
    "label": "findOption()",
    "kind": "Method",
    "detail": "Function (unsigned N =)",
    "insertText": "findOption(Name)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(N != Values.size() && \"Option not found!\")"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (Values .)",
    "insertText": "erase(Values.begin() + N)"
  },
  {
    "label": "basic_parser_impl()",
    "kind": "Method",
    "detail": "Function (} } ; class basic_parser_impl { public :)",
    "insertText": "basic_parser_impl(Option &O)"
  },
  {
    "label": "printOptionNoValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printOptionNoValue(const Option &O, size_t GlobalWidth)"
  },
  {
    "label": "getValueName()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "getValueName()"
  },
  {
    "label": "basic_parser_impl()",
    "kind": "Method",
    "detail": "Function (protected : ~)",
    "insertText": "basic_parser_impl()"
  },
  {
    "label": "printOptionName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printOptionName(const Option &O, size_t GlobalWidth)"
  },
  {
    "label": "basic_parser()",
    "kind": "Method",
    "detail": "Function (} ; template<class DataType> class basic_parser : public basic_parser_impl { public :)",
    "insertText": "basic_parser(Option &O) : basic_parser_impl(O)"
  },
  {
    "label": "basic_parser()",
    "kind": "Method",
    "detail": "Function (} typedef DataType parser_data_type ; typedef OptionValue<DataType> OptVal ; protected : ~)",
    "insertText": "basic_parser()"
  },
  {
    "label": "parser()",
    "kind": "Method",
    "detail": "Function (} } ; template<> class parser<bool> final : public basic_parser<bool> { public :)",
    "insertText": "parser(Option &O) : basic_parser(O)"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "parse(Option &O, StringRef ArgName, StringRef Arg, bool &Val)"
  },
  {
    "label": "anchor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "anchor()"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "parse(Option &O, StringRef ArgName, StringRef Arg, boolOrDefault &Val)"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "parse(Option &O, StringRef ArgName, StringRef Arg, int &Val)"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "parse(Option &O, StringRef ArgName, StringRef Arg, unsigned &Val)"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "parse(Option &O, StringRef ArgName, StringRef Arg, unsigned long long &Val)"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "parse(Option &O, StringRef ArgName, StringRef Arg, double &Val)"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "parse(Option &O, StringRef ArgName, StringRef Arg, float &Val)"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "parse(Option &, StringRef, StringRef Arg, std::string &Value)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (Value = Arg .)",
    "insertText": "str()"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "parse(Option &, StringRef, StringRef Arg, char &Value)"
  },
  {
    "label": "printOptionDiff()",
    "kind": "Method",
    "detail": "Function (} ; template class basic_parser<char> ; template<class ParserClass,class DT> void)",
    "insertText": "printOptionDiff(const Option &O, const generic_parser_base &P, const DT &V, const OptionValue<DT> &Default, size_t GlobalWidth)"
  },
  {
    "label": "printOptionDiff()",
    "kind": "Method",
    "detail": "Function (OptionValue<DT> OV = V ; P .)",
    "insertText": "printOptionDiff(O, OV, Default, GlobalWidth)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (} template<class ParserDT,class ValDT> struct OptionDiffPrinter { void)",
    "insertText": "print(const Option &O, const parser<ParserDT> &P, const ValDT & , const OptionValue<ValDT> & , size_t GlobalWidth)"
  },
  {
    "label": "printOptionNoValue()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "printOptionNoValue(O, GlobalWidth)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (} } ; template<class DT> struct OptionDiffPrinter<DT,DT> { void)",
    "insertText": "print(const Option &O, const parser<DT> &P, const DT &V, const OptionValue<DT> &Default, size_t GlobalWidth)"
  },
  {
    "label": "printOptionDiff()",
    "kind": "Method",
    "detail": "Function (P .)",
    "insertText": "printOptionDiff(O, V, Default, GlobalWidth)"
  },
  {
    "label": "printOptionDiff()",
    "kind": "Method",
    "detail": "Function (} } ; template<class ParserClass,class ValDT> void)",
    "insertText": "printOptionDiff(const Option &O, const basic_parser<typename ParserClass::parser_data_type> &P, const ValDT &V, const OptionValue<ValDT> &Default, size_t GlobalWidth)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (OptionDiffPrinter<ParserClass::parser_data_type,ValDT> printer ; printer .)",
    "insertText": "print(O, static_cast<const ParserClass &>(P), V, Default, GlobalWidth)"
  },
  {
    "label": "opt()",
    "kind": "Method",
    "detail": "Function (} template<class Mod> struct applicator { template<class Opt> void)",
    "insertText": "opt(const Mod &M, Opt &O)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (M .)",
    "insertText": "apply(O)"
  },
  {
    "label": "opt()",
    "kind": "Method",
    "detail": "Function (} } ; template<unsigned n> struct applicator<char [ n ]> { template<class Opt> void)",
    "insertText": "opt(const char *Str, Opt &O)"
  },
  {
    "label": "setArgStr()",
    "kind": "Method",
    "detail": "Function (O .)",
    "insertText": "setArgStr(Str)"
  },
  {
    "label": "opt()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct applicator<NumOccurrencesFlag> { void)",
    "insertText": "opt(NumOccurrencesFlag N, Option &O)"
  },
  {
    "label": "setNumOccurrencesFlag()",
    "kind": "Method",
    "detail": "Function (O .)",
    "insertText": "setNumOccurrencesFlag(N)"
  },
  {
    "label": "opt()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct applicator<ValueExpected> { void)",
    "insertText": "opt(ValueExpected VE, Option &O)"
  },
  {
    "label": "setValueExpectedFlag()",
    "kind": "Method",
    "detail": "Function (O .)",
    "insertText": "setValueExpectedFlag(VE)"
  },
  {
    "label": "opt()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct applicator<OptionHidden> { void)",
    "insertText": "opt(OptionHidden OH, Option &O)"
  },
  {
    "label": "setHiddenFlag()",
    "kind": "Method",
    "detail": "Function (O .)",
    "insertText": "setHiddenFlag(OH)"
  },
  {
    "label": "opt()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct applicator<FormattingFlags> { void)",
    "insertText": "opt(FormattingFlags FF, Option &O)"
  },
  {
    "label": "setFormattingFlag()",
    "kind": "Method",
    "detail": "Function (O .)",
    "insertText": "setFormattingFlag(FF)"
  },
  {
    "label": "opt()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct applicator<MiscFlags> { void)",
    "insertText": "opt(MiscFlags MF, Option &O)"
  },
  {
    "label": "setMiscFlag()",
    "kind": "Method",
    "detail": "Function (O .)",
    "insertText": "setMiscFlag(MF)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (} } ; template<class Opt,class Mod,class . . . Mods> void)",
    "insertText": "apply(Opt *O, const Mod &M, const Mods &... Ms)"
  },
  {
    "label": "opt()",
    "kind": "Method",
    "detail": "Function (applicator<Mod)",
    "insertText": "opt(M, *O)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "apply(O, Ms...)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (} template<class Opt,class Mod> void)",
    "insertText": "apply(Opt *O, const Mod &M)"
  },
  {
    "label": "check_location()",
    "kind": "Method",
    "detail": "Function (} template<class DataType,bool ExternalStorage,bool isClass> class opt_storage { DataType* Location ; OptionValue<DataType> Default ; void)",
    "insertText": "check_location()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Location && \"cl::location(...) not specified for a command \" \"line option with external storage, \" \"or cl::init specified before cl::location()!!\")"
  },
  {
    "label": "opt_storage()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "opt_storage() : Location(nullptr)"
  },
  {
    "label": "setLocation()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "setLocation(Option &O, DataType &L)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (Location =& L ; Default = L ; return false ; } template<class T> void)",
    "insertText": "setValue(const T &V, bool initial = false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* Location = V ;)",
    "insertText": "if(initial)"
  },
  {
    "label": "getDefault()",
    "kind": "Method",
    "detail": "Function (} const OptionValue<DataType>&)",
    "insertText": "getDefault()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} DataType)",
    "insertText": "operator()"
  },
  {
    "label": "parser_data_type()",
    "kind": "Method",
    "detail": "Function (ParserClass::parser_data_type Val =)",
    "insertText": "parser_data_type()"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValue(Val)"
  },
  {
    "label": "setPosition()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setPosition(pos)"
  },
  {
    "label": "getOptionWidth()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "getOptionWidth()"
  },
  {
    "label": "printOptionInfo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "printOptionInfo(size_t GlobalWidth)"
  },
  {
    "label": "printOptionInfo()",
    "kind": "Method",
    "detail": "Function (Parser .)",
    "insertText": "printOptionInfo(*this, GlobalWidth)"
  },
  {
    "label": "printOptionValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "printOptionValue(size_t GlobalWidth, bool Force)"
  },
  {
    "label": "ParserClass()",
    "kind": "Method",
    "detail": "Function (cl::printOptionDiff<)",
    "insertText": "ParserClass(*this, Parser, this->getValue(), this->getDefault(), GlobalWidth)"
  },
  {
    "label": "done()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "done()"
  },
  {
    "label": "addArgument()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addArgument()"
  },
  {
    "label": "opt()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "opt(const opt &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (opt&)",
    "insertText": "operator(const opt &)"
  },
  {
    "label": "setInitialValue()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "setInitialValue(const DataType &V)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValue(V, true)"
  },
  {
    "label": "getParser()",
    "kind": "Method",
    "detail": "Function (} ParserClass&)",
    "insertText": "getParser()"
  },
  {
    "label": "opt()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Mods>)",
    "insertText": "opt(const Mods &... Ms) : Option(Optional, NotHidden), Parser(*this)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "apply(this, Ms...)"
  },
  {
    "label": "list_storage()",
    "kind": "Method",
    "detail": "Function (} } ; template class opt<unsigned> ; template class opt<int> ; template class opt<std::string> ; template class opt<char> ; template class opt<bool> ; template<class DataType,class StorageClass> class list_storage { StorageClass* Location ; public :)",
    "insertText": "list_storage() : Location(0)"
  },
  {
    "label": "setLocation()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "setLocation(Option &O, StorageClass &L)"
  },
  {
    "label": "addValue()",
    "kind": "Method",
    "detail": "Function (Location =& L ; return false ; } template<class T> void)",
    "insertText": "addValue(const T &V)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Location != 0 && \"cl::location(...) not specified for a command \" \"line option with external storage!\")"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Location ->)",
    "insertText": "push_back(V)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} } ; template<class DataType> class list_storage<DataType,bool> { std::vector<DataType> Storage ; public : typedef std::vector<DataType>::iterator iterator ; iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} typedef std::vector<DataType>::size_type size_type ; size_type)",
    "insertText": "size()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_back(const DataType &value)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Storage .)",
    "insertText": "push_back(value)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_back(DataType &&value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} typedef std::vector<DataType>::reference reference ; typedef std::vector<DataType>::const_reference const_reference ; reference)",
    "insertText": "operator(size_type pos)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "erase(const_iterator first, const_iterator last)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "erase(iterator pos)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "erase(iterator first, iterator last)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(const_iterator pos, const DataType &value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(const_iterator pos, DataType &&value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(iterator pos, const DataType &value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(iterator pos, DataType &&value)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "front()"
  },
  {
    "label": "DataType()",
    "kind": "Method",
    "detail": "Function (} operator std::vector<)",
    "insertText": "DataType()"
  },
  {
    "label": "handleOccurrence()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "handleOccurrence(unsigned pos, StringRef ArgName, StringRef Arg)"
  },
  {
    "label": "addValue()",
    "kind": "Method",
    "detail": "Function (list_storage<DataType,StorageClass)",
    "insertText": "addValue(Val)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Positions .)",
    "insertText": "push_back(pos)"
  },
  {
    "label": "printOptionValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "printOptionValue(size_t , bool)"
  },
  {
    "label": "list()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "list(const list &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (list&)",
    "insertText": "operator(const list &)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(optnum < this->size() && \"Invalid option index\")"
  },
  {
    "label": "setNumAdditionalVals()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setNumAdditionalVals(n)"
  },
  {
    "label": "list()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Mods>)",
    "insertText": "list(const Mods &... Ms) : Option(ZeroOrMore, NotHidden), Parser(*this)"
  },
  {
    "label": "multi_val()",
    "kind": "Method",
    "detail": "Function (} } ; struct multi_val { unsigned AdditionalVals ;)",
    "insertText": "multi_val(unsigned N) : AdditionalVals(N)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (} template<D,S,P> void)",
    "insertText": "apply(list<D, S, P> &L)"
  },
  {
    "label": "setNumAdditionalVals()",
    "kind": "Method",
    "detail": "Function (L .)",
    "insertText": "setNumAdditionalVals(AdditionalVals)"
  },
  {
    "label": "Bit()",
    "kind": "Method",
    "detail": "Function (} } ; template<class DataType,class StorageClass> class bits_storage { unsigned* Location ; template<class T> unsigned)",
    "insertText": "Bit(const T &V)"
  },
  {
    "label": "unsigned()",
    "kind": "Method",
    "detail": "Function (unsigned BitPos = reinterpret_cast<)",
    "insertText": "unsigned(V)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(BitPos < sizeof(unsigned) * CHAR_BIT && \"enum exceeds width of bit vector!\")"
  },
  {
    "label": "setLocation()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "setLocation(Option &O, unsigned &L)"
  },
  {
    "label": "Bit()",
    "kind": "Method",
    "detail": "Function (* Location | =)",
    "insertText": "Bit(V)"
  },
  {
    "label": "getBits()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getBits()"
  },
  {
    "label": "BitPos()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "BitPos(unsigned)"
  },
  {
    "label": "bits()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "bits(const bits &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bits&)",
    "insertText": "operator(const bits &)"
  },
  {
    "label": "handleOccurrence()",
    "kind": "Method",
    "detail": "Function (} } ; class alias : public Option { Option* AliasFor ; bool)",
    "insertText": "handleOccurrence(unsigned pos, StringRef , StringRef Arg)"
  },
  {
    "label": "addOccurrence()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "addOccurrence(unsigned pos, StringRef , StringRef Value, bool MultiArg = false)"
  },
  {
    "label": "alias()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "alias(const alias &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (alias&)",
    "insertText": "operator(const alias &)"
  },
  {
    "label": "setAliasFor()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "setAliasFor(Option &O)"
  },
  {
    "label": "alias()",
    "kind": "Method",
    "detail": "Function (AliasFor =& O ; } template<class . . . Mods>)",
    "insertText": "alias(const Mods &... Ms) : Option(Optional, Hidden), AliasFor(nullptr)"
  },
  {
    "label": "aliasopt()",
    "kind": "Method",
    "detail": "Function (} } ; struct aliasopt { Option& Opt ;)",
    "insertText": "aliasopt(Option &O) : Opt(O)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "apply(alias &A)"
  },
  {
    "label": "setAliasFor()",
    "kind": "Method",
    "detail": "Function (A .)",
    "insertText": "setAliasFor(Opt)"
  },
  {
    "label": "extrahelp()",
    "kind": "Method",
    "detail": "Function (} } ; struct extrahelp { const char* morehelp ;)",
    "insertText": "extrahelp(const char *help)"
  },
  {
    "label": "PrintVersionMessage()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "PrintVersionMessage()"
  },
  {
    "label": "PrintHelpMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintHelpMessage(bool Hidden = false, bool Categorized = false)"
  },
  {
    "label": "getRegisteredOptions()",
    "kind": "Method",
    "detail": "Function (StringMap<Option*>&)",
    "insertText": "getRegisteredOptions()"
  },
  {
    "label": "TokenizeGNUCommandLine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TokenizeGNUCommandLine(StringRef Source, StringSaver &Saver, SmallVectorImpl<const char *> &NewArgv, bool MarkEOLs = false)"
  },
  {
    "label": "TokenizeWindowsCommandLine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TokenizeWindowsCommandLine(StringRef Source, StringSaver &Saver, SmallVectorImpl<const char *> &NewArgv, bool MarkEOLs = false)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(*TokenizerCallback)(StringRef Source, StringSaver &Saver, SmallVectorImpl<const char *> &NewArgv, bool MarkEOLs)"
  },
  {
    "label": "ExpandResponseFiles()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExpandResponseFiles(StringSaver &Saver, TokenizerCallback Tokenizer, SmallVectorImpl<const char *> &Argv, bool MarkEOLs = false)"
  },
  {
    "label": "HideUnrelatedOptions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HideUnrelatedOptions(cl::OptionCategory &Category)"
  },
  {
    "label": "HideUnrelatedOptions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HideUnrelatedOptions(ArrayRef<const cl::OptionCategory *> Categories)"
  }
]