[
  {
    "label": "InstrItineraryData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InstrItineraryData"
  },
  {
    "label": "LiveVariables",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LiveVariables"
  },
  {
    "label": "MCAsmInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCAsmInfo"
  },
  {
    "label": "MachineMemOperand",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineMemOperand"
  },
  {
    "label": "MachineRegisterInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineRegisterInfo"
  },
  {
    "label": "MDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MDNode"
  },
  {
    "label": "MCInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCInst"
  },
  {
    "label": "MCSchedModel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MCSchedModel"
  },
  {
    "label": "MCSymbolRefExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCSymbolRefExpr"
  },
  {
    "label": "SDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SDNode"
  },
  {
    "label": "ScheduleHazardRecognizer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScheduleHazardRecognizer"
  },
  {
    "label": "SelectionDAG",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SelectionDAG"
  },
  {
    "label": "ScheduleDAG",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScheduleDAG"
  },
  {
    "label": "TargetRegisterClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetRegisterClass"
  },
  {
    "label": "TargetRegisterInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetRegisterInfo"
  },
  {
    "label": "BranchProbability",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BranchProbability"
  },
  {
    "label": "TargetSubtargetInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetSubtargetInfo"
  },
  {
    "label": "TargetSchedModel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetSchedModel"
  },
  {
    "label": "DFAPacketizer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DFAPacketizer"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "SmallVectorImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallVectorImpl"
  },
  {
    "label": "TargetInstrInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetInstrInfo"
  },
  {
    "label": "RegSubRegPair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RegSubRegPair"
  },
  {
    "label": "RegSubRegPairAndIdx",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RegSubRegPairAndIdx"
  },
  {
    "label": "MachineBranchPredicate",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MachineBranchPredicate"
  },
  {
    "label": "ComparePredicate",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ComparePredicate"
  },
  {
    "label": "TargetInstrInfo()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_TARGET_TARGETINSTRINFO_H # define LLVM_TARGET_TARGETINSTRINFO_H # include \" llvm / ADT / DenseMap . h \" # include \" llvm / ADT / SmallSet . h \" # include \" llvm / CodeGen / MachineCombinerPattern . h \" # include \" llvm / CodeGen / MachineFunction . h \" # include \" llvm / MC / MCInstrInfo . h \" # include \" llvm / Target / TargetRegisterInfo . h \" namespace llvm { class InstrItineraryData ; class LiveVariables ; class MCAsmInfo ; class MachineMemOperand ; class MachineRegisterInfo ; class MDNode ; class MCInst ; struct MCSchedModel ; class MCSymbolRefExpr ; class SDNode ; class ScheduleHazardRecognizer ; class SelectionDAG ; class ScheduleDAG ; class TargetRegisterClass ; class TargetRegisterInfo ; class BranchProbability ; class TargetSubtargetInfo ; class TargetSchedModel ; class DFAPacketizer ; template<class T> class SmallVectorImpl ; class TargetInstrInfo : public MCInstrInfo {)",
    "insertText": "TargetInstrInfo(const TargetInstrInfo &)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const TargetInstrInfo &)"
  },
  {
    "label": "TargetInstrInfo()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TargetInstrInfo(unsigned CFSetupOpcode = ~0u, unsigned CFDestroyOpcode = ~0u) : CallFrameSetupOpcode(CFSetupOpcode), CallFrameDestroyOpcode(CFDestroyOpcode)"
  },
  {
    "label": "TargetInstrInfo()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TargetInstrInfo()"
  },
  {
    "label": "getRegClass()",
    "kind": "Method",
    "detail": "Function (const TargetRegisterClass*)",
    "insertText": "getRegClass(const MCInstrDesc &TID, unsigned OpNum, const TargetRegisterInfo *TRI, const MachineFunction &MF)"
  },
  {
    "label": "isTriviallyReMaterializable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isTriviallyReMaterializable(const MachineInstr *MI, AliasAnalysis *AA = nullptr)"
  },
  {
    "label": "isReallyTriviallyReMaterializable()",
    "kind": "Method",
    "detail": "Function (} protected : bool)",
    "insertText": "isReallyTriviallyReMaterializable(const MachineInstr *MI, AliasAnalysis *AA)"
  },
  {
    "label": "getCallFrameSetupOpcode()",
    "kind": "Method",
    "detail": "Function (public : unsigned)",
    "insertText": "getCallFrameSetupOpcode()"
  },
  {
    "label": "isCoalescableExtInstr()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isCoalescableExtInstr(const MachineInstr &MI, unsigned &SrcReg, unsigned &DstReg, unsigned &SubIdx)"
  },
  {
    "label": "isStoreToStackSlot()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "isStoreToStackSlot(const MachineInstr *MI, int &FrameIndex)"
  },
  {
    "label": "isStackSlotCopy()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isStackSlotCopy(const MachineInstr *MI, int &DestFrameIndex, int &SrcFrameIndex)"
  },
  {
    "label": "isAsCheapAsAMove()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isAsCheapAsAMove(const MachineInstr *MI)"
  },
  {
    "label": "reMaterialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reMaterialize(MachineBasicBlock &MBB, MachineBasicBlock::iterator MI, unsigned DestReg, unsigned SubIdx, const MachineInstr *Orig, const TargetRegisterInfo &TRI)"
  },
  {
    "label": "duplicate()",
    "kind": "Method",
    "detail": "Function (MachineInstr*)",
    "insertText": "duplicate(MachineInstr *Orig, MachineFunction &MF)"
  },
  {
    "label": "convertToThreeAddress()",
    "kind": "Method",
    "detail": "Function (MachineInstr*)",
    "insertText": "convertToThreeAddress(MachineFunction::iterator &MFI, MachineBasicBlock::iterator &MBBI, LiveVariables *LV)"
  },
  {
    "label": "findCommutedOpIndices()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "findCommutedOpIndices(MachineInstr *MI, unsigned &SrcOpIdx1, unsigned &SrcOpIdx2)"
  },
  {
    "label": "RegSubRegPair()",
    "kind": "Method",
    "detail": "Function (struct RegSubRegPair { unsigned Reg ; unsigned SubReg ;)",
    "insertText": "RegSubRegPair(unsigned Reg = 0, unsigned SubReg = 0) : Reg(Reg), SubReg(SubReg)"
  },
  {
    "label": "RegSubRegPairAndIdx()",
    "kind": "Method",
    "detail": "Function (} } ; struct RegSubRegPairAndIdx : RegSubRegPair { unsigned SubIdx ;)",
    "insertText": "RegSubRegPairAndIdx(unsigned Reg = 0, unsigned SubReg = 0, unsigned SubIdx = 0) : RegSubRegPair(Reg, SubReg), SubIdx(SubIdx)"
  },
  {
    "label": "getRegSequenceInputs()",
    "kind": "Method",
    "detail": "Function (} } ; bool)",
    "insertText": "getRegSequenceInputs(const MachineInstr &MI, unsigned DefIdx, SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs)"
  },
  {
    "label": "getExtractSubregInputs()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "getExtractSubregInputs(const MachineInstr &MI, unsigned DefIdx, RegSubRegPairAndIdx &InputReg)"
  },
  {
    "label": "getInsertSubregInputs()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "getInsertSubregInputs(const MachineInstr &MI, unsigned DefIdx, RegSubRegPair &BaseReg, RegSubRegPairAndIdx &InsertedReg)"
  },
  {
    "label": "produceSameValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "produceSameValue(const MachineInstr *MI0, const MachineInstr *MI1, const MachineRegisterInfo *MRI = nullptr)"
  },
  {
    "label": "AnalyzeBranch()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AnalyzeBranch(MachineBasicBlock &MBB, MachineBasicBlock *&TBB, MachineBasicBlock *&FBB, SmallVectorImpl<MachineOperand> &Cond, bool AllowModify = false)"
  },
  {
    "label": "AnalyzeBranchPredicate()",
    "kind": "Method",
    "detail": "Function (} } ; bool)",
    "insertText": "AnalyzeBranchPredicate(MachineBasicBlock &MBB, MachineBranchPredicate &MBP, bool AllowModify = false)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Target didn't implement TargetInstrInfo::RemoveBranch!\")"
  },
  {
    "label": "InsertBranch()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "InsertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB, MachineBasicBlock *FBB, ArrayRef<MachineOperand> Cond, DebugLoc DL)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Target didn't implement TargetInstrInfo::InsertBranch!\")"
  },
  {
    "label": "ReplaceTailWithBranchTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ReplaceTailWithBranchTo(MachineBasicBlock::iterator Tail, MachineBasicBlock *NewDest)"
  },
  {
    "label": "getUnconditionalBranch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getUnconditionalBranch(MCInst &MI, const MCSymbolRefExpr *BranchTarget)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Target didn't implement \" \"TargetInstrInfo::getUnconditionalBranch!\")"
  },
  {
    "label": "getTrap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "getTrap(MCInst &MI)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Target didn't implement TargetInstrInfo::getTrap!\")"
  },
  {
    "label": "getJumpInstrTableEntryBound()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getJumpInstrTableEntryBound()"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Target didn't implement TargetInstrInfo::insertSelect!\")"
  },
  {
    "label": "analyzeSelect()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "analyzeSelect(const MachineInstr *MI, SmallVectorImpl<MachineOperand> &Cond, unsigned &TrueOp, unsigned &FalseOp, bool &Optimizable)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(MI && MI->getDesc().isSelect() && \"MI must be a select instruction\")"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Target must implement TargetInstrInfo::optimizeSelect!\")"
  },
  {
    "label": "copyPhysReg()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "copyPhysReg(MachineBasicBlock &MBB, MachineBasicBlock::iterator MI, DebugLoc DL, unsigned DestReg, unsigned SrcReg, bool KillSrc)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Target didn't implement TargetInstrInfo::copyPhysReg!\")"
  },
  {
    "label": "storeRegToStackSlot()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "storeRegToStackSlot(MachineBasicBlock &MBB, MachineBasicBlock::iterator MI, unsigned SrcReg, bool isKill, int FrameIndex, const TargetRegisterClass *RC, const TargetRegisterInfo *TRI)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Target didn't implement \" \"TargetInstrInfo::storeRegToStackSlot!\")"
  },
  {
    "label": "loadRegFromStackSlot()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "loadRegFromStackSlot(MachineBasicBlock &MBB, MachineBasicBlock::iterator MI, unsigned DestReg, int FrameIndex, const TargetRegisterClass *RC, const TargetRegisterInfo *TRI)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Target didn't implement \" \"TargetInstrInfo::loadRegFromStackSlot!\")"
  },
  {
    "label": "expandPostRAPseudo()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "expandPostRAPseudo(MachineBasicBlock::iterator MI)"
  },
  {
    "label": "foldMemoryOperand()",
    "kind": "Method",
    "detail": "Function (MachineInstr*)",
    "insertText": "foldMemoryOperand(MachineBasicBlock::iterator MI, ArrayRef<unsigned> Ops, MachineInstr *LoadMI)"
  },
  {
    "label": "getMachineCombinerPatterns()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "getMachineCombinerPatterns(MachineInstr &Root, SmallVectorImpl<MachineCombinerPattern::MC_PATTERN> &Pattern)"
  },
  {
    "label": "unfoldMemoryOperand()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "unfoldMemoryOperand(MachineFunction &MF, MachineInstr *MI, unsigned Reg, bool UnfoldLoad, bool UnfoldStore, SmallVectorImpl<MachineInstr*> &NewMIs)"
  },
  {
    "label": "getNoopForMachoTarget()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getNoopForMachoTarget(MCInst &NopInst)"
  },
  {
    "label": "isPredicated()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isPredicated(const MachineInstr *MI)"
  },
  {
    "label": "PredicateInstruction()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PredicateInstruction(MachineInstr *MI, ArrayRef<MachineOperand> Pred)"
  },
  {
    "label": "SubsumesPredicate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SubsumesPredicate(ArrayRef<MachineOperand> Pred1, ArrayRef<MachineOperand> Pred2)"
  },
  {
    "label": "isSafeToMoveRegClassDefs()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isSafeToMoveRegClassDefs(const TargetRegisterClass *RC)"
  },
  {
    "label": "getInlineAsmLength()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getInlineAsmLength(const char *Str, const MCAsmInfo &MAI)"
  },
  {
    "label": "CreateTargetHazardRecognizer()",
    "kind": "Method",
    "detail": "Function (ScheduleHazardRecognizer*)",
    "insertText": "CreateTargetHazardRecognizer(const TargetSubtargetInfo *STI, const ScheduleDAG *DAG)"
  },
  {
    "label": "CreateTargetMIHazardRecognizer()",
    "kind": "Method",
    "detail": "Function (ScheduleHazardRecognizer*)",
    "insertText": "CreateTargetMIHazardRecognizer(const InstrItineraryData*, const ScheduleDAG *DAG)"
  },
  {
    "label": "CreateTargetPostRAHazardRecognizer()",
    "kind": "Method",
    "detail": "Function (ScheduleHazardRecognizer*)",
    "insertText": "CreateTargetPostRAHazardRecognizer(const InstrItineraryData*, const ScheduleDAG *DAG)"
  },
  {
    "label": "usePreRAHazardRecognizer()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "usePreRAHazardRecognizer()"
  },
  {
    "label": "analyzeCompare()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "analyzeCompare(const MachineInstr *MI, unsigned &SrcReg, unsigned &SrcReg2, int &Mask, int &Value)"
  },
  {
    "label": "isZeroCost()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isZeroCost(unsigned Opcode)"
  },
  {
    "label": "getOperandLatency()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "getOperandLatency(const InstrItineraryData *ItinData, const MachineInstr *DefMI, unsigned DefIdx, const MachineInstr *UseMI, unsigned UseIdx)"
  },
  {
    "label": "computeOperandLatency()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "computeOperandLatency(const InstrItineraryData *ItinData, const MachineInstr *DefMI, unsigned DefIdx, const MachineInstr *UseMI, unsigned UseIdx)"
  },
  {
    "label": "getInstrLatency()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getInstrLatency(const InstrItineraryData *ItinData, const MachineInstr *MI, unsigned *PredCost = nullptr)"
  },
  {
    "label": "getPredicationCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getPredicationCost(const MachineInstr *MI)"
  },
  {
    "label": "getInstrLatency()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "getInstrLatency(const InstrItineraryData *ItinData, SDNode *Node)"
  },
  {
    "label": "defaultDefLatency()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "defaultDefLatency(const MCSchedModel &SchedModel, const MachineInstr *DefMI)"
  },
  {
    "label": "computeDefOperandLatency()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "computeDefOperandLatency(const InstrItineraryData *ItinData, const MachineInstr *DefMI)"
  },
  {
    "label": "isHighLatencyDef()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isHighLatencyDef(int opc)"
  },
  {
    "label": "verifyInstruction()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "verifyInstruction(const MachineInstr *MI, StringRef &ErrInfo)"
  },
  {
    "label": "setExecutionDomain()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setExecutionDomain(MachineInstr *MI, unsigned Domain)"
  },
  {
    "label": "getPartialRegUpdateClearance()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getPartialRegUpdateClearance(const MachineInstr *MI, unsigned OpNum, const TargetRegisterInfo *TRI)"
  },
  {
    "label": "CreateTargetScheduleState()",
    "kind": "Method",
    "detail": "Function (} DFAPacketizer*)",
    "insertText": "CreateTargetScheduleState(const TargetSubtargetInfo &)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(MIa && (MIa->mayLoad() || MIa->mayStore()) && \"MIa must load from or modify a memory location\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(MIb && (MIb->mayLoad() || MIb->mayStore()) && \"MIb must load from or modify a memory location\")"
  }
]