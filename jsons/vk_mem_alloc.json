[
  {
    "label": "VmaAllocatorCreateFlagBits",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "VmaAllocatorCreateFlagBits"
  },
  {
    "label": "VmaMemoryUsage",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "VmaMemoryUsage"
  },
  {
    "label": "VmaAllocationCreateFlagBits",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "VmaAllocationCreateFlagBits"
  },
  {
    "label": "VmaPoolCreateFlagBits",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "VmaPoolCreateFlagBits"
  },
  {
    "label": "VmaDefragmentationFlagBits",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "VmaDefragmentationFlagBits"
  },
  {
    "label": "VmaDefragmentationMoveOperation",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "VmaDefragmentationMoveOperation"
  },
  {
    "label": "VmaVirtualBlockCreateFlagBits",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "VmaVirtualBlockCreateFlagBits"
  },
  {
    "label": "VmaVirtualAllocationCreateFlagBits",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "VmaVirtualAllocationCreateFlagBits"
  },
  {
    "label": "VmaDeviceMemoryCallbacks",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaDeviceMemoryCallbacks"
  },
  {
    "label": "VmaVulkanFunctions",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaVulkanFunctions"
  },
  {
    "label": "VmaAllocatorCreateInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaAllocatorCreateInfo"
  },
  {
    "label": "VmaAllocatorInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaAllocatorInfo"
  },
  {
    "label": "VmaStatistics",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaStatistics"
  },
  {
    "label": "VmaDetailedStatistics",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaDetailedStatistics"
  },
  {
    "label": "VmaTotalStatistics",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaTotalStatistics"
  },
  {
    "label": "VmaBudget",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaBudget"
  },
  {
    "label": "VmaAllocationCreateInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaAllocationCreateInfo"
  },
  {
    "label": "VmaPoolCreateInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaPoolCreateInfo"
  },
  {
    "label": "VmaAllocationInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaAllocationInfo"
  },
  {
    "label": "VmaAllocationInfo2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaAllocationInfo2"
  },
  {
    "label": "VmaDefragmentationInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaDefragmentationInfo"
  },
  {
    "label": "VmaDefragmentationMove",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaDefragmentationMove"
  },
  {
    "label": "VmaDefragmentationPassMoveInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaDefragmentationPassMoveInfo"
  },
  {
    "label": "VmaDefragmentationStats",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaDefragmentationStats"
  },
  {
    "label": "VmaVirtualBlockCreateInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaVirtualBlockCreateInfo"
  },
  {
    "label": "VmaVirtualAllocationCreateInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaVirtualAllocationCreateInfo"
  },
  {
    "label": "VmaVirtualAllocationInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaVirtualAllocationInfo"
  },
  {
    "label": "VmaMutex",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaMutex"
  },
  {
    "label": "VmaRWMutex",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaRWMutex"
  },
  {
    "label": "VmaSuballocationType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "VmaSuballocationType"
  },
  {
    "label": "VMA_CACHE_OPERATION",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "VMA_CACHE_OPERATION"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "VmaMutexLock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaMutexLock"
  },
  {
    "label": "VmaMutexLockRead",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaMutexLockRead"
  },
  {
    "label": "VmaMutexLockWrite",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaMutexLockWrite"
  },
  {
    "label": "AtomicTransactionalIncrement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AtomicTransactionalIncrement"
  },
  {
    "label": "VmaStlAllocator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaStlAllocator"
  },
  {
    "label": "VmaVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaVector"
  },
  {
    "label": "VmaSmallVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaSmallVector"
  },
  {
    "label": "VmaPoolAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaPoolAllocator"
  },
  {
    "label": "VmaListItem",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaListItem"
  },
  {
    "label": "VmaRawList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaRawList"
  },
  {
    "label": "VmaList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaList"
  },
  {
    "label": "VmaIntrusiveLinkedList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaIntrusiveLinkedList"
  },
  {
    "label": "VmaStringBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaStringBuilder"
  },
  {
    "label": "VmaJsonWriter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaJsonWriter"
  },
  {
    "label": "VmaDeviceMemoryBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaDeviceMemoryBlock"
  },
  {
    "label": "VmaDedicatedAllocationListItemTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaDedicatedAllocationListItemTraits"
  },
  {
    "label": "VmaDedicatedAllocationList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaDedicatedAllocationList"
  },
  {
    "label": "VmaSuballocation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaSuballocation"
  },
  {
    "label": "VmaSuballocationOffsetLess",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaSuballocationOffsetLess"
  },
  {
    "label": "VmaSuballocationOffsetGreater",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaSuballocationOffsetGreater"
  },
  {
    "label": "VmaSuballocationItemSizeLess",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaSuballocationItemSizeLess"
  },
  {
    "label": "VmaAllocationRequest",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaAllocationRequest"
  },
  {
    "label": "VmaBlockMetadata",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaBlockMetadata"
  },
  {
    "label": "VmaBlockMetadata_Linear",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaBlockMetadata_Linear"
  },
  {
    "label": "VmaBlockMetadata_TLSF",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaBlockMetadata_TLSF"
  },
  {
    "label": "VmaBlockVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaBlockVector"
  },
  {
    "label": "VmaPoolListItemTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaPoolListItemTraits"
  },
  {
    "label": "VmaCurrentBudgetData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaCurrentBudgetData"
  },
  {
    "label": "VmaAllocationObjectAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaAllocationObjectAllocator"
  },
  {
    "label": "VmaBufferImageUsage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaBufferImageUsage"
  },
  {
    "label": "ItemBlock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ItemBlock"
  },
  {
    "label": "reverse_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "reverse_iterator"
  },
  {
    "label": "const_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "const_iterator"
  },
  {
    "label": "const_reverse_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "const_reverse_iterator"
  },
  {
    "label": "iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "iterator"
  },
  {
    "label": "COLLECTION_TYPE",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "COLLECTION_TYPE"
  },
  {
    "label": "StackItem",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StackItem"
  },
  {
    "label": "VmaMappingHysteresis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaMappingHysteresis"
  },
  {
    "label": "VmaAllocation_T",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaAllocation_T"
  },
  {
    "label": "FLAGS",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "FLAGS"
  },
  {
    "label": "ALLOCATION_TYPE",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ALLOCATION_TYPE"
  },
  {
    "label": "BlockAllocation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BlockAllocation"
  },
  {
    "label": "DedicatedAllocation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DedicatedAllocation"
  },
  {
    "label": "VmaBlockBufferImageGranularity",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VmaBlockBufferImageGranularity"
  },
  {
    "label": "ValidationContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ValidationContext"
  },
  {
    "label": "RegionInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RegionInfo"
  },
  {
    "label": "SECOND_VECTOR_MODE",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "SECOND_VECTOR_MODE"
  },
  {
    "label": "Block",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Block"
  },
  {
    "label": "VmaDefragmentationContext_T",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaDefragmentationContext_T"
  },
  {
    "label": "FragmentedBlock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FragmentedBlock"
  },
  {
    "label": "StateBalanced",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StateBalanced"
  },
  {
    "label": "StateExtensive",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StateExtensive"
  },
  {
    "label": "MoveAllocationData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MoveAllocationData"
  },
  {
    "label": "VmaPool_T",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaPool_T"
  },
  {
    "label": "VmaVirtualBlock_T",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaVirtualBlock_T"
  },
  {
    "label": "VmaAllocator_T",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VmaAllocator_T"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef AMD_VULKAN_MEMORY_ALLOCATOR_H # define AMD_VULKAN_MEMORY_ALLOCATOR_H # ifdef __cplusplus \" C \" { # endif # include<vulkan / vulkan . h> # if !)",
    "insertText": "defined(VMA_VULKAN_VERSION) #if defined(VK_VERSION_1_3) #define VMA_VULKAN_VERSION 1003000 #elif defined(VK_VERSION_1_2) #define VMA_VULKAN_VERSION 1002000 #elif defined(VK_VERSION_1_1) #define VMA_VULKAN_VERSION 1001000 #else #define VMA_VULKAN_VERSION 1000000 #endif #endif #if defined(__ANDROID__) && defined(VK_NO_PROTOTYPES)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr ; PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties ; PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties ; PFN_vkAllocateMemory vkAllocateMemory ; PFN_vkFreeMemory vkFreeMemory ; PFN_vkMapMemory vkMapMemory ; PFN_vkUnmapMemory vkUnmapMemory ; PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges ; PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges ; PFN_vkBindBufferMemory vkBindBufferMemory ; PFN_vkBindImageMemory vkBindImageMemory ; PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements ; PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements ; PFN_vkCreateBuffer vkCreateBuffer ; PFN_vkDestroyBuffer vkDestroyBuffer ; PFN_vkCreateImage vkCreateImage ; PFN_vkDestroyImage vkDestroyImage ; PFN_vkCmdCopyBuffer vkCmdCopyBuffer ; # if VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0 PFN_vkGetBufferMemoryRequirements2 vkGetBufferMemoryRequirements2 ; PFN_vkGetImageMemoryRequirements2 vkGetImageMemoryRequirements2 ; PFN_vkBindBufferMemory2 vkBindBufferMemory2 ; PFN_vkBindImageMemory2 vkBindImageMemory2 ; PFN_vkGetPhysicalDeviceMemoryProperties2 vkGetPhysicalDeviceMemoryProperties2 ; # endif # endif # if !)",
    "insertText": "defined(VMA_DEDICATED_ALLOCATION) #if VK_KHR_get_memory_requirements2 && VK_KHR_dedicated_allocation #define VMA_DEDICATED_ALLOCATION 1 #else #define VMA_DEDICATED_ALLOCATION 0 #endif #endif #if !defined(VMA_BIND_MEMORY2) #if VK_KHR_bind_memory2 #define VMA_BIND_MEMORY2 1 #else #define VMA_BIND_MEMORY2 0 #endif #endif #if !defined(VMA_MEMORY_BUDGET) #if VK_EXT_memory_budget && (VK_KHR_get_physical_device_properties2 || VMA_VULKAN_VERSION >= 1001000) #define VMA_MEMORY_BUDGET 1 #else #define VMA_MEMORY_BUDGET 0 #endif #endif #if !defined(VMA_BUFFER_DEVICE_ADDRESS) #if VK_KHR_buffer_device_address || VMA_VULKAN_VERSION >= 1002000 #define VMA_BUFFER_DEVICE_ADDRESS 1 #else #define VMA_BUFFER_DEVICE_ADDRESS 0 #endif #endif #if !defined(VMA_MEMORY_PRIORITY) #if VK_EXT_memory_priority #define VMA_MEMORY_PRIORITY 1 #else #define VMA_MEMORY_PRIORITY 0 #endif #endif #if !defined(VMA_KHR_MAINTENANCE4) #if VK_KHR_maintenance4 #define VMA_KHR_MAINTENANCE4 1 #else #define VMA_KHR_MAINTENANCE4 0 #endif #endif #if !defined(VMA_KHR_MAINTENANCE5) #if VK_KHR_maintenance5 #define VMA_KHR_MAINTENANCE5 1 #else #define VMA_KHR_MAINTENANCE5 0 #endif #endif #if !defined(VMA_EXTERNAL_MEMORY) #if VK_KHR_external_memory #define VMA_EXTERNAL_MEMORY 1 #else #define VMA_EXTERNAL_MEMORY 0 #endif #endif #ifndef VMA_CALL_PRE #define VMA_CALL_PRE #endif #ifndef VMA_CALL_POST #define VMA_CALL_POST #endif #ifndef VMA_EXTENDS_VK_STRUCT #define VMA_EXTENDS_VK_STRUCT(vkStruct) #endif #ifndef VMA_LEN_IF_NOT_NULL #define VMA_LEN_IF_NOT_NULL(len) #endif #ifndef VMA_NULLABLE #ifdef __clang__ #define VMA_NULLABLE _Nullable #else #define VMA_NULLABLE #endif #endif #ifndef VMA_NOT_NULL #ifdef __clang__ #define VMA_NOT_NULL _Nonnull #else #define VMA_NOT_NULL #endif #endif #ifndef VMA_NOT_NULL_NON_DISPATCHABLE #if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__) #define VMA_NOT_NULL_NON_DISPATCHABLE VMA_NOT_NULL #else #define VMA_NOT_NULL_NON_DISPATCHABLE #endif #endif #ifndef VMA_NULLABLE_NON_DISPATCHABLE #if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)"
  },
  {
    "label": "VK_DEFINE_HANDLE()",
    "kind": "Method",
    "detail": "Function (VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0 x00000001,VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT = 0 x00000002,VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT = 0 x00000004,VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT = 0 x00000008,VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT = 0 x00000010,VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT = 0 x00000020,VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT = 0 x00000040,VMA_ALLOCATOR_CREATE_KHR_MAINTENANCE4_BIT = 0 x00000080,VMA_ALLOCATOR_CREATE_KHR_MAINTENANCE5_BIT = 0 x00000100,VMA_ALLOCATOR_CREATE_FLAG_BITS_MAX_ENUM = 0 x7FFFFFFF } VmaAllocatorCreateFlagBits ; typedef VkFlags VmaAllocatorCreateFlags ; typedef enum VmaMemoryUsage { VMA_MEMORY_USAGE_UNKNOWN = 0,VMA_MEMORY_USAGE_GPU_ONLY = 1,VMA_MEMORY_USAGE_CPU_ONLY = 2,VMA_MEMORY_USAGE_CPU_TO_GPU = 3,VMA_MEMORY_USAGE_GPU_TO_CPU = 4,VMA_MEMORY_USAGE_CPU_COPY = 5,VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED = 6,VMA_MEMORY_USAGE_AUTO = 7,VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE = 8,VMA_MEMORY_USAGE_AUTO_PREFER_HOST = 9,VMA_MEMORY_USAGE_MAX_ENUM = 0 x7FFFFFFF } VmaMemoryUsage ; typedef enum VmaAllocationCreateFlagBits { VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT = 0 x00000001,VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT = 0 x00000002,VMA_ALLOCATION_CREATE_MAPPED_BIT = 0 x00000004,VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT = 0 x00000020,VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT = 0 x00000040,VMA_ALLOCATION_CREATE_DONT_BIND_BIT = 0 x00000080,VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT = 0 x00000100,VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT = 0 x00000200,VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT = 0 x00000400,VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT = 0 x00000800,VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT = 0 x00001000,VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT = 0 x00010000,VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT = 0 x00020000,VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT = 0 x00040000,VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT = VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT,VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT = VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT,VMA_ALLOCATION_CREATE_STRATEGY_MASK = VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT | VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT | VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT,VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM = 0 x7FFFFFFF } VmaAllocationCreateFlagBits ; typedef VkFlags VmaAllocationCreateFlags ; typedef enum VmaPoolCreateFlagBits { VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT = 0 x00000002,VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT = 0 x00000004,VMA_POOL_CREATE_ALGORITHM_MASK = VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT,VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0 x7FFFFFFF } VmaPoolCreateFlagBits ; typedef VkFlags VmaPoolCreateFlags ; typedef enum VmaDefragmentationFlagBits { VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT = 0 x1,VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT = 0 x2,VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT = 0 x4,VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT = 0 x8,VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK = VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT | VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT | VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT | VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT,VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM = 0 x7FFFFFFF } VmaDefragmentationFlagBits ; typedef VkFlags VmaDefragmentationFlags ; typedef enum VmaDefragmentationMoveOperation { VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY = 0,VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE = 1,VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY = 2,} VmaDefragmentationMoveOperation ; typedef enum VmaVirtualBlockCreateFlagBits { VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT = 0 x00000001,VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK = VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT,VMA_VIRTUAL_BLOCK_CREATE_FLAG_BITS_MAX_ENUM = 0 x7FFFFFFF } VmaVirtualBlockCreateFlagBits ; typedef VkFlags VmaVirtualBlockCreateFlags ; typedef enum VmaVirtualAllocationCreateFlagBits { VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT = VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT,VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT = VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT,VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT = VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT,VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT = VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT,VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK = VMA_ALLOCATION_CREATE_STRATEGY_MASK,VMA_VIRTUAL_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM = 0 x7FFFFFFF } VmaVirtualAllocationCreateFlagBits ; typedef VkFlags VmaVirtualAllocationCreateFlags ; # endif # ifndef _VMA_DATA_TYPES_DECLARATIONS)",
    "insertText": "VK_DEFINE_HANDLE(VmaAllocator) VK_DEFINE_HANDLE(VmaPool) VK_DEFINE_HANDLE(VmaAllocation) VK_DEFINE_HANDLE(VmaDefragmentationContext) VK_DEFINE_NON_DISPATCHABLE_HANDLE(VmaVirtualAllocation) VK_DEFINE_HANDLE(VmaVirtualBlock) typedef void (VKAPI_PTR* PFN_vmaAllocateDeviceMemoryFunction)( VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryType, VkDeviceMemory VMA_NOT_NULL_NON_DISPATCHABLE memory, VkDeviceSize size, void* VMA_NULLABLE pUserData)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(VKAPI_PTR* PFN_vmaFreeDeviceMemoryFunction)( VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryType, VkDeviceMemory VMA_NOT_NULL_NON_DISPATCHABLE memory, VkDeviceSize size, void* VMA_NULLABLE pUserData)"
  },
  {
    "label": "VMA_LEN_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (typedef struct VmaDeviceMemoryCallbacks { PFN_vmaAllocateDeviceMemoryFunction VMA_NULLABLE pfnAllocate ; PFN_vmaFreeDeviceMemoryFunction VMA_NULLABLE pfnFree ; void* VMA_NULLABLE pUserData ; } VmaDeviceMemoryCallbacks ; typedef struct VmaVulkanFunctions { PFN_vkGetInstanceProcAddr VMA_NULLABLE vkGetInstanceProcAddr ; PFN_vkGetDeviceProcAddr VMA_NULLABLE vkGetDeviceProcAddr ; PFN_vkGetPhysicalDeviceProperties VMA_NULLABLE vkGetPhysicalDeviceProperties ; PFN_vkGetPhysicalDeviceMemoryProperties VMA_NULLABLE vkGetPhysicalDeviceMemoryProperties ; PFN_vkAllocateMemory VMA_NULLABLE vkAllocateMemory ; PFN_vkFreeMemory VMA_NULLABLE vkFreeMemory ; PFN_vkMapMemory VMA_NULLABLE vkMapMemory ; PFN_vkUnmapMemory VMA_NULLABLE vkUnmapMemory ; PFN_vkFlushMappedMemoryRanges VMA_NULLABLE vkFlushMappedMemoryRanges ; PFN_vkInvalidateMappedMemoryRanges VMA_NULLABLE vkInvalidateMappedMemoryRanges ; PFN_vkBindBufferMemory VMA_NULLABLE vkBindBufferMemory ; PFN_vkBindImageMemory VMA_NULLABLE vkBindImageMemory ; PFN_vkGetBufferMemoryRequirements VMA_NULLABLE vkGetBufferMemoryRequirements ; PFN_vkGetImageMemoryRequirements VMA_NULLABLE vkGetImageMemoryRequirements ; PFN_vkCreateBuffer VMA_NULLABLE vkCreateBuffer ; PFN_vkDestroyBuffer VMA_NULLABLE vkDestroyBuffer ; PFN_vkCreateImage VMA_NULLABLE vkCreateImage ; PFN_vkDestroyImage VMA_NULLABLE vkDestroyImage ; PFN_vkCmdCopyBuffer VMA_NULLABLE vkCmdCopyBuffer ; # if VMA_DEDICATED_ALLOCATION | | VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0 PFN_vkGetBufferMemoryRequirements2KHR VMA_NULLABLE vkGetBufferMemoryRequirements2KHR ; PFN_vkGetImageMemoryRequirements2KHR VMA_NULLABLE vkGetImageMemoryRequirements2KHR ; # endif # if VMA_BIND_MEMORY2 | | VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0 PFN_vkBindBufferMemory2KHR VMA_NULLABLE vkBindBufferMemory2KHR ; PFN_vkBindImageMemory2KHR VMA_NULLABLE vkBindImageMemory2KHR ; # endif # if VMA_MEMORY_BUDGET | | VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0 PFN_vkGetPhysicalDeviceMemoryProperties2KHR VMA_NULLABLE vkGetPhysicalDeviceMemoryProperties2KHR ; # endif # if VMA_KHR_MAINTENANCE4 | | VMA_VULKAN_VERSION> = 1 0 0 3 0 0 0 PFN_vkGetDeviceBufferMemoryRequirementsKHR VMA_NULLABLE vkGetDeviceBufferMemoryRequirements ; PFN_vkGetDeviceImageMemoryRequirementsKHR VMA_NULLABLE vkGetDeviceImageMemoryRequirements ; # endif } VmaVulkanFunctions ; typedef struct VmaAllocatorCreateInfo { VmaAllocatorCreateFlags flags ; VkPhysicalDevice VMA_NOT_NULL physicalDevice ; VkDevice VMA_NOT_NULL device ; VkDeviceSize preferredLargeHeapBlockSize ; const VkAllocationCallbacks* VMA_NULLABLE pAllocationCallbacks ; const VmaDeviceMemoryCallbacks* VMA_NULLABLE pDeviceMemoryCallbacks ; const VkDeviceSize* VMA_NULLABLE)",
    "insertText": "VMA_LEN_IF_NOT_NULL(\"VkPhysicalDeviceMemoryProperties::memoryHeapCount\")"
  },
  {
    "label": "VMA_LEN_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (const VmaVulkanFunctions* VMA_NULLABLE pVulkanFunctions ; VkInstance VMA_NOT_NULL instance ; uint32_t vulkanApiVersion ; # if VMA_EXTERNAL_MEMORY const VkExternalMemoryHandleTypeFlagsKHR* VMA_NULLABLE)",
    "insertText": "VMA_LEN_IF_NOT_NULL(\"VkPhysicalDeviceMemoryProperties::memoryTypeCount\")"
  },
  {
    "label": "VMA_EXTENDS_VK_STRUCT()",
    "kind": "Method",
    "detail": "Function (# endif } VmaAllocatorCreateInfo ; typedef struct VmaAllocatorInfo { VkInstance VMA_NOT_NULL instance ; VkPhysicalDevice VMA_NOT_NULL physicalDevice ; VkDevice VMA_NOT_NULL device ; } VmaAllocatorInfo ; typedef struct VmaStatistics { uint32_t blockCount ; uint32_t allocationCount ; VkDeviceSize blockBytes ; VkDeviceSize allocationBytes ; } VmaStatistics ; typedef struct VmaDetailedStatistics { VmaStatistics statistics ; uint32_t unusedRangeCount ; VkDeviceSize allocationSizeMin ; VkDeviceSize allocationSizeMax ; VkDeviceSize unusedRangeSizeMin ; VkDeviceSize unusedRangeSizeMax ; } VmaDetailedStatistics ; typedef struct VmaTotalStatistics { VmaDetailedStatistics memoryType [ VK_MAX_MEMORY_TYPES ] ; VmaDetailedStatistics memoryHeap [ VK_MAX_MEMORY_HEAPS ] ; VmaDetailedStatistics total ; } VmaTotalStatistics ; typedef struct VmaBudget { VmaStatistics statistics ; VkDeviceSize usage ; VkDeviceSize budget ; } VmaBudget ; typedef struct VmaAllocationCreateInfo { VmaAllocationCreateFlags flags ; VmaMemoryUsage usage ; VkMemoryPropertyFlags requiredFlags ; VkMemoryPropertyFlags preferredFlags ; uint32_t memoryTypeBits ; VmaPool VMA_NULLABLE pool ; void* VMA_NULLABLE pUserData ; float priority ; } VmaAllocationCreateInfo ; typedef struct VmaPoolCreateInfo { uint32_t memoryTypeIndex ; VmaPoolCreateFlags flags ; VkDeviceSize blockSize ; size_t minBlockCount ; size_t maxBlockCount ; float priority ; VkDeviceSize minAllocationAlignment ; void* VMA_NULLABLE)",
    "insertText": "VMA_EXTENDS_VK_STRUCT(VkMemoryAllocateInfo)"
  },
  {
    "label": "VkBool32()",
    "kind": "Method",
    "detail": "Function (} VmaPoolCreateInfo ; typedef struct VmaAllocationInfo { uint32_t memoryType ; VkDeviceMemory VMA_NULLABLE_NON_DISPATCHABLE deviceMemory ; VkDeviceSize offset ; VkDeviceSize size ; void* VMA_NULLABLE pMappedData ; void* VMA_NULLABLE pUserData ; const char* VMA_NULLABLE pName ; } VmaAllocationInfo ; typedef struct VmaAllocationInfo2 { VmaAllocationInfo allocationInfo ; VkDeviceSize blockSize ; VkBool32 dedicatedMemory ; } VmaAllocationInfo2 ; typedef)",
    "insertText": "VkBool32(VKAPI_PTR* PFN_vmaCheckDefragmentationBreakFunction)(void* VMA_NULLABLE pUserData)"
  },
  {
    "label": "VMA_LEN_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (typedef struct VmaDefragmentationInfo { VmaDefragmentationFlags flags ; VmaPool VMA_NULLABLE pool ; VkDeviceSize maxBytesPerPass ; uint32_t maxAllocationsPerPass ; PFN_vmaCheckDefragmentationBreakFunction VMA_NULLABLE pfnBreakCallback ; void* VMA_NULLABLE pBreakCallbackUserData ; } VmaDefragmentationInfo ; typedef struct VmaDefragmentationMove { VmaDefragmentationMoveOperation operation ; VmaAllocation VMA_NOT_NULL srcAllocation ; VmaAllocation VMA_NOT_NULL dstTmpAllocation ; } VmaDefragmentationMove ; typedef struct VmaDefragmentationPassMoveInfo { uint32_t moveCount ; VmaDefragmentationMove* VMA_NULLABLE)",
    "insertText": "VMA_LEN_IF_NOT_NULL(moveCount)"
  },
  {
    "label": "vmaCreateAllocator()",
    "kind": "Method",
    "detail": "Function (} VmaDefragmentationPassMoveInfo ; typedef struct VmaDefragmentationStats { VkDeviceSize bytesMoved ; VkDeviceSize bytesFreed ; uint32_t allocationsMoved ; uint32_t deviceMemoryBlocksFreed ; } VmaDefragmentationStats ; typedef struct VmaVirtualBlockCreateInfo { VkDeviceSize size ; VmaVirtualBlockCreateFlags flags ; const VkAllocationCallbacks* VMA_NULLABLE pAllocationCallbacks ; } VmaVirtualBlockCreateInfo ; typedef struct VmaVirtualAllocationCreateInfo { VkDeviceSize size ; VkDeviceSize alignment ; VmaVirtualAllocationCreateFlags flags ; void* VMA_NULLABLE pUserData ; } VmaVirtualAllocationCreateInfo ; typedef struct VmaVirtualAllocationInfo { VkDeviceSize offset ; VkDeviceSize size ; void* VMA_NULLABLE pUserData ; } VmaVirtualAllocationInfo ; # endif # ifndef _VMA_FUNCTION_HEADERS VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateAllocator(const VmaAllocatorCreateInfo* VMA_NOT_NULL pCreateInfo, VmaAllocator VMA_NULLABLE* VMA_NOT_NULL pAllocator)"
  },
  {
    "label": "vmaDestroyAllocator()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaDestroyAllocator(VmaAllocator VMA_NULLABLE allocator)"
  },
  {
    "label": "vmaGetAllocatorInfo()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetAllocatorInfo(VmaAllocator VMA_NOT_NULL allocator, VmaAllocatorInfo* VMA_NOT_NULL pAllocatorInfo)"
  },
  {
    "label": "vmaGetPhysicalDeviceProperties()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetPhysicalDeviceProperties(VmaAllocator VMA_NOT_NULL allocator, const VkPhysicalDeviceProperties* VMA_NULLABLE* VMA_NOT_NULL ppPhysicalDeviceProperties)"
  },
  {
    "label": "vmaGetMemoryProperties()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetMemoryProperties(VmaAllocator VMA_NOT_NULL allocator, const VkPhysicalDeviceMemoryProperties* VMA_NULLABLE* VMA_NOT_NULL ppPhysicalDeviceMemoryProperties)"
  },
  {
    "label": "vmaGetMemoryTypeProperties()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetMemoryTypeProperties(VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryTypeIndex, VkMemoryPropertyFlags* VMA_NOT_NULL pFlags)"
  },
  {
    "label": "vmaSetCurrentFrameIndex()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaSetCurrentFrameIndex(VmaAllocator VMA_NOT_NULL allocator, uint32_t frameIndex)"
  },
  {
    "label": "vmaCalculateStatistics()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaCalculateStatistics(VmaAllocator VMA_NOT_NULL allocator, VmaTotalStatistics* VMA_NOT_NULL pStats)"
  },
  {
    "label": "vmaGetHeapBudgets()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetHeapBudgets(VmaAllocator VMA_NOT_NULL allocator, VmaBudget* VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(\"VkPhysicalDeviceMemoryProperties::memoryHeapCount\") pBudgets)"
  },
  {
    "label": "vmaFindMemoryTypeIndex()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaFindMemoryTypeIndex(VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryTypeBits, const VmaAllocationCreateInfo* VMA_NOT_NULL pAllocationCreateInfo, uint32_t* VMA_NOT_NULL pMemoryTypeIndex)"
  },
  {
    "label": "vmaFindMemoryTypeIndexForBufferInfo()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaFindMemoryTypeIndexForBufferInfo(VmaAllocator VMA_NOT_NULL allocator, const VkBufferCreateInfo* VMA_NOT_NULL pBufferCreateInfo, const VmaAllocationCreateInfo* VMA_NOT_NULL pAllocationCreateInfo, uint32_t* VMA_NOT_NULL pMemoryTypeIndex)"
  },
  {
    "label": "vmaFindMemoryTypeIndexForImageInfo()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaFindMemoryTypeIndexForImageInfo(VmaAllocator VMA_NOT_NULL allocator, const VkImageCreateInfo* VMA_NOT_NULL pImageCreateInfo, const VmaAllocationCreateInfo* VMA_NOT_NULL pAllocationCreateInfo, uint32_t* VMA_NOT_NULL pMemoryTypeIndex)"
  },
  {
    "label": "vmaCreatePool()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreatePool(VmaAllocator VMA_NOT_NULL allocator, const VmaPoolCreateInfo* VMA_NOT_NULL pCreateInfo, VmaPool VMA_NULLABLE* VMA_NOT_NULL pPool)"
  },
  {
    "label": "vmaDestroyPool()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaDestroyPool(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NULLABLE pool)"
  },
  {
    "label": "vmaGetPoolStatistics()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetPoolStatistics(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool, VmaStatistics* VMA_NOT_NULL pPoolStats)"
  },
  {
    "label": "vmaCalculatePoolStatistics()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaCalculatePoolStatistics(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool, VmaDetailedStatistics* VMA_NOT_NULL pPoolStats)"
  },
  {
    "label": "vmaCheckPoolCorruption()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCheckPoolCorruption(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool)"
  },
  {
    "label": "vmaGetPoolName()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetPoolName(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool, const char* VMA_NULLABLE* VMA_NOT_NULL ppName)"
  },
  {
    "label": "vmaSetPoolName()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaSetPoolName(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool, const char* VMA_NULLABLE pName)"
  },
  {
    "label": "vmaAllocateMemory()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaAllocateMemory(VmaAllocator VMA_NOT_NULL allocator, const VkMemoryRequirements* VMA_NOT_NULL pVkMemoryRequirements, const VmaAllocationCreateInfo* VMA_NOT_NULL pCreateInfo, VmaAllocation VMA_NULLABLE* VMA_NOT_NULL pAllocation, VmaAllocationInfo* VMA_NULLABLE pAllocationInfo)"
  },
  {
    "label": "vmaAllocateMemoryPages()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaAllocateMemoryPages(VmaAllocator VMA_NOT_NULL allocator, const VkMemoryRequirements* VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pVkMemoryRequirements, const VmaAllocationCreateInfo* VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pCreateInfo, size_t allocationCount, VmaAllocation VMA_NULLABLE* VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations, VmaAllocationInfo* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) pAllocationInfo)"
  },
  {
    "label": "vmaAllocateMemoryForBuffer()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaAllocateMemoryForBuffer(VmaAllocator VMA_NOT_NULL allocator, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer, const VmaAllocationCreateInfo* VMA_NOT_NULL pCreateInfo, VmaAllocation VMA_NULLABLE* VMA_NOT_NULL pAllocation, VmaAllocationInfo* VMA_NULLABLE pAllocationInfo)"
  },
  {
    "label": "vmaAllocateMemoryForImage()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaAllocateMemoryForImage(VmaAllocator VMA_NOT_NULL allocator, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image, const VmaAllocationCreateInfo* VMA_NOT_NULL pCreateInfo, VmaAllocation VMA_NULLABLE* VMA_NOT_NULL pAllocation, VmaAllocationInfo* VMA_NULLABLE pAllocationInfo)"
  },
  {
    "label": "vmaFreeMemory()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaFreeMemory(VmaAllocator VMA_NOT_NULL allocator, const VmaAllocation VMA_NULLABLE allocation)"
  },
  {
    "label": "vmaFreeMemoryPages()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaFreeMemoryPages(VmaAllocator VMA_NOT_NULL allocator, size_t allocationCount, const VmaAllocation VMA_NULLABLE* VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations)"
  },
  {
    "label": "vmaGetAllocationInfo()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetAllocationInfo(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VmaAllocationInfo* VMA_NOT_NULL pAllocationInfo)"
  },
  {
    "label": "vmaGetAllocationInfo2()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetAllocationInfo2(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VmaAllocationInfo2* VMA_NOT_NULL pAllocationInfo)"
  },
  {
    "label": "vmaSetAllocationUserData()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaSetAllocationUserData(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, void* VMA_NULLABLE pUserData)"
  },
  {
    "label": "vmaSetAllocationName()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaSetAllocationName(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, const char* VMA_NULLABLE pName)"
  },
  {
    "label": "vmaGetAllocationMemoryProperties()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetAllocationMemoryProperties(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkMemoryPropertyFlags* VMA_NOT_NULL pFlags)"
  },
  {
    "label": "vmaMapMemory()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaMapMemory(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, void* VMA_NULLABLE* VMA_NOT_NULL ppData)"
  },
  {
    "label": "vmaUnmapMemory()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaUnmapMemory(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation)"
  },
  {
    "label": "vmaFlushAllocation()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaFlushAllocation(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize offset, VkDeviceSize size)"
  },
  {
    "label": "vmaInvalidateAllocation()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaInvalidateAllocation(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize offset, VkDeviceSize size)"
  },
  {
    "label": "vmaFlushAllocations()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaFlushAllocations(VmaAllocator VMA_NOT_NULL allocator, uint32_t allocationCount, const VmaAllocation VMA_NOT_NULL* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) allocations, const VkDeviceSize* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) offsets, const VkDeviceSize* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) sizes)"
  },
  {
    "label": "vmaInvalidateAllocations()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaInvalidateAllocations(VmaAllocator VMA_NOT_NULL allocator, uint32_t allocationCount, const VmaAllocation VMA_NOT_NULL* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) allocations, const VkDeviceSize* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) offsets, const VkDeviceSize* VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) sizes)"
  },
  {
    "label": "vmaCopyMemoryToAllocation()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCopyMemoryToAllocation(VmaAllocator VMA_NOT_NULL allocator, const void* VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(size) pSrcHostPointer, VmaAllocation VMA_NOT_NULL dstAllocation, VkDeviceSize dstAllocationLocalOffset, VkDeviceSize size)"
  },
  {
    "label": "vmaCopyAllocationToMemory()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCopyAllocationToMemory(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL srcAllocation, VkDeviceSize srcAllocationLocalOffset, void* VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(size) pDstHostPointer, VkDeviceSize size)"
  },
  {
    "label": "vmaCheckCorruption()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCheckCorruption(VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryTypeBits)"
  },
  {
    "label": "vmaBeginDefragmentation()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaBeginDefragmentation(VmaAllocator VMA_NOT_NULL allocator, const VmaDefragmentationInfo* VMA_NOT_NULL pInfo, VmaDefragmentationContext VMA_NULLABLE* VMA_NOT_NULL pContext)"
  },
  {
    "label": "vmaEndDefragmentation()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaEndDefragmentation(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationStats* VMA_NULLABLE pStats)"
  },
  {
    "label": "vmaBeginDefragmentationPass()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaBeginDefragmentationPass(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationPassMoveInfo* VMA_NOT_NULL pPassInfo)"
  },
  {
    "label": "vmaEndDefragmentationPass()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaEndDefragmentationPass(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationPassMoveInfo* VMA_NOT_NULL pPassInfo)"
  },
  {
    "label": "vmaBindBufferMemory()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaBindBufferMemory(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer)"
  },
  {
    "label": "vmaBindBufferMemory2()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaBindBufferMemory2(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer, const void* VMA_NULLABLE VMA_EXTENDS_VK_STRUCT(VkBindBufferMemoryInfoKHR) pNext)"
  },
  {
    "label": "vmaBindImageMemory()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaBindImageMemory(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image)"
  },
  {
    "label": "vmaBindImageMemory2()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaBindImageMemory2(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image, const void* VMA_NULLABLE VMA_EXTENDS_VK_STRUCT(VkBindImageMemoryInfoKHR) pNext)"
  },
  {
    "label": "vmaCreateBuffer()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateBuffer(VmaAllocator VMA_NOT_NULL allocator, const VkBufferCreateInfo* VMA_NOT_NULL pBufferCreateInfo, const VmaAllocationCreateInfo* VMA_NOT_NULL pAllocationCreateInfo, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE* VMA_NOT_NULL pBuffer, VmaAllocation VMA_NULLABLE* VMA_NOT_NULL pAllocation, VmaAllocationInfo* VMA_NULLABLE pAllocationInfo)"
  },
  {
    "label": "vmaCreateBufferWithAlignment()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateBufferWithAlignment(VmaAllocator VMA_NOT_NULL allocator, const VkBufferCreateInfo* VMA_NOT_NULL pBufferCreateInfo, const VmaAllocationCreateInfo* VMA_NOT_NULL pAllocationCreateInfo, VkDeviceSize minAlignment, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE* VMA_NOT_NULL pBuffer, VmaAllocation VMA_NULLABLE* VMA_NOT_NULL pAllocation, VmaAllocationInfo* VMA_NULLABLE pAllocationInfo)"
  },
  {
    "label": "vmaCreateAliasingBuffer()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateAliasingBuffer(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, const VkBufferCreateInfo* VMA_NOT_NULL pBufferCreateInfo, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE* VMA_NOT_NULL pBuffer)"
  },
  {
    "label": "vmaCreateAliasingBuffer2()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateAliasingBuffer2(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, const VkBufferCreateInfo* VMA_NOT_NULL pBufferCreateInfo, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE* VMA_NOT_NULL pBuffer)"
  },
  {
    "label": "vmaDestroyBuffer()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaDestroyBuffer(VmaAllocator VMA_NOT_NULL allocator, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE buffer, VmaAllocation VMA_NULLABLE allocation)"
  },
  {
    "label": "vmaCreateImage()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateImage(VmaAllocator VMA_NOT_NULL allocator, const VkImageCreateInfo* VMA_NOT_NULL pImageCreateInfo, const VmaAllocationCreateInfo* VMA_NOT_NULL pAllocationCreateInfo, VkImage VMA_NULLABLE_NON_DISPATCHABLE* VMA_NOT_NULL pImage, VmaAllocation VMA_NULLABLE* VMA_NOT_NULL pAllocation, VmaAllocationInfo* VMA_NULLABLE pAllocationInfo)"
  },
  {
    "label": "vmaCreateAliasingImage()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateAliasingImage(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, const VkImageCreateInfo* VMA_NOT_NULL pImageCreateInfo, VkImage VMA_NULLABLE_NON_DISPATCHABLE* VMA_NOT_NULL pImage)"
  },
  {
    "label": "vmaCreateAliasingImage2()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateAliasingImage2(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, const VkImageCreateInfo* VMA_NOT_NULL pImageCreateInfo, VkImage VMA_NULLABLE_NON_DISPATCHABLE* VMA_NOT_NULL pImage)"
  },
  {
    "label": "vmaDestroyImage()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaDestroyImage(VmaAllocator VMA_NOT_NULL allocator, VkImage VMA_NULLABLE_NON_DISPATCHABLE image, VmaAllocation VMA_NULLABLE allocation)"
  },
  {
    "label": "vmaCreateVirtualBlock()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateVirtualBlock(const VmaVirtualBlockCreateInfo* VMA_NOT_NULL pCreateInfo, VmaVirtualBlock VMA_NULLABLE* VMA_NOT_NULL pVirtualBlock)"
  },
  {
    "label": "vmaDestroyVirtualBlock()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaDestroyVirtualBlock(VmaVirtualBlock VMA_NULLABLE virtualBlock)"
  },
  {
    "label": "vmaIsVirtualBlockEmpty()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkBool32 VMA_CALL_POST)",
    "insertText": "vmaIsVirtualBlockEmpty(VmaVirtualBlock VMA_NOT_NULL virtualBlock)"
  },
  {
    "label": "vmaGetVirtualAllocationInfo()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetVirtualAllocationInfo(VmaVirtualBlock VMA_NOT_NULL virtualBlock, VmaVirtualAllocation VMA_NOT_NULL_NON_DISPATCHABLE allocation, VmaVirtualAllocationInfo* VMA_NOT_NULL pVirtualAllocInfo)"
  },
  {
    "label": "vmaVirtualAllocate()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaVirtualAllocate(VmaVirtualBlock VMA_NOT_NULL virtualBlock, const VmaVirtualAllocationCreateInfo* VMA_NOT_NULL pCreateInfo, VmaVirtualAllocation VMA_NULLABLE_NON_DISPATCHABLE* VMA_NOT_NULL pAllocation, VkDeviceSize* VMA_NULLABLE pOffset)"
  },
  {
    "label": "vmaVirtualFree()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaVirtualFree(VmaVirtualBlock VMA_NOT_NULL virtualBlock, VmaVirtualAllocation VMA_NULLABLE_NON_DISPATCHABLE allocation)"
  },
  {
    "label": "vmaClearVirtualBlock()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaClearVirtualBlock(VmaVirtualBlock VMA_NOT_NULL virtualBlock)"
  },
  {
    "label": "vmaSetVirtualAllocationUserData()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaSetVirtualAllocationUserData(VmaVirtualBlock VMA_NOT_NULL virtualBlock, VmaVirtualAllocation VMA_NOT_NULL_NON_DISPATCHABLE allocation, void* VMA_NULLABLE pUserData)"
  },
  {
    "label": "vmaGetVirtualBlockStatistics()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetVirtualBlockStatistics(VmaVirtualBlock VMA_NOT_NULL virtualBlock, VmaStatistics* VMA_NOT_NULL pStats)"
  },
  {
    "label": "vmaCalculateVirtualBlockStatistics()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaCalculateVirtualBlockStatistics(VmaVirtualBlock VMA_NOT_NULL virtualBlock, VmaDetailedStatistics* VMA_NOT_NULL pStats)"
  },
  {
    "label": "vmaBuildVirtualBlockStatsString()",
    "kind": "Method",
    "detail": "Function (# if VMA_STATS_STRING_ENABLED VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaBuildVirtualBlockStatsString(VmaVirtualBlock VMA_NOT_NULL virtualBlock, char* VMA_NULLABLE* VMA_NOT_NULL ppStatsString, VkBool32 detailedMap)"
  },
  {
    "label": "vmaFreeVirtualBlockStatsString()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaFreeVirtualBlockStatsString(VmaVirtualBlock VMA_NOT_NULL virtualBlock, char* VMA_NULLABLE pStatsString)"
  },
  {
    "label": "vmaBuildStatsString()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaBuildStatsString(VmaAllocator VMA_NOT_NULL allocator, char* VMA_NULLABLE* VMA_NOT_NULL ppStatsString, VkBool32 detailedMap)"
  },
  {
    "label": "vmaFreeStatsString()",
    "kind": "Method",
    "detail": "Function (VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaFreeStatsString(VmaAllocator VMA_NOT_NULL allocator, char* VMA_NULLABLE pStatsString)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # endif # ifdef __cplusplus } # endif # endif # if)",
    "insertText": "defined(__cplusplus) && defined(__INTELLISENSE__) #define VMA_IMPLEMENTATION #endif #ifdef VMA_IMPLEMENTATION #undef VMA_IMPLEMENTATION #include <cstdint> #include <cstdlib> #include <cstring> #include <cinttypes> #include <utility> #include <type_traits> #if !defined(VMA_CPP20) #if __cplusplus >= 202002L || _MSVC_LANG >= 202002L #define VMA_CPP20 1 #else #define VMA_CPP20 0 #endif #endif #ifdef _MSC_VER #include <intrin.h> #endif #if VMA_CPP20 #include <bit> #endif #if VMA_STATS_STRING_ENABLED #include <cstdio> #endif #ifndef _VMA_CONFIGURATION #if !defined(VMA_STATIC_VULKAN_FUNCTIONS) && !defined(VK_NO_PROTOTYPES) #define VMA_STATIC_VULKAN_FUNCTIONS 1 #endif #if !defined(VMA_DYNAMIC_VULKAN_FUNCTIONS) #define VMA_DYNAMIC_VULKAN_FUNCTIONS 1 #endif #ifndef VMA_USE_STL_SHARED_MUTEX #if __cplusplus >= 201703L || _MSVC_LANG >= 201703L #define VMA_USE_STL_SHARED_MUTEX 1 #elif defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 190023918 && __cplusplus == 199711L && _MSVC_LANG >= 201703L #define VMA_USE_STL_SHARED_MUTEX 1 #else #define VMA_USE_STL_SHARED_MUTEX 0 #endif #endif #if !defined(VMA_CONFIGURATION_USER_INCLUDES_H) #include <cassert> #include <algorithm> #include <mutex> #else #include VMA_CONFIGURATION_USER_INCLUDES_H #endif #ifndef VMA_NULL #define VMA_NULL nullptr #endif #ifndef VMA_FALLTHROUGH #if __cplusplus >= 201703L || _MSVC_LANG >= 201703L #define VMA_FALLTHROUGH [[fallthrough]] #else #define VMA_FALLTHROUGH #endif #endif #ifndef VMA_ASSERT #ifdef NDEBUG #define VMA_ASSERT(expr) #else #define VMA_ASSERT(expr) assert(expr) #endif #endif #ifndef VMA_HEAVY_ASSERT #ifdef NDEBUG #define VMA_HEAVY_ASSERT(expr) #else #define VMA_HEAVY_ASSERT(expr) #endif #endif #ifndef VMA_ASSERT_LEAK #define VMA_ASSERT_LEAK(expr) VMA_ASSERT(expr) #endif #if defined(__ANDROID_API__) && (__ANDROID_API__ < 16) #include <cstdlib> static void* vma_aligned_alloc(size_t alignment, size_t size)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (alignment =)",
    "insertText": "sizeof(void*)"
  },
  {
    "label": "memalign()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "memalign(alignment, size)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # elif)",
    "insertText": "defined(__APPLE__) || defined(__ANDROID__) || (defined(__linux__) && defined(__GLIBCXX__) && !defined(_GLIBCXX_HAVE_ALIGNED_ALLOC)) #include <cstdlib> #if defined(__APPLE__) #include <AvailabilityMacros.h> #endif static void* vma_aligned_alloc(size_t alignment, size_t size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} void* pointer ;)",
    "insertText": "if(posix_memalign(&pointer, alignment, size) == 0)"
  },
  {
    "label": "vma_aligned_alloc()",
    "kind": "Method",
    "detail": "Function (} # elif __cplusplus> = 2 0 1 7 0 3 L | | _MSVC_LANG> = 2 0 1 7 0 3 L void*)",
    "insertText": "vma_aligned_alloc(size_t alignment, size_t size)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"Could not implement aligned_alloc automatically. Please enable C++17 or later in your compiler or provide custom implementation of macro VMA_SYSTEM_ALIGNED_MALLOC (and VMA_SYSTEM_ALIGNED_FREE if needed) using the API of your system.\")"
  },
  {
    "label": "_aligned_free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_aligned_free(ptr)"
  },
  {
    "label": "vma_aligned_free()",
    "kind": "Method",
    "detail": "Function (} # else void)",
    "insertText": "vma_aligned_free(void* VMA_NULLABLE ptr)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(ptr)"
  },
  {
    "label": "VMA_ALIGN_OF()",
    "kind": "Method",
    "detail": "Function (} # endif # ifndef VMA_ALIGN_OF # define)",
    "insertText": "VMA_ALIGN_OF(type) (alignof(type)) #endif #ifndef VMA_SYSTEM_ALIGNED_MALLOC #define VMA_SYSTEM_ALIGNED_MALLOC(size, alignment) vma_aligned_alloc((alignment), (size)) #endif #ifndef VMA_SYSTEM_ALIGNED_FREE #if defined(VMA_SYSTEM_FREE) #define VMA_SYSTEM_ALIGNED_FREE(ptr) VMA_SYSTEM_FREE(ptr) #else #define VMA_SYSTEM_ALIGNED_FREE(ptr) vma_aligned_free(ptr) #endif #endif #ifndef VMA_COUNT_BITS_SET #define VMA_COUNT_BITS_SET(v) VmaCountBitsSet(v) #endif #ifndef VMA_BITSCAN_LSB #define VMA_BITSCAN_LSB(mask) VmaBitScanLSB(mask) #endif #ifndef VMA_BITSCAN_MSB #define VMA_BITSCAN_MSB(mask) VmaBitScanMSB(mask) #endif #ifndef VMA_MIN #define VMA_MIN(v1, v2) ((std::min)((v1), (v2))) #endif #ifndef VMA_MAX #define VMA_MAX(v1, v2) ((std::max)((v1), (v2))) #endif #ifndef VMA_SORT #define VMA_SORT(beg, end, cmp) std::sort(beg, end, cmp) #endif #ifndef VMA_DEBUG_LOG_FORMAT #define VMA_DEBUG_LOG_FORMAT(format, ...) #endif #ifndef VMA_DEBUG_LOG #define VMA_DEBUG_LOG(str) VMA_DEBUG_LOG_FORMAT(\"%s\", (str)) #endif #ifndef VMA_LEAK_LOG_FORMAT #define VMA_LEAK_LOG_FORMAT(format, ...) VMA_DEBUG_LOG_FORMAT(format, __VA_ARGS__) #endif #ifndef VMA_CLASS_NO_COPY #define VMA_CLASS_NO_COPY(className) \\ private: \\ className(const className&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (\\ className&)",
    "insertText": "operator(const className&)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (# endif # ifndef VMA_CLASS_NO_COPY_NO_MOVE # define)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(className) \\ private: \\ className(const className&)"
  },
  {
    "label": "className()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "className(className&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (\\ className&)",
    "insertText": "operator(className&&)"
  },
  {
    "label": "VmaUint32ToStr()",
    "kind": "Method",
    "detail": "Function (# endif # if VMA_STATS_STRING_ENABLED void)",
    "insertText": "VmaUint32ToStr(char* VMA_NOT_NULL outStr, size_t strLen, uint32_t num)"
  },
  {
    "label": "snprintf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "snprintf(outStr, strLen, \"%\" PRIu32, num)"
  },
  {
    "label": "VmaUint64ToStr()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VmaUint64ToStr(char* VMA_NOT_NULL outStr, size_t strLen, uint64_t num)"
  },
  {
    "label": "snprintf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "snprintf(outStr, strLen, \"%\" PRIu64, num)"
  },
  {
    "label": "VmaPtrToStr()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VmaPtrToStr(char* VMA_NOT_NULL outStr, size_t strLen, const void* ptr)"
  },
  {
    "label": "snprintf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "snprintf(outStr, strLen, \"%p\", ptr)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} # endif # ifndef VMA_MUTEX class VmaMutex {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaMutex) public: VmaMutex()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Lock()"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (m_Mutex .)",
    "insertText": "lock()"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Unlock()"
  },
  {
    "label": "unlock()",
    "kind": "Method",
    "detail": "Function (m_Mutex .)",
    "insertText": "unlock()"
  },
  {
    "label": "TryLock()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "TryLock()"
  },
  {
    "label": "LockRead()",
    "kind": "Method",
    "detail": "Function (} private : std::mutex m_Mutex ; } ; # define VMA_MUTEX VmaMutex # endif # ifndef VMA_RW_MUTEX # if VMA_USE_STL_SHARED_MUTEX # include<shared_mutex> class VmaRWMutex { public : void)",
    "insertText": "LockRead()"
  },
  {
    "label": "lock_shared()",
    "kind": "Method",
    "detail": "Function (m_Mutex .)",
    "insertText": "lock_shared()"
  },
  {
    "label": "UnlockRead()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UnlockRead()"
  },
  {
    "label": "unlock_shared()",
    "kind": "Method",
    "detail": "Function (m_Mutex .)",
    "insertText": "unlock_shared()"
  },
  {
    "label": "TryLockRead()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "TryLockRead()"
  },
  {
    "label": "LockWrite()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "LockWrite()"
  },
  {
    "label": "UnlockWrite()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UnlockWrite()"
  },
  {
    "label": "TryLockWrite()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "TryLockWrite()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} private : std::shared_mutex m_Mutex ; } ; # define VMA_RW_MUTEX VmaRWMutex # elif)",
    "insertText": "defined(_WIN32) && defined(WINVER)"
  },
  {
    "label": "VmaRWMutex()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "VmaRWMutex()"
  },
  {
    "label": "InitializeSRWLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeSRWLock(&m_Lock)"
  },
  {
    "label": "AcquireSRWLockShared()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AcquireSRWLockShared(&m_Lock)"
  },
  {
    "label": "ReleaseSRWLockShared()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseSRWLockShared(&m_Lock)"
  },
  {
    "label": "AcquireSRWLockExclusive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AcquireSRWLockExclusive(&m_Lock)"
  },
  {
    "label": "ReleaseSRWLockExclusive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseSRWLockExclusive(&m_Lock)"
  },
  {
    "label": "VMA_DEBUG_ALWAYS_DEDICATED_MEMORY()",
    "kind": "Method",
    "detail": "Function (} private : VMA_MUTEX m_Mutex ; } ; # define VMA_RW_MUTEX VmaRWMutex # endif # endif # ifndef VMA_ATOMIC_UINT32 # include<atomic> # define VMA_ATOMIC_UINT32 std::atomic<uint32_t> # endif # ifndef VMA_ATOMIC_UINT64 # include<atomic> # define VMA_ATOMIC_UINT64 std::atomic<uint64_t> # endif # ifndef VMA_DEBUG_ALWAYS_DEDICATED_MEMORY # define)",
    "insertText": "VMA_DEBUG_ALWAYS_DEDICATED_MEMORY(0) #endif #ifndef VMA_MIN_ALIGNMENT #ifdef VMA_DEBUG_ALIGNMENT #define VMA_MIN_ALIGNMENT VMA_DEBUG_ALIGNMENT #else #define VMA_MIN_ALIGNMENT (1) #endif #endif #ifndef VMA_DEBUG_MARGIN #define VMA_DEBUG_MARGIN (0) #endif #ifndef VMA_DEBUG_INITIALIZE_ALLOCATIONS #define VMA_DEBUG_INITIALIZE_ALLOCATIONS (0) #endif #ifndef VMA_DEBUG_DETECT_CORRUPTION #define VMA_DEBUG_DETECT_CORRUPTION (0) #endif #ifndef VMA_DEBUG_GLOBAL_MUTEX #define VMA_DEBUG_GLOBAL_MUTEX (0) #endif #ifndef VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY #define VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY (1) #endif #ifndef VMA_DEBUG_DONT_EXCEED_MAX_MEMORY_ALLOCATION_COUNT #define VMA_DEBUG_DONT_EXCEED_MAX_MEMORY_ALLOCATION_COUNT (0) #endif #ifndef VMA_SMALL_HEAP_MAX_SIZE #define VMA_SMALL_HEAP_MAX_SIZE (1024ull * 1024 * 1024) #endif #ifndef VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE #define VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE (256ull * 1024 * 1024) #endif #ifndef VMA_MAPPING_HYSTERESIS_ENABLED #define VMA_MAPPING_HYSTERESIS_ENABLED 1 #endif #define VMA_VALIDATE(cond)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "VMA_ASSERT(0 && \"Validation failed: \" #cond)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ return false ; \\ } })",
    "insertText": "while(false)"
  },
  {
    "label": "VK_ERROR_UNKNOWN_COPY()",
    "kind": "Method",
    "detail": "Function (const uint8_t VMA_ALLOCATION_FILL_PATTERN_DESTROYED = 0 xEF ; const uint32_t VMA_CORRUPTION_DETECTION_MAGIC_VALUE = 0 x7F84E666 ; const uint32_t VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY = 0 x00000040 ; const uint32_t VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY = 0 x00000080 ; const uint32_t VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_COPY = 0 x00020000 ; const uint32_t VK_IMAGE_CREATE_DISJOINT_BIT_COPY = 0 x00000200 ; const int32_t VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT_COPY = 1 0 0 0 1 5 8 0 0 0 ; const uint32_t VMA_ALLOCATION_INTERNAL_STRATEGY_MIN_OFFSET = 0 x10000000u ; const uint32_t VMA_ALLOCATION_TRY_COUNT = 3 2 ; const uint32_t VMA_VENDOR_ID_AMD = 4 0 9 8 ; # define)",
    "insertText": "VK_ERROR_UNKNOWN_COPY((VkResult)-13)"
  },
  {
    "label": "VK_DEFINE_NON_DISPATCHABLE_HANDLE()",
    "kind": "Method",
    "detail": "Function (\" FREE \",\" UNKNOWN \",\" BUFFER \",\" IMAGE_UNKNOWN \",\" IMAGE_LINEAR \",\" IMAGE_OPTIMAL \",} ; # endif VkAllocationCallbacks VmaEmptyAllocationCallbacks = { VMA_NULL,VMA_NULL,VMA_NULL,VMA_NULL,VMA_NULL,VMA_NULL } ; # ifndef _VMA_ENUM_DECLARATIONS enum VmaSuballocationType { VMA_SUBALLOCATION_TYPE_FREE = 0,VMA_SUBALLOCATION_TYPE_UNKNOWN = 1,VMA_SUBALLOCATION_TYPE_BUFFER = 2,VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN = 3,VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR = 4,VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL = 5,VMA_SUBALLOCATION_TYPE_MAX_ENUM = 0 x7FFFFFFF } ; enum VMA_CACHE_OPERATION { VMA_CACHE_FLUSH,VMA_CACHE_INVALIDATE } ; enum class VmaAllocationRequestType { Normal,TLSF,UpperAddress,EndOf1st,EndOf2nd,} ; # endif # ifndef _VMA_FORWARD_DECLARATIONS)",
    "insertText": "VK_DEFINE_NON_DISPATCHABLE_HANDLE(VmaAllocHandle)"
  },
  {
    "label": "VmaCountBitsSet()",
    "kind": "Method",
    "detail": "Function (struct VmaMutexLock ; struct VmaMutexLockRead ; struct VmaMutexLockWrite ; template<T> struct AtomicTransactionalIncrement ; template<T> struct VmaStlAllocator ; template<T,AllocatorT> class VmaVector ; template<T,AllocatorT,size_t N> class VmaSmallVector ; template<T> class VmaPoolAllocator ; template<T> struct VmaListItem ; template<T> class VmaRawList ; template<T,AllocatorT> class VmaList ; template<ItemTypeTraits> class VmaIntrusiveLinkedList ; # if VMA_STATS_STRING_ENABLED class VmaStringBuilder ; class VmaJsonWriter ; # endif class VmaDeviceMemoryBlock ; struct VmaDedicatedAllocationListItemTraits ; class VmaDedicatedAllocationList ; struct VmaSuballocation ; struct VmaSuballocationOffsetLess ; struct VmaSuballocationOffsetGreater ; struct VmaSuballocationItemSizeLess ; typedef VmaList<VmaSuballocation,VmaStlAllocator<VmaSuballocation>> VmaSuballocationList ; struct VmaAllocationRequest ; class VmaBlockMetadata ; class VmaBlockMetadata_Linear ; class VmaBlockMetadata_TLSF ; class VmaBlockVector ; struct VmaPoolListItemTraits ; struct VmaCurrentBudgetData ; class VmaAllocationObjectAllocator ; # endif # ifndef _VMA_FUNCTIONS uint32_t)",
    "insertText": "VmaCountBitsSet(uint32_t v)"
  },
  {
    "label": "popcount()",
    "kind": "Method",
    "detail": "Function (# if VMA_CPP20 return)",
    "insertText": "popcount(v)"
  },
  {
    "label": "v()",
    "kind": "Method",
    "detail": "Function (# else uint32_t c =)",
    "insertText": "v((v >> 1) & 0x55555555)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "c((c >> 2) & 0x33333333) + (c & 0x33333333)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "c((c >> 4) + c)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "c((c >> 8) + c)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "c((c >> 16) + c)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_MSC_VER) && defined(_WIN64)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# else uint8_t pos = 0 ; uint64_t bit = 1 ; do {)",
    "insertText": "if(mask & bit)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bit<<= 1 ; })",
    "insertText": "while(pos++ < 63)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_VER unsigned long pos ;)",
    "insertText": "if(_BitScanForward(&pos, mask)) return static_cast<uint8_t>(pos)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bit<<= 1 ; })",
    "insertText": "while(pos++ < 31)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# elif VMA_CPP20)",
    "insertText": "if(mask) return 63 - static_cast<uint8_t>(std::countl_zero(mask))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# elif defined __GNUC__ | | defined __clang__)",
    "insertText": "if(mask) return 63 - static_cast<uint8_t>(__builtin_clzll(mask))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bit>> = 1 ; })",
    "insertText": "while(pos-- > 0)"
  },
  {
    "label": "VmaBitScanMSB()",
    "kind": "Method",
    "detail": "Function (# endif return UINT8_MAX ; } uint8_t)",
    "insertText": "VmaBitScanMSB(uint32_t mask)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_VER unsigned long pos ;)",
    "insertText": "if(_BitScanReverse(&pos, mask)) return static_cast<uint8_t>(pos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# elif VMA_CPP20)",
    "insertText": "if(mask) return 31 - static_cast<uint8_t>(std::countl_zero(mask))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# elif defined __GNUC__ | | defined __clang__)",
    "insertText": "if(mask) return 31 - static_cast<uint8_t>(__builtin_clz(mask))"
  },
  {
    "label": "VmaIsPow2()",
    "kind": "Method",
    "detail": "Function (# endif return UINT8_MAX ; } template<T> bool)",
    "insertText": "VmaIsPow2(T x)"
  },
  {
    "label": "VmaAlignUp()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "VmaAlignUp(T val, T alignment)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(VmaIsPow2(alignment))"
  },
  {
    "label": "VmaAlignDown()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "VmaAlignDown(T val, T alignment)"
  },
  {
    "label": "VmaRoundDiv()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "VmaRoundDiv(T x, T y)"
  },
  {
    "label": "VmaDivideRoundingUp()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "VmaDivideRoundingUp(T x, T y)"
  },
  {
    "label": "VmaNextPow2()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "VmaNextPow2(uint32_t v)"
  },
  {
    "label": "VmaNextPow2()",
    "kind": "Method",
    "detail": "Function (v - - ; v | = v>> 1 ; v | = v>> 2 ; v | = v>> 4 ; v | = v>> 8 ; v | = v>> 1 6 ; v + + ; return v ; } uint64_t)",
    "insertText": "VmaNextPow2(uint64_t v)"
  },
  {
    "label": "VmaPrevPow2()",
    "kind": "Method",
    "detail": "Function (v - - ; v | = v>> 1 ; v | = v>> 2 ; v | = v>> 4 ; v | = v>> 8 ; v | = v>> 1 6 ; v | = v>> 3 2 ; v + + ; return v ; } uint32_t)",
    "insertText": "VmaPrevPow2(uint32_t v)"
  },
  {
    "label": "v()",
    "kind": "Method",
    "detail": "Function (v | = v>> 1 ; v | = v>> 2 ; v | = v>> 4 ; v | = v>> 8 ; v | = v>> 1 6 ; v =)",
    "insertText": "v(v >> 1)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(resourceAOffset + resourceASize <= resourceBOffset && resourceASize > 0 && pageSize > 0)"
  },
  {
    "label": "resourceAEnd()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize resourceAEnd = resourceAOffset + resourceASize - 1 ; VkDeviceSize resourceAEndPage =)",
    "insertText": "resourceAEnd(pageSize - 1)"
  },
  {
    "label": "resourceBStart()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize resourceBStart = resourceBOffset ; VkDeviceSize resourceBStartPage =)",
    "insertText": "resourceBStart(pageSize - 1)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(suballocType1, suballocType2)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "switch(suballocType1)"
  },
  {
    "label": "pDst()",
    "kind": "Method",
    "detail": "Function (# if VMA_DEBUG_MARGIN> 0&& VMA_DEBUG_DETECT_CORRUPTION uint32_t*)",
    "insertText": "pDst(uint32_t*)((char*)pData + offset)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const size_t numberCount = VMA_DEBUG_MARGIN /)",
    "insertText": "sizeof(uint32_t)"
  },
  {
    "label": "VmaValidateMagicValue()",
    "kind": "Method",
    "detail": "Function (* pDst = VMA_CORRUPTION_DETECTION_MAGIC_VALUE ; } # else # endif } bool)",
    "insertText": "VmaValidateMagicValue(const void* pData, VkDeviceSize offset)"
  },
  {
    "label": "pSrc()",
    "kind": "Method",
    "detail": "Function (# if VMA_DEBUG_MARGIN> 0&& VMA_DEBUG_DETECT_CORRUPTION const uint32_t*)",
    "insertText": "pSrc(const uint32_t*)((const char*)pData + offset)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(&outBufCreateInfo, 0, sizeof(outBufCreateInfo))"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (outBufCreateInfo . sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO ; outBufCreateInfo . usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT ; outBufCreateInfo .)",
    "insertText": "size(VkDeviceSize)"
  },
  {
    "label": "VmaBinaryFindFirstNotLess()",
    "kind": "Method",
    "detail": "Function (} template<CmpLess,IterT,KeyT> IterT)",
    "insertText": "VmaBinaryFindFirstNotLess(IterT beg, IterT end, const KeyT& key, const CmpLess& cmp)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t down = 0,up =)",
    "insertText": "size_t(end - beg)"
  },
  {
    "label": "down()",
    "kind": "Method",
    "detail": "Function (const size_t mid =)",
    "insertText": "down(up - down)"
  },
  {
    "label": "KeyT()",
    "kind": "Method",
    "detail": "Function (IterT it = VmaBinaryFindFirstNotLess<CmpLess,IterT,)",
    "insertText": "KeyT(beg, end, value, cmp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const T iPtr = arr [ i ] ;)",
    "insertText": "if(iPtr == VMA_NULL)"
  },
  {
    "label": "VmaPnextChainFind()",
    "kind": "Method",
    "detail": "Function (newStruct -> pNext = mainStruct -> pNext ; mainStruct -> pNext = newStruct ; } template<FindT,MainT> const FindT*)",
    "insertText": "VmaPnextChainFind(const MainT* mainStruct, VkStructureType sType)"
  },
  {
    "label": "VmaBufferImageUsage()",
    "kind": "Method",
    "detail": "Function (} } return VMA_NULL ; } struct VmaBufferImageUsage { # if VMA_KHR_MAINTENANCE5 typedef uint64_t BaseType ; # else typedef uint32_t BaseType ; # endif const VmaBufferImageUsage UNKNOWN ; BaseType Value ;)",
    "insertText": "VmaBufferImageUsage()"
  },
  {
    "label": "VmaBufferImageUsage()",
    "kind": "Method",
    "detail": "Function (* this = UNKNOWN ; })",
    "insertText": "VmaBufferImageUsage(BaseType usage) : Value(usage)"
  },
  {
    "label": "VmaBufferImageUsage()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VmaBufferImageUsage(const VkBufferCreateInfo &createInfo, bool useKhrMaintenance5)"
  },
  {
    "label": "VmaBufferImageUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaBufferImageUsage(const VkImageCreateInfo &createInfo)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const VmaBufferImageUsage& rhs)"
  },
  {
    "label": "ContainsDeviceAccess()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ContainsDeviceAccess()"
  },
  {
    "label": "VmaBufferImageUsage()",
    "kind": "Method",
    "detail": "Function (} } ; const VmaBufferImageUsage VmaBufferImageUsage::UNKNOWN =)",
    "insertText": "VmaBufferImageUsage(0)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(VmaBufferImageUsage& lhs, VmaBufferImageUsage& rhs)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "swap(lhs.Value, rhs.Value)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_KHR_MAINTENANCE5)",
    "insertText": "if(useKhrMaintenance5)"
  },
  {
    "label": "VkBufferUsageFlags2CreateInfoKHR()",
    "kind": "Method",
    "detail": "Function (const VkBufferUsageFlags2CreateInfoKHR* const usageFlags2 = VmaPnextChainFind<)",
    "insertText": "VkBufferUsageFlags2CreateInfoKHR(&createInfo, VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (this -> Value = usageFlags2 -> usage ; return ; } } # endif this ->)",
    "insertText": "Value(BaseType)"
  },
  {
    "label": "FindMemoryPreferences()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "FindMemoryPreferences(bool isIntegratedGPU, const VmaAllocationCreateInfo& allocCreateInfo, VmaBufferImageUsage bufImgUsage, VkMemoryPropertyFlags& outRequiredFlags, VkMemoryPropertyFlags& outPreferredFlags, VkMemoryPropertyFlags& outNotPreferredFlags)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (outRequiredFlags = allocCreateInfo . requiredFlags ; outPreferredFlags = allocCreateInfo . preferredFlags ; outNotPreferredFlags = 0 ;)",
    "insertText": "switch(allocCreateInfo.usage)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (outPreferredFlags | = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ; } break ; case VMA_MEMORY_USAGE_CPU_ONLY : outRequiredFlags | = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ; break ; case VMA_MEMORY_USAGE_CPU_TO_GPU : outRequiredFlags | = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT ;)",
    "insertText": "if(!isIntegratedGPU || (outPreferredFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (outPreferredFlags | = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ; } break ; case VMA_MEMORY_USAGE_GPU_TO_CPU : outRequiredFlags | = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT ; outPreferredFlags | = VK_MEMORY_PROPERTY_HOST_CACHED_BIT ; break ; case VMA_MEMORY_USAGE_CPU_COPY : outNotPreferredFlags | = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ; break ; case VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED : outRequiredFlags | = VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT ; break ; case VMA_MEMORY_USAGE_AUTO : case VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE : case VMA_MEMORY_USAGE_AUTO_PREFER_HOST : {)",
    "insertText": "if(bufImgUsage == VmaBufferImageUsage::UNKNOWN)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"VMA_MEMORY_USAGE_AUTO* values can only be used with functions like vmaCreateBuffer, vmaCreateImage so that the details of the created resource are known.\" \" Maybe you use VkBufferUsageFlags2CreateInfoKHR but forgot to use VMA_ALLOCATOR_CREATE_KHR_MAINTENANCE5_BIT?\")"
  },
  {
    "label": "hostAccessSequentialWrite()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "hostAccessSequentialWrite(allocCreateInfo.flags & VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT)"
  },
  {
    "label": "hostAccessRandom()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "hostAccessRandom(allocCreateInfo.flags & VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT)"
  },
  {
    "label": "hostAccessAllowTransferInstead()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "hostAccessAllowTransferInstead(allocCreateInfo.flags & VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const bool preferDevice = allocCreateInfo . usage = = VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE ; const bool preferHost = allocCreateInfo . usage = = VMA_MEMORY_USAGE_AUTO_PREFER_HOST ;)",
    "insertText": "if(hostAccessRandom)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (outPreferredFlags | = VK_MEMORY_PROPERTY_HOST_CACHED_BIT ;)",
    "insertText": "if(!isIntegratedGPU && deviceAccess && hostAccessAllowTransferInstead && !preferHost)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (outPreferredFlags | = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ; } else { outRequiredFlags | = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT ; } } else)",
    "insertText": "if(hostAccessSequentialWrite)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (outPreferredFlags | = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT ; } else { outRequiredFlags | = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT ;)",
    "insertText": "if(deviceAccess)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(((allocCreateInfo.requiredFlags | allocCreateInfo.preferredFlags) & (VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY | VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY)) == 0)"
  },
  {
    "label": "VmaMalloc()",
    "kind": "Method",
    "detail": "Function (outNotPreferredFlags | = VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY ; } return true ; } void*)",
    "insertText": "VmaMalloc(const VkAllocationCallbacks* pAllocationCallbacks, size_t size, size_t alignment)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (void* result = VMA_NULL ;)",
    "insertText": "if((pAllocationCallbacks != VMA_NULL) && (pAllocationCallbacks->pfnAllocation != VMA_NULL))"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "result(*pAllocationCallbacks->pfnAllocation)( pAllocationCallbacks->pUserData, size, alignment, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT)"
  },
  {
    "label": "VMA_SYSTEM_ALIGNED_MALLOC()",
    "kind": "Method",
    "detail": "Function (} else { result =)",
    "insertText": "VMA_SYSTEM_ALIGNED_MALLOC(size, alignment)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VMA_ASSERT(result != VMA_NULL && \"CPU memory allocation failed.\")"
  },
  {
    "label": "VMA_SYSTEM_ALIGNED_FREE()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "VMA_SYSTEM_ALIGNED_FREE(ptr)"
  },
  {
    "label": "VmaAllocate()",
    "kind": "Method",
    "detail": "Function (} } template<T> T*)",
    "insertText": "VmaAllocate(const VkAllocationCallbacks* pAllocationCallbacks)"
  },
  {
    "label": "VmaAllocateArray()",
    "kind": "Method",
    "detail": "Function (} template<T> T*)",
    "insertText": "VmaAllocateArray(const VkAllocationCallbacks* pAllocationCallbacks, size_t count)"
  },
  {
    "label": "vma_new()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "vma_new(allocator, type) new(VmaAllocate<type>(allocator))(type) #define vma_new_array(allocator, type, count) new(VmaAllocateArray<type>((allocator), (count)))(type) template<typename T> static void vma_delete(const VkAllocationCallbacks* pAllocationCallbacks, T* ptr)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (ptr -> ~)",
    "insertText": "T()"
  },
  {
    "label": "VmaFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaFree(pAllocationCallbacks, ptr)"
  },
  {
    "label": "vma_delete_array()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "vma_delete_array(const VkAllocationCallbacks* pAllocationCallbacks, T* ptr, size_t count)"
  },
  {
    "label": "VmaCreateStringCopy()",
    "kind": "Method",
    "detail": "Function (} } char*)",
    "insertText": "VmaCreateStringCopy(const VkAllocationCallbacks* allocs, const char* srcStr)"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (const size_t len =)",
    "insertText": "strlen(srcStr)"
  },
  {
    "label": "vma_new_array()",
    "kind": "Method",
    "detail": "Function (char* const result =)",
    "insertText": "vma_new_array(allocs, char, len + 1)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(result, srcStr, len + 1)"
  },
  {
    "label": "vma_new_array()",
    "kind": "Method",
    "detail": "Function (char* const result =)",
    "insertText": "vma_new_array(allocs, char, strLen + 1)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(result, srcStr, strLen)"
  },
  {
    "label": "VmaFreeString()",
    "kind": "Method",
    "detail": "Function (result [ strLen ] = ' \\ 0 ' ; return result ; } return VMA_NULL ; } # endif void)",
    "insertText": "VmaFreeString(const VkAllocationCallbacks* allocs, char* str)"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (const size_t len =)",
    "insertText": "strlen(str)"
  },
  {
    "label": "vma_delete_array()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vma_delete_array(allocs, str, len + 1)"
  },
  {
    "label": "VmaVectorInsertSorted()",
    "kind": "Method",
    "detail": "Function (} } template<CmpLess,VectorT> size_t)",
    "insertText": "VmaVectorInsertSorted(VectorT& vector, const typename VectorT::value_type& value)"
  },
  {
    "label": "VmaBinaryFindFirstNotLess()",
    "kind": "Method",
    "detail": "Function (const size_t indexToInsert =)",
    "insertText": "VmaBinaryFindFirstNotLess(vector.data(), vector.data() + vector.size(), value, CmpLess()) - vector.data()"
  },
  {
    "label": "VmaVectorInsert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaVectorInsert(vector, indexToInsert, value)"
  },
  {
    "label": "VmaBinaryFindFirstNotLess()",
    "kind": "Method",
    "detail": "Function (CmpLess comparator ; VectorT::iterator it =)",
    "insertText": "VmaBinaryFindFirstNotLess(vector.begin(), vector.end(), value, comparator)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (size_t indexToRemove = it - vector .)",
    "insertText": "begin()"
  },
  {
    "label": "VmaVectorRemove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaVectorRemove(vector, indexToRemove)"
  },
  {
    "label": "VmaAddStatistics()",
    "kind": "Method",
    "detail": "Function (outStats . blockCount = 0 ; outStats . allocationCount = 0 ; outStats . blockBytes = 0 ; outStats . allocationBytes = 0 ; } void)",
    "insertText": "VmaAddStatistics(VmaStatistics& inoutStats, const VmaStatistics& src)"
  },
  {
    "label": "VmaClearDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (inoutStats . blockCount + = src . blockCount ; inoutStats . allocationCount + = src . allocationCount ; inoutStats . blockBytes + = src . blockBytes ; inoutStats . allocationBytes + = src . allocationBytes ; } void)",
    "insertText": "VmaClearDetailedStatistics(VmaDetailedStatistics& outStats)"
  },
  {
    "label": "VmaClearStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaClearStatistics(outStats.statistics)"
  },
  {
    "label": "VmaAddDetailedStatisticsAllocation()",
    "kind": "Method",
    "detail": "Function (outStats . unusedRangeCount = 0 ; outStats . allocationSizeMin = VK_WHOLE_SIZE ; outStats . allocationSizeMax = 0 ; outStats . unusedRangeSizeMin = VK_WHOLE_SIZE ; outStats . unusedRangeSizeMax = 0 ; } void)",
    "insertText": "VmaAddDetailedStatisticsAllocation(VmaDetailedStatistics& inoutStats, VkDeviceSize size)"
  },
  {
    "label": "VMA_MIN()",
    "kind": "Method",
    "detail": "Function (inoutStats . statistics . allocationCount + + ; inoutStats . statistics . allocationBytes + = size ; inoutStats . allocationSizeMin =)",
    "insertText": "VMA_MIN(inoutStats.allocationSizeMin, size)"
  },
  {
    "label": "VMA_MAX()",
    "kind": "Method",
    "detail": "Function (inoutStats . allocationSizeMax =)",
    "insertText": "VMA_MAX(inoutStats.allocationSizeMax, size)"
  },
  {
    "label": "VmaAddDetailedStatisticsUnusedRange()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VmaAddDetailedStatisticsUnusedRange(VmaDetailedStatistics& inoutStats, VkDeviceSize size)"
  },
  {
    "label": "VMA_MIN()",
    "kind": "Method",
    "detail": "Function (inoutStats . unusedRangeCount + + ; inoutStats . unusedRangeSizeMin =)",
    "insertText": "VMA_MIN(inoutStats.unusedRangeSizeMin, size)"
  },
  {
    "label": "VMA_MAX()",
    "kind": "Method",
    "detail": "Function (inoutStats . unusedRangeSizeMax =)",
    "insertText": "VMA_MAX(inoutStats.unusedRangeSizeMax, size)"
  },
  {
    "label": "VmaAddDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VmaAddDetailedStatistics(VmaDetailedStatistics& inoutStats, const VmaDetailedStatistics& src)"
  },
  {
    "label": "VmaAddStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaAddStatistics(inoutStats.statistics, src.statistics)"
  },
  {
    "label": "VMA_MIN()",
    "kind": "Method",
    "detail": "Function (inoutStats . unusedRangeCount + = src . unusedRangeCount ; inoutStats . allocationSizeMin =)",
    "insertText": "VMA_MIN(inoutStats.allocationSizeMin, src.allocationSizeMin)"
  },
  {
    "label": "VMA_MAX()",
    "kind": "Method",
    "detail": "Function (inoutStats . allocationSizeMax =)",
    "insertText": "VMA_MAX(inoutStats.allocationSizeMax, src.allocationSizeMax)"
  },
  {
    "label": "VMA_MIN()",
    "kind": "Method",
    "detail": "Function (inoutStats . unusedRangeSizeMin =)",
    "insertText": "VMA_MIN(inoutStats.unusedRangeSizeMin, src.unusedRangeSizeMin)"
  },
  {
    "label": "VMA_MAX()",
    "kind": "Method",
    "detail": "Function (inoutStats . unusedRangeSizeMax =)",
    "insertText": "VMA_MAX(inoutStats.unusedRangeSizeMax, src.unusedRangeSizeMax)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} # endif # ifndef _VMA_MUTEX_LOCK struct VmaMutexLock {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaMutexLock) public: VmaMutexLock(VMA_MUTEX& mutex, bool useMutex = true) : m_pMutex(useMutex ? &mutex : VMA_NULL)"
  },
  {
    "label": "VmaMutexLock()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "VmaMutexLock()"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} } private : VMA_MUTEX* m_pMutex ; } ; struct VmaMutexLockRead {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaMutexLockRead) public: VmaMutexLockRead(VMA_RW_MUTEX& mutex, bool useMutex) : m_pMutex(useMutex ? &mutex : VMA_NULL)"
  },
  {
    "label": "VmaMutexLockRead()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "VmaMutexLockRead()"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} } private : VMA_RW_MUTEX* m_pMutex ; } ; struct VmaMutexLockWrite {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaMutexLockWrite) public: VmaMutexLockWrite(VMA_RW_MUTEX& mutex, bool useMutex) : m_pMutex(useMutex ? &mutex : VMA_NULL)"
  },
  {
    "label": "VmaMutexLockWrite()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "VmaMutexLockWrite()"
  },
  {
    "label": "debugGlobalMutexLock()",
    "kind": "Method",
    "detail": "Function (} } private : VMA_RW_MUTEX* m_pMutex ; } ; # if VMA_DEBUG_GLOBAL_MUTEX VMA_MUTEX gDebugGlobalMutex ; # define VMA_DEBUG_GLOBAL_MUTEX_LOCK VmaMutexLock)",
    "insertText": "debugGlobalMutexLock(gDebugGlobalMutex, true)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (# else # define VMA_DEBUG_GLOBAL_MUTEX_LOCK # endif # endif # ifndef _VMA_ATOMIC_TRANSACTIONAL_INCREMENT template<AtomicT> struct AtomicTransactionalIncrement { public : using T =)",
    "insertText": "decltype(AtomicT().load())"
  },
  {
    "label": "AtomicTransactionalIncrement()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "AtomicTransactionalIncrement()"
  },
  {
    "label": "Commit()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Commit()"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (m_Atomic = VMA_NULL ; } T)",
    "insertText": "Increment(AtomicT* atomic)"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (m_Atomic = atomic ; return m_Atomic ->)",
    "insertText": "fetch_add(1)"
  },
  {
    "label": "VmaStlAllocator()",
    "kind": "Method",
    "detail": "Function (} private : AtomicT* m_Atomic = VMA_NULL ; } ; # endif # ifndef _VMA_STL_ALLOCATOR template<T> struct VmaStlAllocator { const VkAllocationCallbacks* const m_pCallbacks ; typedef T value_type ;)",
    "insertText": "VmaStlAllocator(const VkAllocationCallbacks* pCallbacks) : m_pCallbacks(pCallbacks)"
  },
  {
    "label": "VmaStlAllocator()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "VmaStlAllocator(const VmaStlAllocator<U>& src) : m_pCallbacks(src.m_pCallbacks)"
  },
  {
    "label": "VmaStlAllocator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VmaStlAllocator(const VmaStlAllocator&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VmaStlAllocator&)",
    "insertText": "operator(const VmaStlAllocator&)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "allocate(size_t n)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "deallocate(T* p, size_t n)"
  },
  {
    "label": "VmaFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaFree(m_pCallbacks, p)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<U> bool)",
    "insertText": "operator(const VmaStlAllocator<U>& rhs)"
  },
  {
    "label": "VmaVector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaVector(size_t count, const AllocatorT& allocator)"
  },
  {
    "label": "VmaVector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaVector(size_t count, const T& value, const AllocatorT& allocator) : VmaVector(count, allocator)"
  },
  {
    "label": "VmaVector()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VmaVector(const VmaVector<T, AllocatorT>& src)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VmaVector&)",
    "insertText": "operator(const VmaVector& rhs)"
  },
  {
    "label": "VmaVector()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaVector()"
  },
  {
    "label": "VmaFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaFree(m_Allocator.m_pCallbacks, m_pArray)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(m_Count > 0)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "end()"
  },
  {
    "label": "pop_front()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pop_front()"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove(0)"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pop_back()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(size() - 1)"
  },
  {
    "label": "push_front()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_front(const T& src)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(0, src)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_back(const T& src)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(size_t newCapacity, bool freeMemory = false)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(size_t newCount)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(0)"
  },
  {
    "label": "shrink_to_fit()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "shrink_to_fit()"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(size_t index, const T& src)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "remove(size_t index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "operator(size_t index)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(index < m_Count)"
  },
  {
    "label": "VmaVector()",
    "kind": "Method",
    "detail": "Function (} template<T,AllocatorT> VmaVector<T,AllocatorT)",
    "insertText": "VmaVector(size_t count, const AllocatorT& allocator) : m_Allocator(allocator), m_pArray(count ? (T*)VmaAllocateArray<T>(allocator.m_pCallbacks, count) : VMA_NULL), m_Count(count), m_Capacity(count)"
  },
  {
    "label": "VmaVector()",
    "kind": "Method",
    "detail": "Function (} template<T,AllocatorT> VmaVector<T,AllocatorT)",
    "insertText": "VmaVector(const VmaVector& src) : m_Allocator(src.m_Allocator), m_pArray(src.m_Count ? (T*)VmaAllocateArray<T>(src.m_Allocator.m_pCallbacks, src.m_Count) : VMA_NULL), m_Count(src.m_Count), m_Capacity(src.m_Count)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(m_pArray, src.m_pArray, m_Count * sizeof(T))"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(rhs.m_Count)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(m_pArray, rhs.m_pArray, m_Count * sizeof(T))"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (const size_t newIndex =)",
    "insertText": "size()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(newIndex + 1)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (m_pArray [ newIndex ] = src ; } template<T,AllocatorT> void VmaVector<T,AllocatorT)",
    "insertText": "reserve(size_t newCapacity, bool freeMemory)"
  },
  {
    "label": "VMA_MAX()",
    "kind": "Method",
    "detail": "Function (newCapacity =)",
    "insertText": "VMA_MAX(newCapacity, m_Count)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (newCapacity = m_Capacity ; })",
    "insertText": "if(newCapacity != m_Capacity)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T* const newArray = newCapacity ? VmaAllocateArray<)",
    "insertText": "T(m_Allocator, newCapacity)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(newArray, m_pArray, m_Count * sizeof(T))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t newCapacity = m_Capacity ;)",
    "insertText": "if(newCount > m_Capacity)"
  },
  {
    "label": "VMA_MAX()",
    "kind": "Method",
    "detail": "Function (newCapacity =)",
    "insertText": "VMA_MAX(newCount, VMA_MAX(m_Capacity * 3 / 2, (size_t)8))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T* const newArray = newCapacity ? VmaAllocateArray<)",
    "insertText": "T(m_Allocator.m_pCallbacks, newCapacity)"
  },
  {
    "label": "VMA_MIN()",
    "kind": "Method",
    "detail": "Function (const size_t elementsToCopy =)",
    "insertText": "VMA_MIN(m_Count, newCount)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(newArray, m_pArray, elementsToCopy * sizeof(T))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T* newArray = VMA_NULL ;)",
    "insertText": "if(m_Count > 0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (newArray = VmaAllocateArray<)",
    "insertText": "T(m_Allocator.m_pCallbacks, m_Count)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(index <= m_Count)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(oldCount + 1)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(m_pArray + (index + 1), m_pArray + index, (oldCount - index) * sizeof(T))"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(m_pArray + index, m_pArray + (index + 1), (oldCount - index - 1) * sizeof(T))"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "resize(oldCount - 1)"
  },
  {
    "label": "VmaVectorInsert()",
    "kind": "Method",
    "detail": "Function (} # endif template<T,allocatorT> void)",
    "insertText": "VmaVectorInsert(VmaVector<T, allocatorT>& vec, size_t index, const T& item)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (vec .)",
    "insertText": "insert(index, item)"
  },
  {
    "label": "VmaVectorRemove()",
    "kind": "Method",
    "detail": "Function (} template<T,allocatorT> void)",
    "insertText": "VmaVectorRemove(VmaVector<T, allocatorT>& vec, size_t index)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (vec .)",
    "insertText": "remove(index)"
  },
  {
    "label": "VmaSmallVector()",
    "kind": "Method",
    "detail": "Function (} # endif # ifndef _VMA_SMALL_VECTOR template<T,AllocatorT,size_t N> class VmaSmallVector { public : typedef T value_type ; typedef T* iterator ;)",
    "insertText": "VmaSmallVector(const AllocatorT& allocator)"
  },
  {
    "label": "VmaSmallVector()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaSmallVector(size_t count, const AllocatorT& allocator)"
  },
  {
    "label": "VmaSmallVector()",
    "kind": "Method",
    "detail": "Function (template<SrcT,SrcAllocatorT,size_t SrcN>)",
    "insertText": "VmaSmallVector(const VmaSmallVector<SrcT, SrcAllocatorT, SrcN>&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<SrcT,SrcAllocatorT,size_t SrcN> VmaSmallVector<T,AllocatorT,N>&)",
    "insertText": "operator(const VmaSmallVector<SrcT, SrcAllocatorT, SrcN>&)"
  },
  {
    "label": "VmaSmallVector()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaSmallVector()"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "front()"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "back()"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (} const T*)",
    "insertText": "data()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(size_t newCount, bool freeMemory = false)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear(bool freeMemory = false)"
  },
  {
    "label": "VmaSmallVector()",
    "kind": "Method",
    "detail": "Function (} private : size_t m_Count ; T m_StaticArray [ N ] ; VmaVector<T,AllocatorT> m_DynamicArray ; } ; # ifndef _VMA_SMALL_VECTOR_FUNCTIONS template<T,AllocatorT,size_t N> VmaSmallVector<T,AllocatorT,N)",
    "insertText": "VmaSmallVector(const AllocatorT& allocator) : m_Count(0), m_DynamicArray(allocator)"
  },
  {
    "label": "VmaSmallVector()",
    "kind": "Method",
    "detail": "Function (} template<T,AllocatorT,size_t N> VmaSmallVector<T,AllocatorT,N)",
    "insertText": "VmaSmallVector(size_t count, const AllocatorT& allocator) : m_Count(count), m_DynamicArray(count > N ? count : 0, allocator)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} template<T,AllocatorT,size_t N> void VmaSmallVector<T,AllocatorT,N)",
    "insertText": "resize(size_t newCount, bool freeMemory)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_DynamicArray .)",
    "insertText": "resize(newCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(newCount > N && m_Count <= N)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(m_DynamicArray.data(), m_StaticArray, m_Count * sizeof(T))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(newCount <= N && m_Count > N)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(m_StaticArray, m_DynamicArray.data(), newCount * sizeof(T))"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} } else { } m_Count = newCount ; } template<T,AllocatorT,size_t N> void VmaSmallVector<T,AllocatorT,N)",
    "insertText": "clear(bool freeMemory)"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(dataPtr + (index + 1), dataPtr + index, (oldCount - index) * sizeof(T))"
  },
  {
    "label": "memmove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memmove(dataPtr + index, dataPtr + (index + 1), (oldCount - index - 1) * sizeof(T))"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} # endif # endif # ifndef _VMA_POOL_ALLOCATOR template<T> class VmaPoolAllocator {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaPoolAllocator) public: VmaPoolAllocator(const VkAllocationCallbacks* pAllocationCallbacks, uint32_t firstBlockCapacity)"
  },
  {
    "label": "VmaPoolAllocator()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaPoolAllocator()"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (template<. . . Types> T*)",
    "insertText": "Alloc(Types&&... args)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(T* ptr)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (private : union Item { uint32_t NextFreeIndex ;)",
    "insertText": "alignas(T) char Value[sizeof(T)"
  },
  {
    "label": "CreateNewBlock()",
    "kind": "Method",
    "detail": "Function (} ; struct ItemBlock { Item* pItems ; uint32_t Capacity ; uint32_t FirstFreeIndex ; } ; const VkAllocationCallbacks* m_pAllocationCallbacks ; const uint32_t m_FirstBlockCapacity ; VmaVector<ItemBlock,VmaStlAllocator<ItemBlock>> m_ItemBlocks ; ItemBlock&)",
    "insertText": "CreateNewBlock()"
  },
  {
    "label": "VmaPoolAllocator()",
    "kind": "Method",
    "detail": "Function (} ; # ifndef _VMA_POOL_ALLOCATOR_FUNCTIONS template<T> VmaPoolAllocator<T)",
    "insertText": "VmaPoolAllocator(const VkAllocationCallbacks* pAllocationCallbacks, uint32_t firstBlockCapacity) : m_pAllocationCallbacks(pAllocationCallbacks), m_FirstBlockCapacity(firstBlockCapacity), m_ItemBlocks(VmaStlAllocator<ItemBlock>(pAllocationCallbacks))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_FirstBlockCapacity > 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ItemBlock& block = m_ItemBlocks [ i ] ;)",
    "insertText": "if(block.FirstFreeIndex != UINT32_MAX)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Value)",
    "insertText": "result(T*)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(result)T(std::forward<Types>(args)...)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(result) T(std::forward<Types>(args)...)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (ItemBlock& block = m_ItemBlocks [ i ] ; Item* pItemPtr ;)",
    "insertText": "memcpy(&pItemPtr, &ptr, sizeof(pItemPtr))"
  },
  {
    "label": "uint32_t()",
    "kind": "Method",
    "detail": "Function (const uint32_t index = static_cast<)",
    "insertText": "uint32_t(pItemPtr - block.pItems)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (pItemPtr -> NextFreeIndex = block . FirstFreeIndex ; block . FirstFreeIndex = index ; return ; } })",
    "insertText": "VMA_ASSERT(0 && \"Pointer doesn't belong to this memory pool.\")"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (const uint32_t newBlockCapacity = m_ItemBlocks .)",
    "insertText": "empty() ? m_FirstBlockCapacity : m_ItemBlocks.back()"
  },
  {
    "label": "vma_new_array()",
    "kind": "Method",
    "detail": "Function (const ItemBlock newBlock = {)",
    "insertText": "vma_new_array(m_pAllocationCallbacks, Item, newBlockCapacity)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (m_ItemBlocks .)",
    "insertText": "push_back(newBlock)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} # endif # endif # ifndef _VMA_RAW_LIST template<T> struct VmaListItem { VmaListItem* pPrev ; VmaListItem* pNext ; T Value ; } ; template<T> class VmaRawList {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaRawList)"
  },
  {
    "label": "VmaRawList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaRawList(const VkAllocationCallbacks* pAllocationCallbacks)"
  },
  {
    "label": "VmaRawList()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaRawList()"
  },
  {
    "label": "GetCount()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetCount()"
  },
  {
    "label": "PushBack()",
    "kind": "Method",
    "detail": "Function (ItemType*)",
    "insertText": "PushBack()"
  },
  {
    "label": "PushFront()",
    "kind": "Method",
    "detail": "Function (ItemType*)",
    "insertText": "PushFront(const T& value)"
  },
  {
    "label": "PushBack()",
    "kind": "Method",
    "detail": "Function (ItemType*)",
    "insertText": "PushBack(const T& value)"
  },
  {
    "label": "PopFront()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopFront()"
  },
  {
    "label": "PopBack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopBack()"
  },
  {
    "label": "InsertBefore()",
    "kind": "Method",
    "detail": "Function (ItemType*)",
    "insertText": "InsertBefore(ItemType* pItem)"
  },
  {
    "label": "InsertAfter()",
    "kind": "Method",
    "detail": "Function (ItemType*)",
    "insertText": "InsertAfter(ItemType* pItem)"
  },
  {
    "label": "InsertBefore()",
    "kind": "Method",
    "detail": "Function (ItemType*)",
    "insertText": "InsertBefore(ItemType* pItem, const T& value)"
  },
  {
    "label": "InsertAfter()",
    "kind": "Method",
    "detail": "Function (ItemType*)",
    "insertText": "InsertAfter(ItemType* pItem, const T& value)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear()"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Remove(ItemType* pItem)"
  },
  {
    "label": "VmaRawList()",
    "kind": "Method",
    "detail": "Function (private : const VkAllocationCallbacks* const m_pAllocationCallbacks ; VmaPoolAllocator<ItemType> m_ItemAllocator ; ItemType* m_pFront ; ItemType* m_pBack ; size_t m_Count ; } ; # ifndef _VMA_RAW_LIST_FUNCTIONS template<T> VmaRawList<T)",
    "insertText": "VmaRawList(const VkAllocationCallbacks* pAllocationCallbacks) : m_pAllocationCallbacks(pAllocationCallbacks), m_ItemAllocator(pAllocationCallbacks, 128), m_pFront(VMA_NULL), m_pBack(VMA_NULL), m_Count(0)"
  },
  {
    "label": "PushFront()",
    "kind": "Method",
    "detail": "Function (} template<T> VmaListItem<T>* VmaRawList<T)",
    "insertText": "PushFront()"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (ItemType* const pNewItem = m_ItemAllocator .)",
    "insertText": "Alloc()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pNewItem -> pPrev = VMA_NULL ;)",
    "insertText": "if(IsEmpty())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ItemType* const pFrontItem = m_pFront ; ItemType* const pNextItem = pFrontItem -> pNext ;)",
    "insertText": "if(pNextItem != VMA_NULL)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (pNextItem -> pPrev = VMA_NULL ; } m_pFront = pNextItem ; m_ItemAllocator .)",
    "insertText": "Free(pFrontItem)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ItemType* const pBackItem = m_pBack ; ItemType* const pPrevItem = pBackItem -> pPrev ;)",
    "insertText": "if(pPrevItem != VMA_NULL)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (pPrevItem -> pNext = VMA_NULL ; } m_pBack = pPrevItem ; m_ItemAllocator .)",
    "insertText": "Free(pBackItem)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (ItemType* pItem = m_pBack ;)",
    "insertText": "while(pItem != VMA_NULL)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (ItemType* const pPrevItem = pItem -> pPrev ; m_ItemAllocator .)",
    "insertText": "Free(pItem)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(pItem != VMA_NULL)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (pItem -> pPrev -> pNext = pItem -> pNext ; } else {)",
    "insertText": "VMA_HEAVY_ASSERT(m_pFront == pItem)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_pFront = pItem -> pNext ; })",
    "insertText": "if(pItem->pNext != VMA_NULL)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (pItem -> pNext -> pPrev = pItem -> pPrev ; } else {)",
    "insertText": "VMA_HEAVY_ASSERT(m_pBack == pItem)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (newItem -> pPrev = prevItem ; newItem -> pNext = pItem ; pItem -> pPrev = newItem ;)",
    "insertText": "if(prevItem != VMA_NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (newItem -> pNext = nextItem ; newItem -> pPrev = pItem ; pItem -> pNext = newItem ;)",
    "insertText": "if(nextItem != VMA_NULL)"
  },
  {
    "label": "InsertBefore()",
    "kind": "Method",
    "detail": "Function (ItemType* const newItem =)",
    "insertText": "InsertBefore(pItem)"
  },
  {
    "label": "InsertAfter()",
    "kind": "Method",
    "detail": "Function (ItemType* const newItem =)",
    "insertText": "InsertAfter(pItem)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (newItem -> Value = value ; return newItem ; } # endif # endif # ifndef _VMA_LIST template<T,AllocatorT> class VmaList {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaList)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (class const_iterator ; class const_reverse_iterator ; class iterator { class const_iterator ; class VmaList<T,AllocatorT> ; public :)",
    "insertText": "iterator() : m_pList(VMA_NULL), m_pItem(VMA_NULL)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "iterator(const reverse_iterator& src) : m_pList(src.m_pList), m_pItem(src.m_pItem)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "operator()"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(m_pItem != VMA_NULL)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(m_pList == rhs.m_pList)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (iterator result =* this ; + +* this ; return result ; } iterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (private : VmaRawList<T>* m_pList ; VmaListItem<T>* m_pItem ;)",
    "insertText": "iterator(VmaRawList<T>* pList, VmaListItem<T>* pItem) : m_pList(pList), m_pItem(pItem)"
  },
  {
    "label": "reverse_iterator()",
    "kind": "Method",
    "detail": "Function (} } ; class reverse_iterator { class const_reverse_iterator ; class VmaList<T,AllocatorT> ; public :)",
    "insertText": "reverse_iterator() : m_pList(VMA_NULL), m_pItem(VMA_NULL)"
  },
  {
    "label": "reverse_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "reverse_iterator(const iterator& src) : m_pList(src.m_pList), m_pItem(src.m_pItem)"
  },
  {
    "label": "reverse_iterator()",
    "kind": "Method",
    "detail": "Function (private : VmaRawList<T>* m_pList ; VmaListItem<T>* m_pItem ;)",
    "insertText": "reverse_iterator(VmaRawList<T>* pList, VmaListItem<T>* pItem) : m_pList(pList), m_pItem(pItem)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (} } ; class const_iterator { class VmaList<T,AllocatorT> ; public :)",
    "insertText": "const_iterator() : m_pList(VMA_NULL), m_pItem(VMA_NULL)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "const_iterator(const iterator& src) : m_pList(src.m_pList), m_pItem(src.m_pItem)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "const_iterator(const reverse_iterator& src) : m_pList(src.m_pList), m_pItem(src.m_pItem)"
  },
  {
    "label": "drop_const()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "drop_const()"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (private : const VmaRawList<T>* m_pList ; const VmaListItem<T>* m_pItem ;)",
    "insertText": "const_iterator(const VmaRawList<T>* pList, const VmaListItem<T>* pItem) : m_pList(pList), m_pItem(pItem)"
  },
  {
    "label": "const_reverse_iterator()",
    "kind": "Method",
    "detail": "Function (} } ; class const_reverse_iterator { class VmaList<T,AllocatorT> ; public :)",
    "insertText": "const_reverse_iterator() : m_pList(VMA_NULL), m_pItem(VMA_NULL)"
  },
  {
    "label": "const_reverse_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "const_reverse_iterator(const reverse_iterator& src) : m_pList(src.m_pList), m_pItem(src.m_pItem)"
  },
  {
    "label": "const_reverse_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "const_reverse_iterator(const iterator& src) : m_pList(src.m_pList), m_pItem(src.m_pItem)"
  },
  {
    "label": "const_reverse_iterator()",
    "kind": "Method",
    "detail": "Function (private : const VmaRawList<T>* m_pList ; const VmaListItem<T>* m_pItem ;)",
    "insertText": "const_reverse_iterator(const VmaRawList<T>* pList, const VmaListItem<T>* pItem) : m_pList(pList), m_pItem(pItem)"
  },
  {
    "label": "VmaList()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "VmaList(const AllocatorT& allocator) : m_RawList(allocator.m_pCallbacks)"
  },
  {
    "label": "cbegin()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "cbegin()"
  },
  {
    "label": "cend()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "cend()"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rbegin()"
  },
  {
    "label": "rend()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rend()"
  },
  {
    "label": "crbegin()",
    "kind": "Method",
    "detail": "Function (} const_reverse_iterator)",
    "insertText": "crbegin()"
  },
  {
    "label": "crend()",
    "kind": "Method",
    "detail": "Function (} const_reverse_iterator)",
    "insertText": "crend()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_back(const T& value)"
  },
  {
    "label": "PushBack()",
    "kind": "Method",
    "detail": "Function (m_RawList .)",
    "insertText": "PushBack(value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(iterator it, const T& value)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "erase(iterator it)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (m_RawList .)",
    "insertText": "Remove(it.m_pItem)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (m_pItem = m_pItem -> pPrev ; } else {)",
    "insertText": "VMA_HEAVY_ASSERT(!m_pList->IsEmpty())"
  },
  {
    "label": "Back()",
    "kind": "Method",
    "detail": "Function (m_pItem = m_pList ->)",
    "insertText": "Back()"
  },
  {
    "label": "Front()",
    "kind": "Method",
    "detail": "Function (m_pItem = m_pList ->)",
    "insertText": "Front()"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (} return* this ; } # endif # endif # ifndef _VMA_INTRUSIVE_LINKED_LIST template<ItemTypeTraits> class VmaIntrusiveLinkedList { public : typedef ItemTypeTraits::ItemType ItemType ; ItemType*)",
    "insertText": "GetPrev(const ItemType* item)"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (} ItemType*)",
    "insertText": "GetNext(const ItemType* item)"
  },
  {
    "label": "VmaIntrusiveLinkedList()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VmaIntrusiveLinkedList()"
  },
  {
    "label": "VmaIntrusiveLinkedList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaIntrusiveLinkedList(VmaIntrusiveLinkedList && src)"
  },
  {
    "label": "VmaIntrusiveLinkedList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaIntrusiveLinkedList(const VmaIntrusiveLinkedList&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VmaIntrusiveLinkedList&)",
    "insertText": "operator(VmaIntrusiveLinkedList&& src)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VmaIntrusiveLinkedList&)",
    "insertText": "operator(const VmaIntrusiveLinkedList&)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(IsEmpty())"
  },
  {
    "label": "PushFront()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PushFront(ItemType* item)"
  },
  {
    "label": "InsertBefore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertBefore(ItemType* existingItem, ItemType* newItem)"
  },
  {
    "label": "InsertAfter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertAfter(ItemType* existingItem, ItemType* newItem)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Remove(ItemType* item)"
  },
  {
    "label": "RemoveAll()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAll()"
  },
  {
    "label": "VmaIntrusiveLinkedList()",
    "kind": "Method",
    "detail": "Function (private : ItemType* m_Front = VMA_NULL ; ItemType* m_Back = VMA_NULL ; size_t m_Count = 0 ; } ; # ifndef _VMA_INTRUSIVE_LINKED_LIST_FUNCTIONS template<ItemTypeTraits> VmaIntrusiveLinkedList<ItemTypeTraits)",
    "insertText": "VmaIntrusiveLinkedList(VmaIntrusiveLinkedList&& src) : m_Front(src.m_Front), m_Back(src.m_Back), m_Count(src.m_Count)"
  },
  {
    "label": "PushBack()",
    "kind": "Method",
    "detail": "Function (m_Front = src . m_Front ; m_Back = src . m_Back ; m_Count = src . m_Count ; src . m_Front = src . m_Back = VMA_NULL ; src . m_Count = 0 ; } return* this ; } template<ItemTypeTraits> void VmaIntrusiveLinkedList<ItemTypeTraits)",
    "insertText": "PushBack(ItemType* item)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(ItemTypeTraits::GetPrev(item) == VMA_NULL && ItemTypeTraits::GetNext(item) == VMA_NULL)"
  },
  {
    "label": "AccessPrev()",
    "kind": "Method",
    "detail": "Function (m_Front = item ; m_Back = item ; m_Count = 1 ; } else {)",
    "insertText": "AccessPrev(item)"
  },
  {
    "label": "AccessNext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessNext(m_Back)"
  },
  {
    "label": "AccessNext()",
    "kind": "Method",
    "detail": "Function (m_Front = item ; m_Back = item ; m_Count = 1 ; } else {)",
    "insertText": "AccessNext(item)"
  },
  {
    "label": "AccessPrev()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessPrev(m_Front)"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (ItemType* const backItem = m_Back ; ItemType* const prevItem =)",
    "insertText": "GetPrev(backItem)"
  },
  {
    "label": "AccessNext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessNext(prevItem)"
  },
  {
    "label": "AccessPrev()",
    "kind": "Method",
    "detail": "Function (} m_Back = prevItem ; - - m_Count ;)",
    "insertText": "AccessPrev(backItem)"
  },
  {
    "label": "AccessNext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessNext(backItem)"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (ItemType* const frontItem = m_Front ; ItemType* const nextItem =)",
    "insertText": "GetNext(frontItem)"
  },
  {
    "label": "AccessPrev()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessPrev(nextItem)"
  },
  {
    "label": "AccessPrev()",
    "kind": "Method",
    "detail": "Function (} m_Front = nextItem ; - - m_Count ;)",
    "insertText": "AccessPrev(frontItem)"
  },
  {
    "label": "AccessNext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessNext(frontItem)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(newItem != VMA_NULL && ItemTypeTraits::GetPrev(newItem) == VMA_NULL && ItemTypeTraits::GetNext(newItem) == VMA_NULL)"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (ItemType* const prevItem =)",
    "insertText": "GetPrev(existingItem)"
  },
  {
    "label": "AccessPrev()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessPrev(newItem)"
  },
  {
    "label": "AccessNext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessNext(newItem)"
  },
  {
    "label": "AccessPrev()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessPrev(existingItem)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "VMA_HEAVY_ASSERT(m_Front == existingItem)"
  },
  {
    "label": "PushBack()",
    "kind": "Method",
    "detail": "Function (m_Front = newItem ; } + + m_Count ; } else)",
    "insertText": "PushBack(newItem)"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (ItemType* const nextItem =)",
    "insertText": "GetNext(existingItem)"
  },
  {
    "label": "AccessNext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessNext(existingItem)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "VMA_HEAVY_ASSERT(m_Back == existingItem)"
  },
  {
    "label": "PushFront()",
    "kind": "Method",
    "detail": "Function (m_Back = newItem ; } + + m_Count ; } else return)",
    "insertText": "PushFront(newItem)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(item != VMA_NULL && m_Count > 0)"
  },
  {
    "label": "AccessNext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessNext(ItemTypeTraits::AccessPrev(item)) = ItemTypeTraits::GetNext(item)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "VMA_HEAVY_ASSERT(m_Front == item)"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (m_Front =)",
    "insertText": "GetNext(item)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ItemTypeTraits::GetNext(item) != VMA_NULL)"
  },
  {
    "label": "AccessPrev()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AccessPrev(ItemTypeTraits::AccessNext(item)) = ItemTypeTraits::GetPrev(item)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "VMA_HEAVY_ASSERT(m_Back == item)"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (m_Back =)",
    "insertText": "GetPrev(item)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (ItemType* item = m_Back ;)",
    "insertText": "while(item != VMA_NULL)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (item = prevItem ; } m_Front = VMA_NULL ; m_Back = VMA_NULL ; m_Count = 0 ; } } # endif # endif # if !)",
    "insertText": "defined(_VMA_STRING_BUILDER)"
  },
  {
    "label": "VmaStringBuilder()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "VmaStringBuilder(const VkAllocationCallbacks* allocationCallbacks) : m_Data(VmaStlAllocator<char>(allocationCallbacks))"
  },
  {
    "label": "VmaStringBuilder()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "VmaStringBuilder()"
  },
  {
    "label": "GetLength()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetLength()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "GetData()"
  },
  {
    "label": "AddNewLine()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddNewLine()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add('\\n')"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Add(char ch)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (m_Data .)",
    "insertText": "push_back(ch)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Add(const char* pStr)"
  },
  {
    "label": "AddNumber()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddNumber(uint32_t num)"
  },
  {
    "label": "AddNumber()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddNumber(uint64_t num)"
  },
  {
    "label": "AddPointer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddPointer(const void* ptr)"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (const size_t strLen =)",
    "insertText": "strlen(pStr)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_Data .)",
    "insertText": "resize(oldCount + strLen)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(m_Data.data() + oldCount, pStr, strLen)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (char buf [ 1 1 ] ; buf [ 1 0 ] = ' \\ 0 ' ; char* p =& buf [ 1 0 ] ; do {* - -)",
    "insertText": "p(char)(num % 10)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (num / = 1 0 ; })",
    "insertText": "while(num)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(p)"
  },
  {
    "label": "VmaPtrToStr()",
    "kind": "Method",
    "detail": "Function (char buf [ 2 1 ] ;)",
    "insertText": "VmaPtrToStr(buf, sizeof(buf), ptr)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(buf)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # endif # endif # if !)",
    "insertText": "defined(_VMA_JSON_WRITER)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaJsonWriter) public: VmaJsonWriter(const VkAllocationCallbacks* pAllocationCallbacks, VmaStringBuilder& sb)"
  },
  {
    "label": "VmaJsonWriter()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaJsonWriter()"
  },
  {
    "label": "BeginObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginObject(bool singleLine = false)"
  },
  {
    "label": "EndObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndObject()"
  },
  {
    "label": "BeginArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginArray(bool singleLine = false)"
  },
  {
    "label": "EndArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndArray()"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteString(const char* pStr)"
  },
  {
    "label": "BeginString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginString(const char* pStr = VMA_NULL)"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ContinueString(const char* pStr)"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ContinueString(uint32_t n)"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ContinueString(uint64_t n)"
  },
  {
    "label": "ContinueString_Pointer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ContinueString_Pointer(const void* ptr)"
  },
  {
    "label": "EndString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndString(const char* pStr = VMA_NULL)"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteNumber(uint32_t n)"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteNumber(uint64_t n)"
  },
  {
    "label": "WriteBool()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteBool(bool b)"
  },
  {
    "label": "WriteNull()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteNull()"
  },
  {
    "label": "BeginValue()",
    "kind": "Method",
    "detail": "Function (private : enum COLLECTION_TYPE { COLLECTION_TYPE_OBJECT,COLLECTION_TYPE_ARRAY,} ; struct StackItem { COLLECTION_TYPE type ; uint32_t valueCount ; bool singleLineMode ; } ; const char* const INDENT ; VmaStringBuilder& m_SB ; VmaVector<StackItem,VmaStlAllocator<StackItem>> m_Stack ; bool m_InsideString ; void)",
    "insertText": "BeginValue(bool isString)"
  },
  {
    "label": "WriteIndent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteIndent(bool oneLess = false)"
  },
  {
    "label": "VmaJsonWriter()",
    "kind": "Method",
    "detail": "Function (} ; const char* const VmaJsonWriter::INDENT = \" \" ; # ifndef _VMA_JSON_WRITER_FUNCTIONS)",
    "insertText": "VmaJsonWriter(const VkAllocationCallbacks* pAllocationCallbacks, VmaStringBuilder& sb) : m_SB(sb), m_Stack(VmaStlAllocator<StackItem>(pAllocationCallbacks)), m_InsideString(false)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!m_InsideString)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_Stack.empty())"
  },
  {
    "label": "BeginObject()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BeginObject(bool singleLine)"
  },
  {
    "label": "BeginValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginValue(false)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add('{')"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (StackItem item ; item . type = COLLECTION_TYPE_OBJECT ; item . valueCount = 0 ; item . singleLineMode = singleLine ; m_Stack .)",
    "insertText": "push_back(item)"
  },
  {
    "label": "WriteIndent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteIndent(true)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add('}')"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!m_Stack.empty() && m_Stack.back().type == COLLECTION_TYPE_OBJECT)"
  },
  {
    "label": "BeginArray()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BeginArray(bool singleLine)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add('[')"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add(']')"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!m_Stack.empty() && m_Stack.back().type == COLLECTION_TYPE_ARRAY)"
  },
  {
    "label": "BeginString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginString(pStr)"
  },
  {
    "label": "EndString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EndString()"
  },
  {
    "label": "BeginString()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BeginString(const char* pStr)"
  },
  {
    "label": "BeginValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeginValue(true)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add('\"')"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_InsideString = true ;)",
    "insertText": "if(pStr != VMA_NULL && pStr[0] != '\\0')"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ContinueString(pStr)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_InsideString)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (char ch = pStr [ i ] ;)",
    "insertText": "if(ch == '\\\\')"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add(\"\\\\\\\\\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ch == '\"')"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add(\"\\\\\\\"\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((uint8_t)ch >= 32)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add(ch)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "switch(ch)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (break ; case ' \\ f ' : m_SB .)",
    "insertText": "Add(\"\\\\f\")"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (break ; case ' \\ n ' : m_SB .)",
    "insertText": "Add(\"\\\\n\")"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (break ; case ' \\ r ' : m_SB .)",
    "insertText": "Add(\"\\\\r\")"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (break ; case ' \\ t ' : m_SB .)",
    "insertText": "Add(\"\\\\t\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (break ; default :)",
    "insertText": "VMA_ASSERT(0 && \"Character not currently supported.\")"
  },
  {
    "label": "AddNumber()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "AddNumber(n)"
  },
  {
    "label": "AddPointer()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "AddPointer(ptr)"
  },
  {
    "label": "EndString()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EndString(const char* pStr)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add(b ? \"true\" : \"false\")"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add(\"null\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(isString)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(currItem.type == COLLECTION_TYPE_OBJECT && currItem.valueCount % 2 != 0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add(\": \")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(currItem.valueCount > 0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add(\", \")"
  },
  {
    "label": "WriteIndent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteIndent()"
  },
  {
    "label": "WriteIndent()",
    "kind": "Method",
    "detail": "Function (} + + currItem . valueCount ; } } void)",
    "insertText": "WriteIndent(bool oneLess)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (- - count ; })",
    "insertText": "for(size_t i = 0; i < count; ++i)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (m_SB .)",
    "insertText": "Add(INDENT)"
  },
  {
    "label": "VmaPrintDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (} } } # endif void)",
    "insertText": "VmaPrintDetailedStatistics(VmaJsonWriter& json, const VmaDetailedStatistics& stat)"
  },
  {
    "label": "BeginObject()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "BeginObject()"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"BlockCount\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(stat.statistics.blockCount)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"BlockBytes\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(stat.statistics.blockBytes)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"AllocationCount\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(stat.statistics.allocationCount)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"AllocationBytes\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(stat.statistics.allocationBytes)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"UnusedRangeCount\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(stat.unusedRangeCount)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"AllocationSizeMin\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(stat.allocationSizeMin)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"AllocationSizeMax\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(stat.allocationSizeMax)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(stat.unusedRangeCount > 1)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"UnusedRangeSizeMin\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(stat.unusedRangeSizeMin)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"UnusedRangeSizeMax\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(stat.unusedRangeSizeMax)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} # endif # ifndef _VMA_MAPPING_HYSTERESIS class VmaMappingHysteresis {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaMappingHysteresis) public: VmaMappingHysteresis()"
  },
  {
    "label": "GetExtraMapping()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "GetExtraMapping()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_MAPPING_HYSTERESIS_ENABLED)",
    "insertText": "if(m_ExtraMapping == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + m_MajorCounter ;)",
    "insertText": "if(m_MajorCounter >= COUNTER_MIN_EXTRA_MAPPING)"
  },
  {
    "label": "PostMinorCounter()",
    "kind": "Method",
    "detail": "Function (m_ExtraMapping = 1 ; m_MajorCounter = 0 ; m_MinorCounter = 0 ; return true ; } } else)",
    "insertText": "PostMinorCounter()"
  },
  {
    "label": "PostUnmap()",
    "kind": "Method",
    "detail": "Function (# endif return false ; } void)",
    "insertText": "PostUnmap()"
  },
  {
    "label": "PostAlloc()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "PostAlloc()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_MAPPING_HYSTERESIS_ENABLED)",
    "insertText": "if(m_ExtraMapping == 1)"
  },
  {
    "label": "PostFree()",
    "kind": "Method",
    "detail": "Function (# endif } bool)",
    "insertText": "PostFree()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + m_MajorCounter ;)",
    "insertText": "if(m_MajorCounter >= COUNTER_MIN_EXTRA_MAPPING && m_MajorCounter > m_MinorCounter + 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + m_MinorCounter ; } else)",
    "insertText": "if(m_MajorCounter > 0)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (- - m_MajorCounter ; - - m_MinorCounter ; } } } ; # endif # ifndef _VMA_DEVICE_MEMORY_BLOCK class VmaDeviceMemoryBlock {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaDeviceMemoryBlock)"
  },
  {
    "label": "VmaDeviceMemoryBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaDeviceMemoryBlock(VmaAllocator hAllocator)"
  },
  {
    "label": "VmaDeviceMemoryBlock()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaDeviceMemoryBlock()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(VmaAllocator hAllocator, VmaPool hParentPool, uint32_t newMemoryTypeIndex, VkDeviceMemory newMemory, VkDeviceSize newSize, uint32_t id, uint32_t algorithm, VkDeviceSize bufferImageGranularity)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy(VmaAllocator allocator)"
  },
  {
    "label": "GetParentPool()",
    "kind": "Method",
    "detail": "Function (VmaPool)",
    "insertText": "GetParentPool()"
  },
  {
    "label": "PostFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PostFree(VmaAllocator hAllocator)"
  },
  {
    "label": "Validate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Validate()"
  },
  {
    "label": "CheckCorruption()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "CheckCorruption(VmaAllocator hAllocator)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "Map(VmaAllocator hAllocator, uint32_t count, void** ppData)"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unmap(VmaAllocator hAllocator, uint32_t count)"
  },
  {
    "label": "WriteMagicValueAfterAllocation()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "WriteMagicValueAfterAllocation(VmaAllocator hAllocator, VkDeviceSize allocOffset, VkDeviceSize allocSize)"
  },
  {
    "label": "ValidateMagicValueAfterAllocation()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "ValidateMagicValueAfterAllocation(VmaAllocator hAllocator, VkDeviceSize allocOffset, VkDeviceSize allocSize)"
  },
  {
    "label": "BindBufferMemory()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "BindBufferMemory(const VmaAllocator hAllocator, const VmaAllocation hAllocation, VkDeviceSize allocationLocalOffset, VkBuffer hBuffer, const void* pNext)"
  },
  {
    "label": "BindImageMemory()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "BindImageMemory(const VmaAllocator hAllocator, const VmaAllocation hAllocation, VkDeviceSize allocationLocalOffset, VkImage hImage, const void* pNext)"
  },
  {
    "label": "VmaAllocation_T()",
    "kind": "Method",
    "detail": "Function (private : VmaPool m_hParentPool ; uint32_t m_MemoryTypeIndex ; uint32_t m_Id ; VkDeviceMemory m_hMemory ; VMA_MUTEX m_MapAndBindMutex ; VmaMappingHysteresis m_MappingHysteresis ; uint32_t m_MapCount ; void* m_pMappedData ; } ; # endif # ifndef _VMA_ALLOCATION_T struct VmaAllocation_T { struct VmaDedicatedAllocationListItemTraits ; enum FLAGS { FLAG_PERSISTENT_MAP = 0 x01,FLAG_MAPPING_ALLOWED = 0 x02,} ; public : enum ALLOCATION_TYPE { ALLOCATION_TYPE_NONE,ALLOCATION_TYPE_BLOCK,ALLOCATION_TYPE_DEDICATED,} ;)",
    "insertText": "VmaAllocation_T(bool mappingAllowed)"
  },
  {
    "label": "VmaAllocation_T()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaAllocation_T()"
  },
  {
    "label": "InitBlockAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitBlockAllocation(VmaDeviceMemoryBlock* block, VmaAllocHandle allocHandle, VkDeviceSize alignment, VkDeviceSize size, uint32_t memoryTypeIndex, VmaSuballocationType suballocationType, bool mapped)"
  },
  {
    "label": "InitDedicatedAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitDedicatedAllocation(VmaPool hParentPool, uint32_t memoryTypeIndex, VkDeviceMemory hMemory, VmaSuballocationType suballocationType, void* pMappedData, VkDeviceSize size)"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (ALLOCATION_TYPE)",
    "insertText": "GetType()"
  },
  {
    "label": "GetAlignment()",
    "kind": "Method",
    "detail": "Function (} VkDeviceSize)",
    "insertText": "GetAlignment()"
  },
  {
    "label": "GetBlock()",
    "kind": "Method",
    "detail": "Function (} VmaDeviceMemoryBlock*)",
    "insertText": "GetBlock()"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_Type == ALLOCATION_TYPE_BLOCK)"
  },
  {
    "label": "IsMappingAllowed()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsMappingAllowed()"
  },
  {
    "label": "SetUserData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetUserData(VmaAllocator hAllocator, void* pUserData)"
  },
  {
    "label": "SetName()",
    "kind": "Method",
    "detail": "Function (m_pUserData = pUserData ; } void)",
    "insertText": "SetName(VmaAllocator hAllocator, const char* pName)"
  },
  {
    "label": "FreeName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeName(VmaAllocator hAllocator)"
  },
  {
    "label": "SwapBlockAllocation()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "SwapBlockAllocation(VmaAllocator hAllocator, VmaAllocation allocation)"
  },
  {
    "label": "GetAllocHandle()",
    "kind": "Method",
    "detail": "Function (VmaAllocHandle)",
    "insertText": "GetAllocHandle()"
  },
  {
    "label": "GetOffset()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize)",
    "insertText": "GetOffset()"
  },
  {
    "label": "GetMemory()",
    "kind": "Method",
    "detail": "Function (VkDeviceMemory)",
    "insertText": "GetMemory()"
  },
  {
    "label": "GetMappedData()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "GetMappedData()"
  },
  {
    "label": "BlockAllocMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BlockAllocMap()"
  },
  {
    "label": "BlockAllocUnmap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BlockAllocUnmap()"
  },
  {
    "label": "DedicatedAllocMap()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "DedicatedAllocMap(VmaAllocator hAllocator, void** ppData)"
  },
  {
    "label": "DedicatedAllocUnmap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DedicatedAllocUnmap(VmaAllocator hAllocator)"
  },
  {
    "label": "GetBufferImageUsage()",
    "kind": "Method",
    "detail": "Function (# if VMA_STATS_STRING_ENABLED VmaBufferImageUsage)",
    "insertText": "GetBufferImageUsage()"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_BufferImageUsage == VmaBufferImageUsage::UNKNOWN)"
  },
  {
    "label": "VmaBufferImageUsage()",
    "kind": "Method",
    "detail": "Function (m_BufferImageUsage =)",
    "insertText": "VmaBufferImageUsage(createInfo, useKhrMaintenance5)"
  },
  {
    "label": "InitImageUsage()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitImageUsage(const VkImageCreateInfo &createInfo)"
  },
  {
    "label": "VmaBufferImageUsage()",
    "kind": "Method",
    "detail": "Function (m_BufferImageUsage =)",
    "insertText": "VmaBufferImageUsage(createInfo)"
  },
  {
    "label": "PrintParameters()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PrintParameters(class VmaJsonWriter& json)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(item->GetType() == VmaAllocation_T::ALLOCATION_TYPE_DEDICATED)"
  },
  {
    "label": "VmaDedicatedAllocationList()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "VmaDedicatedAllocationList()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(bool useMutex)"
  },
  {
    "label": "AddDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddDetailedStatistics(VmaDetailedStatistics& inoutStats)"
  },
  {
    "label": "AddStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddStatistics(VmaStatistics& inoutStats)"
  },
  {
    "label": "BuildStatsString()",
    "kind": "Method",
    "detail": "Function (# if VMA_STATS_STRING_ENABLED void)",
    "insertText": "BuildStatsString(VmaJsonWriter& json)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (# endif bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Register()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Register(VmaAllocation alloc)"
  },
  {
    "label": "Unregister()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unregister(VmaAllocation alloc)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(Validate())"
  },
  {
    "label": "VMA_ASSERT_LEAK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT_LEAK(false && \"Unfreed dedicated allocations found!\")"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (size_t actualCount = 0 ; VmaMutexLockRead)",
    "insertText": "lock(m_Mutex, m_UseMutex)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (+ + actualCount ; })",
    "insertText": "VMA_VALIDATE(actualCount == declaredCount)"
  },
  {
    "label": "GetSize()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize size = item ->)",
    "insertText": "GetSize()"
  },
  {
    "label": "VmaAddDetailedStatisticsAllocation()",
    "kind": "Method",
    "detail": "Function (inoutStats . statistics . blockCount + + ; inoutStats . statistics . blockBytes + = size ;)",
    "insertText": "VmaAddDetailedStatisticsAllocation(inoutStats, item->GetSize())"
  },
  {
    "label": "allocCount()",
    "kind": "Method",
    "detail": "Function (const uint32_t)",
    "insertText": "allocCount(uint32_t)m_AllocationList.GetCount()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (inoutStats . blockCount + = allocCount ; inoutStats . allocationCount + = allocCount ;)",
    "insertText": "for(auto* item = m_AllocationList.Front(); item != VMA_NULL; item = DedicatedAllocationLinkedList::GetNext(item))"
  },
  {
    "label": "BeginArray()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "BeginArray()"
  },
  {
    "label": "BeginObject()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "BeginObject(true)"
  },
  {
    "label": "PrintParameters()",
    "kind": "Method",
    "detail": "Function (alloc ->)",
    "insertText": "PrintParameters(json)"
  },
  {
    "label": "PushBack()",
    "kind": "Method",
    "detail": "Function (m_AllocationList .)",
    "insertText": "PushBack(alloc)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (m_AllocationList .)",
    "insertText": "Remove(alloc)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif # endif # ifndef _VMA_SUBALLOCATION struct VmaSuballocation { VkDeviceSize offset ; VkDeviceSize size ; void* userData ; VmaSuballocationType type ; } ; struct VmaSuballocationOffsetLess { bool)",
    "insertText": "operator()(const VmaSuballocation& lhs, const VmaSuballocation& rhs)"
  },
  {
    "label": "VmaBlockMetadata()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaBlockMetadata()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(VkDeviceSize size)"
  },
  {
    "label": "IsVirtual()",
    "kind": "Method",
    "detail": "Function (m_Size = size ; } bool)",
    "insertText": "IsVirtual()"
  },
  {
    "label": "GetAllocationCount()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetAllocationCount()"
  },
  {
    "label": "GetFreeRegionsCount()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetFreeRegionsCount()"
  },
  {
    "label": "GetSumFreeSize()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize)",
    "insertText": "GetSumFreeSize()"
  },
  {
    "label": "GetAllocationInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetAllocationInfo(VmaAllocHandle allocHandle, VmaVirtualAllocationInfo& outInfo)"
  },
  {
    "label": "GetAllocationOffset()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize)",
    "insertText": "GetAllocationOffset(VmaAllocHandle allocHandle)"
  },
  {
    "label": "GetAllocationUserData()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "GetAllocationUserData(VmaAllocHandle allocHandle)"
  },
  {
    "label": "GetAllocationListBegin()",
    "kind": "Method",
    "detail": "Function (VmaAllocHandle)",
    "insertText": "GetAllocationListBegin()"
  },
  {
    "label": "GetNextAllocation()",
    "kind": "Method",
    "detail": "Function (VmaAllocHandle)",
    "insertText": "GetNextAllocation(VmaAllocHandle prevAlloc)"
  },
  {
    "label": "GetNextFreeRegionSize()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize)",
    "insertText": "GetNextFreeRegionSize(VmaAllocHandle alloc)"
  },
  {
    "label": "PrintDetailedMap()",
    "kind": "Method",
    "detail": "Function (# if VMA_STATS_STRING_ENABLED void)",
    "insertText": "PrintDetailedMap(class VmaJsonWriter& json)"
  },
  {
    "label": "CreateAllocationRequest()",
    "kind": "Method",
    "detail": "Function (# endif bool)",
    "insertText": "CreateAllocationRequest(VkDeviceSize allocSize, VkDeviceSize allocAlignment, bool upperAddress, VmaSuballocationType allocType, uint32_t strategy, VmaAllocationRequest* pAllocationRequest)"
  },
  {
    "label": "CheckCorruption()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "CheckCorruption(const void* pBlockData)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Alloc(const VmaAllocationRequest& request, VmaSuballocationType type, void* userData)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(VmaAllocHandle allocHandle)"
  },
  {
    "label": "SetAllocationUserData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAllocationUserData(VmaAllocHandle allocHandle, void* userData)"
  },
  {
    "label": "DebugLogAllAllocations()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DebugLogAllAllocations()"
  },
  {
    "label": "GetAllocationCallbacks()",
    "kind": "Method",
    "detail": "Function (protected : const VkAllocationCallbacks*)",
    "insertText": "GetAllocationCallbacks()"
  },
  {
    "label": "DebugLogAllocation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DebugLogAllocation(VkDeviceSize offset, VkDeviceSize size, void* userData)"
  },
  {
    "label": "PrintDetailedMap_Begin()",
    "kind": "Method",
    "detail": "Function (# if VMA_STATS_STRING_ENABLED void)",
    "insertText": "PrintDetailedMap_Begin(class VmaJsonWriter& json, VkDeviceSize unusedBytes, size_t allocationCount, size_t unusedRangeCount)"
  },
  {
    "label": "PrintDetailedMap_Allocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintDetailedMap_Allocation(class VmaJsonWriter& json, VkDeviceSize offset, VkDeviceSize size, void* userData)"
  },
  {
    "label": "PrintDetailedMap_UnusedRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintDetailedMap_UnusedRange(class VmaJsonWriter& json, VkDeviceSize offset, VkDeviceSize size)"
  },
  {
    "label": "PrintDetailedMap_End()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintDetailedMap_End(class VmaJsonWriter& json)"
  },
  {
    "label": "VmaBlockMetadata()",
    "kind": "Method",
    "detail": "Function (# endif private : VkDeviceSize m_Size ; const VkAllocationCallbacks* m_pAllocationCallbacks ; const VkDeviceSize m_BufferImageGranularity ; const bool m_IsVirtual ; } ; # ifndef _VMA_BLOCK_METADATA_FUNCTIONS)",
    "insertText": "VmaBlockMetadata(const VkAllocationCallbacks* pAllocationCallbacks, VkDeviceSize bufferImageGranularity, bool isVirtual) : m_Size(0), m_pAllocationCallbacks(pAllocationCallbacks), m_BufferImageGranularity(bufferImageGranularity), m_IsVirtual(isVirtual)"
  },
  {
    "label": "VMA_LEAK_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_LEAK_LOG_FORMAT(\"UNFREED VIRTUAL ALLOCATION; Offset: %\" PRIu64 \"; Size: %\" PRIu64 \"; UserData: %p\", offset, size, userData)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "VMA_ASSERT(userData != VMA_NULL)"
  },
  {
    "label": "VmaAllocation()",
    "kind": "Method",
    "detail": "Function (VmaAllocation allocation = reinterpret_cast<)",
    "insertText": "VmaAllocation(userData)"
  },
  {
    "label": "GetUserData()",
    "kind": "Method",
    "detail": "Function (userData = allocation ->)",
    "insertText": "GetUserData()"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (const char* name = allocation ->)",
    "insertText": "GetName()"
  },
  {
    "label": "VMA_LEAK_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (# if VMA_STATS_STRING_ENABLED)",
    "insertText": "VMA_LEAK_LOG_FORMAT(\"UNFREED ALLOCATION; Offset: %\" PRIu64 \"; Size: %\" PRIu64 \"; UserData: %p; Name: %s; Type: %s; Usage: %\" PRIu64, offset, size, userData, name ? name : \"vma_empty\", VMA_SUBALLOCATION_TYPE_NAMES[allocation->GetSuballocationType()], (uint64_t)allocation->GetBufferImageUsage().Value)"
  },
  {
    "label": "VMA_LEAK_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "VMA_LEAK_LOG_FORMAT(\"UNFREED ALLOCATION; Offset: %\" PRIu64 \"; Size: %\" PRIu64 \"; UserData: %p; Name: %s; Type: %u\", offset, size, userData, name ? name : \"vma_empty\", (unsigned)allocation->GetSuballocationType())"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"TotalBytes\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(GetSize())"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"UnusedBytes\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(unusedBytes)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Allocations\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber((uint64_t)allocationCount)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"UnusedRanges\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber((uint64_t)unusedRangeCount)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Suballocations\")"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Offset\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(offset)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Size\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(size)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"CustomData\")"
  },
  {
    "label": "BeginString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "BeginString()"
  },
  {
    "label": "ContinueString_Pointer()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString_Pointer(userData)"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "else((VmaAllocation)userData)->PrintParameters(json)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Type\")"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(VMA_SUBALLOCATION_TYPE_NAMES[VMA_SUBALLOCATION_TYPE_FREE])"
  },
  {
    "label": "VmaBlockBufferImageGranularity()",
    "kind": "Method",
    "detail": "Function (} # endif # endif # endif # ifndef _VMA_BLOCK_BUFFER_IMAGE_GRANULARITY class VmaBlockBufferImageGranularity final { public : struct ValidationContext { const VkAllocationCallbacks* allocCallbacks ; uint16_t* pageAllocs ; } ;)",
    "insertText": "VmaBlockBufferImageGranularity(VkDeviceSize bufferImageGranularity)"
  },
  {
    "label": "VmaBlockBufferImageGranularity()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaBlockBufferImageGranularity()"
  },
  {
    "label": "IsEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEnabled()"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy(const VkAllocationCallbacks* pAllocationCallbacks)"
  },
  {
    "label": "RoundupAllocRequest()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RoundupAllocRequest(VmaSuballocationType allocType, VkDeviceSize& inOutAllocSize, VkDeviceSize& inOutAllocAlignment)"
  },
  {
    "label": "CheckConflictAndAlignUp()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CheckConflictAndAlignUp(VkDeviceSize& inOutAllocOffset, VkDeviceSize allocSize, VkDeviceSize blockOffset, VkDeviceSize blockSize, VmaSuballocationType allocType)"
  },
  {
    "label": "AllocPages()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AllocPages(uint8_t allocType, VkDeviceSize offset, VkDeviceSize size)"
  },
  {
    "label": "FreePages()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreePages(VkDeviceSize offset, VkDeviceSize size)"
  },
  {
    "label": "StartValidation()",
    "kind": "Method",
    "detail": "Function (ValidationContext)",
    "insertText": "StartValidation(const VkAllocationCallbacks* pAllocationCallbacks, bool isVirutal)"
  },
  {
    "label": "Validate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Validate(ValidationContext& ctx, VkDeviceSize offset, VkDeviceSize size)"
  },
  {
    "label": "FinishValidation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FinishValidation(ValidationContext& ctx)"
  },
  {
    "label": "GetStartPage()",
    "kind": "Method",
    "detail": "Function (private : const uint16_t MAX_LOW_BUFFER_IMAGE_GRANULARITY = 2 5 6 ; struct RegionInfo { uint8_t allocType ; uint16_t allocCount ; } ; VkDeviceSize m_BufferImageGranularity ; uint32_t m_RegionCount ; RegionInfo* m_RegionInfo ; uint32_t)",
    "insertText": "GetStartPage(VkDeviceSize offset)"
  },
  {
    "label": "GetEndPage()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "GetEndPage(VkDeviceSize offset, VkDeviceSize size)"
  },
  {
    "label": "OffsetToPageIndex()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "OffsetToPageIndex(VkDeviceSize offset)"
  },
  {
    "label": "AllocPage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AllocPage(RegionInfo& page, uint8_t allocType)"
  },
  {
    "label": "VmaBlockBufferImageGranularity()",
    "kind": "Method",
    "detail": "Function (} ; # ifndef _VMA_BLOCK_BUFFER_IMAGE_GRANULARITY_FUNCTIONS)",
    "insertText": "VmaBlockBufferImageGranularity(VkDeviceSize bufferImageGranularity) : m_BufferImageGranularity(bufferImageGranularity), m_RegionCount(0), m_RegionInfo(VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_RegionInfo == VMA_NULL && \"Free not called before destroying object!\")"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Init(const VkAllocationCallbacks* pAllocationCallbacks, VkDeviceSize size)"
  },
  {
    "label": "uint32_t()",
    "kind": "Method",
    "detail": "Function (m_RegionCount = static_cast<)",
    "insertText": "uint32_t(VmaDivideRoundingUp(size, m_BufferImageGranularity))"
  },
  {
    "label": "vma_new_array()",
    "kind": "Method",
    "detail": "Function (m_RegionInfo =)",
    "insertText": "vma_new_array(pAllocationCallbacks, RegionInfo, m_RegionCount)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(m_RegionInfo, 0, m_RegionCount * sizeof(RegionInfo))"
  },
  {
    "label": "vma_delete_array()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vma_delete_array(pAllocationCallbacks, m_RegionInfo, m_RegionCount)"
  },
  {
    "label": "VMA_MAX()",
    "kind": "Method",
    "detail": "Function (inOutAllocAlignment =)",
    "insertText": "VMA_MAX(inOutAllocAlignment, m_BufferImageGranularity)"
  },
  {
    "label": "VmaAlignUp()",
    "kind": "Method",
    "detail": "Function (inOutAllocSize =)",
    "insertText": "VmaAlignUp(inOutAllocSize, m_BufferImageGranularity)"
  },
  {
    "label": "GetStartPage()",
    "kind": "Method",
    "detail": "Function (uint32_t startPage =)",
    "insertText": "GetStartPage(inOutAllocOffset)"
  },
  {
    "label": "VmaAlignUp()",
    "kind": "Method",
    "detail": "Function (inOutAllocOffset =)",
    "insertText": "VmaAlignUp(inOutAllocOffset, m_BufferImageGranularity)"
  },
  {
    "label": "GetEndPage()",
    "kind": "Method",
    "detail": "Function (+ + startPage ; } uint32_t endPage =)",
    "insertText": "GetEndPage(inOutAllocOffset, allocSize)"
  },
  {
    "label": "GetStartPage()",
    "kind": "Method",
    "detail": "Function (uint32_t startPage =)",
    "insertText": "GetStartPage(offset)"
  },
  {
    "label": "AllocPage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AllocPage(m_RegionInfo[startPage], allocType)"
  },
  {
    "label": "GetEndPage()",
    "kind": "Method",
    "detail": "Function (uint32_t endPage =)",
    "insertText": "GetEndPage(offset, size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - m_RegionInfo [ startPage ] . allocCount ;)",
    "insertText": "if(m_RegionInfo[startPage].allocCount == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - m_RegionInfo [ endPage ] . allocCount ;)",
    "insertText": "if(m_RegionInfo[endPage].allocCount == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ValidationContext ctx { pAllocationCallbacks,VMA_NULL } ;)",
    "insertText": "if(!isVirutal && IsEnabled())"
  },
  {
    "label": "vma_new_array()",
    "kind": "Method",
    "detail": "Function (ctx . pageAllocs =)",
    "insertText": "vma_new_array(pAllocationCallbacks, uint16_t, m_RegionCount)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(ctx.pageAllocs, 0, m_RegionCount * sizeof(uint16_t))"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (+ + ctx . pageAllocs [ start ] ;)",
    "insertText": "VMA_VALIDATE(m_RegionInfo[start].allocCount > 0)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (+ + ctx . pageAllocs [ end ] ;)",
    "insertText": "VMA_VALIDATE(m_RegionInfo[end].allocCount > 0)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(ctx.pageAllocs != VMA_NULL && \"Validation context not initialized!\")"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(ctx.pageAllocs[page] == m_RegionInfo[page].allocCount)"
  },
  {
    "label": "vma_delete_array()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "vma_delete_array(ctx.allocCallbacks, ctx.pageAllocs, m_RegionCount)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (+ + page . allocCount ; } # endif # endif # ifndef _VMA_BLOCK_METADATA_LINEAR class VmaBlockMetadata_Linear : public VmaBlockMetadata {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaBlockMetadata_Linear) public: VmaBlockMetadata_Linear(const VkAllocationCallbacks* pAllocationCallbacks, VkDeviceSize bufferImageGranularity, bool isVirtual)"
  },
  {
    "label": "VmaBlockMetadata_Linear()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaBlockMetadata_Linear()"
  },
  {
    "label": "AccessSuballocations1st()",
    "kind": "Method",
    "detail": "Function (private : typedef VmaVector<VmaSuballocation,VmaStlAllocator<VmaSuballocation>> SuballocationVectorType ; enum SECOND_VECTOR_MODE { SECOND_VECTOR_EMPTY,SECOND_VECTOR_RING_BUFFER,SECOND_VECTOR_DOUBLE_STACK,} ; VkDeviceSize m_SumFreeSize ; SuballocationVectorType m_Suballocations0,m_Suballocations1 ; uint32_t m_1stVectorIndex ; SECOND_VECTOR_MODE m_2ndVectorMode ; size_t m_1stNullItemsBeginCount ; size_t m_1stNullItemsMiddleCount ; size_t m_2ndNullItemsCount ; SuballocationVectorType&)",
    "insertText": "AccessSuballocations1st()"
  },
  {
    "label": "ShouldCompact1st()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldCompact1st()"
  },
  {
    "label": "CleanupAfterFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CleanupAfterFree()"
  },
  {
    "label": "CreateAllocationRequest_LowerAddress()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CreateAllocationRequest_LowerAddress(VkDeviceSize allocSize, VkDeviceSize allocAlignment, VmaSuballocationType allocType, uint32_t strategy, VmaAllocationRequest* pAllocationRequest)"
  },
  {
    "label": "CreateAllocationRequest_UpperAddress()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CreateAllocationRequest_UpperAddress(VkDeviceSize allocSize, VkDeviceSize allocAlignment, VmaSuballocationType allocType, uint32_t strategy, VmaAllocationRequest* pAllocationRequest)"
  },
  {
    "label": "VmaBlockMetadata_Linear()",
    "kind": "Method",
    "detail": "Function (} ; # ifndef _VMA_BLOCK_METADATA_LINEAR_FUNCTIONS)",
    "insertText": "VmaBlockMetadata_Linear(const VkAllocationCallbacks* pAllocationCallbacks, VkDeviceSize bufferImageGranularity, bool isVirtual) : VmaBlockMetadata(pAllocationCallbacks, bufferImageGranularity, isVirtual), m_SumFreeSize(0), m_Suballocations0(VmaStlAllocator<VmaSuballocation>(pAllocationCallbacks)), m_Suballocations1(VmaStlAllocator<VmaSuballocation>(pAllocationCallbacks)), m_1stVectorIndex(0), m_2ndVectorMode(SECOND_VECTOR_EMPTY), m_1stNullItemsBeginCount(0), m_1stNullItemsMiddleCount(0), m_2ndNullItemsCount(0)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(size)"
  },
  {
    "label": "AccessSuballocations2nd()",
    "kind": "Method",
    "detail": "Function (const SuballocationVectorType& suballocations2nd =)",
    "insertText": "AccessSuballocations2nd()"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(suballocations2nd.empty() == (m_2ndVectorMode == SECOND_VECTOR_EMPTY))"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(!suballocations1st.empty() || suballocations2nd.empty() || m_2ndVectorMode != SECOND_VECTOR_RING_BUFFER)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(suballocations1st[m_1stNullItemsBeginCount].type != VMA_SUBALLOCATION_TYPE_FREE)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(suballocations1st.back().type != VMA_SUBALLOCATION_TYPE_FREE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!suballocations2nd.empty())"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(suballocations2nd.back().type != VMA_SUBALLOCATION_TYPE_FREE)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VMA_VALIDATE(m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount <= suballocations1st.size())"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(m_2ndNullItemsCount <= suballocations2nd.size())"
  },
  {
    "label": "GetDebugMargin()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize debugMargin =)",
    "insertText": "GetDebugMargin()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize offset = 0 ;)",
    "insertText": "if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t nullItem2ndCount = 0 ;)",
    "insertText": "for(size_t i = 0; i < suballoc2ndCount; ++i)"
  },
  {
    "label": "currFree()",
    "kind": "Method",
    "detail": "Function (const VmaSuballocation& suballoc = suballocations2nd [ i ] ; const bool)",
    "insertText": "currFree(suballoc.type == VMA_SUBALLOCATION_TYPE_FREE)"
  },
  {
    "label": "alloc()",
    "kind": "Method",
    "detail": "Function (VmaAllocation const)",
    "insertText": "alloc(VmaAllocation)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(currFree == (alloc == VK_NULL_HANDLE))"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VMA_VALIDATE(suballoc.offset >= offset)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE((VkDeviceSize)alloc->GetAllocHandle() == suballoc.offset + 1)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(alloc->GetSize() == suballoc.size)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (} sumUsedSize + = suballoc . size ; } else { + + nullItem2ndCount ; } offset = suballoc . offset + suballoc . size + debugMargin ; })",
    "insertText": "VMA_VALIDATE(nullItem2ndCount == m_2ndNullItemsCount)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(size_t i = 0; i < m_1stNullItemsBeginCount; ++i)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (const VmaSuballocation& suballoc = suballocations1st [ i ] ;)",
    "insertText": "VMA_VALIDATE(suballoc.type == VMA_SUBALLOCATION_TYPE_FREE && suballoc.userData == VMA_NULL)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} size_t nullItem1stCount = m_1stNullItemsBeginCount ;)",
    "insertText": "for(size_t i = m_1stNullItemsBeginCount; i < suballoc1stCount; ++i)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(i >= m_1stNullItemsBeginCount || currFree)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (} sumUsedSize + = suballoc . size ; } else { + + nullItem1stCount ; } offset = suballoc . offset + suballoc . size + debugMargin ; })",
    "insertText": "VMA_VALIDATE(nullItem1stCount == m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t nullItem2ndCount = 0 ;)",
    "insertText": "for(size_t i = suballoc2ndCount; i--;)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VMA_VALIDATE(offset <= GetSize())"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(m_SumFreeSize == GetSize() - sumUsedSize)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize freeSpace2ndTo1stEnd = suballocations1st [ m_1stNullItemsBeginCount ] . offset ; size_t nextAlloc2ndIndex = 0 ;)",
    "insertText": "while(lastOffset < freeSpace2ndTo1stEnd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + nextAlloc2ndIndex ; })",
    "insertText": "if(nextAlloc2ndIndex < suballoc2ndCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const VmaSuballocation& suballoc = suballocations2nd [ nextAlloc2ndIndex ] ;)",
    "insertText": "if(lastOffset < suballoc.offset)"
  },
  {
    "label": "VmaAddDetailedStatisticsUnusedRange()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize unusedRangeSize = suballoc . offset - lastOffset ;)",
    "insertText": "VmaAddDetailedStatisticsUnusedRange(inoutStats, unusedRangeSize)"
  },
  {
    "label": "VmaAddDetailedStatisticsAllocation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VmaAddDetailedStatisticsAllocation(inoutStats, suballoc.size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lastOffset = suballoc . offset + suballoc . size ; + + nextAlloc2ndIndex ; } else {)",
    "insertText": "if(lastOffset < freeSpace2ndTo1stEnd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + nextAlloc1stIndex ; })",
    "insertText": "if(nextAlloc1stIndex < suballoc1stCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lastOffset = suballoc . offset + suballoc . size ; + + nextAlloc1stIndex ; } else {)",
    "insertText": "if(lastOffset < freeSpace1stTo2ndEnd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} lastOffset = freeSpace1stTo2ndEnd ; } })",
    "insertText": "if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - nextAlloc2ndIndex ; })",
    "insertText": "if(nextAlloc2ndIndex != SIZE_MAX)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (lastOffset = suballoc . offset + suballoc . size ; - - nextAlloc2ndIndex ; } else {)",
    "insertText": "if(lastOffset < size)"
  },
  {
    "label": "PrintDetailedMap_Begin()",
    "kind": "Method",
    "detail": "Function (+ + unusedRangeCount ; } lastOffset = size ; } } } const VkDeviceSize unusedBytes = size - usedBytes ;)",
    "insertText": "PrintDetailedMap_Begin(json, unusedBytes, alloc1stCount + alloc2ndCount, unusedRangeCount)"
  },
  {
    "label": "PrintDetailedMap_UnusedRange()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize unusedRangeSize = suballoc . offset - lastOffset ;)",
    "insertText": "PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize)"
  },
  {
    "label": "PrintDetailedMap_Allocation()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PrintDetailedMap_Allocation(json, suballoc.offset, suballoc.size, suballoc.userData)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} lastOffset = freeSpace2ndTo1stEnd ; } } } nextAlloc1stIndex = m_1stNullItemsBeginCount ;)",
    "insertText": "while(lastOffset < freeSpace1stTo2ndEnd)"
  },
  {
    "label": "PrintDetailedMap_End()",
    "kind": "Method",
    "detail": "Function (} lastOffset = size ; } } })",
    "insertText": "PrintDetailedMap_End(json)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocSize > 0)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocType != VMA_SUBALLOCATION_TYPE_FREE)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pAllocationRequest != VMA_NULL)"
  },
  {
    "label": "CreateAllocationRequest_UpperAddress()",
    "kind": "Method",
    "detail": "Function (pAllocationRequest -> size = allocSize ; return upperAddress ?)",
    "insertText": "CreateAllocationRequest_UpperAddress(allocSize, allocAlignment, allocType, strategy, pAllocationRequest) : CreateAllocationRequest_LowerAddress( allocSize, allocAlignment, allocType, strategy, pAllocationRequest)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!IsVirtual())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const VmaSuballocation& suballoc = suballocations1st [ i ] ;)",
    "insertText": "if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"MEMORY CORRUPTION DETECTED AFTER VALIDATED ALLOCATION!\")"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize)",
    "insertText": "offset(VkDeviceSize)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (const VmaSuballocation newSuballoc = { offset,request . size,userData,type } ;)",
    "insertText": "switch(request.type)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (suballocations2nd .)",
    "insertText": "push_back(newSuballoc)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(suballocations1st.empty() || offset >= suballocations1st.back().offset + suballocations1st.back().size)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(offset + request.size <= GetSize())"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!suballocations1st.empty() && offset + request.size <= suballocations1st[m_1stNullItemsBeginCount].offset)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (m_2ndVectorMode = SECOND_VECTOR_RING_BUFFER ; break ; case SECOND_VECTOR_RING_BUFFER :)",
    "insertText": "VMA_ASSERT(!suballocations2nd.empty())"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (break ; case SECOND_VECTOR_DOUBLE_STACK :)",
    "insertText": "VMA_ASSERT(0 && \"CRITICAL ERROR: Trying to use linear allocator as ring buffer while it was already used as double stack.\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (} break ; default :)",
    "insertText": "VMA_ASSERT(0 && \"CRITICAL INTERNAL ERROR.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaSuballocation& firstSuballoc = suballocations1st [ m_1stNullItemsBeginCount ] ;)",
    "insertText": "if(firstSuballoc.offset == offset)"
  },
  {
    "label": "VmaBinaryFindSorted()",
    "kind": "Method",
    "detail": "Function (const SuballocationVectorType::iterator it = m_2ndVectorMode = = SECOND_VECTOR_RING_BUFFER ?)",
    "insertText": "VmaBinaryFindSorted(suballocations2nd.begin(), suballocations2nd.end(), refSuballoc, VmaSuballocationOffsetLess()) : VmaBinaryFindSorted(suballocations2nd.begin(), suballocations2nd.end(), refSuballoc, VmaSuballocationOffsetGreater())"
  },
  {
    "label": "FindSuballocation()",
    "kind": "Method",
    "detail": "Function (VmaSuballocation& suballoc =)",
    "insertText": "FindSuballocation(outInfo.offset)"
  },
  {
    "label": "FindSuballocation()",
    "kind": "Method",
    "detail": "Function (VmaSuballocation& suballoc =)",
    "insertText": "FindSuballocation((VkDeviceSize)allocHandle - 1)"
  },
  {
    "label": "FindSuballocation()",
    "kind": "Method",
    "detail": "Function (} VmaSuballocation&)",
    "insertText": "FindSuballocation(VkDeviceSize offset)"
  },
  {
    "label": "VmaBinaryFindSorted()",
    "kind": "Method",
    "detail": "Function (VmaSuballocation refSuballoc ; refSuballoc . offset = offset ; { SuballocationVectorType::const_iterator it =)",
    "insertText": "VmaBinaryFindSorted(suballocations1st.begin() + m_1stNullItemsBeginCount, suballocations1st.end(), refSuballoc, VmaSuballocationOffsetLess())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(m_2ndVectorMode != SECOND_VECTOR_EMPTY)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "VMA_ASSERT(0 && \"Allocation not found in linear allocator!\")"
  },
  {
    "label": "AccessSuballocations1st()",
    "kind": "Method",
    "detail": "Function (const size_t nullItemCount = m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount ; const size_t suballocCount =)",
    "insertText": "AccessSuballocations1st().size()"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (const size_t nullItem1stCount = m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount ;)",
    "insertText": "VMA_ASSERT(nullItem1stCount <= suballoc1stCount)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + m_1stNullItemsBeginCount ; - - m_1stNullItemsMiddleCount ; })",
    "insertText": "while(m_1stNullItemsMiddleCount > 0 && suballocations1st.back().type == VMA_SUBALLOCATION_TYPE_FREE)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(m_2ndNullItemsCount > 0 && suballocations2nd.back().type == VMA_SUBALLOCATION_TYPE_FREE)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(m_2ndNullItemsCount > 0 && suballocations2nd[0].type == VMA_SUBALLOCATION_TYPE_FREE)"
  },
  {
    "label": "VmaVectorRemove()",
    "kind": "Method",
    "detail": "Function (- - m_2ndNullItemsCount ;)",
    "insertText": "VmaVectorRemove(suballocations2nd, 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ShouldCompact1st())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const size_t nonNullItemCount = suballoc1stCount - nullItem1stCount ; size_t srcIndex = m_1stNullItemsBeginCount ;)",
    "insertText": "for(size_t dstIndex = 0; dstIndex < nonNullItemCount; ++dstIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + srcIndex ; })",
    "insertText": "if(dstIndex != srcIndex)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (suballocations1st [ dstIndex ] = suballocations1st [ srcIndex ] ; } + + srcIndex ; } suballocations1st .)",
    "insertText": "resize(nonNullItemCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_1stNullItemsBeginCount = 0 ; m_1stNullItemsMiddleCount = 0 ; })",
    "insertText": "if(suballocations2nd.empty())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_2ndVectorMode = SECOND_VECTOR_EMPTY ; })",
    "insertText": "if(suballocations1st.size() - m_1stNullItemsBeginCount == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_1stNullItemsBeginCount = 0 ;)",
    "insertText": "if(!suballocations2nd.empty() && m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (m_2ndVectorMode = SECOND_VECTOR_EMPTY ; m_1stNullItemsMiddleCount = m_2ndNullItemsCount ;)",
    "insertText": "while(m_1stNullItemsBeginCount < suballocations2nd.size() && suballocations2nd[m_1stNullItemsBeginCount].type == VMA_SUBALLOCATION_TYPE_FREE)"
  },
  {
    "label": "GetBufferImageGranularity()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize bufferImageGranularity =)",
    "insertText": "GetBufferImageGranularity()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize resultBaseOffset = 0 ;)",
    "insertText": "if(!suballocations1st.empty())"
  },
  {
    "label": "VmaAlignUp()",
    "kind": "Method",
    "detail": "Function (resultBaseOffset = lastSuballoc . offset + lastSuballoc . size + debugMargin ; } VkDeviceSize resultOffset = resultBaseOffset ; resultOffset =)",
    "insertText": "VmaAlignUp(resultOffset, allocAlignment)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bufferImageGranularityConflict = false ;)",
    "insertText": "for(size_t prevSuballocIndex = suballocations1st.size(); prevSuballocIndex--;)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const VmaSuballocation& prevSuballoc = suballocations1st [ prevSuballocIndex ] ;)",
    "insertText": "if(VmaBlocksOnSamePage(prevSuballoc.offset, prevSuballoc.size, resultOffset, bufferImageGranularity))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bufferImageGranularityConflict = true ; break ; } } else break ; })",
    "insertText": "if(bufferImageGranularityConflict)"
  },
  {
    "label": "VmaAlignUp()",
    "kind": "Method",
    "detail": "Function (resultOffset =)",
    "insertText": "VmaAlignUp(resultOffset, bufferImageGranularity)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const VmaSuballocation& nextSuballoc = suballocations2nd [ nextSuballocIndex ] ;)",
    "insertText": "if(VmaBlocksOnSamePage(resultOffset, allocSize, nextSuballoc.offset, bufferImageGranularity))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pAllocationRequest -> type = VmaAllocationRequestType::EndOf1st ; return true ; } })",
    "insertText": "if(m_2ndVectorMode == SECOND_VECTOR_EMPTY || m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!suballocations1st.empty())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bufferImageGranularityConflict = false ;)",
    "insertText": "for(size_t prevSuballocIndex = suballocations2nd.size(); prevSuballocIndex--;)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } size_t index1st = m_1stNullItemsBeginCount ;)",
    "insertText": "if((index1st == suballocations1st.size() && resultOffset + allocSize + debugMargin <= blockSize) || (index1st < suballocations1st.size() && resultOffset + allocSize + debugMargin <= suballocations1st[index1st].offset))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"Trying to use pool with linear algorithm as double stack, while it is already being used as ring buffer.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (resultBaseOffset = lastSuballoc . offset - allocSize ;)",
    "insertText": "if(allocSize > lastSuballoc.offset)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bufferImageGranularityConflict = false ;)",
    "insertText": "for(size_t nextSuballocIndex = suballocations2nd.size(); nextSuballocIndex--;)"
  },
  {
    "label": "VmaAlignDown()",
    "kind": "Method",
    "detail": "Function (resultOffset =)",
    "insertText": "VmaAlignDown(resultOffset, bufferImageGranularity)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} } const VkDeviceSize endOf1st = ! suballocations1st .)",
    "insertText": "empty() ? suballocations1st.back().offset + suballocations1st.back()"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (pAllocationRequest -> type = VmaAllocationRequestType::UpperAddress ; return true ; } return false ; } # endif # endif # ifndef _VMA_BLOCK_METADATA_TLSF class VmaBlockMetadata_TLSF : public VmaBlockMetadata {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaBlockMetadata_TLSF) public: VmaBlockMetadata_TLSF(const VkAllocationCallbacks* pAllocationCallbacks, VkDeviceSize bufferImageGranularity, bool isVirtual)"
  },
  {
    "label": "VmaBlockMetadata_TLSF()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaBlockMetadata_TLSF()"
  },
  {
    "label": "MarkFree()",
    "kind": "Method",
    "detail": "Function (private : const uint8_t SECOND_LEVEL_INDEX = 5 ; const uint16_t SMALL_BUFFER_SIZE = 2 5 6 ; const uint32_t INITIAL_BLOCK_ALLOC_COUNT = 1 6 ; const uint8_t MEMORY_CLASS_SHIFT = 7 ; const uint8_t MAX_MEMORY_CLASSES = 6 5 - MEMORY_CLASS_SHIFT ; class Block { public : VkDeviceSize offset ; VkDeviceSize size ; Block* prevPhysical ; Block* nextPhysical ; void)",
    "insertText": "MarkFree()"
  },
  {
    "label": "MarkTaken()",
    "kind": "Method",
    "detail": "Function (prevFree = VMA_NULL ; } void)",
    "insertText": "MarkTaken()"
  },
  {
    "label": "IsFree()",
    "kind": "Method",
    "detail": "Function (prevFree = this ; } bool)",
    "insertText": "IsFree()"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(!IsFree())"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(IsFree())"
  },
  {
    "label": "SizeToSecondIndex()",
    "kind": "Method",
    "detail": "Function (uint16_t)",
    "insertText": "SizeToSecondIndex(VkDeviceSize size, uint8_t memoryClass)"
  },
  {
    "label": "GetListIndex()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "GetListIndex(uint8_t memoryClass, uint16_t secondIndex)"
  },
  {
    "label": "GetListIndex()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "GetListIndex(VkDeviceSize size)"
  },
  {
    "label": "RemoveFreeBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveFreeBlock(Block* block)"
  },
  {
    "label": "InsertFreeBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertFreeBlock(Block* block)"
  },
  {
    "label": "MergeBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MergeBlock(Block* block, Block* prev)"
  },
  {
    "label": "FindFreeBlock()",
    "kind": "Method",
    "detail": "Function (Block*)",
    "insertText": "FindFreeBlock(VkDeviceSize size, uint32_t& listIndex)"
  },
  {
    "label": "CheckBlock()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CheckBlock(Block& block, uint32_t listIndex, VkDeviceSize allocSize, VkDeviceSize allocAlignment, VmaSuballocationType allocType, VmaAllocationRequest* pAllocationRequest)"
  },
  {
    "label": "VmaBlockMetadata_TLSF()",
    "kind": "Method",
    "detail": "Function (} ; # ifndef _VMA_BLOCK_METADATA_TLSF_FUNCTIONS)",
    "insertText": "VmaBlockMetadata_TLSF(const VkAllocationCallbacks* pAllocationCallbacks, VkDeviceSize bufferImageGranularity, bool isVirtual) : VmaBlockMetadata(pAllocationCallbacks, bufferImageGranularity, isVirtual), m_AllocCount(0), m_BlocksFreeCount(0), m_BlocksFreeSize(0), m_IsFreeBitmap(0), m_MemoryClasses(0), m_ListsCount(0), m_FreeList(VMA_NULL), m_BlockAllocator(pAllocationCallbacks, INITIAL_BLOCK_ALLOC_COUNT), m_NullBlock(VMA_NULL), m_GranularityHandler(bufferImageGranularity)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (m_GranularityHandler .)",
    "insertText": "Destroy(GetAllocationCallbacks())"
  },
  {
    "label": "NextFree()",
    "kind": "Method",
    "detail": "Function (m_NullBlock ->)",
    "insertText": "NextFree()"
  },
  {
    "label": "PrevFree()",
    "kind": "Method",
    "detail": "Function (m_NullBlock ->)",
    "insertText": "PrevFree()"
  },
  {
    "label": "SizeToMemoryClass()",
    "kind": "Method",
    "detail": "Function (uint8_t memoryClass =)",
    "insertText": "SizeToMemoryClass(size)"
  },
  {
    "label": "SizeToSecondIndex()",
    "kind": "Method",
    "detail": "Function (uint16_t sli =)",
    "insertText": "SizeToSecondIndex(size, memoryClass)"
  },
  {
    "label": "m_ListsCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_ListsCount(memoryClass == 0 ? 0 : (memoryClass - 1) * (1UL << SECOND_LEVEL_INDEX) + sli)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(m_InnerIsFreeBitmap, 0, MAX_MEMORY_CLASSES * sizeof(uint32_t))"
  },
  {
    "label": "vma_new_array()",
    "kind": "Method",
    "detail": "Function (m_FreeList =)",
    "insertText": "vma_new_array(GetAllocationCallbacks(), Block*, m_ListsCount)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(m_FreeList, 0, m_ListsCount * sizeof(Block*))"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(GetSumFreeSize() <= GetSize())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize calculatedSize = m_NullBlock -> size ; VkDeviceSize calculatedFreeSize = m_NullBlock -> size ; size_t allocCount = 0 ; size_t freeCount = 0 ;)",
    "insertText": "for(uint32_t list = 0; list < m_ListsCount; ++list)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Block* block = m_FreeList [ list ] ;)",
    "insertText": "if(block != VMA_NULL)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(block->IsFree())"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(block->PrevFree() == VMA_NULL)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(block->NextFree()->IsFree())"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(block->NextFree()->PrevFree() == block)"
  },
  {
    "label": "StartValidation()",
    "kind": "Method",
    "detail": "Function (} } } VkDeviceSize nextOffset = m_NullBlock -> offset ; auto validateCtx = m_GranularityHandler .)",
    "insertText": "StartValidation(GetAllocationCallbacks(), IsVirtual())"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(m_NullBlock->nextPhysical == VMA_NULL)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(m_NullBlock->prevPhysical->nextPhysical == m_NullBlock)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Block* prev = m_NullBlock->prevPhysical; prev != VMA_NULL; prev = prev->prevPhysical)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(prev->offset + prev->size == nextOffset)"
  },
  {
    "label": "GetListIndex()",
    "kind": "Method",
    "detail": "Function (nextOffset = prev -> offset ; calculatedSize + = prev -> size ; uint32_t listIndex =)",
    "insertText": "GetListIndex(prev->size)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (+ + freeCount ; Block* freeBlock = m_FreeList [ listIndex ] ;)",
    "insertText": "VMA_VALIDATE(freeBlock != VMA_NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool found = false ; do {)",
    "insertText": "if(freeBlock == prev)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(!found && freeBlock != VMA_NULL)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(found)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (calculatedFreeSize + = prev -> size ; } else { + + allocCount ; Block* freeBlock = m_FreeList [ listIndex ] ;)",
    "insertText": "while(freeBlock)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(freeBlock != prev)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!IsVirtual())"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(m_GranularityHandler.Validate(validateCtx, prev->offset, prev->size))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(prev->prevPhysical)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(prev->prevPhysical->nextPhysical == prev)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(m_GranularityHandler.FinishValidation(validateCtx))"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VMA_VALIDATE(nextOffset == 0)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(calculatedSize == GetSize())"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(calculatedFreeSize == GetSumFreeSize())"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(allocCount == m_AllocCount)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE(freeCount == m_BlocksFreeCount)"
  },
  {
    "label": "allocationCount()",
    "kind": "Method",
    "detail": "Function (inoutStats . blockCount + + ; inoutStats .)",
    "insertText": "allocationCount(uint32_t)"
  },
  {
    "label": "GetSize()",
    "kind": "Method",
    "detail": "Function (inoutStats . allocationBytes + =)",
    "insertText": "GetSize() - GetSumFreeSize()"
  },
  {
    "label": "allocator()",
    "kind": "Method",
    "detail": "Function (size_t blockCount = m_AllocCount + m_BlocksFreeCount ; VmaStlAllocator<Block*>)",
    "insertText": "allocator(GetAllocationCallbacks())"
  },
  {
    "label": "blockList()",
    "kind": "Method",
    "detail": "Function (VmaVector<Block*,VmaStlAllocator<Block*>>)",
    "insertText": "blockList(blockCount, allocator)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t i = blockCount ;)",
    "insertText": "for(Block* block = m_NullBlock->prevPhysical; block != VMA_NULL; block = block->prevPhysical)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (blockList [ - - i ] = block ; })",
    "insertText": "VMA_ASSERT(i == 0)"
  },
  {
    "label": "VmaClearDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (VmaDetailedStatistics stats ;)",
    "insertText": "VmaClearDetailedStatistics(stats)"
  },
  {
    "label": "AddDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddDetailedStatistics(stats)"
  },
  {
    "label": "PrintDetailedMap_Begin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintDetailedMap_Begin(json, stats.statistics.blockBytes - stats.statistics.allocationBytes, stats.statistics.allocationCount, stats.unusedRangeCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Block* block = blockList [ i ] ;)",
    "insertText": "if(block->IsFree()) PrintDetailedMap_UnusedRange(json, block->offset, block->size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_NullBlock->size > 0) PrintDetailedMap_UnusedRange(json, m_NullBlock->offset, m_NullBlock->size)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocSize > 0 && \"Cannot allocate empty block!\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!upperAddress && \"VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT can be used only with linear algorithm.\")"
  },
  {
    "label": "VkDeviceSize()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize sizeForNextList = allocSize ; VkDeviceSize smallSizeStep =)",
    "insertText": "VkDeviceSize(SMALL_BUFFER_SIZE / (IsVirtual() ? 1 << SECOND_LEVEL_INDEX : 4))"
  },
  {
    "label": "sizeForNextList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sizeForNextList(1ULL << (VMA_BITSCAN_MSB(allocSize) - SECOND_LEVEL_INDEX))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(allocSize > SMALL_BUFFER_SIZE - smallSizeStep)"
  },
  {
    "label": "FindFreeBlock()",
    "kind": "Method",
    "detail": "Function (nextListBlock =)",
    "insertText": "FindFreeBlock(sizeForNextList, nextListIndex)"
  },
  {
    "label": "FindFreeBlock()",
    "kind": "Method",
    "detail": "Function (} prevListBlock =)",
    "insertText": "FindFreeBlock(allocSize, prevListIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(strategy & VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(CheckBlock(*m_NullBlock, m_ListsCount, allocSize, allocAlignment, allocType, pAllocationRequest))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(strategy & VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT)"
  },
  {
    "label": "blockList()",
    "kind": "Method",
    "detail": "Function (VmaVector<Block*,VmaStlAllocator<Block*>>)",
    "insertText": "blockList(m_BlocksFreeCount, allocator)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(; i < m_BlocksFreeCount; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Block& block =* blockList [ i ] ;)",
    "insertText": "if(CheckBlock(block, GetListIndex(block.size), allocSize, allocAlignment, allocType, pAllocationRequest))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "while(++nextListIndex < m_ListsCount)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (nextListBlock = m_FreeList [ nextListIndex ] ;)",
    "insertText": "while(nextListBlock)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(request.type == VmaAllocationRequestType::TLSF)"
  },
  {
    "label": "currentBlock()",
    "kind": "Method",
    "detail": "Function (Block*)",
    "insertText": "currentBlock(Block*)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize offset = request . algorithmData ;)",
    "insertText": "VMA_ASSERT(currentBlock != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(currentBlock->offset <= offset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize misssingAlignment = offset - currentBlock -> offset ;)",
    "insertText": "if(misssingAlignment)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (Block* prevBlock = currentBlock -> prevPhysical ;)",
    "insertText": "VMA_ASSERT(prevBlock != VMA_NULL && \"There should be no missing alignment at offset 0!\")"
  },
  {
    "label": "GetListIndex()",
    "kind": "Method",
    "detail": "Function (uint32_t oldList =)",
    "insertText": "GetListIndex(prevBlock->size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (prevBlock -> size + = misssingAlignment ;)",
    "insertText": "if(oldList != GetListIndex(prevBlock->size))"
  },
  {
    "label": "RemoveFreeBlock()",
    "kind": "Method",
    "detail": "Function (prevBlock -> size - = misssingAlignment ;)",
    "insertText": "RemoveFreeBlock(prevBlock)"
  },
  {
    "label": "InsertFreeBlock()",
    "kind": "Method",
    "detail": "Function (prevBlock -> size + = misssingAlignment ;)",
    "insertText": "InsertFreeBlock(prevBlock)"
  },
  {
    "label": "InsertFreeBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertFreeBlock(newBlock)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} currentBlock -> size - = misssingAlignment ; currentBlock -> offset + = misssingAlignment ; } VkDeviceSize size = request . size + debugMargin ;)",
    "insertText": "if(currentBlock->size == size)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "VMA_ASSERT(currentBlock->size > size && \"Proper block already found, shouldn't find smaller one!\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (newBlock -> size = currentBlock -> size - size ; newBlock -> offset = currentBlock -> offset + size ; newBlock -> prevPhysical = currentBlock ; newBlock -> nextPhysical = currentBlock -> nextPhysical ; currentBlock -> nextPhysical = newBlock ; currentBlock -> size = size ;)",
    "insertText": "if(currentBlock == m_NullBlock)"
  },
  {
    "label": "UserData()",
    "kind": "Method",
    "detail": "Function (} } currentBlock ->)",
    "insertText": "UserData()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!IsVirtual()) m_GranularityHandler.AllocPages((uint8_t)(uintptr_t)request.customData, currentBlock->offset, currentBlock->size)"
  },
  {
    "label": "block()",
    "kind": "Method",
    "detail": "Function (Block*)",
    "insertText": "block(Block*)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (Block* next = block -> nextPhysical ;)",
    "insertText": "VMA_ASSERT(!block->IsFree() && \"Block is already free!\")"
  },
  {
    "label": "RemoveFreeBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveFreeBlock(next)"
  },
  {
    "label": "MergeBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MergeBlock(next, block)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (block = next ; next = next -> nextPhysical ; } Block* prev = block -> prevPhysical ;)",
    "insertText": "if(prev != VMA_NULL && prev->IsFree() && prev->size != debugMargin)"
  },
  {
    "label": "RemoveFreeBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveFreeBlock(prev)"
  },
  {
    "label": "MergeBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MergeBlock(block, prev)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!next->IsFree()) InsertFreeBlock(block)"
  },
  {
    "label": "InsertFreeBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InsertFreeBlock(next)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!block->IsFree() && \"Cannot get allocation info for free block!\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!block->IsFree() && \"Cannot get user data for free block!\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VMA_ASSERT(false && \"If m_AllocCount > 0 then should find any allocation!\")"
  },
  {
    "label": "startBlock()",
    "kind": "Method",
    "detail": "Function (Block*)",
    "insertText": "startBlock(Block*)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!startBlock->IsFree() && \"Incorrect block!\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!block->IsFree() && \"Incorrect block!\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Block* block = m_NullBlock -> prevPhysical ; m_NullBlock -> prevPhysical = VMA_NULL ;)",
    "insertText": "while(block)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (Block* prev = block -> prevPhysical ; m_BlockAllocator .)",
    "insertText": "Free(block)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(m_InnerIsFreeBitmap, 0, m_MemoryClasses * sizeof(uint32_t))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!block->IsFree() && \"Trying to set user data for not allocated block!\")"
  },
  {
    "label": "SizeToMemoryClass()",
    "kind": "Method",
    "detail": "Function (} uint8_t)",
    "insertText": "SizeToMemoryClass(VkDeviceSize size)"
  },
  {
    "label": "uint16_t()",
    "kind": "Method",
    "detail": "Function (} return static_cast<)",
    "insertText": "uint16_t((size >> (memoryClass + MEMORY_CLASS_SHIFT - SECOND_LEVEL_INDEX)) ^ (1U << SECOND_LEVEL_INDEX))"
  },
  {
    "label": "uint32_t()",
    "kind": "Method",
    "detail": "Function (const uint32_t index = static_cast<)",
    "insertText": "uint32_t(memoryClass - 1) * (1 << SECOND_LEVEL_INDEX)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(block != m_NullBlock)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(block->IsFree())"
  },
  {
    "label": "SizeToSecondIndex()",
    "kind": "Method",
    "detail": "Function (uint16_t secondIndex =)",
    "insertText": "SizeToSecondIndex(block->size, memClass)"
  },
  {
    "label": "GetListIndex()",
    "kind": "Method",
    "detail": "Function (uint32_t index =)",
    "insertText": "GetListIndex(memClass, secondIndex)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_FreeList[index] == block)"
  },
  {
    "label": "memClass()",
    "kind": "Method",
    "detail": "Function (m_InnerIsFreeBitmap [)",
    "insertText": "memClass(1U << secondIndex)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!block->IsFree() && \"Cannot insert block twice!\")"
  },
  {
    "label": "SizeToMemoryClass()",
    "kind": "Method",
    "detail": "Function (uint8_t memClass =)",
    "insertText": "SizeToMemoryClass(block->size)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(index < m_ListsCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_FreeList [ index ] = block ;)",
    "insertText": "if(block->NextFree() != VMA_NULL) block->NextFree()->PrevFree()"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(block->prevPhysical == prev && \"Cannot merge separate physical regions!\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(!prev->IsFree() && \"Cannot merge block that belongs to free list!\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (prevPhysical->nextPhysical = block)",
    "insertText": "if(block->prevPhysical)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (m_BlockAllocator .)",
    "insertText": "Free(prev)"
  },
  {
    "label": "memoryClass()",
    "kind": "Method",
    "detail": "Function (uint32_t innerFreeMap = m_InnerIsFreeBitmap [)",
    "insertText": "memoryClass(~0U << SizeToSecondIndex(size, memoryClass))"
  },
  {
    "label": "m_IsFreeBitmap()",
    "kind": "Method",
    "detail": "Function (uint32_t freeMap =)",
    "insertText": "m_IsFreeBitmap(~0UL << (memoryClass + 1))"
  },
  {
    "label": "VMA_BITSCAN_LSB()",
    "kind": "Method",
    "detail": "Function (memoryClass =)",
    "insertText": "VMA_BITSCAN_LSB(freeMap)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (innerFreeMap = m_InnerIsFreeBitmap [ memoryClass ] ;)",
    "insertText": "VMA_ASSERT(innerFreeMap != 0)"
  },
  {
    "label": "GetListIndex()",
    "kind": "Method",
    "detail": "Function (} listIndex =)",
    "insertText": "GetListIndex(memoryClass, VMA_BITSCAN_LSB(innerFreeMap))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_FreeList[listIndex])"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(block.IsFree() && \"Block is already taken!\")"
  },
  {
    "label": "VmaAlignUp()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize alignedOffset =)",
    "insertText": "VmaAlignUp(block.offset, allocAlignment)"
  },
  {
    "label": "allocHandle()",
    "kind": "Method",
    "detail": "Function (pAllocationRequest -> type = VmaAllocationRequestType::TLSF ; pAllocationRequest ->)",
    "insertText": "allocHandle(VmaAllocHandle)"
  },
  {
    "label": "customData()",
    "kind": "Method",
    "detail": "Function (pAllocationRequest ->)",
    "insertText": "customData(void*)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pAllocationRequest -> algorithmData = alignedOffset ;)",
    "insertText": "if(listIndex != m_ListsCount && block.PrevFree())"
  },
  {
    "label": "PrevFree()",
    "kind": "Method",
    "detail": "Function (block .)",
    "insertText": "PrevFree()->NextFree() = block.NextFree()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_FreeList [ listIndex ] =& block ;)",
    "insertText": "if(block.NextFree()) block.NextFree()->PrevFree()"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} return true ; } # endif # endif # ifndef _VMA_BLOCK_VECTOR class VmaBlockVector { struct VmaDefragmentationContext_T ;)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaBlockVector) public: VmaBlockVector( VmaAllocator hAllocator, VmaPool hParentPool, uint32_t memoryTypeIndex, VkDeviceSize preferredBlockSize, size_t minBlockCount, size_t maxBlockCount, VkDeviceSize bufferImageGranularity, bool explicitBlockSize, uint32_t algorithm, float priority, VkDeviceSize minAllocationAlignment, void* pMemoryAllocateNext)"
  },
  {
    "label": "VmaBlockVector()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaBlockVector()"
  },
  {
    "label": "GetAllocator()",
    "kind": "Method",
    "detail": "Function (VmaAllocator)",
    "insertText": "GetAllocator()"
  },
  {
    "label": "GetBlock()",
    "kind": "Method",
    "detail": "Function (} VmaDeviceMemoryBlock*)",
    "insertText": "GetBlock(size_t index)"
  },
  {
    "label": "IsCorruptionDetectionEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsCorruptionDetectionEnabled()"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "Allocate(VkDeviceSize size, VkDeviceSize alignment, const VmaAllocationCreateInfo& createInfo, VmaSuballocationType suballocType, size_t allocationCount, VmaAllocation* pAllocations)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(const VmaAllocation hAllocation)"
  },
  {
    "label": "CheckCorruption()",
    "kind": "Method",
    "detail": "Function (# endif VkResult)",
    "insertText": "CheckCorruption()"
  },
  {
    "label": "SetIncrementalSort()",
    "kind": "Method",
    "detail": "Function (private : const VmaAllocator m_hAllocator ; const VmaPool m_hParentPool ; const uint32_t m_MemoryTypeIndex ; const VkDeviceSize m_PreferredBlockSize ; const size_t m_MinBlockCount ; const size_t m_MaxBlockCount ; const VkDeviceSize m_BufferImageGranularity ; const bool m_ExplicitBlockSize ; const uint32_t m_Algorithm ; const float m_Priority ; const VkDeviceSize m_MinAllocationAlignment ; void* const m_pMemoryAllocateNext ; VMA_RW_MUTEX m_Mutex ; VmaVector<VmaDeviceMemoryBlock*,VmaStlAllocator<VmaDeviceMemoryBlock*>> m_Blocks ; uint32_t m_NextBlockId ; bool m_IncrementalSort = true ; void)",
    "insertText": "SetIncrementalSort(bool val)"
  },
  {
    "label": "CalcMaxBlockSize()",
    "kind": "Method",
    "detail": "Function (m_IncrementalSort = val ; } VkDeviceSize)",
    "insertText": "CalcMaxBlockSize()"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Remove(VmaDeviceMemoryBlock* pBlock)"
  },
  {
    "label": "IncrementallySortBlocks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IncrementallySortBlocks()"
  },
  {
    "label": "SortByFreeSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SortByFreeSize()"
  },
  {
    "label": "AllocatePage()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "AllocatePage(VkDeviceSize size, VkDeviceSize alignment, const VmaAllocationCreateInfo& createInfo, VmaSuballocationType suballocType, VmaAllocation* pAllocation)"
  },
  {
    "label": "AllocateFromBlock()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "AllocateFromBlock(VmaDeviceMemoryBlock* pBlock, VkDeviceSize size, VkDeviceSize alignment, VmaAllocationCreateFlags allocFlags, void* pUserData, VmaSuballocationType suballocType, uint32_t strategy, VmaAllocation* pAllocation)"
  },
  {
    "label": "CommitAllocationRequest()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "CommitAllocationRequest(VmaAllocationRequest& allocRequest, VmaDeviceMemoryBlock* pBlock, VkDeviceSize alignment, VmaAllocationCreateFlags allocFlags, void* pUserData, VmaSuballocationType suballocType, VmaAllocation* pAllocation)"
  },
  {
    "label": "CreateBlock()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "CreateBlock(VkDeviceSize blockSize, size_t* pNewBlockIndex)"
  },
  {
    "label": "HasEmptyBlock()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasEmptyBlock()"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} ; # endif # ifndef _VMA_DEFRAGMENTATION_CONTEXT struct VmaDefragmentationContext_T {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaDefragmentationContext_T) public: VmaDefragmentationContext_T( VmaAllocator hAllocator, const VmaDefragmentationInfo& info)"
  },
  {
    "label": "VmaDefragmentationContext_T()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaDefragmentationContext_T()"
  },
  {
    "label": "GetStats()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetStats(VmaDefragmentationStats& outStats)"
  },
  {
    "label": "DefragmentPassBegin()",
    "kind": "Method",
    "detail": "Function (outStats = m_GlobalStats ; } VkResult)",
    "insertText": "DefragmentPassBegin(VmaDefragmentationPassMoveInfo& moveInfo)"
  },
  {
    "label": "DefragmentPassEnd()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "DefragmentPassEnd(VmaDefragmentationPassMoveInfo& moveInfo)"
  },
  {
    "label": "GetMoveData()",
    "kind": "Method",
    "detail": "Function (private : const uint8_t MAX_ALLOCS_TO_IGNORE = 1 6 ; enum class CounterStatus { Pass,Ignore,End } ; struct FragmentedBlock { uint32_t data ; VmaDeviceMemoryBlock* block ; } ; struct StateBalanced { VkDeviceSize avgFreeSize = 0 ; VkDeviceSize avgAllocSize = UINT64_MAX ; } ; struct StateExtensive { enum class Operation : uint8_t { FindFreeBlockBuffer,FindFreeBlockTexture,FindFreeBlockAll,MoveBuffers,MoveTextures,MoveAll,Cleanup,Done } ; Operation operation = Operation::FindFreeBlockTexture ; size_t firstFreeBlock = SIZE_MAX ; } ; struct MoveAllocationData { VkDeviceSize size ; VkDeviceSize alignment ; VmaSuballocationType type ; VmaAllocationCreateFlags flags ; VmaDefragmentationMove move = { } ; } ; const VkDeviceSize m_MaxPassBytes ; const uint32_t m_MaxPassAllocations ; const PFN_vmaCheckDefragmentationBreakFunction m_BreakCallback ; void* m_BreakCallbackUserData ; VmaStlAllocator<VmaDefragmentationMove> m_MoveAllocator ; VmaVector<VmaDefragmentationMove,VmaStlAllocator<VmaDefragmentationMove>> m_Moves ; uint8_t m_IgnoredAllocs = 0 ; uint32_t m_Algorithm ; uint32_t m_BlockVectorCount ; VmaBlockVector* m_PoolBlockVector ; VmaBlockVector** m_pBlockVectors ; size_t m_ImmovableBlockCount = 0 ; VmaDefragmentationStats m_GlobalStats = { 0 } ; VmaDefragmentationStats m_PassStats = { 0 } ; void* m_AlgorithmState = VMA_NULL ; MoveAllocationData)",
    "insertText": "GetMoveData(VmaAllocHandle handle, VmaBlockMetadata* metadata)"
  },
  {
    "label": "CheckCounters()",
    "kind": "Method",
    "detail": "Function (CounterStatus)",
    "insertText": "CheckCounters(VkDeviceSize bytes)"
  },
  {
    "label": "IncrementCounters()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IncrementCounters(VkDeviceSize bytes)"
  },
  {
    "label": "ReallocWithinBlock()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReallocWithinBlock(VmaBlockVector& vector, VmaDeviceMemoryBlock* block)"
  },
  {
    "label": "AllocInOtherBlock()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AllocInOtherBlock(size_t start, size_t end, MoveAllocationData& data, VmaBlockVector& vector)"
  },
  {
    "label": "ComputeDefragmentation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ComputeDefragmentation(VmaBlockVector& vector, size_t index)"
  },
  {
    "label": "ComputeDefragmentation_Fast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ComputeDefragmentation_Fast(VmaBlockVector& vector)"
  },
  {
    "label": "ComputeDefragmentation_Balanced()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ComputeDefragmentation_Balanced(VmaBlockVector& vector, size_t index, bool update)"
  },
  {
    "label": "ComputeDefragmentation_Full()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ComputeDefragmentation_Full(VmaBlockVector& vector)"
  },
  {
    "label": "ComputeDefragmentation_Extensive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ComputeDefragmentation_Extensive(VmaBlockVector& vector, size_t index)"
  },
  {
    "label": "UpdateVectorStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateVectorStatistics(VmaBlockVector& vector, StateBalanced& state)"
  },
  {
    "label": "MoveDataToFreeBlocks()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MoveDataToFreeBlocks(VmaSuballocationType currentType, VmaBlockVector& vector, size_t firstFreeBlock, bool& texturePresent, bool& bufferPresent, bool& otherPresent)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} ; # endif # ifndef _VMA_POOL_T struct VmaPool_T { struct VmaPoolListItemTraits ;)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaPool_T)"
  },
  {
    "label": "VmaPool_T()",
    "kind": "Method",
    "detail": "Function (VmaDedicatedAllocationList m_DedicatedAllocations ;)",
    "insertText": "VmaPool_T(VmaAllocator hAllocator, const VmaPoolCreateInfo& createInfo, VkDeviceSize preferredBlockSize)"
  },
  {
    "label": "VmaPool_T()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaPool_T()"
  },
  {
    "label": "GetId()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "GetId()"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_Id == 0)"
  },
  {
    "label": "VmaCurrentBudgetData()",
    "kind": "Method",
    "detail": "Function (VMA_ATOMIC_UINT32 m_AllocationCount [ VK_MAX_MEMORY_HEAPS ] ; VMA_ATOMIC_UINT64 m_BlockBytes [ VK_MAX_MEMORY_HEAPS ] ; VMA_ATOMIC_UINT64 m_AllocationBytes [ VK_MAX_MEMORY_HEAPS ] ; # if VMA_MEMORY_BUDGET VMA_ATOMIC_UINT32 m_OperationsSinceBudgetFetch ; VMA_RW_MUTEX m_BudgetMutex ; uint64_t m_VulkanUsage [ VK_MAX_MEMORY_HEAPS ] ; uint64_t m_VulkanBudget [ VK_MAX_MEMORY_HEAPS ] ; uint64_t m_BlockBytesAtBudgetFetch [ VK_MAX_MEMORY_HEAPS ] ; # endif)",
    "insertText": "VmaCurrentBudgetData()"
  },
  {
    "label": "AddAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAllocation(uint32_t heapIndex, VkDeviceSize allocationSize)"
  },
  {
    "label": "RemoveAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAllocation(uint32_t heapIndex, VkDeviceSize allocationSize)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_AllocationBytes[heapIndex] >= allocationSize)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (m_AllocationBytes [ heapIndex ] - = allocationSize ;)",
    "insertText": "VMA_ASSERT(m_AllocationCount[heapIndex] > 0)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (- - m_AllocationCount [ heapIndex ] ; # if VMA_MEMORY_BUDGET + + m_OperationsSinceBudgetFetch ; # endif } # endif # endif # ifndef _VMA_ALLOCATION_OBJECT_ALLOCATOR class VmaAllocationObjectAllocator {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaAllocationObjectAllocator) public: VmaAllocationObjectAllocator(const VkAllocationCallbacks* pAllocationCallbacks) : m_Allocator(pAllocationCallbacks, 1024)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (} template<. . . Types> VmaAllocation)",
    "insertText": "Allocate(Types&&... args)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(VmaAllocation hAlloc)"
  },
  {
    "label": "mutexLock()",
    "kind": "Method",
    "detail": "Function (VmaMutexLock)",
    "insertText": "mutexLock(m_Mutex)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (m_Allocator .)",
    "insertText": "Free(hAlloc)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} # endif # ifndef _VMA_VIRTUAL_BLOCK_T struct VmaVirtualBlock_T {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaVirtualBlock_T)"
  },
  {
    "label": "VmaVirtualBlock_T()",
    "kind": "Method",
    "detail": "Function (const VkAllocationCallbacks m_AllocationCallbacks ;)",
    "insertText": "VmaVirtualBlock_T(const VmaVirtualBlockCreateInfo& createInfo)"
  },
  {
    "label": "VmaVirtualBlock_T()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaVirtualBlock_T()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "Init()"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Free(VmaVirtualAllocation allocation)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (m_Metadata ->)",
    "insertText": "Free((VmaAllocHandle)allocation)"
  },
  {
    "label": "SetAllocationUserData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAllocationUserData(VmaVirtualAllocation allocation, void* userData)"
  },
  {
    "label": "SetAllocationUserData()",
    "kind": "Method",
    "detail": "Function (m_Metadata ->)",
    "insertText": "SetAllocationUserData((VmaAllocHandle)allocation, userData)"
  },
  {
    "label": "GetAllocationInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetAllocationInfo(VmaVirtualAllocation allocation, VmaVirtualAllocationInfo& outInfo)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "Allocate(const VmaVirtualAllocationCreateInfo& createInfo, VmaVirtualAllocation& outAllocation, VkDeviceSize* outOffset)"
  },
  {
    "label": "GetStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetStatistics(VmaStatistics& outStats)"
  },
  {
    "label": "CalculateDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculateDetailedStatistics(VmaDetailedStatistics& outStats)"
  },
  {
    "label": "BuildStatsString()",
    "kind": "Method",
    "detail": "Function (# if VMA_STATS_STRING_ENABLED void)",
    "insertText": "BuildStatsString(bool detailedMap, VmaStringBuilder& sb)"
  },
  {
    "label": "VmaVirtualBlock_T()",
    "kind": "Method",
    "detail": "Function (# endif private : VmaBlockMetadata* m_Metadata ; } ; # ifndef _VMA_VIRTUAL_BLOCK_T_FUNCTIONS)",
    "insertText": "VmaVirtualBlock_T(const VmaVirtualBlockCreateInfo& createInfo) : m_AllocationCallbacksSpecified(createInfo.pAllocationCallbacks != VMA_NULL), m_AllocationCallbacks(createInfo.pAllocationCallbacks != VMA_NULL ? *createInfo.pAllocationCallbacks : VmaEmptyAllocationCallbacks)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (const uint32_t algorithm = createInfo . flags& VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK ;)",
    "insertText": "switch(algorithm)"
  },
  {
    "label": "vma_new()",
    "kind": "Method",
    "detail": "Function (break ; case VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT : m_Metadata =)",
    "insertText": "vma_new(GetAllocationCallbacks(), VmaBlockMetadata_Linear)(VK_NULL_HANDLE, 1, true)"
  },
  {
    "label": "vma_new()",
    "kind": "Method",
    "detail": "Function (m_Metadata =)",
    "insertText": "vma_new(GetAllocationCallbacks(), VmaBlockMetadata_TLSF)(VK_NULL_HANDLE, 1, true)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} m_Metadata ->)",
    "insertText": "Init(createInfo.size)"
  },
  {
    "label": "VMA_ASSERT_LEAK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT_LEAK(m_Metadata->IsEmpty() && \"Some virtual allocations were not freed before destruction of this virtual block!\")"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vma_delete(GetAllocationCallbacks(), m_Metadata)"
  },
  {
    "label": "GetAllocationInfo()",
    "kind": "Method",
    "detail": "Function (m_Metadata ->)",
    "insertText": "GetAllocationInfo((VmaAllocHandle)allocation, outInfo)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaAllocationRequest request = { } ;)",
    "insertText": "if(m_Metadata->CreateAllocationRequest( createInfo.size, VMA_MAX(createInfo.alignment, (VkDeviceSize)1), (createInfo.flags & VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT) != 0, VMA_SUBALLOCATION_TYPE_UNKNOWN, createInfo.flags & VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK, &request))"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (m_Metadata ->)",
    "insertText": "Alloc(request, VMA_SUBALLOCATION_TYPE_UNKNOWN, createInfo.pUserData)"
  },
  {
    "label": "outAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outAllocation(VmaVirtualAllocation)"
  },
  {
    "label": "VmaClearStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaClearStatistics(outStats)"
  },
  {
    "label": "AddStatistics()",
    "kind": "Method",
    "detail": "Function (m_Metadata ->)",
    "insertText": "AddStatistics(outStats)"
  },
  {
    "label": "VmaClearDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaClearDetailedStatistics(outStats)"
  },
  {
    "label": "AddDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (m_Metadata ->)",
    "insertText": "AddDetailedStatistics(outStats)"
  },
  {
    "label": "json()",
    "kind": "Method",
    "detail": "Function (VmaJsonWriter)",
    "insertText": "json(GetAllocationCallbacks(), sb)"
  },
  {
    "label": "CalculateDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (VmaDetailedStatistics stats ;)",
    "insertText": "CalculateDetailedStatistics(stats)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Stats\")"
  },
  {
    "label": "VmaPrintDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaPrintDetailedStatistics(json, stats)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Details\")"
  },
  {
    "label": "PrintDetailedMap()",
    "kind": "Method",
    "detail": "Function (m_Metadata ->)",
    "insertText": "PrintDetailedMap(json)"
  },
  {
    "label": "VMA_CLASS_NO_COPY_NO_MOVE()",
    "kind": "Method",
    "detail": "Function (} # endif # endif # endif struct VmaAllocator_T {)",
    "insertText": "VMA_CLASS_NO_COPY_NO_MOVE(VmaAllocator_T)"
  },
  {
    "label": "VmaAllocator_T()",
    "kind": "Method",
    "detail": "Function (const uint32_t m_VulkanApiVersion ; bool m_UseKhrDedicatedAllocation ; bool m_UseKhrBindMemory2 ; bool m_UseExtMemoryBudget ; bool m_UseAmdDeviceCoherentMemory ; bool m_UseKhrBufferDeviceAddress ; bool m_UseExtMemoryPriority ; bool m_UseKhrMaintenance4 ; bool m_UseKhrMaintenance5 ; const VkDevice m_hDevice ; const VkInstance m_hInstance ; const bool m_AllocationCallbacksSpecified ; const VkAllocationCallbacks m_AllocationCallbacks ; VmaDeviceMemoryCallbacks m_DeviceMemoryCallbacks ; VmaAllocationObjectAllocator m_AllocationObjectAllocator ; uint32_t m_HeapSizeLimitMask ; VkPhysicalDeviceProperties m_PhysicalDeviceProperties ; VkPhysicalDeviceMemoryProperties m_MemProps ; VmaBlockVector* m_pBlockVectors [ VK_MAX_MEMORY_TYPES ] ; VmaDedicatedAllocationList m_DedicatedAllocations [ VK_MAX_MEMORY_TYPES ] ; VmaCurrentBudgetData m_Budget ; VMA_ATOMIC_UINT32 m_DeviceMemoryCount ;)",
    "insertText": "VmaAllocator_T(const VmaAllocatorCreateInfo* pCreateInfo)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "Init(const VmaAllocatorCreateInfo* pCreateInfo)"
  },
  {
    "label": "VmaAllocator_T()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "VmaAllocator_T()"
  },
  {
    "label": "GetMemoryHeapCount()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "GetMemoryHeapCount()"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(memTypeIndex < m_MemProps.memoryTypeCount)"
  },
  {
    "label": "GetMemoryTypeMinAlignment()",
    "kind": "Method",
    "detail": "Function (} VkDeviceSize)",
    "insertText": "GetMemoryTypeMinAlignment(uint32_t memTypeIndex)"
  },
  {
    "label": "IsIntegratedGpu()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsIntegratedGpu()"
  },
  {
    "label": "GetImageMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetImageMemoryRequirements(VkImage hImage, VkMemoryRequirements& memReq, bool& requiresDedicatedAllocation, bool& prefersDedicatedAllocation)"
  },
  {
    "label": "FindMemoryTypeIndex()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "FindMemoryTypeIndex(uint32_t memoryTypeBits, const VmaAllocationCreateInfo* pAllocationCreateInfo, VmaBufferImageUsage bufImgUsage, uint32_t* pMemoryTypeIndex)"
  },
  {
    "label": "AllocateMemory()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "AllocateMemory(const VkMemoryRequirements& vkMemReq, bool requiresDedicatedAllocation, bool prefersDedicatedAllocation, VkBuffer dedicatedBuffer, VkImage dedicatedImage, VmaBufferImageUsage dedicatedBufferImageUsage, const VmaAllocationCreateInfo& createInfo, VmaSuballocationType suballocType, size_t allocationCount, VmaAllocation* pAllocations)"
  },
  {
    "label": "FreeMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeMemory(size_t allocationCount, const VmaAllocation* pAllocations)"
  },
  {
    "label": "CalculateStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculateStatistics(VmaTotalStatistics* pStats)"
  },
  {
    "label": "GetHeapBudgets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetHeapBudgets(VmaBudget* outBudgets, uint32_t firstHeap, uint32_t heapCount)"
  },
  {
    "label": "GetAllocationInfo()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "GetAllocationInfo(VmaAllocation hAllocation, VmaAllocationInfo* pAllocationInfo)"
  },
  {
    "label": "GetAllocationInfo2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetAllocationInfo2(VmaAllocation hAllocation, VmaAllocationInfo2* pAllocationInfo)"
  },
  {
    "label": "CreatePool()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "CreatePool(const VmaPoolCreateInfo* pCreateInfo, VmaPool* pPool)"
  },
  {
    "label": "DestroyPool()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroyPool(VmaPool pool)"
  },
  {
    "label": "GetPoolStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPoolStatistics(VmaPool pool, VmaStatistics* pPoolStats)"
  },
  {
    "label": "CalculatePoolStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculatePoolStatistics(VmaPool pool, VmaDetailedStatistics* pPoolStats)"
  },
  {
    "label": "SetCurrentFrameIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCurrentFrameIndex(uint32_t frameIndex)"
  },
  {
    "label": "GetCurrentFrameIndex()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "GetCurrentFrameIndex()"
  },
  {
    "label": "CheckPoolCorruption()",
    "kind": "Method",
    "detail": "Function (} VkResult)",
    "insertText": "CheckPoolCorruption(VmaPool hPool)"
  },
  {
    "label": "CheckCorruption()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "CheckCorruption(uint32_t memoryTypeBits)"
  },
  {
    "label": "AllocateVulkanMemory()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "AllocateVulkanMemory(const VkMemoryAllocateInfo* pAllocateInfo, VkDeviceMemory* pMemory)"
  },
  {
    "label": "FreeVulkanMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVulkanMemory(uint32_t memoryType, VkDeviceSize size, VkDeviceMemory hMemory)"
  },
  {
    "label": "BindVulkanBuffer()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "BindVulkanBuffer(VkDeviceMemory memory, VkDeviceSize memoryOffset, VkBuffer buffer, const void* pNext)"
  },
  {
    "label": "BindVulkanImage()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "BindVulkanImage(VkDeviceMemory memory, VkDeviceSize memoryOffset, VkImage image, const void* pNext)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "Map(VmaAllocation hAllocation, void** ppData)"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unmap(VmaAllocation hAllocation)"
  },
  {
    "label": "BindBufferMemory()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "BindBufferMemory(VmaAllocation hAllocation, VkDeviceSize allocationLocalOffset, VkBuffer hBuffer, const void* pNext)"
  },
  {
    "label": "BindImageMemory()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "BindImageMemory(VmaAllocation hAllocation, VkDeviceSize allocationLocalOffset, VkImage hImage, const void* pNext)"
  },
  {
    "label": "FlushOrInvalidateAllocation()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "FlushOrInvalidateAllocation(VmaAllocation hAllocation, VkDeviceSize offset, VkDeviceSize size, VMA_CACHE_OPERATION op)"
  },
  {
    "label": "FlushOrInvalidateAllocations()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "FlushOrInvalidateAllocations(uint32_t allocationCount, const VmaAllocation* allocations, const VkDeviceSize* offsets, const VkDeviceSize* sizes, VMA_CACHE_OPERATION op)"
  },
  {
    "label": "CopyMemoryToAllocation()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "CopyMemoryToAllocation(const void* pSrcHostPointer, VmaAllocation dstAllocation, VkDeviceSize dstAllocationLocalOffset, VkDeviceSize size)"
  },
  {
    "label": "CopyAllocationToMemory()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "CopyAllocationToMemory(VmaAllocation srcAllocation, VkDeviceSize srcAllocationLocalOffset, void* pDstHostPointer, VkDeviceSize size)"
  },
  {
    "label": "FillAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FillAllocation(const VmaAllocation hAllocation, uint8_t pattern)"
  },
  {
    "label": "GetGpuDefragmentationMemoryTypeBits()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "GetGpuDefragmentationMemoryTypeBits()"
  },
  {
    "label": "GetExternalMemoryHandleTypeFlags()",
    "kind": "Method",
    "detail": "Function (# if VMA_EXTERNAL_MEMORY VkExternalMemoryHandleTypeFlagsKHR)",
    "insertText": "GetExternalMemoryHandleTypeFlags(uint32_t memTypeIndex)"
  },
  {
    "label": "ImportVulkanFunctions_Static()",
    "kind": "Method",
    "detail": "Function (# if VMA_STATIC_VULKAN_FUNCTIONS = = 1 void)",
    "insertText": "ImportVulkanFunctions_Static()"
  },
  {
    "label": "ImportVulkanFunctions_Custom()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "ImportVulkanFunctions_Custom(const VmaVulkanFunctions* pVulkanFunctions)"
  },
  {
    "label": "ImportVulkanFunctions_Dynamic()",
    "kind": "Method",
    "detail": "Function (# if VMA_DYNAMIC_VULKAN_FUNCTIONS = = 1 void)",
    "insertText": "ImportVulkanFunctions_Dynamic()"
  },
  {
    "label": "ValidateVulkanFunctions()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "ValidateVulkanFunctions()"
  },
  {
    "label": "CalcPreferredBlockSize()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize)",
    "insertText": "CalcPreferredBlockSize(uint32_t memTypeIndex)"
  },
  {
    "label": "AllocateMemoryOfType()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "AllocateMemoryOfType(VmaPool pool, VkDeviceSize size, VkDeviceSize alignment, bool dedicatedPreferred, VkBuffer dedicatedBuffer, VkImage dedicatedImage, VmaBufferImageUsage dedicatedBufferImageUsage, const VmaAllocationCreateInfo& createInfo, uint32_t memTypeIndex, VmaSuballocationType suballocType, VmaDedicatedAllocationList& dedicatedAllocations, VmaBlockVector& blockVector, size_t allocationCount, VmaAllocation* pAllocations)"
  },
  {
    "label": "AllocateDedicatedMemoryPage()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "AllocateDedicatedMemoryPage(VmaPool pool, VkDeviceSize size, VmaSuballocationType suballocType, uint32_t memTypeIndex, const VkMemoryAllocateInfo& allocInfo, bool map, bool isUserDataString, bool isMappingAllowed, void* pUserData, VmaAllocation* pAllocation)"
  },
  {
    "label": "AllocateDedicatedMemory()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "AllocateDedicatedMemory(VmaPool pool, VkDeviceSize size, VmaSuballocationType suballocType, VmaDedicatedAllocationList& dedicatedAllocations, uint32_t memTypeIndex, bool map, bool isUserDataString, bool isMappingAllowed, bool canAliasMemory, void* pUserData, float priority, VkBuffer dedicatedBuffer, VkImage dedicatedImage, VmaBufferImageUsage dedicatedBufferImageUsage, size_t allocationCount, VmaAllocation* pAllocations, const void* pNextChain = VMA_NULL)"
  },
  {
    "label": "FreeDedicatedMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeDedicatedMemory(const VmaAllocation allocation)"
  },
  {
    "label": "CalcMemTypeParams()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "CalcMemTypeParams(VmaAllocationCreateInfo& outCreateInfo, uint32_t memTypeIndex, VkDeviceSize size, size_t allocationCount)"
  },
  {
    "label": "CalcAllocationParams()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "CalcAllocationParams(VmaAllocationCreateInfo& outCreateInfo, bool dedicatedRequired, bool dedicatedPreferred)"
  },
  {
    "label": "CalculateGpuDefragmentationMemoryTypeBits()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "CalculateGpuDefragmentationMemoryTypeBits()"
  },
  {
    "label": "CalculateGlobalMemoryTypeBits()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "CalculateGlobalMemoryTypeBits()"
  },
  {
    "label": "GetFlushOrInvalidateRange()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetFlushOrInvalidateRange(VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size, VkMappedMemoryRange& outRange)"
  },
  {
    "label": "UpdateVulkanBudget()",
    "kind": "Method",
    "detail": "Function (# if VMA_MEMORY_BUDGET void)",
    "insertText": "UpdateVulkanBudget()"
  },
  {
    "label": "VmaMalloc()",
    "kind": "Method",
    "detail": "Function (# endif } ; # ifndef _VMA_MEMORY_FUNCTIONS void*)",
    "insertText": "VmaMalloc(VmaAllocator hAllocator, size_t size, size_t alignment)"
  },
  {
    "label": "VmaFree()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "VmaFree(VmaAllocator hAllocator, void* ptr)"
  },
  {
    "label": "VmaFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaFree(&hAllocator->m_AllocationCallbacks, ptr)"
  },
  {
    "label": "VmaAllocate()",
    "kind": "Method",
    "detail": "Function (} template<T> T*)",
    "insertText": "VmaAllocate(VmaAllocator hAllocator)"
  },
  {
    "label": "VmaAllocateArray()",
    "kind": "Method",
    "detail": "Function (} template<T> T*)",
    "insertText": "VmaAllocateArray(VmaAllocator hAllocator, size_t count)"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "vma_delete(VmaAllocator hAllocator, T* ptr)"
  },
  {
    "label": "VmaFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaFree(hAllocator, ptr)"
  },
  {
    "label": "vma_delete_array()",
    "kind": "Method",
    "detail": "Function (} } template<T> void)",
    "insertText": "vma_delete_array(VmaAllocator hAllocator, T* ptr, size_t count)"
  },
  {
    "label": "VmaDeviceMemoryBlock()",
    "kind": "Method",
    "detail": "Function (} } # endif # ifndef _VMA_DEVICE_MEMORY_BLOCK_FUNCTIONS)",
    "insertText": "VmaDeviceMemoryBlock(VmaAllocator hAllocator) : m_pMetadata(VMA_NULL), m_MemoryTypeIndex(UINT32_MAX), m_Id(0), m_hMemory(VK_NULL_HANDLE), m_MapCount(0), m_pMappedData(VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT_LEAK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT_LEAK(m_MapCount == 0 && \"VkDeviceMemory block is being destroyed while it is still mapped.\")"
  },
  {
    "label": "VMA_ASSERT_LEAK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT_LEAK(m_hMemory == VK_NULL_HANDLE)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_hMemory == VK_NULL_HANDLE)"
  },
  {
    "label": "vma_new()",
    "kind": "Method",
    "detail": "Function (break ; case VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT : m_pMetadata =)",
    "insertText": "vma_new(hAllocator, VmaBlockMetadata_Linear)(hAllocator->GetAllocationCallbacks(), bufferImageGranularity, false)"
  },
  {
    "label": "vma_new()",
    "kind": "Method",
    "detail": "Function (m_pMetadata =)",
    "insertText": "vma_new(hAllocator, VmaBlockMetadata_TLSF)(hAllocator->GetAllocationCallbacks(), bufferImageGranularity, false)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} m_pMetadata ->)",
    "insertText": "Init(newSize)"
  },
  {
    "label": "VMA_ASSERT_LEAK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT_LEAK(m_pMetadata->IsEmpty() && \"Some allocations were not freed before destruction of this memory block!\")"
  },
  {
    "label": "VMA_ASSERT_LEAK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT_LEAK(m_hMemory != VK_NULL_HANDLE)"
  },
  {
    "label": "FreeVulkanMemory()",
    "kind": "Method",
    "detail": "Function (allocator ->)",
    "insertText": "FreeVulkanMemory(m_MemoryTypeIndex, m_pMetadata->GetSize(), m_hMemory)"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (m_hMemory = VK_NULL_HANDLE ;)",
    "insertText": "vma_delete(allocator, m_pMetadata)"
  },
  {
    "label": "PostAlloc()",
    "kind": "Method",
    "detail": "Function (m_pMetadata = VMA_NULL ; } void)",
    "insertText": "PostAlloc(VmaAllocator hAllocator)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (VmaMutexLock)",
    "insertText": "lock(m_MapAndBindMutex, hAllocator->m_UseMutex)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_MappingHysteresis.GetExtraMapping() == 0)"
  },
  {
    "label": "VMA_NULL()",
    "kind": "Method",
    "detail": "Function (m_pMappedData =)",
    "insertText": "VMA_NULL(*hAllocator->GetVulkanFunctions().vkUnmapMemory)(hAllocator->m_hDevice, m_hMemory)"
  },
  {
    "label": "VMA_VALIDATE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_VALIDATE((m_hMemory != VK_NULL_HANDLE) && (m_pMetadata->GetSize() != 0))"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (void* pData = VMA_NULL ; VkResult res =)",
    "insertText": "Map(hAllocator, 1, &pData)"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unmap(hAllocator, 1)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_pMappedData != VMA_NULL)"
  },
  {
    "label": "PostMap()",
    "kind": "Method",
    "detail": "Function (m_MappingHysteresis .)",
    "insertText": "PostMap()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_MapCount + = count ;)",
    "insertText": "if(ppData != VMA_NULL)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (* ppData = m_pMappedData ; } return VK_SUCCESS ; } else { VkResult)",
    "insertText": "result(*hAllocator->GetVulkanFunctions().vkMapMemory)( hAllocator->m_hDevice, m_hMemory, 0, VK_WHOLE_SIZE, 0, &m_pMappedData)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "VMA_ASSERT(0 && \"VkDeviceMemory block is being unmapped while it was not previously mapped.\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(VMA_DEBUG_MARGIN > 0 && VMA_DEBUG_MARGIN % 4 == 0 && VMA_DEBUG_DETECT_CORRUPTION)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"MEMORY CORRUPTION DETECTED AFTER FREED ALLOCATION!\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(hAllocation->GetType() == VmaAllocation_T::ALLOCATION_TYPE_BLOCK && hAllocation->GetBlock() == this)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocationLocalOffset < hAllocation->GetSize() && \"Invalid allocationLocalOffset. Did you forget that this offset is relative to the beginning of the allocation, not the whole memory block?\")"
  },
  {
    "label": "m_Type()",
    "kind": "Method",
    "detail": "Function (1 },m_Size { 0 },m_pUserData { VMA_NULL },m_pName { VMA_NULL },m_MemoryTypeIndex { 0 },)",
    "insertText": "m_Type(uint8_t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (0 },m_Flags { 0 } {)",
    "insertText": "if(mappingAllowed) m_Flags |= (uint8_t)"
  },
  {
    "label": "VMA_ASSERT_LEAK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT_LEAK(m_MapCount == 0 && \"Allocation was not unmapped before destruction.\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_pName == VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_Type == ALLOCATION_TYPE_NONE)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(block != VMA_NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_Alignment = alignment ; m_Size = size ; m_MemoryTypeIndex = memoryTypeIndex ;)",
    "insertText": "if(mapped)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(IsMappingAllowed() && \"Mapping is not allowed on this allocation! Please use one of the new VMA_ALLOCATION_CREATE_HOST_ACCESS_* flags when creating it.\")"
  },
  {
    "label": "m_Flags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_Flags(uint8_t)"
  },
  {
    "label": "m_SuballocationType()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "m_SuballocationType(uint8_t)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(hMemory != VK_NULL_HANDLE)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pName == VMA_NULL || pName != m_pName)"
  },
  {
    "label": "FreeName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeName(hAllocator)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocation != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocation->m_Type == ALLOCATION_TYPE_BLOCK)"
  },
  {
    "label": "SetAllocationUserData()",
    "kind": "Method",
    "detail": "Function (m_BlockAllocation . m_Block -> m_pMetadata ->)",
    "insertText": "SetAllocationUserData(m_BlockAllocation.m_AllocHandle, allocation)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_BlockAllocation, allocation->m_BlockAllocation)"
  },
  {
    "label": "SetAllocationUserData()",
    "kind": "Method",
    "detail": "Function (m_BlockAllocation . m_Block -> m_pMetadata ->)",
    "insertText": "SetAllocationUserData(m_BlockAllocation.m_AllocHandle, this)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (# if VMA_STATS_STRING_ENABLED)",
    "insertText": "swap(m_BufferImageUsage, allocation->m_BufferImageUsage)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pBlockData != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else { return VMA_NULL ; } break ; case ALLOCATION_TYPE_DEDICATED :)",
    "insertText": "VMA_ASSERT((m_DedicatedAllocation.m_pMappedData != VMA_NULL) == (m_MapCount != 0 || IsPersistentMap()))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(GetType() == ALLOCATION_TYPE_BLOCK)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (+ + m_MapCount ; } else {)",
    "insertText": "VMA_ASSERT(0 && \"Allocation mapped too many times simultaneously.\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (- - m_MapCount ; } else {)",
    "insertText": "VMA_ASSERT(0 && \"Unmapping allocation not previously mapped.\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(GetType() == ALLOCATION_TYPE_DEDICATED)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_DedicatedAllocation.m_pMappedData != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (* ppData = m_DedicatedAllocation . m_pMappedData ; + + m_MapCount ; return VK_SUCCESS ; } else {)",
    "insertText": "VMA_ASSERT(0 && \"Dedicated allocation mapped too many times simultaneously.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - m_MapCount ;)",
    "insertText": "if(m_MapCount == 0 && !IsPersistentMap())"
  },
  {
    "label": "VMA_NULL()",
    "kind": "Method",
    "detail": "Function (m_DedicatedAllocation . m_pMappedData =)",
    "insertText": "VMA_NULL(*hAllocator->GetVulkanFunctions().vkUnmapMemory)( hAllocator->m_hDevice, m_DedicatedAllocation.m_hMemory)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "VMA_ASSERT(0 && \"Unmapping dedicated allocation not previously mapped.\")"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(VMA_SUBALLOCATION_TYPE_NAMES[m_SuballocationType])"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(m_Size)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Usage\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(m_BufferImageUsage.Value)"
  },
  {
    "label": "ContinueString_Pointer()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString_Pointer(m_pUserData)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_pName != VMA_NULL)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Name\")"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(m_pName)"
  },
  {
    "label": "VmaFreeString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaFreeString(hAllocator->GetAllocationCallbacks(), m_pName)"
  },
  {
    "label": "VmaBlockVector()",
    "kind": "Method",
    "detail": "Function (m_pName = VMA_NULL ; } } # endif # ifndef _VMA_BLOCK_VECTOR_FUNCTIONS)",
    "insertText": "VmaBlockVector(VmaAllocator hAllocator, VmaPool hParentPool, uint32_t memoryTypeIndex, VkDeviceSize preferredBlockSize, size_t minBlockCount, size_t maxBlockCount, VkDeviceSize bufferImageGranularity, bool explicitBlockSize, uint32_t algorithm, float priority, VkDeviceSize minAllocationAlignment, void* pMemoryAllocateNext) : m_hAllocator(hAllocator), m_hParentPool(hParentPool), m_MemoryTypeIndex(memoryTypeIndex), m_PreferredBlockSize(preferredBlockSize), m_MinBlockCount(minBlockCount), m_MaxBlockCount(maxBlockCount), m_BufferImageGranularity(bufferImageGranularity), m_ExplicitBlockSize(explicitBlockSize), m_Algorithm(algorithm), m_Priority(priority), m_MinAllocationAlignment(minAllocationAlignment), m_pMemoryAllocateNext(pMemoryAllocateNext), m_Blocks(VmaStlAllocator<VmaDeviceMemoryBlock*>(hAllocator->GetAllocationCallbacks())), m_NextBlockId(0)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (m_Blocks [ i ] ->)",
    "insertText": "Destroy(m_hAllocator)"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vma_delete(m_hAllocator, m_Blocks[i])"
  },
  {
    "label": "CreateMinBlocks()",
    "kind": "Method",
    "detail": "Function (} } VkResult)",
    "insertText": "CreateMinBlocks()"
  },
  {
    "label": "CreateBlock()",
    "kind": "Method",
    "detail": "Function (VkResult res =)",
    "insertText": "CreateBlock(m_PreferredBlockSize, VMA_NULL)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (VmaMutexLockRead)",
    "insertText": "lock(m_Mutex, m_hAllocator->m_UseMutex)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (const VmaDeviceMemoryBlock* const pBlock = m_Blocks [ blockIndex ] ;)",
    "insertText": "VMA_ASSERT(pBlock)"
  },
  {
    "label": "VMA_HEAVY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_HEAVY_ASSERT(pBlock->Validate())"
  },
  {
    "label": "AddStatistics()",
    "kind": "Method",
    "detail": "Function (pBlock -> m_pMetadata ->)",
    "insertText": "AddStatistics(inoutStats)"
  },
  {
    "label": "AddDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (pBlock -> m_pMetadata ->)",
    "insertText": "AddDetailedStatistics(inoutStats)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (const uint32_t requiredMemFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ;)",
    "insertText": "return(VMA_DEBUG_DETECT_CORRUPTION != 0) && (VMA_DEBUG_MARGIN > 0) && (m_Algorithm == 0 || m_Algorithm == VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT) && (m_hAllocator->m_MemProps.memoryTypes[m_MemoryTypeIndex].propertyFlags & requiredMemFlags)"
  },
  {
    "label": "VMA_MAX()",
    "kind": "Method",
    "detail": "Function (size_t allocIndex ; VkResult res = VK_SUCCESS ; alignment =)",
    "insertText": "VMA_MAX(alignment, m_MinAllocationAlignment)"
  },
  {
    "label": "VkDeviceSize()",
    "kind": "Method",
    "detail": "Function (size = VmaAlignUp<)",
    "insertText": "VkDeviceSize(size, sizeof(VMA_CORRUPTION_DETECTION_MAGIC_VALUE))"
  },
  {
    "label": "VkDeviceSize()",
    "kind": "Method",
    "detail": "Function (alignment = VmaAlignUp<)",
    "insertText": "VkDeviceSize(alignment, sizeof(VMA_CORRUPTION_DETECTION_MAGIC_VALUE))"
  },
  {
    "label": "AllocatePage()",
    "kind": "Method",
    "detail": "Function (res =)",
    "insertText": "AllocatePage(size, alignment, createInfo, suballocType, pAllocations + allocIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } } })",
    "insertText": "if(res != VK_SUCCESS)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(pAllocations, 0, sizeof(VmaAllocation) * allocationCount)"
  },
  {
    "label": "isUpperAddress()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "isUpperAddress(createInfo.flags & VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT)"
  },
  {
    "label": "MemoryTypeIndexToHeapIndex()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize freeMemory ; { const uint32_t heapIndex = m_hAllocator ->)",
    "insertText": "MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex)"
  },
  {
    "label": "GetHeapBudgets()",
    "kind": "Method",
    "detail": "Function (VmaBudget heapBudget = { } ; m_hAllocator ->)",
    "insertText": "GetHeapBudgets(&heapBudget, heapIndex, 1)"
  },
  {
    "label": "freeMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "freeMemory(heapBudget.usage < heapBudget.budget) ? (heapBudget.budget - heapBudget.usage)"
  },
  {
    "label": "HasExplicitBlockSize()",
    "kind": "Method",
    "detail": "Function (} const bool canFallbackToDedicated = !)",
    "insertText": "HasExplicitBlockSize() && (createInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT)"
  },
  {
    "label": "canCreateNewBlock()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "canCreateNewBlock((createInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) == 0) && (m_Blocks.size() < m_MaxBlockCount) && (freeMemory >= size || !canFallbackToDedicated)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32_t strategy = createInfo . flags& VMA_ALLOCATION_CREATE_STRATEGY_MASK ;)",
    "insertText": "if(isUpperAddress && (m_Algorithm != VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT || m_MaxBlockCount > 1))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pCurrBlock)"
  },
  {
    "label": "AllocateFromBlock()",
    "kind": "Method",
    "detail": "Function (VkResult res =)",
    "insertText": "AllocateFromBlock(pCurrBlock, size, alignment, createInfo.flags, createInfo.pUserData, suballocType, strategy, pAllocation)"
  },
  {
    "label": "VMA_DEBUG_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG_FORMAT(\" Returned from last block #%\" PRIu32, pCurrBlock->GetId())"
  },
  {
    "label": "isHostVisible()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "isHostVisible(m_hAllocator->m_MemProps.memoryTypes[m_MemoryTypeIndex].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)"
  },
  {
    "label": "isMappingAllowed()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "isMappingAllowed(createInfo.flags & (VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT))"
  },
  {
    "label": "VMA_DEBUG_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG_FORMAT(\" Returned from existing block #%\" PRIu32, pCurrBlock->GetId())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize newBlockSize = m_PreferredBlockSize ; uint32_t newBlockSizeShift = 0 ; const uint32_t NEW_BLOCK_SIZE_SHIFT_MAX = 3 ;)",
    "insertText": "if(!m_ExplicitBlockSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize smallerNewBlockSize = newBlockSize / 2 ;)",
    "insertText": "if(smallerNewBlockSize > maxExistingBlockSize && smallerNewBlockSize >= size * 2)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (newBlockSize = smallerNewBlockSize ; + + newBlockSizeShift ; } else { break ; } } } size_t newBlockIndex = 0 ; VkResult)",
    "insertText": "res(newBlockSize <= freeMemory || !canFallbackToDedicated) ? CreateBlock(newBlockSize, &newBlockIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize smallerNewBlockSize = newBlockSize / 2 ;)",
    "insertText": "if(smallerNewBlockSize >= size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { break ; } } })",
    "insertText": "if(res == VK_SUCCESS)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (VmaDeviceMemoryBlock* const pBlock = m_Blocks [ newBlockIndex ] ;)",
    "insertText": "VMA_ASSERT(pBlock->m_pMetadata->GetSize() >= size)"
  },
  {
    "label": "AllocateFromBlock()",
    "kind": "Method",
    "detail": "Function (res =)",
    "insertText": "AllocateFromBlock(pBlock, size, alignment, createInfo.flags, createInfo.pUserData, suballocType, strategy, pAllocation)"
  },
  {
    "label": "VMA_DEBUG_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG_FORMAT(\" Created new block #%\" PRIu32 \" Size=%\" PRIu64, pBlock->GetId(), newBlockSize)"
  },
  {
    "label": "ValidateMagicValueAfterAllocation()",
    "kind": "Method",
    "detail": "Function (VkResult res = pBlock ->)",
    "insertText": "ValidateMagicValueAfterAllocation(m_hAllocator, hAllocation->GetOffset(), hAllocation->GetSize())"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(res == VK_SUCCESS && \"Couldn't map block memory to validate magic value.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(hAllocation->IsPersistentMap())"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (pBlock ->)",
    "insertText": "Unmap(m_hAllocator, 1)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (pBlock -> m_pMetadata ->)",
    "insertText": "Free(hAllocation->GetAllocHandle())"
  },
  {
    "label": "PostFree()",
    "kind": "Method",
    "detail": "Function (pBlock ->)",
    "insertText": "PostFree(m_hAllocator)"
  },
  {
    "label": "VMA_DEBUG_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG_FORMAT(\" Freed from MemoryTypeIndex=%\" PRIu32, m_MemoryTypeIndex)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (pBlockToDelete = pBlock ;)",
    "insertText": "Remove(pBlock)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(hadEmptyBlockBeforeFree && canDeleteBlock)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(pBlockToDelete != VMA_NULL)"
  },
  {
    "label": "VMA_DEBUG_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG_FORMAT(\" Deleted empty block #%\" PRIu32, pBlockToDelete->GetId())"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vma_delete(m_hAllocator, pBlockToDelete)"
  },
  {
    "label": "RemoveAllocation()",
    "kind": "Method",
    "detail": "Function (} m_hAllocator -> m_Budget .)",
    "insertText": "RemoveAllocation(m_hAllocator->MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex), hAllocation->GetSize())"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (m_hAllocator -> m_AllocationObjectAllocator .)",
    "insertText": "Free(hAllocation)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize result = 0 ;)",
    "insertText": "for(size_t i = m_Blocks.size(); i--;)"
  },
  {
    "label": "VMA_MAX()",
    "kind": "Method",
    "detail": "Function (result =)",
    "insertText": "VMA_MAX(result, m_Blocks[i]->m_pMetadata->GetSize())"
  },
  {
    "label": "VmaVectorRemove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaVectorRemove(m_Blocks, blockIndex)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_Blocks[i - 1], m_Blocks[i])"
  },
  {
    "label": "VMA_SORT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_SORT(m_Blocks.begin(), m_Blocks.end(), [](VmaDeviceMemoryBlock* b1, VmaDeviceMemoryBlock* b2) -> bool { return b1->m_pMetadata->GetSumFreeSize() < b2->m_pMetadata->GetSumFreeSize(); })"
  },
  {
    "label": "isUpperAddress()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "isUpperAddress(allocFlags & VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaAllocationRequest currRequest = { } ;)",
    "insertText": "if(pBlock->m_pMetadata->CreateAllocationRequest( size, alignment, isUpperAddress, suballocType, strategy, &currRequest))"
  },
  {
    "label": "mapped()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "mapped(allocFlags & VMA_ALLOCATION_CREATE_MAPPED_BIT)"
  },
  {
    "label": "isUserDataString()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "isUserDataString(allocFlags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT)"
  },
  {
    "label": "isMappingAllowed()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "isMappingAllowed(allocFlags & (VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT))"
  },
  {
    "label": "PostAlloc()",
    "kind": "Method",
    "detail": "Function (pBlock ->)",
    "insertText": "PostAlloc(m_hAllocator)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (VkResult res = pBlock ->)",
    "insertText": "Map(m_hAllocator, 1, VMA_NULL)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (pBlock -> m_pMetadata ->)",
    "insertText": "Alloc(allocRequest, suballocType, *pAllocation)"
  },
  {
    "label": "AddAllocation()",
    "kind": "Method",
    "detail": "Function (m_hAllocator -> m_Budget .)",
    "insertText": "AddAllocation(m_hAllocator->MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex), allocRequest.size)"
  },
  {
    "label": "FillAllocation()",
    "kind": "Method",
    "detail": "Function (m_hAllocator ->)",
    "insertText": "FillAllocation(*pAllocation, VMA_ALLOCATION_FILL_PATTERN_CREATED)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(IsCorruptionDetectionEnabled())"
  },
  {
    "label": "WriteMagicValueAfterAllocation()",
    "kind": "Method",
    "detail": "Function (VkResult res = pBlock ->)",
    "insertText": "WriteMagicValueAfterAllocation(m_hAllocator, (*pAllocation)->GetOffset(), allocRequest.size)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(res == VK_SUCCESS && \"Couldn't map block memory to write magic value.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VkMemoryAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO } ; allocInfo . pNext = m_pMemoryAllocateNext ; allocInfo . memoryTypeIndex = m_MemoryTypeIndex ; allocInfo . allocationSize = blockSize ; # if VMA_BUFFER_DEVICE_ADDRESS VkMemoryAllocateFlagsInfoKHR allocFlagsInfo = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR } ;)",
    "insertText": "if(m_hAllocator->m_UseKhrBufferDeviceAddress)"
  },
  {
    "label": "VmaPnextChainPushFront()",
    "kind": "Method",
    "detail": "Function (allocFlagsInfo . flags = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR ;)",
    "insertText": "VmaPnextChainPushFront(&allocInfo, &allocFlagsInfo)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif # if VMA_MEMORY_PRIORITY VkMemoryPriorityAllocateInfoEXT priorityInfo = { VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT } ;)",
    "insertText": "if(m_hAllocator->m_UseExtMemoryPriority)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_Priority >= 0.f && m_Priority <= 1.f)"
  },
  {
    "label": "VmaPnextChainPushFront()",
    "kind": "Method",
    "detail": "Function (priorityInfo . priority = m_Priority ;)",
    "insertText": "VmaPnextChainPushFront(&allocInfo, &priorityInfo)"
  },
  {
    "label": "GetExternalMemoryHandleTypeFlags()",
    "kind": "Method",
    "detail": "Function (} # endif # if VMA_EXTERNAL_MEMORY VkExportMemoryAllocateInfoKHR exportMemoryAllocInfo = { VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR } ; exportMemoryAllocInfo . handleTypes = m_hAllocator ->)",
    "insertText": "GetExternalMemoryHandleTypeFlags(m_MemoryTypeIndex)"
  },
  {
    "label": "VmaPnextChainPushFront()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaPnextChainPushFront(&allocInfo, &exportMemoryAllocInfo)"
  },
  {
    "label": "AllocateVulkanMemory()",
    "kind": "Method",
    "detail": "Function (} # endif VkDeviceMemory mem = VK_NULL_HANDLE ; VkResult res = m_hAllocator ->)",
    "insertText": "AllocateVulkanMemory(&allocInfo, &mem)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (pBlock ->)",
    "insertText": "Init(m_hAllocator, m_hParentPool, m_MemoryTypeIndex, mem, allocInfo.allocationSize, m_NextBlockId++, m_Algorithm, m_BufferImageGranularity)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (m_Blocks .)",
    "insertText": "push_back(pBlock)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaDeviceMemoryBlock* const pBlock = m_Blocks [ index ] ;)",
    "insertText": "if(pBlock->m_pMetadata->IsEmpty())"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString(m_Blocks[i]->GetId())"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"MapRefCount\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(m_Blocks[i]->GetMapRefCount())"
  },
  {
    "label": "CheckCorruption()",
    "kind": "Method",
    "detail": "Function (VkResult res = pBlock ->)",
    "insertText": "CheckCorruption(m_hAllocator)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_Algorithm = info . flags& VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK ;)",
    "insertText": "if(info.pool != VMA_NULL)"
  },
  {
    "label": "SetIncrementalSort()",
    "kind": "Method",
    "detail": "Function (m_BlockVectorCount = 1 ; m_PoolBlockVector =& info . pool -> m_BlockVector ; m_pBlockVectors =& m_PoolBlockVector ; m_PoolBlockVector ->)",
    "insertText": "SetIncrementalSort(false)"
  },
  {
    "label": "GetMemoryTypeCount()",
    "kind": "Method",
    "detail": "Function (} else { m_BlockVectorCount = hAllocator ->)",
    "insertText": "GetMemoryTypeCount()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (m_PoolBlockVector = VMA_NULL ; m_pBlockVectors = hAllocator -> m_pBlockVectors ;)",
    "insertText": "for(uint32_t i = 0; i < m_BlockVectorCount; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaBlockVector* vector = m_pBlockVectors [ i ] ;)",
    "insertText": "if(vector != VMA_NULL)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "switch(m_Algorithm)"
  },
  {
    "label": "vma_new_array()",
    "kind": "Method",
    "detail": "Function (break ; case VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT : m_AlgorithmState =)",
    "insertText": "vma_new_array(hAllocator, StateBalanced, m_BlockVectorCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT :)",
    "insertText": "if(hAllocator->GetBufferImageGranularity() > 1)"
  },
  {
    "label": "vma_new_array()",
    "kind": "Method",
    "detail": "Function (m_AlgorithmState =)",
    "insertText": "vma_new_array(hAllocator, StateExtensive, m_BlockVectorCount)"
  },
  {
    "label": "SetIncrementalSort()",
    "kind": "Method",
    "detail": "Function (m_PoolBlockVector ->)",
    "insertText": "SetIncrementalSort(true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaBlockVector* vector = m_pBlockVectors [ i ] ;)",
    "insertText": "if(vector != VMA_NULL) vector->SetIncrementalSort(true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(m_AlgorithmState)"
  },
  {
    "label": "vma_delete_array()",
    "kind": "Method",
    "detail": "Function (break ; case VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT :)",
    "insertText": "vma_delete_array(m_MoveAllocator.m_pCallbacks, reinterpret_cast<StateExtensive*>(m_AlgorithmState), m_BlockVectorCount)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (VmaMutexLockWrite)",
    "insertText": "lock(m_PoolBlockVector->GetMutex(), m_PoolBlockVector->GetAllocator()->m_UseMutex)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (VmaMutexLockWrite)",
    "insertText": "lock(m_pBlockVectors[i]->GetMutex(), m_pBlockVectors[i]->GetAllocator()->m_UseMutex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(m_pBlockVectors[i]->GetBlockCount() == 1)"
  },
  {
    "label": "uint32_t()",
    "kind": "Method",
    "detail": "Function (} } } } moveInfo . moveCount = static_cast<)",
    "insertText": "uint32_t(m_Moves.size())"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(moveInfo.moveCount > 0 ? moveInfo.pMoves != VMA_NULL : true)"
  },
  {
    "label": "blockAllocator()",
    "kind": "Method",
    "detail": "Function (VkResult result = VK_SUCCESS ; VmaStlAllocator<FragmentedBlock>)",
    "insertText": "blockAllocator(m_MoveAllocator.m_pCallbacks)"
  },
  {
    "label": "immovableBlocks()",
    "kind": "Method",
    "detail": "Function (VmaVector<FragmentedBlock,VmaStlAllocator<FragmentedBlock>>)",
    "insertText": "immovableBlocks(blockAllocator)"
  },
  {
    "label": "mappedBlocks()",
    "kind": "Method",
    "detail": "Function (VmaVector<FragmentedBlock,VmaStlAllocator<FragmentedBlock>>)",
    "insertText": "mappedBlocks(blockAllocator)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (VmaAllocator allocator = VMA_NULL ;)",
    "insertText": "for(uint32_t i = 0; i < moveInfo.moveCount; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaDefragmentationMove& move = moveInfo . pMoves [ i ] ; size_t prevCount = 0,currentCount = 0 ; VkDeviceSize freedBlockSize = 0 ; uint32_t vectorIndex ; VmaBlockVector* vector ;)",
    "insertText": "if(m_PoolBlockVector != VMA_NULL)"
  },
  {
    "label": "GetMemoryTypeIndex()",
    "kind": "Method",
    "detail": "Function (vectorIndex = 0 ; vector = m_PoolBlockVector ; } else { vectorIndex = move . srcAllocation ->)",
    "insertText": "GetMemoryTypeIndex()"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (vector = m_pBlockVectors [ vectorIndex ] ;)",
    "insertText": "VMA_ASSERT(vector != VMA_NULL)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "switch(move.operation)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool notPresent = true ;)",
    "insertText": "for(FragmentedBlock& block : mappedBlocks)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (notPresent = false ; block . data + = mapCount ; break ; } })",
    "insertText": "if(notPresent) mappedBlocks.push_back({ mapCount, newMapBlock })"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (} { VmaMutexLockRead)",
    "insertText": "lock(vector->GetMutex(), vector->GetAllocator()->m_UseMutex)"
  },
  {
    "label": "GetBlockCount()",
    "kind": "Method",
    "detail": "Function (prevCount = vector ->)",
    "insertText": "GetBlockCount()"
  },
  {
    "label": "GetBlock()",
    "kind": "Method",
    "detail": "Function (freedBlockSize = move . dstTmpAllocation ->)",
    "insertText": "GetBlock()->m_pMetadata->GetSize()"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (} vector ->)",
    "insertText": "Free(move.dstTmpAllocation)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool notPresent = true ;)",
    "insertText": "for(const FragmentedBlock& block : immovableBlocks)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (notPresent = false ; break ; } })",
    "insertText": "if(notPresent) immovableBlocks.push_back({ vectorIndex, newBlock })"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (} vector ->)",
    "insertText": "Free(move.srcAllocation)"
  },
  {
    "label": "dstBlockSize()",
    "kind": "Method",
    "detail": "Function (freedBlockSize + =)",
    "insertText": "dstBlockSize(currentCount - vector->GetBlockCount())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(prevCount > currentCount)"
  },
  {
    "label": "uint32_t()",
    "kind": "Method",
    "detail": "Function (size_t freedBlocks = prevCount - currentCount ; m_PassStats . deviceMemoryBlocksFreed + = static_cast<)",
    "insertText": "uint32_t(freedBlocks)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_PassStats . bytesFreed + = freedBlockSize ; })",
    "insertText": "if(m_Algorithm == VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT && m_AlgorithmState != VMA_NULL)"
  },
  {
    "label": "StateExtensive()",
    "kind": "Method",
    "detail": "Function (StateExtensive& state = reinterpret_cast<)",
    "insertText": "StateExtensive(m_AlgorithmState)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const size_t diff = prevCount - currentCount ;)",
    "insertText": "if(state.firstFreeBlock >= diff)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (state . firstFreeBlock - = diff ;)",
    "insertText": "if(state.firstFreeBlock != 0) state.firstFreeBlock -= vector->GetBlock(state.firstFreeBlock - 1)->m_pMetadata->IsEmpty()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_GlobalStats . allocationsMoved + = m_PassStats . allocationsMoved ; m_GlobalStats . bytesFreed + = m_PassStats . bytesFreed ; m_GlobalStats . bytesMoved + = m_PassStats . bytesMoved ; m_GlobalStats . deviceMemoryBlocksFreed + = m_PassStats . deviceMemoryBlocksFreed ; m_PassStats = { 0 } ;)",
    "insertText": "if(immovableBlocks.size() > 0)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(vector->m_Blocks[i], vector->m_Blocks[vector->GetBlockCount() - ++m_ImmovableBlockCount])"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(vector->m_Blocks[i], vector->m_Blocks[m_ImmovableBlockCount++])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(const FragmentedBlock& block : mappedBlocks)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (VkResult res = block . block ->)",
    "insertText": "Map(allocator, block.data, VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(res == VK_SUCCESS)"
  },
  {
    "label": "srcAllocation()",
    "kind": "Method",
    "detail": "Function (MoveAllocationData moveData ; moveData . move .)",
    "insertText": "srcAllocation(VmaAllocation)metadata->GetAllocationUserData(handle)"
  },
  {
    "label": "GetSuballocationType()",
    "kind": "Method",
    "detail": "Function (moveData . type = moveData . move . srcAllocation ->)",
    "insertText": "GetSuballocationType()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (moveData . flags = 0 ;)",
    "insertText": "if(moveData.move.srcAllocation->IsPersistentMap())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_PassStats . bytesMoved + = bytes ;)",
    "insertText": "if(++m_PassStats.allocationsMoved >= m_MaxPassAllocations || m_PassStats.bytesMoved >= m_MaxPassBytes)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT((m_PassStats.allocationsMoved == m_MaxPassAllocations || m_PassStats.bytesMoved == m_MaxPassBytes) && \"Exceeded maximal pass threshold!\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (VmaBlockMetadata* metadata = block -> m_pMetadata ;)",
    "insertText": "for(VmaAllocHandle handle = metadata->GetAllocationListBegin(); handle != VK_NULL_HANDLE; handle = metadata->GetNextAllocation(handle))"
  },
  {
    "label": "GetMoveData()",
    "kind": "Method",
    "detail": "Function (MoveAllocationData moveData =)",
    "insertText": "GetMoveData(handle, metadata)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaAllocationRequest request = { } ;)",
    "insertText": "if(metadata->CreateAllocationRequest( moveData.size, moveData.alignment, false, moveData.type, VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT, &request))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (m_Moves .)",
    "insertText": "push_back(moveData.move)"
  },
  {
    "label": "GetBlock()",
    "kind": "Method",
    "detail": "Function (VmaDeviceMemoryBlock* dstBlock = vector .)",
    "insertText": "GetBlock(start)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (m_Moves .)",
    "insertText": "push_back(data.move)"
  },
  {
    "label": "GetBlock()",
    "kind": "Method",
    "detail": "Function (m_pMetadata)",
    "insertText": "GetBlock(i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(AllocInOtherBlock(0, i, moveData, vector))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_AlgorithmState != VMA_NULL)"
  },
  {
    "label": "StateBalanced()",
    "kind": "Method",
    "detail": "Function (StateBalanced& vectorState = reinterpret_cast<)",
    "insertText": "StateBalanced(m_AlgorithmState)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize minimalFreeRegion = vectorState . avgFreeSize / 2 ;)",
    "insertText": "for(size_t i = vector.GetBlockCount() - 1; i > m_ImmovableBlockCount; --i)"
  },
  {
    "label": "GetNextFreeRegionSize()",
    "kind": "Method",
    "detail": "Function (VkDeviceSize nextFreeRegionSize = metadata ->)",
    "insertText": "GetNextFreeRegionSize(handle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } } } prevFreeRegionSize = nextFreeRegionSize ; } })",
    "insertText": "if(startMoveCount == m_Moves.size() && !update)"
  },
  {
    "label": "ComputeDefragmentation_Balanced()",
    "kind": "Method",
    "detail": "Function (vectorState . avgAllocSize = UINT64_MAX ; return)",
    "insertText": "ComputeDefragmentation_Balanced(vector, index, false)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (bool texturePresent = false,bufferPresent = false,otherPresent = false ;)",
    "insertText": "switch(vectorState.operation)"
  },
  {
    "label": "ComputeDefragmentation_Fast()",
    "kind": "Method",
    "detail": "Function (vectorState . operation = StateExtensive::Operation::Cleanup ; return)",
    "insertText": "ComputeDefragmentation_Fast(vector)"
  },
  {
    "label": "last()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "last(vectorState.firstFreeBlock == SIZE_MAX ? vector.GetBlockCount() : vectorState.firstFreeBlock)"
  },
  {
    "label": "GetBlock()",
    "kind": "Method",
    "detail": "Function (m_pMetadata)",
    "insertText": "GetBlock(last)"
  },
  {
    "label": "GetMoveData()",
    "kind": "Method",
    "detail": "Function (MoveAllocationData moveData =)",
    "insertText": "GetMoveData(handle, freeMetadata)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(AllocInOtherBlock(0, last, moveData, vector))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(prevMoveCount == m_Moves.size())"
  },
  {
    "label": "ComputeDefragmentation_Extensive()",
    "kind": "Method",
    "detail": "Function (vectorState . operation = StateExtensive::Operation::MoveTextures ; } vectorState . firstFreeBlock = last ; return)",
    "insertText": "ComputeDefragmentation_Extensive(vector, index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} break ; } case StateExtensive::Operation::MoveTextures : {)",
    "insertText": "if(MoveDataToFreeBlocks(VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL, vector, vectorState.firstFreeBlock, texturePresent, bufferPresent, otherPresent))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!bufferPresent && !otherPresent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (vectorState . operation = StateExtensive::Operation::Cleanup ; break ; } vectorState . operation = StateExtensive::Operation::MoveBuffers ; bufferPresent = false ; otherPresent = false ; } else break ; VMA_FALLTHROUGH ; } case StateExtensive::Operation::MoveBuffers : {)",
    "insertText": "if(MoveDataToFreeBlocks(VMA_SUBALLOCATION_TYPE_BUFFER, vector, vectorState.firstFreeBlock, texturePresent, bufferPresent, otherPresent))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!otherPresent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (vectorState . operation = StateExtensive::Operation::Cleanup ; break ; } vectorState . operation = StateExtensive::Operation::MoveAll ; otherPresent = false ; } else break ; VMA_FALLTHROUGH ; } case StateExtensive::Operation::MoveAll : {)",
    "insertText": "if(MoveDataToFreeBlocks(VMA_SUBALLOCATION_TYPE_FREE, vector, vectorState.firstFreeBlock, texturePresent, bufferPresent, otherPresent))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} vectorState . operation = StateExtensive::Operation::Cleanup ; } break ; } case StateExtensive::Operation::Cleanup : break ; })",
    "insertText": "if(vectorState.operation == StateExtensive::Operation::Cleanup)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t allocCount = 0 ; size_t freeCount = 0 ; state . avgFreeSize = 0 ; state . avgAllocSize = 0 ;)",
    "insertText": "for(size_t i = 0; i < vector.GetBlockCount(); ++i)"
  },
  {
    "label": "avgAllocSize()",
    "kind": "Method",
    "detail": "Function (} state .)",
    "insertText": "avgAllocSize(state.avgAllocSize - state.avgFreeSize)"
  },
  {
    "label": "GetBlock()",
    "kind": "Method",
    "detail": "Function (VmaDeviceMemoryBlock* block = vector .)",
    "insertText": "GetBlock(--i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!VmaIsBufferImageGranularityConflict(moveData.type, currentType))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!VmaIsBufferImageGranularityConflict(moveData.type, VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL))"
  },
  {
    "label": "VmaPool_T()",
    "kind": "Method",
    "detail": "Function (} # endif # ifndef _VMA_POOL_T_FUNCTIONS)",
    "insertText": "VmaPool_T(VmaAllocator hAllocator, const VmaPoolCreateInfo& createInfo, VkDeviceSize preferredBlockSize) : m_BlockVector( hAllocator, this, createInfo.memoryTypeIndex, createInfo.blockSize != 0 ? createInfo.blockSize : preferredBlockSize, createInfo.minBlockCount, createInfo.maxBlockCount, (createInfo.flags& VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT) != 0 ? 1 : hAllocator->GetBufferImageGranularity(), createInfo.blockSize != 0, createInfo.flags & VMA_POOL_CREATE_ALGORITHM_MASK, createInfo.priority, VMA_MAX(hAllocator->GetMemoryTypeMinAlignment(createInfo.memoryTypeIndex), createInfo.minAllocationAlignment), createInfo.pMemoryAllocateNext), m_Id(0), m_Name(VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_PrevPool == VMA_NULL && m_NextPool == VMA_NULL)"
  },
  {
    "label": "GetAllocator()",
    "kind": "Method",
    "detail": "Function (const VkAllocationCallbacks* allocs = m_BlockVector .)",
    "insertText": "GetAllocator()->GetAllocationCallbacks()"
  },
  {
    "label": "VmaFreeString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaFreeString(allocs, m_Name)"
  },
  {
    "label": "SetName()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetName(const char* pName)"
  },
  {
    "label": "VmaCreateStringCopy()",
    "kind": "Method",
    "detail": "Function (m_Name =)",
    "insertText": "VmaCreateStringCopy(allocs, pName)"
  },
  {
    "label": "VmaAllocator_T()",
    "kind": "Method",
    "detail": "Function (} else { m_Name = VMA_NULL ; } } # endif # ifndef _VMA_ALLOCATOR_T_FUNCTIONS)",
    "insertText": "VmaAllocator_T(const VmaAllocatorCreateInfo* pCreateInfo) : m_UseMutex((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT) == 0), m_VulkanApiVersion(pCreateInfo->vulkanApiVersion != 0 ? pCreateInfo->vulkanApiVersion : VK_API_VERSION_1_0), m_UseKhrDedicatedAllocation((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT) != 0), m_UseKhrBindMemory2((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT) != 0), m_UseExtMemoryBudget((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT) != 0), m_UseAmdDeviceCoherentMemory((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT) != 0), m_UseKhrBufferDeviceAddress((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT) != 0), m_UseExtMemoryPriority((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT) != 0), m_UseKhrMaintenance4((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_MAINTENANCE4_BIT) != 0), m_UseKhrMaintenance5((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_MAINTENANCE5_BIT) != 0), m_hDevice(pCreateInfo->device), m_hInstance(pCreateInfo->instance), m_AllocationCallbacksSpecified(pCreateInfo->pAllocationCallbacks != VMA_NULL), m_AllocationCallbacks(pCreateInfo->pAllocationCallbacks ? *pCreateInfo->pAllocationCallbacks : VmaEmptyAllocationCallbacks), m_AllocationObjectAllocator(&m_AllocationCallbacks), m_HeapSizeLimitMask(0), m_DeviceMemoryCount(0), m_PreferredLargeHeapBlockSize(0), m_PhysicalDevice(pCreateInfo->physicalDevice), m_GpuDefragmentationMemoryTypeBits(UINT32_MAX), m_NextPoolId(0), m_GlobalMemoryTypeBits(UINT32_MAX)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_UseKhrDedicatedAllocation = false ; m_UseKhrBindMemory2 = false ; })",
    "insertText": "if(VMA_DEBUG_DETECT_CORRUPTION)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(VMA_DEBUG_MARGIN % sizeof(uint32_t) == 0)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VMA_ASSERT(pCreateInfo->physicalDevice && pCreateInfo->device && pCreateInfo->instance)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "if(VMA_DEDICATED_ALLOCATION) if((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT) != 0)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT set but required extensions are disabled by preprocessor macros.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif #)",
    "insertText": "if(VMA_BIND_MEMORY2) if((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT) != 0)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT set but required extension is disabled by preprocessor macros.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif } #)",
    "insertText": "if(VMA_MEMORY_BUDGET) if((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT) != 0)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT set but required extension is disabled by preprocessor macros.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif #)",
    "insertText": "if(VMA_BUFFER_DEVICE_ADDRESS) if(m_UseKhrBufferDeviceAddress)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT is set but required extension or Vulkan 1.2 is not available in your Vulkan header or its support in VMA has been disabled by a preprocessor macro.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif # if VMA_VULKAN_VERSION<1 0 0 3 0 0 0)",
    "insertText": "if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 3, 0))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"vulkanApiVersion >= VK_API_VERSION_1_3 but required Vulkan version is disabled by preprocessor macros.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif # if VMA_VULKAN_VERSION<1 0 0 2 0 0 0)",
    "insertText": "if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 2, 0))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"vulkanApiVersion >= VK_API_VERSION_1_2 but required Vulkan version is disabled by preprocessor macros.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif # if VMA_VULKAN_VERSION<1 0 0 1 0 0 0)",
    "insertText": "if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"vulkanApiVersion >= VK_API_VERSION_1_1 but required Vulkan version is disabled by preprocessor macros.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif #)",
    "insertText": "if(VMA_MEMORY_PRIORITY) if(m_UseExtMemoryPriority)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT is set but required extension is not available in your Vulkan header or its support in VMA has been disabled by a preprocessor macro.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif #)",
    "insertText": "if(VMA_KHR_MAINTENANCE4) if(m_UseKhrMaintenance4)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"VMA_ALLOCATOR_CREATE_KHR_MAINTENANCE4_BIT is set but required extension is not available in your Vulkan header or its support in VMA has been disabled by a preprocessor macro.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif #)",
    "insertText": "if(VMA_KHR_MAINTENANCE5) if(m_UseKhrMaintenance5)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"VMA_ALLOCATOR_CREATE_KHR_MAINTENANCE5_BIT is set but required extension is not available in your Vulkan header or its support in VMA has been disabled by a preprocessor macro.\")"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "memset(&m_DeviceMemoryCallbacks, 0 ,sizeof(m_DeviceMemoryCallbacks))"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(&m_PhysicalDeviceProperties, 0, sizeof(m_PhysicalDeviceProperties))"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(&m_MemProps, 0, sizeof(m_MemProps))"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(&m_pBlockVectors, 0, sizeof(m_pBlockVectors))"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(&m_VulkanFunctions, 0, sizeof(m_VulkanFunctions))"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (# if VMA_EXTERNAL_MEMORY)",
    "insertText": "memset(&m_TypeExternalMemoryHandleTypes, 0, sizeof(m_TypeExternalMemoryHandleTypes))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(pCreateInfo->pDeviceMemoryCallbacks != VMA_NULL)"
  },
  {
    "label": "ImportVulkanFunctions()",
    "kind": "Method",
    "detail": "Function (m_DeviceMemoryCallbacks . pUserData = pCreateInfo -> pDeviceMemoryCallbacks -> pUserData ; m_DeviceMemoryCallbacks . pfnAllocate = pCreateInfo -> pDeviceMemoryCallbacks -> pfnAllocate ; m_DeviceMemoryCallbacks . pfnFree = pCreateInfo -> pDeviceMemoryCallbacks -> pfnFree ; })",
    "insertText": "ImportVulkanFunctions(pCreateInfo->pVulkanFunctions)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(VmaIsPow2(VMA_MIN_ALIGNMENT))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(VmaIsPow2(VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(VmaIsPow2(m_PhysicalDeviceProperties.limits.bufferImageGranularity))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(VmaIsPow2(m_PhysicalDeviceProperties.limits.nonCoherentAtomSize))"
  },
  {
    "label": "m_PreferredLargeHeapBlockSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_PreferredLargeHeapBlockSize(pCreateInfo->preferredLargeHeapBlockSize != 0) ? pCreateInfo->preferredLargeHeapBlockSize : static_cast<VkDeviceSize>(VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_EXTERNAL_MEMORY)",
    "insertText": "if(pCreateInfo->pTypeExternalMemoryHandleTypes != VMA_NULL)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(m_TypeExternalMemoryHandleTypes, pCreateInfo->pTypeExternalMemoryHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsKHR) * GetMemoryTypeCount())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "if(pCreateInfo->pHeapSizeLimit != VMA_NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize limit = pCreateInfo -> pHeapSizeLimit [ heapIndex ] ;)",
    "insertText": "if(limit != VK_WHOLE_SIZE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_HeapSizeLimitMask | = 1 u<<heapIndex ;)",
    "insertText": "if(limit < m_MemProps.memoryHeaps[heapIndex].size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (m_MemProps . memoryHeaps [ heapIndex ] . size = limit ; } } } })",
    "insertText": "for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)"
  },
  {
    "label": "CalcPreferredBlockSize()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize preferredBlockSize =)",
    "insertText": "CalcPreferredBlockSize(memTypeIndex)"
  },
  {
    "label": "vma_new()",
    "kind": "Method",
    "detail": "Function (m_pBlockVectors [ memTypeIndex ] =)",
    "insertText": "vma_new(this, VmaBlockVector)( this, VK_NULL_HANDLE, memTypeIndex, preferredBlockSize, 0, SIZE_MAX, GetBufferImageGranularity(), false, 0, 0.5f, GetMemoryTypeMinAlignment(memTypeIndex), VMA_NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VkResult res = VK_SUCCESS ; # if VMA_MEMORY_BUDGET)",
    "insertText": "if(m_UseExtMemoryBudget)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_Pools.IsEmpty())"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vma_delete(this, m_pBlockVectors[memTypeIndex])"
  },
  {
    "label": "ImportVulkanFunctions()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ImportVulkanFunctions(const VmaVulkanFunctions* pVulkanFunctions)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(pVulkanFunctions != VMA_NULL)"
  },
  {
    "label": "ImportVulkanFunctions_Custom()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ImportVulkanFunctions_Custom(pVulkanFunctions)"
  },
  {
    "label": "vkGetInstanceProcAddr()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkGetInstanceProcAddr(PFN_vkGetInstanceProcAddr)"
  },
  {
    "label": "vkGetDeviceProcAddr()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkGetDeviceProcAddr(PFN_vkGetDeviceProcAddr)"
  },
  {
    "label": "vkGetPhysicalDeviceProperties()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkGetPhysicalDeviceProperties(PFN_vkGetPhysicalDeviceProperties)"
  },
  {
    "label": "vkGetPhysicalDeviceMemoryProperties()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkGetPhysicalDeviceMemoryProperties(PFN_vkGetPhysicalDeviceMemoryProperties)"
  },
  {
    "label": "vkAllocateMemory()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkAllocateMemory(PFN_vkAllocateMemory)"
  },
  {
    "label": "vkFreeMemory()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkFreeMemory(PFN_vkFreeMemory)"
  },
  {
    "label": "vkMapMemory()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkMapMemory(PFN_vkMapMemory)"
  },
  {
    "label": "vkUnmapMemory()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkUnmapMemory(PFN_vkUnmapMemory)"
  },
  {
    "label": "vkFlushMappedMemoryRanges()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkFlushMappedMemoryRanges(PFN_vkFlushMappedMemoryRanges)"
  },
  {
    "label": "vkInvalidateMappedMemoryRanges()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkInvalidateMappedMemoryRanges(PFN_vkInvalidateMappedMemoryRanges)"
  },
  {
    "label": "vkBindBufferMemory()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkBindBufferMemory(PFN_vkBindBufferMemory)"
  },
  {
    "label": "vkBindImageMemory()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkBindImageMemory(PFN_vkBindImageMemory)"
  },
  {
    "label": "vkGetBufferMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkGetBufferMemoryRequirements(PFN_vkGetBufferMemoryRequirements)"
  },
  {
    "label": "vkGetImageMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkGetImageMemoryRequirements(PFN_vkGetImageMemoryRequirements)"
  },
  {
    "label": "vkCreateBuffer()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkCreateBuffer(PFN_vkCreateBuffer)"
  },
  {
    "label": "vkDestroyBuffer()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkDestroyBuffer(PFN_vkDestroyBuffer)"
  },
  {
    "label": "vkCreateImage()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkCreateImage(PFN_vkCreateImage)"
  },
  {
    "label": "vkDestroyImage()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkDestroyImage(PFN_vkDestroyImage)"
  },
  {
    "label": "vkCmdCopyBuffer()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkCmdCopyBuffer(PFN_vkCmdCopyBuffer)"
  },
  {
    "label": "vkGetBufferMemoryRequirements2KHR()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkGetBufferMemoryRequirements2KHR(PFN_vkGetBufferMemoryRequirements2)"
  },
  {
    "label": "vkGetImageMemoryRequirements2KHR()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkGetImageMemoryRequirements2KHR(PFN_vkGetImageMemoryRequirements2)"
  },
  {
    "label": "vkBindBufferMemory2KHR()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkBindBufferMemory2KHR(PFN_vkBindBufferMemory2)"
  },
  {
    "label": "vkBindImageMemory2KHR()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkBindImageMemory2KHR(PFN_vkBindImageMemory2)"
  },
  {
    "label": "vkGetPhysicalDeviceMemoryProperties2KHR()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkGetPhysicalDeviceMemoryProperties2KHR(PFN_vkGetPhysicalDeviceMemoryProperties2)"
  },
  {
    "label": "vkGetDeviceBufferMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkGetDeviceBufferMemoryRequirements(PFN_vkGetDeviceBufferMemoryRequirements)"
  },
  {
    "label": "vkGetDeviceImageMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (m_VulkanFunctions .)",
    "insertText": "vkGetDeviceImageMemoryRequirements(PFN_vkGetDeviceImageMemoryRequirements)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pVulkanFunctions != VMA_NULL)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (funcName)",
    "insertText": "VMA_COPY_IF_NOT_NULL(funcName) \\ if(pVulkanFunctions->funcName != VMA_NULL)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkGetInstanceProcAddr)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkGetDeviceProcAddr)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceProperties)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceMemoryProperties)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkAllocateMemory)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkFreeMemory)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkMapMemory)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkUnmapMemory)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkFlushMappedMemoryRanges)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkInvalidateMappedMemoryRanges)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkBindBufferMemory)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkBindImageMemory)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkGetBufferMemoryRequirements)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkGetImageMemoryRequirements)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkCreateBuffer)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkDestroyBuffer)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkCreateImage)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkDestroyImage)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkCmdCopyBuffer)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (# if VMA_DEDICATED_ALLOCATION | | VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkGetBufferMemoryRequirements2KHR)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkGetImageMemoryRequirements2KHR)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (# endif # if VMA_BIND_MEMORY2 | | VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkBindBufferMemory2KHR)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkBindImageMemory2KHR)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (# endif # if VMA_MEMORY_BUDGET | | VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceMemoryProperties2KHR)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (# endif # if VMA_KHR_MAINTENANCE4 | | VMA_VULKAN_VERSION> = 1 0 0 3 0 0 0)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkGetDeviceBufferMemoryRequirements)"
  },
  {
    "label": "VMA_COPY_IF_NOT_NULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_COPY_IF_NOT_NULL(vkGetDeviceImageMemoryRequirements)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkGetInstanceProcAddr && m_VulkanFunctions.vkGetDeviceProcAddr && \"To use VMA_DYNAMIC_VULKAN_FUNCTIONS in new versions of VMA you now have to pass \" \"VmaVulkanFunctions::vkGetInstanceProcAddr and vkGetDeviceProcAddr as VmaAllocatorCreateInfo::pVulkanFunctions. \" \"Other members can be null.\")"
  },
  {
    "label": "VMA_FETCH_INSTANCE_FUNC()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "VMA_FETCH_INSTANCE_FUNC(memberName, functionPointerType, functionNameString) \\ if(m_VulkanFunctions.memberName == VMA_NULL) \\ m_VulkanFunctions.memberName = \\ (functionPointerType)m_VulkanFunctions.vkGetInstanceProcAddr(m_hInstance, functionNameString)"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(memberName, functionPointerType, functionNameString) \\ if(m_VulkanFunctions.memberName == VMA_NULL) \\ m_VulkanFunctions.memberName = \\ (functionPointerType)m_VulkanFunctions.vkGetDeviceProcAddr(m_hDevice, functionNameString)"
  },
  {
    "label": "VMA_FETCH_INSTANCE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceProperties, PFN_vkGetPhysicalDeviceProperties, \"vkGetPhysicalDeviceProperties\")"
  },
  {
    "label": "VMA_FETCH_INSTANCE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceMemoryProperties, PFN_vkGetPhysicalDeviceMemoryProperties, \"vkGetPhysicalDeviceMemoryProperties\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkAllocateMemory, PFN_vkAllocateMemory, \"vkAllocateMemory\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkFreeMemory, PFN_vkFreeMemory, \"vkFreeMemory\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkMapMemory, PFN_vkMapMemory, \"vkMapMemory\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkUnmapMemory, PFN_vkUnmapMemory, \"vkUnmapMemory\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkFlushMappedMemoryRanges, PFN_vkFlushMappedMemoryRanges, \"vkFlushMappedMemoryRanges\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkInvalidateMappedMemoryRanges, PFN_vkInvalidateMappedMemoryRanges, \"vkInvalidateMappedMemoryRanges\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkBindBufferMemory, PFN_vkBindBufferMemory, \"vkBindBufferMemory\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkBindImageMemory, PFN_vkBindImageMemory, \"vkBindImageMemory\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkGetBufferMemoryRequirements, PFN_vkGetBufferMemoryRequirements, \"vkGetBufferMemoryRequirements\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkGetImageMemoryRequirements, PFN_vkGetImageMemoryRequirements, \"vkGetImageMemoryRequirements\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkCreateBuffer, PFN_vkCreateBuffer, \"vkCreateBuffer\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkDestroyBuffer, PFN_vkDestroyBuffer, \"vkDestroyBuffer\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkCreateImage, PFN_vkCreateImage, \"vkCreateImage\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkDestroyImage, PFN_vkDestroyImage, \"vkDestroyImage\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkCmdCopyBuffer, PFN_vkCmdCopyBuffer, \"vkCmdCopyBuffer\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkGetBufferMemoryRequirements2KHR, PFN_vkGetBufferMemoryRequirements2, \"vkGetBufferMemoryRequirements2\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkGetImageMemoryRequirements2KHR, PFN_vkGetImageMemoryRequirements2, \"vkGetImageMemoryRequirements2\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkBindBufferMemory2KHR, PFN_vkBindBufferMemory2, \"vkBindBufferMemory2\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkBindImageMemory2KHR, PFN_vkBindImageMemory2, \"vkBindImageMemory2\")"
  },
  {
    "label": "VMA_FETCH_INSTANCE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceMemoryProperties2KHR, PFN_vkGetPhysicalDeviceMemoryProperties2KHR, \"vkGetPhysicalDeviceMemoryProperties2\")"
  },
  {
    "label": "VMA_FETCH_INSTANCE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceMemoryProperties2KHR, PFN_vkGetPhysicalDeviceMemoryProperties2KHR, \"vkGetPhysicalDeviceMemoryProperties2KHR\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif # if VMA_DEDICATED_ALLOCATION)",
    "insertText": "if(m_UseKhrDedicatedAllocation)"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkGetBufferMemoryRequirements2KHR, PFN_vkGetBufferMemoryRequirements2KHR, \"vkGetBufferMemoryRequirements2KHR\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkGetImageMemoryRequirements2KHR, PFN_vkGetImageMemoryRequirements2KHR, \"vkGetImageMemoryRequirements2KHR\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif # if VMA_BIND_MEMORY2)",
    "insertText": "if(m_UseKhrBindMemory2)"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkBindBufferMemory2KHR, PFN_vkBindBufferMemory2KHR, \"vkBindBufferMemory2KHR\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkBindImageMemory2KHR, PFN_vkBindImageMemory2KHR, \"vkBindImageMemory2KHR\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkGetDeviceBufferMemoryRequirements, PFN_vkGetDeviceBufferMemoryRequirements, \"vkGetDeviceBufferMemoryRequirements\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkGetDeviceImageMemoryRequirements, PFN_vkGetDeviceImageMemoryRequirements, \"vkGetDeviceImageMemoryRequirements\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif # if VMA_KHR_MAINTENANCE4)",
    "insertText": "if(m_UseKhrMaintenance4)"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkGetDeviceBufferMemoryRequirements, PFN_vkGetDeviceBufferMemoryRequirementsKHR, \"vkGetDeviceBufferMemoryRequirementsKHR\")"
  },
  {
    "label": "VMA_FETCH_DEVICE_FUNC()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_FETCH_DEVICE_FUNC(vkGetDeviceImageMemoryRequirements, PFN_vkGetDeviceImageMemoryRequirementsKHR, \"vkGetDeviceImageMemoryRequirementsKHR\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceProperties != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkAllocateMemory != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkFreeMemory != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkMapMemory != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkUnmapMemory != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkFlushMappedMemoryRanges != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkInvalidateMappedMemoryRanges != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkBindBufferMemory != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkBindImageMemory != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkGetBufferMemoryRequirements != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkGetImageMemoryRequirements != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkCreateBuffer != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkDestroyBuffer != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkCreateImage != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkDestroyImage != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkCmdCopyBuffer != VMA_NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_DEDICATED_ALLOCATION | | VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0)",
    "insertText": "if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0) || m_UseKhrDedicatedAllocation)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkGetBufferMemoryRequirements2KHR != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkGetImageMemoryRequirements2KHR != VMA_NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif # if VMA_BIND_MEMORY2 | | VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0)",
    "insertText": "if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0) || m_UseKhrBindMemory2)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkBindBufferMemory2KHR != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkBindImageMemory2KHR != VMA_NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif # if VMA_MEMORY_BUDGET | | VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0)",
    "insertText": "if(m_UseExtMemoryBudget || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties2KHR != VMA_NULL)"
  },
  {
    "label": "MemoryTypeIndexToHeapIndex()",
    "kind": "Method",
    "detail": "Function (const uint32_t heapIndex =)",
    "insertText": "MemoryTypeIndexToHeapIndex(memTypeIndex)"
  },
  {
    "label": "VmaAlignUp()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize heapSize = m_MemProps . memoryHeaps [ heapIndex ] . size ; const bool isSmallHeap = heapSize<= VMA_SMALL_HEAP_MAX_SIZE ; return)",
    "insertText": "VmaAlignUp(isSmallHeap ? (heapSize / 8) : m_PreferredLargeHeapBlockSize, (VkDeviceSize)32)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pAllocations != VMA_NULL)"
  },
  {
    "label": "VMA_DEBUG_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG_FORMAT(\" AllocateMemory: MemoryTypeIndex=%\" PRIu32 \", AllocationCount=%zu, Size=%\" PRIu64, memTypeIndex, allocationCount, size)"
  },
  {
    "label": "CalcMemTypeParams()",
    "kind": "Method",
    "detail": "Function (VmaAllocationCreateInfo finalCreateInfo = createInfo ; VkResult res =)",
    "insertText": "CalcMemTypeParams(finalCreateInfo, memTypeIndex, size, allocationCount)"
  },
  {
    "label": "canAllocateDedicated()",
    "kind": "Method",
    "detail": "Function (} else { const bool)",
    "insertText": "canAllocateDedicated(finalCreateInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) == 0 && (pool == VK_NULL_HANDLE || !blockVector.HasExplicitBlockSize())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dedicatedPreferred = true ; })",
    "insertText": "if(m_PhysicalDeviceProperties.limits.maxMemoryAllocationCount < UINT32_MAX / 4 && m_DeviceMemoryCount.load() > m_PhysicalDeviceProperties.limits.maxMemoryAllocationCount * 3 / 4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dedicatedPreferred = false ; })",
    "insertText": "if(dedicatedPreferred)"
  },
  {
    "label": "AllocateDedicatedMemory()",
    "kind": "Method",
    "detail": "Function (res =)",
    "insertText": "AllocateDedicatedMemory(pool, size, suballocType, dedicatedAllocations, memTypeIndex, (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0, (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT) != 0, (finalCreateInfo.flags & (VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT)) != 0, (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT) != 0, finalCreateInfo.pUserData, finalCreateInfo.priority, dedicatedBuffer, dedicatedImage, dedicatedBufferImageUsage, allocationCount, pAllocations, blockVector.GetAllocationNextPtr())"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\" Allocated as DedicatedMemory\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocationCount > 0 && pAllocations)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VkMemoryAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO } ; allocInfo . memoryTypeIndex = memTypeIndex ; allocInfo . allocationSize = size ; allocInfo . pNext = pNextChain ; # if VMA_DEDICATED_ALLOCATION | | VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0 VkMemoryDedicatedAllocateInfoKHR dedicatedAllocInfo = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR } ;)",
    "insertText": "if(!canAliasMemory)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(dedicatedImage == VK_NULL_HANDLE)"
  },
  {
    "label": "VmaPnextChainPushFront()",
    "kind": "Method",
    "detail": "Function (dedicatedAllocInfo . buffer = dedicatedBuffer ;)",
    "insertText": "VmaPnextChainPushFront(&allocInfo, &dedicatedAllocInfo)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(dedicatedImage != VK_NULL_HANDLE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } # endif # if VMA_BUFFER_DEVICE_ADDRESS VkMemoryAllocateFlagsInfoKHR allocFlagsInfo = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR } ;)",
    "insertText": "if(m_UseKhrBufferDeviceAddress)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool canContainBufferWithDeviceAddress = true ;)",
    "insertText": "if(dedicatedBuffer != VK_NULL_HANDLE)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (canContainBufferWithDeviceAddress = dedicatedBufferImageUsage = = VmaBufferImageUsage::UNKNOWN | | dedicatedBufferImageUsage .)",
    "insertText": "Contains(VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (canContainBufferWithDeviceAddress = false ; })",
    "insertText": "if(canContainBufferWithDeviceAddress)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } # endif # if VMA_MEMORY_PRIORITY VkMemoryPriorityAllocateInfoEXT priorityInfo = { VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT } ;)",
    "insertText": "if(m_UseExtMemoryPriority)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(priority >= 0.f && priority <= 1.f)"
  },
  {
    "label": "GetExternalMemoryHandleTypeFlags()",
    "kind": "Method",
    "detail": "Function (} # endif # if VMA_EXTERNAL_MEMORY VkExportMemoryAllocateInfoKHR exportMemoryAllocInfo = { VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR } ; exportMemoryAllocInfo . handleTypes =)",
    "insertText": "GetExternalMemoryHandleTypeFlags(memTypeIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} # endif size_t allocIndex ; VkResult res = VK_SUCCESS ;)",
    "insertText": "for(allocIndex = 0; allocIndex < allocationCount; ++allocIndex)"
  },
  {
    "label": "AllocateDedicatedMemoryPage()",
    "kind": "Method",
    "detail": "Function (res =)",
    "insertText": "AllocateDedicatedMemoryPage(pool, size, suballocType, memTypeIndex, allocInfo, map, isUserDataString, isMappingAllowed, pUserData, pAllocations + allocIndex)"
  },
  {
    "label": "Register()",
    "kind": "Method",
    "detail": "Function (dedicatedAllocations .)",
    "insertText": "Register(pAllocations[allocIndex])"
  },
  {
    "label": "VMA_DEBUG_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "VMA_DEBUG_LOG_FORMAT(\" Allocated DedicatedMemory Count=%zu, MemoryTypeIndex=#%\" PRIu32, allocationCount, memTypeIndex)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "while(allocIndex--)"
  },
  {
    "label": "FreeVulkanMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVulkanMemory(memTypeIndex, currAlloc->GetSize(), hMemory)"
  },
  {
    "label": "RemoveAllocation()",
    "kind": "Method",
    "detail": "Function (m_Budget .)",
    "insertText": "RemoveAllocation(MemoryTypeIndexToHeapIndex(memTypeIndex), currAlloc->GetSize())"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (m_AllocationObjectAllocator .)",
    "insertText": "Free(currAlloc)"
  },
  {
    "label": "AllocateVulkanMemory()",
    "kind": "Method",
    "detail": "Function (VkDeviceMemory hMemory = VK_NULL_HANDLE ; VkResult res =)",
    "insertText": "AllocateVulkanMemory(&allocInfo, &hMemory)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\" vkAllocateMemory FAILED\")"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(*m_VulkanFunctions.vkMapMemory)( m_hDevice, hMemory, 0, VK_WHOLE_SIZE, 0, &pMappedData)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\" vkMapMemory FAILED\")"
  },
  {
    "label": "FreeVulkanMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVulkanMemory(memTypeIndex, size, hMemory)"
  },
  {
    "label": "AddAllocation()",
    "kind": "Method",
    "detail": "Function (m_Budget .)",
    "insertText": "AddAllocation(MemoryTypeIndexToHeapIndex(memTypeIndex), size)"
  },
  {
    "label": "GetBufferMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (} return VK_SUCCESS ; } void)",
    "insertText": "GetBufferMemoryRequirements(VkBuffer hBuffer, VkMemoryRequirements& memReq, bool& requiresDedicatedAllocation, bool& prefersDedicatedAllocation)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_DEDICATED_ALLOCATION | | VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0)",
    "insertText": "if(m_UseKhrDedicatedAllocation || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))"
  },
  {
    "label": "VmaPnextChainPushFront()",
    "kind": "Method",
    "detail": "Function (VkBufferMemoryRequirementsInfo2KHR memReqInfo = { VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR } ; memReqInfo . buffer = hBuffer ; VkMemoryDedicatedRequirementsKHR memDedicatedReq = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR } ; VkMemoryRequirements2KHR memReq2 = { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR } ;)",
    "insertText": "VmaPnextChainPushFront(&memReq2, &memDedicatedReq)"
  },
  {
    "label": "requiresDedicatedAllocation()",
    "kind": "Method",
    "detail": "Function (memReq = memReq2 . memoryRequirements ;)",
    "insertText": "requiresDedicatedAllocation(memDedicatedReq.requiresDedicatedAllocation != VK_FALSE)"
  },
  {
    "label": "prefersDedicatedAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prefersDedicatedAllocation(memDedicatedReq.prefersDedicatedAllocation != VK_FALSE)"
  },
  {
    "label": "endif()",
    "kind": "Method",
    "detail": "Function (} else #)",
    "insertText": "endif(*m_VulkanFunctions.vkGetBufferMemoryRequirements)(m_hDevice, hBuffer, &memReq)"
  },
  {
    "label": "endif()",
    "kind": "Method",
    "detail": "Function (} else #)",
    "insertText": "endif(*m_VulkanFunctions.vkGetImageMemoryRequirements)(m_hDevice, hImage, &memReq)"
  },
  {
    "label": "GetGlobalMemoryTypeBits()",
    "kind": "Method",
    "detail": "Function (memoryTypeBits& =)",
    "insertText": "GetGlobalMemoryTypeBits()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (memoryTypeBits& = pAllocationCreateInfo -> memoryTypeBits ; } VkMemoryPropertyFlags requiredFlags = 0,preferredFlags = 0,notPreferredFlags = 0 ;)",
    "insertText": "if(!FindMemoryPreferences( IsIntegratedGpu(), *pAllocationCreateInfo, bufImgUsage, requiredFlags, preferredFlags, notPreferredFlags))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const VkMemoryPropertyFlags currFlags = m_MemProps . memoryTypes [ memTypeIndex ] . propertyFlags ;)",
    "insertText": "if((requiredFlags & ~currFlags) == 0)"
  },
  {
    "label": "VMA_COUNT_BITS_SET()",
    "kind": "Method",
    "detail": "Function (uint32_t currCost =)",
    "insertText": "VMA_COUNT_BITS_SET(preferredFlags & ~currFlags) + VMA_COUNT_BITS_SET(currFlags & notPreferredFlags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* pMemoryTypeIndex = memTypeIndex ;)",
    "insertText": "if(currCost == 0)"
  },
  {
    "label": "CalcMemTypeParams()",
    "kind": "Method",
    "detail": "Function (} VkResult)",
    "insertText": "CalcMemTypeParams(VmaAllocationCreateInfo& inoutCreateInfo, uint32_t memTypeIndex, VkDeviceSize size, size_t allocationCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (inoutCreateInfo . flags& = ~ VMA_ALLOCATION_CREATE_MAPPED_BIT ; })",
    "insertText": "if((inoutCreateInfo.flags & VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT) != 0 && (inoutCreateInfo.flags & VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT) != 0)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT((inoutCreateInfo.flags & (VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT)) != (VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT) && \"Specifying both flags VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT and VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT is incorrect.\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT((((inoutCreateInfo.flags & VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT) == 0 || (inoutCreateInfo.flags & (VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT)) != 0)) && \"Specifying VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT requires also VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT((inoutCreateInfo.flags & (VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT | VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT)) != 0 && \"When using VMA_ALLOCATION_CREATE_MAPPED_BIT and usage = VMA_MEMORY_USAGE_AUTO*, you must also specify VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(dedicatedRequired || inoutCreateInfo.usage == VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (inoutCreateInfo . flags | = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT ; })",
    "insertText": "if(inoutCreateInfo.pool != VK_NULL_HANDLE)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"Specifying VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT while current custom pool doesn't support dedicated allocations.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((inoutCreateInfo.flags & VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT) != 0 && (inoutCreateInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) != 0)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"Specifying VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT together with VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT makes no sense.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (inoutCreateInfo . flags | = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT ; })",
    "insertText": "if(inoutCreateInfo.usage != VMA_MEMORY_USAGE_AUTO && inoutCreateInfo.usage != VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE && inoutCreateInfo.usage != VMA_MEMORY_USAGE_AUTO_PREFER_HOST)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(VmaIsPow2(vkMemReq.alignment))"
  },
  {
    "label": "AllocateMemoryOfType()",
    "kind": "Method",
    "detail": "Function (VmaBlockVector& blockVector = createInfoFinal . pool -> m_BlockVector ; return)",
    "insertText": "AllocateMemoryOfType(createInfoFinal.pool, vkMemReq.size, vkMemReq.alignment, prefersDedicatedAllocation, dedicatedBuffer, dedicatedImage, dedicatedBufferImageUsage, createInfoFinal, blockVector.GetMemoryTypeIndex(), suballocType, createInfoFinal.pool->m_DedicatedAllocations, blockVector, allocationCount, pAllocations)"
  },
  {
    "label": "FindMemoryTypeIndex()",
    "kind": "Method",
    "detail": "Function (} else { uint32_t memoryTypeBits = vkMemReq . memoryTypeBits ; uint32_t memTypeIndex = UINT32_MAX ; res =)",
    "insertText": "FindMemoryTypeIndex(memoryTypeBits, &createInfoFinal, dedicatedBufferImageUsage, &memTypeIndex)"
  },
  {
    "label": "AllocateMemoryOfType()",
    "kind": "Method",
    "detail": "Function (res =)",
    "insertText": "AllocateMemoryOfType(VK_NULL_HANDLE, vkMemReq.size, vkMemReq.alignment, requiresDedicatedAllocation || prefersDedicatedAllocation, dedicatedBuffer, dedicatedImage, dedicatedBufferImageUsage, createInfoFinal, memTypeIndex, suballocType, m_DedicatedAllocations[memTypeIndex], *blockVector, allocationCount, pAllocations)"
  },
  {
    "label": "memoryTypeBits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memoryTypeBits(1u << memTypeIndex)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(res == VK_SUCCESS)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pAllocations)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaAllocation allocation = pAllocations [ allocIndex ] ;)",
    "insertText": "if(allocation != VK_NULL_HANDLE)"
  },
  {
    "label": "FillAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FillAllocation(allocation, VMA_ALLOCATION_FILL_PATTERN_DESTROYED)"
  },
  {
    "label": "FreeName()",
    "kind": "Method",
    "detail": "Function (} allocation ->)",
    "insertText": "FreeName(this)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (pBlockVector = m_pBlockVectors [ memTypeIndex ] ;)",
    "insertText": "VMA_ASSERT(pBlockVector && \"Trying to free memory of unsupported type!\")"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (} pBlockVector ->)",
    "insertText": "Free(allocation)"
  },
  {
    "label": "FreeDedicatedMemory()",
    "kind": "Method",
    "detail": "Function (} break ; case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED :)",
    "insertText": "FreeDedicatedMemory(allocation)"
  },
  {
    "label": "VmaClearDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaClearDetailedStatistics(pStats->total)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaBlockVector* const pBlockVector = m_pBlockVectors [ memTypeIndex ] ;)",
    "insertText": "if(pBlockVector != VMA_NULL) pBlockVector->AddDetailedStatistics(pStats->memoryType[memTypeIndex])"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (} { VmaMutexLockRead)",
    "insertText": "lock(m_PoolsMutex, m_UseMutex)"
  },
  {
    "label": "AddDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (blockVector .)",
    "insertText": "AddDetailedStatistics(pStats->memoryType[memTypeIndex])"
  },
  {
    "label": "VmaAddDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (const uint32_t memHeapIndex = m_MemProps . memoryTypes [ memTypeIndex ] . heapIndex ;)",
    "insertText": "VmaAddDetailedStatistics(pStats->memoryHeap[memHeapIndex], pStats->memoryType[memTypeIndex])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(uint32_t memHeapIndex = 0; memHeapIndex < GetMemoryHeapCount(); ++memHeapIndex) VmaAddDetailedStatistics(pStats->total, pStats->memoryHeap[memHeapIndex])"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pStats->total.statistics.allocationCount == 0 || pStats->total.allocationSizeMax >= pStats->total.allocationSizeMin)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pStats->total.unusedRangeCount == 0 || pStats->total.unusedRangeSizeMax >= pStats->total.unusedRangeSizeMin)"
  },
  {
    "label": "lockRead()",
    "kind": "Method",
    "detail": "Function (VmaMutexLockRead)",
    "insertText": "lockRead(m_Budget.m_BudgetMutex, m_UseMutex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const uint32_t heapIndex = firstHeap + i ; outBudgets -> statistics . blockCount = m_Budget . m_BlockCount [ heapIndex ] ; outBudgets -> statistics . allocationCount = m_Budget . m_AllocationCount [ heapIndex ] ; outBudgets -> statistics . blockBytes = m_Budget . m_BlockBytes [ heapIndex ] ; outBudgets -> statistics . allocationBytes = m_Budget . m_AllocationBytes [ heapIndex ] ;)",
    "insertText": "if(m_Budget.m_VulkanUsage[heapIndex] + outBudgets->statistics.blockBytes > m_Budget.m_BlockBytesAtBudgetFetch[heapIndex])"
  },
  {
    "label": "VMA_MIN()",
    "kind": "Method",
    "detail": "Function (outBudgets -> usage = m_Budget . m_VulkanUsage [ heapIndex ] + outBudgets -> statistics . blockBytes - m_Budget . m_BlockBytesAtBudgetFetch [ heapIndex ] ; } else { outBudgets -> usage = 0 ; } outBudgets -> budget =)",
    "insertText": "VMA_MIN(m_Budget.m_VulkanBudget[heapIndex], m_MemProps.memoryHeaps[heapIndex].size)"
  },
  {
    "label": "GetHeapBudgets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetHeapBudgets(outBudgets, firstHeap, heapCount)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } else # endif {)",
    "insertText": "for(uint32_t i = 0; i < heapCount; ++i, ++outBudgets)"
  },
  {
    "label": "GetAllocationInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetAllocationInfo(hAllocation, &pAllocationInfo->allocationInfo)"
  },
  {
    "label": "VMA_DEBUG_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG_FORMAT(\" CreatePool: MemoryTypeIndex=%\" PRIu32 \", flags=%\" PRIu32, pCreateInfo->memoryTypeIndex, pCreateInfo->flags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaPoolCreateInfo newCreateInfo =* pCreateInfo ;)",
    "insertText": "if(pCreateInfo->pMemoryAllocateNext)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(((const VkBaseInStructure*)pCreateInfo->pMemoryAllocateNext)->sType != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(newCreateInfo.maxBlockCount == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (newCreateInfo . maxBlockCount = SIZE_MAX ; })",
    "insertText": "if(newCreateInfo.minBlockCount > newCreateInfo.maxBlockCount)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(VmaIsPow2(newCreateInfo.minAllocationAlignment))"
  },
  {
    "label": "CalcPreferredBlockSize()",
    "kind": "Method",
    "detail": "Function (} const VkDeviceSize preferredBlockSize =)",
    "insertText": "CalcPreferredBlockSize(newCreateInfo.memoryTypeIndex)"
  },
  {
    "label": "vma_new()",
    "kind": "Method",
    "detail": "Function (* pPool =)",
    "insertText": "vma_new(this, VmaPool_T)(this, newCreateInfo, preferredBlockSize)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "res(*pPool)->m_BlockVector.CreateMinBlocks()"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vma_delete(this, *pPool)"
  },
  {
    "label": "PushBack()",
    "kind": "Method",
    "detail": "Function (m_Pools .)",
    "insertText": "PushBack(*pPool)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (m_Pools .)",
    "insertText": "Remove(pool)"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "vma_delete(this, pool)"
  },
  {
    "label": "VmaClearStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaClearStatistics(*pPoolStats)"
  },
  {
    "label": "AddStatistics()",
    "kind": "Method",
    "detail": "Function (pool -> m_BlockVector .)",
    "insertText": "AddStatistics(*pPoolStats)"
  },
  {
    "label": "VmaClearDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaClearDetailedStatistics(*pPoolStats)"
  },
  {
    "label": "AddDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (pool -> m_BlockVector .)",
    "insertText": "AddDetailedStatistics(*pPoolStats)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (m_CurrentFrameIndex .)",
    "insertText": "store(frameIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaBlockVector* const pBlockVector = m_pBlockVectors [ memTypeIndex ] ;)",
    "insertText": "if(pBlockVector != VMA_NULL)"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (AtomicTransactionalIncrement<VMA_ATOMIC_UINT32> deviceMemoryCountIncrement ; const uint64_t prevDeviceMemoryCount = deviceMemoryCountIncrement .)",
    "insertText": "Increment(&m_DeviceMemoryCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_DEBUG_DONT_EXCEED_MAX_MEMORY_ALLOCATION_COUNT)",
    "insertText": "if(prevDeviceMemoryCount >= m_PhysicalDeviceProperties.limits.maxMemoryAllocationCount)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize heapSize = m_MemProps . memoryHeaps [ heapIndex ] . size ; VkDeviceSize blockBytes = m_Budget . m_BlockBytes [ heapIndex ] ;)",
    "insertText": "for(;;)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const VkDeviceSize blockBytesAfterAllocation = blockBytes + pAllocateInfo -> allocationSize ;)",
    "insertText": "if(blockBytesAfterAllocation > heapSize)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (break ; } } } else { m_Budget . m_BlockBytes [ heapIndex ] + = pAllocateInfo -> allocationSize ; } + + m_Budget . m_BlockCount [ heapIndex ] ; VkResult)",
    "insertText": "res(*m_VulkanFunctions.vkAllocateMemory)(m_hDevice, pAllocateInfo, GetAllocationCallbacks(), pMemory)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_MEMORY_BUDGET + + m_Budget . m_OperationsSinceBudgetFetch ; # endif)",
    "insertText": "if(m_DeviceMemoryCallbacks.pfnAllocate != VMA_NULL)"
  },
  {
    "label": "MemoryTypeIndexToHeapIndex()",
    "kind": "Method",
    "detail": "Function (const uint32_t heapIndex =)",
    "insertText": "MemoryTypeIndexToHeapIndex(memoryType)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0 | | VMA_BIND_MEMORY2)",
    "insertText": "if((m_UseKhrBindMemory2 || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0)) && m_VulkanFunctions.vkBindBufferMemory2KHR != VMA_NULL)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (VkBindBufferMemoryInfoKHR bindBufferMemoryInfo = { VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR } ; bindBufferMemoryInfo . pNext = pNext ; bindBufferMemoryInfo . buffer = buffer ; bindBufferMemoryInfo . memory = memory ; bindBufferMemoryInfo . memoryOffset = memoryOffset ;)",
    "insertText": "return(*m_VulkanFunctions.vkBindBufferMemory2KHR)(m_hDevice, 1, &bindBufferMemoryInfo)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else # endif { return VK_ERROR_EXTENSION_NOT_PRESENT ; } } else {)",
    "insertText": "return(*m_VulkanFunctions.vkBindBufferMemory)(m_hDevice, buffer, memory, memoryOffset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0 | | VMA_BIND_MEMORY2)",
    "insertText": "if((m_UseKhrBindMemory2 || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0)) && m_VulkanFunctions.vkBindImageMemory2KHR != VMA_NULL)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (VkBindImageMemoryInfoKHR bindBufferMemoryInfo = { VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR } ; bindBufferMemoryInfo . pNext = pNext ; bindBufferMemoryInfo . image = image ; bindBufferMemoryInfo . memory = memory ; bindBufferMemoryInfo . memoryOffset = memoryOffset ;)",
    "insertText": "return(*m_VulkanFunctions.vkBindImageMemory2KHR)(m_hDevice, 1, &bindBufferMemoryInfo)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else # endif { return VK_ERROR_EXTENSION_NOT_PRESENT ; } } else {)",
    "insertText": "return(*m_VulkanFunctions.vkBindImageMemory)(m_hDevice, image, memory, memoryOffset)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (char* pBytes = VMA_NULL ; VkResult res = pBlock ->)",
    "insertText": "Map(this, 1, (void**)&pBytes)"
  },
  {
    "label": "pBytes()",
    "kind": "Method",
    "detail": "Function (* ppData =)",
    "insertText": "pBytes(ptrdiff_t)hAllocation->GetOffset()"
  },
  {
    "label": "DedicatedAllocMap()",
    "kind": "Method",
    "detail": "Function (} return res ; } VMA_FALLTHROUGH ; case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED : return hAllocation ->)",
    "insertText": "DedicatedAllocMap(this, ppData)"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (pBlock ->)",
    "insertText": "Unmap(this, 1)"
  },
  {
    "label": "DedicatedAllocUnmap()",
    "kind": "Method",
    "detail": "Function (} break ; case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED : hAllocation ->)",
    "insertText": "DedicatedAllocUnmap(this)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (VkResult res = VK_ERROR_UNKNOWN_COPY ;)",
    "insertText": "switch(hAllocation->GetType())"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pBlock && \"Binding buffer to allocation that doesn't belong to any block.\")"
  },
  {
    "label": "BindBufferMemory()",
    "kind": "Method",
    "detail": "Function (res = pBlock ->)",
    "insertText": "BindBufferMemory(this, hAllocation, allocationLocalOffset, hBuffer, pNext)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pBlock && \"Binding image to allocation that doesn't belong to any block.\")"
  },
  {
    "label": "BindImageMemory()",
    "kind": "Method",
    "detail": "Function (res = pBlock ->)",
    "insertText": "BindImageMemory(this, hAllocation, allocationLocalOffset, hImage, pNext)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VkResult res = VK_SUCCESS ; VkMappedMemoryRange memRange = { } ;)",
    "insertText": "if(GetFlushOrInvalidateRange(hAllocation, offset, size, memRange))"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (break ; case VMA_CACHE_INVALIDATE :)",
    "insertText": "res(*GetVulkanFunctions().vkInvalidateMappedMemoryRanges)(m_hDevice, 1, &memRange)"
  },
  {
    "label": "RangeVector()",
    "kind": "Method",
    "detail": "Function (typedef VmaStlAllocator<VkMappedMemoryRange> RangeAllocator ; typedef VmaSmallVector<VkMappedMemoryRange,RangeAllocator,1 6> RangeVector ; RangeVector ranges =)",
    "insertText": "RangeVector(RangeAllocator(GetAllocationCallbacks()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const VmaAllocation alloc = allocations [ allocIndex ] ; const VkDeviceSize offset = offsets ! = VMA_NULL ? offsets [ allocIndex ] : 0 ; const VkDeviceSize size = sizes ! = VMA_NULL ? sizes [ allocIndex ] : VK_WHOLE_SIZE ; VkMappedMemoryRange newRange ;)",
    "insertText": "if(GetFlushOrInvalidateRange(alloc, offset, size, newRange))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (ranges .)",
    "insertText": "push_back(newRange)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } VkResult res = VK_SUCCESS ;)",
    "insertText": "if(!ranges.empty())"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (break ; case VMA_CACHE_INVALIDATE :)",
    "insertText": "res(*GetVulkanFunctions().vkInvalidateMappedMemoryRanges)(m_hDevice, (uint32_t)ranges.size(), ranges.data())"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (void* dstMappedData = VMA_NULL ; VkResult res =)",
    "insertText": "Map(dstAllocation, &dstMappedData)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy((char*)dstMappedData + dstAllocationLocalOffset, pSrcHostPointer, (size_t)size)"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unmap(dstAllocation)"
  },
  {
    "label": "FlushOrInvalidateAllocation()",
    "kind": "Method",
    "detail": "Function (res =)",
    "insertText": "FlushOrInvalidateAllocation(dstAllocation, dstAllocationLocalOffset, size, VMA_CACHE_FLUSH)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (void* srcMappedData = VMA_NULL ; VkResult res =)",
    "insertText": "Map(srcAllocation, &srcMappedData)"
  },
  {
    "label": "FlushOrInvalidateAllocation()",
    "kind": "Method",
    "detail": "Function (res =)",
    "insertText": "FlushOrInvalidateAllocation(srcAllocation, srcAllocationLocalOffset, size, VMA_CACHE_INVALIDATE)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(pDstHostPointer, (const char*)srcMappedData + srcAllocationLocalOffset, (size_t)size)"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unmap(srcAllocation)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocation && allocation->GetType() == VmaAllocation_T::ALLOCATION_TYPE_DEDICATED)"
  },
  {
    "label": "Unregister()",
    "kind": "Method",
    "detail": "Function (m_DedicatedAllocations [ memTypeIndex ] .)",
    "insertText": "Unregister(allocation)"
  },
  {
    "label": "FreeVulkanMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeVulkanMemory(memTypeIndex, allocation->GetSize(), hMemory)"
  },
  {
    "label": "RemoveAllocation()",
    "kind": "Method",
    "detail": "Function (m_Budget .)",
    "insertText": "RemoveAllocation(MemoryTypeIndexToHeapIndex(allocation->GetMemoryTypeIndex()), allocation->GetSize())"
  },
  {
    "label": "VMA_DEBUG_LOG_FORMAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG_FORMAT(\" Freed DedicatedMemory MemoryTypeIndex=%\" PRIu32, memTypeIndex)"
  },
  {
    "label": "VmaFillGpuDefragmentationBufferCreateInfo()",
    "kind": "Method",
    "detail": "Function (VkBufferCreateInfo dummyBufCreateInfo ;)",
    "insertText": "VmaFillGpuDefragmentationBufferCreateInfo(dummyBufCreateInfo)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (uint32_t memoryTypeBits = 0 ; VkBuffer buf = VK_NULL_HANDLE ; VkResult)",
    "insertText": "res(*GetVulkanFunctions().vkCreateBuffer)( m_hDevice, &dummyBufCreateInfo, GetAllocationCallbacks(), &buf)"
  },
  {
    "label": "memReq()",
    "kind": "Method",
    "detail": "Function (VkMemoryRequirements)",
    "insertText": "memReq(*GetVulkanFunctions().vkGetBufferMemoryRequirements)(m_hDevice, buf, &memReq)"
  },
  {
    "label": "memoryTypeBits()",
    "kind": "Method",
    "detail": "Function (memoryTypeBits = memReq .)",
    "insertText": "memoryTypeBits(*GetVulkanFunctions().vkDestroyBuffer)(m_hDevice, buf, GetAllocationCallbacks())"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(GetMemoryTypeCount() > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32_t memoryTypeBits = UINT32_MAX ;)",
    "insertText": "if(!m_UseAmdDeviceCoherentMemory)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(offset <= allocationSize)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (outRange . size = allocationSize - outRange . offset ; } else {)",
    "insertText": "VMA_ASSERT(offset + size <= allocationSize)"
  },
  {
    "label": "VMA_MIN()",
    "kind": "Method",
    "detail": "Function (outRange . size =)",
    "insertText": "VMA_MIN(VmaAlignUp(size + (offset - outRange.offset), nonCoherentAtomSize), allocationSize - outRange.offset)"
  },
  {
    "label": "VmaAlignDown()",
    "kind": "Method",
    "detail": "Function (} break ; case VmaAllocation_T::ALLOCATION_TYPE_BLOCK : { outRange . offset =)",
    "insertText": "VmaAlignDown(offset, nonCoherentAtomSize)"
  },
  {
    "label": "VmaAlignUp()",
    "kind": "Method",
    "detail": "Function (} outRange . size =)",
    "insertText": "VmaAlignUp(size + (offset - outRange.offset), nonCoherentAtomSize)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocationOffset % nonCoherentAtomSize == 0)"
  },
  {
    "label": "VMA_MIN()",
    "kind": "Method",
    "detail": "Function (outRange . offset + = allocationOffset ; outRange . size =)",
    "insertText": "VMA_MIN(outRange.size, blockSize - outRange.offset)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(m_UseExtMemoryBudget)"
  },
  {
    "label": "VmaPnextChainPushFront()",
    "kind": "Method",
    "detail": "Function (VkPhysicalDeviceMemoryProperties2KHR memProps = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR } ; VkPhysicalDeviceMemoryBudgetPropertiesEXT budgetProps = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT } ;)",
    "insertText": "VmaPnextChainPushFront(&memProps, &budgetProps)"
  },
  {
    "label": "GetVulkanFunctions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetVulkanFunctions().vkGetPhysicalDeviceMemoryProperties2KHR(m_PhysicalDevice, &memProps)"
  },
  {
    "label": "lockWrite()",
    "kind": "Method",
    "detail": "Function ({ VmaMutexLockWrite)",
    "insertText": "lockWrite(m_Budget.m_BudgetMutex, m_UseMutex)"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (m_Budget . m_VulkanUsage [ heapIndex ] = budgetProps . heapUsage [ heapIndex ] ; m_Budget . m_VulkanBudget [ heapIndex ] = budgetProps . heapBudget [ heapIndex ] ; m_Budget . m_BlockBytesAtBudgetFetch [ heapIndex ] = m_Budget . m_BlockBytes [ heapIndex ] .)",
    "insertText": "load()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_Budget . m_VulkanBudget [ heapIndex ] = m_MemProps . memoryHeaps [ heapIndex ] . size* 8 / 1 0 ; } else)",
    "insertText": "if(m_Budget.m_VulkanBudget[heapIndex] > m_MemProps.memoryHeaps[heapIndex].size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_Budget . m_VulkanBudget [ heapIndex ] = m_MemProps . memoryHeaps [ heapIndex ] . size ; })",
    "insertText": "if(m_Budget.m_VulkanUsage[heapIndex] == 0 && m_Budget.m_BlockBytesAtBudgetFetch[heapIndex] > 0)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (void* pData = VMA_NULL ; VkResult res =)",
    "insertText": "Map(hAllocation, &pData)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(pData, (int)pattern, (size_t)hAllocation->GetSize())"
  },
  {
    "label": "FlushOrInvalidateAllocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushOrInvalidateAllocation(hAllocation, 0, VK_WHOLE_SIZE, VMA_CACHE_FLUSH)"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unmap(hAllocation)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "VMA_ASSERT(0 && \"VMA_DEBUG_INITIALIZE_ALLOCATIONS is enabled, but couldn't map memory to fill allocation.\")"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (m_GpuDefragmentationMemoryTypeBits .)",
    "insertText": "store(memoryTypeBits)"
  },
  {
    "label": "PrintDetailedMap()",
    "kind": "Method",
    "detail": "Function (} return memoryTypeBits ; } # if VMA_STATS_STRING_ENABLED void)",
    "insertText": "PrintDetailedMap(VmaJsonWriter& json)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"DefaultPools\")"
  },
  {
    "label": "BeginString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "BeginString(\"Type \")"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString(memTypeIndex)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function ({ json .)",
    "insertText": "WriteString(\"PreferredBlockSize\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(pBlockVector->GetPreferredBlockSize())"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Blocks\")"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"DedicatedAllocations\")"
  },
  {
    "label": "BuildStatsString()",
    "kind": "Method",
    "detail": "Function (dedicatedAllocList .)",
    "insertText": "BuildStatsString(json)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"CustomPools\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool displayType = true ; size_t index = 0 ;)",
    "insertText": "for(VmaPool pool = m_Pools.Front(); pool != VMA_NULL; pool = m_Pools.GetNext(pool))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VmaBlockVector& blockVector = pool -> m_BlockVector ;)",
    "insertText": "if(blockVector.GetMemoryTypeIndex() == memTypeIndex)"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString((uint64_t)index++)"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString(\" - \")"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString(pool->GetName())"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(blockVector.GetPreferredBlockSize())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(!displayType) json.EndArray()"
  },
  {
    "label": "vmaCreateAllocator()",
    "kind": "Method",
    "detail": "Function (} # endif # endif # ifndef _VMA_PUBLIC_INTERFACE VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateAllocator(const VmaAllocatorCreateInfo* pCreateInfo, VmaAllocator* pAllocator)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pCreateInfo && pAllocator)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pCreateInfo->vulkanApiVersion == 0 || (VK_VERSION_MAJOR(pCreateInfo->vulkanApiVersion) == 1 && VK_VERSION_MINOR(pCreateInfo->vulkanApiVersion) <= 3))"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaCreateAllocator\")"
  },
  {
    "label": "vma_new()",
    "kind": "Method",
    "detail": "Function (* pAllocator =)",
    "insertText": "vma_new(pCreateInfo->pAllocationCallbacks, VmaAllocator_T)(pCreateInfo)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "result(*pAllocator)->Init(pCreateInfo)"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vma_delete(pCreateInfo->pAllocationCallbacks, *pAllocator)"
  },
  {
    "label": "vmaDestroyAllocator()",
    "kind": "Method",
    "detail": "Function (* pAllocator = VK_NULL_HANDLE ; } return result ; } VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaDestroyAllocator(VmaAllocator allocator)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaDestroyAllocator\")"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (VkAllocationCallbacks allocationCallbacks = allocator -> m_AllocationCallbacks ;)",
    "insertText": "vma_delete(&allocationCallbacks, allocator)"
  },
  {
    "label": "vmaGetAllocatorInfo()",
    "kind": "Method",
    "detail": "Function (} } VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetAllocatorInfo(VmaAllocator allocator, VmaAllocatorInfo* pAllocatorInfo)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pAllocatorInfo)"
  },
  {
    "label": "GetPhysicalDevice()",
    "kind": "Method",
    "detail": "Function (pAllocatorInfo -> instance = allocator -> m_hInstance ; pAllocatorInfo -> physicalDevice = allocator ->)",
    "insertText": "GetPhysicalDevice()"
  },
  {
    "label": "vmaGetPhysicalDeviceProperties()",
    "kind": "Method",
    "detail": "Function (pAllocatorInfo -> device = allocator -> m_hDevice ; } VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetPhysicalDeviceProperties(VmaAllocator allocator, const VkPhysicalDeviceProperties **ppPhysicalDeviceProperties)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && ppPhysicalDeviceProperties)"
  },
  {
    "label": "vmaGetMemoryProperties()",
    "kind": "Method",
    "detail": "Function (* ppPhysicalDeviceProperties =& allocator -> m_PhysicalDeviceProperties ; } VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetMemoryProperties(VmaAllocator allocator, const VkPhysicalDeviceMemoryProperties** ppPhysicalDeviceMemoryProperties)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && ppPhysicalDeviceMemoryProperties)"
  },
  {
    "label": "vmaGetMemoryTypeProperties()",
    "kind": "Method",
    "detail": "Function (* ppPhysicalDeviceMemoryProperties =& allocator -> m_MemProps ; } VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetMemoryTypeProperties(VmaAllocator allocator, uint32_t memoryTypeIndex, VkMemoryPropertyFlags* pFlags)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pFlags)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(memoryTypeIndex < allocator->GetMemoryTypeCount())"
  },
  {
    "label": "vmaSetCurrentFrameIndex()",
    "kind": "Method",
    "detail": "Function (* pFlags = allocator -> m_MemProps . memoryTypes [ memoryTypeIndex ] . propertyFlags ; } VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaSetCurrentFrameIndex(VmaAllocator allocator, uint32_t frameIndex)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator)"
  },
  {
    "label": "SetCurrentFrameIndex()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocator ->)",
    "insertText": "SetCurrentFrameIndex(frameIndex)"
  },
  {
    "label": "vmaCalculateStatistics()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaCalculateStatistics(VmaAllocator allocator, VmaTotalStatistics* pStats)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pStats)"
  },
  {
    "label": "CalculateStatistics()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocator ->)",
    "insertText": "CalculateStatistics(pStats)"
  },
  {
    "label": "vmaGetHeapBudgets()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetHeapBudgets(VmaAllocator allocator, VmaBudget* pBudgets)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pBudgets)"
  },
  {
    "label": "GetHeapBudgets()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocator ->)",
    "insertText": "GetHeapBudgets(pBudgets, 0, allocator->GetMemoryHeapCount())"
  },
  {
    "label": "vmaBuildStatsString()",
    "kind": "Method",
    "detail": "Function (} # if VMA_STATS_STRING_ENABLED VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaBuildStatsString(VmaAllocator allocator, char** ppStatsString, VkBool32 detailedMap)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && ppStatsString)"
  },
  {
    "label": "sb()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK VmaStringBuilder)",
    "insertText": "sb(allocator->GetAllocationCallbacks())"
  },
  {
    "label": "GetHeapBudgets()",
    "kind": "Method",
    "detail": "Function ({ VmaBudget budgets [ VK_MAX_MEMORY_HEAPS ] ; allocator ->)",
    "insertText": "GetHeapBudgets(budgets, 0, allocator->GetMemoryHeapCount())"
  },
  {
    "label": "CalculateStatistics()",
    "kind": "Method",
    "detail": "Function (VmaTotalStatistics stats ; allocator ->)",
    "insertText": "CalculateStatistics(&stats)"
  },
  {
    "label": "json()",
    "kind": "Method",
    "detail": "Function (VmaJsonWriter)",
    "insertText": "json(allocator->GetAllocationCallbacks(), sb)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function ({ json .)",
    "insertText": "WriteString(\"General\")"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function ({ const VkPhysicalDeviceProperties& deviceProperties = allocator -> m_PhysicalDeviceProperties ; const VkPhysicalDeviceMemoryProperties& memoryProperties = allocator -> m_MemProps ; json .)",
    "insertText": "WriteString(\"API\")"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Vulkan\")"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"apiVersion\")"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString(VK_VERSION_MAJOR(deviceProperties.apiVersion))"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString(\".\")"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString(VK_VERSION_MINOR(deviceProperties.apiVersion))"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString(VK_VERSION_PATCH(deviceProperties.apiVersion))"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"GPU\")"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(deviceProperties.deviceName)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"deviceType\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(static_cast<uint32_t>(deviceProperties.deviceType))"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"maxMemoryAllocationCount\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(deviceProperties.limits.maxMemoryAllocationCount)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"bufferImageGranularity\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(deviceProperties.limits.bufferImageGranularity)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"nonCoherentAtomSize\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(deviceProperties.limits.nonCoherentAtomSize)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"memoryHeapCount\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(memoryProperties.memoryHeapCount)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"memoryTypeCount\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(memoryProperties.memoryTypeCount)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (} { json .)",
    "insertText": "WriteString(\"Total\")"
  },
  {
    "label": "VmaPrintDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaPrintDetailedStatistics(json, stats.total)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (} { json .)",
    "insertText": "WriteString(\"MemoryInfo\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "for(uint32_t heapIndex = 0; heapIndex < allocator->GetMemoryHeapCount(); ++heapIndex)"
  },
  {
    "label": "BeginString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "BeginString(\"Heap \")"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString(heapIndex)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function ({ const VkMemoryHeap& heapInfo = allocator -> m_MemProps . memoryHeaps [ heapIndex ] ; json .)",
    "insertText": "WriteString(\"Flags\")"
  },
  {
    "label": "BeginArray()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "BeginArray(true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "if(heapInfo.flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT) json.WriteString(\"DEVICE_LOCAL\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0)",
    "insertText": "if(heapInfo.flags & VK_MEMORY_HEAP_MULTI_INSTANCE_BIT) json.WriteString(\"MULTI_INSTANCE\")"
  },
  {
    "label": "flags()",
    "kind": "Method",
    "detail": "Function (# endif VkMemoryHeapFlags flags = heapInfo .)",
    "insertText": "flags(VK_MEMORY_HEAP_DEVICE_LOCAL_BIT #if VMA_VULKAN_VERSION >= 1001000 | VK_MEMORY_HEAP_MULTI_INSTANCE_BIT #endif)"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(heapInfo.size)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"Budget\")"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function ({ json .)",
    "insertText": "WriteString(\"BudgetBytes\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(budgets[heapIndex].budget)"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"UsageBytes\")"
  },
  {
    "label": "WriteNumber()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteNumber(budgets[heapIndex].usage)"
  },
  {
    "label": "VmaPrintDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaPrintDetailedStatistics(json, stats.memoryHeap[heapIndex])"
  },
  {
    "label": "WriteString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "WriteString(\"MemoryPools\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "for(uint32_t typeIndex = 0; typeIndex < allocator->GetMemoryTypeCount(); ++typeIndex)"
  },
  {
    "label": "ContinueString()",
    "kind": "Method",
    "detail": "Function (json .)",
    "insertText": "ContinueString(typeIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function ({ VkMemoryPropertyFlags flags = allocator -> m_MemProps . memoryTypes [ typeIndex ] . propertyFlags ;)",
    "insertText": "if(flags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) json.WriteString(\"DEVICE_LOCAL\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if VMA_VULKAN_VERSION> = 1 0 0 1 0 0 0)",
    "insertText": "if(flags & VK_MEMORY_PROPERTY_PROTECTED_BIT) json.WriteString(\"PROTECTED\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif # if VK_AMD_device_coherent_memory)",
    "insertText": "if(flags & VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY) json.WriteString(\"DEVICE_COHERENT_AMD\")"
  },
  {
    "label": "flags()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "flags(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT #if VMA_VULKAN_VERSION >= 1001000 | VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT #endif #if VK_AMD_device_coherent_memory | VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY | VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY #endif | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT)"
  },
  {
    "label": "VmaPrintDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaPrintDetailedStatistics(json, stats.memoryType[typeIndex])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(detailedMap == VK_TRUE) allocator->PrintDetailedMap(json)"
  },
  {
    "label": "VmaCreateStringCopy()",
    "kind": "Method",
    "detail": "Function (}* ppStatsString =)",
    "insertText": "VmaCreateStringCopy(allocator->GetAllocationCallbacks(), sb.GetData(), sb.GetLength())"
  },
  {
    "label": "vmaFreeStatsString()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaFreeStatsString(VmaAllocator allocator, char* pStatsString)"
  },
  {
    "label": "VmaFreeString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VmaFreeString(allocator->GetAllocationCallbacks(), pStatsString)"
  },
  {
    "label": "vmaFindMemoryTypeIndex()",
    "kind": "Method",
    "detail": "Function (} } # endif VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaFindMemoryTypeIndex(VmaAllocator allocator, uint32_t memoryTypeBits, const VmaAllocationCreateInfo* pAllocationCreateInfo, uint32_t* pMemoryTypeIndex)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator != VK_NULL_HANDLE)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pAllocationCreateInfo != VMA_NULL)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pMemoryTypeIndex != VMA_NULL)"
  },
  {
    "label": "vmaFindMemoryTypeIndexForBufferInfo()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaFindMemoryTypeIndexForBufferInfo(VmaAllocator allocator, const VkBufferCreateInfo* pBufferCreateInfo, const VmaAllocationCreateInfo* pAllocationCreateInfo, uint32_t* pMemoryTypeIndex)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pBufferCreateInfo != VMA_NULL)"
  },
  {
    "label": "GetVulkanFunctions()",
    "kind": "Method",
    "detail": "Function (const VkDevice hDev = allocator -> m_hDevice ; const VmaVulkanFunctions* funcs =& allocator ->)",
    "insertText": "GetVulkanFunctions()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VkResult res ; # if VMA_KHR_MAINTENANCE4 | | VMA_VULKAN_VERSION> = 1 0 0 3 0 0 0)",
    "insertText": "if(funcs->vkGetDeviceBufferMemoryRequirements)"
  },
  {
    "label": "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2()",
    "kind": "Method",
    "detail": "Function (VkDeviceBufferMemoryRequirementsKHR devBufMemReq = { VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR } ; devBufMemReq . pCreateInfo = pBufferCreateInfo ; VkMemoryRequirements2 memReq = {)",
    "insertText": "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2(*funcs->vkGetDeviceBufferMemoryRequirements)(hDev, &devBufMemReq, &memReq)"
  },
  {
    "label": "FindMemoryTypeIndex()",
    "kind": "Method",
    "detail": "Function (res = allocator ->)",
    "insertText": "FindMemoryTypeIndex(memReq.memoryRequirements.memoryTypeBits, pAllocationCreateInfo, VmaBufferImageUsage(*pBufferCreateInfo, allocator->m_UseKhrMaintenance5), pMemoryTypeIndex)"
  },
  {
    "label": "vkCreateBuffer()",
    "kind": "Method",
    "detail": "Function (} else # endif { VkBuffer hBuffer = VK_NULL_HANDLE ; res = funcs ->)",
    "insertText": "vkCreateBuffer(hDev, pBufferCreateInfo, allocator->GetAllocationCallbacks(), &hBuffer)"
  },
  {
    "label": "vkGetBufferMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (VkMemoryRequirements memReq = { } ; funcs ->)",
    "insertText": "vkGetBufferMemoryRequirements(hDev, hBuffer, &memReq)"
  },
  {
    "label": "FindMemoryTypeIndex()",
    "kind": "Method",
    "detail": "Function (res = allocator ->)",
    "insertText": "FindMemoryTypeIndex(memReq.memoryTypeBits, pAllocationCreateInfo, VmaBufferImageUsage(*pBufferCreateInfo, allocator->m_UseKhrMaintenance5), pMemoryTypeIndex)"
  },
  {
    "label": "vkDestroyBuffer()",
    "kind": "Method",
    "detail": "Function (funcs ->)",
    "insertText": "vkDestroyBuffer(hDev, hBuffer, allocator->GetAllocationCallbacks())"
  },
  {
    "label": "vmaFindMemoryTypeIndexForImageInfo()",
    "kind": "Method",
    "detail": "Function (} } return res ; } VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaFindMemoryTypeIndexForImageInfo(VmaAllocator allocator, const VkImageCreateInfo* pImageCreateInfo, const VmaAllocationCreateInfo* pAllocationCreateInfo, uint32_t* pMemoryTypeIndex)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pImageCreateInfo != VMA_NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VkResult res ; # if VMA_KHR_MAINTENANCE4 | | VMA_VULKAN_VERSION> = 1 0 0 3 0 0 0)",
    "insertText": "if(funcs->vkGetDeviceImageMemoryRequirements)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (VkDeviceImageMemoryRequirementsKHR devImgMemReq = { VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR } ; devImgMemReq . pCreateInfo = pImageCreateInfo ;)",
    "insertText": "VMA_ASSERT(pImageCreateInfo->tiling != VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT_COPY && (pImageCreateInfo->flags & VK_IMAGE_CREATE_DISJOINT_BIT_COPY) == 0 && \"Cannot use this VkImageCreateInfo with vmaFindMemoryTypeIndexForImageInfo as I don't know what to pass as VkDeviceImageMemoryRequirements::planeAspect.\")"
  },
  {
    "label": "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2()",
    "kind": "Method",
    "detail": "Function (VkMemoryRequirements2 memReq = {)",
    "insertText": "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2(*funcs->vkGetDeviceImageMemoryRequirements)(hDev, &devImgMemReq, &memReq)"
  },
  {
    "label": "FindMemoryTypeIndex()",
    "kind": "Method",
    "detail": "Function (res = allocator ->)",
    "insertText": "FindMemoryTypeIndex(memReq.memoryRequirements.memoryTypeBits, pAllocationCreateInfo, VmaBufferImageUsage(*pImageCreateInfo), pMemoryTypeIndex)"
  },
  {
    "label": "vkCreateImage()",
    "kind": "Method",
    "detail": "Function (} else # endif { VkImage hImage = VK_NULL_HANDLE ; res = funcs ->)",
    "insertText": "vkCreateImage(hDev, pImageCreateInfo, allocator->GetAllocationCallbacks(), &hImage)"
  },
  {
    "label": "vkGetImageMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (VkMemoryRequirements memReq = { } ; funcs ->)",
    "insertText": "vkGetImageMemoryRequirements(hDev, hImage, &memReq)"
  },
  {
    "label": "FindMemoryTypeIndex()",
    "kind": "Method",
    "detail": "Function (res = allocator ->)",
    "insertText": "FindMemoryTypeIndex(memReq.memoryTypeBits, pAllocationCreateInfo, VmaBufferImageUsage(*pImageCreateInfo), pMemoryTypeIndex)"
  },
  {
    "label": "vkDestroyImage()",
    "kind": "Method",
    "detail": "Function (funcs ->)",
    "insertText": "vkDestroyImage(hDev, hImage, allocator->GetAllocationCallbacks())"
  },
  {
    "label": "vmaCreatePool()",
    "kind": "Method",
    "detail": "Function (} } return res ; } VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreatePool(VmaAllocator allocator, const VmaPoolCreateInfo* pCreateInfo, VmaPool* pPool)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pCreateInfo && pPool)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaCreatePool\")"
  },
  {
    "label": "CreatePool()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "CreatePool(pCreateInfo, pPool)"
  },
  {
    "label": "vmaDestroyPool()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaDestroyPool(VmaAllocator allocator, VmaPool pool)"
  },
  {
    "label": "DestroyPool()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocator ->)",
    "insertText": "DestroyPool(pool)"
  },
  {
    "label": "vmaGetPoolStatistics()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetPoolStatistics(VmaAllocator allocator, VmaPool pool, VmaStatistics* pPoolStats)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pool && pPoolStats)"
  },
  {
    "label": "GetPoolStatistics()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocator ->)",
    "insertText": "GetPoolStatistics(pool, pPoolStats)"
  },
  {
    "label": "vmaCalculatePoolStatistics()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaCalculatePoolStatistics(VmaAllocator allocator, VmaPool pool, VmaDetailedStatistics* pPoolStats)"
  },
  {
    "label": "CalculatePoolStatistics()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocator ->)",
    "insertText": "CalculatePoolStatistics(pool, pPoolStats)"
  },
  {
    "label": "vmaCheckPoolCorruption()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCheckPoolCorruption(VmaAllocator allocator, VmaPool pool)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pool)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK)",
    "insertText": "VMA_DEBUG_LOG(\"vmaCheckPoolCorruption\")"
  },
  {
    "label": "vmaGetPoolName()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetPoolName(VmaAllocator allocator, VmaPool pool, const char** ppName)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pool && ppName)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaGetPoolName\")"
  },
  {
    "label": "vmaSetPoolName()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaSetPoolName(VmaAllocator allocator, VmaPool pool, const char* pName)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaSetPoolName\")"
  },
  {
    "label": "SetName()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK pool ->)",
    "insertText": "SetName(pName)"
  },
  {
    "label": "vmaAllocateMemory()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaAllocateMemory(VmaAllocator allocator, const VkMemoryRequirements* pVkMemoryRequirements, const VmaAllocationCreateInfo* pCreateInfo, VmaAllocation* pAllocation, VmaAllocationInfo* pAllocationInfo)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pVkMemoryRequirements && pCreateInfo && pAllocation)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaAllocateMemory\")"
  },
  {
    "label": "AllocateMemory()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK VkResult result = allocator ->)",
    "insertText": "AllocateMemory(*pVkMemoryRequirements, false, false, VK_NULL_HANDLE, VK_NULL_HANDLE, VmaBufferImageUsage::UNKNOWN, *pCreateInfo, VMA_SUBALLOCATION_TYPE_UNKNOWN, 1, pAllocation)"
  },
  {
    "label": "GetAllocationInfo()",
    "kind": "Method",
    "detail": "Function (allocator ->)",
    "insertText": "GetAllocationInfo(*pAllocation, pAllocationInfo)"
  },
  {
    "label": "vmaAllocateMemoryPages()",
    "kind": "Method",
    "detail": "Function (} return result ; } VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaAllocateMemoryPages(VmaAllocator allocator, const VkMemoryRequirements* pVkMemoryRequirements, const VmaAllocationCreateInfo* pCreateInfo, size_t allocationCount, VmaAllocation* pAllocations, VmaAllocationInfo* pAllocationInfo)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaAllocateMemoryPages\")"
  },
  {
    "label": "AllocateMemory()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK VkResult result = allocator ->)",
    "insertText": "AllocateMemory(*pVkMemoryRequirements, false, false, VK_NULL_HANDLE, VK_NULL_HANDLE, VmaBufferImageUsage::UNKNOWN, *pCreateInfo, VMA_SUBALLOCATION_TYPE_UNKNOWN, allocationCount, pAllocations)"
  },
  {
    "label": "GetAllocationInfo()",
    "kind": "Method",
    "detail": "Function (allocator ->)",
    "insertText": "GetAllocationInfo(pAllocations[i], pAllocationInfo + i)"
  },
  {
    "label": "vmaAllocateMemoryForBuffer()",
    "kind": "Method",
    "detail": "Function (} } return result ; } VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaAllocateMemoryForBuffer(VmaAllocator allocator, VkBuffer buffer, const VmaAllocationCreateInfo* pCreateInfo, VmaAllocation* pAllocation, VmaAllocationInfo* pAllocationInfo)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && buffer != VK_NULL_HANDLE && pCreateInfo && pAllocation)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaAllocateMemoryForBuffer\")"
  },
  {
    "label": "GetBufferMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK VkMemoryRequirements vkMemReq = { } ; bool requiresDedicatedAllocation = false ; bool prefersDedicatedAllocation = false ; allocator ->)",
    "insertText": "GetBufferMemoryRequirements(buffer, vkMemReq, requiresDedicatedAllocation, prefersDedicatedAllocation)"
  },
  {
    "label": "AllocateMemory()",
    "kind": "Method",
    "detail": "Function (VkResult result = allocator ->)",
    "insertText": "AllocateMemory(vkMemReq, requiresDedicatedAllocation, prefersDedicatedAllocation, buffer, VK_NULL_HANDLE, VmaBufferImageUsage::UNKNOWN, *pCreateInfo, VMA_SUBALLOCATION_TYPE_BUFFER, 1, pAllocation)"
  },
  {
    "label": "vmaAllocateMemoryForImage()",
    "kind": "Method",
    "detail": "Function (} return result ; } VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaAllocateMemoryForImage(VmaAllocator allocator, VkImage image, const VmaAllocationCreateInfo* pCreateInfo, VmaAllocation* pAllocation, VmaAllocationInfo* pAllocationInfo)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && image != VK_NULL_HANDLE && pCreateInfo && pAllocation)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaAllocateMemoryForImage\")"
  },
  {
    "label": "GetImageMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK VkMemoryRequirements vkMemReq = { } ; bool requiresDedicatedAllocation = false ; bool prefersDedicatedAllocation = false ; allocator ->)",
    "insertText": "GetImageMemoryRequirements(image, vkMemReq, requiresDedicatedAllocation, prefersDedicatedAllocation)"
  },
  {
    "label": "AllocateMemory()",
    "kind": "Method",
    "detail": "Function (VkResult result = allocator ->)",
    "insertText": "AllocateMemory(vkMemReq, requiresDedicatedAllocation, prefersDedicatedAllocation, VK_NULL_HANDLE, image, VmaBufferImageUsage::UNKNOWN, *pCreateInfo, VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN, 1, pAllocation)"
  },
  {
    "label": "vmaFreeMemory()",
    "kind": "Method",
    "detail": "Function (} return result ; } VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaFreeMemory(VmaAllocator allocator, VmaAllocation allocation)"
  },
  {
    "label": "FreeMemory()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocator ->)",
    "insertText": "FreeMemory(1, &allocation)"
  },
  {
    "label": "vmaFreeMemoryPages()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaFreeMemoryPages(VmaAllocator allocator, size_t allocationCount, const VmaAllocation* pAllocations)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaFreeMemoryPages\")"
  },
  {
    "label": "FreeMemory()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocator ->)",
    "insertText": "FreeMemory(allocationCount, pAllocations)"
  },
  {
    "label": "vmaGetAllocationInfo()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetAllocationInfo(VmaAllocator allocator, VmaAllocation allocation, VmaAllocationInfo* pAllocationInfo)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && allocation && pAllocationInfo)"
  },
  {
    "label": "GetAllocationInfo()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocator ->)",
    "insertText": "GetAllocationInfo(allocation, pAllocationInfo)"
  },
  {
    "label": "vmaGetAllocationInfo2()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaGetAllocationInfo2(VmaAllocator allocator, VmaAllocation allocation, VmaAllocationInfo2* pAllocationInfo)"
  },
  {
    "label": "GetAllocationInfo2()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocator ->)",
    "insertText": "GetAllocationInfo2(allocation, pAllocationInfo)"
  },
  {
    "label": "vmaSetAllocationUserData()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaSetAllocationUserData(VmaAllocator allocator, VmaAllocation allocation, void* pUserData)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && allocation)"
  },
  {
    "label": "SetUserData()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocation ->)",
    "insertText": "SetUserData(allocator, pUserData)"
  },
  {
    "label": "SetName()",
    "kind": "Method",
    "detail": "Function (allocation ->)",
    "insertText": "SetName(allocator, pName)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && allocation && pFlags)"
  },
  {
    "label": "vmaMapMemory()",
    "kind": "Method",
    "detail": "Function (* pFlags = allocator -> m_MemProps . memoryTypes [ memTypeIndex ] . propertyFlags ; } VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaMapMemory(VmaAllocator allocator, VmaAllocation allocation, void** ppData)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && allocation && ppData)"
  },
  {
    "label": "Map()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "Map(allocation, ppData)"
  },
  {
    "label": "vmaUnmapMemory()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaUnmapMemory(VmaAllocator allocator, VmaAllocation allocation)"
  },
  {
    "label": "Unmap()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK allocator ->)",
    "insertText": "Unmap(allocation)"
  },
  {
    "label": "vmaFlushAllocation()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaFlushAllocation(VmaAllocator allocator, VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaFlushAllocation\")"
  },
  {
    "label": "FlushOrInvalidateAllocation()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "FlushOrInvalidateAllocation(allocation, offset, size, VMA_CACHE_FLUSH)"
  },
  {
    "label": "vmaInvalidateAllocation()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaInvalidateAllocation(VmaAllocator allocator, VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaInvalidateAllocation\")"
  },
  {
    "label": "FlushOrInvalidateAllocation()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "FlushOrInvalidateAllocation(allocation, offset, size, VMA_CACHE_INVALIDATE)"
  },
  {
    "label": "vmaFlushAllocations()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaFlushAllocations(VmaAllocator allocator, uint32_t allocationCount, const VmaAllocation* allocations, const VkDeviceSize* offsets, const VkDeviceSize* sizes)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaFlushAllocations\")"
  },
  {
    "label": "FlushOrInvalidateAllocations()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "FlushOrInvalidateAllocations(allocationCount, allocations, offsets, sizes, VMA_CACHE_FLUSH)"
  },
  {
    "label": "vmaInvalidateAllocations()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaInvalidateAllocations(VmaAllocator allocator, uint32_t allocationCount, const VmaAllocation* allocations, const VkDeviceSize* offsets, const VkDeviceSize* sizes)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaInvalidateAllocations\")"
  },
  {
    "label": "FlushOrInvalidateAllocations()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "FlushOrInvalidateAllocations(allocationCount, allocations, offsets, sizes, VMA_CACHE_INVALIDATE)"
  },
  {
    "label": "vmaCopyMemoryToAllocation()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCopyMemoryToAllocation(VmaAllocator allocator, const void* pSrcHostPointer, VmaAllocation dstAllocation, VkDeviceSize dstAllocationLocalOffset, VkDeviceSize size)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pSrcHostPointer && dstAllocation)"
  },
  {
    "label": "CopyMemoryToAllocation()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "CopyMemoryToAllocation(pSrcHostPointer, dstAllocation, dstAllocationLocalOffset, size)"
  },
  {
    "label": "vmaCopyAllocationToMemory()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCopyAllocationToMemory(VmaAllocator allocator, VmaAllocation srcAllocation, VkDeviceSize srcAllocationLocalOffset, void* pDstHostPointer, VkDeviceSize size)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && srcAllocation && pDstHostPointer)"
  },
  {
    "label": "CopyAllocationToMemory()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "CopyAllocationToMemory(srcAllocation, srcAllocationLocalOffset, pDstHostPointer, size)"
  },
  {
    "label": "vmaCheckCorruption()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCheckCorruption(VmaAllocator allocator, uint32_t memoryTypeBits)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaCheckCorruption\")"
  },
  {
    "label": "CheckCorruption()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "CheckCorruption(memoryTypeBits)"
  },
  {
    "label": "vmaBeginDefragmentation()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaBeginDefragmentation(VmaAllocator allocator, const VmaDefragmentationInfo* pInfo, VmaDefragmentationContext* pContext)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pInfo && pContext)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaBeginDefragmentation\")"
  },
  {
    "label": "vma_new()",
    "kind": "Method",
    "detail": "Function (} VMA_DEBUG_GLOBAL_MUTEX_LOCK* pContext =)",
    "insertText": "vma_new(allocator, VmaDefragmentationContext_T)(allocator, *pInfo)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && context)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaEndDefragmentation\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK)",
    "insertText": "if(pStats) context->GetStats(*pStats)"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vma_delete(allocator, context)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(context && pPassInfo)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaBeginDefragmentationPass\")"
  },
  {
    "label": "DefragmentPassBegin()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return context ->)",
    "insertText": "DefragmentPassBegin(*pPassInfo)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaEndDefragmentationPass\")"
  },
  {
    "label": "DefragmentPassEnd()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return context ->)",
    "insertText": "DefragmentPassEnd(*pPassInfo)"
  },
  {
    "label": "vmaBindBufferMemory()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaBindBufferMemory(VmaAllocator allocator, VmaAllocation allocation, VkBuffer buffer)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && allocation && buffer)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaBindBufferMemory\")"
  },
  {
    "label": "BindBufferMemory()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "BindBufferMemory(allocation, 0, buffer, VMA_NULL)"
  },
  {
    "label": "vmaBindBufferMemory2()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaBindBufferMemory2(VmaAllocator allocator, VmaAllocation allocation, VkDeviceSize allocationLocalOffset, VkBuffer buffer, const void* pNext)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaBindBufferMemory2\")"
  },
  {
    "label": "BindBufferMemory()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "BindBufferMemory(allocation, allocationLocalOffset, buffer, pNext)"
  },
  {
    "label": "vmaBindImageMemory()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaBindImageMemory(VmaAllocator allocator, VmaAllocation allocation, VkImage image)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && allocation && image)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaBindImageMemory\")"
  },
  {
    "label": "BindImageMemory()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "BindImageMemory(allocation, 0, image, VMA_NULL)"
  },
  {
    "label": "vmaBindImageMemory2()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaBindImageMemory2(VmaAllocator allocator, VmaAllocation allocation, VkDeviceSize allocationLocalOffset, VkImage image, const void* pNext)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaBindImageMemory2\")"
  },
  {
    "label": "BindImageMemory()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK return allocator ->)",
    "insertText": "BindImageMemory(allocation, allocationLocalOffset, image, pNext)"
  },
  {
    "label": "vmaCreateBuffer()",
    "kind": "Method",
    "detail": "Function (} VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateBuffer(VmaAllocator allocator, const VkBufferCreateInfo* pBufferCreateInfo, const VmaAllocationCreateInfo* pAllocationCreateInfo, VkBuffer* pBuffer, VmaAllocation* pAllocation, VmaAllocationInfo* pAllocationInfo)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pBufferCreateInfo && pAllocationCreateInfo && pBuffer && pAllocation)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(0 && \"Creating a buffer with VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT is not valid if VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT was not used.\")"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK* pBuffer = VK_NULL_HANDLE ;* pAllocation = VK_NULL_HANDLE ; VkResult)",
    "insertText": "res(*allocator->GetVulkanFunctions().vkCreateBuffer)( allocator->m_hDevice, pBufferCreateInfo, allocator->GetAllocationCallbacks(), pBuffer)"
  },
  {
    "label": "GetBufferMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (VkMemoryRequirements vkMemReq = { } ; bool requiresDedicatedAllocation = false ; bool prefersDedicatedAllocation = false ; allocator ->)",
    "insertText": "GetBufferMemoryRequirements(*pBuffer, vkMemReq, requiresDedicatedAllocation, prefersDedicatedAllocation)"
  },
  {
    "label": "AllocateMemory()",
    "kind": "Method",
    "detail": "Function (res = allocator ->)",
    "insertText": "AllocateMemory(vkMemReq, requiresDedicatedAllocation, prefersDedicatedAllocation, *pBuffer, VK_NULL_HANDLE, VmaBufferImageUsage(*pBufferCreateInfo, allocator->m_UseKhrMaintenance5), *pAllocationCreateInfo, VMA_SUBALLOCATION_TYPE_BUFFER, 1, pAllocation)"
  },
  {
    "label": "BindBufferMemory()",
    "kind": "Method",
    "detail": "Function (res = allocator ->)",
    "insertText": "BindBufferMemory(*pAllocation, 0, *pBuffer, VMA_NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(res >= 0)"
  },
  {
    "label": "VMA_STATS_STRING_ENABLED()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "VMA_STATS_STRING_ENABLED(*pAllocation)->InitBufferUsage(*pBufferCreateInfo, allocator->m_UseKhrMaintenance5)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(pAllocationInfo != VMA_NULL)"
  },
  {
    "label": "FreeMemory()",
    "kind": "Method",
    "detail": "Function (} return VK_SUCCESS ; } allocator ->)",
    "insertText": "FreeMemory(1, pAllocation)"
  },
  {
    "label": "VK_NULL_HANDLE()",
    "kind": "Method",
    "detail": "Function (* pAllocation =)",
    "insertText": "VK_NULL_HANDLE(*allocator->GetVulkanFunctions().vkDestroyBuffer)(allocator->m_hDevice, *pBuffer, allocator->GetAllocationCallbacks())"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (* pBuffer = VK_NULL_HANDLE ; return)",
    "insertText": "res(*allocator->GetVulkanFunctions().vkDestroyBuffer)(allocator->m_hDevice, *pBuffer, allocator->GetAllocationCallbacks())"
  },
  {
    "label": "vmaCreateBufferWithAlignment()",
    "kind": "Method",
    "detail": "Function (* pBuffer = VK_NULL_HANDLE ; return res ; } return res ; } VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateBufferWithAlignment(VmaAllocator allocator, const VkBufferCreateInfo* pBufferCreateInfo, const VmaAllocationCreateInfo* pAllocationCreateInfo, VkDeviceSize minAlignment, VkBuffer* pBuffer, VmaAllocation* pAllocation, VmaAllocationInfo* pAllocationInfo)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pBufferCreateInfo && pAllocationCreateInfo && VmaIsPow2(minAlignment) && pBuffer && pAllocation)"
  },
  {
    "label": "VMA_MAX()",
    "kind": "Method",
    "detail": "Function (vkMemReq . alignment =)",
    "insertText": "VMA_MAX(vkMemReq.alignment, minAlignment)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pBufferCreateInfo && pBuffer && allocation)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocationLocalOffset + pBufferCreateInfo->size <= allocation->GetSize())"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaCreateAliasingBuffer2\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* pBuffer = VK_NULL_HANDLE ;)",
    "insertText": "if(pBufferCreateInfo->size == 0)"
  },
  {
    "label": "BindBufferMemory()",
    "kind": "Method",
    "detail": "Function (res = allocator ->)",
    "insertText": "BindBufferMemory(allocation, allocationLocalOffset, *pBuffer, VMA_NULL)"
  },
  {
    "label": "vmaDestroyBuffer()",
    "kind": "Method",
    "detail": "Function (} return res ; } VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaDestroyBuffer(VmaAllocator allocator, VkBuffer buffer, VmaAllocation allocation)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK)",
    "insertText": "if(buffer != VK_NULL_HANDLE)"
  },
  {
    "label": "vmaCreateImage()",
    "kind": "Method",
    "detail": "Function (} } VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateImage(VmaAllocator allocator, const VkImageCreateInfo* pImageCreateInfo, const VmaAllocationCreateInfo* pAllocationCreateInfo, VkImage* pImage, VmaAllocation* pAllocation, VmaAllocationInfo* pAllocationInfo)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pImageCreateInfo && pAllocationCreateInfo && pImage && pAllocation)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK* pImage = VK_NULL_HANDLE ;* pAllocation = VK_NULL_HANDLE ; VkResult)",
    "insertText": "res(*allocator->GetVulkanFunctions().vkCreateImage)( allocator->m_hDevice, pImageCreateInfo, allocator->GetAllocationCallbacks(), pImage)"
  },
  {
    "label": "GetImageMemoryRequirements()",
    "kind": "Method",
    "detail": "Function (VmaSuballocationType suballocType = pImageCreateInfo -> tiling = = VK_IMAGE_TILING_OPTIMAL ? VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL : VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR ; VkMemoryRequirements vkMemReq = { } ; bool requiresDedicatedAllocation = false ; bool prefersDedicatedAllocation = false ; allocator ->)",
    "insertText": "GetImageMemoryRequirements(*pImage, vkMemReq, requiresDedicatedAllocation, prefersDedicatedAllocation)"
  },
  {
    "label": "AllocateMemory()",
    "kind": "Method",
    "detail": "Function (res = allocator ->)",
    "insertText": "AllocateMemory(vkMemReq, requiresDedicatedAllocation, prefersDedicatedAllocation, VK_NULL_HANDLE, *pImage, VmaBufferImageUsage(*pImageCreateInfo), *pAllocationCreateInfo, suballocType, 1, pAllocation)"
  },
  {
    "label": "BindImageMemory()",
    "kind": "Method",
    "detail": "Function (res = allocator ->)",
    "insertText": "BindImageMemory(*pAllocation, 0, *pImage, VMA_NULL)"
  },
  {
    "label": "VMA_STATS_STRING_ENABLED()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "VMA_STATS_STRING_ENABLED(*pAllocation)->InitImageUsage(*pImageCreateInfo)"
  },
  {
    "label": "VK_NULL_HANDLE()",
    "kind": "Method",
    "detail": "Function (* pAllocation =)",
    "insertText": "VK_NULL_HANDLE(*allocator->GetVulkanFunctions().vkDestroyImage)(allocator->m_hDevice, *pImage, allocator->GetAllocationCallbacks())"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (* pImage = VK_NULL_HANDLE ; return)",
    "insertText": "res(*allocator->GetVulkanFunctions().vkDestroyImage)(allocator->m_hDevice, *pImage, allocator->GetAllocationCallbacks())"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(allocator && pImageCreateInfo && pImage && allocation)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (* pImage = VK_NULL_HANDLE ;)",
    "insertText": "VMA_DEBUG_LOG(\"vmaCreateImage2\")"
  },
  {
    "label": "BindImageMemory()",
    "kind": "Method",
    "detail": "Function (res = allocator ->)",
    "insertText": "BindImageMemory(allocation, allocationLocalOffset, *pImage, VMA_NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK)",
    "insertText": "if(image != VK_NULL_HANDLE)"
  },
  {
    "label": "vmaCreateVirtualBlock()",
    "kind": "Method",
    "detail": "Function (} } VMA_CALL_PRE VkResult VMA_CALL_POST)",
    "insertText": "vmaCreateVirtualBlock(const VmaVirtualBlockCreateInfo* VMA_NOT_NULL pCreateInfo, VmaVirtualBlock VMA_NULLABLE * VMA_NOT_NULL pVirtualBlock)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pCreateInfo && pVirtualBlock)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(pCreateInfo->size > 0)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaCreateVirtualBlock\")"
  },
  {
    "label": "vma_new()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK ;* pVirtualBlock =)",
    "insertText": "vma_new(pCreateInfo->pAllocationCallbacks, VmaVirtualBlock_T)(*pCreateInfo)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (VkResult)",
    "insertText": "res(*pVirtualBlock)->Init()"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vma_delete(pCreateInfo->pAllocationCallbacks, *pVirtualBlock)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaDestroyVirtualBlock\")"
  },
  {
    "label": "vma_delete()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK ; VkAllocationCallbacks allocationCallbacks = virtualBlock -> m_AllocationCallbacks ;)",
    "insertText": "vma_delete(&allocationCallbacks, virtualBlock)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(virtualBlock != VK_NULL_HANDLE)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaIsVirtualBlockEmpty\")"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(virtualBlock != VK_NULL_HANDLE && pVirtualAllocInfo != VMA_NULL)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaGetVirtualAllocationInfo\")"
  },
  {
    "label": "GetAllocationInfo()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK ; virtualBlock ->)",
    "insertText": "GetAllocationInfo(allocation, *pVirtualAllocInfo)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(virtualBlock != VK_NULL_HANDLE && pCreateInfo != VMA_NULL && pAllocation != VMA_NULL)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaVirtualAllocate\")"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK ; return virtualBlock ->)",
    "insertText": "Allocate(*pCreateInfo, *pAllocation, pOffset)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaVirtualFree\")"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaClearVirtualBlock\")"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaSetVirtualAllocationUserData\")"
  },
  {
    "label": "SetAllocationUserData()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK ; virtualBlock ->)",
    "insertText": "SetAllocationUserData(allocation, pUserData)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(virtualBlock != VK_NULL_HANDLE && pStats != VMA_NULL)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaGetVirtualBlockStatistics\")"
  },
  {
    "label": "GetStatistics()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK ; virtualBlock ->)",
    "insertText": "GetStatistics(*pStats)"
  },
  {
    "label": "VMA_DEBUG_LOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_DEBUG_LOG(\"vmaCalculateVirtualBlockStatistics\")"
  },
  {
    "label": "CalculateDetailedStatistics()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK ; virtualBlock ->)",
    "insertText": "CalculateDetailedStatistics(*pStats)"
  },
  {
    "label": "vmaBuildVirtualBlockStatsString()",
    "kind": "Method",
    "detail": "Function (} # if VMA_STATS_STRING_ENABLED VMA_CALL_PRE void VMA_CALL_POST)",
    "insertText": "vmaBuildVirtualBlockStatsString(VmaVirtualBlock VMA_NOT_NULL virtualBlock, char* VMA_NULLABLE * VMA_NOT_NULL ppStatsString, VkBool32 detailedMap)"
  },
  {
    "label": "VMA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VMA_ASSERT(virtualBlock != VK_NULL_HANDLE && ppStatsString != VMA_NULL)"
  },
  {
    "label": "sb()",
    "kind": "Method",
    "detail": "Function (VmaStringBuilder)",
    "insertText": "sb(allocationCallbacks)"
  },
  {
    "label": "BuildStatsString()",
    "kind": "Method",
    "detail": "Function (virtualBlock ->)",
    "insertText": "BuildStatsString(detailedMap != VK_FALSE, sb)"
  },
  {
    "label": "VmaCreateStringCopy()",
    "kind": "Method",
    "detail": "Function (* ppStatsString =)",
    "insertText": "VmaCreateStringCopy(allocationCallbacks, sb.GetData(), sb.GetLength())"
  },
  {
    "label": "VmaFreeString()",
    "kind": "Method",
    "detail": "Function (VMA_DEBUG_GLOBAL_MUTEX_LOCK ;)",
    "insertText": "VmaFreeString(virtualBlock->GetAllocationCallbacks(), pStatsString)"
  }
]