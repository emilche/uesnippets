[
  {
    "label": "SListView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SListView"
  },
  {
    "label": "FSlateAccessibleListView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSlateAccessibleListView"
  },
  {
    "label": "FWidgetGenerator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FWidgetGenerator"
  },
  {
    "label": "SListViewPinnedRowWidget",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SListViewPinnedRowWidget"
  },
  {
    "label": "FGenerationPassGuard",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGenerationPassGuard"
  },
  {
    "label": "DECLARE_DELEGATE_OneParam()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Containers / ArrayView . h \" # include \" Containers / ObservableArray . h \" # include \" InputCoreTypes . h \" # include \" Input / Reply . h \" # include \" Layout / Visibility . h \" # include \" Styling / SlateTypes . h \" # include \" Styling / AppStyle . h \" # include \" Framework / SlateDelegates . h \" # include \" Framework / Layout / Overscroll . h \" # include \" Framework / Views / ITypedTableView . h \" # include \" Framework / Views / TableViewMetadata . h \" # include \" Framework / Views / TableViewTypeTraits . h \" # include \" Types / SlateConstants . h \" # include \" Widgets / DeclarativeSyntaxSupport . h \" # include \" Widgets / SOverlay . h \" # include \" Widgets / Layout / SScrollBar . h \" # include \" Widgets / Images / SImage . h \" # include \" Widgets / Text / STextBlock . h \" # include \" Widgets / Views / STableViewBase . h \" # include \" Widgets / Views / STableRow . h \" # include \" Widgets / Views / IItemsSource . h \" # include \" Application / SlateApplicationBase . h \" # if WITH_ACCESSIBILITY # include \" GenericPlatform / Accessibility / GenericAccessibleInterfaces . h \" # include \" Widgets / Accessibility / SlateCoreAccessibleWidgets . h \" # include \" Widgets / Accessibility / SlateAccessibleWidgetCache . h \" # include \" Widgets / Accessibility / SlateAccessibleMessageHandler . h \" # endif template<ItemType> class SListView : public STableViewBase,TListTypeTraits<ItemType>::SerializerType,public ITypedTableView<ItemType> { public : using NullableItemType = TListTypeTraits<ItemType>::NullableType ; using MapKeyFuncs = TListTypeTraits<ItemType>::MapKeyFuncs ; using MapKeyFuncsSparse = TListTypeTraits<ItemType>::MapKeyFuncsSparse ; using TItemSet = TSet<TObjectPtrWrapTypeOf<ItemType>,TListTypeTraits<TObjectPtrWrapTypeOf<ItemType>>::SetKeyFuncs> ; using FOnGenerateRow = TSlateDelegates<ItemType>::FOnGenerateRow ; using FOnItemScrolledIntoView = TSlateDelegates<ItemType>::FOnItemScrolledIntoView ; using FOnSelectionChanged = TSlateDelegates<NullableItemType>::FOnSelectionChanged ; using FIsSelectableOrNavigable = TSlateDelegates<ItemType>::FIsSelectableOrNavigable ; using FOnMouseButtonClick = TSlateDelegates<ItemType>::FOnMouseButtonClick ; using FOnMouseButtonDoubleClick = TSlateDelegates<ItemType>::FOnMouseButtonDoubleClick ; typedef TSlateDelegates<ItemType>::FOnItemToString_Debug FOnItemToString_Debug ;)",
    "insertText": "DECLARE_DELEGATE_OneParam(FOnWidgetToBeRemoved, const TSharedRef<ITableRow>&)"
  },
  {
    "label": "DECLARE_DELEGATE_TwoParams()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_DELEGATE_TwoParams(FOnEntryInitialized, ItemType, const TSharedRef<ITableRow>&)"
  },
  {
    "label": "SLATE_BEGIN_ARGS()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "SLATE_BEGIN_ARGS(SListView<ItemType>) : _ListViewStyle(&FAppStyle::Get().GetWidgetStyle<FTableViewStyle>(\"ListView\")) , _OnGenerateRow() , _OnGeneratePinnedRow() , _OnEntryInitialized() , _OnRowReleased() , _MaxPinnedItems(6) , _OnContextMenuOpening() , _OnItemsRebuilt() , _OnMouseButtonClick() , _OnMouseButtonDoubleClick() , _OnSelectionChanged() , _OnIsSelectableOrNavigable() , _SelectionMode(ESelectionMode::Multi) , _ClearSelectionOnClick(true) , _ExternalScrollbar() , _Orientation(Orient_Vertical) , _EnableAnimatedScrolling(false) , _ScrollbarDragFocusCause(EFocusCause::Mouse) , _AllowOverscroll(EAllowOverscroll::Yes) , _ScrollBarStyle(&FAppStyle::Get().GetWidgetStyle<FScrollBarStyle>(\"ScrollBar\")) , _PreventThrottling(false) , _ConsumeMouseWheel(EConsumeMouseWheel::WhenScrollingPossible) , _WheelScrollMultiplier(GetGlobalScrollAmount()) , _NavigationScrollOffset(0.5f) , _ScrollBarPadding(0.0f) , _HandleGamepadEvents( true ) , _HandleDirectionalNavigation( true ) , _HandleSpacebarSelection(false) , _IsFocusable(true) , _ReturnFocusToSelection() , _OnItemToString_Debug() , _OnEnteredBadState()"
  },
  {
    "label": "SLATE_STYLE_ARGUMENT()",
    "kind": "Method",
    "detail": "Function (this -> _Clipping = EWidgetClipping::ClipToBounds ; })",
    "insertText": "SLATE_STYLE_ARGUMENT(FTableViewStyle, ListViewStyle ) SLATE_EVENT( FOnGenerateRow, OnGenerateRow ) SLATE_EVENT( FOnGenerateRow, OnGeneratePinnedRow ) SLATE_EVENT( FOnEntryInitialized, OnEntryInitialized ) SLATE_EVENT( FOnWidgetToBeRemoved, OnRowReleased ) SLATE_EVENT( FOnTableViewScrolled, OnListViewScrolled ) SLATE_EVENT( FOnItemScrolledIntoView, OnItemScrolledIntoView ) SLATE_EVENT( FOnFinishedScrolling, OnFinishedScrolling ) SLATE_ITEMS_SOURCE_ARGUMENT( ItemType, ListItemsSource ) SLATE_ATTRIBUTE_DEPRECATED( float, ItemHeight, 5.5, \"The ItemHeight is only used for Tile. See ShouldArrangeAsTiles\") SLATE_ATTRIBUTE(int32, MaxPinnedItems) SLATE_EVENT( FOnContextMenuOpening, OnContextMenuOpening ) SLATE_EVENT( FSimpleDelegate, OnItemsRebuilt ) SLATE_EVENT(FOnMouseButtonClick, OnMouseButtonClick) SLATE_EVENT( FOnMouseButtonDoubleClick, OnMouseButtonDoubleClick ) SLATE_EVENT( FOnSelectionChanged, OnSelectionChanged ) SLATE_EVENT( FIsSelectableOrNavigable, OnIsSelectableOrNavigable) SLATE_ATTRIBUTE( ESelectionMode::Type, SelectionMode ) SLATE_ARGUMENT( TSharedPtr<SHeaderRow>, HeaderRow ) SLATE_ARGUMENT ( bool, ClearSelectionOnClick ) SLATE_ARGUMENT( TSharedPtr<SScrollBar>, ExternalScrollbar ) SLATE_ARGUMENT( EOrientation, Orientation ) SLATE_ARGUMENT( EScrollIntoViewAlignment, ScrollIntoViewAlignment ) SLATE_ARGUMENT( bool, EnableAnimatedScrolling) SLATE_ARGUMENT( TOptional<double>, FixedLineScrollOffset ) SLATE_ATTRIBUTE( EVisibility, ScrollbarVisibility) SLATE_ARGUMENT( EFocusCause, ScrollbarDragFocusCause ) SLATE_ARGUMENT( EAllowOverscroll, AllowOverscroll)"
  },
  {
    "label": "SLATE_STYLE_ARGUMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_STYLE_ARGUMENT(FScrollBarStyle, ScrollBarStyle)"
  },
  {
    "label": "SLATE_ARGUMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_ARGUMENT(bool, PreventThrottling)"
  },
  {
    "label": "SLATE_ARGUMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_ARGUMENT(EConsumeMouseWheel, ConsumeMouseWheel)"
  },
  {
    "label": "SLATE_ARGUMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_ARGUMENT(float, WheelScrollMultiplier)"
  },
  {
    "label": "SLATE_ARGUMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_ARGUMENT(float, NavigationScrollOffset)"
  },
  {
    "label": "SLATE_ARGUMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_ARGUMENT(FMargin, ScrollBarPadding)"
  },
  {
    "label": "SLATE_ARGUMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_ARGUMENT(bool, HandleGamepadEvents)"
  },
  {
    "label": "SLATE_ARGUMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_ARGUMENT(bool, HandleDirectionalNavigation)"
  },
  {
    "label": "SLATE_ARGUMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_ARGUMENT(bool, HandleSpacebarSelection)"
  },
  {
    "label": "SLATE_ATTRIBUTE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_ATTRIBUTE(bool, IsFocusable) SLATE_ARGUMENT(bool, ReturnFocusToSelection) SLATE_EVENT(FOnItemToString_Debug, OnItemToString_Debug) SLATE_EVENT(FOnTableViewBadState, OnEnteredBadState)"
  },
  {
    "label": "SLATE_EVENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_EVENT(FOnKeyDown, OnKeyDownHandler) SLATE_END_ARGS() void Construct(const typename SListView<ItemType>::FArguments& InArgs)"
  },
  {
    "label": "SetItemsSource()",
    "kind": "Method",
    "detail": "Function (this -> Clipping = InArgs . _Clipping ; this -> OnGenerateRow = InArgs . _OnGenerateRow ; this -> OnGeneratePinnedRow = InArgs . _OnGeneratePinnedRow ; this -> OnEntryInitialized = InArgs . _OnEntryInitialized ; this -> OnRowReleased = InArgs . _OnRowReleased ; this -> OnItemScrolledIntoView = InArgs . _OnItemScrolledIntoView ; this -> OnFinishedScrolling = InArgs . _OnFinishedScrolling ; this ->)",
    "insertText": "SetItemsSource(InArgs.MakeListItemsSource(this->SharedThis(this)))"
  },
  {
    "label": "IsBound()",
    "kind": "Method",
    "detail": "Function (this -> OnContextMenuOpening = InArgs . _OnContextMenuOpening ; this -> OnItemsRebuilt = InArgs . _OnItemsRebuilt ; this -> OnClick = InArgs . _OnMouseButtonClick ; this -> OnDoubleClick = InArgs . _OnMouseButtonDoubleClick ; this -> OnSelectionChanged = InArgs . _OnSelectionChanged ; this -> OnIsSelectableOrNavigable = InArgs . _OnIsSelectableOrNavigable ; this -> SelectionMode = InArgs . _SelectionMode ; this -> bClearSelectionOnClick = InArgs . _ClearSelectionOnClick ; this -> AllowOverscroll = InArgs . _AllowOverscroll ; this -> ConsumeMouseWheel = InArgs . _ConsumeMouseWheel ; this -> WheelScrollMultiplier = InArgs . _WheelScrollMultiplier ; this -> NavigationScrollOffset = InArgs . _NavigationScrollOffset ; this -> bHandleGamepadEvents = InArgs . _HandleGamepadEvents ; this -> bHandleDirectionalNavigation = InArgs . _HandleDirectionalNavigation ; this -> bHandleSpacebarSelection = InArgs . _HandleSpacebarSelection ; this -> IsFocusable = InArgs . _IsFocusable ; this -> bReturnFocusToSelection = InArgs . _ReturnFocusToSelection ; this -> bEnableAnimatedScrolling = InArgs . _EnableAnimatedScrolling ; this -> FixedLineScrollOffset = InArgs . _FixedLineScrollOffset ; this -> ScrollIntoViewAlignment = InArgs . _ScrollIntoViewAlignment ; this -> OnItemToString_Debug = InArgs . _OnItemToString_Debug .)",
    "insertText": "IsBound() ? InArgs._OnItemToString_Debug : SListView< ItemType >::GetDefaultDebugDelegate()"
  },
  {
    "label": "SetStyle()",
    "kind": "Method",
    "detail": "Function (this -> OnEnteredBadState = InArgs . _OnEnteredBadState ; this -> OnKeyDownHandler = InArgs . _OnKeyDownHandler ; this ->)",
    "insertText": "SetStyle(InArgs._ListViewStyle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (this -> MaxPinnedItems = InArgs . _MaxPinnedItems ; this -> DefaultMaxPinnedItems = InArgs . _MaxPinnedItems ; this -> ScrollBarSlotPadding = InArgs . _ScrollBarPadding ; FString ErrorString ; {)",
    "insertText": "if(!this->OnGenerateRow.IsBound())"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (ErrorString + =)",
    "insertText": "TEXT(\"Please specify an OnGenerateRow. \\n\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!this->HasValidItemsSource())"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (ErrorString + =)",
    "insertText": "TEXT(\"Please specify a ListItemsSource. \\n\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(ErrorString.Len() > 0)"
  },
  {
    "label": "HAlign()",
    "kind": "Method",
    "detail": "Function (this -> ChildSlot .)",
    "insertText": "HAlign(HAlign_Center) .VAlign(VAlign_Center) [ SNew(STextBlock) .Text(FText::FromString(ErrorString))"
  },
  {
    "label": "ConstructChildren()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "ConstructChildren(0.0f, 0.0f, EListItemAlignment::LeftAligned, InArgs._HeaderRow, InArgs._ExternalScrollbar, InArgs._Orientation, InArgs._OnListViewScrolled, InArgs._ScrollBarStyle, InArgs._PreventThrottling)"
  },
  {
    "label": "SetDragFocusCause()",
    "kind": "Method",
    "detail": "Function (this -> ScrollBar ->)",
    "insertText": "SetDragFocusCause(InArgs._ScrollbarDragFocusCause)"
  },
  {
    "label": "SetUserVisibility()",
    "kind": "Method",
    "detail": "Function (this -> ScrollBar ->)",
    "insertText": "SetUserVisibility(InArgs._ScrollbarVisibility)"
  },
  {
    "label": "AddMetadata()",
    "kind": "Method",
    "detail": "Function (} this ->)",
    "insertText": "AddMetadata(MakeShared<TTableViewMetadata<ItemType>>(this->SharedThis(this)))"
  },
  {
    "label": "SListView()",
    "kind": "Method",
    "detail": "Function (} } PRAGMA_DISABLE_DEPRECATION_WARNINGS)",
    "insertText": "SListView(ETableViewMode::Type InListMode = ETableViewMode::List) : STableViewBase(InListMode) , WidgetGenerator(this) , PinnedWidgetGenerator(this) , SelectorItem(TListTypeTraits<ItemType>::MakeNullPtr()) , RangeSelectionStart(TListTypeTraits<ItemType>::MakeNullPtr()) , ItemsSource(nullptr) , ItemToScrollIntoView(TListTypeTraits<ItemType>::MakeNullPtr()) , UserRequestingScrollIntoView(0) , ItemToNotifyWhenInView(TListTypeTraits<ItemType>::MakeNullPtr()) , ScrollIntoViewAlignment(EScrollIntoViewAlignment::CenterAligned) , IsFocusable(true)"
  },
  {
    "label": "SupportsKeyboardFocus()",
    "kind": "Method",
    "detail": "Function (# if WITH_ACCESSIBILITY AccessibleBehavior = EAccessibleBehavior::Auto ; bCanChildrenBeAccessible = true ; # endif } PRAGMA_ENABLE_DEPRECATION_WARNINGS public : bool)",
    "insertText": "SupportsKeyboardFocus()"
  },
  {
    "label": "OnKeyDown()",
    "kind": "Method",
    "detail": "Function (} FReply)",
    "insertText": "OnKeyDown(const FGeometry& MyGeometry, const FKeyEvent& InKeyEvent)"
  },
  {
    "label": "Execute()",
    "kind": "Method",
    "detail": "Function (FReply Reply = OnKeyDownHandler .)",
    "insertText": "Execute(MyGeometry, InKeyEvent)"
  },
  {
    "label": "OnKeyDown_Internal()",
    "kind": "Method",
    "detail": "Function (} protected : FReply)",
    "insertText": "OnKeyDown_Internal(const FGeometry& MyGeometry, const FKeyEvent& InKeyEvent)"
  },
  {
    "label": "GetItems()",
    "kind": "Method",
    "detail": "Function (const TArrayView<const ItemType> ItemsSourceRef =)",
    "insertText": "GetItems()"
  },
  {
    "label": "MakeNullPtr()",
    "kind": "Method",
    "detail": "Function (bool bWasHandled = false ; NullableItemType ItemNavigatedTo = TListTypeTraits<ItemType)",
    "insertText": "MakeNullPtr()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ItemNavigatedTo = ItemsSourceRef [ 0 ] ; bWasHandled = true ; } else)",
    "insertText": "if(InKeyEvent.GetKey() == EKeys::End)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (ItemNavigatedTo = ItemsSourceRef .)",
    "insertText": "Last()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bWasHandled = true ; } else)",
    "insertText": "if(InKeyEvent.GetKey() == EKeys::PageUp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 SelectionIndex = 0 ;)",
    "insertText": "if(TListTypeTraits<ItemType>::IsPtrValid(SelectorItem))"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (SelectionIndex = ItemsSourceRef .)",
    "insertText": "Find(TListTypeTraits<ItemType>::NullableItemTypeConvertToItemType( SelectorItem ))"
  },
  {
    "label": "TruncToInt()",
    "kind": "Method",
    "detail": "Function (} int32 NumItemsInAPage =)",
    "insertText": "TruncToInt(GetNumLiveWidgets())"
  },
  {
    "label": "GetNumItemsPerLine()",
    "kind": "Method",
    "detail": "Function (int32 Remainder = NumItemsInAPage %)",
    "insertText": "GetNumItemsPerLine()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NumItemsInAPage - = Remainder ;)",
    "insertText": "if(SelectionIndex >= NumItemsInAPage)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ItemNavigatedTo = ItemsSourceRef [ SelectionIndex - NumItemsInAPage ] ; } else { ItemNavigatedTo = ItemsSourceRef [ 0 ] ; } bWasHandled = true ; } else)",
    "insertText": "if(InKeyEvent.GetKey() == EKeys::PageDown)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NumItemsInAPage - = Remainder ;)",
    "insertText": "if(SelectionIndex < ItemsSourceRef.Num() - NumItemsInAPage)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} bWasHandled = true ; })",
    "insertText": "if(TListTypeTraits<ItemType>::IsPtrValid(ItemNavigatedTo))"
  },
  {
    "label": "ItemToSelect()",
    "kind": "Method",
    "detail": "Function (ItemType)",
    "insertText": "ItemToSelect(TListTypeTraits<ItemType>::NullableItemTypeConvertToItemType( ItemNavigatedTo ))"
  },
  {
    "label": "NavigationSelect()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NavigationSelect(ItemToSelect, InKeyEvent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(bHandleSpacebarSelection && TListTypeTraits<ItemType>::IsPtrValid(SelectorItem) && InKeyEvent.GetKey() == EKeys::SpaceBar)"
  },
  {
    "label": "SelectorItemDereference()",
    "kind": "Method",
    "detail": "Function (ItemType)",
    "insertText": "SelectorItemDereference(TListTypeTraits<ItemType>::NullableItemTypeConvertToItemType(SelectorItem))"
  },
  {
    "label": "Private_SetItemSelection()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Private_SetItemSelection(SelectorItemDereference, !(this->Private_IsItemSelected(SelectorItemDereference)), true)"
  },
  {
    "label": "Private_SignalSelectionChanged()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Private_SignalSelectionChanged(ESelectInfo::OnKeyPress)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bWasHandled = true ; } else {)",
    "insertText": "if(this->Private_IsItemSelected(SelectorItemDereference))"
  },
  {
    "label": "Private_SetItemSelection()",
    "kind": "Method",
    "detail": "Function (bWasHandled = false ; } else { this ->)",
    "insertText": "Private_SetItemSelection(SelectorItemDereference, true, true)"
  },
  {
    "label": "GetWidgetForItem()",
    "kind": "Method",
    "detail": "Function (bWasHandled = true ; } } RangeSelectionStart = SelectorItem ; TSharedPtr<ITableRow> WidgetForItem = this -> WidgetGenerator .)",
    "insertText": "GetWidgetForItem(SelectorItemDereference)"
  },
  {
    "label": "RequestScrollIntoView()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "RequestScrollIntoView(SelectorItemDereference, InKeyEvent.GetUserIndex())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if((!InKeyEvent.IsShiftDown() && !InKeyEvent.IsAltDown() && InKeyEvent.IsControlDown() && InKeyEvent.GetKey() == EKeys::A) && SelectionMode.Get() == ESelectionMode::Multi)"
  },
  {
    "label": "Private_ClearSelection()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Private_ClearSelection()"
  },
  {
    "label": "Private_SetItemSelection()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Private_SetItemSelection(ItemsSourceRef[ItemIdx], true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bWasHandled = true ; } })",
    "insertText": "if(bWasHandled)"
  },
  {
    "label": "OnKeyDown()",
    "kind": "Method",
    "detail": "Function (} } return)",
    "insertText": "OnKeyDown(MyGeometry, InKeyEvent)"
  },
  {
    "label": "OnNavigation()",
    "kind": "Method",
    "detail": "Function (} public : FNavigationReply)",
    "insertText": "OnNavigation(const FGeometry& MyGeometry, const FNavigationEvent& InNavigationEvent)"
  },
  {
    "label": "CurSelectionIndex()",
    "kind": "Method",
    "detail": "Function (const int32)",
    "insertText": "CurSelectionIndex(!TListTypeTraits<ItemType>::IsPtrValid(SelectorItem)) ? -1 : ItemsSourceRef.Find(TListTypeTraits<ItemType>::NullableItemTypeConvertToItemType(SelectorItem))"
  },
  {
    "label": "GetNavigationType()",
    "kind": "Method",
    "detail": "Function (int32 AttemptSelectIndex = - 1 ; const EUINavigation NavType = InNavigationEvent .)",
    "insertText": "GetNavigationType()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (AttemptSelectIndex = CurSelectionIndex - NumItemsPerLine ; } else)",
    "insertText": "if((Orientation == Orient_Vertical && NavType == EUINavigation::Down) || (Orientation == Orient_Horizontal && NavType == EUINavigation::Right))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (AttemptSelectIndex = CurSelectionIndex + NumItemsPerLine ;)",
    "insertText": "if(!ItemsSourceRef.IsValidIndex(AttemptSelectIndex))"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 NumItems = ItemsSourceRef .)",
    "insertText": "Num()"
  },
  {
    "label": "CeilToInt()",
    "kind": "Method",
    "detail": "Function (const int32 NumLines =)",
    "insertText": "CeilToInt((float)NumItems / (float)NumItemsPerLine)"
  },
  {
    "label": "CeilToInt()",
    "kind": "Method",
    "detail": "Function (const int32 CurLine =)",
    "insertText": "CeilToInt((float)(CurSelectionIndex + 1) / (float)NumItemsPerLine)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (AttemptSelectIndex = NumItems - 1 ; } } } })",
    "insertText": "if(ItemsSourceRef.IsValidIndex(AttemptSelectIndex) && this->bIsGamepadScrollingEnabled)"
  },
  {
    "label": "Private_FindNextSelectableOrNavigableWithIndexAndDirection()",
    "kind": "Method",
    "detail": "Function (TOptional<ItemType> ItemToSelect =)",
    "insertText": "Private_FindNextSelectableOrNavigableWithIndexAndDirection(ItemsSourceRef[AttemptSelectIndex], AttemptSelectIndex, AttemptSelectIndex >= CurSelectionIndex)"
  },
  {
    "label": "NavigationSelect()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NavigationSelect(ItemToSelect.GetValue(), InNavigationEvent)"
  },
  {
    "label": "OnNavigation()",
    "kind": "Method",
    "detail": "Function (} } } return)",
    "insertText": "OnNavigation(MyGeometry, InNavigationEvent)"
  },
  {
    "label": "OnMouseButtonDown()",
    "kind": "Method",
    "detail": "Function (} FReply)",
    "insertText": "OnMouseButtonDown(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)"
  },
  {
    "label": "Private_SignalSelectionChanged()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "Private_SignalSelectionChanged(ESelectInfo::OnMouseClick)"
  },
  {
    "label": "Handled()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "Handled()"
  },
  {
    "label": "OnMouseButtonDown()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "OnMouseButtonDown(MyGeometry, MouseEvent)"
  },
  {
    "label": "OnMouseButtonUp()",
    "kind": "Method",
    "detail": "Function (} FReply)",
    "insertText": "OnMouseButtonUp(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)"
  },
  {
    "label": "OnMouseButtonUp()",
    "kind": "Method",
    "detail": "Function (} } return)",
    "insertText": "OnMouseButtonUp(MyGeometry, MouseEvent)"
  },
  {
    "label": "FSlateAccessibleListView()",
    "kind": "Method",
    "detail": "Function (} # if WITH_ACCESSIBILITY protected : class FSlateAccessibleListView ; class FSlateAccessibleListView : public FSlateAccessibleWidget,public IAccessibleTable { public :)",
    "insertText": "FSlateAccessibleListView(TWeakPtr<SWidget> InWidget, EAccessibleWidgetType InWidgetType) : FSlateAccessibleWidget(InWidget, InWidgetType)"
  },
  {
    "label": "AsTable()",
    "kind": "Method",
    "detail": "Function (} IAccessibleTable*)",
    "insertText": "AsTable()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<TSharedPtr<IAccessibleWidget>> SelectedItemsArray ;)",
    "insertText": "if(Widget.IsValid())"
  },
  {
    "label": "ItemType()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<SListView<ItemType>> ListView = StaticCastSharedPtr<SListView<)",
    "insertText": "ItemType(Widget.Pin())"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (SelectedItemsArray .)",
    "insertText": "Empty(ListView ->SelectedItems.Num())"
  },
  {
    "label": "GetWidgetForItem()",
    "kind": "Method",
    "detail": "Function (const ItemType& CurrentItem =* SelectedItemIt ; TSharedPtr<ITableRow> TableRow = ListView -> WidgetGenerator .)",
    "insertText": "GetWidgetForItem(CurrentItem)"
  },
  {
    "label": "AsWidget()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<SWidget> TableRowWidget = TableRow ->)",
    "insertText": "AsWidget()"
  },
  {
    "label": "GetAccessibleWidgetChecked()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<IAccessibleWidget> AccessibleTableRow =)",
    "insertText": "GetAccessibleWidgetChecked(TableRowWidget)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (SelectedItemsArray .)",
    "insertText": "Add(AccessibleTableRow)"
  },
  {
    "label": "CanSupportMultiSelection()",
    "kind": "Method",
    "detail": "Function (} } } } return SelectedItemsArray ; } bool)",
    "insertText": "CanSupportMultiSelection()"
  },
  {
    "label": "IsSelectionRequired()",
    "kind": "Method",
    "detail": "Function (} return false ; } bool)",
    "insertText": "IsSelectionRequired()"
  },
  {
    "label": "FSlateAccessibleWidget()",
    "kind": "Method",
    "detail": "Function (EAccessibleWidgetType WidgetType = EAccessibleWidgetType::List ; return MakeShareable<)",
    "insertText": "FSlateAccessibleWidget(new SListView<ItemType>::FSlateAccessibleListView(SharedThis(this), WidgetType))"
  },
  {
    "label": "GetDefaultAccessibleText()",
    "kind": "Method",
    "detail": "Function (} TOptional<FText>)",
    "insertText": "GetDefaultAccessibleText(EAccessibleType AccessibleType)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "Name(TEXT(\"List\"))"
  },
  {
    "label": "FWidgetGenerator()",
    "kind": "Method",
    "detail": "Function (} # endif private : class FWidgetGenerator ; class FWidgetGenerator { public :)",
    "insertText": "FWidgetGenerator(SListView<ItemType>* InOwnerList) : OwnerList(InOwnerList)"
  },
  {
    "label": "GetWidgetForItem()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] TSharedPtr<ITableRow>)",
    "insertText": "GetWidgetForItem(const ItemType& Item)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (const TSharedRef<ITableRow>* LookupResult = ItemToWidgetMap .)",
    "insertText": "Find(Item)"
  },
  {
    "label": "OnItemSeen()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnItemSeen(ItemType InItem, TSharedRef<ITableRow> InGeneratedWidget)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (TSharedRef<ITableRow>* LookupResult = ItemToWidgetMap .)",
    "insertText": "Find(InItem)"
  },
  {
    "label": "bWidgetIsNewlyGenerated()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bWidgetIsNewlyGenerated(LookupResult == nullptr)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ItemToWidgetMap .)",
    "insertText": "Add(InItem, InGeneratedWidget)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (WidgetMapToItem .)",
    "insertText": "Add(&InGeneratedWidget.Get(), InItem)"
  },
  {
    "label": "InitializeRow()",
    "kind": "Method",
    "detail": "Function (InGeneratedWidget ->)",
    "insertText": "InitializeRow()"
  },
  {
    "label": "Private_OnEntryInitialized()",
    "kind": "Method",
    "detail": "Function (OwnerList ->)",
    "insertText": "Private_OnEntryInitialized(InItem, InGeneratedWidget)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} ItemsToBeCleanedUp .)",
    "insertText": "Remove(InItem)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ItemsWithGeneratedWidgets .)",
    "insertText": "Add(InItem)"
  },
  {
    "label": "OnBeginGenerationPass()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnBeginGenerationPass()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (ItemsToBeCleanedUp = ItemsWithGeneratedWidgets ; ItemsWithGeneratedWidgets .)",
    "insertText": "Empty()"
  },
  {
    "label": "OnEndGenerationPass()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnEndGenerationPass()"
  },
  {
    "label": "ProcessItemCleanUp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessItemCleanUp()"
  },
  {
    "label": "ValidateWidgetGeneration()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValidateWidgetGeneration()"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Clear()"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (ItemType ItemToBeCleanedUp = ItemsToBeCleanedUp [ ItemIndex ] ; const TSharedRef<ITableRow>* FindResult = ItemToWidgetMap .)",
    "insertText": "Find(ItemToBeCleanedUp)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (const TSharedRef<ITableRow> WidgetToCleanUp =* FindResult ; ItemToWidgetMap .)",
    "insertText": "Remove(ItemToBeCleanedUp)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (WidgetMapToItem .)",
    "insertText": "Remove(&WidgetToCleanUp.Get())"
  },
  {
    "label": "ResetRow()",
    "kind": "Method",
    "detail": "Function (WidgetToCleanUp ->)",
    "insertText": "ResetRow()"
  },
  {
    "label": "ExecuteIfBound()",
    "kind": "Method",
    "detail": "Function (OwnerList -> OnRowReleased .)",
    "insertText": "ExecuteIfBound(WidgetToCleanUp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(!TListTypeTraits<ItemType>::IsPtrValid(ItemToBeCleanedUp))"
  },
  {
    "label": "FindKey()",
    "kind": "Method",
    "detail": "Function (auto Widget = WidgetMapToItem .)",
    "insertText": "FindKey(ItemToBeCleanedUp)"
  },
  {
    "label": "Item()",
    "kind": "Method",
    "detail": "Function (const ITableRow*)",
    "insertText": "Item(WidgetItemPair.Value().Get())"
  },
  {
    "label": "RemoveCurrent()",
    "kind": "Method",
    "detail": "Function (WidgetItemPair .)",
    "insertText": "RemoveCurrent()"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (break ; } } WidgetMapToItem .)",
    "insertText": "Remove(*Widget)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} } } ItemsToBeCleanedUp .)",
    "insertText": "Reset()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const bool bMapsMismatch = ItemToWidgetMap .)",
    "insertText": "Num() != WidgetMapToItem.Num()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const bool bGeneratedWidgetsSizeMismatch = WidgetMapToItem .)",
    "insertText": "Num() != ItemsWithGeneratedWidgets.Num()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bGeneratedWidgetsSizeMismatch)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bMapsMismatch || bGeneratedWidgetsSizeMismatch)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (const TSharedRef<SWidget> RowAsWidget = ItemWidgetPair .)",
    "insertText": "Value()->AsWidget()"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UE_LOG(LogSlate, Warning, TEXT(\"\"))"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "UE_LOG(LogSlate, Warning, TEXT(\"Provide custom 'OnItemToString_Debug' for diagnostics dump.\"))"
  },
  {
    "label": "ExecuteIfBound()",
    "kind": "Method",
    "detail": "Function (} OwnerList -> OnEnteredBadState .)",
    "insertText": "ExecuteIfBound()"
  },
  {
    "label": "Private_OnEntryInitialized()",
    "kind": "Method",
    "detail": "Function (} } public : SListView<ItemType>* OwnerList ; TMap<ItemType,TSharedRef<ITableRow>,FDefaultSetAllocator,MapKeyFuncs> ItemToWidgetMap ; TMap<const ITableRow*,TObjectPtrWrapTypeOf<ItemType>> WidgetMapToItem ; TArray<TObjectPtrWrapTypeOf<ItemType>> ItemsWithGeneratedWidgets ; int32 TotalItemsLastGeneration ; TArray<ItemType> ItemsToBeCleanedUp ; } ; public : void)",
    "insertText": "Private_OnEntryInitialized(ItemType TheItem, const TSharedRef<ITableRow>& TableRow)"
  },
  {
    "label": "ExecuteIfBound()",
    "kind": "Method",
    "detail": "Function (OnEntryInitialized .)",
    "insertText": "ExecuteIfBound(TheItem, TableRow)"
  },
  {
    "label": "Private_SetItemSelection()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Private_SetItemSelection(ItemType TheItem, bool bShouldBeSelected, bool bWasUserDirected = false)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (SelectedItems .)",
    "insertText": "Add(TheItem)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} else { SelectedItems .)",
    "insertText": "Remove(TheItem)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bWasUserDirected || SelectionMode.Get() == ESelectionMode::Single || SelectionMode.Get() == ESelectionMode::SingleToggle)"
  },
  {
    "label": "ClearScrollVelocity()",
    "kind": "Method",
    "detail": "Function (SelectorItem = TheItem ; RangeSelectionStart = TheItem ; } this -> InertialScrollManager .)",
    "insertText": "ClearScrollVelocity()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if WITH_ACCESSIBILITY)",
    "insertText": "if(bShouldBeSelected)"
  },
  {
    "label": "WidgetFromItem()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<ITableRow> TableRow =)",
    "insertText": "WidgetFromItem(TheItem)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Get().GetAccessibleMessageHandler()->OnWidgetEventRaised(FSlateAccessibleMessageHandler::FSlateWidgetAccessibleEventArgs(TableRowWidget, EAccessibleEvent::FocusChange, false, true))"
  },
  {
    "label": "Private_SelectRangeFromCurrentTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Private_SelectRangeFromCurrentTo(ItemType InRangeSelectionEnd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 RangeStartIndex = 0 ;)",
    "insertText": "if(TListTypeTraits<ItemType>::IsPtrValid(RangeSelectionStart))"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (RangeStartIndex = ItemsSourceRef .)",
    "insertText": "Find(TListTypeTraits<ItemType>::NullableItemTypeConvertToItemType( RangeSelectionStart ))"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} int32 RangeEndIndex = ItemsSourceRef .)",
    "insertText": "Find(InRangeSelectionEnd)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (RangeStartIndex =)",
    "insertText": "Clamp(RangeStartIndex, 0, ItemsSourceRef.Num()-1)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (RangeEndIndex =)",
    "insertText": "Clamp(RangeEndIndex, 0, ItemsSourceRef.Num()-1)"
  },
  {
    "label": "Direction()",
    "kind": "Method",
    "detail": "Function (const int32)",
    "insertText": "Direction(RangeEndIndex > RangeStartIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 ItemIndex = RangeStartIndex ;)",
    "insertText": "for(; ItemIndex != RangeEndIndex; ItemIndex += Direction)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (SelectedItems .)",
    "insertText": "Add(ItemsSourceRef[ItemIndex])"
  },
  {
    "label": "Private_SignalSelectionChanged()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Private_SignalSelectionChanged(ESelectInfo::Type SelectInfo)"
  },
  {
    "label": "SelectedItem()",
    "kind": "Method",
    "detail": "Function (TObjectPtrWrapTypeOf<NullableItemType>)",
    "insertText": "SelectedItem(SelectedItems.Num() > 0) ? (*typename TItemSet::TIterator(SelectedItems)) : TListTypeTraits< TObjectPtrWrapTypeOf<ItemType> >::MakeNullPtr()"
  },
  {
    "label": "ExecuteIfBound()",
    "kind": "Method",
    "detail": "Function (OnSelectionChanged .)",
    "insertText": "ExecuteIfBound(SelectedItem, SelectInfo)"
  },
  {
    "label": "Private_ItemFromWidget()",
    "kind": "Method",
    "detail": "Function (} } const TObjectPtrWrapTypeOf<ItemType>*)",
    "insertText": "Private_ItemFromWidget(const ITableRow* TheWidget)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (const TObjectPtrWrapTypeOf<ItemType>* LookupResult = WidgetGenerator . WidgetMapToItem .)",
    "insertText": "Find(TheWidget)"
  },
  {
    "label": "Private_UsesSelectorFocus()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Private_UsesSelectorFocus()"
  },
  {
    "label": "Private_IsItemHighlighted()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Private_IsItemHighlighted(const ItemType& TheItem)"
  },
  {
    "label": "Private_IsItemExpanded()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Private_IsItemExpanded(const ItemType& TheItem)"
  },
  {
    "label": "Private_SetItemExpansion()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Private_SetItemExpansion(ItemType TheItem, bool bShouldBeExpanded)"
  },
  {
    "label": "Private_OnExpanderArrowShiftClicked()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Private_OnExpanderArrowShiftClicked(ItemType TheItem, bool bShouldBeExpanded)"
  },
  {
    "label": "Private_DoesItemHaveChildren()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Private_DoesItemHaveChildren(int32 ItemIndexInList)"
  },
  {
    "label": "Private_SetItemHighlighted()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Private_SetItemHighlighted(ItemType TheItem, bool bShouldBeHighlighted)"
  },
  {
    "label": "Private_ClearHighlightedItems()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Private_ClearHighlightedItems()"
  },
  {
    "label": "Private_GetNestingDepth()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Private_GetNestingDepth(int32 ItemIndexInList)"
  },
  {
    "label": "Private_IsLastChild()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Private_IsLastChild(int32 ItemIndexInList)"
  },
  {
    "label": "Private_GetOrientation()",
    "kind": "Method",
    "detail": "Function (} EOrientation)",
    "insertText": "Private_GetOrientation()"
  },
  {
    "label": "Private_OnItemRightClicked()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Private_OnItemRightClicked(ItemType TheItem, const FPointerEvent& MouseEvent)"
  },
  {
    "label": "OnRightMouseButtonUp()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "OnRightMouseButtonUp(MouseEvent)"
  },
  {
    "label": "Private_OnItemClicked()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Private_OnItemClicked(ItemType TheItem)"
  },
  {
    "label": "SLATE_BEGIN_ARGS()",
    "kind": "Method",
    "detail": "Function (} private : class SListViewPinnedRowWidget ; class SListViewPinnedRowWidget : public SCompoundWidget { public :)",
    "insertText": "SLATE_BEGIN_ARGS(SListViewPinnedRowWidget)"
  },
  {
    "label": "SLATE_END_ARGS()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SLATE_END_ARGS() void Construct(const FArguments& InArgs, TSharedPtr<ITableRow> InPinnedItemRow, TSharedRef<SListView> InOwnerListView, const int32 ItemIndex, const int32 NumPinnedItems)"
  },
  {
    "label": "ItemType()",
    "kind": "Method",
    "detail": "Function (PinnedItemRow = InPinnedItemRow ; OwnerListView = InOwnerListView ; TSharedPtr<STableRow<ItemType>> PinnedRow = StaticCastSharedPtr<STableRow<)",
    "insertText": "ItemType(InPinnedItemRow)"
  },
  {
    "label": "SetBorderImage()",
    "kind": "Method",
    "detail": "Function (PinnedRow ->)",
    "insertText": "SetBorderImage(FAppStyle::Get().GetBrush(\"NoBrush\"))"
  },
  {
    "label": "SetExpanderArrowVisibility()",
    "kind": "Method",
    "detail": "Function (PinnedRow ->)",
    "insertText": "SetExpanderArrowVisibility(EVisibility::Hidden)"
  },
  {
    "label": "SetVisibility()",
    "kind": "Method",
    "detail": "Function (InPinnedItemRowWidget ->)",
    "insertText": "SetVisibility(EVisibility::HitTestInvisible)"
  },
  {
    "label": "SNew()",
    "kind": "Method",
    "detail": "Function (ChildSlot [)",
    "insertText": "SNew(SOverlay) .Visibility(TAttribute<EVisibility>::CreateSP(this, &SListViewPinnedRowWidget::SetPinnedItemVisibility, ItemIndex, NumPinnedItems)) + SOverlay::Slot() .Padding(FMargin(0.0f, 0.0f, 0.0f, 0.0f)) [ SNew(SBorder) .BorderImage_Lambda([this]() { return this->IsHovered() ? FAppStyle::Get().GetBrush(\"Brushes.Hover\") : FAppStyle::Get().GetBrush(\"Brushes.Header\"); }) .Padding(0.f) .Content() [ SNew(SHorizontalBox) + SHorizontalBox::Slot() .AutoWidth() [ InPinnedItemRowWidget ] + SHorizontalBox::Slot() .FillWidth(1.0f) .Padding(2.0f, 2.0f, 0.0f, 0.0f) [ SNew(STextBlock).Text(NSLOCTEXT(\"SListView\", \"Ellipses\", \"...\")) .Visibility(this, &SListViewPinnedRowWidget::SetPinnedItemEllipsesVisibility, ItemIndex) ] ] ] + SOverlay::Slot() .HAlign(HAlign_Fill) .VAlign(VAlign_Top) [ SNew(SImage) .Visibility(EVisibility::HitTestInvisible) .Image(FAppStyle::Get().GetBrush(\"ListView.PinnedItemShadow\"))"
  },
  {
    "label": "ItemFromWidget()",
    "kind": "Method",
    "detail": "Function (const TObjectPtrWrapTypeOf<ItemType>* PinnedItem = OwnerListView ->)",
    "insertText": "ItemFromWidget(PinnedItemRow.Get())"
  },
  {
    "label": "NavigationSelect()",
    "kind": "Method",
    "detail": "Function (OwnerListView ->)",
    "insertText": "NavigationSelect(*PinnedItem, MouseEvent)"
  },
  {
    "label": "Unhandled()",
    "kind": "Method",
    "detail": "Function (} } return)",
    "insertText": "Unhandled()"
  },
  {
    "label": "SetPinnedItemVisibility()",
    "kind": "Method",
    "detail": "Function (} private : EVisibility)",
    "insertText": "SetPinnedItemVisibility(const int32 IndexInList, const int32 NumPinnedItems)"
  },
  {
    "label": "SetBackgroundBrush()",
    "kind": "Method",
    "detail": "Function (Style = InStyle ;)",
    "insertText": "SetBackgroundBrush(Style != nullptr ? &Style->BackgroundBrush : FStyleDefaults::GetNoBrush())"
  },
  {
    "label": "SetOnEntryInitialized()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetOnEntryInitialized(const FOnEntryInitialized& Delegate)"
  },
  {
    "label": "UpdateSelectionSet()",
    "kind": "Method",
    "detail": "Function (OnEntryInitialized = Delegate ; } void)",
    "insertText": "UpdateSelectionSet()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bSelectionChanged = false ;)",
    "insertText": "if(!HasValidItemsSource())"
  },
  {
    "label": "bItemIsSelected()",
    "kind": "Method",
    "detail": "Function (ItemType CurItem = Items [ ItemIndex ] ; const bool)",
    "insertText": "bItemIsSelected(nullptr != SelectedItems.Find( CurItem ))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (NewSelectedItems .)",
    "insertText": "Add(CurItem)"
  },
  {
    "label": "Difference()",
    "kind": "Method",
    "detail": "Function (} } TItemSet SetDifference = SelectedItems .)",
    "insertText": "Difference(NewSelectedItems)"
  },
  {
    "label": "bSelectionChanged()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bSelectionChanged(SetDifference.Num())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (SelectedItems = NewSelectedItems ; })",
    "insertText": "if(bSelectionChanged)"
  },
  {
    "label": "Private_SignalSelectionChanged()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Private_SignalSelectionChanged(ESelectInfo::Direct)"
  },
  {
    "label": "ReGenerateItems()",
    "kind": "Method",
    "detail": "Function (} } } FReGenerateResults)",
    "insertText": "ReGenerateItems(const FGeometry& MyGeometry)"
  },
  {
    "label": "DoubleFractional()",
    "kind": "Method",
    "detail": "Function (double)",
    "insertText": "DoubleFractional(double Value)"
  },
  {
    "label": "ClearWidgets()",
    "kind": "Method",
    "detail": "Function (} ; this ->)",
    "insertText": "ClearWidgets()"
  },
  {
    "label": "GenerationPassGuard()",
    "kind": "Method",
    "detail": "Function (FGenerationPassGuard)",
    "insertText": "GenerationPassGuard(WidgetGenerator)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (float ItemsInView = 0 . 0 f ; float LengthGeneratedSoFar = 0 . 0 f ; float ViewLengthUsedSoFar = 0 . 0 f ; int32 StartIndex =)",
    "insertText": "Clamp((int32)(FMath::FloorToDouble(CurrentScrollOffset)), 0, Items.Num() - 1)"
  },
  {
    "label": "GetAccumulatedLayoutTransform()",
    "kind": "Method",
    "detail": "Function (float FirstItemLength = 0 . 0 f ; bool bHasFilledAvailableArea = false ; bool bAtEndOfList = false ; const float LayoutScaleMultiplier = MyGeometry .)",
    "insertText": "GetAccumulatedLayoutTransform().GetScale()"
  },
  {
    "label": "MyDimensions()",
    "kind": "Method",
    "detail": "Function (FTableViewDimensions)",
    "insertText": "MyDimensions(this->Orientation, MyGeometry.GetLocalSize())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const ItemType& CurItem = Items [ ItemIndex ] ;)",
    "insertText": "if(!TListTypeTraits<ItemType>::IsPtrValid(CurItem))"
  },
  {
    "label": "GenerateWidgetForItem()",
    "kind": "Method",
    "detail": "Function (continue ; } const float ItemLength =)",
    "insertText": "GenerateWidgetForItem(CurItem, ItemIndex, StartIndex, LayoutScaleMultiplier)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const bool bIsFirstItem = ItemIndex = = StartIndex ;)",
    "insertText": "if(bIsFirstItem)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (const float FirstItemFractionScrolledIntoView = 1 . 0)",
    "insertText": "f(float)FMath::Max(DoubleFractional(CurrentScrollOffset), 0.0)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (const float FirstItemLengthScrolledIntoView = ItemLength* FirstItemFractionScrolledIntoView ; const float FirstItemVisibleFraction =)",
    "insertText": "Min(MyDimensions.ScrollAxis / FirstItemLengthScrolledIntoView, FirstItemFractionScrolledIntoView)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ItemsInView + = FirstItemVisibleFraction ; } else)",
    "insertText": "if(ViewLengthUsedSoFar + ItemLength > MyDimensions.ScrollAxis)"
  },
  {
    "label": "ItemsInView()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ItemsInView(MyDimensions.ScrollAxis - ViewLengthUsedSoFar)"
  },
  {
    "label": "ViewLengthUsedSoFar()",
    "kind": "Method",
    "detail": "Function (} else { ItemsInView + = 1 ; } LengthGeneratedSoFar + = ItemLength ;)",
    "insertText": "ViewLengthUsedSoFar(bIsFirstItem)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bHasFilledAvailableArea = true ; } else { const float FloatPrecisionOffset = 0 . 0 0 1 f ; bHasFilledAvailableArea = ViewLengthUsedSoFar> = MyDimensions . ScrollAxis + FloatPrecisionOffset ; } })",
    "insertText": "if(bAtEndOfList && !bHasFilledAvailableArea)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const ItemType& CurItem = Items [ ItemIndex ] ;)",
    "insertText": "if(TListTypeTraits<ItemType>::IsPtrValid(CurItem))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (NewScrollOffsetForBackfill = static_cast<)",
    "insertText": "double(ItemIndex) + (LengthGeneratedSoFar + ItemLength - MyDimensions.ScrollAxis)"
  },
  {
    "label": "FReGenerateResults()",
    "kind": "Method",
    "detail": "Function (} LengthGeneratedSoFar + = ItemLength ; } } return)",
    "insertText": "FReGenerateResults(NewScrollOffsetForBackfill, LengthGeneratedSoFar, Items.Num() - NewScrollOffsetForBackfill, true)"
  },
  {
    "label": "FReGenerateResults()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "FReGenerateResults(CurrentScrollOffset, LengthGeneratedSoFar, ItemsInView, false)"
  },
  {
    "label": "FReGenerateResults()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "FReGenerateResults(0.0f, 0.0f, 0.0f, false)"
  },
  {
    "label": "GenerateWidgetForItem()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GenerateWidgetForItem(const ItemType& CurItem, int32 ItemIndex, int32 StartIndex, float LayoutScaleMultiplier)"
  },
  {
    "label": "GetWidgetForItem()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<ITableRow> WidgetForItem = WidgetGenerator .)",
    "insertText": "GetWidgetForItem(CurItem)"
  },
  {
    "label": "GenerateNewWidget()",
    "kind": "Method",
    "detail": "Function (WidgetForItem = this ->)",
    "insertText": "GenerateNewWidget(CurItem)"
  },
  {
    "label": "SetIndexInList()",
    "kind": "Method",
    "detail": "Function (} WidgetForItem ->)",
    "insertText": "SetIndexInList(ItemIndex)"
  },
  {
    "label": "OnItemSeen()",
    "kind": "Method",
    "detail": "Function (WidgetGenerator .)",
    "insertText": "OnItemSeen(CurItem, WidgetForItem.ToSharedRef())"
  },
  {
    "label": "MarkPrepassAsDirty()",
    "kind": "Method",
    "detail": "Function (NewlyGeneratedWidget ->)",
    "insertText": "MarkPrepassAsDirty()"
  },
  {
    "label": "SlatePrepass()",
    "kind": "Method",
    "detail": "Function (NewlyGeneratedWidget ->)",
    "insertText": "SlatePrepass(LayoutScaleMultiplier)"
  },
  {
    "label": "AppendWidget()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "AppendWidget(WidgetForItem.ToSharedRef())"
  },
  {
    "label": "InsertWidget()",
    "kind": "Method",
    "detail": "Function (} else { this ->)",
    "insertText": "InsertWidget(WidgetForItem.ToSharedRef())"
  },
  {
    "label": "GetVisibility()",
    "kind": "Method",
    "detail": "Function (} const bool bIsVisible = NewlyGeneratedWidget ->)",
    "insertText": "GetVisibility().IsVisible()"
  },
  {
    "label": "GeneratedWidgetDimensions()",
    "kind": "Method",
    "detail": "Function (FTableViewDimensions)",
    "insertText": "GeneratedWidgetDimensions(this->Orientation, bIsVisible ? NewlyGeneratedWidget->GetDesiredSize() : FVector2D::ZeroVector)"
  },
  {
    "label": "ClearPinnedWidgets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearPinnedWidgets()"
  },
  {
    "label": "GenerationPassGuard()",
    "kind": "Method",
    "detail": "Function (FGenerationPassGuard)",
    "insertText": "GenerationPassGuard(PinnedWidgetGenerator)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (MaxPinnedItems .)",
    "insertText": "Set(MaxPinnedItemsOverride)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} else { MaxPinnedItems = DefaultMaxPinnedItems ; } int32 CurrentMaxPinnedItems = MaxPinnedItems .)",
    "insertText": "Get()"
  },
  {
    "label": "GeneratePinnedWidgetForItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GeneratePinnedWidgetForItem(InItems[ItemIndex], ItemIndex, InItems.Num(), LayoutScaleMultiplier)"
  },
  {
    "label": "ResetPtr()",
    "kind": "Method",
    "detail": "Function (TListTypeTraits<ItemType)",
    "insertText": "ResetPtr(SelectorItem)"
  },
  {
    "label": "GeneratePinnedWidgetForItem()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "GeneratePinnedWidgetForItem(const ItemType& CurItem, int32 ItemIndex, int32 NumPinnedItems, float LayoutScaleMultiplier)"
  },
  {
    "label": "GenerateNewPinnedWidget()",
    "kind": "Method",
    "detail": "Function (WidgetForItem = this ->)",
    "insertText": "GenerateNewPinnedWidget(CurItem, ItemIndex, NumPinnedItems)"
  },
  {
    "label": "SNew()",
    "kind": "Method",
    "detail": "Function (TSharedRef<SWidget> NewListItemWidget =)",
    "insertText": "SNew(SListViewPinnedRowWidget, WidgetForItem, SharedThis(this), ItemIndex, NumPinnedItems)"
  },
  {
    "label": "AppendPinnedWidget()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "AppendPinnedWidget(NewListItemWidget)"
  },
  {
    "label": "GetNumItemsBeingObserved()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetNumItemsBeingObserved()"
  },
  {
    "label": "GenerateNewPinnedWidget()",
    "kind": "Method",
    "detail": "Function (} TSharedRef<ITableRow>)",
    "insertText": "GenerateNewPinnedWidget(ItemType InItem, const int32 ItemIndex, const int32 NumPinnedItems)"
  },
  {
    "label": "SNew()",
    "kind": "Method",
    "detail": "Function (} else { TSharedRef<STableRow<ItemType>> NewListItemWidget =)",
    "insertText": "SNew(STableRow<ItemType>, SharedThis(this)) .Content() [ SNew(STextBlock).Text(NSLOCTEXT(\"SListView\", \"OnGeneratePinnedRowNotAssignedMessage\", \"OnGeneratePinnedRow() not assigned.\"))"
  },
  {
    "label": "SNew()",
    "kind": "Method",
    "detail": "Function (} else { TSharedRef<STableRow<ItemType>> NewListItemWidget =)",
    "insertText": "SNew(STableRow<ItemType>, SharedThis(this) ) .Content() [ SNew(STextBlock) .Text( NSLOCTEXT(\"SListView\", \"OnGenerateWidgetNotAssignedMessage\", \"OnGenerateWidget() not assigned.\"))"
  },
  {
    "label": "SetItemsSource()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetItemsSource(MakeUnique<UE::Slate::ItemsSource::FArrayPointer<ItemType>>(InListItemsSource))"
  },
  {
    "label": "ClearItemsSource()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "ClearItemsSource()"
  },
  {
    "label": "SetItemsSource()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "SetItemsSource(TSharedRef<::UE::Slate::Containers::TObservableArray<ItemType>> InListItemsSource)"
  },
  {
    "label": "SetItemsSource()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetItemsSource(MakeUnique<UE::Slate::ItemsSource::FSharedObservableArray<ItemType>>(SharedThis(this), MoveTemp(InListItemsSource)))"
  },
  {
    "label": "SetItemsSource()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetItemsSource(TUniquePtr<UE::Slate::ItemsSource::IItemsSource<ItemType>> Provider)"
  },
  {
    "label": "CancelScrollIntoView()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CancelScrollIntoView()"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (ViewSource =)",
    "insertText": "MoveTemp(Provider)"
  },
  {
    "label": "RebuildList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RebuildList()"
  },
  {
    "label": "SetItemsSource()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetItemsSource(TUniquePtr<UE::Slate::ItemsSource::IItemsSource<ItemType>>())"
  },
  {
    "label": "SetItemsSource()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetItemsSource(&InListItemsSource)"
  },
  {
    "label": "HasValidItemsSource()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasValidItemsSource()"
  },
  {
    "label": "ItemFromWidget()",
    "kind": "Method",
    "detail": "Function (} const TObjectPtrWrapTypeOf<ItemType>*)",
    "insertText": "ItemFromWidget(const ITableRow* WidgetToFind)"
  },
  {
    "label": "IsItemSelected()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsItemSelected(const ItemType& InItem)"
  },
  {
    "label": "SetItemSelection()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetItemSelection(const ItemType& InItem, bool bSelected, ESelectInfo::Type SelectInfo = ESelectInfo::Direct)"
  },
  {
    "label": "Private_SignalSelectionChanged()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Private_SignalSelectionChanged(SelectInfo)"
  },
  {
    "label": "SetItemSelection()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetItemSelection(TConstArrayView<ItemType> InItems, bool bSelected, ESelectInfo::Type SelectInfo = ESelectInfo::Direct)"
  },
  {
    "label": "Private_SetItemSelection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Private_SetItemSelection(Item, bSelected, SelectInfo != ESelectInfo::Direct)"
  },
  {
    "label": "ClearSelection()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearSelection()"
  },
  {
    "label": "SetItemHighlighted()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetItemHighlighted(const ItemType& TheItem, bool bHighlighted)"
  },
  {
    "label": "Private_SetItemHighlighted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Private_SetItemHighlighted(TheItem, bHighlighted)"
  },
  {
    "label": "ClearHighlightedItems()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearHighlightedItems()"
  },
  {
    "label": "GetNumItemsSelected()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetNumItemsSelected()"
  },
  {
    "label": "RequestListRefresh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RequestListRefresh()"
  },
  {
    "label": "GetSelectedItems()",
    "kind": "Method",
    "detail": "Function (} TArray<ItemType>)",
    "insertText": "GetSelectedItems()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (TArray<ItemType> SelectedItemArray ; SelectedItemArray .)",
    "insertText": "Empty(SelectedItems.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (SelectedItemArray .)",
    "insertText": "Add(*SelectedItemIt)"
  },
  {
    "label": "GetSelectedItems()",
    "kind": "Method",
    "detail": "Function (} return SelectedItemArray ; } int32)",
    "insertText": "GetSelectedItems(TArray< ItemType >& SelectedItemArray)"
  },
  {
    "label": "IsItemVisible()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsItemVisible(ItemType Item)"
  },
  {
    "label": "RequestScrollIntoView()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RequestScrollIntoView(ItemType ItemToView, const uint32 UserIndex = 0)"
  },
  {
    "label": "RequestLayoutRefresh()",
    "kind": "Method",
    "detail": "Function (ItemToScrollIntoView = ItemToView ; UserRequestingScrollIntoView = UserIndex ;)",
    "insertText": "RequestLayoutRefresh()"
  },
  {
    "label": "RequestNavigateToItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RequestNavigateToItem(ItemToView, UserIndex)"
  },
  {
    "label": "RequestScrollIntoView()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "RequestScrollIntoView(ItemToView, UserIndex)"
  },
  {
    "label": "RequestNavigateToItem()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RequestNavigateToItem(ItemType Item, const uint32 UserIndex = 0)"
  },
  {
    "label": "Private_FindNextSelectableOrNavigable()",
    "kind": "Method",
    "detail": "Function (TOptional<ItemType> FirstValidItem =)",
    "insertText": "Private_FindNextSelectableOrNavigable(Item)"
  },
  {
    "label": "Private_RequestNavigateToItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Private_RequestNavigateToItem(FirstValidItem.GetValue(), UserIndex)"
  },
  {
    "label": "Private_RequestNavigateToItem()",
    "kind": "Method",
    "detail": "Function (} } private : void)",
    "insertText": "Private_RequestNavigateToItem(ItemType Item, const uint32 UserIndex)"
  },
  {
    "label": "RequestScrollIntoView()",
    "kind": "Method",
    "detail": "Function (bNavigateOnScrollIntoView = true ;)",
    "insertText": "RequestScrollIntoView(Item, UserIndex)"
  },
  {
    "label": "ResetPtr()",
    "kind": "Method",
    "detail": "Function (UserRequestingScrollIntoView = 0 ; bNavigateOnScrollIntoView = false ; TListTypeTraits<ItemType)",
    "insertText": "ResetPtr(ItemToScrollIntoView)"
  },
  {
    "label": "SetSelection()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSelection(ItemType SoleSelectedItem, ESelectInfo::Type SelectInfo = ESelectInfo::Direct)"
  },
  {
    "label": "Private_FindNextSelectableOrNavigable()",
    "kind": "Method",
    "detail": "Function (TOptional<ItemType> FirstValidItem =)",
    "insertText": "Private_FindNextSelectableOrNavigable(SoleSelectedItem)"
  },
  {
    "label": "Private_SetSelection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Private_SetSelection(FirstValidItem.GetValue(), SelectInfo)"
  },
  {
    "label": "Private_SetSelection()",
    "kind": "Method",
    "detail": "Function (} } private : void)",
    "insertText": "Private_SetSelection(ItemType SoleSelectedItem, ESelectInfo::Type SelectInfo)"
  },
  {
    "label": "SetItemSelection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetItemSelection(SoleSelectedItem, true, SelectInfo)"
  },
  {
    "label": "SetSelectionMode()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "SetSelectionMode(const TAttribute<ESelectionMode::Type>& NewSelectionMode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(PreviousMode == ESelectionMode::Multi)"
  },
  {
    "label": "SetSelection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSelection(*SelectedItems.CreateIterator())"
  },
  {
    "label": "SetScrollIntoViewAlignment()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "SetScrollIntoViewAlignment(EScrollIntoViewAlignment NewScrollIntoViewAlignment)"
  },
  {
    "label": "WidgetFromItem()",
    "kind": "Method",
    "detail": "Function (ScrollIntoViewAlignment = NewScrollIntoViewAlignment ; } TSharedPtr<ITableRow>)",
    "insertText": "WidgetFromItem(const ItemType& InItem)"
  },
  {
    "label": "GetWidgetForItem()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<ITableRow> ItemWidget = WidgetGenerator .)",
    "insertText": "GetWidgetForItem(InItem)"
  },
  {
    "label": "AddReferencedObjects()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddReferencedObjects(FReferenceCollector& Collector)"
  },
  {
    "label": "AddReferencedObjects()",
    "kind": "Method",
    "detail": "Function (TListTypeTraits<ItemType)",
    "insertText": "AddReferencedObjects(Collector, WidgetGenerator.ItemsWithGeneratedWidgets, SelectedItems, WidgetGenerator.WidgetMapToItem)"
  },
  {
    "label": "GetReferencerName()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "GetReferencerName()"
  },
  {
    "label": "GetMaxRowSizeForColumn()",
    "kind": "Method",
    "detail": "Function (} FVector2D)",
    "insertText": "GetMaxRowSizeForColumn(const FName& ColumnId, EOrientation ColumnOrientation)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FVector2D MaxSize = FVector2D::ZeroVector ;)",
    "insertText": "for(auto It = WidgetGenerator.WidgetMapToItem.CreateConstIterator(); It; ++It)"
  },
  {
    "label": "Key()",
    "kind": "Method",
    "detail": "Function (const ITableRow* TableRow = It .)",
    "insertText": "Key()"
  },
  {
    "label": "GetRowSizeForColumn()",
    "kind": "Method",
    "detail": "Function (FVector2D NewMaxSize = TableRow ->)",
    "insertText": "GetRowSizeForColumn(ColumnId)"
  },
  {
    "label": "GetDefaultDebugDelegate()",
    "kind": "Method",
    "detail": "Function (MaxSize = NewMaxSize ; } } return MaxSize ; } protected : FOnItemToString_Debug)",
    "insertText": "GetDefaultDebugDelegate()"
  },
  {
    "label": "ScrollIntoView()",
    "kind": "Method",
    "detail": "Function (} EScrollIntoViewResult)",
    "insertText": "ScrollIntoView(const FGeometry& ListViewGeometry)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (const int32 IndexOfItem = Items .)",
    "insertText": "Find(TListTypeTraits<ItemType>::NullableItemTypeConvertToItemType( ItemToScrollIntoView ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NumLiveWidgets = LastGenerateResults . ExactNumLinesOnScreen ;)",
    "insertText": "if(NumLiveWidgets == 0)"
  },
  {
    "label": "NumFullEntriesInView()",
    "kind": "Method",
    "detail": "Function (const int32)",
    "insertText": "NumFullEntriesInView(int32)(FMath::FloorToDouble(CurrentScrollOffset + NumLiveWidgets) - FMath::CeilToDouble(CurrentScrollOffset))"
  },
  {
    "label": "FloorToDouble()",
    "kind": "Method",
    "detail": "Function (const double MinDisplayedIndex = bNavigateOnScrollIntoView ?)",
    "insertText": "FloorToDouble(CurrentScrollOffset) : FMath::CeilToDouble(CurrentScrollOffset)"
  },
  {
    "label": "CeilToDouble()",
    "kind": "Method",
    "detail": "Function (const double MaxDisplayedIndex = bNavigateOnScrollIntoView ?)",
    "insertText": "CeilToDouble(CurrentScrollOffset + NumFullEntriesInView) : FMath::FloorToDouble(CurrentScrollOffset + NumFullEntriesInView)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case EScrollIntoViewAlignment::IntoView :)",
    "insertText": "if(IndexOfItem > MaxDisplayedIndex)"
  },
  {
    "label": "NewScrollOffset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NewScrollOffset(NumLiveWidgets - 1.0)"
  },
  {
    "label": "IndexOfItem()",
    "kind": "Method",
    "detail": "Function (} break ; case EScrollIntoViewAlignment::TopOrLeft : NewScrollOffset = IndexOfItem ; break ; case EScrollIntoViewAlignment::BottomOrRight : NewScrollOffset =)",
    "insertText": "IndexOfItem(NumLiveWidgets - 1.0)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (break ; } const double MaxScrollOffset =)",
    "insertText": "Max(0.0, static_cast<double>(Items.Num()) - NumLiveWidgets)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (NewScrollOffset = FMath::Clamp<)",
    "insertText": "double(NewScrollOffset, 0.0, MaxScrollOffset)"
  },
  {
    "label": "SetScrollOffset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScrollOffset((float)NewScrollOffset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(bNavigateOnScrollIntoView)"
  },
  {
    "label": "AsWidget()",
    "kind": "Method",
    "detail": "Function (const FGeometry& WidgetGeometry = TableRow ->)",
    "insertText": "AsWidget()->GetCachedGeometry()"
  },
  {
    "label": "WidgetTopLeft()",
    "kind": "Method",
    "detail": "Function (const FTableViewDimensions)",
    "insertText": "WidgetTopLeft(this->Orientation, WidgetGeometry.GetAbsolutePositionAtCoordinates(FVector2D::ZeroVector))"
  },
  {
    "label": "ListViewTopLeft()",
    "kind": "Method",
    "detail": "Function (const FTableViewDimensions)",
    "insertText": "ListViewTopLeft(this->Orientation, ListViewGeometry.GetAbsolutePositionAtCoordinates(FVector2D::ZeroVector))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (NewScrollOffset = static_cast<)",
    "insertText": "double(IndexOfItem)"
  },
  {
    "label": "BottomRight()",
    "kind": "Method",
    "detail": "Function (} else { const FVector2D)",
    "insertText": "BottomRight(1.f, 1.f)"
  },
  {
    "label": "WidgetBottomRight()",
    "kind": "Method",
    "detail": "Function (const FTableViewDimensions)",
    "insertText": "WidgetBottomRight(this->Orientation, WidgetGeometry.GetAbsolutePositionAtCoordinates(BottomRight))"
  },
  {
    "label": "ListViewBottomRight()",
    "kind": "Method",
    "detail": "Function (const FTableViewDimensions)",
    "insertText": "ListViewBottomRight(this->Orientation, ListViewGeometry.GetAbsolutePositionAtCoordinates(BottomRight))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (float DistanceRemaining = WidgetBottomRight . ScrollAxis - ListViewBottomRight . ScrollAxis ; float AdditionalOffset = 0 . f ;)",
    "insertText": "for(const ItemType& ItemWithWidget : WidgetGenerator.ItemsWithGeneratedWidgets)"
  },
  {
    "label": "WidgetAbsoluteDimensions()",
    "kind": "Method",
    "detail": "Function (FTableViewDimensions)",
    "insertText": "WidgetAbsoluteDimensions(this->Orientation, WidgetGenerator.GetWidgetForItem(ItemWithWidget)->AsWidget()->GetCachedGeometry().GetAbsoluteSize())"
  },
  {
    "label": "AdditionalOffset()",
    "kind": "Method",
    "detail": "Function (DistanceRemaining - = WidgetAbsoluteDimensions . ScrollAxis ; AdditionalOffset + = 1 . f ; } else { AdditionalOffset + = DistanceRemaining / WidgetAbsoluteDimensions . ScrollAxis ; DistanceRemaining = 0 . f ; break ; } } NewScrollOffset = DesiredScrollOffset +)",
    "insertText": "AdditionalOffset(FixedLineScrollOffset.IsSet() ? 0.f : NavigationScrollOffset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(TListTypeTraits<ItemType>::IsPtrValid(ItemToNotifyWhenInView))"
  },
  {
    "label": "WidgetFromItem()",
    "kind": "Method",
    "detail": "Function (const bool bHasWidgetForItem =)",
    "insertText": "WidgetFromItem(TListTypeTraits<ItemType>::NullableItemTypeConvertToItemType(ItemToNotifyWhenInView)).IsValid()"
  },
  {
    "label": "NullableItemTypeConvertToItemType()",
    "kind": "Method",
    "detail": "Function (ItemType NonNullItemToNotifyWhenInView = TListTypeTraits<ItemType)",
    "insertText": "NullableItemTypeConvertToItemType(ItemToNotifyWhenInView)"
  },
  {
    "label": "GetWidgetForItem()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<ITableRow> Widget = WidgetGenerator .)",
    "insertText": "GetWidgetForItem(NonNullItemToNotifyWhenInView)"
  },
  {
    "label": "NavigateToWidget()",
    "kind": "Method",
    "detail": "Function (SelectorItem = NonNullItemToNotifyWhenInView ;)",
    "insertText": "NavigateToWidget(UserRequestingScrollIntoView, Widget->AsWidget())"
  },
  {
    "label": "ExecuteIfBound()",
    "kind": "Method",
    "detail": "Function (} OnItemScrolledIntoView .)",
    "insertText": "ExecuteIfBound(NonNullItemToNotifyWhenInView, Widget)"
  },
  {
    "label": "ResetPtr()",
    "kind": "Method",
    "detail": "Function (} bNavigateOnScrollIntoView = false ; TListTypeTraits<ItemType)",
    "insertText": "ResetPtr(ItemToNotifyWhenInView)"
  },
  {
    "label": "NotifyFinishedScrolling()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "NotifyFinishedScrolling()"
  },
  {
    "label": "ScrollBy()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "ScrollBy(const FGeometry& MyGeometry, float ScrollByAmountInSlateUnits, EAllowOverscroll InAllowOverscroll)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "if(InAllowOverscroll == EAllowOverscroll::No)"
  },
  {
    "label": "StartingItemIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "StartingItemIndex(int32)"
  },
  {
    "label": "Sign()",
    "kind": "Method",
    "detail": "Function (const float UnclampedScrollDelta =)",
    "insertText": "Sign(ScrollByAmountInSlateUnits)"
  },
  {
    "label": "ScrollBy()",
    "kind": "Method",
    "detail": "Function (const float ActuallyScrolledBy = Overscroll .)",
    "insertText": "ScrollBy(MyGeometry, UnclampedScrollDelta)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return ActuallyScrolledBy ; } else)",
    "insertText": "if(!bWholeListVisible)"
  },
  {
    "label": "OnItemSeen()",
    "kind": "Method",
    "detail": "Function (WidgetGenerator .)",
    "insertText": "OnItemSeen(CurItem, RowWidget.ToSharedRef())"
  },
  {
    "label": "AsWidget()",
    "kind": "Method",
    "detail": "Function (RowWidget ->)",
    "insertText": "AsWidget()->SlatePrepass(LayoutScaleMultiplier)"
  },
  {
    "label": "WidgetDimensions()",
    "kind": "Method",
    "detail": "Function (} const FTableViewDimensions)",
    "insertText": "WidgetDimensions(this->Orientation, RowWidget->AsWidget()->GetDesiredSize())"
  },
  {
    "label": "ScrollAxis()",
    "kind": "Method",
    "detail": "Function (const float RemainingDistance = WidgetDimensions .)",
    "insertText": "ScrollAxis(float)(1.0 - DoubleFractional(NewScrollOffset))"
  },
  {
    "label": "NewScrollOffset()",
    "kind": "Method",
    "detail": "Function (AbsScrollByAmount - = RemainingDistance ;)",
    "insertText": "NewScrollOffset(int32)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } } else)",
    "insertText": "if(AbsScrollByAmount == RemainingDistance)"
  },
  {
    "label": "NewScrollOffset()",
    "kind": "Method",
    "detail": "Function (break ; } else {)",
    "insertText": "NewScrollOffset(int32)NewScrollOffset + (1.0 - ((RemainingDistance - AbsScrollByAmount) / WidgetDimensions.ScrollAxis))"
  },
  {
    "label": "Fractional()",
    "kind": "Method",
    "detail": "Function (break ; } } else { float Fractional =)",
    "insertText": "Fractional((float)NewScrollOffset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Fractional = 1 . 0 f ; - - NewScrollOffset ; } const float PrecedingDistance = WidgetDimensions . ScrollAxis* Fractional ;)",
    "insertText": "if(AbsScrollByAmount > PrecedingDistance)"
  },
  {
    "label": "DoubleFractional()",
    "kind": "Method",
    "detail": "Function (AbsScrollByAmount - = PrecedingDistance ; NewScrollOffset - =)",
    "insertText": "DoubleFractional(NewScrollOffset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - ItemIndex ; } else { NewScrollOffset = 0 . 0 ; break ; } } else)",
    "insertText": "if(AbsScrollByAmount == PrecedingDistance)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (break ; } else { NewScrollOffset =)",
    "insertText": "float(FMath::TruncToInt32(NewScrollOffset)) + ((PrecedingDistance - AbsScrollByAmount) / WidgetDimensions.ScrollAxis)"
  },
  {
    "label": "ScrollTo()",
    "kind": "Method",
    "detail": "Function (break ; } } } } return)",
    "insertText": "ScrollTo((float)NewScrollOffset)"
  },
  {
    "label": "Private_FindNextSelectableOrNavigableWithIndexAndDirection()",
    "kind": "Method",
    "detail": "Function (} return 0 ; } protected : TOptional<ItemType>)",
    "insertText": "Private_FindNextSelectableOrNavigableWithIndexAndDirection(const ItemType& InItemToSelect, int32 SelectionIdx, bool bSelectForward)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ItemType ItemToSelect = InItemToSelect ;)",
    "insertText": "if(OnIsSelectableOrNavigable.IsBound())"
  },
  {
    "label": "SelectionIdx()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SelectionIdx(bSelectForward ? 1 : -1)"
  },
  {
    "label": "ItemType()",
    "kind": "Method",
    "detail": "Function (ItemToSelect = Items [ SelectionIdx ] ; } else { return TOptional<)",
    "insertText": "ItemType()"
  },
  {
    "label": "ItemType()",
    "kind": "Method",
    "detail": "Function (} } } return TOptional<)",
    "insertText": "ItemType(ItemToSelect)"
  },
  {
    "label": "Private_FindNextSelectableOrNavigable()",
    "kind": "Method",
    "detail": "Function (} TOptional<ItemType>)",
    "insertText": "Private_FindNextSelectableOrNavigable(const ItemType& InItemToSelect)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (int32 NewSelectionIdx = Items .)",
    "insertText": "Find(ItemToSelect)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bSelectNextItem = true ;)",
    "insertText": "if(SelectedItems.Num() == 1)"
  },
  {
    "label": "CreateIterator()",
    "kind": "Method",
    "detail": "Function (NullableItemType LastSelectedItem =* SelectedItems .)",
    "insertText": "CreateIterator()"
  },
  {
    "label": "NullableItemTypeConvertToItemType()",
    "kind": "Method",
    "detail": "Function (ItemType NonNullLastSelectedItem = TListTypeTraits<ItemType)",
    "insertText": "NullableItemTypeConvertToItemType(LastSelectedItem)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (const int32 LastSelectedItemIdx = Items .)",
    "insertText": "Find(NonNullLastSelectedItem)"
  },
  {
    "label": "NewSelectionIdx()",
    "kind": "Method",
    "detail": "Function (bSelectNextItem = LastSelectedItemIdx<NewSelectionIdx ; } } do {)",
    "insertText": "NewSelectionIdx(bSelectNextItem ? 1 : -1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "while(!OnIsSelectableOrNavigable.Execute(ItemToSelect))"
  },
  {
    "label": "NavigationSelect()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "NavigationSelect(const ItemType& InItemToSelect, const FInputEvent& InInputEvent)"
  },
  {
    "label": "Private_FindNextSelectableOrNavigable()",
    "kind": "Method",
    "detail": "Function (TOptional<ItemType> ItemToSelect =)",
    "insertText": "Private_FindNextSelectableOrNavigable(InItemToSelect)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (SelectorItem = ItemToSelect .)",
    "insertText": "GetValue()"
  },
  {
    "label": "Private_RequestNavigateToItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Private_RequestNavigateToItem(ItemToSelect.GetValue(), InInputEvent.GetUserIndex())"
  },
  {
    "label": "Private_SelectRangeFromCurrentTo()",
    "kind": "Method",
    "detail": "Function (} this ->)",
    "insertText": "Private_SelectRangeFromCurrentTo(ItemToSelect.GetValue())"
  },
  {
    "label": "Private_SetItemSelection()",
    "kind": "Method",
    "detail": "Function (} else { this ->)",
    "insertText": "Private_SetItemSelection(ItemToSelect.GetValue(), true, true)"
  },
  {
    "label": "Private_SignalSelectionChanged()",
    "kind": "Method",
    "detail": "Function (} this ->)",
    "insertText": "Private_SignalSelectionChanged(ESelectInfo::OnNavigation)"
  },
  {
    "label": "Private_SetSelection()",
    "kind": "Method",
    "detail": "Function (} else { this ->)",
    "insertText": "Private_SetSelection(ItemToSelect.GetValue(), ESelectInfo::OnNavigation)"
  },
  {
    "label": "FGenerationPassGuard()",
    "kind": "Method",
    "detail": "Function (NullableItemType ItemToScrollIntoView ; uint32 UserRequestingScrollIntoView ; NullableItemType ItemToNotifyWhenInView ; EScrollIntoViewAlignment ScrollIntoViewAlignment ; FOnSelectionChanged OnSelectionChanged ; FIsSelectableOrNavigable OnIsSelectableOrNavigable ; FOnMouseButtonClick OnClick ; FOnMouseButtonDoubleClick OnDoubleClick ; FOnKeyDown OnKeyDownHandler ; TAttribute<bool> IsFocusable ; float NavigationScrollOffset = 0 . 5 f ; bool bClearSelectionOnClick ; bool bHandleGamepadEvents ; bool bHandleDirectionalNavigation ; bool bHandleSpacebarSelection = false ; bool bReturnFocusToSelection ; bool bNavigateOnScrollIntoView = false ; const FTableViewStyle* Style ; TAttribute<int32> MaxPinnedItems ; TAttribute<int32> DefaultMaxPinnedItems ; bool bIsHierarchyCollapsed = false ; private : TUniquePtr<UE::Slate::ItemsSource::IItemsSource<ItemType>> ViewSource ; private : struct FGenerationPassGuard { FWidgetGenerator& Generator ;)",
    "insertText": "FGenerationPassGuard(FWidgetGenerator& InGenerator ) : Generator(InGenerator)"
  },
  {
    "label": "FGenerationPassGuard()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FGenerationPassGuard()"
  }
]