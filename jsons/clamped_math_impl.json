[
  {
    "label": "Enable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Enable"
  },
  {
    "label": "ClampedAddOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedAddOp"
  },
  {
    "label": "ClampedSubOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedSubOp"
  },
  {
    "label": "ClampedMulOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedMulOp"
  },
  {
    "label": "ClampedDivOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedDivOp"
  },
  {
    "label": "ClampedModOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedModOp"
  },
  {
    "label": "ClampedLshOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedLshOp"
  },
  {
    "label": "ClampedRshOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedRshOp"
  },
  {
    "label": "ClampedAndOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedAndOp"
  },
  {
    "label": "ClampedOrOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedOrOp"
  },
  {
    "label": "ClampedXorOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedXorOp"
  },
  {
    "label": "ClampedMaxOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedMaxOp"
  },
  {
    "label": "ClampedMinOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClampedMinOp"
  },
  {
    "label": "Clamped",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Clamped"
  },
  {
    "label": "SaturatedNegWrapper()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_NUMERICS_CLAMPED_MATH_IMPL_H_ # define BASE_NUMERICS_CLAMPED_MATH_IMPL_H_ # include<stddef . h> # include<stdint . h> # include<climits> # include<cmath> # include<cstdlib> # include<limits> # include<type_traits> # include \" base / numerics / checked_math . h \" # include \" base / numerics / safe_conversions . h \" # include \" base / numerics / safe_math_shared_impl . h \" namespace base { namespace internal { template<T,std::enable_if<std::is_integral<T>::value&& std::is_signed<T>::value>::type* = nullptr> T)",
    "insertText": "SaturatedNegWrapper(T value)"
  },
  {
    "label": "SaturatedAbsWrapper()",
    "kind": "Method",
    "detail": "Function (} template<T,std::enable_if<std::is_floating_point<T>::value>::type* = nullptr> T)",
    "insertText": "SaturatedAbsWrapper(T value)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (const V saturated = CommonMaxOrMin<)",
    "insertText": "V(IsValueNegative(y))"
  },
  {
    "label": "BASE_NUMERICS_LIKELY()",
    "kind": "Method",
    "detail": "Function (V result = { } ; return)",
    "insertText": "BASE_NUMERICS_LIKELY((CheckedAddOp<T, U>::Do(x, y, &result)))"
  },
  {
    "label": "Do()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,U,class Enable = void> struct ClampedSubOp { } ; template<T,U> struct ClampedSubOp<T,U,std::enable_if<std::is_integral<T>::value&& std::is_integral<U>::value>::type> { using result_type = MaxExponentPromotion<T,U>::type ; template<V = result_type> V)",
    "insertText": "Do(T x, U y)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (const V saturated = CommonMaxOrMin<)",
    "insertText": "V(!IsValueNegative(y))"
  },
  {
    "label": "BASE_NUMERICS_LIKELY()",
    "kind": "Method",
    "detail": "Function (V result = { } ; return)",
    "insertText": "BASE_NUMERICS_LIKELY((CheckedSubOp<T, U>::Do(x, y, &result)))"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (V result = { } ; const V saturated = CommonMaxOrMin<)",
    "insertText": "V(IsValueNegative(x) ^ IsValueNegative(y))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (V result = { } ;)",
    "insertText": "if(BASE_NUMERICS_LIKELY((CheckedDivOp<T, U>::Do(x, y, &result))))"
  },
  {
    "label": "BASE_NUMERICS_LIKELY()",
    "kind": "Method",
    "detail": "Function (V result = { } ; return)",
    "insertText": "BASE_NUMERICS_LIKELY((CheckedModOp<T, U>::Do(x, y, &result)))"
  },
  {
    "label": "Do()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,U,class Enable = void> struct ClampedLshOp { } ; template<T,U> struct ClampedLshOp<T,U,std::enable_if<std::is_integral<T>::value&& std::is_integral<U>::value>::type> { using result_type = T ; template<V = result_type> V)",
    "insertText": "Do(T x, U shift)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (V result = static_cast<)",
    "insertText": "V(as_unsigned(x) << shift)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (} return x ? CommonMaxOrMin<)",
    "insertText": "V(IsValueNegative(x))"
  },
  {
    "label": "as_unsigned()",
    "kind": "Method",
    "detail": "Function (const V saturated =)",
    "insertText": "as_unsigned(V(0)) - IsValueNegative(x)"
  },
  {
    "label": "BASE_FLOAT_ARITHMETIC_OPS()",
    "kind": "Method",
    "detail": "Function (} } ; # define)",
    "insertText": "BASE_FLOAT_ARITHMETIC_OPS(NAME, OP)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (\\ return saturated_cast<)",
    "insertText": "V(x OP y)"
  }
]