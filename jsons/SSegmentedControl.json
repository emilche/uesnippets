[
  {
    "label": "SSegmentedControl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SSegmentedControl"
  },
  {
    "label": "FSlot",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSlot"
  },
  {
    "label": "FSlot()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Styling / AppStyle . h \" # include \" Styling / SegmentedControlStyle . h \" # include \" Widgets / SBoxPanel . h \" # include \" Widgets / Images / SImage . h \" # include \" Widgets / Input / SCheckBox . h \" # include \" Widgets / Layout / SSpacer . h \" # include \" Widgets / Text / STextBlock . h \" # include \" Widgets / Layout / SBorder . h \" # include \" Widgets / Layout / SUniformGridPanel . h \" # include \" Framework / Application / SlateApplication . h \" template<OptionType> class SSegmentedControl : public SCompoundWidget { public : struct FSlot : public TSlotBase<FSlot>,public TAlignmentWidgetSlotMixin<FSlot> {)",
    "insertText": "FSlot(const OptionType& InValue) : TSlotBase<FSlot>() , TAlignmentWidgetSlotMixin<FSlot>(HAlign_Center, VAlign_Fill) , _Text() , _Tooltip() , _Icon(nullptr) , _Value(InValue)"
  },
  {
    "label": "SLATE_SLOT_BEGIN_ARGS_OneMixin()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SLATE_SLOT_BEGIN_ARGS_OneMixin(FSlot, TSlotBase<FSlot>, TAlignmentWidgetSlotMixin<FSlot>) SLATE_ATTRIBUTE(FText, Text) SLATE_ATTRIBUTE(FText, ToolTip) SLATE_ATTRIBUTE(TSharedPtr<IToolTip>, ToolTipWidget) SLATE_ATTRIBUTE(const FSlateBrush*, Icon) SLATE_ARGUMENT(TOptional<OptionType>, Value) SLATE_SLOT_END_ARGS() void Construct(const FChildren& SlotOwner, FSlotArguments&& InArgs)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (TSlotBase<FSlot)",
    "insertText": "Construct(SlotOwner, MoveTemp(InArgs))"
  },
  {
    "label": "ConstructMixin()",
    "kind": "Method",
    "detail": "Function (TAlignmentWidgetSlotMixin<FSlot)",
    "insertText": "ConstructMixin(SlotOwner, MoveTemp(InArgs))"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (_Text =)",
    "insertText": "MoveTemp(InArgs._Text)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InArgs._ToolTip.IsSet())"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (_Tooltip =)",
    "insertText": "MoveTemp(InArgs._ToolTip)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InArgs._ToolTipWidget.IsSet())"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (_ToolTipWidget =)",
    "insertText": "MoveTemp(InArgs._ToolTipWidget)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InArgs._Icon.IsSet())"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (_Icon =)",
    "insertText": "MoveTemp(InArgs._Icon)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InArgs._Value.IsSet())"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (_Value =)",
    "insertText": "MoveTemp(InArgs._Value.GetValue())"
  },
  {
    "label": "SetText()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetText(TAttribute<FText> InText)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (_Text =)",
    "insertText": "MoveTemp(InText)"
  },
  {
    "label": "GetText()",
    "kind": "Method",
    "detail": "Function (} FText)",
    "insertText": "GetText()"
  },
  {
    "label": "SetIcon()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetIcon(TAttribute<const FSlateBrush*> InBrush)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (_Icon =)",
    "insertText": "MoveTemp(InBrush)"
  },
  {
    "label": "GetIcon()",
    "kind": "Method",
    "detail": "Function (} const FSlateBrush*)",
    "insertText": "GetIcon()"
  },
  {
    "label": "SetToolTip()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetToolTip(TAttribute<FText> InTooltip)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (_Tooltip =)",
    "insertText": "MoveTemp(InTooltip)"
  },
  {
    "label": "GetToolTip()",
    "kind": "Method",
    "detail": "Function (} FText)",
    "insertText": "GetToolTip()"
  },
  {
    "label": "Slot()",
    "kind": "Method",
    "detail": "Function (} SSegmentedControl<OptionType> ; private : TAttribute<FText> _Text ; TAttribute<FText> _Tooltip ; TAttribute<TSharedPtr<IToolTip>> _ToolTipWidget ; TAttribute<const FSlateBrush*> _Icon ; OptionType _Value ; TWeakPtr<SCheckBox> _CheckBox ; } ; FSlot::FSlotArguments)",
    "insertText": "Slot(const OptionType& InValue)"
  },
  {
    "label": "DECLARE_DELEGATE_OneParam()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DECLARE_DELEGATE_OneParam(FOnValueChanged, OptionType)"
  },
  {
    "label": "DECLARE_DELEGATE_OneParam()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_DELEGATE_OneParam(FOnValuesChanged, TArray<OptionType>)"
  },
  {
    "label": "DECLARE_DELEGATE_TwoParams()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_DELEGATE_TwoParams(FOnValueChecked, OptionType, ECheckBoxState)"
  },
  {
    "label": "SLATE_BEGIN_ARGS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SLATE_BEGIN_ARGS(SSegmentedControl<OptionType> ) : _Style(&FAppStyle::Get().GetWidgetStyle<FSegmentedControlStyle>(\"SegmentedControl\")) , _TextStyle(&FAppStyle::Get().GetWidgetStyle<FTextBlockStyle>(\"SmallButtonText\")) , _SupportsMultiSelection(false) , _SupportsEmptySelection(false) , _MaxSegmentsPerLine(0)"
  },
  {
    "label": "SLATE_SLOT_ARGUMENT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SLATE_SLOT_ARGUMENT(FSlot, Slots) SLATE_STYLE_ARGUMENT(FSegmentedControlStyle, Style) SLATE_STYLE_ARGUMENT(FTextBlockStyle, TextStyle) SLATE_ARGUMENT(bool, SupportsMultiSelection) SLATE_ARGUMENT(bool, SupportsEmptySelection) SLATE_ATTRIBUTE(OptionType, Value) SLATE_ATTRIBUTE(TArray<OptionType>, Values) SLATE_ATTRIBUTE(FMargin, UniformPadding) SLATE_EVENT(FOnValueChanged, OnValueChanged) SLATE_EVENT(FOnValuesChanged, OnValuesChanged) SLATE_EVENT(FOnValueChecked, OnValueChecked) SLATE_ARGUMENT(int32, MaxSegmentsPerLine) SLATE_END_ARGS() SSegmentedControl() : Children(this) , CurrentValues(*this)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Construct(const FArguments& InArgs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Style = InArgs . _Style ; TextStyle = InArgs . _TextStyle ; SupportsMultiSelection = InArgs . _SupportsMultiSelection ; SupportsEmptySelection = InArgs . _SupportsEmptySelection ; CurrentValuesIsBound = false ;)",
    "insertText": "if(InArgs._Value.IsBound() || InArgs._Value.IsSet())"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValue(InArgs._Value, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(InArgs._Values.IsBound() || InArgs._Values.IsSet())"
  },
  {
    "label": "SetValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValues(InArgs._Values, false)"
  },
  {
    "label": "AddSlots()",
    "kind": "Method",
    "detail": "Function (} OnValueChanged = InArgs . _OnValueChanged ; OnValuesChanged = InArgs . _OnValuesChanged ; OnValueChecked = InArgs . _OnValueChecked ; UniformPadding = InArgs . _UniformPadding ; MaxSegmentsPerLine = InArgs . _MaxSegmentsPerLine ; Children .)",
    "insertText": "AddSlots(MoveTemp(const_cast<TArray<typename FSlot::FSlotArguments>&>(InArgs._Slots)))"
  },
  {
    "label": "RebuildChildren()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RebuildChildren()"
  },
  {
    "label": "SNew()",
    "kind": "Method",
    "detail": "Function (FMargin SlotPadding = Style -> UniformPadding ; SlotPadding . Right = 0 . 0 f ; TSharedPtr<SUniformGridPanel> UniformBox =)",
    "insertText": "SNew(SUniformGridPanel).SlotPadding(SlotPadding)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 NumSlots = Children .)",
    "insertText": "Num()"
  },
  {
    "label": "GetWidget()",
    "kind": "Method",
    "detail": "Function (TSharedRef<SWidget> Child = Children [ SlotIndex ] .)",
    "insertText": "GetWidget()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FSlot* ChildSlotPtr =& Children [ SlotIndex ] ; const OptionType ChildValue = ChildSlotPtr -> _Value ; TAttribute<FVector2D> SpacerLambda = FVector::ZeroVector ;)",
    "insertText": "if(ChildSlotPtr->_Icon.IsBound() || ChildSlotPtr->_Text.IsBound())"
  },
  {
    "label": "MakeAttributeLambda()",
    "kind": "Method",
    "detail": "Function (SpacerLambda =)",
    "insertText": "MakeAttributeLambda([ChildSlotPtr]() { return (ChildSlotPtr->_Icon.Get() != nullptr && !ChildSlotPtr->_Text.Get().IsEmpty()) ? FVector2D(8.0f, 1.0f) : FVector2D::ZeroVector; })"
  },
  {
    "label": "SpacerLambda()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "SpacerLambda(ChildSlotPtr->_Icon.Get() != nullptr && !ChildSlotPtr->_Text.Get().IsEmpty()) ? FVector2D(8.0f, 1.0f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Child == SNullWidget::NullWidget)"
  },
  {
    "label": "SNew()",
    "kind": "Method",
    "detail": "Function (Child =)",
    "insertText": "SNew(SHorizontalBox) +SHorizontalBox::Slot() .AutoWidth() .VAlign(VAlign_Center) [ SNew(SImage) .ColorAndOpacity(FSlateColor::UseForeground()) .Image(ChildSlotPtr->_Icon) ] +SHorizontalBox::Slot() .AutoWidth() [ SNew(SSpacer) .Size(SpacerLambda) ] +SHorizontalBox::Slot() .VAlign(VAlign_Center) .AutoWidth() [ SNew(STextBlock) .TextStyle(TextStyle) .Text(ChildSlotPtr->_Text)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} const FCheckBoxStyle* CheckBoxStyle =& Style -> ControlStyle ;)",
    "insertText": "if(SlotIndex == 0)"
  },
  {
    "label": "SNew()",
    "kind": "Method",
    "detail": "Function (} ChildSlot [)",
    "insertText": "SNew(SBorder) .BorderImage(&Style->BackgroundBrush) .Padding(FMargin(0,0,Style->UniformPadding.Right,0)) [ UniformBox.ToSharedRef()"
  },
  {
    "label": "UpdateCheckboxValuesIfNeeded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateCheckboxValuesIfNeeded()"
  },
  {
    "label": "AddSlot()",
    "kind": "Method",
    "detail": "Function (} using FScopedWidgetSlotArguments = TPanelChildren<FSlot>::FScopedWidgetSlotArguments ; FScopedWidgetSlotArguments)",
    "insertText": "AddSlot(const OptionType& InValue, bool bRebuildChildren = true)"
  },
  {
    "label": "SharedThis()",
    "kind": "Method",
    "detail": "Function (TWeakPtr<SSegmentedControl> AsWeak =)",
    "insertText": "SharedThis(this)"
  },
  {
    "label": "FSlot()",
    "kind": "Method",
    "detail": "Function (Children, INDEX_NONE })",
    "insertText": "FSlot(InValue)"
  },
  {
    "label": "NumSlots()",
    "kind": "Method",
    "detail": "Function (} } int32)",
    "insertText": "NumSlots()"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (} OptionType)",
    "insertText": "GetValue()"
  },
  {
    "label": "GetValues()",
    "kind": "Method",
    "detail": "Function (const TArray<OptionType> Values =)",
    "insertText": "GetValues()"
  },
  {
    "label": "HasValue()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasValue(OptionType InValue)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetValue(TAttribute<OptionType> InValue, bool bUpdateChildren = true)"
  },
  {
    "label": "SetValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValues(TAttribute<TArray<OptionType>>::CreateLambda([InValue]() -> TArray<OptionType> { TArray<OptionType> Values; Values.Add(InValue.Get()); return Values; }), bUpdateChildren)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(InValue.IsSet())"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (TArray<OptionType> Values = { InValue .)",
    "insertText": "Get()"
  },
  {
    "label": "SetValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValues(TAttribute<TArray<OptionType>>(Values), bUpdateChildren)"
  },
  {
    "label": "SetValues()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "SetValues(TAttribute<TArray<OptionType>>(), bUpdateChildren)"
  },
  {
    "label": "SetValues()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetValues(TAttribute<TArray<OptionType>> InValues, bool bUpdateChildren = true)"
  },
  {
    "label": "IsBound()",
    "kind": "Method",
    "detail": "Function (CurrentValuesIsBound = InValues .)",
    "insertText": "IsBound()"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (CurrentValues .)",
    "insertText": "Assign(*this, InValues)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(InValues.IsSet())"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (CurrentValues .)",
    "insertText": "Set(*this, InValues.Get())"
  },
  {
    "label": "Unbind()",
    "kind": "Method",
    "detail": "Function (} else { CurrentValues .)",
    "insertText": "Unbind(*this)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "if(bUpdateChildren)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (} } TSharedPtr<SSegmentedControl<OptionType>>)",
    "insertText": "Create(const TArray<OptionType>& InKeys, const TArray<FText>& InLabels, const TArray<FText>& InTooltips, const TAttribute<TArray<OptionType>>& InValues, bool bSupportsMultiSelection = true, FOnValuesChanged OnValuesChanged = FOnValuesChanged())"
  },
  {
    "label": "SAssignNew()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<SSegmentedControl<OptionType>> Widget ;)",
    "insertText": "SAssignNew(Widget, SSegmentedControl<OptionType>) .SupportsMultiSelection(bSupportsMultiSelection) .Values(InValues) .OnValuesChanged(OnValuesChanged)"
  },
  {
    "label": "AddSlot()",
    "kind": "Method",
    "detail": "Function (Widget ->)",
    "insertText": "AddSlot(InKeys[Index], false) .Text(InLabels[Index]) .ToolTip(InTooltips[Index])"
  },
  {
    "label": "InValue()",
    "kind": "Method",
    "detail": "Function (auto Lambda = [ this,)",
    "insertText": "InValue()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "if(CurrentValuesIsBound)"
  },
  {
    "label": "Lambda()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "Lambda()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FSlot& Slot = Children [ Index ] ;)",
    "insertText": "if(const TSharedPtr<SCheckBox> CheckBox = Slot._CheckBox.Pin())"
  },
  {
    "label": "CommitValue()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "CommitValue(const ECheckBoxState InCheckState, OptionType InValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<OptionType> Values = PreviousValues ;)",
    "insertText": "if(InCheckState != ECheckBoxState::Checked && Values.Num() == 1)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (bModifierIsDown =)",
    "insertText": "Get().GetModifierKeys().IsShiftDown() || FSlateApplication::Get().GetModifierKeys().IsControlDown()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bModifierIsDown)"
  },
  {
    "label": "AddUnique()",
    "kind": "Method",
    "detail": "Function (Values .)",
    "insertText": "AddUnique(InValue)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} else { Values .)",
    "insertText": "Remove(InValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if((InCheckState == ECheckBoxState::Checked) || Values.Contains(InValue))"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (Values .)",
    "insertText": "Reset()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Values .)",
    "insertText": "Add(InValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(!CurrentValuesIsBound)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (CurrentValues .)",
    "insertText": "Set(*this, Values)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(OnValueChecked.IsBound())"
  },
  {
    "label": "Execute()",
    "kind": "Method",
    "detail": "Function (OnValueChecked .)",
    "insertText": "Execute(PreviousValue, ECheckBoxState::Unchecked)"
  },
  {
    "label": "Execute()",
    "kind": "Method",
    "detail": "Function (} } } OnValueChecked .)",
    "insertText": "Execute(InValue, InCheckState)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InCheckState == ECheckBoxState::Checked)"
  },
  {
    "label": "ExecuteIfBound()",
    "kind": "Method",
    "detail": "Function (OnValueChanged .)",
    "insertText": "ExecuteIfBound(InValue)"
  },
  {
    "label": "ExecuteIfBound()",
    "kind": "Method",
    "detail": "Function (} OnValuesChanged .)",
    "insertText": "ExecuteIfBound(Values)"
  }
]