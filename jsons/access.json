[
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "__fn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__fn"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___RANGES_ACCESS_H # define _LIBCPP___RANGES_ACCESS_H # include<__concepts / class_or_enum . h> # include<__config> # include<__iterator / concepts . h> # include<__iterator / readable_traits . h> # include<__ranges / enable_borrowed_range . h> # include<__utility / auto_cast . h> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (template<class _Tp> concept __can_borrow = is_lvalue_reference_v<_Tp> | | enable_borrowed_range<remove_cvref_t<_Tp>> ; } namespace ranges { namespace __begin { template<class _Tp> concept __member_begin = __can_borrow<_Tp>&& __workaround_52970<_Tp>&&)",
    "insertText": "requires(_Tp&& __t)"
  },
  {
    "label": "_LIBCPP_AUTO_CAST()",
    "kind": "Method",
    "detail": "Function (input_or_output_iterator)",
    "insertText": "_LIBCPP_AUTO_CAST(__t.begin())"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "begin(auto&)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "begin(const auto&)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (template<class _Tp> concept __unqualified_begin = ! __member_begin<_Tp>&& __can_borrow<_Tp>&& __class_or_enum<remove_cvref_t<_Tp>>&&)",
    "insertText": "requires(_Tp && __t)"
  },
  {
    "label": "_LIBCPP_AUTO_CAST()",
    "kind": "Method",
    "detail": "Function (input_or_output_iterator)",
    "insertText": "_LIBCPP_AUTO_CAST(begin(__t))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; struct __fn { template<class _Tp> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp (&__t)[]) const noexcept requires (sizeof(_Tp) >= 0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp> requires __unqualified_begin<_Tp> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t) const noexcept(noexcept(_LIBCPP_AUTO_CAST(begin(__t))))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(auto&&)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; } namespace __cpo { auto begin = __begin::__fn { } ; } } namespace ranges { template<class _Tp> using iterator_t =)",
    "insertText": "decltype(ranges::begin(declval<_Tp&>()))"
  },
  {
    "label": "_LIBCPP_AUTO_CAST()",
    "kind": "Method",
    "detail": "Function (sentinel_for<iterator_t<_Tp>>)",
    "insertText": "_LIBCPP_AUTO_CAST(__t.end())"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "end(auto&)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "end(const auto&)"
  },
  {
    "label": "_LIBCPP_AUTO_CAST()",
    "kind": "Method",
    "detail": "Function (sentinel_for<iterator_t<_Tp>>)",
    "insertText": "_LIBCPP_AUTO_CAST(end(__t))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; struct __fn { template<class _Tp,size_t _Np> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp (&__t)[_Np]) const noexcept requires (sizeof(_Tp) >= 0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp> requires __unqualified_end<_Tp> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t) const noexcept(noexcept(_LIBCPP_AUTO_CAST(end(__t))))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; } namespace __cpo { auto end = __end::__fn { } ; } } namespace ranges { namespace __cbegin { struct __fn { template<class _Tp> requires is_lvalue_reference_v<_Tp&&> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t) const noexcept(noexcept(ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t)))) -> decltype( ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp> requires is_rvalue_reference_v<_Tp&&> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t) const noexcept(noexcept(ranges::begin(static_cast<const _Tp&&>(__t)))) -> decltype( ranges::begin(static_cast<const _Tp&&>(__t)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; } namespace __cpo { auto cbegin = __cbegin::__fn { } ; } } namespace ranges { namespace __cend { struct __fn { template<class _Tp> requires is_lvalue_reference_v<_Tp&&> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t) const noexcept(noexcept(ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t)))) -> decltype( ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Tp> requires is_rvalue_reference_v<_Tp&&> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Tp&& __t) const noexcept(noexcept(ranges::end(static_cast<const _Tp&&>(__t)))) -> decltype( ranges::end(static_cast<const _Tp&&>(__t)))"
  }
]