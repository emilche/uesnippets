[
  {
    "label": "LPPassManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LPPassManager"
  },
  {
    "label": "Function",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Function"
  },
  {
    "label": "PMStack",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PMStack"
  },
  {
    "label": "LoopPass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopPass"
  },
  {
    "label": "LoopPass()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ANALYSIS_LOOPPASS_H # define LLVM_ANALYSIS_LOOPPASS_H # include \" llvm / Analysis / LoopInfo . h \" # include \" llvm / IR / LegacyPassManagers . h \" # include \" llvm / Pass . h \" # include<deque> namespace llvm { class LPPassManager ; class Function ; class PMStack ; class LoopPass : public Pass { public :)",
    "insertText": "LoopPass(char &pid) : Pass(PT_Loop, pid)"
  },
  {
    "label": "createPrinterPass()",
    "kind": "Method",
    "detail": "Function (} Pass*)",
    "insertText": "createPrinterPass(raw_ostream &O, const std::string &Banner)"
  },
  {
    "label": "runOnLoop()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "runOnLoop(Loop *L, LPPassManager &LPM)"
  },
  {
    "label": "doInitialization()",
    "kind": "Method",
    "detail": "Function (using llvm::Pass::doInitialization ; using llvm::Pass::doFinalization ; bool)",
    "insertText": "doInitialization(Loop *L, LPPassManager &LPM)"
  },
  {
    "label": "assignPassManager()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assignPassManager(PMStack &PMS, PassManagerType PMT)"
  },
  {
    "label": "getPotentialPassManagerType()",
    "kind": "Method",
    "detail": "Function (PassManagerType)",
    "insertText": "getPotentialPassManagerType()"
  },
  {
    "label": "deleteAnalysisValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "deleteAnalysisValue(Value *V, Loop *L)"
  },
  {
    "label": "deleteAnalysisLoop()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "deleteAnalysisLoop(Loop *L)"
  },
  {
    "label": "skipOptnoneFunction()",
    "kind": "Method",
    "detail": "Function (} protected : bool)",
    "insertText": "skipOptnoneFunction(const Loop *L)"
  },
  {
    "label": "LPPassManager()",
    "kind": "Method",
    "detail": "Function (} ; class LPPassManager : public FunctionPass,public PMDataManager { public : char ID ;)",
    "insertText": "LPPassManager()"
  },
  {
    "label": "runOnFunction()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "runOnFunction(Function &F)"
  },
  {
    "label": "getAnalysisUsage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getAnalysisUsage(AnalysisUsage &Info)"
  },
  {
    "label": "getPassName()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "getPassName()"
  },
  {
    "label": "getContainedPass()",
    "kind": "Method",
    "detail": "Function (LoopPass*)",
    "insertText": "getContainedPass(unsigned N)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(N < PassVector.size() && \"Pass number out of range!\")"
  },
  {
    "label": "LoopPass()",
    "kind": "Method",
    "detail": "Function (LoopPass* LP = static_cast<)",
    "insertText": "LoopPass(PassVector[N])"
  },
  {
    "label": "insertLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insertLoop(Loop *L, Loop *ParentLoop)"
  },
  {
    "label": "insertLoopIntoQueue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insertLoopIntoQueue(Loop *L)"
  },
  {
    "label": "redoLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "redoLoop(Loop *L)"
  },
  {
    "label": "cloneBasicBlockSimpleAnalysis()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "cloneBasicBlockSimpleAnalysis(BasicBlock *From, BasicBlock *To, Loop *L)"
  },
  {
    "label": "deleteSimpleAnalysisValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deleteSimpleAnalysisValue(Value *V, Loop *L)"
  },
  {
    "label": "deleteSimpleAnalysisLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deleteSimpleAnalysisLoop(Loop *L)"
  }
]