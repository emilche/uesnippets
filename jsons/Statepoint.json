[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "GCRelocateOperands",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GCRelocateOperands"
  },
  {
    "label": "ImmutableStatepoint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ImmutableStatepoint"
  },
  {
    "label": "StatepointBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StatepointBase"
  },
  {
    "label": "Statepoint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Statepoint"
  },
  {
    "label": "isStatepoint()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_IR_STATEPOINT_H # define LLVM_IR_STATEPOINT_H # include \" llvm / ADT / iterator_range . h \" # include \" llvm / IR / BasicBlock . h \" # include \" llvm / IR / CallSite . h \" # include \" llvm / IR / Constants . h \" # include \" llvm / IR / Function . h \" # include \" llvm / IR / Instructions . h \" # include \" llvm / IR / Intrinsics . h \" # include \" llvm / Support / Compiler . h \" namespace llvm { enum class StatepointFlags { None = 0,GCTransition = 1,MaskAll = GCTransition } ; class GCRelocateOperands ; class ImmutableStatepoint ; bool)",
    "insertText": "isStatepoint(const ImmutableCallSite &CS)"
  },
  {
    "label": "isStatepoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isStatepoint(const Value *V)"
  },
  {
    "label": "isStatepoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isStatepoint(const Value &V)"
  },
  {
    "label": "isGCRelocate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isGCRelocate(const Value *V)"
  },
  {
    "label": "isGCRelocate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isGCRelocate(const ImmutableCallSite &CS)"
  },
  {
    "label": "isGCResult()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isGCResult(const Value *V)"
  },
  {
    "label": "isGCResult()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isGCResult(const ImmutableCallSite &CS)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (template<FunTy,InstructionTy,ValueTy,CallSiteTy> class StatepointBase { CallSiteTy StatepointCS ; void* operator)",
    "insertText": "new(size_t, unsigned)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void* operator)",
    "insertText": "new(size_t s)"
  },
  {
    "label": "StatepointBase()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "StatepointBase(InstructionTy *I)"
  },
  {
    "label": "CallSiteTy()",
    "kind": "Method",
    "detail": "Function (StatepointCS =)",
    "insertText": "CallSiteTy(I)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(StatepointCS && \"isStatepoint implies CallSite\")"
  },
  {
    "label": "StatepointBase()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "StatepointBase(CallSiteTy CS)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} public : typedef CallSiteTy::arg_iterator arg_iterator ; enum { IDPos = 0,NumPatchBytesPos = 1,CalledFunctionPos = 2,NumCallArgsPos = 3,FlagsPos = 4,CallArgsBeginPos = 5,} ; operator)",
    "insertText": "bool()"
  },
  {
    "label": "getCallSite()",
    "kind": "Method",
    "detail": "Function (} CallSiteTy)",
    "insertText": "getCallSite()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(*this && \"check validity first!\")"
  },
  {
    "label": "getID()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "getID()"
  },
  {
    "label": "getCallSite()",
    "kind": "Method",
    "detail": "Function (const Value* IDVal =)",
    "insertText": "getCallSite().getArgument(IDPos)"
  },
  {
    "label": "getNumPatchBytes()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "getNumPatchBytes()"
  },
  {
    "label": "getCallSite()",
    "kind": "Method",
    "detail": "Function (const Value* NumPatchBytesVal =)",
    "insertText": "getCallSite().getArgument(NumPatchBytesPos)"
  },
  {
    "label": "ConstantInt()",
    "kind": "Method",
    "detail": "Function (uint64_t NumPatchBytes = cast<)",
    "insertText": "ConstantInt(NumPatchBytesVal)->getZExtValue()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isInt<32>(NumPatchBytes) && \"should fit in 32 bits!\")"
  },
  {
    "label": "getInstruction()",
    "kind": "Method",
    "detail": "Function (} InstructionTy*)",
    "insertText": "getInstruction()"
  },
  {
    "label": "getCalledFunction()",
    "kind": "Method",
    "detail": "Function (} FunTy*)",
    "insertText": "getCalledFunction()"
  },
  {
    "label": "getCaller()",
    "kind": "Method",
    "detail": "Function (} FunTy*)",
    "insertText": "getCaller()"
  },
  {
    "label": "doesNotThrow()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "doesNotThrow()"
  },
  {
    "label": "getActualReturnType()",
    "kind": "Method",
    "detail": "Function (} Type*)",
    "insertText": "getActualReturnType()"
  },
  {
    "label": "FunctionType()",
    "kind": "Method",
    "detail": "Function (auto* FTy = cast<)",
    "insertText": "FunctionType(cast<PointerType>(getCalledValue()->getType())->getElementType())"
  },
  {
    "label": "getNumCallArgs()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "getNumCallArgs()"
  },
  {
    "label": "getCallSite()",
    "kind": "Method",
    "detail": "Function (const Value* NumCallArgsVal =)",
    "insertText": "getCallSite().getArgument(NumCallArgsPos)"
  },
  {
    "label": "arg_size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "arg_size()"
  },
  {
    "label": "arg_begin()",
    "kind": "Method",
    "detail": "Function (} CallSiteTy::arg_iterator)",
    "insertText": "arg_begin()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(CallArgsBeginPos <= (int)getCallSite().arg_size())"
  },
  {
    "label": "arg_end()",
    "kind": "Method",
    "detail": "Function (} CallSiteTy::arg_iterator)",
    "insertText": "arg_end()"
  },
  {
    "label": "arg_begin()",
    "kind": "Method",
    "detail": "Function (auto I =)",
    "insertText": "arg_begin() + arg_size()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((getCallSite().arg_end() - I) >= 0)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Index < arg_size() && \"out of bounds!\")"
  },
  {
    "label": "call_args()",
    "kind": "Method",
    "detail": "Function (} iterator_range<arg_iterator>)",
    "insertText": "call_args()"
  },
  {
    "label": "paramHasAttr()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "paramHasAttr(unsigned i, Attribute::AttrKind A)"
  },
  {
    "label": "getNumTotalGCTransitionArgs()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "getNumTotalGCTransitionArgs()"
  },
  {
    "label": "gc_transition_args_begin()",
    "kind": "Method",
    "detail": "Function (} CallSiteTy::arg_iterator)",
    "insertText": "gc_transition_args_begin()"
  },
  {
    "label": "gc_transition_args_begin()",
    "kind": "Method",
    "detail": "Function (auto I =)",
    "insertText": "gc_transition_args_begin() + getNumTotalGCTransitionArgs()"
  },
  {
    "label": "getNumTotalVMSArgs()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "getNumTotalVMSArgs()"
  },
  {
    "label": "gc_transition_args_end()",
    "kind": "Method",
    "detail": "Function (const Value* NumVMSArgs =*)",
    "insertText": "gc_transition_args_end()"
  },
  {
    "label": "vm_state_begin()",
    "kind": "Method",
    "detail": "Function (} CallSiteTy::arg_iterator)",
    "insertText": "vm_state_begin()"
  },
  {
    "label": "vm_state_begin()",
    "kind": "Method",
    "detail": "Function (auto I =)",
    "insertText": "vm_state_begin() + getNumTotalVMSArgs()"
  },
  {
    "label": "gc_args_begin()",
    "kind": "Method",
    "detail": "Function (} CallSiteTy::arg_iterator)",
    "insertText": "gc_args_begin()"
  },
  {
    "label": "gc_args_end()",
    "kind": "Method",
    "detail": "Function (} CallSiteTy::arg_iterator)",
    "insertText": "gc_args_end()"
  },
  {
    "label": "gc_args()",
    "kind": "Method",
    "detail": "Function (} iterator_range<arg_iterator>)",
    "insertText": "gc_args()"
  },
  {
    "label": "getRelocates()",
    "kind": "Method",
    "detail": "Function (} std::vector<GCRelocateOperands>)",
    "insertText": "getRelocates()"
  },
  {
    "label": "getGCResult()",
    "kind": "Method",
    "detail": "Function (InstructionTy*)",
    "insertText": "getGCResult()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getNumCallArgs() >= 0 && \"number of arguments to actually callee can't be negative\")"
  },
  {
    "label": "ImmutableStatepoint()",
    "kind": "Method",
    "detail": "Function (} # endif } ; class ImmutableStatepoint : public StatepointBase<const Function,const Instruction,const Value,ImmutableCallSite> { typedef StatepointBase<const Function,const Instruction,const Value,ImmutableCallSite> Base ; public :)",
    "insertText": "ImmutableStatepoint(const Instruction *I) : Base(I)"
  },
  {
    "label": "ImmutableStatepoint()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ImmutableStatepoint(ImmutableCallSite CS) : Base(CS)"
  },
  {
    "label": "Statepoint()",
    "kind": "Method",
    "detail": "Function (} } ; class Statepoint : public StatepointBase<Function,Instruction,Value,CallSite> { typedef StatepointBase<Function,Instruction,Value,CallSite> Base ; public :)",
    "insertText": "Statepoint(Instruction *I) : Base(I)"
  },
  {
    "label": "Statepoint()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Statepoint(CallSite CS) : Base(CS)"
  },
  {
    "label": "GCRelocateOperands()",
    "kind": "Method",
    "detail": "Function (} } ; class GCRelocateOperands { ImmutableCallSite RelocateCS ; public :)",
    "insertText": "GCRelocateOperands(const User *U) : RelocateCS(U)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isGCRelocate(U))"
  },
  {
    "label": "GCRelocateOperands()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "GCRelocateOperands(const Instruction *inst) : RelocateCS(inst)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isGCRelocate(inst))"
  },
  {
    "label": "GCRelocateOperands()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "GCRelocateOperands(CallSite CS) : RelocateCS(CS)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isGCRelocate(CS))"
  },
  {
    "label": "isTiedToInvoke()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isTiedToInvoke()"
  },
  {
    "label": "getArgument()",
    "kind": "Method",
    "detail": "Function (const Value* Token = RelocateCS .)",
    "insertText": "getArgument(0)"
  },
  {
    "label": "getUnderlyingCallSite()",
    "kind": "Method",
    "detail": "Function (} ImmutableCallSite)",
    "insertText": "getUnderlyingCallSite()"
  },
  {
    "label": "Instruction()",
    "kind": "Method",
    "detail": "Function (} const BasicBlock* InvokeBB = cast<)",
    "insertText": "Instruction(Token)->getParent()->getUniquePredecessor()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(InvokeBB && \"safepoints should have unique landingpads\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(InvokeBB->getTerminator() && \"safepoint block should be well formed\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isStatepoint(InvokeBB->getTerminator()))"
  },
  {
    "label": "getBasePtrIndex()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getBasePtrIndex()"
  },
  {
    "label": "getDerivedPtrIndex()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getDerivedPtrIndex()"
  },
  {
    "label": "getBasePtr()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "getBasePtr()"
  },
  {
    "label": "CS()",
    "kind": "Method",
    "detail": "Function (ImmutableCallSite)",
    "insertText": "CS(getStatepoint())"
  },
  {
    "label": "getDerivedPtr()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "getDerivedPtr()"
  },
  {
    "label": "InvokeInst()",
    "kind": "Method",
    "detail": "Function (LandingPadInst* LandingPad = cast<)",
    "insertText": "InvokeInst(getInstruction())->getLandingPadInst()"
  }
]