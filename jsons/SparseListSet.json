[
  {
    "label": "FArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FArchive"
  },
  {
    "label": "TSparseListSet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TSparseListSet"
  },
  {
    "label": "FListHandle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FListHandle"
  },
  {
    "label": "FChunk",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FChunk"
  },
  {
    "label": "FList",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FList"
  },
  {
    "label": "TSparseListSet()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" HAL / PlatformMath . h \" # include \" Templates / Function . h \" # include \" Templates / UnrealTemplate . h \" # include \" Util / DynamicVector . h \" class FArchive ; namespace UE { namespace Geometry { template<ElementType> struct TSparseListSet { public :)",
    "insertText": "TSparseListSet()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ChunkList .)",
    "insertText": "Add(MakeUnique<FChunk>())"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (ChunkList [ 0 ] ->)",
    "insertText": "Initialize(BlocksPerChunk * BlockSize)"
  },
  {
    "label": "TSparseListSet()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSparseListSet(int BlockSizeIn, int BlocksPerChunkIn)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BlockSize =)",
    "insertText": "Clamp(BlockSizeIn, 4, 65536)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (BlocksPerChunk =)",
    "insertText": "Clamp(BlocksPerChunkIn, 4, 65536)"
  },
  {
    "label": "IsAllocated()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsAllocated(int32 ListIndex)"
  },
  {
    "label": "AllocateAt()",
    "kind": "Method",
    "detail": "Function (} struct FListHandle { void* ListRef = nullptr ; } ; FListHandle)",
    "insertText": "AllocateAt(int32 ListIndex)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (FList NewList ; NewList . Blocks .)",
    "insertText": "Add(AllocateNewBlockMemory())"
  },
  {
    "label": "InsertAt()",
    "kind": "Method",
    "detail": "Function (NewList . CurBlock = NewList . Blocks [ 0 ] ; NewList . CurIndex = 0 ; Lists .)",
    "insertText": "InsertAt(NewList, ListIndex)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Insert(int32 ListIndex, ElementType Value)"
  },
  {
    "label": "Insert_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Insert_Internal(Lists[ListIndex], Value)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Insert(FListHandle ListHandle, ElementType Value)"
  },
  {
    "label": "List()",
    "kind": "Method",
    "detail": "Function (FList&)",
    "insertText": "List(FList*)"
  },
  {
    "label": "Insert_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Insert_Internal(List, Value)"
  },
  {
    "label": "SetValues()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetValues(int32 ListIndex, const TArray<ElementType>& Values)"
  },
  {
    "label": "SetValues_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValues_Internal(Lists[ListIndex], Values)"
  },
  {
    "label": "SetValues()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetValues(FListHandle ListHandle, const TArray<ElementType>& Values)"
  },
  {
    "label": "SetValues_Internal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValues_Internal(List, Values)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Remove(int32 ListIndex, ElementType Value)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear(int32 ListIndex)"
  },
  {
    "label": "Clear_Internal()",
    "kind": "Method",
    "detail": "Function (FList& List = Lists [ ListIndex ] ;)",
    "insertText": "Clear_Internal(List)"
  },
  {
    "label": "GetCount()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetCount(int32 ListIndex)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const FList& List = Lists [ ListIndex ] ; return)",
    "insertText": "Max(0, List.Blocks.Num()-1)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(int32 ListIndex, ElementType Value)"
  },
  {
    "label": "Enumerate()",
    "kind": "Method",
    "detail": "Function (template<FuncType> void)",
    "insertText": "Enumerate(int32 ListIndex, FuncType Func)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FList& List = Lists [ ListIndex ] ;)",
    "insertText": "if(List.CurBlock != nullptr)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32 N = List . Blocks .)",
    "insertText": "Num()"
  },
  {
    "label": "EndElement()",
    "kind": "Method",
    "detail": "Function (const ElementType* Elements = List . Blocks [ BlockIndex ] ; const ElementType*)",
    "insertText": "EndElement(BlockIndex == N-1) ? (Elements + List.CurIndex) : (Elements + BlockSize)"
  },
  {
    "label": "Func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Func(*Elements++)"
  },
  {
    "label": "EnumerateEarlyOut()",
    "kind": "Method",
    "detail": "Function (} } } } template<FuncType> bool)",
    "insertText": "EnumerateEarlyOut(int32 ListIndex, FuncType ApplyFunc)"
  },
  {
    "label": "EndElement()",
    "kind": "Method",
    "detail": "Function (const ElementType* Elements = List . Blocks [ BlockIndex ] ; const ElementType*)",
    "insertText": "EndElement(BlockIndex == N - 1) ? (Elements + List.CurIndex) : (Elements + BlockSize)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (ElementBuffer .)",
    "insertText": "SetNumUninitialized(Size)"
  },
  {
    "label": "GetBlockBufferPtr()",
    "kind": "Method",
    "detail": "Function (} ElementType*)",
    "insertText": "GetBlockBufferPtr(int32 Offset)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (List . CurBlock = List . Blocks .)",
    "insertText": "Last()"
  },
  {
    "label": "SetValues_Internal()",
    "kind": "Method",
    "detail": "Function (List . CurIndex = 0 ; } List . CurBlock [ List . CurIndex + + ] = Value ; } void)",
    "insertText": "SetValues_Internal(FList& List, const TArray<ElementType>& Values)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 k = 0; k < N; ++k)"
  },
  {
    "label": "Clear_Internal()",
    "kind": "Method",
    "detail": "Function (List . CurIndex = 0 ; } List . CurBlock [ List . CurIndex + + ] = Values [ k ] ; } } void)",
    "insertText": "Clear_Internal(FList& List)"
  },
  {
    "label": "FreeBlockMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeBlockMemory(List.Blocks[k])"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (} List . Blocks .)",
    "insertText": "SetNum(1)"
  },
  {
    "label": "AllocateNewBlockMemory()",
    "kind": "Method",
    "detail": "Function (List . CurBlock = List . Blocks [ 0 ] ; List . CurIndex = 0 ; } ElementType*)",
    "insertText": "AllocateNewBlockMemory()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "Lock(&AllocationLock)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (} FChunk* LastChunk = ChunkList .)",
    "insertText": "Last().Get()"
  },
  {
    "label": "GetBlockBufferPtr()",
    "kind": "Method",
    "detail": "Function (} ElementType* BlockBuffer = LastChunk ->)",
    "insertText": "GetBlockBufferPtr(LastChunk->BlocksAllocated * BlockSize)"
  },
  {
    "label": "FreeBlockMemory()",
    "kind": "Method",
    "detail": "Function (LastChunk -> BlocksAllocated + + ; return BlockBuffer ; } void)",
    "insertText": "FreeBlockMemory(ElementType* Block)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (FreeList .)",
    "insertText": "Add(Block)"
  },
  {
    "label": "Stop()",
    "kind": "Method",
    "detail": "Function (ElementType* Elements = List . Blocks [ BlockIndex ] ; int)",
    "insertText": "Stop(BlockIndex == N-1)"
  },
  {
    "label": "bIsLastBlock()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bIsLastBlock(Elements == List.CurBlock)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (List . CurIndex - - ; } else {)",
    "insertText": "Swap(Elements[k], Elements[List.CurIndex-1])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (List . CurIndex - - ; } } else {)",
    "insertText": "if(List.CurIndex == 0)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Swap(Elements[k], List.CurBlock[List.CurIndex-1])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (List . CurIndex - - ; })",
    "insertText": "if(List.CurIndex == 0 && List.Blocks.Num() > 1)"
  },
  {
    "label": "FreeBlockMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeBlockMemory(List.CurBlock)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (List . Blocks .)",
    "insertText": "Pop()"
  }
]