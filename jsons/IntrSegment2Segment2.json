[
  {
    "label": "TIntrSegment2Segment2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TIntrSegment2Segment2"
  },
  {
    "label": "TIntrSegment2Segment2()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" SegmentTypes . h \" # include \" Intersection / Intersector1 . h \" # include \" Intersection / IntersectionUtil . h \" # include \" Intersection / IntrLine2Line2 . h \" # include \" MathUtil . h \" # include \" VectorTypes . h \" # include \" VectorUtil . h \" namespace UE { namespace Geometry { using namespace UE::Math ; template<RealType> class TIntrSegment2Segment2 { protected : TSegment2<RealType> Segment1 ; TSegment2<RealType> Segment2 ; RealType IntervalThreshold = 0 ; RealType DotThreshold = TMathUtil<RealType>::ZeroTolerance ; public : int Quantity = 0 ; EIntersectionResult Result = EIntersectionResult::NotComputed ; EIntersectionType Type = EIntersectionType::Empty ; TVector2<RealType> Point0 ; TVector2<RealType> Point1 ; RealType Parameter0 ; RealType Parameter1 ;)",
    "insertText": "TIntrSegment2Segment2(const TSegment2<RealType>& Segment1In, const TSegment2<RealType>& Segment2In) : Segment1(Segment1In), Segment2(Segment2In)"
  },
  {
    "label": "GetSegment1()",
    "kind": "Method",
    "detail": "Function (} const TSegment2<RealType>&)",
    "insertText": "GetSegment1()"
  },
  {
    "label": "GetSegment2()",
    "kind": "Method",
    "detail": "Function (Segment1 = Value ; Result = EIntersectionResult::NotComputed ; } const TSegment2<RealType>&)",
    "insertText": "GetSegment2()"
  },
  {
    "label": "GetIntervalThreshold()",
    "kind": "Method",
    "detail": "Function (Segment2 = Value ; Result = EIntersectionResult::NotComputed ; } RealType)",
    "insertText": "GetIntervalThreshold()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (IntervalThreshold =)",
    "insertText": "Max(Value, (RealType)0)"
  },
  {
    "label": "GetDotThreshold()",
    "kind": "Method",
    "detail": "Function (Result = EIntersectionResult::NotComputed ; } RealType)",
    "insertText": "GetDotThreshold()"
  },
  {
    "label": "IsSimpleIntersection()",
    "kind": "Method",
    "detail": "Function (Result = EIntersectionResult::NotComputed ; } bool)",
    "insertText": "IsSimpleIntersection()"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Find()"
  },
  {
    "label": "IsPointCount()",
    "kind": "Method",
    "detail": "Function (} bool bIsPoint1 = Segment1 . Extent = = 0 ; bool bIsPoint2 = Segment2 . Extent = = 0 ; int)",
    "insertText": "IsPointCount(int)bIsPoint1 + (int)"
  },
  {
    "label": "this()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "this(TVector2<RealType> Point, RealType Param)"
  },
  {
    "label": "this()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "this()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Quantity = 0 ; Result = EIntersectionResult::NoIntersection ; Type = EIntersectionType::Empty ; } ;)",
    "insertText": "if(IsPointCount == 2)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (bool bIntersects = UE::)",
    "insertText": "DistanceSquared(Segment1.Center, Segment2.Center)"
  },
  {
    "label": "SetPointIntersection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPointIntersection((Segment1.Center + Segment2.Center) * .5, 0)"
  },
  {
    "label": "SetNoIntersection()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "SetNoIntersection()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return bIntersects ; } else)",
    "insertText": "if(IsPointCount == 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RealType DistSq ; RealType Param = 0 ; TVector2<RealType> Point ;)",
    "insertText": "if(bIsPoint1)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (DistSq = Segment2 .)",
    "insertText": "DistanceSquared(Segment1.Center)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (Point = Segment1 . Center ; } else { DistSq = Segment1 .)",
    "insertText": "DistanceSquared(Segment2.Center)"
  },
  {
    "label": "Project()",
    "kind": "Method",
    "detail": "Function (Param = Segment1 .)",
    "insertText": "Project(Segment2.Center)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Point = Segment2 . Center ; } bool bIntersects = DistSq<= IntervalThreshold* IntervalThreshold ;)",
    "insertText": "if(bIntersects)"
  },
  {
    "label": "SetPointIntersection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPointIntersection(Point, Param)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (} return bIntersects ; })",
    "insertText": "checkSlow(IsNormalized(Segment1.Direction) && IsNormalized(Segment2.Direction))"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (TVector2<RealType> s = TVector2<RealType)",
    "insertText": "Zero()"
  },
  {
    "label": "Classify()",
    "kind": "Method",
    "detail": "Function (Type = TIntrLine2Line2<RealType)",
    "insertText": "Classify(Segment1.Center, Segment1.Direction, Segment2.Center, Segment2.Direction, DotThreshold, IntervalThreshold, s)"
  },
  {
    "label": "SetPointIntersection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPointIntersection(Segment1.Center + s[0] * Segment1.Direction, s[0])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(Type == EIntersectionType::Line)"
  },
  {
    "label": "Dot()",
    "kind": "Method",
    "detail": "Function (TVector2<RealType> diff = Segment2 . Center - Segment1 . Center ; RealType t1 = Segment1 . Direction .)",
    "insertText": "Dot(diff)"
  },
  {
    "label": "calc()",
    "kind": "Method",
    "detail": "Function (RealType tmin = t1 - Segment2 . Extent ; RealType tmax = t1 + Segment2 . Extent ; TIntersector1<RealType>)",
    "insertText": "calc(-Segment1.Extent, Segment1.Extent, tmin, tmax)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Quantity = calc . NumIntersections ;)",
    "insertText": "if(Quantity == 2)"
  },
  {
    "label": "GetIntersection()",
    "kind": "Method",
    "detail": "Function (Type = EIntersectionType::Segment ; Parameter0 = calc .)",
    "insertText": "GetIntersection(0)"
  },
  {
    "label": "GetIntersection()",
    "kind": "Method",
    "detail": "Function (Point0 = Segment1 . Center + Parameter0* Segment1 . Direction ; Parameter1 = calc .)",
    "insertText": "GetIntersection(1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Point1 = Segment1 . Center + Parameter1* Segment1 . Direction ; } else)",
    "insertText": "if(Quantity == 1)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (Point0 = Segment1 . Center + Parameter0* Segment1 . Direction ; } else { Type = EIntersectionType::Empty ; } } else { Quantity = 0 ; })",
    "insertText": "Result(Type != EIntersectionType::Empty)"
  },
  {
    "label": "SanityCheck()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "SanityCheck()"
  }
]