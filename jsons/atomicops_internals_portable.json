[
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_ATOMICOPS_INTERNALS_PORTABLE_H_ # define BASE_ATOMICOPS_INTERNALS_PORTABLE_H_ # include<atomic> # include \" build / build_config . h \" namespace base { namespace subtle { typedef volatile std::atomic<Atomic32>* AtomicLocation32 ;)",
    "insertText": "static_assert(sizeof(*(AtomicLocation32) nullptr) == sizeof(Atomic32), \"incompatible 32-bit atomic layout\")"
  },
  {
    "label": "NoBarrier_CompareAndSwap()",
    "kind": "Method",
    "detail": "Function (Atomic32)",
    "insertText": "NoBarrier_CompareAndSwap(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)"
  },
  {
    "label": "NoBarrier_AtomicIncrement()",
    "kind": "Method",
    "detail": "Function (} Atomic32)",
    "insertText": "NoBarrier_AtomicIncrement(volatile Atomic32* ptr, Atomic32 increment)"
  },
  {
    "label": "Barrier_AtomicIncrement()",
    "kind": "Method",
    "detail": "Function (} Atomic32)",
    "insertText": "Barrier_AtomicIncrement(volatile Atomic32* ptr, Atomic32 increment)"
  },
  {
    "label": "Acquire_CompareAndSwap()",
    "kind": "Method",
    "detail": "Function (} Atomic32)",
    "insertText": "Acquire_CompareAndSwap(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)"
  },
  {
    "label": "Release_Store()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Release_Store(volatile Atomic32* ptr, Atomic32 value)"
  },
  {
    "label": "NoBarrier_Load()",
    "kind": "Method",
    "detail": "Function (} Atomic32)",
    "insertText": "NoBarrier_Load(volatile const Atomic32* ptr)"
  },
  {
    "label": "Acquire_Load()",
    "kind": "Method",
    "detail": "Function (} Atomic32)",
    "insertText": "Acquire_Load(volatile const Atomic32* ptr)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(ARCH_CPU_64_BITS)"
  },
  {
    "label": "NoBarrier_CompareAndSwap()",
    "kind": "Method",
    "detail": "Function (Atomic64)",
    "insertText": "NoBarrier_CompareAndSwap(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)"
  },
  {
    "label": "NoBarrier_AtomicIncrement()",
    "kind": "Method",
    "detail": "Function (} Atomic64)",
    "insertText": "NoBarrier_AtomicIncrement(volatile Atomic64* ptr, Atomic64 increment)"
  },
  {
    "label": "Barrier_AtomicIncrement()",
    "kind": "Method",
    "detail": "Function (} Atomic64)",
    "insertText": "Barrier_AtomicIncrement(volatile Atomic64* ptr, Atomic64 increment)"
  },
  {
    "label": "Acquire_CompareAndSwap()",
    "kind": "Method",
    "detail": "Function (} Atomic64)",
    "insertText": "Acquire_CompareAndSwap(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)"
  },
  {
    "label": "Release_Store()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Release_Store(volatile Atomic64* ptr, Atomic64 value)"
  },
  {
    "label": "NoBarrier_Load()",
    "kind": "Method",
    "detail": "Function (} Atomic64)",
    "insertText": "NoBarrier_Load(volatile const Atomic64* ptr)"
  },
  {
    "label": "Acquire_Load()",
    "kind": "Method",
    "detail": "Function (} Atomic64)",
    "insertText": "Acquire_Load(volatile const Atomic64* ptr)"
  }
]