[
  {
    "label": "FGrid",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGrid"
  },
  {
    "label": "FIntersectionSegmentTool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FIntersectionSegmentTool"
  },
  {
    "label": "FFaceMesh",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFaceMesh"
  },
  {
    "label": "FCell",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCell"
  },
  {
    "label": "FCellConnexion",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCellConnexion"
  },
  {
    "label": "CADKERNEL_API",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CADKERNEL_API"
  },
  {
    "label": "FIsoTriangulator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FIsoTriangulator"
  },
  {
    "label": "FCycleTriangulator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCycleTriangulator"
  },
  {
    "label": "FLoopCleaner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLoopCleaner"
  },
  {
    "label": "FParametricMesher",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FParametricMesher"
  },
  {
    "label": "FPairOfDouble",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPairOfDouble"
  },
  {
    "label": "PointType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PointType"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Core / Factory . h \" # include \" Math / Geometry . h \" # include \" Math / Point . h \" # include \" Math / SlopeUtils . h \" # include \" Mesh / Meshers / IsoTriangulator / IntersectionIsoSegmentTool . h \" # include \" Mesh / Meshers / IsoTriangulator / IntersectionSegmentTool . h \" # include \" Mesh / Meshers / IsoTriangulator / IsoNode . h \" # include \" Mesh / Meshers / IsoTriangulator / IsoSegment . h \" # include \" Mesh / Meshers / ParametricMesherConstantes . h \" # include \" UI / Visu . h \" # ifdef CADKERNEL_DEV # include \" UI / DefineForDebug . h \" # include \" Mesh / Meshers / MesherReport . h \" # endif namespace UE::CADKernel { class FGrid ; class FIntersectionSegmentTool ; class FFaceMesh ; struct FCell ; using FMeshPolygonFunc = TFunction<)",
    "insertText": "void(const FGrid&, FIsoNode*[], FFaceMesh&)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (struct FCellConnexion ; struct FIsoTriangulatorChronos { FDuration TriangulateDuration =)",
    "insertText": "Init()"
  },
  {
    "label": "FIsoTriangulatorChronos()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FIsoTriangulatorChronos()"
  },
  {
    "label": "PrintTimeElapse()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PrintTimeElapse()"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (IsoTriangulerDuration + = BuildIsoNodesDuration ; IsoTriangulerDuration + = BuildLoopSegmentsDuration ; IsoTriangulerDuration + = BuildInnerSegmentsDuration ; IsoTriangulerDuration + = FindLoopSegmentOfInnerTriangulationDuration ; IsoTriangulerDuration + = FindIsoSegmentToLinkInnerToLoopDuration ; IsoTriangulerDuration + = FindSegmentToLinkLoopToLoopDuration ; IsoTriangulerDuration + = FindSegmentToLinkInnerToLoopDuration ; IsoTriangulerDuration + = TriangulateOverCycleDuration ; IsoTriangulerDuration + = TriangulateInnerNodesDuration ;)",
    "insertText": "PrintClockElapse(Log, TEXT(\"\"), TEXT(\"IsoTrianguler\"), IsoTriangulerDuration)"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintClockElapse(Log, TEXT(\" \"), TEXT(\"Triangulate\"), TriangulateDuration)"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintClockElapse(Log, TEXT(\" \"), TEXT(\"BuildIsoNodes\"), BuildIsoNodesDuration)"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintClockElapse(Log, TEXT(\" \"), TEXT(\"BuildLoopSegments\"), BuildLoopSegmentsDuration)"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintClockElapse(Log, TEXT(\" \"), TEXT(\"BuildInnerSegments\"), BuildInnerSegmentsDuration)"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintClockElapse(Log, TEXT(\" \"), TEXT(\"FindLoopSegmentOfInnerTriangulation\"), FindLoopSegmentOfInnerTriangulationDuration)"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintClockElapse(Log, TEXT(\" \"), TEXT(\"FindSegmentIsoUVSurroundingSmallLoop\"), FindSegmentIsoUVSurroundingSmallLoopDuration)"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintClockElapse(Log, TEXT(\" \"), TEXT(\"Find IsoSegment ToLink InnerToLoop\"), FindIsoSegmentToLinkInnerToLoopDuration)"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintClockElapse(Log, TEXT(\" \"), TEXT(\"Find Segment ToLink LoopToLoop\"), FindSegmentToLinkLoopToLoopDuration)"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintClockElapse(Log, TEXT(\" \"), TEXT(\"Find Segment ToLink InnerToLoop\"), FindSegmentToLinkInnerToLoopDuration)"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintClockElapse(Log, TEXT(\" \"), TEXT(\"Mesh Over Cycle\"), TriangulateOverCycleDuration)"
  },
  {
    "label": "PrintClockElapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintClockElapse(Log, TEXT(\" \"), TEXT(\"Mesh Inner Nodes\"), TriangulateInnerNodesDuration)"
  },
  {
    "label": "FIsoTriangulator()",
    "kind": "Method",
    "detail": "Function (} } ; class FIsoTriangulator { class FCycleTriangulator ; class FLoopCleaner ; class FParametricMesher ; struct FCell ; protected : FGrid& Grid ; FFaceMesh& Mesh ; TArray<int32> LoopStartIndex ; TArray<FLoopNode> LoopNodes ; int32 LoopNodeCount = 0 ; TArray<FLoopNode*> SortedLoopNodes ; TArray<FIsoInnerNode*> GlobalIndexToIsoInnerNodes ; TArray<FIsoInnerNode> InnerNodes ; int32 InnerNodeCount = 0 ; TFactory<FIsoSegment> IsoSegmentFactory ; TArray<FIsoSegment*> LoopSegments ; TArray<FIsoSegment*> ThinZoneSegments ; TArray<FIsoSegment*> FinalInnerSegments ; TArray<FIsoSegment*> InnerToOuterSegments ; TArray<FIsoSegment*> InnerToLoopCandidateSegments ; FIntersectionSegmentTool LoopSegmentsIntersectionTool ; FIntersectionSegmentTool InnerSegmentsIntersectionTool ; FIntersectionIsoSegmentTool InnerToOuterIsoSegmentsIntersectionTool ; FIntersectionSegmentTool ThinZoneIntersectionTool ; TArray<int32> IndexOfLowerLeftInnerNodeSurroundingALoop ; TArray<FIsoSegment*> FinalToLoops ; TArray<FIsoSegment*> CandidateSegments ; bool bDisplay = false ; bool bNeedCheckOrientation = false ; public : const FMeshingTolerances& Tolerances ; public :)",
    "insertText": "FIsoTriangulator(FGrid& InGrid, FFaceMesh& OutMesh, const FMeshingTolerances& InTolerance)"
  },
  {
    "label": "Triangulate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Triangulate()"
  },
  {
    "label": "BuildNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildNodes()"
  },
  {
    "label": "BuildLoopSegments()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildLoopSegments()"
  },
  {
    "label": "BuildInnerSegments()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildInnerSegments()"
  },
  {
    "label": "GetThinZonesMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetThinZonesMesh()"
  },
  {
    "label": "GetThinZoneMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetThinZoneMesh(const TMap<int32, FLoopNode*>& IndexToNode, const FThinZone2D& ThinZone)"
  },
  {
    "label": "FillMeshNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FillMeshNodes()"
  },
  {
    "label": "BuildInnerSegmentsIntersectionTool()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildInnerSegmentsIntersectionTool()"
  },
  {
    "label": "FindInnerGridCellSurroundingSmallLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindInnerGridCellSurroundingSmallLoop()"
  },
  {
    "label": "ConnectCellLoops()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConnectCellLoops()"
  },
  {
    "label": "FindCellContainingBoundaryNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindCellContainingBoundaryNodes(TArray<FCell>& Cells)"
  },
  {
    "label": "FindCandidateToConnectCellCornerToLoops()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindCandidateToConnectCellCornerToLoops(FCell& Cell)"
  },
  {
    "label": "SelectSegmentsToLinkInnerToLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SelectSegmentsToLinkInnerToLoop()"
  },
  {
    "label": "InitCellCorners()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitCellCorners(FCell& Cell)"
  },
  {
    "label": "TriangulateOverCycle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TriangulateOverCycle(const EGridSpace Space)"
  },
  {
    "label": "FindCycle()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FindCycle(FIsoSegment* StartSegment, bool bLeftSide, TArray<FIsoSegment*>& Cycle, TArray<bool>& CycleOrientation)"
  },
  {
    "label": "MeshCycle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MeshCycle(const TArray<FIsoSegment*>& Cycle, const TArray<bool>& CycleOrientation)"
  },
  {
    "label": "MeshLargeCycle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MeshLargeCycle(const TArray<FIsoSegment*>& Cycle, const TArray<bool>& CycleOrientation)"
  },
  {
    "label": "MeshCycleOf()",
    "kind": "Method",
    "detail": "Function (template<uint32 Dim> void)",
    "insertText": "MeshCycleOf(const TArray<FIsoSegment*>& Cycle, const TArray<bool>& CycleOrientation, FMeshPolygonFunc MeshPolygonFunc)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FIsoNode* Nodes [ Dim ] ;)",
    "insertText": "for(int32 Index = 0; Index < Dim; ++Index)"
  },
  {
    "label": "GetFirstNode()",
    "kind": "Method",
    "detail": "Function (Nodes [ Index ] = CycleOrientation [ Index ] ?& Cycle [ Index ] ->)",
    "insertText": "GetFirstNode() : &Cycle[Index]->GetSecondNode()"
  },
  {
    "label": "MeshPolygonFunc()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MeshPolygonFunc(Grid, Nodes, Mesh)"
  },
  {
    "label": "CanCycleBeMeshed()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CanCycleBeMeshed(const TArray<FIsoSegment*>& Cycle, FIntersectionSegmentTool& CycleIntersectionTool)"
  },
  {
    "label": "TriangulateInnerNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TriangulateInnerNodes()"
  },
  {
    "label": "SortLoopNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SortLoopNodes()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (SortedLoopNodes .)",
    "insertText": "Reserve(LoopNodes.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (SortedLoopNodes .)",
    "insertText": "Add(&LoopNode)"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Sort(SortedLoopNodes, [this](const FLoopNode* Node1, const FLoopNode* Node2) { const FPoint2D& Node1Coordinates = Node1->Get2DPoint(EGridSpace::Default2D, Grid); const FPoint2D& Node2Coordinates = Node2->Get2DPoint(EGridSpace::Default2D, Grid); return (Node1Coordinates.U + Node1Coordinates.V) < (Node2Coordinates.U + Node2Coordinates.V); })"
  },
  {
    "label": "GetGrid()",
    "kind": "Method",
    "detail": "Function (} const FGrid&)",
    "insertText": "GetGrid()"
  },
  {
    "label": "TryToConnectTwoLoopsWithIsocelesTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TryToConnectTwoLoopsWithIsocelesTriangle(FCell& Cell, const TArray<FLoopNode*>& SubLoopA, const TArray<FLoopNode*>& SubLoopB)"
  },
  {
    "label": "TryToConnectTwoSubLoopsWithTheMostIsoSegment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TryToConnectTwoSubLoopsWithTheMostIsoSegment(FCell& Cell, const TArray<FLoopNode*>& SubLoopA, const TArray<FLoopNode*>& SubLoopB)"
  },
  {
    "label": "TryToConnectVertexSubLoopWithTheMostIsoSegment()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TryToConnectVertexSubLoopWithTheMostIsoSegment(FCell& Cell, const TArray<FLoopNode*>& SubLoop)"
  },
  {
    "label": "GetOrTryToCreateSegment()",
    "kind": "Method",
    "detail": "Function (FIsoSegment*)",
    "insertText": "GetOrTryToCreateSegment(FCell& Cell, FLoopNode* NodeA, const FPoint2D& ACoordinates, FIsoNode* NodeB, const FPoint2D& BCoordinates, const double FlatAngle)"
  },
  {
    "label": "DisplayPixels()",
    "kind": "Method",
    "detail": "Function (public : # ifdef CADKERNEL_DEV FIsoTriangulatorChronos Chronos ; # endif # ifdef CADKERNEL_DEBUG void)",
    "insertText": "DisplayPixels(TArray<uint8>& Pixel)"
  },
  {
    "label": "DisplayPixel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisplayPixel(const int32 Index)"
  },
  {
    "label": "DisplayPixel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisplayPixel(const int32 IndexU, const int32 IndexV)"
  },
  {
    "label": "DisplayIsoNodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisplayIsoNodes(EGridSpace Space)"
  },
  {
    "label": "DisplayLoops()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisplayLoops(const TCHAR* Message, bool bOneNode = true, bool bSplitBySegment = false)"
  },
  {
    "label": "DisplayLoopsByNextAndPrevious()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisplayLoopsByNextAndPrevious(const TCHAR* Message)"
  },
  {
    "label": "DisplayCells()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisplayCells(const TArray<FCell>& Cells)"
  },
  {
    "label": "DisplayCell()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisplayCell(const FCell& Cell)"
  },
  {
    "label": "DrawCellBoundary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DrawCellBoundary(int32 Index, EVisuProperty Property)"
  },
  {
    "label": "DisplayCellConnexion()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisplayCellConnexion(const FCellConnexion& LoopConnexion, EVisuProperty Property)"
  },
  {
    "label": "DisplayCellConnexions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisplayCellConnexions(const FString& Message, const TArray<FCellConnexion>& LoopConnexions, EVisuProperty Property)"
  },
  {
    "label": "CotangentCriteria()",
    "kind": "Method",
    "detail": "Function (# endif } ; namespace IsoTriangulatorImpl { double)",
    "insertText": "CotangentCriteria(const FPoint& APoint, const FPoint& BPoint, const FPoint& PPoint, FPoint& OutNormal)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (const double BigValue = HUGE_VALUE ; FPoint PA = APoint - PPoint ; FPoint PB = BPoint - PPoint ; double ScalareProduct = PA* PB ; OutNormal = PA ^ PB ; double NormOFScalarProduct =)",
    "insertText": "sqrt(OutNormal * OutNormal)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const double BigValue = HUGE_VALUE ; FPoint2D PA = APoint - PPoint ; FPoint2D PB = BPoint - PPoint ; double ScalareProduct = PA* PB ; double OutNormal = PA ^ PB ; double NormOFPointProduct =)",
    "insertText": "Abs(OutNormal)"
  },
  {
    "label": "ComputeSlope()",
    "kind": "Method",
    "detail": "Function (const double SlopeAB =)",
    "insertText": "ComputeSlope(APoint, BPoint)"
  },
  {
    "label": "ComputeSlope()",
    "kind": "Method",
    "detail": "Function (const double SlopeAC =)",
    "insertText": "ComputeSlope(APoint, CPoint)"
  },
  {
    "label": "ComputeSlope()",
    "kind": "Method",
    "detail": "Function (const double SlopeBC =)",
    "insertText": "ComputeSlope(BPoint, CPoint)"
  },
  {
    "label": "SwapSlopeOrientation()",
    "kind": "Method",
    "detail": "Function (const double SlopeBA =)",
    "insertText": "SwapSlopeOrientation(SlopeAB)"
  },
  {
    "label": "IsoscelesCriteriaMax()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "IsoscelesCriteriaMax(const FPoint2D& APoint, const FPoint2D& BPoint, const FPoint2D& CPoint)"
  },
  {
    "label": "IsoscelesCriteria()",
    "kind": "Method",
    "detail": "Function (const FPairOfDouble Criteria =)",
    "insertText": "IsoscelesCriteria(APoint, BPoint, CPoint)"
  },
  {
    "label": "IsoscelesCriteriaMin()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "IsoscelesCriteriaMin(const FPoint2D& APoint, const FPoint2D& BPoint, const FPoint2D& CPoint)"
  },
  {
    "label": "EquilateralSlopeCriteria()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "EquilateralSlopeCriteria(const FPoint2D& APoint, const FPoint2D& BPoint, const FPoint2D& CPoint)"
  },
  {
    "label": "SwapSlopeOrientation()",
    "kind": "Method",
    "detail": "Function (const double SlopeCA =)",
    "insertText": "SwapSlopeOrientation(SlopeAC)"
  },
  {
    "label": "SwapSlopeOrientation()",
    "kind": "Method",
    "detail": "Function (const double SlopeCB =)",
    "insertText": "SwapSlopeOrientation(SlopeBC)"
  },
  {
    "label": "TransformIntoOrientedSlope()",
    "kind": "Method",
    "detail": "Function (const double A =)",
    "insertText": "TransformIntoOrientedSlope(SlopeAC - SlopeAB)"
  },
  {
    "label": "TransformIntoOrientedSlope()",
    "kind": "Method",
    "detail": "Function (const double B =)",
    "insertText": "TransformIntoOrientedSlope(SlopeBA - SlopeBC)"
  },
  {
    "label": "TransformIntoOrientedSlope()",
    "kind": "Method",
    "detail": "Function (const double C =)",
    "insertText": "TransformIntoOrientedSlope(SlopeCB - SlopeCA)"
  },
  {
    "label": "EquilateralCriteria()",
    "kind": "Method",
    "detail": "Function (} template<class PointType> double)",
    "insertText": "EquilateralCriteria(const PointType& SegmentA, const PointType& SegmentB, const PointType& Point)"
  }
]