[
  {
    "label": "SimpleAtoi()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_STRINGS_NUMBERS_H_ # define ABSL_STRINGS_NUMBERS_H_ # ifdef __SSSE3__ # include<tmmintrin . h> # endif # ifdef _MSC_VER # include<intrin . h> # endif # include<cstddef> # include<cstdlib> # include<cstring> # include<ctime> # include<limits> # include<string> # include<type_traits> # include \" absl / base / config . h \" # include \" absl / base / internal / endian . h \" # include \" absl / base / macros . h \" # include \" absl / base / port . h \" # include \" absl / numeric / bits . h \" # include \" absl / numeric / int128 . h \" # include \" absl / strings / string_view . h \" namespace absl { ABSL_NAMESPACE_BEGIN template<int_type> ABSL_MUST_USE_RESULT bool)",
    "insertText": "SimpleAtoi(absl::string_view str, int_type* out)"
  },
  {
    "label": "SimpleAtof()",
    "kind": "Method",
    "detail": "Function (ABSL_MUST_USE_RESULT bool)",
    "insertText": "SimpleAtof(absl::string_view str, float* out)"
  },
  {
    "label": "SimpleAtod()",
    "kind": "Method",
    "detail": "Function (ABSL_MUST_USE_RESULT bool)",
    "insertText": "SimpleAtod(absl::string_view str, double* out)"
  },
  {
    "label": "SimpleAtob()",
    "kind": "Method",
    "detail": "Function (ABSL_MUST_USE_RESULT bool)",
    "insertText": "SimpleAtob(absl::string_view str, bool* out)"
  },
  {
    "label": "SimpleHexAtoi()",
    "kind": "Method",
    "detail": "Function (template<int_type> ABSL_MUST_USE_RESULT bool)",
    "insertText": "SimpleHexAtoi(absl::string_view str, int_type* out)"
  },
  {
    "label": "SimpleHexAtoi()",
    "kind": "Method",
    "detail": "Function (ABSL_MUST_USE_RESULT bool)",
    "insertText": "SimpleHexAtoi(absl::string_view str, absl::int128* out)"
  },
  {
    "label": "SimpleHexAtoi()",
    "kind": "Method",
    "detail": "Function (ABSL_MUST_USE_RESULT bool)",
    "insertText": "SimpleHexAtoi(absl::string_view str, absl::uint128* out)"
  },
  {
    "label": "PutTwoDigits()",
    "kind": "Method",
    "detail": "Function (ABSL_NAMESPACE_END } namespace absl { ABSL_NAMESPACE_BEGIN namespace numbers_internal { ABSL_DLL const char kHexChar [ 1 7 ] ; ABSL_DLL const char kHexTable [ 5 1 3 ] ; ABSL_DLL const char two_ASCII_digits [ 1 0 0 ] [ 2 ] ; void)",
    "insertText": "PutTwoDigits(size_t i, char* buf)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < 100)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(buf, two_ASCII_digits[i], 2)"
  },
  {
    "label": "safe_strto32_base()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "safe_strto32_base(absl::string_view text, int32_t* value, int base)"
  },
  {
    "label": "safe_strto64_base()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "safe_strto64_base(absl::string_view text, int64_t* value, int base)"
  },
  {
    "label": "safe_strto128_base()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "safe_strto128_base(absl::string_view text, absl::int128* value, int base)"
  },
  {
    "label": "safe_strtou32_base()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "safe_strtou32_base(absl::string_view text, uint32_t* value, int base)"
  },
  {
    "label": "safe_strtou64_base()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "safe_strtou64_base(absl::string_view text, uint64_t* value, int base)"
  },
  {
    "label": "safe_strtou128_base()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "safe_strtou128_base(absl::string_view text, absl::uint128* value, int base)"
  },
  {
    "label": "SixDigitsToBuffer()",
    "kind": "Method",
    "detail": "Function (const int kFastToBufferSize = 3 2 ; const int kSixDigitsToBufferSize = 1 6 ; size_t)",
    "insertText": "SixDigitsToBuffer(double d, char* buffer)"
  },
  {
    "label": "FastIntToBuffer()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "FastIntToBuffer(int32_t, char*)"
  },
  {
    "label": "FastIntToBuffer()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "FastIntToBuffer(uint32_t, char*)"
  },
  {
    "label": "FastIntToBuffer()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "FastIntToBuffer(int64_t, char*)"
  },
  {
    "label": "FastIntToBuffer()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "FastIntToBuffer(uint64_t, char*)"
  },
  {
    "label": "FastIntToBuffer()",
    "kind": "Method",
    "detail": "Function (template<int_type> char*)",
    "insertText": "FastIntToBuffer(int_type i, char* buffer)"
  },
  {
    "label": "int_type()",
    "kind": "Method",
    "detail": "Function (bool kIsSigned = static_cast<)",
    "insertText": "int_type(1)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (bool kUse64Bit =)",
    "insertText": "sizeof(i)"
  },
  {
    "label": "FastIntToBuffer()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "FastIntToBuffer(static_cast<int32_t>(i), buffer)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(kUse64Bit)"
  },
  {
    "label": "FastIntToBuffer()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "FastIntToBuffer(static_cast<uint32_t>(i), buffer)"
  },
  {
    "label": "safe_strtoi_base()",
    "kind": "Method",
    "detail": "Function (} } } template<int_type> ABSL_MUST_USE_RESULT bool)",
    "insertText": "safe_strtoi_base(absl::string_view s, int_type* out, int base)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (bool kUse64Bit =)",
    "insertText": "sizeof(*out)"
  },
  {
    "label": "safe_strto64_base()",
    "kind": "Method",
    "detail": "Function (int64_t val ; parsed =)",
    "insertText": "safe_strto64_base(s, &val, base)"
  },
  {
    "label": "int_type()",
    "kind": "Method",
    "detail": "Function (* out = static_cast<)",
    "insertText": "int_type(val)"
  },
  {
    "label": "safe_strto32_base()",
    "kind": "Method",
    "detail": "Function (} else { int32_t val ; parsed =)",
    "insertText": "safe_strto32_base(s, &val, base)"
  },
  {
    "label": "safe_strtou64_base()",
    "kind": "Method",
    "detail": "Function (uint64_t val ; parsed =)",
    "insertText": "safe_strtou64_base(s, &val, base)"
  },
  {
    "label": "safe_strtou32_base()",
    "kind": "Method",
    "detail": "Function (} else { uint32_t val ; parsed =)",
    "insertText": "safe_strtou32_base(s, &val, base)"
  },
  {
    "label": "FastHexToBufferZeroPad16()",
    "kind": "Method",
    "detail": "Function (} } return parsed ; } size_t)",
    "insertText": "FastHexToBufferZeroPad16(uint64_t val, char* out)"
  },
  {
    "label": "FromHost64()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_INTERNAL_HAVE_SSSE3 uint64_t be = absl::)",
    "insertText": "FromHost64(val)"
  },
  {
    "label": "_mm_set1_epi8()",
    "kind": "Method",
    "detail": "Function (const auto kNibbleMask =)",
    "insertText": "_mm_set1_epi8(0xf)"
  },
  {
    "label": "_mm_setr_epi8()",
    "kind": "Method",
    "detail": "Function (const auto kHexDigits =)",
    "insertText": "_mm_setr_epi8('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f')"
  },
  {
    "label": "_mm_loadl_epi64()",
    "kind": "Method",
    "detail": "Function (auto v =)",
    "insertText": "_mm_loadl_epi64(reinterpret_cast<__m128i*>(&be))"
  },
  {
    "label": "_mm_srli_epi64()",
    "kind": "Method",
    "detail": "Function (auto v4 =)",
    "insertText": "_mm_srli_epi64(v, 4)"
  },
  {
    "label": "_mm_unpacklo_epi8()",
    "kind": "Method",
    "detail": "Function (auto il =)",
    "insertText": "_mm_unpacklo_epi8(v4, v)"
  },
  {
    "label": "_mm_and_si128()",
    "kind": "Method",
    "detail": "Function (auto m =)",
    "insertText": "_mm_and_si128(il, kNibbleMask)"
  },
  {
    "label": "_mm_shuffle_epi8()",
    "kind": "Method",
    "detail": "Function (auto hexchars =)",
    "insertText": "_mm_shuffle_epi8(kHexDigits, m)"
  },
  {
    "label": "_mm_storeu_si128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_storeu_si128(reinterpret_cast<__m128i*>(out), hexchars)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "for(int i = 0; i < 8; ++i)"
  },
  {
    "label": "byte()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "byte(val >> (56 - 8 * i))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (auto* hex =& absl::numbers_internal::kHexTable [ byte* 2 ] ;)",
    "insertText": "memcpy(out + 2 * i, hex, 2)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (} # endif return 1 6 - static_cast<)",
    "insertText": "size_t(countl_zero(val | 0x1) / 4)"
  },
  {
    "label": "SimpleAtoi()",
    "kind": "Method",
    "detail": "Function (} ABSL_MUST_USE_RESULT bool)",
    "insertText": "SimpleAtoi(absl::string_view str, absl::int128* out)"
  },
  {
    "label": "SimpleAtoi()",
    "kind": "Method",
    "detail": "Function (} ABSL_MUST_USE_RESULT bool)",
    "insertText": "SimpleAtoi(absl::string_view str, absl::uint128* out)"
  }
]