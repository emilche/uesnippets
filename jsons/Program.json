[
  {
    "label": "StringRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StringRef"
  },
  {
    "label": "encapsulates",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "encapsulates"
  },
  {
    "label": "ProcessInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ProcessInfo"
  },
  {
    "label": "WindowsEncodingMethod",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "WindowsEncodingMethod"
  },
  {
    "label": "with",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "with"
  },
  {
    "label": "ChangeStdinToBinary()",
    "kind": "Method",
    "detail": "Function (std::error_code)",
    "insertText": "ChangeStdinToBinary()"
  },
  {
    "label": "ChangeStdoutToBinary()",
    "kind": "Method",
    "detail": "Function (std::error_code)",
    "insertText": "ChangeStdoutToBinary()"
  },
  {
    "label": "ExecuteNoWait()",
    "kind": "Method",
    "detail": "Function (ProcessInfo)",
    "insertText": "ExecuteNoWait(StringRef Program, const char **args, const char **env = nullptr,\n                const StringRef **redirects = nullptr, unsigned memoryLimit = 0,\n                std::string *ErrMsg = nullptr, bool *ExecutionFailed = nullptr)"
  },
  {
    "label": "argumentsFitWithinSystemLimits()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "argumentsFitWithinSystemLimits(ArrayRef<const char*> Args)"
  },
  {
    "label": "writeFileWithEncoding()",
    "kind": "Method",
    "detail": "Function (std::error_code)",
    "insertText": "writeFileWithEncoding(StringRef FileName, StringRef Contents,\n                        WindowsEncodingMethod Encoding = WEM_UTF8)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (ProcessInfo)",
    "insertText": "Wait(\n      const ProcessInfo &PI, ///< The child process that should be waited on.\n      unsigned SecondsToWait, ///< If non-zero, this specifies the amount of\n      ///< time to wait for the child process to exit. If the time expires, the\n      ///< child is killed and this function returns. If zero, this function\n      ///< will perform a non-blocking wait on the child process.\n      bool WaitUntilTerminates, ///< If true, ignores \\p SecondsToWait and waits\n      ///< until child has terminated.\n      std::string *ErrMsg = nullptr ///< If non-zero, provides a pointer to a\n      ///< string instance in which error messages will be returned. If the\n      ///< string is non-empty upon return an error occurred while invoking the\n      ///< program.\n      )"
  }
]