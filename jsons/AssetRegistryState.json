[
  {
    "label": "FArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FArchive"
  },
  {
    "label": "FAssetDataTagMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAssetDataTagMap"
  },
  {
    "label": "FAssetDataTagMapSharedView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAssetDataTagMapSharedView"
  },
  {
    "label": "FAssetRegistryGenerator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAssetRegistryGenerator"
  },
  {
    "label": "FDependsNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDependsNode"
  },
  {
    "label": "FString",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FString"
  },
  {
    "label": "FAssetRegistryImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAssetRegistryImpl"
  },
  {
    "label": "FARCompiledFilter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FARCompiledFilter"
  },
  {
    "label": "FAssetRegistryHeader",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAssetRegistryHeader"
  },
  {
    "label": "FPrimaryAssetId",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPrimaryAssetId"
  },
  {
    "label": "TFunctionRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TFunctionRef"
  },
  {
    "label": "FAssetRegistrySerializationOptions",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAssetRegistrySerializationOptions"
  },
  {
    "label": "FAssetRegistryLoadOptions",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAssetRegistryLoadOptions"
  },
  {
    "label": "FAssetRegistryPruneOptions",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAssetRegistryPruneOptions"
  },
  {
    "label": "FAssetRegistryAppendResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAssetRegistryAppendResult"
  },
  {
    "label": "FAssetRegistryState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAssetRegistryState"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "Archive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Archive"
  },
  {
    "label": "UAssetRegistryImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAssetRegistryImpl"
  },
  {
    "label": "UE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UE"
  },
  {
    "label": "FAssetRegistrySerializationOptions()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" AssetRegistry / AssetData . h \" # include \" AssetRegistry / AssetDataMap . h \" # include \" AssetRegistry / IAssetRegistry . h \" # include \" Containers / Array . h \" # include \" Containers / ArrayView . h \" # include \" Containers / ContainerAllocationPolicies . h \" # include \" Containers / Map . h \" # include \" Containers / Set . h \" # include \" Containers / StringFwd . h \" # include \" CoreTypes . h \" # include \" HAL / PlatformCrt . h \" # include \" Misc / AssetRegistryInterface . h \" # include \" Templates / UnrealTemplate . h \" # include \" UObject / NameTypes . h \" # include \" UObject / SoftObjectPath . h \" # include \" UObject / TopLevelAssetPath . h \" # if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_2 # include \" CoreMinimal . h \" # endif # ifndef UE_ASSETREGISTRY_CACHEDASSETSBYTAG # define UE_ASSETREGISTRY_CACHEDASSETSBYTAG WITH_EDITORONLY_DATA # endif class FArchive ; class FAssetDataTagMap ; class FAssetDataTagMapSharedView ; class FAssetRegistryGenerator ; class FDependsNode ; class FString ; namespace UE::AssetRegistry { class FAssetRegistryImpl ; } struct FARCompiledFilter ; struct FAssetRegistryHeader ; struct FPrimaryAssetId ; template<FuncType> class TFunctionRef ; struct FAssetRegistrySerializationOptions {)",
    "insertText": "FAssetRegistrySerializationOptions(UE::AssetRegistry::ESerializationTarget Target = UE::AssetRegistry::ESerializationTarget::ForGame)"
  },
  {
    "label": "DisableFilters()",
    "kind": "Method",
    "detail": "Function (bool bSerializeAssetRegistry = false ; bool bSerializeDependencies = false ; bool bSerializeSearchableNameDependencies = false ; bool bSerializeManageDependencies = false ; bool bSerializePackageData = false ; bool bUseAssetRegistryTagsAllowListInsteadOfDenyList = false ; bool bFilterAssetDataWithNoTags = false ; bool bFilterDependenciesWithNoTags = false ; bool bFilterSearchableNames = false ; bool bKeepDevelopmentAssetRegistryTags = false ; TMap<FTopLevelAssetPath,TSet<FName>> CookFilterlistTagsByClass ; TSet<FName> CookTagsAsName ; TSet<FName> CookTagsAsPath ; void)",
    "insertText": "DisableFilters()"
  },
  {
    "label": "InitForDevelopment()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "InitForDevelopment()"
  },
  {
    "label": "FAssetRegistryLoadOptions()",
    "kind": "Method",
    "detail": "Function (} ; struct FAssetRegistryLoadOptions {)",
    "insertText": "FAssetRegistryLoadOptions()"
  },
  {
    "label": "FAssetRegistryLoadOptions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAssetRegistryLoadOptions(const FAssetRegistrySerializationOptions& Options)"
  },
  {
    "label": "FAssetRegistryState()",
    "kind": "Method",
    "detail": "Function (bool bLoadDependencies = true ; bool bLoadPackageData = true ; int32 ParallelWorkers = 0 ; } ; struct FAssetRegistryPruneOptions { TSet<FName> RequiredPackages ; TSet<FName> RemovePackages ; TSet<int32> ChunksToKeep ; FAssetRegistrySerializationOptions Options ; bool bRemoveDependenciesWithoutPackages = false ; TSet<FPrimaryAssetType> RemoveDependenciesWithoutPackagesKeepPrimaryAssetTypes ; } ; struct FAssetRegistryAppendResult { TArray<const FAssetData*> AddedAssets ; TArray<const FAssetData*> UpdatedAssets ; } ; class FAssetRegistryState { private : using FCachedAssetKey = UE::AssetRegistry::Private::FCachedAssetKey ; # if UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS using FAssetDataMap = UE::AssetRegistry::Private::FAssetDataMap ; using FAssetDataPtrIndex = UE::AssetRegistry::Private::FAssetDataPtrIndex ; using FAssetDataArrayIndex = UE::AssetRegistry::Private::FAssetDataArrayIndex ; using FAssetDataOrArrayIndex = UE::AssetRegistry::Private::FAssetDataOrArrayIndex ; # endif public : # if ! UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS using FAssetDataMap = UE::AssetRegistry::Private::FAssetDataMap ; using FConstAssetDataMap = UE::AssetRegistry::Private::FConstAssetDataMap ; # endif)",
    "insertText": "FAssetRegistryState()"
  },
  {
    "label": "FAssetRegistryState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAssetRegistryState(const FAssetRegistryState&)"
  },
  {
    "label": "FAssetRegistryState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAssetRegistryState(FAssetRegistryState&& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FAssetRegistryState&)",
    "insertText": "operator(const FAssetRegistryState&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FAssetRegistryState&)",
    "insertText": "operator(FAssetRegistryState&& O)"
  },
  {
    "label": "HasAssets()",
    "kind": "Method",
    "detail": "Function (enum class EInitializationMode { Rebuild,OnlyUpdateExisting,Append,OnlyUpdateNew,} ; bool)",
    "insertText": "HasAssets(const FName PackagePath, bool bARFiltering=false)"
  },
  {
    "label": "GetAssets()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetAssets(const FARCompiledFilter& Filter, const TSet<FName>& PackageNamesToSkip, TArray<FAssetData>& OutAssetData, bool bSkipARFilteredAssets = false)"
  },
  {
    "label": "EnumerateAssets()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EnumerateAssets(const FARCompiledFilter& Filter, const TSet<FName>& PackageNamesToSkip, TFunctionRef<bool(const FAssetData&)> Callback)"
  },
  {
    "label": "EnumerateAssets()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EnumerateAssets(const FARCompiledFilter& Filter, const TSet<FName>& PackageNamesToSkip, TFunctionRef<bool(const FAssetData&)> Callback, UE::AssetRegistry::EEnumerateAssetsFlags InEnumerateFlags)"
  },
  {
    "label": "GetAllAssets()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetAllAssets(const TSet<FName>& PackageNamesToSkip, TArray<FAssetData>& OutAssetData, bool bARFiltering = false)"
  },
  {
    "label": "EnumerateAllAssets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateAllAssets(TFunctionRef<void(const FAssetData&)> Callback)"
  },
  {
    "label": "EnumerateAllAssets()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EnumerateAllAssets(const TSet<FName>& PackageNamesToSkip, TFunctionRef<bool(const FAssetData&)> Callback)"
  },
  {
    "label": "EnumerateAllAssets()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EnumerateAllAssets(const TSet<FName>& PackageNamesToSkip, TFunctionRef<bool(const FAssetData&)> Callback, UE::AssetRegistry::EEnumerateAssetsFlags InEnumerateFlags)"
  },
  {
    "label": "EnumerateAllPaths()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateAllPaths(TFunctionRef<void(FName PathName)> Callback)"
  },
  {
    "label": "GetPackagesByName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPackagesByName(FStringView PackageName, TArray<FName>& OutPackageNames)"
  },
  {
    "label": "GetFirstPackageByName()",
    "kind": "Method",
    "detail": "Function (FName)",
    "insertText": "GetFirstPackageByName(FStringView PackageName)"
  },
  {
    "label": "GetDependencies()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetDependencies(const FAssetIdentifier& AssetIdentifier, TArray<FAssetIdentifier>& OutDependencies, UE::AssetRegistry::EDependencyCategory Category = UE::AssetRegistry::EDependencyCategory::All, const UE::AssetRegistry::FDependencyQuery& Flags = UE::AssetRegistry::FDependencyQuery())"
  },
  {
    "label": "GetDependencies()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetDependencies(const FAssetIdentifier& AssetIdentifier, TArray<FAssetDependency>& OutDependencies, UE::AssetRegistry::EDependencyCategory Category = UE::AssetRegistry::EDependencyCategory::All, const UE::AssetRegistry::FDependencyQuery& Flags = UE::AssetRegistry::FDependencyQuery())"
  },
  {
    "label": "GetReferencers()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetReferencers(const FAssetIdentifier& AssetIdentifier, TArray<FAssetIdentifier>& OutReferencers, UE::AssetRegistry::EDependencyCategory Category = UE::AssetRegistry::EDependencyCategory::All, const UE::AssetRegistry::FDependencyQuery& Flags = UE::AssetRegistry::FDependencyQuery())"
  },
  {
    "label": "GetReferencers()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetReferencers(const FAssetIdentifier& AssetIdentifier, TArray<FAssetDependency>& OutReferencers, UE::AssetRegistry::EDependencyCategory Category = UE::AssetRegistry::EDependencyCategory::All, const UE::AssetRegistry::FDependencyQuery& Flags = UE::AssetRegistry::FDependencyQuery())"
  },
  {
    "label": "GetAssetByObjectPath()",
    "kind": "Method",
    "detail": "Function (const FAssetData*)",
    "insertText": "GetAssetByObjectPath(const FSoftObjectPath& ObjectPath)"
  },
  {
    "label": "GetAssetByObjectPath()",
    "kind": "Method",
    "detail": "Function (const FAssetData*)",
    "insertText": "GetAssetByObjectPath(const UE::AssetRegistry::Private::FCachedAssetKey& Key)"
  },
  {
    "label": "EnumerateAssetsByPackageName()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "EnumerateAssetsByPackageName(const FName PackageName, TFunctionRef<bool(const FAssetData* AssetData)> Callback)"
  },
  {
    "label": "CopyAssetsByPackageName()",
    "kind": "Method",
    "detail": "Function (TArray<const FAssetData*>)",
    "insertText": "CopyAssetsByPackageName(const FName PackageName)"
  },
  {
    "label": "NumAssetsByPackageName()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "NumAssetsByPackageName(const FName PackageName)"
  },
  {
    "label": "EnumerateAssetsByPackagePath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateAssetsByPackagePath(FName LongPackagePathName, TFunctionRef<bool(const FAssetData* AssetData)> Callback)"
  },
  {
    "label": "EnumerateAssetsByClassPathName()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "EnumerateAssetsByClassPathName(const FTopLevelAssetPath ClassPathName, TFunctionRef<bool(const FAssetData* AssetData)> Callback)"
  },
  {
    "label": "EnumerateTags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateTags(TFunctionRef<bool(FName TagName)> Callback)"
  },
  {
    "label": "ContainsTag()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ContainsTag(FName TagName)"
  },
  {
    "label": "EnumerateAssetsByTagName()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "EnumerateAssetsByTagName(const FName TagName, TFunctionRef<bool(const FAssetData* AssetData)> Callback)"
  },
  {
    "label": "EnumerateTagToAssetDatas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateTagToAssetDatas(TFunctionRef<bool(FName TagName, IAssetRegistry::FEnumerateAssetDatasFunc EnumerateAssets)> Callback)"
  },
  {
    "label": "GetAssetPackageDataMap()",
    "kind": "Method",
    "detail": "Function (# endif const TMap<FName,const FAssetPackageData*>&)",
    "insertText": "GetAssetPackageDataMap()"
  },
  {
    "label": "GetPrimaryAssetsIds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPrimaryAssetsIds(TSet<FPrimaryAssetId>& OutPrimaryAssets)"
  },
  {
    "label": "GetAssetPackageData()",
    "kind": "Method",
    "detail": "Function (const FAssetPackageData*)",
    "insertText": "GetAssetPackageData(FName PackageName)"
  },
  {
    "label": "GetAssetPackageData()",
    "kind": "Method",
    "detail": "Function (const FAssetPackageData*)",
    "insertText": "GetAssetPackageData(FName PackageName, FName& OutCorrectCasePackageName)"
  },
  {
    "label": "GetPackageNames()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetPackageNames(TArray<FName>& OutPackageNames)"
  },
  {
    "label": "CreateOrGetAssetPackageData()",
    "kind": "Method",
    "detail": "Function (FAssetPackageData*)",
    "insertText": "CreateOrGetAssetPackageData(FName PackageName)"
  },
  {
    "label": "RemovePackageData()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemovePackageData(FName PackageName)"
  },
  {
    "label": "AddAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAssetData(FAssetData* AssetData)"
  },
  {
    "label": "AddTagsToAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTagsToAssetData(const FSoftObjectPath& InObjectPath, FAssetDataTagMap&& InTagsAndValues)"
  },
  {
    "label": "UpdateAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateAssetData(const FAssetData& NewAssetData, bool bCreateIfNotExists=false)"
  },
  {
    "label": "UpdateAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateAssetData(FAssetData&& NewAssetData, bool bCreateIfNotExists = false)"
  },
  {
    "label": "UpdateAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateAssetData(FAssetData* AssetData, const FAssetData& NewAssetData, bool* bOutModified = nullptr)"
  },
  {
    "label": "UpdateAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateAssetData(FAssetData* AssetData, FAssetData&& NewAssetData, bool* bOutModified = nullptr)"
  },
  {
    "label": "UpdateAssetDataPackageFlags()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UpdateAssetDataPackageFlags(FName PackageName, uint32 PackageFlags)"
  },
  {
    "label": "RemoveAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAssetData(FAssetData* AssetData, bool bRemoveDependencyData, bool& bOutRemovedAssetData, bool& bOutRemovedPackageData)"
  },
  {
    "label": "RemoveAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAssetData(const FSoftObjectPath& SoftObjectPath, bool bRemoveDependencyData, bool& bOutRemovedAssetData, bool& bOutRemovedPackageData)"
  },
  {
    "label": "ClearDependencies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearDependencies(const FAssetIdentifier& AssetIdentifier, UE::AssetRegistry::EDependencyCategory Category)"
  },
  {
    "label": "AddDependencies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddDependencies(const FAssetIdentifier& AssetIdentifier, TConstArrayView<FAssetDependency> Dependencies)"
  },
  {
    "label": "SetDependencies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDependencies(const FAssetIdentifier& AssetIdentifier, TConstArrayView<FAssetDependency> Dependencies, UE::AssetRegistry::EDependencyCategory Category = UE::AssetRegistry::EDependencyCategory::All)"
  },
  {
    "label": "ClearReferencers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearReferencers(const FAssetIdentifier& AssetIdentifier, UE::AssetRegistry::EDependencyCategory Category)"
  },
  {
    "label": "AddReferencers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddReferencers(const FAssetIdentifier& AssetIdentifier, TConstArrayView<FAssetDependency> Referencers)"
  },
  {
    "label": "SetReferencers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetReferencers(const FAssetIdentifier& AssetIdentifier, TConstArrayView<FAssetDependency> Referencers, UE::AssetRegistry::EDependencyCategory Category = UE::AssetRegistry::EDependencyCategory::All)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "InitializeFromExisting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeFromExisting(const FAssetRegistryState& Existing, const FAssetRegistrySerializationOptions& Options, EInitializationMode InitializationMode = EInitializationMode::Rebuild, FAssetRegistryAppendResult* OutAppendResult = nullptr)"
  },
  {
    "label": "PruneAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PruneAssetData(const TSet<FName>& RequiredPackages, const TSet<FName>& RemovePackages, const TSet<int32> ChunksToKeep, const FAssetRegistrySerializationOptions& Options)"
  },
  {
    "label": "PruneAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PruneAssetData(const TSet<FName>& RequiredPackages, const TSet<FName>& RemovePackages, const FAssetRegistrySerializationOptions& Options)"
  },
  {
    "label": "Prune()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Prune(const FAssetRegistryPruneOptions& PruneOptions)"
  },
  {
    "label": "InitializeFromExistingAndPrune()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeFromExistingAndPrune(const FAssetRegistryState& ExistingState, const TSet<FName>& RequiredPackages, const TSet<FName>& RemovePackages, const TSet<int32> ChunksToKeep, const FAssetRegistrySerializationOptions& Options)"
  },
  {
    "label": "FilterTags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FilterTags(const FAssetRegistrySerializationOptions& Options)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Serialize(FArchive& Ar, const FAssetRegistrySerializationOptions& Options)"
  },
  {
    "label": "Save()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Save(FArchive& Ar, const FAssetRegistrySerializationOptions& Options)"
  },
  {
    "label": "Load()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Load(FArchive& Ar, const FAssetRegistryLoadOptions& Options = FAssetRegistryLoadOptions(), FAssetRegistryVersion::Type* OutVersion = nullptr)"
  },
  {
    "label": "LoadFromDisk()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "LoadFromDisk(const TCHAR* InPath, const FAssetRegistryLoadOptions& InOptions, FAssetRegistryState& OutState, FAssetRegistryVersion::Type* OutVersion = nullptr)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetAllocatedSize(bool bLogDetailed = false)"
  },
  {
    "label": "IsFilterValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFilterValid(const FARCompiledFilter& Filter)"
  },
  {
    "label": "GetNumAssets()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumAssets()"
  },
  {
    "label": "GetNumPackages()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumPackages()"
  },
  {
    "label": "Dump()",
    "kind": "Method",
    "detail": "Function (# if ASSET_REGISTRY_STATE_DUMPING_ENABLED void)",
    "insertText": "Dump(const TArray<FString>& Arguments, TArray<FString>& OutPages, int32 LinesPerPage=1)"
  },
  {
    "label": "EnumerateAllMutableAssets()",
    "kind": "Method",
    "detail": "Function (# endif private : void)",
    "insertText": "EnumerateAllMutableAssets(TFunctionRef<void(FAssetData&)> Callback)"
  },
  {
    "label": "GetMutableAssetByObjectPath()",
    "kind": "Method",
    "detail": "Function (FAssetData*)",
    "insertText": "GetMutableAssetByObjectPath(const FSoftObjectPath& ObjectPath)"
  },
  {
    "label": "GetMutableAssetByObjectPath()",
    "kind": "Method",
    "detail": "Function (FAssetData*)",
    "insertText": "GetMutableAssetByObjectPath(const UE::AssetRegistry::Private::FCachedAssetKey& Key)"
  },
  {
    "label": "EnumerateMutableAssetsByPackageName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateMutableAssetsByPackageName(const FName PackageName, TFunctionRef<bool(FAssetData* AssetData)> Callback)"
  },
  {
    "label": "EnumerateMutableAssetsByPackagePath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateMutableAssetsByPackagePath(FName LongPackagePathName, TFunctionRef<bool(FAssetData* AssetData)> Callback)"
  },
  {
    "label": "InitializeFromExisting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeFromExisting(const FAssetDataMap& AssetDataMap, const TMap<FAssetIdentifier, FDependsNode*>& DependsNodeMap, const TMap<FName, FAssetPackageData*>& AssetPackageDataMap, const FAssetRegistrySerializationOptions& Options, EInitializationMode InitializationMode = EInitializationMode::Rebuild, FAssetRegistryAppendResult* OutAppendResult = nullptr)"
  },
  {
    "label": "Load()",
    "kind": "Method",
    "detail": "Function (template<class Archive> void)",
    "insertText": "Load(Archive&& Ar, const FAssetRegistryHeader& Header, const FAssetRegistryLoadOptions& Options)"
  },
  {
    "label": "SetAssetDatas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAssetDatas(TArrayView<FAssetData> AssetDatas, const FAssetRegistryLoadOptions& Options)"
  },
  {
    "label": "ResolveRedirector()",
    "kind": "Method",
    "detail": "Function (FDependsNode*)",
    "insertText": "ResolveRedirector(FDependsNode* InDependency, const FAssetDataMap& InAllowedAssets, TMap<FDependsNode*, FDependsNode*>& InCache)"
  },
  {
    "label": "FindDependsNode()",
    "kind": "Method",
    "detail": "Function (FDependsNode*)",
    "insertText": "FindDependsNode(const FAssetIdentifier& Identifier)"
  },
  {
    "label": "CreateOrFindDependsNode()",
    "kind": "Method",
    "detail": "Function (FDependsNode*)",
    "insertText": "CreateOrFindDependsNode(const FAssetIdentifier& Identifier)"
  },
  {
    "label": "RemoveDependsNode()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RemoveDependsNode(const FAssetIdentifier& Identifier)"
  },
  {
    "label": "FilterTags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FilterTags(const FAssetDataTagMapSharedView& InTagsAndValues, FAssetDataTagMap& OutTagsAndValues, const TSet<FName>* ClassSpecificFilterList, const FAssetRegistrySerializationOptions & Options)"
  },
  {
    "label": "LoadDependencies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LoadDependencies(FArchive& Ar)"
  },
  {
    "label": "LoadDependencies_BeforeFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LoadDependencies_BeforeFlags(FArchive& Ar, bool bSerializeDependencies, FAssetRegistryVersion::Type Version)"
  },
  {
    "label": "SetTagsOnExistingAsset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTagsOnExistingAsset(FAssetData* AssetData, FAssetDataTagMap&& NewTags)"
  },
  {
    "label": "SetDependencyNodeSorting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDependencyNodeSorting(bool bSortDependencies, bool bSortReferencers)"
  },
  {
    "label": "RemoveAssetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAssetData(FAssetData* AssetData, const FCachedAssetKey& Key, bool bRemoveDependencyData, #if UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS UE::AssetRegistry::Private::FAssetDataPtrIndex AssetIndex, #endif bool& bOutRemovedAssetData, bool& bOutRemovedPackageData)"
  },
  {
    "label": "IsPackageUnmountedAndFiltered()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPackageUnmountedAndFiltered(const FName PackageName)"
  },
  {
    "label": "FAssetRegistrySerializationOptions()",
    "kind": "Method",
    "detail": "Function (FAssetDataMap CachedAssets ; # if UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS UE::AssetRegistry::Private::FIndirectAssetDataArrays IndirectAssetDataArrays ; # endif # if ! UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS TMap<FName,TArray<FAssetData*,TInlineAllocator<1>>> CachedAssetsByPackageName ; TMap<FName,TArray<FAssetData*>> CachedAssetsByPath ; TMap<FTopLevelAssetPath,TArray<FAssetData*>> CachedAssetsByClass ; # else UE::AssetRegistry::Private::FAssetPackageNameMap CachedAssetsByPackageName ; TMap<FName,TArray<FAssetDataPtrIndex>> CachedAssetsByPath ; TMap<FTopLevelAssetPath,TArray<FAssetDataPtrIndex>> CachedAssetsByClass ; # endif # if UE_ASSETREGISTRY_CACHEDASSETSBYTAG # if ! UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS TMap<FName,TSet<FAssetData*>> CachedAssetsByTag ; # else TMap<FName,TSet<FAssetDataPtrIndex>> CachedAssetsByTag ; # endif # else TMap<FName,TSet<FTopLevelAssetPath>> CachedClassesByTag ; # endif TMap<FAssetIdentifier,FDependsNode*> CachedDependsNodes ; TMap<FName,FAssetPackageData*> CachedPackageData ; TArray<FAssetData*> PreallocatedAssetDataBuffers ; TArray<FDependsNode*> PreallocatedDependsNodeDataBuffers ; TArray<FAssetPackageData*> PreallocatedPackageDataBuffers ; int32 NumAssets = 0 ; int32 NumDependsNodes = 0 ; int32 NumPackageData = 0 ; bool bCookedGlobalAssetRegistryState = false ; class FAssetRegistryGenerator ; class UAssetRegistryImpl ; class UE::AssetRegistry::FAssetRegistryImpl ; } ;)",
    "insertText": "FAssetRegistrySerializationOptions(UE::AssetRegistry::ESerializationTarget Target)"
  },
  {
    "label": "FAssetRegistryLoadOptions()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAssetRegistryLoadOptions(const FAssetRegistrySerializationOptions& Options) : bLoadDependencies(Options.bSerializeDependencies) , bLoadPackageData(Options.bSerializePackageData)"
  },
  {
    "label": "FAssetRegistryState()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAssetRegistryState() #if UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS : CachedAssetsByPackageName(CachedAssets, IndirectAssetDataArrays)"
  },
  {
    "label": "FAssetRegistryState()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAssetRegistryState(FAssetRegistryState&& Rhs) #if UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS : CachedAssetsByPackageName(CachedAssets, IndirectAssetDataArrays)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "MoveTemp(Rhs)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (FAssetData* const* FoundAsset = CachedAssets .)",
    "insertText": "Find(Key)"
  },
  {
    "label": "const()",
    "kind": "Method",
    "detail": "Function (} return TArrayView<FAssetData*)",
    "insertText": "const()"
  },
  {
    "label": "EnumerateMutableAssetsByPackageName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateMutableAssetsByPackageName(PackageName, [&Callback](FAssetData* AssetData) { return Callback(AssetData); })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using namespace UE::AssetRegistry::Private ; # if ! UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS)",
    "insertText": "if(const TArray<FAssetData*, TInlineAllocator<1>>* FoundAssetArray = CachedAssetsByPackageName.Find(PackageName))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } } } # else)",
    "insertText": "if(TOptional<TConstArrayView<FAssetDataPtrIndex>> AssetArray = CachedAssetsByPackageName.Find(PackageName))"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TArray<const FAssetData*> Result ; Result .)",
    "insertText": "Reserve(NumAssetsByPackageName(PackageName))"
  },
  {
    "label": "EnumerateAssetsByPackageName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateAssetsByPackageName(PackageName, [&Result](const FAssetData* AssetData) { Result.Add(AssetData); return true; })"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (# if ! UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS const auto* Array = CachedAssetsByPackageName .)",
    "insertText": "Find(PackageName)"
  },
  {
    "label": "EnumerateMutableAssetsByPackagePath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateMutableAssetsByPackagePath(LongPackagePathName, [&Callback](FAssetData* AssetData) { return Callback(AssetData); })"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (using namespace UE::AssetRegistry::Private ; # if ! UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS const TArray<FAssetData*>* AssetsInPath = CachedAssetsByPath .)",
    "insertText": "Find(LongPackagePathName)"
  },
  {
    "label": "GetAssetsByClassPathName()",
    "kind": "Method",
    "detail": "Function (break ; } } } # endif } # if ! UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS const TArray<const FAssetData*>&)",
    "insertText": "GetAssetsByClassPathName(const FTopLevelAssetPath ClassPathName)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (TArray<const FAssetData*> InvalidArray ; const TArray<FAssetData*>* FoundAssetArray = CachedAssetsByClass .)",
    "insertText": "Find(ClassPathName)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using namespace UE::AssetRegistry::Private ; # if ! UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS)",
    "insertText": "if(const TArray<FAssetData*>* FoundAssetArray = CachedAssetsByClass.Find(ClassPathName))"
  },
  {
    "label": "Callback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Callback(AssetData)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } # else)",
    "insertText": "if(const TArray<FAssetDataPtrIndex>* FoundAssetArray = CachedAssetsByClass.Find(ClassPathName))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# if UE_ASSETREGISTRY_CACHEDASSETSBYTAG)",
    "insertText": "for(const auto& Pair : CachedAssetsByTag) #else for (const TPair<FName, TSet<FTopLevelAssetPath>>& Pair : CachedClassesByTag)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (# if UE_ASSETREGISTRY_CACHEDASSETSBYTAG return CachedAssetsByTag .)",
    "insertText": "Contains(TagName)"
  },
  {
    "label": "GetAssetsByTagName()",
    "kind": "Method",
    "detail": "Function (# endif } # if ! UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS const TArray<const FAssetData*>&)",
    "insertText": "GetAssetsByTagName(const FName TagName)"
  },
  {
    "label": "GetAssetDataMap()",
    "kind": "Method",
    "detail": "Function (TArray<const FAssetData*> InvalidArray ; return InvalidArray ; } # endif # if ! UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS const FAssetRegistryState::FConstAssetDataMap&)",
    "insertText": "GetAssetDataMap()"
  },
  {
    "label": "GetTagToAssetDatasMap()",
    "kind": "Method",
    "detail": "Function (} # endif # if ! UE_ASSETREGISTRY_INDIRECT_ASSETDATA_POINTERS const TMap<FName,const TArray<const FAssetData*>>)",
    "insertText": "GetTagToAssetDatasMap()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OutPackageNames .)",
    "insertText": "Reserve(CachedAssetsByPackageName.Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutPackageNames .)",
    "insertText": "Add(It.Key)"
  },
  {
    "label": "InitializeFromExisting()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitializeFromExisting(const FAssetRegistryState& Existing, const FAssetRegistrySerializationOptions& Options, EInitializationMode InitializationMode, FAssetRegistryAppendResult* OutAppendResult)"
  },
  {
    "label": "InitializeFromExisting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeFromExisting(Existing.CachedAssets, Existing.CachedDependsNodes, Existing.CachedPackageData, Options, InitializationMode, OutAppendResult)"
  }
]