[
  {
    "label": "optional_ref",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "optional_ref"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TYPES_OPTIONAL_REF_H_ # define BASE_TYPES_OPTIONAL_REF_H_ # include<memory> # include<type_traits> # include \" base / check . h \" # include \" third_party / abseil - cpp / absl / base / attributes . h \" # include \" third_party / abseil - cpp / absl / types / optional . h \" namespace base { template<T> class optional_ref { private :)",
    "insertText": "static_assert(!std::is_reference_v<T>, \"T must not be a reference type (use a pointer?)\")"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (template<U> bool IsCompatibleV = std::is_same_v<std::decay_t<T>,std::decay_t<U>>&& std::is_convertible_v<U*,T*> ; public :)",
    "insertText": "optional_ref()"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "optional_ref(absl::nullopt_t)"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (} template<U,= std::enable_if_t<std::is_const_v<T>&& IsCompatibleV<U>>>)",
    "insertText": "optional_ref(const absl::optional<U>& o ABSL_ATTRIBUTE_LIFETIME_BOUND) : ptr_(o ? &*o : nullptr)"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (} template<U,= std::enable_if_t<IsCompatibleV<U>>>)",
    "insertText": "optional_ref(absl::optional<U>& o ABSL_ATTRIBUTE_LIFETIME_BOUND) : ptr_(o ? &*o : nullptr)"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (} template<U,= std::enable_if_t<IsCompatibleV<U>>>)",
    "insertText": "optional_ref(U* p ABSL_ATTRIBUTE_LIFETIME_BOUND) : ptr_(p)"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (} template<U,= std::enable_if_t<IsCompatibleV<const U>>>)",
    "insertText": "optional_ref(const U& r ABSL_ATTRIBUTE_LIFETIME_BOUND) : ptr_(std::addressof(r))"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (} template<U,= std::enable_if_t<IsCompatibleV<U>>>)",
    "insertText": "optional_ref(U& r ABSL_ATTRIBUTE_LIFETIME_BOUND) : ptr_(std::addressof(r))"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "optional_ref(std::nullptr_t)"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (template<U = T,= std::enable_if_t<std::is_const_v<U>>>)",
    "insertText": "optional_ref(optional_ref<std::remove_const_t<U>> rhs) : ptr_(rhs.as_ptr())"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "optional_ref(const optional_ref&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (optional_ref&)",
    "insertText": "operator(const optional_ref&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "operator()"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (optional_ref<const T>)",
    "insertText": "optional_ref(const T&)"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (optional_ref<T>)",
    "insertText": "optional_ref(T&)"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (optional_ref<const T>)",
    "insertText": "optional_ref(const absl::optional<T>&)"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (optional_ref<T>)",
    "insertText": "optional_ref(absl::optional<T>&)"
  },
  {
    "label": "optional_ref()",
    "kind": "Method",
    "detail": "Function (optional_ref<T>)",
    "insertText": "optional_ref(T*)"
  }
]