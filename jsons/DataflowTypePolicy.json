[
  {
    "label": "UObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UObject"
  },
  {
    "label": "TDataflowPolicyTypeName",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TDataflowPolicyTypeName"
  },
  {
    "label": "IDataflowTypePolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IDataflowTypePolicy"
  },
  {
    "label": "FDataflowAllTypesPolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDataflowAllTypesPolicy"
  },
  {
    "label": "TDataflowSingleTypePolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TDataflowSingleTypePolicy"
  },
  {
    "label": "TDataflowMultiTypePolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TDataflowMultiTypePolicy"
  },
  {
    "label": "FDataflowNumericTypePolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDataflowNumericTypePolicy"
  },
  {
    "label": "FDataflowVectorTypePolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDataflowVectorTypePolicy"
  },
  {
    "label": "FDataflowStringTypePolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDataflowStringTypePolicy"
  },
  {
    "label": "FDataflowStringConvertibleTypePolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDataflowStringConvertibleTypePolicy"
  },
  {
    "label": "FDataflowUObjectConvertibleTypePolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDataflowUObjectConvertibleTypePolicy"
  },
  {
    "label": "FDataflowConverter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDataflowConverter"
  },
  {
    "label": "UE_DATAFLOW_POLICY_DECLARE_TYPENAME()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Misc / TVariant . h \" # include \" UObject / Object . h \" # include \" Math / MathFwd . h \" # include<string> class UObject ; template<TType> struct TDataflowPolicyTypeName { } ; # define)",
    "insertText": "UE_DATAFLOW_POLICY_DECLARE_TYPENAME(TType)"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (\\ const TCHAR*)",
    "insertText": "GetName()"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "TEXT(#TType)"
  },
  {
    "label": "UE_DATAFLOW_POLICY_DECLARE_TYPENAME()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } ;)",
    "insertText": "UE_DATAFLOW_POLICY_DECLARE_TYPENAME(bool) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(uint8) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(uint16) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(uint32) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(uint64) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(int8) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(int16) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(int32) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(int64) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(float) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(double) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(FName) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(FString) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(TObjectPtr<UObject>) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(FVector2D) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(FVector) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(FVector4) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(FVector2f) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(FVector3f) UE_DATAFLOW_POLICY_DECLARE_TYPENAME(FVector4f)"
  },
  {
    "label": "SupportsType()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SupportsType(FName Type)"
  },
  {
    "label": "SupportsType()",
    "kind": "Method",
    "detail": "Function (} ; struct FDataflowAllTypesPolicy : public IDataflowTypePolicy { bool)",
    "insertText": "SupportsType(FName InType)"
  },
  {
    "label": "SupportsTypeStatic()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "SupportsTypeStatic(FName InType)"
  },
  {
    "label": "VisitPolicyByType()",
    "kind": "Method",
    "detail": "Function (} template<TVisitor> bool)",
    "insertText": "VisitPolicyByType(FName RequestedType, TVisitor Visitor)"
  },
  {
    "label": "Visitor()",
    "kind": "Method",
    "detail": "Function (TDataflowSingleTypePolicy<T> SingleTypePolicy ;)",
    "insertText": "Visitor(SingleTypePolicy)"
  },
  {
    "label": "FName()",
    "kind": "Method",
    "detail": "Function (TDataflowSingleTypePolicy Instance ; return& Instance ; } const FName =)",
    "insertText": "FName(TDataflowPolicyTypeName<T>::GetName())"
  },
  {
    "label": "GetInterface()",
    "kind": "Method",
    "detail": "Function (} IDataflowTypePolicy*)",
    "insertText": "GetInterface()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FString InnerTypeStr ;)",
    "insertText": "if(GetObjectPtrInnerType(InType.ToString(), InnerTypeStr))"
  },
  {
    "label": "GetObjectPtrInnerType()",
    "kind": "Method",
    "detail": "Function (FDataflowUObjectConvertibleTypePolicy Instance ; return& Instance ; } bool)",
    "insertText": "GetObjectPtrInnerType(const FString& InTypeStr, FString& InnerType)"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (const TCHAR* ObjectPtrPrefix =)",
    "insertText": "TEXT(\"TObjectPtr<U\")"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (size_t ObjectPtrPrefixLen = std::char_traits<TCHAR)",
    "insertText": "length(ObjectPtrPrefix)"
  },
  {
    "label": "RightChop()",
    "kind": "Method",
    "detail": "Function (InnerType = InTypeStr .)",
    "insertText": "RightChop(ObjectPtrPrefixLen) .LeftChop(1) .TrimStartAndEnd()"
  },
  {
    "label": "To()",
    "kind": "Method",
    "detail": "Function (To = From ; } template<TToType> void)",
    "insertText": "To(const T& From, TToType& To)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (To = From ; } } ; template<T> concept HasToStringMethod =)",
    "insertText": "requires(T t)"
  },
  {
    "label": "FString()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "FString(t.ToString())"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} ; template<T> concept HasInitFromStringMethod =)",
    "insertText": "requires(T t, const FString& s)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "bool(t.InitFromString(s))"
  },
  {
    "label": "From()",
    "kind": "Method",
    "detail": "Function (} ; template<> struct FDataflowConverter<FString> { template<TFromType> void)",
    "insertText": "From(const TFromType& From, FString& To)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (To = From .)",
    "insertText": "ToString()"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(std::is_same_v<TFromType, bool>)"
  },
  {
    "label": "FString()",
    "kind": "Method",
    "detail": "Function (To =)",
    "insertText": "FString((From == true) ? \"True\" : \"False\")"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(std::is_convertible_v<TFromType, double>)"
  },
  {
    "label": "SanitizeFloat()",
    "kind": "Method",
    "detail": "Function (To =)",
    "insertText": "SanitizeFloat(double(From), 0)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(HasToStringMethod<TFromType>)"
  },
  {
    "label": "To()",
    "kind": "Method",
    "detail": "Function (} else { To = From ; } } template<TToType> void)",
    "insertText": "To(const FString& From, TToType& To)"
  },
  {
    "label": "FName()",
    "kind": "Method",
    "detail": "Function (To =)",
    "insertText": "FName(From)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(std::is_same_v<TToType, bool>)"
  },
  {
    "label": "ToBool()",
    "kind": "Method",
    "detail": "Function (To = From .)",
    "insertText": "ToBool()"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(std::is_convertible_v<double, TToType>)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (To = Result ; } else if)",
    "insertText": "constexpr(HasInitFromStringMethod<TToType>)"
  },
  {
    "label": "InitFromString()",
    "kind": "Method",
    "detail": "Function (To .)",
    "insertText": "InitFromString(From)"
  },
  {
    "label": "From()",
    "kind": "Method",
    "detail": "Function (} else { To = From ; } } } ; template<> struct FDataflowConverter<FVector4> { template<TFromType> void)",
    "insertText": "From(const TFromType& From, FVector4& To)"
  },
  {
    "label": "FVector4()",
    "kind": "Method",
    "detail": "Function (To =)",
    "insertText": "FVector4(double)From.X, (double)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(std::is_same_v<TFromType, FVector> || std::is_same_v<TFromType, FVector3f>)"
  },
  {
    "label": "FVector4()",
    "kind": "Method",
    "detail": "Function (To =)",
    "insertText": "FVector4(double)From.X, (double)From.Y, (double)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(std::is_same_v<TFromType, FVector4f>)"
  },
  {
    "label": "FVector4()",
    "kind": "Method",
    "detail": "Function (To =)",
    "insertText": "FVector4(double)From.X, (double)From.Y, (double)From.Z, (double)"
  },
  {
    "label": "To()",
    "kind": "Method",
    "detail": "Function (} else { To = From ; } } template<TToType> void)",
    "insertText": "To(const FVector4& From, TToType& To)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (To = FVector2D { From . X,From . Y } ; } else if)",
    "insertText": "constexpr(std::is_same_v<TToType, FVector2f>)"
  },
  {
    "label": "FVector2f()",
    "kind": "Method",
    "detail": "Function (To =)",
    "insertText": "FVector2f(float)From.X, (float)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(std::is_same_v<TToType, FVector>)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (To = FVector { From . X,From . Y,From . Z } ; } else if)",
    "insertText": "constexpr(std::is_same_v<TToType, FVector3f>)"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (To =)",
    "insertText": "FVector3f(float)From.X, (float)From.Y, (float)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(std::is_same_v<TToType, FVector4f>)"
  },
  {
    "label": "FVector4f()",
    "kind": "Method",
    "detail": "Function (To =)",
    "insertText": "FVector4f(float)From.X, (float)From.Y, (float)From.Z, (float)"
  }
]