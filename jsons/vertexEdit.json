[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "HbrVertexEdit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrVertexEdit"
  },
  {
    "label": "bbox",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "bbox"
  },
  {
    "label": "xyz",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "xyz"
  },
  {
    "label": "HbrMovingVertexEdit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrMovingVertexEdit"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENSUBDIV3_HBRVERTEXEDIT_H # define OPENSUBDIV3_HBRVERTEXEDIT_H # include<algorithm> # include \" . . / hbr / hierarchicalEdit . h \" # include \" . . / version . h \" namespace OpenSubdiv { namespace OPENSUBDIV_VERSION { template<class T> class HbrVertexEdit ; template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& out, const HbrVertexEdit<T>& path)"
  },
  {
    "label": "path()",
    "kind": "Method",
    "detail": "Function (out<<\" vertex)",
    "insertText": "path(\" << path.faceid << ' '; for (int i = 0; i < path.nsubfaces; ++i) { out << static_cast<int>(path.subfaces[i]) << ' '; } return out << static_cast<int>(path.vertexid) << \"), edit = (\" << path.edit[0] << ',' << path.edit[1] << ',' << path.edit[2] << ')"
  },
  {
    "label": "HbrVertexEdit()",
    "kind": "Method",
    "detail": "Function (} template<class T> class HbrVertexEdit : public HbrHierarchicalEdit<T> { public :)",
    "insertText": "HbrVertexEdit(int _faceid, int _nsubfaces, unsigned char *_subfaces, unsigned char _vertexid, int _index, int _width, bool _isP, typename HbrHierarchicalEdit<T>::Operation _op, float *_edit) : HbrHierarchicalEdit<T>(_faceid, _nsubfaces, _subfaces), vertexid(_vertexid), index(_index), width(_width), isP(_isP), op(_op)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (edit = new float [ width ] ;)",
    "insertText": "memcpy(edit, _edit, width * sizeof(float))"
  },
  {
    "label": "HbrVertexEdit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "HbrVertexEdit(int _faceid, int _nsubfaces, int *_subfaces, int _vertexid, int _index, int _width, bool _isP, typename HbrHierarchicalEdit<T>::Operation _op, float *_edit) : HbrHierarchicalEdit<T>(_faceid, _nsubfaces, _subfaces), vertexid(static_cast<unsigned char>(_vertexid)), index(_index), width(_width), isP(_isP), op(_op)"
  },
  {
    "label": "HbrVertexEdit()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "HbrVertexEdit()"
  },
  {
    "label": "GetVertexID()",
    "kind": "Method",
    "detail": "Function (delete [ ] edit ; } unsigned char)",
    "insertText": "GetVertexID()"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetIndex()"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (face ->)",
    "insertText": "GetVertex(vertexid)->SetVertexEdit()"
  },
  {
    "label": "MarkVertexEdits()",
    "kind": "Method",
    "detail": "Function (} face ->)",
    "insertText": "MarkVertexEdits()"
  },
  {
    "label": "ApplyEditToVertex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ApplyEditToVertex(HbrFace<T>* face, HbrVertex<T>* vertex)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (vertex ->)",
    "insertText": "GetData().ApplyVertexEdit(*const_cast<const HbrVertexEdit<T>*>(this))"
  },
  {
    "label": "ApplyToBound()",
    "kind": "Method",
    "detail": "Function (} } # ifdef PRMAN void)",
    "insertText": "ApplyToBound(struct bbox& bbox, RtMatrix *mx)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (struct xyz)",
    "insertText": "p(struct xyz*)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (bbox . min . x =)",
    "insertText": "min(bbox.min.x, p.x)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (bbox . min . y =)",
    "insertText": "min(bbox.min.y, p.y)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (bbox . min . z =)",
    "insertText": "min(bbox.min.z, p.z)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (bbox . max . x =)",
    "insertText": "max(bbox.max.x, p.x)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (bbox . max . y =)",
    "insertText": "max(bbox.max.y, p.y)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (bbox . max . z =)",
    "insertText": "max(bbox.max.z, p.z)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(op == HbrHierarchicalEdit<T>::Add || op == HbrHierarchicalEdit<T>::Subtract)"
  },
  {
    "label": "fabsf()",
    "kind": "Method",
    "detail": "Function (bbox . min . x - =)",
    "insertText": "fabsf(p.x)"
  },
  {
    "label": "fabsf()",
    "kind": "Method",
    "detail": "Function (bbox . min . y - =)",
    "insertText": "fabsf(p.y)"
  },
  {
    "label": "fabsf()",
    "kind": "Method",
    "detail": "Function (bbox . min . z - =)",
    "insertText": "fabsf(p.z)"
  },
  {
    "label": "HbrMovingVertexEdit()",
    "kind": "Method",
    "detail": "Function (} } } # endif private : const unsigned char vertexid ; int index ; int width ; unsigned isP : 1 ; HbrHierarchicalEdit<T>::Operation op ; float* edit ; } ; template<class T> class HbrMovingVertexEdit : public HbrHierarchicalEdit<T> { public :)",
    "insertText": "HbrMovingVertexEdit(int _faceid, int _nsubfaces, unsigned char *_subfaces, unsigned char _vertexid, int _index, int _width, bool _isP, typename HbrHierarchicalEdit<T>::Operation _op, float *_edit) : HbrHierarchicalEdit<T>(_faceid, _nsubfaces, _subfaces), vertexid(_vertexid), index(_index), width(_width), isP(_isP), op(_op)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (edit = new float [ width* 2 ] ;)",
    "insertText": "memcpy(edit, _edit, 2 * width * sizeof(float))"
  },
  {
    "label": "HbrMovingVertexEdit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "HbrMovingVertexEdit(int _faceid, int _nsubfaces, int *_subfaces, int _vertexid, int _index, int _width, bool _isP, typename HbrHierarchicalEdit<T>::Operation _op, float *_edit) : HbrHierarchicalEdit<T>(_faceid, _nsubfaces, _subfaces), vertexid(_vertexid), index(_index), width(_width), isP(_isP), op(_op)"
  },
  {
    "label": "HbrMovingVertexEdit()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "HbrMovingVertexEdit()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (vertex ->)",
    "insertText": "GetData().ApplyMovingVertexEdit(*const_cast<const HbrMovingVertexEdit<T>*>(this))"
  },
  {
    "label": "p1()",
    "kind": "Method",
    "detail": "Function (struct xyz)",
    "insertText": "p1(struct xyz*)"
  },
  {
    "label": "p2()",
    "kind": "Method",
    "detail": "Function (struct xyz)",
    "insertText": "p2(struct xyz*)"
  },
  {
    "label": "MxTransformByMatrix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MxTransformByMatrix(&p1, &p1, *mx, 1)"
  },
  {
    "label": "MxTransformByMatrix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MxTransformByMatrix(&p2, &p2, *mx, 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(op == HbrVertexEdit<T>::Set)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (bbox . min . x =)",
    "insertText": "min(std::min(bbox.min.x, p1.x), p2.x)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (bbox . min . y =)",
    "insertText": "min(std::min(bbox.min.y, p1.y), p2.y)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (bbox . min . z =)",
    "insertText": "min(std::min(bbox.min.z, p1.z), p2.z)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (bbox . max . x =)",
    "insertText": "max(std::max(bbox.max.x, p1.x), p2.x)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (bbox . max . y =)",
    "insertText": "max(std::max(bbox.max.y, p1.y), p2.y)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (bbox . max . z =)",
    "insertText": "max(std::max(bbox.max.z, p1.z), p2.z)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(op == HbrVertexEdit<T>::Add || op == HbrVertexEdit<T>::Subtract)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (float maxx =)",
    "insertText": "max(fabsf(p1.x), fabsf(p2.x))"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (float maxy =)",
    "insertText": "max(fabsf(p1.y), fabsf(p2.y))"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (float maxz =)",
    "insertText": "max(fabsf(p1.z), fabsf(p2.z))"
  }
]