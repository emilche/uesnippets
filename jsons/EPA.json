[
  {
    "label": "TEPAEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TEPAEntry"
  },
  {
    "label": "FEPAFloodEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEPAFloodEntry"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FEPAEntryWrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEPAEntryWrapper"
  },
  {
    "label": "MinkowskiVert()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Simplex . h \" # include<queue> # include \" ChaosCheck . h \" # include \" ChaosLog . h \" # include \" Templates / Function . h \" namespace Chaos { int32 ArraySizeEPA = 1 6 ; template<T> using TEPAWorkingArray = TArray<T,TInlineAllocator<3 2>> ; template<T> const TVec3<T>)",
    "insertText": "MinkowskiVert(const TVec3<T>* VertsABuffer, const TVec3<T>* VertsBBuffer, const int32 Idx)"
  },
  {
    "label": "MinkowskiVert()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> V0 =)",
    "insertText": "MinkowskiVert(VerticesA, VerticesB, InIdx0)"
  },
  {
    "label": "MinkowskiVert()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> V1 =)",
    "insertText": "MinkowskiVert(VerticesA, VerticesB, InIdx1)"
  },
  {
    "label": "MinkowskiVert()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> V2 =)",
    "insertText": "MinkowskiVert(VerticesA, VerticesB, InIdx2)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> V0V1 = V1 - V0 ; const TVec3<T> V0V2 = V2 - V0 ; const TVec3<T> Norm = TVec3<T)",
    "insertText": "CrossProduct(V0V1, V0V2)"
  },
  {
    "label": "SizeSquared()",
    "kind": "Method",
    "detail": "Function (const T NormLenSq = Norm .)",
    "insertText": "SizeSquared()"
  },
  {
    "label": "SelectEpsilon()",
    "kind": "Method",
    "detail": "Function (const T Eps =)",
    "insertText": "SelectEpsilon(1.e-4f * 1.e-4f * 1.e-4f * 1.e-4f, 1.e-8 * 1.e-8 * 1.e-8 * 1.e-8)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (IdxBuffer [ 0 ] = InIdx0 ; IdxBuffer [ 1 ] = InIdx1 ; IdxBuffer [ 2 ] = InIdx2 ; AdjFaces = InAdjFaces ; AdjEdges = InAdjEdges ; Distance = TVec3<T)",
    "insertText": "DotProduct(PlaneNormal, V0)"
  },
  {
    "label": "SwapWinding()",
    "kind": "Method",
    "detail": "Function (bObsolete = false ; return true ; } void)",
    "insertText": "SwapWinding(TEPAEntry* Entries)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(IdxBuffer[0], IdxBuffer[1])"
  },
  {
    "label": "this()",
    "kind": "Method",
    "detail": "Function (auto UpdateAdjEdge = [ Entries,)",
    "insertText": "this(int32 Old, int32 New)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (TEPAEntry& AdjFace = Entries [ AdjFaces [ Old ] ] ; int32& StaleAdjIdx = AdjFace . AdjEdges [ AdjEdges [ Old ] ] ;)",
    "insertText": "check(StaleAdjIdx == Old)"
  },
  {
    "label": "UpdateAdjEdge()",
    "kind": "Method",
    "detail": "Function (StaleAdjIdx = New ; } ;)",
    "insertText": "UpdateAdjEdge(1, 2)"
  },
  {
    "label": "UpdateAdjEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateAdjEdge(2, 1)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(AdjFaces[1], AdjFaces[2])"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(AdjEdges[1], AdjEdges[2])"
  },
  {
    "label": "DistanceToPlane()",
    "kind": "Method",
    "detail": "Function (PlaneNormal = - PlaneNormal ; Distance = - Distance ; } T)",
    "insertText": "DistanceToPlane(const TVec3<T>& X)"
  },
  {
    "label": "IsOriginProjectedInside()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsOriginProjectedInside(const TVec3<T>* VertsABuffer, const TVec3<T>* VertsBBuffer, const T Epsilon)"
  },
  {
    "label": "MinkowskiVert()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> PN = Distance* PlaneNormal ; const TVec3<T> PA =)",
    "insertText": "MinkowskiVert(VertsABuffer, VertsBBuffer, IdxBuffer[0])"
  },
  {
    "label": "MinkowskiVert()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> PB =)",
    "insertText": "MinkowskiVert(VertsABuffer, VertsBBuffer, IdxBuffer[1])"
  },
  {
    "label": "MinkowskiVert()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> PC =)",
    "insertText": "MinkowskiVert(VertsABuffer, VertsBBuffer, IdxBuffer[2])"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> PACNormal = TVec3<T)",
    "insertText": "CrossProduct(PA, PC)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const T PACSign = TVec3<T)",
    "insertText": "DotProduct(PACNormal, PlaneNormal)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> PCBNormal = TVec3<T)",
    "insertText": "CrossProduct(PC, PB)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const T PCBSign = TVec3<T)",
    "insertText": "DotProduct(PCBNormal, PlaneNormal)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const T PBASign = TVec3<T)",
    "insertText": "DotProduct(PBANormal, PlaneNormal)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 NumVerts = VertsA .)",
    "insertText": "Num()"
  },
  {
    "label": "AddFartherPoint()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "AddFartherPoint(const TVec3<T>& Dir)"
  },
  {
    "label": "SupportA()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> NegDir = - Dir ; const TVec3<T> A0 =)",
    "insertText": "SupportA(Dir)"
  },
  {
    "label": "SupportA()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> A1 =)",
    "insertText": "SupportA(NegDir)"
  },
  {
    "label": "SupportB()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> B0 =)",
    "insertText": "SupportB(NegDir)"
  },
  {
    "label": "SupportB()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> B1 =)",
    "insertText": "SupportB(Dir)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> W0 = A0 - B0 ; const TVec3<T> W1 = A1 - B1 ; const T Dist0 = TVec3<T)",
    "insertText": "DotProduct(W0, Dir)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const T Dist1 = TVec3<T)",
    "insertText": "DotProduct(W1, NegDir)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsA .)",
    "insertText": "Add(A1)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsB .)",
    "insertText": "Add(B1)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { VertsA .)",
    "insertText": "Add(A0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsB .)",
    "insertText": "Add(B0)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (} } ; OutEntries .)",
    "insertText": "AddUninitialized(4)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (OutTouchNormal = TVec3<)",
    "insertText": "T(0,0,1)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (bool bValid = false ;)",
    "insertText": "switch(NumVerts)"
  },
  {
    "label": "MinkowskiVert()",
    "kind": "Method",
    "detail": "Function (} case 2 : { TVec3<T> Dir =)",
    "insertText": "MinkowskiVert(VertsA.GetData(), VertsB.GetData(), 1) - MinkowskiVert(VertsA.GetData(), VertsB.GetData(), 0)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (int32 BestAxis = 0 ; T MinVal = TNumericLimits<T)",
    "insertText": "Max()"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const T AbsVal =)",
    "insertText": "Abs(Dir[Axis])"
  },
  {
    "label": "AxisVector()",
    "kind": "Method",
    "detail": "Function (BestAxis = Axis ; MinVal = AbsVal ; } } const TVec3<T> OtherAxis = TVec3<T)",
    "insertText": "AxisVector(BestAxis)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> Orthog = TVec3<T)",
    "insertText": "CrossProduct(Dir, OtherAxis)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> Orthog2 = TVec3<T)",
    "insertText": "CrossProduct(Orthog, Dir)"
  },
  {
    "label": "AddFartherPoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddFartherPoint(Orthog)"
  },
  {
    "label": "AddFartherPoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddFartherPoint(Orthog2)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (bValid = OutEntries [ 0 ] .)",
    "insertText": "Initialize(VertsA.GetData(), VertsB.GetData(), 1, 2, 3, { 3,1,2 }, { 1,1,1 })"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (bValid& = OutEntries [ 1 ] .)",
    "insertText": "Initialize(VertsA.GetData(), VertsB.GetData(), 0, 3, 2, { 2,0,3 }, { 2,1,0 })"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (bValid& = OutEntries [ 2 ] .)",
    "insertText": "Initialize(VertsA.GetData(), VertsB.GetData(), 0, 1, 3, { 3,0,1 }, { 2,2,0 })"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (bValid& = OutEntries [ 3 ] .)",
    "insertText": "Initialize(VertsA.GetData(), VertsB.GetData(), 0, 2, 1, { 1,0,2 }, { 2,0,0 })"
  },
  {
    "label": "GetUnsafeNormal()",
    "kind": "Method",
    "detail": "Function (OutTouchNormal = Orthog .)",
    "insertText": "GetUnsafeNormal()"
  },
  {
    "label": "AddFartherPoint()",
    "kind": "Method",
    "detail": "Function (const TEPAEntry<T>& Base = OutEntries [ 3 ] ;)",
    "insertText": "AddFartherPoint(Base.PlaneNormal)"
  },
  {
    "label": "CHAOS_ENSURE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CHAOS_ENSURE(false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } })",
    "insertText": "if(bValid)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T MaxSignedDistance = 0 ;)",
    "insertText": "for(TEPAEntry<T>& Entry : OutEntries)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MaxSignedDistance = Entry . Distance ; } })",
    "insertText": "if(MaxSignedDistance < 0.0f)"
  },
  {
    "label": "SwapWinding()",
    "kind": "Method",
    "detail": "Function (Entry .)",
    "insertText": "SwapWinding(OutEntries.GetData())"
  },
  {
    "label": "InitializeEPA()",
    "kind": "Method",
    "detail": "Function (} } } return bValid ; } template<T,SupportALambda,SupportBLambda> bool)",
    "insertText": "InitializeEPA(TArray<TVec3<T>>& VertsA, TArray<TVec3<T>>& VertsB, const SupportALambda& SupportA, const SupportBLambda& SupportB, TEPAWorkingArray<TEPAEntry<T>>& OutEntries, TVec3<T>& OutTouchNormal)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TFunctionRef<TVector<)",
    "insertText": "T(const TVec3<T>& V)> SupportARef(SupportA)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TFunctionRef<TVector<)",
    "insertText": "T(const TVec3<T>& V)> SupportBRef(SupportB)"
  },
  {
    "label": "EPAComputeVisibilityBorder()",
    "kind": "Method",
    "detail": "Function (} struct FEPAFloodEntry { int32 EntryIdx ; int32 EdgeIdx ; } ; template<T> void)",
    "insertText": "EPAComputeVisibilityBorder(TEPAWorkingArray<TEPAEntry<T>>& Entries, int32 EntryIdx, const TVec3<T>& W, TEPAWorkingArray<FEPAFloodEntry>& OutBorderEdges, TEPAWorkingArray<FEPAFloodEntry> &ToVisitStack)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({ TEPAEntry<T>& Entry = Entries [ EntryIdx ] ;)",
    "insertText": "for(int i = 0; i < 3; ++i)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ToVisitStack .)",
    "insertText": "Add({ Entry.AdjFaces[i], Entry.AdjEdges[i] })"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} } int32 Iteration = 0 ; const int32 MaxIteration = 1 0 0 0 0 ;)",
    "insertText": "while(ToVisitStack.Num() && Iteration++ < MaxIteration)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (const FEPAFloodEntry FloodEntry = ToVisitStack .)",
    "insertText": "Pop(EAllowShrinking::No)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TEPAEntry<T>& Entry = Entries [ FloodEntry . EntryIdx ] ;)",
    "insertText": "if(!Entry.bObsolete)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutBorderEdges .)",
    "insertText": "Add(FloodEntry)"
  },
  {
    "label": "Idx1()",
    "kind": "Method",
    "detail": "Function (} else { Entry . bObsolete = true ; const int32 Idx0 = FloodEntry . EdgeIdx ; const int32)",
    "insertText": "Idx1(Idx0 + 1)"
  },
  {
    "label": "Idx2()",
    "kind": "Method",
    "detail": "Function (const int32)",
    "insertText": "Idx2(Idx0 + 2)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ToVisitStack .)",
    "insertText": "Add({ Entry.AdjFaces[Idx1], Entry.AdjEdges[Idx1] })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ToVisitStack .)",
    "insertText": "Add({ Entry.AdjFaces[Idx2], Entry.AdjEdges[Idx2] })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(Iteration >= MaxIteration)"
  },
  {
    "label": "ComputeEPAResults()",
    "kind": "Method",
    "detail": "Function (} } template<T> void)",
    "insertText": "ComputeEPAResults(const TVec3<T>* VertsA, const TVec3<T>* VertsB, const TEPAEntry<T>& Entry, T& OutPenetration, TVec3<T>& OutDir, TVec3<T>& OutA, TVec3<T>& OutB)"
  },
  {
    "label": "SimplexIDs()",
    "kind": "Method",
    "detail": "Function (FSimplex)",
    "insertText": "SimplexIDs({ 0,1,2 })"
  },
  {
    "label": "SimplexFindClosestToOrigin()",
    "kind": "Method",
    "detail": "Function (TVec3<T> As [ 4 ] = { VertsA [ Entry . IdxBuffer [ 0 ] ],VertsA [ Entry . IdxBuffer [ 1 ] ],VertsA [ Entry . IdxBuffer [ 2 ] ] } ; TVec3<T> Bs [ 4 ] = { VertsB [ Entry . IdxBuffer [ 0 ] ],VertsB [ Entry . IdxBuffer [ 1 ] ],VertsB [ Entry . IdxBuffer [ 2 ] ] } ; TVec3<T> Simplex [ 4 ] = { As [ 0 ] - Bs [ 0 ],As [ 1 ] - Bs [ 1 ],As [ 2 ] - Bs [ 2 ] } ; T Barycentric [ 4 ] ; OutDir =)",
    "insertText": "SimplexFindClosestToOrigin(Simplex, SimplexIDs, Barycentric, As, Bs)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (OutPenetration = OutDir .)",
    "insertText": "Size()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OutDir = Entry . PlaneNormal ;)",
    "insertText": "if(Entry.Distance < 0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (OutDir = - OutDir ; OutPenetration = - OutPenetration ; } } OutA = TVec3<)",
    "insertText": "T(0)"
  },
  {
    "label": "EPA()",
    "kind": "Method",
    "detail": "Function (} # ifndef DEBUG_EPA # define DEBUG_EPA 0 # endif template<T,TSupportA,TSupportB> EEPAResult)",
    "insertText": "EPA(TArray<TVec3<T>>& VertsABuffer, TArray<TVec3<T>>& VertsBBuffer, const TSupportA& SupportA, const TSupportB& SupportB, T& OutPenetration, TVec3<T>& OutDir, TVec3<T>& WitnessA, TVec3<T>& WitnessB, const FReal Eps = 1.e-2f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const TFunctionRef<TVector<)",
    "insertText": "T(const TVec3<T>& V)> SupportFuncA(SupportA)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const TFunctionRef<TVector<)",
    "insertText": "T(const TVec3<T>& V)> SupportFuncB(SupportB)"
  },
  {
    "label": "EPA()",
    "kind": "Method",
    "detail": "Function (} template<T> EEPAResult)",
    "insertText": "EPA(TArray<TVec3<T>>& VertsABuffer, TArray<TVec3<T>>& VertsBBuffer, const TFunctionRef<TVector<T, 3>(const TVec3<T>& V)>& SupportA, const TFunctionRef<TVector<T, 3>(const TVec3<T>& V)>& SupportB, T& OutPenetration, TVec3<T>& OutDir, TVec3<T>& WitnessA, TVec3<T>& WitnessB, const FReal EpsRel = 1.e-2f)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (struct FEPAEntryWrapper { const TArray<TEPAEntry<T>>* Entries ; int32 Idx ; bool)",
    "insertText": "operator(const FEPAEntryWrapper& Other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } ; T OriginInsideEps = 0 . 0 f ; TEPAWorkingArray<TEPAEntry<T>> Entries ;)",
    "insertText": "if(!InitializeEPA(VertsABuffer,VertsBBuffer,SupportA,SupportB, Entries, OutDir))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsWBuffer .)",
    "insertText": "Add(MinkowskiVert(VertsABuffer.GetData(), VertsBBuffer.GetData(), Idx))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} # endif TEPAWorkingArray<int32> Queue ;)",
    "insertText": "for(int32 Idx = 0; Idx < Entries.Num(); ++Idx)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Queue .)",
    "insertText": "Add(Idx)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} } TEPAWorkingArray<FEPAFloodEntry> VisibilityBorder ; TEPAWorkingArray<FEPAFloodEntry> VisibilityBorderToVisitStack ; TEPAEntry<T> LastEntry = Queue .)",
    "insertText": "Num() > 0 ? Entries[Queue.Last()"
  },
  {
    "label": "Lowest()",
    "kind": "Method",
    "detail": "Function (T LowerBound = TNumericLimits<T)",
    "insertText": "Lowest()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bool bQueueDirty = true ; int32 Iteration = 0 ; int32 MaxIterations = 1 2 8 ; EEPAResult ResultStatus = EEPAResult::MaxIterations ;)",
    "insertText": "while(Queue.Num() && (Iteration++ < MaxIterations))"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort(Queue.GetData(), Queue.GetData() + Queue.Num(), [&Entries](const int32 L, const int32 R) { return Entries[L] > Entries[R]; })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TEPAEntry<T>& Entry = Entries [ EntryIdx ] ; { })",
    "insertText": "if(Entry.bObsolete)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(Entry.Distance > UpperBound)"
  },
  {
    "label": "SupportA()",
    "kind": "Method",
    "detail": "Function (ResultStatus = EEPAResult::Ok ; break ; } const TVec3<T> ASupport =)",
    "insertText": "SupportA(Entry.PlaneNormal)"
  },
  {
    "label": "SupportB()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> BSupport =)",
    "insertText": "SupportB(-Entry.PlaneNormal)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> W = ASupport - BSupport ; const T DistanceToSupportPlane = TVec3<T)",
    "insertText": "DotProduct(Entry.PlaneNormal, W)"
  },
  {
    "label": "UpperBoundTolerance()",
    "kind": "Method",
    "detail": "Function (UpperBound = DistanceToSupportPlane ; } LowerBound = Entry . Distance ; const T)",
    "insertText": "UpperBoundTolerance(T(1) + EpsRel) * FMath::Abs(LowerBound)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ResultStatus = EEPAResult::Ok ; LastEntry = Entry ; break ; })",
    "insertText": "if(UpperBound < LowerBound)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ResultStatus = EEPAResult::Ok ; break ; } LastEntry = Entry ; const int32 NewVertIdx = VertsABuffer .)",
    "insertText": "Add(ASupport)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsBBuffer .)",
    "insertText": "Add(BSupport)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (# if DEBUG_EPA VertsWBuffer .)",
    "insertText": "Add(MinkowskiVert(VertsABuffer.GetData(), VertsBBuffer.GetData(), NewVertIdx))"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (# endif Entry . bObsolete = true ; VisibilityBorder .)",
    "insertText": "Reset()"
  },
  {
    "label": "EPAComputeVisibilityBorder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EPAComputeVisibilityBorder(Entries, EntryIdx, W, VisibilityBorder, VisibilityBorderToVisitStack)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (int32 NewIdx = FirstIdxInBatch ; Entries .)",
    "insertText": "AddUninitialized(NumBorderEdges)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bTerminate = false ;)",
    "insertText": "for(int32 VisibilityIdx = 0; VisibilityIdx < NumBorderEdges; ++VisibilityIdx)"
  },
  {
    "label": "BorderEdgeIdx1()",
    "kind": "Method",
    "detail": "Function (const FEPAFloodEntry& BorderInfo = VisibilityBorder [ VisibilityIdx ] ; TEPAEntry<T>& NewEntry = Entries [ NewIdx ] ; const int32 BorderEntryIdx = BorderInfo . EntryIdx ; TEPAEntry<T>& BorderEntry = Entries [ BorderEntryIdx ] ; const int32 BorderEdgeIdx0 = BorderInfo . EdgeIdx ; const int32)",
    "insertText": "BorderEdgeIdx1(BorderEdgeIdx0 + 1)"
  },
  {
    "label": "NextEntryIdx()",
    "kind": "Method",
    "detail": "Function (const int32)",
    "insertText": "NextEntryIdx(VisibilityIdx + 1) < VisibilityBorder.Num()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (const int32 PrevEntryIdx = NewIdx> FirstIdxInBatch ? NewIdx - 1 : FirstIdxInBatch + NumBorderEdges - 1 ; const bool bValidTri = NewEntry .)",
    "insertText": "Initialize(VertsABuffer.GetData(), VertsBBuffer.GetData(), BorderEntry.IdxBuffer[BorderEdgeIdx1], BorderEntry.IdxBuffer[BorderEdgeIdx0], NewVertIdx, { BorderEntryIdx, PrevEntryIdx, NextEntryIdx }, { BorderEdgeIdx0, 2, 1 })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BorderEntry . AdjFaces [ BorderEdgeIdx0 ] = NewIdx ; BorderEntry . AdjEdges [ BorderEdgeIdx0 ] = 0 ;)",
    "insertText": "if(!bValidTri)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ResultStatus = EEPAResult::Degenerate ; bTerminate = true ; break ; })",
    "insertText": "if(bValidTri && NewEntry.Distance <= UpperBound)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Queue .)",
    "insertText": "Add(NewIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bQueueDirty = true ; } } + + NewIdx ; })",
    "insertText": "if(bTerminate)"
  },
  {
    "label": "ComputeEPAResults()",
    "kind": "Method",
    "detail": "Function (break ; } } else { ResultStatus = EEPAResult::Degenerate ; break ; } })",
    "insertText": "ComputeEPAResults(VertsABuffer.GetData(), VertsBBuffer.GetData(), LastEntry, OutPenetration, OutDir, WitnessA, WitnessB)"
  }
]