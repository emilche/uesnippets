[
  {
    "label": "T_DERIVED",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T_DERIVED"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TArrayNDBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TArrayNDBase"
  },
  {
    "label": "TArrayND",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TArrayND"
  },
  {
    "label": "TryBulkSerializeArrayNDBase()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" # include \" Chaos / Array . h \" # include \" Chaos / UniformGrid . h \" # include \" Chaos / Vector . h \" # include \" UObject / DestructionObjectVersion . h \" # include \" Chaos / ChaosArchive . h \" namespace Chaos { template<T> void)",
    "insertText": "TryBulkSerializeArrayNDBase(FArchive& Ar, TArray<T>& Array)"
  },
  {
    "label": "TryBulkSerializeArrayNDBase()",
    "kind": "Method",
    "detail": "Function (Ar<<Array ; } void)",
    "insertText": "TryBulkSerializeArrayNDBase(FArchive& Ar, TArray<float>& Array)"
  },
  {
    "label": "BulkSerialize()",
    "kind": "Method",
    "detail": "Function (Array .)",
    "insertText": "BulkSerialize(Ar)"
  },
  {
    "label": "TryBulkSerializeArrayNDBase()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TryBulkSerializeArrayNDBase(FArchive& Ar, TArray<TVec3<FRealSingle>>& Array)"
  },
  {
    "label": "ConvertDoubleToFloat()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "ConvertDoubleToFloat(double DoubleValue)"
  },
  {
    "label": "ConvertDoubleToFloat()",
    "kind": "Method",
    "detail": "Function (} TVec3<float>)",
    "insertText": "ConvertDoubleToFloat(TVec3<double> DoubleValue)"
  },
  {
    "label": "ConvertFloatToDouble()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "ConvertFloatToDouble(float FloatValue)"
  },
  {
    "label": "ConvertFloatToDouble()",
    "kind": "Method",
    "detail": "Function (} TVec3<double>)",
    "insertText": "ConvertFloatToDouble(TVec3<float> FloatValue)"
  },
  {
    "label": "TryBulkSerializeArrayNDBaseForDoubles()",
    "kind": "Method",
    "detail": "Function (} template<DOUBLE_T,FLOAT_T> void)",
    "insertText": "TryBulkSerializeArrayNDBaseForDoubles(FArchive& Ar, TArray<DOUBLE_T>& DoubleTypedArray)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<FLOAT_T> FloatTypedArray ;)",
    "insertText": "if(Ar.IsSaving())"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (FloatTypedArray .)",
    "insertText": "SetNumUninitialized(DoubleTypedArray.Num())"
  },
  {
    "label": "ConvertDoubleToFloat()",
    "kind": "Method",
    "detail": "Function (FloatTypedArray [ i ] =)",
    "insertText": "ConvertDoubleToFloat(DoubleTypedArray[i])"
  },
  {
    "label": "TryBulkSerializeArrayNDBase()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TryBulkSerializeArrayNDBase(Ar, FloatTypedArray)"
  },
  {
    "label": "TryBulkSerializeArrayNDBase()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "TryBulkSerializeArrayNDBase(FArchive& Ar, TArray<double>& Array)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (TryBulkSerializeArrayNDBaseForDoubles<double,)",
    "insertText": "float(Ar, Array)"
  },
  {
    "label": "TryBulkSerializeArrayNDBase()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TryBulkSerializeArrayNDBase(FArchive& Ar, TArray<TVec3<FRealDouble>>& Array)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (TryBulkSerializeArrayNDBaseForDoubles<TVec3<FRealDouble>,TVec3<)",
    "insertText": "FRealSingle(Ar, Array)"
  },
  {
    "label": "TArrayNDBase()",
    "kind": "Method",
    "detail": "Function (} template<class T_DERIVED,class T,int d> class TArrayNDBase { public :)",
    "insertText": "TArrayNDBase()"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (MCounts = TVec3<)",
    "insertText": "int32(0)"
  },
  {
    "label": "TArrayNDBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TArrayNDBase(const TVector<int32, d>& Counts, const TArray<T>& Array) : MCounts(Counts), MArray(Array)"
  },
  {
    "label": "TArrayNDBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TArrayNDBase(const TArrayNDBase<T_DERIVED, T, d>& Other)"
  },
  {
    "label": "TArrayNDBase()",
    "kind": "Method",
    "detail": "Function (} # if COMPILE_WITHOUT_UNREAL_SUPPORT)",
    "insertText": "TArrayNDBase(std::istream& Stream) : MCounts(Stream)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (MArray .)",
    "insertText": "SetNum(MCounts[0] * MCounts[1] * MCounts[2])"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (Stream .)",
    "insertText": "read(reinterpret_cast<char*>(MArray.GetData()), sizeof(T) * MArray.Num())"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Write(std::ostream& Stream)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (MCounts .)",
    "insertText": "Write(Stream)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (Stream .)",
    "insertText": "write(reinterpret_cast<const char*>(MArray.GetData()), sizeof(T) * MArray.Num())"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FDestructionObjectVersion::GUID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<MCounts ;)",
    "insertText": "if(Ar.CustomVer(FDestructionObjectVersion::GUID) < FDestructionObjectVersion::BulkSerializeArrays)"
  },
  {
    "label": "TryBulkSerializeArrayNDBase()",
    "kind": "Method",
    "detail": "Function (Ar<<MArray ; } else {)",
    "insertText": "TryBulkSerializeArrayNDBase(Ar, MArray)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Serialize(FChaosArchive& Ar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ar<<MCounts ; Ar<<MArray ; } TArrayNDBase<T_DERIVED,T,d>&)",
    "insertText": "operator(const TArrayNDBase<T_DERIVED, T, d>& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MCounts = Other . MCounts ; MArray = Other . MArray ; return* this ; } TArrayNDBase<T_DERIVED,T,d>&)",
    "insertText": "operator(TArrayNDBase<T_DERIVED, T, d>&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MCounts = Other . MCounts ; MArray =)",
    "insertText": "MoveTemp(Other.MArray)"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Copy(const TArrayNDBase<T_DERIVED, T, d>& Source)"
  },
  {
    "label": "Fill()",
    "kind": "Method",
    "detail": "Function (MCounts = Source . MCounts ; MArray = Source . MArray ; } void)",
    "insertText": "Fill(const T& Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Elem = Value ; } } const T&)",
    "insertText": "operator(const int32 i)"
  },
  {
    "label": "Counts()",
    "kind": "Method",
    "detail": "Function (} TVector<int32,d>)",
    "insertText": "Counts()"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (MCounts = TVector<int32,)",
    "insertText": "d(0)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (MArray .)",
    "insertText": "Reset()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} T*)",
    "insertText": "GetData()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} protected : TVector<int32,d> MCounts ; TArray<T> MArray ; } ; template<Derived,T,int d> FArchive&)",
    "insertText": "operator(FArchive& Ar, TArrayNDBase<Derived, T,d>& ValueIn)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (ValueIn .)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (MArray .)",
    "insertText": "SetNum(Counts.Product())"
  },
  {
    "label": "TArrayND()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TArrayND(const TVector<int32, d>& Counts, const TArray<T>& Array) : Base(Counts, Array)"
  },
  {
    "label": "TArrayND()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TArrayND(const TArrayND<T, d>& Other)"
  },
  {
    "label": "TArrayND()",
    "kind": "Method",
    "detail": "Function (} # if COMPILE_WITHOUT_UNREAL_SUPPORT)",
    "insertText": "TArrayND(std::istream& Stream) : Base(Stream)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif TArrayND<T,d>&)",
    "insertText": "operator(const TArrayND<T, d>& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(MoveTemp(Other))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 SingleIndex = 0 ; int32 count = 1 ;)",
    "insertText": "for(int32 i = d - 1; i >= 0; ++i)"
  },
  {
    "label": "TArrayND()",
    "kind": "Method",
    "detail": "Function (SingleIndex + = count* Index [ i ] ; count* = MCounts [ i ] ; } return MArray [ SingleIndex ] ; } } ; template<class T> class TArrayND<T,3> : public TArrayNDBase<TArrayND<T,3>,T,3> { typedef TArrayNDBase<TArrayND<T,3>,T,3> Base ; using Base::MArray ; using Base::MCounts ; public : # if UE_BUILD_SHIPPING | | UE_BUILD_TEST)",
    "insertText": "TArrayND()"
  },
  {
    "label": "TArrayND()",
    "kind": "Method",
    "detail": "Function (} # endif template<U>)",
    "insertText": "TArrayND(const TUniformGrid<U, 3>& Grid, bool NodeValues = false)"
  },
  {
    "label": "SetCounts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCounts(Grid, NodeValues)"
  },
  {
    "label": "TArrayND()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TArrayND(const TVec3<int32>& Counts)"
  },
  {
    "label": "SetCounts()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCounts(Counts)"
  },
  {
    "label": "TArrayND()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TArrayND(const TVec3<int32>& Counts, const TArray<T>& Array) : Base(Counts, Array)"
  },
  {
    "label": "TArrayND()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TArrayND(const TArrayND<T, 3>& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif TArrayND<T,3>&)",
    "insertText": "operator(const TArrayND<T, 3>& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const T&)",
    "insertText": "operator()(const TVec3<int32>& Index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "operator()(const int32& x, const int32& y, const int32& z)"
  },
  {
    "label": "SetCounts()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCounts(const TVector<int32, 3>& Counts)"
  },
  {
    "label": "SetCounts()",
    "kind": "Method",
    "detail": "Function (} template<U> void)",
    "insertText": "SetCounts(const TUniformGrid<U, 3>& Grid, bool NodeValues = false)"
  },
  {
    "label": "NodeCounts()",
    "kind": "Method",
    "detail": "Function (MCounts = NodeValues ? Grid .)",
    "insertText": "NodeCounts() : Grid.Counts()"
  },
  {
    "label": "TArrayND()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TArrayND(const TUniformGrid<float, 3>& grid)"
  },
  {
    "label": "TArrayND()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TArrayND(const Vector<int32, 3>& Counts)"
  },
  {
    "label": "TArrayND()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TArrayND(const Vector<int32, 3>& Counts, const TArray<char>& Array) : Base(Counts, Array)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} char&)",
    "insertText": "operator()(const Vector<int32, 3>& Index)"
  }
]