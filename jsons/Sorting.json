[
  {
    "label": "SIdentityFunctor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SIdentityFunctor"
  },
  {
    "label": "TLess",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TLess"
  },
  {
    "label": "TReversePredicate",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TReversePredicate"
  },
  {
    "label": "PredicateType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PredicateType"
  },
  {
    "label": "TDereferenceWrapper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TDereferenceWrapper"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" uLang / Common / Templates / References . h \" namespace uLang { struct SIdentityFunctor { template<T> ULANG_FORCEINLINE T&&)",
    "insertText": "operator()(T&& Val)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<T = void> struct TLess { ULANG_FORCEINLINE bool)",
    "insertText": "operator()(const T& A, const T& B)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> ULANG_FORCEINLINE bool)",
    "insertText": "operator()( T&& A, T&& B)"
  },
  {
    "label": "TDereferenceWrapper()",
    "kind": "Method",
    "detail": "Function (} } ; template<class PredicateType> struct TDereferenceWrapper { const PredicateType& _Predicate ;)",
    "insertText": "TDereferenceWrapper(const PredicateType& Predicate ) : _Predicate( Predicate)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T> ULANG_FORCEINLINE TEnableIf<TIsPointer<T>::Value,bool>::Type)",
    "insertText": "operator()(const T A, const T B)"
  }
]