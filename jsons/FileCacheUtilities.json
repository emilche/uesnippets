[
  {
    "label": "FWildcardString",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FWildcardString"
  },
  {
    "label": "FImmutableString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FImmutableString"
  },
  {
    "label": "FTimeLimit",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTimeLimit"
  },
  {
    "label": "IMatchRule",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IMatchRule"
  },
  {
    "label": "FMatchRules",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMatchRules"
  },
  {
    "label": "FMatchRule",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMatchRule"
  },
  {
    "label": "EType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EType"
  },
  {
    "label": "MatchExtensionString()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / EnumAsByte . h \" # include \" Containers / UnrealString . h \" # include \" CoreMinimal . h \" # include \" HAL / Platform . h \" # include \" HAL / PlatformTime . h \" # include \" Misc / Optional . h \" # include \" Serialization / Archive . h \" # include \" Templates / SharedPointer . h \" # include \" Templates / UnrealTemplate . h \" class FWildcardString ; namespace DirectoryWatcher { bool)",
    "insertText": "MatchExtensionString(const TCHAR* Filename, const TCHAR* Extensions)"
  },
  {
    "label": "FImmutableString()",
    "kind": "Method",
    "detail": "Function (struct FImmutableString {)",
    "insertText": "FImmutableString(FString InString = FString()) : String(MoveTemp(InString)), CachedHash(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FImmutableString&)",
    "insertText": "operator(FString InString)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (String =)",
    "insertText": "MoveTemp(InString)"
  },
  {
    "label": "FImmutableString()",
    "kind": "Method",
    "detail": "Function (CachedHash = 0 ; return* this ; })",
    "insertText": "FImmutableString(const TCHAR* InString) : String(InString), CachedHash(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FImmutableString&)",
    "insertText": "operator(const TCHAR* InString)"
  },
  {
    "label": "FImmutableString()",
    "kind": "Method",
    "detail": "Function (String = InString ; CachedHash = 0 ; return* this ; })",
    "insertText": "FImmutableString(const FImmutableString&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FImmutableString&)",
    "insertText": "operator(const FImmutableString&)"
  },
  {
    "label": "FImmutableString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImmutableString(FImmutableString&& In) : String(MoveTemp(In.String)), CachedHash(MoveTemp(In.CachedHash))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FImmutableString&)",
    "insertText": "operator(FImmutableString&& In)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(String, In.String)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(CachedHash, In.CachedHash)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(const FImmutableString& In)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (In . CachedHash =)",
    "insertText": "GetTypeHash(In.String)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} return In . CachedHash ; } const FString&)",
    "insertText": "Get()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<InString . String ;)",
    "insertText": "if(Ar.IsSaving())"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetTypeHash(InString)"
  },
  {
    "label": "FTimeLimit()",
    "kind": "Method",
    "detail": "Function (} Ar<<InString . CachedHash ; return Ar ; } private : FString String ; uint32 CachedHash ; } ; struct FTimeLimit {)",
    "insertText": "FTimeLimit() : Delay(-1)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "FTimeLimit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FTimeLimit(float NumSeconds) : Delay(NumSeconds)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "Seconds()",
    "kind": "Method",
    "detail": "Function (StartTime =)",
    "insertText": "Seconds()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} private : float Delay ; double StartTime ; } ; struct IMatchRule { void)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "IsFileApplicable()",
    "kind": "Method",
    "detail": "Function (TOptional<bool>)",
    "insertText": "IsFileApplicable(const TCHAR* Filename)"
  },
  {
    "label": "FMatchRules()",
    "kind": "Method",
    "detail": "Function (} ; struct FMatchRules {)",
    "insertText": "FMatchRules() : bDefaultIncludeState(true)"
  },
  {
    "label": "AddWildcardRule()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddWildcardRule(const FWildcardString& WildcardString, bool bInclude)"
  },
  {
    "label": "SetApplicableExtensions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetApplicableExtensions(const FString& InExtensions)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(FArchive& Ar, FMatchRules& Rules)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(FArchive& Ar, FMatchRule& Rule)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Rule .)",
    "insertText": "Serialize(Ar)"
  }
]