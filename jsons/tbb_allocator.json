[
  {
    "label": "tbb_allocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "tbb_allocator"
  },
  {
    "label": "rebind",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "rebind"
  },
  {
    "label": "malloc_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "malloc_type"
  },
  {
    "label": "Allocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Allocator"
  },
  {
    "label": "zero_allocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "zero_allocator"
  },
  {
    "label": "B1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "B1"
  },
  {
    "label": "B2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "B2"
  },
  {
    "label": "deallocate_via_handler_v3()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_tbb_allocator_H # define __TBB_tbb_allocator_H # include \" tbb_stddef . h \" # include<new> # if __TBB_ALLOCATOR_CONSTRUCT_VARIADIC # include<utility> # endif # include<cstring> namespace tbb { namespace internal { void __TBB_EXPORTED_FUNC)",
    "insertText": "deallocate_via_handler_v3(void *p)"
  },
  {
    "label": "allocate_via_handler_v3()",
    "kind": "Method",
    "detail": "Function (void* __TBB_EXPORTED_FUNC)",
    "insertText": "allocate_via_handler_v3(size_t n)"
  },
  {
    "label": "is_malloc_used_v3()",
    "kind": "Method",
    "detail": "Function (bool __TBB_EXPORTED_FUNC)",
    "insertText": "is_malloc_used_v3()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if _MSC_VER&& !)",
    "insertText": "defined(__INTEL_COMPILER) #pragma warning (push) #pragma warning (disable: 4100)"
  },
  {
    "label": "tbb_allocator()",
    "kind": "Method",
    "detail": "Function (public : typedef internal::allocator_type<T>::value_type value_type ; typedef value_type* pointer ; typedef const value_type* const_pointer ; typedef value_type& reference ; typedef const value_type& const_reference ; typedef size_t size_type ; typedef ptrdiff_t difference_type ; template<U> struct rebind { typedef tbb_allocator<U> other ; } ; enum malloc_type { scalable,standard } ;)",
    "insertText": "tbb_allocator() throw()"
  },
  {
    "label": "tbb_allocator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "tbb_allocator(const tbb_allocator& ) throw()"
  },
  {
    "label": "tbb_allocator()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "tbb_allocator(const tbb_allocator<U>&) throw()"
  },
  {
    "label": "address()",
    "kind": "Method",
    "detail": "Function (} pointer)",
    "insertText": "address(reference x)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "deallocate(pointer p, size_type)"
  },
  {
    "label": "deallocate_via_handler_v3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deallocate_via_handler_v3(p)"
  },
  {
    "label": "max_size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "max_size() const throw()"
  },
  {
    "label": "size_type()",
    "kind": "Method",
    "detail": "Function (size_type max = static_cast<)",
    "insertText": "size_type(-1) / sizeof (value_type)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_ALLOCATOR_CONSTRUCT_VARIADIC template<U,. . . Args> void)",
    "insertText": "construct(U *p, Args&&... args)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void *)p) U(std::forward<Args>(args)...)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} # else # if __TBB_CPP11_RVALUE_REF_PRESENT void)",
    "insertText": "construct(pointer p, value_type&& value)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)(p)) value_type(std::move(value))"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "construct(pointer p, const value_type& value)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)(p)) value_type(value)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "destroy(pointer p)"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (p -> ~)",
    "insertText": "value_type()"
  },
  {
    "label": "allocator_type()",
    "kind": "Method",
    "detail": "Function (} malloc_type)",
    "insertText": "allocator_type()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # if _MSC_VER&& !)",
    "insertText": "defined(__INTEL_COMPILER) #pragma warning (pop)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (public : typedef void* pointer ; typedef const void* const_pointer ; typedef void value_type ; template<U> struct rebind { typedef tbb_allocator<U> other ; } ; } ; template<T,U> bool)",
    "insertText": "operator(const tbb_allocator<T>&, const tbb_allocator<U>&)"
  },
  {
    "label": "zero_allocator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "zero_allocator(const zero_allocator &a) throw() : base_allocator_type( a)"
  },
  {
    "label": "zero_allocator()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "zero_allocator(const zero_allocator<U> &a) throw() : base_allocator_type( Allocator<U>( a ))"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} pointer)",
    "insertText": "allocate(const size_type n, const void *hint = 0)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (pointer ptr =)",
    "insertText": "allocate(n, hint)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(static_cast<void*>(ptr), 0, n * sizeof(value_type))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T1,template<X1> class B1,T2,template<X2> class B2> bool)",
    "insertText": "operator(const zero_allocator<T1,B1> &a, const zero_allocator<T2,B2> &b)"
  }
]