[
  {
    "label": "TKey",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TKey"
  },
  {
    "label": "TValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TValue"
  },
  {
    "label": "TCompare",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TCompare"
  },
  {
    "label": "CMap()",
    "kind": "Method",
    "detail": "Function (template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "CMap(size_t uiStartingPoolSize) : m_pRoot(NULL), m_uiSize(0), m_cPool(sizeof(CNode), uiStartingPoolSize)"
  },
  {
    "label": "CMap()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "CMap(const CMap& cRight) : m_pRoot(NULL), m_uiSize(0), m_cPool(sizeof(CNode), cRight.m_cPool.size( ))"
  },
  {
    "label": "CMap()",
    "kind": "Method",
    "detail": "Function (* this = cRight ; } template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::~)",
    "insertText": "CMap(void)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE void CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "clear(void)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Ptr(m_pRoot)->DeleteChildren(this)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deallocate(m_pRoot)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (m_pRoot = NULL ; } m_uiSize = 0 ; } template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE size_t CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "size(void)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE bool CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "empty(void)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE TValue& CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "operator(const TKey& tKey)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (TCompare tCompare ; CNodeReference pCurrent = m_pRoot ; CNodeReference pParent = NULL ;)",
    "insertText": "while(pCurrent != NULL && tKey != Ptr(pCurrent)->first)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_pLeft)",
    "insertText": "if(tCompare(tKey, Ptr(pCurrent)->first)) pCurrent = Ptr(pCurrent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(pCurrent == NULL)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (pCurrent =)",
    "insertText": "Allocate(tKey, pParent)"
  },
  {
    "label": "Rebalance()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rebalance(pParent)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (second)",
    "insertText": "Ptr(pCurrent)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>& CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "operator(const CMap<TKey, TValue, TCompare, bUseCustomAllocator>& cRight)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (m_pRoot =)",
    "insertText": "Allocate(cRight.Ptr(cRight.m_pRoot)->first, NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (second)",
    "insertText": "Ptr(m_pRoot)->second = cRight.Ptr(cRight.m_pRoot)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_uiLevel)",
    "insertText": "Ptr(m_pRoot)->m_uiLevel = cRight.Ptr(cRight.m_pRoot)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (+ + m_uiSize ; CArray<CNodeReference> aThis ; CArray<CNodeReference> aRight ; aThis .)",
    "insertText": "push_back(m_pRoot)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (aRight .)",
    "insertText": "push_back(cRight.m_pRoot)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (CNodeReference pThis = aThis .)",
    "insertText": "back()"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (aThis .)",
    "insertText": "pop_back()"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Ptr(pThis)->m_pLeft = Allocate(cRight.Ptr(cRight.Ptr(pRight)->m_pLeft)->first, pThis)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (second)",
    "insertText": "Ptr(Ptr(pThis)->m_pLeft)->second = cRight.Ptr(cRight.Ptr(pRight)->m_pLeft)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_uiLevel)",
    "insertText": "Ptr(Ptr(pThis)->m_pLeft)->m_uiLevel = cRight.Ptr(cRight.Ptr(pRight)->m_pLeft)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (aThis .)",
    "insertText": "push_back(Ptr(pThis)->m_pLeft)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (aRight .)",
    "insertText": "push_back(cRight.Ptr(pRight)->m_pLeft)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + m_uiSize ; })",
    "insertText": "if(cRight.Ptr(pRight)->m_pRight != NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Ptr(pThis)->m_pRight = Allocate(cRight.Ptr(cRight.Ptr(pRight)->m_pRight)->first, pThis)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (second)",
    "insertText": "Ptr(Ptr(pThis)->m_pRight)->second = cRight.Ptr(cRight.Ptr(pRight)->m_pRight)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_uiLevel)",
    "insertText": "Ptr(Ptr(pThis)->m_pRight)->m_uiLevel = cRight.Ptr(cRight.Ptr(pRight)->m_pRight)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (aThis .)",
    "insertText": "push_back(Ptr(pThis)->m_pRight)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (aRight .)",
    "insertText": "push_back(cRight.Ptr(pRight)->m_pRight)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (+ + m_uiSize ; } } })",
    "insertText": "return(*this)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::iterator CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "begin(void)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (m_pLeft)",
    "insertText": "while(Ptr(pCurrent)->m_pLeft != NULL) pCurrent = Ptr(pCurrent)"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::iterator CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "rbegin(void)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (m_pRight)",
    "insertText": "while(Ptr(pCurrent)->m_pRight != NULL) pCurrent = Ptr(pCurrent)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::iterator CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "end(void)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::iterator CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "find(const TKey& tKey)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (TCompare tCompare ; CNodeReference pCurrent = m_pRoot ;)",
    "insertText": "while(pCurrent != NULL && Ptr(pCurrent)->first != tKey)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "iterator(pCurrent, &m_cPool)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::iterator CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "erase(iterator iterWhere)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (# ifdef SPEEDTREE_ITERATOR_DEBUGGING)",
    "insertText": "assert(iterWhere.m_pNode != NULL)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "while(Ptr(pRoot)->m_pParent != NULL) pRoot = Ptr(pRoot)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(pRoot == m_pRoot)"
  },
  {
    "label": "bRootDelete()",
    "kind": "Method",
    "detail": "Function (# endif CNodeReference pRemove = iterWhere . m_pNode ; + + iterWhere ; bool)",
    "insertText": "bRootDelete(pRemove == m_pRoot)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CNodeReference pBalance = NULL ;)",
    "insertText": "if(Ptr(pRemove)->m_pLeft == NULL && Ptr(pRemove)->m_pRight == NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr(pRemove)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bRootDelete)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Ptr(pRemove)->m_pLeft == NULL || Ptr(pRemove)->m_pRight == NULL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pBalance = pChild ;)",
    "insertText": "if(Ptr(pRemove)->m_pParent != NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr(pChild)->m_pParent = Ptr(pRemove)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pRight)",
    "insertText": "Ptr(pSwitch)->m_pRight = Ptr(pRemove)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr(pSwitch)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pLeft)",
    "insertText": "Ptr(pParent)->m_pRight = Ptr(pSwitch)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pLeft)",
    "insertText": "Ptr(pSwitch)->m_pLeft = Ptr(pRemove)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent = pSwitch)",
    "insertText": "Ptr(Ptr(pSwitch)->m_pLeft)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr(pSwitch)->m_pParent = Ptr(pRemove)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_uiLevel)",
    "insertText": "Ptr(pSwitch)->m_uiLevel = Ptr(pRemove)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Deallocate(pRemove)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (CNodeReference pLower = pBalance ;)",
    "insertText": "while(pLower != NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_uiLevel)",
    "insertText": "Ptr(pLower)"
  },
  {
    "label": "Rebalance()",
    "kind": "Method",
    "detail": "Function (} else pLower = NULL ; })",
    "insertText": "Rebalance(pBalance)"
  },
  {
    "label": "lower()",
    "kind": "Method",
    "detail": "Function (} - - m_uiSize ; return iterWhere ; } template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::iterator CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "lower(const TKey& tKey)"
  },
  {
    "label": "higher()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::iterator CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "higher(const TKey& tKey)"
  },
  {
    "label": "lower()",
    "kind": "Method",
    "detail": "Function (TCompare tCompare ; iterator iterHigher =)",
    "insertText": "lower(tKey)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (iterator iterBegin =)",
    "insertText": "begin()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(tCompare(iterHigher->first, tKey))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (iterHigher = iterLower ;)",
    "insertText": "if(iterHigher == end( ))"
  },
  {
    "label": "lower_and_higher()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> void CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "lower_and_higher(const TKey& tKey, const_iterator& iterLower, const_iterator& iterHigher)"
  },
  {
    "label": "ResizePool()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE void CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "ResizePool(size_t uiSize)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_cPool .)",
    "insertText": "resize(uiSize)"
  },
  {
    "label": "SetHeapDescription()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE void CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "SetHeapDescription(const char* pHeapDesc)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (m_pHeapDesc = pHeapDesc ; } template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::CNodeReference CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "Allocate(const TKey& tKey, CNodeReference pParent)"
  },
  {
    "label": "GrabBlock()",
    "kind": "Method",
    "detail": "Function (CNodeReference cReturn = m_cPool .)",
    "insertText": "GrabBlock()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(m_cPool.ResolveBlock(cReturn)) CNode(tKey, pParent)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Ptr(pData)->~CNode()"
  },
  {
    "label": "ReleaseBlock()",
    "kind": "Method",
    "detail": "Function (m_cPool .)",
    "insertText": "ReleaseBlock(pData)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::CNode* CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "Ptr(CNodeReference pNode)"
  },
  {
    "label": "Rebalance()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE void CMap<TKey,TValue,TCompare,bUseCustomAllocator)",
    "insertText": "Rebalance(CNodeReference pCurrent)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const unsigned char c_ucTestSteps = 5 ; unsigned char ucSteps = c_ucTestSteps ;)",
    "insertText": "while(pCurrent != NULL)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pRight)",
    "insertText": "Ptr(pCurrent)->m_pLeft = Ptr(pSave)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pRight = pCurrent)",
    "insertText": "Ptr(pSave)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr(pSave)->m_pParent = Ptr(pCurrent)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (pCurrent = pSave ; } ucSteps = c_ucTestSteps ; } else)",
    "insertText": "if(Ptr(pCurrent)->m_pRight != NULL && Ptr(Ptr(pCurrent)->m_pRight)->m_pRight != NULL && Ptr(Ptr(Ptr(pCurrent)->m_pRight)->m_pRight)->m_uiLevel == Ptr(pCurrent)->m_uiLevel)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pLeft)",
    "insertText": "Ptr(pCurrent)->m_pRight = Ptr(pSave)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ucSteps = c_ucTestSteps ; })",
    "insertText": "if(--ucSteps == 0)"
  },
  {
    "label": "iterator_base()",
    "kind": "Method",
    "detail": "Function (} } template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::)",
    "insertText": "iterator_base(CNodeReference pNode, const CPool* pPool) : m_pNode(pNode), m_pPool(pPool)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::iterator_base& CMap<TKey,TValue,TCompare,bUseCustomAllocator>::)",
    "insertText": "operator(void)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(m_pNode != NULL)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (CNodeReference pLastNode = NULL ;)",
    "insertText": "while(m_pNode != NULL && pLastNode == Ptr( )->m_pRight)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (m_pParent)",
    "insertText": "Ptr()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(this)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (CNodeReference pLastNode = NULL ;)",
    "insertText": "while(m_pNode != NULL && pLastNode == Ptr( )->m_pLeft)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE bool CMap<TKey,TValue,TCompare,bUseCustomAllocator>::)",
    "insertText": "operator(const iterator_base& cRight)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::CNode* CMap<TKey,TValue,TCompare,bUseCustomAllocator>::)",
    "insertText": "Ptr(void)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::)",
    "insertText": "iterator(CNodeReference pNode, const CPool* pPool) : iterator_base(pNode, pPool)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::)",
    "insertText": "iterator(const iterator& cRight) : iterator_base(cRight.m_pNode, cRight.m_pPool)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::)",
    "insertText": "const_iterator(CNodeReference pNode, const CPool* pPool) : iterator_base(pNode, pPool)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::)",
    "insertText": "const_iterator(const iterator& cRight) : iterator_base(((const_iterator*)&cRight)->m_pNode, ((const_iterator*)&cRight)->m_pPool)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::)",
    "insertText": "const_iterator(const const_iterator& cRight) : iterator_base(cRight.m_pNode, cRight.m_pPool)"
  },
  {
    "label": "CNode()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> ST_INLINE CMap<TKey,TValue,TCompare,bUseCustomAllocator>::)",
    "insertText": "CNode(const TKey& tKey, CNodeReference pParent) : first(tKey), m_pLeft(NULL), m_pRight(NULL), m_pParent(pParent), m_uiLevel(0)"
  },
  {
    "label": "DeleteChildren()",
    "kind": "Method",
    "detail": "Function (} template<class TKey,class TValue,class TCompare,bool bUseCustomAllocator> void CMap<TKey,TValue,TCompare,bUseCustomAllocator>::)",
    "insertText": "DeleteChildren(CMap* pMap)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (pMap ->)",
    "insertText": "Deallocate(m_pLeft)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(m_pRight != NULL)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (pMap ->)",
    "insertText": "Deallocate(m_pRight)"
  }
]