[
  {
    "label": "Mat2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mat2"
  },
  {
    "label": "Vec2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Vec2"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_VEC2_HAS_BEEN_INCLUDED # define OPENVDB_MATH_VEC2_HAS_BEEN_INCLUDED # include<openvdb / Exceptions . h> # include \" Math . h \" # include \" Tuple . h \" # include<algorithm> # include<cmath> # include<type_traits> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { template<T> class Mat2 ; template<T> class Vec2 : public Tuple<2,T> { public : using value_type = T ; using ValueType = T ; # if OPENVDB_ABI_VERSION_NUMBER> = 8)",
    "insertText": "Vec2()"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "Vec2(T val)"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = this -> mm [ 1 ] = val ; })",
    "insertText": "Vec2(T x, T y)"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = x ; this -> mm [ 1 ] = y ; } template<Source>)",
    "insertText": "Vec2(Source *a)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = static_cast<)",
    "insertText": "T(a[0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] = static_cast<)",
    "insertText": "T(a[1])"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (} template<Source>)",
    "insertText": "Vec2(const Tuple<2, Source> &t)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = static_cast<)",
    "insertText": "T(t[0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] = static_cast<)",
    "insertText": "T(t[1])"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (} template<Other>)",
    "insertText": "Vec2(Other val, typename std::enable_if<std::is_arithmetic<Other>::value, Conversion>::type = Conversion{})"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = this -> mm [ 1 ] = static_cast<)",
    "insertText": "T(val)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "x()"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = x ; this -> mm [ 1 ] = y ; return* this ; } const Vec2<T>&)",
    "insertText": "setZero()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = 0 ; this -> mm [ 1 ] = 0 ; return* this ; } template<Source> const Vec2<T>&)",
    "insertText": "operator(const Vec2<Source> &v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v [ 0 ] ; this -> mm [ 1 ] = v [ 1 ] ; return* this ; } bool)",
    "insertText": "operator(const Vec2<T> &v)"
  },
  {
    "label": "eq()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "eq(const Vec2<T> &v, T eps = static_cast<T>(1.0e-7))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Vec2<T>)",
    "insertText": "operator()"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} template<T0,T1> const Vec2<T>&)",
    "insertText": "add(const Vec2<T0> &v1, const Vec2<T1> &v2)"
  },
  {
    "label": "sub()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v1 [ 0 ] + v2 [ 0 ] ; this -> mm [ 1 ] = v1 [ 1 ] + v2 [ 1 ] ; return* this ; } template<T0,T1> const Vec2<T>&)",
    "insertText": "sub(const Vec2<T0> &v1, const Vec2<T1> &v2)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v1 [ 0 ] - v2 [ 0 ] ; this -> mm [ 1 ] = v1 [ 1 ] - v2 [ 1 ] ; return* this ; } template<T0,T1> const Vec2<T>&)",
    "insertText": "scale(T0 scalar, const Vec2<T1> &v)"
  },
  {
    "label": "div()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = scalar* v [ 0 ] ; this -> mm [ 1 ] = scalar* v [ 1 ] ; return* this ; } template<T0,T1> const Vec2<T>&)",
    "insertText": "div(T0 scalar, const Vec2<T1> &v)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] = v [ 0 ] / scalar ; this -> mm [ 1 ] = v [ 1 ] / scalar ; return* this ; } T)",
    "insertText": "dot(const Vec2<T> &v)"
  },
  {
    "label": "lengthSqr()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "lengthSqr()"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (} const Vec2<T>&)",
    "insertText": "exp()"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] =)",
    "insertText": "exp(this->mm[0])"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] =)",
    "insertText": "exp(this->mm[1])"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] =)",
    "insertText": "log(this->mm[0])"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 1 ] =)",
    "insertText": "log(this->mm[1])"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (T d =)",
    "insertText": "length()"
  },
  {
    "label": "unit()",
    "kind": "Method",
    "detail": "Function (T d ; return)",
    "insertText": "unit(eps, d)"
  },
  {
    "label": "unit()",
    "kind": "Method",
    "detail": "Function (} Vec2<T>)",
    "insertText": "unit(T eps, T& len)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"Normalizing null 2-vector\")"
  },
  {
    "label": "unitSafe()",
    "kind": "Method",
    "detail": "Function (} return* this / len ; } Vec2<T>)",
    "insertText": "unitSafe()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<S> const Vec2<T>&)",
    "insertText": "operator(S scalar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ]* = scalar ; this -> mm [ 1 ]* = scalar ; return* this ; } template<S> const Vec2<T>&)",
    "insertText": "operator(const Vec2<S> &v1)"
  },
  {
    "label": "numRows()",
    "kind": "Method",
    "detail": "Function (this -> mm [ 0 ] - = v1 [ 0 ] ; this -> mm [ 1 ] - = v1 [ 1 ] ; return* this ; } unsigned)",
    "insertText": "numRows()"
  },
  {
    "label": "projection()",
    "kind": "Method",
    "detail": "Function (} Vec2<T>)",
    "insertText": "projection(const Vec2<T> &onto, T eps = static_cast<T>(1.0e-8))"
  },
  {
    "label": "getArbPerpendicular()",
    "kind": "Method",
    "detail": "Function (} Vec2<T>)",
    "insertText": "getArbPerpendicular()"
  },
  {
    "label": "zero()",
    "kind": "Method",
    "detail": "Function (} Vec2<T>)",
    "insertText": "zero()"
  },
  {
    "label": "ones()",
    "kind": "Method",
    "detail": "Function (} Vec2<T>)",
    "insertText": "ones()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<S,T> Vec2<promote<S,T>::type>)",
    "insertText": "operator(S scalar, const Vec2<T> &v)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec2<promote<S,T>::type>)",
    "insertText": "result(v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (result* = scalar ; return result ; } template<T0,T1> Vec2<promote<T0,T1>::type>)",
    "insertText": "operator(const Vec2<T0> &v0, const Vec2<T1> &v1)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec2<promote<T0,T1>::type>)",
    "insertText": "result(v0[0] * v1[0], v0[1] * v1[1])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<S,T> Vec2<promote<S,T>::type>)",
    "insertText": "operator(const Vec2<T> &v, S scalar)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec2<promote<T0,T1>::type>)",
    "insertText": "result(v0[0] / v1[0], v0[1] / v1[1])"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Vec2<promote<T0,T1>::type>)",
    "insertText": "result(v0)"
  },
  {
    "label": "angle()",
    "kind": "Method",
    "detail": "Function (result - = scalar ; return result ; } template<T> T)",
    "insertText": "angle(const Vec2<T> &v1, const Vec2<T> &v2)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (T c = v1 .)",
    "insertText": "dot(v2)"
  },
  {
    "label": "isApproxEqual()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "isApproxEqual(const Vec2<T>& a, const Vec2<T>& b)"
  },
  {
    "label": "isApproxEqual()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "isApproxEqual(const Vec2<T>& a, const Vec2<T>& b, const Vec2<T>& eps)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec2<T>)",
    "insertText": "Abs(const Vec2<T>& v)"
  },
  {
    "label": "orthonormalize()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "orthonormalize(Vec2<T> &v1, Vec2<T> &v2)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (v1 .)",
    "insertText": "normalize()"
  },
  {
    "label": "minComponent()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec2<T>)",
    "insertText": "minComponent(const Vec2<T> &v1, const Vec2<T> &v2)"
  },
  {
    "label": "maxComponent()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec2<T>)",
    "insertText": "maxComponent(const Vec2<T> &v1, const Vec2<T> &v2)"
  },
  {
    "label": "Exp()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec2<T>)",
    "insertText": "Exp(Vec2<T> v)"
  },
  {
    "label": "Log()",
    "kind": "Method",
    "detail": "Function (} template<T> Vec2<T>)",
    "insertText": "Log(Vec2<T> v)"
  }
]