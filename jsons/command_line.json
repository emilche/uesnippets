[
  {
    "label": "DuplicateSwitchHandler",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DuplicateSwitchHandler"
  },
  {
    "label": "FilePath",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FilePath"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "NoProgram",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "NoProgram"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_COMMAND_LINE_H_ # define BASE_COMMAND_LINE_H_ # include<stddef . h> # include<functional> # include<map> # include<memory> # include<string> # include<vector> # include \" base / base_export . h \" # include \" base / strings / string_piece . h \" # include \" build / build_config . h \" namespace base { class DuplicateSwitchHandler ; class FilePath ; class BASE_EXPORT CommandLine { public : # if)",
    "insertText": "BUILDFLAG(IS_WIN)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# elif)",
    "insertText": "BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)"
  },
  {
    "label": "CommandLine()",
    "kind": "Method",
    "detail": "Function (# endif using CharType = StringType::value_type ; using StringPieceType = base::BasicStringPiece<CharType> ; using StringVector = std::vector<StringType> ; using SwitchMap = std::map<std::string,StringType,std::less<>> ; enum NoProgram { NO_PROGRAM } ;)",
    "insertText": "CommandLine(NoProgram no_program)"
  },
  {
    "label": "CommandLine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CommandLine(const FilePath& program)"
  },
  {
    "label": "CommandLine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CommandLine(int argc, const CharType* const* argv)"
  },
  {
    "label": "CommandLine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CommandLine(const StringVector& argv)"
  },
  {
    "label": "CommandLine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CommandLine(const CommandLine& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CommandLine&)",
    "insertText": "operator(const CommandLine& other)"
  },
  {
    "label": "CommandLine()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CommandLine()"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_WIN) static void set_slash_is_not_a_switch()"
  },
  {
    "label": "InitUsingArgvForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitUsingArgvForTesting(int argc, const char* const* argv)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (# endif bool)",
    "insertText": "Init(int argc, const char* const* argv)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "ForCurrentProcess()",
    "kind": "Method",
    "detail": "Function (CommandLine*)",
    "insertText": "ForCurrentProcess()"
  },
  {
    "label": "InitializedForCurrentProcess()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "InitializedForCurrentProcess()"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_WIN) static CommandLine FromString(StringPieceType command_line)"
  },
  {
    "label": "InitFromArgv()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "InitFromArgv(int argc, const CharType* const* argv)"
  },
  {
    "label": "InitFromArgv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitFromArgv(const StringVector& argv)"
  },
  {
    "label": "GetCommandLineString()",
    "kind": "Method",
    "detail": "Function (StringType)",
    "insertText": "GetCommandLineString()"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_WIN) StringType GetCommandLineStringForShell()"
  },
  {
    "label": "GetCommandLineStringWithUnsafeInsertSequences()",
    "kind": "Method",
    "detail": "Function (StringType)",
    "insertText": "GetCommandLineStringWithUnsafeInsertSequences()"
  },
  {
    "label": "GetArgumentsString()",
    "kind": "Method",
    "detail": "Function (# endif StringType)",
    "insertText": "GetArgumentsString()"
  },
  {
    "label": "argv()",
    "kind": "Method",
    "detail": "Function (const StringVector&)",
    "insertText": "argv()"
  },
  {
    "label": "SetProgram()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetProgram(const FilePath& program)"
  },
  {
    "label": "HasSwitch()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasSwitch(StringPiece switch_string)"
  },
  {
    "label": "HasSwitch()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasSwitch(const char switch_constant[])"
  },
  {
    "label": "GetSwitchValueASCII()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "GetSwitchValueASCII(StringPiece switch_string)"
  },
  {
    "label": "GetSwitchValuePath()",
    "kind": "Method",
    "detail": "Function (FilePath)",
    "insertText": "GetSwitchValuePath(StringPiece switch_string)"
  },
  {
    "label": "GetSwitchValueNative()",
    "kind": "Method",
    "detail": "Function (StringType)",
    "insertText": "GetSwitchValueNative(StringPiece switch_string)"
  },
  {
    "label": "GetSwitches()",
    "kind": "Method",
    "detail": "Function (const SwitchMap&)",
    "insertText": "GetSwitches()"
  },
  {
    "label": "AppendSwitchPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendSwitchPath(StringPiece switch_string, const FilePath& path)"
  },
  {
    "label": "AppendSwitchNative()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendSwitchNative(StringPiece switch_string, StringPieceType value)"
  },
  {
    "label": "AppendSwitchASCII()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendSwitchASCII(StringPiece switch_string, StringPiece value)"
  },
  {
    "label": "RemoveSwitch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveSwitch(const base::StringPiece switch_key_without_prefix)"
  },
  {
    "label": "CopySwitchesFrom()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopySwitchesFrom(const CommandLine& source, const char* const switches[], size_t count)"
  },
  {
    "label": "GetArgs()",
    "kind": "Method",
    "detail": "Function (StringVector)",
    "insertText": "GetArgs()"
  },
  {
    "label": "AppendArg()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendArg(StringPiece value)"
  },
  {
    "label": "AppendArgPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendArgPath(const FilePath& value)"
  },
  {
    "label": "AppendArgNative()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendArgNative(StringPieceType value)"
  },
  {
    "label": "AppendArguments()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendArguments(const CommandLine& other, bool include_program)"
  },
  {
    "label": "PrependWrapper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrependWrapper(StringPieceType wrapper)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_WIN) void ParseFromString(StringPieceType command_line)"
  },
  {
    "label": "HasSingleArgumentSwitch()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasSingleArgumentSwitch()"
  },
  {
    "label": "AppendSwitchesAndArguments()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AppendSwitchesAndArguments(const StringVector& argv)"
  },
  {
    "label": "GetArgumentsStringInternal()",
    "kind": "Method",
    "detail": "Function (StringType)",
    "insertText": "GetArgumentsStringInternal(bool allow_unsafe_insert_sequences)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_WIN) void ParseAsSingleArgument(const StringType& single_arg_switch_string)"
  },
  {
    "label": "ResolveDuplicate()",
    "kind": "Method",
    "detail": "Function (StringPieceType raw_command_line_string_ ; bool has_single_argument_switch_ = false ; # endif CommandLine* current_process_commandline_ ; StringVector argv_ ; SwitchMap switches_ ; ptrdiff_t begin_args_ ; } ; class BASE_EXPORT DuplicateSwitchHandler { public : void)",
    "insertText": "ResolveDuplicate(base::StringPiece key, CommandLine::StringPieceType new_value, CommandLine::StringType& out_value)"
  },
  {
    "label": "DuplicateSwitchHandler()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "DuplicateSwitchHandler()"
  }
]