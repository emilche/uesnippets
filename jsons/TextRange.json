[
  {
    "label": "STextPosition",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "STextPosition"
  },
  {
    "label": "STextRange",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "STextRange"
  },
  {
    "label": "Invalidate()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" uLang / Common / Common . h \" # include \" uLang / Common / Misc / MathUtils . h \" namespace uLang { struct STextPosition { public : uint32_t _Row = uint32_invalid ; uint32_t _Column = uint32_invalid ; ULANG_FORCEINLINE void)",
    "insertText": "Invalidate()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (_Row = _Column = uint32_invalid ; } ULANG_FORCEINLINE void)",
    "insertText": "Reset()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (_Row = _Column = 0 u ; } ULANG_FORCEINLINE bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE bool)",
    "insertText": "operator(const STextPosition& Other)"
  },
  {
    "label": "BeginRow()",
    "kind": "Method",
    "detail": "Function (} } ; struct STextRange { public : uint32_t)",
    "insertText": "BeginRow()"
  },
  {
    "label": "SetBeginColumn()",
    "kind": "Method",
    "detail": "Function (_Begin . _Row = Row ; } void)",
    "insertText": "SetBeginColumn(uint32_t Col)"
  },
  {
    "label": "SetEndRow()",
    "kind": "Method",
    "detail": "Function (_Begin . _Column = Col ; } void)",
    "insertText": "SetEndRow(uint32_t Row)"
  },
  {
    "label": "SetEndColumn()",
    "kind": "Method",
    "detail": "Function (_End . _Row = Row ; } void)",
    "insertText": "SetEndColumn(uint32_t Col)"
  },
  {
    "label": "STextRange()",
    "kind": "Method",
    "detail": "Function (_End . _Column = Col ; } ULANG_FORCEINLINE)",
    "insertText": "STextRange()"
  },
  {
    "label": "STextRange()",
    "kind": "Method",
    "detail": "Function (uint32_invalid,uint32_invalid },_End { uint32_invalid,uint32_invalid } { } ULANG_FORCEINLINE)",
    "insertText": "STextRange(ENoInit)"
  },
  {
    "label": "STextRange()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE)",
    "insertText": "STextRange(uint32_t BeginRow, uint32_t BeginColumn, uint32_t EndRow, uint32_t EndColumn)"
  },
  {
    "label": "STextRange()",
    "kind": "Method",
    "detail": "Function (BeginRow,BeginColumn },_End { EndRow,EndColumn } { } ULANG_FORCEINLINE)",
    "insertText": "STextRange(const STextPosition& Begin, const STextPosition& End) : _Begin(Begin), _End(End)"
  },
  {
    "label": "STextRange()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE)",
    "insertText": "STextRange(const STextPosition& BeginAndEnd) : _Begin(BeginAndEnd), _End(BeginAndEnd)"
  },
  {
    "label": "GetBegin()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE STextPosition)",
    "insertText": "GetBegin()"
  },
  {
    "label": "SetEnd()",
    "kind": "Method",
    "detail": "Function (_Begin = Begin ; } ULANG_FORCEINLINE void)",
    "insertText": "SetEnd(const STextPosition& End)"
  },
  {
    "label": "InvalidateEnd()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE void)",
    "insertText": "InvalidateEnd()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "IsOrdered()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE bool)",
    "insertText": "IsOrdered()"
  },
  {
    "label": "IsRowSingle()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE bool)",
    "insertText": "IsRowSingle()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE bool)",
    "insertText": "operator(const STextRange & Other)"
  },
  {
    "label": "Overlaps()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE bool)",
    "insertText": "Overlaps(const STextRange& Other)"
  },
  {
    "label": "IsContainedIn()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE bool)",
    "insertText": "IsContainedIn(const STextRange& ContainingRange)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ULANG_FORCEINLINE STextRange&)",
    "insertText": "operator(const STextRange& Other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (_Begin = Other . _Begin ; })",
    "insertText": "if(Other._End > _End)"
  }
]