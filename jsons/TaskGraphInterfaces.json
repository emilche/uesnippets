[
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "FRenderThreadStatics",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRenderThreadStatics"
  },
  {
    "label": "FAutoConsoleTaskPriority",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FAutoConsoleTaskPriority"
  },
  {
    "label": "FTaskGraphInterface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTaskGraphInterface"
  },
  {
    "label": "FBaseGraphTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBaseGraphTask"
  },
  {
    "label": "FTaskGraphBlockAllocationTag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTaskGraphBlockAllocationTag"
  },
  {
    "label": "TGraphTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TGraphTask"
  },
  {
    "label": "FConstructor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConstructor"
  },
  {
    "label": "FGraphEventImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGraphEventImpl"
  },
  {
    "label": "FTaskBlockAllocationTag",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTaskBlockAllocationTag"
  },
  {
    "label": "FNamedTaskThread",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNamedTaskThread"
  },
  {
    "label": "FTaskThreadBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTaskThreadBase"
  },
  {
    "label": "FTaskThreadAnyThread",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTaskThreadAnyThread"
  },
  {
    "label": "FGraphEvent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGraphEvent"
  },
  {
    "label": "FTaskGraphImplementation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTaskGraphImplementation"
  },
  {
    "label": "FTaskGraphCompatibilityImplementation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTaskGraphCompatibilityImplementation"
  },
  {
    "label": "ELifeStage",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ELifeStage"
  },
  {
    "label": "TRefCountPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRefCountPtr"
  },
  {
    "label": "TLockFreeClassAllocator_TLSCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TLockFreeClassAllocator_TLSCache"
  },
  {
    "label": "FGraphEventAndSmallTaskStorage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGraphEventAndSmallTaskStorage"
  },
  {
    "label": "FReturnGraphTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FReturnGraphTask"
  },
  {
    "label": "FCustomStatIDGraphTaskBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCustomStatIDGraphTaskBase"
  },
  {
    "label": "FNullGraphTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNullGraphTask"
  },
  {
    "label": "FTriggerEventGraphTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTriggerEventGraphTask"
  },
  {
    "label": "FSimpleDelegateGraphTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSimpleDelegateGraphTask"
  },
  {
    "label": "FDelegateGraphTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDelegateGraphTask"
  },
  {
    "label": "TFunctionGraphTaskImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TFunctionGraphTaskImpl"
  },
  {
    "label": "FFunctionGraphTask",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFunctionGraphTask"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / AssertionMacros . h \" # include \" Containers / ContainerAllocationPolicies . h \" # include \" Containers / Array . h \" # include \" Containers / UnrealString . h \" # include \" Templates / Function . h \" # include \" Delegates / Delegate . h \" # include \" HAL / ThreadSafeCounter . h \" # include \" Containers / LockFreeList . h \" # include \" Stats / Stats . h \" # include \" HAL / IConsoleManager . h \" # include \" HAL / Event . h \" # include \" HAL / LowLevelMemTracker . h \" # include \" Templates / RefCounting . h \" # include \" Containers / LockFreeFixedSizeAllocator . h \" # include \" Experimental / ConcurrentLinearAllocator . h \" # include \" Misc / MemStack . h \" # include \" Misc / Timeout . h \" # include \" Templates / Atomic . h \" # include \" ProfilingDebugging / MetadataTrace . h \" # include \" Async / Fundamental / Task . h \" # include \" Async / TaskGraphFwd . h \" # include \" Async / TaskTrace . h \" # include \" Tasks / TaskPrivate . h \" # include \" Async / InheritedContext . h \" # if !)",
    "insertText": "defined(STATS) #error \"STATS must be defined as either zero or one.\" #endif #define checkThreadGraph checkSlow DECLARE_STATS_GROUP(TEXT(\"Task Graph Tasks\"), STATGROUP_TaskGraphTasks, STATCAT_Advanced)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"FReturnGraphTask\"), STAT_FReturnGraphTask, STATGROUP_TaskGraphTasks, CORE_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"FTriggerEventGraphTask\"), STAT_FTriggerEventGraphTask, STATGROUP_TaskGraphTasks, CORE_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"ParallelFor\"), STAT_ParallelFor, STATGROUP_TaskGraphTasks, CORE_API)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"ParallelForTask\"), STAT_ParallelForTask, STATGROUP_TaskGraphTasks, CORE_API)"
  },
  {
    "label": "GetRenderThread()",
    "kind": "Method",
    "detail": "Function (namespace ENamedThreads { enum Type : int32 { UnusedAnchor = - 1,RHIThread,GameThread,ActualRenderingThread = GameThread + 1,AnyThread = 0 xff,MainQueue = 0 x000,LocalQueue = 0 x100,NumQueues = 2,ThreadIndexMask = 0 xff,QueueIndexMask = 0 x100,QueueIndexShift = 8,NormalTaskPriority = 0 x000,HighTaskPriority = 0 x200,NumTaskPriorities = 2,TaskPriorityMask = 0 x200,TaskPriorityShift = 9,NormalThreadPriority = 0 x000,HighThreadPriority = 0 x400,BackgroundThreadPriority = 0 x800,NumThreadPriorities = 3,ThreadPriorityMask = 0 xC00,ThreadPriorityShift = 1 0,GameThread_Local = GameThread | LocalQueue,ActualRenderingThread_Local = ActualRenderingThread | LocalQueue,AnyHiPriThreadNormalTask = AnyThread | HighThreadPriority | NormalTaskPriority,AnyHiPriThreadHiPriTask = AnyThread | HighThreadPriority | HighTaskPriority,AnyNormalThreadNormalTask = AnyThread | NormalThreadPriority | NormalTaskPriority,AnyNormalThreadHiPriTask = AnyThread | NormalThreadPriority | HighTaskPriority,AnyBackgroundThreadNormalTask = AnyThread | BackgroundThreadPriority | NormalTaskPriority,AnyBackgroundHiPriTask = AnyThread | BackgroundThreadPriority | HighTaskPriority,} ; struct FRenderThreadStatics { private : TAtomic<Type> RenderThread ; TAtomic<Type> RenderThread_Local ; Type)",
    "insertText": "GetRenderThread()"
  },
  {
    "label": "GetRenderThread_Local()",
    "kind": "Method",
    "detail": "Function (Type)",
    "insertText": "GetRenderThread_Local()"
  },
  {
    "label": "SetRenderThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetRenderThread(Type Thread)"
  },
  {
    "label": "SetRenderThread_Local()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetRenderThread_Local(Type Thread)"
  },
  {
    "label": "Store()",
    "kind": "Method",
    "detail": "Function (FRenderThreadStatics::RenderThread .)",
    "insertText": "Store(Thread, EMemoryOrder::Relaxed)"
  },
  {
    "label": "GetThreadIndex()",
    "kind": "Method",
    "detail": "Function (} int32 bHasBackgroundThreads ; int32 bHasHighPriorityThreads ; Type)",
    "insertText": "GetThreadIndex(Type ThreadAndIndex)"
  },
  {
    "label": "GetQueueIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetQueueIndex(Type ThreadAndIndex)"
  },
  {
    "label": "GetTaskPriority()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetTaskPriority(Type ThreadAndIndex)"
  },
  {
    "label": "GetThreadPriorityIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetThreadPriorityIndex(Type ThreadAndIndex)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Result(ThreadAndIndex & ThreadPriorityMask)"
  },
  {
    "label": "SetPriorities()",
    "kind": "Method",
    "detail": "Function (} Type)",
    "insertText": "SetPriorities(Type ThreadAndIndex, int32 PriorityIndex, bool bHiPri)"
  },
  {
    "label": "SetThreadPriority()",
    "kind": "Method",
    "detail": "Function (} Type)",
    "insertText": "SetThreadPriority(Type ThreadAndIndex, Type ThreadPriority)"
  },
  {
    "label": "SetTaskPriority()",
    "kind": "Method",
    "detail": "Function (} Type)",
    "insertText": "SetTaskPriority(Type ThreadAndIndex, Type TaskPriority)"
  },
  {
    "label": "DECLARE_INTRINSIC_TYPE_LAYOUT()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "DECLARE_INTRINSIC_TYPE_LAYOUT(ENamedThreads::Type)"
  },
  {
    "label": "CreateFullHelpText()",
    "kind": "Method",
    "detail": "Function (class FAutoConsoleTaskPriority { FString RawSetting ; FString FullHelpText ; FAutoConsoleVariableRef Variable ; ENamedThreads::Type ThreadPriority ; ENamedThreads::Type TaskPriority ; ENamedThreads::Type TaskPriorityIfForcedToNormalThreadPriority ; FString)",
    "insertText": "CreateFullHelpText(const TCHAR* Name, const TCHAR* OriginalHelp)"
  },
  {
    "label": "ConfigStringFromPriorities()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ConfigStringFromPriorities(ENamedThreads::Type InThreadPriority, ENamedThreads::Type InTaskPriority, ENamedThreads::Type InTaskPriorityBackup)"
  },
  {
    "label": "OnSettingChanged()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnSettingChanged(IConsoleVariable* Variable)"
  },
  {
    "label": "FAutoConsoleTaskPriority()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FAutoConsoleTaskPriority(const TCHAR* Name, const TCHAR* Help, ENamedThreads::Type DefaultThreadPriority, ENamedThreads::Type DefaultTaskPriority, ENamedThreads::Type DefaultTaskPriorityIfForcedToNormalThreadPriority = ENamedThreads::UnusedAnchor) : RawSetting(ConfigStringFromPriorities(DefaultThreadPriority, DefaultTaskPriority, DefaultTaskPriorityIfForcedToNormalThreadPriority)) , FullHelpText(CreateFullHelpText(Name, Help)) , Variable(Name, RawSetting, *FullHelpText, FConsoleVariableDelegate::CreateRaw(this, &FAutoConsoleTaskPriority::OnSettingChanged), ECVF_Default) , ThreadPriority(DefaultThreadPriority) , TaskPriority(DefaultTaskPriority) , TaskPriorityIfForcedToNormalThreadPriority(DefaultTaskPriorityIfForcedToNormalThreadPriority)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} ENamedThreads::Type)",
    "insertText": "Get(ENamedThreads::Type Thread = ENamedThreads::AnyThread)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ThreadPriority == ENamedThreads::BackgroundThreadPriority && !ENamedThreads::bHasBackgroundThreads)"
  },
  {
    "label": "SetPriorities()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "SetPriorities(Thread, ThreadPriority, TaskPriority)"
  },
  {
    "label": "GetTraceIds()",
    "kind": "Method",
    "detail": "Function (} } ; namespace ESubsequentsMode { enum Type { TrackSubsequents,FireAndForget } ; } typedef TArray<FGraphEventRef,TInlineAllocator<4>> FGraphEventArray ; TArray<TaskTrace::FId>)",
    "insertText": "GetTraceIds(const FGraphEventArray& Tasks)"
  },
  {
    "label": "QueueTask()",
    "kind": "Method",
    "detail": "Function (class FTaskGraphInterface { class FBaseGraphTask ; # if TASKGRAPH_NEW_FRONTEND UE::Tasks::Private::FTaskBase ; # endif void)",
    "insertText": "QueueTask(class FBaseGraphTask* Task, bool bWakeUpWorker, ENamedThreads::Type ThreadToExecuteOn, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)"
  },
  {
    "label": "FTaskGraphInterface()",
    "kind": "Method",
    "detail": "Function (public : ~)",
    "insertText": "FTaskGraphInterface()"
  },
  {
    "label": "Startup()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Startup(int32 NumThreads)"
  },
  {
    "label": "Shutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Shutdown()"
  },
  {
    "label": "IsRunning()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsRunning()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (FTaskGraphInterface&)",
    "insertText": "Get()"
  },
  {
    "label": "IsMultithread()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsMultithread()"
  },
  {
    "label": "GetCurrentThreadIfKnown()",
    "kind": "Method",
    "detail": "Function (ENamedThreads::Type)",
    "insertText": "GetCurrentThreadIfKnown(bool bLocalQueue = false)"
  },
  {
    "label": "IsCurrentThreadKnown()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsCurrentThreadKnown()"
  },
  {
    "label": "GetNumWorkerThreads()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumWorkerThreads()"
  },
  {
    "label": "GetNumForegroundThreads()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumForegroundThreads()"
  },
  {
    "label": "GetNumBackgroundThreads()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumBackgroundThreads()"
  },
  {
    "label": "IsThreadProcessingTasks()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsThreadProcessingTasks(ENamedThreads::Type ThreadToCheck)"
  },
  {
    "label": "AttachToThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AttachToThread(ENamedThreads::Type CurrentThread)"
  },
  {
    "label": "ProcessThreadUntilIdle()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "ProcessThreadUntilIdle(ENamedThreads::Type CurrentThread)"
  },
  {
    "label": "ProcessThreadUntilRequestReturn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessThreadUntilRequestReturn(ENamedThreads::Type CurrentThread)"
  },
  {
    "label": "RequestReturn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RequestReturn(ENamedThreads::Type CurrentThread)"
  },
  {
    "label": "WaitUntilTasksComplete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitUntilTasksComplete(const FGraphEventArray& Tasks, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)"
  },
  {
    "label": "TriggerEventWhenTasksComplete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TriggerEventWhenTasksComplete(FEvent* InEvent, const FGraphEventArray& Tasks, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread, ENamedThreads::Type TriggerThread = ENamedThreads::AnyHiPriThreadHiPriTask)"
  },
  {
    "label": "WaitUntilTaskCompletes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitUntilTaskCompletes(const FGraphEventRef& Task, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)"
  },
  {
    "label": "WaitUntilTasksComplete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitUntilTasksComplete({ Task }, CurrentThreadIfKnown)"
  },
  {
    "label": "WaitUntilTaskCompletes()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "WaitUntilTaskCompletes(FGraphEventRef&& Task, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)"
  },
  {
    "label": "WaitUntilTasksComplete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitUntilTasksComplete({ MoveTemp(Task) }, CurrentThreadIfKnown)"
  },
  {
    "label": "TriggerEventWhenTaskCompletes()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TriggerEventWhenTaskCompletes(FEvent* InEvent, const FGraphEventRef& Task, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread, ENamedThreads::Type TriggerThread = ENamedThreads::AnyHiPriThreadHiPriTask)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (FGraphEventArray Prerequistes ; Prerequistes .)",
    "insertText": "Add(Task)"
  },
  {
    "label": "TriggerEventWhenTasksComplete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TriggerEventWhenTasksComplete(InEvent, Prerequistes, CurrentThreadIfKnown, TriggerThread)"
  },
  {
    "label": "FindWork()",
    "kind": "Method",
    "detail": "Function (} FBaseGraphTask*)",
    "insertText": "FindWork(ENamedThreads::Type ThreadInNeed)"
  },
  {
    "label": "StallForTuning()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StallForTuning(int32 Index, bool Stall)"
  },
  {
    "label": "AddShutdownCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddShutdownCallback(TFunction<void()>& Callback)"
  },
  {
    "label": "WakeNamedThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WakeNamedThread(ENamedThreads::Type ThreadToWake)"
  },
  {
    "label": "BroadcastSlow_OnlyUseForSpecialPurposes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BroadcastSlow_OnlyUseForSpecialPurposes(bool bDoTaskThreads, bool bDoBackgroundThreads, TFunction<void(ENamedThreads::Type CurrentThread)>& Callback)"
  },
  {
    "label": "FBaseGraphTask()",
    "kind": "Method",
    "detail": "Function (} ; struct FTaskGraphBlockAllocationTag : FDefaultBlockAllocationTag { uint32 BlockSize = 6 4* 1 0 2 4 ; bool AllowOversizedBlocks = false ; bool RequiresAccurateSize = false ; bool InlineBlockAllocation = true ; const char* TagName = \" TaskGraphLinear \" ; using Allocator = TBlockAllocationCache<BlockSize,FAlignedAllocator> ; } ; # if TASKGRAPH_NEW_FRONTEND class FBaseGraphTask : public UE::Tasks::Private::FTaskBase { public :)",
    "insertText": "FBaseGraphTask(const FGraphEventArray* InPrerequisites) : FTaskBase( 1, false)"
  },
  {
    "label": "AddPrerequisites()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddPrerequisites(*InPrerequisites, false)"
  },
  {
    "label": "UnlockPrerequisites()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UnlockPrerequisites()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Init(const TCHAR* InDebugName, UE::Tasks::ETaskPriority InPriority, UE::Tasks::EExtendedTaskPriority InExtendedPriority, UE::Tasks::ETaskFlags InTaskFlags = UE::Tasks::ETaskFlags::None)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(InDebugName, InPriority, InExtendedPriority, InTaskFlags)"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Unlock(ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)"
  },
  {
    "label": "TryLaunch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TryLaunch(0)"
  },
  {
    "label": "Execute()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Execute(TArray<FBaseGraphTask*>& NewTasks, ENamedThreads::Type CurrentThread, bool bDeleteOnCompletion)"
  },
  {
    "label": "ReleaseInternalReference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseInternalReference()"
  },
  {
    "label": "GetCompletionEvent()",
    "kind": "Method",
    "detail": "Function (} FGraphEventRef)",
    "insertText": "GetCompletionEvent()"
  },
  {
    "label": "AddPrerequisites()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddPrerequisites(*NestedTask)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "checkSlow(UE::Tasks::Private::GetCurrentTask() == this)"
  },
  {
    "label": "AddNested()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddNested(*NestedTask)"
  },
  {
    "label": "IsComplete()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "IsComplete()"
  },
  {
    "label": "CreateGraphEvent()",
    "kind": "Method",
    "detail": "Function (} FGraphEventRef)",
    "insertText": "CreateGraphEvent()"
  },
  {
    "label": "DispatchSubsequents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DispatchSubsequents(ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddRef()"
  },
  {
    "label": "DispatchSubsequents()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DispatchSubsequents(TArray<FBaseGraphTask*>& NewTasks, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)"
  },
  {
    "label": "DispatchSubsequents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DispatchSubsequents()"
  },
  {
    "label": "SetDebugName()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetDebugName(const TCHAR* InDebugName)"
  },
  {
    "label": "Wait()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Wait(ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)"
  },
  {
    "label": "WaitWithNamedThreadsSupport()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "WaitWithNamedThreadsSupport()"
  },
  {
    "label": "GetThreadToExecuteOn()",
    "kind": "Method",
    "detail": "Function (} ENamedThreads::Type)",
    "insertText": "GetThreadToExecuteOn()"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (} } ; template<TTask> class TGraphTask final : public TConcurrentLinearObject<TGraphTask<TTask>,FTaskGraphBlockAllocationTag>,public FBaseGraphTask { public : class FConstructor { public :)",
    "insertText": "UE_NONCOPYABLE(FConstructor)"
  },
  {
    "label": "ConstructAndDispatchWhenReady()",
    "kind": "Method",
    "detail": "Function (template<. . . T> FGraphEventRef)",
    "insertText": "ConstructAndDispatchWhenReady(T&&... Args)"
  },
  {
    "label": "ConstructAndHoldImpl()",
    "kind": "Method",
    "detail": "Function (FGraphEventRef Ref {)",
    "insertText": "ConstructAndHoldImpl(Forward<T>(Args)...)"
  },
  {
    "label": "TryLaunch()",
    "kind": "Method",
    "detail": "Function (Ref ->)",
    "insertText": "TryLaunch(sizeof(TGraphTask))"
  },
  {
    "label": "Created()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Created(Task->GetTraceId(), sizeof(*Task))"
  },
  {
    "label": "ConstructAndHoldImpl()",
    "kind": "Method",
    "detail": "Function (} private : template<. . . T> TGraphTask*)",
    "insertText": "ConstructAndHoldImpl(T&&... Args)"
  },
  {
    "label": "TGraphTask()",
    "kind": "Method",
    "detail": "Function (TGraphTask* Task = new)",
    "insertText": "TGraphTask(Prerequisites)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (TTask* TaskObject =)",
    "insertText": "new(&Task->TaskStorage) TTask(Forward<T>(Args)...)"
  },
  {
    "label": "TranslatePriority()",
    "kind": "Method",
    "detail": "Function (UE::Tasks::ETaskPriority Pri ; UE::Tasks::EExtendedTaskPriority ExtPri ; UE::Tasks::)",
    "insertText": "TranslatePriority(TaskObject->GetDesiredThread(), Pri, ExtPri)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (Task ->)",
    "insertText": "Init(Pri, ExtPri)"
  },
  {
    "label": "TGraphTask()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "TGraphTask(const FGraphEventArray* InPrerequisites) : FBaseGraphTask(InPrerequisites)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Init(UE::Tasks::ETaskPriority InPriority, UE::Tasks::EExtendedTaskPriority InExtendedPriority)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(TEXT(\"GraphTask\"), InPriority, InExtendedPriority)"
  },
  {
    "label": "ExecuteTask()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExecuteTask()"
  },
  {
    "label": "GetTypedPtr()",
    "kind": "Method",
    "detail": "Function (FGraphEventRef GraphEventRef { this } ; TTask* TaskObject = TaskStorage .)",
    "insertText": "GetTypedPtr()"
  },
  {
    "label": "DoTask()",
    "kind": "Method",
    "detail": "Function (TaskObject ->)",
    "insertText": "DoTask(TaskObject->GetDesiredThread(), GraphEventRef)"
  },
  {
    "label": "DestructItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItem(TaskObject)"
  },
  {
    "label": "FGraphEventImpl()",
    "kind": "Method",
    "detail": "Function (} private : TTypeCompatibleBytes<TTask> TaskStorage ; } ; class FGraphEventImpl : public FBaseGraphTask { public :)",
    "insertText": "FGraphEventImpl() : FBaseGraphTask(nullptr)"
  },
  {
    "label": "Created()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Created(GetTraceId(), sizeof(*this))"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(TEXT(\"GraphEvent\"), UE::Tasks::ETaskPriority::Normal, UE::Tasks::EExtendedTaskPriority::TaskEvent)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} void* operator)",
    "insertText": "new(size_t Size)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (void operator)",
    "insertText": "delete(void* Ptr)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} } ; using FGraphEventImplAllocator = TLockFreeFixedSizeAllocator_TLSCache<)",
    "insertText": "sizeof(FGraphEventImpl)"
  },
  {
    "label": "GetGraphEventImplAllocator()",
    "kind": "Method",
    "detail": "Function (FGraphEventImplAllocator&)",
    "insertText": "GetGraphEventImplAllocator()"
  },
  {
    "label": "GetGraphEventImplAllocator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetGraphEventImplAllocator().Free(Ptr)"
  },
  {
    "label": "FBaseGraphTask()",
    "kind": "Method",
    "detail": "Function (FGraphEventImpl* GraphEvent = new FGraphEventImpl ; return FGraphEventRef { GraphEvent,false } ; } # else struct FTaskBlockAllocationTag : FDefaultBlockAllocationTag { uint32 BlockSize = 6 4* 1 0 2 4 ; bool AllowOversizedBlocks = false ; bool RequiresAccurateSize = false ; bool InlineBlockAllocation = true ; const char* TagName = \" TaskLinearAllocator \" ; using Allocator = TBlockAllocationCache<BlockSize,FAlignedAllocator> ; } ; class FBaseGraphTask : private UE::FInheritedContextBase { protected :)",
    "insertText": "FBaseGraphTask(int32 InNumberOfPrerequistitesOutstanding) : ThreadToExecuteOn(ENamedThreads::AnyThread) , NumberOfPrerequistitesOutstanding(InNumberOfPrerequistitesOutstanding + 1)"
  },
  {
    "label": "CaptureInheritedContext()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CaptureInheritedContext()"
  },
  {
    "label": "SetThreadToExecuteOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetThreadToExecuteOn(ENamedThreads::Type InThreadToExecuteOn)"
  },
  {
    "label": "checkThreadGraph()",
    "kind": "Method",
    "detail": "Function (ThreadToExecuteOn = InThreadToExecuteOn ;)",
    "insertText": "checkThreadGraph(LifeStage.Increment() == int32(LS_ThreadSet))"
  },
  {
    "label": "PrerequisitesComplete()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PrerequisitesComplete(ENamedThreads::Type CurrentThread, int32 NumAlreadyFinishedPrequistes, bool bUnlock = true)"
  },
  {
    "label": "NumAlreadyFinishedPrequistes()",
    "kind": "Method",
    "detail": "Function (int32 NumToSub =)",
    "insertText": "NumAlreadyFinishedPrequistes(bUnlock ? 1 : 0)"
  },
  {
    "label": "QueueTask()",
    "kind": "Method",
    "detail": "Function (bool bWakeUpWorker = true ;)",
    "insertText": "QueueTask(CurrentThread, bWakeUpWorker)"
  },
  {
    "label": "FBaseGraphTask()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "FBaseGraphTask()"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (# if DO_GUARD_SLOW int32 Stage = LifeStage .)",
    "insertText": "Increment()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif } #)",
    "insertText": "if(UE_BUILD_SHIPPING || UE_BUILD_TEST) static void CORE_API LogPossiblyInvalidSubsequentsTask(const TCHAR* TaskName)"
  },
  {
    "label": "ConditionalQueueTask()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "ConditionalQueueTask(ENamedThreads::Type CurrentThread, bool& bWakeUpWorker)"
  },
  {
    "label": "GetTraceId()",
    "kind": "Method",
    "detail": "Function (bWakeUpWorker = true ; } } TaskTrace::FId)",
    "insertText": "GetTraceId()"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (# if UE_TASK_TRACE_ENABLED return TraceId .)",
    "insertText": "load(std::memory_order_relaxed)"
  },
  {
    "label": "SetTraceId()",
    "kind": "Method",
    "detail": "Function (# else return TaskTrace::InvalidId ; # endif } void)",
    "insertText": "SetTraceId(TaskTrace::FId InTraceId)"
  },
  {
    "label": "GetTaskHandle()",
    "kind": "Method",
    "detail": "Function (# if UE_TASK_TRACE_ENABLED TraceId = InTraceId ; # endif } LowLevelTasks::FTask&)",
    "insertText": "GetTaskHandle()"
  },
  {
    "label": "DeleteTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeleteTask()"
  },
  {
    "label": "RestoreInheritedContext()",
    "kind": "Method",
    "detail": "Function (UE::FInheritedContextScope InheritedContextScope =)",
    "insertText": "RestoreInheritedContext()"
  },
  {
    "label": "ExecuteTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExecuteTask(NewTasks, CurrentThread, bDeleteOnCompletion)"
  },
  {
    "label": "QueueTask()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "QueueTask(ENamedThreads::Type CurrentThreadIfKnown, bool bWakeUpWorker)"
  },
  {
    "label": "Scheduled()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Scheduled(GetTraceId())"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Get().QueueTask(this, bWakeUpWorker, ThreadToExecuteOn, CurrentThreadIfKnown)"
  },
  {
    "label": "AddSubsequent()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AddSubsequent(class FBaseGraphTask* Subsequent)"
  },
  {
    "label": "PushIfNotClosed()",
    "kind": "Method",
    "detail": "Function (bool bSucceeded = SubsequentList .)",
    "insertText": "PushIfNotClosed(Subsequent)"
  },
  {
    "label": "SubsequentAdded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubsequentAdded(GetTraceId(), Subsequent->GetTraceId())"
  },
  {
    "label": "CheckDontCompleteUntilIsEmpty()",
    "kind": "Method",
    "detail": "Function (} return bSucceeded ; } void)",
    "insertText": "CheckDontCompleteUntilIsEmpty()"
  },
  {
    "label": "DontCompleteUntil()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DontCompleteUntil(FGraphEventRef EventToWaitFor)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (EventsToWaitFor .)",
    "insertText": "Emplace(EventToWaitFor)"
  },
  {
    "label": "SubsequentAdded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubsequentAdded(EventToWaitFor->GetTraceId(), GetTraceId())"
  },
  {
    "label": "DispatchSubsequents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DispatchSubsequents(TArray<FBaseGraphTask*>& NewTasks, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread, bool bInternal = false)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Get().WaitUntilTaskCompletes(this, CurrentThreadIfKnown)"
  },
  {
    "label": "SetDebugName()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetDebugName(const TCHAR* Name)"
  },
  {
    "label": "CreateCompletionHandle()",
    "kind": "Method",
    "detail": "Function (# else return TaskTrace::InvalidId ; # endif } FGraphEventRef)",
    "insertText": "CreateCompletionHandle()"
  },
  {
    "label": "FGraphEvent()",
    "kind": "Method",
    "detail": "Function (struct FGraphEventAndSmallTaskStorage ;)",
    "insertText": "FGraphEvent() : ThreadToDoGatherOn(ENamedThreads::AnyHiPriThreadHiPriTask)"
  },
  {
    "label": "FGraphEvent()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FGraphEvent()"
  },
  {
    "label": "Decrement()",
    "kind": "Method",
    "detail": "Function (int32 RefCount = ReferenceCount .)",
    "insertText": "Decrement()"
  },
  {
    "label": "Recycle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Recycle(this)"
  },
  {
    "label": "GetRefCount()",
    "kind": "Method",
    "detail": "Function (} return RefCount ; } uint32)",
    "insertText": "GetRefCount()"
  },
  {
    "label": "GenerateTaskId()",
    "kind": "Method",
    "detail": "Function (} private : TClosableLockFreePointerListUnorderedSingleConsumer<FBaseGraphTask,0> SubsequentList ; FGraphEventArray EventsToWaitFor ; FThreadSafeCounter ReferenceCount ; ENamedThreads::Type ThreadToDoGatherOn ; # if ! UE_BUILD_SHIPPING&& ! UE_BUILD_TEST const TCHAR* DebugName = nullptr ; # endif # if UE_TASK_TRACE_ENABLED std::atomic<TaskTrace::FId> TraceId {)",
    "insertText": "GenerateTaskId()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void *)&Owner->TaskStorage) TTask(Forward<T>(Args)...)"
  },
  {
    "label": "ConstructAndHold()",
    "kind": "Method",
    "detail": "Function (} template<. . . T> TGraphTask*)",
    "insertText": "ConstructAndHold(T&&... Args)"
  },
  {
    "label": "FConstructor()",
    "kind": "Method",
    "detail": "Function (} private : TGraphTask ; TGraphTask* Owner ; const FGraphEventArray* Prerequisites ; ENamedThreads::Type CurrentThreadIfKnown ;)",
    "insertText": "FConstructor(TGraphTask* InOwner, const FGraphEventArray* InPrerequisites, ENamedThreads::Type InCurrentThreadIfKnown) : Owner(InOwner) , Prerequisites(InPrerequisites) , CurrentThreadIfKnown(InCurrentThreadIfKnown)"
  },
  {
    "label": "FConstructor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FConstructor(const FConstructor& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator(const FConstructor& Other)"
  },
  {
    "label": "CreateTask()",
    "kind": "Method",
    "detail": "Function (} } ; FConstructor)",
    "insertText": "CreateTask(const FGraphEventArray* Prerequisites = NULL, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)"
  },
  {
    "label": "GetSubsequentsMode()",
    "kind": "Method",
    "detail": "Function (FGraphEventRef GraphEvent =)",
    "insertText": "GetSubsequentsMode() == ESubsequentsMode::FireAndForget ? NULL : FGraphEvent::CreateGraphEvent()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32 NumPrereq = Prerequisites ? Prerequisites ->)",
    "insertText": "Num()"
  },
  {
    "label": "Launched()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Launched(GetTraceId(), nullptr, Subsequents.IsValid(), ((TTask*)&TaskStorage)->GetDesiredThread(), sizeof(*this))"
  },
  {
    "label": "ConditionalQueueTask()",
    "kind": "Method",
    "detail": "Function (bool bWakeUpWorker = true ;)",
    "insertText": "ConditionalQueueTask(CurrentThreadIfKnown, bWakeUpWorker)"
  },
  {
    "label": "Task()",
    "kind": "Method",
    "detail": "Function (} TTask&)",
    "insertText": "Task(TTask*)"
  },
  {
    "label": "TaskEventScope()",
    "kind": "Method",
    "detail": "Function ({ TaskTrace::FTaskTimingEventScope)",
    "insertText": "TaskEventScope(GetTraceId())"
  },
  {
    "label": "Scope()",
    "kind": "Method",
    "detail": "Function (FScopeCycleCounter)",
    "insertText": "Scope(Task.GetStatId(), true)"
  },
  {
    "label": "DoTask()",
    "kind": "Method",
    "detail": "Function (Task .)",
    "insertText": "DoTask(CurrentThread, Subsequents)"
  },
  {
    "label": "TTask()",
    "kind": "Method",
    "detail": "Function (Task . ~)",
    "insertText": "TTask()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} TaskConstructed = false ;)",
    "insertText": "if(TTask::GetSubsequentsMode() == ESubsequentsMode::TrackSubsequents)"
  },
  {
    "label": "MemoryBarrier()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MemoryBarrier()"
  },
  {
    "label": "DispatchSubsequents()",
    "kind": "Method",
    "detail": "Function (Subsequents ->)",
    "insertText": "DispatchSubsequents(NewTasks, CurrentThread, true)"
  },
  {
    "label": "Completed()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "Completed(GetTraceId())"
  },
  {
    "label": "Destroyed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroyed(GetTraceId())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bDeleteOnCompletion)"
  },
  {
    "label": "TGraphTask()",
    "kind": "Method",
    "detail": "Function (delete this ; })",
    "insertText": "TGraphTask(FGraphEventRef InSubsequents, int32 NumberOfPrerequistitesOutstanding) : FBaseGraphTask(NumberOfPrerequistitesOutstanding) , TaskConstructed(false)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (Subsequents .)",
    "insertText": "Swap(InSubsequents)"
  },
  {
    "label": "SetTraceId()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTraceId(Subsequents.IsValid() ? Subsequents->GetTraceId() : TaskTrace::GenerateTaskId())"
  },
  {
    "label": "TGraphTask()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TGraphTask()"
  },
  {
    "label": "SetupPrereqs()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetupPrereqs(const FGraphEventArray* Prerequisites, ENamedThreads::Type CurrentThreadIfKnown, bool bUnlock)"
  },
  {
    "label": "SetThreadToExecuteOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetThreadToExecuteOn(Task.GetDesiredThread())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 AlreadyCompletedPrerequisites = 0 ;)",
    "insertText": "if(Prerequisites)"
  },
  {
    "label": "Prerequisite()",
    "kind": "Method",
    "detail": "Function (FGraphEvent*)",
    "insertText": "Prerequisite(*Prerequisites)"
  },
  {
    "label": "PrerequisitesComplete()",
    "kind": "Method",
    "detail": "Function (AlreadyCompletedPrerequisites + + ; } } })",
    "insertText": "PrerequisitesComplete(CurrentThreadIfKnown, AlreadyCompletedPrerequisites, bUnlock)"
  },
  {
    "label": "Setup()",
    "kind": "Method",
    "detail": "Function (} FGraphEventRef)",
    "insertText": "Setup(const FGraphEventArray* Prerequisites = NULL, ENamedThreads::Type CurrentThreadIfKnown = ENamedThreads::AnyThread)"
  },
  {
    "label": "SetupPrereqs()",
    "kind": "Method",
    "detail": "Function (FGraphEventRef ReturnedEventRef = Subsequents ;)",
    "insertText": "SetupPrereqs(Prerequisites, CurrentThreadIfKnown, true)"
  },
  {
    "label": "SetupPrereqs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetupPrereqs(Prerequisites, CurrentThreadIfKnown, false)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} TAlignedBytes<)",
    "insertText": "sizeof(TTask),alignof(TTask)"
  },
  {
    "label": "WaitForAnyTaskCompleted()",
    "kind": "Method",
    "detail": "Function (bool TaskConstructed ; FGraphEventRef Subsequents ; } ; # endif int32)",
    "insertText": "WaitForAnyTaskCompleted(const FGraphEventArray& GraphEvents, FTimespan Timeout = FTimespan::MaxValue())"
  },
  {
    "label": "AnyTaskCompleted()",
    "kind": "Method",
    "detail": "Function (FGraphEventRef)",
    "insertText": "AnyTaskCompleted(const FGraphEventArray& GraphEvents)"
  },
  {
    "label": "FReturnGraphTask()",
    "kind": "Method",
    "detail": "Function (class FReturnGraphTask { public :)",
    "insertText": "FReturnGraphTask(ENamedThreads::Type InThreadToReturnFrom) : ThreadToReturnFrom(InThreadToReturnFrom)"
  },
  {
    "label": "GetStatId()",
    "kind": "Method",
    "detail": "Function (} TStatId)",
    "insertText": "GetStatId()"
  },
  {
    "label": "GetDesiredThread()",
    "kind": "Method",
    "detail": "Function (} ENamedThreads::Type)",
    "insertText": "GetDesiredThread()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Get().RequestReturn(ThreadToReturnFrom)"
  },
  {
    "label": "FCustomStatIDGraphTaskBase()",
    "kind": "Method",
    "detail": "Function (} private : ENamedThreads::Type ThreadToReturnFrom ; } ; class FCustomStatIDGraphTaskBase { public :)",
    "insertText": "FCustomStatIDGraphTaskBase(const TStatId& StatId)"
  },
  {
    "label": "TStatId()",
    "kind": "Method",
    "detail": "Function (# if STATS | | ENABLE_STATNAMEDEVENTS return StatID ; # else return)",
    "insertText": "TStatId()"
  },
  {
    "label": "FNullGraphTask()",
    "kind": "Method",
    "detail": "Function (# endif } private : # if STATS | | ENABLE_STATNAMEDEVENTS TStatId StatID ; # endif } ; class FNullGraphTask : public FCustomStatIDGraphTaskBase { public :)",
    "insertText": "FNullGraphTask(const TStatId& StatId, ENamedThreads::Type InDesiredThread) : FCustomStatIDGraphTaskBase(StatId) , DesiredThread(InDesiredThread)"
  },
  {
    "label": "FTriggerEventGraphTask()",
    "kind": "Method",
    "detail": "Function (} private : ENamedThreads::Type DesiredThread ; } ; class FTriggerEventGraphTask { public :)",
    "insertText": "FTriggerEventGraphTask(FEvent* InEvent, ENamedThreads::Type InDesiredThread = ENamedThreads::AnyHiPriThreadHiPriTask) : Event(InEvent) , DesiredThread(InDesiredThread)"
  },
  {
    "label": "Trigger()",
    "kind": "Method",
    "detail": "Function (Event ->)",
    "insertText": "Trigger()"
  },
  {
    "label": "DECLARE_DELEGATE()",
    "kind": "Method",
    "detail": "Function (} private : FEvent* Event ; ENamedThreads::Type DesiredThread ; } ; class FSimpleDelegateGraphTask : public FCustomStatIDGraphTaskBase { public :)",
    "insertText": "DECLARE_DELEGATE(FDelegate)"
  },
  {
    "label": "ExecuteIfBound()",
    "kind": "Method",
    "detail": "Function (TaskDelegate .)",
    "insertText": "ExecuteIfBound()"
  },
  {
    "label": "FSimpleDelegateGraphTask()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSimpleDelegateGraphTask(const FDelegate& InTaskDeletegate, const TStatId StatId, ENamedThreads::Type InDesiredThread) : FCustomStatIDGraphTaskBase(StatId) , TaskDelegate(InTaskDeletegate) , DesiredThread(InDesiredThread)"
  },
  {
    "label": "CreateAndDispatchWhenReady()",
    "kind": "Method",
    "detail": "Function (} FGraphEventRef)",
    "insertText": "CreateAndDispatchWhenReady(const FDelegate& InTaskDeletegate, const TStatId InStatId, const FGraphEventArray* InPrerequisites = NULL, ENamedThreads::Type InDesiredThread = ENamedThreads::AnyThread)"
  },
  {
    "label": "CreateAndDispatchWhenReady()",
    "kind": "Method",
    "detail": "Function (} FGraphEventRef)",
    "insertText": "CreateAndDispatchWhenReady(const FDelegate& InTaskDeletegate, const TStatId&& InStatId, const FGraphEventRef& InPrerequisite, ENamedThreads::Type InDesiredThread = ENamedThreads::AnyThread)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (FGraphEventArray Prerequisites ;)",
    "insertText": "check(InPrerequisite.GetReference())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Prerequisites .)",
    "insertText": "Add(InPrerequisite)"
  },
  {
    "label": "DECLARE_DELEGATE_TwoParams()",
    "kind": "Method",
    "detail": "Function (} } ; class FDelegateGraphTask : public FCustomStatIDGraphTaskBase { public :)",
    "insertText": "DECLARE_DELEGATE_TwoParams(FDelegate,ENamedThreads::Type, const FGraphEventRef&)"
  },
  {
    "label": "ExecuteIfBound()",
    "kind": "Method",
    "detail": "Function (TaskDelegate .)",
    "insertText": "ExecuteIfBound(CurrentThread, MyCompletionGraphEvent)"
  },
  {
    "label": "FDelegateGraphTask()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FDelegateGraphTask(const FDelegate& InTaskDeletegate, const TStatId InStatId, ENamedThreads::Type InDesiredThread) : FCustomStatIDGraphTaskBase(InStatId) , TaskDelegate(InTaskDeletegate) , DesiredThread(InDesiredThread)"
  },
  {
    "label": "CreateAndDispatchWhenReady()",
    "kind": "Method",
    "detail": "Function (} FGraphEventRef)",
    "insertText": "CreateAndDispatchWhenReady(const FDelegate& InTaskDeletegate, const TStatId InStatId, const FGraphEventArray* InPrerequisites = NULL, ENamedThreads::Type InCurrentThreadIfKnown = ENamedThreads::AnyThread, ENamedThreads::Type InDesiredThread = ENamedThreads::AnyThread)"
  },
  {
    "label": "CreateAndDispatchWhenReady()",
    "kind": "Method",
    "detail": "Function (} FGraphEventRef)",
    "insertText": "CreateAndDispatchWhenReady(const FDelegate& InTaskDeletegate, const TStatId InStatId, const FGraphEventRef& InPrerequisite, ENamedThreads::Type InCurrentThreadIfKnown = ENamedThreads::AnyThread, ENamedThreads::Type InDesiredThread = ENamedThreads::AnyThread)"
  },
  {
    "label": "TFunctionGraphTaskImpl()",
    "kind": "Method",
    "detail": "Function (} } ; template<Signature,ESubsequentsMode::Type SubsequentsMode> class TFunctionGraphTaskImpl : public FCustomStatIDGraphTaskBase { private : TUniqueFunction<Signature> Function ; const ENamedThreads::Type DesiredThread ; public :)",
    "insertText": "TFunctionGraphTaskImpl(TUniqueFunction<Signature>&& InFunction, TStatId StatId, ENamedThreads::Type InDesiredThread) : FCustomStatIDGraphTaskBase(StatId), Function(MoveTemp(InFunction)), DesiredThread(InDesiredThread)"
  },
  {
    "label": "DoTaskImpl()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "DoTaskImpl(TUniqueFunction<void()>& Function, ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)"
  },
  {
    "label": "Function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Function()"
  },
  {
    "label": "DoTaskImpl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DoTaskImpl(TUniqueFunction<void(const FGraphEventRef&)>& Function, ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)"
  },
  {
    "label": "Function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Function(MyCompletionGraphEvent)"
  },
  {
    "label": "DoTaskImpl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DoTaskImpl(TUniqueFunction<void(ENamedThreads::Type, const FGraphEventRef&)>& Function, ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)"
  },
  {
    "label": "Function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Function(CurrentThread, MyCompletionGraphEvent)"
  },
  {
    "label": "CreateAndDispatchWhenReady()",
    "kind": "Method",
    "detail": "Function (} } ; struct FFunctionGraphTask { public : FGraphEventRef)",
    "insertText": "CreateAndDispatchWhenReady(TUniqueFunction<void()> InFunction, TStatId InStatId = TStatId{}, const FGraphEventArray* InPrerequisites = nullptr, ENamedThreads::Type InDesiredThread = ENamedThreads::AnyThread)"
  },
  {
    "label": "CreateAndDispatchWhenReady()",
    "kind": "Method",
    "detail": "Function (} FGraphEventRef)",
    "insertText": "CreateAndDispatchWhenReady(TUniqueFunction<void(ENamedThreads::Type, const FGraphEventRef&)> InFunction, TStatId InStatId = TStatId{}, const FGraphEventArray* InPrerequisites = nullptr, ENamedThreads::Type InDesiredThread = ENamedThreads::AnyThread)"
  },
  {
    "label": "CreateAndDispatchWhenReady()",
    "kind": "Method",
    "detail": "Function (} FGraphEventRef)",
    "insertText": "CreateAndDispatchWhenReady(TUniqueFunction<void()> InFunction, TStatId InStatId, const FGraphEventRef& InPrerequisite, ENamedThreads::Type InDesiredThread = ENamedThreads::AnyThread)"
  },
  {
    "label": "CreateAndDispatchWhenReady()",
    "kind": "Method",
    "detail": "Function (} FGraphEventRef)",
    "insertText": "CreateAndDispatchWhenReady(TUniqueFunction<void(ENamedThreads::Type, const FGraphEventRef&)> InFunction, TStatId InStatId, const FGraphEventRef& InPrerequisite, ENamedThreads::Type InDesiredThread = ENamedThreads::AnyThread)"
  }
]