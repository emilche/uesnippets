[
  {
    "label": "arena",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "arena"
  },
  {
    "label": "task_scheduler_observer_v3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "task_scheduler_observer_v3"
  },
  {
    "label": "task_arena",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "task_arena"
  },
  {
    "label": "delegate_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "delegate_base"
  },
  {
    "label": "return_type_or_void",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "return_type_or_void"
  },
  {
    "label": "delegated_function",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "delegated_function"
  },
  {
    "label": "task_arena_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "task_arena_base"
  },
  {
    "label": "tbb",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "tbb"
  },
  {
    "label": "attach",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "attach"
  },
  {
    "label": "max_concurrency()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_task_arena_H # define __TBB_task_arena_H # include \" task . h \" # include \" tbb_exception . h \" # include \" internal / _template_helpers . h \" # if TBB_USE_THREADING_TOOLS # include \" atomic . h \" # endif # include \" aligned_space . h \" namespace tbb { namespace this_task_arena { int)",
    "insertText": "max_concurrency()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} namespace internal { class arena ; class task_scheduler_observer_v3 ; } namespace interface7 { class task_arena ; namespace internal { using namespace tbb::internal ; class delegate_base : no_assign { public : void)",
    "insertText": "operator()()"
  },
  {
    "label": "delegate_base()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "delegate_base()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} } ; template<F> struct return_type_or_void { # if __TBB_CPP11_DECLTYPE_PRESENT&& ! __TBB_CPP11_DECLTYPE_OF_FUNCTION_RETURN_TYPE_BROKEN typedef)",
    "insertText": "decltype(declval<F>()())"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(my_return_storage.begin()) R(my_func())"
  },
  {
    "label": "delegated_function()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "delegated_function(F& f) : my_func(f)"
  },
  {
    "label": "consume_result()",
    "kind": "Method",
    "detail": "Function (} R)",
    "insertText": "consume_result()"
  },
  {
    "label": "delegated_function()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "delegated_function()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (my_return_storage .)",
    "insertText": "begin()->~R()"
  },
  {
    "label": "my_func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "my_func()"
  },
  {
    "label": "__TBB_TASK_GROUP_CONTEXT()",
    "kind": "Method",
    "detail": "Function (} class task_arena_base ; } ; class task_arena_base { protected : internal::arena* my_arena ; # if __TBB_TASK_GROUP_CONTEXT task_group_context* my_context ; # endif int my_max_concurrency ; unsigned my_master_slots ; intptr_t my_version_and_traits ; enum { default_flags = 0 # if)",
    "insertText": "__TBB_TASK_GROUP_CONTEXT(task_group_context::default_traits & task_group_context::exact_exception)"
  },
  {
    "label": "task_arena_base()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "task_arena_base(int max_concurrency, unsigned reserved_for_masters) : my_arena(0) #if __TBB_TASK_GROUP_CONTEXT , my_context(0) #endif , my_max_concurrency(max_concurrency) , my_master_slots(reserved_for_masters) , my_version_and_traits(default_flags)"
  },
  {
    "label": "internal_initialize()",
    "kind": "Method",
    "detail": "Function (} void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_initialize()"
  },
  {
    "label": "internal_terminate()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_terminate()"
  },
  {
    "label": "internal_attach()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_attach()"
  },
  {
    "label": "internal_enqueue()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_enqueue(task&, intptr_t)"
  },
  {
    "label": "internal_execute()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_execute(delegate_base&)"
  },
  {
    "label": "internal_wait()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_wait()"
  },
  {
    "label": "internal_current_slot()",
    "kind": "Method",
    "detail": "Function (int __TBB_EXPORTED_FUNC)",
    "insertText": "internal_current_slot()"
  },
  {
    "label": "internal_max_concurrency()",
    "kind": "Method",
    "detail": "Function (int __TBB_EXPORTED_FUNC)",
    "insertText": "internal_max_concurrency(const task_arena *)"
  },
  {
    "label": "isolate_within_arena()",
    "kind": "Method",
    "detail": "Function (public : const int automatic = - 1 ; const int not_initialized = - 2 ; } ; # if __TBB_TASK_ISOLATION void __TBB_EXPORTED_FUNC)",
    "insertText": "isolate_within_arena(delegate_base& d, intptr_t reserved = 0)"
  },
  {
    "label": "isolate_impl()",
    "kind": "Method",
    "detail": "Function (template<R,F> R)",
    "insertText": "isolate_impl(F& f)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (delegated_function<F,R>)",
    "insertText": "d(f)"
  },
  {
    "label": "isolate_within_arena()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "isolate_within_arena(d)"
  },
  {
    "label": "enqueue()",
    "kind": "Method",
    "detail": "Function (} # endif } class task_arena : public internal::task_arena_base { class tbb::internal::task_scheduler_observer_v3 ; void)",
    "insertText": "enqueue(task&, task_arena& #if __TBB_TASK_PRIORITY , priority_t #endif)"
  },
  {
    "label": "mark_initialized()",
    "kind": "Method",
    "detail": "Function (bool my_initialized ; void)",
    "insertText": "mark_initialized()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_arena, \"task_arena initialization is incomplete\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (# if __TBB_TASK_GROUP_CONTEXT)",
    "insertText": "__TBB_ASSERT(my_context, \"task_arena initialization is incomplete\")"
  },
  {
    "label": "as_atomic()",
    "kind": "Method",
    "detail": "Function (# endif # if TBB_USE_THREADING_TOOLS)",
    "insertText": "as_atomic(my_initialized).fetch_and_store<release>(true)"
  },
  {
    "label": "enqueue_impl()",
    "kind": "Method",
    "detail": "Function (# else my_initialized = true ; # endif } template<F> void)",
    "insertText": "enqueue_impl(__TBB_FORWARDING_REF(F) f #if __TBB_TASK_PRIORITY , priority_t p = priority_t(0) #endif)"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (# if ! __TBB_TASK_PRIORITY intptr_t p = 0 ; # endif)",
    "insertText": "initialize()"
  },
  {
    "label": "internal_enqueue()",
    "kind": "Method",
    "detail": "Function (# if __TBB_TASK_GROUP_CONTEXT)",
    "insertText": "internal_enqueue(*new(task::allocate_root(*my_context)) internal::function_task< typename internal::strip<F>::type >(internal::forward<F>(f)), p)"
  },
  {
    "label": "internal_enqueue()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "internal_enqueue(*new(task::allocate_root()) internal::function_task< typename internal::strip<F>::type >(internal::forward<F>(f)), p)"
  },
  {
    "label": "execute_impl()",
    "kind": "Method",
    "detail": "Function (# endif } template<R,F> R)",
    "insertText": "execute_impl(F& f)"
  },
  {
    "label": "internal_execute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_execute(d)"
  },
  {
    "label": "task_arena()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "task_arena(int max_concurrency_ = automatic, unsigned reserved_for_masters = 1) : task_arena_base(max_concurrency_, reserved_for_masters) , my_initialized(false)"
  },
  {
    "label": "task_arena()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "task_arena(const task_arena &s) : task_arena_base(s.my_max_concurrency, s.my_master_slots) , my_initialized(false)"
  },
  {
    "label": "task_arena()",
    "kind": "Method",
    "detail": "Function (} struct attach { } ;)",
    "insertText": "task_arena(attach ) : task_arena_base(automatic, 1) , my_initialized(false)"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "initialize(int max_concurrency_, unsigned reserved_for_masters = 1)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!my_arena, \"Impossible to modify settings of an already initialized task_arena\")"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "initialize(attach)"
  },
  {
    "label": "terminate()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "terminate()"
  },
  {
    "label": "task_arena()",
    "kind": "Method",
    "detail": "Function (my_initialized = false ; } } ~)",
    "insertText": "task_arena()"
  },
  {
    "label": "is_active()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_active()"
  },
  {
    "label": "enqueue_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enqueue_impl(std::forward<F>(f))"
  },
  {
    "label": "enqueue()",
    "kind": "Method",
    "detail": "Function (} # else template<F> void)",
    "insertText": "enqueue(const F& f)"
  },
  {
    "label": "enqueue_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enqueue_impl(f)"
  },
  {
    "label": "enqueue()",
    "kind": "Method",
    "detail": "Function (} # endif # if __TBB_TASK_PRIORITY template<F> # if __TBB_CPP11_RVALUE_REF_PRESENT void)",
    "insertText": "enqueue(F&& f, priority_t p)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (# if __TBB_PREVIEW_CRITICAL_TASKS)",
    "insertText": "__TBB_ASSERT(p == priority_low || p == priority_normal || p == priority_high || p == internal::priority_critical, \"Invalid priority level value\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "__TBB_ASSERT(p == priority_low || p == priority_normal || p == priority_high, \"Invalid priority level value\")"
  },
  {
    "label": "enqueue_impl()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "enqueue_impl(std::forward<F>(f), p)"
  },
  {
    "label": "enqueue()",
    "kind": "Method",
    "detail": "Function (} # else void)",
    "insertText": "enqueue(const F& f, priority_t p)"
  },
  {
    "label": "enqueue_impl()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "enqueue_impl(f,p)"
  },
  {
    "label": "execute()",
    "kind": "Method",
    "detail": "Function (} # endif # endif template<F> internal::return_type_or_void<F>::type)",
    "insertText": "execute(F& f)"
  },
  {
    "label": "execute()",
    "kind": "Method",
    "detail": "Function (} template<F> internal::return_type_or_void<F>::type)",
    "insertText": "execute(const F& f)"
  },
  {
    "label": "debug_wait_until_empty()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_EXTRA_DEBUG void)",
    "insertText": "debug_wait_until_empty()"
  },
  {
    "label": "current_thread_index()",
    "kind": "Method",
    "detail": "Function (} # endif int)",
    "insertText": "current_thread_index()"
  },
  {
    "label": "isolate()",
    "kind": "Method",
    "detail": "Function (} } ; # if __TBB_TASK_ISOLATION namespace this_task_arena { template<F> internal::return_type_or_void<F>::type)",
    "insertText": "isolate(F& f)"
  },
  {
    "label": "isolate()",
    "kind": "Method",
    "detail": "Function (} template<F> internal::return_type_or_void<F>::type)",
    "insertText": "isolate(const F& f)"
  },
  {
    "label": "enqueue()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "enqueue(task& t, task_arena& arena #if __TBB_TASK_PRIORITY , priority_t p #endif)"
  },
  {
    "label": "internal_enqueue()",
    "kind": "Method",
    "detail": "Function (arena .)",
    "insertText": "internal_enqueue(t, p)"
  }
]