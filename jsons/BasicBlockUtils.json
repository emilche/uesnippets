[
  {
    "label": "AliasAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AliasAnalysis"
  },
  {
    "label": "MemoryDependenceAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MemoryDependenceAnalysis"
  },
  {
    "label": "DominatorTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DominatorTree"
  },
  {
    "label": "LoopInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopInfo"
  },
  {
    "label": "Instruction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Instruction"
  },
  {
    "label": "MDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MDNode"
  },
  {
    "label": "ReturnInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ReturnInst"
  },
  {
    "label": "TargetLibraryInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetLibraryInfo"
  },
  {
    "label": "TerminatorInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TerminatorInst"
  },
  {
    "label": "CriticalEdgeSplittingOptions",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CriticalEdgeSplittingOptions"
  },
  {
    "label": "DeleteDeadBlock()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_TRANSFORMS_UTILS_BASICBLOCKUTILS_H # define LLVM_TRANSFORMS_UTILS_BASICBLOCKUTILS_H # include \" llvm / IR / BasicBlock . h \" # include \" llvm / IR / CFG . h \" namespace llvm { class AliasAnalysis ; class MemoryDependenceAnalysis ; class DominatorTree ; class LoopInfo ; class Instruction ; class MDNode ; class ReturnInst ; class TargetLibraryInfo ; class TerminatorInst ; void)",
    "insertText": "DeleteDeadBlock(BasicBlock *BB)"
  },
  {
    "label": "FoldSingleEntryPHINodes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FoldSingleEntryPHINodes(BasicBlock *BB, AliasAnalysis *AA = nullptr, MemoryDependenceAnalysis *MemDep = nullptr)"
  },
  {
    "label": "DeleteDeadPHIs()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DeleteDeadPHIs(BasicBlock *BB, const TargetLibraryInfo *TLI = nullptr)"
  },
  {
    "label": "MergeBlockIntoPredecessor()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MergeBlockIntoPredecessor(BasicBlock *BB, DominatorTree *DT = nullptr, LoopInfo *LI = nullptr, AliasAnalysis *AA = nullptr, MemoryDependenceAnalysis *MemDep = nullptr)"
  },
  {
    "label": "ReplaceInstWithValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReplaceInstWithValue(BasicBlock::InstListType &BIL, BasicBlock::iterator &BI, Value *V)"
  },
  {
    "label": "ReplaceInstWithInst()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReplaceInstWithInst(BasicBlock::InstListType &BIL, BasicBlock::iterator &BI, Instruction *I)"
  },
  {
    "label": "ReplaceInstWithInst()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReplaceInstWithInst(Instruction *From, Instruction *To)"
  },
  {
    "label": "CriticalEdgeSplittingOptions()",
    "kind": "Method",
    "detail": "Function (struct CriticalEdgeSplittingOptions { AliasAnalysis* AA ; DominatorTree* DT ; LoopInfo* LI ; bool MergeIdenticalEdges ; bool DontDeleteUselessPHIs ; bool PreserveLCSSA ;)",
    "insertText": "CriticalEdgeSplittingOptions() : AA(nullptr), DT(nullptr), LI(nullptr), MergeIdenticalEdges(false), DontDeleteUselessPHIs(false), PreserveLCSSA(false)"
  },
  {
    "label": "CriticalEdgeSplittingOptions()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CriticalEdgeSplittingOptions(AliasAnalysis *AA, DominatorTree *DT = nullptr, LoopInfo *LI = nullptr) : AA(AA), DT(DT), LI(LI), MergeIdenticalEdges(false), DontDeleteUselessPHIs(false), PreserveLCSSA(false)"
  },
  {
    "label": "CriticalEdgeSplittingOptions()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CriticalEdgeSplittingOptions(DominatorTree *DT, LoopInfo *LI) : AA(nullptr), DT(DT), LI(LI), MergeIdenticalEdges(false), DontDeleteUselessPHIs(false), PreserveLCSSA(false)"
  },
  {
    "label": "setMergeIdenticalEdges()",
    "kind": "Method",
    "detail": "Function (} CriticalEdgeSplittingOptions&)",
    "insertText": "setMergeIdenticalEdges()"
  },
  {
    "label": "setDontDeleteUselessPHIs()",
    "kind": "Method",
    "detail": "Function (MergeIdenticalEdges = true ; return* this ; } CriticalEdgeSplittingOptions&)",
    "insertText": "setDontDeleteUselessPHIs()"
  },
  {
    "label": "SplitCriticalEdge()",
    "kind": "Method",
    "detail": "Function (PreserveLCSSA = true ; return* this ; } } ; BasicBlock*)",
    "insertText": "SplitCriticalEdge(TerminatorInst *TI, unsigned SuccNum, const CriticalEdgeSplittingOptions &Options = CriticalEdgeSplittingOptions())"
  },
  {
    "label": "SplitCriticalEdge()",
    "kind": "Method",
    "detail": "Function (BasicBlock*)",
    "insertText": "SplitCriticalEdge(BasicBlock *BB, succ_iterator SI, const CriticalEdgeSplittingOptions &Options = CriticalEdgeSplittingOptions())"
  },
  {
    "label": "SplitCriticalEdge()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "SplitCriticalEdge(BasicBlock *Succ, pred_iterator PI, const CriticalEdgeSplittingOptions &Options = CriticalEdgeSplittingOptions())"
  },
  {
    "label": "TI()",
    "kind": "Method",
    "detail": "Function (bool MadeChange = false ; TerminatorInst*)",
    "insertText": "TI(*PI)->getTerminator()"
  },
  {
    "label": "getTerminator()",
    "kind": "Method",
    "detail": "Function (TerminatorInst* TI = Src ->)",
    "insertText": "getTerminator()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (unsigned i = 0 ;)",
    "insertText": "while(1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i != TI->getNumSuccessors() && \"Edge doesn't exist!\")"
  },
  {
    "label": "SplitAllCriticalEdges()",
    "kind": "Method",
    "detail": "Function (+ + i ; } } unsigned)",
    "insertText": "SplitAllCriticalEdges(Function &F, const CriticalEdgeSplittingOptions &Options = CriticalEdgeSplittingOptions())"
  },
  {
    "label": "SplitEdge()",
    "kind": "Method",
    "detail": "Function (BasicBlock*)",
    "insertText": "SplitEdge(BasicBlock *From, BasicBlock *To, DominatorTree *DT = nullptr, LoopInfo *LI = nullptr)"
  },
  {
    "label": "SplitBlock()",
    "kind": "Method",
    "detail": "Function (BasicBlock*)",
    "insertText": "SplitBlock(BasicBlock *Old, Instruction *SplitPt, DominatorTree *DT = nullptr, LoopInfo *LI = nullptr)"
  },
  {
    "label": "SplitBlockPredecessors()",
    "kind": "Method",
    "detail": "Function (BasicBlock*)",
    "insertText": "SplitBlockPredecessors(BasicBlock *BB, ArrayRef<BasicBlock *> Preds, const char *Suffix, AliasAnalysis *AA = nullptr, DominatorTree *DT = nullptr, LoopInfo *LI = nullptr, bool PreserveLCSSA = false)"
  },
  {
    "label": "SplitLandingPadPredecessors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SplitLandingPadPredecessors(BasicBlock *OrigBB, ArrayRef<BasicBlock *> Preds, const char *Suffix, const char *Suffix2, SmallVectorImpl<BasicBlock *> &NewBBs, AliasAnalysis *AA = nullptr, DominatorTree *DT = nullptr, LoopInfo *LI = nullptr, bool PreserveLCSSA = false)"
  },
  {
    "label": "SplitBlockAndInsertIfThen()",
    "kind": "Method",
    "detail": "Function (TerminatorInst*)",
    "insertText": "SplitBlockAndInsertIfThen(Value *Cond, Instruction *SplitBefore, bool Unreachable, MDNode *BranchWeights = nullptr, DominatorTree *DT = nullptr)"
  },
  {
    "label": "SplitBlockAndInsertIfThenElse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SplitBlockAndInsertIfThenElse(Value *Cond, Instruction *SplitBefore, TerminatorInst **ThenTerm, TerminatorInst **ElseTerm, MDNode *BranchWeights = nullptr)"
  },
  {
    "label": "GetIfCondition()",
    "kind": "Method",
    "detail": "Function (Value*)",
    "insertText": "GetIfCondition(BasicBlock *BB, BasicBlock *&IfTrue, BasicBlock *&IfFalse)"
  }
]