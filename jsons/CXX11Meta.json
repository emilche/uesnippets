[
  {
    "label": "type_list",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "type_list"
  },
  {
    "label": "numeric_list",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "numeric_list"
  },
  {
    "label": "gen_numeric_list",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gen_numeric_list"
  },
  {
    "label": "gen_numeric_list_reversed",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gen_numeric_list_reversed"
  },
  {
    "label": "gen_numeric_list_swapped_pair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gen_numeric_list_swapped_pair"
  },
  {
    "label": "gen_numeric_list_repeated",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gen_numeric_list_repeated"
  },
  {
    "label": "a",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "a"
  },
  {
    "label": "b",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "b"
  },
  {
    "label": "concat",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "concat"
  },
  {
    "label": "mconcat",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "mconcat"
  },
  {
    "label": "take",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "take"
  },
  {
    "label": "h_skip_helper_numeric",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "h_skip_helper_numeric"
  },
  {
    "label": "h_skip_helper_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "h_skip_helper_type"
  },
  {
    "label": "h_skip",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "h_skip"
  },
  {
    "label": "skip",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "skip"
  },
  {
    "label": "slice",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "slice"
  },
  {
    "label": "get",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "get"
  },
  {
    "label": "id_numeric",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "id_numeric"
  },
  {
    "label": "id_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "id_type"
  },
  {
    "label": "is_same_gf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_same_gf"
  },
  {
    "label": "op",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "op"
  },
  {
    "label": "h_apply_op_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "h_apply_op_helper"
  },
  {
    "label": "h_apply_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "h_apply_op"
  },
  {
    "label": "apply_op_from_left",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "apply_op_from_left"
  },
  {
    "label": "apply_op_from_right",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "apply_op_from_right"
  },
  {
    "label": "test",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "test"
  },
  {
    "label": "contained_in_list",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "contained_in_list"
  },
  {
    "label": "contained_in_list_gf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "contained_in_list_gf"
  },
  {
    "label": "reduce",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "reduce"
  },
  {
    "label": "sum_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "sum_op"
  },
  {
    "label": "product_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "product_op"
  },
  {
    "label": "logical_and_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "logical_and_op"
  },
  {
    "label": "logical_or_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "logical_or_op"
  },
  {
    "label": "equal_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "equal_op"
  },
  {
    "label": "not_equal_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "not_equal_op"
  },
  {
    "label": "lesser_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lesser_op"
  },
  {
    "label": "lesser_equal_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lesser_equal_op"
  },
  {
    "label": "greater_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "greater_op"
  },
  {
    "label": "greater_equal_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "greater_equal_op"
  },
  {
    "label": "not_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "not_op"
  },
  {
    "label": "negation_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "negation_op"
  },
  {
    "label": "greater_equal_zero_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "greater_equal_zero_op"
  },
  {
    "label": "h_array_reduce",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "h_array_reduce"
  },
  {
    "label": "h_repeat",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "h_repeat"
  },
  {
    "label": "InstType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InstType"
  },
  {
    "label": "h_instantiate_by_c_array",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "h_instantiate_by_c_array"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_CXX11META_H # define EIGEN_CXX11META_H # include<vector> # include \" EmulateArray . h \" # include \" CXX11Workarounds . h \" namespace Eigen { namespace internal { template<. . . tt> struct type_list { int count =)",
    "insertText": "sizeof(tt)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (typedef t first_type ; } ; template<T,T . . . nn> struct numeric_list { std::size_t count =)",
    "insertText": "sizeof(nn)"
  },
  {
    "label": "start()",
    "kind": "Method",
    "detail": "Function (const T first_value = n ; } ; # ifndef EIGEN_PARSED_BY_DOXYGEN template<T,std::size_t n,T start = 0,T . . . ii> struct gen_numeric_list : gen_numeric_list<T,n - 1,start,start + n - 1,ii . . .> { } ; template<T,T start,T . . . ii> struct gen_numeric_list<T,0,start,ii . . .> { typedef numeric_list<T,ii . . .> type ; } ; template<T,std::size_t n,T start = 0,T . . . ii> struct gen_numeric_list_reversed : gen_numeric_list_reversed<T,n - 1,start,ii . . .,start + n - 1> { } ; template<T,T start,T . . . ii> struct gen_numeric_list_reversed<T,0,start,ii . . .> { typedef numeric_list<T,ii . . .> type ; } ; template<T,std::size_t n,T a,T b,T start = 0,T . . . ii> struct gen_numeric_list_swapped_pair : gen_numeric_list_swapped_pair<T,n - 1,a,b,)",
    "insertText": "start(start + n-1) == a ? b : ((start + n-1) == b ? a : (start + n-1))"
  },
  {
    "label": "helper()",
    "kind": "Method",
    "detail": "Function (} ; template<T,T a,T b,T start,T . . . ii> struct gen_numeric_list_swapped_pair<T,0,a,b,start,ii . . .> { typedef numeric_list<T,ii . . .> type ; } ; template<T,std::size_t n,T V,T . . . nn> struct gen_numeric_list_repeated : gen_numeric_list_repeated<T,n - 1,V,V,nn . . .> { } ; template<T,T V,T . . . nn> struct gen_numeric_list_repeated<T,0,V,nn . . .> { typedef numeric_list<T,nn . . .> type ; } ; template<class a,class b> struct concat ; template<. . . as,. . . bs> struct concat<type_list<as . . .>,type_list<bs . . .>> { typedef type_list<as . . .,bs . . .> type ; } ; template<T,T . . . as,T . . . bs> struct concat<numeric_list<T,as . . .>,numeric_list<T,bs . . .>> { typedef numeric_list<T,as . . .,bs . . .> type ; } ; template<. . . p> struct mconcat ; template<a> struct mconcat<a> { typedef a type ; } ; template<a,b> struct mconcat<a,b> : concat<a,b> { } ; template<a,b,. . . cs> struct mconcat<a,b,cs . . .> : concat<a,mconcat<b,cs . . .>::type> { } ; template<int n,x> struct take ; template<int n,a,. . . as> struct take<n,type_list<a,as . . .>> : concat<type_list<a>,take<n - 1,type_list<as . . .>>::type> { } ; template<int n> struct take<n,type_list<>> { typedef type_list<> type ; } ; template<a,. . . as> struct take<0,type_list<a,as . . .>> { typedef type_list<> type ; } ; template<> struct take<0,type_list<>> { typedef type_list<> type ; } ; template<T,int n,T a,T . . . as> struct take<n,numeric_list<T,a,as . . .>> : concat<numeric_list<T,a>,take<n - 1,numeric_list<T,as . . .>>::type> { } ; template<T,int n> struct take<n,numeric_list<T>> { typedef numeric_list<T> type ; } ; template<T,T a,T . . . as> struct take<0,numeric_list<T,a,as . . .>> { typedef numeric_list<T> type ; } ; template<T> struct take<0,numeric_list<T>> { typedef numeric_list<T> type ; } ; template<T,int n,T . . . ii> struct h_skip_helper_numeric ; template<T,int n,T i,T . . . ii> struct h_skip_helper_numeric<T,n,i,ii . . .> : h_skip_helper_numeric<T,n - 1,ii . . .> { } ; template<T,T i,T . . . ii> struct h_skip_helper_numeric<T,0,i,ii . . .> { typedef numeric_list<T,i,ii . . .> type ; } ; template<T,int n> struct h_skip_helper_numeric<T,n> { typedef numeric_list<T> type ; } ; template<T> struct h_skip_helper_numeric<T,0> { typedef numeric_list<T> type ; } ; template<int n,. . . tt> struct h_skip_helper_type ; template<int n,t,. . . tt> struct h_skip_helper_type<n,t,tt . . .> : h_skip_helper_type<n - 1,tt . . .> { } ; template<t,. . . tt> struct h_skip_helper_type<0,t,tt . . .> { typedef type_list<t,tt . . .> type ; } ; template<int n> struct h_skip_helper_type<n> { typedef type_list<> type ; } ; template<> struct h_skip_helper_type<0> { typedef type_list<> type ; } ; # endif template<int n> struct h_skip { template<T,T . . . ii> EIGEN_STRONG_INLINE h_skip_helper_numeric<T,n,ii . . .>::type)",
    "insertText": "helper(numeric_list<T, ii...>)"
  },
  {
    "label": "helper()",
    "kind": "Method",
    "detail": "Function (} template<. . . tt> EIGEN_STRONG_INLINE h_skip_helper_type<n,tt . . .>::type)",
    "insertText": "helper(type_list<tt...>)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} } ; template<int n,a> struct skip { typedef)",
    "insertText": "decltype(h_skip<n>::helper(a()))"
  },
  {
    "label": "array_get()",
    "kind": "Method",
    "detail": "Function (} ; template<int start,int count,a> struct slice : take<count,skip<start,a>::type> { } ; template<int n,x> struct get ; template<int n,a,. . . as> struct get<n,type_list<a,as . . .>> : get<n - 1,type_list<as . . .>> { } ; template<a,. . . as> struct get<0,type_list<a,as . . .>> { typedef a type ; } ; template<T,int n,T a,T . . . as> struct get<n,numeric_list<T,a,as . . .>> : get<n - 1,numeric_list<T,as . . .>> { } ; template<T,T a,T . . . as> struct get<0,numeric_list<T,a,as . . .>> { T value = a ; } ; template<std::size_t n,T,T a,T . . . as> T)",
    "insertText": "array_get(const numeric_list<T, a, as...>&)"
  },
  {
    "label": "helper()",
    "kind": "Method",
    "detail": "Function (} template<T,T dummy,t> struct id_numeric { typedef t type ; } ; template<dummy,t> struct id_type { typedef t type ; } ; template<a,b> struct is_same_gf : is_same<a,b> { int global_flags = 0 ; } ; template<bool from_left,template<,> class op,additional_param,. . . values> struct h_apply_op_helper { typedef type_list<op<values,additional_param>::type . . .> type ; } ; template<template<,> class op,additional_param,. . . values> struct h_apply_op_helper<true,op,additional_param,values . . .> { typedef type_list<op<additional_param,values>::type . . .> type ; } ; template<bool from_left,template<,> class op,additional_param> struct h_apply_op { template<. . . values> h_apply_op_helper<from_left,op,additional_param,values . . .>::type)",
    "insertText": "helper(type_list<values...>)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} } ; template<template<,> class op,additional_param,a> struct apply_op_from_left { typedef)",
    "insertText": "decltype(h_apply_op<true, op, additional_param>::helper(a()))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<template<,> class op,additional_param,a> struct apply_op_from_right { typedef)",
    "insertText": "decltype(h_apply_op<false, op, additional_param>::helper(a()))"
  },
  {
    "label": "EIGEN_TPL_PP_SPEC_HACK_DEFC()",
    "kind": "Method",
    "detail": "Function (} ; template<template<,> class test,check_against,h_list,bool last_check_positive = false> struct contained_in_list ; template<template<,> class test,check_against,h_list> struct contained_in_list<test,check_against,h_list,true> { bool value = true ; } ; template<template<,> class test,check_against,a,. . . as> struct contained_in_list<test,check_against,type_list<a,as . . .>,false> : contained_in_list<test,check_against,type_list<as . . .>,test<check_against,a>::value> { } ; template<template<,> class test,check_against)",
    "insertText": "EIGEN_TPL_PP_SPEC_HACK_DEFC(typename, empty) > struct contained_in_list<test, check_against, type_list<EIGEN_TPL_PP_SPEC_HACK_USE(empty)"
  },
  {
    "label": "EIGEN_TPL_PP_SPEC_HACK_DEFC()",
    "kind": "Method",
    "detail": "Function (bool value = false ; } ; template<template<,> class test,check_against,h_list,int default_flags = 0,bool last_check_positive = false,int last_check_flags = default_flags> struct contained_in_list_gf ; template<template<,> class test,check_against,h_list,int default_flags,int last_check_flags> struct contained_in_list_gf<test,check_against,h_list,default_flags,true,last_check_flags> { bool value = true ; int global_flags = last_check_flags ; } ; template<template<,> class test,check_against,a,. . . as,int default_flags,int last_check_flags> struct contained_in_list_gf<test,check_against,type_list<a,as . . .>,default_flags,false,last_check_flags> : contained_in_list_gf<test,check_against,type_list<as . . .>,default_flags,test<check_against,a>::value,test<check_against,a>::global_flags> { } ; template<template<,> class test,check_against)",
    "insertText": "EIGEN_TPL_PP_SPEC_HACK_DEFC(typename, empty), int default_flags, int last_check_flags > struct contained_in_list_gf<test, check_against, type_list<EIGEN_TPL_PP_SPEC_HACK_USE(empty)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (bool value = false ; int global_flags = default_flags ; } ; template<Reducer,. . . Ts> struct reduce ; template<Reducer> struct reduce<Reducer> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int)",
    "insertText": "run()"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; struct sum_op { template<A,B> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE auto)",
    "insertText": "run(A a, B b) -> decltype(a + b)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<. . . Ts> EIGEN_STRONG_INLINE)",
    "insertText": "decltype(reduce<sum_op, Ts...>::run((*((Ts*)0))...)) arg_sum(Ts... ts)"
  },
  {
    "label": "h_array_reverse()",
    "kind": "Method",
    "detail": "Function (} template<Array,int . . . n> EIGEN_STRONG_INLINE Array)",
    "insertText": "h_array_reverse(Array arr, numeric_list<int, n...>)"
  },
  {
    "label": "array_reverse()",
    "kind": "Method",
    "detail": "Function (} template<T,std::size_t N> EIGEN_STRONG_INLINE array<T,N>)",
    "insertText": "array_reverse(array<T, N> arr)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} template<Reducer,T,std::size_t N,std::size_t n = N - 1> struct h_array_reduce { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE auto)",
    "insertText": "run(array<T, N> arr, T identity) -> decltype(Reducer::run(h_array_reduce<Reducer, T, N, n - 1>::run(arr, identity), array_get<n>(arr)))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Reducer,T,std::size_t N> struct h_array_reduce<Reducer,T,N,0> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T)",
    "insertText": "run(const array<T, N>& arr, T)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Reducer,T> struct h_array_reduce<Reducer,T,0> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T)",
    "insertText": "run(const array<T, 0>&, T identity)"
  },
  {
    "label": "array_sum()",
    "kind": "Method",
    "detail": "Function (} template<T,std::size_t N> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE auto)",
    "insertText": "array_sum(const array<T, N>& arr) -> decltype(array_reduce<sum_op, T, N>(arr, static_cast<T>(0)))"
  },
  {
    "label": "array_prod()",
    "kind": "Method",
    "detail": "Function (} template<T,std::size_t N> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE auto)",
    "insertText": "array_prod(const array<T, N>& arr) -> decltype(array_reduce<product_op, T, N>(arr, static_cast<T>(1)))"
  },
  {
    "label": "array_prod()",
    "kind": "Method",
    "detail": "Function (} template<t> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE t)",
    "insertText": "array_prod(const std::vector<t>& a)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(a.size() > 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (t prod = 1 ;)",
    "insertText": "for(size_t i = 0; i < a.size(); ++i)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (prod* = a [ i ] ; } return prod ; } template<Op,A,B,std::size_t N,int . . . n> EIGEN_STRONG_INLINE array<)",
    "insertText": "decltype(Op::run(A(), B())),N> h_array_zip(array<A, N> a, array<B, N> b, numeric_list<int, n...>)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "run(array_get<n>(a), array_get<n>(b))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<Op,A,B,std::size_t N> EIGEN_STRONG_INLINE array<)",
    "insertText": "decltype(Op::run(A(), B())),N> array_zip(array<A, N> a, array<B, N> b)"
  },
  {
    "label": "h_array_zip_and_reduce()",
    "kind": "Method",
    "detail": "Function (} template<Reducer,Op,A,B,std::size_t N,int . . . n> EIGEN_STRONG_INLINE auto)",
    "insertText": "h_array_zip_and_reduce(array<A, N> a, array<B, N> b, numeric_list<int, n...>) -> decltype(reduce<Reducer, typename id_numeric<int,n,decltype(Op::run(A(), B()))>::type...>::run(Op::run(array_get<n>(a), array_get<n>(b))...))"
  },
  {
    "label": "array_zip_and_reduce()",
    "kind": "Method",
    "detail": "Function (} template<Reducer,Op,A,B,std::size_t N> EIGEN_STRONG_INLINE auto)",
    "insertText": "array_zip_and_reduce(array<A, N> a, array<B, N> b) -> decltype(h_array_zip_and_reduce<Reducer, Op, A, B, N>(a, b, typename gen_numeric_list<int, N>::type()))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<Op,A,std::size_t N,int . . . n> EIGEN_STRONG_INLINE array<)",
    "insertText": "decltype(Op::run(A())),N> h_array_apply(array<A, N> a, numeric_list<int, n...>)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "run(array_get<n>(a))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<Op,A,std::size_t N> EIGEN_STRONG_INLINE array<)",
    "insertText": "decltype(Op::run(A())),N> array_apply(array<A, N> a)"
  },
  {
    "label": "h_array_apply_and_reduce()",
    "kind": "Method",
    "detail": "Function (} template<Reducer,Op,A,std::size_t N,int . . . n> EIGEN_STRONG_INLINE auto)",
    "insertText": "h_array_apply_and_reduce(array<A, N> arr, numeric_list<int, n...>) -> decltype(reduce<Reducer, typename id_numeric<int,n,decltype(Op::run(A()))>::type...>::run(Op::run(array_get<n>(arr))...))"
  },
  {
    "label": "array_apply_and_reduce()",
    "kind": "Method",
    "detail": "Function (} template<Reducer,Op,A,std::size_t N> EIGEN_STRONG_INLINE auto)",
    "insertText": "array_apply_and_reduce(array<A, N> a) -> decltype(h_array_apply_and_reduce<Reducer, Op, A, N>(a, typename gen_numeric_list<int, N>::type()))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} template<int n> struct h_repeat { template<t,int . . . ii> EIGEN_STRONG_INLINE array<t,n>)",
    "insertText": "run(t v, numeric_list<int, ii...>)"
  },
  {
    "label": "repeat()",
    "kind": "Method",
    "detail": "Function (} } ; template<int n,t> array<t,n>)",
    "insertText": "repeat(t v)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} template<class InstType,ArrType,std::size_t N,bool Reverse,. . . Ps> struct h_instantiate_by_c_array ; template<class InstType,ArrType,std::size_t N,. . . Ps> struct h_instantiate_by_c_array<InstType,ArrType,N,false,Ps . . .> { InstType)",
    "insertText": "run(ArrType* arr, Ps... args)"
  },
  {
    "label": "instantiate_by_c_array()",
    "kind": "Method",
    "detail": "Function (} } ; template<class InstType,ArrType,std::size_t N,bool Reverse = false> InstType)",
    "insertText": "instantiate_by_c_array(ArrType* arr)"
  }
]