[
  {
    "label": "FName",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FName"
  },
  {
    "label": "FParticleID",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FParticleID"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FParticlePositionRotation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FParticlePositionRotation"
  },
  {
    "label": "FParticleVelocities",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FParticleVelocities"
  },
  {
    "label": "FParticleDynamics",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FParticleDynamics"
  },
  {
    "label": "FProxyBasePairProperty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FProxyBasePairProperty"
  },
  {
    "label": "FProxyBaseProperty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FProxyBaseProperty"
  },
  {
    "label": "FPhysicsObject",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPhysicsObject"
  },
  {
    "label": "FPhysicsObjectPairProperty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPhysicsObjectPairProperty"
  },
  {
    "label": "FPhysicsObjectProperty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPhysicsObjectProperty"
  },
  {
    "label": "FParticleMassProps",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FParticleMassProps"
  },
  {
    "label": "FParticleDynamicMisc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FParticleDynamicMisc"
  },
  {
    "label": "FParticleNonFrequentData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FParticleNonFrequentData"
  },
  {
    "label": "FCollisionData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCollisionData"
  },
  {
    "label": "FMaterialData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMaterialData"
  },
  {
    "label": "TDirtyFlags",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TDirtyFlags"
  },
  {
    "label": "FDirtyIdx",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDirtyIdx"
  },
  {
    "label": "TDirtyElementPool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TDirtyElementPool"
  },
  {
    "label": "FDirtyProxiesBucketInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDirtyProxiesBucketInfo"
  },
  {
    "label": "FDirtyPropertiesManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDirtyPropertiesManager"
  },
  {
    "label": "FDirtyChaosProperties",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDirtyChaosProperties"
  },
  {
    "label": "FShapeDirtyData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FShapeDirtyData"
  },
  {
    "label": "TPropertyPool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPropertyPool"
  },
  {
    "label": "FDirtyPropertiesPool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDirtyPropertiesPool"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" # include \" Chaos / ChaosArchive . h \" # include \" Chaos / Character / CharacterGroundConstraintSettings . h \" # include \" Chaos / Box . h \" # include \" Chaos / Particles . h \" # include \" Chaos / PhysicalMaterials . h \" # include \" Chaos / GeometryParticlesfwd . h \" # include \" Chaos / CollisionFilterData . h \" # include \" Chaos / Collision / CollisionConstraintFlags . h \" # include \" Chaos / KinematicTargets . h \" # include \" Chaos / RigidParticleControlFlags . h \" # include \" UObject / ExternalPhysicsCustomObjectVersion . h \" # include \" UObject / ExternalPhysicsMaterialCustomObjectVersion . h \" # include \" UObject / FortniteSeasonBranchObjectVersion . h \" # include \" UObject / PhysicsObjectVersion . h \" # include \" UObject / UE5MainStreamObjectVersion . h \" # include \" UObject / UE5ReleaseStreamObjectVersion . h \" # include \" Framework / PhysicsProxyBase . h \" # include \" Chaos / Evolution / IterationSettings . h \" # include \" PBDJointConstraintTypes . h \" # include \" PBDSuspensionConstraintTypes . h \" # ifndef CHAOS_DEBUG_NAME # define CHAOS_DEBUG_NAME 0 # endif class FName ; namespace Chaos { struct FParticleID { int32 GlobalID = INDEX_NONE ; int32 LocalID = INDEX_NONE ; bool)",
    "insertText": "operator(const FParticleID& Other)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FFortniteReleaseBranchCustomObjectVersion::GUID)"
  },
  {
    "label": "FRotation3()",
    "kind": "Method",
    "detail": "Function (Ar<<MX<<MR ; } else { FRotation3 DoublePrecisionRotation =)",
    "insertText": "FRotation3(MR)"
  },
  {
    "label": "FRotation3f()",
    "kind": "Method",
    "detail": "Function (Ar<<MX<<DoublePrecisionRotation ; MR =)",
    "insertText": "FRotation3f(MR)"
  },
  {
    "label": "CopyFrom()",
    "kind": "Method",
    "detail": "Function (} } template<TOther> void)",
    "insertText": "CopyFrom(const TOther& Other)"
  },
  {
    "label": "GetX()",
    "kind": "Method",
    "detail": "Function (MX = Other .)",
    "insertText": "GetX()"
  },
  {
    "label": "FRotation3f()",
    "kind": "Method",
    "detail": "Function (MR =)",
    "insertText": "FRotation3f(Other.GetR())"
  },
  {
    "label": "IsEqual()",
    "kind": "Method",
    "detail": "Function (} template<TOther> bool)",
    "insertText": "IsEqual(const TOther& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FParticlePositionRotation& Other)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (} const FVec3&)",
    "insertText": "X()"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (MX = InX ; } const FRotation3)",
    "insertText": "R()"
  },
  {
    "label": "GetR()",
    "kind": "Method",
    "detail": "Function (} const FRotation3)",
    "insertText": "GetR()"
  },
  {
    "label": "SetR()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetR(const FRotation3& InR)"
  },
  {
    "label": "FRotation3f()",
    "kind": "Method",
    "detail": "Function (MR =)",
    "insertText": "FRotation3f(InR)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : FVec3 MX ; FRotation3f MR ; } ; FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar,FParticlePositionRotation& Data)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "MVDouble()",
    "kind": "Method",
    "detail": "Function (Ar<<MV<<MW ; } else { FVec3)",
    "insertText": "MVDouble(MV)"
  },
  {
    "label": "MWDouble()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "MWDouble(MW)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (Ar<<MVDouble<<MWDouble ; MV =)",
    "insertText": "FVec3f(MVDouble)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (MW =)",
    "insertText": "FVec3f(MWDouble)"
  },
  {
    "label": "GetV()",
    "kind": "Method",
    "detail": "Function (MV = Other .)",
    "insertText": "GetV()"
  },
  {
    "label": "GetW()",
    "kind": "Method",
    "detail": "Function (MW = Other .)",
    "insertText": "GetW()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FParticleVelocities& Other)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "V()"
  },
  {
    "label": "SetV()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetV(const FVec3& V)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (MV =)",
    "insertText": "FVec3f(V)"
  },
  {
    "label": "W()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "W()"
  },
  {
    "label": "SetW()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetW(const FVec3& W)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (MW =)",
    "insertText": "FVec3f(W)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : FVec3f MV ; FVec3f MW ; } ; FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar,FParticleVelocities& Data)"
  },
  {
    "label": "AccelerationDouble()",
    "kind": "Method",
    "detail": "Function (Ar<<MAcceleration ; Ar<<MAngularAcceleration ; Ar<<MLinearImpulseVelocity ; Ar<<MAngularImpulseVelocity ; } else { FVec3)",
    "insertText": "AccelerationDouble(MAcceleration)"
  },
  {
    "label": "AngularAccelerationDouble()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "AngularAccelerationDouble(MAngularAcceleration)"
  },
  {
    "label": "LinearImpulseVelocityDouble()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "LinearImpulseVelocityDouble(MLinearImpulseVelocity)"
  },
  {
    "label": "AngularImpulseVelocityDouble()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "AngularImpulseVelocityDouble(MAngularImpulseVelocity)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (Ar<<AccelerationDouble ; Ar<<AngularAccelerationDouble ; Ar<<LinearImpulseVelocityDouble ; Ar<<AngularImpulseVelocityDouble ; MAcceleration =)",
    "insertText": "FVec3f(AccelerationDouble)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (MAngularAcceleration =)",
    "insertText": "FVec3f(AngularAccelerationDouble)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (MLinearImpulseVelocity =)",
    "insertText": "FVec3f(LinearImpulseVelocityDouble)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (MAngularImpulseVelocity =)",
    "insertText": "FVec3f(AngularImpulseVelocityDouble)"
  },
  {
    "label": "Acceleration()",
    "kind": "Method",
    "detail": "Function (MAcceleration = Other .)",
    "insertText": "Acceleration()"
  },
  {
    "label": "AngularAcceleration()",
    "kind": "Method",
    "detail": "Function (MAngularAcceleration = Other .)",
    "insertText": "AngularAcceleration()"
  },
  {
    "label": "LinearImpulseVelocity()",
    "kind": "Method",
    "detail": "Function (MLinearImpulseVelocity = Other .)",
    "insertText": "LinearImpulseVelocity()"
  },
  {
    "label": "AngularImpulseVelocity()",
    "kind": "Method",
    "detail": "Function (MAngularImpulseVelocity = Other .)",
    "insertText": "AngularImpulseVelocity()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FParticleDynamics& Other)"
  },
  {
    "label": "SetAcceleration()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAcceleration(const FVec3& Acceleration)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (MAcceleration =)",
    "insertText": "FVec3f(Acceleration)"
  },
  {
    "label": "SetAngularAcceleration()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAngularAcceleration(const FVec3& AngularAcceleration)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (MAngularAcceleration =)",
    "insertText": "FVec3f(AngularAcceleration)"
  },
  {
    "label": "SetLinearImpulseVelocity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetLinearImpulseVelocity(const FVec3& LinearImpulseVelocity)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (MLinearImpulseVelocity =)",
    "insertText": "FVec3f(LinearImpulseVelocity)"
  },
  {
    "label": "SetAngularImpulseVelocity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAngularImpulseVelocity(const FVec3& AngularImpulseVelocity)"
  },
  {
    "label": "FVec3f()",
    "kind": "Method",
    "detail": "Function (MAngularImpulseVelocity =)",
    "insertText": "FVec3f(AngularImpulseVelocity)"
  },
  {
    "label": "ZeroValue()",
    "kind": "Method",
    "detail": "Function (} FParticleDynamics)",
    "insertText": "ZeroValue()"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (FParticleDynamics Result ; Result . MAcceleration =)",
    "insertText": "FVec3(0)"
  },
  {
    "label": "CenterOfMass()",
    "kind": "Method",
    "detail": "Function (MCenterOfMass = Other .)",
    "insertText": "CenterOfMass()"
  },
  {
    "label": "RotationOfMass()",
    "kind": "Method",
    "detail": "Function (MRotationOfMass = Other .)",
    "insertText": "RotationOfMass()"
  },
  {
    "label": "I()",
    "kind": "Method",
    "detail": "Function (MI = Other .)",
    "insertText": "I()"
  },
  {
    "label": "InvI()",
    "kind": "Method",
    "detail": "Function (MInvI = Other .)",
    "insertText": "InvI()"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (MM = Other .)",
    "insertText": "M()"
  },
  {
    "label": "InvM()",
    "kind": "Method",
    "detail": "Function (MInvM = Other .)",
    "insertText": "InvM()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FParticleMassProps& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MInvM = InInvM ; } private : FVec3 MCenterOfMass ; FRotation3 MRotationOfMass ; TVec3<FRealSingle> MI ; TVec3<FRealSingle> MInvI ; FReal MM ; FReal MInvM ; } ; FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar,FParticleMassProps& Data)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FUE5ReleaseStreamObjectVersion::GUID)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FUE5MainStreamObjectVersion::GUID)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FExternalPhysicsCustomObjectVersion::GUID)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FPhysicsObjectVersion::GUID)"
  },
  {
    "label": "CustomVer()",
    "kind": "Method",
    "detail": "Function (const bool bSinglePrecision = Ar .)",
    "insertText": "CustomVer(FFortniteReleaseBranchCustomObjectVersion::GUID)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (Ar<<MLinearEtherDrag ; Ar<<MAngularEtherDrag ; } else { FReal LinearEtherDragDouble =)",
    "insertText": "FReal(MLinearEtherDrag)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (FReal AngularEtherDragDouble =)",
    "insertText": "FReal(MAngularEtherDrag)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (Ar<<LinearEtherDragDouble ; Ar<<AngularEtherDragDouble ; MLinearEtherDrag =)",
    "insertText": "FRealSingle(LinearEtherDragDouble)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (MAngularEtherDrag =)",
    "insertText": "FRealSingle(AngularEtherDragDouble)"
  },
  {
    "label": "bAddControlFlags()",
    "kind": "Method",
    "detail": "Function (} Ar<<MObjectState ; const bool)",
    "insertText": "bAddControlFlags(Ar.CustomVer(FUE5MainStreamObjectVersion::GUID) >= FUE5MainStreamObjectVersion::AddRigidParticleControlFlags)"
  },
  {
    "label": "SetGravityEnabled()",
    "kind": "Method",
    "detail": "Function (bool bGravityEnabled ; Ar<<bGravityEnabled ; MControlFlags .)",
    "insertText": "SetGravityEnabled(bGravityEnabled)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} Ar<<MSleepType ;)",
    "insertText": "if(!bAddControlFlags && Ar.IsLoading())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bOneWayInteraction = false ;)",
    "insertText": "if(Ar.CustomVer(FExternalPhysicsCustomObjectVersion::GUID) >= FExternalPhysicsCustomObjectVersion::AddOneWayInteraction)"
  },
  {
    "label": "SetOneWayInteractionEnabled()",
    "kind": "Method",
    "detail": "Function (Ar<<bOneWayInteraction ; } MControlFlags .)",
    "insertText": "SetOneWayInteractionEnabled(bOneWayInteraction)"
  },
  {
    "label": "SetCCDEnabled()",
    "kind": "Method",
    "detail": "Function (bool bCCDEnabled ; Ar<<bCCDEnabled ; MControlFlags .)",
    "insertText": "SetCCDEnabled(bCCDEnabled)"
  },
  {
    "label": "bAddCollisionConstraintFlagUE4()",
    "kind": "Method",
    "detail": "Function (} } const bool)",
    "insertText": "bAddCollisionConstraintFlagUE4(Ar.CustomVer(FPhysicsObjectVersion::GUID) >= FPhysicsObjectVersion::AddCollisionConstraintFlag)"
  },
  {
    "label": "bAddCollisionConstraintFlagUE5()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bAddCollisionConstraintFlagUE5(Ar.CustomVer(FUE5MainStreamObjectVersion::GUID) >= FUE5MainStreamObjectVersion::AddCollisionConstraintFlag)"
  },
  {
    "label": "bAddDisableFlagUE4()",
    "kind": "Method",
    "detail": "Function (Ar<<MCollisionConstraintFlag ; } const bool)",
    "insertText": "bAddDisableFlagUE4(Ar.CustomVer(FPhysicsObjectVersion::GUID) >= FPhysicsObjectVersion::AddDisabledFlag)"
  },
  {
    "label": "bAddDisableFlagUE5()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bAddDisableFlagUE5(Ar.CustomVer(FUE5MainStreamObjectVersion::GUID) >= FUE5MainStreamObjectVersion::AddDisabledFlag)"
  },
  {
    "label": "bAddChaosMaxLinearAngularSpeedUE4()",
    "kind": "Method",
    "detail": "Function (Ar<<bDisabled ; } const bool)",
    "insertText": "bAddChaosMaxLinearAngularSpeedUE4(Ar.CustomVer(FPhysicsObjectVersion::GUID) >= FPhysicsObjectVersion::AddChaosMaxLinearAngularSpeed)"
  },
  {
    "label": "bAddChaosMaxLinearAngularSpeedUE5()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bAddChaosMaxLinearAngularSpeedUE5(Ar.CustomVer(FUE5ReleaseStreamObjectVersion::GUID) >= FUE5ReleaseStreamObjectVersion::AddChaosMaxLinearAngularSpeed)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (Ar<<MMaxLinearSpeedSq ; Ar<<MMaxAngularSpeedSq ; } else { FReal MaxLinearSpeedSqDouble =)",
    "insertText": "FReal(MMaxLinearSpeedSq)"
  },
  {
    "label": "FReal()",
    "kind": "Method",
    "detail": "Function (FReal MaxAngularSpeedSqDouble =)",
    "insertText": "FReal(MMaxAngularSpeedSq)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (Ar<<MaxLinearSpeedSqDouble ; Ar<<MaxAngularSpeedSqDouble ; MMaxLinearSpeedSq =)",
    "insertText": "FRealSingle(MaxLinearSpeedSqDouble)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (MMaxAngularSpeedSq =)",
    "insertText": "FRealSingle(MaxAngularSpeedSqDouble)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(Ar.IsLoading())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MInitialOverlapDepenetrationVelocity = 0 ; MSleepThresholdMultiplier = 1 . 0 f ; })",
    "insertText": "if(bAddControlFlags)"
  },
  {
    "label": "SetLinearEtherDrag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLinearEtherDrag(Other.LinearEtherDrag())"
  },
  {
    "label": "SetAngularEtherDrag()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAngularEtherDrag(Other.AngularEtherDrag())"
  },
  {
    "label": "SetMaxLinearSpeedSq()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaxLinearSpeedSq(Other.MaxLinearSpeedSq())"
  },
  {
    "label": "SetMaxAngularSpeedSq()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaxAngularSpeedSq(Other.MaxAngularSpeedSq())"
  },
  {
    "label": "SetInitialOverlapDepenetrationVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetInitialOverlapDepenetrationVelocity(Other.InitialOverlapDepenetrationVelocity())"
  },
  {
    "label": "SetSleepThresholdMultiplier()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSleepThresholdMultiplier(Other.SleepThresholdMultiplier())"
  },
  {
    "label": "SetObjectState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetObjectState(Other.ObjectState())"
  },
  {
    "label": "SetCollisionGroup()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCollisionGroup(Other.CollisionGroup())"
  },
  {
    "label": "SetSleepType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSleepType(Other.SleepType())"
  },
  {
    "label": "SetCollisionConstraintFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCollisionConstraintFlags(Other.CollisionConstraintFlags())"
  },
  {
    "label": "SetControlFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetControlFlags(Other.ControlFlags())"
  },
  {
    "label": "SetDisabled()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDisabled(Other.Disabled())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FParticleDynamicMisc& Other)"
  },
  {
    "label": "LinearEtherDrag()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "LinearEtherDrag()"
  },
  {
    "label": "SetLinearEtherDrag()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetLinearEtherDrag(FReal InLinearEtherDrag)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (MLinearEtherDrag =)",
    "insertText": "FRealSingle(InLinearEtherDrag)"
  },
  {
    "label": "AngularEtherDrag()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "AngularEtherDrag()"
  },
  {
    "label": "SetAngularEtherDrag()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAngularEtherDrag(FReal InAngularEtherDrag)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (MAngularEtherDrag =)",
    "insertText": "FRealSingle(InAngularEtherDrag)"
  },
  {
    "label": "MaxLinearSpeedSq()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "MaxLinearSpeedSq()"
  },
  {
    "label": "SetMaxLinearSpeedSq()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetMaxLinearSpeedSq(FReal InMaxLinearSpeed)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (MMaxLinearSpeedSq =)",
    "insertText": "FRealSingle(InMaxLinearSpeed)"
  },
  {
    "label": "MaxAngularSpeedSq()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "MaxAngularSpeedSq()"
  },
  {
    "label": "SetMaxAngularSpeedSq()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetMaxAngularSpeedSq(FReal InMaxAngularSpeed)"
  },
  {
    "label": "FRealSingle()",
    "kind": "Method",
    "detail": "Function (MMaxAngularSpeedSq =)",
    "insertText": "FRealSingle(InMaxAngularSpeed)"
  },
  {
    "label": "InitialOverlapDepenetrationVelocity()",
    "kind": "Method",
    "detail": "Function (} FRealSingle)",
    "insertText": "InitialOverlapDepenetrationVelocity()"
  },
  {
    "label": "SleepThresholdMultiplier()",
    "kind": "Method",
    "detail": "Function (MInitialOverlapDepenetrationVelocity = InVel ; } FRealSingle)",
    "insertText": "SleepThresholdMultiplier()"
  },
  {
    "label": "ObjectState()",
    "kind": "Method",
    "detail": "Function (MSleepThresholdMultiplier = InSleepThresholdMultiplier ; } EObjectStateType)",
    "insertText": "ObjectState()"
  },
  {
    "label": "GravityEnabled()",
    "kind": "Method",
    "detail": "Function (MObjectState = InState ; } bool)",
    "insertText": "GravityEnabled()"
  },
  {
    "label": "SetGravityEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetGravityEnabled(bool bInGravity)"
  },
  {
    "label": "SetGravityEnabled()",
    "kind": "Method",
    "detail": "Function (MControlFlags .)",
    "insertText": "SetGravityEnabled(bInGravity)"
  },
  {
    "label": "GravityGroupIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GravityGroupIndex()"
  },
  {
    "label": "SetGravityGroupIndex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetGravityGroupIndex(int32 InIndex)"
  },
  {
    "label": "SetGravityGroupIndex()",
    "kind": "Method",
    "detail": "Function (MControlFlags .)",
    "insertText": "SetGravityGroupIndex(InIndex)"
  },
  {
    "label": "UpdateKinematicFromSimulation()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "UpdateKinematicFromSimulation()"
  },
  {
    "label": "SetUpdateKinematicFromSimulation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetUpdateKinematicFromSimulation(bool bUpdateKinematicFromSimulation)"
  },
  {
    "label": "SetUpdateKinematicFromSimulation()",
    "kind": "Method",
    "detail": "Function (MControlFlags .)",
    "insertText": "SetUpdateKinematicFromSimulation(bUpdateKinematicFromSimulation)"
  },
  {
    "label": "CCDEnabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CCDEnabled()"
  },
  {
    "label": "SetCCDEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCCDEnabled(bool bInCCDEnabled)"
  },
  {
    "label": "SetCCDEnabled()",
    "kind": "Method",
    "detail": "Function (MControlFlags .)",
    "insertText": "SetCCDEnabled(bInCCDEnabled)"
  },
  {
    "label": "MACDEnabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "MACDEnabled()"
  },
  {
    "label": "SetMACDEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetMACDEnabled(bool bInCCDEnabled)"
  },
  {
    "label": "SetMACDEnabled()",
    "kind": "Method",
    "detail": "Function (MControlFlags .)",
    "insertText": "SetMACDEnabled(bInCCDEnabled)"
  },
  {
    "label": "SetPositionSolverIterationCount()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetPositionSolverIterationCount(const int32 PositionSolverIterationCountIn)"
  },
  {
    "label": "SetNumPositionIterations()",
    "kind": "Method",
    "detail": "Function (MIterationSettings .)",
    "insertText": "SetNumPositionIterations(PositionSolverIterationCountIn)"
  },
  {
    "label": "SetVelocitySolverIterationCount()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetVelocitySolverIterationCount(const int32 VelocitySolverIterationCountIn)"
  },
  {
    "label": "SetNumVelocityIterations()",
    "kind": "Method",
    "detail": "Function (MIterationSettings .)",
    "insertText": "SetNumVelocityIterations(VelocitySolverIterationCountIn)"
  },
  {
    "label": "SetProjectionSolverIterationCount()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetProjectionSolverIterationCount(const int32 ProjectionSolverIterationCountIn)"
  },
  {
    "label": "SetNumProjectionIterations()",
    "kind": "Method",
    "detail": "Function (MIterationSettings .)",
    "insertText": "SetNumProjectionIterations(ProjectionSolverIterationCountIn)"
  },
  {
    "label": "IterationSettings()",
    "kind": "Method",
    "detail": "Function (} Private::FIterationSettings)",
    "insertText": "IterationSettings()"
  },
  {
    "label": "Disabled()",
    "kind": "Method",
    "detail": "Function (MIterationSettings = SolverIterationSettings ; } bool)",
    "insertText": "Disabled()"
  },
  {
    "label": "CollisionGroup()",
    "kind": "Method",
    "detail": "Function (bDisabled = bInDisabled ; } int32)",
    "insertText": "CollisionGroup()"
  },
  {
    "label": "SleepType()",
    "kind": "Method",
    "detail": "Function (MCollisionGroup = InGroup ; } ESleepType)",
    "insertText": "SleepType()"
  },
  {
    "label": "CollisionConstraintFlags()",
    "kind": "Method",
    "detail": "Function (MSleepType = Type ; } uint32)",
    "insertText": "CollisionConstraintFlags()"
  },
  {
    "label": "AddCollisionConstraintFlag()",
    "kind": "Method",
    "detail": "Function (MCollisionConstraintFlag = InCollisionConstraintFlag ; } void)",
    "insertText": "AddCollisionConstraintFlag(const ECollisionConstraintFlags Flag)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (MCollisionConstraintFlag | =)",
    "insertText": "uint32(Flag)"
  },
  {
    "label": "RemoveCollisionConstraintFlag()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveCollisionConstraintFlag(const ECollisionConstraintFlags Flag)"
  },
  {
    "label": "OneWayInteraction()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "OneWayInteraction()"
  },
  {
    "label": "SetOneWayInteraction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetOneWayInteraction(bool bInOneWayInteraction)"
  },
  {
    "label": "SetOneWayInteractionEnabled()",
    "kind": "Method",
    "detail": "Function (MControlFlags .)",
    "insertText": "SetOneWayInteractionEnabled(bInOneWayInteraction)"
  },
  {
    "label": "InertiaConditioningEnabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "InertiaConditioningEnabled()"
  },
  {
    "label": "SetInertiaConditioningEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetInertiaConditioningEnabled(bool bInEnabled)"
  },
  {
    "label": "SetInertiaConditioningEnabled()",
    "kind": "Method",
    "detail": "Function (MControlFlags .)",
    "insertText": "SetInertiaConditioningEnabled(bInEnabled)"
  },
  {
    "label": "ControlFlags()",
    "kind": "Method",
    "detail": "Function (} FRigidParticleControlFlags)",
    "insertText": "ControlFlags()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MControlFlags = InFlags ; } private : FRealSingle MLinearEtherDrag ; FRealSingle MAngularEtherDrag ; FRealSingle MMaxLinearSpeedSq ; FRealSingle MMaxAngularSpeedSq ; FRealSingle MInitialOverlapDepenetrationVelocity = 0 ; FRealSingle MSleepThresholdMultiplier = 1 ; int32 MCollisionGroup ; EObjectStateType MObjectState ; EResimType MResimType ; ESleepType MSleepType ; uint32 MCollisionConstraintFlag = 0 ; FRigidParticleControlFlags MControlFlags ; Chaos::Private::FIterationSettings MIterationSettings ; bool bDisabled ; } ; FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar,FParticleDynamicMisc& Data)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Serialize(FChaosArchive& Ar)"
  },
  {
    "label": "SerializePtr()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "SerializePtr(MGeometry)"
  },
  {
    "label": "SetGeometry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetGeometry(Other.GetGeometry())"
  },
  {
    "label": "SetUniqueIdx()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetUniqueIdx(Other.UniqueIdx())"
  },
  {
    "label": "SetSpatialIdx()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSpatialIdx(Other.SpatialIdx())"
  },
  {
    "label": "SetResimType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetResimType(Other.ResimType())"
  },
  {
    "label": "SetEnabledDuringResim()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetEnabledDuringResim(Other.EnabledDuringResim())"
  },
  {
    "label": "SetDebugName()",
    "kind": "Method",
    "detail": "Function (# if CHAOS_DEBUG_NAME)",
    "insertText": "SetDebugName(Other.DebugName())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FParticleNonFrequentData& Other)"
  },
  {
    "label": "AccessGeometryDangerous()",
    "kind": "Method",
    "detail": "Function (} FImplicitObject*)",
    "insertText": "AccessGeometryDangerous()"
  },
  {
    "label": "GetGeometry()",
    "kind": "Method",
    "detail": "Function (} const FImplicitObjectRef)",
    "insertText": "GetGeometry()"
  },
  {
    "label": "SetGeometry()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetGeometry(const FImplicitObjectPtr& InGeometry)"
  },
  {
    "label": "DummyPtr()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<const FImplicitObject,ESPMode::ThreadSafe>)",
    "insertText": "DummyPtr(nullptr)"
  },
  {
    "label": "UniqueIdx()",
    "kind": "Method",
    "detail": "Function (} const FUniqueIdx&)",
    "insertText": "UniqueIdx()"
  },
  {
    "label": "SpatialIdx()",
    "kind": "Method",
    "detail": "Function (MUniqueIdx = InIdx ; } FSpatialAccelerationIdx)",
    "insertText": "SpatialIdx()"
  },
  {
    "label": "ResimType()",
    "kind": "Method",
    "detail": "Function (MSpatialIdx = InIdx ; } EResimType)",
    "insertText": "ResimType()"
  },
  {
    "label": "SetParticleID()",
    "kind": "Method",
    "detail": "Function (MResimType = InType ; } void)",
    "insertText": "SetParticleID(const FParticleID& ParticleID)"
  },
  {
    "label": "ParticleID()",
    "kind": "Method",
    "detail": "Function (MParticleID = ParticleID ; } const FParticleID&)",
    "insertText": "ParticleID()"
  },
  {
    "label": "DebugName()",
    "kind": "Method",
    "detail": "Function (MEnabledDuringResim = bEnabledDuringResim ; } # if CHAOS_DEBUG_NAME const TSharedPtr<FString,ESPMode::ThreadSafe>&)",
    "insertText": "DebugName()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MDebugName = InName ; } # endif private : FImplicitObjectPtr MGeometry ; FUniqueIdx MUniqueIdx ; FSpatialAccelerationIdx MSpatialIdx ; FParticleID MParticleID ; EResimType MResimType ; bool MEnabledDuringResim ; # if CHAOS_DEBUG_NAME TSharedPtr<FString,ESPMode::ThreadSafe> MDebugName ; # endif } ; FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar,FParticleNonFrequentData& Data)"
  },
  {
    "label": "HasCollisionData()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasCollisionData()"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FExternalPhysicsMaterialCustomObjectVersion::GUID)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FFortniteSeasonBranchObjectVersion::GUID)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<QueryData ; Ar<<SimData ;)",
    "insertText": "if(Ar.CustomVer(FExternalPhysicsCustomObjectVersion::GUID) >= FExternalPhysicsCustomObjectVersion::AddShapeSimAndQueryCollisionEnabled)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int8 EnableSim = bSimCollision ; int8 EnableQuery = bQueryCollision ; Ar<<EnableSim ; Ar<<EnableQuery ; bSimCollision = EnableSim ; bQueryCollision = EnableQuery ; } else)",
    "insertText": "if(Ar.CustomVer(FExternalPhysicsCustomObjectVersion::GUID) >= FExternalPhysicsCustomObjectVersion::AddShapeCollisionDisable)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool Disable = ! bSimCollision ; Ar<<Disable ; bSimCollision = ! Disable ; })",
    "insertText": "if(Ar.CustomVer(FExternalPhysicsCustomObjectVersion::GUID) >= FExternalPhysicsCustomObjectVersion::SerializePerShapeDataSimulateFlag && Ar.CustomVer(FExternalPhysicsCustomObjectVersion::GUID) < FExternalPhysicsCustomObjectVersion::RemoveShapeSimAndQueryDuplicateRepresentations)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool Simulate = bSimCollision ; Ar<<Simulate ; bSimCollision = Simulate ; })",
    "insertText": "if(Ar.CustomVer(FExternalPhysicsCustomObjectVersion::GUID) >= FExternalPhysicsCustomObjectVersion::SerializeCollisionTraceType)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Data(int32)"
  },
  {
    "label": "CollisionTraceType()",
    "kind": "Method",
    "detail": "Function (Ar<<Data ;)",
    "insertText": "CollisionTraceType(EChaosCollisionTraceFlag)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Ar.CustomVer(FFortniteSeasonBranchObjectVersion::GUID) >= FFortniteSeasonBranchObjectVersion::AddShapeIsProbe)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (int8 IsProbe = bIsProbe ; Ar<<IsProbe ; bIsProbe = IsProbe ; } } } ; FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar,FCollisionData& Data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<Materials ; })",
    "insertText": "if(Ar.CustomVer(FExternalPhysicsMaterialCustomObjectVersion::GUID) >= FExternalPhysicsMaterialCustomObjectVersion::AddedMaterialMasks)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Ar<<MaterialMasks<<MaterialMaskMaps<<MaterialMaskMapMaterials ; } } } ; FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar,FMaterialData& Data)"
  },
  {
    "label": "CHAOS_PROPERTY()",
    "kind": "Method",
    "detail": "Function (# include \" ParticleProperties . inl \" NumProperties } ; # undef CHAOS_PROPERTY # define)",
    "insertText": "CHAOS_PROPERTY(PropName, Type, ProxyType) PropName = (uint32)1 << (uint32)"
  },
  {
    "label": "ChaosPropertyToFlag()",
    "kind": "Method",
    "detail": "Function (# include \" ParticleProperties . inl \" DummyFlag } ; # undef CHAOS_PROPERTY EChaosPropertyFlags)",
    "insertText": "ChaosPropertyToFlag(EChaosProperty Prop)"
  },
  {
    "label": "CHAOS_PROPERTY()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "CHAOS_PROPERTY(PropName, Type, ProxyType)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# include \" ParticleProperties . inl \" # undef CHAOS_PROPERTY default :)",
    "insertText": "return(EChaosPropertyFlags)"
  },
  {
    "label": "SHAPE_PROPERTY()",
    "kind": "Method",
    "detail": "Function (} } # define)",
    "insertText": "SHAPE_PROPERTY(PropName, Type)"
  },
  {
    "label": "SHAPE_PROPERTY()",
    "kind": "Method",
    "detail": "Function (# include \" ShapeProperties . inl \" NumShapeProperties } ; # undef SHAPE_PROPERTY # define)",
    "insertText": "SHAPE_PROPERTY(PropName, Type) PropName = (uint32)1 << (uint32)"
  },
  {
    "label": "ShapePropToFlag()",
    "kind": "Method",
    "detail": "Function (# include \" ShapeProperties . inl \" DummyFlag } ; # undef SHAPE_PROPERTY EShapeFlags)",
    "insertText": "ShapePropToFlag(EShapeProperty Prop)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# include \" ShapeProperties . inl \" # undef SHAPE_PROPERTY default :)",
    "insertText": "return(EShapeFlags)"
  },
  {
    "label": "TDirtyFlags()",
    "kind": "Method",
    "detail": "Function (} } template<FlagsType> class TDirtyFlags { public :)",
    "insertText": "TDirtyFlags() : Bits(0)"
  },
  {
    "label": "IsDirty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDirty()"
  },
  {
    "label": "IsDirty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDirty(const int32 CheckBits)"
  },
  {
    "label": "MarkDirty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MarkDirty(const FlagsType DirtyBits)"
  },
  {
    "label": "Bits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Bits(int32)"
  },
  {
    "label": "MarkClean()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MarkClean(const FlagsType CleanBits)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Clear()"
  },
  {
    "label": "IsClean()",
    "kind": "Method",
    "detail": "Function (Bits = 0 ; } bool)",
    "insertText": "IsClean()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Elements [ Idx ] =)",
    "insertText": "T()"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetNum(int32 Num)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Elements .)",
    "insertText": "SetNum(Num)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Num()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} private : TArray<T> Elements ; } ; struct FDirtyProxiesBucketInfo { int32)",
    "insertText": "Num(uint32)(EPhysicsProxyType::Count)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} ; int32 TotalNum = 0 ; void)",
    "insertText": "Reset()"
  },
  {
    "label": "GetBucketIdx()",
    "kind": "Method",
    "detail": "Function (Num [ Idx ] = 0 ; } TotalNum = 0 ; } void)",
    "insertText": "GetBucketIdx(int32 Idx, int32& OutBucketIdx, int32& InnerIdx)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 Remaining = Idx ;)",
    "insertText": "for(int32 BucketIdx = 0; BucketIdx < (uint32)EPhysicsProxyType::Count; ++BucketIdx)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (InnerIdx = Remaining ; OutBucketIdx = BucketIdx ; return ; } else { Remaining - = Num [ BucketIdx ] ; } })",
    "insertText": "check(false)"
  },
  {
    "label": "PrepareBuckets()",
    "kind": "Method",
    "detail": "Function (} } ; class FDirtyPropertiesManager { public : void)",
    "insertText": "PrepareBuckets(const FDirtyProxiesBucketInfo& DirtyProxiesBucketInfo)"
  },
  {
    "label": "CHAOS_PROPERTY()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "CHAOS_PROPERTY(PropName, Type, ProxyType) PropName##Pool.SetNum(DirtyProxiesBucketInfo.Num[(uint32)ProxyType])"
  },
  {
    "label": "SetNumShapes()",
    "kind": "Method",
    "detail": "Function (# include \" ParticleProperties . inl \" # undef CHAOS_PROPERTY } void)",
    "insertText": "SetNumShapes(int32 NumShapes)"
  },
  {
    "label": "SHAPE_PROPERTY()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "SHAPE_PROPERTY(PropName, Type) PropName##ShapePool.SetNum(NumShapes)"
  },
  {
    "label": "GetChaosPropertyPool()",
    "kind": "Method",
    "detail": "Function (# include \" ShapeProperties . inl \" # undef SHAPE_PROPERTY } template<T,EChaosProperty PropName> TDirtyElementPool<T>&)",
    "insertText": "GetChaosPropertyPool()"
  },
  {
    "label": "CHAOS_PROPERTY()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "CHAOS_PROPERTY(PropName, Type, ProxyType) case EChaosProperty::PropName: return (TDirtyElementPool<T>&)"
  },
  {
    "label": "GetShapePool()",
    "kind": "Method",
    "detail": "Function (} TDirtyElementPool<T> ErrorPool ; return ErrorPool ; } template<T,EShapeProperty PropName> TDirtyElementPool<T>&)",
    "insertText": "GetShapePool()"
  },
  {
    "label": "SHAPE_PROPERTY()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "SHAPE_PROPERTY(PropName, Type) case EShapeProperty::PropName: return (TDirtyElementPool<T>&)"
  },
  {
    "label": "SetParticleBufferType()",
    "kind": "Method",
    "detail": "Function (# include \" ShapeProperties . inl \" # undef SHAPE_PROPERTY } ; class FDirtyChaosProperties { public : void)",
    "insertText": "SetParticleBufferType(EParticleType Type)"
  },
  {
    "label": "GetParticleBufferType()",
    "kind": "Method",
    "detail": "Function (ParticleBufferType = Type ; } EParticleType)",
    "insertText": "GetParticleBufferType()"
  },
  {
    "label": "GetFlags()",
    "kind": "Method",
    "detail": "Function (Flags = InFlags ; } FDirtyChaosPropertyFlags)",
    "insertText": "GetFlags()"
  },
  {
    "label": "MarkDirty()",
    "kind": "Method",
    "detail": "Function (Flags .)",
    "insertText": "MarkDirty(Flag)"
  },
  {
    "label": "SyncRemote()",
    "kind": "Method",
    "detail": "Function (} template<T,EChaosProperty PropName> void)",
    "insertText": "SyncRemote(FDirtyPropertiesManager& Manager, int32 Idx, const T& Val)"
  },
  {
    "label": "PropName()",
    "kind": "Method",
    "detail": "Function (Manager . GetChaosPropertyPool<T,)",
    "insertText": "PropName().GetElement(Idx)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Clear(FDirtyPropertiesManager& Manager, int32 Idx)"
  },
  {
    "label": "CHAOS_PROPERTY()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "CHAOS_PROPERTY(PropName, Type, ProxyType) ClearHelper<Type, EChaosProperty::PropName>(Manager, Idx)"
  },
  {
    "label": "IsDirty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDirty(EChaosPropertyFlags InBits)"
  },
  {
    "label": "CHAOS_PROPERTY()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "CHAOS_PROPERTY(PropName, Type, ProxyType)\\ Type const & Get##PropName(const FDirtyPropertiesManager& Manager, int32 Idx)"
  },
  {
    "label": "PropName()",
    "kind": "Method",
    "detail": "Function (} \\ bool Has # #)",
    "insertText": "PropName()"
  },
  {
    "label": "PropName()",
    "kind": "Method",
    "detail": "Function (} \\ Type const* Find # #)",
    "insertText": "PropName(const FDirtyPropertiesManager& Manager, int32 Idx)"
  },
  {
    "label": "ReadImp()",
    "kind": "Method",
    "detail": "Function (} # include \" ParticleProperties . inl \" # undef CHAOS_PROPERTY private : FDirtyChaosPropertyFlags Flags ; EParticleType ParticleBufferType ; template<T,EChaosProperty PropName> const T&)",
    "insertText": "ReadImp(const FDirtyPropertiesManager& Manager, int32 Idx)"
  },
  {
    "label": "ClearHelper()",
    "kind": "Method",
    "detail": "Function (} template<T,EChaosProperty PropName> void)",
    "insertText": "ClearHelper(FDirtyPropertiesManager& Manager, int32 Idx)"
  },
  {
    "label": "PropName()",
    "kind": "Method",
    "detail": "Function (Manager . GetChaosPropertyPool<T,)",
    "insertText": "PropName().Reset(Idx)"
  },
  {
    "label": "FShapeDirtyData()",
    "kind": "Method",
    "detail": "Function (} } } ; class FShapeDirtyData { public :)",
    "insertText": "FShapeDirtyData(int32 InShapeIdx) : ShapeIdx(InShapeIdx)"
  },
  {
    "label": "GetShapeIdx()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetShapeIdx()"
  },
  {
    "label": "SyncRemote()",
    "kind": "Method",
    "detail": "Function (Flags = InFlags ; } template<T,EShapeProperty PropName> void)",
    "insertText": "SyncRemote(FDirtyPropertiesManager& Manager,int32 Idx, const T& Val)"
  },
  {
    "label": "SHAPE_PROPERTY()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "SHAPE_PROPERTY(PropName, Type) ClearHelper<Type, EShapeProperty::PropName>(Manager, Idx)"
  },
  {
    "label": "SHAPE_PROPERTY()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "SHAPE_PROPERTY(PropName, Type)\\ Type const & Get##PropName(const FDirtyPropertiesManager& Manager, int32 Idx)"
  },
  {
    "label": "AddElement()",
    "kind": "Method",
    "detail": "Function (} } } ; template<T> class TPropertyPool ; using FPropertyIdx = int32 ; template<T> class TPropertyPool { public : T&)",
    "insertText": "AddElement(FPropertyIdx& OutIdx)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (OutIdx = FreeList .)",
    "insertText": "Pop()"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (FreeList .)",
    "insertText": "Push(Idx)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "GetElement(const FPropertyIdx Idx)"
  },
  {
    "label": "GetPool()",
    "kind": "Method",
    "detail": "Function (} private : TArray<T> Elements ; TArray<FPropertyIdx> FreeList ; } ; class FDirtyPropertiesPool { public : template<T,EChaosProperty PropName> TPropertyPool<T>&)",
    "insertText": "GetPool()"
  },
  {
    "label": "CHAOS_PROPERTY()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "CHAOS_PROPERTY(PropName, Type, ProxyType) case EChaosProperty::PropName: return (TPropertyPool<T>&)"
  }
]