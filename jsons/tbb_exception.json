[
  {
    "label": "bad_last_alloc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "bad_last_alloc"
  },
  {
    "label": "improper_lock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "improper_lock"
  },
  {
    "label": "user_abort",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "user_abort"
  },
  {
    "label": "missing_wait",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "missing_wait"
  },
  {
    "label": "invalid_multiple_scheduling",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "invalid_multiple_scheduling"
  },
  {
    "label": "exception_id",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "exception_id"
  },
  {
    "label": "tbb_exception",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "tbb_exception"
  },
  {
    "label": "captured_exception",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "captured_exception"
  },
  {
    "label": "movable_exception",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "movable_exception"
  },
  {
    "label": "tbb_exception_ptr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "tbb_exception_ptr"
  },
  {
    "label": "what()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_exception_H # define __TBB_exception_H # include \" tbb_stddef . h \" # include<exception> # include<new> # include<string> namespace tbb { class bad_last_alloc : public std::bad_alloc { public : const char*)",
    "insertText": "what() const throw()"
  },
  {
    "label": "bad_last_alloc()",
    "kind": "Method",
    "detail": "Function (# if __TBB_DEFAULT_DTOR_THROW_SPEC_BROKEN ~)",
    "insertText": "bad_last_alloc() throw()"
  },
  {
    "label": "throw_bad_last_alloc_exception_v4()",
    "kind": "Method",
    "detail": "Function (} ; namespace internal { void __TBB_EXPORTED_FUNC)",
    "insertText": "throw_bad_last_alloc_exception_v4()"
  },
  {
    "label": "throw_exception_v4()",
    "kind": "Method",
    "detail": "Function (enum exception_id { eid_bad_alloc = 1,eid_bad_last_alloc,eid_nonpositive_step,eid_out_of_range,eid_segment_range_error,eid_index_range_error,eid_missing_wait,eid_invalid_multiple_scheduling,eid_improper_lock,eid_possible_deadlock,eid_operation_not_permitted,eid_condvar_wait_failed,eid_invalid_load_factor,eid_reserved,eid_invalid_swap,eid_reservation_length_error,eid_invalid_key,eid_user_abort,eid_reserved1,# if __TBB_SUPPORTS_WORKERS_WAITING_IN_TERMINATE eid_blocking_thread_join_impossible = eid_reserved1,# endif eid_bad_tagged_msg_cast,eid_max } ; void __TBB_EXPORTED_FUNC)",
    "insertText": "throw_exception_v4(exception_id)"
  },
  {
    "label": "throw_exception()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "throw_exception(exception_id eid)"
  },
  {
    "label": "throw_exception_v4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "throw_exception_v4(eid)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} } } # if __TBB_TASK_GROUP_CONTEXT # include \" tbb_allocator . h \" # include<typeinfo> namespace tbb { class tbb_exception : public std::exception { void* operator)",
    "insertText": "new(size_t)"
  },
  {
    "label": "tbb_exception()",
    "kind": "Method",
    "detail": "Function (public : # if __clang__ ~)",
    "insertText": "tbb_exception() throw()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (; } # endif tbb_exception*)",
    "insertText": "move() throw()"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy() throw()"
  },
  {
    "label": "throw_self()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "throw_self()"
  },
  {
    "label": "name()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "name() const throw()"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (void operator)",
    "insertText": "delete(void* p)"
  },
  {
    "label": "deallocate_via_handler_v3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deallocate_via_handler_v3(p)"
  },
  {
    "label": "captured_exception()",
    "kind": "Method",
    "detail": "Function (} } ; class captured_exception : public tbb_exception { public :)",
    "insertText": "captured_exception(const captured_exception& src ) : tbb_exception(src), my_dynamic(false)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(src.my_exception_name, src.my_exception_info)"
  },
  {
    "label": "captured_exception()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "captured_exception(const char* name_, const char* info ) : my_dynamic(false)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(name_, info)"
  },
  {
    "label": "captured_exception()",
    "kind": "Method",
    "detail": "Function (} __TBB_EXPORTED_METHOD ~)",
    "insertText": "captured_exception() throw()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (captured_exception&)",
    "insertText": "operator(const captured_exception& src)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "__TBB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_THROW(*this)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "set(const char* name, const char* info ) throw()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "clear() throw()"
  },
  {
    "label": "captured_exception()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "captured_exception()"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} captured_exception*)",
    "insertText": "allocate(const char* name, const char* info)"
  },
  {
    "label": "movable_exception()",
    "kind": "Method",
    "detail": "Function (bool my_dynamic ; const char* my_exception_name ; const char* my_exception_info ; } ; template<ExceptionData> class movable_exception : public tbb_exception { typedef movable_exception<ExceptionData> self_type ; public :)",
    "insertText": "movable_exception(const ExceptionData& data_ ) : my_exception_data(data_) , my_dynamic(false) , my_exception_name( #if TBB_USE_EXCEPTIONS typeid(self_type).name() #else \"movable_exception\" #endif)"
  },
  {
    "label": "movable_exception()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "movable_exception(const movable_exception& src ) throw () : tbb_exception(src) , my_exception_data(src.my_exception_data) , my_dynamic(false) , my_exception_name(src.my_exception_name)"
  },
  {
    "label": "movable_exception()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "movable_exception() throw()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const movable_exception&)",
    "insertText": "operator(const movable_exception& src)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (my_exception_data = src . my_exception_data ; my_exception_name = src . my_exception_name ; } return* this ; } ExceptionData&)",
    "insertText": "data() throw()"
  },
  {
    "label": "allocate_via_handler_v3()",
    "kind": "Method",
    "detail": "Function (void* e =)",
    "insertText": "allocate_via_handler_v3(sizeof(movable_exception))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(e) movable_exception(*this)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "return(movable_exception*)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_dynamic, \"Method destroy can be called only on dynamically allocated movable_exceptions\")"
  },
  {
    "label": "movable_exception()",
    "kind": "Method",
    "detail": "Function (this -> ~)",
    "insertText": "movable_exception()"
  },
  {
    "label": "deallocate_via_handler_v3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deallocate_via_handler_v3(this)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (} protected : ExceptionData my_exception_data ; private : bool my_dynamic ; const char* my_exception_name ; } ; # if ! TBB_USE_CAPTURED_EXCEPTION namespace internal { class tbb_exception_ptr { std::exception_ptr my_ptr ; public : tbb_exception_ptr*)",
    "insertText": "allocate()"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (tbb_exception_ptr*)",
    "insertText": "allocate(const tbb_exception& tag)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (tbb_exception_ptr*)",
    "insertText": "allocate(captured_exception& src)"
  },
  {
    "label": "rethrow_exception()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "rethrow_exception(my_ptr)"
  },
  {
    "label": "tbb_exception_ptr()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "tbb_exception_ptr(const std::exception_ptr& src ) : my_ptr(src)"
  },
  {
    "label": "tbb_exception_ptr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "tbb_exception_ptr(const captured_exception& src ) : #if __TBB_MAKE_EXCEPTION_PTR_PRESENT my_ptr(std::make_exception_ptr(src)) #else my_ptr(std::copy_exception(src))"
  }
]