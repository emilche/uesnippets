[
  {
    "label": "AsmPrinter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AsmPrinter"
  },
  {
    "label": "MCExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCExpr"
  },
  {
    "label": "MCSymbol",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCSymbol"
  },
  {
    "label": "raw_ostream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "raw_ostream"
  },
  {
    "label": "DwarfTypeUnit",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DwarfTypeUnit"
  },
  {
    "label": "DIEAbbrevData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIEAbbrevData"
  },
  {
    "label": "DIEAbbrev",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIEAbbrev"
  },
  {
    "label": "DIEInteger",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIEInteger"
  },
  {
    "label": "DIEExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIEExpr"
  },
  {
    "label": "DIELabel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIELabel"
  },
  {
    "label": "DIEDelta",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIEDelta"
  },
  {
    "label": "DIEString",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIEString"
  },
  {
    "label": "DIE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIE"
  },
  {
    "label": "DIEEntry",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIEEntry"
  },
  {
    "label": "DIETypeSignature",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIETypeSignature"
  },
  {
    "label": "DIELocList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIELocList"
  },
  {
    "label": "DIEBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIEBlock"
  },
  {
    "label": "DIELoc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIELoc"
  },
  {
    "label": "DIEValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIEValue"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "IntrusiveBackListNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IntrusiveBackListNode"
  },
  {
    "label": "IntrusiveBackListBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IntrusiveBackListBase"
  },
  {
    "label": "IntrusiveBackList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IntrusiveBackList"
  },
  {
    "label": "const_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "const_iterator"
  },
  {
    "label": "iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "iterator"
  },
  {
    "label": "DIEValueList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DIEValueList"
  },
  {
    "label": "Node",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Node"
  },
  {
    "label": "DIEAbbrevData()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DIE_H # define LLVM_LIB_CODEGEN_ASMPRINTER_DIE_H # include \" llvm / ADT / FoldingSet . h \" # include \" llvm / ADT / PointerIntPair . h \" # include \" llvm / ADT / STLExtras . h \" # include \" llvm / ADT / SmallVector . h \" # include \" llvm / CodeGen / DwarfStringPoolEntry . h \" # include \" llvm / Support / Dwarf . h \" # include<vector> namespace llvm { class AsmPrinter ; class MCExpr ; class MCSymbol ; class raw_ostream ; class DwarfTypeUnit ; class DIEAbbrevData { dwarf::Attribute Attribute ; dwarf::Form Form ; public :)",
    "insertText": "DIEAbbrevData(dwarf::Attribute A, dwarf::Form F) : Attribute(A), Form(F)"
  },
  {
    "label": "getAttribute()",
    "kind": "Method",
    "detail": "Function (} dwarf::Attribute)",
    "insertText": "getAttribute()"
  },
  {
    "label": "DIEAbbrev()",
    "kind": "Method",
    "detail": "Function (} ; class DIEAbbrev : public FoldingSetNode { unsigned Number ; dwarf::Tag Tag ; bool Children ; SmallVector<DIEAbbrevData,1 2> Data ; public :)",
    "insertText": "DIEAbbrev(dwarf::Tag T, bool C) : Tag(T), Children(C), Data()"
  },
  {
    "label": "getTag()",
    "kind": "Method",
    "detail": "Function (} dwarf::Tag)",
    "insertText": "getTag()"
  },
  {
    "label": "setNumber()",
    "kind": "Method",
    "detail": "Function (Children = hasChild ; } void)",
    "insertText": "setNumber(unsigned N)"
  },
  {
    "label": "AddAttribute()",
    "kind": "Method",
    "detail": "Function (Number = N ; } void)",
    "insertText": "AddAttribute(dwarf::Attribute Attribute, dwarf::Form Form)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Data .)",
    "insertText": "push_back(DIEAbbrevData(Attribute, Form))"
  },
  {
    "label": "Profile()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Profile(FoldingSetNodeID &ID)"
  },
  {
    "label": "Emit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Emit(const AsmPrinter *AP)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (# ifndef NDEBUG void)",
    "insertText": "print(raw_ostream &O)"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dump()"
  },
  {
    "label": "DIEInteger()",
    "kind": "Method",
    "detail": "Function (# endif } ; class DIEInteger { uint64_t Integer ; public :)",
    "insertText": "DIEInteger(uint64_t I) : Integer(I)"
  },
  {
    "label": "BestForm()",
    "kind": "Method",
    "detail": "Function (} dwarf::Form)",
    "insertText": "BestForm(bool IsSigned, uint64_t Int)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const int64_t SignedInt = Int ;)",
    "insertText": "if((char)Int == SignedInt)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if((unsigned char)Int == Int)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} return dwarf::DW_FORM_data8 ; } uint64_t)",
    "insertText": "getValue()"
  },
  {
    "label": "EmitValue()",
    "kind": "Method",
    "detail": "Function (Integer = Val ; } void)",
    "insertText": "EmitValue(const AsmPrinter *AP, dwarf::Form Form)"
  },
  {
    "label": "SizeOf()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "SizeOf(const AsmPrinter *AP, dwarf::Form Form)"
  },
  {
    "label": "DIEExpr()",
    "kind": "Method",
    "detail": "Function (# endif } ; class DIEExpr { const MCExpr* Expr ; public :)",
    "insertText": "DIEExpr(const MCExpr *E) : Expr(E)"
  },
  {
    "label": "DIELabel()",
    "kind": "Method",
    "detail": "Function (# endif } ; class DIELabel { const MCSymbol* Label ; public :)",
    "insertText": "DIELabel(const MCSymbol *L) : Label(L)"
  },
  {
    "label": "DIEDelta()",
    "kind": "Method",
    "detail": "Function (# endif } ; class DIEDelta { const MCSymbol* LabelHi ; const MCSymbol* LabelLo ; public :)",
    "insertText": "DIEDelta(const MCSymbol *Hi, const MCSymbol *Lo) : LabelHi(Hi), LabelLo(Lo)"
  },
  {
    "label": "DIEString()",
    "kind": "Method",
    "detail": "Function (# endif } ; class DIEString { DwarfStringPoolEntryRef S ; public :)",
    "insertText": "DIEString(DwarfStringPoolEntryRef S) : S(S)"
  },
  {
    "label": "getString()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "getString()"
  },
  {
    "label": "DIEEntry()",
    "kind": "Method",
    "detail": "Function (# endif } ; class DIE ; class DIEEntry { DIE* Entry ;)",
    "insertText": "DIEEntry()"
  },
  {
    "label": "DIEEntry()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "DIEEntry(DIE &E) : Entry(&E)"
  },
  {
    "label": "getEntry()",
    "kind": "Method",
    "detail": "Function (} DIE&)",
    "insertText": "getEntry()"
  },
  {
    "label": "DIETypeSignature()",
    "kind": "Method",
    "detail": "Function (# endif } ; class DIETypeSignature { const DwarfTypeUnit* Unit ;)",
    "insertText": "DIETypeSignature()"
  },
  {
    "label": "DIETypeSignature()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "DIETypeSignature(const DwarfTypeUnit &Unit) : Unit(&Unit)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Form == dwarf::DW_FORM_ref_sig8)"
  },
  {
    "label": "DIELocList()",
    "kind": "Method",
    "detail": "Function (# endif } ; class DIELocList { size_t Index ; public :)",
    "insertText": "DIELocList(size_t I) : Index(I)"
  },
  {
    "label": "HANDLE_DIEVALUE()",
    "kind": "Method",
    "detail": "Function (# endif } ; class DIEBlock ; class DIELoc ; class DIEValue { public : enum Type { isNone,# define)",
    "insertText": "HANDLE_DIEVALUE(T)"
  },
  {
    "label": "Attribute()",
    "kind": "Method",
    "detail": "Function (private : Type Ty = isNone ; dwarf::Attribute)",
    "insertText": "Attribute(dwarf::Attribute)"
  },
  {
    "label": "Form()",
    "kind": "Method",
    "detail": "Function (dwarf::Form)",
    "insertText": "Form(dwarf::Form)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (typedef AlignedCharArrayUnion<DIEInteger,DIEString,DIEExpr,DIELabel,DIEDelta*,DIEEntry,DIETypeSignature,DIEBlock*,DIELoc*,DIELocList> ValTy ;)",
    "insertText": "static_assert(sizeof(ValTy) <= sizeof(uint64_t) || sizeof(ValTy) <= sizeof(void *), \"Expected all large types to be stored via pointer\")"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (ValTy Val ; template<class T> void)",
    "insertText": "construct(T V)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(reinterpret_cast<void *>(Val.buffer)) T(V)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<class T> T*)",
    "insertText": "get()"
  },
  {
    "label": "destruct()",
    "kind": "Method",
    "detail": "Function (} template<class T> void)",
    "insertText": "destruct()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (get<)",
    "insertText": "T()->~T()"
  },
  {
    "label": "destroyVal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "destroyVal()"
  },
  {
    "label": "HANDLE_DIEVALUE_LARGE()",
    "kind": "Method",
    "detail": "Function (\\ return ; # define)",
    "insertText": "HANDLE_DIEVALUE_LARGE(T) \\ case is##T: \\ construct<const DIE##T *>(*X.get<const DIE##T *>())"
  },
  {
    "label": "DIEValue()",
    "kind": "Method",
    "detail": "Function (\\ return ; # include \" llvm / CodeGen / DIEValue . def \" } } public :)",
    "insertText": "DIEValue()"
  },
  {
    "label": "DIEValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DIEValue(const DIEValue &X) : Ty(X.Ty), Attribute(X.Attribute), Form(X.Form)"
  },
  {
    "label": "copyVal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copyVal(X)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} DIEValue&)",
    "insertText": "operator(const DIEValue &X)"
  },
  {
    "label": "HANDLE_DIEVALUE_SMALL()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "HANDLE_DIEVALUE_SMALL(T) \\ DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T &V) \\ : Ty(is##T), Attribute(Attribute), Form(Form)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (\\ construct<DIE # #)",
    "insertText": "T(V)"
  },
  {
    "label": "HANDLE_DIEVALUE_LARGE()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "HANDLE_DIEVALUE_LARGE(T) \\ DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T *V) \\ : Ty(is##T), Attribute(Attribute), Form(Form)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "assert(V && \"Expected valid value\")"
  },
  {
    "label": "getType()",
    "kind": "Method",
    "detail": "Function (\\ } # include \" llvm / CodeGen / DIEValue . def \" Type)",
    "insertText": "getType()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "assert(getType() == is##T && \"Expected \" #T)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (\\ return* get<DIE # #)",
    "insertText": "T()"
  },
  {
    "label": "HANDLE_DIEVALUE_LARGE()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "HANDLE_DIEVALUE_LARGE(T) \\ const DIE##T &getDIE##T()"
  },
  {
    "label": "EmitValue()",
    "kind": "Method",
    "detail": "Function (\\ } # include \" llvm / CodeGen / DIEValue . def \" void)",
    "insertText": "EmitValue(const AsmPrinter *AP)"
  },
  {
    "label": "SizeOf()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "SizeOf(const AsmPrinter *AP)"
  },
  {
    "label": "IntrusiveBackListNode()",
    "kind": "Method",
    "detail": "Function (# endif } ; struct IntrusiveBackListNode { PointerIntPair<IntrusiveBackListNode*,1> Next ;)",
    "insertText": "IntrusiveBackListNode() : Next(this, true)"
  },
  {
    "label": "getNext()",
    "kind": "Method",
    "detail": "Function (} IntrusiveBackListNode*)",
    "insertText": "getNext()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} } ; struct IntrusiveBackListBase { typedef IntrusiveBackListNode Node ; Node* Last = nullptr ; bool)",
    "insertText": "empty()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(N.Next.getPointer() == &N && \"Expected unlinked node\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(N.Next.getInt() && \"Expected unlinked node\")"
  },
  {
    "label": "setPointerAndInt()",
    "kind": "Method",
    "detail": "Function (N . Next = Last -> Next ; Last -> Next .)",
    "insertText": "setPointerAndInt(&N, false)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} Last =& N ; } } ; template<class T> class IntrusiveBackList : IntrusiveBackListBase { public : using IntrusiveBackListBase::empty ; void)",
    "insertText": "push_back(T &N)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "push_back(N)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "back()"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} class const_iterator ; class iterator : public iterator_facade_base<iterator,std::forward_iterator_tag,T> { class const_iterator ; Node* N = nullptr ; public :)",
    "insertText": "iterator()"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iterator(T *N) : N(N)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} iterator&)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const iterator &X)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "const_iterator(typename IntrusiveBackList<T>::iterator X) : N(X.N)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "const_iterator(const T *N) : N(N)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const const_iterator &X)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "toIterator()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "toIterator(T &N)"
  },
  {
    "label": "toIterator()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "toIterator(const T &N)"
  },
  {
    "label": "Node()",
    "kind": "Method",
    "detail": "Function (} } ; class DIEValueList { struct Node : IntrusiveBackListNode { DIEValue V ;)",
    "insertText": "Node(DIEValue V) : V(V)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iterator(ListTy::iterator X) : iterator_adaptor(X)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (} } ; class const_iterator : public iterator_adaptor_base<const_iterator,ListTy::const_iterator,std::forward_iterator_tag,const DIEValue> { typedef iterator_adaptor_base<const_iterator,ListTy::const_iterator,std::forward_iterator_tag,const DIEValue> iterator_adaptor ; public :)",
    "insertText": "const_iterator()"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "const_iterator(DIEValueList::iterator X) : iterator_adaptor(X.wrapped())"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "const_iterator(ListTy::const_iterator X) : iterator_adaptor(X)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} } ; iterator)",
    "insertText": "insert(BumpPtrAllocator &Alloc, DIEValue V)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (List .)",
    "insertText": "push_back(*new (Alloc) Node(V))"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Ts> iterator)",
    "insertText": "emplace(BumpPtrAllocator &Alloc, Ts &&... Args)"
  },
  {
    "label": "Tag()",
    "kind": "Method",
    "detail": "Function (} } ; class DIE : IntrusiveBackListNode { class IntrusiveBackList<DIE> ; protected : unsigned Offset ; unsigned Size ; unsigned AbbrevNumber = ~ 0 u ; dwarf::Tag)",
    "insertText": "Tag(dwarf::Tag)"
  },
  {
    "label": "DIE()",
    "kind": "Method",
    "detail": "Function (IntrusiveBackList<DIE> Children ; DIE* Parent = nullptr ; DIEValueList Values ; protected :)",
    "insertText": "DIE() : Offset(0), Size(0)"
  },
  {
    "label": "DIE()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "DIE(dwarf::Tag Tag) : Offset(0), Size(0), Tag(Tag)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} public : DIE*)",
    "insertText": "get(BumpPtrAllocator &Alloc, dwarf::Tag Tag)"
  },
  {
    "label": "getAbbrevNumber()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getAbbrevNumber()"
  },
  {
    "label": "children()",
    "kind": "Method",
    "detail": "Function (} typedef IntrusiveBackList<DIE>::iterator child_iterator ; typedef IntrusiveBackList<DIE>::const_iterator const_child_iterator ; typedef iterator_range<child_iterator> child_range ; typedef iterator_range<const_child_iterator> const_child_range ; child_range)",
    "insertText": "children()"
  },
  {
    "label": "values()",
    "kind": "Method",
    "detail": "Function (} typedef DIEValueList::iterator value_iterator ; typedef iterator_range<value_iterator> value_range ; value_range)",
    "insertText": "values()"
  },
  {
    "label": "getParent()",
    "kind": "Method",
    "detail": "Function (} DIE*)",
    "insertText": "getParent()"
  },
  {
    "label": "setAbbrevNumber()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setAbbrevNumber(unsigned I)"
  },
  {
    "label": "getUnit()",
    "kind": "Method",
    "detail": "Function (AbbrevNumber = I ; } const DIE*)",
    "insertText": "getUnit()"
  },
  {
    "label": "getUnitOrNull()",
    "kind": "Method",
    "detail": "Function (const DIE*)",
    "insertText": "getUnitOrNull()"
  },
  {
    "label": "setOffset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOffset(unsigned O)"
  },
  {
    "label": "setSize()",
    "kind": "Method",
    "detail": "Function (Offset = O ; } void)",
    "insertText": "setSize(unsigned S)"
  },
  {
    "label": "addValue()",
    "kind": "Method",
    "detail": "Function (Size = S ; } value_iterator)",
    "insertText": "addValue(BumpPtrAllocator &Alloc, DIEValue Value)"
  },
  {
    "label": "addValue()",
    "kind": "Method",
    "detail": "Function (} template<class T> value_iterator)",
    "insertText": "addValue(BumpPtrAllocator &Alloc, dwarf::Attribute Attribute, dwarf::Form Form, T &&Value)"
  },
  {
    "label": "addChild()",
    "kind": "Method",
    "detail": "Function (} DIE&)",
    "insertText": "addChild(DIE *Child)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!Child->getParent() && \"Child should be orphaned\")"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Child -> Parent = this ; Children .)",
    "insertText": "push_back(*Child)"
  },
  {
    "label": "findAttribute()",
    "kind": "Method",
    "detail": "Function (} DIEValue)",
    "insertText": "findAttribute(dwarf::Attribute Attribute)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (# ifndef NDEBUG void)",
    "insertText": "print(raw_ostream &O, unsigned IndentCount = 0)"
  },
  {
    "label": "DIELoc()",
    "kind": "Method",
    "detail": "Function (# endif } ; class DIELoc : public DIE { unsigned Size ; public :)",
    "insertText": "DIELoc() : Size(0)"
  },
  {
    "label": "ComputeSize()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "ComputeSize(const AsmPrinter *AP)"
  },
  {
    "label": "BestForm()",
    "kind": "Method",
    "detail": "Function (dwarf::Form)",
    "insertText": "BestForm(unsigned DwarfVersion)"
  },
  {
    "label": "DIEBlock()",
    "kind": "Method",
    "detail": "Function (# endif } ; class DIEBlock : public DIE { unsigned Size ; public :)",
    "insertText": "DIEBlock() : Size(0)"
  },
  {
    "label": "BestForm()",
    "kind": "Method",
    "detail": "Function (dwarf::Form)",
    "insertText": "BestForm()"
  }
]