[
  {
    "label": "bitexact_cos()",
    "kind": "Method",
    "detail": "Function (# ifndef BANDS_H # define BANDS_H # include \" arch . h \" # include \" modes . h \" # include \" entenc . h \" # include \" entdec . h \" # include \" rate . h \" opus_int16)",
    "insertText": "bitexact_cos(opus_int16 x)"
  },
  {
    "label": "bitexact_log2tan()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "bitexact_log2tan(int isin,int icos)"
  },
  {
    "label": "compute_band_energies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_band_energies(const CELTMode *m, const celt_sig *X, celt_ener *bandE, int end, int C, int LM, int arch)"
  },
  {
    "label": "normalise_bands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "normalise_bands(const CELTMode *m, const celt_sig * OPUS_RESTRICT freq, celt_norm * OPUS_RESTRICT X, const celt_ener *bandE, int end, int C, int M)"
  },
  {
    "label": "denormalise_bands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "denormalise_bands(const CELTMode *m, const celt_norm * OPUS_RESTRICT X, celt_sig * OPUS_RESTRICT freq, const opus_val16 *bandE, int start, int end, int M, int downsample, int silence)"
  },
  {
    "label": "SPREAD_NONE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "SPREAD_NONE(0) #define SPREAD_LIGHT (1) #define SPREAD_NORMAL (2) #define SPREAD_AGGRESSIVE (3) int spreading_decision(const CELTMode *m, const celt_norm *X, int *average, int last_decision, int *hf_average, int *tapset_decision, int update_hf, int end, int C, int M, const int *spread_weight)"
  },
  {
    "label": "measure_norm_mse()",
    "kind": "Method",
    "detail": "Function (# ifdef MEASURE_NORM_MSE void)",
    "insertText": "measure_norm_mse(const CELTMode *m, float *X, float *X0, float *bandE, float *bandE0, int M, int N, int C)"
  },
  {
    "label": "haar1()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "haar1(celt_norm *X, int N0, int stride)"
  },
  {
    "label": "quant_all_bands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "quant_all_bands(int encode, const CELTMode *m, int start, int end, celt_norm * X, celt_norm * Y, unsigned char *collapse_masks, const celt_ener *bandE, int *pulses, int shortBlocks, int spread, int dual_stereo, int intensity, int *tf_res, opus_int32 total_bits, opus_int32 balance, ec_ctx *ec, int M, int codedBands, opus_uint32 *seed, int complexity, int arch, int disable_inv)"
  },
  {
    "label": "anti_collapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "anti_collapse(const CELTMode *m, celt_norm *X_, unsigned char *collapse_masks, int LM, int C, int size, int start, int end, const opus_val16 *logE, const opus_val16 *prev1logE, const opus_val16 *prev2logE, const int *pulses, opus_uint32 seed, int arch)"
  },
  {
    "label": "celt_lcg_rand()",
    "kind": "Method",
    "detail": "Function (opus_uint32)",
    "insertText": "celt_lcg_rand(opus_uint32 seed)"
  },
  {
    "label": "hysteresis_decision()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "hysteresis_decision(opus_val16 val, const opus_val16 *thresholds, const opus_val16 *hysteresis, int N, int prev)"
  }
]