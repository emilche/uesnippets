[
  {
    "label": "bitexact_cos()",
    "kind": "Method",
    "detail": "Function (opus_int16)",
    "insertText": "bitexact_cos(opus_int16 x)"
  },
  {
    "label": "bitexact_log2tan()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "bitexact_log2tan(int isin,int icos)"
  },
  {
    "label": "compute_band_energies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_band_energies(const CELTMode *m, const celt_sig *X, celt_ener *bandE, int end, int C, int LM, int arch)"
  },
  {
    "label": "compute_noise_energies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute_noise_energies(const CELTMode *m, const celt_sig *X, const opus_val16 *tonality, celt_ener *bandE)"
  },
  {
    "label": "normalise_bands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "normalise_bands(const CELTMode *m, const celt_sig * OPUS_RESTRICT freq, celt_norm * OPUS_RESTRICT X, const celt_ener *bandE, int end, int C, int M)"
  },
  {
    "label": "denormalise_bands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "denormalise_bands(const CELTMode *m, const celt_norm * OPUS_RESTRICT X,\n      celt_sig * OPUS_RESTRICT freq, const opus_val16 *bandE, int start,\n      int end, int M, int downsample, int silence)"
  },
  {
    "label": "spreading_decision()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "spreading_decision(const CELTMode *m, const celt_norm *X, int *average,\n      int last_decision, int *hf_average, int *tapset_decision, int update_hf,\n      int end, int C, int M, const int *spread_weight)"
  },
  {
    "label": "measure_norm_mse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "measure_norm_mse(const CELTMode *m, float *X, float *X0, float *bandE, float *bandE0, int M, int N, int C)"
  },
  {
    "label": "haar1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "haar1(celt_norm *X, int N0, int stride)"
  },
  {
    "label": "quant_all_bands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "quant_all_bands(int encode, const CELTMode *m, int start, int end,\n      celt_norm * X, celt_norm * Y, unsigned char *collapse_masks,\n      const celt_ener *bandE, int *pulses, int shortBlocks, int spread,\n      int dual_stereo, int intensity, int *tf_res, opus_int32 total_bits,\n      opus_int32 balance, ec_ctx *ec, int M, int codedBands, opus_uint32 *seed,\n      int complexity, int arch, int disable_inv)"
  },
  {
    "label": "anti_collapse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "anti_collapse(const CELTMode *m, celt_norm *X_,\n      unsigned char *collapse_masks, int LM, int C, int size, int start,\n      int end, const opus_val16 *logE, const opus_val16 *prev1logE,\n      const opus_val16 *prev2logE, const int *pulses, opus_uint32 seed,\n      int arch)"
  },
  {
    "label": "celt_lcg_rand()",
    "kind": "Method",
    "detail": "Function (opus_uint32)",
    "insertText": "celt_lcg_rand(opus_uint32 seed)"
  },
  {
    "label": "hysteresis_decision()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "hysteresis_decision(opus_val16 val, const opus_val16 *thresholds, const opus_val16 *hysteresis, int N, int prev)"
  }
]