[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "extractScaling()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHMATRIXALGO_H # define INCLUDED_IMATHMATRIXALGO_H # include \" ImathEuler . h \" # include \" ImathExport . h \" # include \" ImathMatrix . h \" # include \" ImathNamespace . h \" # include \" ImathQuat . h \" # include \" ImathVec . h \" # include<math . h> IMATH_INTERNAL_NAMESPACE_HEADER_ENTER IMATH_EXPORT_CONST M22f identity22f ; IMATH_EXPORT_CONST M33f identity33f ; IMATH_EXPORT_CONST M44f identity44f ; IMATH_EXPORT_CONST M22d identity22d ; IMATH_EXPORT_CONST M33d identity33d ; IMATH_EXPORT_CONST M44d identity44d ; template<class T> bool)",
    "insertText": "extractScaling(const Matrix44<T>& mat, Vec3<T>& scl, bool exc = true)"
  },
  {
    "label": "sansScaling()",
    "kind": "Method",
    "detail": "Function (template<class T> Matrix44<T>)",
    "insertText": "sansScaling(const Matrix44<T>& mat, bool exc = true)"
  },
  {
    "label": "removeScaling()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "removeScaling(Matrix44<T>& mat, bool exc = true)"
  },
  {
    "label": "extractScalingAndShear()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "extractScalingAndShear(const Matrix44<T>& mat, Vec3<T>& scl, Vec3<T>& shr, bool exc = true)"
  },
  {
    "label": "sansScalingAndShear()",
    "kind": "Method",
    "detail": "Function (template<class T> Matrix44<T>)",
    "insertText": "sansScalingAndShear(const Matrix44<T>& mat, bool exc = true)"
  },
  {
    "label": "sansScalingAndShear()",
    "kind": "Method",
    "detail": "Function (template<class T> void)",
    "insertText": "sansScalingAndShear(Matrix44<T>& result, const Matrix44<T>& mat, bool exc = true)"
  },
  {
    "label": "removeScalingAndShear()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "removeScalingAndShear(Matrix44<T>& mat, bool exc = true)"
  },
  {
    "label": "extractAndRemoveScalingAndShear()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "extractAndRemoveScalingAndShear(Matrix44<T>& mat, Vec3<T>& scl, Vec3<T>& shr, bool exc = true)"
  },
  {
    "label": "extractEulerXYZ()",
    "kind": "Method",
    "detail": "Function (template<class T> void)",
    "insertText": "extractEulerXYZ(const Matrix44<T>& mat, Vec3<T>& rot)"
  },
  {
    "label": "extractEulerZYX()",
    "kind": "Method",
    "detail": "Function (template<class T> void)",
    "insertText": "extractEulerZYX(const Matrix44<T>& mat, Vec3<T>& rot)"
  },
  {
    "label": "extractQuat()",
    "kind": "Method",
    "detail": "Function (template<class T> Quat<T>)",
    "insertText": "extractQuat(const Matrix44<T>& mat)"
  },
  {
    "label": "extractSHRT()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "extractSHRT(const Matrix44<T>& mat, Vec3<T>& s, Vec3<T>& h, Vec3<T>& r, Vec3<T>& t, bool exc , typename Euler<T>::Order rOrder)"
  },
  {
    "label": "extractSHRT()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "extractSHRT(const Matrix44<T>& mat, Vec3<T>& s, Vec3<T>& h, Vec3<T>& r, Vec3<T>& t, bool exc = true)"
  },
  {
    "label": "extractSHRT()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "extractSHRT(const Matrix44<T>& mat, Vec3<T>& s, Vec3<T>& h, Euler<T>& r, Vec3<T>& t, bool exc = true)"
  },
  {
    "label": "checkForZeroScaleInRow()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "checkForZeroScaleInRow(const T& scl, const Vec3<T>& row, bool exc = true)"
  },
  {
    "label": "outerProduct()",
    "kind": "Method",
    "detail": "Function (template<class T> Matrix44<T>)",
    "insertText": "outerProduct(const Vec4<T>& a, const Vec4<T>& b)"
  },
  {
    "label": "rotationMatrix()",
    "kind": "Method",
    "detail": "Function (template<class T> Matrix44<T>)",
    "insertText": "rotationMatrix(const Vec3<T>& fromDirection, const Vec3<T>& toDirection)"
  },
  {
    "label": "rotationMatrixWithUpDir()",
    "kind": "Method",
    "detail": "Function (template<class T> Matrix44<T>)",
    "insertText": "rotationMatrixWithUpDir(const Vec3<T>& fromDir, const Vec3<T>& toDir, const Vec3<T>& upDir)"
  },
  {
    "label": "alignZAxisWithTargetDir()",
    "kind": "Method",
    "detail": "Function (template<class T> void)",
    "insertText": "alignZAxisWithTargetDir(Matrix44<T>& result, Vec3<T> targetDir, Vec3<T> upDir)"
  },
  {
    "label": "computeLocalFrame()",
    "kind": "Method",
    "detail": "Function (template<class T> Matrix44<T>)",
    "insertText": "computeLocalFrame(const Vec3<T>& p, const Vec3<T>& xDir, const Vec3<T>& normal)"
  },
  {
    "label": "addOffset()",
    "kind": "Method",
    "detail": "Function (template<class T> Matrix44<T>)",
    "insertText": "addOffset(const Matrix44<T>& inMat, const Vec3<T>& tOffset, const Vec3<T>& rOffset, const Vec3<T>& sOffset, const Vec3<T>& ref)"
  },
  {
    "label": "computeRSMatrix()",
    "kind": "Method",
    "detail": "Function (template<class T> Matrix44<T>)",
    "insertText": "computeRSMatrix(bool keepRotateA, bool keepScaleA, const Matrix44<T>& A, const Matrix44<T>& B)"
  },
  {
    "label": "extractScaling()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "extractScaling(const Matrix33<T>& mat, Vec2<T>& scl, bool exc = true)"
  },
  {
    "label": "sansScaling()",
    "kind": "Method",
    "detail": "Function (template<class T> Matrix33<T>)",
    "insertText": "sansScaling(const Matrix33<T>& mat, bool exc = true)"
  },
  {
    "label": "removeScaling()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "removeScaling(Matrix33<T>& mat, bool exc = true)"
  },
  {
    "label": "extractScalingAndShear()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "extractScalingAndShear(const Matrix33<T>& mat, Vec2<T>& scl, T& shr, bool exc = true)"
  },
  {
    "label": "sansScalingAndShear()",
    "kind": "Method",
    "detail": "Function (template<class T> Matrix33<T>)",
    "insertText": "sansScalingAndShear(const Matrix33<T>& mat, bool exc = true)"
  },
  {
    "label": "removeScalingAndShear()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "removeScalingAndShear(Matrix33<T>& mat, bool exc = true)"
  },
  {
    "label": "extractAndRemoveScalingAndShear()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "extractAndRemoveScalingAndShear(Matrix33<T>& mat, Vec2<T>& scl, T& shr, bool exc = true)"
  },
  {
    "label": "extractEuler()",
    "kind": "Method",
    "detail": "Function (template<class T> void)",
    "insertText": "extractEuler(const Matrix22<T>& mat, T& rot)"
  },
  {
    "label": "extractEuler()",
    "kind": "Method",
    "detail": "Function (template<class T> void)",
    "insertText": "extractEuler(const Matrix33<T>& mat, T& rot)"
  },
  {
    "label": "extractSHRT()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "extractSHRT(const Matrix33<T>& mat, Vec2<T>& s, T& h, T& r, Vec2<T>& t, bool exc = true)"
  },
  {
    "label": "checkForZeroScaleInRow()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "checkForZeroScaleInRow(const T& scl, const Vec2<T>& row, bool exc = true)"
  },
  {
    "label": "outerProduct()",
    "kind": "Method",
    "detail": "Function (template<class T> Matrix33<T>)",
    "insertText": "outerProduct(const Vec3<T>& a, const Vec3<T>& b)"
  },
  {
    "label": "extractScaling()",
    "kind": "Method",
    "detail": "Function (template<class T> bool)",
    "insertText": "extractScaling(const Matrix44<T>& mat, Vec3<T>& scl, bool exc)"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (Vec3<T> shr ; Matrix44<T>)",
    "insertText": "M(mat)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3<T> scl ; Vec3<T> shr ; Vec3<T> rot ; Vec3<T> tran ;)",
    "insertText": "if(!extractSHRT (mat, scl, shr, rot, tran, exc))"
  },
  {
    "label": "translate()",
    "kind": "Method",
    "detail": "Function (Matrix44<T> M ; M .)",
    "insertText": "translate(tran)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (M .)",
    "insertText": "rotate(rot)"
  },
  {
    "label": "shear()",
    "kind": "Method",
    "detail": "Function (M .)",
    "insertText": "shear(shr)"
  },
  {
    "label": "makeIdentity()",
    "kind": "Method",
    "detail": "Function (mat .)",
    "insertText": "makeIdentity()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3<T> scl ; Vec3<T> shr ;)",
    "insertText": "if(!extractAndRemoveScalingAndShear (result, scl, shr, exc))"
  },
  {
    "label": "removeScalingAndShear()",
    "kind": "Method",
    "detail": "Function (} template<class T> bool)",
    "insertText": "removeScalingAndShear(Matrix44<T>& mat, bool exc)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3<T> scl ; Vec3<T> shr ;)",
    "insertText": "if(!extractAndRemoveScalingAndShear (mat, scl, shr, exc))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> row [ 3 ] ; row [ 0 ] = Vec3<)",
    "insertText": "T(mat[0][0], mat[0][1], mat[0][2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (row [ 1 ] = Vec3<)",
    "insertText": "T(mat[1][0], mat[1][1], mat[1][2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (row [ 2 ] = Vec3<)",
    "insertText": "T(mat[2][0], mat[2][1], mat[2][2])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T maxVal = 0 ;)",
    "insertText": "for(int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) if (IMATH_INTERNAL_NAMESPACE::abs (row[i][j]) > maxVal) maxVal = IMATH_INTERNAL_NAMESPACE::abs (row[i][j])"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (row [ 0 ] / = scl . x ; shr [ 0 ] = row [ 0 ] .)",
    "insertText": "dot(row[1])"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (row [ 1 ] - = shr [ 0 ]* row [ 0 ] ; scl . y = row [ 1 ] .)",
    "insertText": "length()"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (row [ 1 ] / = scl . y ; shr [ 0 ] / = scl . y ; shr [ 1 ] = row [ 0 ] .)",
    "insertText": "dot(row[2])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (row [ 2 ] / = scl . z ; shr [ 1 ] / = scl . z ; shr [ 2 ] / = scl . z ;)",
    "insertText": "if(row[0].dot (row[1].cross (row[2])) < 0) for (int i = 0; i < 3; i++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (scl [ i ]* = - 1 ; row [ i ]* = - 1 ; })",
    "insertText": "for(int i = 0; i < 3; i++)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "i(mat[0][0], mat[0][1], mat[0][2])"
  },
  {
    "label": "j()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "j(mat[1][0], mat[1][1], mat[1][2])"
  },
  {
    "label": "k()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "k(mat[2][0], mat[2][1], mat[2][2])"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (i .)",
    "insertText": "normalize()"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (Matrix44<T>)",
    "insertText": "M(i[0], i[1], i[2], 0, j[0], j[1], j[2], 0, k[0], k[1], k[2], 0, 0, 0, 0, 1)"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (rot . x =)",
    "insertText": "atan2(M[1][2], M[2][2])"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (Matrix44<T> N ; N .)",
    "insertText": "rotate(Vec3<T> (-rot.x, 0, 0))"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (N = N* M ; T cy =)",
    "insertText": "sqrt(N[0][0] * N[0][0] + N[0][1] * N[0][1])"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (rot . y =)",
    "insertText": "atan2(-N[0][2], cy)"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (rot . z =)",
    "insertText": "atan2(-N[1][0], N[1][1])"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (rot . x = -)",
    "insertText": "atan2(M[1][0], M[0][0])"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (Matrix44<T> N ; N .)",
    "insertText": "rotate(Vec3<T> (0, 0, -rot.x))"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (N = N* M ; T cy =)",
    "insertText": "sqrt(N[2][2] * N[2][2] + N[2][1] * N[2][1])"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (rot . y = -)",
    "insertText": "atan2(-N[2][0], cy)"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (rot . z = -)",
    "insertText": "atan2(-N[1][2], N[1][1])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T tr,s ; T q [ 4 ] ; int i,j,k ; Quat<T> quat ; int nxt [ 3 ] = { 1,2,0 } ; tr = mat [ 0 ] [ 0 ] + mat [ 1 ] [ 1 ] + mat [ 2 ] [ 2 ] ;)",
    "insertText": "if(tr > 0.0)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (s =)",
    "insertText": "sqrt(tr + T (1.0))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (quat . r = s /)",
    "insertText": "T(2.0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (s =)",
    "insertText": "T(0.5)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (quat . v .)",
    "insertText": "x(mat[1][2] - mat[2][1])"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (quat . v .)",
    "insertText": "y(mat[2][0] - mat[0][2])"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (quat . v .)",
    "insertText": "z(mat[0][1] - mat[1][0])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { i = 0 ;)",
    "insertText": "if(mat[1][1] > mat[0][0])"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (j = nxt [ i ] ; k = nxt [ j ] ; s =)",
    "insertText": "sqrt((mat[i][i] - (mat[j][j] + mat[k][k])) + T (1.0))"
  },
  {
    "label": "q()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "q(mat[j][k] - mat[k][j])"
  },
  {
    "label": "j()",
    "kind": "Method",
    "detail": "Function (q [)",
    "insertText": "j(mat[i][j] + mat[j][i])"
  },
  {
    "label": "k()",
    "kind": "Method",
    "detail": "Function (q [)",
    "insertText": "k(mat[i][k] + mat[k][i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Matrix44<T> rot ; rot = mat ;)",
    "insertText": "if(!extractAndRemoveScalingAndShear (rot, s, h, exc))"
  },
  {
    "label": "extractEulerXYZ()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "extractEulerXYZ(rot, r)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (t . x = mat [ 3 ] [ 0 ] ; t . y = mat [ 3 ] [ 1 ] ; t . z = mat [ 3 ] [ 2 ] ;)",
    "insertText": "if(rOrder != Euler<T>::XYZ)"
  },
  {
    "label": "eXYZ()",
    "kind": "Method",
    "detail": "Function (Euler<T>)",
    "insertText": "eXYZ(r, Euler<T>::XYZ)"
  },
  {
    "label": "e()",
    "kind": "Method",
    "detail": "Function (Euler<T>)",
    "insertText": "e(eXYZ, rOrder)"
  },
  {
    "label": "toXYZVector()",
    "kind": "Method",
    "detail": "Function (r = e .)",
    "insertText": "toXYZVector()"
  },
  {
    "label": "extractSHRT()",
    "kind": "Method",
    "detail": "Function (} return true ; } template<class T> bool)",
    "insertText": "extractSHRT(const Matrix44<T>& mat, Vec3<T>& s, Vec3<T>& h, Vec3<T>& r, Vec3<T>& t, bool exc)"
  },
  {
    "label": "extractSHRT()",
    "kind": "Method",
    "detail": "Function (} template<class T> bool)",
    "insertText": "extractSHRT(const Matrix44<T>& mat, Vec3<T>& s, Vec3<T>& h, Euler<T>& r, Vec3<T>& t, bool exc)"
  },
  {
    "label": "checkForZeroScaleInRow()",
    "kind": "Method",
    "detail": "Function (} template<class T> bool)",
    "insertText": "checkForZeroScaleInRow(const T& scl, const Vec3<T>& row, bool exc)"
  },
  {
    "label": "rotationMatrix()",
    "kind": "Method",
    "detail": "Function (} template<class T> Matrix44<T>)",
    "insertText": "rotationMatrix(const Vec3<T>& from, const Vec3<T>& to)"
  },
  {
    "label": "setRotation()",
    "kind": "Method",
    "detail": "Function (Quat<T> q ; q .)",
    "insertText": "setRotation(from, to)"
  },
  {
    "label": "alignZAxisWithTargetDir()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alignZAxisWithTargetDir(zAxis2FromDir, fromDir, Vec3<T> (0, 1, 0))"
  },
  {
    "label": "transposed()",
    "kind": "Method",
    "detail": "Function (Matrix44<T> fromDir2zAxis = zAxis2FromDir .)",
    "insertText": "transposed()"
  },
  {
    "label": "zAxis2ToDir()",
    "kind": "Method",
    "detail": "Function (Matrix44<T>)",
    "insertText": "zAxis2ToDir(UNINITIALIZED)"
  },
  {
    "label": "alignZAxisWithTargetDir()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alignZAxisWithTargetDir(zAxis2ToDir, toDir, upDir)"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (upDir = targetDir .)",
    "insertText": "cross(Vec3<T> (1, 0, 0))"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (} Vec3<T> targetPerpDir = upDir .)",
    "insertText": "cross(targetDir)"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (Vec3<T> targetUpDir = targetDir .)",
    "insertText": "cross(targetPerpDir)"
  },
  {
    "label": "normalized()",
    "kind": "Method",
    "detail": "Function (Vec3<T> row [ 3 ] ; row [ 0 ] = targetPerpDir .)",
    "insertText": "normalized()"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (result . x [ 0 ] [ 0 ] = row [ 0 ] [ 0 ] ; result . x [ 0 ] [ 1 ] = row [ 0 ] [ 1 ] ; result . x [ 0 ] [ 2 ] = row [ 0 ] [ 2 ] ; result .)",
    "insertText": "x(T)"
  },
  {
    "label": "_xDir()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "_xDir(xDir)"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "y(normal % x).normalize()"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "z(x % y).normalize()"
  },
  {
    "label": "addOffset()",
    "kind": "Method",
    "detail": "Function (Matrix44<T> L ; L [ 0 ] [ 0 ] = x [ 0 ] ; L [ 0 ] [ 1 ] = x [ 1 ] ; L [ 0 ] [ 2 ] = x [ 2 ] ; L [ 0 ] [ 3 ] = 0 . 0 ; L [ 1 ] [ 0 ] = y [ 0 ] ; L [ 1 ] [ 1 ] = y [ 1 ] ; L [ 1 ] [ 2 ] = y [ 2 ] ; L [ 1 ] [ 3 ] = 0 . 0 ; L [ 2 ] [ 0 ] = z [ 0 ] ; L [ 2 ] [ 1 ] = z [ 1 ] ; L [ 2 ] [ 2 ] = z [ 2 ] ; L [ 2 ] [ 3 ] = 0 . 0 ; L [ 3 ] [ 0 ] = p [ 0 ] ; L [ 3 ] [ 1 ] = p [ 1 ] ; L [ 3 ] [ 2 ] = p [ 2 ] ; L [ 3 ] [ 3 ] = 1 . 0 ; return L ; } template<class T> Matrix44<T>)",
    "insertText": "addOffset(const Matrix44<T>& inMat, const Vec3<T>& tOffset, const Vec3<T>& rOffset, const Vec3<T>& sOffset, const Matrix44<T>& ref)"
  },
  {
    "label": "_rOffset()",
    "kind": "Method",
    "detail": "Function (Matrix44<T> O ; Vec3<T>)",
    "insertText": "_rOffset(rOffset)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (_rOffset* =)",
    "insertText": "T(M_PI / 180.0)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (O .)",
    "insertText": "rotate(_rOffset)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (O [ 3 ] [ 0 ] = tOffset [ 0 ] ; O [ 3 ] [ 1 ] = tOffset [ 1 ] ; O [ 3 ] [ 2 ] = tOffset [ 2 ] ; Matrix44<T> S ; S .)",
    "insertText": "scale(sOffset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3<T> as,ah,ar,at ;)",
    "insertText": "if(!extractSHRT (A, as, ah, ar, at)) throw std::domain_error (\"degenerate A matrix in computeRSMatrix\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3<T> bs,bh,br,bt ;)",
    "insertText": "if(!extractSHRT (B, bs, bh, br, bt)) throw std::domain_error (\"degenerate B matrix in computeRSMatrix\")"
  },
  {
    "label": "translate()",
    "kind": "Method",
    "detail": "Function (mat .)",
    "insertText": "translate(at)"
  },
  {
    "label": "rotate()",
    "kind": "Method",
    "detail": "Function (mat .)",
    "insertText": "rotate(ar)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (mat .)",
    "insertText": "scale(as)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec2<T> row [ 2 ] ; row [ 0 ] = Vec2<)",
    "insertText": "T(mat[0][0], mat[0][1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (row [ 1 ] = Vec2<)",
    "insertText": "T(mat[1][0], mat[1][1])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T maxVal = 0 ;)",
    "insertText": "for(int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) if (IMATH_INTERNAL_NAMESPACE::abs (row[i][j]) > maxVal) maxVal = IMATH_INTERNAL_NAMESPACE::abs (row[i][j])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (row [ 1 ] / = scl . y ; shr / = scl . y ;)",
    "insertText": "if(row[0][0] * row[1][1] - row[0][1] * row[1][0] < 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (row [ 1 ] [ 0 ]* = - 1 ; row [ 1 ] [ 1 ]* = - 1 ; scl [ 1 ]* = - 1 ; shr* = - 1 ; })",
    "insertText": "for(int i = 0; i < 2; i++)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (Vec2<T>)",
    "insertText": "i(mat[0][0], mat[0][1])"
  },
  {
    "label": "j()",
    "kind": "Method",
    "detail": "Function (Vec2<T>)",
    "insertText": "j(mat[1][0], mat[1][1])"
  },
  {
    "label": "atan2()",
    "kind": "Method",
    "detail": "Function (rot = -)",
    "insertText": "atan2(j[0], i[0])"
  },
  {
    "label": "extractSHRT()",
    "kind": "Method",
    "detail": "Function (} template<class T> bool)",
    "insertText": "extractSHRT(const Matrix33<T>& mat, Vec2<T>& s, T& h, T& r, Vec2<T>& t, bool exc)"
  },
  {
    "label": "extractEuler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "extractEuler(rot, r)"
  },
  {
    "label": "checkForZeroScaleInRow()",
    "kind": "Method",
    "detail": "Function (t . x = mat [ 2 ] [ 0 ] ; t . y = mat [ 2 ] [ 1 ] ; return true ; } template<class T> bool)",
    "insertText": "checkForZeroScaleInRow(const T& scl, const Vec2<T>& row, bool exc)"
  },
  {
    "label": "procrustesRotationAndTranslation()",
    "kind": "Method",
    "detail": "Function (} template<T> M44d)",
    "insertText": "procrustesRotationAndTranslation(const Vec3<T>* A, const Vec3<T>* B, const T* weights, const size_t numPoints, const bool doScaling = false)"
  },
  {
    "label": "procrustesRotationAndTranslation()",
    "kind": "Method",
    "detail": "Function (template<T> M44d)",
    "insertText": "procrustesRotationAndTranslation(const Vec3<T>* A, const Vec3<T>* B, const size_t numPoints, const bool doScaling = false)"
  },
  {
    "label": "jacobiSVD()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "jacobiSVD(const Matrix33<T>& A, Matrix33<T>& U, Vec3<T>& S, Matrix33<T>& V, const T tol = std::numeric_limits<T>::epsilon(), const bool forcePositiveDeterminant = false)"
  },
  {
    "label": "jacobiSVD()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "jacobiSVD(const Matrix44<T>& A, Matrix44<T>& U, Vec4<T>& S, Matrix44<T>& V, const T tol = std::numeric_limits<T>::epsilon(), const bool forcePositiveDeterminant = false)"
  },
  {
    "label": "jacobiEigenSolver()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "jacobiEigenSolver(Matrix33<T>& A, Vec3<T>& S, Matrix33<T>& V, const T tol)"
  },
  {
    "label": "jacobiEigenSolver()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "jacobiEigenSolver(Matrix33<T>& A, Vec3<T>& S, Matrix33<T>& V)"
  },
  {
    "label": "jacobiEigenSolver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "jacobiEigenSolver(A, S, V, std::numeric_limits<T>::epsilon())"
  },
  {
    "label": "jacobiEigenSolver()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "jacobiEigenSolver(Matrix44<T>& A, Vec4<T>& S, Matrix44<T>& V, const T tol)"
  },
  {
    "label": "jacobiEigenSolver()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "jacobiEigenSolver(Matrix44<T>& A, Vec4<T>& S, Matrix44<T>& V)"
  },
  {
    "label": "maxEigenVector()",
    "kind": "Method",
    "detail": "Function (} template<TM,TV> void)",
    "insertText": "maxEigenVector(TM& A, TV& S)"
  },
  {
    "label": "minEigenVector()",
    "kind": "Method",
    "detail": "Function (template<TM,TV> void)",
    "insertText": "minEigenVector(TM& A, TV& S)"
  }
]