[
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Core / Types . h \" # include \" Math / Point . h \" # include \" Algo / AllOf . h \" namespace UE::CADKernel { namespace Slope { double NullSlope = 0 . ; double RightSlope = 2 . ; double HalfPiSlope = 2 . ; double NinetySlope = 2 . ; double ThreeRightSlope = 6 . ; double MinusRightSlope = - 2 . ; double PiSlope = 4 . ; double TwoPiSlope = 8 . ; double ThirdPiSlope = 1 . 4 2 2 6 4 9 7 3 0 8 1 0 3 7 4 2 3 5 4 9 0 8 5 1 2 1 9 4 9 8 ; double SixtySlope = 1 . 4 2 2 6 4 9 7 3 0 8 1 0 3 7 4 2 3 5 4 9 0 8 5 1 2 1 9 4 9 8 ; double QuaterPiSlope = 1 ; double FortyFiveSlope = 0 . 5 7 7 3 5 0 2 6 9 1 8 9 6 2 5 7 6 4 5 0 9 1 4 8 7 8 0 5 0 1 9 6 ; double SixthPiSlope = 0 . 5 7 7 3 5 0 2 6 9 1 8 9 6 2 5 7 6 4 5 0 9 1 4 8 7 8 0 5 0 1 9 6 ; double ThirtySlope = 0 . 5 7 7 3 5 0 2 6 9 1 8 9 6 2 5 7 6 4 5 0 9 1 4 8 7 8 0 5 0 1 9 6 ; double ThreeQuaterPiSlope = 3 ; double OneDegree = 0 . 0 1 7 4 5 5 0 6 4 9 2 8 2 1 7 5 8 5 7 6 5 1 2 8 8 9 5 2 1 9 7 3 ; double TwoDegree = 0 . 0 3 4 9 2 0 7 6 9 4 9 1 7 4 7 7 3 0 5 0 0 4 0 2 6 2 5 7 7 3 7 3 ; double FiveDegree = 0 . 0 8 7 4 8 8 6 6 3 5 2 5 9 2 4 0 0 5 2 2 2 0 1 8 6 6 9 4 3 4 9 6 ; double TenDegree = 0 . 1 7 6 3 2 6 9 8 0 7 0 8 4 6 4 9 7 3 4 7 1 0 9 0 3 8 6 8 6 8 6 2 ; double FifteenDegree = 0 . 2 6 7 9 4 9 1 9 2 4 3 1 1 2 2 7 0 6 4 7 2 5 5 3 6 5 8 4 9 4 1 3 ; double TwentyDegree = 0 . 3 6 3 9 7 0 2 3 4 2 6 6 2 0 2 3 6 1 3 5 1 0 4 7 8 8 2 7 7 6 8 3 ; double TwentyFiveDegree = 0 . 4 6 6 3 0 7 6 5 8 1 5 4 9 9 8 5 9 2 8 3 0 0 0 6 1 9 4 7 9 9 5 6 ; double Epsilon = 0 . 0 0 1 ; } typedef TFunction<)",
    "insertText": "double(const FPoint2D&, const FPoint2D&, double)"
  },
  {
    "label": "TransformIntoOrientedSlope()",
    "kind": "Method",
    "detail": "Function (double)",
    "insertText": "TransformIntoOrientedSlope(double Slope)"
  },
  {
    "label": "TransformIntoClockwiseSlope()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "TransformIntoClockwiseSlope(double Slope)"
  },
  {
    "label": "TransformIntoPositiveSlope()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "TransformIntoPositiveSlope(double Slope)"
  },
  {
    "label": "TransformIntoSlopeRelativeToReferenceAxis()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "TransformIntoSlopeRelativeToReferenceAxis(double Slope)"
  },
  {
    "label": "TransformIntoUnorientedSlope()",
    "kind": "Method",
    "detail": "Function (Slope =)",
    "insertText": "TransformIntoUnorientedSlope(Slope)"
  },
  {
    "label": "SwapSlopeOrientation()",
    "kind": "Method",
    "detail": "Function (Slope = Slope::PiSlope - Slope ; } return Slope ; } double)",
    "insertText": "SwapSlopeOrientation(double Slope)"
  },
  {
    "label": "TransformIntoPositiveSlope()",
    "kind": "Method",
    "detail": "Function (const double SwapedSlope = Slope<Slope::PiSlope ? Slope + Slope::PiSlope : Slope - Slope::PiSlope ; return)",
    "insertText": "TransformIntoPositiveSlope(SwapedSlope)"
  },
  {
    "label": "ComputeSlope()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "ComputeSlope(const FPoint2D& StartPoint, const FPoint2D& EndPoint)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Delta = DeltaV / DeltaU ; } else { Delta = 2 . - DeltaU / DeltaV ; } } else {)",
    "insertText": "if(DeltaU > -DeltaV)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Delta = 8 . + DeltaV / DeltaU ; } else)",
    "insertText": "if(fabs(DeltaV) > DOUBLE_SMALL_NUMBER)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Delta = 6 . - DeltaU / DeltaV ; } else { Delta = 8 . ; } } } else)",
    "insertText": "if(-DeltaU > DOUBLE_SMALL_NUMBER)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Delta = 4 . + DeltaV / DeltaU ; } else { Delta = 2 . - DeltaU / DeltaV ; } } else {)",
    "insertText": "if(-DeltaU > -DeltaV)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Delta = 6 . - DeltaU / DeltaV ; } else { Delta = 4 . ; } } } else {)",
    "insertText": "if(DeltaV > 0)"
  },
  {
    "label": "ComputeSlope()",
    "kind": "Method",
    "detail": "Function (Delta = 2 . ; } else { Delta = 6 . ; } } return Delta ; } double)",
    "insertText": "ComputeSlope(const FPoint2D& StartPoint, const FPoint2D& EndPoint, double ReferenceSlope)"
  },
  {
    "label": "ComputeSlope()",
    "kind": "Method",
    "detail": "Function (const double Slope =)",
    "insertText": "ComputeSlope(StartPoint, EndPoint)"
  },
  {
    "label": "ComputeSlope()",
    "kind": "Method",
    "detail": "Function (const double ReferenceSlope =)",
    "insertText": "ComputeSlope(StartPoint, EndPoint1)"
  },
  {
    "label": "ComputeSlope()",
    "kind": "Method",
    "detail": "Function (const double Slope =)",
    "insertText": "ComputeSlope(StartPoint, EndPoint2)"
  },
  {
    "label": "ComputePositiveSlope()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "ComputePositiveSlope(const FPoint2D& StartPoint, const FPoint2D& EndPoint1, const FPoint2D& EndPoint2)"
  },
  {
    "label": "ClockwiseSlope()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "ClockwiseSlope(const FPoint2D& StartPoint, const FPoint2D& EndPoint, double ReferenceSlope)"
  },
  {
    "label": "CounterClockwiseSlope()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "CounterClockwiseSlope(const FPoint2D& StartPoint, const FPoint2D& EndPoint, double ReferenceSlope)"
  },
  {
    "label": "ComputeOrientedSlope()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "ComputeOrientedSlope(const FPoint2D& StartPoint, const FPoint2D& EndPoint, double ReferenceSlope)"
  },
  {
    "label": "ComputeOrientedSlope()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "ComputeOrientedSlope(const FPoint2D& StartPoint, const FPoint2D& EndPoint1, const FPoint2D& EndPoint2)"
  },
  {
    "label": "ComputeUnorientedSlope()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "ComputeUnorientedSlope(const FPoint2D& StartPoint, const FPoint2D& EndPoint, double ReferenceSlope)"
  },
  {
    "label": "ComputeSlope()",
    "kind": "Method",
    "detail": "Function (const double Slope =)",
    "insertText": "ComputeSlope(StartPoint, EndPoint, ReferenceSlope)"
  },
  {
    "label": "ComputeSlopeRelativeToNearestAxis()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "ComputeSlopeRelativeToNearestAxis(const FPoint2D& StartPoint, const FPoint2D& EndPoint)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Slope = Slope::PiSlope - Slope ; })",
    "insertText": "if(Slope > Slope::QuaterPiSlope)"
  },
  {
    "label": "ComputeSlopeRelativeToReferenceAxis()",
    "kind": "Method",
    "detail": "Function (Slope = Slope::RightSlope - Slope ; } return Slope ; } double)",
    "insertText": "ComputeSlopeRelativeToReferenceAxis(const FPoint2D& StartPoint, const FPoint2D& EndPoint, double ReferenceAxisSlope)"
  },
  {
    "label": "ComputeSlope()",
    "kind": "Method",
    "detail": "Function (const double Slope =)",
    "insertText": "ComputeSlope(StartPoint, EndPoint, ReferenceAxisSlope)"
  },
  {
    "label": "ComputeUnorientedSlope()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "ComputeUnorientedSlope(const FPoint2D& StartPoint, const FPoint2D& EndPoint1, const FPoint2D& EndPoint2)"
  },
  {
    "label": "IsPointPInsideSectorABC()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsPointPInsideSectorABC(const FPoint2D& PointA, const FPoint2D& PointB, const FPoint2D& PointC, const FPoint2D& PointP, const double FlatAngle)"
  },
  {
    "label": "SlopeToVector()",
    "kind": "Method",
    "detail": "Function (} FPoint2D)",
    "insertText": "SlopeToVector(const double Slope)"
  },
  {
    "label": "SlopeStep()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "SlopeStep(int32)(Slope)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (FPoint2D Vector ;)",
    "insertText": "switch(SlopeStep)"
  }
]