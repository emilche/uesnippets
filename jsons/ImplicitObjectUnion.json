[
  {
    "label": "FImplicitBVH",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImplicitBVH"
  },
  {
    "label": "FImplicitBVHObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImplicitBVHObject"
  },
  {
    "label": "FImplicitObjectUnion",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImplicitObjectUnion"
  },
  {
    "label": "FISPCDataVerifier",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FISPCDataVerifier"
  },
  {
    "label": "FLargeUnionClusteredImplicitInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLargeUnionClusteredImplicitInfo"
  },
  {
    "label": "FImplicitObjectUnionClustered",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImplicitObjectUnionClustered"
  },
  {
    "label": "TImplicitTypeInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TImplicitTypeInfo"
  },
  {
    "label": "FImplicitObjectUnion()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitObjectUnion(TArray<Chaos::FImplicitObjectPtr>&& Objects)"
  },
  {
    "label": "FImplicitObjectUnion()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitObjectUnion(const FImplicitObjectUnion& Other)"
  },
  {
    "label": "FImplicitObjectUnion()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitObjectUnion(FImplicitObjectUnion&& Other)"
  },
  {
    "label": "FImplicitObjectUnion()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FImplicitObjectUnion()"
  },
  {
    "label": "Combine()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Combine(TArray<Chaos::FImplicitObjectPtr>& Objects)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAt(int32 RemoveIndex)"
  },
  {
    "label": "RemoveAtSortedIndices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAtSortedIndices(const TArrayView<const int32>& InIndices)"
  },
  {
    "label": "GetNumRootObjects()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumRootObjects()"
  },
  {
    "label": "GetNumLeafObjects()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetNumLeafObjects()"
  },
  {
    "label": "RebuildBVH()",
    "kind": "Method",
    "detail": "Function (Flags . bAllowBVH = bInAllowBVH ;)",
    "insertText": "RebuildBVH()"
  },
  {
    "label": "CopyGeometry()",
    "kind": "Method",
    "detail": "Function (} } Chaos::FImplicitObjectPtr)",
    "insertText": "CopyGeometry()"
  },
  {
    "label": "CopyGeometryWithScale()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "CopyGeometryWithScale(const FVec3& Scale)"
  },
  {
    "label": "DeepCopyGeometry()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "DeepCopyGeometry()"
  },
  {
    "label": "DeepCopyGeometryWithScale()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "DeepCopyGeometryWithScale(const FVec3& Scale)"
  },
  {
    "label": "PhiWithNormal()",
    "kind": "Method",
    "detail": "Function (FReal)",
    "insertText": "PhiWithNormal(const FVec3& x, FVec3& Normal)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const Chaos::FImplicitObjectsArray& Objects = MObjects ; FReal Phi = TNumericLimits<FReal)",
    "insertText": "Max()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool NeedsNormalize = false ;)",
    "insertText": "for(int32 i = 0; i < Objects.Num(); ++i)"
  },
  {
    "label": "PhiWithNormal()",
    "kind": "Method",
    "detail": "Function (continue ; } FVec3 NextNormal ; FReal NextPhi = Objects [ i ] ->)",
    "insertText": "PhiWithNormal(x, NextNormal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Phi = NextPhi ; Normal = NextNormal ; NeedsNormalize = false ; } else)",
    "insertText": "if(NextPhi == Phi)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Normal + = NextNormal ; NeedsNormalize = true ; } })",
    "insertText": "if(NeedsNormalize)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (Normal .)",
    "insertText": "Normalize()"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (} return Phi ; } const FAABB3)",
    "insertText": "BoundingBox()"
  },
  {
    "label": "AccumulateAllImplicitObjects()",
    "kind": "Method",
    "detail": "Function (Object ->)",
    "insertText": "AccumulateAllImplicitObjects(Out, ParentTM)"
  },
  {
    "label": "FindAllIntersectingObjects()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "FindAllIntersectingObjects(TArray < Pair<const FImplicitObject*, FRigidTransform3>>& Out, const FAABB3& LocalBounds)"
  },
  {
    "label": "CacheAllImplicitObjects()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CacheAllImplicitObjects()"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Raycast(const FVec3& StartPoint, const FVec3& Dir, const FReal Length, const FReal Thickness, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FReal MinTime = 0 ; bool bFound = false ;)",
    "insertText": "for(const Chaos::FImplicitObjectPtr& Obj : MObjects)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FVec3 Position ; FVec3 Normal ; FReal Time ; int32 FaceIdx ;)",
    "insertText": "if(Obj->Raycast(StartPoint, Dir, Length, Thickness, Time, Position, Normal, FaceIdx))"
  },
  {
    "label": "Overlap()",
    "kind": "Method",
    "detail": "Function (MinTime = Time ; OutTime = Time ; OutPosition = Position ; OutNormal = Normal ; OutFaceIndex = FaceIdx ; bFound = true ; } } } return bFound ; } bool)",
    "insertText": "Overlap(const FVec3& Point, const FReal Thickness)"
  },
  {
    "label": "IsValidGeometry()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValidGeometry()"
  },
  {
    "label": "GetObjects()",
    "kind": "Method",
    "detail": "Function (bValid = bValid&&)",
    "insertText": "GetObjects().Num()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetTypeHash()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (uint32 Result = 0 ;)",
    "insertText": "for(const Chaos::FImplicitObjectPtr& InnerObj : MObjects)"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "HashCombine(Result, InnerObj->GetTypeHash())"
  },
  {
    "label": "GetBVH()",
    "kind": "Method",
    "detail": "Function (} return Result ; } const Private::FImplicitBVH*)",
    "insertText": "GetBVH()"
  },
  {
    "label": "OffsetOfMObjects()",
    "kind": "Method",
    "detail": "Function (} # if INTEL_ISPC struct FISPCDataVerifier { int32)",
    "insertText": "OffsetOfMObjects()"
  },
  {
    "label": "SizeOfMObjects()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "SizeOfMObjects()"
  },
  {
    "label": "FindClosestIntersectionImp()",
    "kind": "Method",
    "detail": "Function (} } ; FISPCDataVerifier ; # endif protected : Pair<FVec3,bool>)",
    "insertText": "FindClosestIntersectionImp(const FVec3& StartPoint, const FVec3& EndPoint, const FReal Thickness)"
  },
  {
    "label": "FindClosestIntersection()",
    "kind": "Method",
    "detail": "Function (auto ClosestIntersection = MObjects [ 0 ] ->)",
    "insertText": "FindClosestIntersection(StartPoint, EndPoint, Thickness)"
  },
  {
    "label": "Second()",
    "kind": "Method",
    "detail": "Function (FReal Length = ClosestIntersection .)",
    "insertText": "Second(ClosestIntersection.First - StartPoint).Size()"
  },
  {
    "label": "NewLength()",
    "kind": "Method",
    "detail": "Function (FReal)",
    "insertText": "NewLength(NextClosestIntersection.First - StartPoint).Size()"
  },
  {
    "label": "CountObjectsInHierarchyImpl()",
    "kind": "Method",
    "detail": "Function (Length = NewLength ; ClosestIntersection = NextClosestIntersection ; } } return ClosestIntersection ; } int32)",
    "insertText": "CountObjectsInHierarchyImpl()"
  },
  {
    "label": "CountLeafObjectsInHierarchyImpl()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "CountLeafObjectsInHierarchyImpl()"
  },
  {
    "label": "VisitOverlappingLeafObjectsImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitOverlappingLeafObjectsImpl(const FAABB3& LocalBounds, const FRigidTransform3& ObjectTransform, const int32 RootObjectIndex, int32& ObjectIndex, int32& LeafObjectIndex, const FImplicitHierarchyVisitor& VisitorFunc)"
  },
  {
    "label": "VisitLeafObjectsImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitLeafObjectsImpl(const FRigidTransform3& ObjectTransform, const int32 RootObjectIndex, int32& ObjectIndex, int32& LeafObjectIndex, const FImplicitHierarchyVisitor& VisitorFunc)"
  },
  {
    "label": "VisitObjectsImpl()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "VisitObjectsImpl(const FRigidTransform3& ObjectTransform, const int32 RootObjectIndex, int32& ObjectIndex, int32& LeafObjectIndex, const FImplicitHierarchyVisitorBool& VisitorFunc)"
  },
  {
    "label": "IsOverlappingBoundsImpl()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsOverlappingBoundsImpl(const FAABB3& LocalBounds)"
  },
  {
    "label": "SetNumLeafObjects()",
    "kind": "Method",
    "detail": "Function (FImplicitObject ; void)",
    "insertText": "SetNumLeafObjects(const int32 InNumLeafObjects)"
  },
  {
    "label": "CreateBVH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateBVH()"
  },
  {
    "label": "DestroyBVH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroyBVH()"
  },
  {
    "label": "LegacySerializeBVH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LegacySerializeBVH(FChaosArchive& Ar)"
  },
  {
    "label": "FFLags()",
    "kind": "Method",
    "detail": "Function (union FFLags { public :)",
    "insertText": "FFLags() : Bits(0)"
  },
  {
    "label": "HasValidBVH()",
    "kind": "Method",
    "detail": "Function (} struct { uint8 bAllowBVH : 1 ; uint8 bHasBVH : 1 ; } ; uint8 Bits ; } ; bool)",
    "insertText": "HasValidBVH()"
  },
  {
    "label": "FLargeUnionClusteredImplicitInfo()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::FImplicitObjectPtr> MObjects ; FAABB3 MLocalBoundingBox ; TUniquePtr<Private::FImplicitBVH> BVH ; int32 NumLeafObjects ; FFLags Flags ; } ; struct FLargeUnionClusteredImplicitInfo {)",
    "insertText": "FLargeUnionClusteredImplicitInfo(const FImplicitObject* InImplicit, const FRigidTransform3& InTransform, const FBVHParticles* InBVHParticles) : Implicit(InImplicit) , Transform(InTransform) , BVHParticles(InBVHParticles)"
  },
  {
    "label": "FImplicitObjectUnionClustered()",
    "kind": "Method",
    "detail": "Function (} const FImplicitObject* Implicit ; FRigidTransform3 Transform ; const FBVHParticles* BVHParticles ; } ; class FImplicitObjectUnionClustered : public FImplicitObjectUnion { public :)",
    "insertText": "FImplicitObjectUnionClustered()"
  },
  {
    "label": "FImplicitObjectUnionClustered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitObjectUnionClustered(TArray<Chaos::FImplicitObjectPtr>&& Objects, const TArray<FPBDRigidParticleHandle*>& OriginalParticleLookupHack = TArray<FPBDRigidParticleHandle*>())"
  },
  {
    "label": "FImplicitObjectUnionClustered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitObjectUnionClustered(const FImplicitObjectUnionClustered& Other)"
  },
  {
    "label": "FImplicitObjectUnionClustered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitObjectUnionClustered(FImplicitObjectUnionClustered&& Other)"
  },
  {
    "label": "FindAllIntersectingChildren()",
    "kind": "Method",
    "detail": "Function (} TArray<FPBDRigidParticleHandle*>)",
    "insertText": "FindAllIntersectingChildren(const FAABB3& LocalBounds)"
  },
  {
    "label": "FindParticleForImplicitObject()",
    "kind": "Method",
    "detail": "Function (const FPBDRigidParticleHandle*)",
    "insertText": "FindParticleForImplicitObject(const FImplicitObject* Object)"
  },
  {
    "label": "GetChildSimplicial()",
    "kind": "Method",
    "detail": "Function (const FBVHParticles*)",
    "insertText": "GetChildSimplicial(const int32 ChildIndex)"
  },
  {
    "label": "IsBaseOf()",
    "kind": "Method",
    "detail": "Function (private : TArray<FPBDRigidParticleHandle*> MOriginalParticleLookupHack ; TMap<const FImplicitObject*,FPBDRigidParticleHandle*> MCollisionParticleLookupHack ; } ; template<> struct TImplicitTypeInfo<FImplicitObjectUnion> { bool)",
    "insertText": "IsBaseOf(const EImplicitObjectType InType)"
  }
]