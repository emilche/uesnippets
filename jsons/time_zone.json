[
  {
    "label": "representing",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "representing"
  },
  {
    "label": "time_zone",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "time_zone"
  },
  {
    "label": "absolute_lookup",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "absolute_lookup"
  },
  {
    "label": "will",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "will"
  },
  {
    "label": "civil_lookup",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "civil_lookup"
  },
  {
    "label": "civil_kind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "civil_kind"
  },
  {
    "label": "civil_transition",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "civil_transition"
  },
  {
    "label": "Impl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Impl"
  },
  {
    "label": "should",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "should"
  },
  {
    "label": "split_seconds()",
    "kind": "Method",
    "detail": "Function (D>)",
    "insertText": "split_seconds(const time_point<D>& tp)"
  },
  {
    "label": "split_seconds()",
    "kind": "Method",
    "detail": "Function (seconds>)",
    "insertText": "split_seconds(\n    const time_point<seconds>& tp)"
  },
  {
    "label": "load_time_zone()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "load_time_zone(const std::string& name, time_zone* tz)"
  },
  {
    "label": "utc_time_zone()",
    "kind": "Method",
    "detail": "Function (time_zone)",
    "insertText": "utc_time_zone()"
  },
  {
    "label": "fixed_time_zone()",
    "kind": "Method",
    "detail": "Function (time_zone)",
    "insertText": "fixed_time_zone(const seconds& offset)"
  },
  {
    "label": "local_time_zone()",
    "kind": "Method",
    "detail": "Function (time_zone)",
    "insertText": "local_time_zone()"
  },
  {
    "label": "format()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "format(const std::string&, const time_point<seconds>&,\n                   const femtoseconds&, const time_zone&)"
  },
  {
    "label": "parse()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "parse(const std::string&, const std::string&, const time_zone&,\n           time_point<seconds>*, femtoseconds*, std::string* err = nullptr)"
  },
  {
    "label": "join_seconds()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "join_seconds(\n    const time_point<seconds>& sec, const femtoseconds& fs,\n    time_point<std::chrono::duration<Rep, std::ratio<1, Denom>>>* tpp)"
  },
  {
    "label": "join_seconds()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "join_seconds(\n    const time_point<seconds>& sec, const femtoseconds& fs,\n    time_point<std::chrono::duration<Rep, std::ratio<Num, 1>>>* tpp)"
  },
  {
    "label": "join_seconds()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "join_seconds(\n    const time_point<seconds>& sec, const femtoseconds& fs,\n    time_point<std::chrono::duration<Rep, std::ratio<1, 1>>>* tpp)"
  },
  {
    "label": "join_seconds()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "join_seconds(const time_point<seconds>& sec, const femtoseconds&,\n                  time_point<seconds>* tpp)"
  }
]