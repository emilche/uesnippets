[
  {
    "label": "DScheme",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "DScheme"
  },
  {
    "label": "DDScheme",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "DDScheme"
  },
  {
    "label": "BiasedGradientScheme",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "BiasedGradientScheme"
  },
  {
    "label": "TemporalIntegrationScheme",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "TemporalIntegrationScheme"
  },
  {
    "label": "D1",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "D1"
  },
  {
    "label": "D1Vec",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "D1Vec"
  },
  {
    "label": "D2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "D2"
  },
  {
    "label": "dsSchemeToString()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_FINITEDIFFERENCE_HAS_BEEN_INCLUDED # define OPENVDB_MATH_FINITEDIFFERENCE_HAS_BEEN_INCLUDED # include<openvdb / Types . h> # include \" Math . h \" # include \" Coord . h \" # include \" Vec3 . h \" # include<string> # include<boost / algorithm / string / case_conv . hpp> # include<boost / algorithm / string / trim . hpp> # ifdef DWA_OPENVDB # include<simd / Simd . h> # endif namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { enum DScheme { UNKNOWN_DS = - 1,CD_2NDT = 0,CD_2ND,CD_4TH,CD_6TH,FD_1ST,FD_2ND,FD_3RD,BD_1ST,BD_2ND,BD_3RD,FD_WENO5,BD_WENO5,FD_HJWENO5,BD_HJWENO5 } ; enum { NUM_DS_SCHEMES = BD_HJWENO5 + 1 } ; std::string)",
    "insertText": "dsSchemeToString(DScheme dss)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (std::string ret ;)",
    "insertText": "switch(dss)"
  },
  {
    "label": "trim()",
    "kind": "Method",
    "detail": "Function (DScheme ret = UNKNOWN_DS ; std::string str = s ;)",
    "insertText": "trim(str)"
  },
  {
    "label": "to_lower()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "to_lower(str)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = CD_2NDT ; } else)",
    "insertText": "if(str == dsSchemeToString(CD_2ND))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = CD_2ND ; } else)",
    "insertText": "if(str == dsSchemeToString(CD_4TH))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = CD_4TH ; } else)",
    "insertText": "if(str == dsSchemeToString(CD_6TH))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = CD_6TH ; } else)",
    "insertText": "if(str == dsSchemeToString(FD_1ST))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = FD_1ST ; } else)",
    "insertText": "if(str == dsSchemeToString(FD_2ND))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = FD_2ND ; } else)",
    "insertText": "if(str == dsSchemeToString(FD_3RD))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = FD_3RD ; } else)",
    "insertText": "if(str == dsSchemeToString(BD_1ST))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = BD_1ST ; } else)",
    "insertText": "if(str == dsSchemeToString(BD_2ND))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = BD_2ND ; } else)",
    "insertText": "if(str == dsSchemeToString(BD_3RD))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = BD_3RD ; } else)",
    "insertText": "if(str == dsSchemeToString(FD_WENO5))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = FD_WENO5 ; } else)",
    "insertText": "if(str == dsSchemeToString(BD_WENO5))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = BD_WENO5 ; } else)",
    "insertText": "if(str == dsSchemeToString(FD_HJWENO5))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = FD_HJWENO5 ; } else)",
    "insertText": "if(str == dsSchemeToString(BD_HJWENO5))"
  },
  {
    "label": "dsSchemeToMenuName()",
    "kind": "Method",
    "detail": "Function (ret = BD_HJWENO5 ; } return ret ; } std::string)",
    "insertText": "dsSchemeToMenuName(DScheme dss)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (std::string ret ;)",
    "insertText": "switch(bgs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = FIRST_BIAS ; } else)",
    "insertText": "if(str == biasedGradientSchemeToString(SECOND_BIAS))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = SECOND_BIAS ; } else)",
    "insertText": "if(str == biasedGradientSchemeToString(THIRD_BIAS))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = THIRD_BIAS ; } else)",
    "insertText": "if(str == biasedGradientSchemeToString(WENO5_BIAS))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = WENO5_BIAS ; } else)",
    "insertText": "if(str == biasedGradientSchemeToString(HJWENO5_BIAS))"
  },
  {
    "label": "biasedGradientSchemeToMenuName()",
    "kind": "Method",
    "detail": "Function (ret = HJWENO5_BIAS ; } return ret ; } std::string)",
    "insertText": "biasedGradientSchemeToMenuName(BiasedGradientScheme bgs)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (std::string ret ;)",
    "insertText": "switch(tis)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = TVD_RK1 ; } else)",
    "insertText": "if(str == temporalIntegrationSchemeToString(TVD_RK2))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ret = TVD_RK2 ; } else)",
    "insertText": "if(str == temporalIntegrationSchemeToString(TVD_RK3))"
  },
  {
    "label": "temporalIntegrationSchemeToMenuName()",
    "kind": "Method",
    "detail": "Function (ret = TVD_RK3 ; } return ret ; } std::string)",
    "insertText": "temporalIntegrationSchemeToMenuName(TemporalIntegrationScheme tis)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (const double C = 1 3 . 0 / 1 2 . 0 ; const double eps = 1 . 0 e - 6* static_cast<)",
    "insertText": "double(scale2)"
  },
  {
    "label": "Pow2()",
    "kind": "Method",
    "detail": "Function (const double A1 = 0 . 1 /)",
    "insertText": "Pow2(C*math::Pow2(v1-2*v2+v3)+0.25*math::Pow2(v1-4*v2+3.0*v3)+eps), A2=0.6/math::Pow2(C*math::Pow2(v2-2*v3+v4)+0.25*math::Pow2(v2-v4)+eps), A3=0.3/math::Pow2(C*math::Pow2(v3-2*v4+v5)+0.25*math::Pow2(3.0*v3-4*v4+v5)+eps)"
  },
  {
    "label": "GodunovsNormSqrd()",
    "kind": "Method",
    "detail": "Function (} template<Real> Real)",
    "insertText": "GodunovsNormSqrd(bool isOutside, Real dP_xm, Real dP_xp, Real dP_ym, Real dP_yp, Real dP_zm, Real dP_zp)"
  },
  {
    "label": "zero()",
    "kind": "Method",
    "detail": "Function (using math::Max ; using math::Min ; using math::Pow2 ; const Real)",
    "insertText": "zero(0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Real dPLen2 ;)",
    "insertText": "if(isOutside)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (dPLen2 =)",
    "insertText": "Max(Pow2(Max(dP_xm, zero)), Pow2(Min(dP_xp,zero)))"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (dPLen2 + =)",
    "insertText": "Max(Pow2(Max(dP_ym, zero)), Pow2(Min(dP_yp,zero)))"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (dPLen2 + =)",
    "insertText": "Max(Pow2(Max(dP_zm, zero)), Pow2(Min(dP_zp,zero)))"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} else { dPLen2 =)",
    "insertText": "Max(Pow2(Min(dP_xm, zero)), Pow2(Max(dP_xp,zero)))"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (dPLen2 + =)",
    "insertText": "Max(Pow2(Min(dP_ym, zero)), Pow2(Max(dP_yp,zero)))"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (dPLen2 + =)",
    "insertText": "Max(Pow2(Min(dP_zm, zero)), Pow2(Max(dP_zp,zero)))"
  },
  {
    "label": "GodunovsNormSqrd()",
    "kind": "Method",
    "detail": "Function (} return dPLen2 ; } template<Real> Real)",
    "insertText": "GodunovsNormSqrd(bool isOutside, const Vec3<Real>& gradient_m, const Vec3<Real>& gradient_p)"
  },
  {
    "label": "simdMin()",
    "kind": "Method",
    "detail": "Function (} # ifdef DWA_OPENVDB simd::Float4)",
    "insertText": "simdMin(const simd::Float4& a, const simd::Float4& b)"
  },
  {
    "label": "simdMax()",
    "kind": "Method",
    "detail": "Function (} simd::Float4)",
    "insertText": "simdMax(const simd::Float4& a, const simd::Float4& b)"
  },
  {
    "label": "simdSum()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "simdSum(const simd::Float4& v)"
  },
  {
    "label": "Pow2()",
    "kind": "Method",
    "detail": "Function (simd::Float4)",
    "insertText": "Pow2(const simd::Float4& v)"
  },
  {
    "label": "C()",
    "kind": "Method",
    "detail": "Function (using math::Pow2 ; using F4 = simd::Float4 ; const F4)",
    "insertText": "C(13.f / 12.f), eps(1.0e-6f * scale2), two(2.0), three(3.0), four(4.0), five(5.0), fourth(0.25), A1 = F4(0.1f) / Pow2(C*Pow2(v1-two*v2+v3) + fourth*Pow2(v1-four*v2+three*v3) + eps), A2 = F4(0.6f) / Pow2(C*Pow2(v2-two*v3+v4) + fourth*Pow2(v2-v4) + eps), A3 = F4(0.3f) / Pow2(C*Pow2(v3-two*v4+v5) + fourth*Pow2(three*v3-four*v4+v5) + eps)"
  },
  {
    "label": "_mm_add_ps()",
    "kind": "Method",
    "detail": "Function (__m128 temp =)",
    "insertText": "_mm_add_ps(v.base(), _mm_movehl_ps(v.base(), v.base()))"
  },
  {
    "label": "_mm_add_ss()",
    "kind": "Method",
    "detail": "Function (temp =)",
    "insertText": "_mm_add_ss(temp, _mm_shuffle_ps(temp, temp, 1))"
  },
  {
    "label": "GodunovsNormSqrd()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GodunovsNormSqrd(bool isOutside, const simd::Float4& dP_m, const simd::Float4& dP_p)"
  },
  {
    "label": "zero()",
    "kind": "Method",
    "detail": "Function (const simd::Float4)",
    "insertText": "zero(0.0)"
  },
  {
    "label": "simdMax()",
    "kind": "Method",
    "detail": "Function (simd::Float4 v = isOutside ?)",
    "insertText": "simdMax(math::Pow2(simdMax(dP_m, zero)), math::Pow2(simdMin(dP_p, zero))) : simdMax(math::Pow2(simdMin(dP_m, zero)), math::Pow2(simdMax(dP_p, zero)))"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (} # endif template<DScheme DiffScheme> struct D1 { template<Accessor> Accessor::ValueType)",
    "insertText": "inX(const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "inY()",
    "kind": "Method",
    "detail": "Function (template<Accessor> Accessor::ValueType)",
    "insertText": "inY(const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "inZ()",
    "kind": "Method",
    "detail": "Function (template<Accessor> Accessor::ValueType)",
    "insertText": "inZ(const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (template<Stencil> Stencil::ValueType)",
    "insertText": "inX(const Stencil& S)"
  },
  {
    "label": "inY()",
    "kind": "Method",
    "detail": "Function (template<Stencil> Stencil::ValueType)",
    "insertText": "inY(const Stencil& S)"
  },
  {
    "label": "inZ()",
    "kind": "Method",
    "detail": "Function (template<Stencil> Stencil::ValueType)",
    "insertText": "inZ(const Stencil& S)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} ; template<> struct D1<CD_2NDT> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xp1, const ValueType& xm1)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "difference(const bool& xp1, const bool&)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D1<CD_4TH> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xp2, const ValueType& xp1, const ValueType& xm1, const ValueType& xm2)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D1<CD_6TH> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xp3, const ValueType& xp2, const ValueType& xp1, const ValueType& xm1, const ValueType& xm2, const ValueType& xm3)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D1<FD_1ST> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xp1, const ValueType& xp0)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D1<FD_2ND> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xp2, const ValueType& xp1, const ValueType& xp0)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D1<FD_3RD> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xp3, const ValueType& xp2, const ValueType& xp1, const ValueType& xp0)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D1<BD_1ST> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xm1, const ValueType& xm0)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D1<BD_2ND> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xm2, const ValueType& xm1, const ValueType& xm0)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D1<BD_3RD> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xm3, const ValueType& xm2, const ValueType& xm1, const ValueType& xm0)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D1<FD_WENO5> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xp3, const ValueType& xp2, const ValueType& xp1, const ValueType& xp0, const ValueType& xm1, const ValueType& xm2)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; ValueType V [ 6 ] ; V [ 0 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(3,0,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 1 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(2,0,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 2 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(1,0,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 3 ] = grid .)",
    "insertText": "getValue(ijk)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 4 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(-1,0,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 5 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(-2,0,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; ValueType V [ 6 ] ; V [ 0 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,3,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 1 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,2,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 2 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,1,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 4 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,-1,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 5 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,-2,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; ValueType V [ 6 ] ; V [ 0 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,0,3))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 1 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,0,2))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 2 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,0,1))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 4 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,0,-1))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (V [ 5 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,0,-2))"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D1<BD_WENO5> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xm3, const ValueType& xm2, const ValueType& xm1, const ValueType& xm0, const ValueType& xp1, const ValueType& xp2)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; ValueType V [ 6 ] ; V [ 0 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(-3,0,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; ValueType V [ 6 ] ; V [ 0 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,-3,0))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; ValueType V [ 6 ] ; V [ 0 ] = grid .)",
    "insertText": "getValue(ijk.offsetBy(0,0,-3))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (using ValueType = Stencil::ValueType ; ValueType V [ 6 ] ; V [ 0 ] = S . template)",
    "insertText": "getValue()"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (} } ; template<DScheme DiffScheme> struct D1Vec { template<Accessor> Accessor::ValueType::value_type)",
    "insertText": "inX(const Accessor& grid, const Coord& ijk, int n)"
  },
  {
    "label": "inY()",
    "kind": "Method",
    "detail": "Function (} template<Accessor> Accessor::ValueType::value_type)",
    "insertText": "inY(const Accessor& grid, const Coord& ijk, int n)"
  },
  {
    "label": "inZ()",
    "kind": "Method",
    "detail": "Function (} template<Accessor> Accessor::ValueType::value_type)",
    "insertText": "inZ(const Accessor& grid, const Coord& ijk, int n)"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (} template<Stencil> Stencil::ValueType::value_type)",
    "insertText": "inX(const Stencil& S, int n)"
  },
  {
    "label": "inY()",
    "kind": "Method",
    "detail": "Function (} template<Stencil> Stencil::ValueType::value_type)",
    "insertText": "inY(const Stencil& S, int n)"
  },
  {
    "label": "inZ()",
    "kind": "Method",
    "detail": "Function (} template<Stencil> Stencil::ValueType::value_type)",
    "insertText": "inZ(const Stencil& S, int n)"
  },
  {
    "label": "inXandY()",
    "kind": "Method",
    "detail": "Function (template<Accessor> Accessor::ValueType)",
    "insertText": "inXandY(const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "inXandZ()",
    "kind": "Method",
    "detail": "Function (template<Accessor> Accessor::ValueType)",
    "insertText": "inXandZ(const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "inYandZ()",
    "kind": "Method",
    "detail": "Function (template<Accessor> Accessor::ValueType)",
    "insertText": "inYandZ(const Accessor& grid, const Coord& ijk)"
  },
  {
    "label": "inXandY()",
    "kind": "Method",
    "detail": "Function (template<Stencil> Stencil::ValueType)",
    "insertText": "inXandY(const Stencil& S)"
  },
  {
    "label": "inXandZ()",
    "kind": "Method",
    "detail": "Function (template<Stencil> Stencil::ValueType)",
    "insertText": "inXandZ(const Stencil& S)"
  },
  {
    "label": "inYandZ()",
    "kind": "Method",
    "detail": "Function (template<Stencil> Stencil::ValueType)",
    "insertText": "inYandZ(const Stencil& S)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} ; template<> struct D2<CD_SECOND> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xp1, const ValueType& xp0, const ValueType& xm1)"
  },
  {
    "label": "crossdifference()",
    "kind": "Method",
    "detail": "Function (} template<ValueType> ValueType)",
    "insertText": "crossdifference(const ValueType& xpyp, const ValueType& xpym, const ValueType& xmyp, const ValueType& xmym)"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D2<CD_FOURTH> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xp2, const ValueType& xp1, const ValueType& xp0, const ValueType& xm1, const ValueType& xm2)"
  },
  {
    "label": "crossdifference()",
    "kind": "Method",
    "detail": "Function (} template<ValueType> ValueType)",
    "insertText": "crossdifference(const ValueType& xp2yp2, const ValueType& xp2yp1, const ValueType& xp2ym1, const ValueType& xp2ym2, const ValueType& xp1yp2, const ValueType& xp1yp1, const ValueType& xp1ym1, const ValueType& xp1ym2, const ValueType& xm2yp2, const ValueType& xm2yp1, const ValueType& xm2ym1, const ValueType& xm2ym2, const ValueType& xm1yp2, const ValueType& xm1yp1, const ValueType& xm1ym1, const ValueType& xm1ym2)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType tmp1 =)",
    "insertText": "ValueType(2./3.0)*(xp1yp1 - xm1yp1 - xp1ym1 + xm1ym1)- ValueType(1./12.)*(xp2yp1 - xm2yp1 - xp2ym1 + xm2ym1)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType tmp2 =)",
    "insertText": "ValueType(2./3.0)*(xp1yp2 - xm1yp2 - xp1ym2 + xm1ym2)- ValueType(1./12.)*(xp2yp2 - xm2yp2 - xp2ym2 + xm2ym2)"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; Accessor::ValueType tmp1 = D1<CD_4TH)",
    "insertText": "inX(grid, ijk.offsetBy(0, 1, 0)) - D1<CD_4TH>::inX(grid, ijk.offsetBy(0,-1, 0))"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (Accessor::ValueType tmp2 = D1<CD_4TH)",
    "insertText": "inX(grid, ijk.offsetBy(0, 2, 0)) - D1<CD_4TH>::inX(grid, ijk.offsetBy(0,-2, 0))"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; Accessor::ValueType tmp1 = D1<CD_4TH)",
    "insertText": "inX(grid, ijk.offsetBy(0, 0, 1)) - D1<CD_4TH>::inX(grid, ijk.offsetBy(0, 0,-1))"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (Accessor::ValueType tmp2 = D1<CD_4TH)",
    "insertText": "inX(grid, ijk.offsetBy(0, 0, 2)) - D1<CD_4TH>::inX(grid, ijk.offsetBy(0, 0,-2))"
  },
  {
    "label": "inY()",
    "kind": "Method",
    "detail": "Function (using ValueType = Accessor::ValueType ; Accessor::ValueType tmp1 = D1<CD_4TH)",
    "insertText": "inY(grid, ijk.offsetBy(0, 0, 1)) - D1<CD_4TH>::inY(grid, ijk.offsetBy(0, 0,-1))"
  },
  {
    "label": "inY()",
    "kind": "Method",
    "detail": "Function (Accessor::ValueType tmp2 = D1<CD_4TH)",
    "insertText": "inY(grid, ijk.offsetBy(0, 0, 2)) - D1<CD_4TH>::inY(grid, ijk.offsetBy(0, 0,-2))"
  },
  {
    "label": "difference()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct D2<CD_SIXTH> { template<ValueType> ValueType)",
    "insertText": "difference(const ValueType& xp3, const ValueType& xp2, const ValueType& xp1, const ValueType& xp0, const ValueType& xm1, const ValueType& xm2, const ValueType& xm3)"
  },
  {
    "label": "crossdifference()",
    "kind": "Method",
    "detail": "Function (} template<ValueType> ValueType)",
    "insertText": "crossdifference(const ValueType& xp1yp1,const ValueType& xm1yp1, const ValueType& xp1ym1,const ValueType& xm1ym1, const ValueType& xp2yp1,const ValueType& xm2yp1, const ValueType& xp2ym1,const ValueType& xm2ym1, const ValueType& xp3yp1,const ValueType& xm3yp1, const ValueType& xp3ym1,const ValueType& xm3ym1, const ValueType& xp1yp2,const ValueType& xm1yp2, const ValueType& xp1ym2,const ValueType& xm1ym2, const ValueType& xp2yp2,const ValueType& xm2yp2, const ValueType& xp2ym2,const ValueType& xm2ym2, const ValueType& xp3yp2,const ValueType& xm3yp2, const ValueType& xp3ym2,const ValueType& xm3ym2, const ValueType& xp1yp3,const ValueType& xm1yp3, const ValueType& xp1ym3,const ValueType& xm1ym3, const ValueType& xp2yp3,const ValueType& xm2yp3, const ValueType& xp2ym3,const ValueType& xm2ym3, const ValueType& xp3yp3,const ValueType& xm3yp3, const ValueType& xp3ym3,const ValueType& xm3ym3)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType tmp1 =)",
    "insertText": "ValueType(0.7500)*(xp1yp1 - xm1yp1 - xp1ym1 + xm1ym1) - ValueType(0.1500)*(xp2yp1 - xm2yp1 - xp2ym1 + xm2ym1) + ValueType(1./60.)*(xp3yp1 - xm3yp1 - xp3ym1 + xm3ym1)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType tmp2 =)",
    "insertText": "ValueType(0.7500)*(xp1yp2 - xm1yp2 - xp1ym2 + xm1ym2) - ValueType(0.1500)*(xp2yp2 - xm2yp2 - xp2ym2 + xm2ym2) + ValueType(1./60.)*(xp3yp2 - xm3yp2 - xp3ym2 + xm3ym2)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType tmp3 =)",
    "insertText": "ValueType(0.7500)*(xp1yp3 - xm1yp3 - xp1ym3 + xm1ym3) - ValueType(0.1500)*(xp2yp3 - xm2yp3 - xp2ym3 + xm2ym3) + ValueType(1./60.)*(xp3yp3 - xm3yp3 - xp3ym3 + xm3ym3)"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (using ValueT = Accessor::ValueType ; ValueT tmp1 = D1<CD_6TH)",
    "insertText": "inX(grid, ijk.offsetBy(0, 1, 0)) - D1<CD_6TH>::inX(grid, ijk.offsetBy(0,-1, 0))"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (ValueT tmp2 = D1<CD_6TH)",
    "insertText": "inX(grid, ijk.offsetBy(0, 2, 0)) - D1<CD_6TH>::inX(grid, ijk.offsetBy(0,-2, 0))"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (ValueT tmp3 = D1<CD_6TH)",
    "insertText": "inX(grid, ijk.offsetBy(0, 3, 0)) - D1<CD_6TH>::inX(grid, ijk.offsetBy(0,-3, 0))"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (using ValueT = Accessor::ValueType ; ValueT tmp1 = D1<CD_6TH)",
    "insertText": "inX(grid, ijk.offsetBy(0, 0, 1)) - D1<CD_6TH>::inX(grid, ijk.offsetBy(0, 0,-1))"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (ValueT tmp2 = D1<CD_6TH)",
    "insertText": "inX(grid, ijk.offsetBy(0, 0, 2)) - D1<CD_6TH>::inX(grid, ijk.offsetBy(0, 0,-2))"
  },
  {
    "label": "inX()",
    "kind": "Method",
    "detail": "Function (ValueT tmp3 = D1<CD_6TH)",
    "insertText": "inX(grid, ijk.offsetBy(0, 0, 3)) - D1<CD_6TH>::inX(grid, ijk.offsetBy(0, 0,-3))"
  },
  {
    "label": "inY()",
    "kind": "Method",
    "detail": "Function (using ValueT = Accessor::ValueType ; ValueT tmp1 = D1<CD_6TH)",
    "insertText": "inY(grid, ijk.offsetBy(0, 0, 1)) - D1<CD_6TH>::inY(grid, ijk.offsetBy(0, 0,-1))"
  },
  {
    "label": "inY()",
    "kind": "Method",
    "detail": "Function (ValueT tmp2 = D1<CD_6TH)",
    "insertText": "inY(grid, ijk.offsetBy(0, 0, 2)) - D1<CD_6TH>::inY(grid, ijk.offsetBy(0, 0,-2))"
  },
  {
    "label": "inY()",
    "kind": "Method",
    "detail": "Function (ValueT tmp3 = D1<CD_6TH)",
    "insertText": "inY(grid, ijk.offsetBy(0, 0, 3)) - D1<CD_6TH>::inY(grid, ijk.offsetBy(0, 0,-3))"
  }
]