[
  {
    "label": "ESetMaskConditionType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ESetMaskConditionType"
  },
  {
    "label": "EWaveFunctionType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EWaveFunctionType"
  },
  {
    "label": "EFieldOperationType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldOperationType"
  },
  {
    "label": "EFieldCullingOperationType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldCullingOperationType"
  },
  {
    "label": "EFieldResolutionType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldResolutionType"
  },
  {
    "label": "EFieldFilterType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldFilterType"
  },
  {
    "label": "EFieldObjectType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldObjectType"
  },
  {
    "label": "EFieldPositionType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldPositionType"
  },
  {
    "label": "EFieldFalloffType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldFalloffType"
  },
  {
    "label": "EFieldPhysicsType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldPhysicsType"
  },
  {
    "label": "EFieldVectorType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldVectorType"
  },
  {
    "label": "EFieldScalarType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldScalarType"
  },
  {
    "label": "EFieldIntegerType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldIntegerType"
  },
  {
    "label": "EFieldOutputType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldOutputType"
  },
  {
    "label": "EFieldPhysicsDefaultFields",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EFieldPhysicsDefaultFields"
  },
  {
    "label": "CHAOS_API",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CHAOS_API"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" GeometryCollection / ManagedArrayCollection . h \" # include \" UObject / ObjectMacros . h \" # include \" FieldSystemTypes . generated . h \")",
    "insertText": "UENUM(BlueprintType)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_Set_Always)",
    "insertText": "UMETA(DisplayName = \"Set Always\", ToolTip = \"The particle output value will be equal to Interior-value if the particle position is inside a sphere / Exterior-value otherwise.\"), Field_Set_IFF_NOT_Interior UMETA(DisplayName = \"Merge Interior\", ToolTip = \"The particle output value will be equal to Interior-value if the particle position is inside the sphere or if the particle input value is already Interior-Value / Exterior-value otherwise.\"), Field_Set_IFF_NOT_Exterior UMETA(DisplayName = \"Merge Exterior\", ToolTip = \"The particle output value will be equal to Exterior-value if the particle position is outside the sphere or if the particle input value is already Exterior-Value / Interior-value otherwise.\"), Field_MaskCondition_Max UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_Wave_Cosine)",
    "insertText": "UMETA(DisplayName = \"Cosine\", ToolTip = \"Cosine wave that will move in time.\"), Field_Wave_Gaussian UMETA(DisplayName = \"Gaussian\", ToolTip = \"Gaussian wave that will move in time.\"), Field_Wave_Falloff UMETA(DisplayName = \"Falloff\", ToolTip = \"The radial falloff radius will move along temporal wave.\"), Field_Wave_Decay UMETA(DisplayName = \"Decay\", ToolTip = \"The magnitude of the field will decay in time.\"), Field_Wave_Max UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_Multiply)",
    "insertText": "UMETA(DisplayName = \"Multiply\", ToolTip = \"Multiply the fields output values : Output = Left * Right\"), Field_Divide UMETA(DisplayName = \"Divide\", ToolTip = \"Divide the fields output values : Output = Left / Right\"), Field_Add UMETA(DisplayName = \"Add\", ToolTip = \"Add the fields output values : Output = Left + Right\"), Field_Substract UMETA(DisplayName = \"Subtract\", ToolTip = \"Subtract the fields output : Output = Left - Right\"), Field_Operation_Max UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_Culling_Inside)",
    "insertText": "UMETA(DisplayName = \"Inside\", ToolTip = \"Evaluate the input field if the result of the culling field is equal to 0\"), Field_Culling_Outside UMETA(DisplayName = \"Outside\", ToolTip = \"Evaluate the input field if the result of the culling field is different from 0\"), Field_Culling_Operation_Max UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_Resolution_Minimal)",
    "insertText": "UMETA(DisplayName = \"Minimum\", ToolTip = \"Apply the field to all the active particles\"), Field_Resolution_DisabledParents UMETA(DisplayName = \"Parents\", ToolTip = \"Apply the field to all the parent particles\"), Field_Resolution_Maximum UMETA(DisplayName = \"Maximum\", ToolTip = \"Apply the field to all the solver particles\"), Field_Resolution_Max UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_Filter_Dynamic)",
    "insertText": "UMETA(DisplayName = \"Dynamic\", ToolTip = \"Apply the field to all the dynamic particles\"), Field_Filter_Kinematic UMETA(DisplayName = \"Kinematic\", ToolTip = \"Apply the field to all the kinematic particles\"), Field_Filter_Static UMETA(DisplayName = \"Static\", ToolTip = \"Apply the field to all the static particles\"), Field_Filter_All UMETA(DisplayName = \"All\", ToolTip = \"Apply the field to all the solver particles\"), Field_Filter_Sleeping UMETA(DisplayName = \"Sleeping\", ToolTip = \"Apply the field to all the sleeping particles\"), Field_Filter_Disabled UMETA(DisplayName = \"Disabled\", ToolTip = \"Apply the field to all the disabled particles\"), Field_Filter_Max UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_Object_Rigid)",
    "insertText": "UMETA(DisplayName = \"Rigid\", ToolTip = \"Apply the field to all the rigid particles\"), Field_Object_Cloth UMETA(DisplayName = \"Cloth\", ToolTip = \"Apply the field to all the cloth particles\"), Field_Object_Destruction UMETA(DisplayName = \"Destruction\", ToolTip = \"Apply the field to all the destruction particles\"), Field_Object_Character UMETA(DisplayName = \"Character\", ToolTip = \"Apply the field to all the character particles\"), Field_Object_All UMETA(DisplayName = \"All\", ToolTip = \"Apply the field to all the objects particles\"), Field_Object_Max UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_Position_CenterOfMass)",
    "insertText": "UMETA(DisplayName = \"CenterOfMass\", ToolTip = \"Apply the field to the particles center of mass position\"), Field_Position_PivotPoint UMETA(DisplayName = \"PivotPoint\", ToolTip = \"Apply the field to the particles pivot point position\"), Field_Position_Max UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_FallOff_None)",
    "insertText": "UMETA(DisplayName = \"None\", ToolTip = \"No falloff function is used\"), Field_Falloff_Linear UMETA(DisplayName = \"Linear\", ToolTip = \"The falloff function will be proportional to x\"), Field_Falloff_Inverse UMETA(DisplayName = \"Inverse\", ToolTip = \"The falloff function will be proportional to 1.0/x\"), Field_Falloff_Squared UMETA(DisplayName = \"Squared\", ToolTip = \"The falloff function will be proportional to x*x\"), Field_Falloff_Logarithmic UMETA(DisplayName = \"Logarithmic\", ToolTip = \"The falloff function will be proportional to log(x)\"), Field_Falloff_Max UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_None)",
    "insertText": "UMETA(Hidden), Field_DynamicState UMETA(DisplayName = \"Dynamic State\", ToolTip = \"Set the dynamic state of a particle (static, dynamic, kinematic...)\"), Field_LinearForce UMETA(DisplayName = \"Linear Force\", ToolTip = \"Add a vector field to the particles linear force.\"), Field_ExternalClusterStrain UMETA(DisplayName = \"External Strain\", ToolTip = \"Apply an external strain over the particles. If this strain is over the internal one, the cluster will break.\"), Field_Kill UMETA(DisplayName = \"Kill Particle\", ToolTip = \"Disable the particles for which the field will be higher than 0.\"), Field_LinearVelocity UMETA(DisplayName = \"Linear Velocity\", ToolTip = \"Add a vector field to the particles linear velocity.\"), Field_AngularVelociy UMETA(DisplayName = \"Angular Velocity\", ToolTip = \"Add a vector field to the particles angular velocity.\"), Field_AngularTorque UMETA(DisplayName = \"Angular Torque\", ToolTip = \"Add a vector field to the particles angular torque.\"), Field_InternalClusterStrain UMETA(DisplayName = \"Internal Strain\", ToolTip = \"Add a strain field to the particles internal one.\"), Field_DisableThreshold UMETA(DisplayName = \"Disabled Threshold\", ToolTip = \"Disable the particles if their linear and angular velocity are less than the threshold.\"), Field_SleepingThreshold UMETA(DisplayName = \"Sleeping Threshold\", ToolTip = \"Set particles in sleeping mode if their linear and angular velocity are less than the threshold.\"), Field_PositionStatic UMETA(DisplayName = \"Position Static\", ToolTip = \"Add a position constraint to the particles to remain static\", Hidden), Field_PositionAnimated UMETA(DisplayName = \"Position Animated\", ToolTip = \"Add a position constraint to the particles to follow its kinematic position\", Hidden), Field_PositionTarget UMETA(DisplayName = \"Position Target\", ToolTip = \"Add a position constraint to the particles to follow a target position\", Hidden), Field_DynamicConstraint UMETA(DisplayName = \"Dynamic Constraint\", ToolTip = \"Add the particles to a spring constraint holding them together\", Hidden), Field_CollisionGroup UMETA(DisplayName = \"Collision Group\", ToolTip = \"Set the particles collision group.\"), Field_ActivateDisabled UMETA(DisplayName = \"Activate Disabled\", ToolTip = \"Activate all the disabled particles for which the field value will be 0\"), Field_InitialLinearVelocity UMETA(DisplayName = \"Initial Linear Velocity\", ToolTip = \"Set the geometry collection initial linear velocity\", Hidden), Field_InitialAngularVelocity UMETA(DisplayName = \"Initial Angular Velocity\", ToolTip = \"Set the geometry collection initial angular velocity\", Hidden), Field_LinearImpulse UMETA(DisplayName = \"Linear Impulse\", ToolTip = \"Add a vector field affecting the particles linear impulse.\", Hidden), Field_PhysicsType_Max UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Vector_LinearForce)",
    "insertText": "UMETA(DisplayName = \"Linear Force\", ToolTip = \"Add a vector field to the particles linear force.\"), Vector_LinearVelocity UMETA(DisplayName = \"Linear Velocity\", ToolTip = \"Add a vector field to the particles linear velocity.\"), Vector_AngularVelocity UMETA(DisplayName = \"Angular Velocity\", ToolTip = \"Add a vector field to the particles angular velocity.\"), Vector_AngularTorque UMETA(DisplayName = \"Angular Torque\", ToolTip = \"Add a vector field to the particles angular torque.\"), Vector_PositionTarget UMETA(DisplayName = \"Position Target\", ToolTip = \"Add a position constraint to the particles to follow a target position\", Hidden), Vector_InitialLinearVelocity UMETA(DisplayName = \"Initial Linear Velocity\", ToolTip = \"Set the geometry collection initial linear velocity\", Hidden), Vector_InitialAngularVelocity UMETA(DisplayName = \"Initial Angular Velocity\", ToolTip = \"Set the geometry collection initial angular velocity\", Hidden), Vector_LinearImpulse UMETA(DisplayName = \"Linear Impulse\", ToolTip = \"Add a vector field affecting the particles linear impulse.\", Hidden), Vector_TargetMax UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Scalar_ExternalClusterStrain)",
    "insertText": "UMETA(DisplayName = \"External Strain\", ToolTip = \"Apply an external strain over the particles. If this strain is over the internal one, the cluster will break.\"), Scalar_Kill UMETA(DisplayName = \"Kill Particle\", ToolTip = \"Disable the particles for which the field will be higher than 0.\"), Scalar_DisableThreshold UMETA(DisplayName = \"Disabled Threshold\", ToolTip = \"Disable the particles if their linear and angular velocity are less than the threshold.\"), Scalar_SleepingThreshold UMETA(DisplayName = \"Sleeping Threshold\", ToolTip = \"Set particles in sleeping mode if their linear and angular velocity are less than the threshold.\"), Scalar_InternalClusterStrain UMETA(DisplayName = \"Internal Strain\", ToolTip = \"Add a strain field to the particles internal one.\"), Scalar_DynamicConstraint UMETA(DisplayName = \"Dynamic Constraint\", ToolTip = \"Add the particles to a spring constraint holding them together\", Hidden), Scalar_TargetMax UMETA(Hidden)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Integer_DynamicState)",
    "insertText": "UMETA(DisplayName = \"Dynamic State\", ToolTip = \"Set the dynamic state of a particle (static, dynamic, kinematic...)\"), Integer_ActivateDisabled UMETA(DisplayName = \"Activate Disabled\", ToolTip = \"Activate all the disabled particles for which the field value will be 0\"), Integer_CollisionGroup UMETA(DisplayName = \"Collision Group\", ToolTip = \"Set the particles collision group.\"), Integer_PositionAnimated UMETA(DisplayName = \"Position Animated\", ToolTip = \"Add a position constraint to the particles to follow its kinematic position\", Hidden), Integer_PositionStatic UMETA(DisplayName = \"Position Static\", ToolTip = \"Add a position constraint to the particles to remain static\", Hidden), Integer_TargetMax UMETA(Hidden)"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UENUM()"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_Output_Vector)",
    "insertText": "UMETA(DisplayName = \"Vector Field\"), Field_Output_Scalar UMETA(DisplayName = \"Scalar Field\"), Field_Output_Integer UMETA(DisplayName = \"Integer Field\"), Field_Output_Max UMETA(Hidden)"
  },
  {
    "label": "GetFieldTargetTypes()",
    "kind": "Method",
    "detail": "Function (TArray<EFieldPhysicsType>)",
    "insertText": "GetFieldTargetTypes(EFieldOutputType OutputType)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (TArray<EFieldPhysicsType> PhysicsTypes ;)",
    "insertText": "switch(OutputType)"
  },
  {
    "label": "GetFieldTargetIndex()",
    "kind": "Method",
    "detail": "Function (} EFieldOutputType)",
    "insertText": "GetFieldTargetIndex(const TArray<EFieldPhysicsType>& VectorTypes, const TArray<EFieldPhysicsType>& ScalarTypes, const TArray<EFieldPhysicsType>& IntegerTypes, const EFieldPhysicsType FieldTarget, int32& TargetIndex)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (EFieldOutputType OutputType = EFieldOutputType::Field_Output_Max ; TargetIndex = VectorTypes .)",
    "insertText": "Find(FieldTarget)"
  },
  {
    "label": "GetFieldTargetOutput()",
    "kind": "Method",
    "detail": "Function (OutputType = EFieldOutputType::Field_Output_Integer ; } } else { OutputType = EFieldOutputType::Field_Output_Scalar ; } } else { OutputType = EFieldOutputType::Field_Output_Vector ; } return OutputType ; } EFieldOutputType)",
    "insertText": "GetFieldTargetOutput(const EFieldPhysicsType FieldTarget)"
  },
  {
    "label": "GetFieldTargetTypes()",
    "kind": "Method",
    "detail": "Function (EFieldOutputType OutputType = EFieldOutputType::Field_Output_Max ; const TArray<EFieldPhysicsType> VectorTypes =)",
    "insertText": "GetFieldTargetTypes(EFieldOutputType::Field_Output_Vector)"
  },
  {
    "label": "GetFieldTargetTypes()",
    "kind": "Method",
    "detail": "Function (const TArray<EFieldPhysicsType> ScalarTypes =)",
    "insertText": "GetFieldTargetTypes(EFieldOutputType::Field_Output_Scalar)"
  },
  {
    "label": "GetFieldTargetTypes()",
    "kind": "Method",
    "detail": "Function (const TArray<EFieldPhysicsType> IntegerTypes =)",
    "insertText": "GetFieldTargetTypes(EFieldOutputType::Field_Output_Integer)"
  },
  {
    "label": "GetFieldTargetIndex()",
    "kind": "Method",
    "detail": "Function (int32 TargetIndex = INDEX_NONE ; return)",
    "insertText": "GetFieldTargetIndex(VectorTypes, ScalarTypes, IntegerTypes, FieldTarget, TargetIndex)"
  },
  {
    "label": "GetFieldOutputName()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "GetFieldOutputName(const EFieldOutputType Type)"
  },
  {
    "label": "GetFieldPhysicsTypes()",
    "kind": "Method",
    "detail": "Function (const TArray<FName> FieldPhysicsNames = { \" Node \",\" DynamicState \",\" LinearForce \",\" ExternalClusterStrain \",\" Kill \",\" LinearVelocity \",\" AngularVelocity \",\" AngularTorque \",\" InternalClusterStrain \",\" DisableThreshold \",\" SleepingThreshold \",\" PositionStatic \",\" PositionAnimated \",\" PositionTarget \",\" DynamicConstraint \",\" CollisionGroup \",\" ActivateDisabled \",\" InitialLinearVelocity \",\" InitialAngularVelocity \",\" LinearImpulse \" } ; return FieldPhysicsNames ; } const TArray<EFieldPhysicsType>&)",
    "insertText": "GetFieldPhysicsTypes()"
  },
  {
    "label": "GetFieldPhysicsName()",
    "kind": "Method",
    "detail": "Function (const TArray<EFieldPhysicsType> FieldPhysicsTypes = { EFieldPhysicsType::Field_None,EFieldPhysicsType::Field_DynamicState,EFieldPhysicsType::Field_LinearForce,EFieldPhysicsType::Field_ExternalClusterStrain,EFieldPhysicsType::Field_Kill,EFieldPhysicsType::Field_LinearVelocity,EFieldPhysicsType::Field_AngularVelociy,EFieldPhysicsType::Field_AngularTorque,EFieldPhysicsType::Field_InternalClusterStrain,EFieldPhysicsType::Field_DisableThreshold,EFieldPhysicsType::Field_SleepingThreshold,EFieldPhysicsType::Field_PositionStatic,EFieldPhysicsType::Field_PositionAnimated,EFieldPhysicsType::Field_PositionTarget,EFieldPhysicsType::Field_DynamicConstraint,EFieldPhysicsType::Field_CollisionGroup,EFieldPhysicsType::Field_ActivateDisabled,EFieldPhysicsType::Field_InitialLinearVelocity,EFieldPhysicsType::Field_InitialAngularVelocity,EFieldPhysicsType::Field_LinearImpulse } ; return FieldPhysicsTypes ; } const FName&)",
    "insertText": "GetFieldPhysicsName(EFieldPhysicsType PhysicsType)"
  },
  {
    "label": "GetFieldPhysicsNames()",
    "kind": "Method",
    "detail": "Function (const TArray<FName>& FieldPhysicsNames =)",
    "insertText": "GetFieldPhysicsNames()"
  },
  {
    "label": "NoneField()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "NoneField(\"\")"
  },
  {
    "label": "GetFieldPhysicsType()",
    "kind": "Method",
    "detail": "Function (} EFieldPhysicsType)",
    "insertText": "GetFieldPhysicsType(const FName& PhysicsName)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (const int32 PhysicsIndex = FieldPhysicsNames .)",
    "insertText": "Find(PhysicsName)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Field_RadialIntMask)",
    "insertText": "UMETA(DisplayName = \"RadialIntMask\"), Field_RadialFalloff UMETA(DisplayName = \"RadialFalloff\"), Field_UniformVector UMETA(DisplayName = \"UniformVector\"), Field_RadialVector UMETA(DisplayName = \"RadialVector\"), Field_RadialVectorFalloff UMETA(DisplayName = \"RadialVectorFalloff\"), Field_EFieldPhysicsDefaultFields_Max UMETA(Hidden)"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "USTRUCT()"
  },
  {
    "label": "GENERATED_USTRUCT_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_USTRUCT_BODY() public: static FName StaticType()"
  },
  {
    "label": "FFieldCollection()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FFieldCollection()"
  },
  {
    "label": "AddGroup()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddGroup(\"VectorField\")"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (AddAttribute<)",
    "insertText": "FVector3f(\"Start\", \"VectorField\")"
  },
  {
    "label": "FVector3f()",
    "kind": "Method",
    "detail": "Function (AddAttribute<)",
    "insertText": "FVector3f(\"End\", \"VectorField\")"
  },
  {
    "label": "FLinearColor()",
    "kind": "Method",
    "detail": "Function (AddAttribute<)",
    "insertText": "FLinearColor(\"Color\", \"VectorField\")"
  },
  {
    "label": "AddVectorToField()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "AddVectorToField(FVector3f Start, FVector3f End)"
  },
  {
    "label": "AddElements()",
    "kind": "Method",
    "detail": "Function (int32 Size =)",
    "insertText": "AddElements(1, \"VectorField\")"
  },
  {
    "label": "FLinearColor()",
    "kind": "Method",
    "detail": "Function (ModifyAttribute<)",
    "insertText": "FLinearColor(\"Color\", \"VectorField\")[Size] = FLinearColor(0.6f, 0.6f, 0.6f)"
  },
  {
    "label": "GetVectorField()",
    "kind": "Method",
    "detail": "Function (} } TArray<TPair<FVector3f,FVector3f>>)",
    "insertText": "GetVectorField()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<TPair<FVector3f,FVector3f>> VectorField ;)",
    "insertText": "if(FindAttribute<FVector3f>(\"Start\", \"VectorField\") != nullptr && FindAttribute<FVector3f>(\"End\", \"VectorField\") != nullptr)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VectorField .)",
    "insertText": "Add(TPair<FVector3f, FVector3f>(VectorFieldStart[i], VectorFieldEnd[i]))"
  },
  {
    "label": "GetVectorColor()",
    "kind": "Method",
    "detail": "Function (} } return VectorField ; } TArray<FLinearColor>)",
    "insertText": "GetVectorColor()"
  },
  {
    "label": "FLinearColor()",
    "kind": "Method",
    "detail": "Function (} else { return TArray<)",
    "insertText": "FLinearColor()"
  }
]