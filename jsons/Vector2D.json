[
  {
    "label": "TVector2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TVector2"
  },
  {
    "label": "UPackageMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPackageMap"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "TIsUECoreVariant",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsUECoreVariant"
  },
  {
    "label": "TCanBulkSerialize",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TCanBulkSerialize"
  },
  {
    "label": "warning()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / Crc . h \" # include \" Math / UnrealMathUtility . h \" # include \" Containers / UnrealString . h \" # include \" Misc / Parse . h \" # include \" Misc / LargeWorldCoordinatesSerializer . h \" # if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_4 # include \" Misc / NetworkVersion . h \" # endif # include \" Misc / EngineNetworkCustomVersion . h \" # include \" Math / IntPoint . h \" # include \" Logging / LogMacros . h \" # include<type_traits> # ifdef _MSC_VER # pragma)",
    "insertText": "warning(push) #pragma warning (disable : 4459)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (namespace Math { template<T> struct TVector2 {)",
    "insertText": "static_assert(std::is_floating_point_v<T>, \"T must be floating point\")"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (} ; const TVector2<T> ZeroVector ; const TVector2<T> UnitVector ; const TVector2<T> Unit45Deg ; TVector2<T>)",
    "insertText": "Zero()"
  },
  {
    "label": "UnitY()",
    "kind": "Method",
    "detail": "Function (} TVector2<T>)",
    "insertText": "UnitY()"
  },
  {
    "label": "TVector2()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "TVector2()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TVector2<)",
    "insertText": "T(T InF)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (template<IntType> TVector2<)",
    "insertText": "T(TIntPoint<IntType> InPos)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TVector2<)",
    "insertText": "T(EForceInit)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TVector2<)",
    "insertText": "T(ENoInit)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} TVector2<)",
    "insertText": "T(const TVector<T>& V)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (TVector2<)",
    "insertText": "T(const TVector4<T>& V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (public : TVector2<T>)",
    "insertText": "operator(const TVector2<T>& V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TVector2<T>)",
    "insertText": "operator(T Scale)"
  },
  {
    "label": "ComponentwiseAllLessThan()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ComponentwiseAllLessThan(const TVector2<T>& Other)"
  },
  {
    "label": "ComponentwiseAllGreaterThan()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ComponentwiseAllGreaterThan(const TVector2<T>& Other)"
  },
  {
    "label": "ComponentwiseAllLessOrEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ComponentwiseAllLessOrEqual(const TVector2<T>& Other)"
  },
  {
    "label": "ComponentwiseAllGreaterOrEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ComponentwiseAllGreaterOrEqual(const TVector2<T>& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TVector2<T>)",
    "insertText": "operator(T V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "Component()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "Component(int32 Index)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (public : T)",
    "insertText": "DotProduct(const TVector2<T>& A, const TVector2<T>& B)"
  },
  {
    "label": "Equals()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Equals(const TVector2<T>& V, T Tolerance=UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(T InX, T InY)"
  },
  {
    "label": "GetMax()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "GetMax()"
  },
  {
    "label": "GetAbsMax()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "GetAbsMax()"
  },
  {
    "label": "GetMin()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "GetMin()"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "Size()"
  },
  {
    "label": "SizeSquared()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "SizeSquared()"
  },
  {
    "label": "Dot()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "Dot(const TVector2<T>& V2)"
  },
  {
    "label": "GetRotated()",
    "kind": "Method",
    "detail": "Function (TVector2<T>)",
    "insertText": "GetRotated(T AngleDeg)"
  },
  {
    "label": "GetSafeNormal()",
    "kind": "Method",
    "detail": "Function (TVector2<T>)",
    "insertText": "GetSafeNormal(T Tolerance=UE_SMALL_NUMBER)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Normalize(T Tolerance=UE_SMALL_NUMBER)"
  },
  {
    "label": "IsNearlyZero()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsNearlyZero(T Tolerance=UE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "ToDirectionAndLength()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ToDirectionAndLength(TVector2<T> &OutDir, double &OutLength)"
  },
  {
    "label": "ToDirectionAndLength()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ToDirectionAndLength(TVector2<T> &OutDir, float &OutLength)"
  },
  {
    "label": "IsZero()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsZero()"
  },
  {
    "label": "IntPoint()",
    "kind": "Method",
    "detail": "Function (FIntPoint)",
    "insertText": "IntPoint()"
  },
  {
    "label": "RoundToVector()",
    "kind": "Method",
    "detail": "Function (TVector2<T>)",
    "insertText": "RoundToVector()"
  },
  {
    "label": "ClampAxes()",
    "kind": "Method",
    "detail": "Function (TVector2<T>)",
    "insertText": "ClampAxes(T MinAxisVal, T MaxAxisVal)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ToString()"
  },
  {
    "label": "InitFromString()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "InitFromString(const FString& InSourceString)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar<<* this ; return true ; } bool)",
    "insertText": "Serialize(FStructuredArchive::FSlot Slot)"
  },
  {
    "label": "SerializeFromMismatchedTag()",
    "kind": "Method",
    "detail": "Function (Slot<<* this ; return true ; } bool)",
    "insertText": "SerializeFromMismatchedTag(FName StructTag, FArchive& Ar)"
  },
  {
    "label": "DiagnosticCheckNaN()",
    "kind": "Method",
    "detail": "Function (# if ENABLE_NAN_DIAGNOSTIC void)",
    "insertText": "DiagnosticCheckNaN()"
  },
  {
    "label": "logOrEnsureNanError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "logOrEnsureNanError(TEXT(\"FVector2 contains NaN: %s\"), *ToString())"
  },
  {
    "label": "ContainsNaN()",
    "kind": "Method",
    "detail": "Function (} # endif bool)",
    "insertText": "ContainsNaN()"
  },
  {
    "label": "NetSerialize()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FEngineNetworkCustomVersion::Guid)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (Ar<<X<<Y ; } else {)",
    "insertText": "checkf(Ar.IsLoading(), TEXT(\"float -> double conversion applied outside of load!\"))"
  },
  {
    "label": "SphericalToUnitCartesian()",
    "kind": "Method",
    "detail": "Function (float SX,SY ; Ar<<SX<<SY ; X = SX ; Y = SY ; } return true ; } TVector<T>)",
    "insertText": "SphericalToUnitCartesian()"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<FArg)",
    "insertText": "UE_REQUIRES(!std::is_same_v<T, FArg>)> explicit TVector2(const TVector2<FArg>& From) : TVector2<T>((T)From.X, (T)From.Y)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> uint32)",
    "insertText": "GetTypeHash(const TVector2<T>& Vector)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FArchive&)",
    "insertText": "operator(FArchive& Ar, TVector2<float>& V)"
  },
  {
    "label": "EnterStream()",
    "kind": "Method",
    "detail": "Function (FStructuredArchive::FStream Stream = Slot .)",
    "insertText": "EnterStream()"
  },
  {
    "label": "EnterElement()",
    "kind": "Method",
    "detail": "Function (Stream .)",
    "insertText": "EnterElement()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FArchive&)",
    "insertText": "operator(FArchive& Ar, TVector2<double>& V)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (float X,Y ; Ar<<X<<Y ; V = TVector2<)",
    "insertText": "double(X, Y)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return Ar ; } void)",
    "insertText": "operator(FStructuredArchive::FSlot Slot, TVector2<double>& V)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "checkf(Slot.GetUnderlyingArchive().IsLoading(), TEXT(\"float -> double conversion applied outside of load!\"))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } # if !)",
    "insertText": "defined(_MSC_VER) || defined(__clang__)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (template<> const FVector2f FVector2f::UnitVector ; template<> const FVector2f FVector2f::Unit45Deg ; template<> const FVector2d FVector2d::ZeroVector ; template<> const FVector2d FVector2d::UnitVector ; template<> const FVector2d FVector2d::Unit45Deg ; # endif template<T,T2)",
    "insertText": "UE_REQUIRES(std::is_arithmetic_v<T2>)> FORCEINLINE TVector2<T> operator*(T2 Scale, const TVector2<T>& V)"
  },
  {
    "label": "TVector2()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector2<T)",
    "insertText": "TVector2(T InX,T InY) : X(InX), Y(InY)"
  },
  {
    "label": "TVector2()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector2<T)",
    "insertText": "TVector2(T InF) : X(InF), Y(InF)"
  },
  {
    "label": "TVector2()",
    "kind": "Method",
    "detail": "Function (} template<T> template<IntType> TVector2<T)",
    "insertText": "TVector2(TIntPoint<IntType> InPos)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "X(T)"
  },
  {
    "label": "Y()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Y(T)"
  },
  {
    "label": "TVector2()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector2<T)",
    "insertText": "TVector2(EForceInit) : X(0), Y(0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T RScale = 1 . f / Scale ; return TVector2<)",
    "insertText": "T(X * RScale, Y * RScale)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector2<T> TVector2<T)",
    "insertText": "operator(T A)"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (} template<T> T TVector2<T)",
    "insertText": "Distance(const TVector2<T>& V1, const TVector2<T>& V2)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (} template<T> T TVector2<T)",
    "insertText": "CrossProduct(const TVector2<T>& A, const TVector2<T>& B)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector2<T> TVector2<T)",
    "insertText": "Min(const TVector2<T>& A, const TVector2<T>& B)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector2<T> TVector2<T)",
    "insertText": "Clamp(const TVector2<T>& V, const TVector2<T>& MinValue, const TVector2<T>& MaxValue)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector2<T> TVector2<T)",
    "insertText": "operator()"
  },
  {
    "label": "SinCos()",
    "kind": "Method",
    "detail": "Function (T S,C ;)",
    "insertText": "SinCos(&S, &C, FMath::DegreesToRadians(AngleDeg))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T OMC = 1 . 0 f - C ; return TVector2<)",
    "insertText": "T(C * X - S * Y, S * X + C * Y)"
  },
  {
    "label": "GetSafeNormal()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector2<T> TVector2<T)",
    "insertText": "GetSafeNormal(T Tolerance)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const T SquareSum = X* X + Y* Y ;)",
    "insertText": "if(SquareSum > Tolerance)"
  },
  {
    "label": "InvSqrt()",
    "kind": "Method",
    "detail": "Function (const T Scale =)",
    "insertText": "InvSqrt(SquareSum)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} return TVector2<)",
    "insertText": "T(0.f, 0.f)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (} template<T> bool TVector2<T)",
    "insertText": "Normalize(T Tolerance)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T OneOverLength = 1 . 0 f / OutLength ; OutDir = TVector2<)",
    "insertText": "T(X*OneOverLength, Y*OneOverLength)"
  },
  {
    "label": "IsNearlyZero()",
    "kind": "Method",
    "detail": "Function (} else { OutDir = TVector2<T>::ZeroVector ; } } template<T> bool TVector2<T)",
    "insertText": "IsNearlyZero(T Tolerance)"
  },
  {
    "label": "FIntPoint()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "FIntPoint(FInt64Point(FMath::RoundToInt64(X), FMath::RoundToInt64(Y)))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else { return TVector2<)",
    "insertText": "T(FMath::RoundToDouble(X), FMath::RoundToDouble(Y))"
  },
  {
    "label": "GetSignVector()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector2<T> TVector2<T)",
    "insertText": "GetSignVector()"
  },
  {
    "label": "GetAbs()",
    "kind": "Method",
    "detail": "Function (} template<T> TVector2<T> TVector2<T)",
    "insertText": "GetAbs()"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (X = Y = 0 ; const bool bSuccessful =)",
    "insertText": "Value(*InSourceString, TEXT(\"X=\") , X) && FParse::Value(*InSourceString, TEXT(\"Y=\"), Y)"
  }
]