[
  {
    "label": "ZeroBehavior",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ZeroBehavior"
  },
  {
    "label": "TrailingZerosCounter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TrailingZerosCounter"
  },
  {
    "label": "LeadingZerosCounter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LeadingZerosCounter"
  },
  {
    "label": "PopulationCounter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PopulationCounter"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_SUPPORT_MATHEXTRAS_H # define LLVM_SUPPORT_MATHEXTRAS_H # include \" dxc / WinAdapter . h \" # include \" llvm / Support / Compiler . h \" # include \" llvm / Support / SwapByteOrder . h \" # include<cassert> # include<cstring> # include<type_traits> # ifdef _MSC_VER # include<intrin . h> # endif # ifdef __ANDROID_NDK__ # include<android / api - level . h> # endif namespace llvm { enum ZeroBehavior { ZB_Undefined,ZB_Max,ZB_Width } ; namespace detail { template<T,std::size_t SizeOfT> struct TrailingZerosCounter { std::size_t)",
    "insertText": "count(T Val, ZeroBehavior)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (std::size_t ZeroBits = 0 ; T Shift = std::numeric_limits<T>::digits>> 1 ; T Mask = std::numeric_limits<T)",
    "insertText": "max()"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (Val>> = Shift ; ZeroBits | = Shift ; } Shift>> = 1 ; Mask>> = Shift ; } return ZeroBits ; } } ; # if __GNUC__> = 4 | | _MSC_VER template<T> struct TrailingZerosCounter<T,4> { std::size_t)",
    "insertText": "count(T Val, ZeroBehavior ZB)"
  },
  {
    "label": "__has_builtin()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "__has_builtin(__builtin_ctz) || LLVM_GNUC_PREREQ(4, 0, 0) return __builtin_ctz(Val)"
  },
  {
    "label": "_BitScanForward()",
    "kind": "Method",
    "detail": "Function (# elif _MSC_VER unsigned long Index ;)",
    "insertText": "_BitScanForward(&Index, Val)"
  },
  {
    "label": "__has_builtin()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "__has_builtin(__builtin_ctzll) || LLVM_GNUC_PREREQ(4, 0, 0) return __builtin_ctzll(Val)"
  },
  {
    "label": "_BitScanForward64()",
    "kind": "Method",
    "detail": "Function (# elif _MSC_VER unsigned long Index ;)",
    "insertText": "_BitScanForward64(&Index, Val)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::size_t ZeroBits = 0 ;)",
    "insertText": "for(T Shift = std::numeric_limits<T>::digits >> 1; Shift; Shift >>= 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T Tmp = Val>> Shift ;)",
    "insertText": "if(Tmp)"
  },
  {
    "label": "__has_builtin()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "__has_builtin(__builtin_clz) || LLVM_GNUC_PREREQ(4, 0, 0) return __builtin_clz(Val)"
  },
  {
    "label": "_BitScanReverse()",
    "kind": "Method",
    "detail": "Function (# elif _MSC_VER unsigned long Index ;)",
    "insertText": "_BitScanReverse(&Index, Val)"
  },
  {
    "label": "__has_builtin()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "__has_builtin(__builtin_clzll) || LLVM_GNUC_PREREQ(4, 0, 0) return __builtin_clzll(Val)"
  },
  {
    "label": "_BitScanReverse64()",
    "kind": "Method",
    "detail": "Function (# elif _MSC_VER unsigned long Index ;)",
    "insertText": "_BitScanReverse64(&Index, Val)"
  },
  {
    "label": "findFirstSet()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "findFirstSet(T Val, ZeroBehavior ZB = ZB_Max)"
  },
  {
    "label": "findLastSet()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "findLastSet(T Val, ZeroBehavior ZB = ZB_Max)"
  },
  {
    "label": "R2()",
    "kind": "Method",
    "detail": "Function (} const unsigned char BitReverseTable256 [ 2 5 6 ] = { # define)",
    "insertText": "R2(n) n, n + 2 * 64, n + 1 * 64, n + 3 * 64 #define R4(n) R2(n), R2(n + 2 * 16), R2(n + 1 * 16), R2(n + 3 * 16) #define R6(n) R4(n), R4(n + 2 * 4), R4(n + 1 * 4), R4(n + 3 * 4) R6(0), R6(2), R6(1), R6(3)"
  },
  {
    "label": "reverseBits()",
    "kind": "Method",
    "detail": "Function (template<T> T)",
    "insertText": "reverseBits(T Val)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (unsigned char in [)",
    "insertText": "sizeof(Val)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(in, &Val, sizeof(Val))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(&Val, out, sizeof(Val))"
  },
  {
    "label": "Lo_32()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "Lo_32(uint64_t Value)"
  },
  {
    "label": "Make_64()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "Make_64(uint32_t High, uint32_t Low)"
  },
  {
    "label": "isInt()",
    "kind": "Method",
    "detail": "Function (} template<unsigned N> bool)",
    "insertText": "isInt(int64_t x)"
  },
  {
    "label": "isShiftedInt()",
    "kind": "Method",
    "detail": "Function (} template<unsigned N,unsigned S> bool)",
    "insertText": "isShiftedInt(int64_t x)"
  },
  {
    "label": "isUInt()",
    "kind": "Method",
    "detail": "Function (} template<unsigned N> bool)",
    "insertText": "isUInt(uint64_t x)"
  },
  {
    "label": "isShiftedUInt()",
    "kind": "Method",
    "detail": "Function (} template<unsigned N,unsigned S> bool)",
    "insertText": "isShiftedUInt(uint64_t x)"
  },
  {
    "label": "isUIntN()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isUIntN(unsigned N, uint64_t x)"
  },
  {
    "label": "isIntN()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isIntN(unsigned N, int64_t x)"
  },
  {
    "label": "isMask_32()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isMask_32(uint32_t Value)"
  },
  {
    "label": "isMask_64()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isMask_64(uint64_t Value)"
  },
  {
    "label": "isShiftedMask_32()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isShiftedMask_32(uint32_t Value)"
  },
  {
    "label": "isShiftedMask_64()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isShiftedMask_64(uint64_t Value)"
  },
  {
    "label": "isPowerOf2_32()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isPowerOf2_32(uint32_t Value)"
  },
  {
    "label": "isPowerOf2_64()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isPowerOf2_64(uint64_t Value)"
  },
  {
    "label": "ByteSwap_16()",
    "kind": "Method",
    "detail": "Function (} uint16_t)",
    "insertText": "ByteSwap_16(uint16_t Value)"
  },
  {
    "label": "ByteSwap_32()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "ByteSwap_32(uint32_t Value)"
  },
  {
    "label": "ByteSwap_64()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "ByteSwap_64(uint64_t Value)"
  },
  {
    "label": "countLeadingOnes()",
    "kind": "Method",
    "detail": "Function (} template<T> std::size_t)",
    "insertText": "countLeadingOnes(T Value, ZeroBehavior ZB = ZB_Width)"
  },
  {
    "label": "countTrailingOnes()",
    "kind": "Method",
    "detail": "Function (} template<T> std::size_t)",
    "insertText": "countTrailingOnes(T Value, ZeroBehavior ZB = ZB_Width)"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (} namespace detail { template<T,std::size_t SizeOfT> struct PopulationCounter { unsigned)",
    "insertText": "count(T Value)"
  },
  {
    "label": "__builtin_popcount()",
    "kind": "Method",
    "detail": "Function (# if __GNUC__> = 4 return)",
    "insertText": "__builtin_popcount(Value)"
  },
  {
    "label": "v()",
    "kind": "Method",
    "detail": "Function (# else uint32_t v = Value ; v =)",
    "insertText": "v((v >> 1) & 0x55555555)"
  },
  {
    "label": "v()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "v(v & 0x33333333) + ((v >> 2) & 0x33333333)"
  },
  {
    "label": "__builtin_popcountll()",
    "kind": "Method",
    "detail": "Function (# if __GNUC__> = 4 return)",
    "insertText": "__builtin_popcountll(Value)"
  },
  {
    "label": "v()",
    "kind": "Method",
    "detail": "Function (# else uint64_t v = Value ; v =)",
    "insertText": "v((v >> 1) & 0x5555555555555555ULL)"
  },
  {
    "label": "v()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "v(v & 0x3333333333333333ULL) + ((v >> 2) & 0x3333333333333333ULL)"
  },
  {
    "label": "v()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "v(v + (v >> 4))"
  },
  {
    "label": "countPopulation()",
    "kind": "Method",
    "detail": "Function (# endif } } ; } template<T> unsigned)",
    "insertText": "countPopulation(T Value)"
  },
  {
    "label": "Log2()",
    "kind": "Method",
    "detail": "Function (} double __cdecl)",
    "insertText": "Log2(double Value)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(__ANDROID_API__) && __ANDROID_API__ < 18 return __builtin_log(Value) / __builtin_log(2.0)"
  },
  {
    "label": "log2()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "log2(Value)"
  },
  {
    "label": "Log2_32()",
    "kind": "Method",
    "detail": "Function (# endif } unsigned)",
    "insertText": "Log2_32(uint32_t Value)"
  },
  {
    "label": "Log2_64()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "Log2_64(uint64_t Value)"
  },
  {
    "label": "Log2_32_Ceil()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "Log2_32_Ceil(uint32_t Value)"
  },
  {
    "label": "Log2_64_Ceil()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "Log2_64_Ceil(uint64_t Value)"
  },
  {
    "label": "GreatestCommonDivisor64()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "GreatestCommonDivisor64(uint64_t A, uint64_t B)"
  },
  {
    "label": "BitsToDouble()",
    "kind": "Method",
    "detail": "Function (uint64_t T = B ; B = A % B ; A = T ; } return A ; } double)",
    "insertText": "BitsToDouble(uint64_t Bits)"
  },
  {
    "label": "BitsToFloat()",
    "kind": "Method",
    "detail": "Function (union { uint64_t L ; double D ; } T ; T . L = Bits ; return T . D ; } float)",
    "insertText": "BitsToFloat(uint32_t Bits)"
  },
  {
    "label": "DoubleToBits()",
    "kind": "Method",
    "detail": "Function (union { uint32_t I ; float F ; } T ; T . I = Bits ; return T . F ; } uint64_t)",
    "insertText": "DoubleToBits(double Double)"
  },
  {
    "label": "FloatToBits()",
    "kind": "Method",
    "detail": "Function (union { uint64_t L ; double D ; } T ; T . D = Double ; return T . L ; } uint32_t)",
    "insertText": "FloatToBits(float Float)"
  },
  {
    "label": "MinAlign()",
    "kind": "Method",
    "detail": "Function (union { uint32_t I ; float F ; } T ; T . F = Float ; return T . I ; } uint64_t)",
    "insertText": "MinAlign(uint64_t A, uint64_t B)"
  },
  {
    "label": "alignAddr()",
    "kind": "Method",
    "detail": "Function (} uintptr_t)",
    "insertText": "alignAddr(const void *Addr, size_t Alignment)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Alignment && isPowerOf2_64((uint64_t)Alignment) && \"Alignment is not a power of two!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((uintptr_t)Addr + Alignment - 1 >= (uintptr_t)Addr)"
  },
  {
    "label": "alignmentAdjustment()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "alignmentAdjustment(const void *Ptr, size_t Alignment)"
  },
  {
    "label": "NextPowerOf2()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "NextPowerOf2(uint64_t A)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "A(A >> 1)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "A(A >> 2)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "A(A >> 4)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "A(A >> 8)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "A(A >> 16)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "A(A >> 32)"
  },
  {
    "label": "RoundUpToAlignment()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "RoundUpToAlignment(uint64_t Value, uint64_t Align)"
  },
  {
    "label": "OffsetToAlignment()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "OffsetToAlignment(uint64_t Value, uint64_t Align)"
  },
  {
    "label": "SignExtend32()",
    "kind": "Method",
    "detail": "Function (} template<unsigned B> int32_t)",
    "insertText": "SignExtend32(uint32_t x)"
  },
  {
    "label": "SignExtend32()",
    "kind": "Method",
    "detail": "Function (} int32_t)",
    "insertText": "SignExtend32(uint32_t X, unsigned B)"
  },
  {
    "label": "SignExtend64()",
    "kind": "Method",
    "detail": "Function (} template<unsigned B> int64_t)",
    "insertText": "SignExtend64(uint64_t x)"
  },
  {
    "label": "SignExtend64()",
    "kind": "Method",
    "detail": "Function (} int64_t)",
    "insertText": "SignExtend64(uint64_t X, unsigned B)"
  }
]