[
  {
    "label": "LCNew()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" appconst . h \" typedef struct { int prev,next ; } lcnode ; typedef struct { int N ; lcnode* List ; } listCollectionRec ; typedef listCollectionRec* listCollectionP ; listCollectionP)",
    "insertText": "LCNew(int N)"
  },
  {
    "label": "LCFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LCFree(listCollectionP *pListColl)"
  },
  {
    "label": "LCInsertAfter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LCInsertAfter(listCollectionP listColl, int theAnchor, int theNewNode)"
  },
  {
    "label": "LCInsertBefore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LCInsertBefore(listCollectionP listColl, int theAnchor, int theNewNode)"
  },
  {
    "label": "LCReset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LCReset(listCollectionP listColl)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (List[K].prev = listColl->List[K].next = NIL)",
    "insertText": "for(K=0; K < listColl->N; K++)"
  },
  {
    "label": "LCCopy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "LCCopy(listCollectionP dst, listCollectionP src)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int K ;)",
    "insertText": "if(dst==NULL || src==NULL || dst->N != src->N)"
  },
  {
    "label": "LCGetNext()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "LCGetNext(listCollectionP listColl, int theList, int theNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int next ;)",
    "insertText": "if(listColl==NULL || theList==NIL || theNode==NIL)"
  },
  {
    "label": "LCGetPrev()",
    "kind": "Method",
    "detail": "Function (next = listColl -> List [ theNode ] . next ; return next = = theList ? NIL : next ; } int)",
    "insertText": "LCGetPrev(listCollectionP listColl, int theList, int theNode)"
  },
  {
    "label": "LCPrepend()",
    "kind": "Method",
    "detail": "Function (listColl -> List [ theNode ] . prev = listColl -> List [ theNode ] . next = theNode ; theList = theNode ; } else { int pred = listColl -> List [ theList ] . prev ; listColl -> List [ theList ] . prev = theNode ; listColl -> List [ theNode ] . next = theList ; listColl -> List [ theNode ] . prev = pred ; listColl -> List [ pred ] . next = theNode ; } return theList ; } int)",
    "insertText": "LCPrepend(listCollectionP listColl, int theList, int theNode)"
  },
  {
    "label": "LCDelete()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "LCDelete(listCollectionP listColl, int theList, int theNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (listColl -> List [ theList ] . prev = listColl -> List [ theList ] . next = NIL ; theList = NIL ; } else { int pred = listColl -> List [ theNode ] . prev,succ = listColl -> List [ theNode ] . next ; listColl -> List [ pred ] . next = succ ; listColl -> List [ succ ] . prev = pred ; listColl -> List [ theNode ] . prev = listColl -> List [ theNode ] . next = NIL ;)",
    "insertText": "if(theList == theNode)"
  }
]