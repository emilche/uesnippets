[
  {
    "label": "UObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UObject"
  },
  {
    "label": "FInternalReferenceCollectorReferencerNameProvider",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FInternalReferenceCollectorReferencerNameProvider"
  },
  {
    "label": "TStrongObjectPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TStrongObjectPtr"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TWeakObjectPtrBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TWeakObjectPtrBase"
  },
  {
    "label": "TWeakObjectPtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TWeakObjectPtr"
  },
  {
    "label": "ReleaseUObject()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Templates / EnableIf . h \" # include \" Templates / PointerIsConvertibleFromTo . h \" # include \" Templates / UniquePtr . h \" # include \" UObject / StrongObjectPtrTemplatesFwd . h \" class UObject ; namespace UEStrongObjectPtr_Private { struct FInternalReferenceCollectorReferencerNameProvider { } ; void)",
    "insertText": "ReleaseUObject(const UObject*)"
  },
  {
    "label": "TStrongObjectPtr()",
    "kind": "Method",
    "detail": "Function (} template<ObjectType,ReferencerNameProvider> class TStrongObjectPtr { public : using ElementType = ObjectType ;)",
    "insertText": "TStrongObjectPtr(TStrongObjectPtr&& InOther)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Object = InOther . Object ; InOther . Object = nullptr ; } TStrongObjectPtr&)",
    "insertText": "operator(TStrongObjectPtr&& InOther)"
  },
  {
    "label": "TStrongObjectPtr()",
    "kind": "Method",
    "detail": "Function (Object = InOther . Object ; InOther . Object = nullptr ; } return* this ; } ~)",
    "insertText": "TStrongObjectPtr()"
  },
  {
    "label": "TStrongObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TStrongObjectPtr(TYPE_OF_NULLPTR = nullptr)"
  },
  {
    "label": "TStrongObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TStrongObjectPtr(ObjectType* InObject)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset(InObject)"
  },
  {
    "label": "TStrongObjectPtr()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TStrongObjectPtr(const TStrongObjectPtr& InOther)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset(InOther.Get())"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<OtherObjectType,OtherReferencerNameProvider)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<OtherObjectType*, ObjectType*>) > FORCEINLINE_DEBUGGABLE TStrongObjectPtr(const TStrongObjectPtr<OtherObjectType, OtherReferencerNameProvider>& InOther)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TStrongObjectPtr&)",
    "insertText": "operator(const TStrongObjectPtr& InOther)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ObjectType*)",
    "insertText": "operator()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} ObjectType*)",
    "insertText": "Get()"
  },
  {
    "label": "ReleaseUObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseUObject(Object)"
  },
  {
    "label": "Attach()",
    "kind": "Method",
    "detail": "Function (Object = nullptr ; } } private : template<class T,class TWeakObjectPtrBase> struct TWeakObjectPtr ; void)",
    "insertText": "Attach(ObjectType* InNewObject)"
  },
  {
    "label": "Detach()",
    "kind": "Method",
    "detail": "Function (Object = InNewObject ; } ObjectType*)",
    "insertText": "Detach()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (Object = nullptr ; return DetachedObject ; } public : void)",
    "insertText": "Reset(ObjectType* InNewObject)"
  },
  {
    "label": "AddRef()",
    "kind": "Method",
    "detail": "Function (} InNewObject ->)",
    "insertText": "AddRef()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} } [ [ nodiscard ] ] uint32)",
    "insertText": "GetTypeHash(const TStrongObjectPtr& InStrongObjectPtr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : const UObject* Object { nullptr } ; [ [ nodiscard ] ] bool)",
    "insertText": "operator(const TStrongObjectPtr& InLHS, const TStrongObjectPtr& InRHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "operator(const TStrongObjectPtr& InLHS, TYPE_OF_NULLPTR)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] bool)",
    "insertText": "operator(TYPE_OF_NULLPTR, const TStrongObjectPtr& InRHS)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<RHSObjectType,RHSReferencerNameProvider)",
    "insertText": "UE_REQUIRES(UE_REQUIRES_EXPR(std::declval<ObjectType*>() == std::declval<RHSObjectType*>())) > [[nodiscard]] friend FORCEINLINE bool operator==(const TStrongObjectPtr& InLHS, const TStrongObjectPtr<RHSObjectType, RHSReferencerNameProvider>& InRHS)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<LHSObjectType,LHSReferencerNameProvider)",
    "insertText": "UE_REQUIRES(UE_REQUIRES_EXPR(std::declval<LHSObjectType*>() == std::declval<ObjectType*>())) > [[nodiscard]] friend FORCEINLINE bool operator==(const TStrongObjectPtr<LHSObjectType, LHSReferencerNameProvider>& InLHS, const TStrongObjectPtr& InRHS)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<RHSObjectType,RHSReferencerNameProvider)",
    "insertText": "UE_REQUIRES(UE_REQUIRES_EXPR(std::declval<ObjectType*>() == std::declval<RHSObjectType*>())) > [[nodiscard]] friend FORCEINLINE bool operator!=(const TStrongObjectPtr& InLHS, const TStrongObjectPtr<RHSObjectType, RHSReferencerNameProvider>& InRHS)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<LHSObjectType,LHSReferencerNameProvider)",
    "insertText": "UE_REQUIRES(UE_REQUIRES_EXPR(std::declval<LHSObjectType*>() == std::declval<ObjectType*>())) > [[nodiscard]] friend FORCEINLINE bool operator!=(const TStrongObjectPtr<LHSObjectType, LHSReferencerNameProvider>& InLHS, const TStrongObjectPtr& InRHS)"
  }
]