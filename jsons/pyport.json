[
  {
    "label": "_Py_STATIC_CAST()",
    "kind": "Method",
    "detail": "Function (# ifndef Py_PYPORT_H # define Py_PYPORT_H # include \" pyconfig . h \" # include<inttypes . h> # include<limits . h> # ifndef UCHAR_MAX # error \" limits . h must define UCHAR_MAX \" # endif # if UCHAR_MAX ! = 2 5 5 # error \" Python ' s source code assumes C ' s unsigned char is an 8 - bit type \" # endif # ifdef __cplusplus # define)",
    "insertText": "_Py_STATIC_CAST(type, expr) static_cast<type>(expr) #else # define _Py_STATIC_CAST(type, expr) ((type)(expr)) #endif #define _Py_CAST(type, expr) ((type)(expr)) #if defined(__cplusplus) && __cplusplus >= 201103 # define _Py_NULL nullptr #else # define _Py_NULL NULL #endif #if defined(Py_BUILD_CORE_BUILTIN) && !defined(Py_BUILD_CORE) # define Py_BUILD_CORE #endif #if defined(Py_BUILD_CORE_MODULE) && !defined(Py_BUILD_CORE)"
  },
  {
    "label": "PY_SSIZE_T_MIN()",
    "kind": "Method",
    "detail": "Function (typedef intptr_t Py_intptr_t ; # ifdef HAVE_PY_SSIZE_T # elif HAVE_SSIZE_T typedef ssize_t Py_ssize_t ; # define PY_SSIZE_T_MAX SSIZE_MAX # elif SIZEOF_VOID_P = = SIZEOF_SIZE_T typedef Py_intptr_t Py_ssize_t ; # define PY_SSIZE_T_MAX INTPTR_MAX # else # error \" Python needs a typedef for Py_ssize_t in pyport . h . \" # endif # define)",
    "insertText": "PY_SSIZE_T_MIN(-PY_SSIZE_T_MAX-1)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# define SIZEOF_PY_UHASH_T SIZEOF_SIZE_T typedef size_t Py_uhash_t ; typedef Py_ssize_t Py_ssize_clean_t ; # define PY_SIZE_MAX SIZE_MAX # ifndef PY_FORMAT_SIZE_T # define PY_FORMAT_SIZE_T \" z \" # endif # if)",
    "insertText": "defined(_MSC_VER) # pragma warning(disable: 4710) # define Py_LOCAL(type) static type __fastcall # define Py_LOCAL_INLINE(type) static __inline type __fastcall #else # define Py_LOCAL(type) static type # define Py_LOCAL_INLINE(type) static inline type #endif #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000 # define Py_MEMCPY memcpy #endif #ifdef HAVE_IEEEFP_H #include <ieeefp.h> #endif #include <math.h> #ifdef HAVE_SYS_TIME_H #include <sys/time.h> #endif #include <time.h> #ifdef HAVE_SYS_SELECT_H #include <sys/select.h> #endif #ifdef HAVE_SYS_STAT_H #include <sys/stat.h> #elif defined(HAVE_STAT_H) #include <stat.h> #endif #ifndef S_IFMT #define S_IFMT 0170000 #endif #ifndef S_IFLNK # define S_IFLNK 0120000 #endif #ifndef S_ISREG #define S_ISREG(x) (((x) & S_IFMT) == S_IFREG) #endif #ifndef S_ISDIR #define S_ISDIR(x) (((x) & S_IFMT) == S_IFDIR) #endif #ifndef S_ISCHR #define S_ISCHR(x) (((x) & S_IFMT) == S_IFCHR)"
  },
  {
    "label": "Py_ARITHMETIC_RIGHT_SHIFT()",
    "kind": "Method",
    "detail": "Function (# endif # ifdef SIGNED_RIGHT_SHIFT_ZERO_FILLS # define)",
    "insertText": "Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) \\ ((I) < 0 ? -1-((-1-(I)) >> (J)) : (I) >> (J)) #else #define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) ((I) >> (J)) #endif #define Py_FORCE_EXPANSION(X) X #ifdef Py_DEBUG # define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) \\ (assert(_Py_STATIC_CAST(WIDE, _Py_STATIC_CAST(NARROW, (VALUE))) == (VALUE)), \\ _Py_STATIC_CAST(NARROW, (VALUE))) #else # define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) _Py_STATIC_CAST(NARROW, (VALUE)) #endif #if defined(__GNUC__) \\ && ((__GNUC__ >= 4) || (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1)) #define Py_DEPRECATED(VERSION_UNUSED) __attribute__((__deprecated__)) #elif defined(_MSC_VER) #define Py_DEPRECATED(VERSION) __declspec(deprecated( \\ \"deprecated in \" #VERSION)) #else #define Py_DEPRECATED(VERSION_UNUSED) #endif #if defined(__clang__) #define _Py_COMP_DIAG_PUSH _Pragma(\"clang diagnostic push\") #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS \\ _Pragma(\"clang diagnostic ignored \\\"-Wdeprecated-declarations\\\"\") #define _Py_COMP_DIAG_POP _Pragma(\"clang diagnostic pop\") #elif defined(__GNUC__) \\ && ((__GNUC__ >= 5) || (__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) #define _Py_COMP_DIAG_PUSH _Pragma(\"GCC diagnostic push\") #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS \\ _Pragma(\"GCC diagnostic ignored \\\"-Wdeprecated-declarations\\\"\") #define _Py_COMP_DIAG_POP _Pragma(\"GCC diagnostic pop\") #elif defined(_MSC_VER) #define _Py_COMP_DIAG_PUSH __pragma(warning(push)) #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS __pragma(warning(disable: 4996)) #define _Py_COMP_DIAG_POP __pragma(warning(pop)) #else #define _Py_COMP_DIAG_PUSH #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS #define _Py_COMP_DIAG_POP #endif #if defined(__GNUC__) \\ && ((__GNUC__ >= 5) || (__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) #define _Py_HOT_FUNCTION __attribute__((hot)) #else #define _Py_HOT_FUNCTION #endif #if defined(Py_DEBUG) # define Py_ALWAYS_INLINE #elif defined(__GNUC__) || defined(__clang__) || defined(__INTEL_COMPILER) # define Py_ALWAYS_INLINE __attribute__((always_inline)) #elif defined(_MSC_VER) # define Py_ALWAYS_INLINE __forceinline #else # define Py_ALWAYS_INLINE #endif #if defined(__GNUC__) || defined(__clang__) || defined(__INTEL_COMPILER) # define Py_NO_INLINE __attribute__ ((noinline)) #elif defined(_MSC_VER) # define Py_NO_INLINE __declspec(noinline) #else # define Py_NO_INLINE #endif #ifdef HAVE__GETPTY #include <sys/types.h> extern char * _getpty(int *, int, mode_t, int)"
  }
]