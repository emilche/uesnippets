[
  {
    "label": "MemoryBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MemoryBuffer"
  },
  {
    "label": "MCAsmInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCAsmInfo"
  },
  {
    "label": "AsmLexer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AsmLexer"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_MC_MCPARSER_ASMLEXER_H # define LLVM_MC_MCPARSER_ASMLEXER_H # include \" llvm / ADT / StringRef . h \" # include \" llvm / MC / MCParser / MCAsmLexer . h \" # include \" llvm / Support / DataTypes . h \" # include<string> namespace llvm { class MemoryBuffer ; class MCAsmInfo ; class AsmLexer : public MCAsmLexer { const MCAsmInfo& MAI ; const char* CurPtr ; StringRef CurBuf ; bool isAtStartOfLine ; void)",
    "insertText": "operator(const AsmLexer&)"
  },
  {
    "label": "AsmLexer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AsmLexer(const AsmLexer&)"
  },
  {
    "label": "LexToken()",
    "kind": "Method",
    "detail": "Function (protected : AsmToken)",
    "insertText": "LexToken()"
  },
  {
    "label": "AsmLexer()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "AsmLexer(const MCAsmInfo &MAI)"
  },
  {
    "label": "AsmLexer()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "AsmLexer()"
  },
  {
    "label": "setBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setBuffer(StringRef Buf, const char *ptr = nullptr)"
  },
  {
    "label": "LexUntilEndOfStatement()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "LexUntilEndOfStatement()"
  },
  {
    "label": "LexUntilEndOfLine()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "LexUntilEndOfLine()"
  },
  {
    "label": "peekTok()",
    "kind": "Method",
    "detail": "Function (const AsmToken)",
    "insertText": "peekTok(bool ShouldSkipSpace = true)"
  },
  {
    "label": "isAtStartOfComment()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isAtStartOfComment(const char *Ptr)"
  },
  {
    "label": "isAtStatementSeparator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isAtStatementSeparator(const char *Ptr)"
  },
  {
    "label": "getMAI()",
    "kind": "Method",
    "detail": "Function (const MCAsmInfo&)",
    "insertText": "getMAI()"
  },
  {
    "label": "ReturnError()",
    "kind": "Method",
    "detail": "Function (AsmToken)",
    "insertText": "ReturnError(const char *Loc, const std::string &Msg)"
  },
  {
    "label": "LexIdentifier()",
    "kind": "Method",
    "detail": "Function (AsmToken)",
    "insertText": "LexIdentifier()"
  },
  {
    "label": "LexSlash()",
    "kind": "Method",
    "detail": "Function (AsmToken)",
    "insertText": "LexSlash()"
  },
  {
    "label": "LexLineComment()",
    "kind": "Method",
    "detail": "Function (AsmToken)",
    "insertText": "LexLineComment()"
  },
  {
    "label": "LexDigit()",
    "kind": "Method",
    "detail": "Function (AsmToken)",
    "insertText": "LexDigit()"
  },
  {
    "label": "LexSingleQuote()",
    "kind": "Method",
    "detail": "Function (AsmToken)",
    "insertText": "LexSingleQuote()"
  },
  {
    "label": "LexQuote()",
    "kind": "Method",
    "detail": "Function (AsmToken)",
    "insertText": "LexQuote()"
  },
  {
    "label": "LexFloatLiteral()",
    "kind": "Method",
    "detail": "Function (AsmToken)",
    "insertText": "LexFloatLiteral()"
  },
  {
    "label": "LexHexFloatLiteral()",
    "kind": "Method",
    "detail": "Function (AsmToken)",
    "insertText": "LexHexFloatLiteral(bool NoIntDigits)"
  }
]