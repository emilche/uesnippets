[
  {
    "label": "ALEMBIC_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ALEMBIC_EXPORT"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "totally_ordered",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "totally_ordered"
  },
  {
    "label": "mutex",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "mutex"
  },
  {
    "label": "scoped_lock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "scoped_lock"
  },
  {
    "label": "noncopyable()",
    "kind": "Method",
    "detail": "Function (# ifndef Alembic_Util_Foundation_h # define Alembic_Util_Foundation_h # include<Alembic / Util / Config . h> # include<unordered_map> # include<memory> # include<half . h> # include<iomanip> # include<iostream> # include<sstream> # include<exception> # include<limits> # include<list> # include<map> # include<string> # include<vector> # include<cstdio> # include<cstdlib> # include<cstring> # include<cassert> # include<Alembic / Util / Export . h> # ifdef _MSC_VER # ifndef WIN32_LEAN_AND_MEAN # define WIN32_LEAN_AND_MEAN # endif # ifndef NOMINMAX # define NOMINMAX # endif # include<Windows . h> # endif # include<algorithm> # ifndef ALEMBIC_VERSION_NS # define ALEMBIC_VERSION_NS v12 # endif namespace Alembic { namespace Util { namespace ALEMBIC_VERSION_NS { class ALEMBIC_EXPORT noncopyable { protected :)",
    "insertText": "noncopyable()"
  },
  {
    "label": "noncopyable()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "noncopyable(const noncopyable&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (const noncopyable&)",
    "insertText": "operator(const noncopyable&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; using std::dynamic_pointer_cast ; using std::enable_shared_from_this ; using std::shared_ptr ; using std::static_pointer_cast ; using std::weak_ptr ; using std::unordered_map ; using std::unique_ptr ; template<class T> class totally_ordered { bool)",
    "insertText": "operator(const T& x, const T& y)"
  },
  {
    "label": "mutex()",
    "kind": "Method",
    "detail": "Function (} } ; # ifdef _MSC_VER class mutex : noncopyable { public :)",
    "insertText": "mutex()"
  },
  {
    "label": "InitializeCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeCriticalSection(&cs)"
  },
  {
    "label": "DeleteCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeleteCriticalSection(&cs)"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "lock()"
  },
  {
    "label": "EnterCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnterCriticalSection(&cs)"
  },
  {
    "label": "unlock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "unlock()"
  },
  {
    "label": "LeaveCriticalSection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeaveCriticalSection(&cs)"
  },
  {
    "label": "pthread_mutex_init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_init(&m, NULL)"
  },
  {
    "label": "pthread_mutex_destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_destroy(&m)"
  },
  {
    "label": "pthread_mutex_lock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_lock(&m)"
  },
  {
    "label": "pthread_mutex_unlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_unlock(&m)"
  },
  {
    "label": "scoped_lock()",
    "kind": "Method",
    "detail": "Function (} private : pthread_mutex_t m ; } ; # endif class scoped_lock : noncopyable { public :)",
    "insertText": "scoped_lock(mutex & l ) : m( l)"
  },
  {
    "label": "scoped_lock()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "scoped_lock()"
  }
]