[
  {
    "label": "lws_log_levels",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_log_levels"
  },
  {
    "label": "lws",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws"
  },
  {
    "label": "lws_pollfd",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_pollfd"
  },
  {
    "label": "pollfd",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "pollfd"
  },
  {
    "label": "timer_mapping",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "timer_mapping"
  },
  {
    "label": "genled_state",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "genled_state"
  },
  {
    "label": "lws_group_member",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_group_member"
  },
  {
    "label": "ip4_addr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ip4_addr"
  },
  {
    "label": "ip6_addr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ip6_addr"
  },
  {
    "label": "lws_esp32",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_esp32"
  },
  {
    "label": "lws_esp32_image",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_esp32_image"
  },
  {
    "label": "lws_vhost",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_vhost"
  },
  {
    "label": "lws_context_creation_info",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_context_creation_info"
  },
  {
    "label": "lws_context",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_context"
  },
  {
    "label": "lws_pollargs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_pollargs"
  },
  {
    "label": "lws_tokens",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_tokens"
  },
  {
    "label": "lws_token_limits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_token_limits"
  },
  {
    "label": "lws_close_status",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_close_status"
  },
  {
    "label": "lws_extension",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_extension"
  },
  {
    "label": "lws_ssl_info",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_ssl_info"
  },
  {
    "label": "lws_cert_update_state",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_cert_update_state"
  },
  {
    "label": "lws_acme_cert_aging_args",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_acme_cert_aging_args"
  },
  {
    "label": "lws_callback_reasons",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_callback_reasons"
  },
  {
    "label": "lws_genhash_types",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_genhash_types"
  },
  {
    "label": "lws_genhmac_types",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_genhmac_types"
  },
  {
    "label": "lws_genhash_ctx",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_genhash_ctx"
  },
  {
    "label": "lws_genhmac_ctx",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_genhmac_ctx"
  },
  {
    "label": "enum_jwk_tok",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "enum_jwk_tok"
  },
  {
    "label": "lws_genrsa_ctx",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_genrsa_ctx"
  },
  {
    "label": "lws_genrsa_element",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_genrsa_element"
  },
  {
    "label": "lws_genrsa_elements",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_genrsa_elements"
  },
  {
    "label": "lws_jwk",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_jwk"
  },
  {
    "label": "lws_extension_callback_reasons",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_extension_callback_reasons"
  },
  {
    "label": "lws_ext_options_types",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_ext_options_types"
  },
  {
    "label": "lws_ext_options",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_ext_options"
  },
  {
    "label": "lws_ext_option_arg",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_ext_option_arg"
  },
  {
    "label": "lws_protocols",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_protocols"
  },
  {
    "label": "lws_protocol_vhost_options",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_protocol_vhost_options"
  },
  {
    "label": "lws_plugin_capability",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_plugin_capability"
  },
  {
    "label": "lws_plugin",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_plugin"
  },
  {
    "label": "lwsgs_auth_bits",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lwsgs_auth_bits"
  },
  {
    "label": "lws_session_info",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_session_info"
  },
  {
    "label": "lws_gs_event",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_gs_event"
  },
  {
    "label": "lws_gs_event_args",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_gs_event_args"
  },
  {
    "label": "lws_context_options",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_context_options"
  },
  {
    "label": "lws_plat_file_ops",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_plat_file_ops"
  },
  {
    "label": "lws_http_mount",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_http_mount"
  },
  {
    "label": "lws_mount_protocols",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_mount_protocols"
  },
  {
    "label": "lws_client_connect_ssl_connection_flags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_client_connect_ssl_connection_flags"
  },
  {
    "label": "lws_client_connect_info",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_client_connect_info"
  },
  {
    "label": "http_status",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "http_status"
  },
  {
    "label": "lws_process_html_args",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_process_html_args"
  },
  {
    "label": "lws_process_html_state",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_process_html_state"
  },
  {
    "label": "lws_token_indexes",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_token_indexes"
  },
  {
    "label": "lws_spa_fileupload_states",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_spa_fileupload_states"
  },
  {
    "label": "lws_spa",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_spa"
  },
  {
    "label": "pending_timeout",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "pending_timeout"
  },
  {
    "label": "lws_write_protocol",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_write_protocol"
  },
  {
    "label": "lws_write_passthru",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_write_passthru"
  },
  {
    "label": "lws_udp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_udp"
  },
  {
    "label": "sockaddr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "sockaddr"
  },
  {
    "label": "sockaddr_in",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "sockaddr_in"
  },
  {
    "label": "lws_dll",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_dll"
  },
  {
    "label": "lws_dll_lws",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_dll_lws"
  },
  {
    "label": "lws_buflist",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_buflist"
  },
  {
    "label": "lws_wifi_scan",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_wifi_scan"
  },
  {
    "label": "lws_tls_cert_info",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_tls_cert_info"
  },
  {
    "label": "lws_ring",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_ring"
  },
  {
    "label": "lws_enum_stdinouterr",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_enum_stdinouterr"
  },
  {
    "label": "lws_cgi_hdr_state",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lws_cgi_hdr_state"
  },
  {
    "label": "lws_cgi_args",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_cgi_args"
  },
  {
    "label": "lws_fop_fd",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_fop_fd"
  },
  {
    "label": "lws_fops_index",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_fops_index"
  },
  {
    "label": "lwsgs_smtp_states",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lwsgs_smtp_states"
  },
  {
    "label": "lws_email",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lws_email"
  },
  {
    "label": "lejp_ctx",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lejp_ctx"
  },
  {
    "label": "lejp_states",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lejp_states"
  },
  {
    "label": "lejp_reasons",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lejp_reasons"
  },
  {
    "label": "lejp_callbacks",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "lejp_callbacks"
  },
  {
    "label": "num_flags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "num_flags"
  },
  {
    "label": "_lejp_stack",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_lejp_stack"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef LIBWEBSOCKET_H_3060898B846849FF9F88F5DB59B5950C # define LIBWEBSOCKET_H_3060898B846849FF9F88F5DB59B5950C # ifdef __cplusplus # include<cstddef> # include<cstdarg> \" C \" { # else # include<stdarg . h> # endif # include<string . h> # include<stdlib . h> # include \" lws_config . h \" # if)",
    "insertText": "defined(LWS_HAS_INTPTR_T)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "defined(WIN32) || defined(_WIN32) #ifndef WIN32_LEAN_AND_MEAN #define WIN32_LEAN_AND_MEAN #endif #include <winsock2.h> #include <ws2tcpip.h> #include <stddef.h> #include <basetsd.h> #include <io.h> #ifndef _WIN32_WCE #include <fcntl.h> #else #define _O_RDONLY 0x0000 #define O_RDONLY _O_RDONLY #endif #define LWS_INLINE __inline #define LWS_VISIBLE #define LWS_WARN_UNUSED_RESULT #define LWS_WARN_DEPRECATED #define LWS_FORMAT(string_index) #ifdef LWS_DLL #ifdef LWS_INTERNAL #define LWS_EXTERN extern __declspec(dllexport) #else #define LWS_EXTERN extern __declspec(dllimport) #endif #else #define LWS_EXTERN #endif #define LWS_INVALID_FILE INVALID_HANDLE_VALUE #define LWS_O_RDONLY _O_RDONLY #define LWS_O_WRONLY _O_WRONLY #define LWS_O_CREAT _O_CREAT #define LWS_O_TRUNC _O_TRUNC #ifndef __func__ #define __func__ __FUNCTION__ #endif #else #include <unistd.h> #if defined(LWS_HAVE_SYS_CAPABILITY_H) && defined(LWS_HAVE_LIBCAP) #include <sys/capability.h> #endif #if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__QNX__) || defined(__OpenBSD__) #include <sys/socket.h> #include <netinet/in.h> #endif #define LWS_INLINE inline #define LWS_O_RDONLY O_RDONLY #define LWS_O_WRONLY O_WRONLY #define LWS_O_CREAT O_CREAT #define LWS_O_TRUNC O_TRUNC #if !defined(LWS_PLAT_OPTEE) && !defined(OPTEE_TA) && !defined(LWS_WITH_ESP32) #include <poll.h> #include <netdb.h> #define LWS_INVALID_FILE -1 #else #define getdtablesize() (30) #if defined(LWS_WITH_ESP32) #define LWS_INVALID_FILE NULL #else #define LWS_INVALID_FILE NULL #endif #endif #if defined(__GNUC__) #if __GNUC__ >= 4 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) #define LWS_WARN_UNUSED_RESULT __attribute__((warn_unused_result)) #else #define LWS_WARN_UNUSED_RESULT #endif #define LWS_VISIBLE __attribute__((visibility(\"default\"))) #define LWS_WARN_DEPRECATED __attribute__ ((deprecated)) #define LWS_FORMAT(string_index) __attribute__ ((format(printf, string_index, string_index+1))) #else #define LWS_VISIBLE #define LWS_WARN_UNUSED_RESULT #define LWS_WARN_DEPRECATED #define LWS_FORMAT(string_index) #endif #if defined(__ANDROID__) #include <netinet/in.h> #include <unistd.h> #define getdtablesize() sysconf(_SC_OPEN_MAX) #endif #endif #if defined(LWS_WITH_LIBEV) #include <ev.h> #endif #ifdef LWS_WITH_LIBUV #include <uv.h> #ifdef LWS_HAVE_UV_VERSION_H #include <uv-version.h> #endif #ifdef LWS_HAVE_NEW_UV_VERSION_H #include <uv/version.h> #endif #endif #if defined(LWS_WITH_LIBEVENT) #include <event2/event.h> #endif #ifndef LWS_EXTERN #define LWS_EXTERN extern #endif #ifdef _WIN32 #define random rand #else #if !defined(OPTEE_TA) #include <sys/time.h> #include <unistd.h> #endif #endif #if defined(LWS_WITH_TLS) #ifdef USE_WOLFSSL #ifdef USE_OLD_CYASSL #ifdef _WIN32 #include <IDE/WIN/user_settings.h> #include <cyassl/ctaocrypt/settings.h> #else #include <cyassl/options.h> #endif #include <cyassl/openssl/ssl.h> #include <cyassl/error-ssl.h> #else #ifdef _WIN32 #include <IDE/WIN/user_settings.h> #include <wolfssl/wolfcrypt/settings.h> #else #include <wolfssl/options.h> #endif #include <wolfssl/openssl/ssl.h> #include <wolfssl/error-ssl.h> #endif #else #if defined(LWS_WITH_MBEDTLS) #if defined(LWS_WITH_ESP32) #undef MBEDTLS_CONFIG_FILE #define MBEDTLS_CONFIG_FILE <mbedtls/esp_config.h> #endif #include <mbedtls/ssl.h> #else #include <openssl/ssl.h> #if !defined(LWS_WITH_MBEDTLS) #include <openssl/err.h> #endif #endif #endif #endif #if LWS_MAX_SMP > 1 #include <pthread.h> #define lws_pthread_mutex(name)"
  },
  {
    "label": "lws_pthread_mutex_init()",
    "kind": "Method",
    "detail": "Function (LWS_INLINE void)",
    "insertText": "lws_pthread_mutex_init(pthread_mutex_t *lock)"
  },
  {
    "label": "pthread_mutex_init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_init(lock, NULL)"
  },
  {
    "label": "lws_pthread_mutex_destroy()",
    "kind": "Method",
    "detail": "Function (} LWS_INLINE void)",
    "insertText": "lws_pthread_mutex_destroy(pthread_mutex_t *lock)"
  },
  {
    "label": "pthread_mutex_destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_destroy(lock)"
  },
  {
    "label": "lws_pthread_mutex_lock()",
    "kind": "Method",
    "detail": "Function (} LWS_INLINE void)",
    "insertText": "lws_pthread_mutex_lock(pthread_mutex_t *lock)"
  },
  {
    "label": "pthread_mutex_lock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_lock(lock)"
  },
  {
    "label": "lws_pthread_mutex_unlock()",
    "kind": "Method",
    "detail": "Function (} LWS_INLINE void)",
    "insertText": "lws_pthread_mutex_unlock(pthread_mutex_t *lock)"
  },
  {
    "label": "pthread_mutex_unlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_mutex_unlock(lock)"
  },
  {
    "label": "lws_pthread_mutex()",
    "kind": "Method",
    "detail": "Function (} # else # define)",
    "insertText": "lws_pthread_mutex(name) #define lws_pthread_mutex_init(_a) #define lws_pthread_mutex_destroy(_a) #define lws_pthread_mutex_lock(_a) #define lws_pthread_mutex_unlock(_a)"
  },
  {
    "label": "_lws_log()",
    "kind": "Method",
    "detail": "Function (LLL_ERR = 1<<0,LLL_WARN = 1<<1,LLL_NOTICE = 1<<2,LLL_INFO = 1<<3,LLL_DEBUG = 1<<4,LLL_PARSER = 1<<5,LLL_HEADER = 1<<6,LLL_EXT = 1<<7,LLL_CLIENT = 1<<8,LLL_LATENCY = 1<<9,LLL_USER = 1<<1 0,LLL_COUNT = 1 1 } ; LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "_lws_log(int filter, const char *format, ...) LWS_FORMAT(2)"
  },
  {
    "label": "_lws_logv()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "_lws_logv(int filter, const char *format, va_list vl)"
  },
  {
    "label": "lwsl_timestamp()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lwsl_timestamp(int level, char *p, int len)"
  },
  {
    "label": "lwsl_err()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "lwsl_err(...) _lws_log(LLL_ERR, __VA_ARGS__) #define lwsl_user(...) _lws_log(LLL_USER, __VA_ARGS__) #if !defined(LWS_WITH_NO_LOGS) #define lwsl_warn(...) _lws_log(LLL_WARN, __VA_ARGS__) #define lwsl_notice(...) _lws_log(LLL_NOTICE, __VA_ARGS__) #endif #ifdef _DEBUG #if defined(LWS_WITH_NO_LOGS) #define lwsl_warn(...) _lws_log(LLL_WARN, __VA_ARGS__) #define lwsl_notice(...) _lws_log(LLL_NOTICE, __VA_ARGS__) #endif #define lwsl_info(...) _lws_log(LLL_INFO, __VA_ARGS__) #define lwsl_debug(...) _lws_log(LLL_DEBUG, __VA_ARGS__) #define lwsl_parser(...) _lws_log(LLL_PARSER, __VA_ARGS__) #define lwsl_header(...) _lws_log(LLL_HEADER, __VA_ARGS__) #define lwsl_ext(...) _lws_log(LLL_EXT, __VA_ARGS__) #define lwsl_client(...) _lws_log(LLL_CLIENT, __VA_ARGS__) #define lwsl_latency(...) _lws_log(LLL_LATENCY, __VA_ARGS__) #else #if defined(LWS_WITH_NO_LOGS) #define lwsl_warn(...)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0) #define lwsl_notice(...)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0) #endif #define lwsl_info(...)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0) #define lwsl_debug(...)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0) #define lwsl_parser(...)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0) #define lwsl_header(...)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0) #define lwsl_ext(...)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0) #define lwsl_client(...)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0) #define lwsl_latency(...)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(0) #endif #define lwsl_hexdump_err(...) lwsl_hexdump_level(LLL_ERR, __VA_ARGS__) #define lwsl_hexdump_warn(...) lwsl_hexdump_level(LLL_WARN, __VA_ARGS__) #define lwsl_hexdump_notice(...) lwsl_hexdump_level(LLL_NOTICE, __VA_ARGS__) #define lwsl_hexdump_info(...) lwsl_hexdump_level(LLL_INFO, __VA_ARGS__) #define lwsl_hexdump_debug(...) lwsl_hexdump_level(LLL_DEBUG, __VA_ARGS__) LWS_VISIBLE LWS_EXTERN void lwsl_hexdump_level(int level, const void *vbuf, size_t len)"
  },
  {
    "label": "lwsl_hexdump()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lwsl_hexdump(const void *buf, size_t len)"
  },
  {
    "label": "lws_is_be()",
    "kind": "Method",
    "detail": "Function (LWS_INLINE int)",
    "insertText": "lws_is_be(void)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (const int probe = ~ 0 xff ;)",
    "insertText": "return(const char *)"
  },
  {
    "label": "lws_set_log_level()",
    "kind": "Method",
    "detail": "Function (} LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_set_log_level(int level, void (*log_emit_function)(int level, const char *line))"
  },
  {
    "label": "lwsl_emit_syslog()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lwsl_emit_syslog(int level, const char *line)"
  },
  {
    "label": "lwsl_visible()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lwsl_visible(int level)"
  },
  {
    "label": "lws_container_of()",
    "kind": "Method",
    "detail": "Function (# include<stddef . h> # ifndef lws_container_of # define)",
    "insertText": "lws_container_of(P,T,M) ((T *)((char *)(P) - offsetof(T, M)))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (typedef int64_t lws_usec_t ; # define LWS_FEATURE_SERVE_HTTP_FILE_HAS_OTHER_HEADERS_ARG # define LWS_FEATURE_PROTOCOLS_HAS_ID_FIELD # define LWS_FEATURE_PROTOCOLS_HAS_PEER_WRITE_ALLOWANCE # define LWS_FEATURE_SERVE_HTTP_FILE_HAS_OTHER_HEADERS_LEN # define LWS_FEATURE_FOPS # if)",
    "insertText": "defined(_WIN32)"
  },
  {
    "label": "LWS_POLLHUP()",
    "kind": "Method",
    "detail": "Function (typedef HANDLE lws_filefd_type ; struct lws_pollfd { lws_sockfd_type fd ; SHORT events ; SHORT revents ; } ; # define)",
    "insertText": "LWS_POLLHUP(FD_CLOSE) #define LWS_POLLIN (FD_READ | FD_ACCEPT) #define LWS_POLLOUT (FD_WRITE) #else #if defined(LWS_WITH_ESP32)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (typedef int lws_filefd_type ; struct pollfd { lws_sockfd_type fd ; short events ; short revents ; } ; # define POLLIN 0 x0001 # define POLLPRI 0 x0002 # define POLLOUT 0 x0004 # define POLLERR 0 x0008 # define POLLHUP 0 x0010 # define POLLNVAL 0 x0020 # include<freertos / FreeRTOS . h> # include<freertos / event_groups . h> # include<string . h> # include \" esp_wifi . h \" # include \" esp_system . h \" # include \" esp_event . h \" # include \" esp_event_loop . h \" # include \" nvs . h \" # include \" driver / gpio . h \" # include \" esp_spi_flash . h \" # include \" freertos / timers . h \" # if !)",
    "insertText": "defined(CONFIG_FREERTOS_HZ)"
  },
  {
    "label": "uv_cb_t()",
    "kind": "Method",
    "detail": "Function (typedef void)",
    "insertText": "uv_cb_t(uv_timer_t *)"
  },
  {
    "label": "lws_uv_getloop()",
    "kind": "Method",
    "detail": "Function (typedef void* uv_handle_t ; struct timer_mapping { uv_cb_t* cb ; uv_timer_t* t ; } ; # define UV_VERSION_MAJOR 1 # define)",
    "insertText": "lws_uv_getloop(a, b) (NULL) static LWS_INLINE void uv_timer_init(void *l, uv_timer_t *t)"
  },
  {
    "label": "esp32_uvtimer_cb()",
    "kind": "Method",
    "detail": "Function (* t = NULL ; } void)",
    "insertText": "esp32_uvtimer_cb(TimerHandle_t t)"
  },
  {
    "label": "uv_timer_start()",
    "kind": "Method",
    "detail": "Function (LWS_INLINE void)",
    "insertText": "uv_timer_start(uv_timer_t *t, uv_cb_t *cb, int first, int rep)"
  },
  {
    "label": "tm()",
    "kind": "Method",
    "detail": "Function (struct timer_mapping*)",
    "insertText": "tm(struct timer_mapping *)malloc(sizeof(*tm))"
  },
  {
    "label": "xTimerCreate()",
    "kind": "Method",
    "detail": "Function (tm -> t = t ; tm -> cb = cb ;* t =)",
    "insertText": "xTimerCreate(\"x\", pdMS_TO_TICKS(first), !!rep, tm, (TimerCallbackFunction_t)esp32_uvtimer_cb)"
  },
  {
    "label": "xTimerStart()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "xTimerStart(*t, 0)"
  },
  {
    "label": "uv_timer_stop()",
    "kind": "Method",
    "detail": "Function (} LWS_INLINE void)",
    "insertText": "uv_timer_stop(uv_timer_t *t)"
  },
  {
    "label": "xTimerStop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "xTimerStop(*t, 0)"
  },
  {
    "label": "uv_close()",
    "kind": "Method",
    "detail": "Function (} LWS_INLINE void)",
    "insertText": "uv_close(uv_handle_t *h, void *v)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(pvTimerGetTimerID((uv_timer_t)h))"
  },
  {
    "label": "xTimerDelete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "xTimerDelete(*(uv_timer_t *)h, 0)"
  },
  {
    "label": "lws_esp32_identify_physical_device()",
    "kind": "Method",
    "detail": "Function (} # include<mdns . h> # include<esp_partition . h> # define LWS_PLUGIN_STATIC # define LWS_MAGIC_REBOOT_TYPE_ADS 0 x50001ffc # define LWS_MAGIC_REBOOT_TYPE_REQ_FACTORY 0 xb00bcafe # define LWS_MAGIC_REBOOT_TYPE_FORCED_FACTORY 0 xfaceb00b # define LWS_MAGIC_REBOOT_TYPE_FORCED_FACTORY_BUTTON 0 xf0cedfac void)",
    "insertText": "lws_esp32_identify_physical_device(void)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "void(*lws_cb_scan_done)(uint16_t count, wifi_ap_record_t *recs, void *arg)"
  },
  {
    "label": "lws_esp32_event_passthru()",
    "kind": "Method",
    "detail": "Function (enum genled_state { LWSESP32_GENLED__INIT,LWSESP32_GENLED__LOST_NETWORK,LWSESP32_GENLED__NO_NETWORK,LWSESP32_GENLED__CONN_AP,LWSESP32_GENLED__GOT_IP,LWSESP32_GENLED__OK,} ; struct lws_group_member { struct lws_group_member* next ; uint64_t last_seen ; char model [ 1 6 ] ; char role [ 1 6 ] ; char host [ 3 2 ] ; char mac [ 2 0 ] ; int width,height ; struct ip4_addr addr ; struct ip6_addr addrv6 ; uint8_t flags ; } ; # define LWS_SYSTEM_GROUP_MEMBER_ADD 1 # define LWS_SYSTEM_GROUP_MEMBER_CHANGE 2 # define LWS_SYSTEM_GROUP_MEMBER_REMOVE 3 # define LWS_GROUP_FLAG_SELF 1 struct lws_esp32 { char sta_ip [ 1 6 ] ; char sta_mask [ 1 6 ] ; char sta_gw [ 1 6 ] ; char serial [ 1 6 ] ; char opts [ 1 6 ] ; char model [ 1 6 ] ; char group [ 1 6 ] ; char role [ 1 6 ] ; char ssid [ 4 ] [ 6 4 ] ; char password [ 4 ] [ 6 4 ] ; char active_ssid [ 6 4 ] ; char access_pw [ 1 6 ] ; char hostname [ 3 2 ] ; char mac [ 2 0 ] ; char le_dns [ 6 4 ] ; char le_email [ 6 4 ] ; char region ; char inet ; char conn_ap ; enum genled_state genled ; uint64_t genled_t ; lws_cb_scan_done scan_consumer ; void* scan_consumer_arg ; struct lws_group_member* first ; int extant_group_members ; char acme ; char upload ; volatile char button_is_down ; } ; struct lws_esp32_image { uint32_t romfs ; uint32_t romfs_len ; uint32_t json ; uint32_t json_len ; } ; struct lws_esp32 lws_esp32 ; struct lws_vhost ; esp_err_t)",
    "insertText": "lws_esp32_event_passthru(void *ctx, system_event_t *event)"
  },
  {
    "label": "lws_esp32_wlan_config()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "lws_esp32_wlan_config(void)"
  },
  {
    "label": "lws_esp32_wlan_start_ap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "lws_esp32_wlan_start_ap(void)"
  },
  {
    "label": "lws_esp32_wlan_start_station()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "lws_esp32_wlan_start_station(void)"
  },
  {
    "label": "lws_esp32_set_creation_defaults()",
    "kind": "Method",
    "detail": "Function (struct lws_context_creation_info ; void)",
    "insertText": "lws_esp32_set_creation_defaults(struct lws_context_creation_info *info)"
  },
  {
    "label": "lws_esp32_init()",
    "kind": "Method",
    "detail": "Function (struct lws_context*)",
    "insertText": "lws_esp32_init(struct lws_context_creation_info *, struct lws_vhost **pvh)"
  },
  {
    "label": "lws_esp32_wlan_nvs_get()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "lws_esp32_wlan_nvs_get(int retry)"
  },
  {
    "label": "lws_nvs_set_str()",
    "kind": "Method",
    "detail": "Function (esp_err_t)",
    "insertText": "lws_nvs_set_str(nvs_handle handle, const char* key, const char* value)"
  },
  {
    "label": "lws_esp32_restart_guided()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "lws_esp32_restart_guided(uint32_t type)"
  },
  {
    "label": "lws_esp_ota_get_boot_partition()",
    "kind": "Method",
    "detail": "Function (const esp_partition_t*)",
    "insertText": "lws_esp_ota_get_boot_partition(void)"
  },
  {
    "label": "lws_esp32_get_image_info()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "lws_esp32_get_image_info(const esp_partition_t *part, struct lws_esp32_image *i, char *json, int json_len)"
  },
  {
    "label": "lws_esp32_leds_network_indication()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "lws_esp32_leds_network_indication(void)"
  },
  {
    "label": "lws_esp32_get_reboot_type()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "lws_esp32_get_reboot_type(void)"
  },
  {
    "label": "lws_esp32_sine_interp()",
    "kind": "Method",
    "detail": "Function (uint16_t)",
    "insertText": "lws_esp32_sine_interp(int n)"
  },
  {
    "label": "lws_esp32_leds_timer_cb()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "lws_esp32_leds_timer_cb(TimerHandle_t th)"
  },
  {
    "label": "LWS_POLLHUP()",
    "kind": "Method",
    "detail": "Function (# else typedef int lws_sockfd_type ; typedef int lws_filefd_type ; # endif # define lws_pollfd pollfd # define)",
    "insertText": "LWS_POLLHUP(POLLHUP|POLLERR) #define LWS_POLLIN (POLLIN) #define LWS_POLLOUT (POLLOUT) #endif #if (defined(WIN32) || defined(_WIN32)) && !defined(__MINGW32__) #define ssize_t SSIZE_T #endif #if defined(WIN32) && defined(LWS_HAVE__STAT32I64) #include <sys/types.h> #include <sys/stat.h> #endif #if defined(LWS_HAVE_STDINT_H) #include <stdint.h> #else #if defined(WIN32) || defined(_WIN32)"
  },
  {
    "label": "lws_close_reason()",
    "kind": "Method",
    "detail": "Function (typedef unsigned __int16 uint16_t ; typedef unsigned __int8 uint8_t ; # else typedef unsigned int uint32_t ; typedef unsigned short uint16_t ; typedef unsigned char uint8_t ; # endif # endif typedef unsigned long long lws_filepos_t ; typedef long long lws_fileofs_t ; typedef uint32_t lws_fop_flags_t ; struct lws_pollargs { lws_sockfd_type fd ; int events ; int prev_events ; } ; struct lws_tokens ; struct lws_token_limits ; enum lws_close_status { LWS_CLOSE_STATUS_NOSTATUS = 0,LWS_CLOSE_STATUS_NORMAL = 1 0 0 0,LWS_CLOSE_STATUS_GOINGAWAY = 1 0 0 1,LWS_CLOSE_STATUS_PROTOCOL_ERR = 1 0 0 2,LWS_CLOSE_STATUS_UNACCEPTABLE_OPCODE = 1 0 0 3,LWS_CLOSE_STATUS_RESERVED = 1 0 0 4,LWS_CLOSE_STATUS_NO_STATUS = 1 0 0 5,LWS_CLOSE_STATUS_ABNORMAL_CLOSE = 1 0 0 6,LWS_CLOSE_STATUS_INVALID_PAYLOAD = 1 0 0 7,LWS_CLOSE_STATUS_POLICY_VIOLATION = 1 0 0 8,LWS_CLOSE_STATUS_MESSAGE_TOO_LARGE = 1 0 0 9,LWS_CLOSE_STATUS_EXTENSION_REQUIRED = 1 0 1 0,LWS_CLOSE_STATUS_UNEXPECTED_CONDITION = 1 0 1 1,LWS_CLOSE_STATUS_TLS_FAILURE = 1 0 1 5,LWS_CLOSE_STATUS_CLIENT_TRANSACTION_DONE = 2 0 0 0,LWS_CLOSE_STATUS_NOSTATUS_CONTEXT_DESTROY = 9 9 9 9,} ; LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_close_reason(struct lws *wsi, enum lws_close_status status, unsigned char *buf, size_t len)"
  },
  {
    "label": "lws_callback_function()",
    "kind": "Method",
    "detail": "Function (struct lws ; struct lws_context ; struct lws_extension ; struct lws_ssl_info { int where ; int ret ; } ; enum lws_cert_update_state { LWS_CUS_IDLE,LWS_CUS_STARTING,LWS_CUS_SUCCESS,LWS_CUS_FAILED,LWS_CUS_CREATE_KEYS,LWS_CUS_REG,LWS_CUS_AUTH,LWS_CUS_CHALLENGE,LWS_CUS_CREATE_REQ,LWS_CUS_REQ,LWS_CUS_CONFIRM,LWS_CUS_ISSUE,} ; enum { LWS_TLS_REQ_ELEMENT_COUNTRY,LWS_TLS_REQ_ELEMENT_STATE,LWS_TLS_REQ_ELEMENT_LOCALITY,LWS_TLS_REQ_ELEMENT_ORGANIZATION,LWS_TLS_REQ_ELEMENT_COMMON_NAME,LWS_TLS_REQ_ELEMENT_EMAIL,LWS_TLS_REQ_ELEMENT_COUNT,LWS_TLS_SET_DIR_URL = LWS_TLS_REQ_ELEMENT_COUNT,LWS_TLS_SET_AUTH_PATH,LWS_TLS_SET_CERT_PATH,LWS_TLS_SET_KEY_PATH,LWS_TLS_TOTAL_COUNT } ; struct lws_acme_cert_aging_args { struct lws_vhost* vh ; const char* element_overrides [ LWS_TLS_TOTAL_COUNT ] ; } ; enum lws_callback_reasons { LWS_CALLBACK_PROTOCOL_INIT = 2 7,LWS_CALLBACK_PROTOCOL_DESTROY = 2 8,LWS_CALLBACK_WSI_CREATE = 2 9,LWS_CALLBACK_WSI_DESTROY = 3 0,LWS_CALLBACK_HTTP_BIND_PROTOCOL = 4 9,LWS_CALLBACK_HTTP_DROP_PROTOCOL = 5 0,LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS = 2 1,LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS = 2 2,LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION = 2 3,LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY = 3 7,LWS_CALLBACK_SSL_INFO = 6 7,LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION = 5 8,LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED = 1 9,LWS_CALLBACK_HTTP = 1 2,LWS_CALLBACK_HTTP_BODY = 1 3,LWS_CALLBACK_HTTP_BODY_COMPLETION = 1 4,LWS_CALLBACK_HTTP_FILE_COMPLETION = 1 5,LWS_CALLBACK_HTTP_WRITEABLE = 1 6,LWS_CALLBACK_CLOSED_HTTP = 5,LWS_CALLBACK_FILTER_HTTP_CONNECTION = 1 8,LWS_CALLBACK_ADD_HEADERS = 5 3,LWS_CALLBACK_CHECK_ACCESS_RIGHTS = 5 1,LWS_CALLBACK_PROCESS_HTML = 5 2,LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP = 4 4,LWS_CALLBACK_CLOSED_CLIENT_HTTP = 4 5,LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ = 4 8,LWS_CALLBACK_RECEIVE_CLIENT_HTTP = 4 6,LWS_CALLBACK_COMPLETED_CLIENT_HTTP = 4 7,LWS_CALLBACK_CLIENT_HTTP_WRITEABLE = 5 7,LWS_CALLBACK_ESTABLISHED = 0,LWS_CALLBACK_CLOSED = 4,LWS_CALLBACK_SERVER_WRITEABLE = 1 1,LWS_CALLBACK_RECEIVE = 6,LWS_CALLBACK_RECEIVE_PONG = 7,LWS_CALLBACK_WS_PEER_INITIATED_CLOSE = 3 8,LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION = 2 0,LWS_CALLBACK_CONFIRM_EXTENSION_OKAY = 2 5,LWS_CALLBACK_CLIENT_CONNECTION_ERROR = 1,LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH = 2,LWS_CALLBACK_CLIENT_ESTABLISHED = 3,LWS_CALLBACK_CLIENT_CLOSED = 7 5,LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER = 2 4,LWS_CALLBACK_CLIENT_RECEIVE = 8,LWS_CALLBACK_CLIENT_RECEIVE_PONG = 9,LWS_CALLBACK_CLIENT_WRITEABLE = 1 0,LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED = 2 6,LWS_CALLBACK_WS_EXT_DEFAULTS = 3 9,LWS_CALLBACK_FILTER_NETWORK_CONNECTION = 1 7,LWS_CALLBACK_GET_THREAD_ID = 3 1,LWS_CALLBACK_ADD_POLL_FD = 3 2,LWS_CALLBACK_DEL_POLL_FD = 3 3,LWS_CALLBACK_CHANGE_MODE_POLL_FD = 3 4,LWS_CALLBACK_LOCK_POLL = 3 5,LWS_CALLBACK_UNLOCK_POLL = 3 6,LWS_CALLBACK_CGI = 4 0,LWS_CALLBACK_CGI_TERMINATED = 4 1,LWS_CALLBACK_CGI_STDIN_DATA = 4 2,LWS_CALLBACK_CGI_STDIN_COMPLETED = 4 3,LWS_CALLBACK_CGI_PROCESS_ATTACH = 7 0,LWS_CALLBACK_SESSION_INFO = 5 4,LWS_CALLBACK_GS_EVENT = 5 5,LWS_CALLBACK_HTTP_PMO = 5 6,LWS_CALLBACK_RAW_RX = 5 9,LWS_CALLBACK_RAW_CLOSE = 6 0,LWS_CALLBACK_RAW_WRITEABLE = 6 1,LWS_CALLBACK_RAW_ADOPT = 6 2,LWS_CALLBACK_RAW_ADOPT_FILE = 6 3,LWS_CALLBACK_RAW_RX_FILE = 6 4,LWS_CALLBACK_RAW_WRITEABLE_FILE = 6 5,LWS_CALLBACK_RAW_CLOSE_FILE = 6 6,LWS_CALLBACK_TIMER = 7 3,LWS_CALLBACK_EVENT_WAIT_CANCELLED = 7 1,LWS_CALLBACK_CHILD_CLOSING = 6 9,LWS_CALLBACK_CHILD_WRITE_VIA_PARENT = 6 8,LWS_CALLBACK_VHOST_CERT_AGING = 7 2,LWS_CALLBACK_VHOST_CERT_UPDATE = 7 4,LWS_CALLBACK_USER = 1 0 0 0,} ; typedef int)",
    "insertText": "lws_callback_function(struct lws *wsi, enum lws_callback_reasons reason, void *user, void *in, size_t len)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# define LWS_CB_REASON_AUX_BF__CGI 1 # define LWS_CB_REASON_AUX_BF__PROXY 2 # define LWS_CB_REASON_AUX_BF__CGI_CHUNK_END 4 # define LWS_CB_REASON_AUX_BF__CGI_HEADERS 8 struct lws_vhost ; # if)",
    "insertText": "defined(LWS_WITH_TLS) #if defined(LWS_WITH_MBEDTLS)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (LWS_GENHASH_TYPE_SHA1,LWS_GENHASH_TYPE_SHA256,LWS_GENHASH_TYPE_SHA384,LWS_GENHASH_TYPE_SHA512,} ; enum lws_genhmac_types { LWS_GENHMAC_TYPE_SHA256,LWS_GENHMAC_TYPE_SHA384,LWS_GENHMAC_TYPE_SHA512,} ; # define LWS_GENHASH_LARGEST 6 4 struct lws_genhash_ctx { uint8_t type ; # if)",
    "insertText": "defined(LWS_WITH_MBEDTLS)"
  },
  {
    "label": "lws_genhash_size()",
    "kind": "Method",
    "detail": "Function (mbedtls_md_context_t ctx ; # else const EVP_MD* evp_type ; EVP_MD_CTX* ctx ; # endif } ; LWS_VISIBLE LWS_EXTERN size_t LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_genhash_size(enum lws_genhash_types type)"
  },
  {
    "label": "lws_genhmac_size()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN size_t LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_genhmac_size(enum lws_genhmac_types type)"
  },
  {
    "label": "lws_genhash_init()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_genhash_init(struct lws_genhash_ctx *ctx, enum lws_genhash_types type)"
  },
  {
    "label": "lws_genhash_update()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_genhash_update(struct lws_genhash_ctx *ctx, const void *in, size_t len)"
  },
  {
    "label": "lws_genhash_destroy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_genhash_destroy(struct lws_genhash_ctx *ctx, void *result)"
  },
  {
    "label": "lws_genhmac_init()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "lws_genhmac_init(struct lws_genhmac_ctx *ctx, enum lws_genhmac_types type, const uint8_t *key, size_t key_len)"
  },
  {
    "label": "lws_genhmac_update()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "lws_genhmac_update(struct lws_genhmac_ctx *ctx, const void *in, size_t len)"
  },
  {
    "label": "lws_genhmac_destroy()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "lws_genhmac_destroy(struct lws_genhmac_ctx *ctx, void *result)"
  },
  {
    "label": "lws_jwk_destroy_genrsa_elements()",
    "kind": "Method",
    "detail": "Function (# else BIGNUM* bn [ LWS_COUNT_RSA_ELEMENTS ] ; RSA* rsa ; # endif } ; struct lws_genrsa_element { uint8_t* buf ; uint16_t len ; } ; struct lws_genrsa_elements { struct lws_genrsa_element e [ LWS_COUNT_RSA_ELEMENTS ] ; } ; LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_jwk_destroy_genrsa_elements(struct lws_genrsa_elements *el)"
  },
  {
    "label": "lws_genrsa_create()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_genrsa_create(struct lws_genrsa_ctx *ctx, struct lws_genrsa_elements *el)"
  },
  {
    "label": "lws_genrsa_new_keypair()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_genrsa_new_keypair(struct lws_context *context, struct lws_genrsa_ctx *ctx, struct lws_genrsa_elements *el, int bits)"
  },
  {
    "label": "lws_genrsa_public_decrypt()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_genrsa_public_decrypt(struct lws_genrsa_ctx *ctx, const uint8_t *in, size_t in_len, uint8_t *out, size_t out_max)"
  },
  {
    "label": "lws_genrsa_public_verify()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_genrsa_public_verify(struct lws_genrsa_ctx *ctx, const uint8_t *in, enum lws_genhash_types hash_type, const uint8_t *sig, size_t sig_len)"
  },
  {
    "label": "lws_genrsa_public_sign()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_genrsa_public_sign(struct lws_genrsa_ctx *ctx, const uint8_t *in, enum lws_genhash_types hash_type, uint8_t *sig, size_t sig_len)"
  },
  {
    "label": "lws_genrsa_destroy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_genrsa_destroy(struct lws_genrsa_ctx *ctx)"
  },
  {
    "label": "lws_genrsa_render_pkey_asn1()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_genrsa_render_pkey_asn1(struct lws_genrsa_ctx *ctx, int _private, uint8_t *pkey_asn1, size_t pkey_asn1_len)"
  },
  {
    "label": "lws_jwk_import()",
    "kind": "Method",
    "detail": "Function (struct lws_jwk { char keytype [ 5 ] ; struct lws_genrsa_elements el ; } ; LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_jwk_import(struct lws_jwk *s, const char *in, size_t len)"
  },
  {
    "label": "lws_jwk_destroy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_jwk_destroy(struct lws_jwk *s)"
  },
  {
    "label": "lws_jwk_export()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_jwk_export(struct lws_jwk *s, int _private, char *p, size_t len)"
  },
  {
    "label": "lws_jwk_load()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE int)",
    "insertText": "lws_jwk_load(struct lws_jwk *s, const char *filename)"
  },
  {
    "label": "lws_jwk_save()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE int)",
    "insertText": "lws_jwk_save(struct lws_jwk *s, const char *filename)"
  },
  {
    "label": "lws_jwk_rfc7638_fingerprint()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE int)",
    "insertText": "lws_jwk_rfc7638_fingerprint(struct lws_jwk *s, char *digest32)"
  },
  {
    "label": "lws_jws_confirm_sig()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_jws_confirm_sig(const char *in, size_t len, struct lws_jwk *jwk)"
  },
  {
    "label": "lws_jws_sign_from_b64()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_jws_sign_from_b64(const char *b64_hdr, size_t hdr_len, const char *b64_pay, size_t pay_len, char *b64_sig, size_t sig_len, enum lws_genhash_types hash_type, struct lws_jwk *jwk)"
  },
  {
    "label": "lws_jws_create_packet()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_jws_create_packet(struct lws_jwk *jwk, const char *payload, size_t len, const char *nonce, char *out, size_t out_len)"
  },
  {
    "label": "lws_jws_base64_enc()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_jws_base64_enc(const char *in, size_t in_len, char *out, size_t out_max)"
  },
  {
    "label": "lws_extension_callback_function()",
    "kind": "Method",
    "detail": "Function (# endif enum lws_extension_callback_reasons { LWS_EXT_CB_CONSTRUCT = 4,LWS_EXT_CB_CLIENT_CONSTRUCT = 5,LWS_EXT_CB_DESTROY = 8,LWS_EXT_CB_PACKET_TX_PRESEND = 1 2,LWS_EXT_CB_PAYLOAD_TX = 2 1,LWS_EXT_CB_PAYLOAD_RX = 2 2,LWS_EXT_CB_OPTION_DEFAULT = 2 3,LWS_EXT_CB_OPTION_SET = 2 4,LWS_EXT_CB_OPTION_CONFIRM = 2 5,LWS_EXT_CB_NAMED_OPTION_SET = 2 6,} ; enum lws_ext_options_types { EXTARG_NONE,EXTARG_DEC,EXTARG_OPT_DEC } ; struct lws_ext_options { const char* name ; enum lws_ext_options_types type ; } ; struct lws_ext_option_arg { const char* option_name ; int option_index ; const char* start ; int len ; } ; typedef int)",
    "insertText": "lws_extension_callback_function(struct lws_context *context, const struct lws_extension *ext, struct lws *wsi, enum lws_extension_callback_reasons reason, void *user, void *in, size_t len)"
  },
  {
    "label": "lws_set_extension_option()",
    "kind": "Method",
    "detail": "Function (struct lws_extension { const char* name ; lws_extension_callback_function* callback ; const char* client_offer ; } ; LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_set_extension_option(struct lws *wsi, const char *ext_name, const char *opt_name, const char *opt_val)"
  },
  {
    "label": "lws_ext_parse_options()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_ext_parse_options(const struct lws_extension *ext, struct lws *wsi, void *ext_user, const struct lws_ext_options *opts, const char *o, int len)"
  },
  {
    "label": "lws_extension_callback_pm_deflate()",
    "kind": "Method",
    "detail": "Function (LWS_EXTERN int)",
    "insertText": "lws_extension_callback_pm_deflate(struct lws_context *context, const struct lws_extension *ext, struct lws *wsi, enum lws_extension_callback_reasons reason, void *user, void *in, size_t len)"
  },
  {
    "label": "lws_vhost_name_to_protocol()",
    "kind": "Method",
    "detail": "Function (struct lws_protocols { const char* name ; lws_callback_function* callback ; size_t per_session_data_size ; size_t rx_buffer_size ; unsigned int id ; void* user ; size_t tx_packet_size ; } ; LWS_VISIBLE LWS_EXTERN const struct lws_protocols*)",
    "insertText": "lws_vhost_name_to_protocol(struct lws_vhost *vh, const char *name)"
  },
  {
    "label": "lws_get_protocol()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const struct lws_protocols*)",
    "insertText": "lws_get_protocol(struct lws *wsi)"
  },
  {
    "label": "lws_protocol_get()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const struct lws_protocols*)",
    "insertText": "lws_protocol_get(struct lws *wsi)"
  },
  {
    "label": "lws_protocol_vh_priv_zalloc()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void*)",
    "insertText": "lws_protocol_vh_priv_zalloc(struct lws_vhost *vhost, const struct lws_protocols *prot, int size)"
  },
  {
    "label": "lws_protocol_vh_priv_get()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void*)",
    "insertText": "lws_protocol_vh_priv_get(struct lws_vhost *vhost, const struct lws_protocols *prot)"
  },
  {
    "label": "lws_adjust_protocol_psds()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void*)",
    "insertText": "lws_adjust_protocol_psds(struct lws *wsi, size_t new_size)"
  },
  {
    "label": "lws_finalize_startup()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_finalize_startup(struct lws_context *context)"
  },
  {
    "label": "lws_pvo_search()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const struct lws_protocol_vhost_options*)",
    "insertText": "lws_pvo_search(const struct lws_protocol_vhost_options *pvo, const char *name)"
  },
  {
    "label": "lws_protocol_init()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_protocol_init(struct lws_context *context)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (# ifdef LWS_WITH_PLUGINS # define LWS_PLUGIN_API_MAGIC 1 8 0 struct lws_plugin_capability { unsigned int api_magic ; const struct lws_protocols* protocols ; int count_protocols ; const struct lws_extension* extensions ; int count_extensions ; } ; typedef)",
    "insertText": "int(*lws_plugin_init_func)(struct lws_context *, struct lws_plugin_capability *)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "int(*lws_plugin_destroy_func)(struct lws_context *)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (struct lws_plugin { struct lws_plugin* list ; #)",
    "insertText": "if(UV_VERSION_MAJOR > 0)"
  },
  {
    "label": "LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT()",
    "kind": "Method",
    "detail": "Function (# else void* l ; # endif char name [ 6 4 ] ; struct lws_plugin_capability caps ; } ; # endif # define LWSGS_EMAIL_CONTENT_SIZE 1 6 3 8 4 typedef struct { unsigned char bin [ 2 0 ] ; } lwsgw_hash_bin ; typedef struct { char id [ 4 1 ] ; } lwsgw_hash ; enum lwsgs_auth_bits { LWSGS_AUTH_LOGGED_IN = 1,LWSGS_AUTH_ADMIN = 2,LWSGS_AUTH_VERIFIED = 4,LWSGS_AUTH_FORGOT_FLOW = 8,} ; struct lws_session_info { char username [ 3 2 ] ; char email [ 1 0 0 ] ; char ip [ 7 2 ] ; unsigned int mask ; char session [ 4 2 ] ; } ; enum lws_gs_event { LWSGSE_CREATED,LWSGSE_DELETED } ; struct lws_gs_event_args { enum lws_gs_event event ; const char* username ; const char* email ; } ; enum lws_context_options {)",
    "insertText": "LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT(1 << 1) | (1 << 12), LWS_SERVER_OPTION_SKIP_SERVER_CANONICAL_NAME = (1 << 2), LWS_SERVER_OPTION_ALLOW_NON_SSL_ON_SSL_PORT = (1 << 3) | (1 << 12), LWS_SERVER_OPTION_LIBEV = (1 << 4), LWS_SERVER_OPTION_DISABLE_IPV6 = (1 << 5), LWS_SERVER_OPTION_DISABLE_OS_CA_CERTS = (1 << 6), LWS_SERVER_OPTION_PEER_CERT_NOT_REQUIRED = (1 << 7), LWS_SERVER_OPTION_VALIDATE_UTF8 = (1 << 8), LWS_SERVER_OPTION_SSL_ECDH = (1 << 9) | (1 << 12), LWS_SERVER_OPTION_LIBUV = (1 << 10), LWS_SERVER_OPTION_REDIRECT_HTTP_TO_HTTPS = (1 << 11) | (1 << 12), LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT = (1 << 12), LWS_SERVER_OPTION_EXPLICIT_VHOSTS = (1 << 13), LWS_SERVER_OPTION_UNIX_SOCK = (1 << 14), LWS_SERVER_OPTION_STS = (1 << 15), LWS_SERVER_OPTION_IPV6_V6ONLY_MODIFY = (1 << 16), LWS_SERVER_OPTION_IPV6_V6ONLY_VALUE = (1 << 17), LWS_SERVER_OPTION_UV_NO_SIGSEGV_SIGFPE_SPIN = (1 << 18), LWS_SERVER_OPTION_JUST_USE_RAW_ORIGIN = (1 << 19), LWS_SERVER_OPTION_FALLBACK_TO_RAW = (1 << 20), LWS_SERVER_OPTION_LIBEVENT = (1 << 21), LWS_SERVER_OPTION_ONLY_RAW = (1 << 22), LWS_SERVER_OPTION_ALLOW_LISTEN_SHARE = (1 << 23), LWS_SERVER_OPTION_CREATE_VHOST_SSL_CTX = (1 << 24), LWS_SERVER_OPTION_SKIP_PROTOCOL_INIT = (1 << 25), LWS_SERVER_OPTION_IGNORE_MISSING_CERT = (1 << 26)"
  },
  {
    "label": "lws_check_opt()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "lws_check_opt(c, f) (((c) & (f)) == (f))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (struct lws_context_creation_info { int port ; const char* iface ; const struct lws_protocols* protocols ; const struct lws_extension* extensions ; const struct lws_token_limits* token_limits ; const char* ssl_private_key_password ; const char* ssl_cert_filepath ; const char* ssl_private_key_filepath ; const char* ssl_ca_filepath ; const char* ssl_cipher_list ; const char* http_proxy_address ; unsigned int http_proxy_port ; int gid ; int uid ; unsigned int options ; void* user ; int ka_time ; int ka_probes ; int ka_interval ; # if)",
    "insertText": "defined(LWS_WITH_TLS) && !defined(LWS_WITH_MBEDTLS)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# else void* provided_client_ssl_ctx ; # endif short max_http_header_data ; short max_http_header_pool ; unsigned int count_threads ; unsigned int fd_limit_per_thread ; unsigned int timeout_secs ; const char* ecdh_curve ; const char* vhost_name ; const char* const* plugin_dirs ; const struct lws_protocol_vhost_options* pvo ; int keepalive_timeout ; const char* log_filepath ; const struct lws_http_mount* mounts ; const char* server_string ; unsigned int pt_serv_buf_size ; unsigned int max_http_header_data2 ; long ssl_options_set ; long ssl_options_clear ; unsigned short ws_ping_pong_interval ; const struct lws_protocol_vhost_options* headers ; const struct lws_protocol_vhost_options* reject_service_keywords ; void* external_baggage_free_on_destroy ; const char* client_ssl_private_key_password ; const char* client_ssl_cert_filepath ; const char* client_ssl_private_key_filepath ; const char* client_ssl_ca_filepath ; const char* client_ssl_cipher_list ; const struct lws_plat_file_ops* fops ; int simultaneous_ssl_restriction ; const char* socks_proxy_address ; unsigned int socks_proxy_port ; # if)",
    "insertText": "defined(LWS_HAVE_SYS_CAPABILITY_H) && defined(LWS_HAVE_LIBCAP)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (char count_caps ; # endif int bind_iface ; int ssl_info_event_mask ; unsigned int timeout_secs_ah_idle ; unsigned short ip_limit_ah ; unsigned short ip_limit_wsi ; uint32_t http2_settings [ 7 ] ; const char* error_document_404 ; const char* alpn ; void** foreign_loops ;)",
    "insertText": "void(*signal_cb)(void *event_lib_handle, int signum)"
  },
  {
    "label": "lws_create_context()",
    "kind": "Method",
    "detail": "Function (struct lws_context** pcontext ; void* _unused [ 4 ] ; } ; LWS_VISIBLE LWS_EXTERN struct lws_context*)",
    "insertText": "lws_create_context(const struct lws_context_creation_info *info)"
  },
  {
    "label": "lws_context_destroy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_context_destroy(struct lws_context *context)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "int(*lws_reload_func)(void)"
  },
  {
    "label": "lws_context_deprecate()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_context_deprecate(struct lws_context *context, lws_reload_func cb)"
  },
  {
    "label": "lws_context_is_deprecated()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_context_is_deprecated(struct lws_context *context)"
  },
  {
    "label": "lws_set_proxy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_set_proxy(struct lws_vhost *vhost, const char *proxy)"
  },
  {
    "label": "lws_set_socks()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_set_socks(struct lws_vhost *vhost, const char *socks)"
  },
  {
    "label": "lws_create_vhost()",
    "kind": "Method",
    "detail": "Function (struct lws_vhost ; LWS_VISIBLE LWS_EXTERN struct lws_vhost*)",
    "insertText": "lws_create_vhost(struct lws_context *context, const struct lws_context_creation_info *info)"
  },
  {
    "label": "lws_vhost_destroy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_vhost_destroy(struct lws_vhost *vh)"
  },
  {
    "label": "lwsws_get_config_globals()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lwsws_get_config_globals(struct lws_context_creation_info *info, const char *d, char **config_strings, int *len)"
  },
  {
    "label": "lwsws_get_config_vhosts()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lwsws_get_config_vhosts(struct lws_context *context, struct lws_context_creation_info *info, const char *d, char **config_strings, int *len)"
  },
  {
    "label": "lws_vhost_get()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws_vhost*)",
    "insertText": "lws_vhost_get(struct lws *wsi)"
  },
  {
    "label": "lws_get_vhost()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws_vhost*)",
    "insertText": "lws_get_vhost(struct lws *wsi)"
  },
  {
    "label": "lws_get_vhost_name()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char*)",
    "insertText": "lws_get_vhost_name(struct lws_vhost *vhost)"
  },
  {
    "label": "lws_get_vhost_port()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_get_vhost_port(struct lws_vhost *vhost)"
  },
  {
    "label": "lws_get_vhost_user()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void*)",
    "insertText": "lws_get_vhost_user(struct lws_vhost *vhost)"
  },
  {
    "label": "lws_get_vhost_iface()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char*)",
    "insertText": "lws_get_vhost_iface(struct lws_vhost *vhost)"
  },
  {
    "label": "lws_json_dump_vhost()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_json_dump_vhost(const struct lws_vhost *vh, char *buf, int len)"
  },
  {
    "label": "lws_json_dump_context()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_json_dump_context(const struct lws_context *context, char *buf, int len, int hide_vhosts)"
  },
  {
    "label": "lws_vhost_user()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void*)",
    "insertText": "lws_vhost_user(struct lws_vhost *vhost)"
  },
  {
    "label": "lws_context_user()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void*)",
    "insertText": "lws_context_user(struct lws_context *context)"
  },
  {
    "label": "LCCSCF_USE_SSL()",
    "kind": "Method",
    "detail": "Function (struct lws_protocol_vhost_options { const struct lws_protocol_vhost_options* next ; const struct lws_protocol_vhost_options* options ; const char* name ; const char* value ; } ; enum lws_mount_protocols { LWSMPRO_HTTP = 0,LWSMPRO_HTTPS = 1,LWSMPRO_FILE = 2,LWSMPRO_CGI = 3,LWSMPRO_REDIR_HTTP = 4,LWSMPRO_REDIR_HTTPS = 5,LWSMPRO_CALLBACK = 6,} ; struct lws_http_mount { const struct lws_http_mount* mount_next ; const char* mountpoint ; const char* origin ; const char* def ; const char* protocol ; const struct lws_protocol_vhost_options* cgienv ; const struct lws_protocol_vhost_options* extra_mimetypes ; const struct lws_protocol_vhost_options* interpret ; int cgi_timeout ; int cache_max_age ; unsigned int auth_mask ; unsigned int cache_reusable : 1 ; unsigned int cache_revalidate : 1 ; unsigned int cache_intermediaries : 1 ; unsigned char origin_protocol ; unsigned char mountpoint_len ; const char* basic_auth_login_file ; void* _unused [ 2 ] ; } ; enum lws_client_connect_ssl_connection_flags {)",
    "insertText": "LCCSCF_USE_SSL(1 << 0), LCCSCF_ALLOW_SELFSIGNED = (1 << 1), LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK = (1 << 2), LCCSCF_ALLOW_EXPIRED = (1 << 3), LCCSCF_PIPELINE = (1 << 16)"
  },
  {
    "label": "lws_client_connect_via_info()",
    "kind": "Method",
    "detail": "Function (struct lws_client_connect_info { struct lws_context* context ; const char* address ; int port ; int ssl_connection ; const char* path ; const char* host ; const char* origin ; const char* protocol ; int ietf_version_or_minus_one ; void* userdata ; const void* client_exts ; const char* method ; struct lws* parent_wsi ; const char* uri_replace_from ; const char* uri_replace_to ; struct lws_vhost* vhost ; struct lws** pwsi ; const char* iface ; const char* local_protocol_name ; const char* alpn ; void* _unused [ 4 ] ; } ; LWS_VISIBLE LWS_EXTERN struct lws*)",
    "insertText": "lws_client_connect_via_info(struct lws_client_connect_info * ccinfo)"
  },
  {
    "label": "lws_client_connect()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws* LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_client_connect(struct lws_context *clients, const char *address, int port, int ssl_connection, const char *path, const char *host, const char *origin, const char *protocol, int ietf_version_or_minus_one)"
  },
  {
    "label": "lws_client_connect_extended()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws* LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_client_connect_extended(struct lws_context *clients, const char *address, int port, int ssl_connection, const char *path, const char *host, const char *origin, const char *protocol, int ietf_version_or_minus_one, void *userdata)"
  },
  {
    "label": "lws_init_vhost_client_ssl()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_init_vhost_client_ssl(const struct lws_context_creation_info *info, struct lws_vhost *vhost)"
  },
  {
    "label": "lws_http_client_read()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_http_client_read(struct lws *wsi, char **buf, int *len)"
  },
  {
    "label": "lws_http_client_http_response()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN unsigned int)",
    "insertText": "lws_http_client_http_response(struct lws *wsi)"
  },
  {
    "label": "lws_client_http_body_pending()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_client_http_body_pending(struct lws *wsi, int something_left_to_send)"
  },
  {
    "label": "lws_service()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_service(struct lws_context *context, int timeout_ms)"
  },
  {
    "label": "lws_service_tsi()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_service_tsi(struct lws_context *context, int timeout_ms, int tsi)"
  },
  {
    "label": "lws_cancel_service_pt()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_cancel_service_pt(struct lws *wsi)"
  },
  {
    "label": "lws_cancel_service()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_cancel_service(struct lws_context *context)"
  },
  {
    "label": "lws_service_fd()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_service_fd(struct lws_context *context, struct lws_pollfd *pollfd)"
  },
  {
    "label": "lws_service_fd_tsi()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_service_fd_tsi(struct lws_context *context, struct lws_pollfd *pollfd, int tsi)"
  },
  {
    "label": "lws_service_adjust_timeout()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_service_adjust_timeout(struct lws_context *context, int timeout_ms, int tsi)"
  },
  {
    "label": "lws_handle_POLLOUT_event()",
    "kind": "Method",
    "detail": "Function (# define lws_plat_service_tsi lws_service_tsi LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_handle_POLLOUT_event(struct lws *wsi, struct lws_pollfd *pollfd)"
  },
  {
    "label": "lws_get_mimetype()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char*)",
    "insertText": "lws_get_mimetype(const char *file, const struct lws_http_mount *m)"
  },
  {
    "label": "lws_serve_http_file()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_serve_http_file(struct lws *wsi, const char *file, const char *content_type, const char *other_headers, int other_headers_len)"
  },
  {
    "label": "lws_serve_http_file_fragment()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_serve_http_file_fragment(struct lws *wsi)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (enum http_status { HTTP_STATUS_CONTINUE = 1 0 0,HTTP_STATUS_OK = 2 0 0,HTTP_STATUS_NO_CONTENT = 2 0 4,HTTP_STATUS_PARTIAL_CONTENT = 2 0 6,HTTP_STATUS_MOVED_PERMANENTLY = 3 0 1,HTTP_STATUS_FOUND = 3 0 2,HTTP_STATUS_SEE_OTHER = 3 0 3,HTTP_STATUS_NOT_MODIFIED = 3 0 4,HTTP_STATUS_BAD_REQUEST = 4 0 0,HTTP_STATUS_UNAUTHORIZED,HTTP_STATUS_PAYMENT_REQUIRED,HTTP_STATUS_FORBIDDEN,HTTP_STATUS_NOT_FOUND,HTTP_STATUS_METHOD_NOT_ALLOWED,HTTP_STATUS_NOT_ACCEPTABLE,HTTP_STATUS_PROXY_AUTH_REQUIRED,HTTP_STATUS_REQUEST_TIMEOUT,HTTP_STATUS_CONFLICT,HTTP_STATUS_GONE,HTTP_STATUS_LENGTH_REQUIRED,HTTP_STATUS_PRECONDITION_FAILED,HTTP_STATUS_REQ_ENTITY_TOO_LARGE,HTTP_STATUS_REQ_URI_TOO_LONG,HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,HTTP_STATUS_REQ_RANGE_NOT_SATISFIABLE,HTTP_STATUS_EXPECTATION_FAILED,HTTP_STATUS_INTERNAL_SERVER_ERROR = 5 0 0,HTTP_STATUS_NOT_IMPLEMENTED,HTTP_STATUS_BAD_GATEWAY,HTTP_STATUS_SERVICE_UNAVAILABLE,HTTP_STATUS_GATEWAY_TIMEOUT,HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED,} ; struct lws_process_html_args { char* p ; int len ; int max_len ; int final ; int chunked ; } ; typedef const)",
    "insertText": "char(*lws_process_html_state_cb)(void *data, int index)"
  },
  {
    "label": "lws_chunked_html_process()",
    "kind": "Method",
    "detail": "Function (struct lws_process_html_state { char* start ; char swallow [ 1 6 ] ; int pos ; void* data ; const char* const* vars ; int count_vars ; lws_process_html_state_cb replace ; } ; LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_chunked_html_process(struct lws_process_html_args *args, struct lws_process_html_state *s)"
  },
  {
    "label": "lws_token_to_string()",
    "kind": "Method",
    "detail": "Function (struct lws_tokens { char* token ; int len ; } ; enum lws_token_indexes { WSI_TOKEN_GET_URI = 0,WSI_TOKEN_POST_URI = 1,WSI_TOKEN_OPTIONS_URI = 2,WSI_TOKEN_HOST = 3,WSI_TOKEN_CONNECTION = 4,WSI_TOKEN_UPGRADE = 5,WSI_TOKEN_ORIGIN = 6,WSI_TOKEN_DRAFT = 7,WSI_TOKEN_CHALLENGE = 8,WSI_TOKEN_EXTENSIONS = 9,WSI_TOKEN_KEY1 = 1 0,WSI_TOKEN_KEY2 = 1 1,WSI_TOKEN_PROTOCOL = 1 2,WSI_TOKEN_ACCEPT = 1 3,WSI_TOKEN_NONCE = 1 4,WSI_TOKEN_HTTP = 1 5,WSI_TOKEN_HTTP2_SETTINGS = 1 6,WSI_TOKEN_HTTP_ACCEPT = 1 7,WSI_TOKEN_HTTP_AC_REQUEST_HEADERS = 1 8,WSI_TOKEN_HTTP_IF_MODIFIED_SINCE = 1 9,WSI_TOKEN_HTTP_IF_NONE_MATCH = 2 0,WSI_TOKEN_HTTP_ACCEPT_ENCODING = 2 1,WSI_TOKEN_HTTP_ACCEPT_LANGUAGE = 2 2,WSI_TOKEN_HTTP_PRAGMA = 2 3,WSI_TOKEN_HTTP_CACHE_CONTROL = 2 4,WSI_TOKEN_HTTP_AUTHORIZATION = 2 5,WSI_TOKEN_HTTP_COOKIE = 2 6,WSI_TOKEN_HTTP_CONTENT_LENGTH = 2 7,WSI_TOKEN_HTTP_CONTENT_TYPE = 2 8,WSI_TOKEN_HTTP_DATE = 2 9,WSI_TOKEN_HTTP_RANGE = 3 0,WSI_TOKEN_HTTP_REFERER = 3 1,WSI_TOKEN_KEY = 3 2,WSI_TOKEN_VERSION = 3 3,WSI_TOKEN_SWORIGIN = 3 4,WSI_TOKEN_HTTP_COLON_AUTHORITY = 3 5,WSI_TOKEN_HTTP_COLON_METHOD = 3 6,WSI_TOKEN_HTTP_COLON_PATH = 3 7,WSI_TOKEN_HTTP_COLON_SCHEME = 3 8,WSI_TOKEN_HTTP_COLON_STATUS = 3 9,WSI_TOKEN_HTTP_ACCEPT_CHARSET = 4 0,WSI_TOKEN_HTTP_ACCEPT_RANGES = 4 1,WSI_TOKEN_HTTP_ACCESS_CONTROL_ALLOW_ORIGIN = 4 2,WSI_TOKEN_HTTP_AGE = 4 3,WSI_TOKEN_HTTP_ALLOW = 4 4,WSI_TOKEN_HTTP_CONTENT_DISPOSITION = 4 5,WSI_TOKEN_HTTP_CONTENT_ENCODING = 4 6,WSI_TOKEN_HTTP_CONTENT_LANGUAGE = 4 7,WSI_TOKEN_HTTP_CONTENT_LOCATION = 4 8,WSI_TOKEN_HTTP_CONTENT_RANGE = 4 9,WSI_TOKEN_HTTP_ETAG = 5 0,WSI_TOKEN_HTTP_EXPECT = 5 1,WSI_TOKEN_HTTP_EXPIRES = 5 2,WSI_TOKEN_HTTP_FROM = 5 3,WSI_TOKEN_HTTP_IF_MATCH = 5 4,WSI_TOKEN_HTTP_IF_RANGE = 5 5,WSI_TOKEN_HTTP_IF_UNMODIFIED_SINCE = 5 6,WSI_TOKEN_HTTP_LAST_MODIFIED = 5 7,WSI_TOKEN_HTTP_LINK = 5 8,WSI_TOKEN_HTTP_LOCATION = 5 9,WSI_TOKEN_HTTP_MAX_FORWARDS = 6 0,WSI_TOKEN_HTTP_PROXY_AUTHENTICATE = 6 1,WSI_TOKEN_HTTP_PROXY_AUTHORIZATION = 6 2,WSI_TOKEN_HTTP_REFRESH = 6 3,WSI_TOKEN_HTTP_RETRY_AFTER = 6 4,WSI_TOKEN_HTTP_SERVER = 6 5,WSI_TOKEN_HTTP_SET_COOKIE = 6 6,WSI_TOKEN_HTTP_STRICT_TRANSPORT_SECURITY = 6 7,WSI_TOKEN_HTTP_TRANSFER_ENCODING = 6 8,WSI_TOKEN_HTTP_USER_AGENT = 6 9,WSI_TOKEN_HTTP_VARY = 7 0,WSI_TOKEN_HTTP_VIA = 7 1,WSI_TOKEN_HTTP_WWW_AUTHENTICATE = 7 2,WSI_TOKEN_PATCH_URI = 7 3,WSI_TOKEN_PUT_URI = 7 4,WSI_TOKEN_DELETE_URI = 7 5,WSI_TOKEN_HTTP_URI_ARGS = 7 6,WSI_TOKEN_PROXY = 7 7,WSI_TOKEN_HTTP_X_REAL_IP = 7 8,WSI_TOKEN_HTTP1_0 = 7 9,WSI_TOKEN_X_FORWARDED_FOR = 8 0,WSI_TOKEN_CONNECT = 8 1,WSI_TOKEN_HEAD_URI = 8 2,WSI_TOKEN_TE = 8 3,WSI_TOKEN_REPLAY_NONCE = 8 4,WSI_TOKEN_COLON_PROTOCOL = 8 5,WSI_TOKEN_X_AUTH_TOKEN = 8 6,_WSI_TOKEN_CLIENT_SENT_PROTOCOLS,_WSI_TOKEN_CLIENT_PEER_ADDRESS,_WSI_TOKEN_CLIENT_URI,_WSI_TOKEN_CLIENT_HOST,_WSI_TOKEN_CLIENT_ORIGIN,_WSI_TOKEN_CLIENT_METHOD,_WSI_TOKEN_CLIENT_IFACE,_WSI_TOKEN_CLIENT_ALPN,WSI_TOKEN_COUNT,WSI_TOKEN_NAME_PART,WSI_TOKEN_SKIPPING,WSI_TOKEN_SKIPPING_SAW_CR,WSI_PARSING_COMPLETE,WSI_INIT_TOKEN_MUXURL,} ; struct lws_token_limits { unsigned short token_limit [ WSI_TOKEN_COUNT ] ; } ; LWS_VISIBLE LWS_EXTERN const unsigned char*)",
    "insertText": "lws_token_to_string(enum lws_token_indexes token)"
  },
  {
    "label": "lws_hdr_total_length()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_hdr_total_length(struct lws *wsi, enum lws_token_indexes h)"
  },
  {
    "label": "lws_hdr_fragment_length()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_hdr_fragment_length(struct lws *wsi, enum lws_token_indexes h, int frag_idx)"
  },
  {
    "label": "lws_hdr_copy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_hdr_copy(struct lws *wsi, char *dest, int len, enum lws_token_indexes h)"
  },
  {
    "label": "lws_hdr_copy_fragment()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_hdr_copy_fragment(struct lws *wsi, char *dest, int len, enum lws_token_indexes h, int frag_idx)"
  },
  {
    "label": "lws_get_urlarg_by_name()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char*)",
    "insertText": "lws_get_urlarg_by_name(struct lws *wsi, const char *name, char *buf, int len)"
  },
  {
    "label": "LWSAHH_CODE_MASK()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "LWSAHH_CODE_MASK((1 << 16) - 1) #define LWSAHH_FLAG_NO_SERVER_NAME (1 << 30) LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT lws_add_http_header_status(struct lws *wsi, unsigned int code, unsigned char **p, unsigned char *end)"
  },
  {
    "label": "lws_add_http_header_by_name()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_add_http_header_by_name(struct lws *wsi, const unsigned char *name, const unsigned char *value, int length, unsigned char **p, unsigned char *end)"
  },
  {
    "label": "lws_add_http_header_by_token()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_add_http_header_by_token(struct lws *wsi, enum lws_token_indexes token, const unsigned char *value, int length, unsigned char **p, unsigned char *end)"
  },
  {
    "label": "lws_add_http_header_content_length()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_add_http_header_content_length(struct lws *wsi, lws_filepos_t content_length, unsigned char **p, unsigned char *end)"
  },
  {
    "label": "lws_finalize_http_header()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_finalize_http_header(struct lws *wsi, unsigned char **p, unsigned char *end)"
  },
  {
    "label": "lws_finalize_write_http_header()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_finalize_write_http_header(struct lws *wsi, unsigned char *start, unsigned char **p, unsigned char *end)"
  },
  {
    "label": "LWS_ILLEGAL_HTTP_CONTENT_LEN()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "LWS_ILLEGAL_HTTP_CONTENT_LEN((lws_filepos_t)-1ll) LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT lws_add_http_common_headers(struct lws *wsi, unsigned int code, const char *content_type, lws_filepos_t content_len, unsigned char **p, unsigned char *end)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (enum lws_spa_fileupload_states { LWS_UFS_CONTENT,LWS_UFS_FINAL_CONTENT,LWS_UFS_OPEN } ; typedef)",
    "insertText": "int(*lws_spa_fileupload_cb)(void *data, const char *name, const char *filename, char *buf, int len, enum lws_spa_fileupload_states state)"
  },
  {
    "label": "lws_spa_create()",
    "kind": "Method",
    "detail": "Function (struct lws_spa ; LWS_VISIBLE LWS_EXTERN struct lws_spa*)",
    "insertText": "lws_spa_create(struct lws *wsi, const char * const *param_names, int count_params, int max_storage, lws_spa_fileupload_cb opt_cb, void *opt_data)"
  },
  {
    "label": "lws_spa_process()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_spa_process(struct lws_spa *spa, const char *in, int len)"
  },
  {
    "label": "lws_spa_finalize()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_spa_finalize(struct lws_spa *spa)"
  },
  {
    "label": "lws_spa_get_length()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_spa_get_length(struct lws_spa *spa, int n)"
  },
  {
    "label": "lws_spa_get_string()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char*)",
    "insertText": "lws_spa_get_string(struct lws_spa *spa, int n)"
  },
  {
    "label": "lws_spa_destroy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_spa_destroy(struct lws_spa *spa)"
  },
  {
    "label": "lws_urlencode()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char*)",
    "insertText": "lws_urlencode(char *escaped, const char *string, int len)"
  },
  {
    "label": "lws_urldecode()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_urldecode(char *string, const char *escaped, int len)"
  },
  {
    "label": "lws_return_http_status()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_return_http_status(struct lws *wsi, unsigned int code, const char *html_body)"
  },
  {
    "label": "lws_http_redirect()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_http_redirect(struct lws *wsi, int code, const unsigned char *loc, int len, unsigned char **p, unsigned char *end)"
  },
  {
    "label": "lws_http_transaction_completed()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_http_transaction_completed(struct lws *wsi)"
  },
  {
    "label": "lws_sql_purify()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char*)",
    "insertText": "lws_sql_purify(char *escaped, const char *string, int len)"
  },
  {
    "label": "lws_json_purify()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char*)",
    "insertText": "lws_json_purify(char *escaped, const char *string, int len)"
  },
  {
    "label": "lws_filename_purify_inplace()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_filename_purify_inplace(char *filename)"
  },
  {
    "label": "lws_plat_write_cert()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_plat_write_cert(struct lws_vhost *vhost, int is_key, int fd, void *buf, int len)"
  },
  {
    "label": "lws_plat_write_file()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_plat_write_file(const char *filename, void *buf, int len)"
  },
  {
    "label": "lws_plat_read_file()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_plat_read_file(const char *filename, void *buf, int len)"
  },
  {
    "label": "lws_plat_recommended_rsa_bits()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_plat_recommended_rsa_bits(void)"
  },
  {
    "label": "lws_uv_getloop()",
    "kind": "Method",
    "detail": "Function (# ifdef LWS_WITH_LIBUV LWS_VISIBLE LWS_EXTERN uv_loop_t*)",
    "insertText": "lws_uv_getloop(struct lws_context *context, int tsi)"
  },
  {
    "label": "lws_libuv_static_refcount_add()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_libuv_static_refcount_add(uv_handle_t *, struct lws_context *context)"
  },
  {
    "label": "lws_libuv_static_refcount_del()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_libuv_static_refcount_del(uv_handle_t *)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "defined(LWS_WITH_ESP32) #define lws_libuv_static_refcount_add(_a, _b)"
  },
  {
    "label": "lws_set_timeout()",
    "kind": "Method",
    "detail": "Function (NO_PENDING_TIMEOUT = 0,PENDING_TIMEOUT_AWAITING_PROXY_RESPONSE = 1,PENDING_TIMEOUT_AWAITING_CONNECT_RESPONSE = 2,PENDING_TIMEOUT_ESTABLISH_WITH_SERVER = 3,PENDING_TIMEOUT_AWAITING_SERVER_RESPONSE = 4,PENDING_TIMEOUT_AWAITING_PING = 5,PENDING_TIMEOUT_CLOSE_ACK = 6,PENDING_TIMEOUT_UNUSED1 = 7,PENDING_TIMEOUT_SENT_CLIENT_HANDSHAKE = 8,PENDING_TIMEOUT_SSL_ACCEPT = 9,PENDING_TIMEOUT_HTTP_CONTENT = 1 0,PENDING_TIMEOUT_AWAITING_CLIENT_HS_SEND = 1 1,PENDING_FLUSH_STORED_SEND_BEFORE_CLOSE = 1 2,PENDING_TIMEOUT_SHUTDOWN_FLUSH = 1 3,PENDING_TIMEOUT_CGI = 1 4,PENDING_TIMEOUT_HTTP_KEEPALIVE_IDLE = 1 5,PENDING_TIMEOUT_WS_PONG_CHECK_SEND_PING = 1 6,PENDING_TIMEOUT_WS_PONG_CHECK_GET_PONG = 1 7,PENDING_TIMEOUT_CLIENT_ISSUE_PAYLOAD = 1 8,PENDING_TIMEOUT_AWAITING_SOCKS_GREETING_REPLY = 1 9,PENDING_TIMEOUT_AWAITING_SOCKS_CONNECT_REPLY = 2 0,PENDING_TIMEOUT_AWAITING_SOCKS_AUTH_REPLY = 2 1,PENDING_TIMEOUT_KILLED_BY_SSL_INFO = 2 2,PENDING_TIMEOUT_KILLED_BY_PARENT = 2 3,PENDING_TIMEOUT_CLOSE_SEND = 2 4,PENDING_TIMEOUT_HOLDING_AH = 2 5,PENDING_TIMEOUT_UDP_IDLE = 2 6,PENDING_TIMEOUT_CLIENT_CONN_IDLE = 2 7,PENDING_TIMEOUT_LAGGING = 2 8,PENDING_TIMEOUT_USER_REASON_BASE = 1 0 0 0 } ; # define LWS_TO_KILL_ASYNC - 1 # define LWS_TO_KILL_SYNC - 2 LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_set_timeout(struct lws *wsi, enum pending_timeout reason, int secs)"
  },
  {
    "label": "LWS_SET_TIMER_USEC_CANCEL()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "LWS_SET_TIMER_USEC_CANCEL((lws_usec_t)-1ll) #define LWS_USEC_PER_SEC (1000000ll) LWS_VISIBLE LWS_EXTERN void lws_set_timer_usecs(struct lws *wsi, lws_usec_t usecs)"
  },
  {
    "label": "lws_timed_callback_vh_protocol()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_timed_callback_vh_protocol(struct lws_vhost *vh, const struct lws_protocols *prot, int reason, int secs)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(LWS_SIZEOFPTR) #define LWS_SIZEOFPTR ((int)sizeof (void *)) #endif #if defined(__x86_64__) #define _LWS_PAD_SIZE 16 #else #define _LWS_PAD_SIZE LWS_SIZEOFPTR #endif #define _LWS_PAD(n) (((n) % _LWS_PAD_SIZE) ? \\ ((n) + (_LWS_PAD_SIZE - ((n) % _LWS_PAD_SIZE))) : (n)) #define LWS_PRE _LWS_PAD(4 + 10 + 2)"
  },
  {
    "label": "lws_write()",
    "kind": "Method",
    "detail": "Function (LWS_WRITE_TEXT = 0,LWS_WRITE_BINARY = 1,LWS_WRITE_CONTINUATION = 2,LWS_WRITE_HTTP = 3,LWS_WRITE_PING = 5,LWS_WRITE_PONG = 6,LWS_WRITE_HTTP_FINAL = 7,LWS_WRITE_HTTP_HEADERS = 8,LWS_WRITE_HTTP_HEADERS_CONTINUATION = 9,LWS_WRITE_NO_FIN = 0 x40,LWS_WRITE_H2_STREAM_END = 0 x80,LWS_WRITE_CLIENT_IGNORE_XOR_MASK = 0 x80 } ; struct lws_write_passthru { struct lws* wsi ; unsigned char* buf ; size_t len ; enum lws_write_protocol wp ; } ; LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_write(struct lws *wsi, unsigned char *buf, size_t len, enum lws_write_protocol protocol)"
  },
  {
    "label": "lws_write_http()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "lws_write_http(wsi, buf, len) \\ lws_write(wsi, (unsigned char *)(buf), len, LWS_WRITE_HTTP) static LWS_INLINE int lws_write_ws_flags(int initial, int is_start, int is_end)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int r ;)",
    "insertText": "if(is_start)"
  },
  {
    "label": "lws_callback_on_writable_all_protocol()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_callback_on_writable_all_protocol(const struct lws_context *context, const struct lws_protocols *protocol)"
  },
  {
    "label": "lws_callback_on_writable_all_protocol_vhost()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_callback_on_writable_all_protocol_vhost(const struct lws_vhost *vhost, const struct lws_protocols *protocol)"
  },
  {
    "label": "lws_callback_all_protocol()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_callback_all_protocol(struct lws_context *context, const struct lws_protocols *protocol, int reason)"
  },
  {
    "label": "lws_callback_all_protocol_vhost()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_callback_all_protocol_vhost(struct lws_vhost *vh, const struct lws_protocols *protocol, int reason)"
  },
  {
    "label": "lws_callback_all_protocol_vhost_args()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE int)",
    "insertText": "lws_callback_all_protocol_vhost_args(struct lws_vhost *vh, const struct lws_protocols *protocol, int reason, void *argp, size_t len)"
  },
  {
    "label": "lws_callback_vhost_protocols()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_callback_vhost_protocols(struct lws *wsi, int reason, void *in, int len)"
  },
  {
    "label": "lws_callback_vhost_protocols_vhost()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_callback_vhost_protocols_vhost(struct lws_vhost *vh, int reason, void *in, size_t len)"
  },
  {
    "label": "lws_callback_http_dummy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_callback_http_dummy(struct lws *wsi, enum lws_callback_reasons reason, void *user, void *in, size_t len)"
  },
  {
    "label": "lws_get_socket_fd()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN lws_sockfd_type)",
    "insertText": "lws_get_socket_fd(struct lws *wsi)"
  },
  {
    "label": "lws_get_peer_write_allowance()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN lws_fileofs_t)",
    "insertText": "lws_get_peer_write_allowance(struct lws *wsi)"
  },
  {
    "label": "LWS_RXFLOW_REASON_USER_BOOL()",
    "kind": "Method",
    "detail": "Function (enum {)",
    "insertText": "LWS_RXFLOW_REASON_USER_BOOL(1 << 0), LWS_RXFLOW_REASON_HTTP_RXBUFFER = (1 << 6), LWS_RXFLOW_REASON_H2_PPS_PENDING = (1 << 7), LWS_RXFLOW_REASON_APPLIES = (1 << 14), LWS_RXFLOW_REASON_APPLIES_ENABLE_BIT = (1 << 13), LWS_RXFLOW_REASON_APPLIES_ENABLE = LWS_RXFLOW_REASON_APPLIES | LWS_RXFLOW_REASON_APPLIES_ENABLE_BIT, LWS_RXFLOW_REASON_APPLIES_DISABLE = LWS_RXFLOW_REASON_APPLIES, LWS_RXFLOW_REASON_FLAG_PROCESS_NOW = (1 << 12)"
  },
  {
    "label": "lws_rx_flow_control()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_rx_flow_control(struct lws *wsi, int enable)"
  },
  {
    "label": "lws_rx_flow_allow_all_protocol()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_rx_flow_allow_all_protocol(const struct lws_context *context, const struct lws_protocols *protocol)"
  },
  {
    "label": "lws_remaining_packet_payload()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN size_t)",
    "insertText": "lws_remaining_packet_payload(struct lws *wsi)"
  },
  {
    "label": "lws_adopt_socket()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws*)",
    "insertText": "lws_adopt_socket(struct lws_context *context, lws_sockfd_type accept_fd)"
  },
  {
    "label": "lws_adopt_socket_vhost()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws*)",
    "insertText": "lws_adopt_socket_vhost(struct lws_vhost *vh, lws_sockfd_type accept_fd)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (typedef enum { LWS_ADOPT_RAW_FILE_DESC = 0,LWS_ADOPT_HTTP = 1,LWS_ADOPT_SOCKET = 2,LWS_ADOPT_ALLOW_SSL = 4,LWS_ADOPT_WS_PARENTIO = 8,LWS_ADOPT_FLAG_UDP = 1 6,LWS_ADOPT_RAW_SOCKET_UDP = LWS_ADOPT_SOCKET | LWS_ADOPT_FLAG_UDP,} lws_adoption_type ; typedef union { lws_sockfd_type sockfd ; lws_filefd_type filefd ; } lws_sock_file_fd_type ; # if !)",
    "insertText": "defined(LWS_WITH_ESP32)"
  },
  {
    "label": "lws_adopt_descriptor_vhost()",
    "kind": "Method",
    "detail": "Function (struct sockaddr sa ; socklen_t salen ; struct sockaddr sa_pending ; socklen_t salen_pending ; } ; # endif LWS_VISIBLE LWS_EXTERN struct lws*)",
    "insertText": "lws_adopt_descriptor_vhost(struct lws_vhost *vh, lws_adoption_type type, lws_sock_file_fd_type fd, const char *vh_prot_name, struct lws *parent)"
  },
  {
    "label": "lws_adopt_socket_readbuf()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws*)",
    "insertText": "lws_adopt_socket_readbuf(struct lws_context *context, lws_sockfd_type accept_fd, const char *readbuf, size_t len)"
  },
  {
    "label": "lws_adopt_socket_vhost_readbuf()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws*)",
    "insertText": "lws_adopt_socket_vhost_readbuf(struct lws_vhost *vhost, lws_sockfd_type accept_fd, const char *readbuf, size_t len)"
  },
  {
    "label": "lws_create_adopt_udp()",
    "kind": "Method",
    "detail": "Function (# define LWS_CAUDP_BIND 1 LWS_VISIBLE LWS_EXTERN struct lws*)",
    "insertText": "lws_create_adopt_udp(struct lws_vhost *vhost, int port, int flags, const char *protocol_name, struct lws *parent_wsi)"
  },
  {
    "label": "lws_canonical_hostname()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char* LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_canonical_hostname(struct lws_context *context)"
  },
  {
    "label": "lws_get_peer_addresses()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_get_peer_addresses(struct lws *wsi, lws_sockfd_type fd, char *name, int name_len, char *rip, int rip_len)"
  },
  {
    "label": "lws_get_peer_simple()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char*)",
    "insertText": "lws_get_peer_simple(struct lws *wsi, char *name, int namelen)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# define LWS_ITOSA_NOT_EXIST - 1 # define LWS_ITOSA_NOT_USABLE - 2 # define LWS_ITOSA_USABLE 0 # if !)",
    "insertText": "defined(LWS_WITH_ESP32) LWS_VISIBLE LWS_EXTERN int lws_interface_to_sa(int ipv6, const char *ifname, struct sockaddr_in *addr, size_t addrlen)"
  },
  {
    "label": "lws_start_foreach_ll()",
    "kind": "Method",
    "detail": "Function (# endif # define)",
    "insertText": "lws_start_foreach_ll(type, it, start)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ type it = start ; \\)",
    "insertText": "while(it)"
  },
  {
    "label": "lws_end_foreach_ll()",
    "kind": "Method",
    "detail": "Function (nxt)",
    "insertText": "lws_end_foreach_ll(it, nxt)"
  },
  {
    "label": "lws_start_foreach_llp()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # define)",
    "insertText": "lws_start_foreach_llp(type, it, start)"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (\\ type)",
    "insertText": "it(start)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "while(*(it))"
  },
  {
    "label": "lws_start_foreach_llp_safe()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "lws_start_foreach_llp_safe(type, it, start, nxt)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "next((*(it))->nxt)"
  },
  {
    "label": "lws_end_foreach_llp()",
    "kind": "Method",
    "detail": "Function (nxt)",
    "insertText": "lws_end_foreach_llp(it, nxt) \\ it = &(*(it))"
  },
  {
    "label": "lws_end_foreach_llp_safe()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # define)",
    "insertText": "lws_end_foreach_llp_safe(it)"
  },
  {
    "label": "lws_ll_fwd_insert()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # define)",
    "insertText": "lws_ll_fwd_insert(\\ ___new_object, \\ ___m_list, \\ ___list_head \\)"
  },
  {
    "label": "lws_ll_fwd_remove()",
    "kind": "Method",
    "detail": "Function (\\ ___new_object -> ___m_list = ___list_head ; \\ ___list_head = ___new_object ; \\ } # define)",
    "insertText": "lws_ll_fwd_remove(\\ ___type, \\ ___m_list, \\ ___target, \\ ___list_head \\)"
  },
  {
    "label": "lws_start_foreach_llp()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "lws_start_foreach_llp(___type **, ___ppss, ___list_head)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(*___ppss == ___target)"
  },
  {
    "label": "lws_end_foreach_llp()",
    "kind": "Method",
    "detail": "Function (\\* ___ppss = ___target -> ___m_list ; \\ break ; \\ } \\ })",
    "insertText": "lws_end_foreach_llp(___ppss, ___m_list)"
  },
  {
    "label": "lws_dll_add_front()",
    "kind": "Method",
    "detail": "Function (\\ } struct lws_dll { struct lws_dll* prev ; struct lws_dll* next ; } ; LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_dll_add_front(struct lws_dll *d, struct lws_dll *phead)"
  },
  {
    "label": "lws_dll_remove()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_dll_remove(struct lws_dll *d)"
  },
  {
    "label": "lws_dll_is_null()",
    "kind": "Method",
    "detail": "Function (struct lws_dll_lws { struct lws_dll_lws* prev ; struct lws_dll_lws* next ; } ; # define)",
    "insertText": "lws_dll_is_null(___dll) (!(___dll)->prev && !(___dll)->next) static LWS_INLINE void lws_dll_lws_add_front(struct lws_dll_lws *_a, struct lws_dll_lws *_head)"
  },
  {
    "label": "lws_dll_add_front()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "lws_dll_add_front((struct lws_dll *)_a, (struct lws_dll *)_head)"
  },
  {
    "label": "lws_dll_lws_remove()",
    "kind": "Method",
    "detail": "Function (} LWS_INLINE void)",
    "insertText": "lws_dll_lws_remove(struct lws_dll_lws *_a)"
  },
  {
    "label": "lws_dll_remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "lws_dll_remove((struct lws_dll *)_a)"
  },
  {
    "label": "lws_start_foreach_dll_safe()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "lws_start_foreach_dll_safe(___type, ___it, ___tmp, ___start)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ ___type ___it = ___start ; \\)",
    "insertText": "while(___it)"
  },
  {
    "label": "___tmp()",
    "kind": "Method",
    "detail": "Function (next)",
    "insertText": "___tmp(___it)"
  },
  {
    "label": "lws_end_foreach_dll_safe()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "lws_end_foreach_dll_safe(___it, ___tmp)"
  },
  {
    "label": "lws_start_foreach_dll()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # define)",
    "insertText": "lws_start_foreach_dll(___type, ___it, ___start)"
  },
  {
    "label": "lws_end_foreach_dll()",
    "kind": "Method",
    "detail": "Function (next)",
    "insertText": "lws_end_foreach_dll(___it) \\ ___it = (___it)"
  },
  {
    "label": "lws_buflist_append_segment()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } struct lws_buflist ; LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_buflist_append_segment(struct lws_buflist **head, const uint8_t *buf, size_t len)"
  },
  {
    "label": "lws_buflist_next_segment_len()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN size_t)",
    "insertText": "lws_buflist_next_segment_len(struct lws_buflist **head, uint8_t **buf)"
  },
  {
    "label": "lws_buflist_use_segment()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_buflist_use_segment(struct lws_buflist **head, size_t len)"
  },
  {
    "label": "lws_buflist_destroy_all_segments()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_buflist_destroy_all_segments(struct lws_buflist **head)"
  },
  {
    "label": "lws_buflist_describe()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "lws_buflist_describe(struct lws_buflist **head, void *id)"
  },
  {
    "label": "lws_ptr_diff()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "lws_ptr_diff(head, tail) \\ ((int)((char *)(head) - (char *)(tail))) LWS_VISIBLE LWS_EXTERN int lws_snprintf(char *str, size_t size, const char *format, ...) LWS_FORMAT(3)"
  },
  {
    "label": "lws_strncpy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN char*)",
    "insertText": "lws_strncpy(char *dest, const char *src, size_t size)"
  },
  {
    "label": "lws_get_random()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_get_random(struct lws_context *context, void *buf, int len)"
  },
  {
    "label": "lws_daemonize()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_daemonize(const char *_lock_path)"
  },
  {
    "label": "lws_get_library_version()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char* LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_get_library_version(void)"
  },
  {
    "label": "lws_wsi_user()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void*)",
    "insertText": "lws_wsi_user(struct lws *wsi)"
  },
  {
    "label": "lws_set_wsi_user()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_set_wsi_user(struct lws *wsi, void *user)"
  },
  {
    "label": "lws_parse_uri()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_parse_uri(char *p, const char **prot, const char **ads, int *port, const char **path)"
  },
  {
    "label": "lws_cmdline_option()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const char*)",
    "insertText": "lws_cmdline_option(int argc, const char **argv, const char *val)"
  },
  {
    "label": "lws_now_secs()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN unsigned long)",
    "insertText": "lws_now_secs(void)"
  },
  {
    "label": "lws_compare_time_t()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_compare_time_t(struct lws_context *context, time_t t1, time_t t2)"
  },
  {
    "label": "lws_get_context()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws_context* LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_get_context(const struct lws *wsi)"
  },
  {
    "label": "lws_get_vhost_listen_port()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_get_vhost_listen_port(struct lws_vhost *vhost)"
  },
  {
    "label": "lws_get_count_threads()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_get_count_threads(struct lws_context *context)"
  },
  {
    "label": "lws_get_parent()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws* LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_get_parent(const struct lws *wsi)"
  },
  {
    "label": "lws_get_child()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws* LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_get_child(const struct lws *wsi)"
  },
  {
    "label": "lws_get_udp()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const struct lws_udp* LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_get_udp(const struct lws *wsi)"
  },
  {
    "label": "lws_set_parent_carries_io()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_set_parent_carries_io(struct lws *wsi)"
  },
  {
    "label": "lws_get_opaque_parent_data()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void*)",
    "insertText": "lws_get_opaque_parent_data(const struct lws *wsi)"
  },
  {
    "label": "lws_set_opaque_parent_data()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_set_opaque_parent_data(struct lws *wsi, void *data)"
  },
  {
    "label": "lws_get_child_pending_on_writable()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_get_child_pending_on_writable(const struct lws *wsi)"
  },
  {
    "label": "lws_clear_child_pending_on_writable()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_clear_child_pending_on_writable(struct lws *wsi)"
  },
  {
    "label": "lws_get_close_length()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_get_close_length(struct lws *wsi)"
  },
  {
    "label": "lws_get_close_payload()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN unsigned char*)",
    "insertText": "lws_get_close_payload(struct lws *wsi)"
  },
  {
    "label": "lws_get_network_wsi()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws*)",
    "insertText": "lws_get_network_wsi(struct lws *wsi)"
  },
  {
    "label": "lws_set_allocator()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_set_allocator(void *(*realloc)(void *ptr, size_t size, const char *reason))"
  },
  {
    "label": "lws_send_pipe_choked()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_send_pipe_choked(struct lws *wsi)"
  },
  {
    "label": "lws_is_final_fragment()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_is_final_fragment(struct lws *wsi)"
  },
  {
    "label": "lws_is_first_fragment()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_is_first_fragment(struct lws *wsi)"
  },
  {
    "label": "lws_get_reserved_bits()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN unsigned char)",
    "insertText": "lws_get_reserved_bits(struct lws *wsi)"
  },
  {
    "label": "lws_partial_buffered()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_partial_buffered(struct lws *wsi)"
  },
  {
    "label": "lws_frame_is_binary()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_frame_is_binary(struct lws *wsi)"
  },
  {
    "label": "lws_is_ssl()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_is_ssl(struct lws *wsi)"
  },
  {
    "label": "lws_is_cgi()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_is_cgi(struct lws *wsi)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (struct lws_wifi_scan { struct lws_wifi_scan* next ; char ssid [ 3 2 ] ; int32_t rssi ; uint8_t bssid [ 6 ] ; uint8_t count ; uint8_t channel ; uint8_t authmode ; } ; # if)",
    "insertText": "defined(LWS_WITH_TLS) && !defined(LWS_WITH_MBEDTLS) LWS_VISIBLE LWS_EXTERN SSL* lws_get_ssl(struct lws *wsi)"
  },
  {
    "label": "lws_tls_peer_cert_info()",
    "kind": "Method",
    "detail": "Function (# endif enum lws_tls_cert_info { LWS_TLS_CERT_INFO_VALIDITY_FROM,LWS_TLS_CERT_INFO_VALIDITY_TO,LWS_TLS_CERT_INFO_COMMON_NAME,LWS_TLS_CERT_INFO_ISSUER_NAME,LWS_TLS_CERT_INFO_USAGE,LWS_TLS_CERT_INFO_VERIFIED,LWS_TLS_CERT_INFO_OPAQUE_PUBLIC_KEY,} ; union lws_tls_cert_info_results { unsigned int verified ; time_t time ; unsigned int usage ; struct { int len ; char name [ 6 4 ] ; } ns ; } ; LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_tls_peer_cert_info(struct lws *wsi, enum lws_tls_cert_info type, union lws_tls_cert_info_results *buf, size_t len)"
  },
  {
    "label": "lws_tls_vhost_cert_info()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_tls_vhost_cert_info(struct lws_vhost *vhost, enum lws_tls_cert_info type, union lws_tls_cert_info_results *buf, size_t len)"
  },
  {
    "label": "lws_tls_acme_sni_cert_create()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_tls_acme_sni_cert_create(struct lws_vhost *vhost, const char *san_a, const char *san_b)"
  },
  {
    "label": "lws_tls_acme_sni_csr_create()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_tls_acme_sni_csr_create(struct lws_context *context, const char *elements[], uint8_t *csr, size_t csr_len, char **privkey_pem, size_t *privkey_len)"
  },
  {
    "label": "lws_tls_cert_updated()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_tls_cert_updated(struct lws_context *context, const char *certpath, const char *keypath, const char *mem_cert, size_t len_mem_cert, const char *mem_privkey, size_t len_mem_privkey)"
  },
  {
    "label": "lws_ring_create()",
    "kind": "Method",
    "detail": "Function (struct lws_ring ; LWS_VISIBLE LWS_EXTERN struct lws_ring*)",
    "insertText": "lws_ring_create(size_t element_len, size_t count, void (*destroy_element)(void *element))"
  },
  {
    "label": "lws_ring_destroy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_ring_destroy(struct lws_ring *ring)"
  },
  {
    "label": "lws_ring_get_count_free_elements()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN size_t)",
    "insertText": "lws_ring_get_count_free_elements(struct lws_ring *ring)"
  },
  {
    "label": "lws_ring_get_count_waiting_elements()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN size_t)",
    "insertText": "lws_ring_get_count_waiting_elements(struct lws_ring *ring, uint32_t *tail)"
  },
  {
    "label": "lws_ring_insert()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN size_t)",
    "insertText": "lws_ring_insert(struct lws_ring *ring, const void *src, size_t max_count)"
  },
  {
    "label": "lws_ring_consume()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN size_t)",
    "insertText": "lws_ring_consume(struct lws_ring *ring, uint32_t *tail, void *dest, size_t max_count)"
  },
  {
    "label": "lws_ring_get_element()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN const void*)",
    "insertText": "lws_ring_get_element(struct lws_ring *ring, uint32_t *tail)"
  },
  {
    "label": "lws_ring_update_oldest_tail()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_ring_update_oldest_tail(struct lws_ring *ring, uint32_t tail)"
  },
  {
    "label": "lws_ring_get_oldest_tail()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN uint32_t)",
    "insertText": "lws_ring_get_oldest_tail(struct lws_ring *ring)"
  },
  {
    "label": "lws_ring_next_linear_insert_range()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_ring_next_linear_insert_range(struct lws_ring *ring, void **start, size_t *bytes)"
  },
  {
    "label": "lws_ring_bump_head()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_ring_bump_head(struct lws_ring *ring, size_t bytes)"
  },
  {
    "label": "lws_ring_dump()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_ring_dump(struct lws_ring *ring, uint32_t *tail)"
  },
  {
    "label": "lws_ring_consume_and_update_oldest_tail()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "lws_ring_consume_and_update_oldest_tail(\\ ___ring, \\ ___type, \\ ___ptail, \\ ___count, \\ ___list_head, \\ ___mtail, \\ ___mlist \\)"
  },
  {
    "label": "lws_ring_get_oldest_tail()",
    "kind": "Method",
    "detail": "Function (\\ int ___n,___m ; \\ \\ ___n =)",
    "insertText": "lws_ring_get_oldest_tail(___ring) == *(___ptail)"
  },
  {
    "label": "lws_ring_consume()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "lws_ring_consume(___ring, ___ptail, NULL, ___count)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(___n)"
  },
  {
    "label": "___oldest()",
    "kind": "Method",
    "detail": "Function (\\ uint32_t ___oldest ; \\ ___n = 0 ; \\)",
    "insertText": "___oldest(___ptail)"
  },
  {
    "label": "lws_ring_get_count_waiting_elements()",
    "kind": "Method",
    "detail": "Function (\\ ___m =)",
    "insertText": "lws_ring_get_count_waiting_elements(\\ ___ring, &(*___ppss)->tail)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(___m >= ___n)"
  },
  {
    "label": "___oldest()",
    "kind": "Method",
    "detail": "Function (tail)",
    "insertText": "___oldest(*___ppss)"
  },
  {
    "label": "lws_end_foreach_llp()",
    "kind": "Method",
    "detail": "Function (\\ } \\ })",
    "insertText": "lws_end_foreach_llp(___ppss, ___mlist)"
  },
  {
    "label": "lws_ring_update_oldest_tail()",
    "kind": "Method",
    "detail": "Function (\\ \\)",
    "insertText": "lws_ring_update_oldest_tail(___ring, ___oldest)"
  },
  {
    "label": "lws_ring_consume_single_tail()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # define)",
    "insertText": "lws_ring_consume_single_tail(\\ ___ring, \\ ___ptail, \\ ___count \\)"
  },
  {
    "label": "lws_ring_update_oldest_tail()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "lws_ring_update_oldest_tail(___ring, *(___ptail))"
  },
  {
    "label": "lws_SHA1()",
    "kind": "Method",
    "detail": "Function (\\ } # ifdef LWS_SHA1_USE_OPENSSL_NAME # define lws_SHA1 SHA1 # else LWS_VISIBLE LWS_EXTERN unsigned char*)",
    "insertText": "lws_SHA1(const unsigned char *d, size_t n, unsigned char *md)"
  },
  {
    "label": "lws_b64_encode_string()",
    "kind": "Method",
    "detail": "Function (# endif LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_b64_encode_string(const char *in, int in_len, char *out, int out_size)"
  },
  {
    "label": "lws_b64_encode_string_url()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_b64_encode_string_url(const char *in, int in_len, char *out, int out_size)"
  },
  {
    "label": "lws_b64_decode_string()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_b64_decode_string(const char *in, char *out, int out_size)"
  },
  {
    "label": "lws_b64_decode_string_len()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_b64_decode_string_len(const char *in, int in_len, char *out, int out_size)"
  },
  {
    "label": "lws_cgi()",
    "kind": "Method",
    "detail": "Function (enum lws_enum_stdinouterr { LWS_STDIN = 0,LWS_STDOUT = 1,LWS_STDERR = 2,} ; enum lws_cgi_hdr_state { LCHS_HEADER,LCHS_CR1,LCHS_LF1,LCHS_CR2,LCHS_LF2,LHCS_RESPONSE,LHCS_DUMP_HEADERS,LHCS_PAYLOAD,LCHS_SINGLE_0A,} ; struct lws_cgi_args { struct lws** stdwsi ; enum lws_enum_stdinouterr ch ; unsigned char* data ; enum lws_cgi_hdr_state hdr_state ; int len ; } ; # ifdef LWS_WITH_CGI LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_cgi(struct lws *wsi, const char * const *exec_array, int script_uri_path_len, int timeout_secs, const struct lws_protocol_vhost_options *mp_cgienv)"
  },
  {
    "label": "lws_cgi_write_split_stdout_headers()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_cgi_write_split_stdout_headers(struct lws *wsi)"
  },
  {
    "label": "lws_cgi_kill()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_cgi_kill(struct lws *wsi)"
  },
  {
    "label": "lws_cgi_get_stdwsi()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN struct lws*)",
    "insertText": "lws_cgi_get_stdwsi(struct lws *wsi, enum lws_enum_stdinouterr ch)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "defined(LWS_WITH_ESP32) #define LWS_FOP_OPEN _open #define LWS_FOP_CLOSE _close #define LWS_FOP_SEEK_CUR _seek_cur #define LWS_FOP_READ _read #define LWS_FOP_WRITE _write #else #define LWS_FOP_OPEN open #define LWS_FOP_CLOSE close #define LWS_FOP_SEEK_CUR seek_cur #define LWS_FOP_READ read #define LWS_FOP_WRITE write #endif #define LWS_FOP_FLAGS_MASK ((1 << 23) - 1) #define LWS_FOP_FLAG_COMPR_ACCEPTABLE_GZIP (1 << 24) #define LWS_FOP_FLAG_COMPR_IS_GZIP (1 << 25) #define LWS_FOP_FLAG_MOD_TIME_VALID (1 << 26) #define LWS_FOP_FLAG_VIRTUAL (1 << 27)"
  },
  {
    "label": "lws_fop_fd_t()",
    "kind": "Method",
    "detail": "Function (struct lws_fop_fd { lws_filefd_type fd ; const struct lws_plat_file_ops* fops ; void* filesystem_priv ; lws_filepos_t pos ; lws_filepos_t len ; lws_fop_flags_t flags ; uint32_t mod_time ; } ; typedef struct lws_fop_fd* lws_fop_fd_t ; struct lws_fops_index { const char* sig ; uint8_t len ; } ; struct lws_plat_file_ops {)",
    "insertText": "lws_fop_fd_t(*LWS_FOP_OPEN)(const struct lws_plat_file_ops *fops, const char *filename, const char *vpath, lws_fop_flags_t *flags)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int(*LWS_FOP_CLOSE)(lws_fop_fd_t *fop_fd)"
  },
  {
    "label": "lws_fileofs_t()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "lws_fileofs_t(*LWS_FOP_SEEK_CUR)(lws_fop_fd_t fop_fd, lws_fileofs_t offset_from_cur_pos)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int(*LWS_FOP_READ)(lws_fop_fd_t fop_fd, lws_filepos_t *amount, uint8_t *buf, lws_filepos_t len)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int(*LWS_FOP_WRITE)(lws_fop_fd_t fop_fd, lws_filepos_t *amount, uint8_t *buf, lws_filepos_t len)"
  },
  {
    "label": "lws_get_fops()",
    "kind": "Method",
    "detail": "Function (struct lws_fops_index fi [ 3 ] ; const struct lws_plat_file_ops* next ; } ; LWS_VISIBLE LWS_EXTERN struct lws_plat_file_ops* LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_get_fops(struct lws_context *context)"
  },
  {
    "label": "lws_set_fops()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_set_fops(struct lws_context *context, const struct lws_plat_file_ops *fops)"
  },
  {
    "label": "lws_vfs_tell()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN lws_filepos_t LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_vfs_tell(lws_fop_fd_t fop_fd)"
  },
  {
    "label": "lws_vfs_get_length()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN lws_filepos_t LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_vfs_get_length(lws_fop_fd_t fop_fd)"
  },
  {
    "label": "lws_vfs_get_mod_time()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN uint32_t LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_vfs_get_mod_time(lws_fop_fd_t fop_fd)"
  },
  {
    "label": "lws_vfs_file_seek_set()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN lws_fileofs_t)",
    "insertText": "lws_vfs_file_seek_set(lws_fop_fd_t fop_fd, lws_fileofs_t offset)"
  },
  {
    "label": "lws_vfs_file_seek_end()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN lws_fileofs_t)",
    "insertText": "lws_vfs_file_seek_end(lws_fop_fd_t fop_fd, lws_fileofs_t offset)"
  },
  {
    "label": "lws_vfs_file_open()",
    "kind": "Method",
    "detail": "Function (struct lws_plat_file_ops fops_zip ; LWS_VISIBLE LWS_EXTERN lws_fop_fd_t LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_vfs_file_open(const struct lws_plat_file_ops *fops, const char *vfs_path, lws_fop_flags_t *flags)"
  },
  {
    "label": "lws_vfs_file_close()",
    "kind": "Method",
    "detail": "Function (LWS_INLINE int)",
    "insertText": "lws_vfs_file_close(lws_fop_fd_t *fop_fd)"
  },
  {
    "label": "lws_vfs_file_seek_cur()",
    "kind": "Method",
    "detail": "Function (} LWS_INLINE lws_fileofs_t)",
    "insertText": "lws_vfs_file_seek_cur(lws_fop_fd_t fop_fd, lws_fileofs_t offset)"
  },
  {
    "label": "lws_vfs_file_read()",
    "kind": "Method",
    "detail": "Function (} LWS_INLINE int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_vfs_file_read(lws_fop_fd_t fop_fd, lws_filepos_t *amount, uint8_t *buf, lws_filepos_t len)"
  },
  {
    "label": "lws_vfs_file_write()",
    "kind": "Method",
    "detail": "Function (} LWS_INLINE int LWS_WARN_UNUSED_RESULT)",
    "insertText": "lws_vfs_file_write(lws_fop_fd_t fop_fd, lws_filepos_t *amount, uint8_t *buf, lws_filepos_t len)"
  },
  {
    "label": "_lws_plat_file_open()",
    "kind": "Method",
    "detail": "Function (} LWS_VISIBLE LWS_EXTERN lws_fop_fd_t)",
    "insertText": "_lws_plat_file_open(const struct lws_plat_file_ops *fops, const char *filename, const char *vpath, lws_fop_flags_t *flags)"
  },
  {
    "label": "_lws_plat_file_close()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "_lws_plat_file_close(lws_fop_fd_t *fop_fd)"
  },
  {
    "label": "_lws_plat_file_seek_cur()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN lws_fileofs_t)",
    "insertText": "_lws_plat_file_seek_cur(lws_fop_fd_t fop_fd, lws_fileofs_t offset)"
  },
  {
    "label": "_lws_plat_file_read()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "_lws_plat_file_read(lws_fop_fd_t fop_fd, lws_filepos_t *amount, uint8_t *buf, lws_filepos_t len)"
  },
  {
    "label": "_lws_plat_file_write()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "_lws_plat_file_write(lws_fop_fd_t fop_fd, lws_filepos_t *amount, uint8_t *buf, lws_filepos_t len)"
  },
  {
    "label": "lws_alloc_vfs_file()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_alloc_vfs_file(struct lws_context *context, const char *filename, uint8_t **buf, lws_filepos_t *amount)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (# ifdef LWS_WITH_SMTP enum lwsgs_smtp_states { LGSSMTP_IDLE,LGSSMTP_CONNECTING,LGSSMTP_CONNECTED,LGSSMTP_SENT_HELO,LGSSMTP_SENT_FROM,LGSSMTP_SENT_TO,LGSSMTP_SENT_DATA,LGSSMTP_SENT_BODY,LGSSMTP_SENT_QUIT,} ; struct lws_email { void* data ; uv_loop_t* loop ; char email_smtp_ip [ 3 2 ] ; char email_helo [ 3 2 ] ; char email_from [ 1 0 0 ] ; char email_to [ 1 0 0 ] ; unsigned int max_content_size ;)",
    "insertText": "int(*on_next)(struct lws_email *email)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int(*on_sent)(struct lws_email *email)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "int(*on_get_body)(struct lws_email *email, char *buf, int len)"
  },
  {
    "label": "lws_email_init()",
    "kind": "Method",
    "detail": "Function (uv_timer_t timeout_email ; enum lwsgs_smtp_states estate ; uv_connect_t email_connect_req ; uv_tcp_t email_client ; time_t email_connect_started ; char email_buf [ 2 5 6 ] ; char* content ; } ; LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lws_email_init(struct lws_email *email, uv_loop_t *loop, int max_content)"
  },
  {
    "label": "lws_email_check()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_email_check(struct lws_email *email)"
  },
  {
    "label": "lws_email_destroy()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_email_destroy(struct lws_email *email)"
  },
  {
    "label": "LWS_ARRAY_SIZE()",
    "kind": "Method",
    "detail": "Function (# endif struct lejp_ctx ; # define)",
    "insertText": "LWS_ARRAY_SIZE(_x) (sizeof(_x) / sizeof(_x[0]))"
  },
  {
    "label": "_lejp_callback()",
    "kind": "Method",
    "detail": "Function (LEJP_IDLE = 0,LEJP_MEMBERS = 1,LEJP_M_P = 2,LEJP_MP_STRING = LEJP_FLAG_WS_KEEP | 3,LEJP_MP_STRING_ESC = LEJP_FLAG_WS_KEEP | 4,LEJP_MP_STRING_ESC_U1 = LEJP_FLAG_WS_KEEP | 5,LEJP_MP_STRING_ESC_U2 = LEJP_FLAG_WS_KEEP | 6,LEJP_MP_STRING_ESC_U3 = LEJP_FLAG_WS_KEEP | 7,LEJP_MP_STRING_ESC_U4 = LEJP_FLAG_WS_KEEP | 8,LEJP_MP_DELIM = 9,LEJP_MP_VALUE = 1 0,LEJP_MP_VALUE_NUM_INT = LEJP_FLAG_WS_KEEP | 1 1,LEJP_MP_VALUE_NUM_EXP = LEJP_FLAG_WS_KEEP | 1 2,LEJP_MP_VALUE_TOK = LEJP_FLAG_WS_KEEP | 1 3,LEJP_MP_COMMA_OR_END = 1 4,LEJP_MP_ARRAY_END = 1 5,} ; enum lejp_reasons { LEJP_CONTINUE = - 1,LEJP_REJECT_IDLE_NO_BRACE = - 2,LEJP_REJECT_MEMBERS_NO_CLOSE = - 3,LEJP_REJECT_MP_NO_OPEN_QUOTE = - 4,LEJP_REJECT_MP_STRING_UNDERRUN = - 5,LEJP_REJECT_MP_ILLEGAL_CTRL = - 6,LEJP_REJECT_MP_STRING_ESC_ILLEGAL_ESC = - 7,LEJP_REJECT_ILLEGAL_HEX = - 8,LEJP_REJECT_MP_DELIM_MISSING_COLON = - 9,LEJP_REJECT_MP_DELIM_BAD_VALUE_START = - 1 0,LEJP_REJECT_MP_VAL_NUM_INT_NO_FRAC = - 1 1,LEJP_REJECT_MP_VAL_NUM_FORMAT = - 1 2,LEJP_REJECT_MP_VAL_NUM_EXP_BAD_EXP = - 1 3,LEJP_REJECT_MP_VAL_TOK_UNKNOWN = - 1 4,LEJP_REJECT_MP_C_OR_E_UNDERF = - 1 5,LEJP_REJECT_MP_C_OR_E_NOTARRAY = - 1 6,LEJP_REJECT_MP_ARRAY_END_MISSING = - 1 7,LEJP_REJECT_STACK_OVERFLOW = - 1 8,LEJP_REJECT_MP_DELIM_ISTACK = - 1 9,LEJP_REJECT_NUM_TOO_LONG = - 2 0,LEJP_REJECT_MP_C_OR_E_NEITHER = - 2 1,LEJP_REJECT_UNKNOWN = - 2 2,LEJP_REJECT_CALLBACK = - 2 3 } ; # define LEJP_FLAG_CB_IS_VALUE 6 4 enum lejp_callbacks { LEJPCB_CONSTRUCTED = 0,LEJPCB_DESTRUCTED = 1,LEJPCB_START = 2,LEJPCB_COMPLETE = 3,LEJPCB_FAILED = 4,LEJPCB_PAIR_NAME = 5,LEJPCB_VAL_TRUE = LEJP_FLAG_CB_IS_VALUE | 6,LEJPCB_VAL_FALSE = LEJP_FLAG_CB_IS_VALUE | 7,LEJPCB_VAL_NULL = LEJP_FLAG_CB_IS_VALUE | 8,LEJPCB_VAL_NUM_INT = LEJP_FLAG_CB_IS_VALUE | 9,LEJPCB_VAL_NUM_FLOAT = LEJP_FLAG_CB_IS_VALUE | 1 0,LEJPCB_VAL_STR_START = 1 1,LEJPCB_VAL_STR_CHUNK = LEJP_FLAG_CB_IS_VALUE | 1 2,LEJPCB_VAL_STR_END = LEJP_FLAG_CB_IS_VALUE | 1 3,LEJPCB_ARRAY_START = 1 4,LEJPCB_ARRAY_END = 1 5,LEJPCB_OBJECT_START = 1 6,LEJPCB_OBJECT_END = 1 7 } ; LWS_EXTERN signed char)",
    "insertText": "_lejp_callback(struct lejp_ctx *ctx, char reason)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (typedef signed)",
    "insertText": "char(*lejp_callback)(struct lejp_ctx *ctx, char reason)"
  },
  {
    "label": "LEJP_SEEN_MINUS()",
    "kind": "Method",
    "detail": "Function (# ifndef LEJP_MAX_DEPTH # define LEJP_MAX_DEPTH 1 2 # endif # ifndef LEJP_MAX_INDEX_DEPTH # define LEJP_MAX_INDEX_DEPTH 5 # endif # ifndef LEJP_MAX_PATH # define LEJP_MAX_PATH 1 2 8 # endif # ifndef LEJP_STRING_CHUNK # define LEJP_STRING_CHUNK 2 5 5 # endif enum num_flags {)",
    "insertText": "LEJP_SEEN_MINUS(1 << 0), LEJP_SEEN_POINT = (1 << 1), LEJP_SEEN_POST_POINT = (1 << 2), LEJP_SEEN_EXP = (1 << 3)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (struct _lejp_stack { char s ; char p ; char i ; char b ; } ; struct lejp_ctx { signed)",
    "insertText": "char(*callback)(struct lejp_ctx *ctx, char reason)"
  },
  {
    "label": "lejp_construct()",
    "kind": "Method",
    "detail": "Function (void* user ; const char* const* paths ; struct _lejp_stack st [ LEJP_MAX_DEPTH ] ; uint16_t i [ LEJP_MAX_INDEX_DEPTH ] ; uint16_t wild [ LEJP_MAX_INDEX_DEPTH ] ; char path [ LEJP_MAX_PATH ] ; char buf [ LEJP_STRING_CHUNK ] ; uint32_t line ; uint16_t uni ; uint8_t npos ; uint8_t dcount ; uint8_t f ; uint8_t sp ; uint8_t ipos ; uint8_t ppos ; uint8_t count_paths ; uint8_t path_match ; uint8_t path_match_len ; uint8_t wildcount ; } ; LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lejp_construct(struct lejp_ctx *ctx, signed char (*callback)(struct lejp_ctx *ctx, char reason), void *user, const char * const *paths, unsigned char paths_count)"
  },
  {
    "label": "lejp_destruct()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lejp_destruct(struct lejp_ctx *ctx)"
  },
  {
    "label": "lejp_parse()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lejp_parse(struct lejp_ctx *ctx, const unsigned char *json, int len)"
  },
  {
    "label": "lejp_change_callback()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lejp_change_callback(struct lejp_ctx *ctx, signed char (*callback)(struct lejp_ctx *ctx, char reason))"
  },
  {
    "label": "lejp_get_wildcard()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN int)",
    "insertText": "lejp_get_wildcard(struct lejp_ctx *ctx, int wildcard, char *dest, int len)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (enum { LWSSTATS_C_CONNECTIONS,LWSSTATS_C_API_CLOSE,LWSSTATS_C_API_READ,LWSSTATS_C_API_LWS_WRITE,LWSSTATS_C_API_WRITE,LWSSTATS_C_WRITE_PARTIALS,LWSSTATS_C_WRITEABLE_CB_REQ,LWSSTATS_C_WRITEABLE_CB_EFF_REQ,LWSSTATS_C_WRITEABLE_CB,LWSSTATS_C_SSL_CONNECTIONS_FAILED,LWSSTATS_C_SSL_CONNECTIONS_ACCEPTED,LWSSTATS_C_SSL_CONNECTIONS_ACCEPT_SPIN,LWSSTATS_C_SSL_CONNS_HAD_RX,LWSSTATS_C_TIMEOUTS,LWSSTATS_C_SERVICE_ENTRY,LWSSTATS_B_READ,LWSSTATS_B_WRITE,LWSSTATS_B_PARTIALS_ACCEPTED_PARTS,LWSSTATS_MS_SSL_CONNECTIONS_ACCEPTED_DELAY,LWSSTATS_MS_WRITABLE_DELAY,LWSSTATS_MS_WORST_WRITABLE_DELAY,LWSSTATS_MS_SSL_RX_DELAY,LWSSTATS_C_PEER_LIMIT_AH_DENIED,LWSSTATS_C_PEER_LIMIT_WSI_DENIED,LWSSTATS_SIZE } ; # if)",
    "insertText": "defined(LWS_WITH_STATS) LWS_VISIBLE LWS_EXTERN uint64_t lws_stats_get(struct lws_context *context, int index)"
  },
  {
    "label": "lws_stats_log_dump()",
    "kind": "Method",
    "detail": "Function (LWS_VISIBLE LWS_EXTERN void)",
    "insertText": "lws_stats_log_dump(struct lws_context *context)"
  },
  {
    "label": "lws_stats_get()",
    "kind": "Method",
    "detail": "Function (# else LWS_INLINE uint64_t)",
    "insertText": "lws_stats_get(struct lws_context *context, int index)"
  }
]