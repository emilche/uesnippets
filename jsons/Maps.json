[
  {
    "label": "MapBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MapBase"
  },
  {
    "label": "ScaleMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScaleMap"
  },
  {
    "label": "TranslationMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TranslationMap"
  },
  {
    "label": "ScaleTranslateMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScaleTranslateMap"
  },
  {
    "label": "UniformScaleMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UniformScaleMap"
  },
  {
    "label": "UniformScaleTranslateMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UniformScaleTranslateMap"
  },
  {
    "label": "AffineMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AffineMap"
  },
  {
    "label": "UnitaryMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnitaryMap"
  },
  {
    "label": "NonlinearFrustumMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NonlinearFrustumMap"
  },
  {
    "label": "CompoundMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CompoundMap"
  },
  {
    "label": "is_linear",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_linear"
  },
  {
    "label": "is_uniform_scale",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_uniform_scale"
  },
  {
    "label": "is_uniform_scale_translate",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_uniform_scale_translate"
  },
  {
    "label": "is_scale",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_scale"
  },
  {
    "label": "is_scale_translate",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_scale_translate"
  },
  {
    "label": "is_uniform_diagonal_jacobian",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_uniform_diagonal_jacobian"
  },
  {
    "label": "is_diagonal_jacobian",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_diagonal_jacobian"
  },
  {
    "label": "OPENVDB_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OPENVDB_API"
  },
  {
    "label": "createSymmetricMap()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_MAPS_HAS_BEEN_INCLUDED # define OPENVDB_MATH_MAPS_HAS_BEEN_INCLUDED # include \" Math . h \" # include \" Mat4 . h \" # include \" Vec3 . h \" # include \" BBox . h \" # include \" Coord . h \" # include<openvdb / io / io . h> # include<openvdb / util / Name . h> # include<openvdb / Types . h> # include<cmath> # include<iostream> # include<map> # include<string> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { class MapBase ; class ScaleMap ; class TranslationMap ; class ScaleTranslateMap ; class UniformScaleMap ; class UniformScaleTranslateMap ; class AffineMap ; class UnitaryMap ; class NonlinearFrustumMap ; template<T1,T2> class CompoundMap ; using UnitaryAndTranslationMap = CompoundMap<UnitaryMap,TranslationMap> ; using SpectralDecomposedMap = CompoundMap<CompoundMap<UnitaryMap,ScaleMap>,UnitaryMap> ; using SymmetricMap = SpectralDecomposedMap ; using FullyDecomposedMap = CompoundMap<SymmetricMap,UnitaryAndTranslationMap> ; using PolarDecomposedMap = CompoundMap<SymmetricMap,UnitaryMap> ; template<T> struct is_linear { const bool value = false ; } ; template<> struct is_linear<AffineMap> { const bool value = true ; } ; template<> struct is_linear<ScaleMap> { const bool value = true ; } ; template<> struct is_linear<UniformScaleMap> { const bool value = true ; } ; template<> struct is_linear<UnitaryMap> { const bool value = true ; } ; template<> struct is_linear<TranslationMap> { const bool value = true ; } ; template<> struct is_linear<ScaleTranslateMap> { const bool value = true ; } ; template<> struct is_linear<UniformScaleTranslateMap> { const bool value = true ; } ; template<T1,T2> struct is_linear<CompoundMap<T1,T2>> { const bool value = is_linear<T1>::value&& is_linear<T2>::value ; } ; template<T> struct is_uniform_scale { const bool value = false ; } ; template<> struct is_uniform_scale<UniformScaleMap> { const bool value = true ; } ; template<T> struct is_uniform_scale_translate { const bool value = false ; } ; template<> struct is_uniform_scale_translate<TranslationMap> { const bool value = true ; } ; template<> struct is_uniform_scale_translate<UniformScaleTranslateMap> { const bool value = true ; } ; template<T> struct is_scale { const bool value = false ; } ; template<> struct is_scale<ScaleMap> { const bool value = true ; } ; template<T> struct is_scale_translate { const bool value = false ; } ; template<> struct is_scale_translate<ScaleTranslateMap> { const bool value = true ; } ; template<T> struct is_uniform_diagonal_jacobian { const bool value = is_uniform_scale<T>::value | | is_uniform_scale_translate<T>::value ; } ; template<T> struct is_diagonal_jacobian { const bool value = is_scale<T>::value | | is_scale_translate<T>::value ; } ; SharedPtr<SymmetricMap>)",
    "insertText": "createSymmetricMap(const Mat3d& m)"
  },
  {
    "label": "createFullyDecomposedMap()",
    "kind": "Method",
    "detail": "Function (SharedPtr<FullyDecomposedMap>)",
    "insertText": "createFullyDecomposedMap(const Mat4d& m)"
  },
  {
    "label": "createPolarDecomposedMap()",
    "kind": "Method",
    "detail": "Function (SharedPtr<PolarDecomposedMap>)",
    "insertText": "createPolarDecomposedMap(const Mat3d& m)"
  },
  {
    "label": "simplify()",
    "kind": "Method",
    "detail": "Function (SharedPtr<MapBase>)",
    "insertText": "simplify(SharedPtr<AffineMap> affine)"
  },
  {
    "label": "approxInverse()",
    "kind": "Method",
    "detail": "Function (Mat4d)",
    "insertText": "approxInverse(const Mat4d& mat)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (class MapBase { public : using Ptr = SharedPtr<MapBase> ; using ConstPtr = SharedPtr<const MapBase> ; using MapFactory =)",
    "insertText": "Ptr(*)()"
  },
  {
    "label": "MapBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MapBase(const MapBase&)"
  },
  {
    "label": "MapBase()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "MapBase()"
  },
  {
    "label": "getAffineMap()",
    "kind": "Method",
    "detail": "Function (SharedPtr<AffineMap>)",
    "insertText": "getAffineMap()"
  },
  {
    "label": "type()",
    "kind": "Method",
    "detail": "Function (Name)",
    "insertText": "type()"
  },
  {
    "label": "isType()",
    "kind": "Method",
    "detail": "Function (template<MapT> bool)",
    "insertText": "isType()"
  },
  {
    "label": "isEqual()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isEqual(const MapBase& other)"
  },
  {
    "label": "isLinear()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLinear()"
  },
  {
    "label": "hasUniformScale()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasUniformScale()"
  },
  {
    "label": "applyMap()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "applyMap(const Vec3d& in)"
  },
  {
    "label": "applyInverseMap()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "applyInverseMap(const Vec3d& in)"
  },
  {
    "label": "applyIJT()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "applyIJT(const Vec3d& in)"
  },
  {
    "label": "applyIJT()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "applyIJT(const Vec3d& in, const Vec3d& domainPos)"
  },
  {
    "label": "applyIJC()",
    "kind": "Method",
    "detail": "Function (Mat3d)",
    "insertText": "applyIJC(const Mat3d& m)"
  },
  {
    "label": "applyIJC()",
    "kind": "Method",
    "detail": "Function (Mat3d)",
    "insertText": "applyIJC(const Mat3d& m, const Vec3d& v, const Vec3d& domainPos)"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (double)",
    "insertText": "determinant()"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (double)",
    "insertText": "determinant(const Vec3d&)"
  },
  {
    "label": "voxelSize()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "voxelSize()"
  },
  {
    "label": "voxelSize()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "voxelSize(const Vec3d&)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "read(std::istream&)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "write(std::ostream&)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "str()"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "copy()"
  },
  {
    "label": "preRotate()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "preRotate(double radians, Axis axis = X_AXIS)"
  },
  {
    "label": "preTranslate()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "preTranslate(const Vec3d&)"
  },
  {
    "label": "preScale()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "preScale(const Vec3d&)"
  },
  {
    "label": "preShear()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "preShear(double shear, Axis axis0, Axis axis1)"
  },
  {
    "label": "postRotate()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "postRotate(double radians, Axis axis = X_AXIS)"
  },
  {
    "label": "postTranslate()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "postTranslate(const Vec3d&)"
  },
  {
    "label": "postScale()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "postScale(const Vec3d&)"
  },
  {
    "label": "postShear()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "postShear(double shear, Axis axis0, Axis axis1)"
  },
  {
    "label": "applyJacobian()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "applyJacobian(const Vec3d& in)"
  },
  {
    "label": "applyJacobian()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "applyJacobian(const Vec3d& in, const Vec3d& domainPos)"
  },
  {
    "label": "applyInverseJacobian()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "applyInverseJacobian(const Vec3d& in)"
  },
  {
    "label": "applyInverseJacobian()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "applyInverseJacobian(const Vec3d& in, const Vec3d& domainPos)"
  },
  {
    "label": "applyJT()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "applyJT(const Vec3d& in)"
  },
  {
    "label": "applyJT()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "applyJT(const Vec3d& in, const Vec3d& domainPos)"
  },
  {
    "label": "inverseMap()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "inverseMap()"
  },
  {
    "label": "isEqualBase()",
    "kind": "Method",
    "detail": "Function (} template<MapT> bool)",
    "insertText": "isEqualBase(const MapT& self, const MapBase& other)"
  },
  {
    "label": "instance()",
    "kind": "Method",
    "detail": "Function (} } ; class MapRegistry { public : using MapDictionary = std::map<Name,MapBase::MapFactory> ; MapRegistry*)",
    "insertText": "instance()"
  },
  {
    "label": "createMap()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "createMap(const Name&)"
  },
  {
    "label": "isRegistered()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isRegistered(const Name&)"
  },
  {
    "label": "registerMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerMap(const Name&, MapBase::MapFactory)"
  },
  {
    "label": "unregisterMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unregisterMap(const Name&)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "MapRegistry()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "MapRegistry()"
  },
  {
    "label": "staticInstance()",
    "kind": "Method",
    "detail": "Function (} MapRegistry*)",
    "insertText": "staticInstance()"
  },
  {
    "label": "AffineMap()",
    "kind": "Method",
    "detail": "Function (MapDictionary mMap ; } ; # if OPENVDB_ABI_VERSION_NUMBER> = 8 # define OPENVDB_MAP_CLASS_SPECIFIER final # define OPENVDB_MAP_FUNC_SPECIFIER final # else # define OPENVDB_MAP_CLASS_SPECIFIER # define OPENVDB_MAP_FUNC_SPECIFIER override # endif class AffineMap OPENVDB_MAP_CLASS_SPECIFIER : public MapBase { public : using Ptr = SharedPtr<AffineMap> ; using ConstPtr = SharedPtr<const AffineMap> ;)",
    "insertText": "AffineMap(): mMatrix(Mat4d::identity()), mMatrixInv(Mat4d::identity()), mJacobianInv(Mat3d::identity()), mDeterminant(1), mVoxelSize(Vec3d(1,1,1)), mIsDiagonal(true), mIsIdentity(true)"
  },
  {
    "label": "AffineMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AffineMap(const Mat3d& m)"
  },
  {
    "label": "mat4()",
    "kind": "Method",
    "detail": "Function (Mat4d)",
    "insertText": "mat4(Mat4d::identity())"
  },
  {
    "label": "setMat3()",
    "kind": "Method",
    "detail": "Function (mat4 .)",
    "insertText": "setMat3(m)"
  },
  {
    "label": "updateAcceleration()",
    "kind": "Method",
    "detail": "Function (mMatrix = mat4 ;)",
    "insertText": "updateAcceleration()"
  },
  {
    "label": "AffineMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AffineMap(const Mat4d& m): mMatrix(m)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"Tried to initialize an affine transform from a non-affine 4x4 matrix\")"
  },
  {
    "label": "AffineMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AffineMap(const AffineMap& other): MapBase(other), mMatrix(other.mMatrix), mMatrixInv(other.mMatrixInv), mJacobianInv(other.mJacobianInv), mDeterminant(other.mDeterminant), mVoxelSize(other.mVoxelSize), mIsDiagonal(other.mIsDiagonal), mIsIdentity(other.mIsIdentity)"
  },
  {
    "label": "AffineMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AffineMap(const AffineMap& first, const AffineMap& second): mMatrix(first.mMatrix * second.mMatrix)"
  },
  {
    "label": "AffineMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "AffineMap()"
  },
  {
    "label": "create()",
    "kind": "Method",
    "detail": "Function (MapBase::Ptr)",
    "insertText": "create()"
  },
  {
    "label": "isRegistered()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isRegistered()"
  },
  {
    "label": "registerMap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "registerMap()"
  },
  {
    "label": "registerMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerMap(AffineMap::mapType(), AffineMap::create)"
  },
  {
    "label": "mapType()",
    "kind": "Method",
    "detail": "Function (} Name)",
    "insertText": "mapType()"
  },
  {
    "label": "getMat3()",
    "kind": "Method",
    "detail": "Function (Mat3d mat = mMatrix .)",
    "insertText": "getMat3()"
  },
  {
    "label": "det()",
    "kind": "Method",
    "detail": "Function (const double det = mat .)",
    "insertText": "det()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const AffineMap& other)"
  },
  {
    "label": "applyInverseJacobian()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "applyInverseJacobian(const Vec3d& in, const Vec3d&)"
  },
  {
    "label": "applyJT()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "applyJT(const Vec3d& in, const Vec3d&)"
  },
  {
    "label": "asPointer()",
    "kind": "Method",
    "detail": "Function (const double* m = mMatrix .)",
    "insertText": "asPointer()"
  },
  {
    "label": "applyIJT()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "applyIJT(const Vec3d& in, const Vec3d&)"
  },
  {
    "label": "applyIJC()",
    "kind": "Method",
    "detail": "Function (} Mat3d)",
    "insertText": "applyIJC(const Mat3d& in, const Vec3d& , const Vec3d&)"
  },
  {
    "label": "isIdentity()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isIdentity()"
  },
  {
    "label": "isScaleTranslate()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isScaleTranslate()"
  },
  {
    "label": "accumPreRotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "accumPreRotation(Axis axis, double radians)"
  },
  {
    "label": "preRotate()",
    "kind": "Method",
    "detail": "Function (mMatrix .)",
    "insertText": "preRotate(axis, radians)"
  },
  {
    "label": "accumPreScale()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "accumPreScale(const Vec3d& v)"
  },
  {
    "label": "preScale()",
    "kind": "Method",
    "detail": "Function (mMatrix .)",
    "insertText": "preScale(v)"
  },
  {
    "label": "accumPreTranslation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "accumPreTranslation(const Vec3d& v)"
  },
  {
    "label": "preTranslate()",
    "kind": "Method",
    "detail": "Function (mMatrix .)",
    "insertText": "preTranslate(v)"
  },
  {
    "label": "accumPreShear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "accumPreShear(Axis axis0, Axis axis1, double shear)"
  },
  {
    "label": "preShear()",
    "kind": "Method",
    "detail": "Function (mMatrix .)",
    "insertText": "preShear(axis0, axis1, shear)"
  },
  {
    "label": "accumPostRotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "accumPostRotation(Axis axis, double radians)"
  },
  {
    "label": "postRotate()",
    "kind": "Method",
    "detail": "Function (mMatrix .)",
    "insertText": "postRotate(axis, radians)"
  },
  {
    "label": "accumPostScale()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "accumPostScale(const Vec3d& v)"
  },
  {
    "label": "postScale()",
    "kind": "Method",
    "detail": "Function (mMatrix .)",
    "insertText": "postScale(v)"
  },
  {
    "label": "accumPostTranslation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "accumPostTranslation(const Vec3d& v)"
  },
  {
    "label": "postTranslate()",
    "kind": "Method",
    "detail": "Function (mMatrix .)",
    "insertText": "postTranslate(v)"
  },
  {
    "label": "accumPostShear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "accumPostShear(Axis axis0, Axis axis1, double shear)"
  },
  {
    "label": "postShear()",
    "kind": "Method",
    "detail": "Function (mMatrix .)",
    "insertText": "postShear(axis0, axis1, shear)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "read(std::istream& is)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (mMatrix .)",
    "insertText": "read(is)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "write(std::ostream& os)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (mMatrix .)",
    "insertText": "write(os)"
  },
  {
    "label": "createDecomposedMap()",
    "kind": "Method",
    "detail": "Function (} SharedPtr<FullyDecomposedMap>)",
    "insertText": "createDecomposedMap()"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (} AffineMap::Ptr)",
    "insertText": "inverse()"
  },
  {
    "label": "accumPreRotation()",
    "kind": "Method",
    "detail": "Function (affineMap ->)",
    "insertText": "accumPreRotation(axis, radians)"
  },
  {
    "label": "preTranslate()",
    "kind": "Method",
    "detail": "Function (} MapBase::Ptr)",
    "insertText": "preTranslate(const Vec3d& t)"
  },
  {
    "label": "accumPreTranslation()",
    "kind": "Method",
    "detail": "Function (affineMap ->)",
    "insertText": "accumPreTranslation(t)"
  },
  {
    "label": "preScale()",
    "kind": "Method",
    "detail": "Function (} MapBase::Ptr)",
    "insertText": "preScale(const Vec3d& s)"
  },
  {
    "label": "accumPreScale()",
    "kind": "Method",
    "detail": "Function (affineMap ->)",
    "insertText": "accumPreScale(s)"
  },
  {
    "label": "accumPreShear()",
    "kind": "Method",
    "detail": "Function (affineMap ->)",
    "insertText": "accumPreShear(axis0, axis1, shear)"
  },
  {
    "label": "accumPostRotation()",
    "kind": "Method",
    "detail": "Function (affineMap ->)",
    "insertText": "accumPostRotation(axis, radians)"
  },
  {
    "label": "postTranslate()",
    "kind": "Method",
    "detail": "Function (} MapBase::Ptr)",
    "insertText": "postTranslate(const Vec3d& t)"
  },
  {
    "label": "accumPostTranslation()",
    "kind": "Method",
    "detail": "Function (affineMap ->)",
    "insertText": "accumPostTranslation(t)"
  },
  {
    "label": "postScale()",
    "kind": "Method",
    "detail": "Function (} MapBase::Ptr)",
    "insertText": "postScale(const Vec3d& s)"
  },
  {
    "label": "accumPostScale()",
    "kind": "Method",
    "detail": "Function (affineMap ->)",
    "insertText": "accumPostScale(s)"
  },
  {
    "label": "accumPostShear()",
    "kind": "Method",
    "detail": "Function (affineMap ->)",
    "insertText": "accumPostShear(axis0, axis1, shear)"
  },
  {
    "label": "getMat4()",
    "kind": "Method",
    "detail": "Function (} Mat4d)",
    "insertText": "getMat4()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"Tried to initialize an affine transform from a nearly singular matrix\")"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (mJacobianInv = mat3 .)",
    "insertText": "inverse().transpose()"
  },
  {
    "label": "isDiagonal()",
    "kind": "Method",
    "detail": "Function (mIsDiagonal =)",
    "insertText": "isDiagonal(mMatrix)"
  },
  {
    "label": "isIdentity()",
    "kind": "Method",
    "detail": "Function (mIsIdentity =)",
    "insertText": "isIdentity(mMatrix)"
  },
  {
    "label": "applyMap()",
    "kind": "Method",
    "detail": "Function (Vec3d pos =)",
    "insertText": "applyMap(Vec3d(0,0,0))"
  },
  {
    "label": "mVoxelSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mVoxelSize(0) = (applyMap(Vec3d(1,0,0)) - pos).length()"
  },
  {
    "label": "mVoxelSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mVoxelSize(1) = (applyMap(Vec3d(0,1,0)) - pos).length()"
  },
  {
    "label": "mVoxelSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mVoxelSize(2) = (applyMap(Vec3d(0,0,1)) - pos).length()"
  },
  {
    "label": "ScaleMap()",
    "kind": "Method",
    "detail": "Function (} Mat4d mMatrix ; Mat4d mMatrixInv ; Mat3d mJacobianInv ; double mDeterminant ; Vec3d mVoxelSize ; bool mIsDiagonal,mIsIdentity ; } ; class ScaleMap : public MapBase { public : using Ptr = SharedPtr<ScaleMap> ; using ConstPtr = SharedPtr<const ScaleMap> ;)",
    "insertText": "ScaleMap(): MapBase(), mScaleValues(Vec3d(1,1,1)), mVoxelSize(Vec3d(1,1,1)), mScaleValuesInverse(Vec3d(1,1,1)), mInvScaleSqr(1,1,1), mInvTwiceScale(0.5,0.5,0.5)"
  },
  {
    "label": "ScaleMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ScaleMap(const Vec3d& scale): MapBase(), mScaleValues(scale), mVoxelSize(Vec3d(std::abs(scale(0)),std::abs(scale(1)), std::abs(scale(2))))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"Non-zero scale values required\")"
  },
  {
    "label": "ScaleMap()",
    "kind": "Method",
    "detail": "Function (} mScaleValuesInverse = 1 . 0 / mScaleValues ; mInvScaleSqr = mScaleValuesInverse* mScaleValuesInverse ; mInvTwiceScale = mScaleValuesInverse / 2 ; })",
    "insertText": "ScaleMap(const ScaleMap& other): MapBase(), mScaleValues(other.mScaleValues), mVoxelSize(other.mVoxelSize), mScaleValuesInverse(other.mScaleValuesInverse), mInvScaleSqr(other.mInvScaleSqr), mInvTwiceScale(other.mInvTwiceScale)"
  },
  {
    "label": "ScaleMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ScaleMap()"
  },
  {
    "label": "registerMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerMap(ScaleMap::mapType(), ScaleMap::create)"
  },
  {
    "label": "isApproxEqual()",
    "kind": "Method",
    "detail": "Function (bool value =)",
    "insertText": "isApproxEqual(std::abs(mScaleValues.x()), std::abs(mScaleValues.y()), double(5e-7))"
  },
  {
    "label": "isApproxEqual()",
    "kind": "Method",
    "detail": "Function (value = value&&)",
    "insertText": "isApproxEqual(std::abs(mScaleValues.x()), std::abs(mScaleValues.z()), double(5e-7))"
  },
  {
    "label": "applyJacobian()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "applyJacobian(const Vec3d& in, const Vec3d&)"
  },
  {
    "label": "applyIJC()",
    "kind": "Method",
    "detail": "Function (} Mat3d)",
    "insertText": "applyIJC(const Mat3d& in)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Mat3d tmp ;)",
    "insertText": "for(int i = 0; i < 3; i++)"
  },
  {
    "label": "setRow()",
    "kind": "Method",
    "detail": "Function (tmp .)",
    "insertText": "setRow(i, in.row(i) * mScaleValuesInverse(i))"
  },
  {
    "label": "setCol()",
    "kind": "Method",
    "detail": "Function (tmp .)",
    "insertText": "setCol(i, tmp.col(i) * mScaleValuesInverse(i))"
  },
  {
    "label": "applyIJC()",
    "kind": "Method",
    "detail": "Function (} return tmp ; } Mat3d)",
    "insertText": "applyIJC(const Mat3d& in, const Vec3d&, const Vec3d&)"
  },
  {
    "label": "getScale()",
    "kind": "Method",
    "detail": "Function (} const Vec3d&)",
    "insertText": "getScale()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const ScaleMap& other)"
  },
  {
    "label": "preRotate()",
    "kind": "Method",
    "detail": "Function (} MapBase::Ptr)",
    "insertText": "preRotate(double radians, Axis axis)"
  },
  {
    "label": "postRotate()",
    "kind": "Method",
    "detail": "Function (} MapBase::Ptr)",
    "insertText": "postRotate(double radians, Axis axis)"
  },
  {
    "label": "UniformScaleMap()",
    "kind": "Method",
    "detail": "Function (} private : Vec3d mScaleValues,mVoxelSize,mScaleValuesInverse,mInvScaleSqr,mInvTwiceScale ; } ; class UniformScaleMap OPENVDB_MAP_CLASS_SPECIFIER : public ScaleMap { public : using Ptr = SharedPtr<UniformScaleMap> ; using ConstPtr = SharedPtr<const UniformScaleMap> ;)",
    "insertText": "UniformScaleMap(): ScaleMap(Vec3d(1,1,1))"
  },
  {
    "label": "UniformScaleMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UniformScaleMap(double scale): ScaleMap(Vec3d(scale, scale, scale))"
  },
  {
    "label": "UniformScaleMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UniformScaleMap(const UniformScaleMap& other): ScaleMap(other)"
  },
  {
    "label": "UniformScaleMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "UniformScaleMap()"
  },
  {
    "label": "getInvScale()",
    "kind": "Method",
    "detail": "Function (const Vec3d& invScale =)",
    "insertText": "getInvScale()"
  },
  {
    "label": "registerMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerMap(UniformScaleMap::mapType(), UniformScaleMap::create)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const UniformScaleMap& other)"
  },
  {
    "label": "preScale()",
    "kind": "Method",
    "detail": "Function (} ; MapBase::Ptr)",
    "insertText": "preScale(const Vec3d& v)"
  },
  {
    "label": "new_scale()",
    "kind": "Method",
    "detail": "Function (const Vec3d)",
    "insertText": "new_scale(v * mScaleValues)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "Ptr(new ScaleMap(new_scale))"
  },
  {
    "label": "postScale()",
    "kind": "Method",
    "detail": "Function (} } MapBase::Ptr)",
    "insertText": "postScale(const Vec3d& v)"
  },
  {
    "label": "TranslationMap()",
    "kind": "Method",
    "detail": "Function (} class TranslationMap OPENVDB_MAP_CLASS_SPECIFIER : public MapBase { public : using Ptr = SharedPtr<TranslationMap> ; using ConstPtr = SharedPtr<const TranslationMap> ;)",
    "insertText": "TranslationMap(): MapBase(), mTranslation(Vec3d(0,0,0))"
  },
  {
    "label": "TranslationMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TranslationMap(const Vec3d& t): MapBase(), mTranslation(t)"
  },
  {
    "label": "TranslationMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TranslationMap(const TranslationMap& other): MapBase(), mTranslation(other.mTranslation)"
  },
  {
    "label": "TranslationMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TranslationMap()"
  },
  {
    "label": "registerMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerMap(TranslationMap::mapType(), TranslationMap::create)"
  },
  {
    "label": "getTranslation()",
    "kind": "Method",
    "detail": "Function (} const Vec3d&)",
    "insertText": "getTranslation()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TranslationMap& other)"
  },
  {
    "label": "matrix()",
    "kind": "Method",
    "detail": "Function (Mat4d)",
    "insertText": "matrix(Mat4d::identity())"
  },
  {
    "label": "setTranslation()",
    "kind": "Method",
    "detail": "Function (matrix .)",
    "insertText": "setTranslation(mTranslation)"
  },
  {
    "label": "affineMap()",
    "kind": "Method",
    "detail": "Function (AffineMap::Ptr)",
    "insertText": "affineMap(new AffineMap(matrix))"
  },
  {
    "label": "ScaleTranslateMap()",
    "kind": "Method",
    "detail": "Function (} private : Vec3d mTranslation ; } ; class ScaleTranslateMap : public MapBase { public : using Ptr = SharedPtr<ScaleTranslateMap> ; using ConstPtr = SharedPtr<const ScaleTranslateMap> ;)",
    "insertText": "ScaleTranslateMap(): MapBase(), mTranslation(Vec3d(0,0,0)), mScaleValues(Vec3d(1,1,1)), mVoxelSize(Vec3d(1,1,1)), mScaleValuesInverse(Vec3d(1,1,1)), mInvScaleSqr(1,1,1), mInvTwiceScale(0.5,0.5,0.5)"
  },
  {
    "label": "ScaleTranslateMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ScaleTranslateMap(const Vec3d& scale, const Vec3d& translate): MapBase(), mTranslation(translate), mScaleValues(scale), mVoxelSize(std::abs(scale(0)), std::abs(scale(1)), std::abs(scale(2)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const double determinant = scale [ 0 ]* scale [ 1 ]* scale [ 2 ] ;)",
    "insertText": "if(std::abs(determinant) < 3.0 * math::Tolerance<double>::value())"
  },
  {
    "label": "ScaleTranslateMap()",
    "kind": "Method",
    "detail": "Function (} mScaleValuesInverse = 1 . 0 / mScaleValues ; mInvScaleSqr = mScaleValuesInverse* mScaleValuesInverse ; mInvTwiceScale = mScaleValuesInverse / 2 ; })",
    "insertText": "ScaleTranslateMap(const ScaleMap& scale, const TranslationMap& translate): MapBase(), mTranslation(translate.getTranslation()), mScaleValues(scale.getScale()), mVoxelSize(std::abs(mScaleValues(0)), std::abs(mScaleValues(1)), std::abs(mScaleValues(2))), mScaleValuesInverse(1.0 / scale.getScale())"
  },
  {
    "label": "ScaleTranslateMap()",
    "kind": "Method",
    "detail": "Function (mInvScaleSqr = mScaleValuesInverse* mScaleValuesInverse ; mInvTwiceScale = mScaleValuesInverse / 2 ; })",
    "insertText": "ScaleTranslateMap(const ScaleTranslateMap& other): MapBase(), mTranslation(other.mTranslation), mScaleValues(other.mScaleValues), mVoxelSize(other.mVoxelSize), mScaleValuesInverse(other.mScaleValuesInverse), mInvScaleSqr(other.mInvScaleSqr), mInvTwiceScale(other.mInvTwiceScale)"
  },
  {
    "label": "ScaleTranslateMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ScaleTranslateMap()"
  },
  {
    "label": "registerMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerMap(ScaleTranslateMap::mapType(), ScaleTranslateMap::create)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Mat3d tmp ;)",
    "insertText": "for(int i=0; i<3; i++)"
  },
  {
    "label": "setRow()",
    "kind": "Method",
    "detail": "Function (tmp .)",
    "insertText": "setRow(i, in.row(i)*mScaleValuesInverse(i))"
  },
  {
    "label": "setCol()",
    "kind": "Method",
    "detail": "Function (tmp .)",
    "insertText": "setCol(i, tmp.col(i)*mScaleValuesInverse(i))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const ScaleTranslateMap& other)"
  },
  {
    "label": "affineMap()",
    "kind": "Method",
    "detail": "Function (AffineMap::Ptr)",
    "insertText": "affineMap(new AffineMap(math::scale<Mat4d>(mScaleValues)))"
  },
  {
    "label": "accumPostTranslation()",
    "kind": "Method",
    "detail": "Function (affineMap ->)",
    "insertText": "accumPostTranslation(mTranslation)"
  },
  {
    "label": "scaled_trans()",
    "kind": "Method",
    "detail": "Function (const Vec3d& s = mScaleValues ; const Vec3d)",
    "insertText": "scaled_trans(t.x() * s.x(), t.y() * s.y(), t.z() * s.z())"
  },
  {
    "label": "UniformScaleTranslateMap()",
    "kind": "Method",
    "detail": "Function (} class UniformScaleTranslateMap OPENVDB_MAP_CLASS_SPECIFIER : public ScaleTranslateMap { public : using Ptr = SharedPtr<UniformScaleTranslateMap> ; using ConstPtr = SharedPtr<const UniformScaleTranslateMap> ;)",
    "insertText": "UniformScaleTranslateMap():ScaleTranslateMap(Vec3d(1,1,1), Vec3d(0,0,0))"
  },
  {
    "label": "UniformScaleTranslateMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UniformScaleTranslateMap(double scale, const Vec3d& translate): ScaleTranslateMap(Vec3d(scale,scale,scale), translate)"
  },
  {
    "label": "UniformScaleTranslateMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UniformScaleTranslateMap(const UniformScaleMap& scale, const TranslationMap& translate): ScaleTranslateMap(scale.getScale(), translate.getTranslation())"
  },
  {
    "label": "UniformScaleTranslateMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UniformScaleTranslateMap(const UniformScaleTranslateMap& other):ScaleTranslateMap(other)"
  },
  {
    "label": "UniformScaleTranslateMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "UniformScaleTranslateMap()"
  },
  {
    "label": "registerMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerMap(UniformScaleTranslateMap::mapType(), UniformScaleTranslateMap::create)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const UniformScaleTranslateMap& other)"
  },
  {
    "label": "getScale()",
    "kind": "Method",
    "detail": "Function (const double scale = this ->)",
    "insertText": "getScale().x()"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "Ptr(new ScaleTranslateMap(v, mTranslation))"
  },
  {
    "label": "trans()",
    "kind": "Method",
    "detail": "Function (} else { const Vec3d)",
    "insertText": "trans(mTranslation.x()*v.x(), mTranslation.y()*v.y(), mTranslation.z()*v.z())"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "Ptr(new ScaleTranslateMap(new_scale, mTranslation))"
  },
  {
    "label": "new_trans()",
    "kind": "Method",
    "detail": "Function (const Vec3d)",
    "insertText": "new_trans(mTranslation.x()*v.x(), mTranslation.y()*v.y(), mTranslation.z()*v.z())"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "Ptr(new ScaleTranslateMap(new_scale, new_trans))"
  },
  {
    "label": "UnitaryMap()",
    "kind": "Method",
    "detail": "Function (} } class UnitaryMap OPENVDB_MAP_CLASS_SPECIFIER : public MapBase { public : using Ptr = SharedPtr<UnitaryMap> ; using ConstPtr = SharedPtr<const UnitaryMap> ;)",
    "insertText": "UnitaryMap(): mAffineMap(Mat4d::identity())"
  },
  {
    "label": "UnitaryMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UnitaryMap(const Vec3d& axis, double radians)"
  },
  {
    "label": "setToRotation()",
    "kind": "Method",
    "detail": "Function (Mat3d matrix ; matrix .)",
    "insertText": "setToRotation(axis, radians)"
  },
  {
    "label": "AffineMap()",
    "kind": "Method",
    "detail": "Function (mAffineMap =)",
    "insertText": "AffineMap(matrix)"
  },
  {
    "label": "UnitaryMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UnitaryMap(Axis axis, double radians)"
  },
  {
    "label": "UnitaryMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UnitaryMap(const Mat3d& m)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"Matrix initializing unitary map was not unitary\")"
  },
  {
    "label": "UnitaryMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UnitaryMap(const Mat4d& m)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"4x4 Matrix initializing unitary map was not unitary: not invertible\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!isAffine(m))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"4x4 Matrix initializing unitary map was not unitary: not affine\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(hasTranslation(m))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"4x4 Matrix initializing unitary map was not unitary: had translation\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!isUnitary(m.getMat3()))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"4x4 Matrix initializing unitary map was not unitary\")"
  },
  {
    "label": "AffineMap()",
    "kind": "Method",
    "detail": "Function (} mAffineMap =)",
    "insertText": "AffineMap(m)"
  },
  {
    "label": "UnitaryMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UnitaryMap(const UnitaryMap& other): MapBase(other), mAffineMap(other.mAffineMap)"
  },
  {
    "label": "UnitaryMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UnitaryMap(const UnitaryMap& first, const UnitaryMap& second): mAffineMap(*(first.getAffineMap()), *(second.getAffineMap()))"
  },
  {
    "label": "UnitaryMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "UnitaryMap()"
  },
  {
    "label": "registerMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerMap(UnitaryMap::mapType(), UnitaryMap::create)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const UnitaryMap& other)"
  },
  {
    "label": "first()",
    "kind": "Method",
    "detail": "Function (UnitaryMap)",
    "insertText": "first(axis, radians)"
  },
  {
    "label": "unitaryMap()",
    "kind": "Method",
    "detail": "Function (UnitaryMap::Ptr)",
    "insertText": "unitaryMap(new UnitaryMap(first, *this))"
  },
  {
    "label": "accumPreScale()",
    "kind": "Method",
    "detail": "Function (affineMap ->)",
    "insertText": "accumPreScale(v)"
  },
  {
    "label": "second()",
    "kind": "Method",
    "detail": "Function (UnitaryMap)",
    "insertText": "second(axis, radians)"
  },
  {
    "label": "unitaryMap()",
    "kind": "Method",
    "detail": "Function (UnitaryMap::Ptr)",
    "insertText": "unitaryMap(new UnitaryMap(*this, second))"
  },
  {
    "label": "accumPostScale()",
    "kind": "Method",
    "detail": "Function (affineMap ->)",
    "insertText": "accumPostScale(v)"
  },
  {
    "label": "NonlinearFrustumMap()",
    "kind": "Method",
    "detail": "Function (} private : AffineMap mAffineMap ; } ; class NonlinearFrustumMap OPENVDB_MAP_CLASS_SPECIFIER : public MapBase { public : using Ptr = SharedPtr<NonlinearFrustumMap> ; using ConstPtr = SharedPtr<const NonlinearFrustumMap> ;)",
    "insertText": "NonlinearFrustumMap(): MapBase(), mBBox(Vec3d(0), Vec3d(1)), mTaper(1), mDepth(1)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init()"
  },
  {
    "label": "NonlinearFrustumMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NonlinearFrustumMap(const BBoxd& bb, double taper, double depth): MapBase(),mBBox(bb), mTaper(taper), mDepth(depth)"
  },
  {
    "label": "NonlinearFrustumMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NonlinearFrustumMap(const BBoxd& bb, double taper, double depth, const MapBase::Ptr& secondMap): mBBox(bb), mTaper(taper), mDepth(depth)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"The second map in the Frustum transfrom must be linear\")"
  },
  {
    "label": "mSecondMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "mSecondMap(secondMap->getAffineMap())"
  },
  {
    "label": "NonlinearFrustumMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NonlinearFrustumMap(const NonlinearFrustumMap& other): MapBase(), mBBox(other.mBBox), mTaper(other.mTaper), mDepth(other.mDepth), mSecondMap(other.mSecondMap), mHasSimpleAffine(other.mHasSimpleAffine)"
  },
  {
    "label": "NonlinearFrustumMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "NonlinearFrustumMap(const Vec3d& position, const Vec3d& direction, const Vec3d& up, double aspect , double z_near, double depth, Coord::ValueType x_count, Coord::ValueType z_count)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"The frustum depth must be non-zero and positive\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!(up.length() > 0))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"The frustum height must be non-zero and positive\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!(aspect > 0))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"The frustum aspect ratio must be non-zero and positive\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!(isApproxEqual(up.dot(direction), 0.)))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"The frustum up orientation must be perpendicular to into-frustum direction\")"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (} double near_plane_height = 2* up .)",
    "insertText": "length()"
  },
  {
    "label": "BBoxd()",
    "kind": "Method",
    "detail": "Function (mBBox =)",
    "insertText": "BBoxd(Vec3d(0,0,0), Vec3d(x_count, y_count, z_count))"
  },
  {
    "label": "mTaper()",
    "kind": "Method",
    "detail": "Function (mDepth = depth / near_plane_width ; double gamma = near_plane_width / z_near ;)",
    "insertText": "mTaper(mDepth*gamma + 1.)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (Vec3d direction_unit = direction ; direction_unit .)",
    "insertText": "normalize()"
  },
  {
    "label": "r1()",
    "kind": "Method",
    "detail": "Function (Mat4d)",
    "insertText": "r1(Mat4d::identity())"
  },
  {
    "label": "setToRotation()",
    "kind": "Method",
    "detail": "Function (r1 .)",
    "insertText": "setToRotation(Vec3d(0,0,1), direction_unit)"
  },
  {
    "label": "r2()",
    "kind": "Method",
    "detail": "Function (Mat4d)",
    "insertText": "r2(Mat4d::identity())"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (Vec3d temp = r1 .)",
    "insertText": "inverse().transform(up)"
  },
  {
    "label": "setToRotation()",
    "kind": "Method",
    "detail": "Function (r2 .)",
    "insertText": "setToRotation(Vec3d(0,1,0), temp)"
  },
  {
    "label": "Mat4d()",
    "kind": "Method",
    "detail": "Function (Mat4d scale = math::scale<)",
    "insertText": "Mat4d(Vec3d(near_plane_width, near_plane_width, near_plane_width))"
  },
  {
    "label": "setTranslation()",
    "kind": "Method",
    "detail": "Function (Mat4d mat = scale* r2* r1 ; mat .)",
    "insertText": "setTranslation(position + z_near*direction_unit)"
  },
  {
    "label": "AffineMap()",
    "kind": "Method",
    "detail": "Function (mSecondMap =)",
    "insertText": "AffineMap(mat)"
  },
  {
    "label": "NonlinearFrustumMap()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "NonlinearFrustumMap()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(NotImplementedError, \"inverseMap() is not implemented for NonlinearFrustumMap\")"
  },
  {
    "label": "registerMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerMap(NonlinearFrustumMap::mapType(), NonlinearFrustumMap::create)"
  },
  {
    "label": "e1()",
    "kind": "Method",
    "detail": "Function (const Vec3d)",
    "insertText": "e1(1,0,0)"
  },
  {
    "label": "e2()",
    "kind": "Method",
    "detail": "Function (const Vec3d)",
    "insertText": "e2(0,1,0)"
  },
  {
    "label": "e3()",
    "kind": "Method",
    "detail": "Function (const Vec3d)",
    "insertText": "e3(0,0,1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const NonlinearFrustumMap& other)"
  },
  {
    "label": "e()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "e(0,0,0)"
  },
  {
    "label": "e()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "e(0)"
  },
  {
    "label": "e()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "e(1)"
  },
  {
    "label": "e()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "e(2)"
  },
  {
    "label": "applyJacobian()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "applyJacobian(const Vec3d& in, const Vec3d& isloc)"
  },
  {
    "label": "centered()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "centered(isloc)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (centered = centered - mBBox .)",
    "insertText": "min()"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (centered .)",
    "insertText": "x()"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (centered .)",
    "insertText": "y()"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (const double zprime = centered .)",
    "insertText": "z()"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (const double)",
    "insertText": "scale(mGamma * zprime + 1.)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (const double scale2 = mGamma* mDepthOnLz / mLx ; const Vec3d)",
    "insertText": "tmp(scale * in.x() + scale2 * centered.x()* in.z(), scale * in.y() + scale2 * centered.y()* in.z(), mDepthOnLz * in.z())"
  },
  {
    "label": "applyInverseJacobian()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "applyInverseJacobian(const Vec3d& in, const Vec3d& isloc)"
  },
  {
    "label": "applyInverseJacobian()",
    "kind": "Method",
    "detail": "Function (const double scale2 = mGamma* mDepthOnLz / mLx ; Vec3d out = mSecondMap .)",
    "insertText": "applyInverseJacobian(in)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (out .)",
    "insertText": "x() = (out.x() - scale2 * centered.x() * out.z() / mDepthOnLz)"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (out .)",
    "insertText": "y() = (out.y() - scale2 * centered.y() * out.z() / mDepthOnLz)"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (out .)",
    "insertText": "z() = out.z()"
  },
  {
    "label": "applyJT()",
    "kind": "Method",
    "detail": "Function (const Vec3d tmp = mSecondMap .)",
    "insertText": "applyJT(in)"
  },
  {
    "label": "Vec3d()",
    "kind": "Method",
    "detail": "Function (const double scale2 = mGamma* mDepthOnLz / mLx ; return)",
    "insertText": "Vec3d(scale * tmp.x(), scale * tmp.y(), scale2 * centered.x()* tmp.x() + scale2 * centered.y()* tmp.y() + mDepthOnLz * tmp.z())"
  },
  {
    "label": "applyIJT()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "applyIJT(const Vec3d& d1_is, const Vec3d& ijk)"
  },
  {
    "label": "applyFrustumMap()",
    "kind": "Method",
    "detail": "Function (const Vec3d loc =)",
    "insertText": "applyFrustumMap(ijk)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"Tried to evaluate the frustum transform\" \" at the singular focal point (e.g. camera)\")"
  },
  {
    "label": "getConstJacobianInv()",
    "kind": "Method",
    "detail": "Function (} const double sinv = 1 . 0 / s ; const double pt0 = mLx* sinv ; const double pt1 = mGamma* pt0 ; const double pt2 = pt1* sinv ; const Mat3d& jacinv = mSecondMap .)",
    "insertText": "getConstJacobianInv()"
  },
  {
    "label": "gradE()",
    "kind": "Method",
    "detail": "Function (Mat3d)",
    "insertText": "gradE(Mat3d::zero())"
  },
  {
    "label": "gradE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "gradE(0,j) = pt0 * jacinv(0,j) - pt2 * loc.x()*jacinv(2,j)"
  },
  {
    "label": "gradE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "gradE(1,j) = pt0 * jacinv(1,j) - pt2 * loc.y()*jacinv(2,j)"
  },
  {
    "label": "gradE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "gradE(2,j) = (1./mDepthOnLz) * jacinv(2,j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} Vec3d result ;)",
    "insertText": "for(int i = 0; i < 3; ++i)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "result(i) = d1_is(0) * gradE(0,i) + d1_is(1) * gradE(1,i) + d1_is(2) * gradE(2,i)"
  },
  {
    "label": "applyIJC()",
    "kind": "Method",
    "detail": "Function (} Mat3d)",
    "insertText": "applyIJC(const Mat3d& d2_is, const Vec3d& d1_is, const Vec3d& ijk)"
  },
  {
    "label": "matE0()",
    "kind": "Method",
    "detail": "Function (Mat3d)",
    "insertText": "matE0(Mat3d::zero())"
  },
  {
    "label": "matE1()",
    "kind": "Method",
    "detail": "Function (Mat3d)",
    "insertText": "matE1(Mat3d::zero())"
  },
  {
    "label": "jacinv()",
    "kind": "Method",
    "detail": "Function (const double pt4 = 2 .*)",
    "insertText": "jacinv(2,j) * jacinv(2,k)"
  },
  {
    "label": "matE0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "matE0(j,k) = -(jacinv(0,j) * jacinv(2,k) + jacinv(2,j) * jacinv(0,k)) * pt2 + pt4 * loc.x()"
  },
  {
    "label": "matE1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "matE1(j,k) = -(jacinv(1,j) * jacinv(2,k) + jacinv(2,j) * jacinv(1,k)) * pt2 + pt4 * loc.y()"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (} Mat3d)",
    "insertText": "result(Mat3d::zero())"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "result(m, n) += gradE(j, m) * gradE(i, n) * d2_is(i, j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } } })",
    "insertText": "for(int m = 0; m < 3; ++m)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "result(m, n) += matE0(m, n) * d1_is(0) + matE1(m, n) * d1_is(1)"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "determinant(const Vec3d& loc)"
  },
  {
    "label": "loc()",
    "kind": "Method",
    "detail": "Function (const Vec3d)",
    "insertText": "loc(0.5*(mBBox.min().x() + mBBox.max().x()), 0.5*(mBBox.min().y() + mBBox.max().y()), mBBox.min().z())"
  },
  {
    "label": "voxelSize()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "voxelSize(const Vec3d& loc)"
  },
  {
    "label": "applyMap()",
    "kind": "Method",
    "detail": "Function (Vec3d out,pos =)",
    "insertText": "applyMap(loc)"
  },
  {
    "label": "out()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "out(0) = (applyMap(loc + Vec3d(1,0,0)) - pos).length()"
  },
  {
    "label": "out()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "out(1) = (applyMap(loc + Vec3d(0,1,0)) - pos).length()"
  },
  {
    "label": "out()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "out(2) = (applyMap(loc + Vec3d(0,0,1)) - pos).length()"
  },
  {
    "label": "setTaper()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setTaper(double t)"
  },
  {
    "label": "getTaper()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "getTaper()"
  },
  {
    "label": "getDepth()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "getDepth()"
  },
  {
    "label": "hasSimpleAffine()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasSimpleAffine()"
  },
  {
    "label": "BBoxd()",
    "kind": "Method",
    "detail": "Function (mBBox =)",
    "insertText": "BBoxd(bb.min().asVec3d(), bb.max().asVec3d())"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} is .)",
    "insertText": "read(reinterpret_cast<char*>(&mTaper), sizeof(double))"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&mDepth), sizeof(double))"
  },
  {
    "label": "readString()",
    "kind": "Method",
    "detail": "Function (Name type =)",
    "insertText": "readString(is)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(KeyError, \"Map \" << type << \" is not registered\")"
  },
  {
    "label": "createMap()",
    "kind": "Method",
    "detail": "Function (} MapBase::Ptr proxy = math::)",
    "insertText": "createMap(type)"
  },
  {
    "label": "mSecondMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mSecondMap(proxy->getAffineMap())"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&mTaper), sizeof(double))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&mDepth), sizeof(double))"
  },
  {
    "label": "writeString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeString(os, mSecondMap.type())"
  },
  {
    "label": "extents()",
    "kind": "Method",
    "detail": "Function (mLx = mBBox .)",
    "insertText": "extents().x()"
  },
  {
    "label": "extents()",
    "kind": "Method",
    "detail": "Function (mLy = mBBox .)",
    "insertText": "extents().y()"
  },
  {
    "label": "extents()",
    "kind": "Method",
    "detail": "Function (mLz = mBBox .)",
    "insertText": "extents().z()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"The index space bounding box\" \" must have at least two index points in each direction.\")"
  },
  {
    "label": "mGamma()",
    "kind": "Method",
    "detail": "Function (} mXo = 0 . 5* mLx ; mYo = 0 . 5* mLy ;)",
    "insertText": "mGamma(1./mTaper - 1)"
  },
  {
    "label": "mDepthOnLz()",
    "kind": "Method",
    "detail": "Function (mDepthOnLz = mDepth / mLz ; mDepthOnLzLxLx =)",
    "insertText": "mDepthOnLz(mLx * mLx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mHasSimpleAffine = false ; return ; })",
    "insertText": "if(!isApproxEqual(tmp(0), tmp(2)))"
  },
  {
    "label": "applyMap()",
    "kind": "Method",
    "detail": "Function (Vec3d tmp1 = mSecondMap .)",
    "insertText": "applyMap(Vec3d(1,0,0))"
  },
  {
    "label": "applyMap()",
    "kind": "Method",
    "detail": "Function (Vec3d tmp2 = mSecondMap .)",
    "insertText": "applyMap(Vec3d(0,1,0))"
  },
  {
    "label": "applyMap()",
    "kind": "Method",
    "detail": "Function (Vec3d tmp3 = mSecondMap .)",
    "insertText": "applyMap(Vec3d(0,0,1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mHasSimpleAffine = false ; return ; })",
    "insertText": "if(!isApproxEqual(tmp2.dot(tmp3), 0., 1.e-7))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mHasSimpleAffine = false ; return ; })",
    "insertText": "if(!isApproxEqual(tmp3.dot(tmp1), 0., 1.e-7))"
  },
  {
    "label": "applyFrustumMap()",
    "kind": "Method",
    "detail": "Function (mHasSimpleAffine = false ; return ; } } Vec3d)",
    "insertText": "applyFrustumMap(const Vec3d& in)"
  },
  {
    "label": "out()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "out(in)"
  },
  {
    "label": "updateAffineMatrix()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateAffineMatrix()"
  },
  {
    "label": "CompoundMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CompoundMap(const FirstMapType& f, const SecondMapType& s): mFirstMap(f), mSecondMap(s)"
  },
  {
    "label": "CompoundMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CompoundMap(const MyType& other): mFirstMap(other.mFirstMap), mSecondMap(other.mSecondMap), mAffineMap(other.mAffineMap)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const MyType& other)"
  },
  {
    "label": "isIdentity()",
    "kind": "Method",
    "detail": "Function (} else { return mFirstMap .)",
    "insertText": "isIdentity()&&mSecondMap.isIdentity()"
  },
  {
    "label": "isDiagonal()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "isDiagonal()"
  },
  {
    "label": "isDiagonal()",
    "kind": "Method",
    "detail": "Function (} else { return mFirstMap .)",
    "insertText": "isDiagonal()&&mSecondMap.isDiagonal()"
  },
  {
    "label": "affine()",
    "kind": "Method",
    "detail": "Function (AffineMap::Ptr)",
    "insertText": "affine(new AffineMap(mAffineMap))"
  },
  {
    "label": "firstMap()",
    "kind": "Method",
    "detail": "Function (} } const FirstMapType&)",
    "insertText": "firstMap()"
  },
  {
    "label": "setSecondMap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setSecondMap(const SecondMapType& second)"
  },
  {
    "label": "AffineMap()",
    "kind": "Method",
    "detail": "Function (mAffineMap =)",
    "insertText": "AffineMap(*first, *second)"
  }
]