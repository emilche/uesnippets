[
  {
    "label": "FArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FArchive"
  },
  {
    "label": "FLinkerLoad",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLinkerLoad"
  },
  {
    "label": "UField",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UField"
  },
  {
    "label": "UStruct",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UStruct"
  },
  {
    "label": "FUObjectItem",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUObjectItem"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "TIsWeakPointerType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsWeakPointerType"
  },
  {
    "label": "TIsZeroConstructType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsZeroConstructType"
  },
  {
    "label": "FFieldPath",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFieldPath"
  },
  {
    "label": "FGCInternals",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGCInternals"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TWeakFieldPtr",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TWeakFieldPtr"
  },
  {
    "label": "FFieldPathProperty",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFieldPathProperty"
  },
  {
    "label": "EPathResolveType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EPathResolveType"
  },
  {
    "label": "PropertyType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PropertyType"
  },
  {
    "label": "TFieldPath",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TFieldPath"
  },
  {
    "label": "EDummy1",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EDummy1"
  },
  {
    "label": "TPropertyPathMapKeyFuncs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPropertyPathMapKeyFuncs"
  },
  {
    "label": "NeedsResolving()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / Map . h \" # include \" Containers / UnrealString . h \" # include \" CoreTypes . h \" # include \" HAL / ThreadSafeCounter . h \" # include \" Misc / AssertionMacros . h \" # include \" Templates / Requires . h \" # include \" Templates / TypeHash . h \" # include \" Templates / UnrealTemplate . h \" # include \" UObject / Field . h \" # include \" UObject / NameTypes . h \" # include \" UObject / UObjectArray . h \" # include \" UObject / WeakObjectPtr . h \" # include \" UObject / WeakObjectPtrTemplates . h \" # include<type_traits> class FArchive ; class FLinkerLoad ; class UField ; class UStruct ; struct FUObjectItem ; template<T> struct TIsPODType ; template<T> struct TIsWeakPointerType ; template<T> struct TIsZeroConstructType ; struct FFieldPath { struct FGCInternals ; template<class T> struct TWeakFieldPtr ; class FFieldPathProperty ; protected : enum EPathResolveType { UseStructIfOuterNotFound = 0,UseStructAlways = 1 } ; FField* ResolvedField = nullptr ; # if WITH_EDITORONLY_DATA FFieldClass* InitialFieldClass = nullptr ; int32 FieldPathSerialNumber = 0 ; # endif TWeakObjectPtr<UStruct> ResolvedOwner ; TArray<FName> Path ; bool)",
    "insertText": "NeedsResolving()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITORONLY_DATA UStruct* Owner = ResolvedOwner .)",
    "insertText": "Get()"
  },
  {
    "label": "ClearCachedField()",
    "kind": "Method",
    "detail": "Function (# endif } return true ; } void)",
    "insertText": "ClearCachedField()"
  },
  {
    "label": "IsFieldPathSerialNumberIdentical()",
    "kind": "Method",
    "detail": "Function (ResolvedField = nullptr ; # if WITH_EDITORONLY_DATA InitialFieldClass = nullptr ; FieldPathSerialNumber = 0 ; # endif } private : # if WITH_EDITORONLY_DATA bool)",
    "insertText": "IsFieldPathSerialNumberIdentical(UStruct* InStruct)"
  },
  {
    "label": "GetFieldPathSerialNumber()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetFieldPathSerialNumber(UStruct* InStruct)"
  },
  {
    "label": "GetResolvedOwnerItemInternal()",
    "kind": "Method",
    "detail": "Function (# endif FUObjectItem*)",
    "insertText": "GetResolvedOwnerItemInternal()"
  },
  {
    "label": "ClearCachedFieldInternal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearCachedFieldInternal()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (ResolvedField = nullptr ; ResolvedOwner .)",
    "insertText": "Reset()"
  },
  {
    "label": "TryToResolveOwnerFromStruct()",
    "kind": "Method",
    "detail": "Function (} UStruct*)",
    "insertText": "TryToResolveOwnerFromStruct(UStruct* InCurrentStruct = nullptr, EPathResolveType InResolveType = FFieldPath::UseStructIfOuterNotFound)"
  },
  {
    "label": "TryToResolveOwnerFromLinker()",
    "kind": "Method",
    "detail": "Function (UStruct*)",
    "insertText": "TryToResolveOwnerFromLinker(FLinkerLoad* InLinker)"
  },
  {
    "label": "ConvertFromFullPath()",
    "kind": "Method",
    "detail": "Function (UStruct*)",
    "insertText": "ConvertFromFullPath(FLinkerLoad* InLinker)"
  },
  {
    "label": "FFieldPath()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FFieldPath()"
  },
  {
    "label": "FFieldPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FFieldPath(FField* InField)"
  },
  {
    "label": "Generate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Generate(InField)"
  },
  {
    "label": "FFieldPath()",
    "kind": "Method",
    "detail": "Function (} # if WITH_EDITORONLY_DATA)",
    "insertText": "FFieldPath(UField* InField, const FName& InPropertyTypeName)"
  },
  {
    "label": "Generate()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "Generate(FField* InField)"
  },
  {
    "label": "Generate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Generate(const TCHAR* InFieldPathString)"
  },
  {
    "label": "GenerateFromUField()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITORONLY_DATA void)",
    "insertText": "GenerateFromUField(UField* InField)"
  },
  {
    "label": "TryToResolvePath()",
    "kind": "Method",
    "detail": "Function (# endif FField*)",
    "insertText": "TryToResolvePath(UStruct* InCurrentStruct, EPathResolveType InResolveType = FFieldPath::UseStructIfOuterNotFound)"
  },
  {
    "label": "TryToResolvePath()",
    "kind": "Method",
    "detail": "Function (FField* FoundField =)",
    "insertText": "TryToResolvePath(InCurrentStruct, InResolveType)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ResolvedField = FoundField ; # if WITH_EDITORONLY_DATA)",
    "insertText": "if(!InitialFieldClass)"
  },
  {
    "label": "GetClass()",
    "kind": "Method",
    "detail": "Function (InitialFieldClass = FoundField ->)",
    "insertText": "GetClass()"
  },
  {
    "label": "GetFieldPathSerialNumber()",
    "kind": "Method",
    "detail": "Function (FieldPathSerialNumber =)",
    "insertText": "GetFieldPathSerialNumber(Owner)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif } else)",
    "insertText": "if(ResolvedField)"
  },
  {
    "label": "GetTyped()",
    "kind": "Method",
    "detail": "Function (ResolvedField = nullptr ; } } FField*)",
    "insertText": "GetTyped(FFieldClass* ExpectedType, UStruct* InCurrentStruct = nullptr)"
  },
  {
    "label": "ResolveField()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResolveField(ExpectedType, InCurrentStruct, FFieldPath::UseStructIfOuterNotFound)"
  },
  {
    "label": "IsPathToFieldEmpty()",
    "kind": "Method",
    "detail": "Function (} return ResolvedField ; } bool)",
    "insertText": "IsPathToFieldEmpty()"
  },
  {
    "label": "IsStale()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsStale()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (Path .)",
    "insertText": "Empty()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FFieldPath& InOther)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(FArchive& Ar, FFieldPath& InOutPropertyPath)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] uint32)",
    "insertText": "GetTypeHash(const FFieldPath& InPropertyPath)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (uint32 HashValue = 0 ;)",
    "insertText": "for(const FName& PathSegment : InPropertyPath.Path)"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (HashValue =)",
    "insertText": "HashCombine(HashValue, GetTypeHash(PathSegment))"
  },
  {
    "label": "TFieldPath()",
    "kind": "Method",
    "detail": "Function (} return HashValue ; } } ; template<class PropertyType> struct TFieldPath : public FFieldPath { private : enum EDummy1 { Dummy1 } ; public :)",
    "insertText": "TFieldPath()"
  },
  {
    "label": "TFieldPath()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TFieldPath(const TFieldPath& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TFieldPath&)",
    "insertText": "operator(const TFieldPath& Other)"
  },
  {
    "label": "TFieldPath()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TFieldPath(const TCHAR* InPath) : FFieldPath()"
  },
  {
    "label": "Generate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Generate(InPath)"
  },
  {
    "label": "TFieldPath()",
    "kind": "Method",
    "detail": "Function (} # if WITH_EDITORONLY_DATA)",
    "insertText": "TFieldPath(UField* InField) : FFieldPath(InField, PropertyType::StaticClass()->GetFName())"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} # endif template<OtherPropertyType)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<OtherPropertyType*, PropertyType*>) > FORCEINLINE TFieldPath(OtherPropertyType* InProperty, EDummy1 = Dummy1) : FFieldPath((FField*)CastField<PropertyType>(InProperty))"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<OtherPropertyType)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<OtherPropertyType*, PropertyType*>) > FORCEINLINE TFieldPath(const TFieldPath<OtherPropertyType>& Other) : FFieldPath(Other)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<OtherPropertyType)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<OtherPropertyType*, PropertyType*>) > FORCEINLINE void operator=(OtherPropertyType* InProperty)"
  },
  {
    "label": "ResolvedField()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResolvedField(FField*)"
  },
  {
    "label": "Generate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Generate(ResolvedField)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<OtherPropertyType)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<OtherPropertyType*, PropertyType*>) > FORCEINLINE void operator=(const TFieldPath<OtherPropertyType>& Other)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} PropertyType*)",
    "insertText": "Get(UStruct* InCurrentStruct = nullptr)"
  },
  {
    "label": "ResolveWithRenamedStructPackage()",
    "kind": "Method",
    "detail": "Function (} PropertyType*)",
    "insertText": "ResolveWithRenamedStructPackage(UStruct* InCurrentStruct)"
  },
  {
    "label": "ResolveField()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResolveField(PropertyType::StaticClass(), InCurrentStruct, FFieldPath::UseStructAlways)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} PropertyType*)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<LhsType,RhsType> auto)",
    "insertText": "operator(const TFieldPath<LhsType>& Lhs, const TFieldPath<LhsType>& Rhs) -> decltype((LhsType*)nullptr == (RhsType*)nullptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<LhsType,RhsType> auto)",
    "insertText": "operator(const TFieldPath<LhsType>& Lhs, const RhsType* Rhs) -> decltype((LhsType*)nullptr == Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<LhsType,RhsType> auto)",
    "insertText": "operator(const LhsType* Lhs, const TFieldPath<RhsType>& Rhs) -> decltype(Lhs == (RhsType*)nullptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<LhsType> bool)",
    "insertText": "operator(TFieldPath<LhsType>& Lhs, TYPE_OF_NULLPTR)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<RhsType> bool)",
    "insertText": "operator(TYPE_OF_NULLPTR, TFieldPath<RhsType>& Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # if ! PLATFORM_COMPILER_HAS_GENERATED_COMPARISON_OPERATORS template<LhsType,RhsType> auto)",
    "insertText": "operator(const TFieldPath<LhsType>& Lhs, const TFieldPath<LhsType>& Rhs) -> decltype((LhsType*)nullptr != (RhsType*)nullptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<LhsType,RhsType> auto)",
    "insertText": "operator(const TFieldPath<LhsType>& Lhs, const RhsType* Rhs) -> decltype((LhsType*)nullptr != Rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<LhsType,RhsType> auto)",
    "insertText": "operator(const LhsType* Lhs, const TFieldPath<RhsType>& Rhs) -> decltype(Lhs != (RhsType*)nullptr)"
  },
  {
    "label": "MakePropertyPath()",
    "kind": "Method",
    "detail": "Function (} # endif template<PropertyType> TFieldPath<PropertyType>)",
    "insertText": "MakePropertyPath(PropertyType* Ptr)"
  },
  {
    "label": "Matches()",
    "kind": "Method",
    "detail": "Function (} template<class T> struct TIsPODType<TFieldPath<T>> { enum { Value = true } ; } ; template<class T> struct TIsZeroConstructType<TFieldPath<T>> { enum { Value = true } ; } ; template<class T> struct TIsWeakPointerType<TFieldPath<T>> { enum { Value = true } ; } ; template<KeyType,ValueType,bool bInAllowDuplicateKeys = false> struct TPropertyPathMapKeyFuncs : public TDefaultMapKeyFuncs<KeyType,ValueType,bInAllowDuplicateKeys> { typedef TDefaultMapKeyFuncs<KeyType,ValueType,bInAllowDuplicateKeys>::KeyInitType KeyInitType ; bool)",
    "insertText": "Matches(KeyInitType A, KeyInitType B)"
  }
]