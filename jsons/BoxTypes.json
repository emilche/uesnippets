[
  {
    "label": "TInterval1",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TInterval1"
  },
  {
    "label": "TAxisAlignedBox3",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAxisAlignedBox3"
  },
  {
    "label": "TAxisAlignedBox2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAxisAlignedBox2"
  },
  {
    "label": "TInterval1()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Math / Box . h \" # include \" Math / Box2D . h \" # include \" VectorTypes . h \" # include \" TransformTypes . h \" namespace UE { namespace Geometry { using namespace UE::Math ; template<RealType> struct TInterval1 { RealType Min ; RealType Max ;)",
    "insertText": "TInterval1() : TInterval1(Empty())"
  },
  {
    "label": "TInterval1()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TInterval1(const RealType& Min, const RealType& Max)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (this -> Min = Min ; this -> Max = Max ; } TInterval1<RealType>)",
    "insertText": "Empty()"
  },
  {
    "label": "MakeFromUnordered()",
    "kind": "Method",
    "detail": "Function (} TInterval1<RealType>)",
    "insertText": "MakeFromUnordered(const RealType& A, const RealType& B)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (TInterval1<RealType>)",
    "insertText": "Result(A, B)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(Result.Min, Result.Max)"
  },
  {
    "label": "Center()",
    "kind": "Method",
    "detail": "Function (} return Result ; } RealType)",
    "insertText": "Center()"
  },
  {
    "label": "Extent()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "Extent()"
  },
  {
    "label": "Length()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "Length()"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Contain(const RealType& V)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Min = V ; })",
    "insertText": "if(V > Max)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Max = V ; } } void)",
    "insertText": "Contain(const TInterval1<RealType>& O)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Min = O . Min ; })",
    "insertText": "if(O.Max > Max)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (Max = O . Max ; } } bool)",
    "insertText": "Contains(RealType D)"
  },
  {
    "label": "Overlaps()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Overlaps(const TInterval1<RealType>& O)"
  },
  {
    "label": "SquaredDist()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "SquaredDist(const TInterval1<RealType>& O)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Min > O.Max)"
  },
  {
    "label": "Dist()",
    "kind": "Method",
    "detail": "Function (} else { return 0 ; } } RealType)",
    "insertText": "Dist(const TInterval1<RealType>& O)"
  },
  {
    "label": "RealType()",
    "kind": "Method",
    "detail": "Function (} return TInterval1<)",
    "insertText": "RealType(TMathUtil<RealType>::Max(Min, O.Min), TMathUtil<RealType>::Min(Max, O.Max))"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "Clamp(RealType f)"
  },
  {
    "label": "Interpolate()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "Interpolate(RealType T)"
  },
  {
    "label": "GetT()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "GetT(RealType Value)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Set(TInterval1 O)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (Min = O . Min ; Max = O . Max ; } void)",
    "insertText": "Set(RealType A, RealType B)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Min = A ; Max = B ; } TInterval1)",
    "insertText": "operator(TInterval1 V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TInterval1)",
    "insertText": "operator(RealType f)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "TAxisAlignedBox3()",
    "kind": "Method",
    "detail": "Function (Max + = Radius ; Min - = Radius ; } } ; typedef TInterval1<float> FInterval1f ; typedef TInterval1<double> FInterval1d ; template<RealType> struct TAxisAlignedBox3 { TVector<RealType> Min ; TVector<RealType> Max ;)",
    "insertText": "TAxisAlignedBox3() : TAxisAlignedBox3(TAxisAlignedBox3<RealType>::Empty())"
  },
  {
    "label": "TAxisAlignedBox3()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAxisAlignedBox3(const TVector<RealType>& Min, const TVector<RealType>& Max)"
  },
  {
    "label": "TAxisAlignedBox3()",
    "kind": "Method",
    "detail": "Function (this -> Min = Min ; this -> Max = Max ; })",
    "insertText": "TAxisAlignedBox3(const TVector<RealType>& A, const TVector<RealType>& B, const TVector<RealType>& C)"
  },
  {
    "label": "RealType()",
    "kind": "Method",
    "detail": "Function (Min = TVector<)",
    "insertText": "RealType(TMathUtil<RealType>::Min3(A.X, B.X, C.X), TMathUtil<RealType>::Min3(A.Y, B.Y, C.Y), TMathUtil<RealType>::Min3(A.Z, B.Z, C.Z))"
  },
  {
    "label": "RealType()",
    "kind": "Method",
    "detail": "Function (Max = TVector<)",
    "insertText": "RealType(TMathUtil<RealType>::Max3(A.X, B.X, C.X), TMathUtil<RealType>::Max3(A.Y, B.Y, C.Y), TMathUtil<RealType>::Max3(A.Z, B.Z, C.Z))"
  },
  {
    "label": "TAxisAlignedBox3()",
    "kind": "Method",
    "detail": "Function (} template<OtherRealType>)",
    "insertText": "TAxisAlignedBox3(const TAxisAlignedBox3<OtherRealType>& OtherBox)"
  },
  {
    "label": "RealType()",
    "kind": "Method",
    "detail": "Function (this -> Min = TVector<)",
    "insertText": "RealType(OtherBox.Min)"
  },
  {
    "label": "RealType()",
    "kind": "Method",
    "detail": "Function (this -> Max = TVector<)",
    "insertText": "RealType(OtherBox.Max)"
  },
  {
    "label": "TAxisAlignedBox3()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAxisAlignedBox3(const TVector<RealType>& Center, RealType HalfWidth)"
  },
  {
    "label": "RealType()",
    "kind": "Method",
    "detail": "Function (this -> Min = TVector<)",
    "insertText": "RealType(Center.X-HalfWidth, Center.Y-HalfWidth, Center.Z-HalfWidth)"
  },
  {
    "label": "RealType()",
    "kind": "Method",
    "detail": "Function (this -> Max = TVector<)",
    "insertText": "RealType(Center.X+HalfWidth, Center.Y+HalfWidth, Center.Z+HalfWidth)"
  },
  {
    "label": "TAxisAlignedBox3()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAxisAlignedBox3(const TAxisAlignedBox3& Box, const TFunction<TVector<RealType>(const TVector<RealType>&)> TransformF)"
  },
  {
    "label": "TransformF()",
    "kind": "Method",
    "detail": "Function (Min = Box . Min ; Max = Box . Max ; return ; } TVector<RealType> C0 =)",
    "insertText": "TransformF(Box.GetCorner(0))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Min = C0 ; Max = C0 ;)",
    "insertText": "for(int i = 1; i < 8; ++i)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Contain(TransformF(Box.GetCorner(i)))"
  },
  {
    "label": "TAxisAlignedBox3()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TAxisAlignedBox3(const TAxisAlignedBox3& Box, const FTransformSRT3d& Transform)"
  },
  {
    "label": "TransformPosition()",
    "kind": "Method",
    "detail": "Function (TVector<RealType> C0 = Transform .)",
    "insertText": "TransformPosition(Box.GetCorner(0))"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Contain(Transform.TransformPosition(Box.GetCorner(i)))"
  },
  {
    "label": "TAxisAlignedBox3()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TAxisAlignedBox3(TArrayView<const TVector<RealType>> Pts) : TAxisAlignedBox3(TAxisAlignedBox3<RealType>::Empty())"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Contain(Pts)"
  },
  {
    "label": "TAxisAlignedBox3()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAxisAlignedBox3(const TArray<TVector<RealType>>& Pts) : TAxisAlignedBox3(TAxisAlignedBox3<RealType>::Empty())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TAxisAlignedBox3<RealType>& Other)"
  },
  {
    "label": "ToRet()",
    "kind": "Method",
    "detail": "Function (TBox<OutRealType>)",
    "insertText": "ToRet((TVector<OutRealType>)Min, (TVector<OutRealType>)Max)"
  },
  {
    "label": "RealType()",
    "kind": "Method",
    "detail": "Function (Min = TVector<)",
    "insertText": "RealType(Box.Min)"
  },
  {
    "label": "RealType()",
    "kind": "Method",
    "detail": "Function (Max = TVector<)",
    "insertText": "RealType(Box.Max)"
  },
  {
    "label": "GetCorner()",
    "kind": "Method",
    "detail": "Function (} } TVector<RealType>)",
    "insertText": "GetCorner(int Index)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "X(((Index & 1) != 0) ^ ((Index & 2) != 0)) ? (Max.X) : (Min.X)"
  },
  {
    "label": "Y()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Y((Index / 2) % 2 == 0) ? (Min.Y) : (Max.Y)"
  },
  {
    "label": "Z()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Z(Index < 4) ? (Min.Z) : (Max.Z)"
  },
  {
    "label": "Infinite()",
    "kind": "Method",
    "detail": "Function (} TAxisAlignedBox3<RealType>)",
    "insertText": "Infinite()"
  },
  {
    "label": "MakeBoundsFromIndices()",
    "kind": "Method",
    "detail": "Function (} template<PointFunc> TAxisAlignedBox3<RealType>)",
    "insertText": "MakeBoundsFromIndices(int32 MaxIndex, PointFunc GetPoint)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Result .)",
    "insertText": "Contain(GetPoint(Index))"
  },
  {
    "label": "MakeBoundsFromIndices()",
    "kind": "Method",
    "detail": "Function (} return Result ; } template<EnumerableIntType,PointFunc> TAxisAlignedBox3<RealType>)",
    "insertText": "MakeBoundsFromIndices(EnumerableIntType IndexEnumerable, PointFunc GetPoint)"
  },
  {
    "label": "Extents()",
    "kind": "Method",
    "detail": "Function (} TVector<RealType>)",
    "insertText": "Extents()"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Contain(const TVector<RealType>& V)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Min . X = V . X ; })",
    "insertText": "if(V.X > Max.X)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Max . X = V . X ; })",
    "insertText": "if(V.Y < Min.Y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Min . Y = V . Y ; })",
    "insertText": "if(V.Y > Max.Y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Max . Y = V . Y ; })",
    "insertText": "if(V.Z < Min.Z)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Min . Z = V . Z ; })",
    "insertText": "if(V.Z > Max.Z)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Max . Z = V . Z ; } } void)",
    "insertText": "Contain(const TAxisAlignedBox3<RealType>& Other)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Min . X = Min . X<Other . Min . X ? Min . X : Other . Min . X ; Min . Y = Min . Y<Other . Min . Y ? Min . Y : Other . Min . Y ; Min . Z = Min . Z<Other . Min . Z ? Min . Z : Other . Min . Z ; Max . X = Max . X> Other . Max . X ? Max . X : Other . Max . X ; Max . Y = Max . Y> Other . Max . Y ? Max . Y : Other . Max . Y ; Max . Z = Max . Z> Other . Max . Z ? Max . Z : Other . Max . Z ; } void)",
    "insertText": "Contain(TArrayView<const TVector<RealType>> Pts)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Contain(Pt)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Contain(const TArray<TVector<RealType>>& Pts)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "Contains(const TVector<RealType>& V)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(const TAxisAlignedBox3<RealType>& Box)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (} TVector<RealType>)",
    "insertText": "Clamp(const TVector<RealType>& V)"
  },
  {
    "label": "Intersect()",
    "kind": "Method",
    "detail": "Function (} TAxisAlignedBox3<RealType>)",
    "insertText": "Intersect(const TAxisAlignedBox3<RealType>& Box)"
  },
  {
    "label": "Intersection()",
    "kind": "Method",
    "detail": "Function (TAxisAlignedBox3<RealType>)",
    "insertText": "Intersection(TVector<RealType>(TMathUtil<RealType>::Max(Min.X, Box.Min.X), TMathUtil<RealType>::Max(Min.Y, Box.Min.Y), TMathUtil<RealType>::Max(Min.Z, Box.Min.Z)), TVector<RealType>(TMathUtil<RealType>::Min(Max.X, Box.Max.X), TMathUtil<RealType>::Min(Max.Y, Box.Max.Y), TMathUtil<RealType>::Min(Max.Z, Box.Max.Z)))"
  },
  {
    "label": "Intersects()",
    "kind": "Method",
    "detail": "Function (} else { return Intersection ; } } bool)",
    "insertText": "Intersects(TAxisAlignedBox3 Box)"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "DistanceSquared(const TVector<RealType>& V)"
  },
  {
    "label": "dx()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "dx(V.X < Min.X) ? Min.X - V.X : (V.X > Max.X ? V.X - Max.X : 0)"
  },
  {
    "label": "dy()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "dy(V.Y < Min.Y) ? Min.Y - V.Y : (V.Y > Max.Y ? V.Y - Max.Y : 0)"
  },
  {
    "label": "dz()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "dz(V.Z < Min.Z) ? Min.Z - V.Z : (V.Z > Max.Z ? V.Z - Max.Z : 0)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (RealType delta_x = TMathUtil<RealType)",
    "insertText": "Abs((Box.Min.X + Box.Max.X) - (Min.X + Max.X)) - ((Max.X - Min.X) + (Box.Max.X - Box.Min.X))"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (delta_x = 0 ; } RealType delta_y = TMathUtil<RealType)",
    "insertText": "Abs((Box.Min.Y + Box.Max.Y) - (Min.Y + Max.Y)) - ((Max.Y - Min.Y) + (Box.Max.Y - Box.Min.Y))"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (delta_y = 0 ; } RealType delta_z = TMathUtil<RealType)",
    "insertText": "Abs((Box.Min.Z + Box.Max.Z) - (Min.Z + Max.Z)) - ((Max.Z - Min.Z) + (Box.Max.Z - Box.Min.Z))"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (delta_z = 0 ; })",
    "insertText": "return(RealType)0.25 * (delta_x * delta_x + delta_y * delta_y + delta_z * delta_z)"
  },
  {
    "label": "Dimension()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "Dimension(int32 Index)"
  },
  {
    "label": "Width()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "Width()"
  },
  {
    "label": "Height()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "Height()"
  },
  {
    "label": "Depth()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "Depth()"
  },
  {
    "label": "Volume()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "Volume()"
  },
  {
    "label": "SurfaceArea()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "SurfaceArea()"
  },
  {
    "label": "DiagonalLength()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "DiagonalLength()"
  },
  {
    "label": "MaxDim()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "MaxDim()"
  },
  {
    "label": "MinDim()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "MinDim()"
  },
  {
    "label": "Diagonal()",
    "kind": "Method",
    "detail": "Function (} TVector<RealType>)",
    "insertText": "Diagonal()"
  },
  {
    "label": "TAxisAlignedBox2()",
    "kind": "Method",
    "detail": "Function (Max . X + = Radius ; Max . Y + = Radius ; Max . Z + = Radius ; Min . X - = Radius ; Min . Y - = Radius ; Min . Z - = Radius ; } } ; template<RealType> struct TAxisAlignedBox2 { TVector2<RealType> Min ; TVector2<RealType> Max ;)",
    "insertText": "TAxisAlignedBox2() : TAxisAlignedBox2(Empty())"
  },
  {
    "label": "TAxisAlignedBox2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAxisAlignedBox2(const TVector2<RealType>& Min, const TVector2<RealType>& Max) : Min(Min), Max(Max)"
  },
  {
    "label": "TAxisAlignedBox2()",
    "kind": "Method",
    "detail": "Function (} template<OtherRealType>)",
    "insertText": "TAxisAlignedBox2(const TAxisAlignedBox2<OtherRealType>& OtherBox)"
  },
  {
    "label": "TAxisAlignedBox2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAxisAlignedBox2(RealType SquareSize) : Min((RealType)0, (RealType)0), Max(SquareSize, SquareSize)"
  },
  {
    "label": "TAxisAlignedBox2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAxisAlignedBox2(RealType Width, RealType Height) : Min((RealType)0, (RealType)0), Max(Width, Height)"
  },
  {
    "label": "TAxisAlignedBox2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAxisAlignedBox2(const TArray<TVector2<RealType>>& Pts) : TAxisAlignedBox2(Empty())"
  },
  {
    "label": "TAxisAlignedBox2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAxisAlignedBox2(TArrayView<const TVector2<RealType>> Pts) : TAxisAlignedBox2(Empty())"
  },
  {
    "label": "TAxisAlignedBox2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TAxisAlignedBox2(const TVector2<RealType>& Center, RealType HalfWidth)"
  },
  {
    "label": "RealType()",
    "kind": "Method",
    "detail": "Function (this -> Min = TVector2<)",
    "insertText": "RealType(Center.X - HalfWidth, Center.Y - HalfWidth)"
  },
  {
    "label": "RealType()",
    "kind": "Method",
    "detail": "Function (this -> Max = TVector2<)",
    "insertText": "RealType(Center.X + HalfWidth, Center.Y + HalfWidth)"
  },
  {
    "label": "OutRealType()",
    "kind": "Method",
    "detail": "Function (} template<OutRealType> operator TBox2<)",
    "insertText": "OutRealType()"
  },
  {
    "label": "ToRet()",
    "kind": "Method",
    "detail": "Function (TBox2<OutRealType>)",
    "insertText": "ToRet((TVector2<OutRealType>)Min, (TVector2<OutRealType>)Max)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "X((Index % 3) == 0) ? (Min.X) : (Max.X)"
  },
  {
    "label": "Y()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Y((Index & 2) == 0) ? (Min.Y) : (Max.Y)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Contain(const TVector2<RealType>& V)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Max . Y = V . Y ; } } void)",
    "insertText": "Contain(const TAxisAlignedBox2<RealType>& Other)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (Min . X = Min . X<Other . Min . X ? Min . X : Other . Min . X ; Min . Y = Min . Y<Other . Min . Y ? Min . Y : Other . Min . Y ; Max . X = Max . X> Other . Max . X ? Max . X : Other . Max . X ; Max . Y = Max . Y> Other . Max . Y ? Max . Y : Other . Max . Y ; } void)",
    "insertText": "Contain(const TArray<TVector2<RealType>>& Pts)"
  },
  {
    "label": "Contain()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Contain(TArrayView<const TVector2<RealType>> Pts)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "Contains(const TVector2<RealType>& V)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(const TAxisAlignedBox2<RealType>& Box)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (} TVector<RealType>)",
    "insertText": "Clamp(const TVector2<RealType>& V)"
  },
  {
    "label": "Intersects()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Intersects(const TAxisAlignedBox2<RealType>& Box)"
  },
  {
    "label": "Intersect()",
    "kind": "Method",
    "detail": "Function (} TAxisAlignedBox2<RealType>)",
    "insertText": "Intersect(const TAxisAlignedBox2<RealType> &Box)"
  },
  {
    "label": "Intersection()",
    "kind": "Method",
    "detail": "Function (TAxisAlignedBox2<RealType>)",
    "insertText": "Intersection(TVector2<RealType>(TMathUtil<RealType>::Max(Min.X, Box.Min.X), TMathUtil<RealType>::Max(Min.Y, Box.Min.Y)), TVector2<RealType>(TMathUtil<RealType>::Min(Max.X, Box.Max.X), TMathUtil<RealType>::Min(Max.Y, Box.Max.Y)))"
  },
  {
    "label": "DistanceSquared()",
    "kind": "Method",
    "detail": "Function (} else { return Intersection ; } } RealType)",
    "insertText": "DistanceSquared(const TVector2<RealType>& V)"
  },
  {
    "label": "Area()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "Area()"
  },
  {
    "label": "Perimeter()",
    "kind": "Method",
    "detail": "Function (} RealType)",
    "insertText": "Perimeter()"
  }
]