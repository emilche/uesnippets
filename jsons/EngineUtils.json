[
  {
    "label": "FCanvas",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCanvas"
  },
  {
    "label": "FViewport",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FViewport"
  },
  {
    "label": "UCanvas",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UCanvas"
  },
  {
    "label": "UConsole",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UConsole"
  },
  {
    "label": "UPrimitiveComponent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UPrimitiveComponent"
  },
  {
    "label": "HActor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HActor"
  },
  {
    "label": "HBSPBrushVert",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HBSPBrushVert"
  },
  {
    "label": "HStaticMeshVert",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HStaticMeshVert"
  },
  {
    "label": "HTranslucentActor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HTranslucentActor"
  },
  {
    "label": "FActorIteratorState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FActorIteratorState"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "TActorIteratorBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TActorIteratorBase"
  },
  {
    "label": "FActorIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FActorIterator"
  },
  {
    "label": "FActorRange",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FActorRange"
  },
  {
    "label": "TActorIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TActorIterator"
  },
  {
    "label": "TActorRange",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TActorRange"
  },
  {
    "label": "FSelectedActorIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSelectedActorIterator"
  },
  {
    "label": "FSelectedActorRange",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSelectedActorRange"
  },
  {
    "label": "FConsoleOutputDevice",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConsoleOutputDevice"
  },
  {
    "label": "FName",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FName"
  },
  {
    "label": "FDebugDisplayProperty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDebugDisplayProperty"
  },
  {
    "label": "FSubLevelActorDetails",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSubLevelActorDetails"
  },
  {
    "label": "FSubLevelStatus",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSubLevelStatus"
  },
  {
    "label": "FContentComparisonAssetInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FContentComparisonAssetInfo"
  },
  {
    "label": "FContentComparisonHelper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FContentComparisonHelper"
  },
  {
    "label": "EAssetToLoad",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EAssetToLoad"
  },
  {
    "label": "FStripDataFlags",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FStripDataFlags"
  },
  {
    "label": "UTexture",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UTexture"
  },
  {
    "label": "DECLARE_HIT_PROXY()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / ObjectMacros . h \" # include \" Templates / SubclassOf . h \" # include \" Engine / EngineTypes . h \" # include \" GameFramework / Actor . h \" # include \" HitProxies . h \" # include \" Engine / Level . h \" # include \" Engine / World . h \" # include \" UObject / UObjectHash . h \" # include \" ProfilingDebugging / ProfilingHelpers . h \" # include \" GameFramework / WorldSettings . h \" # if WITH_EDITOR # include \" Algo / Accumulate . h \" # include \" Algo / Copy . h \" # endif class FCanvas ; class FViewport ; class UCanvas ; class UConsole ; class UPrimitiveComponent ; struct HActor : public HHitProxy {)",
    "insertText": "DECLARE_HIT_PROXY(ENGINE_API)"
  },
  {
    "label": "HActor()",
    "kind": "Method",
    "detail": "Function (TObjectPtr<const UPrimitiveComponent> PrimComponent ; int32 SectionIndex ; int32 MaterialIndex ;)",
    "insertText": "HActor(AActor* InActor, const UPrimitiveComponent* InPrimComponent ) : Actor( InActor ) , PrimComponent( InPrimComponent ) , SectionIndex( -1 ) , MaterialIndex( -1)"
  },
  {
    "label": "HActor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "HActor(AActor* InActor, const UPrimitiveComponent* InPrimComponent, int32 InSectionIndex, int32 InMaterialIndex) : Actor( InActor ) , PrimComponent( InPrimComponent ) , SectionIndex(InSectionIndex) , MaterialIndex( InMaterialIndex)"
  },
  {
    "label": "HActor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "HActor(AActor* InActor, const UPrimitiveComponent* InPrimComponent, EHitProxyPriority InPriority) : HHitProxy( InPriority ) , Actor( InActor ) , PrimComponent( InPrimComponent ) , SectionIndex( -1 ) , MaterialIndex( -1)"
  },
  {
    "label": "HActor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "HActor(AActor* InActor, const UPrimitiveComponent* InPrimComponent, EHitProxyPriority InPriority, int32 InSectionIndex, int32 InMaterialIndex) : HHitProxy(InPriority) , Actor(InActor) , PrimComponent(InPrimComponent) , SectionIndex(InSectionIndex) , MaterialIndex(InMaterialIndex)"
  },
  {
    "label": "AddReferencedObjects()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddReferencedObjects(FReferenceCollector& Collector)"
  },
  {
    "label": "GetMouseCursor()",
    "kind": "Method",
    "detail": "Function (EMouseCursor::Type)",
    "insertText": "GetMouseCursor()"
  },
  {
    "label": "GetElementHandle()",
    "kind": "Method",
    "detail": "Function (FTypedElementHandle)",
    "insertText": "GetElementHandle()"
  },
  {
    "label": "AlwaysAllowsTranslucentPrimitives()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AlwaysAllowsTranslucentPrimitives()"
  },
  {
    "label": "HBSPBrushVert()",
    "kind": "Method",
    "detail": "Function (TWeakObjectPtr<ABrush> Brush ; FVector3f* Vertex ;)",
    "insertText": "HBSPBrushVert(ABrush* InBrush,FVector3f* InVertex): HHitProxy(HPP_UI), Brush(InBrush), Vertex(InVertex)"
  },
  {
    "label": "HStaticMeshVert()",
    "kind": "Method",
    "detail": "Function (TObjectPtr<AActor> Actor ; FVector Vertex ;)",
    "insertText": "HStaticMeshVert(AActor* InActor,FVector InVertex): HHitProxy(HPP_UI), Actor(InActor), Vertex(InVertex)"
  },
  {
    "label": "AddReferencedObject()",
    "kind": "Method",
    "detail": "Function (Collector .)",
    "insertText": "AddReferencedObject(Actor)"
  },
  {
    "label": "DECLARE_HIT_PROXY()",
    "kind": "Method",
    "detail": "Function (} } ; struct HTranslucentActor : public HActor {)",
    "insertText": "DECLARE_HIT_PROXY(ENGINE_API ) HTranslucentActor( AActor* InActor, const UPrimitiveComponent* InPrimComponent ) : HActor( InActor, InPrimComponent)"
  },
  {
    "label": "HTranslucentActor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "HTranslucentActor(AActor* InActor, const UPrimitiveComponent* InPrimComponent, EHitProxyPriority InPriority) : HActor(InActor, InPrimComponent, InPriority)"
  },
  {
    "label": "FActorIteratorState()",
    "kind": "Method",
    "detail": "Function (} ; class FActorIteratorState { public : const UWorld* CurrentWorld ; TArray<AActor*> ActorArray ; int32 Index ; bool ReachedEnd ; int32 ConsideredCount ; AActor* CurrentActor ; TArray<AActor*> SpawnedActorArray ; UClass* DesiredClass ; FDelegateHandle ActorSpawnedDelegateHandle ;)",
    "insertText": "FActorIteratorState(const UWorld* InWorld, const TSubclassOf<AActor> InClass) : CurrentWorld( InWorld ), Index( -1 ), ReachedEnd( false ), ConsideredCount( 0 ), CurrentActor(nullptr), DesiredClass(InClass)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR TArray<AActor*> LocalActorsOfClass ;)",
    "insertText": "if(InClass != AActor::StaticClass())"
  },
  {
    "label": "GetObjectsOfClass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetObjectsOfClass(InClass, reinterpret_cast<TArray<UObject*>&>(LocalActorsOfClass), true, RF_ClassDefaultObject, EInternalObjectFlags::Garbage)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (MaxActors + = Level -> Actors .)",
    "insertText": "Num()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} } TArray<AActor*> LocalWorldActors ; LocalWorldActors .)",
    "insertText": "Reserve(MaxActors)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (LocalWorldActors .)",
    "insertText": "Append(InWorld->PersistentLevel->Actors)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(ULevel* Level : InWorld->GetLevels())"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (LocalWorldActors .)",
    "insertText": "Append(Level->Actors)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (ActorArray .)",
    "insertText": "Reserve(LocalActorsOfClass.Num())"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const bool bLookUpInActorsOfClass = LocalActorsOfClass .)",
    "insertText": "Num() < LocalWorldActors.Num()"
  },
  {
    "label": "LookUpSet()",
    "kind": "Method",
    "detail": "Function (TSet<AActor*>)",
    "insertText": "LookUpSet(bLookUpInActorsOfClass ? LocalActorsOfClass : LocalWorldActors)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<AActor*>& ArrayToIterate = bLookUpInActorsOfClass ? LocalWorldActors : LocalActorsOfClass ;)",
    "insertText": "for(AActor* Actor : ArrayToIterate)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ActorArray .)",
    "insertText": "Add(Actor)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "Swap(LocalWorldActors, ActorArray)"
  },
  {
    "label": "GetObjectsOfClass()",
    "kind": "Method",
    "detail": "Function (} # else EObjectFlags ExcludeFlags = RF_ClassDefaultObject ;)",
    "insertText": "GetObjectsOfClass(InClass, reinterpret_cast<TArray<UObject*>&>(ActorArray), true, ExcludeFlags, EInternalObjectFlags::Garbage)"
  },
  {
    "label": "CreateRaw()",
    "kind": "Method",
    "detail": "Function (# endif const auto ActorSpawnedDelegate = FOnActorSpawned::)",
    "insertText": "CreateRaw(this, &FActorIteratorState::OnActorSpawned)"
  },
  {
    "label": "AddOnActorSpawnedHandler()",
    "kind": "Method",
    "detail": "Function (ActorSpawnedDelegateHandle = CurrentWorld ->)",
    "insertText": "AddOnActorSpawnedHandler(ActorSpawnedDelegate)"
  },
  {
    "label": "FActorIteratorState()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FActorIteratorState()"
  },
  {
    "label": "RemoveOnActorSpawnedHandler()",
    "kind": "Method",
    "detail": "Function (CurrentWorld ->)",
    "insertText": "RemoveOnActorSpawnedHandler(ActorSpawnedDelegateHandle)"
  },
  {
    "label": "GetActorChecked()",
    "kind": "Method",
    "detail": "Function (} AActor*)",
    "insertText": "GetActorChecked()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR)",
    "insertText": "if(ULevel* ActorLevel = InActor->GetLevel(); ActorLevel && (ActorLevel->GetWorld() == CurrentWorld))"
  },
  {
    "label": "AddUnique()",
    "kind": "Method",
    "detail": "Function (SpawnedActorArray .)",
    "insertText": "AddUnique(InActor)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (} } } } ; enum class EActorIteratorType { End } ; enum class EActorIteratorFlags { AllActors = 0 x00000000,SkipPendingKill = 0 x00000001,OnlySelectedActors = 0 x00000002,OnlyActiveLevels = 0 x00000004,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(EActorIteratorFlags)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<Derived> class TActorIteratorBase { public : void)",
    "insertText": "operator()"
  },
  {
    "label": "GetLevel()",
    "kind": "Method",
    "detail": "Function (LocalCurrentActor = LocalActorArray [ LocalIndex ] ; } else { LocalCurrentActor = LocalSpawnedActorArray [ LocalIndex - LocalActorArrayNum ] ; } State -> ConsideredCount + + ; ULevel* ActorLevel = LocalCurrentActor ? LocalCurrentActor ->)",
    "insertText": "GetLevel()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "RemoveActor()",
    "kind": "Method",
    "detail": "Function (State -> CurrentWorld ->)",
    "insertText": "RemoveActor(State->CurrentActor, true)"
  },
  {
    "label": "GetProgressNumerator()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetProgressNumerator()"
  },
  {
    "label": "TActorIteratorBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TActorIteratorBase(const UWorld* InWorld, TSubclassOf<AActor> InClass, const EActorIteratorFlags InFlags) : Flags(InFlags)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (State .)",
    "insertText": "Emplace(InWorld, InClass)"
  },
  {
    "label": "IsActorSuitable()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsActorSuitable(const AActor* Actor)"
  },
  {
    "label": "bIsLevelVisibleOrAssociating()",
    "kind": "Method",
    "detail": "Function (bIsAssociatingLevel || Level->bIsDisassociatingLevel)",
    "insertText": "bIsLevelVisibleOrAssociating(Level->bIsVisible && !Level->bIsBeingRemoved)"
  },
  {
    "label": "GetCachedLevelCollection()",
    "kind": "Method",
    "detail": "Function (const FLevelCollection* const ActorLevelCollection = Level ->)",
    "insertText": "GetCachedLevelCollection()"
  },
  {
    "label": "GetActiveLevelCollection()",
    "kind": "Method",
    "detail": "Function (const FLevelCollection* const ActiveLevelCollection = Level -> OwningWorld ? Level -> OwningWorld ->)",
    "insertText": "GetActiveLevelCollection()"
  },
  {
    "label": "ActiveLevelCollection()",
    "kind": "Method",
    "detail": "Function (const bool bIsCurrentLevelCollectionTicking = !)",
    "insertText": "ActiveLevelCollection(ActorLevelCollection == ActiveLevelCollection)"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (const bool bIsLevelCollectionNullOrStatic = ! ActorLevelCollection | | ActorLevelCollection ->)",
    "insertText": "GetType()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (const bool bShouldIterateLevelCollection = bIsCurrentLevelCollectionTicking | | bIsLevelCollectionNullOrStatic ; return bIsLevelVisibleOrAssociating&& bShouldIterateLevelCollection ; } return true ; } private : EActorIteratorFlags Flags ; TOptional<FActorIteratorState> State ; bool)",
    "insertText": "operator(const TActorIteratorBase& Lhs, const TActorIteratorBase& Rhs)"
  },
  {
    "label": "FActorIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FActorIterator(const UWorld* InWorld, const TSubclassOf<AActor> InClass, const EActorIteratorFlags InFlags = EActorIteratorFlags::OnlyActiveLevels | EActorIteratorFlags::SkipPendingKill) : Super(InWorld, InClass, InFlags)"
  },
  {
    "label": "FActorIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FActorIterator(EActorIteratorType) : Super(EActorIteratorType::End)"
  },
  {
    "label": "FActorRange()",
    "kind": "Method",
    "detail": "Function (} } ; class FActorRange { public :)",
    "insertText": "FActorRange(const UWorld* InWorld, const EActorIteratorFlags InFlags = EActorIteratorFlags::OnlyActiveLevels | EActorIteratorFlags::SkipPendingKill) : Flags(InFlags) , World(InWorld)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} private : EActorIteratorFlags Flags ; const UWorld* World ; FActorIterator)",
    "insertText": "begin(const FActorRange& Range)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} FActorIterator)",
    "insertText": "end(const FActorRange& Range)"
  },
  {
    "label": "TActorIterator()",
    "kind": "Method",
    "detail": "Function (} } ; template<ActorType> class TActorIterator : public TActorIteratorBase<TActorIterator<ActorType>> { class TActorIteratorBase<TActorIterator> ; typedef TActorIteratorBase<TActorIterator> Super ; public :)",
    "insertText": "TActorIterator(const UWorld* InWorld, TSubclassOf<ActorType> InClass = ActorType::StaticClass(), EActorIteratorFlags InFlags = EActorIteratorFlags::OnlyActiveLevels | EActorIteratorFlags::SkipPendingKill) : Super(InWorld, InClass, InFlags)"
  },
  {
    "label": "TActorIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TActorIterator(EActorIteratorType) : Super(EActorIteratorType::End)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} private : EActorIteratorFlags Flags ; const UWorld* World ; TSubclassOf<ActorType> Class ; TActorIterator<ActorType>)",
    "insertText": "begin(const TActorRange& Range)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} TActorIterator<ActorType>)",
    "insertText": "end(const TActorRange& Range)"
  },
  {
    "label": "FSelectedActorIterator()",
    "kind": "Method",
    "detail": "Function (} } ; class FSelectedActorIterator : public TActorIteratorBase<FSelectedActorIterator> { class TActorIteratorBase<FSelectedActorIterator> ; typedef TActorIteratorBase<FSelectedActorIterator> Super ; public :)",
    "insertText": "FSelectedActorIterator(const UWorld* InWorld) : Super(InWorld, AActor::StaticClass(), EActorIteratorFlags::SkipPendingKill | EActorIteratorFlags::OnlySelectedActors)"
  },
  {
    "label": "FSelectedActorIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSelectedActorIterator(const UWorld* InWorld, const TSubclassOf<AActor> InClass) : Super(InWorld, InClass, EActorIteratorFlags::SkipPendingKill | EActorIteratorFlags::OnlySelectedActors)"
  },
  {
    "label": "FSelectedActorIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSelectedActorIterator(EActorIteratorType) : Super(EActorIteratorType::End)"
  },
  {
    "label": "FSelectedActorRange()",
    "kind": "Method",
    "detail": "Function (} } ; class FSelectedActorRange { public :)",
    "insertText": "FSelectedActorRange(const UWorld* InWorld) : World(InWorld)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} private : const UWorld* World ; FSelectedActorIterator)",
    "insertText": "begin(const FSelectedActorRange& Range)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} FSelectedActorIterator)",
    "insertText": "end(const FSelectedActorRange& Range)"
  },
  {
    "label": "FConsoleOutputDevice()",
    "kind": "Method",
    "detail": "Function (} } ; class FConsoleOutputDevice : public FStringOutputDevice { typedef FStringOutputDevice Super ; public :)",
    "insertText": "FConsoleOutputDevice(class UConsole* InConsole): Super(TEXT(\"\")), Console(InConsole)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Serialize(const TCHAR* Text, ELogVerbosity::Type Verbosity, const class FName& Category)"
  },
  {
    "label": "DrawStatsHUD()",
    "kind": "Method",
    "detail": "Function (private : UConsole* Console ; } ; void)",
    "insertText": "DrawStatsHUD(UWorld* InWorld, FViewport* Viewport, FCanvas* Canvas, UCanvas* CanvasObject, TArray<struct FDebugDisplayProperty>& DebugProperties, const FVector& ViewLocation, const FRotator& ViewRotation)"
  },
  {
    "label": "FSubLevelActorDetails()",
    "kind": "Method",
    "detail": "Function (struct FSubLevelActorDetails {)",
    "insertText": "FSubLevelActorDetails() : Count(0) , NativeClassName(NAME_None)"
  },
  {
    "label": "GetSubLevelsStatus()",
    "kind": "Method",
    "detail": "Function (} int32 Count ; FName NativeClassName ; } ; struct FSubLevelStatus { FName PackageName ; FString LevelLabel ; EStreamingStatus StreamingStatus ; int32 LODIndex ; bool bInConsiderList ; bool bPlayerInside ; int32 ActorCount ; TMap<FName,FSubLevelActorDetails> ActorMapToCount ; } ; TArray<FSubLevelStatus>)",
    "insertText": "GetSubLevelsStatus(UWorld* InWorld, bool SortByActorCount = false)"
  },
  {
    "label": "FContentComparisonAssetInfo()",
    "kind": "Method",
    "detail": "Function (# if ! UE_BUILD_SHIPPING struct FContentComparisonAssetInfo { FString AssetName ; int32 ResourceSize ;)",
    "insertText": "FContentComparisonAssetInfo()"
  },
  {
    "label": "Memzero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memzero(this, sizeof(FContentComparisonAssetInfo))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FContentComparisonAssetInfo& Other)"
  },
  {
    "label": "FContentComparisonHelper()",
    "kind": "Method",
    "detail": "Function (} } ; class FContentComparisonHelper { public :)",
    "insertText": "FContentComparisonHelper()"
  },
  {
    "label": "CompareClasses()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CompareClasses(const FString& InBaseClassName, int32 InRecursionDepth)"
  },
  {
    "label": "CompareClasses()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CompareClasses(const FString& InBaseClassName, const TArray<FString>& InBaseClassesToIgnore, int32 InRecursionDepth)"
  },
  {
    "label": "RecursiveObjectCollection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecursiveObjectCollection(UObject* InStartObject, int32 InCurrDepth, int32 InMaxDepth, TMap<UObject*,bool>& OutCollectedReferences)"
  },
  {
    "label": "FindOrLoadAssetsByPath()",
    "kind": "Method",
    "detail": "Function (protected : TMap<FString,bool> ReferenceClassesOfInterest ; } ; # endif namespace EngineUtils { enum EAssetToLoad { ATL_Regular,ATL_Class,} ; bool)",
    "insertText": "FindOrLoadAssetsByPath(const FString& Path, TArray<UObject*>& OutAssets, EAssetToLoad Type)"
  },
  {
    "label": "FStripDataFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FStripDataFlags(FArchive& Ar, uint8 InClassFlags = 0, const FPackageFileVersion& InVersion = GOldestLoadablePackageFileUEVersion)"
  },
  {
    "label": "FStripDataFlags()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FStripDataFlags(FArchive& Ar, uint8 InGlobalFlags, uint8 InClassFlags, const FPackageFileVersion& InVersion = GOldestLoadablePackageFileUEVersion)"
  },
  {
    "label": "FStripDataFlags()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FStripDataFlags(FStructuredArchive::FSlot Slot, uint8 InClassFlags = 0, const FPackageFileVersion& InVersion = GOldestLoadablePackageFileUEVersion)"
  },
  {
    "label": "FStripDataFlags()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FStripDataFlags(FStructuredArchive::FSlot Slot, uint8 InGlobalFlags, uint8 InClassFlags, const FPackageFileVersion& InVersion = GOldestLoadablePackageFileUEVersion)"
  },
  {
    "label": "IsEditorDataStripped()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEditorDataStripped()"
  },
  {
    "label": "IsAudioVisualDataStripped()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsAudioVisualDataStripped()"
  },
  {
    "label": "IsDataNeededForCookingStripped()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDataNeededForCookingStripped()"
  },
  {
    "label": "IsClassDataStripped()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsClassDataStripped(uint8 InFlags)"
  },
  {
    "label": "CheckAndReportInvalidUsage()",
    "kind": "Method",
    "detail": "Function (} } ; class UTexture ; namespace VirtualTextureUtils { void)",
    "insertText": "CheckAndReportInvalidUsage(const UObject* Owner, const FName& PropertyName, const UTexture* Texture)"
  }
]