[
  {
    "label": "UWorld",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UWorld"
  },
  {
    "label": "UWorldPartition",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UWorldPartition"
  },
  {
    "label": "FWorldPartitionActorDesc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FWorldPartitionActorDesc"
  },
  {
    "label": "FWorldPartitionActorDescInstance",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FWorldPartitionActorDescInstance"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "FWorldPartitionHelpers",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FWorldPartitionHelpers"
  },
  {
    "label": "ActorClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ActorClass"
  },
  {
    "label": "TDeprecated",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TDeprecated"
  },
  {
    "label": "FForEachActorWithLoadingParams",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FForEachActorWithLoadingParams"
  },
  {
    "label": "FForEachActorWithLoadingResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FForEachActorWithLoadingResult"
  },
  {
    "label": "GetWorldPartitionFromObject()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" GameFramework / Actor . h \" # include \" Engine / World . h \" # include \" Engine / Level . h \" # include \" WorldPartition / WorldPartitionRuntimeCellInterface . h \" # if WITH_EDITOR # include \" WorldPartition / WorldPartitionHandle . h \" # endif class UWorld ; class UWorldPartition ; # if WITH_EDITOR class FWorldPartitionActorDesc ; class FWorldPartitionActorDescInstance ; # endif namespace FWorldPartitionHelpersPrivate { UWorldPartition*)",
    "insertText": "GetWorldPartitionFromObject(const UObject* InObject)"
  },
  {
    "label": "GetWorldPartition()",
    "kind": "Method",
    "detail": "Function (template<class T> UWorldPartition*)",
    "insertText": "GetWorldPartition(const T* InObject)"
  },
  {
    "label": "GetWorldPartition()",
    "kind": "Method",
    "detail": "Function (} template<> UWorldPartition*)",
    "insertText": "GetWorldPartition(const ULevel* InLevel)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(const UWorld* OuterWorld = Cast<UWorld>(InLevel->GetOuter()))"
  },
  {
    "label": "GetWorldPartition()",
    "kind": "Method",
    "detail": "Function (} } return nullptr ; } template<> UWorldPartition*)",
    "insertText": "GetWorldPartition(const UWorld* InWorld)"
  },
  {
    "label": "GetWorldPartition()",
    "kind": "Method",
    "detail": "Function (} template<> UWorldPartition*)",
    "insertText": "GetWorldPartition(const AActor* InActor)"
  },
  {
    "label": "ServerExecConsoleCommand()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ServerExecConsoleCommand(UWorld* InWorld, const FString& InConsoleCommandName, const TArray<FString>& InArgs)"
  },
  {
    "label": "IsActorDescClassCompatibleWith()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR private : bool)",
    "insertText": "IsActorDescClassCompatibleWith(const FWorldPartitionActorDesc* ActorDesc, const UClass* Class)"
  },
  {
    "label": "ForEachIntersectingActorDesc()",
    "kind": "Method",
    "detail": "Function (} } ; public : template<class ActorClass = AActor> void)",
    "insertText": "ForEachIntersectingActorDesc(UWorldPartition* WorldPartition, const FBox& Box, TFunctionRef<bool(const FWorldPartitionActorDesc*)> Func)"
  },
  {
    "label": "DeprecatedForEachIntersectingActorDesc()",
    "kind": "Method",
    "detail": "Function (TDeprecated<ActorClass)",
    "insertText": "DeprecatedForEachIntersectingActorDesc()"
  },
  {
    "label": "ForEachActorDesc()",
    "kind": "Method",
    "detail": "Function (} template<class ActorClass = AActor> void)",
    "insertText": "ForEachActorDesc(UWorldPartition* WorldPartition, TFunctionRef<bool(const FWorldPartitionActorDesc*)> Func)"
  },
  {
    "label": "DeprecatedForEachActorDesc()",
    "kind": "Method",
    "detail": "Function (TDeprecated<ActorClass)",
    "insertText": "DeprecatedForEachActorDesc()"
  },
  {
    "label": "ForEachIntersectingActorDescInstance()",
    "kind": "Method",
    "detail": "Function (} template<class ActorClass = AActor> void)",
    "insertText": "ForEachIntersectingActorDescInstance(UWorldPartition* WorldPartition, const FBox& Box, TFunctionRef<bool(const FWorldPartitionActorDescInstance*)> Func)"
  },
  {
    "label": "ForEachActorDescInstance()",
    "kind": "Method",
    "detail": "Function (} template<class ActorClass = AActor> void)",
    "insertText": "ForEachActorDescInstance(UWorldPartition* WorldPartition, TFunctionRef<bool(const FWorldPartitionActorDescInstance*)> Func)"
  },
  {
    "label": "ForEachIntersectingActorDescInstance()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ForEachIntersectingActorDescInstance(UWorldPartition* WorldPartition, const FBox& Box, TSubclassOf<AActor> ActorClass, TFunctionRef<bool(const FWorldPartitionActorDescInstance*)> Func)"
  },
  {
    "label": "ForEachActorDescInstance()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForEachActorDescInstance(UWorldPartition* WorldPartition, TSubclassOf<AActor> ActorClass, TFunctionRef<bool(const FWorldPartitionActorDescInstance*)> Func)"
  },
  {
    "label": "FForEachActorWithLoadingParams()",
    "kind": "Method",
    "detail": "Function (struct FForEachActorWithLoadingParams {)",
    "insertText": "FForEachActorWithLoadingParams()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (bool bGCPerActor ; bool bKeepReferences ; TArray<TSubclassOf<AActor>> ActorClasses ; TArray<FGuid> ActorGuids ; TUniqueFunction<)",
    "insertText": "bool(const FWorldPartitionActorDesc*)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (TUniqueFunction<)",
    "insertText": "void()"
  },
  {
    "label": "ForEachActorWithLoading()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ForEachActorWithLoading(UWorldPartition* WorldPartition, TFunctionRef<bool(const FWorldPartitionActorDescInstance*)> Func, const FForEachActorWithLoadingParams& Params = FForEachActorWithLoadingParams())"
  },
  {
    "label": "ForEachActorWithLoading()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ForEachActorWithLoading(UWorldPartition* WorldPartition, TFunctionRef<bool(const FWorldPartitionActorDescInstance*)> Func, const FForEachActorWithLoadingParams& Params, FForEachActorWithLoadingResult& Result)"
  },
  {
    "label": "HasExceededMaxMemory()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasExceededMaxMemory()"
  },
  {
    "label": "ShouldCollectGarbage()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldCollectGarbage()"
  },
  {
    "label": "DoCollectGarbage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DoCollectGarbage()"
  },
  {
    "label": "FakeEngineTick()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FakeEngineTick(UWorld* World)"
  },
  {
    "label": "ConvertRuntimePathToEditorPath()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ConvertRuntimePathToEditorPath(const FSoftObjectPath& InPath, FSoftObjectPath& OutPath)"
  },
  {
    "label": "GetLoadedActorsForLevel()",
    "kind": "Method",
    "detail": "Function (TMap<FGuid,AActor*>)",
    "insertText": "GetLoadedActorsForLevel(const ULevel* InLevel)"
  },
  {
    "label": "GetRegisteredActorsForLevel()",
    "kind": "Method",
    "detail": "Function (TMap<FGuid,AActor*>)",
    "insertText": "GetRegisteredActorsForLevel(const ULevel* InLevel)"
  },
  {
    "label": "ConvertEditorPathToRuntimePath()",
    "kind": "Method",
    "detail": "Function (# endif bool)",
    "insertText": "ConvertEditorPathToRuntimePath(const FSoftObjectPath& InPath, FSoftObjectPath& OutPath)"
  }
]