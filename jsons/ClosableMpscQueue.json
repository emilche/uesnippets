[
  {
    "label": "TClosableMpscQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TClosableMpscQueue"
  },
  {
    "label": "FNode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNode"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Templates / TypeCompatibleBytes . h \" # include \" Templates / UnrealTemplate . h \" # include<atomic> template<T> class TClosableMpscQueue final { public :)",
    "insertText": "UE_NONCOPYABLE(TClosableMpscQueue)"
  },
  {
    "label": "TClosableMpscQueue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TClosableMpscQueue()"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (FNode* Next = Tail -> Next .)",
    "insertText": "load(std::memory_order_relaxed)"
  },
  {
    "label": "DestructItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItem((T*)&Tail->Value)"
  },
  {
    "label": "Enqueue()",
    "kind": "Method",
    "detail": "Function (delete Tail ; Tail = Next ; } } template<. . . ArgTypes> bool)",
    "insertText": "Enqueue(ArgTypes&&... Args)"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (FNode* Prev = Head .)",
    "insertText": "load(std::memory_order_acquire)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Prev == nullptr)"
  },
  {
    "label": "DestructItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItem((T*)&New->Value)"
  },
  {
    "label": "store()",
    "kind": "Method",
    "detail": "Function (delete New ; return false ; } Prev -> Next .)",
    "insertText": "store(New, std::memory_order_release)"
  },
  {
    "label": "exchange()",
    "kind": "Method",
    "detail": "Function (FNode* Tail =& Sentinel ; FNode* const Head_Local = Head .)",
    "insertText": "exchange(nullptr, std::memory_order_acq_rel)"
  },
  {
    "label": "Close_NonMember()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Close_NonMember(Head_Local, Tail, Consumer)"
  },
  {
    "label": "Close_NonMember()",
    "kind": "Method",
    "detail": "Function (} private : struct FNode { std::atomic<FNode*> Next { nullptr } ; TTypeCompatibleBytes<T> Value ; } ; FNode Sentinel ; std::atomic<FNode*> Head {& Sentinel } ; private : template<F> void)",
    "insertText": "Close_NonMember(FNode* Head, FNode* Tail, const F& Consumer)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(Next == nullptr)"
  },
  {
    "label": "Consumer()",
    "kind": "Method",
    "detail": "Function (auto Consume = [&)",
    "insertText": "Consumer(FNode* Node)"
  },
  {
    "label": "ValuePtr()",
    "kind": "Method",
    "detail": "Function (Value)",
    "insertText": "ValuePtr(T*)"
  },
  {
    "label": "Consumer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Consumer(MoveTemp(*ValuePtr))"
  },
  {
    "label": "DestructItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructItem(ValuePtr)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (delete Node ; } ;)",
    "insertText": "while(Tail != Head)"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (FNode* Next =)",
    "insertText": "GetNext(Tail)"
  },
  {
    "label": "Consume()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Consume(Tail)"
  },
  {
    "label": "Consume()",
    "kind": "Method",
    "detail": "Function (Tail = Next ; })",
    "insertText": "Consume(Head)"
  }
]