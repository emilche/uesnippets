[
  {
    "label": "FOrientedBox",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FOrientedBox"
  },
  {
    "label": "TIsPODType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsPODType"
  },
  {
    "label": "FOrientedBox()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Math / Vector . h \" # include \" Math / Interval . h \" struct FOrientedBox { FVector Center ; FVector AxisX ; FVector AxisY ; FVector AxisZ ; FVector::FReal ExtentX ; FVector::FReal ExtentY ; FVector::FReal ExtentZ ; public :)",
    "insertText": "FOrientedBox() : Center(0.0f) , AxisX(1.0f, 0.0f, 0.0f) , AxisY(0.0f, 1.0f, 0.0f) , AxisZ(0.0f, 0.0f, 1.0f) , ExtentX(1.0f) , ExtentY(1.0f) , ExtentZ(1.0f)"
  },
  {
    "label": "CalcVertices()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "CalcVertices(FVector* Verts)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const float Signs [ ] = { - 1 . 0 f,1 . 0 f } ;)",
    "insertText": "for(int32 i = 0; i < 2; i++)"
  },
  {
    "label": "Project()",
    "kind": "Method",
    "detail": "Function (* Verts + + = Center + Signs [ i ]* AxisX* ExtentX + Signs [ j ]* AxisY* ExtentY + Signs [ k ]* AxisZ* ExtentZ ; } } } } FFloatInterval)",
    "insertText": "Project(const FVector& Axis)"
  },
  {
    "label": "Axis()",
    "kind": "Method",
    "detail": "Function (const FVector::FReal Signs [ ] = { - 1 . 0 f,1 . 0 f } ; FVector::FReal ProjectedCenter = Axis | Center ; FVector::FReal ProjectedAxisX =)",
    "insertText": "Axis(ExtentX * AxisX)"
  },
  {
    "label": "Axis()",
    "kind": "Method",
    "detail": "Function (FVector::FReal ProjectedAxisY =)",
    "insertText": "Axis(ExtentY * AxisY)"
  },
  {
    "label": "Axis()",
    "kind": "Method",
    "detail": "Function (FVector::FReal ProjectedAxisZ =)",
    "insertText": "Axis(ExtentZ * AxisZ)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (float ProjectedVertex =)",
    "insertText": "float(ProjectedCenter + Signs[i] * ProjectedAxisX + Signs[j] * ProjectedAxisY + Signs[k] * ProjectedAxisZ)"
  },
  {
    "label": "Include()",
    "kind": "Method",
    "detail": "Function (ProjectionInterval .)",
    "insertText": "Include(ProjectedVertex)"
  }
]