[
  {
    "label": "FBlueprintDifferenceTreeEntry",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBlueprintDifferenceTreeEntry"
  },
  {
    "label": "ISourceControlRevision",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ISourceControlRevision"
  },
  {
    "label": "SWidget",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SWidget"
  },
  {
    "label": "UBlueprint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UBlueprint"
  },
  {
    "label": "UObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UObject"
  },
  {
    "label": "UStruct",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UStruct"
  },
  {
    "label": "FRevisionInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRevisionInfo"
  },
  {
    "label": "STreeView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "STreeView"
  },
  {
    "label": "FResolvedProperty",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FResolvedProperty"
  },
  {
    "label": "FPropertySoftPath",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPropertySoftPath"
  },
  {
    "label": "FChainElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FChainElement"
  },
  {
    "label": "FSCSIdentifier",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSCSIdentifier"
  },
  {
    "label": "FSCSResolvedIdentifier",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSCSResolvedIdentifier"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "FSingleObjectDiffEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSingleObjectDiffEntry"
  },
  {
    "label": "FSCSDiffEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSCSDiffEntry"
  },
  {
    "label": "FSCSDiffRoot",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSCSDiffRoot"
  },
  {
    "label": "FDiffParameters",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDiffParameters"
  },
  {
    "label": "FResolvedProperty()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / Set . h \" # if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_5 # include \" Containers / SparseArray . h \" # include \" CoreMinimal . h \" # endif # include \" Containers / UnrealString . h \" # include \" Delegates / Delegate . h \" # include \" HAL / Platform . h \" # include \" HAL / PlatformCrt . h \" # include \" Internationalization / Text . h \" # include \" Math / Color . h \" # include \" Misc / AssertionMacros . h \" # include \" PropertyPath . h \" # include \" Templates / SharedPointer . h \" # include \" Templates / TypeHash . h \" # include \" UObject / NameTypes . h \" # include \" UObject / UnrealType . h \" # include \" UObject / WeakFieldPtr . h \" # include \" Widgets / SBoxPanel . h \" # include \" Widgets / SWidget . h \" # include \" Widgets / Views / STreeView . h \" # include \" PropertyHandle . h \" class FBlueprintDifferenceTreeEntry ; class ISourceControlRevision ; class SWidget ; class UBlueprint ; class UObject ; class UStruct ; struct FRevisionInfo ; template<ItemType> class STreeView ; struct FResolvedProperty {)",
    "insertText": "FResolvedProperty() : Object(nullptr) , Property(nullptr)"
  },
  {
    "label": "FResolvedProperty()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FResolvedProperty(const void* InObject, const FProperty* InProperty) : Object(InObject) , Property(InProperty)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FResolvedProperty& RHS)"
  },
  {
    "label": "FPropertySoftPath()",
    "kind": "Method",
    "detail": "Function (} const void* Object ; const FProperty* Property ; } ; struct FPropertySoftPath {)",
    "insertText": "FPropertySoftPath()"
  },
  {
    "label": "FPropertySoftPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPropertySoftPath(const FProperty* Property)"
  },
  {
    "label": "FPropertySoftPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPropertySoftPath(TArray<FName> InPropertyChain)"
  },
  {
    "label": "FPropertySoftPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPropertySoftPath(FPropertyPath InPropertyPath)"
  },
  {
    "label": "FPropertySoftPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPropertySoftPath(const FPropertySoftPath& MainPropertyPath, const FPropertySoftPath& SubPropertyPath)"
  },
  {
    "label": "FPropertySoftPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPropertySoftPath(const FPropertySoftPath& SubPropertyPath, const FProperty* LeafProperty)"
  },
  {
    "label": "FPropertySoftPath()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPropertySoftPath(const FPropertySoftPath& SubPropertyPath, int32 ContainerIndex)"
  },
  {
    "label": "Resolve()",
    "kind": "Method",
    "detail": "Function (FResolvedProperty)",
    "insertText": "Resolve(const UObject* Object)"
  },
  {
    "label": "Resolve()",
    "kind": "Method",
    "detail": "Function (FResolvedProperty)",
    "insertText": "Resolve(const UStruct* Struct, const void* StructData)"
  },
  {
    "label": "ResolvePath()",
    "kind": "Method",
    "detail": "Function (FPropertyPath)",
    "insertText": "ResolvePath(const UObject* Object)"
  },
  {
    "label": "GetRootProperty()",
    "kind": "Method",
    "detail": "Function (FPropertySoftPath)",
    "insertText": "GetRootProperty(int32 Depth)"
  },
  {
    "label": "TryReadIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "TryReadIndex(int32 Index)"
  },
  {
    "label": "ToDisplayName()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ToDisplayName(const int32 NumberOfElements = INDEX_NONE)"
  },
  {
    "label": "IsSubPropertyMatch()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSubPropertyMatch(const FPropertySoftPath& PotentialBasePropertyPath)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(FPropertySoftPath const& RHS)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (PropertyChain .)",
    "insertText": "Append(RHS.PropertyChain)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (DisplayString = PropertyName .)",
    "insertText": "ToString()"
  },
  {
    "label": "FChainElement()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "FChainElement(const FProperty* Property)"
  },
  {
    "label": "GetFName()",
    "kind": "Method",
    "detail": "Function (PropertyName = Property ->)",
    "insertText": "GetFName()"
  },
  {
    "label": "GetAuthoredName()",
    "kind": "Method",
    "detail": "Function (DisplayString = Property ->)",
    "insertText": "GetAuthoredName()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "operator(FChainElement const& RHS)"
  },
  {
    "label": "TryReadIndex()",
    "kind": "Method",
    "detail": "Function (} } ; int32)",
    "insertText": "TryReadIndex(const TArray<FChainElement>& LocalPropertyChain, int32& OutIndex)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetTypeHash(FPropertySoftPath const& Path)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TArray<FChainElement> PropertyChain ; const UStruct* RootTypeHint ; } ; struct FSCSIdentifier { FName Name ; TArray<int32> TreeLocation ; } ; struct FSCSResolvedIdentifier { FSCSIdentifier Identifier ; const UObject* Object ; } ; bool)",
    "insertText": "operator(const FSCSIdentifier& A, const FSCSIdentifier& B)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (uint32 Ret = 0 ;)",
    "insertText": "for(const FPropertySoftPath::FChainElement& PropertyElement : Path.PropertyChain)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (Ret = Ret ^)",
    "insertText": "GetTypeHash(PropertyElement.PropertyName)"
  },
  {
    "label": "FSingleObjectDiffEntry()",
    "kind": "Method",
    "detail": "Function (} return Ret ; } typedef TSet<FPropertySoftPath> FPropertySoftPathSet ; namespace EPropertyDiffType { enum Type { Invalid,PropertyAddedToA,PropertyAddedToB,PropertyValueChanged,} ; } struct FSingleObjectDiffEntry {)",
    "insertText": "FSingleObjectDiffEntry() : Identifier() , DiffType(EPropertyDiffType::Invalid)"
  },
  {
    "label": "FSingleObjectDiffEntry()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSingleObjectDiffEntry(const FPropertySoftPath& InIdentifier, EPropertyDiffType::Type InDiffType ) : Identifier(InIdentifier) , DiffType(InDiffType)"
  },
  {
    "label": "FSCSDiffEntry()",
    "kind": "Method",
    "detail": "Function (} FPropertySoftPath Identifier ; EPropertyDiffType::Type DiffType ; } ; namespace ETreeDiffType { enum Type { NODE_ADDED,NODE_REMOVED,NODE_TYPE_CHANGED,NODE_PROPERTY_CHANGED,NODE_MOVED,NODE_CORRUPTED,NODE_FIXED } ; } struct FSCSDiffEntry {)",
    "insertText": "FSCSDiffEntry(const FSCSIdentifier& InIdentifier, ETreeDiffType::Type InDiffType, const FSingleObjectDiffEntry& InPropertyDiff ) : TreeIdentifier(InIdentifier) , DiffType(InDiffType) , PropertyDiff(InPropertyDiff)"
  },
  {
    "label": "DECLARE_DELEGATE_OneParam()",
    "kind": "Method",
    "detail": "Function (} FSCSIdentifier TreeIdentifier ; ETreeDiffType::Type DiffType ; FSingleObjectDiffEntry PropertyDiff ; } ; struct FSCSDiffRoot { TArray<FSCSDiffEntry> Entries ; } ; namespace DiffUtils {)",
    "insertText": "DECLARE_DELEGATE_OneParam(FOnGenerateCustomDiffEntries, TArray<FSingleObjectDiffEntry>&) DECLARE_DELEGATE_RetVal_TwoParams(TSharedRef<SWidget>, FOnGenerateCustomDiffEntryWidget, const FSingleObjectDiffEntry&, FText&) DECLARE_DELEGATE_FourParams(FOnOrganizeDiffEntries, TArray<TSharedPtr<FBlueprintDifferenceTreeEntry>>&, const TArray<FSingleObjectDiffEntry>&, TFunctionRef<TSharedPtr<FBlueprintDifferenceTreeEntry>(const FSingleObjectDiffEntry&)>, TFunctionRef<TSharedPtr<FBlueprintDifferenceTreeEntry>(FText&)>)"
  },
  {
    "label": "FDiffParameters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FDiffParameters()"
  },
  {
    "label": "FDiffParameters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FDiffParameters(const FPropertySoftPath& RootPath) : RootPath(RootPath)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} FPropertySoftPath RootPath ; TFunction<)",
    "insertText": "bool(const FProperty&)"
  },
  {
    "label": "GetCDO()",
    "kind": "Method",
    "detail": "Function (bool bShouldDiffArrayElements = true ; } ; const UObject*)",
    "insertText": "GetCDO(const UBlueprint* ForBlueprint)"
  },
  {
    "label": "CompareUnrelatedStructs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CompareUnrelatedStructs(const UStruct* StructA, const void* A, const UObject* OwningOuterA, const UStruct* StructB, const void* B, const UObject* OwningOuterB, TArray<FSingleObjectDiffEntry>& OutDifferingProperties)"
  },
  {
    "label": "CompareUnrelatedObjects()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CompareUnrelatedObjects(const UObject* A, const UObject* B, TArray<FSingleObjectDiffEntry>& OutDifferingProperties)"
  },
  {
    "label": "CompareUnrelatedSCS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CompareUnrelatedSCS(const UBlueprint* Old, const TArray< FSCSResolvedIdentifier >& OldHierarchy, const UBlueprint* New, const TArray< FSCSResolvedIdentifier >& NewHierarchy, FSCSDiffRoot& OutDifferingEntries)"
  },
  {
    "label": "Identical()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Identical(const FResolvedProperty& AProp, const FResolvedProperty& BProp, const UObject* OwningOuterA, const UObject* OwningOuterB)"
  },
  {
    "label": "Identical()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Identical(const FResolvedProperty& AProp, const FResolvedProperty& BProp, const UObject* OwningOuterA, const UObject* OwningOuterB, FDiffParameters DiffParameters, TArray<FPropertySoftPath>& DifferingProperties)"
  },
  {
    "label": "Identical()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Identical(const TSharedPtr<IPropertyHandle>& PropertyHandleA, const TSharedPtr<IPropertyHandle>& PropertyHandleB, const TArray<TWeakObjectPtr<UObject>>& OwningOutersA = {}, const TArray<TWeakObjectPtr<UObject>>& OwningOutersB = {})"
  },
  {
    "label": "Identical()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Identical(TArray<FPropertySoftPath>& OutDifferingProperties, const TSharedPtr<IPropertyHandle>& PropertyHandleA, const TSharedPtr<IPropertyHandle>& PropertyHandleB, const TArray<TWeakObjectPtr<UObject>>& OwningOutersA = {}, const TArray<TWeakObjectPtr<UObject>>& OwningOutersB = {})"
  },
  {
    "label": "GetVisiblePropertiesInOrderDeclared()",
    "kind": "Method",
    "detail": "Function (TArray<FPropertySoftPath>)",
    "insertText": "GetVisiblePropertiesInOrderDeclared(const UStruct* ForStruct, const FPropertySoftPath& Scope = FPropertySoftPath())"
  },
  {
    "label": "ResolveAll()",
    "kind": "Method",
    "detail": "Function (TArray<FPropertyPath>)",
    "insertText": "ResolveAll(const UObject* Object, const TArray<FPropertySoftPath>& InSoftProperties)"
  },
  {
    "label": "ResolveAll()",
    "kind": "Method",
    "detail": "Function (TArray<FPropertyPath>)",
    "insertText": "ResolveAll(const UObject* Object, const TArray<FSingleObjectDiffEntry>& InDifferences)"
  },
  {
    "label": "LoadPackageForDiff()",
    "kind": "Method",
    "detail": "Function (UPackage*)",
    "insertText": "LoadPackageForDiff(const FPackagePath& InTempPackagePath, const FPackagePath& InOriginalPackagePath)"
  },
  {
    "label": "LoadPackageForDiff()",
    "kind": "Method",
    "detail": "Function (UPackage*)",
    "insertText": "LoadPackageForDiff(TSharedPtr<ISourceControlRevision> Revision)"
  },
  {
    "label": "DECLARE_DELEGATE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DECLARE_DELEGATE(FOnDiffEntryFocused)"
  },
  {
    "label": "DECLARE_DELEGATE_RetVal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_DELEGATE_RetVal(TSharedRef<SWidget>, FGenerateDiffEntryWidget)"
  },
  {
    "label": "FBlueprintDifferenceTreeEntry()",
    "kind": "Method",
    "detail": "Function (class FBlueprintDifferenceTreeEntry { public :)",
    "insertText": "FBlueprintDifferenceTreeEntry(FOnDiffEntryFocused InOnFocus, FGenerateDiffEntryWidget InGenerateWidget, TArray< TSharedPtr<FBlueprintDifferenceTreeEntry> > InChildren = TArray< TSharedPtr<FBlueprintDifferenceTreeEntry> >()) : OnFocus(InOnFocus) , GenerateWidget(InGenerateWidget) , Children(InChildren)"
  },
  {
    "label": "FBlueprintDifferenceTreeEntry()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FBlueprintDifferenceTreeEntry()"
  },
  {
    "label": "NoDifferencesEntry()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<FBlueprintDifferenceTreeEntry>)",
    "insertText": "NoDifferencesEntry()"
  },
  {
    "label": "UnknownDifferencesEntry()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<FBlueprintDifferenceTreeEntry>)",
    "insertText": "UnknownDifferencesEntry()"
  },
  {
    "label": "CreateCategoryEntry()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<FBlueprintDifferenceTreeEntry>)",
    "insertText": "CreateCategoryEntry(const FText& LabelText, const FText& ToolTipText, FOnDiffEntryFocused FocusCallback, const TArray< TSharedPtr<FBlueprintDifferenceTreeEntry> >& Children, bool bHasDifferences)"
  },
  {
    "label": "CreateCategoryEntryForMerge()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<FBlueprintDifferenceTreeEntry>)",
    "insertText": "CreateCategoryEntryForMerge(const FText& LabelText, const FText& ToolTipText, FOnDiffEntryFocused FocusCallback, const TArray< TSharedPtr<FBlueprintDifferenceTreeEntry> >& Children, bool bHasRemoteDifferences, bool bHasLocalDifferences, bool bHasConflicts)"
  },
  {
    "label": "CreateTreeView()",
    "kind": "Method",
    "detail": "Function (FOnDiffEntryFocused OnFocus ; FGenerateDiffEntryWidget GenerateWidget ; TArray<TSharedPtr<FBlueprintDifferenceTreeEntry>> Children ; } ; namespace DiffTreeView { TSharedRef<STreeView<TSharedPtr<FBlueprintDifferenceTreeEntry>>>)",
    "insertText": "CreateTreeView(TArray< TSharedPtr<FBlueprintDifferenceTreeEntry> >* DifferencesList)"
  },
  {
    "label": "CurrentDifference()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "CurrentDifference(TSharedRef< STreeView<TSharedPtr< FBlueprintDifferenceTreeEntry > > > TreeView, const TArray< TSharedPtr<class FBlueprintDifferenceTreeEntry> >& Differences)"
  },
  {
    "label": "HighlightNextDifference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HighlightNextDifference(TSharedRef< STreeView<TSharedPtr< FBlueprintDifferenceTreeEntry > > > TreeView, const TArray< TSharedPtr<class FBlueprintDifferenceTreeEntry> >& Differences, const TArray< TSharedPtr<class FBlueprintDifferenceTreeEntry> >& RootDifferences)"
  },
  {
    "label": "HighlightPrevDifference()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HighlightPrevDifference(TSharedRef< STreeView<TSharedPtr< FBlueprintDifferenceTreeEntry > > > TreeView, const TArray< TSharedPtr<class FBlueprintDifferenceTreeEntry> >& Differences, const TArray< TSharedPtr<class FBlueprintDifferenceTreeEntry> >& RootDifferences)"
  },
  {
    "label": "HasNextDifference()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasNextDifference(TSharedRef< STreeView<TSharedPtr< FBlueprintDifferenceTreeEntry > > > TreeView, const TArray< TSharedPtr<class FBlueprintDifferenceTreeEntry> >& Differences)"
  },
  {
    "label": "HasPrevDifference()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasPrevDifference(TSharedRef< STreeView<TSharedPtr< FBlueprintDifferenceTreeEntry > > > TreeView, const TArray< TSharedPtr<class FBlueprintDifferenceTreeEntry> >& Differences)"
  },
  {
    "label": "LookupColor()",
    "kind": "Method",
    "detail": "Function (} struct FRevisionInfo ; namespace DiffViewUtils { FLinearColor)",
    "insertText": "LookupColor(bool bDiffers, bool bConflicts = false)"
  },
  {
    "label": "Differs()",
    "kind": "Method",
    "detail": "Function (FLinearColor)",
    "insertText": "Differs()"
  },
  {
    "label": "Identical()",
    "kind": "Method",
    "detail": "Function (FLinearColor)",
    "insertText": "Identical()"
  },
  {
    "label": "Missing()",
    "kind": "Method",
    "detail": "Function (FLinearColor)",
    "insertText": "Missing()"
  },
  {
    "label": "Conflicting()",
    "kind": "Method",
    "detail": "Function (FLinearColor)",
    "insertText": "Conflicting()"
  },
  {
    "label": "PropertyDiffMessage()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "PropertyDiffMessage(FSingleObjectDiffEntry Difference, FText ObjectName)"
  },
  {
    "label": "SCSDiffMessage()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "SCSDiffMessage(const FSCSDiffEntry& Difference, FText ObjectName)"
  },
  {
    "label": "GetPanelLabel()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "GetPanelLabel(const UObject* Asset, const FRevisionInfo& Revision, FText Label)"
  },
  {
    "label": "Box()",
    "kind": "Method",
    "detail": "Function (SHorizontalBox::FSlot::FSlotArguments)",
    "insertText": "Box(bool bIsPresent, FLinearColor Color)"
  }
]