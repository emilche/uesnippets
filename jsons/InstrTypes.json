[
  {
    "label": "LLVMContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LLVMContext"
  },
  {
    "label": "TerminatorInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TerminatorInst"
  },
  {
    "label": "UnaryInstruction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnaryInstruction"
  },
  {
    "label": "OperandTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OperandTraits"
  },
  {
    "label": "BinaryOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BinaryOperator"
  },
  {
    "label": "Instruction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Instruction"
  },
  {
    "label": "CastInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CastInst"
  },
  {
    "label": "CmpInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CmpInst"
  },
  {
    "label": "Predicate",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Predicate"
  },
  {
    "label": "TerminatorInst()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_IR_INSTRTYPES_H # define LLVM_IR_INSTRTYPES_H # include \" llvm / ADT / Twine . h \" # include \" llvm / IR / DerivedTypes . h \" # include \" llvm / IR / Instruction . h \" # include \" llvm / IR / OperandTraits . h \" namespace llvm { class LLVMContext ; class TerminatorInst : public Instruction { protected :)",
    "insertText": "TerminatorInst(Type *Ty, Instruction::TermOps iType, Use *Ops, unsigned NumOps, Instruction *InsertBefore = nullptr) : Instruction(Ty, iType, Ops, NumOps, InsertBefore)"
  },
  {
    "label": "TerminatorInst()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TerminatorInst(Type *Ty, Instruction::TermOps iType, Use *Ops, unsigned NumOps, BasicBlock *InsertAtEnd) : Instruction(Ty, iType, Ops, NumOps, InsertAtEnd)"
  },
  {
    "label": "TerminatorInst()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TerminatorInst()"
  },
  {
    "label": "getSuccessorV()",
    "kind": "Method",
    "detail": "Function (BasicBlock*)",
    "insertText": "getSuccessorV(unsigned idx)"
  },
  {
    "label": "getNumSuccessorsV()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getNumSuccessorsV()"
  },
  {
    "label": "setSuccessorV()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setSuccessorV(unsigned idx, BasicBlock *B)"
  },
  {
    "label": "getNumSuccessors()",
    "kind": "Method",
    "detail": "Function (public : unsigned)",
    "insertText": "getNumSuccessors()"
  },
  {
    "label": "getSuccessor()",
    "kind": "Method",
    "detail": "Function (} BasicBlock*)",
    "insertText": "getSuccessor(unsigned idx)"
  },
  {
    "label": "setSuccessor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setSuccessor(unsigned idx, BasicBlock *B)"
  },
  {
    "label": "setSuccessorV()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setSuccessorV(idx, B)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const Instruction *I)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const Value *V)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} } ; class UnaryInstruction : public Instruction { void* operator)",
    "insertText": "new(size_t, unsigned)"
  },
  {
    "label": "UnaryInstruction()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "UnaryInstruction(Type *Ty, unsigned iType, Value *V, Instruction *IB = nullptr) : Instruction(Ty, iType, &Op<0>(), 1, IB)"
  },
  {
    "label": "Op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Op()"
  },
  {
    "label": "UnaryInstruction()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UnaryInstruction(Type *Ty, unsigned iType, Value *V, BasicBlock *IAE) : Instruction(Ty, iType, &Op<0>(), 1, IAE)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (} public : void* operator)",
    "insertText": "new(size_t s)"
  },
  {
    "label": "UnaryInstruction()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "UnaryInstruction()"
  },
  {
    "label": "DECLARE_TRANSPARENT_OPERAND_ACCESSORS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value)"
  },
  {
    "label": "DEFINE_TRANSPARENT_OPERAND_ACCESSORS()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct OperandTraits<UnaryInstruction> : public FixedNumOperandTraits<UnaryInstruction,1> { } ;)",
    "insertText": "DEFINE_TRANSPARENT_OPERAND_ACCESSORS(UnaryInstruction, Value)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "init(BinaryOps iType)"
  },
  {
    "label": "BinaryOperator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty, const Twine &Name, Instruction *InsertBefore)"
  },
  {
    "label": "BinaryOperator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "cloneImpl()",
    "kind": "Method",
    "detail": "Function (class Instruction ; BinaryOperator*)",
    "insertText": "cloneImpl()"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (BinaryOperator*)",
    "insertText": "Create(BinaryOps Op, Value *S1, Value *S2, const Twine &Name = Twine(), Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (BinaryOperator*)",
    "insertText": "Create(BinaryOps Op, Value *S1, Value *S2, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "HANDLE_BINARY_INST()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "HANDLE_BINARY_INST(N, OPC, CLASS) \\ static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\ const Twine &Name = \"\")"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "Create(Instruction::OPC, V1, V2, Name)"
  },
  {
    "label": "HANDLE_BINARY_INST()",
    "kind": "Method",
    "detail": "Function (\\ } # include \" llvm / IR / Instruction . def \" # define)",
    "insertText": "HANDLE_BINARY_INST(N, OPC, CLASS) \\ static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\ const Twine &Name, BasicBlock *BB)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "Create(Instruction::OPC, V1, V2, Name, BB)"
  },
  {
    "label": "HANDLE_BINARY_INST()",
    "kind": "Method",
    "detail": "Function (\\ } # include \" llvm / IR / Instruction . def \" # define)",
    "insertText": "HANDLE_BINARY_INST(N, OPC, CLASS) \\ static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\ const Twine &Name, Instruction *I)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "Create(Instruction::OPC, V1, V2, Name, I)"
  },
  {
    "label": "CreateNSW()",
    "kind": "Method",
    "detail": "Function (\\ } # include \" llvm / IR / Instruction . def \" BinaryOperator*)",
    "insertText": "CreateNSW(BinaryOps Opc, Value *V1, Value *V2, const Twine &Name = \"\")"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (BinaryOperator* BO =)",
    "insertText": "Create(Opc, V1, V2, Name)"
  },
  {
    "label": "setHasNoSignedWrap()",
    "kind": "Method",
    "detail": "Function (BO ->)",
    "insertText": "setHasNoSignedWrap(true)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (BinaryOperator* BO =)",
    "insertText": "Create(Opc, V1, V2, Name, BB)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (BinaryOperator* BO =)",
    "insertText": "Create(Opc, V1, V2, Name, I)"
  },
  {
    "label": "setHasNoUnsignedWrap()",
    "kind": "Method",
    "detail": "Function (BO ->)",
    "insertText": "setHasNoUnsignedWrap(true)"
  },
  {
    "label": "setIsExact()",
    "kind": "Method",
    "detail": "Function (BO ->)",
    "insertText": "setIsExact(true)"
  },
  {
    "label": "NUWNSWEXACT()",
    "kind": "Method",
    "detail": "Function (\\ return Create # #)",
    "insertText": "NUWNSWEXACT(Instruction::OPC, V1, V2, Name)"
  },
  {
    "label": "OPC()",
    "kind": "Method",
    "detail": "Function (\\ } \\ BinaryOperator* Create # # NUWNSWEXACT # #)",
    "insertText": "OPC(Value *V1, Value *V2, const Twine &Name, BasicBlock *BB)"
  },
  {
    "label": "NUWNSWEXACT()",
    "kind": "Method",
    "detail": "Function (\\ return Create # #)",
    "insertText": "NUWNSWEXACT(Instruction::OPC, V1, V2, Name, BB)"
  },
  {
    "label": "OPC()",
    "kind": "Method",
    "detail": "Function (\\ } \\ BinaryOperator* Create # # NUWNSWEXACT # #)",
    "insertText": "OPC(Value *V1, Value *V2, const Twine &Name, Instruction *I)"
  },
  {
    "label": "NUWNSWEXACT()",
    "kind": "Method",
    "detail": "Function (\\ return Create # #)",
    "insertText": "NUWNSWEXACT(Instruction::OPC, V1, V2, Name, I)"
  },
  {
    "label": "DEFINE_HELPERS()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "DEFINE_HELPERS(Add, NSW) DEFINE_HELPERS(Add, NUW) DEFINE_HELPERS(Sub, NSW) DEFINE_HELPERS(Sub, NUW) DEFINE_HELPERS(Mul, NSW) DEFINE_HELPERS(Mul, NUW) DEFINE_HELPERS(Shl, NSW) DEFINE_HELPERS(Shl, NUW) DEFINE_HELPERS(SDiv, Exact) DEFINE_HELPERS(UDiv, Exact) DEFINE_HELPERS(AShr, Exact) DEFINE_HELPERS(LShr, Exact) #undef DEFINE_HELPERS static BinaryOperator *CreateNeg(Value *Op, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CreateNeg()",
    "kind": "Method",
    "detail": "Function (BinaryOperator*)",
    "insertText": "CreateNeg(Value *Op, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "CreateNSWNeg()",
    "kind": "Method",
    "detail": "Function (BinaryOperator*)",
    "insertText": "CreateNSWNeg(Value *Op, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CreateNSWNeg()",
    "kind": "Method",
    "detail": "Function (BinaryOperator*)",
    "insertText": "CreateNSWNeg(Value *Op, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "CreateNUWNeg()",
    "kind": "Method",
    "detail": "Function (BinaryOperator*)",
    "insertText": "CreateNUWNeg(Value *Op, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CreateNUWNeg()",
    "kind": "Method",
    "detail": "Function (BinaryOperator*)",
    "insertText": "CreateNUWNeg(Value *Op, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "CreateFNeg()",
    "kind": "Method",
    "detail": "Function (BinaryOperator*)",
    "insertText": "CreateFNeg(Value *Op, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CreateFNeg()",
    "kind": "Method",
    "detail": "Function (BinaryOperator*)",
    "insertText": "CreateFNeg(Value *Op, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "CreateNot()",
    "kind": "Method",
    "detail": "Function (BinaryOperator*)",
    "insertText": "CreateNot(Value *Op, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CreateNot()",
    "kind": "Method",
    "detail": "Function (BinaryOperator*)",
    "insertText": "CreateNot(Value *Op, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "isNeg()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isNeg(const Value *V)"
  },
  {
    "label": "isFNeg()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isFNeg(const Value *V, bool IgnoreZeroSign=false)"
  },
  {
    "label": "isNot()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isNot(const Value *V)"
  },
  {
    "label": "getNegArgument()",
    "kind": "Method",
    "detail": "Function (const Value*)",
    "insertText": "getNegArgument(const Value *BinOp)"
  },
  {
    "label": "getNegArgument()",
    "kind": "Method",
    "detail": "Function (Value*)",
    "insertText": "getNegArgument(Value *BinOp)"
  },
  {
    "label": "getFNegArgument()",
    "kind": "Method",
    "detail": "Function (const Value*)",
    "insertText": "getFNegArgument(const Value *BinOp)"
  },
  {
    "label": "getFNegArgument()",
    "kind": "Method",
    "detail": "Function (Value*)",
    "insertText": "getFNegArgument(Value *BinOp)"
  },
  {
    "label": "getNotArgument()",
    "kind": "Method",
    "detail": "Function (const Value*)",
    "insertText": "getNotArgument(const Value *BinOp)"
  },
  {
    "label": "getNotArgument()",
    "kind": "Method",
    "detail": "Function (Value*)",
    "insertText": "getNotArgument(Value *BinOp)"
  },
  {
    "label": "getOpcode()",
    "kind": "Method",
    "detail": "Function (BinaryOps)",
    "insertText": "getOpcode()"
  },
  {
    "label": "swapOperands()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "swapOperands()"
  },
  {
    "label": "setHasNoUnsignedWrap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setHasNoUnsignedWrap(bool b = true)"
  },
  {
    "label": "setHasNoSignedWrap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setHasNoSignedWrap(bool b = true)"
  },
  {
    "label": "setIsExact()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setIsExact(bool b = true)"
  },
  {
    "label": "hasNoUnsignedWrap()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasNoUnsignedWrap()"
  },
  {
    "label": "hasNoSignedWrap()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasNoSignedWrap()"
  },
  {
    "label": "isExact()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isExact()"
  },
  {
    "label": "copyIRFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copyIRFlags(const Value *V)"
  },
  {
    "label": "andIRFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "andIRFlags(const Value *V)"
  },
  {
    "label": "DEFINE_TRANSPARENT_OPERAND_ACCESSORS()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct OperandTraits<BinaryOperator> : public FixedNumOperandTraits<BinaryOperator,2> { } ;)",
    "insertText": "DEFINE_TRANSPARENT_OPERAND_ACCESSORS(BinaryOperator, Value)"
  },
  {
    "label": "anchor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "anchor()"
  },
  {
    "label": "CastInst()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "CastInst(Type *Ty, unsigned iType, Value *S, const Twine &NameStr = \"\", Instruction *InsertBefore = nullptr) : UnaryInstruction(Ty, iType, S, InsertBefore)"
  },
  {
    "label": "setName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setName(NameStr)"
  },
  {
    "label": "CastInst()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CastInst(Type *Ty, unsigned iType, Value *S, const Twine &NameStr, BasicBlock *InsertAtEnd) : UnaryInstruction(Ty, iType, S, InsertAtEnd)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (} public : CastInst*)",
    "insertText": "Create(Instruction::CastOps, Value *S, Type *Ty, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "Create(Instruction::CastOps, Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "CreateZExtOrBitCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreateZExtOrBitCast(Value *S, Type *Ty, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CreateZExtOrBitCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreateZExtOrBitCast(Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "CreateSExtOrBitCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreateSExtOrBitCast(Value *S, Type *Ty, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CreateSExtOrBitCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreateSExtOrBitCast(Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "CreatePointerCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreatePointerCast(Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "CreatePointerCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreatePointerCast(Value *S, Type *Ty, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CreatePointerBitCastOrAddrSpaceCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreatePointerBitCastOrAddrSpaceCast(Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "CreatePointerBitCastOrAddrSpaceCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreatePointerBitCastOrAddrSpaceCast(Value *S, Type *Ty, const Twine &Name = \"\", Instruction *InsertBefore = 0)"
  },
  {
    "label": "CreateBitOrPointerCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreateBitOrPointerCast(Value *S, Type *Ty, const Twine &Name = \"\", Instruction *InsertBefore = 0)"
  },
  {
    "label": "CreateIntegerCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreateIntegerCast(Value *S, Type *Ty, bool isSigned, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CreateIntegerCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreateIntegerCast(Value *S, Type *Ty, bool isSigned, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "CreateFPCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreateFPCast(Value *S, Type *Ty, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CreateFPCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreateFPCast(Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "CreateTruncOrBitCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreateTruncOrBitCast(Value *S, Type *Ty, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CreateTruncOrBitCast()",
    "kind": "Method",
    "detail": "Function (CastInst*)",
    "insertText": "CreateTruncOrBitCast(Value *S, Type *Ty, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "isCastable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isCastable(Type *SrcTy, Type *DestTy)"
  },
  {
    "label": "isBitCastable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isBitCastable(Type *SrcTy, Type *DestTy)"
  },
  {
    "label": "isBitOrNoopPointerCastable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isBitOrNoopPointerCastable(Type *SrcTy, Type *DestTy, const DataLayout &DL)"
  },
  {
    "label": "getCastOpcode()",
    "kind": "Method",
    "detail": "Function (Instruction::CastOps)",
    "insertText": "getCastOpcode(const Value *Val, bool SrcIsSigned, Type *Ty, bool DstIsSigned)"
  },
  {
    "label": "isIntegerCast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isIntegerCast()"
  },
  {
    "label": "isLosslessCast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLosslessCast()"
  },
  {
    "label": "isNoopCast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isNoopCast(Instruction::CastOps Opcode, Type *SrcTy, Type *DstTy, Type *IntPtrTy)"
  },
  {
    "label": "isNoopCast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isNoopCast(Type *IntPtrTy)"
  },
  {
    "label": "isNoopCast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isNoopCast(const DataLayout &DL)"
  },
  {
    "label": "isEliminableCastPair()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "isEliminableCastPair(Instruction::CastOps firstOpcode, Instruction::CastOps secondOpcode, Type *SrcTy, Type *MidTy, Type *DstTy, Type *SrcIntPtrTy, Type *MidIntPtrTy, Type *DstIntPtrTy)"
  },
  {
    "label": "getSrcTy()",
    "kind": "Method",
    "detail": "Function (} Type*)",
    "insertText": "getSrcTy()"
  },
  {
    "label": "getDestTy()",
    "kind": "Method",
    "detail": "Function (} Type*)",
    "insertText": "getDestTy()"
  },
  {
    "label": "castIsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "castIsValid(Instruction::CastOps op, Value *S, Type *DstTy)"
  },
  {
    "label": "CmpInst()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CmpInst()"
  },
  {
    "label": "CmpInst()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "CmpInst(Type *ty, Instruction::OtherOps op, unsigned short pred, Value *LHS, Value *RHS, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "CmpInst()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CmpInst(Type *ty, Instruction::OtherOps op, unsigned short pred, Value *LHS, Value *RHS, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (} CmpInst*)",
    "insertText": "Create(OtherOps Op, unsigned short predicate, Value *S1, Value *S2, const Twine &Name = \"\", Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (CmpInst*)",
    "insertText": "Create(OtherOps Op, unsigned short predicate, Value *S1, Value *S2, const Twine &Name, BasicBlock *InsertAtEnd)"
  },
  {
    "label": "getPredicate()",
    "kind": "Method",
    "detail": "Function (} Predicate)",
    "insertText": "getPredicate()"
  },
  {
    "label": "setPredicate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setPredicate(Predicate P)"
  },
  {
    "label": "setInstructionSubclassData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setInstructionSubclassData(P)"
  },
  {
    "label": "isFPPredicate()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isFPPredicate(Predicate P)"
  },
  {
    "label": "isIntPredicate()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isIntPredicate()"
  },
  {
    "label": "getInversePredicate()",
    "kind": "Method",
    "detail": "Function (} Predicate)",
    "insertText": "getInversePredicate()"
  },
  {
    "label": "getInversePredicate()",
    "kind": "Method",
    "detail": "Function (} Predicate)",
    "insertText": "getInversePredicate(Predicate pred)"
  },
  {
    "label": "getSwappedPredicate()",
    "kind": "Method",
    "detail": "Function (Predicate)",
    "insertText": "getSwappedPredicate()"
  },
  {
    "label": "getSwappedPredicate()",
    "kind": "Method",
    "detail": "Function (} Predicate)",
    "insertText": "getSwappedPredicate(Predicate pred)"
  },
  {
    "label": "isCommutative()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isCommutative()"
  },
  {
    "label": "isEquality()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isEquality()"
  },
  {
    "label": "isSigned()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isSigned()"
  },
  {
    "label": "isUnsigned()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isUnsigned()"
  },
  {
    "label": "isTrueWhenEqual()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isTrueWhenEqual()"
  },
  {
    "label": "isFalseWhenEqual()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isFalseWhenEqual()"
  },
  {
    "label": "isUnsigned()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isUnsigned(unsigned short predicate)"
  },
  {
    "label": "isSigned()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isSigned(unsigned short predicate)"
  },
  {
    "label": "isOrdered()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isOrdered(unsigned short predicate)"
  },
  {
    "label": "isUnordered()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isUnordered(unsigned short predicate)"
  },
  {
    "label": "isTrueWhenEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isTrueWhenEqual(unsigned short predicate)"
  },
  {
    "label": "isFalseWhenEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isFalseWhenEqual(unsigned short predicate)"
  },
  {
    "label": "makeCmpResultType()",
    "kind": "Method",
    "detail": "Function (} Type*)",
    "insertText": "makeCmpResultType(Type* opnd_type)"
  },
  {
    "label": "getInt1Ty()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "getInt1Ty(opnd_type->getContext())"
  },
  {
    "label": "setValueSubclassData()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "setValueSubclassData(unsigned short D)"
  },
  {
    "label": "setValueSubclassData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueSubclassData(D)"
  }
]