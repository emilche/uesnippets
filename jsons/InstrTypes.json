[
  {
    "label": "LLVMContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LLVMContext"
  },
  {
    "label": "are",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "are"
  },
  {
    "label": "TerminatorInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TerminatorInst"
  },
  {
    "label": "UnaryInstruction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnaryInstruction"
  },
  {
    "label": "OperandTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OperandTraits"
  },
  {
    "label": "BinaryOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BinaryOperator"
  },
  {
    "label": "Instruction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Instruction"
  },
  {
    "label": "OperandTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OperandTraits"
  },
  {
    "label": "for",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "for"
  },
  {
    "label": "of",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "of"
  },
  {
    "label": "CastInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CastInst"
  },
  {
    "label": "is",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "is"
  },
  {
    "label": "for",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "for"
  },
  {
    "label": "of",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "of"
  },
  {
    "label": "CmpInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CmpInst"
  },
  {
    "label": "Predicate",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Predicate"
  },
  {
    "label": "OperandTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OperandTraits"
  },
  {
    "label": "getNumSuccessorsV()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "getNumSuccessorsV()"
  },
  {
    "label": "getSuccessorV()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "getSuccessorV(idx)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (User::operator)",
    "insertText": "new(s, 1)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init(BinaryOps iType)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (User::operator)",
    "insertText": "new(s, 2)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "Create(Instruction::OPC, V1, V2, Name)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "Create(Instruction::OPC, V1, V2, Name, BB)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "Create(Instruction::OPC, V1, V2, Name, I)"
  },
  {
    "label": "isNeg()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isNeg(const Value *V)"
  },
  {
    "label": "isFNeg()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isFNeg(const Value *V, bool IgnoreZeroSign=false)"
  },
  {
    "label": "isNot()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isNot(const Value *V)"
  },
  {
    "label": "swapOperands()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "swapOperands()"
  },
  {
    "label": "setHasNoUnsignedWrap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setHasNoUnsignedWrap(bool b = true)"
  },
  {
    "label": "setHasNoSignedWrap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setHasNoSignedWrap(bool b = true)"
  },
  {
    "label": "setIsExact()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setIsExact(bool b = true)"
  },
  {
    "label": "copyIRFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copyIRFlags(const Value *V)"
  },
  {
    "label": "andIRFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "andIRFlags(const Value *V)"
  },
  {
    "label": "isCastable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isCastable(\n    Type *SrcTy, ///< The Type from which the value should be cast.\n    Type *DestTy ///< The Type to which the value should be cast.\n  )"
  },
  {
    "label": "isBitCastable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isBitCastable(\n    Type *SrcTy, ///< The Type from which the value should be cast.\n    Type *DestTy ///< The Type to which the value should be cast.\n  )"
  },
  {
    "label": "isBitOrNoopPointerCastable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isBitOrNoopPointerCastable(\n      Type *SrcTy,  ///< The Type from which the value should be cast.\n      Type *DestTy, ///< The Type to which the value should be cast.\n      const DataLayout &DL)"
  },
  {
    "label": "getCastOpcode()",
    "kind": "Method",
    "detail": "Function (Instruction::CastOps)",
    "insertText": "getCastOpcode(\n    const Value *Val, ///< The value to cast\n    bool SrcIsSigned, ///< Whether to treat the source as signed\n    Type *Ty,   ///< The Type to which the value should be casted\n    bool DstIsSigned  ///< Whether to treate the dest. as signed\n  )"
  },
  {
    "label": "isNoopCast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isNoopCast(\n    Instruction::CastOps Opcode,  ///< Opcode of cast\n    Type *SrcTy,   ///< SrcTy of cast\n    Type *DstTy,   ///< DstTy of cast\n    Type *IntPtrTy ///< Integer type corresponding to Ptr types\n  )"
  },
  {
    "label": "isEliminableCastPair()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "isEliminableCastPair(\n    Instruction::CastOps firstOpcode,  ///< Opcode of first cast\n    Instruction::CastOps secondOpcode, ///< Opcode of second cast\n    Type *SrcTy, ///< SrcTy of 1st cast\n    Type *MidTy, ///< DstTy of 1st cast & SrcTy of 2nd cast\n    Type *DstTy, ///< DstTy of 2nd cast\n    Type *SrcIntPtrTy, ///< Integer type corresponding to Ptr SrcTy, or null\n    Type *MidIntPtrTy, ///< Integer type corresponding to Ptr MidTy, or null\n    Type *DstIntPtrTy  ///< Integer type corresponding to Ptr DstTy, or null\n  )"
  },
  {
    "label": "getType()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "getType()"
  },
  {
    "label": "castIsValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "castIsValid(Instruction::CastOps op, Value *S, Type *DstTy)"
  },
  {
    "label": "CmpInst()",
    "kind": "Method",
    "detail": "Function (protected:)",
    "insertText": "CmpInst(Type *ty, Instruction::OtherOps op, unsigned short pred,\n          Value *LHS, Value *RHS, const Twine &Name = \"\",\n          Instruction *InsertBefore = nullptr)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (User::operator)",
    "insertText": "new(s, 2)"
  },
  {
    "label": "getInversePredicate()",
    "kind": "Method",
    "detail": "Function (Predicate)",
    "insertText": "getInversePredicate(Predicate pred)"
  },
  {
    "label": "getSwappedPredicate()",
    "kind": "Method",
    "detail": "Function (Predicate)",
    "insertText": "getSwappedPredicate(Predicate pred)"
  },
  {
    "label": "swapOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swapOperands()"
  },
  {
    "label": "isUnsigned()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isUnsigned(unsigned short predicate)"
  },
  {
    "label": "isSigned()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isSigned(unsigned short predicate)"
  },
  {
    "label": "isOrdered()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isOrdered(unsigned short predicate)"
  },
  {
    "label": "isUnordered()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isUnordered(unsigned short predicate)"
  },
  {
    "label": "isTrueWhenEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isTrueWhenEqual(unsigned short predicate)"
  },
  {
    "label": "isFalseWhenEqual()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isFalseWhenEqual(unsigned short predicate)"
  }
]