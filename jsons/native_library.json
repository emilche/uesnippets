[
  {
    "label": "NativeLibraryType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "NativeLibraryType"
  },
  {
    "label": "NativeLibraryObjCStatus",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "NativeLibraryObjCStatus"
  },
  {
    "label": "NativeLibraryStruct",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NativeLibraryStruct"
  },
  {
    "label": "PA_COMPONENT_EXPORT",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PA_COMPONENT_EXPORT"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ALLOC_BASE_NATIVE_LIBRARY_H_ # define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ALLOC_BASE_NATIVE_LIBRARY_H_ # include<string> # include \" base / allocator / partition_allocator / partition_alloc_base / component_export . h \" # include \" base / allocator / partition_allocator / partition_alloc_base / files / file_path . h \" # include \" base / allocator / partition_allocator / partition_alloc_base / migration_adapter . h \" # include \" build / build_config . h \" # if)",
    "insertText": "BUILDFLAG(IS_WIN) #include <windows.h> #elif BUILDFLAG(IS_APPLE)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_WIN)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# elif)",
    "insertText": "BUILDFLAG(IS_APPLE)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (BUNDLE,DYNAMIC_LIB } ; enum NativeLibraryObjCStatus { OBJC_UNKNOWN,OBJC_PRESENT,OBJC_NOT_PRESENT,} ; struct NativeLibraryStruct { NativeLibraryType type ; CFBundleRefNum bundle_resource_ref ; NativeLibraryObjCStatus objc_status ; union { CFBundleRef bundle ; void* dylib ; } ; } ; using NativeLibrary = NativeLibraryStruct* ; # elif)",
    "insertText": "BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)"
  },
  {
    "label": "PA_COMPONENT_EXPORT()",
    "kind": "Method",
    "detail": "Function (# endif struct)",
    "insertText": "PA_COMPONENT_EXPORT(PARTITION_ALLOC)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_WIN) NativeLibraryLoadError() : code(0)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} # endif std::string)",
    "insertText": "ToString()"
  },
  {
    "label": "NativeLibraryOptions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NativeLibraryOptions()"
  },
  {
    "label": "NativeLibraryOptions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NativeLibraryOptions(const NativeLibraryOptions& options)"
  },
  {
    "label": "PA_COMPONENT_EXPORT()",
    "kind": "Method",
    "detail": "Function (bool prefer_own_symbols = false ; } ;)",
    "insertText": "PA_COMPONENT_EXPORT(PARTITION_ALLOC) NativeLibrary LoadNativeLibrary(const FilePath& library_path, NativeLibraryLoadError* error)"
  },
  {
    "label": "PA_COMPONENT_EXPORT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_COMPONENT_EXPORT(PARTITION_ALLOC) NativeLibrary LoadNativeLibraryWithOptions(const FilePath& library_path, const NativeLibraryOptions& options, NativeLibraryLoadError* error)"
  },
  {
    "label": "PA_COMPONENT_EXPORT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_COMPONENT_EXPORT(PARTITION_ALLOC) void* GetFunctionPointerFromNativeLibrary(NativeLibrary library, const std::string& name)"
  }
]