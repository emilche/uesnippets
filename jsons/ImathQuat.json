[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "IMATH_EXPORT_TEMPLATE_TYPE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMATH_EXPORT_TEMPLATE_TYPE"
  },
  {
    "label": "S",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "S"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHQUAT_H # define INCLUDED_IMATHQUAT_H # include \" ImathExport . h \" # include \" ImathNamespace . h \" # include \" ImathMatrix . h \" # include<iostream> IMATH_INTERNAL_NAMESPACE_HEADER_ENTER #)",
    "insertText": "if(defined _WIN32 || defined _WIN64) && defined _MSC_VER # pragma warning(push) # pragma warning(disable : 4244)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (public : T r ; Vec3<T> v ; IMATH_HOSTDEVICE IMATH_CONSTEXPR14 T&)",
    "insertText": "operator(int index)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Quat()"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Quat(const Quat& q)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Quat(const Quat<S>& q)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Quat(T s, T i, T j, T k)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Quat(T s, Vec3<T> d)"
  },
  {
    "label": "identity()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Quat<T>)",
    "insertText": "identity()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Quat<T>&)",
    "insertText": "operator(const Quat<T>& q)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Quat<T>&)",
    "insertText": "operator(T t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE bool)",
    "insertText": "operator(const Quat<S>& q)"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "length()"
  },
  {
    "label": "angle()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "angle()"
  },
  {
    "label": "axis()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Vec3<T>)",
    "insertText": "axis()"
  },
  {
    "label": "toMatrix33()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Matrix33<T>)",
    "insertText": "toMatrix33()"
  },
  {
    "label": "toMatrix44()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Matrix44<T>)",
    "insertText": "toMatrix44()"
  },
  {
    "label": "log()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Quat<T>)",
    "insertText": "log()"
  },
  {
    "label": "exp()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Quat<T>)",
    "insertText": "exp()"
  },
  {
    "label": "invert()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Quat<T>&)",
    "insertText": "invert()"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Quat<T>)",
    "insertText": "inverse()"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Quat<T>&)",
    "insertText": "normalize()"
  },
  {
    "label": "normalized()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Quat<T>)",
    "insertText": "normalized()"
  },
  {
    "label": "rotateVector()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Vec3<T>)",
    "insertText": "rotateVector(const Vec3<T>& original)"
  },
  {
    "label": "euclideanInnerProduct()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "euclideanInnerProduct(const Quat<T>& q)"
  },
  {
    "label": "setAxisAngle()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Quat<T>&)",
    "insertText": "setAxisAngle(const Vec3<T>& axis, T radians)"
  },
  {
    "label": "setRotation()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Quat<T>&)",
    "insertText": "setRotation(const Vec3<T>& fromDirection, const Vec3<T>& toDirection)"
  },
  {
    "label": "setRotationInternal()",
    "kind": "Method",
    "detail": "Function (typedef T BaseType ; private : IMATH_HOSTDEVICE void)",
    "insertText": "setRotationInternal(const Vec3<T>& f0, const Vec3<T>& t0, Quat<T>& q)"
  },
  {
    "label": "slerp()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Quat<T>)",
    "insertText": "slerp(const Quat<T>& q1, const Quat<T>& q2, T t)"
  },
  {
    "label": "slerpShortestArc()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Quat<T>)",
    "insertText": "slerpShortestArc(const Quat<T>& q1, const Quat<T>& q2, T t)"
  },
  {
    "label": "squad()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Quat<T>)",
    "insertText": "squad(const Quat<T>& q1, const Quat<T>& q2, const Quat<T>& qa, const Quat<T>& qb, T t)"
  },
  {
    "label": "intermediate()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE void)",
    "insertText": "intermediate(const Quat<T>& q0, const Quat<T>& q1, const Quat<T>& q2, const Quat<T>& q3, Quat<T>& qa, Quat<T>& qb)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE Matrix33<T>)",
    "insertText": "operator(const Matrix33<T>& M, const Quat<T>& q)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE Matrix33<T>)",
    "insertText": "operator(const Quat<T>& q, const Matrix33<T>& M)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& o, const Quat<T>& q)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE Quat<T>)",
    "insertText": "operator(const Quat<T>& q1, const Quat<T>& q2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE Quat<T>)",
    "insertText": "operator(const Quat<T>& q, T t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE Quat<T>)",
    "insertText": "operator(T t, const Quat<T>& q)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Vec3<T>)",
    "insertText": "operator(const Vec3<T>& v, const Quat<T>& q)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (typedef Quat<float> Quatf ; typedef Quat<double> Quatd ; template<class T> IMATH_HOSTDEVICE Quat<T)",
    "insertText": "Quat() IMATH_NOEXCEPT : r (1), v (0, 0, 0)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (} template<class T> template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Quat<T)",
    "insertText": "Quat(const Quat<S>& q) IMATH_NOEXCEPT : r (q.r), v (q.v)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Quat<T)",
    "insertText": "Quat(T s, T i, T j, T k) IMATH_NOEXCEPT : r (s), v (i, j, k)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Quat<T)",
    "insertText": "Quat(T s, Vec3<T> d) IMATH_NOEXCEPT : r (s), v (d)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Quat<T)",
    "insertText": "Quat(const Quat<T>& q) IMATH_NOEXCEPT : r (q.r), v (q.v)"
  },
  {
    "label": "r()",
    "kind": "Method",
    "detail": "Function (T rtmp = r* q .)",
    "insertText": "r(v ^ q.v)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (r / = l ; v / = l ; } else { r = 1 ; v = Vec3<)",
    "insertText": "T(0)"
  },
  {
    "label": "Quat()",
    "kind": "Method",
    "detail": "Function (T qdot =* this ^* this ; return)",
    "insertText": "Quat(r / qdot, -v / qdot)"
  },
  {
    "label": "qdot()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "qdot(*this) ^ (*this)"
  },
  {
    "label": "vec()",
    "kind": "Method",
    "detail": "Function (Quat<T>)",
    "insertText": "vec(0, original)"
  },
  {
    "label": "inv()",
    "kind": "Method",
    "detail": "Function (Quat<T>)",
    "insertText": "inv(*this)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (Quat<T> d = q1 - q2 ; T lengthD =)",
    "insertText": "sqrt(d ^ d)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (Quat<T> s = q1 + q2 ; T lengthS =)",
    "insertText": "sqrt(s ^ s)"
  },
  {
    "label": "angle4D()",
    "kind": "Method",
    "detail": "Function (T a =)",
    "insertText": "angle4D(q1, q2)"
  },
  {
    "label": "sinx_over_x()",
    "kind": "Method",
    "detail": "Function (T s = 1 - t ; Quat<T> q =)",
    "insertText": "sinx_over_x(s * a) / sinx_over_x (a) * s * q1 + sinx_over_x (t * a) / sinx_over_x (a)"
  },
  {
    "label": "spline()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Quat<T>)",
    "insertText": "spline(const Quat<T>& q0, const Quat<T>& q1, const Quat<T>& q2, const Quat<T>& q3, T t)"
  },
  {
    "label": "intermediate()",
    "kind": "Method",
    "detail": "Function (Quat<T> qa =)",
    "insertText": "intermediate(q0, q1, q2)"
  },
  {
    "label": "intermediate()",
    "kind": "Method",
    "detail": "Function (Quat<T> qb =)",
    "insertText": "intermediate(q1, q2, q3)"
  },
  {
    "label": "squad()",
    "kind": "Method",
    "detail": "Function (Quat<T> result =)",
    "insertText": "squad(q1, qa, qb, q2, t)"
  },
  {
    "label": "slerp()",
    "kind": "Method",
    "detail": "Function (Quat<T> r1 =)",
    "insertText": "slerp(q1, q2, t)"
  },
  {
    "label": "slerp()",
    "kind": "Method",
    "detail": "Function (Quat<T> r2 =)",
    "insertText": "slerp(qa, qb, t)"
  },
  {
    "label": "slerp()",
    "kind": "Method",
    "detail": "Function (Quat<T> result =)",
    "insertText": "slerp(r1, r2, 2 * t * (1 - t))"
  },
  {
    "label": "c3()",
    "kind": "Method",
    "detail": "Function (Quat<T> c1 = q1inv* q2 ; Quat<T> c2 = q1inv* q0 ; Quat<T>)",
    "insertText": "c3(T) (-0.25) * (c2.log() + c1.log())"
  },
  {
    "label": "acos()",
    "kind": "Method",
    "detail": "Function (T theta =)",
    "insertText": "acos(std::min (r, (T) 1.0))"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (T sintheta =)",
    "insertText": "sin(theta)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T k ;)",
    "insertText": "if(std::abs(sintheta) < 1 && std::abs(theta) >= std::numeric_limits<T>::max() * std::abs(sintheta))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T k ;)",
    "insertText": "if(abs (theta) < 1 && abs (sintheta) >= std::numeric_limits<T>::max() * abs (theta))"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (r =)",
    "insertText": "cos(radians / 2)"
  },
  {
    "label": "normalized()",
    "kind": "Method",
    "detail": "Function (v = axis .)",
    "insertText": "normalized() * std::sin (radians / 2)"
  },
  {
    "label": "setRotationInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setRotationInternal(f0, t0, *this)"
  },
  {
    "label": "h0()",
    "kind": "Method",
    "detail": "Function (} else { Vec3<T>)",
    "insertText": "h0(f0 + t0).normalized()"
  },
  {
    "label": "setRotationInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setRotationInternal(f0, h0, *this)"
  },
  {
    "label": "setRotationInternal()",
    "kind": "Method",
    "detail": "Function (Quat<T> q ;)",
    "insertText": "setRotationInternal(h0, t0, q)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3<T> f02 = f0* f0 ;)",
    "insertText": "if(f02.x <= f02.y && f02.x <= f02.z) v = (f0 % Vec3<T> (1, 0, 0)).normalized()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> a = q . v % v ; Vec3<T> b = q . v % a ; return v +)",
    "insertText": "T(2) * (q.r * a + b)"
  }
]