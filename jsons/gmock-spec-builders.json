[
  {
    "label": "Expectation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Expectation"
  },
  {
    "label": "ExpectationSet",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ExpectationSet"
  },
  {
    "label": "FunctionMocker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FunctionMocker"
  },
  {
    "label": "ExpectationBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ExpectationBase"
  },
  {
    "label": "TypedExpectation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypedExpectation"
  },
  {
    "label": "ExpectationTester",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ExpectationTester"
  },
  {
    "label": "UntypedActionResultHolderBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UntypedActionResultHolderBase"
  },
  {
    "label": "GTEST_API_",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GTEST_API_"
  },
  {
    "label": "UntypedOnCallSpecBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UntypedOnCallSpecBase"
  },
  {
    "label": "Clause",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Clause"
  },
  {
    "label": "OnCallSpec",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OnCallSpec"
  },
  {
    "label": "CallReaction",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "CallReaction"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "NiceMock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NiceMock"
  },
  {
    "label": "NaggyMock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NaggyMock"
  },
  {
    "label": "StrictMock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StrictMock"
  },
  {
    "label": "Sequence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Sequence"
  },
  {
    "label": "Less",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Less"
  },
  {
    "label": "UntypedFunctionMockerBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UntypedFunctionMockerBase"
  },
  {
    "label": "MockSpec",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MockSpec"
  },
  {
    "label": "ReferenceOrValueWrapper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ReferenceOrValueWrapper"
  },
  {
    "label": "ActionResultHolder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ActionResultHolder"
  },
  {
    "label": "MockFunction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MockFunction"
  },
  {
    "label": "GTEST_DISABLE_MSC_WARNINGS_PUSH_()",
    "kind": "Method",
    "detail": "Function (# ifndef GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_ # define GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_ # include<functional> # include<map> # include<memory> # include<set> # include<sstream> # include<string> # include<type_traits> # include<utility> # include<vector> # include \" gmock / gmock - actions . h \" # include \" gmock / gmock - cardinalities . h \" # include \" gmock / gmock - matchers . h \" # include \" gmock / internal / gmock - internal - utils . h \" # include \" gmock / internal / gmock - port . h \" # include \" gtest / gtest . h \" # if GTEST_HAS_EXCEPTIONS # include<stdexcept> # endif)",
    "insertText": "GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\)"
  },
  {
    "label": "GTEST_DECLARE_STATIC_MUTEX_()",
    "kind": "Method",
    "detail": "Function (class Expectation ; class ExpectationSet ; namespace internal { template<F> class FunctionMocker ; class ExpectationBase ; template<F> class TypedExpectation ; class ExpectationTester ; GTEST_API_)",
    "insertText": "GTEST_DECLARE_STATIC_MUTEX_(g_gmock_mutex)"
  },
  {
    "label": "UntypedFunctionMockerBase()",
    "kind": "Method",
    "detail": "Function (class UntypedActionResultHolderBase ; class GTEST_API_ UntypedFunctionMockerBase { public :)",
    "insertText": "UntypedFunctionMockerBase()"
  },
  {
    "label": "VerifyAndClearExpectationsLocked()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "VerifyAndClearExpectationsLocked() GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "ClearDefaultActionsLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearDefaultActionsLocked() GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "UntypedPerformDefaultAction()",
    "kind": "Method",
    "detail": "Function (UntypedActionResultHolderBase*)",
    "insertText": "UntypedPerformDefaultAction(void* untyped_args, const std::string& call_description)"
  },
  {
    "label": "UntypedPerformAction()",
    "kind": "Method",
    "detail": "Function (UntypedActionResultHolderBase*)",
    "insertText": "UntypedPerformAction(const void* untyped_action, void* untyped_args)"
  },
  {
    "label": "UntypedDescribeUninterestingCall()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UntypedDescribeUninterestingCall(const void* untyped_args, ::std::ostream* os) const GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "UntypedFindMatchingExpectation()",
    "kind": "Method",
    "detail": "Function (const ExpectationBase*)",
    "insertText": "UntypedFindMatchingExpectation(const void* untyped_args, const void** untyped_action, bool* is_excessive, ::std::ostream* what, ::std::ostream* why) GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "UntypedPrintArgs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UntypedPrintArgs(const void* untyped_args, ::std::ostream* os)"
  },
  {
    "label": "RegisterOwner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterOwner(const void* mock_obj) GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "SetOwnerAndName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetOwnerAndName(const void* mock_obj, const char* name) GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "MockObject()",
    "kind": "Method",
    "detail": "Function (const void*)",
    "insertText": "MockObject() const GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "Name() const GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "UntypedInvokeWith()",
    "kind": "Method",
    "detail": "Function (UntypedActionResultHolderBase*)",
    "insertText": "UntypedInvokeWith(void* untyped_args) GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "GetHandleOf()",
    "kind": "Method",
    "detail": "Function (protected : typedef std::vector<const void*> UntypedOnCallSpecs ; using UntypedExpectations = std::vector<std::shared_ptr<ExpectationBase>> ; Expectation)",
    "insertText": "GetHandleOf(ExpectationBase* exp)"
  },
  {
    "label": "UntypedOnCallSpecBase()",
    "kind": "Method",
    "detail": "Function (const void* mock_obj_ ; const char* name_ ; UntypedOnCallSpecs untyped_on_call_specs_ ; UntypedExpectations untyped_expectations_ ; } ; class UntypedOnCallSpecBase { public :)",
    "insertText": "UntypedOnCallSpecBase(const char* a_file, int a_line) : file_(a_file), line_(a_line), last_clause_(kNone)"
  },
  {
    "label": "file()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "file()"
  },
  {
    "label": "Assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Assert(property, file_, line_, failure_message)"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExpectSpecProperty(bool property, const std::string& failure_message)"
  },
  {
    "label": "Expect()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Expect(property, file_, line_, failure_message)"
  },
  {
    "label": "OnCallSpec()",
    "kind": "Method",
    "detail": "Function (} const char* file_ ; int line_ ; Clause last_clause_ ; } ; template<F> class OnCallSpec : public UntypedOnCallSpecBase { public : typedef Function<F>::ArgumentTuple ArgumentTuple ; typedef Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple ;)",
    "insertText": "OnCallSpec(const char* a_file, int a_line, const ArgumentMatcherTuple& matchers) : UntypedOnCallSpecBase(a_file, a_line), matchers_(matchers), extra_matcher_(A<const ArgumentTuple&>())"
  },
  {
    "label": "With()",
    "kind": "Method",
    "detail": "Function (} OnCallSpec&)",
    "insertText": "With(const Matcher<const ArgumentTuple&>& m)"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectSpecProperty(last_clause_ < kWith, \".With() cannot appear \" \"more than once in an ON_CALL().\")"
  },
  {
    "label": "WillByDefault()",
    "kind": "Method",
    "detail": "Function (last_clause_ = kWith ; extra_matcher_ = m ; return* this ; } OnCallSpec&)",
    "insertText": "WillByDefault(const Action<F>& action)"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectSpecProperty(last_clause_ < kWillByDefault, \".WillByDefault() must appear \" \"exactly once in an ON_CALL().\")"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (last_clause_ = kWillByDefault ;)",
    "insertText": "ExpectSpecProperty(!action.IsDoDefault(), \"DoDefault() cannot be used in ON_CALL().\")"
  },
  {
    "label": "Matches()",
    "kind": "Method",
    "detail": "Function (action_ = action ; return* this ; } bool)",
    "insertText": "Matches(const ArgumentTuple& args)"
  },
  {
    "label": "GetAction()",
    "kind": "Method",
    "detail": "Function (} const Action<F>&)",
    "insertText": "GetAction()"
  },
  {
    "label": "AssertSpecProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertSpecProperty(last_clause_ == kWillByDefault, \".WillByDefault() must appear exactly \" \"once in an ON_CALL().\")"
  },
  {
    "label": "VerifyAndClearExpectations()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "VerifyAndClearExpectations(void* mock_obj) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "VerifyAndClear()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "VerifyAndClear(void* mock_obj) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "IsNaggy()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsNaggy(void* mock_obj) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "IsNice()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsNice(void* mock_obj) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "IsStrict()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsStrict(void* mock_obj) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "AllowUninterestingCalls()",
    "kind": "Method",
    "detail": "Function (private : class internal::UntypedFunctionMockerBase ; template<F> class internal::FunctionMocker ; template<M> class NiceMock ; template<M> class NaggyMock ; template<M> class StrictMock ; void)",
    "insertText": "AllowUninterestingCalls(const void* mock_obj) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "WarnUninterestingCalls()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WarnUninterestingCalls(const void* mock_obj) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "FailUninterestingCalls()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FailUninterestingCalls(const void* mock_obj) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "UnregisterCallReaction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterCallReaction(const void* mock_obj) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "GetReactionOnUninterestingCalls()",
    "kind": "Method",
    "detail": "Function (internal::CallReaction)",
    "insertText": "GetReactionOnUninterestingCalls(const void* mock_obj) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "VerifyAndClearExpectationsLocked()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "VerifyAndClearExpectationsLocked(void* mock_obj) GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex)"
  },
  {
    "label": "ClearDefaultActionsLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearDefaultActionsLocked(void* mock_obj) GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex)"
  },
  {
    "label": "Register()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Register(const void* mock_obj, internal::UntypedFunctionMockerBase* mocker) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "RegisterUseByOnCallOrExpectCall()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterUseByOnCallOrExpectCall(const void* mock_obj, const char* file, int line) GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex)"
  },
  {
    "label": "UnregisterLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterLocked(internal::UntypedFunctionMockerBase* mocker) GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex)"
  },
  {
    "label": "Expectation()",
    "kind": "Method",
    "detail": "Function (} ; class GTEST_API_ Expectation { public :)",
    "insertText": "Expectation()"
  },
  {
    "label": "Expectation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Expectation(internal::ExpectationBase& exp)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const Expectation& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : class ExpectationSet ; class Sequence ; class::testing::internal::ExpectationBase ; class::testing::internal::UntypedFunctionMockerBase ; template<F> class::testing::internal::FunctionMocker ; template<F> class::testing::internal::TypedExpectation ; class Less { public : bool)",
    "insertText": "operator()(const Expectation& lhs, const Expectation& rhs)"
  },
  {
    "label": "Expectation()",
    "kind": "Method",
    "detail": "Function (} } ; typedef::std::set<Expectation,Less> Set ;)",
    "insertText": "Expectation(const std::shared_ptr<internal::ExpectationBase>& expectation_base)"
  },
  {
    "label": "expectation_base()",
    "kind": "Method",
    "detail": "Function (const std::shared_ptr<internal::ExpectationBase>&)",
    "insertText": "expectation_base()"
  },
  {
    "label": "ExpectationSet()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ExpectationSet(internal::ExpectationBase& exp)"
  },
  {
    "label": "Expectation()",
    "kind": "Method",
    "detail": "Function (* this + =)",
    "insertText": "Expectation(exp)"
  },
  {
    "label": "ExpectationSet()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ExpectationSet(const Expectation& e)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (* this + = e ; } bool)",
    "insertText": "operator(const ExpectationSet& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ExpectationSet&)",
    "insertText": "operator(const Expectation& e)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (expectations_ .)",
    "insertText": "insert(e)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "end()"
  },
  {
    "label": "Sequence()",
    "kind": "Method",
    "detail": "Function (} private : Expectation::Set expectations_ ; } ; class GTEST_API_ Sequence { public :)",
    "insertText": "Sequence() : last_expectation_(new Expectation)"
  },
  {
    "label": "AddExpectation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddExpectation(const Expectation& expectation)"
  },
  {
    "label": "InSequence()",
    "kind": "Method",
    "detail": "Function (private : std::shared_ptr<Expectation> last_expectation_ ; } ; class GTEST_API_ InSequence { public :)",
    "insertText": "InSequence()"
  },
  {
    "label": "GTEST_DISALLOW_COPY_AND_ASSIGN_()",
    "kind": "Method",
    "detail": "Function (private : bool sequence_created_ ;)",
    "insertText": "GTEST_DISALLOW_COPY_AND_ASSIGN_(InSequence)"
  },
  {
    "label": "ExpectationBase()",
    "kind": "Method",
    "detail": "Function (} GTEST_ATTRIBUTE_UNUSED_ ; namespace internal { GTEST_API_ ThreadLocal<Sequence*> g_gmock_implicit_sequence ; class GTEST_API_ ExpectationBase { public :)",
    "insertText": "ExpectationBase(const char* file, int line, const std::string& source_text)"
  },
  {
    "label": "ExpectationBase()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ExpectationBase()"
  },
  {
    "label": "cardinality()",
    "kind": "Method",
    "detail": "Function (} const Cardinality&)",
    "insertText": "cardinality()"
  },
  {
    "label": "FormatFileLocation()",
    "kind": "Method",
    "detail": "Function (* os<<)",
    "insertText": "FormatFileLocation(file(), line())"
  },
  {
    "label": "DescribeCallCountTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DescribeCallCountTo(::std::ostream* os) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "MaybeDescribeExtraMatcherTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeDescribeExtraMatcherTo(::std::ostream* os)"
  },
  {
    "label": "GetHandle()",
    "kind": "Method",
    "detail": "Function (protected : class::testing::Expectation ; class UntypedFunctionMockerBase ; enum Clause { kNone,kWith,kTimes,kInSequence,kAfter,kWillOnce,kWillRepeatedly,kRetiresOnSaturation } ; typedef std::vector<const void*> UntypedActions ; Expectation)",
    "insertText": "GetHandle()"
  },
  {
    "label": "AssertSpecProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertSpecProperty(bool property, const std::string& failure_message)"
  },
  {
    "label": "SpecifyCardinality()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SpecifyCardinality(const Cardinality& cardinality)"
  },
  {
    "label": "cardinality_specified()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "cardinality_specified()"
  },
  {
    "label": "RetireAllPreRequisites()",
    "kind": "Method",
    "detail": "Function (cardinality_ = a_cardinality ; } void)",
    "insertText": "RetireAllPreRequisites() GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "is_retired()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "is_retired() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "AssertHeld()",
    "kind": "Method",
    "detail": "Function (g_gmock_mutex .)",
    "insertText": "AssertHeld()"
  },
  {
    "label": "IsSatisfied()",
    "kind": "Method",
    "detail": "Function (retired_ = true ; } bool)",
    "insertText": "IsSatisfied() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "IsSaturated()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSaturated() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "IsOverSaturated()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsOverSaturated() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "AllPrerequisitesAreSatisfied()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "AllPrerequisitesAreSatisfied() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "FindUnsatisfiedPrerequisites()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindUnsatisfiedPrerequisites(ExpectationSet* result) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "call_count()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "call_count() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "CheckActionCountIfNotDone()",
    "kind": "Method",
    "detail": "Function (call_count_ + + ; } void)",
    "insertText": "CheckActionCountIfNotDone() const GTEST_LOCK_EXCLUDED_(mutex_)"
  },
  {
    "label": "UntypedTimes()",
    "kind": "Method",
    "detail": "Function (class::testing::Sequence ; class::testing::internal::ExpectationTester ; template<Function> class TypedExpectation ; void)",
    "insertText": "UntypedTimes(const Cardinality& a_cardinality)"
  },
  {
    "label": "GTEST_DISALLOW_ASSIGN_()",
    "kind": "Method",
    "detail": "Function (const char* file_ ; int line_ ; const std::string source_text_ ; bool cardinality_specified_ ; Cardinality cardinality_ ; ExpectationSet immediate_prerequisites_ ; int call_count_ ; bool retired_ ; UntypedActions untyped_actions_ ; bool extra_matcher_specified_ ; bool repeated_action_specified_ ; bool retires_on_saturation_ ; Clause last_clause_ ; bool action_count_checked_ ; Mutex mutex_ ;)",
    "insertText": "GTEST_DISALLOW_ASSIGN_(ExpectationBase)"
  },
  {
    "label": "TypedExpectation()",
    "kind": "Method",
    "detail": "Function (} ; template<F> class TypedExpectation : public ExpectationBase { public : typedef Function<F>::ArgumentTuple ArgumentTuple ; typedef Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple ; typedef Function<F>::Result Result ;)",
    "insertText": "TypedExpectation(FunctionMocker<F>* owner, const char* a_file, int a_line, const std::string& a_source_text, const ArgumentMatcherTuple& m) : ExpectationBase(a_file, a_line, a_source_text), owner_(owner), matchers_(m), extra_matcher_(A<const ArgumentTuple&>()), repeated_action_(DoDefault())"
  },
  {
    "label": "TypedExpectation()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TypedExpectation()"
  },
  {
    "label": "F()",
    "kind": "Method",
    "detail": "Function (delete static_cast<const Action<)",
    "insertText": "F(*it)"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectSpecProperty(false, \".With() cannot appear \" \"more than once in an EXPECT_CALL().\")"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "ExpectSpecProperty(last_clause_ < kWith, \".With() must be the first \" \"clause in an EXPECT_CALL().\")"
  },
  {
    "label": "Times()",
    "kind": "Method",
    "detail": "Function (} last_clause_ = kWith ; extra_matcher_ = m ; extra_matcher_specified_ = true ; return* this ; } TypedExpectation&)",
    "insertText": "Times(const Cardinality& a_cardinality)"
  },
  {
    "label": "UntypedTimes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UntypedTimes(a_cardinality)"
  },
  {
    "label": "InSequence()",
    "kind": "Method",
    "detail": "Function (} TypedExpectation&)",
    "insertText": "InSequence(const Sequence& s)"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectSpecProperty(last_clause_ <= kInSequence, \".InSequence() cannot appear after .After(),\" \" .WillOnce(), .WillRepeatedly(), or \" \".RetiresOnSaturation().\")"
  },
  {
    "label": "AddExpectation()",
    "kind": "Method",
    "detail": "Function (last_clause_ = kInSequence ; s .)",
    "insertText": "AddExpectation(GetHandle())"
  },
  {
    "label": "InSequence()",
    "kind": "Method",
    "detail": "Function (} TypedExpectation&)",
    "insertText": "InSequence(const Sequence& s1, const Sequence& s2, const Sequence& s3)"
  },
  {
    "label": "InSequence()",
    "kind": "Method",
    "detail": "Function (} TypedExpectation&)",
    "insertText": "InSequence(const Sequence& s1, const Sequence& s2, const Sequence& s3, const Sequence& s4)"
  },
  {
    "label": "InSequence()",
    "kind": "Method",
    "detail": "Function (} TypedExpectation&)",
    "insertText": "InSequence(const Sequence& s1, const Sequence& s2, const Sequence& s3, const Sequence& s4, const Sequence& s5)"
  },
  {
    "label": "After()",
    "kind": "Method",
    "detail": "Function (} TypedExpectation&)",
    "insertText": "After(const ExpectationSet& s)"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectSpecProperty(last_clause_ <= kAfter, \".After() cannot appear after .WillOnce(),\" \" .WillRepeatedly(), or \" \".RetiresOnSaturation().\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (last_clause_ = kAfter ;)",
    "insertText": "for(ExpectationSet::const_iterator it = s.begin(); it != s.end(); ++it)"
  },
  {
    "label": "After()",
    "kind": "Method",
    "detail": "Function (immediate_prerequisites_ + =* it ; } return* this ; } TypedExpectation&)",
    "insertText": "After(const ExpectationSet& s1, const ExpectationSet& s2)"
  },
  {
    "label": "After()",
    "kind": "Method",
    "detail": "Function (} TypedExpectation&)",
    "insertText": "After(const ExpectationSet& s1, const ExpectationSet& s2, const ExpectationSet& s3)"
  },
  {
    "label": "After()",
    "kind": "Method",
    "detail": "Function (} TypedExpectation&)",
    "insertText": "After(const ExpectationSet& s1, const ExpectationSet& s2, const ExpectationSet& s3, const ExpectationSet& s4)"
  },
  {
    "label": "After()",
    "kind": "Method",
    "detail": "Function (} TypedExpectation&)",
    "insertText": "After(const ExpectationSet& s1, const ExpectationSet& s2, const ExpectationSet& s3, const ExpectationSet& s4, const ExpectationSet& s5)"
  },
  {
    "label": "WillOnce()",
    "kind": "Method",
    "detail": "Function (} TypedExpectation&)",
    "insertText": "WillOnce(const Action<F>& action)"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectSpecProperty(last_clause_ <= kWillOnce, \".WillOnce() cannot appear after \" \".WillRepeatedly() or .RetiresOnSaturation().\")"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (last_clause_ = kWillOnce ; untyped_actions_ .)",
    "insertText": "push_back(new Action<F>(action))"
  },
  {
    "label": "set_cardinality()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_cardinality(Exactly(static_cast<int>(untyped_actions_.size())))"
  },
  {
    "label": "WillRepeatedly()",
    "kind": "Method",
    "detail": "Function (} return* this ; } TypedExpectation&)",
    "insertText": "WillRepeatedly(const Action<F>& action)"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectSpecProperty(false, \".WillRepeatedly() cannot appear \" \"more than once in an EXPECT_CALL().\")"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "ExpectSpecProperty(last_clause_ < kWillRepeatedly, \".WillRepeatedly() cannot appear \" \"after .RetiresOnSaturation().\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} last_clause_ = kWillRepeatedly ; repeated_action_specified_ = true ; repeated_action_ = action ;)",
    "insertText": "if(!cardinality_specified())"
  },
  {
    "label": "set_cardinality()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_cardinality(AtLeast(static_cast<int>(untyped_actions_.size())))"
  },
  {
    "label": "CheckActionCountIfNotDone()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CheckActionCountIfNotDone()"
  },
  {
    "label": "ExpectSpecProperty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExpectSpecProperty(last_clause_ < kRetiresOnSaturation, \".RetiresOnSaturation() cannot appear \" \"more than once.\")"
  },
  {
    "label": "DescribeTo()",
    "kind": "Method",
    "detail": "Function (* os<<\" Expected args : \" ; extra_matcher_ .)",
    "insertText": "DescribeTo(os)"
  },
  {
    "label": "Matches()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Matches(const ArgumentTuple& args) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "ShouldHandleArguments()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ShouldHandleArguments(const ArgumentTuple& args) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "ExplainMatchResultTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExplainMatchResultTo(const ArgumentTuple& args, ::std::ostream* os) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* os<<\" Expected : the expectation is active \\ n \"<<\" Actual : it is retired \\ n \" ; } else)",
    "insertText": "if(!Matches(args))"
  },
  {
    "label": "ExplainMatchFailureTupleTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExplainMatchFailureTupleTo(matchers_, args, os)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} StringMatchResultListener listener ;)",
    "insertText": "if(!extra_matcher_.MatchAndExplain(args, &listener))"
  },
  {
    "label": "PrintIfNotEmpty()",
    "kind": "Method",
    "detail": "Function (* os<<\" \\ n Actual : don ' t match \" ;)",
    "insertText": "PrintIfNotEmpty(listener.str(), os)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* os<<\" \\ n \" ; } } else)",
    "insertText": "if(!AllPrerequisitesAreSatisfied())"
  },
  {
    "label": "FindUnsatisfiedPrerequisites()",
    "kind": "Method",
    "detail": "Function (* os<<\" Expected : all pre - requisites are satisfied \\ n \"<<\" Actual : the following immediate pre - requisites \"<<\" are not satisfied : \\ n \" ; ExpectationSet unsatisfied_prereqs ;)",
    "insertText": "FindUnsatisfiedPrerequisites(&unsatisfied_prereqs)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int i = 0 ;)",
    "insertText": "for(ExpectationSet::const_iterator it = unsatisfied_prereqs.begin(); it != unsatisfied_prereqs.end(); ++it)"
  },
  {
    "label": "expectation_base()",
    "kind": "Method",
    "detail": "Function (it ->)",
    "insertText": "expectation_base()->DescribeLocationTo(os)"
  },
  {
    "label": "os()",
    "kind": "Method",
    "detail": "Function (* os<<\" pre - requisite # \"<<i + +<<\" \\ n \" ; }*)",
    "insertText": "os(end of pre-requisites)"
  },
  {
    "label": "GetCurrentAction()",
    "kind": "Method",
    "detail": "Function (} else {* os<<\" The call matches the expectation . \\ n \" ; } } const Action<F>&)",
    "insertText": "GetCurrentAction(const FunctionMocker<F>* mocker, const ArgumentTuple& args) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "call_count()",
    "kind": "Method",
    "detail": "Function (const int count =)",
    "insertText": "call_count()"
  },
  {
    "label": "Assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Assert(count >= 1, __FILE__, __LINE__, \"call_count() is <= 0 when GetCurrentAction() is \" \"called - this should never happen.\")"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (const int action_count = static_cast<)",
    "insertText": "int(untyped_actions_.size())"
  },
  {
    "label": "DescribeLocationTo()",
    "kind": "Method",
    "detail": "Function (::std::stringstream ss ;)",
    "insertText": "DescribeLocationTo(&ss)"
  },
  {
    "label": "source_text()",
    "kind": "Method",
    "detail": "Function (ss<<\" Actions ran out in \"<<)",
    "insertText": "source_text() << \"...\\n\" << \"Called \" << count << \" times, but only \" << action_count << \" WillOnce()\" << (action_count == 1 ? \" is\" : \"s are\")"
  },
  {
    "label": "DescribeDefaultActionTo()",
    "kind": "Method",
    "detail": "Function (mocker ->)",
    "insertText": "DescribeDefaultActionTo(args, &ss)"
  },
  {
    "label": "Log()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Log(kWarning, ss.str(), 1)"
  },
  {
    "label": "F()",
    "kind": "Method",
    "detail": "Function (} return count<= action_count ?* static_cast<const Action<)",
    "insertText": "F(untyped_actions_[static_cast<size_t>(count - 1)]) : repeated_action()"
  },
  {
    "label": "GetActionForArguments()",
    "kind": "Method",
    "detail": "Function (} const Action<F>*)",
    "insertText": "GetActionForArguments(const FunctionMocker<F>* mocker, const ArgumentTuple& args, ::std::ostream* what, ::std::ostream* why) GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "IncrementCallCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IncrementCallCount()"
  },
  {
    "label": "DescribeDefaultActionTo()",
    "kind": "Method",
    "detail": "Function (* what<<\" Mock function called more times than expected - \" ; mocker ->)",
    "insertText": "DescribeDefaultActionTo(args, what)"
  },
  {
    "label": "DescribeCallCountTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DescribeCallCountTo(why)"
  },
  {
    "label": "RetireAllPreRequisites()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RetireAllPreRequisites()"
  },
  {
    "label": "Retire()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Retire()"
  },
  {
    "label": "source_text()",
    "kind": "Method",
    "detail": "Function (}* what<<\" Mock function call matches \"<<)",
    "insertText": "source_text()"
  },
  {
    "label": "GTEST_DISALLOW_COPY_AND_ASSIGN_()",
    "kind": "Method",
    "detail": "Function (} FunctionMocker<F>* const owner_ ; ArgumentMatcherTuple matchers_ ; Matcher<const ArgumentTuple&> extra_matcher_ ; Action<F> repeated_action_ ;)",
    "insertText": "GTEST_DISALLOW_COPY_AND_ASSIGN_(TypedExpectation)"
  },
  {
    "label": "LogWithLocation()",
    "kind": "Method",
    "detail": "Function (} ; GTEST_API_ void)",
    "insertText": "LogWithLocation(testing::internal::LogSeverity severity, const char* file, int line, const std::string& message)"
  },
  {
    "label": "MockSpec()",
    "kind": "Method",
    "detail": "Function (template<F> class MockSpec { public : typedef internal::Function<F>::ArgumentTuple ArgumentTuple ; typedef internal::Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple ;)",
    "insertText": "MockSpec(internal::FunctionMocker<F>* function_mocker, const ArgumentMatcherTuple& matchers) : function_mocker_(function_mocker), matchers_(matchers)"
  },
  {
    "label": "InternalDefaultActionSetAt()",
    "kind": "Method",
    "detail": "Function (} internal::OnCallSpec<F>&)",
    "insertText": "InternalDefaultActionSetAt(const char* file, int line, const char* obj, const char* call)"
  },
  {
    "label": "LogWithLocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LogWithLocation(internal::kInfo, file, line, std::string(\"ON_CALL(\") + obj + \", \" + call + \") invoked\")"
  },
  {
    "label": "InternalExpectedAt()",
    "kind": "Method",
    "detail": "Function (} internal::TypedExpectation<F>&)",
    "insertText": "InternalExpectedAt(const char* file, int line, const char* obj, const char* call)"
  },
  {
    "label": "source_text()",
    "kind": "Method",
    "detail": "Function (const std::string)",
    "insertText": "source_text(std::string(\"EXPECT_CALL(\") + obj + \", \" + call + \")\")"
  },
  {
    "label": "LogWithLocation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LogWithLocation(internal::kInfo, file, line, source_text + \" invoked\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} MockSpec<F>&)",
    "insertText": "operator()(const internal::WithoutMatchers&, void* const)"
  },
  {
    "label": "ReferenceOrValueWrapper()",
    "kind": "Method",
    "detail": "Function (} ; template<T> class ReferenceOrValueWrapper { public :)",
    "insertText": "ReferenceOrValueWrapper(T value) : value_(std::move(value))"
  },
  {
    "label": "Unwrap()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "Unwrap()"
  },
  {
    "label": "Peek()",
    "kind": "Method",
    "detail": "Function (} const T&)",
    "insertText": "Peek()"
  },
  {
    "label": "UntypedActionResultHolderBase()",
    "kind": "Method",
    "detail": "Function (public : ~)",
    "insertText": "UntypedActionResultHolderBase()"
  },
  {
    "label": "PrintAsActionResult()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PrintAsActionResult(::std::ostream* os)"
  },
  {
    "label": "Print()",
    "kind": "Method",
    "detail": "Function (* os<<\" \\ n Returns : \" ; UniversalPrinter<T)",
    "insertText": "Print(result_.Peek(), os)"
  },
  {
    "label": "PerformDefaultAction()",
    "kind": "Method",
    "detail": "Function (} template<F> ActionResultHolder*)",
    "insertText": "PerformDefaultAction(const FunctionMocker<F>* func_mocker, typename Function<F>::ArgumentTuple&& args, const std::string& call_description)"
  },
  {
    "label": "PerformAction()",
    "kind": "Method",
    "detail": "Function (} template<F> ActionResultHolder*)",
    "insertText": "PerformAction(const Action<F>& action, typename Function<F>::ArgumentTuple&& args)"
  },
  {
    "label": "ActionResultHolder()",
    "kind": "Method",
    "detail": "Function (} private : typedef ReferenceOrValueWrapper<T> Wrapper ;)",
    "insertText": "ActionResultHolder(Wrapper result) : result_(std::move(result))"
  },
  {
    "label": "GTEST_DISALLOW_COPY_AND_ASSIGN_()",
    "kind": "Method",
    "detail": "Function (} Wrapper result_ ;)",
    "insertText": "GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionResultHolder)"
  },
  {
    "label": "PrintAsActionResult()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PrintAsActionResult(::std::ostream*)"
  },
  {
    "label": "PerformDefaultAction()",
    "kind": "Method",
    "detail": "Function (func_mocker ->)",
    "insertText": "PerformDefaultAction(std::move(args), call_description)"
  },
  {
    "label": "Perform()",
    "kind": "Method",
    "detail": "Function (action .)",
    "insertText": "Perform(std::move(args))"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} ; template<F> class FunctionMocker ; template<R,. . . Args> class FunctionMocker<)",
    "insertText": "R(Args...)"
  },
  {
    "label": "FunctionMocker()",
    "kind": "Method",
    "detail": "Function (public : using Result = R ; using ArgumentTuple = std::tuple<Args . . .> ; using ArgumentMatcherTuple = std::tuple<Matcher<Args> . . .> ;)",
    "insertText": "FunctionMocker()"
  },
  {
    "label": "FunctionMocker()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FunctionMocker(const FunctionMocker&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FunctionMocker&)",
    "insertText": "operator(const FunctionMocker&)"
  },
  {
    "label": "FunctionMocker()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FunctionMocker() override GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "l()",
    "kind": "Method",
    "detail": "Function (MutexLock)",
    "insertText": "l(&g_gmock_mutex)"
  },
  {
    "label": "UnregisterLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterLocked(this)"
  },
  {
    "label": "ClearDefaultActionsLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearDefaultActionsLocked()"
  },
  {
    "label": "FindOnCallSpec()",
    "kind": "Method",
    "detail": "Function (} const OnCallSpec<F>*)",
    "insertText": "FindOnCallSpec(const ArgumentTuple& args)"
  },
  {
    "label": "PerformDefaultAction()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } Result)",
    "insertText": "PerformDefaultAction(ArgumentTuple&& args, const std::string& call_description)"
  },
  {
    "label": "FindOnCallSpec()",
    "kind": "Method",
    "detail": "Function (const OnCallSpec<F>* const spec = this ->)",
    "insertText": "FindOnCallSpec(args)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} const std::string message = call_description + \" \\ n The mock function has no default action \" \" set,and its return type has no default value set . \" ; # if GTEST_HAS_EXCEPTIONS)",
    "insertText": "if(!DefaultValue<Result>::Exists())"
  },
  {
    "label": "runtime_error()",
    "kind": "Method",
    "detail": "Function (throw)",
    "insertText": "runtime_error(message)"
  },
  {
    "label": "Assert()",
    "kind": "Method",
    "detail": "Function (} # else)",
    "insertText": "Assert(DefaultValue<Result>::Exists(), \"\", -1, message)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (# endif return DefaultValue<Result)",
    "insertText": "Get()"
  },
  {
    "label": "ArgumentTuple()",
    "kind": "Method",
    "detail": "Function (ArgumentTuple* args = static_cast<)",
    "insertText": "ArgumentTuple(untyped_args)"
  },
  {
    "label": "F()",
    "kind": "Method",
    "detail": "Function (const Action<F> action =* static_cast<const Action<)",
    "insertText": "F(untyped_action)"
  },
  {
    "label": "ClearDefaultActionsLocked()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearDefaultActionsLocked() override GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (UntypedOnCallSpecs specs_to_delete ; untyped_on_call_specs_ .)",
    "insertText": "swap(specs_to_delete)"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (g_gmock_mutex .)",
    "insertText": "Unlock()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (} g_gmock_mutex .)",
    "insertText": "Lock()"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (} Result)",
    "insertText": "Invoke(Args... args) GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "tuple()",
    "kind": "Method",
    "detail": "Function (ArgumentTuple)",
    "insertText": "tuple(std::forward<Args>(args)...)"
  },
  {
    "label": "holder()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<ResultHolder>)",
    "insertText": "holder(DownCast_<ResultHolder*>( this->UntypedInvokeWith(static_cast<void*>(&tuple))))"
  },
  {
    "label": "With()",
    "kind": "Method",
    "detail": "Function (} MockSpec<F>)",
    "insertText": "With(Matcher<Args>... m)"
  },
  {
    "label": "AddNewOnCallSpec()",
    "kind": "Method",
    "detail": "Function (} protected : template<Function> class MockSpec ; typedef ActionResultHolder<Result> ResultHolder ; OnCallSpec<F>&)",
    "insertText": "AddNewOnCallSpec(const char* file, int line, const ArgumentMatcherTuple& m) GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "RegisterUseByOnCallOrExpectCall()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterUseByOnCallOrExpectCall(MockObject(), file, line)"
  },
  {
    "label": "F()",
    "kind": "Method",
    "detail": "Function (OnCallSpec<F>* const on_call_spec = new OnCallSpec<)",
    "insertText": "F(file, line, m)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (untyped_on_call_specs_ .)",
    "insertText": "push_back(on_call_spec)"
  },
  {
    "label": "F()",
    "kind": "Method",
    "detail": "Function (TypedExpectation<F>* const expectation = new TypedExpectation<)",
    "insertText": "F(this, file, line, source_text, m)"
  },
  {
    "label": "untyped_expectation()",
    "kind": "Method",
    "detail": "Function (const std::shared_ptr<ExpectationBase>)",
    "insertText": "untyped_expectation(expectation)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (untyped_expectations_ .)",
    "insertText": "push_back(untyped_expectation)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (Sequence* const implicit_sequence = g_gmock_implicit_sequence .)",
    "insertText": "get()"
  },
  {
    "label": "AddExpectation()",
    "kind": "Method",
    "detail": "Function (implicit_sequence ->)",
    "insertText": "AddExpectation(Expectation(untyped_expectation))"
  },
  {
    "label": "DescribeDefaultActionTo()",
    "kind": "Method",
    "detail": "Function (} return* expectation ; } private : template<Func> class TypedExpectation ; void)",
    "insertText": "DescribeDefaultActionTo(const ArgumentTuple& args, ::std::ostream* os)"
  },
  {
    "label": "os()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "os(std::is_void<Result>::value ? \"returning directly.\\n\" : \"returning default value.\\n\")"
  },
  {
    "label": "FormatFileLocation()",
    "kind": "Method",
    "detail": "Function (} else {* os<<\" taking default action specified at : \\ n \"<<)",
    "insertText": "FormatFileLocation(spec->file(), spec->line())"
  },
  {
    "label": "UntypedDescribeUninterestingCall()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "UntypedDescribeUninterestingCall(const void* untyped_args, ::std::ostream* os) const override GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "DescribeDefaultActionTo()",
    "kind": "Method",
    "detail": "Function (* os<<\" Uninteresting mock function call - \" ;)",
    "insertText": "DescribeDefaultActionTo(args, os)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (* os<<\" Function call : \"<<)",
    "insertText": "Name()"
  },
  {
    "label": "UniversalPrint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UniversalPrint(args, os)"
  },
  {
    "label": "UntypedFindMatchingExpectation()",
    "kind": "Method",
    "detail": "Function (} const ExpectationBase*)",
    "insertText": "UntypedFindMatchingExpectation(const void* untyped_args, const void** untyped_action, bool* is_excessive, ::std::ostream* what, ::std::ostream* why) override GTEST_LOCK_EXCLUDED_(g_gmock_mutex)"
  },
  {
    "label": "FindMatchingExpectationLocked()",
    "kind": "Method",
    "detail": "Function (TypedExpectation<F>* exp = this ->)",
    "insertText": "FindMatchingExpectationLocked(args)"
  },
  {
    "label": "FormatUnexpectedCallMessageLocked()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "FormatUnexpectedCallMessageLocked(args, what, why)"
  },
  {
    "label": "GetActionForArguments()",
    "kind": "Method",
    "detail": "Function (const Action<F>* action = exp ->)",
    "insertText": "GetActionForArguments(this, args, what, why)"
  },
  {
    "label": "FindMatchingExpectationLocked()",
    "kind": "Method",
    "detail": "Function (} TypedExpectation<F>*)",
    "insertText": "FindMatchingExpectationLocked(const ArgumentTuple& args) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "F()",
    "kind": "Method",
    "detail": "Function (TypedExpectation<F>* const exp = static_cast<TypedExpectation<)",
    "insertText": "F(it->get())"
  },
  {
    "label": "PrintTriedExpectationsLocked()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrintTriedExpectationsLocked(args, why)"
  },
  {
    "label": "PrintTriedExpectationsLocked()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PrintTriedExpectationsLocked(const ArgumentTuple& args, ::std::ostream* why) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (const size_t count = untyped_expectations_ .)",
    "insertText": "size()"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (* why<<\" Google Mock tried the following \"<<)",
    "insertText": "count(count == 1 ? \"expectation, but it didn't match\" : \"expectations, but none matched\")"
  },
  {
    "label": "F()",
    "kind": "Method",
    "detail": "Function (TypedExpectation<F>* const expectation = static_cast<TypedExpectation<)",
    "insertText": "F(untyped_expectations_[i].get())"
  },
  {
    "label": "DescribeLocationTo()",
    "kind": "Method",
    "detail": "Function (* why<<\" \\ n \" ; expectation ->)",
    "insertText": "DescribeLocationTo(why)"
  },
  {
    "label": "ExplainMatchResultTo()",
    "kind": "Method",
    "detail": "Function (expectation ->)",
    "insertText": "ExplainMatchResultTo(args, why)"
  },
  {
    "label": "GTEST_DISABLE_MSC_WARNINGS_POP_()",
    "kind": "Method",
    "detail": "Function (} } } ;)",
    "insertText": "GTEST_DISABLE_MSC_WARNINGS_POP_() void ReportUninterestingCall(CallReaction reaction, const std::string& msg)"
  },
  {
    "label": "MockFunction()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "MockFunction()"
  },
  {
    "label": "MockFunction()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MockFunction(const MockFunction&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MockFunction&)",
    "insertText": "operator(const MockFunction&)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (std::function<)",
    "insertText": "R(Args...)> AsStdFunction()"
  },
  {
    "label": "Call()",
    "kind": "Method",
    "detail": "Function (} ; } R)",
    "insertText": "Call(Args... args)"
  },
  {
    "label": "SetOwnerAndName()",
    "kind": "Method",
    "detail": "Function (mock_ .)",
    "insertText": "SetOwnerAndName(this, \"Call\")"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} internal::MockSpec<)",
    "insertText": "R(Args...)> gmock_Call(Matcher<Args>... m)"
  },
  {
    "label": "RegisterOwner()",
    "kind": "Method",
    "detail": "Function (mock_ .)",
    "insertText": "RegisterOwner(this)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} internal::MockSpec<)",
    "insertText": "R(Args...)> gmock_Call(const internal::WithoutMatchers&, R (*)(Args...))"
  },
  {
    "label": "Const()",
    "kind": "Method",
    "detail": "Function (} ; using internal::MockSpec ; template<T> const T&)",
    "insertText": "Const(const T& x)"
  }
]