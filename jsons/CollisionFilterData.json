[
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FCollisionFilterData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCollisionFilterData"
  },
  {
    "label": "LexToString()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" ChaosArchive . h \" # include \" UObject / ExternalPhysicsCustomObjectVersion . h \" namespace Chaos { enum class EFilterFlags : uint8 { SimpleCollision = 0 b00000001,ComplexCollision = 0 b00000010,CCD = 0 b00000100,ContactNotify = 0 b00001000,StaticShape = 0 b00010000,ModifyContacts = 0 b00100000,KinematicKinematicPairs = 0 b01000000,} ; const TCHAR*)",
    "insertText": "LexToString(EFilterFlags FilterFlag)"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (default : return)",
    "insertText": "TEXT(\"Invalid\")"
  },
  {
    "label": "FCollisionFilterData()",
    "kind": "Method",
    "detail": "Function (} } } struct FCollisionFilterData { uint32 Word0 ; uint32 Word1 ; uint32 Word2 ; uint32 Word3 ;)",
    "insertText": "FCollisionFilterData()"
  },
  {
    "label": "HasFlag()",
    "kind": "Method",
    "detail": "Function (Word0 = Word1 = Word2 = Word3 = 0 ; } bool)",
    "insertText": "HasFlag(Chaos::EFilterFlags InFlag)"
  },
  {
    "label": "FilterFlags()",
    "kind": "Method",
    "detail": "Function (const uint32)",
    "insertText": "FilterFlags(Word3 & 0xFFFFFF)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FCollisionFilterData& A, const FCollisionFilterData& B)"
  }
]