[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "IMATH_EXPORT_TEMPLATE_TYPE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMATH_EXPORT_TEMPLATE_TYPE"
  },
  {
    "label": "Frustum()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHFRUSTUM_H # define INCLUDED_IMATHFRUSTUM_H # include \" ImathExport . h \" # include \" ImathNamespace . h \" # include \" ImathFun . h \" # include \" ImathLine . h \" # include \" ImathMatrix . h \" # include \" ImathPlane . h \" # include \" ImathVec . h \" IMATH_INTERNAL_NAMESPACE_HEADER_ENTER template<class T> class IMATH_EXPORT_TEMPLATE_TYPE Frustum { public : IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Frustum()"
  },
  {
    "label": "Frustum()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Frustum(const Frustum&)"
  },
  {
    "label": "Frustum()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Frustum(T nearPlane, T farPlane, T left, T right, T top, T bottom, bool ortho = false)"
  },
  {
    "label": "Frustum()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Frustum(T nearPlane, T farPlane, T fovx, T fovy, T aspect)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Frustum&)",
    "insertText": "operator(const Frustum&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE bool)",
    "insertText": "operator(const Frustum<T>& src)"
  },
  {
    "label": "orthographic()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE bool)",
    "insertText": "orthographic()"
  },
  {
    "label": "fovy()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "fovy()"
  },
  {
    "label": "aspect()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 T)",
    "insertText": "aspect()"
  },
  {
    "label": "aspectExc()",
    "kind": "Method",
    "detail": "Function (IMATH_CONSTEXPR14 T)",
    "insertText": "aspectExc()"
  },
  {
    "label": "projectionMatrix()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Matrix44<T>)",
    "insertText": "projectionMatrix()"
  },
  {
    "label": "projectionMatrixExc()",
    "kind": "Method",
    "detail": "Function (IMATH_CONSTEXPR14 Matrix44<T>)",
    "insertText": "projectionMatrixExc()"
  },
  {
    "label": "degenerate()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE bool)",
    "insertText": "degenerate()"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "set(T nearPlane, T farPlane, T left, T right, T top, T bottom, bool ortho = false)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "set(T nearPlane, T farPlane, T fovx, T fovy, T aspect)"
  },
  {
    "label": "setExc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setExc(T nearPlane, T farPlane, T fovx, T fovy, T aspect)"
  },
  {
    "label": "modifyNearAndFar()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "modifyNearAndFar(T nearPlane, T farPlane)"
  },
  {
    "label": "setOrthographic()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "setOrthographic(bool)"
  },
  {
    "label": "planes()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "planes(Plane3<T> p[6])"
  },
  {
    "label": "planes()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "planes(Plane3<T> p[6], const Matrix44<T>& M)"
  },
  {
    "label": "window()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 IMATH_HOSTDEVICE Frustum<T>)",
    "insertText": "window(T left, T right, T top, T bottom)"
  },
  {
    "label": "projectScreenToRay()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Line3<T>)",
    "insertText": "projectScreenToRay(const Vec2<T>&)"
  },
  {
    "label": "projectPointToScreen()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Vec2<T>)",
    "insertText": "projectPointToScreen(const Vec3<T>&)"
  },
  {
    "label": "projectPointToScreenExc()",
    "kind": "Method",
    "detail": "Function (IMATH_CONSTEXPR14 Vec2<T>)",
    "insertText": "projectPointToScreenExc(const Vec3<T>&)"
  },
  {
    "label": "ZToDepth()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 T)",
    "insertText": "ZToDepth(long zval, long min, long max)"
  },
  {
    "label": "ZToDepthExc()",
    "kind": "Method",
    "detail": "Function (IMATH_CONSTEXPR14 T)",
    "insertText": "ZToDepthExc(long zval, long min, long max)"
  },
  {
    "label": "normalizedZToDepth()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 T)",
    "insertText": "normalizedZToDepth(T zval)"
  },
  {
    "label": "normalizedZToDepthExc()",
    "kind": "Method",
    "detail": "Function (IMATH_CONSTEXPR14 T)",
    "insertText": "normalizedZToDepthExc(T zval)"
  },
  {
    "label": "DepthToZ()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 long)",
    "insertText": "DepthToZ(T depth, long zmin, long zmax)"
  },
  {
    "label": "DepthToZExc()",
    "kind": "Method",
    "detail": "Function (IMATH_CONSTEXPR14 long)",
    "insertText": "DepthToZExc(T depth, long zmin, long zmax)"
  },
  {
    "label": "worldRadius()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 T)",
    "insertText": "worldRadius(const Vec3<T>& p, T radius)"
  },
  {
    "label": "worldRadiusExc()",
    "kind": "Method",
    "detail": "Function (IMATH_CONSTEXPR14 T)",
    "insertText": "worldRadiusExc(const Vec3<T>& p, T radius)"
  },
  {
    "label": "screenRadius()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 T)",
    "insertText": "screenRadius(const Vec3<T>& p, T radius)"
  },
  {
    "label": "screenRadiusExc()",
    "kind": "Method",
    "detail": "Function (IMATH_CONSTEXPR14 T)",
    "insertText": "screenRadiusExc(const Vec3<T>& p, T radius)"
  },
  {
    "label": "screenToLocal()",
    "kind": "Method",
    "detail": "Function (protected : IMATH_HOSTDEVICE Vec2<T>)",
    "insertText": "screenToLocal(const Vec2<T>&)"
  },
  {
    "label": "localToScreen()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Vec2<T>)",
    "insertText": "localToScreen(const Vec2<T>&)"
  },
  {
    "label": "localToScreenExc()",
    "kind": "Method",
    "detail": "Function (IMATH_CONSTEXPR14 Vec2<T>)",
    "insertText": "localToScreenExc(const Vec2<T>&)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(T (0.1), T (1000.0), T (-1.0), T (1.0), T (1.0), T (-1.0), false)"
  },
  {
    "label": "Frustum()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_CONSTEXPR14 Frustum<T)",
    "insertText": "Frustum(const Frustum& f)"
  },
  {
    "label": "Frustum()",
    "kind": "Method",
    "detail": "Function (* this = f ; } template<class T> IMATH_CONSTEXPR14 Frustum<T)",
    "insertText": "Frustum(T n, T f, T l, T r, T t, T b, bool o)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(n, f, l, r, t, b, o)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(nearPlane, farPlane, fovx, fovy, aspect)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_CONSTEXPR14 const Frustum<T>& Frustum<T)",
    "insertText": "operator(const Frustum& f)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} template<class T> void Frustum<T)",
    "insertText": "set(T n, T f, T l, T r, T t, T b, bool o)"
  },
  {
    "label": "modifyNearAndFar()",
    "kind": "Method",
    "detail": "Function (_nearPlane = n ; _farPlane = f ; _left = l ; _right = r ; _bottom = b ; _top = t ; _orthographic = o ; } template<class T> void Frustum<T)",
    "insertText": "modifyNearAndFar(T n, T f)"
  },
  {
    "label": "lowerLeft()",
    "kind": "Method",
    "detail": "Function (_nearPlane = n ; } else { Line3<T>)",
    "insertText": "lowerLeft(Vec3<T> (0, 0, 0), Vec3<T> (_left, _bottom, -_nearPlane))"
  },
  {
    "label": "upperRight()",
    "kind": "Method",
    "detail": "Function (Line3<T>)",
    "insertText": "upperRight(Vec3<T> (0, 0, 0), Vec3<T> (_right, _top, -_nearPlane))"
  },
  {
    "label": "nearPlane()",
    "kind": "Method",
    "detail": "Function (Plane3<T>)",
    "insertText": "nearPlane(Vec3<T> (0, 0, -1), n)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> ll = Vec3<)",
    "insertText": "T(0, 0, 0)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (nearPlane .)",
    "insertText": "intersect(lowerLeft, ll)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (nearPlane .)",
    "insertText": "intersect(upperRight, ur)"
  },
  {
    "label": "setOrthographic()",
    "kind": "Method",
    "detail": "Function (_left = ll . x ; _right = ur . x ; _top = ur . y ; _bottom = ll . y ; _nearPlane = n ; _farPlane = f ; } _farPlane = f ; } template<class T> void Frustum<T)",
    "insertText": "setOrthographic(bool ortho)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const T two = static_cast<)",
    "insertText": "T(2)"
  },
  {
    "label": "tan()",
    "kind": "Method",
    "detail": "Function (_right = nearPlane*)",
    "insertText": "tan(fovx / two)"
  },
  {
    "label": "_top()",
    "kind": "Method",
    "detail": "Function (_left = - _right ;)",
    "insertText": "_top((_right - _left) / aspect)"
  },
  {
    "label": "tan()",
    "kind": "Method",
    "detail": "Function (_bottom = - _top ; } else { _top = nearPlane*)",
    "insertText": "tan(fovy / two)"
  },
  {
    "label": "_right()",
    "kind": "Method",
    "detail": "Function (_bottom = - _top ;)",
    "insertText": "_right(_top - _bottom)"
  },
  {
    "label": "fovx()",
    "kind": "Method",
    "detail": "Function (_left = - _right ; } _nearPlane = nearPlane ; _farPlane = farPlane ; _orthographic = false ; } template<class T> T Frustum<T)",
    "insertText": "fovx()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T rightMinusLeft = _right - _left ; T topMinusBottom = _top - _bottom ;)",
    "insertText": "if(abs (topMinusBottom) < T (1) && abs (rightMinusLeft) > std::numeric_limits<T>::max() * abs (topMinusBottom))"
  },
  {
    "label": "domain_error()",
    "kind": "Method",
    "detail": "Function (throw)",
    "insertText": "domain_error(\"Bad viewing frustum: \" \"aspect ratio cannot be computed.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T rightPlusLeft = _right + _left ; T rightMinusLeft = _right - _left ; T topPlusBottom = _top + _bottom ; T topMinusBottom = _top - _bottom ; T farPlusNear = _farPlane + _nearPlane ; T farMinusNear = _farPlane - _nearPlane ;)",
    "insertText": "if((abs (rightMinusLeft) < T (1) && abs (rightPlusLeft) > std::numeric_limits<T>::max() * abs (rightMinusLeft)) || (abs (topMinusBottom) < T (1) && abs (topPlusBottom) > std::numeric_limits<T>::max() * abs (topMinusBottom)) || (abs (farMinusNear) < 1 && abs (farPlusNear) > std::numeric_limits<T>::max() * abs (farMinusNear)))"
  },
  {
    "label": "domain_error()",
    "kind": "Method",
    "detail": "Function (throw)",
    "insertText": "domain_error(\"Bad viewing frustum: \" \"projection matrix cannot be computed.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(_orthographic)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T tx = - rightPlusLeft / rightMinusLeft ; T ty = - topPlusBottom / topMinusBottom ; T tz = - farPlusNear / farMinusNear ;)",
    "insertText": "if((abs (rightMinusLeft) < T (1) && T (2) > std::numeric_limits<T>::max() * abs (rightMinusLeft)) || (abs (topMinusBottom) < T (1) && T (2) > std::numeric_limits<T>::max() * abs (topMinusBottom)) || (abs (farMinusNear) < T (1) && T (2) > std::numeric_limits<T>::max() * abs (farMinusNear)))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T C =)",
    "insertText": "T(-2)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} T E = twoTimesNear / rightMinusLeft ; T F = twoTimesNear / topMinusBottom ; return Matrix44<)",
    "insertText": "T(E, 0, 0, 0, 0, F, 0, 0, A, B, C, -1, 0, 0, D, 0)"
  },
  {
    "label": "window()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_CONSTEXPR14 Frustum<T> Frustum<T)",
    "insertText": "window(T l, T r, T t, T b)"
  },
  {
    "label": "screenToLocal()",
    "kind": "Method",
    "detail": "Function (Vec2<T> bl =)",
    "insertText": "screenToLocal(Vec2<T> (l, b))"
  },
  {
    "label": "screenToLocal()",
    "kind": "Method",
    "detail": "Function (Vec2<T> tr =)",
    "insertText": "screenToLocal(Vec2<T> (r, t))"
  },
  {
    "label": "screenToLocal()",
    "kind": "Method",
    "detail": "Function (} template<class T> Vec2<T> Frustum<T)",
    "insertText": "screenToLocal(const Vec2<T>& s)"
  },
  {
    "label": "localToScreenExc()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_CONSTEXPR14 Vec2<T> Frustum<T)",
    "insertText": "localToScreenExc(const Vec2<T>& p)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T bottomMinusTop = _bottom - _top ;)",
    "insertText": "if((abs (leftMinusRight) < T (1) && abs (leftPlusRight) > std::numeric_limits<T>::max() * abs (leftMinusRight)) || (abs (bottomMinusTop) < T (1) && abs (bottomPlusTop) > std::numeric_limits<T>::max() * abs (bottomMinusTop)))"
  },
  {
    "label": "domain_error()",
    "kind": "Method",
    "detail": "Function (throw)",
    "insertText": "domain_error(\"Bad viewing frustum: \" \"local-to-screen transformation cannot be computed\")"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} return Vec2<)",
    "insertText": "T(leftPlusRight / leftMinusRight, bottomPlusTop / bottomMinusTop)"
  },
  {
    "label": "localToScreen()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_CONSTEXPR14 Vec2<T> Frustum<T)",
    "insertText": "localToScreen(const Vec2<T>& p)"
  },
  {
    "label": "projectScreenToRay()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_CONSTEXPR14 Line3<T> Frustum<T)",
    "insertText": "projectScreenToRay(const Vec2<T>& p)"
  },
  {
    "label": "screenToLocal()",
    "kind": "Method",
    "detail": "Function (Vec2<T> point =)",
    "insertText": "screenToLocal(p)"
  },
  {
    "label": "projectPointToScreenExc()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_CONSTEXPR14 Vec2<T> Frustum<T)",
    "insertText": "projectPointToScreenExc(const Vec3<T>& point)"
  },
  {
    "label": "projectPointToScreen()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_CONSTEXPR14 Vec2<T> Frustum<T)",
    "insertText": "projectPointToScreen(const Vec3<T>& point)"
  },
  {
    "label": "ZToDepthExc()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_CONSTEXPR14 T Frustum<T)",
    "insertText": "ZToDepthExc(long zval, long zmin, long zmax)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int zdiff = zmax - zmin ;)",
    "insertText": "if(zdiff == 0)"
  },
  {
    "label": "domain_error()",
    "kind": "Method",
    "detail": "Function (throw)",
    "insertText": "domain_error(\"Bad call to Frustum::ZToDepth: zmax == zmin\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(zval > zmax + 1)"
  },
  {
    "label": "fzval()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "fzval(T (zval) - T (zmin)) / T (zdiff)"
  },
  {
    "label": "ZToDepth()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_CONSTEXPR14 T Frustum<T)",
    "insertText": "ZToDepth(long zval, long zmin, long zmax)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T Zp = zval*)",
    "insertText": "T(2) - T (1)"
  },
  {
    "label": "Zp()",
    "kind": "Method",
    "detail": "Function (} else { T farTimesNear = 2* _farPlane* _nearPlane ; T farMinusNear =)",
    "insertText": "Zp(_farPlane - _nearPlane)"
  },
  {
    "label": "domain_error()",
    "kind": "Method",
    "detail": "Function (throw)",
    "insertText": "domain_error(\"Frustum::normalizedZToDepth cannot be computed: \" \"near and far clipping planes of the viewing frustum \" \"may be too close to each other\")"
  },
  {
    "label": "domain_error()",
    "kind": "Method",
    "detail": "Function (throw)",
    "insertText": "domain_error(\"Bad viewing frustum: \" \"near and far clipping planes \" \"are too close to each other\")"
  },
  {
    "label": "long()",
    "kind": "Method",
    "detail": "Function (} T Zp = - farPlusNear / farMinusNear ; return)",
    "insertText": "long(0.5 * (Zp + 1) * zdiff)"
  },
  {
    "label": "domain_error()",
    "kind": "Method",
    "detail": "Function (throw)",
    "insertText": "domain_error(\"Bad call to DepthToZ function: \" \"value of `depth' is too small\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} T farPlusNear = farTimesNear / depth + _farPlane + _nearPlane ;)",
    "insertText": "if(abs (farMinusNear) < T (1) && abs (farPlusNear) > std::numeric_limits<T>::max() * abs (farMinusNear))"
  },
  {
    "label": "domain_error()",
    "kind": "Method",
    "detail": "Function (} else { throw)",
    "insertText": "domain_error(\"Bad call to Frustum::screenRadius: \" \"magnitude of `p' is too small\")"
  },
  {
    "label": "radius()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "radius(-_nearPlane / p.z)"
  },
  {
    "label": "domain_error()",
    "kind": "Method",
    "detail": "Function (} else { throw)",
    "insertText": "domain_error(\"Bad viewing frustum: \" \"near clipping plane is too close to zero\")"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "a(_left, _bottom, -_nearPlane)"
  },
  {
    "label": "b()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "b(_left, _top, -_nearPlane)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "c(_right, _top, -_nearPlane)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "d(_right, _bottom, -_nearPlane)"
  },
  {
    "label": "o()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "o(0, 0, 0)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 0 ] .)",
    "insertText": "set(o, c, b)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 1 ] .)",
    "insertText": "set(o, d, c)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 2 ] .)",
    "insertText": "set(o, a, d)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 3 ] .)",
    "insertText": "set(o, b, a)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} else { p [ 0 ] .)",
    "insertText": "set(Vec3<T> (0, 1, 0), _top)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 1 ] .)",
    "insertText": "set(Vec3<T> (1, 0, 0), _right)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 2 ] .)",
    "insertText": "set(Vec3<T> (0, -1, 0), -_bottom)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 3 ] .)",
    "insertText": "set(Vec3<T> (-1, 0, 0), -_left)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} p [ 4 ] .)",
    "insertText": "set(Vec3<T> (0, 0, 1), -_nearPlane)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 5 ] .)",
    "insertText": "set(Vec3<T> (0, 0, -1), _farPlane)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> a = Vec3<)",
    "insertText": "T(_left, _bottom, -_nearPlane)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> b = Vec3<)",
    "insertText": "T(_left, _top, -_nearPlane)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> c = Vec3<)",
    "insertText": "T(_right, _top, -_nearPlane)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> d = Vec3<)",
    "insertText": "T(_right, _bottom, -_nearPlane)"
  },
  {
    "label": "farLeft()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "farLeft(T) (s * _left)"
  },
  {
    "label": "farRight()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "farRight(T) (s * _right)"
  },
  {
    "label": "farTop()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "farTop(T) (s * _top)"
  },
  {
    "label": "farBottom()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "farBottom(T) (s * _bottom)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> e = Vec3<)",
    "insertText": "T(farLeft, farBottom, -_farPlane)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> f = Vec3<)",
    "insertText": "T(farLeft, farTop, -_farPlane)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> g = Vec3<)",
    "insertText": "T(farRight, farTop, -_farPlane)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 4 ] .)",
    "insertText": "set(a, d, c)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 5 ] .)",
    "insertText": "set(e, f, g)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else { Vec3<T> e = Vec3<)",
    "insertText": "T(_left, _bottom, -_farPlane)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> f = Vec3<)",
    "insertText": "T(_left, _top, -_farPlane)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> g = Vec3<)",
    "insertText": "T(_right, _top, -_farPlane)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> h = Vec3<)",
    "insertText": "T(_right, _bottom, -_farPlane)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 0 ] .)",
    "insertText": "set(c, g, f)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 1 ] .)",
    "insertText": "set(d, h, g)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 2 ] .)",
    "insertText": "set(a, e, h)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (p [ 3 ] .)",
    "insertText": "set(b, f, e)"
  }
]