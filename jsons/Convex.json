[
  {
    "label": "FConvex",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConvex"
  },
  {
    "label": "FISPCDataVerifier",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FISPCDataVerifier"
  },
  {
    "label": "FConvex()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / ImplicitObject . h \" # include \" Chaos / AABB . h \" # include \" Chaos / ConvexStructureData . h \" # include \" Chaos / MassProperties . h \" # include \" Math / UnrealMathVectorCommon . h \" # include \" CollisionConvexMesh . h \" # include \" ChaosArchive . h \" # include \" ChaosCheck . h \" # include \" ChaosLog . h \" # include \" UObject / ReleaseObjectVersion . h \" # include \" UObject / PhysicsObjectVersion . h \" # include \" UObject / UE5MainStreamObjectVersion . h \" # include \" UObject / UE5ReleaseStreamObjectVersion . h \" # include \" UObject / FortniteMainBranchObjectVersion . h \" namespace Chaos { class FConvex final : public FImplicitObject { public : using FImplicitObject::GetTypeName ; using TType = FRealSingle ; using FRealType = TType ; using FVec3Type = TVec3<FRealType> ; using FPlaneType = TPlaneConcrete<FRealType,3> ; using FAABB3Type = TAABB<FRealType,3> ; unsigned D = 3 ;)",
    "insertText": "FConvex() : FImplicitObject(EImplicitObject::IsConvex | EImplicitObject::HasBoundingBox, ImplicitObjectType::Convex) , Volume(0.f) , CenterOfMass(FVec3Type(0.f)) , UnitMassInertiaTensor(1., 1., 1.) , RotationOfMass(FRotation3::Identity)"
  },
  {
    "label": "FConvex()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FConvex(FConvex&& Other) : FImplicitObject(EImplicitObject::IsConvex | EImplicitObject::HasBoundingBox, ImplicitObjectType::Convex) , Planes(MoveTemp(Other.Planes)) , Vertices(MoveTemp(Other.Vertices)) , LocalBoundingBox(MoveTemp(Other.LocalBoundingBox)) , StructureData(MoveTemp(Other.StructureData)) , Volume(MoveTemp(Other.Volume)) , CenterOfMass(MoveTemp(Other.CenterOfMass)) , UnitMassInertiaTensor(MoveTemp(Other.UnitMassInertiaTensor)) , RotationOfMass(MoveTemp(Other.RotationOfMass))"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (LocalBoundingBox .)",
    "insertText": "GrowToInclude(Vertices[ParticleIndex])"
  },
  {
    "label": "GetCenterOfMass()",
    "kind": "Method",
    "detail": "Function (} CenterOfMass = LocalBoundingBox .)",
    "insertText": "GetCenterOfMass()"
  },
  {
    "label": "GetVolume()",
    "kind": "Method",
    "detail": "Function (Volume = LocalBoundingBox .)",
    "insertText": "GetVolume()"
  },
  {
    "label": "ComputeUnitMassInertiaTensorAndRotationOfMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeUnitMassInertiaTensorAndRotationOfMass(Volume)"
  },
  {
    "label": "FConvex()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FConvex(TArray<FPlaneType>&& InPlanes, TArray<TArray<int32>>&& InFaceIndices, TArray<FVec3Type>&& InVertices) : FImplicitObject(EImplicitObject::IsConvex | EImplicitObject::HasBoundingBox, ImplicitObjectType::Convex) , Planes(MoveTemp(InPlanes)) , Vertices(MoveTemp(InVertices))"
  },
  {
    "label": "CreateStructureData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateStructureData(MoveTemp(InFaceIndices))"
  },
  {
    "label": "FConvex()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FConvex(TArray<FPlaneType>&& InPlanes, TArray<TArray<int32>>&& InFaceIndices, TArray<FVec3Type>&& InVertices, const FVec3Type& InMin, const FVec3Type& InMax, const FRealType InVolume, const FVec3Type InInertiaTensor, const FRotation3& InRotationMatrix, const bool bRegularDatas) : FImplicitObject(EImplicitObject::IsConvex | EImplicitObject::HasBoundingBox, ImplicitObjectType::Convex) , Planes(MoveTemp(InPlanes)) , Vertices(MoveTemp(InVertices))"
  },
  {
    "label": "FAABB3Type()",
    "kind": "Method",
    "detail": "Function (LocalBoundingBox =)",
    "insertText": "FAABB3Type(InMin, InMax)"
  },
  {
    "label": "CreateStructureData()",
    "kind": "Method",
    "detail": "Function (Volume = InVolume ; RotationOfMass = InRotationMatrix ; UnitMassInertiaTensor = InInertiaTensor ;)",
    "insertText": "CreateStructureData(MoveTemp(InFaceIndices), bRegularDatas)"
  },
  {
    "label": "FConvex()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FConvex(const TArray<FVec3Type>& InVertices, const FReal InMargin, FConvexBuilder::EBuildMethod BuildMethod = FConvexBuilder::EBuildMethod::Default) : FImplicitObject(EImplicitObject::IsConvex | EImplicitObject::HasBoundingBox, ImplicitObjectType::Convex) , CenterOfMass(FVec3Type(0.f))"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 NumVertices = InVertices .)",
    "insertText": "Num()"
  },
  {
    "label": "CHAOS_ENSURE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CHAOS_ENSURE(Planes.Num() == FaceIndices.Num())"
  },
  {
    "label": "CalculateVolumeAndCenterOfMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculateVolumeAndCenterOfMass(Vertices, FaceIndices, Volume, CenterOfMass)"
  },
  {
    "label": "MergeFaces()",
    "kind": "Method",
    "detail": "Function (const FRealType DistanceTolerance = 1 . 0 f ; const FRealType AngleTolerance = 1 . e - 6 f ;)",
    "insertText": "MergeFaces(Planes, FaceIndices, Vertices, DistanceTolerance)"
  },
  {
    "label": "MergeColinearEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MergeColinearEdges(Planes, FaceIndices, Vertices, AngleTolerance)"
  },
  {
    "label": "CreateStructureData()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CreateStructureData(MoveTemp(FaceIndices))"
  },
  {
    "label": "SetMargin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMargin(InMargin)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FConvex&)",
    "insertText": "operator(const FConvex& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FConvex&)",
    "insertText": "operator(FConvex&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Type = Other . Type ; CollisionType = Other . CollisionType ; Margin = Other . Margin ; bIsConvex = Other . bIsConvex ; bDoCollide = Other . bDoCollide ; bHasBoundingBox = Other . bHasBoundingBox ; # if TRACK_CHAOS_GEOMETRY bIsTracked = Other . bIsTracked ; # endif Planes =)",
    "insertText": "MoveTemp(Other.Planes)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Vertices =)",
    "insertText": "MoveTemp(Other.Vertices)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (LocalBoundingBox =)",
    "insertText": "MoveTemp(Other.LocalBoundingBox)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (StructureData =)",
    "insertText": "MoveTemp(Other.StructureData)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Volume =)",
    "insertText": "MoveTemp(Other.Volume)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (CenterOfMass =)",
    "insertText": "MoveTemp(Other.CenterOfMass)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (UnitMassInertiaTensor =)",
    "insertText": "MoveTemp(Other.UnitMassInertiaTensor)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (RotationOfMass =)",
    "insertText": "MoveTemp(Other.RotationOfMass)"
  },
  {
    "label": "CopyGeometryWithScale()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "CopyGeometryWithScale(const FVec3& Scale)"
  },
  {
    "label": "DeepCopyGeometry()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "DeepCopyGeometry()"
  },
  {
    "label": "DeepCopyGeometryWithScale()",
    "kind": "Method",
    "detail": "Function (Chaos::FImplicitObjectPtr)",
    "insertText": "DeepCopyGeometryWithScale(const FVec3& Scale)"
  },
  {
    "label": "MovePlanesAndRebuild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MovePlanesAndRebuild(FRealType InDelta)"
  },
  {
    "label": "CreateStructureData()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "CreateStructureData(TArray<TArray<int32>>&& FaceIndices, const bool bRegularDatas = false)"
  },
  {
    "label": "StaticType()",
    "kind": "Method",
    "detail": "Function (public : EImplicitObjectType)",
    "insertText": "StaticType()"
  },
  {
    "label": "GetLocalBoundingBox()",
    "kind": "Method",
    "detail": "Function (} FConvex::FAABB3Type)",
    "insertText": "GetLocalBoundingBox()"
  },
  {
    "label": "PhiWithNormalScaled()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "PhiWithNormalScaled(const FVec3& X, const FVec3& Scale, FVec3& Normal)"
  },
  {
    "label": "PhiWithNormalInternal()",
    "kind": "Method",
    "detail": "Function (} private : FReal)",
    "insertText": "PhiWithNormalInternal(const FVec3& X, FVec3& Normal)"
  },
  {
    "label": "Lowest()",
    "kind": "Method",
    "detail": "Function (FReal MaxPhi = TNumericLimits<FReal)",
    "insertText": "Lowest()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 MaxPlane = 0 ;)",
    "insertText": "for(int32 Idx = 0; Idx < NumPlanes; ++Idx)"
  },
  {
    "label": "SignedDistance()",
    "kind": "Method",
    "detail": "Function (const FReal Phi = Planes [ Idx ] .)",
    "insertText": "SignedDistance(X)"
  },
  {
    "label": "PhiWithNormal()",
    "kind": "Method",
    "detail": "Function (MaxPhi = Phi ; MaxPlane = Idx ; } } FReal Phi = Planes [ MaxPlane ] .)",
    "insertText": "PhiWithNormal(X, Normal)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const FVec3 XOnPlane = X - Phi* Normal ; FReal ClosestDistance = TNumericLimits<FReal)",
    "insertText": "Max()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FVec3 ClosestPoint ;)",
    "insertText": "for(int32 Index = 0; Index < PlaneVerticesNum - 2; Index++)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "A(GetVertex(GetPlaneVertex(MaxPlane, 0)))"
  },
  {
    "label": "B()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "B(GetVertex(GetPlaneVertex(MaxPlane, Index + 1)))"
  },
  {
    "label": "C()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "C(GetVertex(GetPlaneVertex(MaxPlane, Index + 2)))"
  },
  {
    "label": "FindClosestPointOnTriangle()",
    "kind": "Method",
    "detail": "Function (const FVec3 Point =)",
    "insertText": "FindClosestPointOnTriangle(XOnPlane, A, B, C, X)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (ClosestDistance = Distance ; ClosestPoint = Point ; } } const TVector<FReal,3> Difference = X - ClosestPoint ; Phi = Difference .)",
    "insertText": "Size()"
  },
  {
    "label": "Normal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Normal(Difference)"
  },
  {
    "label": "PhiWithNormalScaledInternal()",
    "kind": "Method",
    "detail": "Function (} return Phi ; } FReal)",
    "insertText": "PhiWithNormalScaledInternal(const FVec3& X, const FVec3& Scale, FVec3& Normal)"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (FVec3 MaxNormal =)",
    "insertText": "FVec3(0,0,1)"
  },
  {
    "label": "PlaneNormal()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "PlaneNormal(Planes[Idx].Normal() / Scale).GetUnsafeNormal()"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (FVec3 PlanePos = Planes [ Idx ] .)",
    "insertText": "X()"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (FReal PlaneDistance =)",
    "insertText": "DotProduct(X - PlanePos, PlaneNormal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MaxPhi = PlaneDistance ; MaxNormal = PlaneNormal ; MaxPlane = Idx ; } } Normal = MaxNormal ;)",
    "insertText": "if(MaxPhi < 0)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "A(Scale * GetVertex(GetPlaneVertex(MaxPlane, 0)))"
  },
  {
    "label": "B()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "B(Scale * GetVertex(GetPlaneVertex(MaxPlane, Index + 1)))"
  },
  {
    "label": "C()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "C(Scale * GetVertex(GetPlaneVertex(MaxPlane, Index + 2)))"
  },
  {
    "label": "Raycast()",
    "kind": "Method",
    "detail": "Function (Normal = Difference / DifferenceLen ; MaxPhi = DifferenceLen ; } return MaxPhi ; } public : bool)",
    "insertText": "Raycast(const FVec3& StartPoint, const FVec3& Dir, const FReal Length, const FReal Thickness, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex)"
  },
  {
    "label": "RaycastFast()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RaycastFast(const FVec3& StartPoint, const FVec3& Dir, const FReal Length, const FReal Thickness, FReal& OutTime, FVec3& OutPosition, FVec3& OutNormal, int32& OutFaceIndex)"
  },
  {
    "label": "FindClosestIntersectionImp()",
    "kind": "Method",
    "detail": "Function (Pair<FVec3,bool>)",
    "insertText": "FindClosestIntersectionImp(const FVec3& StartPoint, const FVec3& EndPoint, const FReal Thickness)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TArray<Pair<FReal,FVec3>> Intersections ; Intersections .)",
    "insertText": "Reserve(FMath::Min(static_cast<int32>(NumPlanes*.1), 16))"
  },
  {
    "label": "FindClosestIntersection()",
    "kind": "Method",
    "detail": "Function (auto PlaneIntersection = Planes [ Idx ] .)",
    "insertText": "FindClosestIntersection(StartPoint, EndPoint, Thickness)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Intersections .)",
    "insertText": "Add(MakePair((FReal)(PlaneIntersection.First - StartPoint).SizeSquared(), PlaneIntersection.First))"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (} } Intersections .)",
    "insertText": "Sort([](const Pair<FReal, FVec3>& Elem1, const Pair<FReal, FVec3>& Elem2) { return Elem1.First < Elem2.First; })"
  },
  {
    "label": "MakePair()",
    "kind": "Method",
    "detail": "Function (} } return)",
    "insertText": "MakePair(FVec3(0), false)"
  },
  {
    "label": "HasStructureData()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasStructureData()"
  },
  {
    "label": "GetStructureData()",
    "kind": "Method",
    "detail": "Function (} const FConvexStructureData&)",
    "insertText": "GetStructureData()"
  },
  {
    "label": "GetMostOpposingPlaneScaled()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetMostOpposingPlaneScaled(const FVec3& Normal, const FVec3& Scale)"
  },
  {
    "label": "GetClosestEdge()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "GetClosestEdge(int32 PlaneIndexHint, const FVec3& Position, FVec3& OutEdgePos0, FVec3& OutEdgePos1)"
  },
  {
    "label": "GetClosestEdgePosition()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "GetClosestEdgePosition(int32 PlaneIndex, const FVec3& Position)"
  },
  {
    "label": "GetClosestEdge()",
    "kind": "Method",
    "detail": "Function (FVec3 Unused0,Unused1 ; return)",
    "insertText": "GetClosestEdge(PlaneIndex, Position, Unused0, Unused1)"
  },
  {
    "label": "GetClosestEdgeVertices()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetClosestEdgeVertices(int32 PlaneIndex, const FVec3& Position, int32& OutVertexIndex0, int32& OutVertexIndex1)"
  },
  {
    "label": "FindVertexPlanes()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "FindVertexPlanes(int32 VertexIndex, int32* OutVertexPlanes, int32 MaxVertexPlanes)"
  },
  {
    "label": "GetVertexPlanes3()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetVertexPlanes3(int32 VertexIndex, int32& PlaneIndex0, int32& PlaneIndex1, int32& PlaneIndex2)"
  },
  {
    "label": "NumPlaneVertices()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "NumPlaneVertices(int32 PlaneIndex)"
  },
  {
    "label": "GetPlaneVertex()",
    "kind": "Method",
    "detail": "Function (} return 0 ; } int32)",
    "insertText": "GetPlaneVertex(int32 PlaneIndex, int32 PlaneVertexIndex)"
  },
  {
    "label": "GetEdgeVertex()",
    "kind": "Method",
    "detail": "Function (} return INDEX_NONE ; } int32)",
    "insertText": "GetEdgeVertex(int32 EdgeIndex, int32 EdgeVertexIndex)"
  },
  {
    "label": "GetEdgePlane()",
    "kind": "Method",
    "detail": "Function (} return INDEX_NONE ; } int32)",
    "insertText": "GetEdgePlane(int32 EdgeIndex, int32 EdgePlaneIndex)"
  },
  {
    "label": "NumPlanes()",
    "kind": "Method",
    "detail": "Function (} return INDEX_NONE ; } int32)",
    "insertText": "NumPlanes()"
  },
  {
    "label": "NumEdges()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "NumEdges()"
  },
  {
    "label": "NumVertices()",
    "kind": "Method",
    "detail": "Function (} return 0 ; } int32)",
    "insertText": "NumVertices()"
  },
  {
    "label": "GetPlane()",
    "kind": "Method",
    "detail": "Function (} const TPlaneConcrete<FReal,3>)",
    "insertText": "GetPlane(int32 FaceIndex)"
  },
  {
    "label": "GetPlaneNX()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetPlaneNX(const int32 FaceIndex, FVec3& OutN, FVec3& OutX)"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (OutN =)",
    "insertText": "FVec3(Planes[FaceIndex].Normal())"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (OutX =)",
    "insertText": "FVec3(Planes[FaceIndex].X())"
  },
  {
    "label": "GetPlaneRaw()",
    "kind": "Method",
    "detail": "Function (} const FPlaneType&)",
    "insertText": "GetPlaneRaw(int32 FaceIndex)"
  },
  {
    "label": "FindMostOpposingFaceScaled()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "FindMostOpposingFaceScaled(const FVec3& Position, const FVec3& UnitDir, int32 HintFaceIndex, FReal SearchDist, const FVec3& Scale)"
  },
  {
    "label": "FindGeometryOpposingNormal()",
    "kind": "Method",
    "detail": "Function (FVec3)",
    "insertText": "FindGeometryOpposingNormal(const FVec3& DenormDir, int32 FaceIndex, const FVec3& OriginalNormal)"
  },
  {
    "label": "GetFaces()",
    "kind": "Method",
    "detail": "Function (const FPlaneType& OpposingFace =)",
    "insertText": "GetFaces()"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "FVec3(0.f, 0.f, 1.f)"
  },
  {
    "label": "FindClosestFaceAndVertices()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "FindClosestFaceAndVertices(const FVec3& Position, TArray<FVec3>& FaceVertices, FReal SearchDist = 0.01f)"
  },
  {
    "label": "GetWindingOrder()",
    "kind": "Method",
    "detail": "Function (FReal)",
    "insertText": "GetWindingOrder()"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FRealType Dot =)",
    "insertText": "DotProduct(Vertices[Idx], Direction)"
  },
  {
    "label": "IntersectPlanes3()",
    "kind": "Method",
    "detail": "Function (MaxDot = Dot ; MaxVIdx = Idx ; } } return MaxVIdx ; } public : bool)",
    "insertText": "IntersectPlanes3(const FVec3& X1, const FVec3& N1, const FVec3& X2, const FVec3& N2, const FVec3& X3, const FVec3& N3, FVec3& OutX, const FReal EpsilonSq = FReal(1.e-6))"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const FVec3 N1CrossN2 =)",
    "insertText": "CrossProduct(N1, N2)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FReal Det =)",
    "insertText": "DotProduct(N1CrossN2, N3)"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (OutX =)",
    "insertText": "FVec3(0)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const FVec3 N3CrossN1 =)",
    "insertText": "CrossProduct(N3, N1)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FReal D1 =)",
    "insertText": "DotProduct(X1, N1)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FReal D2 =)",
    "insertText": "DotProduct(X2, N2)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FReal D3 =)",
    "insertText": "DotProduct(X3, N3)"
  },
  {
    "label": "OutX()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OutX(D1 * N2CrossN3 + D2 * N3CrossN1 + D3 * N1CrossN2)"
  },
  {
    "label": "GetMarginAdjustedVertex()",
    "kind": "Method",
    "detail": "Function (} return true ; } FVec3)",
    "insertText": "GetMarginAdjustedVertex(const int32 VertexIndex, const FReal InMargin, FReal* OutSupportDelta)"
  },
  {
    "label": "GetVertexPlanes3()",
    "kind": "Method",
    "detail": "Function (} int32 PlaneIndex0 = INDEX_NONE ; int32 PlaneIndex1 = INDEX_NONE ; int32 PlaneIndex2 = INDEX_NONE ; const int32 NumVertexPlanes =)",
    "insertText": "GetVertexPlanes3(VertexIndex, PlaneIndex0, PlaneIndex1, PlaneIndex2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FVec3 VertexPos = Vertices [ VertexIndex ] ;)",
    "insertText": "if(IntersectPlanes3( VertexPos - InMargin * Planes[PlaneIndex0].Normal(), Planes[PlaneIndex0].Normal(), VertexPos - InMargin * Planes[PlaneIndex1].Normal(), Planes[PlaneIndex1].Normal(), VertexPos - InMargin * Planes[PlaneIndex2].Normal(), Planes[PlaneIndex2].Normal(), VertexPos))"
  },
  {
    "label": "OutSupportDelta()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "OutSupportDelta(Vertices[VertexIndex] - VertexPos).Size()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} return VertexPos ; } })",
    "insertText": "if(NumVertexPlanes == 2)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (const FVec3 NewPlaneX =)",
    "insertText": "GetVertex(VertexIndex)"
  },
  {
    "label": "Normal()",
    "kind": "Method",
    "detail": "Function (const FVec3 NewPlaneN0 = Planes [ PlaneIndex0 ] .)",
    "insertText": "Normal()"
  },
  {
    "label": "NewPlaneN()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "NewPlaneN(NewPlaneN0 + NewPlaneN1).GetSafeNormal()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(NumVertexPlanes == 1)"
  },
  {
    "label": "GetMarginAdjustedVertexScaled()",
    "kind": "Method",
    "detail": "Function (} FVec3)",
    "insertText": "GetMarginAdjustedVertexScaled(int32 VertexIndex, FReal InMargin, const FVec3& Scale, FReal* OutSupportDelta)"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (const FVec3 InvScale =)",
    "insertText": "FVec3(FReal(1) / Scale.X, FReal(1) / Scale.Y, FReal(1) / Scale.Z)"
  },
  {
    "label": "NewPlaneN0()",
    "kind": "Method",
    "detail": "Function (const FVec3 VertexPos = Scale* Vertices [ VertexIndex ] ; const FVec3)",
    "insertText": "NewPlaneN0(Planes[PlaneIndex0].Normal() * InvScale).GetUnsafeNormal()"
  },
  {
    "label": "NewPlaneN1()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "NewPlaneN1(Planes[PlaneIndex1].Normal() * InvScale).GetUnsafeNormal()"
  },
  {
    "label": "NewPlaneN2()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "NewPlaneN2(Planes[PlaneIndex2].Normal() * InvScale).GetUnsafeNormal()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FVec3 AdjustedVertexPos = VertexPos ;)",
    "insertText": "if(IntersectPlanes3( VertexPos - InMargin * NewPlaneN0, NewPlaneN0, VertexPos - InMargin * NewPlaneN1, NewPlaneN1, VertexPos - InMargin * NewPlaneN2, NewPlaneN2, AdjustedVertexPos))"
  },
  {
    "label": "OutSupportDelta()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "OutSupportDelta(VertexPos - AdjustedVertexPos).Size()"
  },
  {
    "label": "NewPlaneN()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "NewPlaneN(Planes[PlaneIndex0].Normal() * InvScale).GetUnsafeNormal()"
  },
  {
    "label": "SupportCore()",
    "kind": "Method",
    "detail": "Function (} public : FVec3)",
    "insertText": "SupportCore(const FVec3& Direction, const FReal InMargin, FReal* OutSupportDelta, int32& VertexIndex)"
  },
  {
    "label": "GetSupportVertex()",
    "kind": "Method",
    "detail": "Function (const int32 SupportVertexIndex =)",
    "insertText": "GetSupportVertex(FVec3Type(Direction))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VertexIndex = SupportVertexIndex ;)",
    "insertText": "if(SupportVertexIndex != INDEX_NONE)"
  },
  {
    "label": "SupportCoreSimd()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "SupportCoreSimd(const VectorRegister4Float& Direction, const FReal InMargin)"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (FVec3 DirectionVec3 ;)",
    "insertText": "VectorStoreFloat3(Direction, &DirectionVec3)"
  },
  {
    "label": "GetSupportVertex()",
    "kind": "Method",
    "detail": "Function (const int32 SupportVertexIndex =)",
    "insertText": "GetSupportVertex(DirectionVec3)"
  },
  {
    "label": "GetMarginAdjustedVertex()",
    "kind": "Method",
    "detail": "Function (FVec3 SupportVert =)",
    "insertText": "GetMarginAdjustedVertex(SupportVertexIndex, InMargin, nullptr)"
  },
  {
    "label": "VectorZeroFloat()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "VectorZeroFloat()"
  },
  {
    "label": "SupportCoreScaled()",
    "kind": "Method",
    "detail": "Function (} FVec3)",
    "insertText": "SupportCoreScaled(const FVec3& Direction, FReal InMargin, const FVec3& Scale, FReal* OutSupportDelta, int32& VertexIndex)"
  },
  {
    "label": "FVec3Type()",
    "kind": "Method",
    "detail": "Function (const FVec3Type DirectionScaled =)",
    "insertText": "FVec3Type(Scale * Direction)"
  },
  {
    "label": "GetSupportVertex()",
    "kind": "Method",
    "detail": "Function (const int32 SupportVertexIndex =)",
    "insertText": "GetSupportVertex(DirectionScaled)"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "FVec3(GetMarginAdjustedVertexScaled(SupportVertexIndex, InMargin, Scale, OutSupportDelta))"
  },
  {
    "label": "Support()",
    "kind": "Method",
    "detail": "Function (} FVec3)",
    "insertText": "Support(const FVec3& Direction, const FReal Thickness, int32& VertexIndex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VertexIndex = MaxVIdx ;)",
    "insertText": "if(MaxVIdx != INDEX_NONE)"
  },
  {
    "label": "SupportScaled()",
    "kind": "Method",
    "detail": "Function (} FVec3)",
    "insertText": "SupportScaled(const FVec3& Direction, const FReal Thickness, const FVec3& Scale, int32& VertexIndex)"
  },
  {
    "label": "Support()",
    "kind": "Method",
    "detail": "Function (FVec3 SupportPoint =)",
    "insertText": "Support(Direction * Scale, 0.0f, VertexIndex)"
  },
  {
    "label": "GetSafeNormal()",
    "kind": "Method",
    "detail": "Function (SupportPoint + = Thickness* Direction .)",
    "insertText": "GetSafeNormal()"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} return SupportPoint ; } FString)",
    "insertText": "ToString()"
  },
  {
    "label": "ToStringSummary()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ToStringSummary()"
  },
  {
    "label": "ToStringFull()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ToStringFull()"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (S .)",
    "insertText": "Append(TEXT(\"\\n\"))"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (S .)",
    "insertText": "Append(FString::Printf(TEXT(\" Vertex %d: [%f, %f, %f]\\n\"), VertexIndex, Vert.X, Vert.Y, Vert.Z))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 PlaneIndex = 0; PlaneIndex < NumPlanes(); ++PlaneIndex)"
  },
  {
    "label": "GetPlane()",
    "kind": "Method",
    "detail": "Function (const TPlaneConcrete<FReal,3> Plane =)",
    "insertText": "GetPlane(PlaneIndex)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (S .)",
    "insertText": "Append(FString::Printf(TEXT(\" Plane %d: Normal: [%f, %f, %f], Distance: %f, Verts: [\"), PlaneIndex, Plane.Normal().X, Plane.Normal().Y, Plane.Normal().Z, FVec3::DotProduct(Plane.X(), Plane.Normal())))"
  },
  {
    "label": "NumPlaneVertices()",
    "kind": "Method",
    "detail": "Function (const int32 PlaneVertexCount =)",
    "insertText": "NumPlaneVertices(PlaneIndex)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (S .)",
    "insertText": "Append(FString::Printf(TEXT(\"%d\"), GetPlaneVertex(PlaneIndex, PlaneVertexIndex)))"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (S .)",
    "insertText": "Append(FString::Printf(TEXT(\", \")))"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (} } S .)",
    "insertText": "Append(FString::Printf(TEXT(\"]\\n\")))"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (} S .)",
    "insertText": "Append(FString::Printf(TEXT(\" Edges: \")))"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (S .)",
    "insertText": "Append(FString::Printf(TEXT(\"[%d, %d]\"), GetEdgeVertex(EdgeIndex, 0), GetEdgeVertex(EdgeIndex, 1)))"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (} } S .)",
    "insertText": "Append(FString::Printf(TEXT(\"\\n\")))"
  },
  {
    "label": "FMatrix33()",
    "kind": "Method",
    "detail": "Function (const FVec3 ScaledInertiaTensorDiagonal { UnitMassInertiaTensor* Mass } ; return)",
    "insertText": "FMatrix33(ScaledInertiaTensorDiagonal.X, ScaledInertiaTensorDiagonal.Y, ScaledInertiaTensorDiagonal.Z)"
  },
  {
    "label": "GetRotationOfMass()",
    "kind": "Method",
    "detail": "Function (} FRotation3)",
    "insertText": "GetRotationOfMass()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (uint32 Result = LocalBoundingBox .)",
    "insertText": "GetTypeHash()"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "HashCombine(Result, ::GetTypeHash(Vertex[0]))"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "HashCombine(Result, ::GetTypeHash(Vertex[1]))"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "HashCombine(Result, ::GetTypeHash(Vertex[2]))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(const FPlaneType& Plane : Planes)"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "HashCombine(Result, Plane.GetTypeHash())"
  },
  {
    "label": "SerializeImp()",
    "kind": "Method",
    "detail": "Function (} return Result ; } void)",
    "insertText": "SerializeImp(FArchive& Ar)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FExternalPhysicsCustomObjectVersion::GUID)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FUE5MainStreamObjectVersion::GUID)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FPhysicsObjectVersion::GUID)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FFortniteMainBranchObjectVersion::GUID)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FUE5ReleaseStreamObjectVersion::GUID)"
  },
  {
    "label": "SerializeImp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SerializeImp(Ar)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<TPlane<FRealType,3>> TmpPlanes ; Ar<<TmpPlanes ; Planes .)",
    "insertText": "SetNum(TmpPlanes.Num())"
  },
  {
    "label": "PlaneConcrete()",
    "kind": "Method",
    "detail": "Function (Planes [ Idx ] = TmpPlanes [ Idx ] .)",
    "insertText": "PlaneConcrete()"
  },
  {
    "label": "bConvexVerticesNewFormatUE4()",
    "kind": "Method",
    "detail": "Function (} } else { Ar<<Planes ; } bool)",
    "insertText": "bConvexVerticesNewFormatUE4(Ar.CustomVer(FPhysicsObjectVersion::GUID) >= FPhysicsObjectVersion::ConvexUsesVerticesArray)"
  },
  {
    "label": "bConvexVerticesNewFormatUE5()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bConvexVerticesNewFormatUE5(Ar.CustomVer(FUE5MainStreamObjectVersion::GUID) >= FUE5MainStreamObjectVersion::ConvexUsesVerticesArray)"
  },
  {
    "label": "bConvexVerticesNewFormatFN()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bConvexVerticesNewFormatFN(Ar.CustomVer(FFortniteMainBranchObjectVersion::GUID) >= FFortniteMainBranchObjectVersion::ChaosConvexVariableStructureDataAndVerticesArray)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bConvexVerticesNewFormat = bConvexVerticesNewFormatUE4 | | bConvexVerticesNewFormatUE5 | | bConvexVerticesNewFormatFN ;)",
    "insertText": "if(!bConvexVerticesNewFormat)"
  },
  {
    "label": "NumVertices()",
    "kind": "Method",
    "detail": "Function (TParticles<FRealType,3> TmpSurfaceParticles ; Ar<<TmpSurfaceParticles ; const int32)",
    "insertText": "NumVertices(int32)TmpSurfaceParticles.Size()"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Vertices .)",
    "insertText": "SetNum(NumVertices)"
  },
  {
    "label": "GetX()",
    "kind": "Method",
    "detail": "Function (Vertices [ VertexIndex ] = TmpSurfaceParticles .)",
    "insertText": "GetX(VertexIndex)"
  },
  {
    "label": "SerializeAsAABB()",
    "kind": "Method",
    "detail": "Function (} } else { Ar<<Vertices ; } TBox<FRealType,3)",
    "insertText": "SerializeAsAABB(Ar, LocalBoundingBox)"
  },
  {
    "label": "VolumeFloat()",
    "kind": "Method",
    "detail": "Function (FRealSingle)",
    "insertText": "VolumeFloat(FRealSingle)"
  },
  {
    "label": "Volume()",
    "kind": "Method",
    "detail": "Function (Ar<<VolumeFloat ;)",
    "insertText": "Volume(FRealType)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Volume = 0 ; } Ar<<CenterOfMass ; } else)",
    "insertText": "if(Ar.IsLoading())"
  },
  {
    "label": "Build()",
    "kind": "Method",
    "detail": "Function (TArray<TArray<int32>> FaceIndices ; TArray<FVec3Type> TempVertices ;)",
    "insertText": "Build(Vertices, Planes, FaceIndices, TempVertices, LocalBoundingBox)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (} Ar .)",
    "insertText": "UsingCustomVersion(FReleaseObjectVersion::GUID)"
  },
  {
    "label": "MarginFloat()",
    "kind": "Method",
    "detail": "Function (FRealSingle)",
    "insertText": "MarginFloat(FRealSingle)"
  },
  {
    "label": "Margin()",
    "kind": "Method",
    "detail": "Function (Ar<<MarginFloat ;)",
    "insertText": "Margin(FReal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Ar.CustomVer(FReleaseObjectVersion::GUID) >= FReleaseObjectVersion::StructureDataAddedToConvex)"
  },
  {
    "label": "BuildPlaneVertexIndices()",
    "kind": "Method",
    "detail": "Function (TArray<TArray<int32>> FaceIndices ;)",
    "insertText": "BuildPlaneVertexIndices(Planes, Vertices, FaceIndices)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Ar.CustomVer(FUE5ReleaseStreamObjectVersion::GUID) >= FUE5ReleaseStreamObjectVersion::AddedInertiaTensorAndRotationOfMassAddedToConvex)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Serialize(FChaosArchive& Ar)"
  },
  {
    "label": "ScopedMemory()",
    "kind": "Method",
    "detail": "Function (FChaosArchiveScopedMemory)",
    "insertText": "ScopedMemory(Ar, GetTypeName())"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "IsValidGeometry()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValidGeometry()"
  },
  {
    "label": "IsPerformanceWarning()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsPerformanceWarning()"
  },
  {
    "label": "PerformanceWarningAndSimplifaction()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "PerformanceWarningAndSimplifaction()"
  },
  {
    "label": "PerformanceWarningString()",
    "kind": "Method",
    "detail": "Function (FString PerformanceWarningString =)",
    "insertText": "PerformanceWarningString(Planes.Num(), Vertices.Num())"
  },
  {
    "label": "SimplifyGeometry()",
    "kind": "Method",
    "detail": "Function (PerformanceWarningString + = \",[ Simplifying ] \" ;)",
    "insertText": "SimplifyGeometry()"
  },
  {
    "label": "Simplify()",
    "kind": "Method",
    "detail": "Function (TArray<TArray<int32>> FaceIndices ;)",
    "insertText": "Simplify(Planes, FaceIndices, Vertices, LocalBoundingBox)"
  },
  {
    "label": "GetCenter()",
    "kind": "Method",
    "detail": "Function (} FVec3)",
    "insertText": "GetCenter()"
  },
  {
    "label": "OffsetOfPlanes()",
    "kind": "Method",
    "detail": "Function (} # if INTEL_ISPC struct FISPCDataVerifier { int32)",
    "insertText": "OffsetOfPlanes()"
  },
  {
    "label": "SizeOfPlanes()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "SizeOfPlanes()"
  },
  {
    "label": "OffsetOfVertices()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "OffsetOfVertices()"
  },
  {
    "label": "SizeOfVertices()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "SizeOfVertices()"
  },
  {
    "label": "OffsetOfStructureData()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "OffsetOfStructureData()"
  },
  {
    "label": "SizeOfStructureData()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "SizeOfStructureData()"
  },
  {
    "label": "ComputeUnitMassInertiaTensorAndRotationOfMass()",
    "kind": "Method",
    "detail": "Function (} } ; FISPCDataVerifier ; # endif private : void)",
    "insertText": "ComputeUnitMassInertiaTensorAndRotationOfMass(const FReal InVolume)"
  },
  {
    "label": "FConvex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FConvex(const FConvex& Other) : FImplicitObject(EImplicitObject::IsConvex | EImplicitObject::HasBoundingBox, ImplicitObjectType::Convex) , Planes(Other.Planes) , Vertices(Other.Vertices) , LocalBoundingBox(Other.LocalBoundingBox) , Volume(Other.Volume) , CenterOfMass(Other.CenterOfMass) , UnitMassInertiaTensor(Other.UnitMassInertiaTensor) , RotationOfMass(Other.RotationOfMass)"
  },
  {
    "label": "CopyFrom()",
    "kind": "Method",
    "detail": "Function (StructureData .)",
    "insertText": "CopyFrom(Other.StructureData)"
  },
  {
    "label": "SetMargin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMargin(Other.Margin)"
  }
]