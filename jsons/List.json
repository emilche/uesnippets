[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "ST_DLL_LINK",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ST_DLL_LINK"
  },
  {
    "label": "CNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CNode"
  },
  {
    "label": "iterator_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "iterator_base"
  },
  {
    "label": "CList",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CList"
  },
  {
    "label": "iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "iterator"
  },
  {
    "label": "const_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "const_iterator"
  },
  {
    "label": "CList()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Core / ExportBegin . h \" # include \" Array . h \" # include<cassert> # ifndef SPEEDTREE_NO_ALLOCATORS # include \" Core / Memory . h \" # endif namespace SpeedTree { template<class T,bool bUseCustomAllocator = true> class ST_DLL_LINK CList { protected : class CNode ; public :)",
    "insertText": "CList(void)"
  },
  {
    "label": "CList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CList(const CList& cRight)"
  },
  {
    "label": "CList()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CList()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear(void)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "empty(void)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "size(void)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "push_back(const T& tData)"
  },
  {
    "label": "push_front()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "push_front(const T& tData)"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pop_back(void)"
  },
  {
    "label": "pop_front()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pop_front(void)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "front(void)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "back(void)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CList&)",
    "insertText": "operator(const CList& cRight)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort(void)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (class iterator_base { class CList ; public : bool)",
    "insertText": "operator(const iterator_base& cRight)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (iterator_base&)",
    "insertText": "operator(void)"
  },
  {
    "label": "iterator_base()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "iterator_base(CNode* pNode = NULL)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (CNode* m_pNode ; } ; class iterator : public iterator_base { public :)",
    "insertText": "iterator(CNode* pNode = NULL) : iterator_base(pNode)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "T(void)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (} ; class const_iterator : public iterator_base { public :)",
    "insertText": "const_iterator(CNode* pNode = NULL) : iterator_base(pNode)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "const_iterator(const iterator& cRight) : iterator_base(cRight.m_pNode)"
  },
  {
    "label": "const()",
    "kind": "Method",
    "detail": "Function (} operator T)",
    "insertText": "const(void)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} ; iterator)",
    "insertText": "begin(void)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "end(void)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "erase(iterator iterWhere)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "insert(iterator iterWhere, const T& tData)"
  },
  {
    "label": "insert_sorted()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "insert_sorted(const T& tData)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (protected : CNode*)",
    "insertText": "Allocate(const T& tData, CNode* pNext, CNode* pPrevious)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deallocate(CNode* pData)"
  },
  {
    "label": "CNode()",
    "kind": "Method",
    "detail": "Function (class CNode { public :)",
    "insertText": "CNode(const T& tData, CNode* pNext, CNode* pPrevious)"
  }
]