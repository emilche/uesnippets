[
  {
    "label": "FMarkerPair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMarkerPair"
  },
  {
    "label": "FMarkerSyncAnimPosition",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMarkerSyncAnimPosition"
  },
  {
    "label": "FPassedMarker",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPassedMarker"
  },
  {
    "label": "FMemoryReader",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMemoryReader"
  },
  {
    "label": "FMemoryWriter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMemoryWriter"
  },
  {
    "label": "UMirrorDataTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UMirrorDataTable"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "EBoneAxis",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EBoneAxis"
  },
  {
    "label": "EBoneControlSpace",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EBoneControlSpace"
  },
  {
    "label": "EBoneRotationSource",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EBoneRotationSource"
  },
  {
    "label": "FPerBoneBlendWeight",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPerBoneBlendWeight"
  },
  {
    "label": "FPerBoneBlendWeights",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPerBoneBlendWeights"
  },
  {
    "label": "FGraphTraversalCounter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGraphTraversalCounter"
  },
  {
    "label": "FAnimNotifyEvent",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimNotifyEvent"
  },
  {
    "label": "UAnimNotify",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimNotify"
  },
  {
    "label": "UAnimNotifyState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimNotifyState"
  },
  {
    "label": "TStructOpsTypeTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TStructOpsTypeTraits"
  },
  {
    "label": "FAnimSyncMarker",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimSyncMarker"
  },
  {
    "label": "FAnimNotifyTrack",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimNotifyTrack"
  },
  {
    "label": "EAdditiveAnimationType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EAdditiveAnimationType"
  },
  {
    "label": "FSlotNodeWeightInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSlotNodeWeightInfo"
  },
  {
    "label": "FMarkerSyncData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMarkerSyncData"
  },
  {
    "label": "FAnimWeight",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimWeight"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FAnimKeyHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimKeyHelper"
  },
  {
    "label": "FAxisOption",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAxisOption"
  },
  {
    "label": "FTrackToSkeletonMap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTrackToSkeletonMap"
  },
  {
    "label": "FRawAnimSequenceTrack",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRawAnimSequenceTrack"
  },
  {
    "label": "URawAnimSequenceTrackExtensions",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "URawAnimSequenceTrackExtensions"
  },
  {
    "label": "FBoneData",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBoneData"
  },
  {
    "label": "ENABLE_ANIM_DEBUG()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / ObjectMacros . h \" # include \" Misc / MemStack . h \" # include \" Algo / Transform . h \" # include \" Animation / AnimLinkableElement . h \" # include \" Animation / AnimEnums . h \" # include \" Misc / SecureHash . h \" # include \" Kismet / BlueprintFunctionLibrary . h \" # include \" UObject / UE5ReleaseStreamObjectVersion . h \" # include \" AnimTypes . generated . h \" struct FMarkerPair ; struct FMarkerSyncAnimPosition ; struct FPassedMarker ; class FMemoryReader ; class FMemoryWriter ; class UMirrorDataTable ; # define)",
    "insertText": "ENABLE_ANIM_DEBUG(1 && !(UE_BUILD_SHIPPING || UE_BUILD_TEST)) #define DEFAULT_SAMPLERATE 30.f #define MINIMUM_ANIMATION_LENGTH (1/DEFAULT_SAMPLERATE)"
  },
  {
    "label": "GetTriggerTimeOffsetForType()",
    "kind": "Method",
    "detail": "Function (enum Type { OffsetBefore,OffsetAfter,NoOffset } ; } float)",
    "insertText": "GetTriggerTimeOffsetForType(EAnimEventTriggerOffsets::Type OffsetType)"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UENUM()"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (BA_X)",
    "insertText": "UMETA(DisplayName = \"X Axis\"), BA_Y UMETA(DisplayName = \"Y Axis\"), BA_Z UMETA(DisplayName = \"Z Axis\")"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UENUM(BlueprintType)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (BCS_WorldSpace)",
    "insertText": "UMETA(DisplayName = \"World Space\"), BCS_ComponentSpace UMETA(DisplayName = \"Component Space\"), BCS_ParentBoneSpace UMETA(DisplayName = \"Parent Bone Space\"), BCS_BoneSpace UMETA(DisplayName = \"Bone Space\")"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (BRS_KeepComponentSpaceRotation)",
    "insertText": "UMETA(DisplayName = \"No Change (Preserve Existing Component Space Rotation)\"), BRS_KeepLocalSpaceRotation UMETA(DisplayName = \"Maintain Local Rotation Relative to Parent\"), BRS_CopyFromTarget UMETA(DisplayName = \"Copy Target Rotation\")"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (enum Type : int { NoFiltering,LOD,} ; })",
    "insertText": "USTRUCT(BlueprintType)"
  },
  {
    "label": "GENERATED_USTRUCT_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_USTRUCT_BODY() UPROPERTY()"
  },
  {
    "label": "FPerBoneBlendWeight()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPerBoneBlendWeight() : SourceIndex(0) , BlendWeight(0.0f)"
  },
  {
    "label": "FPerBoneBlendWeights()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPerBoneBlendWeights()"
  },
  {
    "label": "FGraphTraversalCounter()",
    "kind": "Method",
    "detail": "Function (} } ; struct FGraphTraversalCounter { private : uint64 LastSyncronizedFrame ; int16 Counter ; int16 SkipFrames ; public :)",
    "insertText": "FGraphTraversalCounter() : LastSyncronizedFrame(INDEX_NONE) , Counter(INDEX_NONE) , SkipFrames(0)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} int16)",
    "insertText": "Get()"
  },
  {
    "label": "Increment()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Increment()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Counter + + ; LastSyncronizedFrame = GFrameCounter ;)",
    "insertText": "if(Counter == INDEX_NONE)"
  },
  {
    "label": "SetMaxSkippedFrames()",
    "kind": "Method",
    "detail": "Function (Counter + + ; } } void)",
    "insertText": "SetMaxSkippedFrames(int16 InMaxSkippedFrames)"
  },
  {
    "label": "GetMaxSkippedFrames()",
    "kind": "Method",
    "detail": "Function (SkipFrames = InMaxSkippedFrames ; } int16)",
    "insertText": "GetMaxSkippedFrames()"
  },
  {
    "label": "SynchronizeWith()",
    "kind": "Method",
    "detail": "Function (Counter = INDEX_NONE ; LastSyncronizedFrame = INDEX_NONE ; SkipFrames = 0 ; } void)",
    "insertText": "SynchronizeWith(const FGraphTraversalCounter& InMasterCounter)"
  },
  {
    "label": "IsSynchronized_Counter()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSynchronized_Counter(const FGraphTraversalCounter& InOtherCounter)"
  },
  {
    "label": "IsSynchronized_Frame()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSynchronized_Frame(const FGraphTraversalCounter& InOtherCounter)"
  },
  {
    "label": "IsSynchronized_All()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSynchronized_All(const FGraphTraversalCounter& InOtherCounter)"
  },
  {
    "label": "WasSynchronizedCounter()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "WasSynchronizedCounter(const FGraphTraversalCounter& InOtherCounter)"
  },
  {
    "label": "WasSynchronizedLastFrame()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "WasSynchronizedLastFrame(const FGraphTraversalCounter& InOtherCounter)"
  },
  {
    "label": "GENERATED_USTRUCT_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_USTRUCT_BODY() #if WITH_EDITORONLY_DATA UPROPERTY()"
  },
  {
    "label": "FAnimNotifyEvent()",
    "kind": "Method",
    "detail": "Function (private : FName CachedNotifyEventName ; FName CachedNotifyEventBaseName ; public :)",
    "insertText": "FAnimNotifyEvent() : FAnimLinkableElement() #if WITH_EDITORONLY_DATA , DisplayTime_DEPRECATED(0) #endif , TriggerTimeOffset(0) , EndTriggerTimeOffset(0) , TriggerWeightThreshold(ZERO_ANIMWEIGHT_THRESH) , Notify(nullptr) , NotifyStateClass(nullptr) , Duration(0) , bConvertedFromBranchingPoint(false) , MontageTickType(EMontageNotifyTickType::Queued) , NotifyTriggerChance(1.f) , NotifyFilterType(ENotifyFilterType::NoFiltering) , NotifyFilterLOD(0) , bCanBeFilteredViaRequest(true) , bTriggerOnDedicatedServer(true) , bTriggerOnFollower(false) #if WITH_EDITORONLY_DATA , NotifyColor(FColor::Black) #endif , TrackIndex(0) , CachedNotifyEventName(NAME_None) , CachedNotifyEventBaseName(NAME_None)"
  },
  {
    "label": "FAnimNotifyEvent()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FAnimNotifyEvent()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} # if WITH_EDITORONLY_DATA bool)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "PostSerialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PostSerialize(const FArchive& Ar)"
  },
  {
    "label": "RefreshTriggerOffset()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "RefreshTriggerOffset(EAnimEventTriggerOffsets::Type PredictedOffsetType)"
  },
  {
    "label": "RefreshEndTriggerOffset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefreshEndTriggerOffset(EAnimEventTriggerOffsets::Type PredictedOffsetType)"
  },
  {
    "label": "GetTriggerTime()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetTriggerTime()"
  },
  {
    "label": "GetEndTriggerTime()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetEndTriggerTime()"
  },
  {
    "label": "GetDuration()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetDuration()"
  },
  {
    "label": "SetDuration()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDuration(float NewDuration)"
  },
  {
    "label": "IsBranchingPoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsBranchingPoint()"
  },
  {
    "label": "IsBlueprintNotify()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsBlueprintNotify()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const FAnimNotifyEvent& Other)"
  },
  {
    "label": "SetTime()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTime(float NewTime, EAnimLinkMethod::Type ReferenceFrame = EAnimLinkMethod::Absolute)"
  },
  {
    "label": "GetNotifyEventName()",
    "kind": "Method",
    "detail": "Function (FName)",
    "insertText": "GetNotifyEventName()"
  },
  {
    "label": "GetNotifyEventName()",
    "kind": "Method",
    "detail": "Function (FName)",
    "insertText": "GetNotifyEventName(const UMirrorDataTable* MirrorDataTable)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() FAnimSyncMarker() : MarkerName(NAME_None) , Time(0.0f) #if WITH_EDITORONLY_DATA , TrackIndex(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif bool)",
    "insertText": "operator(const FAnimSyncMarker& Other)"
  },
  {
    "label": "FAnimNotifyTrack()",
    "kind": "Method",
    "detail": "Function (TArray<FAnimNotifyEvent*> Notifies ; TArray<FAnimSyncMarker*> SyncMarkers ;)",
    "insertText": "FAnimNotifyTrack() : TrackName(TEXT(\"\")) , TrackColor(FLinearColor::White)"
  },
  {
    "label": "FAnimNotifyTrack()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAnimNotifyTrack(FName InTrackName, FLinearColor InTrackColor) : TrackName(InTrackName) , TrackColor(InTrackColor)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (AAT_None)",
    "insertText": "UMETA(DisplayName=\"No additive\"), AAT_LocalSpaceBase UMETA(DisplayName=\"Local Space\"), AAT_RotationOffsetMeshSpace UMETA(DisplayName=\"Mesh Space\")"
  },
  {
    "label": "FSlotNodeWeightInfo()",
    "kind": "Method",
    "detail": "Function (enum Type : int { Override,DoNotOverride,NormalizeByWeight,BlendByWeight,UseBasePose,UseMaxValue,UseMinValue,} ; } struct FSlotNodeWeightInfo { float SourceWeight ; float SlotNodeWeight ; float TotalNodeWeight ;)",
    "insertText": "FSlotNodeWeightInfo() : SourceWeight(0.f) , SlotNodeWeight(0.f) , TotalNodeWeight(0.f)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (SourceWeight = 0 . f ; SlotNodeWeight = 0 . f ; TotalNodeWeight = 0 . f ; } } ;)",
    "insertText": "USTRUCT()"
  },
  {
    "label": "GetMarkerIndicesForTime()",
    "kind": "Method",
    "detail": "Function (TArray<FName> UniqueMarkerNames ; void)",
    "insertText": "GetMarkerIndicesForTime(float CurrentTime, bool bLooping, const TArray<FName>& ValidMarkerNames, FMarkerPair& OutPrevMarker, FMarkerPair& OutNextMarker, float SequenceLength)"
  },
  {
    "label": "GetMarkerSyncPositionFromMarkerIndicies()",
    "kind": "Method",
    "detail": "Function (FMarkerSyncAnimPosition)",
    "insertText": "GetMarkerSyncPositionFromMarkerIndicies(int32 PrevMarker, int32 NextMarker, float CurrentTime, float SequenceLength, const UMirrorDataTable* MirrorTable = nullptr)"
  },
  {
    "label": "CollectUniqueNames()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CollectUniqueNames()"
  },
  {
    "label": "CollectMarkersInRange()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CollectMarkersInRange(float PrevPosition, float NewPosition, TArray<FPassedMarker>& OutMarkersPassedThisTick, float TotalDeltaMove)"
  },
  {
    "label": "IsRelevant()",
    "kind": "Method",
    "detail": "Function (} ; typedef TMemStackAllocator<> FAnimStackAllocator ; struct FAnimWeight { bool)",
    "insertText": "IsRelevant(float InWeight)"
  },
  {
    "label": "IsFullWeight()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsFullWeight(float InWeight)"
  },
  {
    "label": "GetSmallestRelevantWeight()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetSmallestRelevantWeight()"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Linear)",
    "insertText": "UMETA(DisplayName=\"Linear\"), Step UMETA(DisplayName=\"Step\")"
  },
  {
    "label": "FAnimKeyHelper()",
    "kind": "Method",
    "detail": "Function (namespace SmartName { typedef uint16 UID_Type ; UID_Type MaxUID = MAX_uint16 ; } struct FAnimKeyHelper {)",
    "insertText": "FAnimKeyHelper(float InLength, int32 InNumKeys) : Length(InLength) , NumKeys(InNumKeys)"
  },
  {
    "label": "TimePerKey()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "TimePerKey()"
  },
  {
    "label": "KeysPerSecond()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "KeysPerSecond()"
  },
  {
    "label": "LastKey()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "LastKey()"
  },
  {
    "label": "GetLength()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetLength()"
  },
  {
    "label": "GetAxisVector()",
    "kind": "Method",
    "detail": "Function (enum Type : int { X,Y,Z,X_Neg,Y_Neg,Z_Neg,Custom } ; } struct FAxisOption { FVector)",
    "insertText": "GetAxisVector(const TEnumAsByte<EAxisOption::Type> InAxis, const FVector& CustomAxis)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (enum Type : int { None = 0,TranslationX,TranslationY,TranslationZ,RotationX,RotationY,RotationZ,Scale)",
    "insertText": "UMETA(DisplayName = \"Scale (largest component)\")"
  },
  {
    "label": "FTrackToSkeletonMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FTrackToSkeletonMap() : BoneTreeIndex(0)"
  },
  {
    "label": "FTrackToSkeletonMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FTrackToSkeletonMap(int32 InBoneTreeIndex) : BoneTreeIndex(InBoneTreeIndex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FArchive&)",
    "insertText": "operator(FArchive& Ar, FTrackToSkeletonMap &Item)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FArchive&)",
    "insertText": "operator(FArchive& Ar, FRawAnimSequenceTrack& T)"
  },
  {
    "label": "BulkSerialize()",
    "kind": "Method",
    "detail": "Function (T . PosKeys .)",
    "insertText": "BulkSerialize(Ar)"
  },
  {
    "label": "ContainsNaN()",
    "kind": "Method",
    "detail": "Function (} return Ar ; } bool)",
    "insertText": "ContainsNaN()"
  },
  {
    "label": "bContainsNaN()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bContainsNaN(const auto& Keys)"
  },
  {
    "label": "CheckForNan()",
    "kind": "Method",
    "detail": "Function (} return false ; } return true ; } ; bContainsNaN =)",
    "insertText": "CheckForNan(PosKeys)"
  },
  {
    "label": "CheckForNan()",
    "kind": "Method",
    "detail": "Function (bContainsNaN =)",
    "insertText": "CheckForNan(RotKeys)"
  },
  {
    "label": "CheckForNan()",
    "kind": "Method",
    "detail": "Function (bContainsNaN =)",
    "insertText": "CheckForNan(ScaleKeys)"
  },
  {
    "label": "UsingCustomVersion()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "UsingCustomVersion(FUE5ReleaseStreamObjectVersion::GUID)"
  },
  {
    "label": "UCLASS()",
    "kind": "Method",
    "detail": "Function (} ; template<> struct TStructOpsTypeTraits<FRawAnimSequenceTrack> : public TStructOpsTypeTraitsBase2<FRawAnimSequenceTrack> { enum { WithSerializer = true } ; EPropertyObjectReferenceType WithSerializerObjectReferences = EPropertyObjectReferenceType::None ; } ;)",
    "insertText": "UCLASS(MinimalAPI)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() public: UFUNCTION(BlueprintPure, Category = Animation, meta=(ScriptMethod)) static TArray<FVector> GetPositionalKeys(UPARAM(ref)const FRawAnimSequenceTrack& Track)"
  },
  {
    "label": "Transform()",
    "kind": "Method",
    "detail": "Function (TArray<FVector> Keys ;)",
    "insertText": "Transform(Track.PosKeys, Keys, [](FVector3f FloatKey) { return FVector(FloatKey); })"
  },
  {
    "label": "Transform()",
    "kind": "Method",
    "detail": "Function (TArray<FQuat> Keys ;)",
    "insertText": "Transform(Track.RotKeys, Keys, [](FQuat4f FloatKey) { return FQuat(FloatKey); })"
  },
  {
    "label": "Transform()",
    "kind": "Method",
    "detail": "Function (TArray<FVector> Keys ;)",
    "insertText": "Transform(Track.ScaleKeys, Keys, [](FVector3f FloatKey) { return FVector(FloatKey); })"
  },
  {
    "label": "GetDepth()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetDepth()"
  },
  {
    "label": "IsEndEffector()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEndEffector()"
  },
  {
    "label": "GetArrayGuid()",
    "kind": "Method",
    "detail": "Function (} } ; # if 0 template<ArrayType> FGuid)",
    "insertText": "GetArrayGuid(const TArray<ArrayType>& Array)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (FSHA1 Sha ; Sha .)",
    "insertText": "Update((uint8*)Array.GetData(), Array.Num() * Array.GetTypeSize())"
  },
  {
    "label": "Final()",
    "kind": "Method",
    "detail": "Function (Sha .)",
    "insertText": "Final()"
  },
  {
    "label": "GetHash()",
    "kind": "Method",
    "detail": "Function (uint32 Hash [ 5 ] ; Sha .)",
    "insertText": "GetHash((uint8*)Hash)"
  },
  {
    "label": "Guid()",
    "kind": "Method",
    "detail": "Function (FGuid)",
    "insertText": "Guid(Hash[0] ^ Hash[4], Hash[1], Hash[2], Hash[3])"
  },
  {
    "label": "LowLevelOutputDebugStringf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LowLevelOutputDebugStringf(TEXT(\"Array: %i %s\\n\"), Array.Num(), *GetArrayGuid(Array).ToString())"
  },
  {
    "label": "LowLevelOutputDebugStringf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LowLevelOutputDebugStringf(TEXT(\"\\t%i %s\\n\"), i, *Array[i].ToString())"
  },
  {
    "label": "DebugLogArray()",
    "kind": "Method",
    "detail": "Function (} } template<> void)",
    "insertText": "DebugLogArray(const TArray<FRawAnimSequenceTrack>& RawData)"
  }
]