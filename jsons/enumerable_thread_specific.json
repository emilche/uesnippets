[
  {
    "label": "ets_key_usage_type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ets_key_usage_type"
  },
  {
    "label": "enumerable_thread_specific",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "enumerable_thread_specific"
  },
  {
    "label": "ets_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ets_base"
  },
  {
    "label": "slot",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "slot"
  },
  {
    "label": "array",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "array"
  },
  {
    "label": "enumerable_thread_specific_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "enumerable_thread_specific_iterator"
  },
  {
    "label": "segmented_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "segmented_iterator"
  },
  {
    "label": "construct_by_default",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "construct_by_default"
  },
  {
    "label": "construct_by_exemplar",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "construct_by_exemplar"
  },
  {
    "label": "construct_by_finit",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "construct_by_finit"
  },
  {
    "label": "construct_by_args",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "construct_by_args"
  },
  {
    "label": "callback_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "callback_base"
  },
  {
    "label": "callback_leaf",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "callback_leaf"
  },
  {
    "label": "ets_element",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ets_element"
  },
  {
    "label": "is_compatible_ets",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_compatible_ets"
  },
  {
    "label": "is_callable_no_args",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "is_callable_no_args"
  },
  {
    "label": "generic_range_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "generic_range_type"
  },
  {
    "label": "flattened2d",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "flattened2d"
  },
  {
    "label": "__TBB_ETS_USE_CPP11()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_enumerable_thread_specific_H # define __TBB_enumerable_thread_specific_H # include \" atomic . h \" # include \" concurrent_vector . h \" # include \" tbb_thread . h \" # include \" tbb_allocator . h \" # include \" cache_aligned_allocator . h \" # include \" aligned_space . h \" # include \" internal / _template_helpers . h \" # include \" internal / _tbb_hash_compare_impl . h \" # include \" tbb_profiling . h \" # include<string . h> # if _WIN32 | | _WIN64 # include \" machine / windows_api . h \" # else # include<pthread . h> # endif # define)",
    "insertText": "__TBB_ETS_USE_CPP11(__TBB_CPP11_RVALUE_REF_PRESENT && __TBB_CPP11_VARIADIC_TEMPLATES_PRESENT \\ && __TBB_CPP11_DECLTYPE_PRESENT && __TBB_CPP11_LAMBDAS_PRESENT)"
  },
  {
    "label": "at()",
    "kind": "Method",
    "detail": "Function (enum ets_key_usage_type { ets_key_per_instance,ets_no_key } ; namespace interface6 { template<T,Allocator,ets_key_usage_type ETS_key_type> class enumerable_thread_specific ; namespace internal { using namespace tbb::internal ; template<ets_key_usage_type ETS_key_type> class ets_base : tbb::internal::no_copy { protected : typedef tbb_thread::id key_type ; # if __TBB_PROTECTED_NESTED_CLASS_BROKEN public : # endif struct slot ; struct array { array* next ; size_t lg_size ; slot&)",
    "insertText": "at(size_t k)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "size()"
  },
  {
    "label": "mask()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "mask()"
  },
  {
    "label": "start()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "start(size_t h)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} } ; struct slot { key_type key ; void* ptr ; bool)",
    "insertText": "empty()"
  },
  {
    "label": "match()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "match(key_type k)"
  },
  {
    "label": "create_local()",
    "kind": "Method",
    "detail": "Function (} } ; # if __TBB_PROTECTED_NESTED_CLASS_BROKEN protected : # endif atomic<array*> my_root ; atomic<size_t> my_count ; void*)",
    "insertText": "create_local()"
  },
  {
    "label": "create_array()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "create_array(size_t _size)"
  },
  {
    "label": "free_array()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free_array(void* ptr, size_t _size)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (array*)",
    "insertText": "allocate(size_t lg_size)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t n =)",
    "insertText": "size_t(1)"
  },
  {
    "label": "array()",
    "kind": "Method",
    "detail": "Function (array* a = static_cast<)",
    "insertText": "array(create_array( sizeof(array)+n*sizeof(slot) ))"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (a -> lg_size = lg_size ;)",
    "insertText": "memset(a+1, 0, n*sizeof(slot))"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t n =)",
    "insertText": "size_t(1)<<(a->lg_size)"
  },
  {
    "label": "free_array()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free_array((void *)a, size_t(sizeof(array)+n*sizeof(slot)))"
  },
  {
    "label": "ets_base()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ets_base()"
  },
  {
    "label": "table_lookup()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "table_lookup(bool& exists)"
  },
  {
    "label": "table_clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "table_clear()"
  },
  {
    "label": "table_elementwise_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "table_elementwise_copy(const ets_base& other, void*(*add_element)(ets_base&, void*))"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!my_root,NULL)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!my_count,NULL)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (array* root = my_root =)",
    "insertText": "allocate(other.my_root->lg_size)"
  },
  {
    "label": "at()",
    "kind": "Method",
    "detail": "Function (slot& s1 = r ->)",
    "insertText": "at(i)"
  },
  {
    "label": "at()",
    "kind": "Method",
    "detail": "Function (slot& s2 = root ->)",
    "insertText": "at(j)"
  },
  {
    "label": "add_element()",
    "kind": "Method",
    "detail": "Function (s2 . ptr =)",
    "insertText": "add_element(*this, s1.ptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (s2 . key = s1 . key ; break ; } else)",
    "insertText": "if(s2.match(s1.key))"
  },
  {
    "label": "table_swap()",
    "kind": "Method",
    "detail": "Function (} } } } } void)",
    "insertText": "table_swap(ets_base& other)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(this!=&other, \"Don't swap an instance with itself\")"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (tbb::internal::swap<)",
    "insertText": "relaxed(my_root, other.my_root)"
  },
  {
    "label": "relaxed()",
    "kind": "Method",
    "detail": "Function (tbb::internal::swap<)",
    "insertText": "relaxed(my_count, other.my_count)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(!my_root, NULL)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (my_root = r -> next ;)",
    "insertText": "free(r)"
  },
  {
    "label": "get_id()",
    "kind": "Method",
    "detail": "Function (const key_type k = tbb::)",
    "insertText": "get_id()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(k != key_type(),NULL)"
  },
  {
    "label": "key_type()",
    "kind": "Method",
    "detail": "Function (void* found ; size_t h = tbb::tbb_hash<)",
    "insertText": "key_type()(k)"
  },
  {
    "label": "call_itt_notify()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_itt_notify(acquired,r)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (size_t s = r ? r -> lg_size : 2 ;)",
    "insertText": "while(c>size_t(1)<<(s-1))"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (array* a =)",
    "insertText": "allocate(s)"
  },
  {
    "label": "call_itt_notify()",
    "kind": "Method",
    "detail": "Function (a -> next = r ;)",
    "insertText": "call_itt_notify(releasing,a)"
  },
  {
    "label": "compare_and_swap()",
    "kind": "Method",
    "detail": "Function (array* new_r = my_root .)",
    "insertText": "compare_and_swap(a,r)"
  },
  {
    "label": "call_itt_notify()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_itt_notify(acquired, new_r)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(a)"
  },
  {
    "label": "call_itt_notify()",
    "kind": "Method",
    "detail": "Function (break ; } r = new_r ; } } } insert : array* ir = my_root ;)",
    "insertText": "call_itt_notify(acquired, ir)"
  },
  {
    "label": "create_key()",
    "kind": "Method",
    "detail": "Function (s . ptr = found ; return found ; } } } } template<> class ets_base<ets_key_per_instance> : protected ets_base<ets_no_key> { typedef ets_base<ets_no_key> super ; # if _WIN32 | | _WIN64 # if __TBB_WIN8UI_SUPPORT typedef DWORD tls_key_t ; void)",
    "insertText": "create_key()"
  },
  {
    "label": "FlsAlloc()",
    "kind": "Method",
    "detail": "Function (my_key =)",
    "insertText": "FlsAlloc(NULL)"
  },
  {
    "label": "destroy_key()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "destroy_key()"
  },
  {
    "label": "FlsFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlsFree(my_key)"
  },
  {
    "label": "set_tls()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_tls(void * value)"
  },
  {
    "label": "FlsSetValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlsSetValue(my_key, (LPVOID)value)"
  },
  {
    "label": "get_tls()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "get_tls()"
  },
  {
    "label": "TlsAlloc()",
    "kind": "Method",
    "detail": "Function (my_key =)",
    "insertText": "TlsAlloc()"
  },
  {
    "label": "TlsFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TlsFree(my_key)"
  },
  {
    "label": "TlsSetValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TlsSetValue(my_key, (LPVOID)value)"
  },
  {
    "label": "pthread_key_create()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_key_create(&my_key, NULL)"
  },
  {
    "label": "pthread_key_delete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_key_delete(my_key)"
  },
  {
    "label": "pthread_setspecific()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pthread_setspecific(my_key, value)"
  },
  {
    "label": "table_lookup()",
    "kind": "Method",
    "detail": "Function (exists = true ; } else { found =)",
    "insertText": "table_lookup(exists)"
  },
  {
    "label": "set_tls()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_tls(found)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(my_key, other.my_key)"
  },
  {
    "label": "table_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "table_swap(other)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; template<Container,Value> class enumerable_thread_specific_iterator # if)",
    "insertText": "defined(_WIN64) && defined(_MSC_VER)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Container* my_container ; Container::size_type my_index ; Value* my_value ; template<C,T> enumerable_thread_specific_iterator<C,T>)",
    "insertText": "operator(ptrdiff_t offset, const enumerable_thread_specific_iterator<C,T>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<C,T,U> bool)",
    "insertText": "operator(const enumerable_thread_specific_iterator<C,T>& i, const enumerable_thread_specific_iterator<C,U>& j)"
  },
  {
    "label": "enumerable_thread_specific_iterator()",
    "kind": "Method",
    "detail": "Function (template<C,U> class enumerable_thread_specific_iterator ; public :)",
    "insertText": "enumerable_thread_specific_iterator(const Container &container, typename Container::size_type index ) : my_container(&const_cast<Container &>(container)), my_index(index), my_value(NULL)"
  },
  {
    "label": "enumerable_thread_specific_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "enumerable_thread_specific_iterator() : my_container(NULL), my_index(0), my_value(NULL)"
  },
  {
    "label": "enumerable_thread_specific_iterator()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "enumerable_thread_specific_iterator(const enumerable_thread_specific_iterator<Container, U>& other ) : my_container( other.my_container ), my_index( other.my_index), my_value( const_cast<Value *>(other.my_value))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} enumerable_thread_specific_iterator)",
    "insertText": "operator(ptrdiff_t offset)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (my_index - = offset ; my_value = NULL ; return* this ; } Value&)",
    "insertText": "operator()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Value* value = my_value ;)",
    "insertText": "if(!value)"
  },
  {
    "label": "my_value()",
    "kind": "Method",
    "detail": "Function (value =)",
    "insertText": "my_value(*my_container)[my_index].value()"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "__TBB_ASSERT(value==(*my_container)[my_index].value(), \"corrupt cache\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (- - my_index ; my_value = NULL ; return* this ; } enumerable_thread_specific_iterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (enumerable_thread_specific_iterator result =* this ; - - my_index ; my_value = NULL ; return result ; } typedef ptrdiff_t difference_type ; typedef Value value_type ; typedef Value* pointer ; typedef Value& reference ; typedef std::random_access_iterator_tag iterator_category ; } ; template<Container,T> enumerable_thread_specific_iterator<Container,T>)",
    "insertText": "operator(ptrdiff_t offset, const enumerable_thread_specific_iterator<Container,T>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Container,T,U> bool)",
    "insertText": "operator(const enumerable_thread_specific_iterator<Container,T>& i, const enumerable_thread_specific_iterator<Container,U>& j)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<C,T,U> bool)",
    "insertText": "operator(const segmented_iterator<C,T>& i, const segmented_iterator<C,U>& j)"
  },
  {
    "label": "segmented_iterator()",
    "kind": "Method",
    "detail": "Function (template<C,U> class segmented_iterator ; public :)",
    "insertText": "segmented_iterator()"
  },
  {
    "label": "segmented_iterator()",
    "kind": "Method",
    "detail": "Function (my_segcont = NULL ; })",
    "insertText": "segmented_iterator(const SegmentedContainer& _segmented_container ) : my_segcont(const_cast<SegmentedContainer*>(&_segmented_container)), outer_iter(my_segcont->end())"
  },
  {
    "label": "segmented_iterator()",
    "kind": "Method",
    "detail": "Function (} typedef SegmentedContainer::iterator outer_iterator ; typedef SegmentedContainer::value_type InnerContainer ; typedef InnerContainer::iterator inner_iterator ; typedef ptrdiff_t difference_type ; typedef Value value_type ; typedef SegmentedContainer::size_type size_type ; typedef Value* pointer ; typedef Value& reference ; typedef std::input_iterator_tag iterator_category ; template<U>)",
    "insertText": "segmented_iterator(const segmented_iterator<SegmentedContainer, U>& other) : my_segcont(other.my_segcont), outer_iter(other.outer_iter), inner_iter(other.inner_iter)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<U> segmented_iterator&)",
    "insertText": "operator(const segmented_iterator<SegmentedContainer, U>& other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (my_segcont = other . my_segcont ; outer_iter = other . outer_iter ;)",
    "insertText": "if(outer_iter != my_segcont->end())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } segmented_iterator&)",
    "insertText": "operator(const outer_iterator& new_outer_iter)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_segcont != NULL, NULL)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (inner_iter = outer_iter ->)",
    "insertText": "begin()"
  },
  {
    "label": "advance_me()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "advance_me()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const outer_iterator& other_outer)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(outer_iter != my_segcont->end(), \"Dereferencing a pointer at end of container\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(inner_iter != outer_iter->end(), NULL)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(outer_iter != my_segcont->end(), NULL)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + inner_iter ;)",
    "insertText": "while(inner_iter == outer_iter->end() && ++outer_iter != my_segcont->end())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } } ; template<SegmentedContainer,T,U> bool)",
    "insertText": "operator(const segmented_iterator<SegmentedContainer,T>& i, const segmented_iterator<SegmentedContainer,U>& j)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} template<T> struct construct_by_default : tbb::internal::no_assign { void)",
    "insertText": "construct(void*where)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(where) T()"
  },
  {
    "label": "construct_by_default()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "construct_by_default(int)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(where) T(exemplar)"
  },
  {
    "label": "construct_by_exemplar()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "construct_by_exemplar(const T& t ) : exemplar(t)"
  },
  {
    "label": "construct_by_exemplar()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_ETS_USE_CPP11)",
    "insertText": "construct_by_exemplar(T&& t ) : exemplar(std::move(t))"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} # endif } ; template<T,Finit> struct construct_by_finit : tbb::internal::no_assign { Finit f ; void)",
    "insertText": "construct(void* where)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(where) T(f())"
  },
  {
    "label": "construct_by_finit()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "construct_by_finit(const Finit& f_ ) : f(f_)"
  },
  {
    "label": "construct_by_finit()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_ETS_USE_CPP11)",
    "insertText": "construct_by_finit(Finit&& f_ ) : f(std::move(f_))"
  },
  {
    "label": "call()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call([where](const typename strip<P>::type&... args ){ new(where) T(args...); }, pack)"
  },
  {
    "label": "construct_by_args()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "construct_by_args(P&& ... args ) : pack(std::forward<P>(args)...)"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (} } ; # endif template<T> class callback_base { public : callback_base*)",
    "insertText": "clone()"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy()"
  },
  {
    "label": "callback_base()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "callback_base()"
  },
  {
    "label": "callback_leaf()",
    "kind": "Method",
    "detail": "Function (} ; template<T,Constructor> class callback_leaf : public callback_base<T>,Constructor { # if __TBB_ETS_USE_CPP11 template<. . . P>)",
    "insertText": "callback_leaf(P&& ... params ) : Constructor(std::forward<P>(params)...)"
  },
  {
    "label": "callback_leaf()",
    "kind": "Method",
    "detail": "Function (} # else template<X>)",
    "insertText": "callback_leaf(const X& x ) : Constructor(x)"
  },
  {
    "label": "my_allocator_type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "my_allocator_type().destroy(this)"
  },
  {
    "label": "my_allocator_type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "my_allocator_type().deallocate(this,1)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "construct(where)"
  },
  {
    "label": "make()",
    "kind": "Method",
    "detail": "Function (} public : # if __TBB_ETS_USE_CPP11 template<. . . P> callback_base<T>*)",
    "insertText": "make(P&& ... params)"
  },
  {
    "label": "my_allocator_type()",
    "kind": "Method",
    "detail": "Function (void* where =)",
    "insertText": "my_allocator_type().allocate(1)"
  },
  {
    "label": "make()",
    "kind": "Method",
    "detail": "Function (} # else template<X> callback_base<T>*)",
    "insertText": "make(const X& x)"
  },
  {
    "label": "ets_element()",
    "kind": "Method",
    "detail": "Function (} # endif } ; template<U> struct ets_element { tbb::aligned_space<U> my_space ; bool is_built ;)",
    "insertText": "ets_element()"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (is_built = false ; } U*)",
    "insertText": "value()"
  },
  {
    "label": "value_committed()",
    "kind": "Method",
    "detail": "Function (} U*)",
    "insertText": "value_committed()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (my_space .)",
    "insertText": "begin()->~U()"
  },
  {
    "label": "decide()",
    "kind": "Method",
    "detail": "Function (is_built = false ; } } } ; template<T,ETS> struct is_compatible_ets { const bool value = false ; } ; template<T,U,A,ets_key_usage_type C> struct is_compatible_ets<T,enumerable_thread_specific<U,A,C>> { const bool value = internal::is_same_type<T,U>::value ; } ; # if __TBB_ETS_USE_CPP11 template<T> class is_callable_no_args { private : typedef char yes [ 1 ] ; typedef char no [ 2 ] ; template<U> yes&)",
    "insertText": "decide(decltype(declval<U>()())*)"
  },
  {
    "label": "decide()",
    "kind": "Method",
    "detail": "Function (template<U> no&)",
    "insertText": "decide(...)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (public : const bool)",
    "insertText": "value(sizeof(decide<T>(NULL)) == sizeof(yes))"
  },
  {
    "label": "generic_range_type()",
    "kind": "Method",
    "detail": "Function (} ; # endif } template<T,Allocator = cache_aligned_allocator<T>,ets_key_usage_type ETS_key_type = ets_no_key> class enumerable_thread_specific : internal::ets_base<ETS_key_type> { template<U,A,ets_key_usage_type C> class enumerable_thread_specific ; typedef internal::padded<internal::ets_element<T>> padded_element ; template<I> class generic_range_type : public blocked_range<I> { public : typedef T value_type ; typedef T& reference ; typedef const T& const_reference ; typedef I iterator ; typedef ptrdiff_t difference_type ;)",
    "insertText": "generic_range_type(I begin_, I end_, size_t grainsize_ = 1) : blocked_range<I>(begin_,end_,grainsize_)"
  },
  {
    "label": "generic_range_type()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "generic_range_type(const generic_range_type<U>& r) : blocked_range<I>(r.begin(),r.end(),r.grainsize())"
  },
  {
    "label": "generic_range_type()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "generic_range_type(generic_range_type& r, split ) : blocked_range<I>(r,split())"
  },
  {
    "label": "grow_by()",
    "kind": "Method",
    "detail": "Function (padded_element& lref =* my_locals .)",
    "insertText": "grow_by(1)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (my_construct_callback ->)",
    "insertText": "construct(lref.value())"
  },
  {
    "label": "create_local_by_copy()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "create_local_by_copy(internal::ets_base<ets_no_key>& base, void* p)"
  },
  {
    "label": "enumerable_thread_specific()",
    "kind": "Method",
    "detail": "Function (enumerable_thread_specific& ets = static_cast<)",
    "insertText": "enumerable_thread_specific(base)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(lref.value()) T(*static_cast<T*>(p))"
  },
  {
    "label": "create_local_by_move()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_ETS_USE_CPP11 void*)",
    "insertText": "create_local_by_move(internal::ets_base<ets_no_key>& base, void* p)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(lref.value()) T(std::move(*static_cast<T*>(p)))"
  },
  {
    "label": "nelements()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "nelements(_size + sizeof(uintptr_t) -1) / sizeof(uintptr_t)"
  },
  {
    "label": "free_array()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "free_array(void* _ptr, size_t _size)"
  },
  {
    "label": "array_allocator_type()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "array_allocator_type().deallocate( reinterpret_cast<uintptr_t *>(_ptr),nelements)"
  },
  {
    "label": "enumerable_thread_specific()",
    "kind": "Method",
    "detail": "Function (} public : typedef Allocator allocator_type ; typedef T value_type ; typedef T& reference ; typedef const T& const_reference ; typedef T* pointer ; typedef const T* const_pointer ; typedef internal_collection_type::size_type size_type ; typedef internal_collection_type::difference_type difference_type ; typedef internal::enumerable_thread_specific_iterator<internal_collection_type,value_type> iterator ; typedef internal::enumerable_thread_specific_iterator<internal_collection_type,const value_type> const_iterator ; typedef generic_range_type<iterator> range_type ; typedef generic_range_type<const_iterator> const_range_type ;)",
    "insertText": "enumerable_thread_specific() : my_construct_callback( internal::callback_leaf<T,internal::construct_by_default<T> >::make( 0))"
  },
  {
    "label": "enumerable_thread_specific()",
    "kind": "Method",
    "detail": "Function (} template<Finit # if __TBB_ETS_USE_CPP11,= internal::enable_if<internal::is_callable_no_args<internal::strip<Finit>::type>::value>::type # endif>)",
    "insertText": "enumerable_thread_specific(Finit finit ) : my_construct_callback( internal::callback_leaf<T,internal::construct_by_finit<T,Finit> >::make( tbb::internal::move(finit) ))"
  },
  {
    "label": "enumerable_thread_specific()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "enumerable_thread_specific(const T& exemplar ) : my_construct_callback( internal::callback_leaf<T,internal::construct_by_exemplar<T> >::make( exemplar ))"
  },
  {
    "label": "enumerable_thread_specific()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_ETS_USE_CPP11)",
    "insertText": "enumerable_thread_specific(T&& exemplar ) : my_construct_callback( internal::callback_leaf<T,internal::construct_by_exemplar<T> >::make( std::move(exemplar) ))"
  },
  {
    "label": "enumerable_thread_specific()",
    "kind": "Method",
    "detail": "Function (} template<P1,. . . P,= internal::enable_if<! internal::is_callable_no_args<internal::strip<P1>::type>::value&& ! internal::is_compatible_ets<T,internal::strip<P1>::type>::value&& ! internal::is_same_type<T,internal::strip<P1>::type>::value>::type>)",
    "insertText": "enumerable_thread_specific(P1&& arg1, P&& ... args ) : my_construct_callback( internal::callback_leaf<T,internal::construct_by_args<T,P1,P...> >::make( std::forward<P1>(arg1), std::forward<P>(args)... ))"
  },
  {
    "label": "enumerable_thread_specific()",
    "kind": "Method",
    "detail": "Function (} # endif ~)",
    "insertText": "enumerable_thread_specific()"
  },
  {
    "label": "local()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "local()"
  },
  {
    "label": "local()",
    "kind": "Method",
    "detail": "Function (bool exists ; return)",
    "insertText": "local(exists)"
  },
  {
    "label": "local()",
    "kind": "Method",
    "detail": "Function (} reference)",
    "insertText": "local(bool& exists)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "range()",
    "kind": "Method",
    "detail": "Function (} range_type)",
    "insertText": "range(size_t grainsize=1)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear()"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (} private : template<A2,ets_key_usage_type C2> void)",
    "insertText": "internal_copy(const enumerable_thread_specific<T, A2, C2>& other)"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (# if __TBB_ETS_USE_CPP11&& TBB_USE_ASSERT)",
    "insertText": "__TBB_STATIC_ASSERT((internal::is_compatible_ets<T, typename internal::strip<decltype(other)>::type>::value), \"is_compatible_ets fails\")"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(my_locals.size()==0,NULL)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (my_locals .)",
    "insertText": "reserve(other.size())"
  },
  {
    "label": "table_elementwise_copy()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "table_elementwise_copy(other, create_local_by_copy)"
  },
  {
    "label": "internal_swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "internal_swap(enumerable_thread_specific& other)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "__TBB_ASSERT(this!=&other, NULL)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(my_construct_callback, other.my_construct_callback)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(my_locals, other.my_locals)"
  },
  {
    "label": "internal_move()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_ETS_USE_CPP11 template<A2,ets_key_usage_type C2> void)",
    "insertText": "internal_move(enumerable_thread_specific<T, A2, C2>&& other)"
  },
  {
    "label": "table_elementwise_copy()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "table_elementwise_copy(other, create_local_by_move)"
  },
  {
    "label": "enumerable_thread_specific()",
    "kind": "Method",
    "detail": "Function (} # endif public :)",
    "insertText": "enumerable_thread_specific(const enumerable_thread_specific& other ) : internal::ets_base<ETS_key_type>()"
  },
  {
    "label": "internal_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_copy(other)"
  },
  {
    "label": "enumerable_thread_specific()",
    "kind": "Method",
    "detail": "Function (} template<Alloc,ets_key_usage_type Cachetype>)",
    "insertText": "enumerable_thread_specific(const enumerable_thread_specific<T, Alloc, Cachetype>& other)"
  },
  {
    "label": "enumerable_thread_specific()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_ETS_USE_CPP11)",
    "insertText": "enumerable_thread_specific(enumerable_thread_specific&& other ) : my_construct_callback()"
  },
  {
    "label": "internal_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_swap(other)"
  },
  {
    "label": "enumerable_thread_specific()",
    "kind": "Method",
    "detail": "Function (} template<Alloc,ets_key_usage_type Cachetype>)",
    "insertText": "enumerable_thread_specific(enumerable_thread_specific<T, Alloc, Cachetype>&& other ) : my_construct_callback()"
  },
  {
    "label": "internal_move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_move(std::move(other))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif enumerable_thread_specific&)",
    "insertText": "operator(const enumerable_thread_specific& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } template<Alloc,ets_key_usage_type Cachetype> enumerable_thread_specific&)",
    "insertText": "operator(const enumerable_thread_specific<T, Alloc, Cachetype>& other)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(static_cast<void*>(this)!=static_cast<const void*>(&other), NULL)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (internal::ets_element<T> location ; my_construct_callback ->)",
    "insertText": "construct(location.value())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (T my_result =* ci ;)",
    "insertText": "while(++ci != end()) my_result = f_combine( my_result, *ci)"
  },
  {
    "label": "f_combine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "f_combine(*ci)"
  },
  {
    "label": "flattened2d()",
    "kind": "Method",
    "detail": "Function (} } } ; template<Container> class flattened2d { typedef Container::value_type conval_type ; public : typedef conval_type::size_type size_type ; typedef conval_type::difference_type difference_type ; typedef conval_type::allocator_type allocator_type ; typedef conval_type::value_type value_type ; typedef conval_type::reference reference ; typedef conval_type::const_reference const_reference ; typedef conval_type::pointer pointer ; typedef conval_type::const_pointer const_pointer ; typedef internal::segmented_iterator<Container,value_type> iterator ; typedef internal::segmented_iterator<Container,const value_type> const_iterator ;)",
    "insertText": "flattened2d(const Container &c, typename Container::const_iterator b, typename Container::const_iterator e ) : my_container(const_cast<Container*>(&c)), my_begin(b), my_end(e)"
  },
  {
    "label": "flattened2d()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "flattened2d(const Container &c ) : my_container(const_cast<Container*>(&c)), my_begin(c.begin()), my_end(c.end())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_type tot_size = 0 ;)",
    "insertText": "for(typename Container::const_iterator i = my_begin; i != my_end; ++i)"
  },
  {
    "label": "flatten2d()",
    "kind": "Method",
    "detail": "Function (} return tot_size ; } private : Container* my_container ; Container::const_iterator my_begin ; Container::const_iterator my_end ; } ; template<Container> flattened2d<Container>)",
    "insertText": "flatten2d(const Container &c, const typename Container::const_iterator b, const typename Container::const_iterator e)"
  },
  {
    "label": "flatten2d()",
    "kind": "Method",
    "detail": "Function (} template<Container> flattened2d<Container>)",
    "insertText": "flatten2d(const Container &c)"
  }
]