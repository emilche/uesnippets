[
  {
    "label": "cache_aligned_allocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "cache_aligned_allocator"
  },
  {
    "label": "rebind",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "rebind"
  },
  {
    "label": "cache_aligned_resource",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "cache_aligned_resource"
  },
  {
    "label": "NFS_GetLineSize()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_cache_aligned_allocator_H # define __TBB_cache_aligned_allocator_H # include<new> # include \" tbb_stddef . h \" # if __TBB_ALLOCATOR_CONSTRUCT_VARIADIC # include<utility> # endif # if __TBB_CPP17_MEMORY_RESOURCE_PRESENT # include<memory_resource> # endif namespace tbb { namespace internal { size_t __TBB_EXPORTED_FUNC)",
    "insertText": "NFS_GetLineSize()"
  },
  {
    "label": "NFS_Allocate()",
    "kind": "Method",
    "detail": "Function (void* __TBB_EXPORTED_FUNC)",
    "insertText": "NFS_Allocate(size_t n_element, size_t element_size, void* hint)"
  },
  {
    "label": "NFS_Free()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "NFS_Free(void*)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if _MSC_VER&& !)",
    "insertText": "defined(__INTEL_COMPILER) #pragma warning (push) #pragma warning (disable: 4100)"
  },
  {
    "label": "cache_aligned_allocator()",
    "kind": "Method",
    "detail": "Function (public : typedef internal::allocator_type<T>::value_type value_type ; typedef value_type* pointer ; typedef const value_type* const_pointer ; typedef value_type& reference ; typedef const value_type& const_reference ; typedef size_t size_type ; typedef ptrdiff_t difference_type ; template<U> struct rebind { typedef cache_aligned_allocator<U> other ; } ;)",
    "insertText": "cache_aligned_allocator() throw()"
  },
  {
    "label": "cache_aligned_allocator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "cache_aligned_allocator(const cache_aligned_allocator& ) throw()"
  },
  {
    "label": "cache_aligned_allocator()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "cache_aligned_allocator(const cache_aligned_allocator<U>&) throw()"
  },
  {
    "label": "address()",
    "kind": "Method",
    "detail": "Function (} pointer)",
    "insertText": "address(reference x)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "deallocate(pointer p, size_type)"
  },
  {
    "label": "NFS_Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NFS_Free(p)"
  },
  {
    "label": "max_size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "max_size() const throw()"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_ALLOCATOR_CONSTRUCT_VARIADIC template<U,. . . Args> void)",
    "insertText": "construct(U *p, Args&&... args)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void *)p) U(std::forward<Args>(args)...)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} # else # if __TBB_CPP11_RVALUE_REF_PRESENT void)",
    "insertText": "construct(pointer p, value_type&& value)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)(p)) value_type(std::move(value))"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "construct(pointer p, const value_type& value)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)(p)) value_type(value)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "destroy(pointer p)"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (p -> ~)",
    "insertText": "value_type()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # if _MSC_VER&& !)",
    "insertText": "defined(__INTEL_COMPILER) #pragma warning (pop)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (public : typedef void* pointer ; typedef const void* const_pointer ; typedef void value_type ; template<U> struct rebind { typedef cache_aligned_allocator<U> other ; } ; } ; template<T,U> bool)",
    "insertText": "operator(const cache_aligned_allocator<T>&, const cache_aligned_allocator<U>&)"
  },
  {
    "label": "cache_aligned_resource()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "cache_aligned_resource(std::pmr::memory_resource* upstream) : m_upstream(upstream)"
  },
  {
    "label": "upstream_resource()",
    "kind": "Method",
    "detail": "Function (} std::pmr::memory_resource*)",
    "insertText": "upstream_resource()"
  },
  {
    "label": "correct_alignment()",
    "kind": "Method",
    "detail": "Function (size_t cache_line_alignment =)",
    "insertText": "correct_alignment(alignment)"
  },
  {
    "label": "base()",
    "kind": "Method",
    "detail": "Function (uintptr_t)",
    "insertText": "base(uintptr_t)m_upstream->allocate(correct_size(bytes) + cache_line_alignment)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(base != 0, \"Upstream resource returned NULL.\")"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if _MSC_VER&& !)",
    "insertText": "defined(__INTEL_COMPILER) #pragma warning(push) #pragma warning(disable: 4146 4706) #endif uintptr_t result = (base + cache_line_alignment)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if _MSC_VER&& !)",
    "insertText": "defined(__INTEL_COMPILER) #pragma warning(pop) #endif ((uintptr_t*)result)"
  },
  {
    "label": "do_deallocate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "do_deallocate(void* ptr, size_t bytes, size_t alignment)"
  },
  {
    "label": "base()",
    "kind": "Method",
    "detail": "Function (uintptr_t)",
    "insertText": "base((uintptr_t*)ptr)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (m_upstream ->)",
    "insertText": "deallocate((void*)base, correct_size(bytes) + correct_alignment(alignment))"
  },
  {
    "label": "do_is_equal()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "do_is_equal(const std::pmr::memory_resource& other)"
  },
  {
    "label": "correct_alignment()",
    "kind": "Method",
    "detail": "Function (# else return false ; # endif } size_t)",
    "insertText": "correct_alignment(size_t alignment)"
  },
  {
    "label": "__TBB_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_ASSERT(tbb::internal::is_power_of_two(alignment), \"Alignment is not a power of 2\")"
  },
  {
    "label": "correct_size()",
    "kind": "Method",
    "detail": "Function (# endif return alignment<cache_line_size ? cache_line_size : alignment ; } size_t)",
    "insertText": "correct_size(size_t bytes)"
  }
]