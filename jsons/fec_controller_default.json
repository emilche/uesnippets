[
  {
    "label": "FecControllerDefault",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FecControllerDefault"
  },
  {
    "label": "FecControllerDefault()",
    "kind": "Method",
    "detail": "Function (# ifndef MODULES_VIDEO_CODING_FEC_CONTROLLER_DEFAULT_H_ # define MODULES_VIDEO_CODING_FEC_CONTROLLER_DEFAULT_H_ # include<stddef . h> # include<stdint . h> # include<memory> # include<vector> # include \" api / fec_controller . h \" # include \" modules / video_coding / media_opt_util . h \" # include \" rtc_base / synchronization / mutex . h \" # include \" rtc_base / thread_annotations . h \" # include \" system_wrappers / include / clock . h \" namespace webrtc { class FecControllerDefault : public FecController { public :)",
    "insertText": "FecControllerDefault(Clock* clock, VCMProtectionCallback* protection_callback)"
  },
  {
    "label": "FecControllerDefault()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FecControllerDefault(Clock* clock)"
  },
  {
    "label": "FecControllerDefault()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FecControllerDefault()"
  },
  {
    "label": "FecControllerDefault()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FecControllerDefault(const FecControllerDefault&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FecControllerDefault&)",
    "insertText": "operator(const FecControllerDefault&)"
  },
  {
    "label": "SetProtectionCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetProtectionCallback(VCMProtectionCallback* protection_callback)"
  },
  {
    "label": "SetProtectionMethod()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetProtectionMethod(bool enable_fec, bool enable_nack)"
  },
  {
    "label": "SetEncodingData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetEncodingData(size_t width, size_t height, size_t num_temporal_layers, size_t max_payload_size)"
  },
  {
    "label": "UpdateFecRates()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "UpdateFecRates(uint32_t estimated_bitrate_bps, int actual_framerate_fps, uint8_t fraction_lost, std::vector<bool> loss_mask_vector, int64_t round_trip_time_ms)"
  },
  {
    "label": "UpdateWithEncodedData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateWithEncodedData(size_t encoded_image_length, VideoFrameType encoded_image_frametype)"
  },
  {
    "label": "UseLossVectorMask()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UseLossVectorMask()"
  },
  {
    "label": "GetProtectionOverheadRateThreshold()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetProtectionOverheadRateThreshold()"
  },
  {
    "label": "RTC_GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (private : enum { kBitrateAverageWinMs = 1 0 0 0 } ; Clock* const clock_ ; VCMProtectionCallback* protection_callback_ ; Mutex mutex_ ; std::unique_ptr<media_optimization::VCMLossProtectionLogic> loss_prot_logic_)",
    "insertText": "RTC_GUARDED_BY(mutex_)"
  }
]