[
  {
    "label": "SamePairUnordered()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" GeometryBase . h \" # include \" IndexTypes . h \" # include \" IntVectorTypes . h \" # include \" Math / MathFwd . h \" # include \" Math / Vector . h \" # include \" Util / DynamicVector . h \" # include \" VectorTypes . h \" namespace IndexUtil { using namespace UE::Math ; using namespace UE::Geometry ; using UE::Geometry::FIndex2i ; template<T> bool)",
    "insertText": "SamePairUnordered(T a0, T a1, T b0, T b1)"
  },
  {
    "label": "FindSharedEdgeVertex()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "FindSharedEdgeVertex(const FIndex2i & EdgeVerts1, const FIndex2i & EdgeVerts2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(TriangleVerts[1] == VertexID1)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(TriangleVerts[0] == VertexID2)"
  },
  {
    "label": "FindTriOtherVtx()",
    "kind": "Method",
    "detail": "Function (} } template<T,Vec> int)",
    "insertText": "FindTriOtherVtx(T VertexID1, T VertexID2, const Vec & TriangleVerts)"
  },
  {
    "label": "FindTriOtherVtx()",
    "kind": "Method",
    "detail": "Function (} } return IndexConstants::InvalidID ; } int)",
    "insertText": "FindTriOtherVtx(int VertexID1, int VertexID2, const TDynamicVector<FIndex3i> & TriIndexArray, int TriangleIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const FIndex3i& Triangle = TriIndexArray [ TriangleIndex ] ;)",
    "insertText": "for(int j = 0; j < 3; ++j)"
  },
  {
    "label": "FindTriOtherIndex()",
    "kind": "Method",
    "detail": "Function (} } return IndexConstants::InvalidID ; } template<T,Vec> int)",
    "insertText": "FindTriOtherIndex(T VertexID1, T VertexID2, const Vec & TriangleVerts)"
  },
  {
    "label": "GetOtherTriIndex()",
    "kind": "Method",
    "detail": "Function (} } return IndexConstants::InvalidID ; } int)",
    "insertText": "GetOtherTriIndex(int i0, int i1)"
  },
  {
    "label": "OrientTriEdge()",
    "kind": "Method",
    "detail": "Function (const int values [ 4 ] = { 0,2,1,0 } ; return values [ i0 + i1 ] ; } template<T,Vec> bool)",
    "insertText": "OrientTriEdge(T & Vertex1, T & Vertex2, const Vec & TriangleVerts)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T Temp = Vertex1 ; Vertex1 = Vertex2 ; Vertex2 = Temp ; return true ; } } else)",
    "insertText": "if(Vertex1 == TriangleVerts[1])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T Temp = Vertex1 ; Vertex1 = Vertex2 ; Vertex2 = Temp ; return true ; } } else)",
    "insertText": "if(Vertex1 == TriangleVerts[2])"
  },
  {
    "label": "OrientTriEdgeAndFindOtherVtx()",
    "kind": "Method",
    "detail": "Function (T Temp = Vertex1 ; Vertex1 = Vertex2 ; Vertex2 = Temp ; return true ; } } return false ; } template<T,Vec> int)",
    "insertText": "OrientTriEdgeAndFindOtherVtx(T & Vertex1, T & Vertex2, const Vec & TriangleVerts)"
  },
  {
    "label": "TriangleVerts()",
    "kind": "Method",
    "detail": "Function (Vertex1 = TriangleVerts [ j ] ; Vertex2 =)",
    "insertText": "TriangleVerts(j + 1)"
  },
  {
    "label": "ApplyMap()",
    "kind": "Method",
    "detail": "Function (} } return IndexConstants::InvalidID ; } template<Func> void)",
    "insertText": "ApplyMap(FIndex3i & Val, Func MapFunc)"
  },
  {
    "label": "ApplyMap()",
    "kind": "Method",
    "detail": "Function (Val [ 0 ] = MapFunc [ Val [ 0 ] ] ; Val [ 1 ] = MapFunc [ Val [ 1 ] ] ; Val [ 2 ] = MapFunc [ Val [ 2 ] ] ; } template<T,Func> void)",
    "insertText": "ApplyMap(TVector<T> & Val, Func MapFunc)"
  },
  {
    "label": "ApplyMap()",
    "kind": "Method",
    "detail": "Function (Val [ 0 ] = MapFunc [ Val [ 0 ] ] ; Val [ 1 ] = MapFunc [ Val [ 1 ] ] ; Val [ 2 ] = MapFunc [ Val [ 2 ] ] ; } template<Func> FIndex3i)",
    "insertText": "ApplyMap(const FIndex3i & Val, Func MapFunc)"
  },
  {
    "label": "ApplyMap()",
    "kind": "Method",
    "detail": "Function (} template<T,Func> TVector<T>)",
    "insertText": "ApplyMap(const TVector<T> & Val, Func MapFunc)"
  },
  {
    "label": "ArrayCheck()",
    "kind": "Method",
    "detail": "Function (} template<T,Func> bool)",
    "insertText": "ArrayCheck(const TArray<T>& ToCheck, Func CheckFn)"
  }
]