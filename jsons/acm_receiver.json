[
  {
    "label": "Clock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Clock"
  },
  {
    "label": "NetEq",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NetEq"
  },
  {
    "label": "RTPHeader",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RTPHeader"
  },
  {
    "label": "AcmReceiver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AcmReceiver"
  },
  {
    "label": "DecoderInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DecoderInfo"
  },
  {
    "label": "AcmReceiver()",
    "kind": "Method",
    "detail": "Function (# ifndef MODULES_AUDIO_CODING_ACM2_ACM_RECEIVER_H_ # define MODULES_AUDIO_CODING_ACM2_ACM_RECEIVER_H_ # include<stdint . h> # include<map> # include<memory> # include<string> # include<utility> # include<vector> # include \" absl / types / optional . h \" # include \" api / array_view . h \" # include \" api / audio_codecs / audio_decoder . h \" # include \" api / audio_codecs / audio_format . h \" # include \" modules / audio_coding / acm2 / acm_resampler . h \" # include \" modules / audio_coding / acm2 / call_statistics . h \" # include \" modules / audio_coding / include / audio_coding_module . h \" # include \" rtc_base / synchronization / mutex . h \" # include \" rtc_base / thread_annotations . h \" namespace webrtc { class Clock ; class NetEq ; struct RTPHeader ; namespace acm2 { class AcmReceiver { public :)",
    "insertText": "AcmReceiver(const AudioCodingModule::Config& config)"
  },
  {
    "label": "AcmReceiver()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "AcmReceiver()"
  },
  {
    "label": "InsertPacket()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "InsertPacket(const RTPHeader& rtp_header, rtc::ArrayView<const uint8_t> incoming_payload)"
  },
  {
    "label": "GetAudio()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetAudio(int desired_freq_hz, AudioFrame* audio_frame, bool* muted)"
  },
  {
    "label": "SetCodecs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCodecs(const std::map<int, SdpAudioFormat>& codecs)"
  },
  {
    "label": "SetMinimumDelay()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "SetMinimumDelay(int delay_ms)"
  },
  {
    "label": "SetMaximumDelay()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "SetMaximumDelay(int delay_ms)"
  },
  {
    "label": "SetBaseMinimumDelayMs()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SetBaseMinimumDelayMs(int delay_ms)"
  },
  {
    "label": "GetBaseMinimumDelayMs()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetBaseMinimumDelayMs()"
  },
  {
    "label": "ResetInitialDelay()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetInitialDelay()"
  },
  {
    "label": "last_packet_sample_rate_hz()",
    "kind": "Method",
    "detail": "Function (absl::optional<int>)",
    "insertText": "last_packet_sample_rate_hz()"
  },
  {
    "label": "last_output_sample_rate_hz()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "last_output_sample_rate_hz()"
  },
  {
    "label": "GetNetworkStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetNetworkStatistics(NetworkStatistics* statistics, bool get_and_clear_legacy_stats = true)"
  },
  {
    "label": "FlushBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushBuffers()"
  },
  {
    "label": "RemoveAllCodecs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAllCodecs()"
  },
  {
    "label": "GetPlayoutTimestamp()",
    "kind": "Method",
    "detail": "Function (absl::optional<uint32_t>)",
    "insertText": "GetPlayoutTimestamp()"
  },
  {
    "label": "FilteredCurrentDelayMs()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "FilteredCurrentDelayMs()"
  },
  {
    "label": "TargetDelayMs()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "TargetDelayMs()"
  },
  {
    "label": "LastDecoder()",
    "kind": "Method",
    "detail": "Function (absl::optional<std::pair<int,SdpAudioFormat>>)",
    "insertText": "LastDecoder()"
  },
  {
    "label": "EnableNack()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "EnableNack(size_t max_nack_list_size)"
  },
  {
    "label": "DisableNack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisableNack()"
  },
  {
    "label": "GetNackList()",
    "kind": "Method",
    "detail": "Function (std::vector<uint16_t>)",
    "insertText": "GetNackList(int64_t round_trip_time_ms)"
  },
  {
    "label": "GetDecodingCallStatistics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetDecodingCallStatistics(AudioDecodingCallStats* stats)"
  },
  {
    "label": "NowInTimestamp()",
    "kind": "Method",
    "detail": "Function (private : struct DecoderInfo { int payload_type ; int sample_rate_hz ; int num_channels ; SdpAudioFormat sdp_format ; } ; uint32_t)",
    "insertText": "NowInTimestamp(int decoder_sampling_rate)"
  },
  {
    "label": "RTC_GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (Mutex mutex_ ; absl::optional<DecoderInfo> last_decoder_)",
    "insertText": "RTC_GUARDED_BY(mutex_)"
  }
]