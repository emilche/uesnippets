[
  {
    "label": "FChaosArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosArchive"
  },
  {
    "label": "FImplicitBVH",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImplicitBVH"
  },
  {
    "label": "FImplicitBVTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImplicitBVTree"
  },
  {
    "label": "FImplicitBVTreeNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImplicitBVTreeNode"
  },
  {
    "label": "FImplicitBVHObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImplicitBVHObject"
  },
  {
    "label": "FImplicitBVHNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FImplicitBVHNode"
  },
  {
    "label": "FWorkData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FWorkData"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" # include \" Chaos / BoundingVolumeHierarchy . h \" # include \" Chaos / ImplicitFwd . h \" # include \" Chaos / Serializable . h \" namespace Chaos { class FChaosArchive ; namespace Private { class FImplicitBVH ; class FImplicitBVTree ; class FImplicitBVTreeNode ; class FImplicitBVHObject { public : class FImplicitBVH ; FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, FImplicitBVHObject& BVHObjecty)"
  },
  {
    "label": "FImplicitBVHObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitBVHObject()"
  },
  {
    "label": "FImplicitBVHObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitBVHObject(const TSerializablePtr<FImplicitObject>& InGeometry, const FVec3& InX, const FRotation3& InR, const FAABB3& InBounds, const int32 InRootObjectIndex, const int32 InObjectIndex)"
  },
  {
    "label": "GetGeometry()",
    "kind": "Method",
    "detail": "Function (const FImplicitObject*)",
    "insertText": "GetGeometry()"
  },
  {
    "label": "GetX()",
    "kind": "Method",
    "detail": "Function (} const FVec3f&)",
    "insertText": "GetX()"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (} const FAABB3f&)",
    "insertText": "GetBounds()"
  },
  {
    "label": "GetTransformf()",
    "kind": "Method",
    "detail": "Function (} FRigidTransform3f)",
    "insertText": "GetTransformf()"
  },
  {
    "label": "GetTransform()",
    "kind": "Method",
    "detail": "Function (} FRigidTransform3)",
    "insertText": "GetTransform()"
  },
  {
    "label": "GetObjectIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetObjectIndex()"
  },
  {
    "label": "FImplicitBVHNode()",
    "kind": "Method",
    "detail": "Function (float R [ 4 ] ; FVec3f X ; FAABB3f Bounds ; int32 RootObjectIndex ; TSerializablePtr<FImplicitObject> Geometry ; int32 ObjectIndex ; } ; class FImplicitBVHNode { public :)",
    "insertText": "FImplicitBVHNode(const FAABB3f& InBounds, const int32 InObjectBeginIndex, const int32 InObjectEndIndex) : Bounds(InBounds) , ObjectBeginIndex(InObjectBeginIndex) , ObjectEndIndex(InObjectEndIndex)"
  },
  {
    "label": "IsLeaf()",
    "kind": "Method",
    "detail": "Function (INDEX_NONE,INDEX_NONE } { } bool)",
    "insertText": "IsLeaf()"
  },
  {
    "label": "MakeEmpty()",
    "kind": "Method",
    "detail": "Function (TUniquePtr<FImplicitBVH>)",
    "insertText": "MakeEmpty()"
  },
  {
    "label": "CountLeafObjects()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "CountLeafObjects(const TArrayView<const Chaos::FImplicitObjectPtr>& InRootObjects)"
  },
  {
    "label": "CollectLeafObjects()",
    "kind": "Method",
    "detail": "Function (FObjects)",
    "insertText": "CollectLeafObjects(const TArrayView<const Chaos::FImplicitObjectPtr>& InRootObjects)"
  },
  {
    "label": "CollectLeafObject()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CollectLeafObject(const FImplicitObject* Object, const FRigidTransform3& ParentTransform, const int32 RootObjectIndex, TArray<FImplicitBVHObject>& LeafObjects, const int32 LeafObjectIndex)"
  },
  {
    "label": "TryMake()",
    "kind": "Method",
    "detail": "Function (TUniquePtr<FImplicitBVH>)",
    "insertText": "TryMake(const TArrayView<const Chaos::FImplicitObjectPtr>& InRootObjects, const int32 MinObjects, const int32 InMaxBVHDepth)"
  },
  {
    "label": "TryMakeFromLeaves()",
    "kind": "Method",
    "detail": "Function (TUniquePtr<FImplicitBVH>)",
    "insertText": "TryMakeFromLeaves(TArray<FImplicitBVHObject>&& LeafObjects, const int32 InMinObjects, const int32 InMaxBVHDepth)"
  },
  {
    "label": "FImplicitBVH()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FImplicitBVH()"
  },
  {
    "label": "GetNumObjects()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumObjects()"
  },
  {
    "label": "GetDepth()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetDepth()"
  },
  {
    "label": "GetX()",
    "kind": "Method",
    "detail": "Function (} const FVec3f&)",
    "insertText": "GetX(const int32 ObjectIndex)"
  },
  {
    "label": "GetR()",
    "kind": "Method",
    "detail": "Function (} FRotation3f)",
    "insertText": "GetR(const int32 ObjectIndex)"
  },
  {
    "label": "GetBounds()",
    "kind": "Method",
    "detail": "Function (} const FAABB3f&)",
    "insertText": "GetBounds(const int32 ObjectIndex)"
  },
  {
    "label": "GetTransformf()",
    "kind": "Method",
    "detail": "Function (} FRigidTransform3f)",
    "insertText": "GetTransformf(const int32 ObjectIndex)"
  },
  {
    "label": "GetTransform()",
    "kind": "Method",
    "detail": "Function (} FRigidTransform3)",
    "insertText": "GetTransform(const int32 ObjectIndex)"
  },
  {
    "label": "GetRootObjectIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetRootObjectIndex(const int32 ObjectIndex)"
  },
  {
    "label": "GetObjectIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetObjectIndex(const int32 ObjectIndex)"
  },
  {
    "label": "VisitAllIntersections()",
    "kind": "Method",
    "detail": "Function (} template<TVisitor> void)",
    "insertText": "VisitAllIntersections(const FAABB3& LocalBounds, const TVisitor& ObjectVisitor)"
  },
  {
    "label": "ObjectVisitor()",
    "kind": "Method",
    "detail": "Function (const auto& NodeVisitor = [ this,&)",
    "insertText": "ObjectVisitor(const int32 NodeIndex)"
  },
  {
    "label": "VisitNodeObjects()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitNodeObjects(NodeIndex, ObjectVisitor)"
  },
  {
    "label": "VisitOverlappingNodesStack()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "VisitOverlappingNodesStack(FAABB3f(LocalBounds), NodeVisitor)"
  },
  {
    "label": "VisitOverlappingNodes()",
    "kind": "Method",
    "detail": "Function (} template<TVisitor> void)",
    "insertText": "VisitOverlappingNodes(const FAABB3& LocalBounds, const TVisitor& NodeVisitor)"
  },
  {
    "label": "VisitNodes()",
    "kind": "Method",
    "detail": "Function (} template<TVisitor> void)",
    "insertText": "VisitNodes(const TVisitor& NodeVisitor)"
  },
  {
    "label": "VisitNodesStack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitNodesStack(NodeVisitor)"
  },
  {
    "label": "VisitNodeObjects()",
    "kind": "Method",
    "detail": "Function (} template<TVisitor> void)",
    "insertText": "VisitNodeObjects(const int32 NodeIndex, const TVisitor& ObjectVisitor)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const FImplicitBVHNode& Node = Nodes [ NodeIndex ] ;)",
    "insertText": "for(int32 NodeObjectIndex = Node.ObjectBeginIndex; NodeObjectIndex < Node.ObjectEndIndex; ++NodeObjectIndex)"
  },
  {
    "label": "ObjectVisitor()",
    "kind": "Method",
    "detail": "Function (const FImplicitBVHObject& Object = Objects [ NodeObjectIndices [ NodeObjectIndex ] ] ;)",
    "insertText": "ObjectVisitor(Object.GetGeometry(), Object.GetTransformf(), Object.GetBounds(), Object.GetRootObjectIndex(), Object.GetObjectIndex())"
  },
  {
    "label": "IsOverlappingBounds()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "IsOverlappingBounds(const FAABB3& LocalBounds)"
  },
  {
    "label": "VisitOverlappingLeafNodes()",
    "kind": "Method",
    "detail": "Function (} template<TVisitor> void)",
    "insertText": "VisitOverlappingLeafNodes(const FImplicitBVH& BVHA, const FImplicitBVH& BVHB, const FRigidTransform3& TransformBToA, const TVisitor& LeafPairVisitor)"
  },
  {
    "label": "VisitOverlappingLeafNodesStack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VisitOverlappingLeafNodesStack(BVHA, BVHB, TransformBToA, LeafPairVisitor)"
  },
  {
    "label": "GetNumNodes()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetNumNodes()"
  },
  {
    "label": "GetNodeBounds()",
    "kind": "Method",
    "detail": "Function (} const FAABB3f&)",
    "insertText": "GetNodeBounds(const int32 NodeIndex)"
  },
  {
    "label": "FImplicitBVH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FImplicitBVH(FObjects&& InObjects, const int32 InMaxBVHDepth)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (FChaosArchive&)",
    "insertText": "Serialize(FChaosArchive& Ar)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(FObjects&& InObjects, const int32 MaxDepth, const int32 MaxLeafObjects)"
  },
  {
    "label": "VisitOverlappingNodesStack()",
    "kind": "Method",
    "detail": "Function (template<TVisitor> void)",
    "insertText": "VisitOverlappingNodesStack(const FAABB3f& LocalBounds, const TVisitor& NodeVisitor)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TArray<int32,TMemStackAllocator<>> NodeStack ; NodeStack .)",
    "insertText": "Reserve(GetDepth())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 NodeIndex = 0 ;)",
    "insertText": "while(true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FImplicitBVHNode& Node = Nodes [ NodeIndex ] ;)",
    "insertText": "if(Node.Bounds.Intersects(LocalBounds))"
  },
  {
    "label": "NodeVisitor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "NodeVisitor(NodeIndex)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "check(NodeStack.Num() < GetDepth())"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (NodeIndex = Node . ChildNodeIndices [ 0 ] ; NodeStack .)",
    "insertText": "Push(Node.ChildNodeIndices[1])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } })",
    "insertText": "if(NodeStack.IsEmpty())"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (break ; } NodeIndex = NodeStack .)",
    "insertText": "Pop(EAllowShrinking::No)"
  },
  {
    "label": "VisitNodesStack()",
    "kind": "Method",
    "detail": "Function (} } template<TVisitor> void)",
    "insertText": "VisitNodesStack(const TVisitor& NodeVisitor)"
  },
  {
    "label": "NodeVisitor()",
    "kind": "Method",
    "detail": "Function (const FImplicitBVHNode& Node = Nodes [ NodeIndex ] ; const bool bVisitChildren =)",
    "insertText": "NodeVisitor(Node.Bounds, NodeDepth, NodeIndex)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (const int32 ChildNodeIndexL = Node . ChildNodeIndices [ 0 ] ; const int32 ChildNodeIndexR = Node . ChildNodeIndices [ 1 ] ; NodeDepth = NodeDepth + 1 ; NodeIndex = ChildNodeIndexL ; NodeStack .)",
    "insertText": "Push({ ChildNodeIndexR, NodeDepth })"
  },
  {
    "label": "Top()",
    "kind": "Method",
    "detail": "Function (break ; } NodeIndex = NodeStack .)",
    "insertText": "Top()"
  },
  {
    "label": "VisitOverlappingLeafNodesStack()",
    "kind": "Method",
    "detail": "Function (} } template<TVisitor> void)",
    "insertText": "VisitOverlappingLeafNodesStack(const FImplicitBVH& BVHA, const FImplicitBVH& BVHB, const FRigidTransform3& TransformBToA, const TVisitor& LeafPairVisitor)"
  },
  {
    "label": "GetDepth()",
    "kind": "Method",
    "detail": "Function (TArray<TVec2<int32>,TMemStackAllocator<>> NodePairStack ; const int32 NodeStackMax = BVHA .)",
    "insertText": "GetDepth() + BVHB.GetDepth()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (NodePairStack .)",
    "insertText": "Reserve(NodeStackMax)"
  },
  {
    "label": "TransformedAABB()",
    "kind": "Method",
    "detail": "Function (const FImplicitBVHNode& NodeA = BVHA . Nodes [ NodeIndexA ] ; const FImplicitBVHNode& NodeB = BVHB . Nodes [ NodeIndexB ] ; const FAABB3f& BoundsA = NodeA . Bounds ; FAABB3f BoundsBInA = NodeB . Bounds .)",
    "insertText": "TransformedAABB(TransformBToA)"
  },
  {
    "label": "LeafPairVisitor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeafPairVisitor(NodeIndexA, NodeIndexB)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "check(NodePairStack.Num() < NodeStackMax)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (NodeIndexA = NodeA . ChildNodeIndices [ 0 ] ; NodePairStack .)",
    "insertText": "Push({ NodeA.ChildNodeIndices[1], NodeIndexB })"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (continue ; } else { NodeIndexB = NodeB . ChildNodeIndices [ 0 ] ; NodePairStack .)",
    "insertText": "Push({ NodeIndexA, NodeB.ChildNodeIndices[1] })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } } })",
    "insertText": "if(NodePairStack.IsEmpty())"
  },
  {
    "label": "IsOverlappingBoundsStack()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "IsOverlappingBoundsStack(const FAABB3f& LocalBounds)"
  },
  {
    "label": "BuildTree()",
    "kind": "Method",
    "detail": "Function (} return false ; } struct FWorkData { TArray<FVec3f> ObjectCenters ; TArray<int32> NodeObjectIndices0 ; TArray<int32> NodeObjectIndices1 ; } ; void)",
    "insertText": "BuildTree(const int32 MaxDepth, const int32 MaxLeafObjects)"
  },
  {
    "label": "AddNodeRecursive()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "AddNodeRecursive(const FAABB3f& NodeBounds, const int32 ObjectBeginIndex, const int32 ObjectEndIndex, const int32 NodeDepth, const int32 MaxDepth, const int32 MaxLeafObjects, FWorkData& WorkData)"
  },
  {
    "label": "Partition()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "Partition(const FAABB3f& NodeBounds, const int32 ObjectBeginIndex, const int32 ObjectEndIndex, FAABB3f& OutChildNodeBounds0, FAABB3f& OutChildNodeBounds1, int32& OutPartitionIndex, FWorkData& WorkData)"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (FObjects Objects ; TArray<int32> NodeObjectIndices ; TArray<FImplicitBVHNode> Nodes ; int32 TreeDepth ; } ; } template<> bool)",
    "insertText": "HasBoundingBox(const TArray<Private::FImplicitBVHObject>& Objects, const int32 ObjectIndex)"
  },
  {
    "label": "GetWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> const TAABB<T,d>)",
    "insertText": "GetWorldSpaceBoundingBox(const TArray<Private::FImplicitBVHObject>& Objects, const int32 ObjectIndex, const TMap<int32, TAABB<T, d>>& WorldSpaceBoxes)"
  },
  {
    "label": "ComputeAllWorldSpaceBoundingBoxes()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> void)",
    "insertText": "ComputeAllWorldSpaceBoundingBoxes(const TArray<Private::FImplicitBVHObject>& Objects, const TArray<int32>& AllObjects, const bool bUseVelocity, const T Dt, TMap<int32, TAABB<T, d>>& WorldSpaceBoxes)"
  }
]