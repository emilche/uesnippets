[
  {
    "label": "scalar_opposite_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_opposite_op"
  },
  {
    "label": "functor_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "functor_traits"
  },
  {
    "label": "scalar_abs_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_abs_op"
  },
  {
    "label": "scalar_score_coeff_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_score_coeff_op"
  },
  {
    "label": "abs_knowing_score",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "abs_knowing_score"
  },
  {
    "label": "scalar_abs2_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_abs2_op"
  },
  {
    "label": "scalar_conjugate_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_conjugate_op"
  },
  {
    "label": "scalar_arg_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_arg_op"
  },
  {
    "label": "scalar_cast_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_cast_op"
  },
  {
    "label": "scalar_shift_right_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_shift_right_op"
  },
  {
    "label": "scalar_shift_left_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_shift_left_op"
  },
  {
    "label": "scalar_real_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_real_op"
  },
  {
    "label": "scalar_imag_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_imag_op"
  },
  {
    "label": "scalar_real_ref_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_real_ref_op"
  },
  {
    "label": "scalar_imag_ref_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_imag_ref_op"
  },
  {
    "label": "scalar_exp_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_exp_op"
  },
  {
    "label": "scalar_expm1_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_expm1_op"
  },
  {
    "label": "scalar_log_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_log_op"
  },
  {
    "label": "scalar_log1p_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_log1p_op"
  },
  {
    "label": "scalar_log10_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_log10_op"
  },
  {
    "label": "scalar_log2_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_log2_op"
  },
  {
    "label": "scalar_sqrt_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_sqrt_op"
  },
  {
    "label": "scalar_rsqrt_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_rsqrt_op"
  },
  {
    "label": "scalar_cos_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_cos_op"
  },
  {
    "label": "scalar_sin_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_sin_op"
  },
  {
    "label": "scalar_tan_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_tan_op"
  },
  {
    "label": "scalar_acos_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_acos_op"
  },
  {
    "label": "scalar_asin_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_asin_op"
  },
  {
    "label": "scalar_atan_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_atan_op"
  },
  {
    "label": "scalar_tanh_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_tanh_op"
  },
  {
    "label": "scalar_atanh_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_atanh_op"
  },
  {
    "label": "scalar_sinh_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_sinh_op"
  },
  {
    "label": "scalar_asinh_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_asinh_op"
  },
  {
    "label": "scalar_cosh_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_cosh_op"
  },
  {
    "label": "scalar_acosh_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_acosh_op"
  },
  {
    "label": "scalar_inverse_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_inverse_op"
  },
  {
    "label": "scalar_square_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_square_op"
  },
  {
    "label": "scalar_cube_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_cube_op"
  },
  {
    "label": "scalar_round_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_round_op"
  },
  {
    "label": "scalar_floor_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_floor_op"
  },
  {
    "label": "scalar_rint_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_rint_op"
  },
  {
    "label": "scalar_ceil_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_ceil_op"
  },
  {
    "label": "scalar_isnan_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_isnan_op"
  },
  {
    "label": "scalar_isinf_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_isinf_op"
  },
  {
    "label": "scalar_isfinite_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_isfinite_op"
  },
  {
    "label": "scalar_boolean_not_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_boolean_not_op"
  },
  {
    "label": "scalar_sign_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_sign_op"
  },
  {
    "label": "scalar_logistic_op",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "scalar_logistic_op"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_UNARY_FUNCTORS_H # define EIGEN_UNARY_FUNCTORS_H namespace Eigen { namespace internal { template<Scalar> struct scalar_opposite_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_opposite_op) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_opposite_op<Scalar>> { enum { Cost = NumTraits<Scalar>::AddCost,PacketAccess = packet_traits<Scalar>::HasNegate } ; } ; template<Scalar> struct scalar_abs_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_abs_op)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type)",
    "insertText": "operator() (const Scalar& a)"
  },
  {
    "label": "packetOp()",
    "kind": "Method",
    "detail": "Function (} template<Packet> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet)",
    "insertText": "packetOp(const Packet& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_abs_op<Scalar>> { enum { Cost = NumTraits<Scalar>::AddCost,PacketAccess = packet_traits<Scalar>::HasAbs } ; } ; template<Scalar> struct scalar_score_coeff_op : scalar_abs_op<Scalar> { typedef void Score_is_abs ; } ; template<Scalar> struct functor_traits<scalar_score_coeff_op<Scalar>> : functor_traits<scalar_abs_op<Scalar>> { } ; template<Scalar,= void> struct abs_knowing_score {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(abs_knowing_score)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<Score> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type)",
    "insertText": "operator() (const Scalar& a, const Score&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<Scal> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type)",
    "insertText": "operator() (const Scal&, const result_type& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_abs2_op<Scalar>> { enum { Cost = NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasAbs2 } ; } ; template<Scalar> struct scalar_conjugate_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_conjugate_op) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_conjugate_op<Scalar>> { enum { Cost = 0,PacketAccess = packet_traits<Scalar>::HasConj } ; } ; template<Scalar> struct scalar_arg_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_arg_op)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_arg_op<Scalar>> { enum { Cost = NumTraits<Scalar>::IsComplex ? 5* NumTraits<Scalar>::MulCost : NumTraits<Scalar>::AddCost,PacketAccess = packet_traits<Scalar>::HasArg } ; } ; template<Scalar,NewType> struct scalar_cast_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_cast_op)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar,NewType> struct functor_traits<scalar_cast_op<Scalar,NewType>> { enum { Cost = is_same<Scalar,NewType>::value ? 0 : NumTraits<NewType>::AddCost,PacketAccess = false } ; } ; template<Scalar,int N> struct scalar_shift_right_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_shift_right_op) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar,int N> struct functor_traits<scalar_shift_right_op<Scalar,N>> { enum { Cost = NumTraits<Scalar>::AddCost,PacketAccess = packet_traits<Scalar>::HasShift } ; } ; template<Scalar,int N> struct scalar_shift_left_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_shift_left_op) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar,int N> struct functor_traits<scalar_shift_left_op<Scalar,N>> { enum { Cost = NumTraits<Scalar>::AddCost,PacketAccess = packet_traits<Scalar>::HasShift } ; } ; template<Scalar> struct scalar_real_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_real_op)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_real_op<Scalar>> { enum { Cost = 0,PacketAccess = false } ; } ; template<Scalar> struct scalar_imag_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_imag_op)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_imag_op<Scalar>> { enum { Cost = 0,PacketAccess = false } ; } ; template<Scalar> struct scalar_real_ref_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_real_ref_op)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_real_ref_op<Scalar>> { enum { Cost = 0,PacketAccess = false } ; } ; template<Scalar> struct scalar_imag_ref_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_imag_ref_op)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_imag_ref_op<Scalar>> { enum { Cost = 0,PacketAccess = false } ; } ; template<Scalar> struct scalar_exp_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_exp_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "Cost()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_exp_op<Scalar>> { enum { PacketAccess = packet_traits<Scalar>::HasExp,# ifdef EIGEN_VECTORIZE_FMA)",
    "insertText": "Cost(sizeof(Scalar) == 4 ? (8 * NumTraits<Scalar>::AddCost + 6 * NumTraits<Scalar>::MulCost) : (14 * NumTraits<Scalar>::AddCost + 6 * NumTraits<Scalar>::MulCost + scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value)) #else Cost = (sizeof(Scalar) == 4 ? (21 * NumTraits<Scalar>::AddCost + 13 * NumTraits<Scalar>::MulCost) : (23 * NumTraits<Scalar>::AddCost + 12 * NumTraits<Scalar>::MulCost + scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value))"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} ; template<Scalar> struct scalar_expm1_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_expm1_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_expm1_op<Scalar>> { enum { PacketAccess = packet_traits<Scalar>::HasExpm1,Cost = functor_traits<scalar_exp_op<Scalar>>::Cost } ; } ; template<Scalar> struct scalar_log_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_log_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "Cost()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_log_op<Scalar>> { enum { PacketAccess = packet_traits<Scalar>::HasLog,)",
    "insertText": "Cost(PacketAccess #ifdef EIGEN_VECTORIZE_FMA ? (20 * NumTraits<Scalar>::AddCost + 7 * NumTraits<Scalar>::MulCost) #else ? (36 * NumTraits<Scalar>::AddCost + 14 * NumTraits<Scalar>::MulCost) #endif : sizeof(Scalar)==4 ? 40 : 85)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} ; template<Scalar> struct scalar_log1p_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_log1p_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_log1p_op<Scalar>> { enum { PacketAccess = packet_traits<Scalar>::HasLog1p,Cost = functor_traits<scalar_log_op<Scalar>>::Cost } ; } ; template<Scalar> struct scalar_log10_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_log10_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_USING_STD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_USING_STD(log10) return log10(a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_log10_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasLog10 } ; } ; template<Scalar> struct scalar_log2_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_log2_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_log2_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasLog } ; } ; template<Scalar> struct scalar_sqrt_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_sqrt_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "Cost()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_sqrt_op<Scalar>> { enum { # if EIGEN_FAST_MATH)",
    "insertText": "Cost(sizeof(Scalar) == 8 ? 28 : (3 * NumTraits<Scalar>::AddCost + 5 * NumTraits<Scalar>::MulCost)), #else Cost = (sizeof(Scalar) == 8 ? 28 : 14)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} ; template<> struct scalar_sqrt_op<bool> {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_sqrt_op) EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline bool operator() (const bool& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_rsqrt_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasRsqrt } ; } ; template<Scalar> struct scalar_cos_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_cos_op) EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_cos_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasCos } ; } ; template<Scalar> struct scalar_sin_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_sin_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_sin_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasSin } ; } ; template<Scalar> struct scalar_tan_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_tan_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_tan_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasTan } ; } ; template<Scalar> struct scalar_acos_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_acos_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_acos_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasACos } ; } ; template<Scalar> struct scalar_asin_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_asin_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_asin_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasASin } ; } ; template<Scalar> struct scalar_atan_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_atan_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_atan_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasATan } ; } ; template<Scalar> struct scalar_tanh_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_tanh_op) EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a)"
  },
  {
    "label": "packetOp()",
    "kind": "Method",
    "detail": "Function (} template<Packet> EIGEN_DEVICE_FUNC Packet)",
    "insertText": "packetOp(const Packet& x)"
  },
  {
    "label": "Cost()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_tanh_op<Scalar>> { enum { PacketAccess = packet_traits<Scalar>::HasTanh,)",
    "insertText": "Cost((EIGEN_FAST_MATH && is_same<Scalar,float>::value) #ifdef EIGEN_VECTORIZE_FMA ? (2 * NumTraits<Scalar>::AddCost + 6 * NumTraits<Scalar>::MulCost + scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value) #else ? (11 * NumTraits<Scalar>::AddCost + 11 * NumTraits<Scalar>::MulCost + scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value) #endif : (6 * NumTraits<Scalar>::AddCost + 3 * NumTraits<Scalar>::MulCost + 2 * scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value + functor_traits<scalar_exp_op<Scalar> >::Cost))"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} ; # if EIGEN_HAS_CXX11_MATH template<Scalar> struct scalar_atanh_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_atanh_op) EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_atanh_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = false } ; } ; # endif template<Scalar> struct scalar_sinh_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_sinh_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_sinh_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasSinh } ; } ; # if EIGEN_HAS_CXX11_MATH template<Scalar> struct scalar_asinh_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_asinh_op) EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_asinh_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = false } ; } ; # endif template<Scalar> struct scalar_cosh_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_cosh_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_cosh_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasCosh } ; } ; # if EIGEN_HAS_CXX11_MATH template<Scalar> struct scalar_acosh_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_acosh_op) EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_acosh_op<Scalar>> { enum { Cost = 5* NumTraits<Scalar>::MulCost,PacketAccess = false } ; } ; # endif template<Scalar> struct scalar_inverse_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_inverse_op) EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_inverse_op<Scalar>> { enum { PacketAccess = packet_traits<Scalar>::HasDiv,Cost = scalar_div_cost<Scalar,PacketAccess>::value } ; } ; template<Scalar> struct scalar_square_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_square_op) EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_square_op<Scalar>> { enum { Cost = NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasMul } ; } ; template<> struct scalar_square_op<bool> {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_square_op) EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline bool operator() (const bool& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_cube_op<Scalar>> { enum { Cost = 2* NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasMul } ; } ; template<> struct scalar_cube_op<bool> {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_cube_op) EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline bool operator() (const bool& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_round_op<Scalar>> { enum { Cost = NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasRound } ; } ; template<Scalar> struct scalar_floor_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_floor_op) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_floor_op<Scalar>> { enum { Cost = NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasFloor } ; } ; template<Scalar> struct scalar_rint_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_rint_op) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_rint_op<Scalar>> { enum { Cost = NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasRint } ; } ; template<Scalar> struct scalar_ceil_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_ceil_op) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_ceil_op<Scalar>> { enum { Cost = NumTraits<Scalar>::MulCost,PacketAccess = packet_traits<Scalar>::HasCeil } ; } ; template<Scalar> struct scalar_isnan_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_isnan_op)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(SYCL_DEVICE_ONLY) return numext::isnan(a)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "return(numext::isnan)(a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (# endif } } ; template<Scalar> struct functor_traits<scalar_isnan_op<Scalar>> { enum { Cost = NumTraits<Scalar>::MulCost,PacketAccess = false } ; } ; template<Scalar> struct scalar_isinf_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_isinf_op)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(SYCL_DEVICE_ONLY) return numext::isinf(a)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "return(numext::isinf)(a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (# endif } } ; template<Scalar> struct functor_traits<scalar_isinf_op<Scalar>> { enum { Cost = NumTraits<Scalar>::MulCost,PacketAccess = false } ; } ; template<Scalar> struct scalar_isfinite_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_isfinite_op)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(SYCL_DEVICE_ONLY) return numext::isfinite(a)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "return(numext::isfinite)(a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (# endif } } ; template<Scalar> struct functor_traits<scalar_isfinite_op<Scalar>> { enum { Cost = NumTraits<Scalar>::MulCost,PacketAccess = false } ; } ; template<Scalar> struct scalar_boolean_not_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_boolean_not_op) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (template<Scalar> struct scalar_sign_op<Scalar,false,true> {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_sign_op) EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (typedef NumTraits<Scalar>::Real real_type ; real_type aa =)",
    "insertText": "abs(a)"
  },
  {
    "label": "real_type()",
    "kind": "Method",
    "detail": "Function (aa =)",
    "insertText": "real_type(1)"
  },
  {
    "label": "IsComplex()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar> struct functor_traits<scalar_sign_op<Scalar>> { enum { Cost = NumTraits<Scalar)",
    "insertText": "IsComplex(8*NumTraits<Scalar>::MulCost ) : ( 3*NumTraits<Scalar>::AddCost)"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} ; template<T> struct scalar_logistic_op {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_logistic_op) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T operator()(const T& x)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet one = pset1<)",
    "insertText": "Packet(T(1))"
  },
  {
    "label": "EIGEN_EMPTY_STRUCT_CTOR()",
    "kind": "Method",
    "detail": "Function (} } ; # ifndef EIGEN_GPU_COMPILE_PHASE template<> struct scalar_logistic_op<float> {)",
    "insertText": "EIGEN_EMPTY_STRUCT_CTOR(scalar_logistic_op) EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float operator()(const float& x)"
  },
  {
    "label": "packetOp()",
    "kind": "Method",
    "detail": "Function (} template<Packet> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet)",
    "insertText": "packetOp(const Packet& _x)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet cutoff_lower = pset1<)",
    "insertText": "Packet(-9.f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet lt_mask = pcmp_lt<)",
    "insertText": "Packet(_x, cutoff_lower)"
  },
  {
    "label": "predux_any()",
    "kind": "Method",
    "detail": "Function (const bool any_small =)",
    "insertText": "predux_any(lt_mask)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_VECTORIZE_FMA const Packet cutoff_upper = pset1<)",
    "insertText": "Packet(15.7243833541870117f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (# else const Packet cutoff_upper = pset1<)",
    "insertText": "Packet(15.6437711715698242f)"
  },
  {
    "label": "pmin()",
    "kind": "Method",
    "detail": "Function (# endif const Packet x =)",
    "insertText": "pmin(_x, cutoff_upper)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet alpha_1 = pset1<)",
    "insertText": "Packet(2.48287947061529e-01f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet alpha_3 = pset1<)",
    "insertText": "Packet(8.51377133304701e-03f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet alpha_5 = pset1<)",
    "insertText": "Packet(6.08574864600143e-05f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet alpha_7 = pset1<)",
    "insertText": "Packet(1.15627324459942e-07f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet alpha_9 = pset1<)",
    "insertText": "Packet(4.37031012579801e-11f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet beta_0 = pset1<)",
    "insertText": "Packet(9.93151921023180e-01f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet beta_2 = pset1<)",
    "insertText": "Packet(1.16817656904453e-01f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet beta_4 = pset1<)",
    "insertText": "Packet(1.70198817374094e-03f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet beta_6 = pset1<)",
    "insertText": "Packet(6.29106785017040e-06f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet beta_8 = pset1<)",
    "insertText": "Packet(5.76102136993427e-09f)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet beta_10 = pset1<)",
    "insertText": "Packet(6.10247389755681e-13f)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (const Packet x2 =)",
    "insertText": "pmul(x, x)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (Packet p =)",
    "insertText": "pmadd(x2, alpha_9, alpha_7)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_5)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_3)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmadd(x2, p, alpha_1)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "pmul(x, p)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (Packet q =)",
    "insertText": "pmadd(x2, beta_10, beta_8)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (q =)",
    "insertText": "pmadd(x2, q, beta_6)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (q =)",
    "insertText": "pmadd(x2, q, beta_4)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (q =)",
    "insertText": "pmadd(x2, q, beta_2)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (q =)",
    "insertText": "pmadd(x2, q, beta_0)"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (const Packet logistic =)",
    "insertText": "padd(pdiv(p, q), pset1<Packet>(0.5f))"
  },
  {
    "label": "pexp()",
    "kind": "Method",
    "detail": "Function (const Packet exponential =)",
    "insertText": "pexp(_x)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} else { return logistic ; } } } ; # endif template<T> struct functor_traits<scalar_logistic_op<T>> { enum { Cost = scalar_div_cost<T,packet_traits<T>::HasDiv)",
    "insertText": "value(internal::is_same<T, float>::value ? NumTraits<T>::AddCost * 15 + NumTraits<T>::MulCost * 11 : NumTraits<T>::AddCost * 2 + functor_traits<scalar_exp_op<T> >::Cost), PacketAccess = packet_traits<T>::HasAdd && packet_traits<T>::HasDiv && (internal::is_same<T, float>::value ? packet_traits<T>::HasMul && packet_traits<T>::HasMax && packet_traits<T>::HasMin : packet_traits<T>::HasNegate && packet_traits<T>::HasExp)"
  }
]