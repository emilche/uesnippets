[
  {
    "label": "AllocInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AllocInfo"
  },
  {
    "label": "PartitionRootEnumerator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PartitionRootEnumerator"
  },
  {
    "label": "PurgeFlags",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PurgeFlags"
  },
  {
    "label": "PartitionOptions",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PartitionOptions"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "PA_ALIGNAS",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PA_ALIGNAS"
  },
  {
    "label": "Flags",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Flags"
  },
  {
    "label": "internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "internal"
  },
  {
    "label": "ThreadCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadCache"
  },
  {
    "label": "ScopedSyscallTimer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScopedSyscallTimer"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ROOT_H_ # define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ROOT_H_ # include<algorithm> # include<atomic> # include<cstddef> # include<cstdint> # include \" base / allocator / partition_allocator / address_pool_manager_types . h \" # include \" base / allocator / partition_allocator / allocation_guard . h \" # include \" base / allocator / partition_allocator / chromecast_buildflags . h \" # include \" base / allocator / partition_allocator / freeslot_bitmap . h \" # include \" base / allocator / partition_allocator / page_allocator . h \" # include \" base / allocator / partition_allocator / page_allocator_constants . h \" # include \" base / allocator / partition_allocator / partition_address_space . h \" # include \" base / allocator / partition_allocator / partition_alloc - inl . h \" # include \" base / allocator / partition_allocator / partition_alloc_base / bits . h \" # include \" base / allocator / partition_allocator / partition_alloc_base / compiler_specific . h \" # include \" base / allocator / partition_allocator / partition_alloc_base / component_export . h \" # include \" base / allocator / partition_allocator / partition_alloc_base / debug / debugging_buildflags . h \" # include \" base / allocator / partition_allocator / partition_alloc_base / thread_annotations . h \" # include \" base / allocator / partition_allocator / partition_alloc_base / time / time . h \" # include \" base / allocator / partition_allocator / partition_alloc_buildflags . h \" # include \" base / allocator / partition_allocator / partition_alloc_check . h \" # include \" base / allocator / partition_allocator / partition_alloc_config . h \" # include \" base / allocator / partition_allocator / partition_alloc_constants . h \" # include \" base / allocator / partition_allocator / partition_alloc_forward . h \" # include \" base / allocator / partition_allocator / partition_alloc_hooks . h \" # include \" base / allocator / partition_allocator / partition_alloc_notreached . h \" # include \" base / allocator / partition_allocator / partition_bucket_lookup . h \" # include \" base / allocator / partition_allocator / partition_cookie . h \" # include \" base / allocator / partition_allocator / partition_direct_map_extent . h \" # include \" base / allocator / partition_allocator / partition_freelist_entry . h \" # include \" base / allocator / partition_allocator / partition_lock . h \" # include \" base / allocator / partition_allocator / partition_oom . h \" # include \" base / allocator / partition_allocator / partition_page . h \" # include \" base / allocator / partition_allocator / partition_ref_count . h \" # include \" base / allocator / partition_allocator / partition_tag . h \" # include \" base / allocator / partition_allocator / partition_tag_types . h \" # include \" base / allocator / partition_allocator / reservation_offset_table . h \" # include \" base / allocator / partition_allocator / tagging . h \" # include \" base / allocator / partition_allocator / thread_cache . h \" # include \" build / build_config . h \" # if)",
    "insertText": "BUILDFLAG(STARSCAN) #include \"base/allocator/partition_allocator/starscan/pcscan.h\" #include \"base/allocator/partition_allocator/starscan/state_bitmap.h\" #endif #define CHECK_MAX_SIZE_OR_RETURN_NULLPTR(size, flags) \\ if (size > partition_alloc::internal::MaxDirectMapped())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(flags & AllocFlags::kReturnNull)"
  },
  {
    "label": "PA_CHECK()",
    "kind": "Method",
    "detail": "Function (\\ return nullptr ; \\ } \\)",
    "insertText": "PA_CHECK(false)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (\\ } namespace partition_alloc::internal { template<Z> bool offset_type = std::is_integral_v<Z>&&)",
    "insertText": "sizeof(Z) <= sizeof(ptrdiff_t)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (size_t kAllocInfoSize = 1<<2 4 ; struct AllocInfo { std::atomic<size_t> index { 0 } ; struct { uintptr_t addr ; size_t size ; } allocs [ kAllocInfoSize ] = { } ; } ; # if)",
    "insertText": "BUILDFLAG(RECORD_ALLOC_INFO)"
  },
  {
    "label": "RecordAllocOrFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecordAllocOrFree(uintptr_t addr, size_t size)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# endif } namespace partition_alloc { namespace internal { # if)",
    "insertText": "BUILDFLAG(PA_DCHECK_IS_ON) PA_COMPONENT_EXPORT(PARTITION_ALLOC) void DCheckIfManagedByPartitionAllocBRPPool(uintptr_t address)"
  },
  {
    "label": "DCheckIfManagedByPartitionAllocBRPPool()",
    "kind": "Method",
    "detail": "Function (# else PA_ALWAYS_INLINE void)",
    "insertText": "DCheckIfManagedByPartitionAllocBRPPool(uintptr_t address)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # endif # if)",
    "insertText": "defined(PA_USE_PARTITION_ROOT_ENUMERATOR)"
  },
  {
    "label": "PartitionOptions()",
    "kind": "Method",
    "detail": "Function (# endif } struct PurgeFlags { enum : int { kDecommitEmptySlotSpans = 1<<0,kDiscardUnusedSystemPages = 1<<1,kAggressiveReclaim = 1<<2,} ; } ; struct PartitionOptions { enum class AlignedAlloc : uint8_t { kDisallowed,kAllowed,} ; enum class ThreadCache : uint8_t { kDisabled,kEnabled,} ; enum class Quarantine : uint8_t { kDisallowed,kAllowed,} ; enum class Cookie : uint8_t { kDisallowed,kAllowed,} ; enum class BackupRefPtr : uint8_t { kDisabled,kEnabled,} ; enum class BackupRefPtrZapping : uint8_t { kDisabled,kEnabled,} ; enum class UseConfigurablePool : uint8_t { kNo,kIfAvailable,} ;)",
    "insertText": "PartitionOptions(AlignedAlloc aligned_alloc, ThreadCache thread_cache, Quarantine quarantine, Cookie cookie, BackupRefPtr backup_ref_ptr, BackupRefPtrZapping backup_ref_ptr_zapping, UseConfigurablePool use_configurable_pool) : aligned_alloc(aligned_alloc), thread_cache(thread_cache), quarantine(quarantine), cookie(cookie), backup_ref_ptr(backup_ref_ptr), backup_ref_ptr_zapping(backup_ref_ptr_zapping), use_configurable_pool(use_configurable_pool)"
  },
  {
    "label": "PA_ALIGNAS()",
    "kind": "Method",
    "detail": "Function (} AlignedAlloc aligned_alloc ; ThreadCache thread_cache ; Quarantine quarantine ; Cookie cookie ; BackupRefPtr backup_ref_ptr ; BackupRefPtrZapping backup_ref_ptr_zapping ; UseConfigurablePool use_configurable_pool ; } ; template<bool thread_safe> struct)",
    "insertText": "PA_ALIGNAS(64) PA_COMPONENT_EXPORT(PARTITION_ALLOC)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (using SlotSpan = internal::SlotSpanMetadata<thread_safe> ; using Page = internal::PartitionPage<thread_safe> ; using Bucket = internal::PartitionBucket<thread_safe> ; using FreeListEntry = internal::PartitionFreelistEntry ; using SuperPageExtentEntry = internal::PartitionSuperPageExtentEntry<thread_safe> ; using DirectMapExtent = internal::PartitionDirectMapExtent<thread_safe> ; # if)",
    "insertText": "BUILDFLAG(STARSCAN)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# endif enum class QuarantineMode : uint8_t { kAlwaysDisabled,kDisabledByDefault,kEnabled,} ; enum class ScanMode : uint8_t { kDisabled,kEnabled,} ; enum class BucketDistribution : uint8_t { kDefault,kCoarser,kDenser } ; struct Flags { QuarantineMode quarantine_mode ; ScanMode scan_mode ; BucketDistribution bucket_distribution = BucketDistribution::kCoarser ; bool with_thread_cache = false ; bool allow_aligned_alloc ; bool allow_cookie ; # if)",
    "insertText": "BUILDFLAG(ENABLE_BACKUP_REF_PTR_SUPPORT)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (bool brp_zapping_enabled_ ; # if)",
    "insertText": "defined(PA_ENABLE_MAC11_MALLOC_SIZE_HACK)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # endif bool use_configurable_pool ; # if)",
    "insertText": "defined(PA_EXTRAS_REQUIRED)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (uint32_t extras_offset ; # else uint32_t extras_size = 0 ; uint32_t extras_offset = 0 ; # endif } ; union { Flags flags ; uint8_t one_cacheline [ internal::kPartitionCachelineSize ] ; } ;)",
    "insertText": "static_assert(thread_safe, \"Only the thread-safe root is supported.\")"
  },
  {
    "label": "PA_GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (::partition_alloc::internal::Lock lock_ ; Bucket buckets [ internal::kNumBuckets ] = { } ; Bucket sentinel_bucket { } ; bool initialized = false ; std::atomic<size_t> total_size_of_committed_pages { 0 } ; std::atomic<size_t> max_size_of_committed_pages { 0 } ; std::atomic<size_t> total_size_of_super_pages { 0 } ; std::atomic<size_t> total_size_of_direct_mapped_pages { 0 } ; size_t total_size_of_allocated_bytes)",
    "insertText": "PA_GUARDED_BY(lock_)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (uintptr_t inverted_self = 0 ; std::atomic<int> thread_caches_being_constructed_ { 0 } ; bool quarantine_always_for_testing = false ; # if)",
    "insertText": "defined(PA_ENABLE_MTE_CHECKED_PTR_SUPPORT_WITH_64_BITS_POINTERS)"
  },
  {
    "label": "PartitionRoot()",
    "kind": "Method",
    "detail": "Function (uintptr_t next_tag_bitmap_page = 0 ; # endif)",
    "insertText": "PartitionRoot()"
  },
  {
    "label": "PartitionRoot()",
    "kind": "Method",
    "detail": "Function (QuarantineMode::kAlwaysDisabled,ScanMode::kDisabled } { })",
    "insertText": "PartitionRoot(PartitionOptions opts) : flags()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init(opts)"
  },
  {
    "label": "DestructForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestructForTesting()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(PA_ENABLE_MAC11_MALLOC_SIZE_HACK) void EnableMac11MallocSizeHackForTesting()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "Init(PartitionOptions)"
  },
  {
    "label": "EnableThreadCacheIfSupported()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnableThreadCacheIfSupported()"
  },
  {
    "label": "IsValidSlotSpan()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE bool)",
    "insertText": "IsValidSlotSpan(SlotSpan* slot_span)"
  },
  {
    "label": "FromSlotSpan()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE PartitionRoot*)",
    "insertText": "FromSlotSpan(SlotSpan* slot_span)"
  },
  {
    "label": "FromFirstSuperPage()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE PartitionRoot*)",
    "insertText": "FromFirstSuperPage(uintptr_t super_page)"
  },
  {
    "label": "FromAddrInFirstSuperpage()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE PartitionRoot*)",
    "insertText": "FromAddrInFirstSuperpage(uintptr_t address)"
  },
  {
    "label": "DecreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "DecreaseTotalSizeOfAllocatedBytes(SlotSpan* slot_span) PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "IncreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "IncreaseTotalSizeOfAllocatedBytes(SlotSpan* slot_span, size_t raw_size) PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "DecreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "DecreaseTotalSizeOfAllocatedBytes(uintptr_t addr, size_t len) PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "IncreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "IncreaseTotalSizeOfAllocatedBytes(uintptr_t addr, size_t len, size_t raw_size) PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "IncreaseCommittedPages()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "IncreaseCommittedPages(size_t len)"
  },
  {
    "label": "DecreaseCommittedPages()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "DecreaseCommittedPages(size_t len)"
  },
  {
    "label": "DecommitSystemPagesForData()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "DecommitSystemPagesForData(uintptr_t address, size_t length, PageAccessibilityDisposition accessibility_disposition) PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "RecommitSystemPagesForData()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "RecommitSystemPagesForData(uintptr_t address, size_t length, PageAccessibilityDisposition accessibility_disposition) PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "TryRecommitSystemPagesForData()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE bool)",
    "insertText": "TryRecommitSystemPagesForData(uintptr_t address, size_t length, PageAccessibilityDisposition accessibility_disposition) PA_LOCKS_EXCLUDED(lock_)"
  },
  {
    "label": "OutOfMemory()",
    "kind": "Method",
    "detail": "Function ([ [ noreturn ] ] PA_NOINLINE void)",
    "insertText": "OutOfMemory(size_t size)"
  },
  {
    "label": "AlignedAllocWithFlags()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void*)",
    "insertText": "AlignedAllocWithFlags(unsigned int flags, size_t alignment, size_t requested_size)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (PA_NOINLINE PA_MALLOC_FN void*)",
    "insertText": "Alloc(size_t requested_size, const char* type_name)"
  },
  {
    "label": "AllocWithFlags()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE PA_MALLOC_FN void*)",
    "insertText": "AllocWithFlags(unsigned int flags, size_t requested_size, const char* type_name)"
  },
  {
    "label": "AllocWithFlagsInternal()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE PA_MALLOC_FN void*)",
    "insertText": "AllocWithFlagsInternal(unsigned int flags, size_t requested_size, size_t slot_span_alignment, const char* type_name)"
  },
  {
    "label": "AllocWithFlagsNoHooks()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE PA_MALLOC_FN void*)",
    "insertText": "AllocWithFlagsNoHooks(unsigned int flags, size_t requested_size, size_t slot_span_alignment)"
  },
  {
    "label": "Realloc()",
    "kind": "Method",
    "detail": "Function (PA_NOINLINE void*)",
    "insertText": "Realloc(void* ptr, size_t newize, const char* type_name)"
  },
  {
    "label": "TryRealloc()",
    "kind": "Method",
    "detail": "Function (PA_NOINLINE void*)",
    "insertText": "TryRealloc(void* ptr, size_t new_size, const char* type_name)"
  },
  {
    "label": "ReallocWithFlags()",
    "kind": "Method",
    "detail": "Function (PA_NOINLINE void*)",
    "insertText": "ReallocWithFlags(unsigned int flags, void* ptr, size_t new_size, const char* type_name)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (PA_NOINLINE void)",
    "insertText": "Free(void* object)"
  },
  {
    "label": "FreeWithFlags()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "FreeWithFlags(unsigned int flags, void* object)"
  },
  {
    "label": "FreeNoHooks()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "FreeNoHooks(void* object)"
  },
  {
    "label": "FreeNoHooksImmediate()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "FreeNoHooksImmediate(void* object, SlotSpan* slot_span, uintptr_t slot_start)"
  },
  {
    "label": "GetUsableSize()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE size_t)",
    "insertText": "GetUsableSize(void* ptr)"
  },
  {
    "label": "GetUsableSizeWithMac11MallocSizeHack()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE size_t)",
    "insertText": "GetUsableSizeWithMac11MallocSizeHack(void* ptr)"
  },
  {
    "label": "GetPageAccessibility()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE PageAccessibilityConfiguration)",
    "insertText": "GetPageAccessibility()"
  },
  {
    "label": "AllocationCapacityFromSlotStart()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE size_t)",
    "insertText": "AllocationCapacityFromSlotStart(uintptr_t slot_start)"
  },
  {
    "label": "AllocationCapacityFromRequestedSize()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE size_t)",
    "insertText": "AllocationCapacityFromRequestedSize(size_t size)"
  },
  {
    "label": "IsMemoryTaggingEnabled()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE bool)",
    "insertText": "IsMemoryTaggingEnabled()"
  },
  {
    "label": "PurgeMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PurgeMemory(int flags)"
  },
  {
    "label": "ShrinkEmptySlotSpansRing()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ShrinkEmptySlotSpansRing(size_t limit) PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "EnableLargeEmptySlotSpanRing()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnableLargeEmptySlotSpanRing()"
  },
  {
    "label": "DumpStats()",
    "kind": "Method",
    "detail": "Function (::partition_alloc::internal::ScopedGuard locker { lock_ } ; global_empty_slot_span_ring_size = internal::kMaxFreeableSpans ; } void)",
    "insertText": "DumpStats(const char* partition_name, bool is_light_dump, PartitionStatsDumper* partition_stats_dumper)"
  },
  {
    "label": "DeleteForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeleteForTesting(PartitionRoot* partition_root)"
  },
  {
    "label": "ResetBookkeepingForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetBookkeepingForTesting()"
  },
  {
    "label": "GetBucketDistribution()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE BucketDistribution)",
    "insertText": "GetBucketDistribution()"
  },
  {
    "label": "FreeInSlotSpan()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "FreeInSlotSpan(uintptr_t slot_start, SlotSpan* slot_span) PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "RawFree()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "RawFree(uintptr_t slot_start)"
  },
  {
    "label": "RawFree()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "RawFree(uintptr_t slot_start, SlotSpan* slot_span) PA_LOCKS_EXCLUDED(lock_)"
  },
  {
    "label": "RawFreeBatch()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "RawFreeBatch(FreeListEntry* head, FreeListEntry* tail, size_t size, SlotSpan* slot_span) PA_LOCKS_EXCLUDED(lock_)"
  },
  {
    "label": "RawFreeWithThreadCache()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "RawFreeWithThreadCache(uintptr_t slot_start, SlotSpan* slot_span)"
  },
  {
    "label": "SwitchToDefaultBucketDistribution()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwitchToDefaultBucketDistribution()"
  },
  {
    "label": "SwitchToDenserBucketDistribution()",
    "kind": "Method",
    "detail": "Function (flags . bucket_distribution = BucketDistribution::kDefault ; } void)",
    "insertText": "SwitchToDenserBucketDistribution()"
  },
  {
    "label": "ResetBucketDistributionForTesting()",
    "kind": "Method",
    "detail": "Function (flags . bucket_distribution = BucketDistribution::kDenser ; } void)",
    "insertText": "ResetBucketDistributionForTesting()"
  },
  {
    "label": "thread_cache_for_testing()",
    "kind": "Method",
    "detail": "Function (flags . bucket_distribution = BucketDistribution::kCoarser ; } ThreadCache*)",
    "insertText": "thread_cache_for_testing()"
  },
  {
    "label": "get_total_size_of_committed_pages()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "get_total_size_of_committed_pages()"
  },
  {
    "label": "get_max_size_of_committed_pages()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "get_max_size_of_committed_pages()"
  },
  {
    "label": "get_total_size_of_allocated_bytes()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "get_total_size_of_allocated_bytes()"
  },
  {
    "label": "get_max_size_of_allocated_bytes()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "get_max_size_of_allocated_bytes()"
  },
  {
    "label": "ChoosePool()",
    "kind": "Method",
    "detail": "Function (} internal::pool_handle)",
    "insertText": "ChoosePool()"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(IsConfigurablePoolAvailable())"
  },
  {
    "label": "IsQuarantineAllowed()",
    "kind": "Method",
    "detail": "Function (# else return internal::kRegularPoolHandle ; # endif } PA_ALWAYS_INLINE bool)",
    "insertText": "IsQuarantineAllowed()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(PA_HAS_MEMORY_TAGGING) if (PA_UNLIKELY(quarantine_always_for_testing))"
  },
  {
    "label": "IsScanEnabled()",
    "kind": "Method",
    "detail": "Function (quarantine_always_for_testing = value ; } PA_ALWAYS_INLINE bool)",
    "insertText": "IsScanEnabled()"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(flags.scan_mode != ScanMode::kEnabled || IsQuarantineEnabled())"
  },
  {
    "label": "GetDirectMapSlotSize()",
    "kind": "Method",
    "detail": "Function (} PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR PA_ALWAYS_INLINE size_t)",
    "insertText": "GetDirectMapSlotSize(size_t raw_size)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(raw_size <= internal::MaxDirectMapped())"
  },
  {
    "label": "GetDirectMapReservationSize()",
    "kind": "Method",
    "detail": "Function (} PA_ALWAYS_INLINE size_t)",
    "insertText": "GetDirectMapReservationSize(size_t padded_raw_size)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(padded_raw_size <= internal::MaxDirectMapped())"
  },
  {
    "label": "AdjustSize0IfNeeded()",
    "kind": "Method",
    "detail": "Function (} PA_ALWAYS_INLINE size_t)",
    "insertText": "AdjustSize0IfNeeded(size_t size)"
  },
  {
    "label": "AdjustSize0IfNeeded()",
    "kind": "Method",
    "detail": "Function (size =)",
    "insertText": "AdjustSize0IfNeeded(size)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(size + flags.extras_size >= size)"
  },
  {
    "label": "ObjectToSlotStart()",
    "kind": "Method",
    "detail": "Function (} PA_ALWAYS_INLINE uintptr_t)",
    "insertText": "ObjectToSlotStart(void* object)"
  },
  {
    "label": "brp_enabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "brp_enabled()"
  },
  {
    "label": "brp_zapping_enabled()",
    "kind": "Method",
    "detail": "Function (# else return false ; # endif } bool)",
    "insertText": "brp_zapping_enabled()"
  },
  {
    "label": "uses_configurable_pool()",
    "kind": "Method",
    "detail": "Function (# else return false ; # endif } PA_ALWAYS_INLINE bool)",
    "insertText": "uses_configurable_pool()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (max_empty_slot_spans_dirty_bytes_shift = 0 ; } # if)",
    "insertText": "defined(PA_ENABLE_MTE_CHECKED_PTR_SUPPORT_WITH_64_BITS_POINTERS) PA_ALWAYS_INLINE partition_alloc::PartitionTag GetNewPartitionTag()"
  },
  {
    "label": "EnableSortActiveSlotSpans()",
    "kind": "Method",
    "detail": "Function (auto tag = + + current_partition_tag ; tag + = ! tag ; current_partition_tag = tag ; return tag ; } # endif void)",
    "insertText": "EnableSortActiveSlotSpans()"
  },
  {
    "label": "PA_NO_SANITIZE()",
    "kind": "Method",
    "detail": "Function (private : bool sort_active_slot_spans_ = false ; PA_ALWAYS_INLINE const Bucket&)",
    "insertText": "PA_NO_SANITIZE(\"undefined\") bucket_at(size_t i)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(i <= internal::kNumBuckets)"
  },
  {
    "label": "ret()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ret(bucket >= this->buckets && bucket <= &this->sentinel_bucket)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(ret == bucket->is_direct_mapped())"
  },
  {
    "label": "AllocFromBucket()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE uintptr_t)",
    "insertText": "AllocFromBucket(Bucket* bucket, unsigned int flags, size_t raw_size, size_t slot_span_alignment, size_t* usable_size, bool* is_already_zeroed) PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "TryReallocInPlaceForNormalBuckets()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryReallocInPlaceForNormalBuckets(void* object, SlotSpan* slot_span, size_t new_size)"
  },
  {
    "label": "TryReallocInPlaceForDirectMap()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TryReallocInPlaceForDirectMap(internal::SlotSpanMetadata<thread_safe>* slot_span, size_t requested_size) PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "DecommitEmptySlotSpans()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecommitEmptySlotSpans() PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "RawFreeLocked()",
    "kind": "Method",
    "detail": "Function (PA_ALWAYS_INLINE void)",
    "insertText": "RawFreeLocked(uintptr_t slot_start) PA_EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "MaybeInitThreadCacheAndAlloc()",
    "kind": "Method",
    "detail": "Function (uintptr_t)",
    "insertText": "MaybeInitThreadCacheAndAlloc(uint16_t bucket_index, size_t* slot_size)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(PA_USE_PARTITION_ROOT_ENUMERATOR) static internal::Lock& GetEnumeratorLock()"
  },
  {
    "label": "PA_GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (PartitionRoot*)",
    "insertText": "PA_GUARDED_BY(GetEnumeratorLock())"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (class internal::PartitionRootEnumerator ; # endif class ThreadCache ; } ; namespace internal { class ScopedSyscallTimer { public : # if)",
    "insertText": "defined(PA_COUNT_SYSCALL_TIME) explicit ScopedSyscallTimer(PartitionRoot<>* root) : root_(root), tick_(base::TimeTicks::Now())"
  },
  {
    "label": "ScopedSyscallTimer()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ScopedSyscallTimer()"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (root_ -> syscall_count .)",
    "insertText": "fetch_add(1, std::memory_order_relaxed)"
  },
  {
    "label": "elapsed_nanos()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "elapsed_nanos(base::TimeTicks::Now() - tick_).InNanoseconds()"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (root_ -> syscall_total_time_ns .)",
    "insertText": "fetch_add(elapsed_nanos, std::memory_order_relaxed)"
  },
  {
    "label": "ScopedSyscallTimer()",
    "kind": "Method",
    "detail": "Function (} private : PartitionRoot<>* root_ ; const base::TimeTicks tick_ ; # else)",
    "insertText": "ScopedSyscallTimer(PartitionRoot<>* root)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (} # endif } ; # if)",
    "insertText": "BUILDFLAG(ENABLE_BACKUP_REF_PTR_SUPPORT) PA_ALWAYS_INLINE uintptr_t PartitionAllocGetDirectMapSlotStartInBRPPool(uintptr_t address)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(IsManagedByPartitionAllocBRPPool(address))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(PA_HAS_64_BITS_POINTERS) uintptr_t offset = OffsetInBRPPool(address)"
  },
  {
    "label": "GetDirectMapReservationStart()",
    "kind": "Method",
    "detail": "Function (uintptr_t reservation_start =)",
    "insertText": "GetDirectMapReservationStart(address, kBRPPoolHandle, offset)"
  },
  {
    "label": "GetDirectMapReservationStart()",
    "kind": "Method",
    "detail": "Function (# else uintptr_t reservation_start =)",
    "insertText": "GetDirectMapReservationStart(address)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(!reservation_start)"
  },
  {
    "label": "FromAddr()",
    "kind": "Method",
    "detail": "Function (auto* first_page = PartitionPage<ThreadSafe)",
    "insertText": "FromAddr(reservation_start + PartitionPageSize())"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (auto* page = first_page + first_page -> slot_span_metadata_offset ;)",
    "insertText": "PA_DCHECK(page->is_valid)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(!page->slot_span_metadata_offset)"
  },
  {
    "label": "ToSlotSpanStart()",
    "kind": "Method",
    "detail": "Function (auto* slot_span =& page -> slot_span_metadata ; uintptr_t slot_start = SlotSpanMetadata<ThreadSafe)",
    "insertText": "ToSlotSpanStart(slot_span)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(PA_DCHECK_IS_ON) auto* metadata = PartitionDirectMapMetadata<ThreadSafe>::FromSlotSpan(slot_span)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (size_t padding_for_alignment = metadata -> direct_map_extent . padding_for_alignment ;)",
    "insertText": "PA_DCHECK(padding_for_alignment == static_cast<size_t>(page - first_page) * PartitionPageSize())"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(slot_start == reservation_start + PartitionPageSize() + padding_for_alignment)"
  },
  {
    "label": "PartitionAllocGetSlotStartInBRPPool()",
    "kind": "Method",
    "detail": "Function (# endif return slot_start ; } PA_ALWAYS_INLINE uintptr_t)",
    "insertText": "PartitionAllocGetSlotStartInBRPPool(uintptr_t address)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (address - = kPartitionPastAllocationAdjustment ;)",
    "insertText": "PA_DCHECK(IsManagedByNormalBucketsOrDirectMap(address))"
  },
  {
    "label": "DCheckIfManagedByPartitionAllocBRPPool()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCheckIfManagedByPartitionAllocBRPPool(address)"
  },
  {
    "label": "PartitionAllocGetDirectMapSlotStartInBRPPool()",
    "kind": "Method",
    "detail": "Function (uintptr_t directmap_slot_start =)",
    "insertText": "PartitionAllocGetDirectMapSlotStartInBRPPool(address)"
  },
  {
    "label": "FromAddr()",
    "kind": "Method",
    "detail": "Function (auto* slot_span = SlotSpanMetadata<ThreadSafe)",
    "insertText": "FromAddr(address)"
  },
  {
    "label": "FromSlotSpan()",
    "kind": "Method",
    "detail": "Function (auto* root = PartitionRoot<ThreadSafe)",
    "insertText": "FromSlotSpan(slot_span)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(root->brp_enabled())"
  },
  {
    "label": "GetSlotNumber()",
    "kind": "Method",
    "detail": "Function (size_t offset_in_slot_span = address - slot_span_start ; auto* bucket = slot_span -> bucket ; return slot_span_start + bucket -> slot_size* bucket ->)",
    "insertText": "GetSlotNumber(offset_in_slot_span)"
  },
  {
    "label": "PartitionAllocIsValidPtrDelta()",
    "kind": "Method",
    "detail": "Function (} template<Z,= std::enable_if_t<offset_type<Z>,void>> PA_ALWAYS_INLINE bool)",
    "insertText": "PartitionAllocIsValidPtrDelta(uintptr_t address, Z delta_in_bytes)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (uintptr_t adjusted_address = address - kPartitionPastAllocationAdjustment ;)",
    "insertText": "PA_DCHECK(IsManagedByNormalBucketsOrDirectMap(adjusted_address))"
  },
  {
    "label": "DCheckIfManagedByPartitionAllocBRPPool()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCheckIfManagedByPartitionAllocBRPPool(adjusted_address)"
  },
  {
    "label": "PartitionAllocGetSlotStartInBRPPool()",
    "kind": "Method",
    "detail": "Function (uintptr_t slot_start =)",
    "insertText": "PartitionAllocGetSlotStartInBRPPool(adjusted_address)"
  },
  {
    "label": "FromSlotStart()",
    "kind": "Method",
    "detail": "Function (adjusted_address = 0 ; auto* slot_span = SlotSpanMetadata<ThreadSafe)",
    "insertText": "FromSlotStart(slot_start)"
  },
  {
    "label": "SlotStartToObjectAddr()",
    "kind": "Method",
    "detail": "Function (uintptr_t object_addr = root ->)",
    "insertText": "SlotStartToObjectAddr(slot_start)"
  },
  {
    "label": "uintptr_t()",
    "kind": "Method",
    "detail": "Function (uintptr_t new_address = address + static_cast<)",
    "insertText": "uintptr_t(delta_in_bytes)"
  },
  {
    "label": "PartitionAllocFreeForRefCounting()",
    "kind": "Method",
    "detail": "Function (} PA_ALWAYS_INLINE void)",
    "insertText": "PartitionAllocFreeForRefCounting(uintptr_t slot_start)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(!PartitionRefCountPointer(slot_start)->IsAlive())"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(PA_EXPENSIVE_DCHECKS_ARE_ON) DebugMemset(SlotStartAddr2Ptr(slot_start), kFreedByte, slot_span->GetUtilizedSlotSize() #if BUILDFLAG(PUT_REF_COUNT_IN_PREVIOUS_SLOT) - sizeof(PartitionRefCount) #endif)"
  },
  {
    "label": "fetch_sub()",
    "kind": "Method",
    "detail": "Function (# endif root -> total_size_of_brp_quarantined_bytes .)",
    "insertText": "fetch_sub(slot_span->GetSlotSizeForBookkeeping(), std::memory_order_relaxed)"
  },
  {
    "label": "fetch_sub()",
    "kind": "Method",
    "detail": "Function (root -> total_count_of_brp_quarantined_slots .)",
    "insertText": "fetch_sub(1, std::memory_order_relaxed)"
  },
  {
    "label": "RawFreeWithThreadCache()",
    "kind": "Method",
    "detail": "Function (root ->)",
    "insertText": "RawFreeWithThreadCache(slot_start, slot_span)"
  },
  {
    "label": "AllocFromBucket()",
    "kind": "Method",
    "detail": "Function (} # endif } template<bool thread_safe> PA_ALWAYS_INLINE uintptr_t PartitionRoot<thread_safe)",
    "insertText": "AllocFromBucket(Bucket* bucket, unsigned int flags, size_t raw_size, size_t slot_span_alignment, size_t* usable_size, bool* is_already_zeroed)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK((slot_span_alignment >= internal::PartitionPageSize()) && internal::base::bits::IsPowerOfTwo(slot_span_alignment))"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (SlotSpan* slot_span = bucket -> active_slot_spans_head ;)",
    "insertText": "PA_DCHECK(slot_span)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(!slot_span->marked_full)"
  },
  {
    "label": "SlotStartPtr2Addr()",
    "kind": "Method",
    "detail": "Function (uintptr_t slot_start =)",
    "insertText": "SlotStartPtr2Addr(slot_span->get_freelist_head())"
  },
  {
    "label": "AdjustSizeForExtrasSubtract()",
    "kind": "Method",
    "detail": "Function (* is_already_zeroed = false ;* usable_size =)",
    "insertText": "AdjustSizeForExtrasSubtract(bucket->slot_size)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(*usable_size == slot_span->GetUsableSize(this))"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(IsValidSlotSpan(slot_span))"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(!slot_span->CanStoreRawSize())"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(!slot_span->bucket->is_direct_mapped())"
  },
  {
    "label": "PopForAlloc()",
    "kind": "Method",
    "detail": "Function (void* entry = slot_span ->)",
    "insertText": "PopForAlloc(bucket->slot_size)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(internal::SlotStartPtr2Addr(entry) == slot_start)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(slot_span->bucket == bucket)"
  },
  {
    "label": "SlowPathAlloc()",
    "kind": "Method",
    "detail": "Function (} else { slot_start = bucket ->)",
    "insertText": "SlowPathAlloc(this, flags, raw_size, slot_span_alignment, is_already_zeroed)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK((slot_span->bucket == bucket) || (slot_span->bucket->is_direct_mapped() && (bucket == &sentinel_bucket)))"
  },
  {
    "label": "GetUsableSize()",
    "kind": "Method",
    "detail": "Function (* usable_size = slot_span ->)",
    "insertText": "GetUsableSize(this)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PA_DCHECK(slot_span->GetUtilizedSlotSize() <= slot_span->bucket->slot_size)"
  },
  {
    "label": "IncreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IncreaseTotalSizeOfAllocatedBytes(slot_span, raw_size)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(USE_FREESLOT_BITMAP) if (!slot_span->bucket->is_direct_mapped())"
  },
  {
    "label": "FreeSlotBitmapMarkSlotAsUsed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeSlotBitmapMarkSlotAsUsed(slot_start)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(flags < FreeFlags::kLastFlag << 1)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(MEMORY_TOOL_REPLACES_ALLOCATOR) if (!(flags & FreeFlags::kNoMemoryToolOverride))"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(object)"
  },
  {
    "label": "FreeObserverHookIfEnabled()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeObserverHookIfEnabled(object)"
  },
  {
    "label": "FreeNoHooks()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FreeNoHooks(object)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(PA_HAS_MEMORY_TAGGING)"
  },
  {
    "label": "PA_PREFETCH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_PREFETCH(object)"
  },
  {
    "label": "ObjectPtr2Addr()",
    "kind": "Method",
    "detail": "Function (uintptr_t object_addr =)",
    "insertText": "ObjectPtr2Addr(object)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(ENABLE_PARTITION_ALLOC_AS_MALLOC_SUPPORT) && \\ (BUILDFLAG(IS_ANDROID) && !BUILDFLAG(PA_IS_CAST_ANDROID)) PA_CHECK(IsManagedByPartitionAlloc(object_addr))"
  },
  {
    "label": "FromAddrInFirstSuperpage()",
    "kind": "Method",
    "detail": "Function (# endif auto* root =)",
    "insertText": "FromAddrInFirstSuperpage(object_addr)"
  },
  {
    "label": "FromObject()",
    "kind": "Method",
    "detail": "Function (SlotSpan* slot_span =)",
    "insertText": "FromObject(object)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(FromSlotSpan(slot_span) == root)"
  },
  {
    "label": "ObjectToSlotStart()",
    "kind": "Method",
    "detail": "Function (uintptr_t slot_start = root ->)",
    "insertText": "ObjectToSlotStart(object)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(slot_span == SlotSpan::FromSlotStart(slot_start))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(PA_HAS_MEMORY_TAGGING) if (PA_LIKELY(root->IsMemoryTaggingEnabled()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const size_t slot_size = slot_span -> bucket -> slot_size ;)",
    "insertText": "if(PA_LIKELY(slot_size <= internal::kMaxMemoryTaggingSize))"
  },
  {
    "label": "TagMemoryRangeIncrement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TagMemoryRangeIncrement(slot_start, slot_size)"
  },
  {
    "label": "TagPtr()",
    "kind": "Method",
    "detail": "Function (object =)",
    "insertText": "TagPtr(object)"
  },
  {
    "label": "PA_PREFETCH()",
    "kind": "Method",
    "detail": "Function (} } # else)",
    "insertText": "PA_PREFETCH(slot_span)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "defined(PA_ENABLE_MTE_CHECKED_PTR_SUPPORT_WITH_64_BITS_POINTERS) if (!root->IsDirectMappedBucket(slot_span->bucket))"
  },
  {
    "label": "PartitionTagIncrementValue()",
    "kind": "Method",
    "detail": "Function (partition_alloc::)",
    "insertText": "PartitionTagIncrementValue(slot_start, slot_span->bucket->slot_size)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (} # endif # if)",
    "insertText": "BUILDFLAG(STARSCAN) if (PA_UNLIKELY(root->ShouldQuarantine(object)))"
  },
  {
    "label": "JoinScanIfNeeded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "JoinScanIfNeeded()"
  },
  {
    "label": "MoveToQuarantine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MoveToQuarantine(object, slot_span->GetUsableSize(root), slot_start, slot_span->bucket->slot_size)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(object)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(slot_start)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(PA_DCHECK_IS_ON) if (flags.allow_cookie)"
  },
  {
    "label": "PartitionCookieCheckValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PartitionCookieCheckValue(static_cast<unsigned char*>(object) + slot_span->GetUsableSize(this))"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (} # endif # if)",
    "insertText": "BUILDFLAG(STARSCAN) if (PA_UNLIKELY(IsQuarantineEnabled()))"
  },
  {
    "label": "StateBitmapFromAddr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StateBitmapFromAddr(slot_start)->Free(slot_start)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (} } # endif # if)",
    "insertText": "BUILDFLAG(ENABLE_BACKUP_REF_PTR_SUPPORT) if (brp_enabled())"
  },
  {
    "label": "PartitionRefCountPointer()",
    "kind": "Method",
    "detail": "Function (auto* ref_count =)",
    "insertText": "PartitionRefCountPointer(slot_start)"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (total_size_of_brp_quarantined_bytes .)",
    "insertText": "fetch_add(slot_span->GetSlotSizeForBookkeeping(), std::memory_order_relaxed)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# elif)",
    "insertText": "defined(PA_ZERO_RANDOMLY_ON_FREE) if (PA_UNLIKELY(internal::RandomPeriod()) && !IsDirectMappedBucket(slot_span->bucket))"
  },
  {
    "label": "SecureMemset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SecureMemset(internal::SlotStartAddr2Ptr(slot_start), 0, slot_span->GetUtilizedSlotSize() #if BUILDFLAG(PUT_REF_COUNT_IN_PREVIOUS_SLOT) - sizeof(internal::PartitionRefCount) #endif)"
  },
  {
    "label": "FreeInSlotSpan()",
    "kind": "Method",
    "detail": "Function (} template<bool thread_safe> PA_ALWAYS_INLINE void PartitionRoot<thread_safe)",
    "insertText": "FreeInSlotSpan(uintptr_t slot_start, SlotSpan* slot_span)"
  },
  {
    "label": "DecreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecreaseTotalSizeOfAllocatedBytes(slot_span)"
  },
  {
    "label": "FreeSlotBitmapMarkSlotAsFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeSlotBitmapMarkSlotAsFree(slot_start)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (} # endif return slot_span ->)",
    "insertText": "Free(slot_start)"
  },
  {
    "label": "RawFree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RawFree(slot_start, slot_span)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(COMPILER_MSVC) && !defined(__clang__) #pragma optimize(\"\", off) #endif template <bool thread_safe> PA_ALWAYS_INLINE void PartitionRoot<thread_safe>::RawFree(uintptr_t slot_start, SlotSpan* slot_span)"
  },
  {
    "label": "uintptr_t()",
    "kind": "Method",
    "detail": "Function (* static_cast<volatile)",
    "insertText": "uintptr_t(internal::SlotStartAddr2Ptr(slot_start))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "if(defined(COMPILER_MSVC) && !defined(__clang__)) __asm__ __volatile__(\"\" : : \"r\"(slot_start) : \"memory\")"
  },
  {
    "label": "FreeInSlotSpan()",
    "kind": "Method",
    "detail": "Function (# endif::partition_alloc::internal::ScopedGuard guard { lock_ } ;)",
    "insertText": "FreeInSlotSpan(slot_start, slot_span)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(COMPILER_MSVC) && !defined(__clang__) #pragma optimize(\"\", on) #endif template <bool thread_safe> PA_ALWAYS_INLINE void PartitionRoot<thread_safe>::RawFreeBatch( FreeListEntry* head, FreeListEntry* tail, size_t size, SlotSpan* slot_span)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(head)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(tail)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(size > 0)"
  },
  {
    "label": "AppendFreeList()",
    "kind": "Method",
    "detail": "Function (slot_span ->)",
    "insertText": "AppendFreeList(head, tail, size)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (size_t bucket_index = static_cast<)",
    "insertText": "size_t(slot_span->bucket - this->buckets)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (auto* thread_cache =)",
    "insertText": "Get()"
  },
  {
    "label": "RawFreeLocked()",
    "kind": "Method",
    "detail": "Function (} template<bool thread_safe> PA_ALWAYS_INLINE void PartitionRoot<thread_safe)",
    "insertText": "RawFreeLocked(uintptr_t slot_start)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(!IsDirectMappedBucket(slot_span->bucket))"
  },
  {
    "label": "SuperPageExtentEntry()",
    "kind": "Method",
    "detail": "Function (auto* extent_entry = reinterpret_cast<)",
    "insertText": "SuperPageExtentEntry(reinterpret_cast<uintptr_t>(slot_span) & internal::SystemPageBaseMask())"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(internal::IsReservationStart(super_page))"
  },
  {
    "label": "thread_safe()",
    "kind": "Method",
    "detail": "Function (auto* extent_entry = internal::PartitionSuperPageToExtent<)",
    "insertText": "thread_safe(super_page)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (PartitionRoot* root = extent_entry -> root ;)",
    "insertText": "PA_DCHECK(root->inverted_self == ~reinterpret_cast<uintptr_t>(root))"
  },
  {
    "label": "IncreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (} template<bool thread_safe> PA_ALWAYS_INLINE void PartitionRoot<thread_safe)",
    "insertText": "IncreaseTotalSizeOfAllocatedBytes(SlotSpan* slot_span, size_t raw_size)"
  },
  {
    "label": "IncreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IncreaseTotalSizeOfAllocatedBytes(reinterpret_cast<uintptr_t>(slot_span), slot_span->GetSlotSizeForBookkeeping(), raw_size)"
  },
  {
    "label": "DecreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (} template<bool thread_safe> PA_ALWAYS_INLINE void PartitionRoot<thread_safe)",
    "insertText": "DecreaseTotalSizeOfAllocatedBytes(SlotSpan* slot_span)"
  },
  {
    "label": "DecreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecreaseTotalSizeOfAllocatedBytes(reinterpret_cast<uintptr_t>(slot_span), slot_span->GetSlotSizeForBookkeeping())"
  },
  {
    "label": "IncreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (} template<bool thread_safe> PA_ALWAYS_INLINE void PartitionRoot<thread_safe)",
    "insertText": "IncreaseTotalSizeOfAllocatedBytes(uintptr_t addr, size_t len, size_t raw_size)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (total_size_of_allocated_bytes + = len ; max_size_of_allocated_bytes =)",
    "insertText": "max(max_size_of_allocated_bytes, total_size_of_allocated_bytes)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(RECORD_ALLOC_INFO) partition_alloc::internal::RecordAllocOrFree(addr | 0x01, raw_size)"
  },
  {
    "label": "DecreaseTotalSizeOfAllocatedBytes()",
    "kind": "Method",
    "detail": "Function (# endif } template<bool thread_safe> PA_ALWAYS_INLINE void PartitionRoot<thread_safe)",
    "insertText": "DecreaseTotalSizeOfAllocatedBytes(uintptr_t addr, size_t len)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(total_size_of_allocated_bytes >= len)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (total_size_of_allocated_bytes - = len ; # if)",
    "insertText": "BUILDFLAG(RECORD_ALLOC_INFO) partition_alloc::internal::RecordAllocOrFree(addr | 0x00, len)"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (const auto old_total = total_size_of_committed_pages .)",
    "insertText": "fetch_add(len, std::memory_order_relaxed)"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (const auto new_total = old_total + len ; size_t expected = max_size_of_committed_pages .)",
    "insertText": "load(std::memory_order_relaxed)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (size_t desired ; do { desired =)",
    "insertText": "max(expected, new_total)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(!max_size_of_committed_pages.compare_exchange_weak( expected, desired, std::memory_order_relaxed, std::memory_order_relaxed))"
  },
  {
    "label": "fetch_sub()",
    "kind": "Method",
    "detail": "Function (total_size_of_committed_pages .)",
    "insertText": "fetch_sub(len, std::memory_order_relaxed)"
  },
  {
    "label": "DecommitSystemPagesForData()",
    "kind": "Method",
    "detail": "Function (} template<bool thread_safe> PA_ALWAYS_INLINE void PartitionRoot<thread_safe)",
    "insertText": "DecommitSystemPagesForData(uintptr_t address, size_t length, PageAccessibilityDisposition accessibility_disposition)"
  },
  {
    "label": "DecommitSystemPages()",
    "kind": "Method",
    "detail": "Function (internal::ScopedSyscallTimer timer { this } ;)",
    "insertText": "DecommitSystemPages(address, length, accessibility_disposition)"
  },
  {
    "label": "DecreaseCommittedPages()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecreaseCommittedPages(length)"
  },
  {
    "label": "RecommitSystemPagesForData()",
    "kind": "Method",
    "detail": "Function (} template<bool thread_safe> PA_ALWAYS_INLINE void PartitionRoot<thread_safe)",
    "insertText": "RecommitSystemPagesForData(uintptr_t address, size_t length, PageAccessibilityDisposition accessibility_disposition)"
  },
  {
    "label": "TryRecommitSystemPages()",
    "kind": "Method",
    "detail": "Function (internal::ScopedSyscallTimer timer { this } ; bool ok =)",
    "insertText": "TryRecommitSystemPages(address, length, GetPageAccessibility(), accessibility_disposition)"
  },
  {
    "label": "DecommitEmptySlotSpans()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecommitEmptySlotSpans()"
  },
  {
    "label": "RecommitSystemPages()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RecommitSystemPages(address, length, GetPageAccessibility(), accessibility_disposition)"
  },
  {
    "label": "IncreaseCommittedPages()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "IncreaseCommittedPages(length)"
  },
  {
    "label": "TryRecommitSystemPagesForData()",
    "kind": "Method",
    "detail": "Function (} template<bool thread_safe> PA_ALWAYS_INLINE bool PartitionRoot<thread_safe)",
    "insertText": "TryRecommitSystemPagesForData(uintptr_t address, size_t length, PageAccessibilityDisposition accessibility_disposition)"
  },
  {
    "label": "guard()",
    "kind": "Method",
    "detail": "Function ({::partition_alloc::internal::ScopedGuard)",
    "insertText": "guard(lock_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ok) IncreaseCommittedPages(length)"
  },
  {
    "label": "FromObjectInnerPtr()",
    "kind": "Method",
    "detail": "Function (auto* slot_span =)",
    "insertText": "FromObjectInnerPtr(ptr)"
  },
  {
    "label": "GetUsableSize()",
    "kind": "Method",
    "detail": "Function (size_t usable_size = slot_span ->)",
    "insertText": "GetUsableSize(root)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(PA_ENABLE_MAC11_MALLOC_SIZE_HACK) if (PA_UNLIKELY(root->flags.mac11_malloc_size_hack_enabled_ && usable_size == internal::kMac11MallocSizeHackUsableSize))"
  },
  {
    "label": "PartitionAllocGetSlotStartInBRPPool()",
    "kind": "Method",
    "detail": "Function (uintptr_t slot_start =)",
    "insertText": "PartitionAllocGetSlotStartInBRPPool(UntagPtr(ptr))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(PA_HAS_MEMORY_TAGGING) if (IsMemoryTaggingEnabled())"
  },
  {
    "label": "SizeToBucketIndex()",
    "kind": "Method",
    "detail": "Function (} template<bool thread_safe> PA_ALWAYS_INLINE uint16_t PartitionRoot<thread_safe)",
    "insertText": "SizeToBucketIndex(size_t size, BucketDistribution bucket_distribution)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK((slot_span_alignment >= internal::PartitionPageSize()) && partition_alloc::internal::base::bits::IsPowerOfTwo(slot_span_alignment))"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(flags < AllocFlags::kLastFlag << 1)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK((flags & AllocFlags::kNoHooks) == 0)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(initialized)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(MEMORY_TOOL_REPLACES_ALLOCATOR) if (!(flags & AllocFlags::kNoMemoryToolOverride))"
  },
  {
    "label": "calloc()",
    "kind": "Method",
    "detail": "Function (const bool zero_fill = flags& AllocFlags::kZeroFill ; void* result = zero_fill ?)",
    "insertText": "calloc(1, requested_size) : malloc(requested_size)"
  },
  {
    "label": "PA_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_CHECK(result || flags & AllocFlags::kReturnNull)"
  },
  {
    "label": "AllocationObserverHookIfEnabled()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AllocationObserverHookIfEnabled(object, requested_size, type_name)"
  },
  {
    "label": "AdjustSizeForExtrasAdd()",
    "kind": "Method",
    "detail": "Function (size_t raw_size =)",
    "insertText": "AdjustSizeForExtrasAdd(requested_size)"
  },
  {
    "label": "PA_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_CHECK(raw_size >= requested_size)"
  },
  {
    "label": "SizeToBucketIndex()",
    "kind": "Method",
    "detail": "Function (uint16_t bucket_index =)",
    "insertText": "SizeToBucketIndex(raw_size, this->GetBucketDistribution())"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (size_t usable_size ; bool is_already_zeroed = false ; uintptr_t slot_start = 0 ; size_t slot_size ; # if)",
    "insertText": "BUILDFLAG(STARSCAN) const bool is_quarantine_enabled = IsQuarantineEnabled()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif)",
    "insertText": "if(PA_LIKELY(this->flags.with_thread_cache && slot_span_alignment <= internal::PartitionPageSize()))"
  },
  {
    "label": "GetFromCache()",
    "kind": "Method",
    "detail": "Function (slot_start = tcache ->)",
    "insertText": "GetFromCache(bucket_index, &slot_size)"
  },
  {
    "label": "MaybeInitThreadCacheAndAlloc()",
    "kind": "Method",
    "detail": "Function (} else { slot_start =)",
    "insertText": "MaybeInitThreadCacheAndAlloc(bucket_index, &slot_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(PA_LIKELY(slot_start))"
  },
  {
    "label": "AdjustSizeForExtrasSubtract()",
    "kind": "Method",
    "detail": "Function (usable_size =)",
    "insertText": "AdjustSizeForExtrasSubtract(slot_size)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(PA_DCHECK_IS_ON) SlotSpan* slot_span = SlotSpan::FromSlotStart(slot_start)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(slot_span->bucket == &bucket_at(bucket_index))"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(slot_span->bucket->slot_size == slot_size)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(usable_size == slot_span->GetUsableSize(this))"
  },
  {
    "label": "RawAlloc()",
    "kind": "Method",
    "detail": "Function (# endif } else { slot_start =)",
    "insertText": "RawAlloc(buckets + bucket_index, flags, raw_size, slot_span_alignment, &usable_size, &is_already_zeroed)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(PA_UNLIKELY(!slot_start))"
  },
  {
    "label": "SlotStartToObject()",
    "kind": "Method",
    "detail": "Function (void* object =)",
    "insertText": "SlotStartToObject(slot_start)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(PA_DCHECK_IS_ON) if (this->flags.allow_cookie)"
  },
  {
    "label": "PartitionCookieWriteValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PartitionCookieWriteValue(static_cast<unsigned char*>(object) + usable_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif bool zero_fill = flags& AllocFlags::kZeroFill ;)",
    "insertText": "if(PA_LIKELY(!zero_fill))"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(PA_EXPENSIVE_DCHECKS_ARE_ON) internal::DebugMemset(object, internal::kUninitializedByte, usable_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif } else)",
    "insertText": "if(!is_already_zeroed)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(object, 0, usable_size)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (bool needs_mac11_malloc_size_hack = false ; # if)",
    "insertText": "defined(PA_ENABLE_MAC11_MALLOC_SIZE_HACK) if (PA_UNLIKELY(this->flags.mac11_malloc_size_hack_enabled_ && requested_size == internal::kMac11MallocSizeHackRequestedSize))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (needs_mac11_malloc_size_hack = true ; } # endif auto* ref_count =)",
    "insertText": "new(internal::PartitionRefCountPointer(slot_start)) internal::PartitionRefCount(needs_mac11_malloc_size_hack)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(PA_REF_COUNT_STORE_REQUESTED_SIZE) ref_count->SetRequestedSize(requested_size)"
  },
  {
    "label": "else()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "else(void)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# endif } # endif # if)",
    "insertText": "BUILDFLAG(STARSCAN) if (PA_UNLIKELY(is_quarantine_enabled))"
  },
  {
    "label": "StateBitmapFromAddr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StateBitmapFromAddr(slot_start)->Allocate(slot_start)"
  },
  {
    "label": "RawAlloc()",
    "kind": "Method",
    "detail": "Function (} } # endif return object ; } template<bool thread_safe> PA_ALWAYS_INLINE uintptr_t PartitionRoot<thread_safe)",
    "insertText": "RawAlloc(Bucket* bucket, unsigned int flags, size_t raw_size, size_t slot_span_alignment, size_t* usable_size, bool* is_already_zeroed)"
  },
  {
    "label": "AllocFromBucket()",
    "kind": "Method",
    "detail": "Function (::partition_alloc::internal::ScopedGuard guard { lock_ } ; return)",
    "insertText": "AllocFromBucket(bucket, flags, raw_size, slot_span_alignment, usable_size, is_already_zeroed)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(this->flags.allow_aligned_alloc)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(!this->flags.extras_offset)"
  },
  {
    "label": "PA_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_CHECK(partition_alloc::internal::base::bits::IsPowerOfTwo(alignment))"
  },
  {
    "label": "PA_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_CHECK(alignment <= internal::kMaxSupportedAlignment)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t adjusted_size = requested_size ;)",
    "insertText": "if(alignment <= internal::PartitionPageSize())"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (raw_size = alignment ; } else { raw_size = static_cast<)",
    "insertText": "size_t(1) << (int{sizeof(size_t) * 8} - partition_alloc::internal::base::bits::CountLeadingZeroBits( raw_size - 1))"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PA_DCHECK(partition_alloc::internal::base::bits::IsPowerOfTwo(raw_size))"
  },
  {
    "label": "AdjustSizeForExtrasSubtract()",
    "kind": "Method",
    "detail": "Function (adjusted_size =)",
    "insertText": "AdjustSizeForExtrasSubtract(raw_size)"
  },
  {
    "label": "PartitionExcessiveAllocationSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PartitionExcessiveAllocationSize(requested_size)"
  },
  {
    "label": "PA_NOTREACHED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_NOTREACHED()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (} } size_t slot_span_alignment =)",
    "insertText": "max(alignment, internal::PartitionPageSize())"
  },
  {
    "label": "AllocWithFlagsNoHooks()",
    "kind": "Method",
    "detail": "Function (bool no_hooks = flags& AllocFlags::kNoHooks ; void* object = no_hooks ?)",
    "insertText": "AllocWithFlagsNoHooks(0, adjusted_size, slot_span_alignment) : AllocWithFlagsInternal(0, adjusted_size, slot_span_alignment, \"\")"
  },
  {
    "label": "PA_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_CHECK(!(reinterpret_cast<uintptr_t>(object) & (alignment - 1)))"
  },
  {
    "label": "Realloc()",
    "kind": "Method",
    "detail": "Function (} template<bool thread_safe> PA_NOINLINE void* PartitionRoot<thread_safe)",
    "insertText": "Realloc(void* ptr, size_t new_size, const char* type_name)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(MEMORY_TOOL_REPLACES_ALLOCATOR)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "PA_DCHECK(PartitionRoot<thread_safe>::initialized)"
  },
  {
    "label": "AdjustSizeForExtrasAdd()",
    "kind": "Method",
    "detail": "Function (size =)",
    "insertText": "AdjustSizeForExtrasAdd(size)"
  },
  {
    "label": "bucket_at()",
    "kind": "Method",
    "detail": "Function (auto& bucket =)",
    "insertText": "bucket_at(SizeToBucketIndex(size, GetBucketDistribution()))"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(!bucket.slot_size || bucket.slot_size >= size)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(!(bucket.slot_size % internal::kSmallestBucket))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size = bucket . slot_size ; } else)",
    "insertText": "if(size > internal::MaxDirectMapped())"
  },
  {
    "label": "GetDirectMapSlotSize()",
    "kind": "Method",
    "detail": "Function (} else { size =)",
    "insertText": "GetDirectMapSlotSize(size)"
  },
  {
    "label": "AdjustSizeForExtrasSubtract()",
    "kind": "Method",
    "detail": "Function (} size =)",
    "insertText": "AdjustSizeForExtrasSubtract(size)"
  }
]