[
  {
    "label": "FHitResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHitResult"
  },
  {
    "label": "FSeparatingAxisPointCheck",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSeparatingAxisPointCheck"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (# pragma once # if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_4 # include \" CoreMinimal . h \" # endif # include \" Math / Vector . h \" # include \" Stats / Stats . h \" # if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_4 # include \" Engine / HitResult . h \" # endif # include \" EngineDefines . h \" struct FHitResult ;)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"SceneQueryTotal\"), STAT_Collision_SceneQueryTotal, STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"RaycastAny\"),STAT_Collision_RaycastAny,STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"RaycastSingle\"),STAT_Collision_RaycastSingle,STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"RaycastMultiple\"),STAT_Collision_RaycastMultiple,STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"GeomSweepAny\"),STAT_Collision_GeomSweepAny,STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"GeomSweepSingle\"),STAT_Collision_GeomSweepSingle,STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"GeomSweepMultiple\"),STAT_Collision_GeomSweepMultiple,STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"GeomOverlapMultiple\"),STAT_Collision_GeomOverlapMultiple,STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"GeomOverlapBlocking\"), STAT_Collision_GeomOverlapBlocking, STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"GeomOverlapAny\"), STAT_Collision_GeomOverlapAny, STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"BodyInstanceOverlapMulti\"), STAT_Collision_FBodyInstance_OverlapMulti, STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"BodyInstanceOverlapTest\"), STAT_Collision_FBodyInstance_OverlapTest, STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"BodyInstanceLineTrace\"), STAT_Collision_FBodyInstance_LineTrace, STATGROUP_Collision,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"PreFilter\"), STAT_Collision_PreFilter, STATGROUP_CollisionVerbose,)"
  },
  {
    "label": "DECLARE_CYCLE_STAT_EXTERN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DECLARE_CYCLE_STAT_EXTERN(TEXT(\"SpherecastMultipleInternal\"), STAT_Collision_SpherecastMultiple_Internal, STATGROUP_Collision,)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "if(1 && !(UE_BUILD_SHIPPING || UE_BUILD_TEST) && WITH_EDITOR && WITH_UNREAL_DEVELOPER_TOOLS)"
  },
  {
    "label": "FSeparatingAxisPointCheck()",
    "kind": "Method",
    "detail": "Function (public : FVector HitNormal ; float BestDist ; bool bHit ;)",
    "insertText": "FSeparatingAxisPointCheck(const TArray<FVector>& InPolyVertices, const FVector& InBoxCenter, const FVector& InBoxExtent, bool bInCalcLeastPenetration = true ) : HitNormal(FVector::ZeroVector), BestDist(TNumericLimits<float>::Max()), PolyVertices(InPolyVertices), BoxCenter(InBoxCenter), BoxExtent(InBoxExtent), bCalcLeastPenetration(bInCalcLeastPenetration)"
  },
  {
    "label": "bHit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bHit(PolyVertices.Num() == 3) ? FindSeparatingAxisTriangle() : FindSeparatingAxisGeneric()"
  },
  {
    "label": "TestSeparatingAxisCommon()",
    "kind": "Method",
    "detail": "Function (} private : bool)",
    "insertText": "TestSeparatingAxisCommon(const FVector& Axis, float ProjectedPolyMin, float ProjectedPolyMax)"
  },
  {
    "label": "TestSeparatingAxisTriangle()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TestSeparatingAxisTriangle(const FVector& Axis)"
  },
  {
    "label": "TestSeparatingAxisGeneric()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TestSeparatingAxisGeneric(const FVector& Axis)"
  },
  {
    "label": "FindSeparatingAxisTriangle()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FindSeparatingAxisTriangle()"
  },
  {
    "label": "FindSeparatingAxisGeneric()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FindSeparatingAxisGeneric()"
  },
  {
    "label": "LineCheckWithTriangle()",
    "kind": "Method",
    "detail": "Function (const TArray<FVector>& PolyVertices ; FVector BoxCenter ; FVector BoxExtent ; bool bCalcLeastPenetration ; } ; bool)",
    "insertText": "LineCheckWithTriangle(FHitResult& Result,const FVector& V1,const FVector& V2,const FVector& V3,const FVector& Start,const FVector& End,const FVector& Direction)"
  }
]