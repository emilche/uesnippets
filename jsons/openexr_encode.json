[
  {
    "label": "_exr_encode_pipeline",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_exr_encode_pipeline"
  },
  {
    "label": "EXR_ENCODE_DATA_SAMPLE_COUNTS_ARE_INDIVIDUAL()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENEXR_CORE_ENCODE_H # define OPENEXR_CORE_ENCODE_H # include \" openexr_chunkio . h \" # include \" openexr_coding . h \" # ifdef __cplusplus \" C \" { # endif # define)",
    "insertText": "EXR_ENCODE_DATA_SAMPLE_COUNTS_ARE_INDIVIDUAL((uint16_t) (1 << 0)) #define EXR_ENCODE_NON_IMAGE_DATA_AS_POINTERS ((uint16_t) (1 << 1))"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (exr_coding_channel_info_t* channels ; int16_t channel_count ; uint16_t encode_flags ; int part_index ; exr_const_context_t context ; exr_chunk_info_t chunk ; void* encoding_user_data ; void* packed_buffer ; uint64_t packed_bytes ; size_t packed_alloc_size ; int32_t* sample_count_table ; size_t sample_count_alloc_size ; void* packed_sample_count_table ; size_t packed_sample_count_bytes ; size_t packed_sample_count_alloc_size ; void* compressed_buffer ; size_t compressed_bytes ; size_t compressed_alloc_size ; void* scratch_buffer_1 ; size_t scratch_alloc_size_1 ; void* scratch_buffer_2 ; size_t scratch_alloc_size_2 ;)",
    "insertText": "void(*alloc_fn) (exr_transcoding_pipeline_buffer_id_t, size_t)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "void(*free_fn) (exr_transcoding_pipeline_buffer_id_t, void*)"
  },
  {
    "label": "exr_result_t()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "exr_result_t(*convert_and_pack_fn) (struct _exr_encode_pipeline* pipeline)"
  },
  {
    "label": "exr_result_t()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "exr_result_t(*compress_fn) (struct _exr_encode_pipeline* pipeline)"
  },
  {
    "label": "exr_result_t()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "exr_result_t(*yield_until_ready_fn) ( struct _exr_encode_pipeline* pipeline)"
  },
  {
    "label": "exr_result_t()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "exr_result_t(*write_fn) (struct _exr_encode_pipeline* pipeline)"
  },
  {
    "label": "exr_encoding_initialize()",
    "kind": "Method",
    "detail": "Function (exr_coding_channel_info_t _quick_chan_store [ 5 ] ; } exr_encode_pipeline_t ; # define EXR_ENCODE_PIPELINE_INITIALIZER \\ { \\ 0 \\ } EXR_EXPORT exr_result_t)",
    "insertText": "exr_encoding_initialize(exr_const_context_t ctxt, int part_index, const exr_chunk_info_t* cinfo, exr_encode_pipeline_t* encode_pipe)"
  },
  {
    "label": "exr_encoding_choose_default_routines()",
    "kind": "Method",
    "detail": "Function (EXR_EXPORT exr_result_t)",
    "insertText": "exr_encoding_choose_default_routines(exr_const_context_t ctxt, int part_index, exr_encode_pipeline_t* encode_pipe)"
  },
  {
    "label": "exr_encoding_update()",
    "kind": "Method",
    "detail": "Function (EXR_EXPORT exr_result_t)",
    "insertText": "exr_encoding_update(exr_const_context_t ctxt, int part_index, const exr_chunk_info_t* cinfo, exr_encode_pipeline_t* encode_pipe)"
  },
  {
    "label": "exr_encoding_run()",
    "kind": "Method",
    "detail": "Function (EXR_EXPORT exr_result_t)",
    "insertText": "exr_encoding_run(exr_const_context_t ctxt, int part_index, exr_encode_pipeline_t* encode_pipe)"
  },
  {
    "label": "exr_encoding_destroy()",
    "kind": "Method",
    "detail": "Function (EXR_EXPORT exr_result_t)",
    "insertText": "exr_encoding_destroy(exr_const_context_t ctxt, exr_encode_pipeline_t* encode_pipe)"
  }
]