[
  {
    "label": "APInt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "APInt"
  },
  {
    "label": "Argument",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Argument"
  },
  {
    "label": "AssemblyAnnotationWriter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AssemblyAnnotationWriter"
  },
  {
    "label": "BasicBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BasicBlock"
  },
  {
    "label": "Constant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Constant"
  },
  {
    "label": "DataLayout",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DataLayout"
  },
  {
    "label": "Function",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Function"
  },
  {
    "label": "GlobalAlias",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GlobalAlias"
  },
  {
    "label": "GlobalObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GlobalObject"
  },
  {
    "label": "GlobalValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GlobalValue"
  },
  {
    "label": "GlobalVariable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GlobalVariable"
  },
  {
    "label": "InlineAsm",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InlineAsm"
  },
  {
    "label": "Instruction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Instruction"
  },
  {
    "label": "LLVMContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LLVMContext"
  },
  {
    "label": "Module",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Module"
  },
  {
    "label": "ModuleSlotTracker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ModuleSlotTracker"
  },
  {
    "label": "StringRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StringRef"
  },
  {
    "label": "Twine",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Twine"
  },
  {
    "label": "Type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Type"
  },
  {
    "label": "ValueHandleBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueHandleBase"
  },
  {
    "label": "ValueSymbolTable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueSymbolTable"
  },
  {
    "label": "raw_ostream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "raw_ostream"
  },
  {
    "label": "StringMapEntry",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StringMapEntry"
  },
  {
    "label": "Value",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Value"
  },
  {
    "label": "ValueAsMetadata",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueAsMetadata"
  },
  {
    "label": "use_iterator_impl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "use_iterator_impl"
  },
  {
    "label": "user_iterator_impl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "user_iterator_impl"
  },
  {
    "label": "ValueTy",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ValueTy"
  },
  {
    "label": "Compare",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Compare"
  },
  {
    "label": "isa_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "isa_impl"
  },
  {
    "label": "PointerLikeTypeTraits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PointerLikeTypeTraits"
  },
  {
    "label": "use_iterator_impl()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_IR_VALUE_H # define LLVM_IR_VALUE_H # include \" llvm - c / Core . h \" # include \" llvm / ADT / iterator_range . h \" # include \" llvm / IR / Use . h \" # include \" llvm / Support / CBindingWrapping . h \" # include \" llvm / Support / Casting . h \" # include \" llvm / Support / Compiler . h \" namespace llvm { class APInt ; class Argument ; class AssemblyAnnotationWriter ; class BasicBlock ; class Constant ; class DataLayout ; class Function ; class GlobalAlias ; class GlobalObject ; class GlobalValue ; class GlobalVariable ; class InlineAsm ; class Instruction ; class LLVMContext ; class Module ; class ModuleSlotTracker ; class StringRef ; class Twine ; class Type ; class ValueHandleBase ; class ValueSymbolTable ; class raw_ostream ; template<ValueTy> class StringMapEntry ; typedef StringMapEntry<Value*> ValueName ; class Value { Type* VTy ; Use* UseList ; class ValueAsMetadata ; class ValueHandleBase ; const unsigned char SubclassID ; unsigned char HasValueHandle : 1 ; protected : unsigned char SubclassOptionalData : 7 ; private : unsigned short SubclassData ; protected : enum : unsigned { NumUserOperandsBits = 2 9 } ; unsigned NumUserOperands : NumUserOperandsBits ; bool IsUsedByMD : 1 ; bool HasName : 1 ; bool HasHungOffUses : 1 ; private : template<UseT> class use_iterator_impl { UseT* U ;)",
    "insertText": "use_iterator_impl(UseT *u) : U(u)"
  },
  {
    "label": "use_iterator_impl()",
    "kind": "Method",
    "detail": "Function (} class Value ; public : using iterator_category = std::forward_iterator_tag ; using value_type = UseT* ; using difference_type = std::ptrdiff_t ; using pointer = value_type* ; using reference = value_type& ;)",
    "insertText": "use_iterator_impl() : U()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const use_iterator_impl &x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} use_iterator_impl&)",
    "insertText": "operator()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(U && \"Cannot increment end iterator!\")"
  },
  {
    "label": "getNext()",
    "kind": "Method",
    "detail": "Function (U = U ->)",
    "insertText": "getNext()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(U && \"Cannot dereference end iterator!\")"
  },
  {
    "label": "UseT()",
    "kind": "Method",
    "detail": "Function (} operator use_iterator_impl<const)",
    "insertText": "UseT()"
  },
  {
    "label": "user_iterator_impl()",
    "kind": "Method",
    "detail": "Function (} } ; template<UserTy> class user_iterator_impl { use_iterator_impl<Use> UI ;)",
    "insertText": "user_iterator_impl(Use *U) : UI(U)"
  },
  {
    "label": "user_iterator_impl()",
    "kind": "Method",
    "detail": "Function (} class Value ; public : using iterator_category = std::forward_iterator_tag ; using value_type = UserTy* ; using difference_type = std::ptrdiff_t ; using pointer = value_type* ; using reference = value_type& ;)",
    "insertText": "user_iterator_impl()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const user_iterator_impl &x)"
  },
  {
    "label": "atEnd()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "atEnd()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + UI ; return* this ; } user_iterator_impl)",
    "insertText": "operator(int)"
  },
  {
    "label": "UserTy()",
    "kind": "Method",
    "detail": "Function (} operator user_iterator_impl<const)",
    "insertText": "UserTy()"
  },
  {
    "label": "getUse()",
    "kind": "Method",
    "detail": "Function (} Use&)",
    "insertText": "getUse()"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Value(const Value &)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "Value(Type *Ty, unsigned scid)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (public : ~)",
    "insertText": "Value()"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dump()"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &O)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &O, ModuleSlotTracker &MST)"
  },
  {
    "label": "printAsOperand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printAsOperand(raw_ostream &O, bool PrintType = true, const Module *M = nullptr)"
  },
  {
    "label": "printAsOperand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printAsOperand(raw_ostream &O, bool PrintType, ModuleSlotTracker &MST)"
  },
  {
    "label": "getType()",
    "kind": "Method",
    "detail": "Function (Type*)",
    "insertText": "getType()"
  },
  {
    "label": "hasName()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasName()"
  },
  {
    "label": "setValueName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueName(ValueName *VN)"
  },
  {
    "label": "destroyValueName()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "destroyValueName()"
  },
  {
    "label": "setNameImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setNameImpl(const Twine &Name)"
  },
  {
    "label": "getName()",
    "kind": "Method",
    "detail": "Function (public : StringRef)",
    "insertText": "getName()"
  },
  {
    "label": "setName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setName(const Twine &Name)"
  },
  {
    "label": "takeName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "takeName(Value *V)"
  },
  {
    "label": "replaceAllUsesWith()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replaceAllUsesWith(Value *V)"
  },
  {
    "label": "replaceUsesOutsideBlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replaceUsesOutsideBlock(Value *V, BasicBlock *BB)"
  },
  {
    "label": "use_empty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "use_empty()"
  },
  {
    "label": "use_begin()",
    "kind": "Method",
    "detail": "Function (} const_use_iterator)",
    "insertText": "use_begin()"
  },
  {
    "label": "use_end()",
    "kind": "Method",
    "detail": "Function (} use_iterator)",
    "insertText": "use_end()"
  },
  {
    "label": "uses()",
    "kind": "Method",
    "detail": "Function (} iterator_range<use_iterator>)",
    "insertText": "uses()"
  },
  {
    "label": "user_empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "user_empty()"
  },
  {
    "label": "user_begin()",
    "kind": "Method",
    "detail": "Function (} const_user_iterator)",
    "insertText": "user_begin()"
  },
  {
    "label": "user_end()",
    "kind": "Method",
    "detail": "Function (} user_iterator)",
    "insertText": "user_end()"
  },
  {
    "label": "user_back()",
    "kind": "Method",
    "detail": "Function (} User*)",
    "insertText": "user_back()"
  },
  {
    "label": "users()",
    "kind": "Method",
    "detail": "Function (} iterator_range<user_iterator>)",
    "insertText": "users()"
  },
  {
    "label": "hasOneUse()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasOneUse()"
  },
  {
    "label": "use_begin()",
    "kind": "Method",
    "detail": "Function (const_use_iterator I =)",
    "insertText": "use_begin(), E = use_end()"
  },
  {
    "label": "hasNUsesOrMore()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasNUsesOrMore(unsigned N)"
  },
  {
    "label": "isUsedInBasicBlock()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isUsedInBasicBlock(const BasicBlock *BB)"
  },
  {
    "label": "getNumUses()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getNumUses()"
  },
  {
    "label": "addUse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addUse(Use &U)"
  },
  {
    "label": "addToList()",
    "kind": "Method",
    "detail": "Function (U .)",
    "insertText": "addToList(&UseList)"
  },
  {
    "label": "HANDLE_VALUE()",
    "kind": "Method",
    "detail": "Function (} enum ValueTy { # define)",
    "insertText": "HANDLE_VALUE(Name) Name##Val, #include \"llvm/IR/Value.def\" #define HANDLE_CONSTANT_MARKER(Marker, Constant)"
  },
  {
    "label": "getValueID()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getValueID()"
  },
  {
    "label": "hasSameSubclassOptionalData()",
    "kind": "Method",
    "detail": "Function (SubclassOptionalData = 0 ; } bool)",
    "insertText": "hasSameSubclassOptionalData(const Value *V)"
  },
  {
    "label": "hasValueHandle()",
    "kind": "Method",
    "detail": "Function (SubclassOptionalData& = V -> SubclassOptionalData ; } bool)",
    "insertText": "hasValueHandle()"
  },
  {
    "label": "stripPointerCasts()",
    "kind": "Method",
    "detail": "Function (const Value*)",
    "insertText": "stripPointerCasts()"
  },
  {
    "label": "stripPointerCastsNoFollowAliases()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "stripPointerCastsNoFollowAliases()"
  },
  {
    "label": "stripInBoundsConstantOffsets()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "stripInBoundsConstantOffsets()"
  },
  {
    "label": "stripAndAccumulateInBoundsConstantOffsets()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL, APInt &Offset)"
  },
  {
    "label": "stripInBoundsOffsets()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "stripInBoundsOffsets()"
  },
  {
    "label": "DoPHITranslation()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "DoPHITranslation(const BasicBlock *CurBB, const BasicBlock *PredBB)"
  },
  {
    "label": "mutateType()",
    "kind": "Method",
    "detail": "Function (} const unsigned MaxAlignmentExponent = 2 9 ; const unsigned MaximumAlignment = 1 u<<MaxAlignmentExponent ; void)",
    "insertText": "mutateType(Type *Ty)"
  },
  {
    "label": "sortUseList()",
    "kind": "Method",
    "detail": "Function (VTy = Ty ; } template<class Compare> void)",
    "insertText": "sortUseList(Compare Cmp)"
  },
  {
    "label": "reverseUseList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reverseUseList()"
  },
  {
    "label": "mergeUseLists()",
    "kind": "Method",
    "detail": "Function (private : template<class Compare> Use*)",
    "insertText": "mergeUseLists(Use *L, Use *R, Compare Cmp)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Use* Merged ; Use** Next =& Merged ;)",
    "insertText": "while(true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* Next = R ; break ; })",
    "insertText": "if(!R)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* Next = L ; break ; })",
    "insertText": "if(Cmp(*R, *L))"
  },
  {
    "label": "getSubclassDataFromValue()",
    "kind": "Method",
    "detail": "Function (* Next = R ; Next =& R -> Next ; R = R -> Next ; } else {* Next = L ; Next =& L -> Next ; L = L -> Next ; } } return Merged ; } protected : unsigned short)",
    "insertText": "getSubclassDataFromValue()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (SubclassData = D ; } } ; raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const Value &V)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (V .)",
    "insertText": "print(OS)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Val = V ;)",
    "insertText": "if(V) V->addUse(*this)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const unsigned MaxSlots = 3 2 ; Use* Slots [ MaxSlots ] ; Use* Next = UseList -> Next ; UseList -> Next = nullptr ; unsigned NumSlots = 1 ; Slots [ 0 ] = UseList ;)",
    "insertText": "while(Next->Next)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Use* Current = Next ; Next = Current -> Next ; Current -> Next = nullptr ; unsigned I ;)",
    "insertText": "for(I = 0; I < NumSlots; ++I)"
  },
  {
    "label": "mergeUseLists()",
    "kind": "Method",
    "detail": "Function (Current =)",
    "insertText": "mergeUseLists(Slots[I], Current, Cmp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Slots [ I ] = nullptr ; })",
    "insertText": "if(I == NumSlots)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (+ + NumSlots ;)",
    "insertText": "assert(NumSlots <= MaxSlots && \"Use list bigger than 2^32\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} Slots [ I ] = Current ; })",
    "insertText": "assert(Next && \"Expected one more Use\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!Next->Next && \"Expected only one Use\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (UseList = Next ;)",
    "insertText": "for(unsigned I = 0; I < NumSlots; ++I) if (Slots[I]) UseList = mergeUseLists(Slots[I], UseList, Cmp)"
  },
  {
    "label": "setPrev()",
    "kind": "Method",
    "detail": "Function (I ->)",
    "insertText": "setPrev(Prev)"
  },
  {
    "label": "doit()",
    "kind": "Method",
    "detail": "Function (Prev =& I -> Next ; } } template<> struct isa_impl<Constant,Value> { bool)",
    "insertText": "doit(const Value &Val)"
  },
  {
    "label": "getAsVoidPointer()",
    "kind": "Method",
    "detail": "Function (} } ; template<> class PointerLikeTypeTraits<Value*> { typedef Value* PT ; public : void*)",
    "insertText": "getAsVoidPointer(PT P)"
  },
  {
    "label": "DEFINE_ISA_CONVERSION_FUNCTIONS()",
    "kind": "Method",
    "detail": "Function (} enum { NumLowBitsAvailable = 2 } ; } ;)",
    "insertText": "DEFINE_ISA_CONVERSION_FUNCTIONS(Value, LLVMValueRef) inline Value **unwrap(LLVMValueRef *Vals)"
  },
  {
    "label": "unwrap()",
    "kind": "Method",
    "detail": "Function (} template<T> T**)",
    "insertText": "unwrap(LLVMValueRef *Vals, unsigned Length)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# ifdef DEBUG)",
    "insertText": "for(LLVMValueRef *I = Vals, *E = Vals + Length; I != E; ++I) cast<T>(*I)"
  },
  {
    "label": "endif()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "endif(void)"
  },
  {
    "label": "wrap()",
    "kind": "Method",
    "detail": "Function (} LLVMValueRef*)",
    "insertText": "wrap(const Value **Vals)"
  }
]