[
  {
    "label": "FStack",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStack"
  },
  {
    "label": "LegacySortInternal()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Templates / IdentityFunctor . h \" # include \" Templates / Invoke . h \" # include \" Templates / Less . h \" # include \" Templates / UnrealTemplate . h \" namespace AlgoImpl { template<T,ProjectionType,PredicateType> void)",
    "insertText": "LegacySortInternal(T* First, int32 Num, ProjectionType Projection, PredicateType Predicate)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (struct FStack { T* Min ; T* Max ; } ;)",
    "insertText": "if(Num < 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Current =* StackTop ; Loop : PTRINT Count = Current . Max - Current . Min + 1 ;)",
    "insertText": "if(Count <= 8)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (T* Max,* Item ;)",
    "insertText": "for(Max=Current.Min, Item=Current.Min+1; Item<=Current.Max; Item++)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (Max = Item ; } })",
    "insertText": "Swap(*Max, *Current.Max--)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "Swap(Current.Min[Count/2], Current.Min[0])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Inner . Min = Current . Min ; Inner . Max = Current . Max + 1 ;)",
    "insertText": "for(; ;)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (break ; })",
    "insertText": "Swap(*Inner.Min, *Inner.Max)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Swap(*Current.Min, *Inner.Max)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StackTop -> Min = Current . Min ; StackTop -> Max = Inner . Max - 1 ; StackTop + + ; })",
    "insertText": "if(Current.Max>Inner.Min)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StackTop -> Min = Inner . Min ; StackTop -> Max = Current . Max ; StackTop + + ; })",
    "insertText": "if(Current.Min+1<Inner.Max)"
  },
  {
    "label": "LegacySort()",
    "kind": "Method",
    "detail": "Function (Current . Max = Inner . Max - 1 ; goto Loop ; } } } } } } namespace Algo { template<RangeType> void)",
    "insertText": "LegacySort(RangeType&& Range)"
  },
  {
    "label": "LegacySortInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LegacySortInternal(GetData(Range), GetNum(Range), FIdentityFunctor(), TLess<>())"
  },
  {
    "label": "LegacySort()",
    "kind": "Method",
    "detail": "Function (} template<RangeType,PredicateType> void)",
    "insertText": "LegacySort(RangeType&& Range, PredicateType Pred)"
  },
  {
    "label": "LegacySortInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LegacySortInternal(GetData(Range), GetNum(Range), FIdentityFunctor(), MoveTemp(Pred))"
  },
  {
    "label": "LegacySortBy()",
    "kind": "Method",
    "detail": "Function (} template<RangeType,ProjectionType> void)",
    "insertText": "LegacySortBy(RangeType&& Range, ProjectionType Proj)"
  },
  {
    "label": "LegacySortInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LegacySortInternal(GetData(Range), GetNum(Range), MoveTemp(Proj), TLess<>())"
  },
  {
    "label": "LegacySortBy()",
    "kind": "Method",
    "detail": "Function (} template<RangeType,ProjectionType,PredicateType> void)",
    "insertText": "LegacySortBy(RangeType&& Range, ProjectionType Proj, PredicateType Pred)"
  },
  {
    "label": "LegacySortInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LegacySortInternal(GetData(Range), GetNum(Range), MoveTemp(Proj), MoveTemp(Pred))"
  }
]