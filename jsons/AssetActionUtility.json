[
  {
    "label": "FAssetData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAssetData"
  },
  {
    "label": "FAssetActionSupportCondition",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAssetActionSupportCondition"
  },
  {
    "label": "BLUTILITY_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BLUTILITY_API"
  },
  {
    "label": "add",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "add"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" UObject / ObjectMacros . h \" # include \" EditorUtilityObject . h \" # include \" UObject / ScriptMacros . h \" # include \" IEditorUtilityExtension . h \" # include \" AssetActionUtility . generated . h \" namespace AssetActionUtilityTags { const FName BlutilityTagVersion ; const FName SupportedClasses ; const FName IsActionForBlueprint ; const FName CallableFunctions ; const FName SupportedConditions ; } struct FAssetData ;)",
    "insertText": "USTRUCT()"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, Category=Condition)"
  },
  {
    "label": "UCLASS()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "UCLASS(Abstract, hideCategories=(Object), Blueprintable)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() public: UE_DEPRECATED(5.2, \"GetSupportedClasses() instead, but ideally you're not requesting this directly and are instead using the FAssetActionUtilityPrototype to wrap access to an unload utility asset.\") UFUNCTION(BlueprintPure, BlueprintImplementableEvent, Category=\"Assets\", meta=(DeprecatedFunction, DeprecationMessage=\"If you were just returning a single class add it to the SupportedClasses array (you can find it listed in the Class Defaults). If you were doing complex logic to simulate having multiple classes act as filters, add them to the SupportedClasses array. If you were doing 'other' logic, you'll need to do that upon action execution.\")) UClass* GetSupportedClass()"
  }
]