[
  {
    "label": "ForwardIt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ForwardIt"
  },
  {
    "label": "PredicateType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PredicateType"
  },
  {
    "label": "FNoncopyable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNoncopyable"
  },
  {
    "label": "TGuardValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TGuardValue"
  },
  {
    "label": "TOptionalGuardValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TOptionalGuardValue"
  },
  {
    "label": "TGuardValue_Bitfield_Cleanup",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TGuardValue_Bitfield_Cleanup"
  },
  {
    "label": "TScopeCounter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TScopeCounter"
  },
  {
    "label": "TKeyValuePair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TKeyValuePair"
  },
  {
    "label": "TRemovePointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TRemovePointer"
  },
  {
    "label": "TRValueToLValueReference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TRValueToLValueReference"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TForceInitAtBoot",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TForceInitAtBoot"
  },
  {
    "label": "FNoopStruct",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNoopStruct"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (A . ~)",
    "insertText": "T()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)&A) T(B)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "Move(T& A,typename TMoveSupportTraits<T>::Move B)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)&A) T(MoveTemp(B))"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T)",
    "insertText": "UE_REQUIRES(TIsContiguousContainer<T>::Value) > constexpr auto GetData(T&& Container) -> decltype(Container.GetData())"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (} template<T,SIZE_T N> T*)",
    "insertText": "GetData(T (& Container)[N])"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T)",
    "insertText": "UE_REQUIRES(TIsContiguousContainer<T>::Value) > constexpr auto GetNum(T&& Container) -> decltype(Container.Num())"
  },
  {
    "label": "GetNum()",
    "kind": "Method",
    "detail": "Function (} template<T,SIZE_T N> SIZE_T)",
    "insertText": "GetNum(T (& Container)[N])"
  },
  {
    "label": "AsConst()",
    "kind": "Method",
    "detail": "Function (} template<T> const T&)",
    "insertText": "AsConst(T& Ref)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (template<T,SIZE_T N> const)",
    "insertText": "T(&AsConst(T (&Array)[N]))"
  },
  {
    "label": "OutType()",
    "kind": "Method",
    "detail": "Function (OutType Out = static_cast<)",
    "insertText": "OutType(In)"
  },
  {
    "label": "InType()",
    "kind": "Method",
    "detail": "Function (bool bRoundtrips = In = = static_cast<)",
    "insertText": "InType(Out)"
  },
  {
    "label": "IntCastChecked()",
    "kind": "Method",
    "detail": "Function (} else { return bRoundtrips ; } } template<OutType,InType> OutType)",
    "insertText": "IntCastChecked(InType In)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "checkf(IntFitsIn<OutType>(In), TEXT(\"Loss of data caused by narrowing conversion, In = %\" UINT64_FMT), (uint64)In)"
  },
  {
    "label": "FloatFitsIn()",
    "kind": "Method",
    "detail": "Function (} template<OutType,InType> bool)",
    "insertText": "FloatFitsIn(InType In, InType Precision)"
  },
  {
    "label": "FloatCastChecked()",
    "kind": "Method",
    "detail": "Function (} template<OutType,InType> OutType)",
    "insertText": "FloatCastChecked(InType In, InType Precision)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} # ifdef __clang__ template<T)",
    "insertText": "UE_REQUIRES(__is_array(T)) > auto UEArrayCountHelper(T& t) -> char(&)[sizeof(t) / sizeof(t[0])"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (# else template<T,uint32 N>)",
    "insertText": "char(&UEArrayCountHelper(const T (&)[N]))"
  },
  {
    "label": "UE_ARRAY_COUNT()",
    "kind": "Method",
    "detail": "Function (# endif # define)",
    "insertText": "UE_ARRAY_COUNT(array ) (sizeof(UEArrayCountHelper(array)) - 1) #ifdef __clang__ #define STRUCT_OFFSET( struc, member ) __builtin_offsetof(struc, member) #else #define STRUCT_OFFSET( struc, member ) offsetof(struc, member) #endif #if PLATFORM_VTABLE_AT_END_OF_CLASS #error need implementation #else #define VTABLE_OFFSET( Class, MultipleInheritenceParent ) ( ((PTRINT) static_cast<MultipleInheritenceParent*>((Class*)1)) - 1)"
  },
  {
    "label": "UE_FORCE_CONSTEVAL()",
    "kind": "Method",
    "detail": "Function (template<T,T Val> T TForceConstEval_V = Val ; } # define)",
    "insertText": "UE_FORCE_CONSTEVAL(expr) UE::Core::Private::TForceConstEval_V<std::decay_t<decltype(expr)>, (expr)> template<class ForwardIt> inline ForwardIt MinElement(ForwardIt First, ForwardIt Last)"
  },
  {
    "label": "MinElement()",
    "kind": "Method",
    "detail": "Function (Result = First ; } } return Result ; } template<class ForwardIt,class PredicateType> ForwardIt)",
    "insertText": "MinElement(ForwardIt First, ForwardIt Last, PredicateType Predicate)"
  },
  {
    "label": "MaxElement()",
    "kind": "Method",
    "detail": "Function (Result = First ; } } return Result ; } template<class ForwardIt> ForwardIt)",
    "insertText": "MaxElement(ForwardIt First, ForwardIt Last)"
  },
  {
    "label": "MaxElement()",
    "kind": "Method",
    "detail": "Function (Result = First ; } } return Result ; } template<class ForwardIt,class PredicateType> ForwardIt)",
    "insertText": "MaxElement(ForwardIt First, ForwardIt Last, PredicateType Predicate)"
  },
  {
    "label": "FNoncopyable()",
    "kind": "Method",
    "detail": "Function (Result = First ; } } return Result ; } class FNoncopyable { protected :)",
    "insertText": "FNoncopyable()"
  },
  {
    "label": "FNoncopyable()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "FNoncopyable(const FNoncopyable&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FNoncopyable&)",
    "insertText": "operator(const FNoncopyable&)"
  },
  {
    "label": "TGuardValue()",
    "kind": "Method",
    "detail": "Function (} ; template<RefType,AssignedType = RefType> struct TGuardValue : private FNoncopyable { [ [ nodiscard ] ])",
    "insertText": "TGuardValue(RefType& ReferenceValue, const AssignedType& NewValue) : RefValue(ReferenceValue), OriginalValue(ReferenceValue)"
  },
  {
    "label": "TGuardValue()",
    "kind": "Method",
    "detail": "Function (RefValue = NewValue ; } ~)",
    "insertText": "TGuardValue()"
  },
  {
    "label": "TOptionalGuardValue()",
    "kind": "Method",
    "detail": "Function (RefValue = NewValue ; } } ~)",
    "insertText": "TOptionalGuardValue()"
  },
  {
    "label": "TGuardValue_Bitfield_Cleanup()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "TGuardValue_Bitfield_Cleanup()"
  },
  {
    "label": "Func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Func()"
  },
  {
    "label": "FGuardValue_Bitfield()",
    "kind": "Method",
    "detail": "Function (} private : FuncType Func ; } ; # define)",
    "insertText": "FGuardValue_Bitfield(ReferenceValue, NewValue) \\ const bool PREPROCESSOR_JOIN(TempBitfield, __LINE__)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (\\ ReferenceValue = NewValue ; \\ const TGuardValue_Bitfield_Cleanup<TFunction<)",
    "insertText": "void()>> PREPROCESSOR_JOIN(TempBitfieldCleanup, __LINE__)([&](){ ReferenceValue = PREPROCESSOR_JOIN(TempBitfield, __LINE__); })"
  },
  {
    "label": "TScopeCounter()",
    "kind": "Method",
    "detail": "Function (template<Type> struct TScopeCounter : private FNoncopyable { [ [ nodiscard ] ])",
    "insertText": "TScopeCounter(Type& ReferenceValue) : RefValue(ReferenceValue)"
  },
  {
    "label": "TScopeCounter()",
    "kind": "Method",
    "detail": "Function (+ + RefValue ; } ~)",
    "insertText": "TScopeCounter()"
  },
  {
    "label": "TKeyValuePair()",
    "kind": "Method",
    "detail": "Function (- - RefValue ; } private : Type& RefValue ; } ; template<KeyType,ValueType> struct TKeyValuePair {)",
    "insertText": "TKeyValuePair(const KeyType& InKey, const ValueType& InValue ) : Key(InKey), Value(InValue)"
  },
  {
    "label": "TKeyValuePair()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TKeyValuePair(const KeyType& InKey ) : Key(InKey)"
  },
  {
    "label": "TKeyValuePair()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TKeyValuePair()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const TKeyValuePair& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (typedef T Type ; } ; template<T> struct TRemovePointer<T*> { typedef T Type ; } ; template<T> UE_INTRINSIC_CAST std::remove_reference_t<T>&&)",
    "insertText": "MoveTemp(T&& Obj)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using CastType = std::remove_reference_t<T> ;)",
    "insertText": "static_assert(std::is_lvalue_reference_v<T>, \"MoveTemp called on an rvalue\")"
  },
  {
    "label": "MoveTempIfPossible()",
    "kind": "Method",
    "detail": "Function (} template<T> UE_INTRINSIC_CAST std::remove_reference_t<T>&&)",
    "insertText": "MoveTempIfPossible(T&& Obj)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (using CastType = std::remove_reference_t<T> ;)",
    "insertText": "return(CastType&&)"
  },
  {
    "label": "CopyTemp()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "CopyTemp(T& Val)"
  },
  {
    "label": "CopyTemp()",
    "kind": "Method",
    "detail": "Function (} template<T> T)",
    "insertText": "CopyTemp(const T& Val)"
  },
  {
    "label": "Forward()",
    "kind": "Method",
    "detail": "Function (} template<T> UE_INTRINSIC_CAST T&&)",
    "insertText": "Forward(std::remove_reference_t<T>& Obj)"
  },
  {
    "label": "Forward()",
    "kind": "Method",
    "detail": "Function (} template<T> UE_INTRINSIC_CAST T&&)",
    "insertText": "Forward(std::remove_reference_t<T>&& Obj)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "Swap(T& A, T& B)"
  },
  {
    "label": "Temp()",
    "kind": "Method",
    "detail": "Function (TTypeCompatibleBytes<T>)",
    "insertText": "Temp(TTypeCompatibleBytes<T>*)&Temp = *(TTypeCompatibleBytes<T>*)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (} else { T Temp =)",
    "insertText": "MoveTemp(A)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (A =)",
    "insertText": "MoveTemp(B)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (B =)",
    "insertText": "MoveTemp(Temp)"
  },
  {
    "label": "Exchange()",
    "kind": "Method",
    "detail": "Function (} } template<T> void)",
    "insertText": "Exchange(T& A, T& B)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(A, B)"
  },
  {
    "label": "StaticCast()",
    "kind": "Method",
    "detail": "Function (} template<T,ArgType> T)",
    "insertText": "StaticCast(ArgType&& Arg)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T> struct TRValueToLValueReference { typedef T Type ; } ; template<T> struct TRValueToLValueReference<T&&> { typedef T& Type ; } ; template<T)",
    "insertText": "UE_REQUIRES(std::is_same_v<T, uint32>) > FORCEINLINE T ReverseBits( T Bits)"
  },
  {
    "label": "Bits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Bits(Bits << 16) | ( Bits >> 16)"
  },
  {
    "label": "Bits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Bits((Bits & 0x00ff00ff) << 8 ) | ( (Bits & 0xff00ff00) >> 8)"
  },
  {
    "label": "Bits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Bits((Bits & 0x0f0f0f0f) << 4 ) | ( (Bits & 0xf0f0f0f0) >> 4)"
  },
  {
    "label": "Bits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Bits((Bits & 0x33333333) << 2 ) | ( (Bits & 0xcccccccc) >> 2)"
  },
  {
    "label": "Bits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Bits((Bits & 0x55555555) << 1 ) | ( (Bits & 0xaaaaaaaa) >> 1)"
  },
  {
    "label": "uint64()",
    "kind": "Method",
    "detail": "Function (template<> uint64 BitMask<)",
    "insertText": "uint64(uint32 Count)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (} template<> uint32 BitMask<)",
    "insertText": "uint32(uint32 Count)"
  },
  {
    "label": "uint16()",
    "kind": "Method",
    "detail": "Function (} template<> uint16 BitMask<)",
    "insertText": "uint16(uint32 Count)"
  },
  {
    "label": "uint8()",
    "kind": "Method",
    "detail": "Function (} template<> uint8 BitMask<)",
    "insertText": "uint8(uint32 Count)"
  },
  {
    "label": "TForceInitAtBoot()",
    "kind": "Method",
    "detail": "Function (} template<class T> struct TForceInitAtBoot {)",
    "insertText": "TForceInitAtBoot()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Get()"
  },
  {
    "label": "FNoopStruct()",
    "kind": "Method",
    "detail": "Function (} } ; struct FNoopStruct {)",
    "insertText": "FNoopStruct()"
  },
  {
    "label": "DeclVal()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> T&&)",
    "insertText": "DeclVal()"
  },
  {
    "label": "ImplicitConv()",
    "kind": "Method",
    "detail": "Function (template<T> T)",
    "insertText": "ImplicitConv(typename TIdentity<T>::Type Obj)"
  },
  {
    "label": "UE_REQUIRES()",
    "kind": "Method",
    "detail": "Function (} template<T,Base)",
    "insertText": "UE_REQUIRES(std::is_convertible_v<std::remove_reference_t<T>*, const volatile Base*>) > UE_INTRINSIC_CAST FORCEINLINE decltype(auto) ForwardAsBase(std::remove_reference_t<T>&& Obj)"
  }
]