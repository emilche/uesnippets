[
  {
    "label": "TileData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TileData"
  },
  {
    "label": "FindActiveValues",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FindActiveValues"
  },
  {
    "label": "RootChild",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RootChild"
  },
  {
    "label": "anyActiveValues()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TOOLS_FINDACTIVEVALUES_HAS_BEEN_INCLUDED # define OPENVDB_TOOLS_FINDACTIVEVALUES_HAS_BEEN_INCLUDED # include<vector> # include<openvdb / version . h> # include<openvdb / Types . h> # include<openvdb / tree / ValueAccessor . h> # include \" Count . h \" # include<tbb / blocked_range . h> # include<tbb / parallel_for . h> # include<tbb / parallel_reduce . h> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tools { template<ValueType> struct TileData ; template<TreeT> bool)",
    "insertText": "anyActiveValues(const TreeT& tree, const CoordBBox &bbox)"
  },
  {
    "label": "anyActiveVoxels()",
    "kind": "Method",
    "detail": "Function (template<TreeT> bool)",
    "insertText": "anyActiveVoxels(const TreeT& tree, const CoordBBox &bbox)"
  },
  {
    "label": "anyActiveTiles()",
    "kind": "Method",
    "detail": "Function (template<TreeT> bool)",
    "insertText": "anyActiveTiles(const TreeT& tree, const CoordBBox &bbox)"
  },
  {
    "label": "noActiveValues()",
    "kind": "Method",
    "detail": "Function (template<TreeT> bool)",
    "insertText": "noActiveValues(const TreeT& tree, const CoordBBox &bbox)"
  },
  {
    "label": "countActiveValues()",
    "kind": "Method",
    "detail": "Function (template<TreeT> Index64)",
    "insertText": "countActiveValues(const TreeT& tree, const CoordBBox &bbox)"
  },
  {
    "label": "activeTiles()",
    "kind": "Method",
    "detail": "Function (template<TreeT> std::vector<TileData<TreeT::ValueType>>)",
    "insertText": "activeTiles(const TreeT& tree, const CoordBBox &bbox)"
  },
  {
    "label": "FindActiveValues()",
    "kind": "Method",
    "detail": "Function (template<TreeT> class FindActiveValues { public : using TileDataT = TileData<TreeT::ValueType> ;)",
    "insertText": "FindActiveValues(const TreeT& tree)"
  },
  {
    "label": "FindActiveValues()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FindActiveValues()"
  },
  {
    "label": "update()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "update(const TreeT& tree)"
  },
  {
    "label": "anyActiveValues()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "anyActiveValues(const CoordBBox &bbox, bool useAccessor = false)"
  },
  {
    "label": "anyActiveVoxels()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "anyActiveVoxels(const CoordBBox &bbox)"
  },
  {
    "label": "anyActiveTiles()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "anyActiveTiles(const CoordBBox &bbox)"
  },
  {
    "label": "noActiveValues()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "noActiveValues(const CoordBBox &bbox, bool useAccessor = false)"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (} Index64)",
    "insertText": "count(const CoordBBox &bbox)"
  },
  {
    "label": "activeTiles()",
    "kind": "Method",
    "detail": "Function (std::vector<TileDataT>)",
    "insertText": "activeTiles(const CoordBBox &bbox)"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Use anyActiveValues() instead\") inline bool any(const CoordBBox &bbox, bool useAccessor = false)"
  },
  {
    "label": "OPENVDB_DEPRECATED_MESSAGE()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "OPENVDB_DEPRECATED_MESSAGE(\"Use noActiveValues() instead\") inline bool none(const CoordBBox &bbox, bool useAccessor = false)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "clear()"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init(const TreeT &tree)"
  },
  {
    "label": "getBBoxMask()",
    "kind": "Method",
    "detail": "Function (template<NodeT> NodeT::NodeMaskType)",
    "insertText": "getBBoxMask(const CoordBBox &bbox, const NodeT* node)"
  },
  {
    "label": "anyActiveValues()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "anyActiveValues(const typename TreeT::LeafNodeType* leaf, const CoordBBox &bbox)"
  },
  {
    "label": "anyActiveVoxels()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "anyActiveVoxels(const typename TreeT::LeafNodeType* leaf, const CoordBBox &bbox)"
  },
  {
    "label": "anyActiveTiles()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "anyActiveTiles(const typename TreeT::LeafNodeType*, const CoordBBox&)"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (; } Index64)",
    "insertText": "count(const typename TreeT::LeafNodeType* leaf, const CoordBBox &bbox)"
  },
  {
    "label": "anyActiveValues()",
    "kind": "Method",
    "detail": "Function (template<NodeT> bool)",
    "insertText": "anyActiveValues(const NodeT* node, const CoordBBox &bbox)"
  },
  {
    "label": "anyActiveVoxels()",
    "kind": "Method",
    "detail": "Function (template<NodeT> bool)",
    "insertText": "anyActiveVoxels(const NodeT* node, const CoordBBox &bbox)"
  },
  {
    "label": "anyActiveTiles()",
    "kind": "Method",
    "detail": "Function (template<NodeT> bool)",
    "insertText": "anyActiveTiles(const NodeT* node, const CoordBBox &bbox)"
  },
  {
    "label": "activeTiles()",
    "kind": "Method",
    "detail": "Function (template<NodeT> void)",
    "insertText": "activeTiles(const NodeT* node, const CoordBBox &bbox, std::vector<TileDataT> &tiles)"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (template<NodeT> Index64)",
    "insertText": "count(const NodeT* node, const CoordBBox &bbox)"
  },
  {
    "label": "FindActiveValues()",
    "kind": "Method",
    "detail": "Function (using AccT = tree::ValueAccessor<const TreeT,false> ; using RootChildType = TreeT::RootNodeType::ChildNodeType ; struct RootChild ; AccT mAcc ; std::vector<TileDataT> mRootTiles ; std::vector<RootChild> mRootNodes ; } ; template<TreeT> FindActiveValues<TreeT)",
    "insertText": "FindActiveValues(const TreeT& tree) : mAcc(tree), mRootTiles(), mRootNodes()"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "init(tree)"
  },
  {
    "label": "AccT()",
    "kind": "Method",
    "detail": "Function (mAcc =)",
    "insertText": "AccT(tree)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} template<TreeT> void FindActiveValues<TreeT)",
    "insertText": "init(const TreeT& tree)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (const auto& root = tree .)",
    "insertText": "root()"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (mRootNodes .)",
    "insertText": "emplace_back(i.getCoord(), &*i)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(auto i = root.cbeginValueOn(); i; ++i)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (mRootTiles .)",
    "insertText": "emplace_back(root, i.getCoord(), *i)"
  },
  {
    "label": "anyActiveValues()",
    "kind": "Method",
    "detail": "Function (} } template<TreeT> bool FindActiveValues<TreeT)",
    "insertText": "anyActiveValues(const CoordBBox &bbox, bool useAccessor)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(mAcc.tree().isValueOn( (bbox.min() + bbox.max())>>1 ))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(auto& tile : mRootTiles)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(auto& node : mRootNodes)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } else)",
    "insertText": "if(node.bbox.isInside(bbox))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->anyActiveValues(node.child, bbox))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->anyActiveVoxels(node.child, bbox))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->anyActiveTiles(node.child, bbox))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; } else)",
    "insertText": "if(tile.bbox.isInside(bbox))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(bbox.isInside(tile.bbox))"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (count + = RootChildType::NUM_VOXELS ; } else { auto tmp = tile . bbox ; tmp .)",
    "insertText": "intersect(bbox)"
  },
  {
    "label": "volume()",
    "kind": "Method",
    "detail": "Function (count + = tmp .)",
    "insertText": "volume()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(auto &node : mRootNodes)"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (} else { count + = this ->)",
    "insertText": "count(node.child, bbox)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (tiles .)",
    "insertText": "emplace_back(bbox, tile.value, tile.level)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (tiles .)",
    "insertText": "push_back(tile)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (tiles .)",
    "insertText": "emplace_back(tmp, tile.value, tile.level)"
  },
  {
    "label": "activeTiles()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "activeTiles(node.child, bbox, tiles)"
  },
  {
    "label": "getNodeBoundingBox()",
    "kind": "Method",
    "detail": "Function (NodeT::NodeMaskType mask ; auto b = node ->)",
    "insertText": "getNodeBoundingBox()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(bbox.hasOverlap(b))"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "setOn()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (b .)",
    "insertText": "min()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (b .)",
    "insertText": "max()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(b.hasVolume())"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (auto it = b .)",
    "insertText": "begin()"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "setOn(ijk[2] + (ijk[1] << NodeT::LOG2DIM) + (ijk[0] << 2*NodeT::LOG2DIM))"
  },
  {
    "label": "getBBoxMask()",
    "kind": "Method",
    "detail": "Function (auto mask = this ->)",
    "insertText": "getBBoxMask(bbox, node)"
  },
  {
    "label": "getValueMask()",
    "kind": "Method",
    "detail": "Function (const auto tmp = mask& node ->)",
    "insertText": "getValueMask()"
  },
  {
    "label": "getChildMask()",
    "kind": "Method",
    "detail": "Function (mask& = node ->)",
    "insertText": "getChildMask()"
  },
  {
    "label": "getTable()",
    "kind": "Method",
    "detail": "Function (const auto* table = node ->)",
    "insertText": "getTable()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool active = false ;)",
    "insertText": "for(auto i = mask.beginOn(); !active && i; ++i)"
  },
  {
    "label": "anyActiveValues()",
    "kind": "Method",
    "detail": "Function (active = this ->)",
    "insertText": "anyActiveValues(table[i.pos()].getChild(), bbox)"
  },
  {
    "label": "anyActiveVoxels()",
    "kind": "Method",
    "detail": "Function (active = this ->)",
    "insertText": "anyActiveVoxels(table[i.pos()].getChild(), bbox)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool active = false ;)",
    "insertText": "for(auto i = leaf->cbeginValueOn(); !active && i; ++i)"
  },
  {
    "label": "isInside()",
    "kind": "Method",
    "detail": "Function (active = bbox .)",
    "insertText": "isInside(i.getCoord())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool active = false ;)",
    "insertText": "if(NodeT::LEVEL>1)"
  },
  {
    "label": "anyActiveTiles()",
    "kind": "Method",
    "detail": "Function (active = this ->)",
    "insertText": "anyActiveTiles(table[i.pos()].getChild(), bbox)"
  },
  {
    "label": "onVoxelCount()",
    "kind": "Method",
    "detail": "Function (count = leaf ->)",
    "insertText": "onVoxelCount()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(leaf->isDense())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(b.hasOverlap(bbox))"
  },
  {
    "label": "childNodes()",
    "kind": "Method",
    "detail": "Function ({ using ChildT = NodeT::ChildNodeType ; using RangeT = tbb::blocked_range<std::vector<const ChildT*>::iterator> ; std::vector<const ChildT*>)",
    "insertText": "childNodes(childMask.countOn())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int j = 0 ;)",
    "insertText": "for(auto i = childMask.beginOn(); i; ++i, ++j) childNodes[j] = table[i.pos()].getChild()"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (count + =)",
    "insertText": "parallel_reduce(RangeT(childNodes.begin(), childNodes.end()), 0, [&](const RangeT& r, Index64 sum)->Index64 { for ( auto i = r.begin(); i != r.end(); ++i ) sum += this->count(*i, bbox); return sum; }, []( Index64 a, Index64 b )->Index64 { return a+b; })"
  },
  {
    "label": "coords()",
    "kind": "Method",
    "detail": "Function (} { std::vector<Coord>)",
    "insertText": "coords(mask.countOn())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (using RangeT = tbb::blocked_range<std::vector<Coord>::iterator> ; int j = 0 ;)",
    "insertText": "for(auto i = mask.beginOn(); i; ++i, ++j) coords[j] = node->offsetToGlobalCoord(i.pos())"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (count + =)",
    "insertText": "parallel_reduce(RangeT(coords.begin(), coords.end()), 0, [&bbox](const RangeT& r, Index64 sum)->Index64 { for ( auto i = r.begin(); i != r.end(); ++i ) { auto b = CoordBBox::createCube(*i, NodeT::ChildNodeType::DIM); b.intersect(bbox); sum += b.volume(); } return sum; }, []( Index64 a, Index64 b )->Index64 { return a+b; })"
  },
  {
    "label": "countOn()",
    "kind": "Method",
    "detail": "Function (} const size_t tileCount = mask .)",
    "insertText": "countOn()"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (tiles .)",
    "insertText": "emplace_back(*node, iter.pos())"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (tiles .)",
    "insertText": "back().bbox.intersect(bbox)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (} } else { std::vector<TileDataT>)",
    "insertText": "tmp(tileCount)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int n = 0 ;)",
    "insertText": "for(auto iter = mask.beginOn(); iter; ++iter) tmp[n++].level = iter.pos()"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, tileCount, 8), [&](const tbb::blocked_range<size_t>& r) { for ( size_t i = r.begin(); i != r.end(); ++i ) { tmp[i] = TileDataT(*node, tmp[i].level); tmp[i].bbox.intersect(bbox); } })"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (tiles .)",
    "insertText": "insert(tiles.end(), tmp.begin(), tmp.end())"
  },
  {
    "label": "RootChild()",
    "kind": "Method",
    "detail": "Function (} } template<TreeT> struct FindActiveValues<TreeT>::RootChild { const CoordBBox bbox ; const RootChildType* child ;)",
    "insertText": "RootChild(const Coord& ijk = Coord(), const RootChildType* ptr = nullptr) : bbox(CoordBBox::createCube(ijk, RootChildType::DIM)), child(ptr)"
  },
  {
    "label": "TileData()",
    "kind": "Method",
    "detail": "Function (} } ; template<ValueType> struct TileData { CoordBBox bbox ; ValueType value ; Index level ; bool state ;)",
    "insertText": "TileData()"
  },
  {
    "label": "TileData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TileData(const CoordBBox &b, const ValueType &v, Index l, bool active = true) : bbox(b), value(v), level(l), state(active)"
  },
  {
    "label": "TileData()",
    "kind": "Method",
    "detail": "Function (} template<ParentNodeT>)",
    "insertText": "TileData(const ParentNodeT &parent, Index childIdx) : bbox(CoordBBox::createCube(parent.offsetToGlobalCoord(childIdx), parent.getChildDim())) , level(parent.getLevel()) , state(true)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(childIdx < ParentNodeT::NUM_VALUES)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(parent.isChildMaskOff(childIdx))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(parent.isValueMaskOn(childIdx))"
  },
  {
    "label": "getTable()",
    "kind": "Method",
    "detail": "Function (value = parent .)",
    "insertText": "getTable()[childIdx].getValue()"
  },
  {
    "label": "TileData()",
    "kind": "Method",
    "detail": "Function (} template<ParentNodeT>)",
    "insertText": "TileData(const ParentNodeT &parent, const Coord &ijk, const ValueType &v) : bbox(CoordBBox::createCube(ijk, parent.getChildDim())) , value(v) , level(parent.getLevel()) , state(true)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (FindActiveValues<TreeT>)",
    "insertText": "op(tree)"
  }
]