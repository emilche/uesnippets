[
  {
    "label": "TMathUtilConstants",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TMathUtilConstants"
  },
  {
    "label": "TMathUtil",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMathUtil"
  },
  {
    "label": "SafeLargeValue()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" GeometryBase . h \" # include \" HAL / Platform . h \" # include \" EngineDefines . h \" # include<cmath> # include<cfloat> template<RealType> struct TMathUtilConstants ; template<> struct TMathUtilConstants<float> { float Epsilon = FLT_EPSILON ; float ZeroTolerance = 1 e - 0 6 f ; float MaxReal = FLT_MAX ; float SafeLargeValue = UE_LARGE_WORLD_MAX ; float Pi = 3 . 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 2 6 4 3 3 8 3 2 7 9 5 f ; float FourPi = 4 . 0 f* Pi ; float TwoPi = 2 . 0 f* Pi ; float HalfPi = 0 . 5 f* Pi ; float InvPi = 1 . 0 f / Pi ; float InvTwoPi = 1 . 0 f / TwoPi ; float DegToRad = Pi / 1 8 0 . 0 f ; float RadToDeg = 1 8 0 . 0 f / Pi ; float Sqrt2 = 1 . 4 1 4 2 1 3 5 6 2 3 7 3 0 9 5 0 4 8 8 0 1 6 8 8 7 2 4 2 0 9 7 f ; float InvSqrt2 = 1 . 0 f / Sqrt2 ; float Sqrt3 = 1 . 7 3 2 0 5 0 8 0 7 5 6 8 8 7 7 2 9 3 5 2 7 4 4 6 3 4 1 5 0 5 9 f ; float InvSqrt3 = 1 . 0 f / Sqrt3 ; } ; template<> struct TMathUtilConstants<double> { double Epsilon = DBL_EPSILON ; double ZeroTolerance = 1 e - 0 8 ; double MaxReal = DBL_MAX ; double)",
    "insertText": "SafeLargeValue(double)"
  },
  {
    "label": "IsNaN()",
    "kind": "Method",
    "detail": "Function (double Pi = 3 . 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 2 6 4 3 3 8 3 2 7 9 5 ; double FourPi = 4 . 0* Pi ; double TwoPi = 2 . 0* Pi ; double HalfPi = 0 . 5* Pi ; double InvPi = 1 . 0 / Pi ; double InvTwoPi = 1 . 0 / TwoPi ; double DegToRad = Pi / 1 8 0 . 0 ; double RadToDeg = 1 8 0 . 0 / Pi ; double Sqrt2 = 1 . 4 1 4 2 1 3 5 6 2 3 7 3 0 9 5 0 4 8 8 0 1 6 8 8 7 2 4 2 0 9 7 ; double InvSqrt2 = 1 . 0 / Sqrt2 ; double Sqrt3 = 1 . 7 3 2 0 5 0 8 0 7 5 6 8 8 7 7 2 9 3 5 2 7 4 4 6 3 4 1 5 0 5 9 ; double InvSqrt3 = 1 . 0 / Sqrt3 ; } ; template<> struct TMathUtilConstants<int32> { int32 Epsilon = 0 ; int32 ZeroTolerance = 0 ; int32 MaxReal = MAX_int32 ; int32 SafeLargeValue = MAX_int32 / 2 ; int32 Pi = 3 ; int32 FourPi = 4* Pi ; int32 TwoPi = 2* Pi ; int32 HalfPi = 1 ; int32 InvPi = 1 ; int32 InvTwoPi = 1 ; int32 DegToRad = 1 ; int32 RadToDeg = 1 ; int32 Sqrt2 = 1 ; int32 InvSqrt2 = 1 ; int32 Sqrt3 = 2 ; int32 InvSqrt3 = 1 ; } ; template<> struct TMathUtilConstants<int64> { int64 Epsilon = 0 ; int64 ZeroTolerance = 0 ; int64 MaxReal = MAX_int64 ; int64 SafeLargeValue = MAX_int64 / 2 ; int64 Pi = 3 ; int64 FourPi = 4* Pi ; int64 TwoPi = 2* Pi ; int64 HalfPi = 1 ; int64 InvPi = 1 ; int64 InvTwoPi = 1 ; int64 DegToRad = 1 ; int64 RadToDeg = 1 ; int64 Sqrt2 = 1 ; int64 InvSqrt2 = 1 ; int64 Sqrt3 = 2 ; int64 InvSqrt3 = 1 ; } ; template<RealType> class TMathUtil : public TMathUtilConstants<RealType> { public : bool)",
    "insertText": "IsNaN(const RealType Value)"
  },
  {
    "label": "IsFinite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFinite(const RealType Value)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Abs(const RealType Value)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Clamp(const RealType Value, const RealType ClampMin, const RealType ClampMax)"
  },
  {
    "label": "Sign()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Sign(const RealType Value)"
  },
  {
    "label": "SignAsInt()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "SignAsInt(const RealType Value)"
  },
  {
    "label": "SignNonZero()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "SignNonZero(const RealType Value)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Max(const RealType A, const RealType B)"
  },
  {
    "label": "Max3()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Max3(const RealType A, const RealType B, const RealType C)"
  },
  {
    "label": "Max3Index()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Max3Index(const RealType A, const RealType B, const RealType C)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Min(const RealType A, const RealType B)"
  },
  {
    "label": "Min3()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Min3(const RealType A, const RealType B, const RealType C)"
  },
  {
    "label": "Min3Index()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Min3Index(const RealType A, const RealType B, const RealType C)"
  },
  {
    "label": "MinMax()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MinMax(RealType A, RealType B, RealType C, RealType& MinOut, RealType& MaxOut)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Sqrt(const RealType Value)"
  },
  {
    "label": "Cbrt()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Cbrt(const RealType Value)"
  },
  {
    "label": "Tan()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Tan(const RealType Value)"
  },
  {
    "label": "Atan2()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Atan2(const RealType ValueY, const RealType ValueX)"
  },
  {
    "label": "Sin()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Sin(const RealType Value)"
  },
  {
    "label": "Cos()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Cos(const RealType Value)"
  },
  {
    "label": "ACos()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "ACos(const RealType Value)"
  },
  {
    "label": "Floor()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Floor(const RealType Value)"
  },
  {
    "label": "Ceil()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Ceil(const RealType Value)"
  },
  {
    "label": "Round()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Round(const RealType Value)"
  },
  {
    "label": "Pow()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Pow(const RealType Value, const RealType Power)"
  },
  {
    "label": "Exp()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Exp(const RealType Power)"
  },
  {
    "label": "Log()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Log(const RealType Value)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Lerp(const RealType A, const RealType B, RealType Alpha)"
  },
  {
    "label": "Atan2Positive()",
    "kind": "Method",
    "detail": "Function (RealType)",
    "insertText": "Atan2Positive(const RealType Y, const RealType X)"
  },
  {
    "label": "TMathUtil()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "TMathUtil()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(B >= C)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(B <= C)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MinOut = A ; MaxOut = TMathUtil<RealType)",
    "insertText": "Max(B, C)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { MinOut = C ; MaxOut = B ; } } else {)",
    "insertText": "if(A > C)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (MaxOut = A ; MinOut = TMathUtil<RealType)",
    "insertText": "Min(B, C)"
  },
  {
    "label": "Log()",
    "kind": "Method",
    "detail": "Function (} template<RealType> RealType TMathUtil<RealType)",
    "insertText": "Log(const RealType Power)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (Alpha =)",
    "insertText": "Clamp(Alpha, (RealType)0, (RealType)1)"
  },
  {
    "label": "Atan2()",
    "kind": "Method",
    "detail": "Function (RealType Theta = TMathUtil<RealType)",
    "insertText": "Atan2(Y, X)"
  }
]