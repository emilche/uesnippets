[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "HbrHalfedge",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrHalfedge"
  },
  {
    "label": "HbrHalfedgeCompare",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrHalfedgeCompare"
  },
  {
    "label": "HbrVertex",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrVertex"
  },
  {
    "label": "HbrVertexOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrVertexOperator"
  },
  {
    "label": "HbrFaceOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrFaceOperator"
  },
  {
    "label": "HbrHalfedgeOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrHalfedgeOperator"
  },
  {
    "label": "Mask",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Mask"
  },
  {
    "label": "ParentType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ParentType"
  },
  {
    "label": "morefvardata",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "morefvardata"
  },
  {
    "label": "adaptiveFlags",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "adaptiveFlags"
  },
  {
    "label": "HbrVertex()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENSUBDIV3_HBRVERTEX_H # define OPENSUBDIV3_HBRVERTEX_H # include<assert . h> # include<iostream> # include<iterator> # include<vector> # include \" . . / hbr / fvarData . h \" # include \" . . / hbr / face . h \" # include \" . . / version . h \" namespace OpenSubdiv { namespace OPENSUBDIV_VERSION { template<class T> class HbrHalfedge ; template<class T> class HbrHalfedgeCompare ; template<class T> class HbrVertex ; template<class T> class HbrVertexOperator ; template<class T> class HbrFaceOperator ; template<class T> class HbrHalfedgeOperator ; template<class T> class HbrVertex { public :)",
    "insertText": "HbrVertex()"
  },
  {
    "label": "HbrVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HbrVertex(int vid, const T &data, int fvarwidth)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize(vid, data, fvarwidth)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Initialize(int vid, const T &data, int fvarwidth)"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy(HbrMesh<T> *mesh = 0)"
  },
  {
    "label": "AddIncidentEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddIncidentEdge(HbrHalfedge<T>* edge)"
  },
  {
    "label": "RemoveIncidentEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveIncidentEdge(HbrHalfedge<T>* edge)"
  },
  {
    "label": "EdgeRemovalWillMakeSingular()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EdgeRemovalWillMakeSingular(HbrHalfedge<T>* edge)"
  },
  {
    "label": "Finish()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Finish()"
  },
  {
    "label": "GetValence()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetValence()"
  },
  {
    "label": "GetCoarseValence()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetCoarseValence()"
  },
  {
    "label": "GetID()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetID()"
  },
  {
    "label": "NewFVarData()",
    "kind": "Method",
    "detail": "Function (HbrFVarData<T>&)",
    "insertText": "NewFVarData(const HbrFace<T>* face)"
  },
  {
    "label": "GetFace()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>*)",
    "insertText": "GetFace()"
  },
  {
    "label": "GetMesh()",
    "kind": "Method",
    "detail": "Function (HbrMesh<T>*)",
    "insertText": "GetMesh()"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>*)",
    "insertText": "GetEdge(const HbrVertex<T>* dest)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>*)",
    "insertText": "GetEdge(int dest)"
  },
  {
    "label": "GetNextEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>*)",
    "insertText": "GetNextEdge(const HbrHalfedge<T>* edge)"
  },
  {
    "label": "GetPreviousEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>*)",
    "insertText": "GetPreviousEdge(const HbrHalfedge<T>* edge)"
  },
  {
    "label": "GetQEONext()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "GetQEONext(const HbrVertex<T>* dest)"
  },
  {
    "label": "GetQEONext()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "GetQEONext(const HbrHalfedge<T>* edge)"
  },
  {
    "label": "GetQEOPrev()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "GetQEOPrev(const HbrHalfedge<T>* edge)"
  },
  {
    "label": "GetQEOPrev()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "GetQEOPrev(const HbrVertex<T>* dest)"
  },
  {
    "label": "GetQELNext()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "GetQELNext(const HbrVertex<T>* dest)"
  },
  {
    "label": "OnBoundary()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OnBoundary()"
  },
  {
    "label": "IsFVarSmooth()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFVarSmooth(int datum)"
  },
  {
    "label": "IsFVarAllSmooth()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFVarAllSmooth()"
  },
  {
    "label": "IsFVarDart()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFVarDart(int datum)"
  },
  {
    "label": "IsFVarCorner()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFVarCorner(int datum)"
  },
  {
    "label": "GetSharpness()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetSharpness()"
  },
  {
    "label": "ClearMask()",
    "kind": "Method",
    "detail": "Function (sharpness = sharp ;)",
    "insertText": "ClearMask()"
  },
  {
    "label": "IsSharp()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSharp(bool next)"
  },
  {
    "label": "GetMask()",
    "kind": "Method",
    "detail": "Function (mask0 = mask1 = 0 ; validmask = 0 ; volatil = 0 ; } unsigned char)",
    "insertText": "GetMask(bool next)"
  },
  {
    "label": "GetFVarMask()",
    "kind": "Method",
    "detail": "Function (unsigned char)",
    "insertText": "GetFVarMask(int datum)"
  },
  {
    "label": "GetFractionalMask()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetFractionalMask()"
  },
  {
    "label": "IsSingular()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSingular()"
  },
  {
    "label": "ApplyOperatorSurroundingEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyOperatorSurroundingEdges(HbrHalfedgeOperator<T> &op)"
  },
  {
    "label": "GetSurroundingVertices()",
    "kind": "Method",
    "detail": "Function (template<OutputIterator> void)",
    "insertText": "GetSurroundingVertices(OutputIterator vertices)"
  },
  {
    "label": "ApplyOperatorSurroundingVertices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyOperatorSurroundingVertices(HbrVertexOperator<T> &op)"
  },
  {
    "label": "ApplyOperatorSurroundingFaces()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyOperatorSurroundingFaces(HbrFaceOperator<T> &op)"
  },
  {
    "label": "GetParentEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>*)",
    "insertText": "GetParentEdge()"
  },
  {
    "label": "GetParentFace()",
    "kind": "Method",
    "detail": "Function (} HbrFace<T>*)",
    "insertText": "GetParentFace()"
  },
  {
    "label": "GetParentVertex()",
    "kind": "Method",
    "detail": "Function (} HbrVertex<T>*)",
    "insertText": "GetParentVertex()"
  },
  {
    "label": "SetParent()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetParent(HbrHalfedge<T>* edge)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!edge || !parent.vertex)"
  },
  {
    "label": "SetParent()",
    "kind": "Method",
    "detail": "Function (parentType = k_ParentEdge ; parent . edge = edge ; } void)",
    "insertText": "SetParent(HbrFace<T>* face)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!face || !parent.vertex)"
  },
  {
    "label": "SetParent()",
    "kind": "Method",
    "detail": "Function (parentType = k_ParentFace ; parent . face = face ; } void)",
    "insertText": "SetParent(HbrVertex<T>* vertex)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!vertex || !parent.vertex)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (parentType = k_ParentVertex ; parent . vertex = vertex ; } HbrVertex<T>*)",
    "insertText": "Subdivide()"
  },
  {
    "label": "Refine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Refine()"
  },
  {
    "label": "GuaranteeNeighbors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbors()"
  },
  {
    "label": "UnGuaranteeNeighbors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnGuaranteeNeighbors()"
  },
  {
    "label": "HasChild()",
    "kind": "Method",
    "detail": "Function (neighborsguaranteed = 0 ; validmask = 0 ; } bool)",
    "insertText": "HasChild()"
  },
  {
    "label": "IsReferenced()",
    "kind": "Method",
    "detail": "Function (vchild = - 1 ; } bool)",
    "insertText": "IsReferenced()"
  },
  {
    "label": "IsVolatile()",
    "kind": "Method",
    "detail": "Function (extraordinary = 1 ; } bool)",
    "insertText": "IsVolatile()"
  },
  {
    "label": "ClearCollected()",
    "kind": "Method",
    "detail": "Function (collected = 1 ; } void)",
    "insertText": "ClearCollected()"
  },
  {
    "label": "HasVertexEdit()",
    "kind": "Method",
    "detail": "Function (collected = 0 ; } bool)",
    "insertText": "HasVertexEdit()"
  },
  {
    "label": "ClearVertexEdit()",
    "kind": "Method",
    "detail": "Function (hasvertexedit = 1 ; } void)",
    "insertText": "ClearVertexEdit()"
  },
  {
    "label": "GetMemStats()",
    "kind": "Method",
    "detail": "Function (hasvertexedit = 0 ; } unsigned long)",
    "insertText": "GetMemStats()"
  },
  {
    "label": "IsConnected()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsConnected()"
  },
  {
    "label": "DecrementUsage()",
    "kind": "Method",
    "detail": "Function (used + + ; } void)",
    "insertText": "DecrementUsage()"
  },
  {
    "label": "IsUsed()",
    "kind": "Method",
    "detail": "Function (used - - ; } bool)",
    "insertText": "IsUsed()"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (} HbrVertex<T>*&)",
    "insertText": "GetNext()"
  },
  {
    "label": "SetClientData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetClientData(HbrMesh<T> *mesh, void *data)"
  },
  {
    "label": "SetVertexClientData()",
    "kind": "Method",
    "detail": "Function (mesh ->)",
    "insertText": "SetVertexClientData(id, data)"
  },
  {
    "label": "splitSingular()",
    "kind": "Method",
    "detail": "Function (} enum ParentType { k_ParentNone,k_ParentFace,k_ParentEdge,k_ParentVertex } ; private : void)",
    "insertText": "splitSingular()"
  },
  {
    "label": "adaptiveFlags()",
    "kind": "Method",
    "detail": "Function (T data ; struct morefvardata { int count ; }* morefvar ; int id ; int references ; int used ; float sharpness ; int vchild ; unsigned short nIncidentEdges ; unsigned short mask0 : 3 ; unsigned short mask1 : 3 ; unsigned short extraordinary : 1 ; unsigned short validmask : 1 ; unsigned short volatil : 1 ; unsigned short neighborsguaranteed : 1 ; unsigned short collected : 1 ; unsigned short hasvertexedit : 1 ; unsigned short editsapplied : 1 ; unsigned short destroyed : 1 ; unsigned short parentType : 2 ; union { HbrHalfedge<T>* edge ; HbrHalfedge<T>** edges ; } incident ; union { HbrFace<T>* face ; HbrHalfedge<T>* edge ; HbrVertex<T>* vertex ; } parent ; # ifdef HBR_ADAPTIVE public : struct adaptiveFlags { unsigned isTagged : 1 ; unsigned wasTagged : 1 ;)",
    "insertText": "adaptiveFlags() : isTagged(0), wasTagged(0)"
  },
  {
    "label": "HbrVertex()",
    "kind": "Method",
    "detail": "Function (} } ; adaptiveFlags _adaptiveFlags ; # endif } ; template<class T> HbrVertex<T)",
    "insertText": "HbrVertex() : morefvar(0), id(-1), references(0), used(0), sharpness(0.0f), vchild(-1), nIncidentEdges(0), extraordinary(0), validmask(0), volatil(0), neighborsguaranteed(0), collected(0), hasvertexedit(0), editsapplied(0), destroyed(0), parentType(k_ParentNone)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (parent . vertex = 0 ; incident . edge = 0 ; } template<class T> void HbrVertex<T)",
    "insertText": "Initialize(int vid, const T &vdata, int fvarwidth)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (neighborsguaranteed = 0 ; collected = 0 ; hasvertexedit = 0 ; editsapplied = 0 ; destroyed = 0 ; sharpness = 0 . 0 f ; nIncidentEdges = 0 ; vchild = - 1 ;)",
    "insertText": "assert(!parent.vertex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (parentType = k_ParentVertex ; parent . vertex = 0 ;)",
    "insertText": "if(fvarwidth)"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "buffer((char*) this + sizeof(*this))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(buffer) HbrFVarData<T>()"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Destroy()"
  },
  {
    "label": "Destroy()",
    "kind": "Method",
    "detail": "Function (} template<class T> void HbrVertex<T)",
    "insertText": "Destroy(HbrMesh<T> *mesh)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(references == 0)"
  },
  {
    "label": "RemoveChild()",
    "kind": "Method",
    "detail": "Function (parent . edge ->)",
    "insertText": "RemoveChild()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (parent . edge = 0 ; } else)",
    "insertText": "if(parentType == k_ParentFace && parent.face)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (parent . face = 0 ; } else)",
    "insertText": "if(parentType == k_ParentVertex && parent.vertex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (parent . vertex = 0 ; })",
    "insertText": "if(vchild != -1)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* vchildVert = mesh ->)",
    "insertText": "GetVertex(vchild)"
  },
  {
    "label": "SetParent()",
    "kind": "Method",
    "detail": "Function (vchildVert ->)",
    "insertText": "SetParent(static_cast<HbrVertex*>(0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} vchild = - 1 ; })",
    "insertText": "if(morefvar)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free(morefvar)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(edge->GetOrgVertex() == this)"
  },
  {
    "label": "incidentEdges()",
    "kind": "Method",
    "detail": "Function (int i ; unsigned short newEdgeCount = 0 ; bool edgeFound = false ; HbrHalfedge<T>**)",
    "insertText": "incidentEdges(nIncidentEdges > 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (edgeFound = true ; })",
    "insertText": "if(incidentEdges[i]->IsBoundary())"
  },
  {
    "label": "GetNextEdge()",
    "kind": "Method",
    "detail": "Function (incidentEdges [ newEdgeCount + + ] = incidentEdges [ i ] ; } else { HbrHalfedge<T>* start = incidentEdges [ i ] ; HbrHalfedge<T>* edge = start ; bool prevmatch = false ; do { edge =)",
    "insertText": "GetNextEdge(edge)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (prevmatch = true ; break ; } } })",
    "insertText": "while(!prevmatch && edge && edge != start)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (incidentEdges [ newEdgeCount + + ] = incidentEdges [ i ] ; } } })",
    "insertText": "if(newEdgeCount == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (delete [ ] incidentEdges ; } incidentEdges =& incident . edge ; incidentEdges [ 0 ] = edge ; nIncidentEdges = 1 ; } } else)",
    "insertText": "if(edge->IsBoundary())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>** newIncidentEdges = 0 ;)",
    "insertText": "if(newEdgeCount + 1 > 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (newIncidentEdges = new HbrHalfedge<T>* [ newEdgeCount + 1 ] ; } else { newIncidentEdges =& incident . edge ; })",
    "insertText": "for(i = 0; i < newEdgeCount; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (newIncidentEdges [ i ] = incidentEdges [ i ] ; })",
    "insertText": "if(nIncidentEdges > 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (incident . edges = newIncidentEdges ; } } incidentEdges [ newEdgeCount ] = edge ; } else {)",
    "insertText": "if(newEdgeCount != nIncidentEdges)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>** newIncidentEdges = 0 ;)",
    "insertText": "if(newEdgeCount > 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (incident . edges = newIncidentEdges ; } } })",
    "insertText": "if(!incidentEdges[0]->IsBoundary())"
  },
  {
    "label": "GetIncidentEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* start =)",
    "insertText": "GetIncidentEdge()"
  },
  {
    "label": "GetFace()",
    "kind": "Method",
    "detail": "Function (incidentEdges [ 0 ] = start ; HbrFacePath incidentEdgePath = incidentEdges [ 0 ] ->)",
    "insertText": "GetFace()->GetPath()"
  },
  {
    "label": "GetNextEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* e =)",
    "insertText": "GetNextEdge(start)"
  },
  {
    "label": "GetNextEdge()",
    "kind": "Method",
    "detail": "Function (incidentEdges [ 0 ] = e ; incidentEdgePath = ePath ; } HbrHalfedge<T>* next =)",
    "insertText": "GetNextEdge(e)"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (e = e ->)",
    "insertText": "GetPrev()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (references - - ;)",
    "insertText": "if(references)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (incidentEdges [ i ] = next ; return ; } edgeFound = true ; break ; } })",
    "insertText": "if(edgeFound)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(nIncidentEdges > 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>** newIncidentEdges = 0 ;)",
    "insertText": "if(nIncidentEdges - 1 > 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (newIncidentEdges = new HbrHalfedge<T>* [ nIncidentEdges - 1 ] ; } else { newIncidentEdges =& incident . edge ; } j = 0 ;)",
    "insertText": "for(i = 0; i < nIncidentEdges; ++i)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (newIncidentEdges [ j + + ] = incidentEdges [ i ] ; } })",
    "insertText": "assert(j == nIncidentEdges - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (incident . edges = newIncidentEdges ; } return ; } else)",
    "insertText": "if(nIncidentEdges == 1 && !incidentEdges[0]->IsBoundary())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (incidentEdges [ 0 ] = next ; } else { std::cout<<\" Could not split cycle ! \\ n \" ;)",
    "insertText": "assert(0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(!edge->IsBoundary() && next)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>** newIncidentEdges = 0 ;)",
    "insertText": "if(nIncidentEdges + 1 > 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (extraordinary = false ;)",
    "insertText": "if(HbrMesh<T>* mesh = GetMesh())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!IsSingular())"
  },
  {
    "label": "GetSubdivision()",
    "kind": "Method",
    "detail": "Function (extraordinary = mesh ->)",
    "insertText": "GetSubdivision()->VertexIsExtraordinary(mesh, this)"
  },
  {
    "label": "start()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>*)",
    "insertText": "start(nIncidentEdges > 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* edge = start ;)",
    "insertText": "if(edge)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(edge && edge != start)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (size_t fvtsize =)",
    "insertText": "sizeof(HbrFVarData<T>) + sizeof(float) * (GetMesh()->GetTotalFVarWidth() - 1)"
  },
  {
    "label": "fvt()",
    "kind": "Method",
    "detail": "Function (HbrFVarData<T>*)",
    "insertText": "fvt(HbrFVarData<T> *)((char *) morefvar + sizeof(int))"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "return((HbrFVarData<T>*) ((char*) this + sizeof(*this)))"
  },
  {
    "label": "GetMesh()",
    "kind": "Method",
    "detail": "Function (const int fvarwidth =)",
    "insertText": "GetMesh()->GetTotalFVarWidth()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (size_t fvtsize =)",
    "insertText": "sizeof(HbrFVarData<T>) + (fvarwidth - 1) * sizeof(float)"
  },
  {
    "label": "newmorefvar()",
    "kind": "Method",
    "detail": "Function (struct morefvardata*)",
    "insertText": "newmorefvar(struct morefvardata *) malloc(sizeof(int) + (morefvar->count + 1) * fvtsize)"
  },
  {
    "label": "newfvt()",
    "kind": "Method",
    "detail": "Function (HbrFVarData<T>*)",
    "insertText": "newfvt(HbrFVarData<T> *)((char *) newmorefvar + sizeof(int))"
  },
  {
    "label": "oldfvt()",
    "kind": "Method",
    "detail": "Function (HbrFVarData<T>*)",
    "insertText": "oldfvt(HbrFVarData<T> *)((char *) morefvar + sizeof(int))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(newfvt) HbrFVarData<T>()"
  },
  {
    "label": "SetAllData()",
    "kind": "Method",
    "detail": "Function (newfvt ->)",
    "insertText": "SetAllData(fvarwidth, oldfvt->GetData(0))"
  },
  {
    "label": "SetFaceID()",
    "kind": "Method",
    "detail": "Function (newfvt ->)",
    "insertText": "SetFaceID(oldfvt->GetFaceID())"
  },
  {
    "label": "oldfvt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "oldfvt(HbrFVarData<T>*)((char*) oldfvt + fvtsize)"
  },
  {
    "label": "newfvt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "newfvt(HbrFVarData<T>*)((char*) newfvt + fvtsize)"
  },
  {
    "label": "SetFaceID()",
    "kind": "Method",
    "detail": "Function (newfvt ->)",
    "insertText": "SetFaceID(face->GetID())"
  },
  {
    "label": "morefvar()",
    "kind": "Method",
    "detail": "Function (morefvar = newmorefvar ; return* newfvt ; } else {)",
    "insertText": "morefvar(struct morefvardata *) malloc(sizeof(int) + fvtsize)"
  },
  {
    "label": "newfvt()",
    "kind": "Method",
    "detail": "Function (HbrFVarData<T>*)",
    "insertText": "newfvt(HbrFVarData<T> *)((char *) morefvar + sizeof(int))"
  },
  {
    "label": "cycle()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>*)",
    "insertText": "cycle(nIncidentEdges > 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(edge && edge != cycle)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* edge =)",
    "insertText": "GetEdge(dest)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (edge = start ;)",
    "insertText": "while(edge)"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (} else { return next ->)",
    "insertText": "GetDestVertex()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(next == start)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { return 0 ; } } else)",
    "insertText": "if(!next)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(start->GetDestVertex() == dest)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { return 0 ; } } else)",
    "insertText": "if(next->GetDestVertex() == dest)"
  },
  {
    "label": "GetEdge()",
    "kind": "Method",
    "detail": "Function (} else { edge = next ; } } return 0 ; } } edge = dest ->)",
    "insertText": "GetEdge(this)"
  },
  {
    "label": "GetQEOPrev()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "GetQEOPrev(edge->GetDestVertex())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(!nextedge)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} mask0 = mask1 = 0 ;)",
    "insertText": "if(sharpness > k_Smooth && sharpness < k_InfinitelySharp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mask0 + = k_Corner ; })",
    "insertText": "if(IsSharp(true))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mask0 + + ; } })",
    "insertText": "if(edge->IsSharp(true))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mask1 + + ; } })",
    "insertText": "if(esharp > HbrHalfedge<T>::k_Smooth && esharp < HbrHalfedge<T>::k_InfinitelySharp)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (volatil = 1 ; } break ; } else { edge = nextedge ; } } validmask = 1 ;)",
    "insertText": "return(unsigned char)(next ? mask1 : mask0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned char mask = 0 ;)",
    "insertText": "if(IsSharp(false))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float mask = 0 ; float n = 0 ;)",
    "insertText": "if(sharpness > k_Smooth && sharpness < k_Dart)"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (esharp = edge ->)",
    "insertText": "GetPrev()->GetSharpness()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (mask + = esharp ; + + n ; } break ; } else { edge = next ; } })",
    "insertText": "assert(n > 0.0f && mask < n)"
  },
  {
    "label": "GetSurroundingEdges()",
    "kind": "Method",
    "detail": "Function (} template<class T> template<OutputIterator> void HbrVertex<T)",
    "insertText": "GetSurroundingEdges(OutputIterator edges)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(*edge)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(*edge->GetPrev())"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (* vertices + + = edge ->)",
    "insertText": "GetDestVertex(mesh)"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (* vertices + + = edge ->)",
    "insertText": "GetPrev()->GetOrgVertex(mesh)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(*edge->GetDestVertex(mesh))"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(*edge->GetPrev()->GetOrgVertex(mesh))"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "op(*edge->GetLeftFace())"
  },
  {
    "label": "GetSubdivision()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* vchildVert = mesh ->)",
    "insertText": "GetSubdivision()->Subdivide(mesh, this)"
  },
  {
    "label": "SetParent()",
    "kind": "Method",
    "detail": "Function (vchildVert ->)",
    "insertText": "SetParent(this)"
  },
  {
    "label": "GetSubdivision()",
    "kind": "Method",
    "detail": "Function (mesh ->)",
    "insertText": "GetSubdivision()->RefineAtVertex(mesh, this)"
  },
  {
    "label": "GetSubdivision()",
    "kind": "Method",
    "detail": "Function (mesh ->)",
    "insertText": "GetSubdivision()->GuaranteeNeighbors(mesh, this)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (neighborsguaranteed = 1 ;)",
    "insertText": "if(hasvertexedit && !editsapplied)"
  },
  {
    "label": "GetLeftFace()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>* face = edge ->)",
    "insertText": "GetLeftFace()"
  },
  {
    "label": "ApplyEditToVertex()",
    "kind": "Method",
    "detail": "Function (edit ->)",
    "insertText": "ApplyEditToVertex(face, this)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::vector<HbrHalfedge<T>*> edges ;)",
    "insertText": "for(int i = 1; i < nIncidentEdges; ++i)"
  },
  {
    "label": "NewVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* w = mesh ->)",
    "insertText": "NewVertex()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (w ->)",
    "insertText": "GetData().AddWithWeight(GetData(), 1.0)"
  },
  {
    "label": "SetSharpness()",
    "kind": "Method",
    "detail": "Function (w ->)",
    "insertText": "SetSharpness(GetSharpness())"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* start = incidentEdges [ i ] ; e = start ; edges .)",
    "insertText": "clear()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(e && e != start)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (e =* ei ;)",
    "insertText": "if(e->GetOpposite())"
  },
  {
    "label": "GetOpposite()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* next = e ->)",
    "insertText": "GetOpposite()->GetNext()"
  },
  {
    "label": "SetOrgVertex()",
    "kind": "Method",
    "detail": "Function (references - - ; next ->)",
    "insertText": "SetOrgVertex(w)"
  },
  {
    "label": "AddIncidentEdge()",
    "kind": "Method",
    "detail": "Function (w ->)",
    "insertText": "AddIncidentEdge(next)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(e->GetOrgVertex() == this)"
  },
  {
    "label": "AddIncidentEdge()",
    "kind": "Method",
    "detail": "Function (w ->)",
    "insertText": "AddIncidentEdge(e)"
  },
  {
    "label": "addSplitVertex()",
    "kind": "Method",
    "detail": "Function (# ifdef HBR_ADAPTIVE mesh ->)",
    "insertText": "addSplitVertex(w->GetID(), this->GetID())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (delete [ ] incidentEdges ; } nIncidentEdges = 1 ; incident . edge = e ; } template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& out, const HbrVertex<T>& vertex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T> class HbrVertexOperator { public : void)",
    "insertText": "operator() (HbrVertex<T> &vertex)"
  },
  {
    "label": "HbrVertexOperator()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "HbrVertexOperator()"
  }
]