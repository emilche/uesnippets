[
  {
    "label": "FPBDFlatWeightMapView",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDFlatWeightMapView"
  },
  {
    "label": "FPBDFlatWeightMap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDFlatWeightMap"
  },
  {
    "label": "FPBDFlatWeightMapView()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / PBDSoftsEvolutionFwd . h \" # include \" Chaos / Vector . h \" # include \" Containers / ArrayView . h \" namespace Chaos::Softs { class FPBDFlatWeightMapView final { public :)",
    "insertText": "FPBDFlatWeightMapView(const FSolverVec2& InWeightedValue, const TConstArrayView<FSolverReal>& Multipliers, int32 InNumElements) : NumElements(InNumElements) , MapValues(Multipliers.Num() == NumElements ? Multipliers : TConstArrayView<FSolverReal>()) , OffsetRange(InWeightedValue[0], InWeightedValue[1] - InWeightedValue[0])"
  },
  {
    "label": "FPBDFlatWeightMapView()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FPBDFlatWeightMapView()"
  },
  {
    "label": "FPBDFlatWeightMapView()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPBDFlatWeightMapView(const FPBDFlatWeightMapView&)"
  },
  {
    "label": "FPBDFlatWeightMapView()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPBDFlatWeightMapView(FPBDFlatWeightMapView&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPBDFlatWeightMapView&)",
    "insertText": "operator(const FPBDFlatWeightMapView&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPBDFlatWeightMapView&)",
    "insertText": "operator(FPBDFlatWeightMapView&&)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "Num()"
  },
  {
    "label": "HasWeightMap()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasWeightMap()"
  },
  {
    "label": "SetWeightedValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetWeightedValue(const FSolverVec2& InWeightedValue)"
  },
  {
    "label": "GetOffsetRange()",
    "kind": "Method",
    "detail": "Function (OffsetRange [ 0 ] = InWeightedValue [ 0 ] ; OffsetRange [ 1 ] = InWeightedValue [ 1 ] - InWeightedValue [ 0 ] ; } const FSolverVec2&)",
    "insertText": "GetOffsetRange()"
  },
  {
    "label": "GetLow()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "GetLow()"
  },
  {
    "label": "FSolverReal()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "FSolverReal()"
  },
  {
    "label": "SetMapValues()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetMapValues(const TConstArrayView<FSolverReal>& InMapValues)"
  },
  {
    "label": "GetMapValues()",
    "kind": "Method",
    "detail": "Function (} } TConstArrayView<FSolverReal>)",
    "insertText": "GetMapValues()"
  },
  {
    "label": "FPBDFlatWeightMap()",
    "kind": "Method",
    "detail": "Function (template<int32 Valence>)",
    "insertText": "FPBDFlatWeightMap(const FSolverVec2& InWeightedValue, const TConstArrayView<FRealSingle>& Multipliers = TConstArrayView<FRealSingle>(), const TConstArrayView<TVector<int32, Valence>>& Constraints = TConstArrayView<TVector<int32, Valence>>(), int32 ParticleOffset = INDEX_NONE, int32 ParticleCount = 0, typename TEnableIf<Valence >= 2 && Valence <= 4>::Type* = nullptr)"
  },
  {
    "label": "FPBDFlatWeightMap()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FPBDFlatWeightMap()"
  },
  {
    "label": "FPBDFlatWeightMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPBDFlatWeightMap(const FPBDFlatWeightMap&)"
  },
  {
    "label": "FPBDFlatWeightMap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPBDFlatWeightMap(FPBDFlatWeightMap&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPBDFlatWeightMap&)",
    "insertText": "operator(const FPBDFlatWeightMap&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FPBDFlatWeightMap&)",
    "insertText": "operator(FPBDFlatWeightMap&&)"
  },
  {
    "label": "SetWeightedValue()",
    "kind": "Method",
    "detail": "Function (MapView .)",
    "insertText": "SetWeightedValue(InWeightedValue)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "GetHigh()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "GetHigh()"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (} FSolverReal)",
    "insertText": "GetValue(int32 Index)"
  },
  {
    "label": "ReorderIndices()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ReorderIndices(const TArray<int32>& OrigToReorderedIndices)"
  },
  {
    "label": "CalculateMapValues()",
    "kind": "Method",
    "detail": "Function (private : TArray<FSolverReal>)",
    "insertText": "CalculateMapValues(const TConstArrayView<FRealSingle>& Multipliers, int32 ParticleCount)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<FSolverReal> Result ;)",
    "insertText": "if(Multipliers.Num() == ParticleCount && ParticleCount > 0)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (Result .)",
    "insertText": "SetNumUninitialized(ParticleCount)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (Result [ Index ] =)",
    "insertText": "Clamp(Multipliers[Index], (FSolverReal)0.f, (FSolverReal)1.f)"
  },
  {
    "label": "CalculateMapValues()",
    "kind": "Method",
    "detail": "Function (} } return Result ; } template<int32 Valence> TArray<FSolverReal>)",
    "insertText": "CalculateMapValues(const TConstArrayView<FRealSingle>& Multipliers, const TConstArrayView<TVector<int32, Valence>>& Constraints, int32 ParticleOffset, int32 ParticleCount)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (Result .)",
    "insertText": "SetNumUninitialized(ConstraintCount)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const TVector<int32,Valence>& Constraint = Constraints [ ConstraintIndex ] ; FSolverReal Weight = 0 . f ;)",
    "insertText": "for(int32 Index = 0; Index < Valence; ++Index)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (Weight + =)",
    "insertText": "Clamp((FSolverReal)Multipliers[Constraint[Index] - ParticleOffset], (FSolverReal)0.f, (FSolverReal)1.f)"
  },
  {
    "label": "Weight()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Weight(FSolverReal)"
  },
  {
    "label": "FPBDFlatWeightMap()",
    "kind": "Method",
    "detail": "Function (Result [ ConstraintIndex ] = Weight ; } } return Result ; } TArray<FSolverReal> MapValues ; FPBDFlatWeightMapView MapView ; } ;)",
    "insertText": "FPBDFlatWeightMap(const FSolverVec2& InWeightedValue, const TConstArrayView<FRealSingle>& Multipliers, int32 ParticleCount) : MapValues(CalculateMapValues(Multipliers, ParticleCount)) , MapView(InWeightedValue, TConstArrayView<FSolverReal>(MapValues), ParticleCount)"
  },
  {
    "label": "FPBDFlatWeightMap()",
    "kind": "Method",
    "detail": "Function (} template<int32 Valence>)",
    "insertText": "FPBDFlatWeightMap(const FSolverVec2& InWeightedValue, const TConstArrayView<FRealSingle>& Multipliers, const TConstArrayView<TVector<int32, Valence>>& Constraints, int32 ParticleOffset, int32 ParticleCount, typename TEnableIf<Valence >= 2 && Valence <= 4>::Type*) : MapValues(CalculateMapValues(Multipliers, Constraints, ParticleOffset, ParticleCount)) , MapView(InWeightedValue, TConstArrayView<FSolverReal>(MapValues), Constraints.Num())"
  },
  {
    "label": "ReorderIndices()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ReorderIndices(const TArray<int32>& OrigToReorderedConstraintIndices)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<FSolverReal> ReorderedValues ; ReorderedValues .)",
    "insertText": "SetNumUninitialized(MapValues.Num())"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (const int32 ReorderedConstraintIndex = OrigToReorderedConstraintIndices [ OrigConstraintIndex ] ; ReorderedValues [ ReorderedConstraintIndex ] = MapValues [ OrigConstraintIndex ] ; } MapValues =)",
    "insertText": "MoveTemp(ReorderedValues)"
  },
  {
    "label": "SetMapValues()",
    "kind": "Method",
    "detail": "Function (MapView .)",
    "insertText": "SetMapValues(TConstArrayView<FSolverReal>(MapValues))"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "check(MapValues.Num() == 0)"
  }
]