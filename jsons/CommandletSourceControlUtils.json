[
  {
    "label": "FQueuedSourceControlOperations",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FQueuedSourceControlOperations"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FileCheckoutOperation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FileCheckoutOperation"
  },
  {
    "label": "DECLARE_LOG_CATEGORY_EXTERN()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / UnrealString . h \" # include \" HAL / Platform . h \" # include \" Logging / LogMacros . h \" # include \" UObject / Package . h \" # include \" UObject / WeakObjectPtr . h \" # include \" UObject / WeakObjectPtrTemplates . h \")",
    "insertText": "DECLARE_LOG_CATEGORY_EXTERN(LogSourceControlUtils, Log, All)"
  },
  {
    "label": "FQueuedSourceControlOperations()",
    "kind": "Method",
    "detail": "Function (class FQueuedSourceControlOperations { public : enum class EVerbosity { All = 0,Info,ErrorsOnly } ;)",
    "insertText": "FQueuedSourceControlOperations(EVerbosity InVerbosity = EVerbosity::All)"
  },
  {
    "label": "FQueuedSourceControlOperations()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FQueuedSourceControlOperations()"
  },
  {
    "label": "SetMaxNumQueuedPackages()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaxNumQueuedPackages(int32 MaxNumPackages)"
  },
  {
    "label": "SetMaxTemporaryFileTotalSize()",
    "kind": "Method",
    "detail": "Function (QueuedPackageFlushLimit = MaxNumPackages ; } void)",
    "insertText": "SetMaxTemporaryFileTotalSize(int64 MaxTotalFileSizeInMB)"
  },
  {
    "label": "MaxTotalFileSizeInMB()",
    "kind": "Method",
    "detail": "Function (QueueFileSizeFlushLimit =)",
    "insertText": "MaxTotalFileSizeInMB(1024 * 1024)"
  },
  {
    "label": "QueueDeleteOperation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "QueueDeleteOperation(const FString& FileToDelete)"
  },
  {
    "label": "QueueCheckoutOperation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "QueueCheckoutOperation(const FString& FileToCheckout, UPackage* Package = nullptr)"
  },
  {
    "label": "QueueCheckoutAndReplaceOperation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "QueueCheckoutAndReplaceOperation(const FString& FileToCheckout, const FString& ReplacementFile, UPackage* Package = nullptr)"
  },
  {
    "label": "HasPendingOperations()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasPendingOperations()"
  },
  {
    "label": "FlushPendingOperations()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushPendingOperations(bool bForceAll)"
  },
  {
    "label": "GetNumDeletedFiles()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumDeletedFiles()"
  },
  {
    "label": "FlushCheckoutOperations()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushCheckoutOperations(bool bForceAll)"
  },
  {
    "label": "UnloadPackages()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnloadPackages(const TArray<FString> PackageNames)"
  },
  {
    "label": "DeleteFilesFromSourceControl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DeleteFilesFromSourceControl(const TArray<FString>& FilesToDelete, bool bShouldRevert)"
  },
  {
    "label": "VerboseMessage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VerboseMessage(const FString& Message)"
  },
  {
    "label": "FileCheckoutOperation()",
    "kind": "Method",
    "detail": "Function (struct FileCheckoutOperation {)",
    "insertText": "FileCheckoutOperation(UPackage* InPackage, const FString& InFileToCheckout, const FString& InReplacementFile) : Package(InPackage) , FileToCheckout(InFileToCheckout) , ReplacementFile(InReplacementFile)"
  }
]