[
  {
    "label": "PartitionDirectMapExtent",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PartitionDirectMapExtent"
  },
  {
    "label": "PartitionDirectMapMetadata",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PartitionDirectMapMetadata"
  },
  {
    "label": "FromSlotSpan()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_DIRECT_MAP_EXTENT_H_ # define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_DIRECT_MAP_EXTENT_H_ # include \" base / allocator / partition_allocator / partition_alloc_base / compiler_specific . h \" # include \" base / allocator / partition_allocator / partition_alloc_check . h \" # include \" base / allocator / partition_allocator / partition_bucket . h \" # include \" base / allocator / partition_allocator / partition_page . h \" namespace partition_alloc::internal { template<bool thread_safe> struct PartitionDirectMapExtent { PartitionDirectMapExtent<thread_safe>* next_extent ; PartitionDirectMapExtent<thread_safe>* prev_extent ; PartitionBucket<thread_safe>* bucket ; size_t reservation_size ; size_t padding_for_alignment ; PA_ALWAYS_INLINE PartitionDirectMapExtent<thread_safe>*)",
    "insertText": "FromSlotSpan(SlotSpanMetadata<thread_safe>* slot_span)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(slot_span->bucket->is_direct_mapped())"
  },
  {
    "label": "thread_safe()",
    "kind": "Method",
    "detail": "Function (auto* metadata = reinterpret_cast<PartitionDirectMapMetadata<)",
    "insertText": "thread_safe(slot_span)"
  },
  {
    "label": "PA_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PA_DCHECK(&metadata->page.slot_span_metadata == slot_span)"
  }
]