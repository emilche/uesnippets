[
  {
    "label": "UmfPackLU",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UmfPackLU"
  },
  {
    "label": "umfpack_defaults()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_UMFPACKSUPPORT_H # define EIGEN_UMFPACKSUPPORT_H # ifndef SuiteSparse_long # ifdef UF_long # define SuiteSparse_long UF_long # else # error neither SuiteSparse_long nor UF_long are defined # endif # endif namespace Eigen { void)",
    "insertText": "umfpack_defaults(double control[UMFPACK_CONTROL], double, int)"
  },
  {
    "label": "umfpack_di_defaults()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_di_defaults(control)"
  },
  {
    "label": "umfpack_defaults()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_defaults(double control[UMFPACK_CONTROL], std::complex<double>, int)"
  },
  {
    "label": "umfpack_zi_defaults()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zi_defaults(control)"
  },
  {
    "label": "umfpack_defaults()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_defaults(double control[UMFPACK_CONTROL], double, SuiteSparse_long)"
  },
  {
    "label": "umfpack_dl_defaults()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_dl_defaults(control)"
  },
  {
    "label": "umfpack_defaults()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_defaults(double control[UMFPACK_CONTROL], std::complex<double>, SuiteSparse_long)"
  },
  {
    "label": "umfpack_zl_defaults()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zl_defaults(control)"
  },
  {
    "label": "umfpack_report_info()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_info(double control[UMFPACK_CONTROL], double info[UMFPACK_INFO], double, int)"
  },
  {
    "label": "umfpack_di_report_info()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_di_report_info(control, info)"
  },
  {
    "label": "umfpack_report_info()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_info(double control[UMFPACK_CONTROL], double info[UMFPACK_INFO], std::complex<double>, int)"
  },
  {
    "label": "umfpack_zi_report_info()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zi_report_info(control, info)"
  },
  {
    "label": "umfpack_report_info()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_info(double control[UMFPACK_CONTROL], double info[UMFPACK_INFO], double, SuiteSparse_long)"
  },
  {
    "label": "umfpack_dl_report_info()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_dl_report_info(control, info)"
  },
  {
    "label": "umfpack_report_info()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_info(double control[UMFPACK_CONTROL], double info[UMFPACK_INFO], std::complex<double>, SuiteSparse_long)"
  },
  {
    "label": "umfpack_zl_report_info()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zl_report_info(control, info)"
  },
  {
    "label": "umfpack_report_status()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_status(double control[UMFPACK_CONTROL], int status, double, int)"
  },
  {
    "label": "umfpack_di_report_status()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_di_report_status(control, status)"
  },
  {
    "label": "umfpack_report_status()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_status(double control[UMFPACK_CONTROL], int status, std::complex<double>, int)"
  },
  {
    "label": "umfpack_zi_report_status()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zi_report_status(control, status)"
  },
  {
    "label": "umfpack_report_status()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_status(double control[UMFPACK_CONTROL], int status, double, SuiteSparse_long)"
  },
  {
    "label": "umfpack_dl_report_status()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_dl_report_status(control, status)"
  },
  {
    "label": "umfpack_report_status()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_status(double control[UMFPACK_CONTROL], int status, std::complex<double>, SuiteSparse_long)"
  },
  {
    "label": "umfpack_zl_report_status()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zl_report_status(control, status)"
  },
  {
    "label": "umfpack_report_control()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_control(double control[UMFPACK_CONTROL], double, int)"
  },
  {
    "label": "umfpack_di_report_control()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_di_report_control(control)"
  },
  {
    "label": "umfpack_report_control()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_control(double control[UMFPACK_CONTROL], std::complex<double>, int)"
  },
  {
    "label": "umfpack_zi_report_control()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zi_report_control(control)"
  },
  {
    "label": "umfpack_report_control()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_control(double control[UMFPACK_CONTROL], double, SuiteSparse_long)"
  },
  {
    "label": "umfpack_dl_report_control()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_dl_report_control(control)"
  },
  {
    "label": "umfpack_report_control()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_report_control(double control[UMFPACK_CONTROL], std::complex<double>, SuiteSparse_long)"
  },
  {
    "label": "umfpack_zl_report_control()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zl_report_control(control)"
  },
  {
    "label": "umfpack_free_numeric()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "umfpack_free_numeric(void **Numeric, double, int)"
  },
  {
    "label": "umfpack_di_free_numeric()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_di_free_numeric(Numeric)"
  },
  {
    "label": "umfpack_free_numeric()",
    "kind": "Method",
    "detail": "Function (* Numeric = 0 ; } void)",
    "insertText": "umfpack_free_numeric(void **Numeric, std::complex<double>, int)"
  },
  {
    "label": "umfpack_zi_free_numeric()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zi_free_numeric(Numeric)"
  },
  {
    "label": "umfpack_free_numeric()",
    "kind": "Method",
    "detail": "Function (* Numeric = 0 ; } void)",
    "insertText": "umfpack_free_numeric(void **Numeric, double, SuiteSparse_long)"
  },
  {
    "label": "umfpack_dl_free_numeric()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_dl_free_numeric(Numeric)"
  },
  {
    "label": "umfpack_free_numeric()",
    "kind": "Method",
    "detail": "Function (* Numeric = 0 ; } void)",
    "insertText": "umfpack_free_numeric(void **Numeric, std::complex<double>, SuiteSparse_long)"
  },
  {
    "label": "umfpack_zl_free_numeric()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zl_free_numeric(Numeric)"
  },
  {
    "label": "umfpack_free_symbolic()",
    "kind": "Method",
    "detail": "Function (* Numeric = 0 ; } void)",
    "insertText": "umfpack_free_symbolic(void **Symbolic, double, int)"
  },
  {
    "label": "umfpack_di_free_symbolic()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_di_free_symbolic(Symbolic)"
  },
  {
    "label": "umfpack_free_symbolic()",
    "kind": "Method",
    "detail": "Function (* Symbolic = 0 ; } void)",
    "insertText": "umfpack_free_symbolic(void **Symbolic, std::complex<double>, int)"
  },
  {
    "label": "umfpack_zi_free_symbolic()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zi_free_symbolic(Symbolic)"
  },
  {
    "label": "umfpack_free_symbolic()",
    "kind": "Method",
    "detail": "Function (* Symbolic = 0 ; } void)",
    "insertText": "umfpack_free_symbolic(void **Symbolic, double, SuiteSparse_long)"
  },
  {
    "label": "umfpack_dl_free_symbolic()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_dl_free_symbolic(Symbolic)"
  },
  {
    "label": "umfpack_free_symbolic()",
    "kind": "Method",
    "detail": "Function (* Symbolic = 0 ; } void)",
    "insertText": "umfpack_free_symbolic(void **Symbolic, std::complex<double>, SuiteSparse_long)"
  },
  {
    "label": "umfpack_zl_free_symbolic()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_zl_free_symbolic(Symbolic)"
  },
  {
    "label": "umfpack_symbolic()",
    "kind": "Method",
    "detail": "Function (* Symbolic = 0 ; } int)",
    "insertText": "umfpack_symbolic(int n_row,int n_col, const int Ap[], const int Ai[], const double Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])"
  },
  {
    "label": "umfpack_symbolic()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpack_symbolic(int n_row,int n_col, const int Ap[], const int Ai[], const std::complex<double> Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])"
  },
  {
    "label": "umfpack_symbolic()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_symbolic(SuiteSparse_long n_row,SuiteSparse_long n_col, const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const double Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])"
  },
  {
    "label": "umfpack_symbolic()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_symbolic(SuiteSparse_long n_row,SuiteSparse_long n_col, const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const std::complex<double> Ax[], void **Symbolic, const double Control [UMFPACK_CONTROL], double Info [UMFPACK_INFO])"
  },
  {
    "label": "umfpack_numeric()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpack_numeric(const int Ap[], const int Ai[], const double Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])"
  },
  {
    "label": "umfpack_numeric()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpack_numeric(const int Ap[], const int Ai[], const std::complex<double> Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])"
  },
  {
    "label": "umfpack_numeric()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_numeric(const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const double Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])"
  },
  {
    "label": "umfpack_numeric()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_numeric(const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const std::complex<double> Ax[], void *Symbolic, void **Numeric, const double Control[UMFPACK_CONTROL],double Info [UMFPACK_INFO])"
  },
  {
    "label": "umfpack_solve()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpack_solve(int sys, const int Ap[], const int Ai[], const double Ax[], double X[], const double B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])"
  },
  {
    "label": "umfpack_solve()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpack_solve(int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[], std::complex<double> X[], const std::complex<double> B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])"
  },
  {
    "label": "umfpack_solve()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_solve(int sys, const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const double Ax[], double X[], const double B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])"
  },
  {
    "label": "umfpack_solve()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_solve(int sys, const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const std::complex<double> Ax[], std::complex<double> X[], const std::complex<double> B[], void *Numeric, const double Control[UMFPACK_CONTROL], double Info[UMFPACK_INFO])"
  },
  {
    "label": "umfpack_get_lunz()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)"
  },
  {
    "label": "umfpack_get_lunz()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)"
  },
  {
    "label": "umfpack_get_lunz()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_get_lunz(SuiteSparse_long *lnz, SuiteSparse_long *unz, SuiteSparse_long *n_row, SuiteSparse_long *n_col, SuiteSparse_long *nz_udiag, void *Numeric, double)"
  },
  {
    "label": "umfpack_get_lunz()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_get_lunz(SuiteSparse_long *lnz, SuiteSparse_long *unz, SuiteSparse_long *n_row, SuiteSparse_long *n_col, SuiteSparse_long *nz_udiag, void *Numeric, std::complex<double>)"
  },
  {
    "label": "umfpack_get_numeric()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpack_get_numeric(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[], int P[], int Q[], double Dx[], int *do_recip, double Rs[], void *Numeric)"
  },
  {
    "label": "umfpack_get_numeric()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpack_get_numeric(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[], int P[], int Q[], std::complex<double> Dx[], int *do_recip, double Rs[], void *Numeric)"
  },
  {
    "label": "umfpack_get_numeric()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_get_numeric(SuiteSparse_long Lp[], SuiteSparse_long Lj[], double Lx[], SuiteSparse_long Up[], SuiteSparse_long Ui[], double Ux[], SuiteSparse_long P[], SuiteSparse_long Q[], double Dx[], SuiteSparse_long *do_recip, double Rs[], void *Numeric)"
  },
  {
    "label": "umfpack_get_numeric()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_get_numeric(SuiteSparse_long Lp[], SuiteSparse_long Lj[], std::complex<double> Lx[], SuiteSparse_long Up[], SuiteSparse_long Ui[], std::complex<double> Ux[], SuiteSparse_long P[], SuiteSparse_long Q[], std::complex<double> Dx[], SuiteSparse_long *do_recip, double Rs[], void *Numeric)"
  },
  {
    "label": "umfpack_get_determinant()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpack_get_determinant(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO], int)"
  },
  {
    "label": "umfpack_get_determinant()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpack_get_determinant(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO], int)"
  },
  {
    "label": "umfpack_get_determinant()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_get_determinant(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO], SuiteSparse_long)"
  },
  {
    "label": "umfpack_get_determinant()",
    "kind": "Method",
    "detail": "Function (} SuiteSparse_long)",
    "insertText": "umfpack_get_determinant(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO], SuiteSparse_long)"
  },
  {
    "label": "UmfPackLU()",
    "kind": "Method",
    "detail": "Function (} template<_MatrixType> class UmfPackLU : public SparseSolverBase<UmfPackLU<_MatrixType>> { protected : typedef SparseSolverBase<UmfPackLU<_MatrixType>> Base ; using Base::m_isInitialized ; public : using Base::_solve_impl ; typedef _MatrixType MatrixType ; typedef MatrixType::Scalar Scalar ; typedef MatrixType::RealScalar RealScalar ; typedef MatrixType::StorageIndex StorageIndex ; typedef Matrix<Scalar,Dynamic,1> Vector ; typedef Matrix<int,1,MatrixType::ColsAtCompileTime> IntRowVectorType ; typedef Matrix<int,MatrixType::RowsAtCompileTime,1> IntColVectorType ; typedef SparseMatrix<Scalar> LUMatrixType ; typedef SparseMatrix<Scalar,ColMajor,StorageIndex> UmfpackMatrixType ; typedef Ref<const UmfpackMatrixType,StandardCompressedFormat> UmfpackMatrixRef ; enum { ColsAtCompileTime = MatrixType::ColsAtCompileTime,MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime } ; public : typedef Array<double,UMFPACK_CONTROL,1> UmfpackControl ; typedef Array<double,UMFPACK_INFO,1> UmfpackInfo ;)",
    "insertText": "UmfPackLU() : m_dummy(0,0), mp_matrix(m_dummy)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init()"
  },
  {
    "label": "UmfPackLU()",
    "kind": "Method",
    "detail": "Function (} template<InputMatrixType>)",
    "insertText": "UmfPackLU(const InputMatrixType& matrix) : mp_matrix(matrix)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(matrix)"
  },
  {
    "label": "UmfPackLU()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "UmfPackLU()"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "cols()"
  },
  {
    "label": "info()",
    "kind": "Method",
    "detail": "Function (} ComputationInfo)",
    "insertText": "info()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized && \"Decomposition is not initialized.\")"
  },
  {
    "label": "grab()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "grab(matrix.derived())"
  },
  {
    "label": "analyzePattern_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "analyzePattern_impl()"
  },
  {
    "label": "factorize_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "factorize_impl()"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (} template<InputMatrixType> void)",
    "insertText": "analyzePattern(const InputMatrixType& matrix)"
  },
  {
    "label": "umfpackFactorizeReturncode()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "umfpackFactorizeReturncode()"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_numeric && \"UmfPackLU: you must first call factorize()\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_analysisIsOk && \"UmfPackLU: you must first call analyzePattern()\")"
  },
  {
    "label": "printUmfpackControl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "printUmfpackControl()"
  },
  {
    "label": "umfpack_report_control()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_report_control(m_control.data(), Scalar(),StorageIndex())"
  },
  {
    "label": "printUmfpackInfo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "printUmfpackInfo()"
  },
  {
    "label": "umfpack_report_info()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_report_info(m_control.data(), m_umfpackInfo.data(), Scalar(),StorageIndex())"
  },
  {
    "label": "printUmfpackStatus()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "printUmfpackStatus()"
  },
  {
    "label": "umfpack_report_status()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_report_status(m_control.data(), m_fact_errorCode, Scalar(),StorageIndex())"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (} template<BDerived,XDerived> bool)",
    "insertText": "_solve_impl(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x)"
  },
  {
    "label": "determinant()",
    "kind": "Method",
    "detail": "Function (Scalar)",
    "insertText": "determinant()"
  },
  {
    "label": "extractData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "extractData()"
  },
  {
    "label": "umfpack_defaults()",
    "kind": "Method",
    "detail": "Function (m_info = InvalidInput ; m_isInitialized = false ; m_numeric = 0 ; m_symbolic = 0 ; m_extractedDataAreDirty = true ;)",
    "insertText": "umfpack_defaults(m_control.data(), Scalar(),StorageIndex())"
  },
  {
    "label": "umfpack_symbolic()",
    "kind": "Method",
    "detail": "Function (m_fact_errorCode =)",
    "insertText": "umfpack_symbolic(internal::convert_index<StorageIndex>(mp_matrix.rows()), internal::convert_index<StorageIndex>(mp_matrix.cols()), mp_matrix.outerIndexPtr(), mp_matrix.innerIndexPtr(), mp_matrix.valuePtr(), &m_symbolic, m_control.data(), m_umfpackInfo.data())"
  },
  {
    "label": "umfpack_numeric()",
    "kind": "Method",
    "detail": "Function (m_fact_errorCode =)",
    "insertText": "umfpack_numeric(mp_matrix.outerIndexPtr(), mp_matrix.innerIndexPtr(), mp_matrix.valuePtr(), m_symbolic, &m_numeric, m_control.data(), m_umfpackInfo.data())"
  },
  {
    "label": "grab()",
    "kind": "Method",
    "detail": "Function (m_info = m_fact_errorCode = = UMFPACK_OK ? Success : NumericalIssue ; m_factorizationIsOk = true ; m_extractedDataAreDirty = true ; } template<MatrixDerived> void)",
    "insertText": "grab(const EigenBase<MatrixDerived> &A)"
  },
  {
    "label": "UmfpackMatrixRef()",
    "kind": "Method",
    "detail": "Function (mp_matrix . ~)",
    "insertText": "UmfpackMatrixRef()"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&mp_matrix) UmfpackMatrixRef(A.derived())"
  },
  {
    "label": "grab()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "grab(const UmfpackMatrixRef &A)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(&mp_matrix) UmfpackMatrixRef(A)"
  },
  {
    "label": "UmfPackLU()",
    "kind": "Method",
    "detail": "Function (} } LUMatrixType m_l ; StorageIndex m_fact_errorCode ; UmfpackControl m_control ; UmfpackInfo m_umfpackInfo ; LUMatrixType m_u ; IntColVectorType m_p ; IntRowVectorType m_q ; UmfpackMatrixType m_dummy ; UmfpackMatrixRef mp_matrix ; void* m_numeric ; void* m_symbolic ; ComputationInfo m_info ; int m_factorizationIsOk ; int m_analysisIsOk ; bool m_extractedDataAreDirty ; private :)",
    "insertText": "UmfPackLU(const UmfPackLU&)"
  },
  {
    "label": "umfpack_get_lunz()",
    "kind": "Method",
    "detail": "Function (StorageIndex lnz,unz,rows,cols,nz_udiag ;)",
    "insertText": "umfpack_get_lunz(&lnz, &unz, &rows, &cols, &nz_udiag, m_numeric, Scalar())"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_l .)",
    "insertText": "resize(rows,(std::min)(rows,cols))"
  },
  {
    "label": "resizeNonZeros()",
    "kind": "Method",
    "detail": "Function (m_l .)",
    "insertText": "resizeNonZeros(lnz)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_u .)",
    "insertText": "resize((std::min)(rows,cols),cols)"
  },
  {
    "label": "resizeNonZeros()",
    "kind": "Method",
    "detail": "Function (m_u .)",
    "insertText": "resizeNonZeros(unz)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_p .)",
    "insertText": "resize(rows)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_q .)",
    "insertText": "resize(cols)"
  },
  {
    "label": "umfpack_get_numeric()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "umfpack_get_numeric(m_l.outerIndexPtr(), m_l.innerIndexPtr(), m_l.valuePtr(), m_u.outerIndexPtr(), m_u.innerIndexPtr(), m_u.valuePtr(), m_p.data(), m_q.data(), 0, 0, 0, m_numeric)"
  },
  {
    "label": "umfpack_get_determinant()",
    "kind": "Method",
    "detail": "Function (Scalar det ;)",
    "insertText": "umfpack_get_determinant(&det, 0, m_numeric, 0, StorageIndex())"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert((BDerived::Flags&RowMajorBit)==0 && \"UmfPackLU backend does not support non col-major rhs yet\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert((XDerived::Flags&RowMajorBit)==0 && \"UmfPackLU backend does not support non col-major result yet\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(b.derived().data() != x.derived().data() && \" Umfpack does not support inplace solve\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Scalar* x_ptr = 0 ; Matrix<Scalar,Dynamic,1> x_tmp ;)",
    "insertText": "if(x.innerStride()!=1)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (x_tmp .)",
    "insertText": "resize(x.rows())"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (x_ptr = x_tmp .)",
    "insertText": "data()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int j=0; j<rhsCols; ++j)"
  },
  {
    "label": "umfpack_solve()",
    "kind": "Method",
    "detail": "Function (StorageIndex errorCode =)",
    "insertText": "umfpack_solve(UMFPACK_A, mp_matrix.outerIndexPtr(), mp_matrix.innerIndexPtr(), mp_matrix.valuePtr(), x_ptr, &b.const_cast_derived().col(j).coeffRef(0), m_numeric, m_control.data(), m_umfpackInfo.data())"
  }
]