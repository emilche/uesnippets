[
  {
    "label": "FPBDRigidsEvolutionGBF",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDRigidsEvolutionGBF"
  },
  {
    "label": "FDirtyRigidParticleData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDirtyRigidParticleData"
  },
  {
    "label": "FInitialState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FInitialState"
  },
  {
    "label": "FRigidBodyHandle_External",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRigidBodyHandle_External"
  },
  {
    "label": "FRigidBodyHandle_Internal",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRigidBodyHandle_Internal"
  },
  {
    "label": "FSingleParticlePhysicsProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSingleParticlePhysicsProxy"
  },
  {
    "label": "TThreadedSingleParticlePhysicsProxyBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TThreadedSingleParticlePhysicsProxyBase"
  },
  {
    "label": "FInitialState()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Real . h \" # include \" Chaos / ArrayCollectionArray . h \" # include \" Chaos / Framework / MultiBufferResource . h \" # include \" Chaos / Framework / PhysicsProxy . h \" # include \" Chaos / PBDPositionConstraints . h \" # include \" Chaos / ParticleHandle . h \" # include \" Chaos / PhysicsObject . h \" # include \" PhysicsCoreTypes . h \" # include \" Chaos / Defines . h \" # include \" Chaos / PullPhysicsDataImp . h \" # include \" Chaos / Core . h \" # include \" PhysicsProxy / SingleParticlePhysicsProxyFwd . h \" # include \" Framework / Threading . h \" # include \" Math / NumericLimits . h \" # include \" RewindData . h \" namespace Chaos { class FPBDRigidsEvolutionGBF ; struct FDirtyRigidParticleData ; class FInitialState { public :)",
    "insertText": "FInitialState() : Mass(0.f) , InvMass(0.f) , InertiaTensor(1.f)"
  },
  {
    "label": "FInitialState()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FInitialState(FReal MassIn, FReal InvMassIn, FVector InertiaTensorIn) : Mass(MassIn) , InvMass(InvMassIn) , InertiaTensor(InertiaTensorIn)"
  },
  {
    "label": "GetMass()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "GetMass()"
  },
  {
    "label": "FSingleParticlePhysicsProxy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSingleParticlePhysicsProxy()"
  },
  {
    "label": "FSingleParticlePhysicsProxy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSingleParticlePhysicsProxy(const FSingleParticlePhysicsProxy&)"
  },
  {
    "label": "FSingleParticlePhysicsProxy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSingleParticlePhysicsProxy(FSingleParticlePhysicsProxy&&)"
  },
  {
    "label": "GetInterpolationData()",
    "kind": "Method",
    "detail": "Function (FProxyInterpolationBase*)",
    "insertText": "GetInterpolationData()"
  },
  {
    "label": "GetGameThreadAPI()",
    "kind": "Method",
    "detail": "Function (} FRigidBodyHandle_External&)",
    "insertText": "GetGameThreadAPI()"
  },
  {
    "label": "GetPhysicsThreadAPI()",
    "kind": "Method",
    "detail": "Function (} FRigidBodyHandle_Internal*)",
    "insertText": "GetPhysicsThreadAPI()"
  },
  {
    "label": "GetHandle_LowLevel()",
    "kind": "Method",
    "detail": "Function (} FParticleHandle*)",
    "insertText": "GetHandle_LowLevel()"
  },
  {
    "label": "PushToPhysicsState()",
    "kind": "Method",
    "detail": "Function (Handle = InHandle ; } void)",
    "insertText": "PushToPhysicsState(const FDirtyPropertiesManager& Manager,int32 DataIdx,const FDirtyProxy& Dirty,FShapeDirtyData* ShapesData, FReal ExternalDt)"
  },
  {
    "label": "ClearAccumulatedData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearAccumulatedData()"
  },
  {
    "label": "BufferPhysicsResults()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BufferPhysicsResults(FDirtyRigidParticleData&)"
  },
  {
    "label": "BufferPhysicsResults_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BufferPhysicsResults_External(FDirtyRigidParticleData&)"
  },
  {
    "label": "PullFromPhysicsState()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PullFromPhysicsState(const FDirtyRigidParticleData& PullData, int32 SolverSyncTimestamp, const FDirtyRigidParticleData* NextPullData = nullptr, const FRealSingle* Alpha = nullptr, const FDirtyRigidParticleReplicationErrorData* Error = nullptr, const Chaos::FReal AsyncFixedTimeStep = 0)"
  },
  {
    "label": "IsDirty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsDirty()"
  },
  {
    "label": "GetWakeEvent()",
    "kind": "Method",
    "detail": "Function (EWakeEventEntry)",
    "insertText": "GetWakeEvent()"
  },
  {
    "label": "ClearEvents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearEvents()"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (PARTICLE_TYPE*)",
    "insertText": "GetParticle_LowLevel()"
  },
  {
    "label": "GetRigidParticleUnsafe()",
    "kind": "Method",
    "detail": "Function (} FPBDRigidParticle*)",
    "insertText": "GetRigidParticleUnsafe()"
  },
  {
    "label": "GetPhysicsObject()",
    "kind": "Method",
    "detail": "Function (} FPhysicsObjectHandle)",
    "insertText": "GetPhysicsObject()"
  },
  {
    "label": "GetOrCreateErrorInterpolationData()",
    "kind": "Method",
    "detail": "Function (} protected : TUniquePtr<PARTICLE_TYPE> Particle ; FParticleHandle* Handle ; FPhysicsObjectUniquePtr Reference ; int32 GravityGroupIndex ; private : TUniquePtr<FProxyInterpolationBase> InterpolationData ; template<ErrorDataType> ErrorDataType*)",
    "insertText": "GetOrCreateErrorInterpolationData()"
  },
  {
    "label": "ErrorDataType()",
    "kind": "Method",
    "detail": "Function (InterpolationData = MakeUnique<)",
    "insertText": "ErrorDataType()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(InterpolationData.Get()->GetInterpolationType() != ErrorDataType::InterpolationType)"
  },
  {
    "label": "ErrorDataType()",
    "kind": "Method",
    "detail": "Function (InterpolationData = MakeUnique<)",
    "insertText": "ErrorDataType(InterpolationData.Get()->GetPullDataInterpIdx_External(), InterpolationData.Get()->GetInterpChannel_External())"
  },
  {
    "label": "ErrorDataType()",
    "kind": "Method",
    "detail": "Function (} return static_cast<)",
    "insertText": "ErrorDataType(InterpolationData.Get())"
  },
  {
    "label": "FSingleParticlePhysicsProxy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSingleParticlePhysicsProxy(TUniquePtr<PARTICLE_TYPE>&& InParticle, FParticleHandle* InHandle, UObject* InOwner = nullptr)"
  },
  {
    "label": "TThreadedSingleParticlePhysicsProxyBase()",
    "kind": "Method",
    "detail": "Function (} ; template<bool bExternal> class TThreadedSingleParticlePhysicsProxyBase : protected FSingleParticlePhysicsProxy {)",
    "insertText": "TThreadedSingleParticlePhysicsProxyBase()"
  },
  {
    "label": "GetProxy()",
    "kind": "Method",
    "detail": "Function (public : FSingleParticlePhysicsProxy*)",
    "insertText": "GetProxy()"
  },
  {
    "label": "CanTreatAsKinematic()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CanTreatAsKinematic()"
  },
  {
    "label": "CanTreatAsRigid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CanTreatAsRigid()"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (} const FVec3&)",
    "insertText": "X()"
  },
  {
    "label": "GetX()",
    "kind": "Method",
    "detail": "Function (} const FVec3&)",
    "insertText": "GetX()"
  },
  {
    "label": "SetXBase()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "SetXBase(const FVec3& InX, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InX, bInvalidate, this](auto* Particle) { if (bInvalidate) { auto Dyn = Particle->CastToRigidParticle(); if (Dyn && Dyn->ObjectState() == EObjectStateType::Sleeping) { SetObjectStateHelper(*GetProxy(), *Dyn, EObjectStateType::Dynamic, true); } } Particle->SetX(InX, bInvalidate); })"
  },
  {
    "label": "UniqueIdx()",
    "kind": "Method",
    "detail": "Function (} public : FUniqueIdx)",
    "insertText": "UniqueIdx()"
  },
  {
    "label": "SetUniqueIdx()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetUniqueIdx(const FUniqueIdx UniqueIdx, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([UniqueIdx, bInvalidate](auto* Particle) { Particle->SetUniqueIdx(UniqueIdx, bInvalidate); })"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} FRotation3)",
    "insertText": "R()"
  },
  {
    "label": "GetR()",
    "kind": "Method",
    "detail": "Function (} FRotation3)",
    "insertText": "GetR()"
  },
  {
    "label": "SetRBase()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "SetRBase(const FRotation3& InR, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InR, bInvalidate, this](auto* Particle) { if (bInvalidate) { auto Dyn = Particle->CastToRigidParticle(); if (Dyn && Dyn->ObjectState() == EObjectStateType::Sleeping) { SetObjectStateHelper(*GetProxy(), *Dyn, EObjectStateType::Dynamic, true); } } Particle->SetR(InR, bInvalidate); })"
  },
  {
    "label": "DummyPtr()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<FImplicitObject,ESPMode::ThreadSafe>)",
    "insertText": "DummyPtr(nullptr)"
  },
  {
    "label": "SetDebugName()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetDebugName(const TSharedPtr<FString, ESPMode::ThreadSafe>& InDebugName)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InDebugName](auto* Ptr) { Ptr->SetDebugName(InDebugName); })"
  },
  {
    "label": "GetGeometry()",
    "kind": "Method",
    "detail": "Function (} # endif const FImplicitObjectRef)",
    "insertText": "GetGeometry()"
  },
  {
    "label": "ShapesArray()",
    "kind": "Method",
    "detail": "Function (} const FShapesArray&)",
    "insertText": "ShapesArray()"
  },
  {
    "label": "ObjectState()",
    "kind": "Method",
    "detail": "Function (} EObjectStateType)",
    "insertText": "ObjectState()"
  },
  {
    "label": "ObjectType()",
    "kind": "Method",
    "detail": "Function (} EParticleType)",
    "insertText": "ObjectType()"
  },
  {
    "label": "SpatialIdx()",
    "kind": "Method",
    "detail": "Function (} FSpatialAccelerationIdx)",
    "insertText": "SpatialIdx()"
  },
  {
    "label": "SetSpatialIdx()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSpatialIdx(FSpatialAccelerationIdx Idx)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([Idx](auto* Ptr) { Ptr->SetSpatialIdx(Idx); })"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "V()"
  },
  {
    "label": "GetV()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "GetV()"
  },
  {
    "label": "SetVBase()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "SetVBase(const FVec3& InV, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InV, bInvalidate, this](auto* Particle) { if (auto Kinematic = Particle->CastToKinematicParticle()) { if (bInvalidate) { auto Dyn = Particle->CastToRigidParticle(); if (Dyn && Dyn->ObjectState() == EObjectStateType::Sleeping && !InV.IsNearlyZero()) { SetObjectStateHelper(*GetProxy(), *Dyn, EObjectStateType::Dynamic, true); } } Kinematic->SetV(InV, bInvalidate); } })"
  },
  {
    "label": "W()",
    "kind": "Method",
    "detail": "Function (} public : const FVec3)",
    "insertText": "W()"
  },
  {
    "label": "GetW()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "GetW()"
  },
  {
    "label": "SetWBase()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "SetWBase(const FVec3& InW, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InW, bInvalidate, this](auto* Particle) { if (auto Kinematic = Particle->CastToKinematicParticle()) { if (bInvalidate) { auto Dyn = Particle->CastToRigidParticle(); if (Dyn && Dyn->ObjectState() == EObjectStateType::Sleeping && !InW.IsNearlyZero()) { SetObjectStateHelper(*GetProxy(), *Dyn, EObjectStateType::Dynamic, true); } } Kinematic->SetW(InW, bInvalidate); } })"
  },
  {
    "label": "SetKinematicTarget()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "SetKinematicTarget(const FRigidTransform3& InTargetTransform, bool bInvalidate = true)"
  },
  {
    "label": "SetKinematicTarget()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetKinematicTarget(FKinematicTarget::MakePositionTarget(InTargetTransform), bInvalidate)"
  },
  {
    "label": "SetKinematicTarget()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetKinematicTarget(const FKinematicTarget& InKinematicTarget, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InKinematicTarget, bInvalidate](auto* Ptr) { if (auto Kinematic = Ptr->CastToKinematicParticle()) { Kinematic->SetKinematicTarget(InKinematicTarget, bInvalidate); } })"
  },
  {
    "label": "GravityEnabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GravityEnabled()"
  },
  {
    "label": "SetGravityEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetGravityEnabled(const bool InGravityEnabled)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([InGravityEnabled](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetGravityEnabled(InGravityEnabled); } })"
  },
  {
    "label": "GravityGroupIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GravityGroupIndex()"
  },
  {
    "label": "SetGravityGroupIndex()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetGravityGroupIndex(const uint32 InGravityGroupIndex)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([InGravityGroupIndex](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetGravityGroupIndex(InGravityGroupIndex); } })"
  },
  {
    "label": "UpdateKinematicFromSimulation()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "UpdateKinematicFromSimulation()"
  },
  {
    "label": "SetUpdateKinematicFromSimulation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetUpdateKinematicFromSimulation(const bool InUpdateKinematicFromSimulation)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([InUpdateKinematicFromSimulation](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetUpdateKinematicFromSimulation(InUpdateKinematicFromSimulation); } })"
  },
  {
    "label": "CCDEnabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CCDEnabled()"
  },
  {
    "label": "SetCCDEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCCDEnabled(const bool InCCDEnabled)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([InCCDEnabled](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetCCDEnabled(InCCDEnabled); } })"
  },
  {
    "label": "MACDEnabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "MACDEnabled()"
  },
  {
    "label": "SetMACDEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetMACDEnabled(const bool InCCDEnabled)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([InCCDEnabled](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetMACDEnabled(InCCDEnabled); } })"
  },
  {
    "label": "SetPositionSolverIterations()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetPositionSolverIterations(const int32 PositionSolverIterationsIn)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([PositionSolverIterationsIn](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetPositionSolverIterations(PositionSolverIterationsIn); } })"
  },
  {
    "label": "SetVelocitySolverIterations()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetVelocitySolverIterations(const int32 VelocitySolverIterationsIn)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([VelocitySolverIterationsIn](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetVelocitySolverIterations(VelocitySolverIterationsIn); } })"
  },
  {
    "label": "SetProjectionSolverIterations()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetProjectionSolverIterations(const int32 ProjectionSolverIterationsIn)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([ProjectionSolverIterationsIn](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetProjectionSolverIterations(ProjectionSolverIterationsIn); } })"
  },
  {
    "label": "OneWayInteraction()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "OneWayInteraction()"
  },
  {
    "label": "SetOneWayInteraction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetOneWayInteraction(const bool bInOneWayInteraction)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([bInOneWayInteraction](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetOneWayInteraction(bInOneWayInteraction); } })"
  },
  {
    "label": "InertiaConditioningEnabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "InertiaConditioningEnabled()"
  },
  {
    "label": "SetInertiaConditioningEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetInertiaConditioningEnabled(const bool bInEnabled)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([bInEnabled](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetInertiaConditioningEnabled(bInEnabled); } })"
  },
  {
    "label": "SetResimType()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetResimType(EResimType ResimType)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([ResimType](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetResimType(ResimType); } })"
  },
  {
    "label": "ResimType()",
    "kind": "Method",
    "detail": "Function (} EResimType)",
    "insertText": "ResimType()"
  },
  {
    "label": "Acceleration()",
    "kind": "Method",
    "detail": "Function (} return EResimType::FullResim ; } const FVec3)",
    "insertText": "Acceleration()"
  },
  {
    "label": "SetAcceleration()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAcceleration(const FVec3& Acceleration, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&Acceleration, bInvalidate, this](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { if (Rigid->ObjectState() == EObjectStateType::Sleeping || Rigid->ObjectState() == EObjectStateType::Dynamic) { if (bInvalidate) { SetObjectStateHelper(*GetProxy(), *Rigid, EObjectStateType::Dynamic, true); } Rigid->SetAcceleration(Acceleration); } } })"
  },
  {
    "label": "AddForce()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddForce(const FVec3& InForce, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InForce, bInvalidate, this](auto* Particle) { if (auto* Rigid = Particle->CastToRigidParticle()) { if (Rigid->ObjectState() == EObjectStateType::Sleeping || Rigid->ObjectState() == EObjectStateType::Dynamic) { if (bInvalidate) { SetObjectStateHelper(*GetProxy(), *Rigid, EObjectStateType::Dynamic, true); } Rigid->AddForce(InForce, bInvalidate); } } })"
  },
  {
    "label": "SetAngularAcceleration()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAngularAcceleration(const FVec3& AngularAcceleration, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&AngularAcceleration, bInvalidate, this](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { if (Rigid->ObjectState() == EObjectStateType::Sleeping || Rigid->ObjectState() == EObjectStateType::Dynamic) { if (bInvalidate) { SetObjectStateHelper(*GetProxy(), *Rigid, EObjectStateType::Dynamic, true); } Rigid->SetAngularAcceleration(AngularAcceleration); } } })"
  },
  {
    "label": "AngularAcceleration()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "AngularAcceleration()"
  },
  {
    "label": "AddTorque()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddTorque(const FVec3& InTorque, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InTorque, bInvalidate, this](auto* Particle) { if (auto* Rigid = Particle->CastToRigidParticle()) { if (Rigid->ObjectState() == EObjectStateType::Sleeping || Rigid->ObjectState() == EObjectStateType::Dynamic) { if (bInvalidate) { SetObjectStateHelper(*GetProxy(), *Rigid, EObjectStateType::Dynamic, true); } Rigid->AddTorque(InTorque, bInvalidate); } } })"
  },
  {
    "label": "LinearImpulseVelocity()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "LinearImpulseVelocity()"
  },
  {
    "label": "LinearImpulse()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "LinearImpulse()"
  },
  {
    "label": "SetLinearImpulse()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetLinearImpulse(const FVec3& InLinearImpulse, bool bIsVelocity, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InLinearImpulse, bIsVelocity, bInvalidate, this](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { if (Rigid->ObjectState() == EObjectStateType::Sleeping || Rigid->ObjectState() == EObjectStateType::Dynamic) { if (bInvalidate) { SetObjectStateHelper(*GetProxy(), *Rigid, EObjectStateType::Dynamic, true); } if (bIsVelocity) { Rigid->SetLinearImpulseVelocity(InLinearImpulse, bInvalidate); } else { Rigid->SetLinearImpulseVelocity(InLinearImpulse * Rigid->InvM(), bInvalidate); } } } })"
  },
  {
    "label": "AngularImpulseVelocity()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "AngularImpulseVelocity()"
  },
  {
    "label": "AngularImpulse()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "AngularImpulse()"
  },
  {
    "label": "SetAngularImpulse()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAngularImpulse(const FVec3& InAngularImpulse, bool bIsVelocity, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InAngularImpulse, bIsVelocity, bInvalidate, this](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { if (Rigid->ObjectState() == EObjectStateType::Sleeping || Rigid->ObjectState() == EObjectStateType::Dynamic) { if (bInvalidate) { SetObjectStateHelper(*GetProxy(), *Rigid, EObjectStateType::Dynamic, true); } if (bIsVelocity) { Rigid->SetAngularImpulseVelocity(InAngularImpulse, bInvalidate); } else { const FMatrix33 WorldInvI = Utilities::ComputeWorldSpaceInertia(Rigid->GetR() * Rigid->RotationOfMass(), Rigid->InvI()); Rigid->SetAngularImpulseVelocity(WorldInvI * InAngularImpulse, bInvalidate); } } } })"
  },
  {
    "label": "I()",
    "kind": "Method",
    "detail": "Function (} const Chaos::TVec3<FRealSingle>)",
    "insertText": "I()"
  },
  {
    "label": "SetI()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetI(const Chaos::TVec3<FRealSingle>& InI)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InI](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { Rigid->SetI(InI); } })"
  },
  {
    "label": "InvI()",
    "kind": "Method",
    "detail": "Function (} const Chaos::TVec3<FRealSingle>)",
    "insertText": "InvI()"
  },
  {
    "label": "SetInvI()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetInvI(const Chaos::TVec3<FRealSingle>& InInvI)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InInvI](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { Rigid->SetInvI(InInvI); } })"
  },
  {
    "label": "M()",
    "kind": "Method",
    "detail": "Function (} const FReal)",
    "insertText": "M()"
  },
  {
    "label": "SetM()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetM(const FReal InM)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InM](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { Rigid->SetM(InM); } })"
  },
  {
    "label": "InvM()",
    "kind": "Method",
    "detail": "Function (} const FReal)",
    "insertText": "InvM()"
  },
  {
    "label": "SetInvM()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetInvM(const FReal InInvM)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InInvM](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { Rigid->SetInvM(InInvM); } })"
  },
  {
    "label": "CenterOfMass()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "CenterOfMass()"
  },
  {
    "label": "SetCenterOfMass()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCenterOfMass(const FVec3& InCenterOfMass, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InCenterOfMass, bInvalidate](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { Rigid->SetCenterOfMass(InCenterOfMass, bInvalidate); } })"
  },
  {
    "label": "RotationOfMass()",
    "kind": "Method",
    "detail": "Function (} const FRotation3)",
    "insertText": "RotationOfMass()"
  },
  {
    "label": "SetRotationOfMass()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetRotationOfMass(const FRotation3& InRotationOfMass, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InRotationOfMass, bInvalidate](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { Rigid->SetRotationOfMass(InRotationOfMass, bInvalidate); } })"
  },
  {
    "label": "LinearEtherDrag()",
    "kind": "Method",
    "detail": "Function (} const FReal)",
    "insertText": "LinearEtherDrag()"
  },
  {
    "label": "SetLinearEtherDrag()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetLinearEtherDrag(const FReal InLinearEtherDrag)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InLinearEtherDrag](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { Rigid->SetLinearEtherDrag(InLinearEtherDrag); } })"
  },
  {
    "label": "AngularEtherDrag()",
    "kind": "Method",
    "detail": "Function (} const FReal)",
    "insertText": "AngularEtherDrag()"
  },
  {
    "label": "SetAngularEtherDrag()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAngularEtherDrag(const FReal InAngularEtherDrag)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([&InAngularEtherDrag](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { Rigid->SetAngularEtherDrag(InAngularEtherDrag); } })"
  },
  {
    "label": "SetObjectStateBase()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "SetObjectStateBase(const EObjectStateType InState, bool bAllowEvents = false, bool bInvalidate = true)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([InState, bAllowEvents, bInvalidate, this](auto* Ptr) { if (auto Rigid = Ptr->CastToRigidParticle()) { SetObjectStateHelper(*this, *Rigid, InState, bAllowEvents, bInvalidate); } })"
  },
  {
    "label": "SetSleepType()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "SetSleepType(ESleepType InSleepType)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Write([InSleepType](auto* Particle) { if (auto Rigid = Particle->CastToRigidParticle()) { return Rigid->SetSleepType(InSleepType); } })"
  },
  {
    "label": "SleepType()",
    "kind": "Method",
    "detail": "Function (} ESleepType)",
    "insertText": "SleepType()"
  },
  {
    "label": "VerifyContext()",
    "kind": "Method",
    "detail": "Function (} return ESleepType::MaterialSleep ; } protected : void)",
    "insertText": "VerifyContext()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# if PHYSICS_THREAD_CONTEXT)",
    "insertText": "if(bExternal)"
  },
  {
    "label": "EnsureIsInPhysicsThreadContext()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "EnsureIsInPhysicsThreadContext()"
  },
  {
    "label": "Read()",
    "kind": "Method",
    "detail": "Function (} # endif } private : template<TLambda> auto)",
    "insertText": "Read(const TLambda& Lambda)"
  },
  {
    "label": "ReadRef()",
    "kind": "Method",
    "detail": "Function (} template<TLambda> const auto&)",
    "insertText": "ReadRef(const TLambda& Lambda)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (} template<TLambda> void)",
    "insertText": "Write(const TLambda& Lambda)"
  },
  {
    "label": "Lambda()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Lambda(GetParticle_LowLevel())"
  },
  {
    "label": "GetSolverBase()",
    "kind": "Method",
    "detail": "Function (} else { FPhysicsSolverBase* SolverBase =)",
    "insertText": "GetSolverBase()"
  },
  {
    "label": "MarkDirtyFromPT()",
    "kind": "Method",
    "detail": "Function (RewindData ->)",
    "insertText": "MarkDirtyFromPT(*GetHandle_LowLevel())"
  },
  {
    "label": "Lambda()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Lambda(GetHandle_LowLevel())"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } } ;)",
    "insertText": "static_assert(sizeof(TThreadedSingleParticlePhysicsProxyBase<true>) == sizeof(FSingleParticlePhysicsProxy), \"Derived types only used to constrain API, all data lives in base class \")"
  },
  {
    "label": "FRigidBodyHandle_External()",
    "kind": "Method",
    "detail": "Function (class FRigidBodyHandle_External : public TThreadedSingleParticlePhysicsProxyBase<true> {)",
    "insertText": "FRigidBodyHandle_External()"
  },
  {
    "label": "SetIgnoreAnalyticCollisions()",
    "kind": "Method",
    "detail": "Function (public : using Base = TThreadedSingleParticlePhysicsProxyBase<true> ; using Base::VerifyContext ; void)",
    "insertText": "SetIgnoreAnalyticCollisions(bool bIgnoreAnalyticCollisions)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->SetIgnoreAnalyticCollisions(bIgnoreAnalyticCollisions)"
  },
  {
    "label": "UpdateShapeBounds()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UpdateShapeBounds()"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->UpdateShapeBounds()"
  },
  {
    "label": "UpdateShapeBounds()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UpdateShapeBounds(const FTransform& Transform)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->UpdateShapeBounds(Transform)"
  },
  {
    "label": "SetShapeCollisionTraceType()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetShapeCollisionTraceType(int32 InShapeIndex, EChaosCollisionTraceFlag TraceType)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->SetShapeCollisionTraceType(InShapeIndex, TraceType)"
  },
  {
    "label": "SetShapeSimCollisionEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetShapeSimCollisionEnabled(int32 InShapeIndex, bool bInEnabled)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->SetShapeSimCollisionEnabled(InShapeIndex, bInEnabled)"
  },
  {
    "label": "SetShapeQueryCollisionEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetShapeQueryCollisionEnabled(int32 InShapeIndex, bool bInEnabled)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->SetShapeQueryCollisionEnabled(InShapeIndex, bInEnabled)"
  },
  {
    "label": "SetShapeSimData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetShapeSimData(int32 InShapeIndex, const FCollisionFilterData& SimData)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->SetShapeSimData(InShapeIndex, SimData)"
  },
  {
    "label": "SetParticleID()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetParticleID(const FParticleID& ParticleID)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->SetParticleID(ParticleID)"
  },
  {
    "label": "SetX()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetX(const FVec3& InX, bool bInvalidate = true)"
  },
  {
    "label": "SetXBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetXBase(InX, bInvalidate)"
  },
  {
    "label": "FSingleParticleProxyTimestamp()",
    "kind": "Method",
    "detail": "Function (FSingleParticleProxyTimestamp& SyncTS = GetSyncTimestampAs<)",
    "insertText": "FSingleParticleProxyTimestamp()"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (SyncTS . OverWriteX .)",
    "insertText": "Set(GetSolverSyncTimestamp_External(), InX)"
  },
  {
    "label": "SetR()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetR(const FRotation3& InR, bool bInvalidate = true)"
  },
  {
    "label": "SetRBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetRBase(InR, bInvalidate)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (SyncTS . OverWriteR .)",
    "insertText": "Set(GetSolverSyncTimestamp_External(), InR)"
  },
  {
    "label": "SetV()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetV(const FVec3& InV, bool bInvalidate = true)"
  },
  {
    "label": "SetVBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetVBase(InV, bInvalidate)"
  },
  {
    "label": "SetX()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetX(X(), bInvalidate)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (SyncTS . OverWriteV .)",
    "insertText": "Set(GetSolverSyncTimestamp_External(), InV)"
  },
  {
    "label": "SetW()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetW(const FVec3& InW, bool bInvalidate = true)"
  },
  {
    "label": "SetWBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetWBase(InW, bInvalidate)"
  },
  {
    "label": "SetR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetR(R(), bInvalidate)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (SyncTS . OverWriteW .)",
    "insertText": "Set(GetSolverSyncTimestamp_External(), InW)"
  },
  {
    "label": "SetObjectState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetObjectState(const EObjectStateType InState, bool bAllowEvents = false, bool bInvalidate = true)"
  },
  {
    "label": "GetSolverSyncTimestamp_External()",
    "kind": "Method",
    "detail": "Function (SyncTS . ObjectStateTimestamp =)",
    "insertText": "GetSolverSyncTimestamp_External()"
  },
  {
    "label": "SetV()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetV(FVec3(0), bInvalidate)"
  },
  {
    "label": "SetW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetW(FVec3(0), bInvalidate)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InState == EObjectStateType::Kinematic && Rigid->ObjectState() != EObjectStateType::Kinematic)"
  },
  {
    "label": "SetKinematicTarget()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetKinematicTarget(Chaos::FKinematicTarget(), bInvalidate)"
  },
  {
    "label": "SetObjectStateBase()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "SetObjectStateBase(InState, bAllowEvents, bInvalidate)"
  },
  {
    "label": "Island()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Island()"
  },
  {
    "label": "SetIsland()",
    "kind": "Method",
    "detail": "Function (} return INDEX_NONE ; } void)",
    "insertText": "SetIsland(const int32 InIsland)"
  },
  {
    "label": "SetIsland()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetIsland(InIsland)"
  },
  {
    "label": "ClearForces()",
    "kind": "Method",
    "detail": "Function (} return EWakeEventEntry::None ; } void)",
    "insertText": "ClearForces(bool bInvalidate = true)"
  },
  {
    "label": "ClearForces()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "ClearForces(bInvalidate)"
  },
  {
    "label": "ClearTorques()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ClearTorques(bool bInvalidate = true)"
  },
  {
    "label": "ClearTorques()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "ClearTorques(bInvalidate)"
  },
  {
    "label": "UserData()",
    "kind": "Method",
    "detail": "Function (} } void*)",
    "insertText": "UserData()"
  },
  {
    "label": "SetUserData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetUserData(void* InUserData)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->SetUserData(InUserData)"
  },
  {
    "label": "SetGeometry()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetGeometry(const Chaos::FImplicitObjectPtr& ImplicitGeometryPtr)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->SetGeometry(ImplicitGeometryPtr)"
  },
  {
    "label": "RemoveShape()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveShape(FPerShapeData* InShape, bool bWakeTouching)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->RemoveShape(InShape, bWakeTouching)"
  },
  {
    "label": "MergeShapesArray()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MergeShapesArray(FShapesArray&& OtherShapesArray)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->MergeShapesArray(MoveTemp(OtherShapesArray))"
  },
  {
    "label": "MergeGeometry()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MergeGeometry(TArray<Chaos::FImplicitObjectPtr>&& Objects)"
  },
  {
    "label": "GetParticle_LowLevel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetParticle_LowLevel()->MergeGeometry(MoveTemp(Objects))"
  },
  {
    "label": "IsKinematicTargetDirty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsKinematicTargetDirty()"
  },
  {
    "label": "ClearKinematicTarget()",
    "kind": "Method",
    "detail": "Function (} return false ; } void)",
    "insertText": "ClearKinematicTarget()"
  },
  {
    "label": "SetSmoothEdgeCollisionsEnabled()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetSmoothEdgeCollisionsEnabled(bool bEnabled)"
  },
  {
    "label": "AddCollisionConstraintFlag()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "AddCollisionConstraintFlag(ECollisionConstraintFlags::CCF_SmoothEdgeCollisions)"
  },
  {
    "label": "RemoveCollisionConstraintFlag()",
    "kind": "Method",
    "detail": "Function (} else { Rigid ->)",
    "insertText": "RemoveCollisionConstraintFlag(ECollisionConstraintFlags::CCF_SmoothEdgeCollisions)"
  },
  {
    "label": "SetCCDEnabled()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "SetCCDEnabled(bool bEnabled)"
  },
  {
    "label": "SetCCDEnabled()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetCCDEnabled(bEnabled)"
  },
  {
    "label": "SetMACDEnabled()",
    "kind": "Method",
    "detail": "Function (} return false ; } void)",
    "insertText": "SetMACDEnabled(bool bEnabled)"
  },
  {
    "label": "SetMACDEnabled()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetMACDEnabled(bEnabled)"
  },
  {
    "label": "IterationSettings()",
    "kind": "Method",
    "detail": "Function (} return false ; } Private::FIterationSettings)",
    "insertText": "IterationSettings()"
  },
  {
    "label": "FIterationSettings()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "FIterationSettings(0, 0, 0)"
  },
  {
    "label": "SetPositionSolverIterationCount()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetPositionSolverIterationCount(uint32 PositionSolverIterationCountIn)"
  },
  {
    "label": "SetPositionSolverIterations()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetPositionSolverIterations(PositionSolverIterationCountIn)"
  },
  {
    "label": "SetVelocitySolverIterationCount()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetVelocitySolverIterationCount(uint32 VelocitySolverIterationCountIn)"
  },
  {
    "label": "SetVelocitySolverIterations()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetVelocitySolverIterations(VelocitySolverIterationCountIn)"
  },
  {
    "label": "SetProjectionSolverIterationCount()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetProjectionSolverIterationCount(uint32 ProjectionSolverIterationCountIn)"
  },
  {
    "label": "SetProjectionSolverIterations()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetProjectionSolverIterations(ProjectionSolverIterationCountIn)"
  },
  {
    "label": "SetMaxLinearSpeedSq()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetMaxLinearSpeedSq(FReal InNewSpeed)"
  },
  {
    "label": "SetMaxLinearSpeedSq()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetMaxLinearSpeedSq(InNewSpeed)"
  },
  {
    "label": "GetMaxLinearSpeedSq()",
    "kind": "Method",
    "detail": "Function (} } FReal)",
    "insertText": "GetMaxLinearSpeedSq()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} return TNumericLimits<FReal)",
    "insertText": "Max()"
  },
  {
    "label": "SetMaxAngularSpeedSq()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetMaxAngularSpeedSq(FReal InNewSpeed)"
  },
  {
    "label": "SetMaxAngularSpeedSq()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetMaxAngularSpeedSq(InNewSpeed)"
  },
  {
    "label": "GetMaxAngularSpeedSq()",
    "kind": "Method",
    "detail": "Function (} } FReal)",
    "insertText": "GetMaxAngularSpeedSq()"
  },
  {
    "label": "GetInitialOverlapDepenetrationVelocity()",
    "kind": "Method",
    "detail": "Function (} FRealSingle)",
    "insertText": "GetInitialOverlapDepenetrationVelocity()"
  },
  {
    "label": "SetInitialOverlapDepenetrationVelocity()",
    "kind": "Method",
    "detail": "Function (} return 0 ; } void)",
    "insertText": "SetInitialOverlapDepenetrationVelocity(FRealSingle InNewSpeed)"
  },
  {
    "label": "SetInitialOverlapDepenetrationVelocity()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetInitialOverlapDepenetrationVelocity(InNewSpeed)"
  },
  {
    "label": "SetSleepThresholdMultiplier()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetSleepThresholdMultiplier(FRealSingle Multiplier)"
  },
  {
    "label": "SetSleepThresholdMultiplier()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetSleepThresholdMultiplier(Multiplier)"
  },
  {
    "label": "SetDisabled()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetDisabled(bool bDisable)"
  },
  {
    "label": "SetDisabled()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetDisabled(bDisable)"
  },
  {
    "label": "Disabled()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "Disabled()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} return false ; } } ;)",
    "insertText": "static_assert(sizeof(FRigidBodyHandle_External) == sizeof(FSingleParticlePhysicsProxy), \"Derived types only used to constrain API, all data lives in base class \")"
  },
  {
    "label": "FRigidBodyHandle_Internal()",
    "kind": "Method",
    "detail": "Function (class FRigidBodyHandle_Internal : public TThreadedSingleParticlePhysicsProxyBase<false> {)",
    "insertText": "FRigidBodyHandle_Internal()"
  },
  {
    "label": "PreV()",
    "kind": "Method",
    "detail": "Function (public : using Base = TThreadedSingleParticlePhysicsProxyBase<false> ; const FVec3)",
    "insertText": "PreV()"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "FVec3(0)"
  },
  {
    "label": "PreW()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "PreW()"
  },
  {
    "label": "SetP()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetP(InX)"
  },
  {
    "label": "SetQ()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "SetQ(InR)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "static_assert(sizeof(FRigidBodyHandle_Internal) == sizeof(FSingleParticlePhysicsProxy), \"Derived types only used to constrain API, all data lives in base class \")"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (FSingleParticlePhysicsProxy*)",
    "insertText": "Create(TUniquePtr<FGeometryParticle>&& Particle)"
  },
  {
    "label": "FSingleParticlePhysicsProxy()",
    "kind": "Method",
    "detail": "Function (auto Proxy = new)",
    "insertText": "FSingleParticlePhysicsProxy(MoveTemp(Particle), nullptr)"
  }
]