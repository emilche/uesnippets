[
  {
    "label": "evaluator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "evaluator"
  },
  {
    "label": "evaluator_assume_aliasing",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "evaluator_assume_aliasing"
  },
  {
    "label": "generic_product_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "generic_product_impl"
  },
  {
    "label": "product_evaluator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "product_evaluator"
  },
  {
    "label": "Assignment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Assignment"
  },
  {
    "label": "assignment_from_xpr_op_product",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "assignment_from_xpr_op_product"
  },
  {
    "label": "is_row_major",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_row_major"
  },
  {
    "label": "set",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "set"
  },
  {
    "label": "add",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "add"
  },
  {
    "label": "sub",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "sub"
  },
  {
    "label": "adds",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "adds"
  },
  {
    "label": "generic_product_impl_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "generic_product_impl_base"
  },
  {
    "label": "etor_product_coeff_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "etor_product_coeff_impl"
  },
  {
    "label": "etor_product_packet_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "etor_product_packet_impl"
  },
  {
    "label": "triangular_product_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "triangular_product_impl"
  },
  {
    "label": "selfadjoint_product_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "selfadjoint_product_impl"
  },
  {
    "label": "diagonal_product_evaluator_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "diagonal_product_evaluator_base"
  },
  {
    "label": "permutation_matrix_product",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "permutation_matrix_product"
  },
  {
    "label": "transposition_matrix_product",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "transposition_matrix_product"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_PRODUCTEVALUATORS_H # define EIGEN_PRODUCTEVALUATORS_H namespace Eigen { namespace internal { template<Lhs,Rhs,int Options> struct evaluator<Product<Lhs,Rhs,Options>> : public product_evaluator<Product<Lhs,Rhs,Options>> { typedef Product<Lhs,Rhs,Options> XprType ; typedef product_evaluator<XprType> Base ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator(const XprType& xpr) : Base(xpr)"
  },
  {
    "label": "EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs,Scalar1,Scalar2,Plain1> struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_product_op<Scalar1,Scalar2>,const CwiseNullaryOp<internal::scalar_constant_op<Scalar1>,Plain1>,const Product<Lhs,Rhs,DefaultProduct>>> { const bool value = true ; } ; template<Lhs,Rhs,Scalar1,Scalar2,Plain1> struct evaluator<CwiseBinaryOp<internal::scalar_product_op<Scalar1,Scalar2>,const CwiseNullaryOp<internal::scalar_constant_op<Scalar1>,Plain1>,const Product<Lhs,Rhs,DefaultProduct>>> : public evaluator<Product<)",
    "insertText": "EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(Scalar1,Lhs,product)"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator(const XprType& xpr) : Base(xpr.lhs().functor().m_other * xpr.rhs().lhs() * xpr.rhs().rhs())"
  },
  {
    "label": "evaluator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs,int DiagIndex> struct evaluator<Diagonal<const Product<Lhs,Rhs,DefaultProduct>,DiagIndex>> : public evaluator<Diagonal<const Product<Lhs,Rhs,LazyProduct>,DiagIndex>> { typedef Diagonal<const Product<Lhs,Rhs,DefaultProduct>,DiagIndex> XprType ; typedef evaluator<Diagonal<const Product<Lhs,Rhs,LazyProduct>,DiagIndex>> Base ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "evaluator(const XprType& xpr) : Base(Diagonal<const Product<Lhs, Rhs, LazyProduct>, DiagIndex>( Product<Lhs, Rhs, LazyProduct>(xpr.nestedExpression().lhs(), xpr.nestedExpression().rhs()), xpr.index() ))"
  },
  {
    "label": "product_evaluator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs,LhsShape = evaluator_traits<Lhs>::Shape,RhsShape = evaluator_traits<Rhs>::Shape,int ProductType = internal::product_type<Lhs,Rhs>::value> struct generic_product_impl ; template<Lhs,Rhs> struct evaluator_assume_aliasing<Product<Lhs,Rhs,DefaultProduct>> { const bool value = true ; } ; template<Lhs,Rhs,int Options,int ProductTag,LhsShape,RhsShape> struct product_evaluator<Product<Lhs,Rhs,Options>,ProductTag,LhsShape,RhsShape> : public evaluator<Product<Lhs,Rhs,Options>::PlainObject> { typedef Product<Lhs,Rhs,Options> XprType ; typedef XprType::PlainObject PlainObject ; typedef evaluator<PlainObject> Base ; enum { Flags = Base::Flags | EvalBeforeNestingBit } ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "product_evaluator(const XprType& xpr) : m_result(xpr.rows(), xpr.cols())"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(static_cast<Base*>(this)) Base(m_result)"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (generic_product_impl<Lhs,Rhs,LhsShape,RhsShape,ProductTag)",
    "insertText": "evalTo(m_result, xpr.lhs(), xpr.rhs())"
  },
  {
    "label": "enable_if()",
    "kind": "Method",
    "detail": "Function (} protected : PlainObject m_result ; } ; template<DstXprType,Lhs,Rhs,int Options,Scalar> struct Assignment<DstXprType,Product<Lhs,Rhs,Options>,internal::assign_op<Scalar,Scalar>,Dense2Dense,)",
    "insertText": "enable_if(Options==DefaultProduct || Options==AliasFreeProduct)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (typedef Product<Lhs,Rhs,Options> SrcXprType ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (Index dstRows = src .)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (Index dstCols = src .)",
    "insertText": "cols()"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (generic_product_impl<Lhs,Rhs)",
    "insertText": "evalTo(dst, src.lhs(), src.rhs())"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (typedef Product<Lhs,Rhs,Options> SrcXprType ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<Scalar,Scalar> &)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols())"
  },
  {
    "label": "addTo()",
    "kind": "Method",
    "detail": "Function (generic_product_impl<Lhs,Rhs)",
    "insertText": "addTo(dst, src.lhs(), src.rhs())"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (typedef Product<Lhs,Rhs,Options> SrcXprType ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<Scalar,Scalar> &)"
  },
  {
    "label": "subTo()",
    "kind": "Method",
    "detail": "Function (generic_product_impl<Lhs,Rhs)",
    "insertText": "subTo(dst, src.lhs(), src.rhs())"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<DstXprType,Lhs,Rhs,AssignFunc,Scalar,ScalarBis,Plain> struct Assignment<DstXprType,CwiseBinaryOp<internal::scalar_product_op<ScalarBis,Scalar>,const CwiseNullaryOp<internal::scalar_constant_op<ScalarBis>,Plain>,const Product<Lhs,Rhs,DefaultProduct>>,AssignFunc,Dense2Dense> { typedef CwiseBinaryOp<internal::scalar_product_op<ScalarBis,Scalar>,const CwiseNullaryOp<internal::scalar_constant_op<ScalarBis>,Plain>,const Product<Lhs,Rhs,DefaultProduct>> SrcXprType ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(DstXprType &dst, const SrcXprType &src, const AssignFunc& func)"
  },
  {
    "label": "call_assignment_no_alias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_assignment_no_alias(dst, (src.lhs().functor().m_other * src.rhs().lhs())*src.rhs().rhs(), func)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<OtherXpr,Lhs,Rhs> struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_sum_op<OtherXpr::Scalar,Product<Lhs,Rhs,DefaultProduct>::Scalar>,const OtherXpr,const Product<Lhs,Rhs,DefaultProduct>>,DenseShape> { const bool value = true ; } ; template<OtherXpr,Lhs,Rhs> struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_difference_op<OtherXpr::Scalar,Product<Lhs,Rhs,DefaultProduct>::Scalar>,const OtherXpr,const Product<Lhs,Rhs,DefaultProduct>>,DenseShape> { const bool value = true ; } ; template<DstXprType,OtherXpr,ProductType,Func1,Func2> struct assignment_from_xpr_op_product { template<SrcXprType,InitialFunc> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(DstXprType &dst, const SrcXprType &src, const InitialFunc&)"
  },
  {
    "label": "call_assignment_no_alias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_assignment_no_alias(dst, src.lhs(), Func1())"
  },
  {
    "label": "call_assignment_no_alias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_assignment_no_alias(dst, src.rhs(), Func2())"
  },
  {
    "label": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT()",
    "kind": "Method",
    "detail": "Function (} } ; # define)",
    "insertText": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(ASSIGN_OP,BINOP,ASSIGN_OP2)"
  },
  {
    "label": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(assign_op, scalar_sum_op,add_assign_op)"
  },
  {
    "label": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(add_assign_op,scalar_sum_op,add_assign_op)"
  },
  {
    "label": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(sub_assign_op,scalar_sum_op,sub_assign_op)"
  },
  {
    "label": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(assign_op, scalar_difference_op,sub_assign_op)"
  },
  {
    "label": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(add_assign_op,scalar_difference_op,sub_assign_op)"
  },
  {
    "label": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(sub_assign_op,scalar_difference_op,add_assign_op)"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (template<Lhs,Rhs> struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,InnerProduct> { template<Dst> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "coeffRef(0,0) = (lhs.transpose().cwiseProduct(rhs)).sum()"
  },
  {
    "label": "addTo()",
    "kind": "Method",
    "detail": "Function (} template<Dst> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "coeffRef(0,0) += (lhs.transpose().cwiseProduct(rhs)).sum()"
  },
  {
    "label": "subTo()",
    "kind": "Method",
    "detail": "Function (} template<Dst> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "coeffRef(0,0) -= (lhs.transpose().cwiseProduct(rhs)).sum()"
  },
  {
    "label": "outer_product_selector_run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Dst,Lhs,Rhs,Func> void EIGEN_DEVICE_FUNC)",
    "insertText": "outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const false_type&)"
  },
  {
    "label": "rhsEval()",
    "kind": "Method",
    "detail": "Function (evaluator<Rhs>)",
    "insertText": "rhsEval(rhs)"
  },
  {
    "label": "ei_declare_local_nested_eval()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ei_declare_local_nested_eval(Lhs,lhs,Rhs::SizeAtCompileTime,actual_lhs)"
  },
  {
    "label": "outer_product_selector_run()",
    "kind": "Method",
    "detail": "Function (} template<Dst,Lhs,Rhs,Func> void EIGEN_DEVICE_FUNC)",
    "insertText": "outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const true_type&)"
  },
  {
    "label": "lhsEval()",
    "kind": "Method",
    "detail": "Function (evaluator<Lhs>)",
    "insertText": "lhsEval(lhs)"
  },
  {
    "label": "ei_declare_local_nested_eval()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ei_declare_local_nested_eval(Rhs,rhs,Lhs::SizeAtCompileTime,actual_rhs)"
  },
  {
    "label": "conditional()",
    "kind": "Method",
    "detail": "Function (} template<Lhs,Rhs> struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,OuterProduct> { template<T> struct is_row_major :)",
    "insertText": "conditional(int(T::Flags)&RowMajorBit)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; typedef Product<Lhs,Rhs>::Scalar Scalar ; struct set { template<Dst,Src> EIGEN_DEVICE_FUNC void)",
    "insertText": "operator()(const Dst& dst, const Src& src)"
  },
  {
    "label": "const_cast_derived()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "const_cast_derived()"
  },
  {
    "label": "adds()",
    "kind": "Method",
    "detail": "Function (} } ; struct adds { Scalar m_scale ;)",
    "insertText": "adds(const Scalar& s) : m_scale(s)"
  },
  {
    "label": "outer_product_selector_run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outer_product_selector_run(dst, lhs, rhs, set(), is_row_major<Dst>())"
  },
  {
    "label": "outer_product_selector_run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outer_product_selector_run(dst, lhs, rhs, add(), is_row_major<Dst>())"
  },
  {
    "label": "outer_product_selector_run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outer_product_selector_run(dst, lhs, rhs, sub(), is_row_major<Dst>())"
  },
  {
    "label": "scaleAndAddTo()",
    "kind": "Method",
    "detail": "Function (} template<Dst> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)"
  },
  {
    "label": "outer_product_selector_run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "outer_product_selector_run(dst, lhs, rhs, adds(alpha), is_row_major<Dst>())"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "setZero()"
  },
  {
    "label": "scaleAndAddTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "scaleAndAddTo(dst, lhs, rhs, Scalar(1))"
  },
  {
    "label": "scaleAndAddTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "scaleAndAddTo(dst,lhs, rhs, Scalar(1))"
  },
  {
    "label": "scaleAndAddTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "scaleAndAddTo(dst, lhs, rhs, Scalar(-1))"
  },
  {
    "label": "scaleAndAddTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "scaleAndAddTo(dst,lhs,rhs,alpha)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs> struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemvProduct> : generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemvProduct>> { typedef nested_eval<Lhs,1>::type LhsNested ; typedef nested_eval<Rhs,1>::type RhsNested ; typedef Product<Lhs,Rhs>::Scalar Scalar ; enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight } ; typedef internal::remove_all<internal::conditional<)",
    "insertText": "int(Side)"
  },
  {
    "label": "scaleAndAddTo()",
    "kind": "Method",
    "detail": "Function (template<Dest> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (dst .)",
    "insertText": "coeffRef(0,0) += alpha * lhs.row(0).conjugate().dot(rhs.col(0))"
  },
  {
    "label": "actual_rhs()",
    "kind": "Method",
    "detail": "Function (RhsNested)",
    "insertText": "actual_rhs(rhs)"
  },
  {
    "label": "Side()",
    "kind": "Method",
    "detail": "Function (internal::gemv_dense_selector<)",
    "insertText": "Side(int(MatrixType::Flags)&RowMajorBit) ? RowMajor : ColMajor, bool(internal::blas_traits<MatrixType>::HasUsableDirectAccess) >::run(actual_lhs, actual_rhs, dst, alpha)"
  },
  {
    "label": "call_assignment_no_alias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_assignment_no_alias(dst, lhs.lazyProduct(rhs), internal::assign_op<typename Dst::Scalar,Scalar>())"
  },
  {
    "label": "call_assignment_no_alias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_assignment_no_alias(dst, lhs.lazyProduct(rhs), internal::add_assign_op<typename Dst::Scalar,Scalar>())"
  },
  {
    "label": "call_assignment_no_alias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_assignment_no_alias(dst, lhs.lazyProduct(rhs), internal::sub_assign_op<typename Dst::Scalar,Scalar>())"
  },
  {
    "label": "eval_dynamic()",
    "kind": "Method",
    "detail": "Function (} template<Dst,Func> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "eval_dynamic(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Func &func)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (enum { HasScalarFactor = blas_traits<Lhs>::HasScalarFactor | | blas_traits<Rhs>::HasScalarFactor,ConjLhs = blas_traits<Lhs>::NeedToConjugate,ConjRhs = blas_traits<Rhs>::NeedToConjugate } ; Scalar actualAlpha = combine_scalar_factors<)",
    "insertText": "Scalar(lhs, rhs)"
  },
  {
    "label": "eval_dynamic_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eval_dynamic_impl(dst, blas_traits<Lhs>::extract(lhs).template conjugateIf<ConjLhs>(), blas_traits<Rhs>::extract(rhs).template conjugateIf<ConjRhs>(), func, actualAlpha, typename conditional<HasScalarFactor,true_type,false_type>::type())"
  },
  {
    "label": "eval_dynamic_impl()",
    "kind": "Method",
    "detail": "Function (} protected : template<Dst,LhsT,RhsT,Func,Scalar> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "eval_dynamic_impl(Dst& dst, const LhsT& lhs, const RhsT& rhs, const Func &func, const Scalar& s , false_type)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(s)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(s==Scalar(1))"
  },
  {
    "label": "call_restricted_packet_assignment_no_alias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_restricted_packet_assignment_no_alias(dst, lhs.lazyProduct(rhs), func)"
  },
  {
    "label": "eval_dynamic_impl()",
    "kind": "Method",
    "detail": "Function (} template<Dst,LhsT,RhsT,Func,Scalar> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "eval_dynamic_impl(Dst& dst, const LhsT& lhs, const RhsT& rhs, const Func &func, const Scalar& s, true_type)"
  },
  {
    "label": "call_restricted_packet_assignment_no_alias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "call_restricted_packet_assignment_no_alias(dst, s * lhs.lazyProduct(rhs), func)"
  },
  {
    "label": "product_evaluator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs> struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,LazyCoeffBasedProductMode> : generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode> { } ; template<int Traversal,int UnrollingIndex,Lhs,Rhs,RetScalar> struct etor_product_coeff_impl ; template<int StorageOrder,int UnrollingIndex,Lhs,Rhs,Packet,int LoadMode> struct etor_product_packet_impl ; template<Lhs,Rhs,int ProductTag> struct product_evaluator<Product<Lhs,Rhs,LazyProduct>,ProductTag,DenseShape,DenseShape> : evaluator_base<Product<Lhs,Rhs,LazyProduct>> { typedef Product<Lhs,Rhs,LazyProduct> XprType ; typedef XprType::Scalar Scalar ; typedef XprType::CoeffReturnType CoeffReturnType ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "product_evaluator(const XprType& xpr) : m_lhs(xpr.lhs()), m_rhs(xpr.rhs()), m_lhsImpl(m_lhs), m_rhsImpl(m_rhs), m_innerDim(xpr.lhs().cols())"
  },
  {
    "label": "EIGEN_INTERNAL_CHECK_COST_VALUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_CHECK_COST_VALUE(NumTraits<Scalar>::MulCost)"
  },
  {
    "label": "EIGEN_INTERNAL_CHECK_COST_VALUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_CHECK_COST_VALUE(NumTraits<Scalar>::AddCost)"
  },
  {
    "label": "EIGEN_INTERNAL_CHECK_COST_VALUE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost)"
  },
  {
    "label": "EIGEN_SIZE_MIN_PREFER_FIXED()",
    "kind": "Method",
    "detail": "Function (# if 0 std::cerr<<\" LhsOuterStrideBytes = \"<<LhsOuterStrideBytes<<\" \\ n \" ; std::cerr<<\" RhsOuterStrideBytes = \"<<RhsOuterStrideBytes<<\" \\ n \" ; std::cerr<<\" LhsAlignment = \"<<LhsAlignment<<\" \\ n \" ; std::cerr<<\" RhsAlignment = \"<<RhsAlignment<<\" \\ n \" ; std::cerr<<\" CanVectorizeLhs = \"<<CanVectorizeLhs<<\" \\ n \" ; std::cerr<<\" CanVectorizeRhs = \"<<CanVectorizeRhs<<\" \\ n \" ; std::cerr<<\" CanVectorizeInner = \"<<CanVectorizeInner<<\" \\ n \" ; std::cerr<<\" EvalToRowMajor = \"<<EvalToRowMajor<<\" \\ n \" ; std::cerr<<\" Alignment = \"<<Alignment<<\" \\ n \" ; std::cerr<<\" Flags = \"<<Flags<<\" \\ n \" ; # endif } typedef internal::nested_eval<Lhs,Rhs::ColsAtCompileTime>::type LhsNested ; typedef internal::nested_eval<Rhs,Lhs::RowsAtCompileTime>::type RhsNested ; typedef internal::remove_all<LhsNested>::type LhsNestedCleaned ; typedef internal::remove_all<RhsNested>::type RhsNestedCleaned ; typedef evaluator<LhsNestedCleaned> LhsEtorType ; typedef evaluator<RhsNestedCleaned> RhsEtorType ; enum { RowsAtCompileTime = LhsNestedCleaned::RowsAtCompileTime,ColsAtCompileTime = RhsNestedCleaned::ColsAtCompileTime,InnerSize =)",
    "insertText": "EIGEN_SIZE_MIN_PREFER_FIXED(LhsNestedCleaned::ColsAtCompileTime, RhsNestedCleaned::RowsAtCompileTime)"
  },
  {
    "label": "InnerSize()",
    "kind": "Method",
    "detail": "Function (typedef find_best_packet<Scalar,RowsAtCompileTime>::type LhsVecPacketType ; typedef find_best_packet<Scalar,ColsAtCompileTime>::type RhsVecPacketType ; enum { LhsCoeffReadCost = LhsEtorType::CoeffReadCost,RhsCoeffReadCost = RhsEtorType::CoeffReadCost,CoeffReadCost = InnerSize = = 0 ? NumTraits<Scalar>::ReadCost : InnerSize = = Dynamic ? HugeCost :)",
    "insertText": "InnerSize(NumTraits<Scalar>::MulCost + int(LhsCoeffReadCost) + int(RhsCoeffReadCost)) + (InnerSize - 1) * NumTraits<Scalar>::AddCost, Unroll = CoeffReadCost <= EIGEN_UNROLLING_LIMIT, LhsFlags = LhsEtorType::Flags, RhsFlags = RhsEtorType::Flags, LhsRowMajor = LhsFlags & RowMajorBit, RhsRowMajor = RhsFlags & RowMajorBit, LhsVecPacketSize = unpacket_traits<LhsVecPacketType>::size, RhsVecPacketSize = unpacket_traits<RhsVecPacketType>::size, LhsAlignment = EIGEN_PLAIN_ENUM_MIN(LhsEtorType::Alignment,LhsVecPacketSize*int(sizeof(typename LhsNestedCleaned::Scalar))), RhsAlignment = EIGEN_PLAIN_ENUM_MIN(RhsEtorType::Alignment,RhsVecPacketSize*int(sizeof(typename RhsNestedCleaned::Scalar))), SameType = is_same<typename LhsNestedCleaned::Scalar,typename RhsNestedCleaned::Scalar>::value, CanVectorizeRhs = bool(RhsRowMajor) && (RhsFlags & PacketAccessBit) && (ColsAtCompileTime!=1), CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit) && (RowsAtCompileTime!=1), EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1 : (MaxColsAtCompileTime==1&&MaxRowsAtCompileTime!=1) ? 0 : (bool(RhsRowMajor) && !CanVectorizeLhs), Flags = ((int(LhsFlags) | int(RhsFlags)) & HereditaryBits & ~RowMajorBit) | (EvalToRowMajor ? RowMajorBit : 0) | (SameType && (CanVectorizeLhs || CanVectorizeRhs) ? PacketAccessBit : 0) | (XprType::IsVectorAtCompileTime ? LinearAccessBit : 0), LhsOuterStrideBytes = int(LhsNestedCleaned::OuterStrideAtCompileTime) * int(sizeof(typename LhsNestedCleaned::Scalar)), RhsOuterStrideBytes = int(RhsNestedCleaned::OuterStrideAtCompileTime) * int(sizeof(typename RhsNestedCleaned::Scalar)), Alignment = bool(CanVectorizeLhs) ? (LhsOuterStrideBytes<=0 || (int(LhsOuterStrideBytes) % EIGEN_PLAIN_ENUM_MAX(1,LhsAlignment))!=0 ? 0 : LhsAlignment) : bool(CanVectorizeRhs) ? (RhsOuterStrideBytes<=0 || (int(RhsOuterStrideBytes) % EIGEN_PLAIN_ENUM_MAX(1,RhsAlignment))!=0 ? 0 : RhsAlignment) : 0, CanVectorizeInner = SameType && LhsRowMajor && (!RhsRowMajor) && (int(LhsFlags) & int(RhsFlags) & ActualPacketAccessBit) && (int(InnerSize) % packet_traits<Scalar>::size == 0)"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const CoeffReturnType)",
    "insertText": "coeff(Index row, Index col)"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const CoeffReturnType)",
    "insertText": "coeff(Index index)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "row(RowsAtCompileTime == 1 || MaxRowsAtCompileTime==1)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "col(RowsAtCompileTime == 1 || MaxRowsAtCompileTime==1)"
  },
  {
    "label": "packet()",
    "kind": "Method",
    "detail": "Function (} template<int LoadMode,PacketType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const PacketType)",
    "insertText": "packet(Index row, Index col)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (PacketType res ; typedef etor_product_packet_impl<)",
    "insertText": "bool(int(Flags)&RowMajorBit) ? RowMajor : ColMajor, Unroll ? int(InnerSize)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "run(row, col, m_lhsImpl, m_rhsImpl, m_innerDim, res)"
  },
  {
    "label": "product_evaluator()",
    "kind": "Method",
    "detail": "Function (} protected : internal::add_const_on_value_type<LhsNested>::type m_lhs ; internal::add_const_on_value_type<RhsNested>::type m_rhs ; LhsEtorType m_lhsImpl ; RhsEtorType m_rhsImpl ; Index m_innerDim ; } ; template<Lhs,Rhs> struct product_evaluator<Product<Lhs,Rhs,DefaultProduct>,LazyCoeffBasedProductMode,DenseShape,DenseShape> : product_evaluator<Product<Lhs,Rhs,LazyProduct>,CoeffBasedProductMode,DenseShape,DenseShape> { typedef Product<Lhs,Rhs,DefaultProduct> XprType ; typedef Product<Lhs,Rhs,LazyProduct> BaseProduct ; typedef product_evaluator<BaseProduct,CoeffBasedProductMode,DenseShape,DenseShape> Base ; enum { Flags = Base::Flags | EvalBeforeNestingBit } ; EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE)",
    "insertText": "product_evaluator(const XprType& xpr) : Base(BaseProduct(xpr.lhs(),xpr.rhs()))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<int UnrollingIndex,Lhs,Rhs,Packet,int LoadMode> struct etor_product_packet_impl<RowMajor,UnrollingIndex,Lhs,Rhs,Packet,LoadMode> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet &res)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (etor_product_packet_impl<RowMajor,UnrollingIndex - 1,Lhs,Rhs,Packet,LoadMode)",
    "insertText": "run(row, col, lhs, rhs, innerDim, res)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (res =)",
    "insertText": "pmadd(pset1<Packet>(lhs.coeff(row, Index(UnrollingIndex-1))), rhs.template packet<LoadMode,Packet>(Index(UnrollingIndex-1), col), res)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (res =)",
    "insertText": "pmadd(lhs.template packet<LoadMode,Packet>(row, Index(UnrollingIndex-1)), pset1<Packet>(rhs.coeff(Index(UnrollingIndex-1), col)), res)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs,Packet,int LoadMode> struct etor_product_packet_impl<RowMajor,1,Lhs,Rhs,Packet,LoadMode> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index , Packet &res)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (res =)",
    "insertText": "pmul(pset1<Packet>(lhs.coeff(row, Index(0))),rhs.template packet<LoadMode,Packet>(Index(0), col))"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (res =)",
    "insertText": "pmul(lhs.template packet<LoadMode,Packet>(row, Index(0)), pset1<Packet>(rhs.coeff(Index(0), col)))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs,Packet,int LoadMode> struct etor_product_packet_impl<RowMajor,0,Lhs,Rhs,Packet,LoadMode> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(Index , Index , const Lhs& , const Rhs& , Index , Packet &res)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (res = pset1<)",
    "insertText": "Packet(typename unpacket_traits<Packet>::type(0))"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs,Packet,int LoadMode> struct etor_product_packet_impl<RowMajor,Dynamic,Lhs,Rhs,Packet,LoadMode> { EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet& res)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (triangular_product_impl<Lhs::Mode,true,Lhs::MatrixType,false,Rhs,Rhs::ColsAtCompileTime = = 1)",
    "insertText": "run(dst, lhs.nestedExpression(), rhs, alpha)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (triangular_product_impl<Rhs::Mode,false,Lhs,Lhs::RowsAtCompileTime = = 1,Rhs::MatrixType,false)",
    "insertText": "run(dst, lhs, rhs.nestedExpression(), alpha)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} } ; template<MatrixType,DiagonalType,Derived,int ProductOrder> struct diagonal_product_evaluator_base : evaluator_base<Derived> { typedef ScalarBinaryOpTraits<MatrixType::Scalar,DiagonalType::Scalar>::ReturnType Scalar ; public : enum { CoeffReadCost =)",
    "insertText": "int(NumTraits<Scalar>::MulCost) + int(evaluator<MatrixType>::CoeffReadCost) + int(evaluator<DiagonalType>::CoeffReadCost), MatrixFlags = evaluator<MatrixType>::Flags, DiagFlags = evaluator<DiagonalType>::Flags, _StorageOrder = (Derived::MaxRowsAtCompileTime==1 && Derived::MaxColsAtCompileTime!=1) ? RowMajor : (Derived::MaxColsAtCompileTime==1 && Derived::MaxRowsAtCompileTime!=1) ? ColMajor : MatrixFlags & RowMajorBit ? RowMajor : ColMajor, _SameStorageOrder = _StorageOrder == (MatrixFlags & RowMajorBit ? RowMajor : ColMajor), _ScalarAccessOnDiag = !((int(_StorageOrder) == ColMajor && int(ProductOrder) == OnTheLeft) ||(int(_StorageOrder) == RowMajor && int(ProductOrder) == OnTheRight)), _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value, _Vectorizable = bool(int(MatrixFlags)&PacketAccessBit) && _SameTypes && (_SameStorageOrder || (MatrixFlags&LinearAccessBit)==LinearAccessBit) && (_ScalarAccessOnDiag || (bool(int(DiagFlags)&PacketAccessBit))), _LinearAccessMask = (MatrixType::RowsAtCompileTime==1 || MatrixType::ColsAtCompileTime==1) ? LinearAccessBit : 0, Flags = ((HereditaryBits|_LinearAccessMask) & (unsigned int)(MatrixFlags)) | (_Vectorizable ? PacketAccessBit : 0), Alignment = evaluator<MatrixType>::Alignment, AsScalarProduct = (DiagonalType::SizeAtCompileTime==1) || (DiagonalType::SizeAtCompileTime==Dynamic && MatrixType::RowsAtCompileTime==1 && ProductOrder==OnTheLeft) || (DiagonalType::SizeAtCompileTime==Dynamic && MatrixType::ColsAtCompileTime==1 && ProductOrder==OnTheRight)"
  },
  {
    "label": "diagonal_product_evaluator_base()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC)",
    "insertText": "diagonal_product_evaluator_base(const MatrixType &mat, const DiagonalType &diag) : m_diagImpl(diag), m_matImpl(mat)"
  },
  {
    "label": "coeff()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar)",
    "insertText": "coeff(Index idx)"
  },
  {
    "label": "packet_impl()",
    "kind": "Method",
    "detail": "Function (} protected : template<int LoadMode,PacketType> EIGEN_STRONG_INLINE PacketType)",
    "insertText": "packet_impl(Index row, Index col, Index id, internal::true_type)"
  },
  {
    "label": "packet_impl()",
    "kind": "Method",
    "detail": "Function (} template<int LoadMode,PacketType> EIGEN_STRONG_INLINE PacketType)",
    "insertText": "packet_impl(Index row, Index col, Index id, internal::false_type)"
  },
  {
    "label": "InnerSize()",
    "kind": "Method",
    "detail": "Function (enum {)",
    "insertText": "InnerSize(MatrixType::Flags & RowMajorBit) ? MatrixType::ColsAtCompileTime : MatrixType::RowsAtCompileTime, DiagonalPacketLoadMode = EIGEN_PLAIN_ENUM_MIN(LoadMode,((InnerSize%16) == 0) ? int(Aligned16) : int(evaluator<DiagonalType>::Alignment))"
  },
  {
    "label": "product_evaluator()",
    "kind": "Method",
    "detail": "Function (} evaluator<DiagonalType> m_diagImpl ; evaluator<MatrixType> m_matImpl ; } ; template<Lhs,Rhs,int ProductKind,int ProductTag> struct product_evaluator<Product<Lhs,Rhs,ProductKind>,ProductTag,DiagonalShape,DenseShape> : diagonal_product_evaluator_base<Rhs,Lhs::DiagonalVectorType,Product<Lhs,Rhs,LazyProduct>,OnTheLeft> { typedef diagonal_product_evaluator_base<Rhs,Lhs::DiagonalVectorType,Product<Lhs,Rhs,LazyProduct>,OnTheLeft> Base ; using Base::m_diagImpl ; using Base::m_matImpl ; using Base::coeff ; typedef Base::Scalar Scalar ; typedef Product<Lhs,Rhs,ProductKind> XprType ; typedef XprType::PlainObject PlainObject ; typedef Lhs::DiagonalVectorType DiagonalType ; enum { StorageOrder = Base::_StorageOrder } ; EIGEN_DEVICE_FUNC)",
    "insertText": "product_evaluator(const XprType& xpr) : Base(xpr.rhs(), xpr.lhs().diagonal())"
  },
  {
    "label": "packet()",
    "kind": "Method",
    "detail": "Function (} template<int LoadMode,PacketType> EIGEN_STRONG_INLINE PacketType)",
    "insertText": "packet(Index idx)"
  },
  {
    "label": "product_evaluator()",
    "kind": "Method",
    "detail": "Function (} # endif } ; template<Lhs,Rhs,int ProductKind,int ProductTag> struct product_evaluator<Product<Lhs,Rhs,ProductKind>,ProductTag,DenseShape,DiagonalShape> : diagonal_product_evaluator_base<Lhs,Rhs::DiagonalVectorType,Product<Lhs,Rhs,LazyProduct>,OnTheRight> { typedef diagonal_product_evaluator_base<Lhs,Rhs::DiagonalVectorType,Product<Lhs,Rhs,LazyProduct>,OnTheRight> Base ; using Base::m_diagImpl ; using Base::m_matImpl ; using Base::coeff ; typedef Base::Scalar Scalar ; typedef Product<Lhs,Rhs,ProductKind> XprType ; typedef XprType::PlainObject PlainObject ; enum { StorageOrder = Base::_StorageOrder } ; EIGEN_DEVICE_FUNC)",
    "insertText": "product_evaluator(const XprType& xpr) : Base(xpr.lhs(), xpr.rhs().diagonal())"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} # endif } ; template<ExpressionType,int Side,bool Transposed,ExpressionShape> struct permutation_matrix_product ; template<ExpressionType,int Side,bool Transposed> struct permutation_matrix_product<ExpressionType,Side,Transposed,DenseShape> { typedef nested_eval<ExpressionType,1>::type MatrixType ; typedef remove_all<MatrixType>::type MatrixTypeCleaned ; template<Dest,PermutationType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(Dest& dst, const PermutationType& perm, const ExpressionType& xpr)"
  },
  {
    "label": "mat()",
    "kind": "Method",
    "detail": "Function (MatrixType)",
    "insertText": "mat(xpr)"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (const Index n = Side = = OnTheLeft ? mat .)",
    "insertText": "rows() : mat.cols()"
  },
  {
    "label": "mask()",
    "kind": "Method",
    "detail": "Function (Matrix<bool,PermutationType::RowsAtCompileTime,1,0,PermutationType::MaxRowsAtCompileTime>)",
    "insertText": "mask(perm.size())"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "fill(false)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Index r = 0 ;)",
    "insertText": "while(r < perm.size())"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (Index k0 = r + + ; Index kPrev = k0 ; mask .)",
    "insertText": "coeffRef(k0)"
  },
  {
    "label": "ColsAtCompileTime()",
    "kind": "Method",
    "detail": "Function (Block<Dest,Side = = OnTheLeft ? 1 : Dest::RowsAtCompileTime,Side = = OnTheRight ? 1 :)",
    "insertText": "ColsAtCompileTime(dst, k) .swap(Block<Dest, Side==OnTheLeft ? 1 : Dest::RowsAtCompileTime, Side==OnTheRight ? 1 : Dest::ColsAtCompileTime> (dst,((Side==OnTheLeft) ^ Transposed) ? k0 : kPrev))"
  },
  {
    "label": "coeffRef()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "coeffRef(k)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (kPrev = k ; } } } else {)",
    "insertText": "for(Index i = 0; i < n; ++i)"
  },
  {
    "label": "ColsAtCompileTime()",
    "kind": "Method",
    "detail": "Function (Block<Dest,Side = = OnTheLeft ? 1 : Dest::RowsAtCompileTime,Side = = OnTheRight ? 1 :)",
    "insertText": "ColsAtCompileTime(dst, ((Side==OnTheLeft) ^ Transposed) ? perm.indices().coeff(i) : i) = Block<const MatrixTypeCleaned,Side==OnTheLeft ? 1 : MatrixTypeCleaned::RowsAtCompileTime,Side==OnTheRight ? 1 : MatrixTypeCleaned::ColsAtCompileTime> (mat, ((Side==OnTheRight) ^ Transposed) ? perm.indices().coeff(i) : i)"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (} } } } ; template<Lhs,Rhs,int ProductTag,MatrixShape> struct generic_product_impl<Lhs,Rhs,PermutationShape,MatrixShape,ProductTag> { template<Dest> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (permutation_matrix_product<Rhs,OnTheLeft,false,MatrixShape)",
    "insertText": "run(dst, lhs, rhs)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (permutation_matrix_product<Lhs,OnTheRight,false,MatrixShape)",
    "insertText": "run(dst, rhs, lhs)"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs,int ProductTag,MatrixShape> struct generic_product_impl<Inverse<Lhs>,Rhs,PermutationShape,MatrixShape,ProductTag> { template<Dest> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "evalTo(Dest& dst, const Inverse<Lhs>& lhs, const Rhs& rhs)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (permutation_matrix_product<Rhs,OnTheLeft,true,MatrixShape)",
    "insertText": "run(dst, lhs.nestedExpression(), rhs)"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs,int ProductTag,MatrixShape> struct generic_product_impl<Lhs,Inverse<Rhs>,MatrixShape,PermutationShape,ProductTag> { template<Dest> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "evalTo(Dest& dst, const Lhs& lhs, const Inverse<Rhs>& rhs)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (permutation_matrix_product<Lhs,OnTheRight,true,MatrixShape)",
    "insertText": "run(dst, rhs.nestedExpression(), lhs)"
  },
  {
    "label": "run()",
    "kind": "Method",
    "detail": "Function (} } ; template<ExpressionType,int Side,bool Transposed,ExpressionShape> struct transposition_matrix_product { typedef nested_eval<ExpressionType,1>::type MatrixType ; typedef remove_all<MatrixType>::type MatrixTypeCleaned ; template<Dest,TranspositionType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "run(Dest& dst, const TranspositionType& tr, const ExpressionType& xpr)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (typedef TranspositionType::StorageIndex StorageIndex ; const Index size = tr .)",
    "insertText": "size()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StorageIndex j = 0 ;)",
    "insertText": "if(!is_same_dense(dst,mat))"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs,int ProductTag,MatrixShape> struct generic_product_impl<Transpose<Lhs>,Rhs,TranspositionsShape,MatrixShape,ProductTag> { template<Dest> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "evalTo(Dest& dst, const Transpose<Lhs>& lhs, const Rhs& rhs)"
  },
  {
    "label": "evalTo()",
    "kind": "Method",
    "detail": "Function (} } ; template<Lhs,Rhs,int ProductTag,MatrixShape> struct generic_product_impl<Lhs,Transpose<Rhs>,MatrixShape,TranspositionsShape,ProductTag> { template<Dest> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "evalTo(Dest& dst, const Lhs& lhs, const Transpose<Rhs>& rhs)"
  }
]