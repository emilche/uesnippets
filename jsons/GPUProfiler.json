[
  {
    "label": "FQueue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQueue"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FEvent",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEvent"
  },
  {
    "label": "FFrameBoundary",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFrameBoundary"
  },
  {
    "label": "FBeginBreadcrumb",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBeginBreadcrumb"
  },
  {
    "label": "FEndBreadcrumb",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEndBreadcrumb"
  },
  {
    "label": "FBeginWork",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBeginWork"
  },
  {
    "label": "FEndWork",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEndWork"
  },
  {
    "label": "FStats",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStats"
  },
  {
    "label": "FSignalFence",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSignalFence"
  },
  {
    "label": "FWaitFence",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FWaitFence"
  },
  {
    "label": "FFlip",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFlip"
  },
  {
    "label": "FVsync",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVsync"
  },
  {
    "label": "FEventStream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FEventStream"
  },
  {
    "label": "FChunk",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FChunk"
  },
  {
    "label": "FHeader",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHeader"
  },
  {
    "label": "FIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FIterator"
  },
  {
    "label": "FEventSink",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEventSink"
  },
  {
    "label": "FGPUProfilerEventNodeStats",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGPUProfilerEventNodeStats"
  },
  {
    "label": "FGPUProfilerEventNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FGPUProfilerEventNode"
  },
  {
    "label": "FGPUProfilerEventNodeFrame",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGPUProfilerEventNodeFrame"
  },
  {
    "label": "FGPUTimingCalibrationTimestamp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGPUTimingCalibrationTimestamp"
  },
  {
    "label": "FGPUTiming",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGPUTiming"
  },
  {
    "label": "FGPUProfiler",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FGPUProfiler"
  },
  {
    "label": "CSV_DECLARE_CATEGORY_MODULE_EXTERN()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Misc / TVariant . h \" # include \" ProfilingDebugging / CsvProfiler . h \" # include \" RHIBreadcrumbs . h \" # if HAS_GPU_STATS)",
    "insertText": "CSV_DECLARE_CATEGORY_MODULE_EXTERN(RHI_API, GPU)"
  },
  {
    "label": "FQueue()",
    "kind": "Method",
    "detail": "Function (# endif # if RHI_NEW_GPU_PROFILER namespace UE::RHI::GPUProfiler { struct FQueue { enum class EType : uint8 { Graphics,Compute,Copy,SwapChain } ; union { struct { EType Type ; uint8 GPU ; uint8 Index ; uint8 Padding ; } ; uint32 Value = 0 ; } ;)",
    "insertText": "FQueue()"
  },
  {
    "label": "FQueue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FQueue(EType Type, uint8 GPU, uint8 Index) : Type (Type) , GPU (GPU) , Index (Index) , Padding(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(FQueue const& RHS)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(FQueue const& Queue)"
  },
  {
    "label": "GetTypeString()",
    "kind": "Method",
    "detail": "Function (} TCHAR const*)",
    "insertText": "GetTypeString()"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (default : return)",
    "insertText": "TEXT(\"<unknown>\")"
  },
  {
    "label": "FFrameBoundary()",
    "kind": "Method",
    "detail": "Function (} } } ; struct FEvent { struct FFrameBoundary { uint32 FrameNumber ; # if WITH_RHI_BREADCRUMBS FRHIBreadcrumbNode* Breadcrumb ; # endif)",
    "insertText": "FFrameBoundary(uint32 FrameNumber #if WITH_RHI_BREADCRUMBS , FRHIBreadcrumbNode* Breadcrumb #endif ) : FrameNumber(FrameNumber) #if WITH_RHI_BREADCRUMBS , Breadcrumb(Breadcrumb)"
  },
  {
    "label": "FBeginBreadcrumb()",
    "kind": "Method",
    "detail": "Function (} } ; # if WITH_RHI_BREADCRUMBS struct FBeginBreadcrumb { FRHIBreadcrumbNode* const Breadcrumb ; uint64 GPUTimestampTOP ;)",
    "insertText": "FBeginBreadcrumb(FRHIBreadcrumbNode* Breadcrumb, uint64 GPUTimestampTOP = 0) : Breadcrumb(Breadcrumb) , GPUTimestampTOP(GPUTimestampTOP)"
  },
  {
    "label": "FEndBreadcrumb()",
    "kind": "Method",
    "detail": "Function (} } ; struct FEndBreadcrumb { FRHIBreadcrumbNode* const Breadcrumb ; uint64 GPUTimestampBOP = 0 ;)",
    "insertText": "FEndBreadcrumb(FRHIBreadcrumbNode* Breadcrumb, uint64 GPUTimestampBOP = 0) : Breadcrumb(Breadcrumb) , GPUTimestampBOP(GPUTimestampBOP)"
  },
  {
    "label": "FBeginWork()",
    "kind": "Method",
    "detail": "Function (} } ; # endif struct FBeginWork { uint64 CPUTimestamp ; uint64 GPUTimestampTOP ;)",
    "insertText": "FBeginWork(uint64 CPUTimestamp, uint64 GPUTimestampTOP = 0) : CPUTimestamp(CPUTimestamp) , GPUTimestampTOP(GPUTimestampTOP)"
  },
  {
    "label": "FEndWork()",
    "kind": "Method",
    "detail": "Function (} } ; struct FEndWork { uint64 GPUTimestampBOP ;)",
    "insertText": "FEndWork(uint64 GPUTimestampBOP = 0) : GPUTimestampBOP(GPUTimestampBOP)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} } ; struct FStats { uint32 NumDraws ; uint32 NumPrimitives ; operator)",
    "insertText": "bool()"
  },
  {
    "label": "FWaitFence()",
    "kind": "Method",
    "detail": "Function (} } ; struct FWaitFence { uint64 CPUTimestamp ; uint64 ID ; uint64 Value ;)",
    "insertText": "FWaitFence(uint64 CPUTimestamp, uint64 ID, uint64 Value) : CPUTimestamp(CPUTimestamp) , ID(ID) , Value(Value)"
  },
  {
    "label": "FFrameBoundary()",
    "kind": "Method",
    "detail": "Function (} } ; struct FFlip { uint64 GPUTimestamp ; } ; struct FVsync { uint64 GPUTimestamp ; } ; using FStorage = TVariant<FFrameBoundary # if WITH_RHI_BREADCRUMBS,FBeginBreadcrumb,FEndBreadcrumb # endif,FBeginWork,FEndWork,FStats,FSignalFence,FWaitFence,FFlip,FVsync> ; enum class EType { FrameBoundary = FStorage::IndexOfType<)",
    "insertText": "FFrameBoundary(), #if WITH_RHI_BREADCRUMBS BeginBreadcrumb = FStorage::IndexOfType<FBeginBreadcrumb>(), EndBreadcrumb = FStorage::IndexOfType<FEndBreadcrumb >(), #endif BeginWork = FStorage::IndexOfType<FBeginWork >(), EndWork = FStorage::IndexOfType<FEndWork >(), Stats = FStorage::IndexOfType<FStats >(), SignalFence = FStorage::IndexOfType<FSignalFence >(), WaitFence = FStorage::IndexOfType<FWaitFence >(), Flip = FStorage::IndexOfType<FFlip >(), VSync = FStorage::IndexOfType<FVsync >()"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (FStorage Value ; EType)",
    "insertText": "GetType()"
  },
  {
    "label": "FEvent()",
    "kind": "Method",
    "detail": "Function (} template<T>)",
    "insertText": "FEvent(T const& Value) : Value(TInPlaceType<T>(), Value)"
  },
  {
    "label": "FEvent()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FEvent(FEvent const&)"
  },
  {
    "label": "FEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FEvent(FEvent&&)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (} ; class FEventStream { private : struct FChunk { struct FHeader { FChunk* Next = nullptr ; uint32 Num = 0 ; # if WITH_RHI_BREADCRUMBS FRHIBreadcrumbAllocatorArray BreadcrumbAllocators ; # endif } Header ; uint32 ChunkSizeInBytes = 1 6* 1 0 2 4 ; uint32 RemainingBytes = ChunkSizeInBytes - Align<)",
    "insertText": "uint32(sizeof(FHeader), alignof(FHeader))"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (uint32 MaxEventsPerChunk = RemainingBytes / Align<)",
    "insertText": "uint32(sizeof(FEvent), alignof(FEvent))"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (TStaticArray<TTypeCompatibleBytes<FEvent>,MaxEventsPerChunk> Elements ; TLockFreePointerListUnordered<void,PLATFORM_CACHE_LINE_SIZE> MemoryPool ; void* operator)",
    "insertText": "new(size_t Size)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (void* Memory = MemoryPool .)",
    "insertText": "Pop()"
  },
  {
    "label": "Malloc()",
    "kind": "Method",
    "detail": "Function (Memory =)",
    "insertText": "Malloc(sizeof(FChunk), alignof(FChunk))"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (} return Memory ; } void operator)",
    "insertText": "delete(void* Pointer)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (MemoryPool .)",
    "insertText": "Push(Pointer)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (} FEvent*)",
    "insertText": "GetElement(uint32 Index)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "static_assert(sizeof(FChunk) <= FChunk::ChunkSizeInBytes, \"Incorrect FChunk size.\")"
  },
  {
    "label": "FEventStream()",
    "kind": "Method",
    "detail": "Function (FChunk* First = nullptr ; FChunk* Current = nullptr ; public :)",
    "insertText": "FEventStream()"
  },
  {
    "label": "FEventStream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FEventStream(FEventStream const&)"
  },
  {
    "label": "FEventStream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FEventStream(FEventStream&& Other) : First(Other.First) , Current(Other.Current)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (FChunk* Next = First -> Header . Next ; delete First ; First = Next ; } } template<TEventType,. . . TArgs> TEventType&)",
    "insertText": "Emplace(TArgs&&... Args)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Current = new FChunk ;)",
    "insertText": "if(!First)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (First = Current ; } })",
    "insertText": "if(Current->Header.Num >= FChunk::MaxEventsPerChunk)"
  },
  {
    "label": "GetElement()",
    "kind": "Method",
    "detail": "Function (FChunk* NewChunk = new FChunk ; Current -> Header . Next = NewChunk ; Current = NewChunk ; } FEvent* Event = Current ->)",
    "insertText": "GetElement(Current->Header.Num++)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new(Event) FEvent(TEventType(Forward<TArgs>(Args)...))"
  },
  {
    "label": "TEventType()",
    "kind": "Method",
    "detail": "Function (TEventType& Data = Event -> Value . Get<)",
    "insertText": "TEventType()"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (# if WITH_RHI_BREADCRUMBS if)",
    "insertText": "constexpr(std::is_same_v<UE::RHI::GPUProfiler::FEvent::FBeginBreadcrumb, TEventType> || std::is_same_v<UE::RHI::GPUProfiler::FEvent::FEndBreadcrumb , TEventType>)"
  },
  {
    "label": "AddUnique()",
    "kind": "Method",
    "detail": "Function (Current -> Header . BreadcrumbAllocators .)",
    "insertText": "AddUnique(Data.Breadcrumb->Allocator)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} # endif return Data ; } bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Current = Other . Current ; First = Other . First ; } else)",
    "insertText": "if(!Other.IsEmpty())"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (Current -> Header . Next = Other . First ; Current = Other . Current ; } Other . Current = nullptr ; Other . First = nullptr ; } auto)",
    "insertText": "begin()"
  },
  {
    "label": "FIterator()",
    "kind": "Method",
    "detail": "Function (class FIterator { FEventStream ; FChunk* Current ; uint32 Index = 0 ;)",
    "insertText": "FIterator(FChunk* Current) : Current(Current)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} public : FIterator&)",
    "insertText": "operator()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + Index ;)",
    "insertText": "while(Current && Index >= Current->Header.Num)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Current = Current -> Header . Next ; Index = 0 ; } return* this ; } bool)",
    "insertText": "operator(std::nullptr_t)"
  },
  {
    "label": "FIterator()",
    "kind": "Method",
    "detail": "Function (} } ; return)",
    "insertText": "FIterator(First)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} std::nullptr_t)",
    "insertText": "end()"
  },
  {
    "label": "FEventSink()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FEventSink()"
  },
  {
    "label": "FEventSink()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FEventSink(FEventSink const&)"
  },
  {
    "label": "FEventSink()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FEventSink(FEventSink&&)"
  },
  {
    "label": "ProcessEvents()",
    "kind": "Method",
    "detail": "Function (public : void)",
    "insertText": "ProcessEvents(FQueue Queue, FEventStream const& EventStream)"
  },
  {
    "label": "InitializeQueues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeQueues(TConstArrayView<FQueue> Queues)"
  },
  {
    "label": "ProcessEvents()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "ProcessEvents(FQueue Queue, FEventStream EventStream)"
  },
  {
    "label": "FGPUProfilerEventNodeStats()",
    "kind": "Method",
    "detail": "Function (} # else class FGPUProfilerEventNodeStats : public FRefCountedObject { public :)",
    "insertText": "FGPUProfilerEventNodeStats() : NumDraws(0), NumPrimitives(0), NumVertices(0), NumDispatches(0), GroupCount(FIntVector(0, 0, 0)), NumTotalDispatches(0), NumTotalDraws(0), NumTotalPrimitives(0), NumTotalVertices(0), TimingResult(0), NumEvents(0)"
  },
  {
    "label": "FGPUProfilerEventNodeStats()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FGPUProfilerEventNodeStats(const FGPUProfilerEventNodeStats& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (NumDraws = rhs . NumDraws ; NumPrimitives = rhs . NumPrimitives ; NumVertices = rhs . NumVertices ; NumDispatches = rhs . NumDispatches ; NumTotalDispatches = rhs . NumTotalDispatches ; NumTotalDraws = rhs . NumDraws ; NumTotalPrimitives = rhs . NumPrimitives ; NumTotalVertices = rhs . NumVertices ; TimingResult = rhs . TimingResult ; NumEvents = rhs . NumEvents ; } uint32 NumDraws ; uint32 NumPrimitives ; uint32 NumVertices ; uint32 NumDispatches ; FIntVector GroupCount ; uint32 NumTotalDispatches ; uint32 NumTotalDraws ; uint32 NumTotalPrimitives ; uint32 NumTotalVertices ; float TimingResult ; uint32 NumEvents ; const FGPUProfilerEventNodeStats)",
    "insertText": "operator(const FGPUProfilerEventNodeStats& rhs)"
  },
  {
    "label": "FGPUProfilerEventNode()",
    "kind": "Method",
    "detail": "Function (NumDraws + = rhs . NumDraws ; NumPrimitives + = rhs . NumPrimitives ; NumVertices + = rhs . NumVertices ; NumDispatches + = rhs . NumDispatches ; NumTotalDispatches + = rhs . NumTotalDispatches ; NumTotalDraws + = rhs . NumDraws ; NumTotalPrimitives + = rhs . NumPrimitives ; NumTotalVertices + = rhs . NumVertices ; TimingResult + = rhs . TimingResult ; NumEvents + = rhs . NumEvents ; return* this ; } } ; class FGPUProfilerEventNode : public FGPUProfilerEventNodeStats { public :)",
    "insertText": "FGPUProfilerEventNode(const TCHAR* InName, FGPUProfilerEventNode* InParent) : FGPUProfilerEventNodeStats(), Name(InName), Parent(InParent)"
  },
  {
    "label": "FGPUProfilerEventNode()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FGPUProfilerEventNode()"
  },
  {
    "label": "GetTiming()",
    "kind": "Method",
    "detail": "Function (} FString Name ; FGPUProfilerEventNode* Parent ; TArray<TRefCountPtr<FGPUProfilerEventNode>> Children ; float)",
    "insertText": "GetTiming()"
  },
  {
    "label": "StopTiming()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "StopTiming()"
  },
  {
    "label": "FGPUProfilerEventNodeFrame()",
    "kind": "Method",
    "detail": "Function (} } ; struct FGPUProfilerEventNodeFrame { ~)",
    "insertText": "FGPUProfilerEventNodeFrame()"
  },
  {
    "label": "StartFrame()",
    "kind": "Method",
    "detail": "Function (} TArray<TRefCountPtr<FGPUProfilerEventNode>> EventTree ; void)",
    "insertText": "StartFrame()"
  },
  {
    "label": "EndFrame()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EndFrame()"
  },
  {
    "label": "DumpEventTree()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DumpEventTree()"
  },
  {
    "label": "GetRootTimingResults()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetRootTimingResults()"
  },
  {
    "label": "PlatformDisablesVSync()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "PlatformDisablesVSync()"
  },
  {
    "label": "StaticInitialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StaticInitialize(void* UserData, PlatformStaticInitialize* PlatformFunction)"
  },
  {
    "label": "SetTimingFrequency()",
    "kind": "Method",
    "detail": "Function (GIsSupported = true ; } else { GIsSupported = false ; } GAreGlobalsInitialized = true ; } } protected : bool GAreGlobalsInitialized ; bool GIsSupported ; void)",
    "insertText": "SetTimingFrequency(uint64 TimingFrequency, uint32 GPUIndex = 0)"
  },
  {
    "label": "SetCalibrationTimestamp()",
    "kind": "Method",
    "detail": "Function (GTimingFrequency [ GPUIndex ] = TimingFrequency ; } void)",
    "insertText": "SetCalibrationTimestamp(FGPUTimingCalibrationTimestamp CalibrationTimestamp, uint32 GPUIndex = 0)"
  },
  {
    "label": "FGPUProfiler()",
    "kind": "Method",
    "detail": "Function (GCalibrationTimestamp [ GPUIndex ] = CalibrationTimestamp ; } private : TStaticArray<uint64,MAX_NUM_GPUS> GTimingFrequency ; TStaticArray<FGPUTimingCalibrationTimestamp,MAX_NUM_GPUS> GCalibrationTimestamp ; } ; struct FGPUProfiler { bool bTrackingEvents ; bool bTrackingGPUCrashData ; bool bLatchedGProfilingGPU ; bool bLatchedGProfilingGPUHitches ; bool bPreviousLatchedGProfilingGPUHitches ; bool bOriginalGEmitDrawEvents ; int32 GPUHitchDebounce ; int32 GPUCrashDataDepth ; FGPUProfilerEventNodeFrame* CurrentEventNodeFrame = nullptr ; FGPUProfilerEventNode* CurrentEventNode ; int32 StackDepth ;)",
    "insertText": "FGPUProfiler() : bTrackingEvents(false), bTrackingGPUCrashData(false), bLatchedGProfilingGPU(false), bLatchedGProfilingGPUHitches(false), bPreviousLatchedGProfilingGPUHitches(false), bOriginalGEmitDrawEvents(false), GPUHitchDebounce(0), GPUCrashDataDepth(-1), CurrentEventNodeFrame(NULL), CurrentEventNode(NULL), StackDepth(0)"
  },
  {
    "label": "FGPUProfiler()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FGPUProfiler()"
  },
  {
    "label": "RegisterGPUWork()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RegisterGPUWork(uint32 NumDraws, uint32 NumPrimitives, uint32 NumVertices)"
  },
  {
    "label": "RegisterGPUWork()",
    "kind": "Method",
    "detail": "Function (CurrentEventNode -> NumDraws + = NumDraws ; CurrentEventNode -> NumPrimitives + = NumPrimitives ; CurrentEventNode -> NumVertices + = NumVertices ; } } void)",
    "insertText": "RegisterGPUWork(uint32 NumPrimitives = 0, uint32 NumVertices = 0)"
  },
  {
    "label": "RegisterGPUWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterGPUWork(1, NumPrimitives, NumVertices)"
  },
  {
    "label": "RegisterGPUDispatch()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RegisterGPUDispatch(FIntVector GroupCount)"
  },
  {
    "label": "CreateEventNode()",
    "kind": "Method",
    "detail": "Function (CurrentEventNode -> NumDispatches + + ; CurrentEventNode -> GroupCount = GroupCount ; } } FGPUProfilerEventNode*)",
    "insertText": "CreateEventNode(const TCHAR* InName, FGPUProfilerEventNode* InParent)"
  },
  {
    "label": "PushEvent()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PushEvent(const TCHAR* Name, FColor Color)"
  },
  {
    "label": "PopEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopEvent()"
  },
  {
    "label": "IsProfilingGPU()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsProfilingGPU()"
  }
]