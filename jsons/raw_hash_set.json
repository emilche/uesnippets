[
  {
    "label": "probe_seq",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "probe_seq"
  },
  {
    "label": "ContainerKey",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ContainerKey"
  },
  {
    "label": "Hash",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Hash"
  },
  {
    "label": "Eq",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Eq"
  },
  {
    "label": "RequireUsableKey",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RequireUsableKey"
  },
  {
    "label": "PassedKey",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PassedKey"
  },
  {
    "label": "E",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "E"
  },
  {
    "label": "Policy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Policy"
  },
  {
    "label": "IsDecomposable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsDecomposable"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "NonIterableBitMask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NonIterableBitMask"
  },
  {
    "label": "BitMask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BitMask"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "GroupSse2Impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GroupSse2Impl"
  },
  {
    "label": "GroupAArch64Impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GroupAArch64Impl"
  },
  {
    "label": "GroupPortableImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GroupPortableImpl"
  },
  {
    "label": "Alloc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Alloc"
  },
  {
    "label": "raw_hash_set",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "raw_hash_set"
  },
  {
    "label": "InputIter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InputIter"
  },
  {
    "label": "FindInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FindInfo"
  },
  {
    "label": "K",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "K"
  },
  {
    "label": "SameAsElementReference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SameAsElementReference"
  },
  {
    "label": "iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "iterator"
  },
  {
    "label": "const_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "const_iterator"
  },
  {
    "label": "T2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T2"
  },
  {
    "label": "InputIt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InputIt"
  },
  {
    "label": "constructor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "constructor"
  },
  {
    "label": "F",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "F"
  },
  {
    "label": "Container",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Container"
  },
  {
    "label": "absl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "absl"
  },
  {
    "label": "FindElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FindElement"
  },
  {
    "label": "HashElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HashElement"
  },
  {
    "label": "K1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "K1"
  },
  {
    "label": "EqualElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EqualElement"
  },
  {
    "label": "K2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "K2"
  },
  {
    "label": "EmplaceDecomposable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EmplaceDecomposable"
  },
  {
    "label": "InsertSlot",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InsertSlot"
  },
  {
    "label": "RawHashSetTestOnlyAccess",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RawHashSetTestOnlyAccess"
  },
  {
    "label": "HashtableDebugAccess",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HashtableDebugAccess"
  },
  {
    "label": "SwapAlloc()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_CONTAINER_INTERNAL_RAW_HASH_SET_H_ # define ABSL_CONTAINER_INTERNAL_RAW_HASH_SET_H_ # include<algorithm> # include<cmath> # include<cstdint> # include<cstring> # include<iterator> # include<limits> # include<memory> # include<tuple> # include<type_traits> # include<utility> # include \" absl / base / config . h \" # include \" absl / base / internal / endian . h \" # include \" absl / base / internal / prefetch . h \" # include \" absl / base / optimization . h \" # include \" absl / base / port . h \" # include \" absl / container / internal / common . h \" # include \" absl / container / internal / compressed_tuple . h \" # include \" absl / container / internal / container_memory . h \" # include \" absl / container / internal / hash_policy_traits . h \" # include \" absl / container / internal / hashtable_debug_hooks . h \" # include \" absl / container / internal / hashtablez_sampler . h \" # include \" absl / memory / memory . h \" # include \" absl / meta / type_traits . h \" # include \" absl / numeric / bits . h \" # include \" absl / utility / utility . h \" # ifdef ABSL_INTERNAL_HAVE_SSE2 # include<emmintrin . h> # endif # ifdef ABSL_INTERNAL_HAVE_SSSE3 # include<tmmintrin . h> # endif # ifdef _MSC_VER # include<intrin . h> # endif # ifdef ABSL_INTERNAL_HAVE_ARM_NEON # include<arm_neon . h> # endif namespace absl { ABSL_NAMESPACE_BEGIN namespace container_internal { template<AllocType> void)",
    "insertText": "SwapAlloc(AllocType& lhs, AllocType& rhs, std::true_type)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (using std::swap ;)",
    "insertText": "swap(lhs, rhs)"
  },
  {
    "label": "SwapAlloc()",
    "kind": "Method",
    "detail": "Function (} template<AllocType> void)",
    "insertText": "SwapAlloc(AllocType& , AllocType& , std::false_type)"
  },
  {
    "label": "probe_seq()",
    "kind": "Method",
    "detail": "Function (} template<size_t Width> class probe_seq { public :)",
    "insertText": "probe_seq(size_t hash, size_t mask)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(((mask + 1) & mask) == 0 && \"not a mask\")"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (mask_ = mask ; offset_ = hash& mask_ ; } size_t)",
    "insertText": "offset()"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "next()"
  },
  {
    "label": "index()",
    "kind": "Method",
    "detail": "Function (index_ + = Width ; offset_ + = index_ ; offset_& = mask_ ; } size_t)",
    "insertText": "index()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} ; template<class E,class Policy,class Hash,class Eq,class . . . Ts> struct IsDecomposable : std::false_type { } ; template<class Policy,class Hash,class Eq,class . . . Ts> struct IsDecomposable<absl::void_t<)",
    "insertText": "decltype(Policy::apply( RequireUsableKey<typename Policy::key_type, Hash, Eq>(), std::declval<Ts>()...))"
  },
  {
    "label": "IsNoThrowSwappable()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> bool)",
    "insertText": "IsNoThrowSwappable(std::true_type = {})"
  },
  {
    "label": "noexcept()",
    "kind": "Method",
    "detail": "Function (using std::swap ; return)",
    "insertText": "noexcept(swap(std::declval<T&>(), std::declval<T&>()))"
  },
  {
    "label": "IsNoThrowSwappable()",
    "kind": "Method",
    "detail": "Function (} template<class T> bool)",
    "insertText": "IsNoThrowSwappable(std::false_type)"
  },
  {
    "label": "ABSL_ASSUME()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_ASSUME(x != 0)"
  },
  {
    "label": "NonIterableBitMask()",
    "kind": "Method",
    "detail": "Function (} template<class T,int SignificantBits,int Shift = 0> class NonIterableBitMask { public :)",
    "insertText": "NonIterableBitMask(T mask) : mask_(mask)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "HighestBitSet()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "HighestBitSet()"
  },
  {
    "label": "TrailingZeros()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "TrailingZeros()"
  },
  {
    "label": "LeadingZeros()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "LeadingZeros()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (int total_significant_bits = SignificantBits<<Shift ; int extra_bits =)",
    "insertText": "sizeof(T)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} T mask_ ; } ; template<class T,int SignificantBits,int Shift = 0> class BitMask : public NonIterableBitMask<T,SignificantBits,Shift> { using Base = NonIterableBitMask<T,SignificantBits,Shift> ;)",
    "insertText": "static_assert(std::is_unsigned<T>::value, \"\")"
  },
  {
    "label": "BitMask()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "BitMask(T mask) : Base(mask)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} using value_type = int ; using iterator = BitMask ; using const_iterator = BitMask ; BitMask&)",
    "insertText": "operator()"
  },
  {
    "label": "mask_()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "mask_(this->mask_ - 1)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} BitMask)",
    "insertText": "begin()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : bool)",
    "insertText": "operator(const BitMask& a, const BitMask& b)"
  },
  {
    "label": "EmptyGroup()",
    "kind": "Method",
    "detail": "Function (ABSL_DLL const ctrl_t kEmptyGroup [ 1 6 ] ; ctrl_t*)",
    "insertText": "EmptyGroup()"
  },
  {
    "label": "ShouldInsertBackwards()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ShouldInsertBackwards(size_t hash, const ctrl_t* ctrl)"
  },
  {
    "label": "PerTableSalt()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "PerTableSalt(const ctrl_t* ctrl)"
  },
  {
    "label": "H1()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "H1(size_t hash, const ctrl_t* ctrl)"
  },
  {
    "label": "H2()",
    "kind": "Method",
    "detail": "Function (} h2_t)",
    "insertText": "H2(size_t hash)"
  },
  {
    "label": "IsDeleted()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDeleted(ctrl_t c)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(__GNUC__) && !defined(__clang__) if (std::is_unsigned<char>::value)"
  },
  {
    "label": "_mm_set1_epi8()",
    "kind": "Method",
    "detail": "Function (const __m128i mask =)",
    "insertText": "_mm_set1_epi8(0x80)"
  },
  {
    "label": "_mm_subs_epi8()",
    "kind": "Method",
    "detail": "Function (const __m128i diff =)",
    "insertText": "_mm_subs_epi8(b, a)"
  },
  {
    "label": "_mm_cmpgt_epi8()",
    "kind": "Method",
    "detail": "Function (} # endif return)",
    "insertText": "_mm_cmpgt_epi8(a, b)"
  },
  {
    "label": "GroupSse2Impl()",
    "kind": "Method",
    "detail": "Function (} struct GroupSse2Impl { size_t kWidth = 1 6 ;)",
    "insertText": "GroupSse2Impl(const ctrl_t* pos)"
  },
  {
    "label": "_mm_loadu_si128()",
    "kind": "Method",
    "detail": "Function (ctrl =)",
    "insertText": "_mm_loadu_si128(reinterpret_cast<const __m128i*>(pos))"
  },
  {
    "label": "Match()",
    "kind": "Method",
    "detail": "Function (} BitMask<uint32_t,kWidth>)",
    "insertText": "Match(h2_t hash)"
  },
  {
    "label": "_mm_set1_epi8()",
    "kind": "Method",
    "detail": "Function (auto match =)",
    "insertText": "_mm_set1_epi8(static_cast<char>(hash))"
  },
  {
    "label": "MaskEmpty()",
    "kind": "Method",
    "detail": "Function (} NonIterableBitMask<uint32_t,kWidth>)",
    "insertText": "MaskEmpty()"
  },
  {
    "label": "kWidth()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_INTERNAL_HAVE_SSSE3 return NonIterableBitMask<uint32_t,)",
    "insertText": "kWidth(static_cast<uint32_t>(_mm_movemask_epi8(_mm_sign_epi8(ctrl, ctrl))))"
  },
  {
    "label": "_mm_set1_epi8()",
    "kind": "Method",
    "detail": "Function (# else auto match =)",
    "insertText": "_mm_set1_epi8(static_cast<char>(ctrl_t::kEmpty))"
  },
  {
    "label": "MaskEmptyOrDeleted()",
    "kind": "Method",
    "detail": "Function (# endif } NonIterableBitMask<uint32_t,kWidth>)",
    "insertText": "MaskEmptyOrDeleted()"
  },
  {
    "label": "_mm_set1_epi8()",
    "kind": "Method",
    "detail": "Function (auto special =)",
    "insertText": "_mm_set1_epi8(static_cast<char>(ctrl_t::kSentinel))"
  },
  {
    "label": "CountLeadingEmptyOrDeleted()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "CountLeadingEmptyOrDeleted()"
  },
  {
    "label": "ConvertSpecialToEmptyAndFullToDeleted()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ConvertSpecialToEmptyAndFullToDeleted(ctrl_t* dst)"
  },
  {
    "label": "_mm_set1_epi8()",
    "kind": "Method",
    "detail": "Function (auto msbs =)",
    "insertText": "_mm_set1_epi8(static_cast<char>(-128))"
  },
  {
    "label": "_mm_set1_epi8()",
    "kind": "Method",
    "detail": "Function (auto x126 =)",
    "insertText": "_mm_set1_epi8(126)"
  },
  {
    "label": "_mm_or_si128()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_INTERNAL_HAVE_SSSE3 auto res =)",
    "insertText": "_mm_or_si128(_mm_shuffle_epi8(x126, ctrl), msbs)"
  },
  {
    "label": "_mm_setzero_si128()",
    "kind": "Method",
    "detail": "Function (# else auto zero =)",
    "insertText": "_mm_setzero_si128()"
  },
  {
    "label": "_mm_cmpgt_epi8_fixed()",
    "kind": "Method",
    "detail": "Function (auto special_mask =)",
    "insertText": "_mm_cmpgt_epi8_fixed(zero, ctrl)"
  },
  {
    "label": "_mm_or_si128()",
    "kind": "Method",
    "detail": "Function (auto res =)",
    "insertText": "_mm_or_si128(msbs, _mm_andnot_si128(special_mask, x126))"
  },
  {
    "label": "_mm_storeu_si128()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "_mm_storeu_si128(reinterpret_cast<__m128i*>(dst), res)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} __m128i ctrl ; } ; # endif # if)",
    "insertText": "defined(ABSL_INTERNAL_HAVE_ARM_NEON) && defined(ABSL_IS_LITTLE_ENDIAN)"
  },
  {
    "label": "GroupAArch64Impl()",
    "kind": "Method",
    "detail": "Function (size_t kWidth = 8 ;)",
    "insertText": "GroupAArch64Impl(const ctrl_t* pos)"
  },
  {
    "label": "vld1_u8()",
    "kind": "Method",
    "detail": "Function (ctrl =)",
    "insertText": "vld1_u8(reinterpret_cast<const uint8_t*>(pos))"
  },
  {
    "label": "vdup_n_u8()",
    "kind": "Method",
    "detail": "Function (uint8x8_t dup =)",
    "insertText": "vdup_n_u8(hash)"
  },
  {
    "label": "vceq_u8()",
    "kind": "Method",
    "detail": "Function (auto mask =)",
    "insertText": "vceq_u8(ctrl, dup)"
  },
  {
    "label": "kWidth()",
    "kind": "Method",
    "detail": "Function (uint64_t msbs = 0 x8080808080808080ULL ; return BitMask<uint64_t,)",
    "insertText": "kWidth(vget_lane_u64(vreinterpret_u64_u8(mask), 0) & msbs)"
  },
  {
    "label": "vget_lane_u64()",
    "kind": "Method",
    "detail": "Function (uint64_t mask =)",
    "insertText": "vget_lane_u64(vreinterpret_u64_u8(vceq_s8( vdup_n_s8(static_cast<int8_t>(ctrl_t::kEmpty)), vreinterpret_s8_u8(ctrl))), 0)"
  },
  {
    "label": "vget_lane_u64()",
    "kind": "Method",
    "detail": "Function (uint64_t mask =)",
    "insertText": "vget_lane_u64(vreinterpret_u64_u8(vcgt_s8( vdup_n_s8(static_cast<int8_t>(ctrl_t::kSentinel)), vreinterpret_s8_u8(ctrl))), 0)"
  },
  {
    "label": "vget_lane_u64()",
    "kind": "Method",
    "detail": "Function (uint64_t mask =)",
    "insertText": "vget_lane_u64(vreinterpret_u64_u8(ctrl), 0)"
  },
  {
    "label": "uint32_t()",
    "kind": "Method",
    "detail": "Function (uint64_t bits = 0 x0101010101010101ULL ; return static_cast<)",
    "insertText": "uint32_t(countr_zero((mask | ~(mask >> 7)) & bits) >> 3)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (uint64_t msbs = 0 x8080808080808080ULL ; uint64_t lsbs = 0 x0101010101010101ULL ; auto x = mask& msbs ; auto)",
    "insertText": "res(~x + (x >> 7))"
  },
  {
    "label": "Store64()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Store64(dst, res)"
  },
  {
    "label": "GroupPortableImpl()",
    "kind": "Method",
    "detail": "Function (} uint8x8_t ctrl ; } ; # endif struct GroupPortableImpl { size_t kWidth = 8 ;)",
    "insertText": "GroupPortableImpl(const ctrl_t* pos) : ctrl(little_endian::Load64(pos))"
  },
  {
    "label": "ctrl()",
    "kind": "Method",
    "detail": "Function (uint64_t msbs = 0 x8080808080808080ULL ; uint64_t lsbs = 0 x0101010101010101ULL ; auto x =)",
    "insertText": "ctrl(lsbs * hash)"
  },
  {
    "label": "kWidth()",
    "kind": "Method",
    "detail": "Function (uint64_t msbs = 0 x8080808080808080ULL ; return NonIterableBitMask<uint64_t,)",
    "insertText": "kWidth((ctrl & (~ctrl << 6)) & msbs)"
  },
  {
    "label": "kWidth()",
    "kind": "Method",
    "detail": "Function (uint64_t msbs = 0 x8080808080808080ULL ; return NonIterableBitMask<uint64_t,)",
    "insertText": "kWidth((ctrl & (~ctrl << 7)) & msbs)"
  },
  {
    "label": "uint32_t()",
    "kind": "Method",
    "detail": "Function (uint64_t bits = 0 x0101010101010101ULL ; return static_cast<)",
    "insertText": "uint32_t(countr_zero((ctrl | ~(ctrl >> 7)) & bits) >> 3)"
  },
  {
    "label": "NumClonedBytes()",
    "kind": "Method",
    "detail": "Function (# else using Group = GroupPortableImpl ; # endif size_t)",
    "insertText": "NumClonedBytes()"
  },
  {
    "label": "ConvertDeletedToEmptyAndFullToDeleted()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ConvertDeletedToEmptyAndFullToDeleted(ctrl_t* ctrl, size_t capacity)"
  },
  {
    "label": "NormalizeCapacity()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "NormalizeCapacity(size_t n)"
  },
  {
    "label": "CapacityToGrowth()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "CapacityToGrowth(size_t capacity)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(IsValidCapacity(capacity))"
  },
  {
    "label": "SelectBucketCountForIterRange()",
    "kind": "Method",
    "detail": "Function (} template<class InputIter> size_t)",
    "insertText": "SelectBucketCountForIterRange(InputIter first, InputIter last, size_t bucket_count)"
  },
  {
    "label": "ABSL_INTERNAL_ASSERT_IS_FULL()",
    "kind": "Method",
    "detail": "Function (} return 0 ; } # define)",
    "insertText": "ABSL_INTERNAL_ASSERT_IS_FULL(ctrl, operation)"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "ABSL_HARDENING_ASSERT(\\ (ctrl != nullptr) && operation \\ \" called on invalid iterator. The iterator might be an end() \" \\ \"iterator or may have been default constructed.\")"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "ABSL_HARDENING_ASSERT(\\ (IsFull(*ctrl)) && operation \\ \" called on invalid iterator. The element might have been erased or \" \\ \"the table might have rehashed.\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(0) inline void AssertIsValid(ctrl_t* ctrl)"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT((ctrl == nullptr || IsFull(*ctrl)) && \"Invalid operation on iterator. The element might have \" \"been erased or the table might have rehashed.\")"
  },
  {
    "label": "is_small()",
    "kind": "Method",
    "detail": "Function (} struct FindInfo { size_t offset ; size_t probe_length ; } ; bool)",
    "insertText": "is_small(size_t capacity)"
  },
  {
    "label": "find_first_non_full()",
    "kind": "Method",
    "detail": "Function (} template<= void> FindInfo)",
    "insertText": "find_first_non_full(const ctrl_t* ctrl, size_t hash, size_t capacity)"
  },
  {
    "label": "probe()",
    "kind": "Method",
    "detail": "Function (auto seq =)",
    "insertText": "probe(ctrl, hash, capacity)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(NDEBUG) if (!is_small(capacity) && ShouldInsertBackwards(hash, ctrl))"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (} # endif return { seq .)",
    "insertText": "offset(mask.LowestBitSet()), seq.index()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(seq.index() <= capacity && \"full table!\")"
  },
  {
    "label": "find_first_non_full()",
    "kind": "Method",
    "detail": "Function (} } template FindInfo)",
    "insertText": "find_first_non_full(const ctrl_t*, size_t, size_t)"
  },
  {
    "label": "ResetCtrl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetCtrl(size_t capacity, ctrl_t* ctrl, const void* slot, size_t slot_size)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(ctrl, static_cast<int8_t>(ctrl_t::kEmpty), capacity + 1 + NumClonedBytes())"
  },
  {
    "label": "SanitizerPoisonMemoryRegion()",
    "kind": "Method",
    "detail": "Function (ctrl [ capacity ] = ctrl_t::kSentinel ;)",
    "insertText": "SanitizerPoisonMemoryRegion(slot, slot_size * capacity)"
  },
  {
    "label": "SetCtrl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCtrl(size_t i, ctrl_t h, size_t capacity, ctrl_t* ctrl, const void* slot, size_t slot_size)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(i < capacity)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (auto* slot_i = static_cast<const)",
    "insertText": "char(slot)"
  },
  {
    "label": "SanitizerUnpoisonMemoryRegion()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SanitizerUnpoisonMemoryRegion(slot_i, slot_size)"
  },
  {
    "label": "SanitizerPoisonMemoryRegion()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "SanitizerPoisonMemoryRegion(slot_i, slot_size)"
  },
  {
    "label": "ctrl()",
    "kind": "Method",
    "detail": "Function (} ctrl [ i ] = h ;)",
    "insertText": "ctrl((i - NumClonedBytes()) & capacity) + (NumClonedBytes() & capacity)"
  },
  {
    "label": "SetCtrl()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCtrl(size_t i, h2_t h, size_t capacity, ctrl_t* ctrl, const void* slot, size_t slot_size)"
  },
  {
    "label": "SetCtrl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCtrl(i, static_cast<ctrl_t>(h), capacity, ctrl, slot, slot_size)"
  },
  {
    "label": "SlotOffset()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "SlotOffset(size_t capacity, size_t slot_align)"
  },
  {
    "label": "AllocSize()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "AllocSize(size_t capacity, size_t slot_size, size_t slot_align)"
  },
  {
    "label": "KeyTypeCanBeHashed()",
    "kind": "Method",
    "detail": "Function (} template<class Policy,class Hash,class Eq,class Alloc> class raw_hash_set { using PolicyTraits = hash_policy_traits<Policy> ; using KeyArgImpl = KeyArg<IsTransparent<Eq>::value&& IsTransparent<Hash>::value> ; public : using init_type = PolicyTraits::init_type ; using key_type = PolicyTraits::key_type ; using slot_type = PolicyTraits::slot_type ; using allocator_type = Alloc ; using size_type = size_t ; using difference_type = ptrdiff_t ; using hasher = Hash ; using key_equal = Eq ; using policy_type = Policy ; using value_type = PolicyTraits::value_type ; using reference = value_type& ; using const_reference = const value_type& ; using pointer = absl::allocator_traits<allocator_type>::template rebind_traits<value_type>::pointer ; using const_pointer = absl::allocator_traits<allocator_type>::template rebind_traits<value_type>::const_pointer ; template<class K> using key_arg = KeyArgImpl::template type<K,key_type> ; private : auto)",
    "insertText": "KeyTypeCanBeHashed(const Hash& h, const key_type& k) -> decltype(h(k))"
  },
  {
    "label": "KeyTypeCanBeEq()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "KeyTypeCanBeEq(const Eq& eq, const key_type& k) -> decltype(eq(k, k))"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (using AllocTraits = absl::allocator_traits<allocator_type> ; using SlotAlloc = absl::allocator_traits<allocator_type>::template rebind_alloc<slot_type> ; using SlotAllocTraits = absl::allocator_traits<allocator_type>::template rebind_traits<slot_type> ;)",
    "insertText": "static_assert(std::is_lvalue_reference<reference>::value, \"Policy::element() must return a reference\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (template<T> struct SameAsElementReference : std::is_same<std::remove_cv<std::remove_reference<reference>::type>::type,std::remove_cv<std::remove_reference<T>::type>::type> { } ; template<class T> using RequiresInsertable = std::enable_if<absl::disjunction<std::is_convertible<T,init_type>,SameAsElementReference<T>>::value,int>::type ; template<class T> using RequiresNotInit = std::enable_if<! std::is_same<T,init_type>::value,int>::type ; template<class . . . Ts> using IsDecomposable = IsDecomposable<void,PolicyTraits,Hash,Eq,Ts . . .> ; public :)",
    "insertText": "static_assert(std::is_same<pointer, value_type*>::value, \"Allocators with custom pointer types are not supported\")"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (class iterator { class raw_hash_set ; public : using iterator_category = std::forward_iterator_tag ; using value_type = raw_hash_set::value_type ; using reference = absl::conditional_t<PolicyTraits::constant_iterators::value,const value_type&,value_type&> ; using pointer = absl::remove_reference_t<reference>* ; using difference_type = raw_hash_set::difference_type ;)",
    "insertText": "iterator()"
  },
  {
    "label": "ABSL_INTERNAL_ASSERT_IS_FULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_ASSERT_IS_FULL(ctrl_, \"operator*()\")"
  },
  {
    "label": "ABSL_INTERNAL_ASSERT_IS_FULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_ASSERT_IS_FULL(ctrl_, \"operator->\")"
  },
  {
    "label": "ABSL_INTERNAL_ASSERT_IS_FULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_ASSERT_IS_FULL(ctrl_, \"operator++\")"
  },
  {
    "label": "skip_empty_or_deleted()",
    "kind": "Method",
    "detail": "Function (+ + ctrl_ ; + + slot_ ;)",
    "insertText": "skip_empty_or_deleted()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (auto tmp =* this ; + +* this ; return tmp ; } bool)",
    "insertText": "operator(const iterator& a, const iterator& b)"
  },
  {
    "label": "AssertIsValid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertIsValid(a.ctrl_)"
  },
  {
    "label": "AssertIsValid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AssertIsValid(b.ctrl_)"
  },
  {
    "label": "iterator()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "iterator(ctrl_t* ctrl, slot_type* slot) : ctrl_(ctrl), slot_(slot)"
  },
  {
    "label": "ABSL_ASSUME()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_ASSUME(ctrl != nullptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ctrl_ + = shift ; slot_ + = shift ; })",
    "insertText": "if(ABSL_PREDICT_FALSE(*ctrl_ == ctrl_t::kSentinel))"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (} ctrl_t* ctrl_ = nullptr ; union { slot_type* slot_ ; } ; } ; class const_iterator { class raw_hash_set ; public : using iterator_category = iterator::iterator_category ; using value_type = raw_hash_set::value_type ; using reference = raw_hash_set::const_reference ; using pointer = raw_hash_set::const_pointer ; using difference_type = raw_hash_set::difference_type ;)",
    "insertText": "const_iterator()"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "const_iterator(iterator i) : inner_(std::move(i))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + inner_ ; return* this ; } const_iterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "const_iterator()",
    "kind": "Method",
    "detail": "Function (} private :)",
    "insertText": "const_iterator(const ctrl_t* ctrl, const slot_type* slot) : inner_(const_cast<ctrl_t*>(ctrl), const_cast<slot_type*>(slot))"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (} iterator inner_ ; } ; using node_type = node_handle<Policy,hash_policy_traits<Policy>,Alloc> ; using insert_return_type = InsertReturnType<iterator,node_type> ;)",
    "insertText": "raw_hash_set() noexcept( std::is_nothrow_default_constructible<hasher>::value&& std::is_nothrow_default_constructible<key_equal>::value&& std::is_nothrow_default_constructible<allocator_type>::value)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "raw_hash_set(size_t bucket_count, const hasher& hash = hasher(), const key_equal& eq = key_equal(), const allocator_type& alloc = allocator_type()) : ctrl_(EmptyGroup()), settings_(0u, HashtablezInfoHandle(), hash, eq, alloc)"
  },
  {
    "label": "NormalizeCapacity()",
    "kind": "Method",
    "detail": "Function (capacity_ =)",
    "insertText": "NormalizeCapacity(bucket_count)"
  },
  {
    "label": "initialize_slots()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initialize_slots()"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "raw_hash_set(size_t bucket_count, const hasher& hash, const allocator_type& alloc) : raw_hash_set(bucket_count, hash, key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "raw_hash_set(size_t bucket_count, const allocator_type& alloc) : raw_hash_set(bucket_count, hasher(), key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "raw_hash_set(const allocator_type& alloc) : raw_hash_set(0, hasher(), key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (} template<class InputIter>)",
    "insertText": "raw_hash_set(InputIter first, InputIter last, size_t bucket_count = 0, const hasher& hash = hasher(), const key_equal& eq = key_equal(), const allocator_type& alloc = allocator_type()) : raw_hash_set(SelectBucketCountForIterRange(first, last, bucket_count), hash, eq, alloc)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(first, last)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (} template<class InputIter>)",
    "insertText": "raw_hash_set(InputIter first, InputIter last, size_t bucket_count, const hasher& hash, const allocator_type& alloc) : raw_hash_set(first, last, bucket_count, hash, key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (} template<class InputIter>)",
    "insertText": "raw_hash_set(InputIter first, InputIter last, size_t bucket_count, const allocator_type& alloc) : raw_hash_set(first, last, bucket_count, hasher(), key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (} template<class InputIter>)",
    "insertText": "raw_hash_set(InputIter first, InputIter last, const allocator_type& alloc) : raw_hash_set(first, last, 0, hasher(), key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (} template<class T,RequiresNotInit<T> = 0,RequiresInsertable<T> = 0>)",
    "insertText": "raw_hash_set(std::initializer_list<T> init, size_t bucket_count = 0, const hasher& hash = hasher(), const key_equal& eq = key_equal(), const allocator_type& alloc = allocator_type()) : raw_hash_set(init.begin(), init.end(), bucket_count, hash, eq, alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "raw_hash_set(std::initializer_list<init_type> init, size_t bucket_count = 0, const hasher& hash = hasher(), const key_equal& eq = key_equal(), const allocator_type& alloc = allocator_type()) : raw_hash_set(init.begin(), init.end(), bucket_count, hash, eq, alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (} template<class T,RequiresNotInit<T> = 0,RequiresInsertable<T> = 0>)",
    "insertText": "raw_hash_set(std::initializer_list<T> init, size_t bucket_count, const hasher& hash, const allocator_type& alloc) : raw_hash_set(init, bucket_count, hash, key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "raw_hash_set(std::initializer_list<init_type> init, size_t bucket_count, const hasher& hash, const allocator_type& alloc) : raw_hash_set(init, bucket_count, hash, key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (} template<class T,RequiresNotInit<T> = 0,RequiresInsertable<T> = 0>)",
    "insertText": "raw_hash_set(std::initializer_list<T> init, size_t bucket_count, const allocator_type& alloc) : raw_hash_set(init, bucket_count, hasher(), key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "raw_hash_set(std::initializer_list<init_type> init, size_t bucket_count, const allocator_type& alloc) : raw_hash_set(init, bucket_count, hasher(), key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (} template<class T,RequiresNotInit<T> = 0,RequiresInsertable<T> = 0>)",
    "insertText": "raw_hash_set(std::initializer_list<T> init, const allocator_type& alloc) : raw_hash_set(init, 0, hasher(), key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "raw_hash_set(std::initializer_list<init_type> init, const allocator_type& alloc) : raw_hash_set(init, 0, hasher(), key_equal(), alloc)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "raw_hash_set(const raw_hash_set& that) : raw_hash_set(that, AllocTraits::select_on_container_copy_construction( that.alloc_ref()))"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "raw_hash_set(const raw_hash_set& that, const allocator_type& a) : raw_hash_set(0, that.hash_ref(), that.eq_ref(), a)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(that.size())"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (const size_t hash =)",
    "insertText": "apply(HashElement{hash_ref()}, v)"
  },
  {
    "label": "find_first_non_full()",
    "kind": "Method",
    "detail": "Function (auto target =)",
    "insertText": "find_first_non_full(ctrl_, hash, capacity_)"
  },
  {
    "label": "SetCtrl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCtrl(target.offset, H2(hash), capacity_, ctrl_, slots_, sizeof(slot_type))"
  },
  {
    "label": "emplace_at()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "emplace_at(target.offset, v)"
  },
  {
    "label": "infoz()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "infoz().RecordInsert(hash, target.probe_length)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_ = that .)",
    "insertText": "size()"
  },
  {
    "label": "growth_left()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "growth_left() -= that.size()"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "raw_hash_set(raw_hash_set&& that) noexcept( std::is_nothrow_copy_constructible<hasher>::value&& std::is_nothrow_copy_constructible<key_equal>::value&& std::is_nothrow_copy_constructible<allocator_type>::value) : ctrl_(absl::exchange(that.ctrl_, EmptyGroup())), slots_(absl::exchange(that.slots_, nullptr)), size_(absl::exchange(that.size_, size_t{0})), capacity_(absl::exchange(that.capacity_, size_t{0})), settings_(absl::exchange(that.growth_left(), size_t{0}), absl::exchange(that.infoz(), HashtablezInfoHandle()), that.hash_ref(), that.eq_ref(), that.alloc_ref())"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "raw_hash_set(raw_hash_set&& that, const allocator_type& a) : ctrl_(EmptyGroup()), slots_(nullptr), size_(0), capacity_(0), settings_(0, HashtablezInfoHandle(), that.hash_ref(), that.eq_ref(), a)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(ctrl_, that.ctrl_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(slots_, that.slots_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(size_, that.size_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(capacity_, that.capacity_)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(growth_left(), that.growth_left())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(infoz(), that.infoz())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } raw_hash_set&)",
    "insertText": "operator(const raw_hash_set& that)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (raw_hash_set)",
    "insertText": "tmp(that, AllocTraits::propagate_on_container_copy_assignment::value ? that.alloc_ref() : alloc_ref())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(tmp)"
  },
  {
    "label": "raw_hash_set()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "raw_hash_set()"
  },
  {
    "label": "destroy_slots()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy_slots()"
  },
  {
    "label": "iterator_at()",
    "kind": "Method",
    "detail": "Function (auto it =)",
    "insertText": "iterator_at(0)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "end()"
  },
  {
    "label": "cend()",
    "kind": "Method",
    "detail": "Function (} const_iterator)",
    "insertText": "cend()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} ABSL_ATTRIBUTE_REINITIALIZES void)",
    "insertText": "clear()"
  },
  {
    "label": "infoz()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "infoz().RecordClearedReservation()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(capacity_)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy(&alloc_ref(), slots_ + i)"
  },
  {
    "label": "ResetCtrl()",
    "kind": "Method",
    "detail": "Function (} } size_ = 0 ;)",
    "insertText": "ResetCtrl(capacity_, ctrl_, slots_, sizeof(slot_type))"
  },
  {
    "label": "reset_growth_left()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reset_growth_left()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(empty())"
  },
  {
    "label": "infoz()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "infoz().RecordStorageChanged(0, capacity_)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} template<class T,RequiresInsertable<T> = 0,class T2 = T,std::enable_if<IsDecomposable<T2>::value,int>::type = 0,T* = nullptr> std::pair<iterator,bool>)",
    "insertText": "insert(T&& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} template<class T,RequiresInsertable<T> = 0,std::enable_if<IsDecomposable<const T&>::value,int>::type = 0> std::pair<iterator,bool>)",
    "insertText": "insert(const T& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} std::pair<iterator,bool>)",
    "insertText": "insert(init_type&& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} template<class T,RequiresInsertable<T> = 0,class T2 = T,std::enable_if<IsDecomposable<T2>::value,int>::type = 0,T* = nullptr> iterator)",
    "insertText": "insert(const_iterator, T&& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} template<class T,RequiresInsertable<T> = 0,std::enable_if<IsDecomposable<const T&>::value,int>::type = 0> iterator)",
    "insertText": "insert(const_iterator, const T& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(const_iterator, init_type&& value)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} template<class InputIt> void)",
    "insertText": "insert(InputIt first, InputIt last)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} template<class T,RequiresNotInit<T> = 0,RequiresInsertable<const T&> = 0> void)",
    "insertText": "insert(std::initializer_list<T> ilist)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(ilist.begin(), ilist.end())"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "insert(std::initializer_list<init_type> ilist)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} insert_return_type)",
    "insertText": "insert(node_type&& node)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "end(), false, node_type()"
  },
  {
    "label": "element()",
    "kind": "Method",
    "detail": "Function (const auto& elem =)",
    "insertText": "element(CommonAccess::GetSlot(node))"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (auto res =)",
    "insertText": "apply(InsertSlot<false>{*this, std::move(*CommonAccess::GetSlot(node))}, elem)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset(&node)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (} else { return { res . first,false,)",
    "insertText": "move(node)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} } iterator)",
    "insertText": "insert(const_iterator, node_type&& node)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (auto res =)",
    "insertText": "insert(std::move(node))"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (node =)",
    "insertText": "move(res.node)"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Args,std::enable_if<! IsDecomposable<Args . . .>::value,int>::type = 0> std::pair<iterator,bool>)",
    "insertText": "emplace(Args&&... args)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alignas(slot_type) unsigned char raw[sizeof(slot_type)"
  },
  {
    "label": "slot_type()",
    "kind": "Method",
    "detail": "Function (slot_type* slot = reinterpret_cast<)",
    "insertText": "slot_type(&raw)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "construct(&alloc_ref(), slot, std::forward<Args>(args)...)"
  },
  {
    "label": "element()",
    "kind": "Method",
    "detail": "Function (const auto& elem =)",
    "insertText": "element(slot)"
  },
  {
    "label": "emplace_hint()",
    "kind": "Method",
    "detail": "Function (} template<class . . . Args> iterator)",
    "insertText": "emplace_hint(const_iterator, Args&&... args)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} class constructor { class raw_hash_set ; public : template<class . . . Args> void)",
    "insertText": "operator()(Args&&... args)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(*slot_)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "construct(alloc_, *slot_, std::forward<Args>(args)...)"
  },
  {
    "label": "constructor()",
    "kind": "Method",
    "detail": "Function (* slot_ = nullptr ; } private :)",
    "insertText": "constructor(allocator_type* a, slot_type** slot) : alloc_(a), slot_(slot)"
  },
  {
    "label": "lazy_emplace()",
    "kind": "Method",
    "detail": "Function (} allocator_type* alloc_ ; slot_type** slot_ ; } ; template<class K = key_type,class F> iterator)",
    "insertText": "lazy_emplace(const key_arg<K>& key, F&& f)"
  },
  {
    "label": "find_or_prepare_insert()",
    "kind": "Method",
    "detail": "Function (auto res =)",
    "insertText": "find_or_prepare_insert(key)"
  },
  {
    "label": "F()",
    "kind": "Method",
    "detail": "Function (slot_type* slot = slots_ + res . first ; std::forward<)",
    "insertText": "F(f)(constructor(&alloc_ref(), &slot))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!slot)"
  },
  {
    "label": "iterator_at()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "iterator_at(res.first)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} template<class K = key_type> size_type)",
    "insertText": "erase(const key_arg<K>& key)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (auto it =)",
    "insertText": "find(key)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase(it)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase(cit.inner_)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "erase(iterator it)"
  },
  {
    "label": "ABSL_INTERNAL_ASSERT_IS_FULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_ASSERT_IS_FULL(it.ctrl_, \"erase()\")"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy(&alloc_ref(), it.slot_)"
  },
  {
    "label": "erase_meta_only()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase_meta_only(it)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "erase(const_iterator first, const_iterator last)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase(first++)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} return last . inner_ ; } template<H,E> void)",
    "insertText": "merge(raw_hash_set<Policy, H, E, Alloc>& src)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(this != &src)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (auto next =)",
    "insertText": "next(it)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (} it = next ; } } template<H,E> void)",
    "insertText": "merge(raw_hash_set<Policy, H, E, Alloc>&& src)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "merge(src)"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (} node_type)",
    "insertText": "extract(const_iterator position)"
  },
  {
    "label": "ABSL_INTERNAL_ASSERT_IS_FULL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_INTERNAL_ASSERT_IS_FULL(position.inner_.ctrl_, \"extract()\")"
  },
  {
    "label": "node_type()",
    "kind": "Method",
    "detail": "Function (auto node = CommonAccess::Transfer<)",
    "insertText": "node_type(alloc_ref(), position.inner_.slot_)"
  },
  {
    "label": "erase_meta_only()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase_meta_only(position)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(raw_hash_set& that) noexcept( IsNoThrowSwappable<hasher>() && IsNoThrowSwappable<key_equal>() && IsNoThrowSwappable<allocator_type>( typename AllocTraits::propagate_on_container_swap{}))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(hash_ref(), that.hash_ref())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(eq_ref(), that.eq_ref())"
  },
  {
    "label": "SwapAlloc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SwapAlloc(alloc_ref(), that.alloc_ref(), typename AllocTraits::propagate_on_container_swap{})"
  },
  {
    "label": "rehash()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "rehash(size_t n)"
  },
  {
    "label": "infoz()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "infoz().RecordStorageChanged(0, 0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(m)"
  },
  {
    "label": "infoz()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "infoz().RecordReservation(n)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "reserve(size_t n)"
  },
  {
    "label": "GrowthToLowerboundCapacity()",
    "kind": "Method",
    "detail": "Function (size_t m =)",
    "insertText": "GrowthToLowerboundCapacity(n)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(NormalizeCapacity(m))"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (} } template<class K = key_type> size_t)",
    "insertText": "count(const key_arg<K>& key)"
  },
  {
    "label": "prefetch()",
    "kind": "Method",
    "detail": "Function (} template<class K = key_type> void)",
    "insertText": "prefetch(const key_arg<K>& key)"
  },
  {
    "label": "prefetch_heap_block()",
    "kind": "Method",
    "detail": "Function (# ifdef ABSL_INTERNAL_HAVE_PREFETCH)",
    "insertText": "prefetch_heap_block()"
  },
  {
    "label": "probe()",
    "kind": "Method",
    "detail": "Function (auto seq =)",
    "insertText": "probe(ctrl_, hash_ref()(key), capacity_)"
  },
  {
    "label": "PrefetchT0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrefetchT0(ctrl_ + seq.offset())"
  },
  {
    "label": "PrefetchT0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrefetchT0(slots_ + seq.offset())"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (# endif } template<class K = key_type> iterator)",
    "insertText": "find(const key_arg<K>& key, size_t hash)"
  },
  {
    "label": "probe()",
    "kind": "Method",
    "detail": "Function (auto seq =)",
    "insertText": "probe(ctrl_, hash, capacity_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ABSL_PREDICT_TRUE(g.MaskEmpty())) return end()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(seq.index() <= capacity_ && \"full table!\")"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} } template<class K = key_type> iterator)",
    "insertText": "find(const key_arg<K>& key)"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (} template<class K = key_type> bool)",
    "insertText": "contains(const key_arg<K>& key)"
  },
  {
    "label": "equal_range()",
    "kind": "Method",
    "detail": "Function (} template<class K = key_type> std::pair<iterator,iterator>)",
    "insertText": "equal_range(const key_arg<K>& key)"
  },
  {
    "label": "max_load_factor()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "max_load_factor()"
  },
  {
    "label": "hash_function()",
    "kind": "Method",
    "detail": "Function (} hasher)",
    "insertText": "hash_function()"
  },
  {
    "label": "key_eq()",
    "kind": "Method",
    "detail": "Function (} key_equal)",
    "insertText": "key_eq()"
  },
  {
    "label": "get_allocator()",
    "kind": "Method",
    "detail": "Function (} allocator_type)",
    "insertText": "get_allocator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const raw_hash_set& a, const raw_hash_set& b)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const raw_hash_set* outer =& a ; const raw_hash_set* inner =& b ;)",
    "insertText": "if(outer->capacity() > inner->capacity()) std::swap(outer, inner)"
  },
  {
    "label": "AbslHashValue()",
    "kind": "Method",
    "detail": "Function (} template<H> std::enable_if<H::template is_hashable<value_type>::value,H>::type)",
    "insertText": "AbslHashValue(H h, const raw_hash_set& s)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(raw_hash_set& a, raw_hash_set& b) noexcept(noexcept(a.swap(b)))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (a .)",
    "insertText": "swap(b)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} private : template<class Container,Enabler> struct absl::container_internal::hashtable_debug_internal::HashtableDebugAccess ; struct FindElement { template<class K,class . . . Args> const_iterator)",
    "insertText": "operator()(const K& key, Args&&...)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const hasher& h ; } ; template<class K1> struct EqualElement { template<class K2,class . . . Args> bool)",
    "insertText": "operator()(const K2& lhs, Args&&...)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const K1& rhs ; const key_equal& eq ; } ; struct EmplaceDecomposable { template<class K,class . . . Args> std::pair<iterator,bool>)",
    "insertText": "operator()(const K& key, Args&&... args)"
  },
  {
    "label": "emplace_at()",
    "kind": "Method",
    "detail": "Function (s .)",
    "insertText": "emplace_at(res.first, std::forward<Args>(args)...)"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer(&s.alloc_ref(), s.slots_ + res.first, &slot)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(do_destroy)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroy(&s.alloc_ref(), &slot)"
  },
  {
    "label": "erase_meta_only()",
    "kind": "Method",
    "detail": "Function (} raw_hash_set& s ; slot_type&& slot ; } ; void)",
    "insertText": "erase_meta_only(const_iterator it)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(IsFull(*it.inner_.ctrl_) && \"erasing a dangling iterator\")"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (- - size_ ; const size_t index = static_cast<)",
    "insertText": "size_t(it.inner_.ctrl_ - ctrl_)"
  },
  {
    "label": "index_before()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "index_before(index - Group::kWidth)"
  },
  {
    "label": "Group()",
    "kind": "Method",
    "detail": "Function (const auto empty_after =)",
    "insertText": "Group(it.inner_.ctrl_).MaskEmpty()"
  },
  {
    "label": "Group()",
    "kind": "Method",
    "detail": "Function (const auto empty_before =)",
    "insertText": "Group(ctrl_ + index_before).MaskEmpty()"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (bool was_never_full = empty_before&& empty_after&& static_cast<)",
    "insertText": "size_t(empty_after.TrailingZeros() + empty_before.LeadingZeros())"
  },
  {
    "label": "SetCtrl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCtrl(index, was_never_full ? ctrl_t::kEmpty : ctrl_t::kDeleted, capacity_, ctrl_, slots_, sizeof(slot_type))"
  },
  {
    "label": "growth_left()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "growth_left()"
  },
  {
    "label": "infoz()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "infoz().RecordErase()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(capacity_)"
  },
  {
    "label": "infoz()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "infoz() = Sample(sizeof(slot_type))"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (} char* mem = static_cast<)",
    "insertText": "char(Allocate<alignof(slot_type)>( &alloc_ref(), AllocSize(capacity_, sizeof(slot_type), alignof(slot_type))))"
  },
  {
    "label": "ctrl_t()",
    "kind": "Method",
    "detail": "Function (ctrl_ = reinterpret_cast<)",
    "insertText": "ctrl_t(mem)"
  },
  {
    "label": "slot_type()",
    "kind": "Method",
    "detail": "Function (slots_ = reinterpret_cast<)",
    "insertText": "slot_type(mem + SlotOffset(capacity_, alignof(slot_type)))"
  },
  {
    "label": "infoz()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "infoz().RecordStorageChanged(size_, capacity_)"
  },
  {
    "label": "SanitizerUnpoisonMemoryRegion()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "SanitizerUnpoisonMemoryRegion(slots_, sizeof(slot_type) * capacity_)"
  },
  {
    "label": "alignof()",
    "kind": "Method",
    "detail": "Function (Deallocate<)",
    "insertText": "alignof(slot_type)>( &alloc_ref(), ctrl_, AllocSize(capacity_, sizeof(slot_type), alignof(slot_type)))"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resize(size_t new_capacity)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(IsValidCapacity(new_capacity))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t total_probe_length = 0 ;)",
    "insertText": "for(size_t i = 0; i != old_capacity; ++i)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (size_t hash =)",
    "insertText": "apply(HashElement{hash_ref()}, PolicyTraits::element(old_slots + i))"
  },
  {
    "label": "SetCtrl()",
    "kind": "Method",
    "detail": "Function (size_t new_i = target . offset ; total_probe_length + = target . probe_length ;)",
    "insertText": "SetCtrl(new_i, H2(hash), capacity_, ctrl_, slots_, sizeof(slot_type))"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer(&alloc_ref(), slots_ + new_i, old_slots + i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(old_capacity)"
  },
  {
    "label": "SanitizerUnpoisonMemoryRegion()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SanitizerUnpoisonMemoryRegion(old_slots, sizeof(slot_type) * old_capacity)"
  },
  {
    "label": "alignof()",
    "kind": "Method",
    "detail": "Function (Deallocate<)",
    "insertText": "alignof(slot_type)>( &alloc_ref(), old_ctrl, AllocSize(old_capacity, sizeof(slot_type), alignof(slot_type)))"
  },
  {
    "label": "infoz()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "infoz().RecordRehash(total_probe_length)"
  },
  {
    "label": "drop_deletes_without_resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "drop_deletes_without_resize()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(IsValidCapacity(capacity_))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!is_small(capacity_))"
  },
  {
    "label": "ConvertDeletedToEmptyAndFullToDeleted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConvertDeletedToEmptyAndFullToDeleted(ctrl_, capacity_)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (const size_t hash =)",
    "insertText": "apply(HashElement{hash_ref()}, PolicyTraits::element(slots_ + i))"
  },
  {
    "label": "probe()",
    "kind": "Method",
    "detail": "Function (const size_t new_i = target . offset ; total_probe_length + = target . probe_length ; const size_t probe_offset =)",
    "insertText": "probe(ctrl_, hash, capacity_).offset()"
  },
  {
    "label": "this()",
    "kind": "Method",
    "detail": "Function (const auto probe_index = [ probe_offset,)",
    "insertText": "this(size_t pos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "if(ABSL_PREDICT_TRUE(probe_index(new_i) == probe_index(i)))"
  },
  {
    "label": "SetCtrl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCtrl(i, H2(hash), capacity_, ctrl_, slots_, sizeof(slot_type))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(IsEmpty(ctrl_[new_i]))"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer(&alloc_ref(), slots_ + new_i, slots_ + i)"
  },
  {
    "label": "SetCtrl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCtrl(i, ctrl_t::kEmpty, capacity_, ctrl_, slots_, sizeof(slot_type))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "assert(IsDeleted(ctrl_[new_i]))"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer(&alloc_ref(), slot, slots_ + i)"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer(&alloc_ref(), slots_ + i, slots_ + new_i)"
  },
  {
    "label": "transfer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transfer(&alloc_ref(), slots_ + new_i, slot)"
  },
  {
    "label": "rehash_and_grow_if_necessary()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "rehash_and_grow_if_necessary()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(capacity_ > Group::kWidth && size() * uint64_t{32} <= capacity_ * uint64_t{25})"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "resize(capacity_ * 2 + 1)"
  },
  {
    "label": "has_element()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "has_element(const value_type& elem)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (size_t hash =)",
    "insertText": "apply(HashElement{hash_ref()}, elem)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ABSL_PREDICT_TRUE(g.MaskEmpty()))"
  },
  {
    "label": "move_assign()",
    "kind": "Method",
    "detail": "Function (} return false ; } raw_hash_set&)",
    "insertText": "move_assign(raw_hash_set&& that, std::true_type)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (raw_hash_set)",
    "insertText": "tmp(std::move(that))"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (raw_hash_set)",
    "insertText": "tmp(std::move(that), alloc_ref())"
  },
  {
    "label": "hash_ref()",
    "kind": "Method",
    "detail": "Function (auto hash =)",
    "insertText": "hash_ref()(key)"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (seq .)",
    "insertText": "offset(i)"
  },
  {
    "label": "prepare_insert()",
    "kind": "Method",
    "detail": "Function (} return {)",
    "insertText": "prepare_insert(hash)"
  },
  {
    "label": "prepare_insert()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "prepare_insert(size_t hash)"
  },
  {
    "label": "growth_left()",
    "kind": "Method",
    "detail": "Function (} + + size_ ;)",
    "insertText": "growth_left() -= IsEmpty(ctrl_[target.offset])"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "construct(&alloc_ref(), slots_ + i, std::forward<Args>(args)...)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(PolicyTraits::apply(FindElement{*this}, *iterator_at(i)) == iterator_at(i) && \"constructed value does not match the lookup key\")"
  },
  {
    "label": "iterator_at()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "iterator_at(size_t i)"
  },
  {
    "label": "growth_left()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "growth_left() = CapacityToGrowth(capacity())"
  },
  {
    "label": "PrefetchT2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrefetchT2(ctrl_)"
  },
  {
    "label": "infoz()",
    "kind": "Method",
    "detail": "Function (} HashtablezInfoHandle&)",
    "insertText": "infoz()"
  },
  {
    "label": "hash_ref()",
    "kind": "Method",
    "detail": "Function (} hasher&)",
    "insertText": "hash_ref()"
  },
  {
    "label": "eq_ref()",
    "kind": "Method",
    "detail": "Function (} key_equal&)",
    "insertText": "eq_ref()"
  },
  {
    "label": "alloc_ref()",
    "kind": "Method",
    "detail": "Function (} allocator_type&)",
    "insertText": "alloc_ref()"
  },
  {
    "label": "EraseIf()",
    "kind": "Method",
    "detail": "Function (slot_type* slots_ = nullptr ; size_t size_ = 0 ; size_t capacity_ = 0 ; absl::container_internal::CompressedTuple<size_t,HashtablezInfoHandle,hasher,key_equal,allocator_type> settings_ { 0 u,HashtablezInfoHandle { },hasher { },key_equal { },allocator_type { } } ; } ; template<P,H,E,A,Predicate> raw_hash_set<P,H,E,A>::size_type)",
    "insertText": "EraseIf(Predicate& pred, raw_hash_set<P, H, E, A>* c)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (c ->)",
    "insertText": "erase(it++)"
  },
  {
    "label": "GetNumProbes()",
    "kind": "Method",
    "detail": "Function (} namespace hashtable_debug_internal { template<Set> struct HashtableDebugAccess<Set,absl::void_t<Set::raw_hash_set>> { using Traits = Set::PolicyTraits ; using Slot = Traits::slot_type ; size_t)",
    "insertText": "GetNumProbes(const Set& set, const typename Set::key_type& key)"
  },
  {
    "label": "probe()",
    "kind": "Method",
    "detail": "Function (auto seq =)",
    "insertText": "probe(set.ctrl_, hash, set.capacity_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + num_probes ; })",
    "insertText": "if(g.MaskEmpty())"
  },
  {
    "label": "AllocatedByteSize()",
    "kind": "Method",
    "detail": "Function (+ + num_probes ; } } size_t)",
    "insertText": "AllocatedByteSize(const Set& c)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t capacity = c . capacity_ ;)",
    "insertText": "if(capacity == 0)"
  },
  {
    "label": "AllocSize()",
    "kind": "Method",
    "detail": "Function (size_t m =)",
    "insertText": "AllocSize(capacity, sizeof(Slot), alignof(Slot))"
  },
  {
    "label": "space_used()",
    "kind": "Method",
    "detail": "Function (size_t per_slot =)",
    "insertText": "space_used(static_cast<const Slot*>(nullptr))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(size_t i = 0; i != capacity; ++i)"
  },
  {
    "label": "space_used()",
    "kind": "Method",
    "detail": "Function (m + =)",
    "insertText": "space_used(c.slots_ + i)"
  },
  {
    "label": "LowerBoundAllocatedByteSize()",
    "kind": "Method",
    "detail": "Function (} } } return m ; } size_t)",
    "insertText": "LowerBoundAllocatedByteSize(size_t size)"
  },
  {
    "label": "GrowthToLowerboundCapacity()",
    "kind": "Method",
    "detail": "Function (size_t capacity =)",
    "insertText": "GrowthToLowerboundCapacity(size)"
  },
  {
    "label": "AllocSize()",
    "kind": "Method",
    "detail": "Function (size_t m =)",
    "insertText": "AllocSize(NormalizeCapacity(capacity), sizeof(Slot), alignof(Slot))"
  }
]