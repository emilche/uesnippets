[
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "MainThreadOnly",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MainThreadOnly"
  },
  {
    "label": "DoWorkScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DoWorkScope"
  },
  {
    "label": "RunScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RunScope"
  },
  {
    "label": "InitializeFeatures()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TASK_SEQUENCE_MANAGER_THREAD_CONTROLLER_WITH_MESSAGE_PUMP_IMPL_H_ # define BASE_TASK_SEQUENCE_MANAGER_THREAD_CONTROLLER_WITH_MESSAGE_PUMP_IMPL_H_ # include<memory> # include \" base / base_export . h \" # include \" base / memory / raw_ptr . h \" # include \" base / message_loop / message_pump . h \" # include \" base / message_loop / work_id_provider . h \" # include \" base / run_loop . h \" # include \" base / task / common / checked_lock . h \" # include \" base / task / common / task_annotator . h \" # include \" base / task / sequence_manager / sequence_manager_impl . h \" # include \" base / task / sequence_manager / sequenced_task_source . h \" # include \" base / task / sequence_manager / thread_controller . h \" # include \" base / task / sequence_manager / thread_controller_power_monitor . h \" # include \" base / task / sequence_manager / work_deduplicator . h \" # include \" base / thread_annotations . h \" # include \" base / threading / hang_watcher . h \" # include \" base / threading / platform_thread . h \" # include \" base / threading / sequence_local_storage_map . h \" # include \" base / threading / thread_task_runner_handle . h \" # include \" base / time / time . h \" # include \" build / build_config . h \" # include \" third_party / abseil - cpp / absl / types / optional . h \" namespace base { namespace sequence_manager { namespace internal { class BASE_EXPORT ThreadControllerWithMessagePumpImpl : public ThreadController,public MessagePump::Delegate,public RunLoop::Delegate,public RunLoop::NestingObserver { public : void)",
    "insertText": "InitializeFeatures()"
  },
  {
    "label": "ResetFeatures()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetFeatures()"
  },
  {
    "label": "ThreadControllerWithMessagePumpImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ThreadControllerWithMessagePumpImpl(std::unique_ptr<MessagePump> message_pump, const SequenceManager::Settings& settings)"
  },
  {
    "label": "ThreadControllerWithMessagePumpImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ThreadControllerWithMessagePumpImpl(const ThreadControllerWithMessagePumpImpl&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ThreadControllerWithMessagePumpImpl&)",
    "insertText": "operator(const ThreadControllerWithMessagePumpImpl&)"
  },
  {
    "label": "ThreadControllerWithMessagePumpImpl()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ThreadControllerWithMessagePumpImpl()"
  },
  {
    "label": "CreateUnbound()",
    "kind": "Method",
    "detail": "Function (using ShouldScheduleWork = WorkDeduplicator::ShouldScheduleWork ; std::unique_ptr<ThreadControllerWithMessagePumpImpl>)",
    "insertText": "CreateUnbound(const SequenceManager::Settings& settings)"
  },
  {
    "label": "SetSequencedTaskSource()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSequencedTaskSource(SequencedTaskSource* task_source)"
  },
  {
    "label": "BindToCurrentThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BindToCurrentThread(std::unique_ptr<MessagePump> message_pump)"
  },
  {
    "label": "SetWorkBatchSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetWorkBatchSize(int work_batch_size)"
  },
  {
    "label": "WillQueueTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WillQueueTask(PendingTask* pending_task)"
  },
  {
    "label": "ScheduleWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScheduleWork()"
  },
  {
    "label": "SetNextDelayedDoWork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetNextDelayedDoWork(LazyNow* lazy_now, absl::optional<WakeUp> wake_up)"
  },
  {
    "label": "SetTimerSlack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTimerSlack(TimerSlack timer_slack)"
  },
  {
    "label": "RunsTasksInCurrentSequence()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RunsTasksInCurrentSequence()"
  },
  {
    "label": "SetDefaultTaskRunner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDefaultTaskRunner(scoped_refptr<SingleThreadTaskRunner> task_runner)"
  },
  {
    "label": "GetDefaultTaskRunner()",
    "kind": "Method",
    "detail": "Function (scoped_refptr<SingleThreadTaskRunner>)",
    "insertText": "GetDefaultTaskRunner()"
  },
  {
    "label": "RestoreDefaultTaskRunner()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RestoreDefaultTaskRunner()"
  },
  {
    "label": "AddNestingObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddNestingObserver(RunLoop::NestingObserver* observer)"
  },
  {
    "label": "RemoveNestingObserver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveNestingObserver(RunLoop::NestingObserver* observer)"
  },
  {
    "label": "SetTaskExecutionAllowed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTaskExecutionAllowed(bool allowed)"
  },
  {
    "label": "IsTaskExecutionAllowed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsTaskExecutionAllowed()"
  },
  {
    "label": "GetBoundMessagePump()",
    "kind": "Method",
    "detail": "Function (MessagePump*)",
    "insertText": "GetBoundMessagePump()"
  },
  {
    "label": "PrioritizeYieldingToNative()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PrioritizeYieldingToNative(base::TimeTicks prioritize_until)"
  },
  {
    "label": "EnablePeriodicYieldingToNative()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnablePeriodicYieldingToNative(base::TimeDelta delta)"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_IOS) || BUILDFLAG(IS_ANDROID) void AttachToMessagePump()"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# endif # if)",
    "insertText": "BUILDFLAG(IS_IOS) void DetachFromMessagePump()"
  },
  {
    "label": "ShouldQuitRunLoopWhenIdle()",
    "kind": "Method",
    "detail": "Function (# endif bool)",
    "insertText": "ShouldQuitRunLoopWhenIdle()"
  },
  {
    "label": "OnBeginNestedRunLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnBeginNestedRunLoop()"
  },
  {
    "label": "OnExitNestedRunLoop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnExitNestedRunLoop()"
  },
  {
    "label": "ThreadControllerWithMessagePumpImpl()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "ThreadControllerWithMessagePumpImpl(const SequenceManager::Settings& settings)"
  },
  {
    "label": "OnBeginWorkItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnBeginWorkItem()"
  },
  {
    "label": "OnEndWorkItem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnEndWorkItem()"
  },
  {
    "label": "BeforeWait()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BeforeWait()"
  },
  {
    "label": "DoWork()",
    "kind": "Method",
    "detail": "Function (MessagePump::Delegate::NextWorkInfo)",
    "insertText": "DoWork()"
  },
  {
    "label": "DoIdleWork()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DoIdleWork()"
  },
  {
    "label": "OnBeginWorkItemImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnBeginWorkItemImpl(LazyNow& lazy_now)"
  },
  {
    "label": "OnEndWorkItemImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnEndWorkItemImpl(LazyNow& lazy_now)"
  },
  {
    "label": "Run()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Run(bool application_tasks_allowed, TimeDelta timeout)"
  },
  {
    "label": "Quit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Quit()"
  },
  {
    "label": "EnsureWorkScheduled()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnsureWorkScheduled()"
  },
  {
    "label": "MainThreadOnly()",
    "kind": "Method",
    "detail": "Function (struct MainThreadOnly {)",
    "insertText": "MainThreadOnly()"
  },
  {
    "label": "TimeTicks()",
    "kind": "Method",
    "detail": "Function (raw_ptr<SequencedTaskSource> task_source = nullptr ; raw_ptr<RunLoop::NestingObserver> nesting_observer = nullptr ; std::unique_ptr<ThreadTaskRunnerHandle> thread_task_runner_handle ; bool quit_pending = false ; bool in_high_res_mode = false ; int work_batch_size = 1 ; base::TimeTicks yield_to_native_after_batch =)",
    "insertText": "TimeTicks()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (TimeTicks next_delayed_do_work =)",
    "insertText": "Max()"
  },
  {
    "label": "MainThreadOnlyForTesting()",
    "kind": "Method",
    "detail": "Function (bool task_execution_allowed = true ; } ; const MainThreadOnly&)",
    "insertText": "MainThreadOnlyForTesting()"
  },
  {
    "label": "InitializeThreadTaskRunnerHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeThreadTaskRunnerHandle() EXCLUSIVE_LOCKS_REQUIRED(task_runner_lock_)"
  },
  {
    "label": "GetAlternationInterval()",
    "kind": "Method",
    "detail": "Function (base::TimeDelta)",
    "insertText": "GetAlternationInterval()"
  },
  {
    "label": "main_thread_only()",
    "kind": "Method",
    "detail": "Function (MainThreadOnly&)",
    "insertText": "main_thread_only()"
  },
  {
    "label": "DCHECK_CALLED_ON_VALID_THREAD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_CALLED_ON_VALID_THREAD(associated_thread_->thread_checker)"
  }
]