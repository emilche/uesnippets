[
  {
    "label": "FFloatAnimationAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFloatAnimationAttribute"
  },
  {
    "label": "FIntegerAnimationAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FIntegerAnimationAttribute"
  },
  {
    "label": "FStringAnimationAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStringAnimationAttribute"
  },
  {
    "label": "FTransformAnimationAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTransformAnimationAttribute"
  },
  {
    "label": "FVectorAnimationAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FVectorAnimationAttribute"
  },
  {
    "label": "FQuaternionAnimationAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FQuaternionAnimationAttribute"
  },
  {
    "label": "FNonBlendableQuaternionAnimationAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNonBlendableQuaternionAnimationAttribute"
  },
  {
    "label": "FNonBlendableVectorAnimationAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNonBlendableVectorAnimationAttribute"
  },
  {
    "label": "FNonBlendableTransformAnimationAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNonBlendableTransformAnimationAttribute"
  },
  {
    "label": "FNonBlendableFloatAnimationAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNonBlendableFloatAnimationAttribute"
  },
  {
    "label": "FNonBlendableIntegerAnimationAttribute",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNonBlendableIntegerAnimationAttribute"
  },
  {
    "label": "TAttributeTypeTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TAttributeTypeTraits"
  },
  {
    "label": "UBuiltInAttributesExtensions",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UBuiltInAttributesExtensions"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Animation / AnimSequenceBase . h \" # include \" Animation / AttributeTraits . h \" # include \" AnimationRuntime . h \" # include \" Algo / Transform . h \" # include \" BuiltInAttributeTypes . generated . h \")",
    "insertText": "USTRUCT(BlueprintType)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=FloatAnimationAttribute)"
  },
  {
    "label": "Accumulate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Accumulate(const FFloatAnimationAttribute& Attribute, float Weight, EAdditiveAnimationType AdditiveType)"
  },
  {
    "label": "MakeAdditive()",
    "kind": "Method",
    "detail": "Function (Value + = Attribute . Value* Weight ; } void)",
    "insertText": "MakeAdditive(const FFloatAnimationAttribute& BaseAttribute)"
  },
  {
    "label": "Multiply()",
    "kind": "Method",
    "detail": "Function (Value - = BaseAttribute . Value ; } FFloatAnimationAttribute)",
    "insertText": "Multiply(float Weight)"
  },
  {
    "label": "Interpolate()",
    "kind": "Method",
    "detail": "Function (FFloatAnimationAttribute Out ; Out . Value = Value* Weight ; return Out ; } void)",
    "insertText": "Interpolate(const FFloatAnimationAttribute& Attribute, float Alpha)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Value(1.f - Alpha)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Value(Attribute.Value * Alpha)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=IntegerAnimationAttribute)"
  },
  {
    "label": "Accumulate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Accumulate(const FIntegerAnimationAttribute& Attribute, float Weight, EAdditiveAnimationType AdditiveType)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Value(int32)(Attribute.Value * Weight)"
  },
  {
    "label": "MakeAdditive()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MakeAdditive(const FIntegerAnimationAttribute& BaseAttribute)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (FIntegerAnimationAttribute Out ; Out .)",
    "insertText": "Value(int32)(Value * Weight)"
  },
  {
    "label": "TruncToInt32()",
    "kind": "Method",
    "detail": "Function (Value =)",
    "insertText": "TruncToInt32(Value * (1.f - Alpha))"
  },
  {
    "label": "TruncToInt32()",
    "kind": "Method",
    "detail": "Function (Value + =)",
    "insertText": "TruncToInt32(Attribute.Value * Alpha)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=StringAnimationAttribute)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} ; uint32)",
    "insertText": "GetTypeHash(const FStringAnimationAttribute& Key)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=TransformAnimationAttribute)"
  },
  {
    "label": "Accumulate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Accumulate(const FTransformAnimationAttribute& Attribute, float Weight, EAdditiveAnimationType AdditiveType)"
  },
  {
    "label": "VBlendWeight()",
    "kind": "Method",
    "detail": "Function ({ const ScalarRegister)",
    "insertText": "VBlendWeight(Weight)"
  },
  {
    "label": "AccumulateWithShortestRotation()",
    "kind": "Method",
    "detail": "Function (Value .)",
    "insertText": "AccumulateWithShortestRotation(Attribute.Value, VBlendWeight)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(FAnimWeight::IsFullWeight(Weight))"
  },
  {
    "label": "AccumulateWithAdditiveScale()",
    "kind": "Method",
    "detail": "Function (Value .)",
    "insertText": "AccumulateWithAdditiveScale(Attribute.Value, VBlendWeight)"
  },
  {
    "label": "BlendFromIdentityAndAccumulate()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "BlendFromIdentityAndAccumulate(Value, Attribute.Value, VBlendWeight)"
  },
  {
    "label": "MakeAdditive()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "MakeAdditive(const FTransformAnimationAttribute& BaseAttribute)"
  },
  {
    "label": "ConvertTransformToAdditive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConvertTransformToAdditive(Value, BaseAttribute.Value)"
  },
  {
    "label": "Normalize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Normalize()"
  },
  {
    "label": "NormalizeRotation()",
    "kind": "Method",
    "detail": "Function (Value .)",
    "insertText": "NormalizeRotation()"
  },
  {
    "label": "Multiply()",
    "kind": "Method",
    "detail": "Function (} FTransformAnimationAttribute)",
    "insertText": "Multiply(const float Weight)"
  },
  {
    "label": "Interpolate()",
    "kind": "Method",
    "detail": "Function (Out . Value = Value* VBlendWeight ; return Out ; } void)",
    "insertText": "Interpolate(const FTransformAnimationAttribute& Attribute, float Alpha)"
  },
  {
    "label": "BlendWith()",
    "kind": "Method",
    "detail": "Function (Value .)",
    "insertText": "BlendWith(Attribute.Value, Alpha)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=VectorAnimationAttribute)"
  },
  {
    "label": "Accumulate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Accumulate(const FVectorAnimationAttribute& Attribute, float Weight, EAdditiveAnimationType AdditiveType)"
  },
  {
    "label": "MakeAdditive()",
    "kind": "Method",
    "detail": "Function ({ Value + = Attribute . Value* Weight ; } } void)",
    "insertText": "MakeAdditive(const FVectorAnimationAttribute& BaseAttribute)"
  },
  {
    "label": "Interpolate()",
    "kind": "Method",
    "detail": "Function (FVectorAnimationAttribute Out ; Out . Value = Value* Weight ; return Out ; } void)",
    "insertText": "Interpolate(const FVectorAnimationAttribute& Attribute, float Alpha)"
  },
  {
    "label": "FVector()",
    "kind": "Method",
    "detail": "Function (Value = FMath::Lerp<)",
    "insertText": "FVector(Value, Attribute.Value, Alpha)"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=QuaternionAnimationAttribute)"
  },
  {
    "label": "Accumulate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Accumulate(const FQuaternionAnimationAttribute& Attribute, float Weight, EAdditiveAnimationType AdditiveType)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "if(AdditiveType == AAT_None)"
  },
  {
    "label": "DotResult()",
    "kind": "Method",
    "detail": "Function (const FQuat WeightedRotation = Attribute . Value* Weight ; const FQuat::FReal)",
    "insertText": "DotResult(Value | WeightedRotation)"
  },
  {
    "label": "FloatSelect()",
    "kind": "Method",
    "detail": "Function (const FQuat::FReal Bias =)",
    "insertText": "FloatSelect(DotResult, FQuat::FReal(1.0f), FQuat::FReal(-1.0f))"
  },
  {
    "label": "FastLerp()",
    "kind": "Method",
    "detail": "Function (Value + = WeightedRotation* Bias ; } else { const FQuat WeightedRotation =)",
    "insertText": "FastLerp(FQuat::Identity, Attribute.Value, Weight).GetNormalized()"
  },
  {
    "label": "MakeAdditive()",
    "kind": "Method",
    "detail": "Function (Value = WeightedRotation* Value ; } } } void)",
    "insertText": "MakeAdditive(const FQuaternionAnimationAttribute& BaseAttribute)"
  },
  {
    "label": "Inverse()",
    "kind": "Method",
    "detail": "Function (Value = Value* BaseAttribute . Value .)",
    "insertText": "Inverse()"
  },
  {
    "label": "Interpolate()",
    "kind": "Method",
    "detail": "Function (FQuaternionAnimationAttribute Out ; Out . Value = Value* Weight ; return Out ; } void)",
    "insertText": "Interpolate(const FQuaternionAnimationAttribute& Attribute, float Alpha)"
  },
  {
    "label": "FastLerp()",
    "kind": "Method",
    "detail": "Function (Value =)",
    "insertText": "FastLerp(Value, Attribute.Value, Alpha).GetNormalized()"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "USTRUCT()"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY()"
  },
  {
    "label": "AddTypedCustomAttribute()",
    "kind": "Method",
    "detail": "Function (namespace UE { namespace Anim { template<> struct TAttributeTypeTraits<FIntegerAnimationAttribute> : public TAttributeTypeTraitsBase<FIntegerAnimationAttribute> { enum { StepInterpolate = true,} ; } ; template<> struct TAttributeTypeTraits<FStringAnimationAttribute> : public TAttributeTypeTraitsBase<FStringAnimationAttribute> { enum { IsBlendable = false,} ; } ; template<> struct TAttributeTypeTraits<FTransformAnimationAttribute> : public TAttributeTypeTraitsBase<FTransformAnimationAttribute> { enum { RequiresNormalization = true,} ; } ; template<> struct TAttributeTypeTraits<FQuaternionAnimationAttribute> : public TAttributeTypeTraitsBase<FQuaternionAnimationAttribute> { enum { RequiresNormalization = true,} ; } ; template<> struct TAttributeTypeTraits<FNonBlendableQuaternionAnimationAttribute> : public TAttributeTypeTraitsBase<FNonBlendableQuaternionAnimationAttribute> { enum { IsBlendable = false,} ; } ; template<> struct TAttributeTypeTraits<FNonBlendableVectorAnimationAttribute> : public TAttributeTypeTraitsBase<FNonBlendableVectorAnimationAttribute> { enum { IsBlendable = false,} ; } ; template<> struct TAttributeTypeTraits<FNonBlendableTransformAnimationAttribute> : public TAttributeTypeTraitsBase<FNonBlendableTransformAnimationAttribute> { enum { IsBlendable = false,} ; } ; template<> struct TAttributeTypeTraits<FNonBlendableFloatAnimationAttribute> : public TAttributeTypeTraitsBase<FNonBlendableFloatAnimationAttribute> { enum { IsBlendable = false,} ; } ; template<> struct TAttributeTypeTraits<FNonBlendableIntegerAnimationAttribute> : public TAttributeTypeTraitsBase<FNonBlendableIntegerAnimationAttribute> { enum { IsBlendable = false,} ; } ; # if WITH_EDITOR template<AttributeType,ValueType> bool)",
    "insertText": "AddTypedCustomAttribute(const FName& AttributeName, const FName& BoneName, UAnimSequenceBase* AnimSequenceBase, TArrayView<const float> Keys, TArrayView<const ValueType> Values, bool bShouldTransact = true)"
  },
  {
    "label": "CreateAttributeIdentifier()",
    "kind": "Method",
    "detail": "Function (const FAnimationAttributeIdentifier Identifier =)",
    "insertText": "CreateAttributeIdentifier(AnimSequenceBase, AttributeName, BoneName, AttributeType::StaticStruct())"
  },
  {
    "label": "GetController()",
    "kind": "Method",
    "detail": "Function (IAnimationDataController& Controller = AnimSequenceBase ->)",
    "insertText": "GetController()"
  },
  {
    "label": "Transform()",
    "kind": "Method",
    "detail": "Function (TArray<AttributeType> AttributeValues ;)",
    "insertText": "Transform(Values, AttributeValues, [](const ValueType& Value) { AttributeType Attribute; Attribute.Value = Value; return Attribute; })"
  },
  {
    "label": "UCLASS()",
    "kind": "Method",
    "detail": "Function (} return false ; } # endif } })",
    "insertText": "UCLASS()"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() public: #if WITH_EDITOR UFUNCTION(BlueprintCallable, Category = Attributes, meta = (ScriptMethod)) static bool AddTransformAttribute(UAnimSequenceBase* AnimSequenceBase, const FName& AttributeName, const FName& BoneName, const TArray<float>& Keys, const TArray<FTransform>& Values)"
  }
]