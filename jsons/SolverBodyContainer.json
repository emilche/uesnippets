[
  {
    "label": "FSolverBody",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSolverBody"
  },
  {
    "label": "FSolverBodyContainer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSolverBodyContainer"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Evolution / SolverBody . h \" # include \" Chaos / Framework / ContainerItemHandle . h \" # include \" Chaos / ObjectPool . h \" # include \" Chaos / ParticleHandle . h \" # include \" Chaos / Particle / ParticleUtilities . h \" # include \" Chaos / Framework / ChunkedArray . h \" # include \" Containers / Array . h \" # include \" Containers / Map . h \" namespace Chaos { class FSolverBody ; class FSolverBodyContainer ; class FSolverBodyContainer { private : const int32 NumBodiesPerChunk = 2 5 6 ; const int32 BodyArrayChunkSize = NumBodiesPerChunk*)",
    "insertText": "sizeof(FSolverBody)"
  },
  {
    "label": "FSolverBodyContainer()",
    "kind": "Method",
    "detail": "Function (public : using FSolverBodyArray = Private::TChaosChunkedArray<FSolverBody,BodyArrayChunkSize> ;)",
    "insertText": "FSolverBodyContainer() : bLocked(true)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset(int MaxBodies)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (SolverBodies .)",
    "insertText": "Reset()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (Particles .)",
    "insertText": "Reset(MaxBodies)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (bLocked = false ; } int)",
    "insertText": "Num()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "Max()"
  },
  {
    "label": "GetParticle()",
    "kind": "Method",
    "detail": "Function (} FGeometryParticleHandle*)",
    "insertText": "GetParticle(const int32 Index)"
  },
  {
    "label": "GatherInput()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GatherInput(const FReal Dt, const int32 BeginIndex, const int32 EndIndex)"
  },
  {
    "label": "ScatterOutput()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ScatterOutput(const int32 BeginIndex, const int32 EndIndex)"
  },
  {
    "label": "SetImplicitVelocities()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetImplicitVelocities(FReal Dt)"
  },
  {
    "label": "ApplyCorrections()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyCorrections()"
  },
  {
    "label": "UpdateRotationDependentState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateRotationDependentState()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Lock()"
  },
  {
    "label": "CopyTo()",
    "kind": "Method",
    "detail": "Function (bLocked = true ; } void)",
    "insertText": "CopyTo(FSolverBodyContainer& Dest)"
  },
  {
    "label": "AddParticle()",
    "kind": "Method",
    "detail": "Function (Dest . SolverBodies = SolverBodies ; Dest . Particles = Particles ; Dest . ParticleToIndexMap = ParticleToIndexMap ; Dest . bLocked = bLocked ; } private : int32)",
    "insertText": "AddParticle(FGenericParticleHandle InParticle)"
  }
]