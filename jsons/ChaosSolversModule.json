[
  {
    "label": "IChaosSolverActorClassProvider",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IChaosSolverActorClassProvider"
  },
  {
    "label": "IChaosSettingsProvider",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IChaosSettingsProvider"
  },
  {
    "label": "FPersistentPhysicsTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPersistentPhysicsTask"
  },
  {
    "label": "FPhysicsProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsProxy"
  },
  {
    "label": "FPhysicsSolverBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPhysicsSolverBase"
  },
  {
    "label": "FInternalDefaultSettings",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FInternalDefaultSettings"
  },
  {
    "label": "FSolverStateStorage",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSolverStateStorage"
  },
  {
    "label": "FChaosSolversModule",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosSolversModule"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FChaosScopeSolverLock",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FChaosScopeSolverLock"
  },
  {
    "label": "GetSolverActorClass()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" HAL / Event . h \" # include \" HAL / IConsoleManager . h \" # include \" HAL / ThreadSafeBool . h \" # include \" Modules / ModuleInterface . h \" # include \" Modules / ModuleManager . h \" # include \" Async / AsyncWork . h \" # include \" UObject / ObjectMacros . h \" # include \" Framework / Threading . h \" # include \" PhysicsCoreTypes . h \" # include \" Chaos / Framework / MultiBufferResource . h \" # include \" Chaos / Declares . h \" # include \" Chaos / PhysicalMaterials . h \" # include \" Chaos / Defines . h \" # include \" Async / TaskGraphInterfaces . h \" class IChaosSolverActorClassProvider { public : UClass*)",
    "insertText": "GetSolverActorClass()"
  },
  {
    "label": "IChaosSettingsProvider()",
    "kind": "Method",
    "detail": "Function (} ; class IChaosSettingsProvider { public : ~)",
    "insertText": "IChaosSettingsProvider()"
  },
  {
    "label": "GetMinDeltaVelocityForHitEvents()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetMinDeltaVelocityForHitEvents()"
  },
  {
    "label": "GetResimulationErrorPositionThresholdEnabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetResimulationErrorPositionThresholdEnabled()"
  },
  {
    "label": "FSolverStateStorage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSolverStateStorage(const FSolverStateStorage& InCopy)"
  },
  {
    "label": "FSolverStateStorage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSolverStateStorage(FSolverStateStorage&& InSteal)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FSolverStateStorage&)",
    "insertText": "operator(const FSolverStateStorage& InCopy)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FSolverStateStorage&)",
    "insertText": "operator(FSolverStateStorage&& InSteal)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (} ; enum class ESolverFlags : uint8 { None = 0,Standalone = 1<<0 } ;)",
    "insertText": "ENUM_CLASS_FLAGS(ESolverFlags)"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (class FChaosSolversModule { public : FChaosSolversModule*)",
    "insertText": "GetModule()"
  },
  {
    "label": "FChaosSolversModule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FChaosSolversModule()"
  },
  {
    "label": "StartupModule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartupModule()"
  },
  {
    "label": "ShutdownModule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ShutdownModule()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize()"
  },
  {
    "label": "Shutdown()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Shutdown()"
  },
  {
    "label": "IsPersistentTaskEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPersistentTaskEnabled()"
  },
  {
    "label": "IsPersistentTaskRunning()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPersistentTaskRunning()"
  },
  {
    "label": "GetDedicatedTask()",
    "kind": "Method",
    "detail": "Function (Chaos::FPersistentPhysicsTask*)",
    "insertText": "GetDedicatedTask()"
  },
  {
    "label": "SyncTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SyncTask(bool bForceBlockingSync = false)"
  },
  {
    "label": "CreateSolver()",
    "kind": "Method",
    "detail": "Function (Chaos::FPBDRigidsSolver*)",
    "insertText": "CreateSolver(UObject* InOwner, Chaos::FReal InAsyncDt, Chaos::EThreadingMode ThreadingMode = Chaos::EThreadingMode::SingleThread, const FName& DebugName = NAME_None)"
  },
  {
    "label": "MigrateSolver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MigrateSolver(Chaos::FPhysicsSolverBase* InSolver, const UObject* InNewOwner)"
  },
  {
    "label": "SetSolverActorClass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSolverActorClass(UClass* InActorClass, UClass* InActorRequiredBaseClass)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (SolverActorClass = InActorClass ; SolverActorRequiredBaseClass = InActorRequiredBaseClass ;)",
    "insertText": "check(IsValidSolverActorClass(SolverActorClass))"
  },
  {
    "label": "IsValidSolverActorClass()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValidSolverActorClass(UClass* Class)"
  },
  {
    "label": "DestroySolver()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroySolver(Chaos::FPhysicsSolverBase* InState)"
  },
  {
    "label": "GetAllSolvers()",
    "kind": "Method",
    "detail": "Function (const TArray<Chaos::FPhysicsSolverBase*>&)",
    "insertText": "GetAllSolvers()"
  },
  {
    "label": "GetSolvers()",
    "kind": "Method",
    "detail": "Function (TArray<const Chaos::FPhysicsSolverBase*>)",
    "insertText": "GetSolvers(const UObject* InOwner)"
  },
  {
    "label": "GetSolvers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSolvers(const UObject* InOwner, TArray<const Chaos::FPhysicsSolverBase*>& OutSolvers)"
  },
  {
    "label": "GetSolversMutable()",
    "kind": "Method",
    "detail": "Function (TArray<Chaos::FPhysicsSolverBase*>)",
    "insertText": "GetSolversMutable(const UObject* InOwner)"
  },
  {
    "label": "GetSolversMutable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSolversMutable(const UObject* InOwner, TArray<Chaos::FPhysicsSolverBase*>& OutSolvers)"
  },
  {
    "label": "DumpHierarchyStats()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DumpHierarchyStats(int32* OutOptMaxCellElements = nullptr)"
  },
  {
    "label": "PauseSolvers()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR void)",
    "insertText": "PauseSolvers()"
  },
  {
    "label": "ResumeSolvers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResumeSolvers()"
  },
  {
    "label": "SingleStepSolvers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SingleStepSolvers()"
  },
  {
    "label": "ShouldStepSolver()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldStepSolver(int32& InOutSingleStepCounter)"
  },
  {
    "label": "RegisterSolverActorClassProvider()",
    "kind": "Method",
    "detail": "Function (# endif void)",
    "insertText": "RegisterSolverActorClassProvider(IChaosSolverActorClassProvider* Provider)"
  },
  {
    "label": "GetSettingsProvider()",
    "kind": "Method",
    "detail": "Function (SolverActorClassProvider = Provider ; } ; const IChaosSettingsProvider&)",
    "insertText": "GetSettingsProvider()"
  },
  {
    "label": "SetSettingsProvider()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSettingsProvider(IChaosSettingsProvider* InProvider)"
  },
  {
    "label": "LockSolvers()",
    "kind": "Method",
    "detail": "Function (SettingsProvider = InProvider ; } void)",
    "insertText": "LockSolvers()"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (SolverLock .)",
    "insertText": "Lock()"
  },
  {
    "label": "UnlockSolvers()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UnlockSolvers()"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (SolverLock .)",
    "insertText": "Unlock()"
  },
  {
    "label": "OnUpdateMaterial()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnUpdateMaterial(Chaos::FMaterialHandle InHandle)"
  },
  {
    "label": "OnCreateMaterial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnCreateMaterial(Chaos::FMaterialHandle InHandle)"
  },
  {
    "label": "OnDestroyMaterial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnDestroyMaterial(Chaos::FMaterialHandle InHandle)"
  },
  {
    "label": "OnUpdateMaterialMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnUpdateMaterialMask(Chaos::FMaterialMaskHandle InHandle)"
  },
  {
    "label": "OnCreateMaterialMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnCreateMaterialMask(Chaos::FMaterialMaskHandle InHandle)"
  },
  {
    "label": "OnDestroyMaterialMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnDestroyMaterialMask(Chaos::FMaterialMaskHandle InHandle)"
  },
  {
    "label": "GetSolverUpdatePrerequisites()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSolverUpdatePrerequisites(FGraphEventArray& InPrerequisiteContainer)"
  },
  {
    "label": "FChaosScopeSolverLock()",
    "kind": "Method",
    "detail": "Function (private : IChaosSolverActorClassProvider* SolverActorClassProvider ; IChaosSettingsProvider* SettingsProvider ; bool bPersistentTaskSpawned ; FAsyncTask<Chaos::FPersistentPhysicsTask>* PhysicsAsyncTask ; Chaos::FPersistentPhysicsTask* PhysicsInnerTask ; FDelegateHandle PreExitHandle ; TArray<Chaos::FPhysicsSolverBase*> AllSolvers ; TMap<const UObject*,TArray<Chaos::FPhysicsSolverBase*>> SolverMap ; FCriticalSection SolverLock ; UClass* SolverActorClass ; UClass* SolverActorRequiredBaseClass ; FGraphEventRef GlobalCommandTaskEventRef ; # if STATS float AverageUpdateTime ; float TotalAverageUpdateTime ; float Fps ; float EffectiveFps ; # endif # if WITH_EDITOR FThreadSafeBool bPauseSolvers ; FThreadSafeCounter SingleStepCounter ; # endif bool bModuleInitialized ; FDelegateHandle OnCreateMaterialHandle ; FDelegateHandle OnDestroyMaterialHandle ; FDelegateHandle OnUpdateMaterialHandle ; FDelegateHandle OnCreateMaterialMaskHandle ; FDelegateHandle OnDestroyMaterialMaskHandle ; FDelegateHandle OnUpdateMaterialMaskHandle ; } ; struct FChaosScopeSolverLock {)",
    "insertText": "FChaosScopeSolverLock()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetModule()->LockSolvers()"
  },
  {
    "label": "GetModule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetModule()->UnlockSolvers()"
  }
]