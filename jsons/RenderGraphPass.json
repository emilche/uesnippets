[
  {
    "label": "FRDGDispatchPassBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGDispatchPassBuilder"
  },
  {
    "label": "FRDGBarrierBatchBeginId",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRDGBarrierBatchBeginId"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FRDGTransitionInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRDGTransitionInfo"
  },
  {
    "label": "FRDGBarrierBatchEndId",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRDGBarrierBatchEndId"
  },
  {
    "label": "FRDGBarrierBatchBegin",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGBarrierBatchBegin"
  },
  {
    "label": "FRDGBarrierBatchEnd",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGBarrierBatchEnd"
  },
  {
    "label": "FRDGBarrierValidation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGBarrierValidation"
  },
  {
    "label": "FRDGBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGBuilder"
  },
  {
    "label": "FRDGPass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGPass"
  },
  {
    "label": "FTextureState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTextureState"
  },
  {
    "label": "FBufferState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBufferState"
  },
  {
    "label": "FExternalAccessOp",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FExternalAccessOp"
  },
  {
    "label": "TRDGLambdaPass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRDGLambdaPass"
  },
  {
    "label": "ExecuteLambdaTraits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ExecuteLambdaTraits"
  },
  {
    "label": "TLambdaTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TLambdaTraits"
  },
  {
    "label": "FRDGDispatchPass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGDispatchPass"
  },
  {
    "label": "TRDGDispatchPass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRDGDispatchPass"
  },
  {
    "label": "TRDGEmptyLambdaPass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRDGEmptyLambdaPass"
  },
  {
    "label": "FRDGSentinelPass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGSentinelPass"
  },
  {
    "label": "FRDGTrace",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGTrace"
  },
  {
    "label": "FRDGUserValidation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FRDGUserValidation"
  },
  {
    "label": "FShaderParametersMetadata",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FShaderParametersMetadata"
  },
  {
    "label": "FRDGBarrierBatchBeginId()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" Containers / ContainerAllocationPolicies . h \" # include \" Containers / SortedMap . h \" # include \" Containers / StaticArray . h \" # include \" Containers / UnrealString . h \" # include \" HAL / Platform . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / EnumClassFlags . h \" # include \" MultiGPU . h \" # include \" RHI . h \" # include \" RHICommandList . h \" # include \" RHIDefinitions . h \" # include \" RenderGraphAllocator . h \" # include \" RenderGraphDefinitions . h \" # include \" RenderGraphEvent . h \" # include \" RenderGraphParameter . h \" # include \" RenderGraphResources . h \" # include \" ShaderParameterMacros . h \" # include \" Stats / Stats . h \" # include \" Stats / Stats2 . h \" # include \" Templates / EnableIf . h \" # include \" Templates / UnrealTemplate . h \" # include \" Templates / UnrealTypeTraits . h \" class FRDGDispatchPassBuilder ; using FRDGTransitionQueue = TArray<const FRHITransition*,TInlineAllocator<8>> ; struct FRDGBarrierBatchBeginId {)",
    "insertText": "FRDGBarrierBatchBeginId()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(FRDGBarrierBatchBeginId Other)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash(FRDGBarrierBatchBeginId Id)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (uint32 Hash =)",
    "insertText": "GetTypeHash(*(const uint64*)Id.Passes.GetData())"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} FRDGPassHandlesByPipeline Passes ; ERHIPipeline PipelinesAfter = ERHIPipeline::None ; } ; enum class ERDGBarrierLocation : uint8 { Prologue,Epilogue } ; struct FRDGTransitionInfo {)",
    "insertText": "static_assert((int32)ERHIAccess::Last <= (1 << 20) && (int32)ERDGViewableResourceType::MAX <= 3 && (int32)EResourceTransitionFlags::Last == (1 << 2), \"FRDGTransitionInfo packing is no longer correct.\")"
  },
  {
    "label": "FRDGBarrierBatchEndId()",
    "kind": "Method",
    "detail": "Function (uint64 AccessBefore : 2 1 ; uint64 AccessAfter : 2 1 ; uint64 ResourceHandle : 1 6 ; uint64 ResourceType : 3 ; uint64 ResourceTransitionFlags : 3 ; union { struct { uint16 ArraySlice ; uint8 MipIndex ; uint8 PlaneSlice ; } Texture ; struct { uint64 CommitSize ; } Buffer ; } ; } ; struct FRDGBarrierBatchEndId {)",
    "insertText": "FRDGBarrierBatchEndId()"
  },
  {
    "label": "FRDGBarrierBatchEndId()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRDGBarrierBatchEndId(FRDGPassHandle InPassHandle, ERDGBarrierLocation InBarrierLocation) : PassHandle(InPassHandle) , BarrierLocation(InBarrierLocation)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(FRDGBarrierBatchEndId Other)"
  },
  {
    "label": "FRDGBarrierBatchBegin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRDGBarrierBatchBegin(ERHIPipeline PipelinesToBegin, ERHIPipeline PipelinesToEnd, const TCHAR* DebugName, FRDGPassesByPipeline DebugPasses)"
  },
  {
    "label": "AddTransition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTransition(FRDGViewableResource* Resource, FRDGTransitionInfo Info)"
  },
  {
    "label": "AddAlias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddAlias(FRDGViewableResource* Resource, const FRHITransientAliasingInfo& Info)"
  },
  {
    "label": "SetUseCrossPipelineFence()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetUseCrossPipelineFence(bool bUseSeparateTransition)"
  },
  {
    "label": "CreateTransition()",
    "kind": "Method",
    "detail": "Function (bSeparateFenceTransitionNeeded = true ; } else { TransitionFlags = ERHITransitionCreateFlags::None ; } bTransitionNeeded = true ; } void)",
    "insertText": "CreateTransition(TConstArrayView<FRHITransitionInfo> TransitionsRHI)"
  },
  {
    "label": "Submit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Submit(FRHIComputeCommandList& RHICmdList, ERHIPipeline Pipeline)"
  },
  {
    "label": "Submit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Submit(FRHIComputeCommandList& RHICmdList, ERHIPipeline Pipeline, FRDGTransitionQueue& TransitionsToBegin)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reserve(uint32 TransitionCount)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Transitions .)",
    "insertText": "Reserve(TransitionCount)"
  },
  {
    "label": "IsTransitionNeeded()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsTransitionNeeded()"
  },
  {
    "label": "AddDependency()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddDependency(FRDGBarrierBatchBegin* BeginBatch)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reserve(uint32 TransitionBatchCount)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Dependencies .)",
    "insertText": "Reserve(TransitionBatchCount)"
  },
  {
    "label": "GetId()",
    "kind": "Method",
    "detail": "Function (} FRDGBarrierBatchEndId)",
    "insertText": "GetId()"
  },
  {
    "label": "IsPairedWith()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsPairedWith(const FRDGBarrierBatchBegin& BeginBatch)"
  },
  {
    "label": "FRDGPass()",
    "kind": "Method",
    "detail": "Function (private : TArray<FRDGBarrierBatchBegin*,TInlineAllocator<4,FRDGArrayAllocator>> Dependencies ; FRDGPass* Pass ; ERDGBarrierLocation BarrierLocation ; class FRDGBarrierBatchBegin ; class FRDGBarrierValidation ; } ; class FRDGPass { public :)",
    "insertText": "FRDGPass(FRDGEventName&& InName, FRDGParameterStruct InParameterStruct, ERDGPassFlags InFlags, ERDGPassTaskMode InTaskMode)"
  },
  {
    "label": "FRDGPass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRDGPass(const FRDGPass&)"
  },
  {
    "label": "FRDGPass()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FRDGPass()"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (# if RDG_ENABLE_DEBUG const TCHAR*)",
    "insertText": "GetName()"
  },
  {
    "label": "GetEventName()",
    "kind": "Method",
    "detail": "Function (} # endif const FRDGEventName&)",
    "insertText": "GetEventName()"
  },
  {
    "label": "FRHIGPUMask()",
    "kind": "Method",
    "detail": "Function (# if WITH_MGPU return GPUMask ; # else return)",
    "insertText": "FRHIGPUMask()"
  },
  {
    "label": "GetPrologueBarriersToBegin()",
    "kind": "Method",
    "detail": "Function (# endif } protected : FRDGBarrierBatchBegin&)",
    "insertText": "GetPrologueBarriersToBegin(FRDGAllocator& Allocator, FRDGTransitionCreateQueue& CreateQueue)"
  },
  {
    "label": "GetEpilogueBarriersToBeginForGraphics()",
    "kind": "Method",
    "detail": "Function (FRDGBarrierBatchBegin&)",
    "insertText": "GetEpilogueBarriersToBeginForGraphics(FRDGAllocator& Allocator, FRDGTransitionCreateQueue& CreateQueue)"
  },
  {
    "label": "GetEpilogueBarriersToBeginForAsyncCompute()",
    "kind": "Method",
    "detail": "Function (FRDGBarrierBatchBegin&)",
    "insertText": "GetEpilogueBarriersToBeginForAsyncCompute(FRDGAllocator& Allocator, FRDGTransitionCreateQueue& CreateQueue)"
  },
  {
    "label": "GetEpilogueBarriersToBeginForAll()",
    "kind": "Method",
    "detail": "Function (FRDGBarrierBatchBegin&)",
    "insertText": "GetEpilogueBarriersToBeginForAll(FRDGAllocator& Allocator, FRDGTransitionCreateQueue& CreateQueue)"
  },
  {
    "label": "GetEpilogueBarriersToBeginFor()",
    "kind": "Method",
    "detail": "Function (FRDGBarrierBatchBegin&)",
    "insertText": "GetEpilogueBarriersToBeginFor(FRDGAllocator& Allocator, FRDGTransitionCreateQueue& CreateQueue, ERHIPipeline PipelineForEnd)"
  },
  {
    "label": "checkNoEntry()",
    "kind": "Method",
    "detail": "Function (default :)",
    "insertText": "checkNoEntry()"
  },
  {
    "label": "GetPrologueBarriersToEnd()",
    "kind": "Method",
    "detail": "Function (} } FRDGBarrierBatchEnd&)",
    "insertText": "GetPrologueBarriersToEnd(FRDGAllocator& Allocator)"
  },
  {
    "label": "GetEpilogueBarriersToEnd()",
    "kind": "Method",
    "detail": "Function (FRDGBarrierBatchEnd&)",
    "insertText": "GetEpilogueBarriersToEnd(FRDGAllocator& Allocator)"
  },
  {
    "label": "Execute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Execute(FRHIComputeCommandList& RHICmdList)"
  },
  {
    "label": "LaunchDispatchPassTasks()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "LaunchDispatchPassTasks(FRDGDispatchPassBuilder& DispatchPassBuilder)"
  },
  {
    "label": "IF_RDG_ENABLE_DEBUG()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "IF_RDG_ENABLE_DEBUG(FString FullPathIfDebug)"
  },
  {
    "label": "FTextureState()",
    "kind": "Method",
    "detail": "Function (const FRDGEventName Name ; const FRDGParameterStruct ParameterStruct ; const ERDGPassFlags Flags ; const ERDGPassTaskMode TaskMode ; const ERHIPipeline Pipeline ; FRDGPassHandle Handle ; uint32 Workload = 1 ; union { struct { uint32 bSkipRenderPassBegin : 1 ; uint32 bSkipRenderPassEnd : 1 ; uint32 bAsyncComputeBegin : 1 ; uint32 bAsyncComputeEnd : 1 ; uint32 bGraphicsFork : 1 ; uint32 bGraphicsJoin : 1 ; uint32 bRenderPassOnlyWrites : 1 ; uint32 bSentinel : 1 ; uint32 bDispatchAfterExecute : 1 ; uint32 bDispatchPass : 1 ; } ; uint32 PackedBits1 = 0 ; } ; union { struct { uint32 bParallelExecuteBegin : 1 ; uint32 bParallelExecuteEnd : 1 ; uint32 bParallelExecute : 1 ; uint32 bEmptyParameters : 1 ; uint32 bHasExternalOutputs : 1 ; uint32 bCulled : 1 ; uint32 bExternalAccessPass : 1 ; } ; uint32 PacketBits2 = 0 ; } ; FRDGPassHandle CrossPipelineProducer ; FRDGPassHandle GraphicsForkPass ; FRDGPassHandle GraphicsJoinPass ; FRDGPassHandle PrologueBarrierPass ; FRDGPassHandle EpilogueBarrierPass ; TArray<FRDGPassHandle,FRDGArrayAllocator> CrossPipelineConsumers ; TArray<FRDGPass*,FRDGArrayAllocator> Producers ; struct FTextureState {)",
    "insertText": "FTextureState()"
  },
  {
    "label": "FTextureState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FTextureState(FRDGTextureRef InTexture) : Texture(InTexture)"
  },
  {
    "label": "GetSubresourceCount()",
    "kind": "Method",
    "detail": "Function (const uint32 SubresourceCount = Texture ->)",
    "insertText": "GetSubresourceCount()"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (State .)",
    "insertText": "SetNum(SubresourceCount)"
  },
  {
    "label": "FBufferState()",
    "kind": "Method",
    "detail": "Function (} FRDGTextureRef Texture = nullptr ; FRDGTextureSubresourceState State ; FRDGTextureSubresourceState MergeState ; uint32 ReferenceCount = 0 ; } ; struct FBufferState {)",
    "insertText": "FBufferState()"
  },
  {
    "label": "FBufferState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBufferState(FRDGBufferRef InBuffer) : Buffer(InBuffer)"
  },
  {
    "label": "FExternalAccessOp()",
    "kind": "Method",
    "detail": "Function (} FRDGBufferRef Buffer = nullptr ; FRDGSubresourceState State ; FRDGSubresourceState* MergeState = nullptr ; uint32 ReferenceCount = 0 ; } ; TArray<FTextureState,FRDGArrayAllocator> TextureStates ; TArray<FBufferState,FRDGArrayAllocator> BufferStates ; TArray<FRDGViewHandle,FRDGArrayAllocator> Views ; TArray<FRDGUniformBufferHandle,FRDGArrayAllocator> UniformBuffers ; struct FExternalAccessOp {)",
    "insertText": "FExternalAccessOp()"
  },
  {
    "label": "FExternalAccessOp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FExternalAccessOp(FRDGViewableResource* InResource, FRDGViewableResource::EAccessMode InMode) : Resource(InResource) , Mode(InMode)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} FRDGViewableResource* Resource ; FRDGViewableResource::EAccessMode Mode ; } ; TArray<FExternalAccessOp,FRDGArrayAllocator> ExternalAccessOps ; TArray<FRDGPass*,TInlineAllocator<1,FRDGArrayAllocator>> ResourcesToBegin ; TArray<FRDGPass*,TInlineAllocator<1,FRDGArrayAllocator>> ResourcesToEnd ; FRDGBarrierBatchBegin* PrologueBarriersToBegin = nullptr ; FRDGBarrierBatchEnd PrologueBarriersToEnd ; FRDGBarrierBatchBegin EpilogueBarriersToBeginForGraphics ; FRDGBarrierBatchBegin* EpilogueBarriersToBeginForAsyncCompute = nullptr ; FRDGBarrierBatchBegin* EpilogueBarriersToBeginForAll = nullptr ; TArray<FRDGBarrierBatchBegin*,FRDGArrayAllocator> SharedEpilogueBarriersToBegin ; FRDGBarrierBatchEnd* EpilogueBarriersToEnd = nullptr ; uint32 ParallelPassSetIndex = 0 ; # if WITH_MGPU FRHIGPUMask GPUMask ; # endif FRDGScope* Scope = nullptr ; # if RDG_ENABLE_TRACE TArray<FRDGTextureHandle,FRDGArrayAllocator> TraceTextures ; TArray<FRDGBufferHandle,FRDGArrayAllocator> TraceBuffers ; # endif FRDGBuilder ; FRDGPassRegistry ; FRDGTrace ; FRDGUserValidation ; FRDGDispatchPassBuilder ; } ; template<ParameterStructType,ExecuteLambdaType> class TRDGLambdaPass : public FRDGPass { class ExecuteLambdaTraits { private : int32 kMaximumLambdaCaptureSize = 1 0 2 4 ;)",
    "insertText": "static_assert(sizeof(ExecuteLambdaType) <= kMaximumLambdaCaptureSize, \"The amount of data of captured for the pass looks abnormally high.\")"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (template<T> struct TLambdaTraits : TLambdaTraits<)",
    "insertText": "decltype(&T::operator())"
  },
  {
    "label": "ReturnType()",
    "kind": "Method",
    "detail": "Function (} ; template<ReturnType,ClassType,ArgType> struct TLambdaTraits<)",
    "insertText": "ReturnType(ClassType::*)(ArgType&)"
  },
  {
    "label": "ReturnType()",
    "kind": "Method",
    "detail": "Function (using TRHICommandList = ArgType ; using TRDGPass = void ; using TRDGAsyncToken = void ; bool bIsTaskAsync = false ; } ; template<ReturnType,ClassType,ArgType> struct TLambdaTraits<)",
    "insertText": "ReturnType(ClassType::*)(FRDGAsyncTask, ArgType&)"
  },
  {
    "label": "ReturnType()",
    "kind": "Method",
    "detail": "Function (using TRHICommandList = ArgType ; using TRDGPass = void ; bool bIsTaskAsync = true ; } ; template<ReturnType,ClassType,ArgType1,ArgType2> struct TLambdaTraits<)",
    "insertText": "ReturnType(ClassType::*)(const ArgType1*, ArgType2&)"
  },
  {
    "label": "ReturnType()",
    "kind": "Method",
    "detail": "Function (bool bIsTaskAsync = false ; } ; template<ReturnType,ClassType,ArgType1,ArgType2> struct TLambdaTraits<)",
    "insertText": "ReturnType(ClassType::*)(const ArgType1*, FRDGAsyncTask, ArgType2&)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (bool bIsTaskAsync = true ; } ; public : using TRHICommandList = TLambdaTraits<ExecuteLambdaType>::TRHICommandList ; bool bIsCommandListImmediate = std::is_same_v<TRHICommandList,FRHICommandListImmediate> ; bool bIsPassArgValid = ! std::is_same_v<TLambdaTraits<ExecuteLambdaType>::TRDGPass,void> ; ERDGPassTaskMode TaskMode = bIsCommandListImmediate ? ERDGPassTaskMode::: TLambdaTraits<ExecuteLambdaType>::bIsTaskAsync ? ERDGPassTaskMode::Async : ERDGPassTaskMode::Await ;)",
    "insertText": "static_assert((bIsCommandListImmediate && TLambdaTraits<ExecuteLambdaType>::bIsTaskAsync) == false, \"RDG pass is marked with RDG_TASK_ASYNC but is using the immediate command list. This is not allowed.\")"
  },
  {
    "label": "TRDGLambdaPass()",
    "kind": "Method",
    "detail": "Function (} ; public :)",
    "insertText": "TRDGLambdaPass(FRDGEventName&& InName, const FShaderParametersMetadata* InParameterMetadata, const ParameterStructType* InParameterStruct, ERDGPassFlags InPassFlags, ExecuteLambdaType&& InExecuteLambda) : FRDGPass(MoveTemp(InName), FRDGParameterStruct(InParameterStruct, InParameterMetadata), InPassFlags, ExecuteLambdaTraits::TaskMode) , ExecuteLambda(MoveTemp(InExecuteLambda)) #if RDG_ENABLE_DEBUG , DebugParameterStruct(InParameterStruct)"
  },
  {
    "label": "ExecuteLambdaFunc()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "ExecuteLambdaFunc(FRHIComputeCommandList& RHICmdList)"
  },
  {
    "label": "ExecuteLambda()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExecuteLambda(this, FRDGAsyncTask(), static_cast<typename ExecuteLambdaTraits::TRHICommandList&>(RHICmdList))"
  },
  {
    "label": "ExecuteLambda()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "ExecuteLambda(FRDGAsyncTask(), static_cast<typename ExecuteLambdaTraits::TRHICommandList&>(RHICmdList))"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} } else { if)",
    "insertText": "constexpr(ExecuteLambdaTraits::bIsPassArgValid)"
  },
  {
    "label": "ExecuteLambda()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExecuteLambda(this, static_cast<typename ExecuteLambdaTraits::TRHICommandList&>(RHICmdList))"
  },
  {
    "label": "ExecuteLambda()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "ExecuteLambda(static_cast<typename ExecuteLambdaTraits::TRHICommandList&>(RHICmdList))"
  },
  {
    "label": "QUICK_SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (# if ! USE_NULL_RHI)",
    "insertText": "QUICK_SCOPE_CYCLE_COUNTER(STAT_FRDGPass_Execute)"
  },
  {
    "label": "SetStaticUniformBuffers()",
    "kind": "Method",
    "detail": "Function (RHICmdList .)",
    "insertText": "SetStaticUniformBuffers(ParameterStruct.GetStaticUniformBuffers())"
  },
  {
    "label": "ExecuteLambdaFunc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExecuteLambdaFunc(static_cast<typename ExecuteLambdaTraits::TRHICommandList&>(RHICmdList))"
  },
  {
    "label": "IF_RDG_ENABLE_DEBUG()",
    "kind": "Method",
    "detail": "Function (# endif } ExecuteLambdaType ExecuteLambda ;)",
    "insertText": "IF_RDG_ENABLE_DEBUG(const ParameterStructType* DebugParameterStruct)"
  },
  {
    "label": "FRDGDispatchPass()",
    "kind": "Method",
    "detail": "Function (} ; class FRDGDispatchPass : public FRDGPass { public :)",
    "insertText": "FRDGDispatchPass(FRDGEventName&& InName, FRDGParameterStruct InParameterStruct, ERDGPassFlags InFlags) : FRDGPass(MoveTemp(InName), InParameterStruct, InFlags, ERDGPassTaskMode::Async)"
  },
  {
    "label": "GetAsImmediate()",
    "kind": "Method",
    "detail": "Function (RHICmdList .)",
    "insertText": "GetAsImmediate().QueueAsyncCommandListSubmit(MoveTemp(CommandLists))"
  },
  {
    "label": "CreateCommandList()",
    "kind": "Method",
    "detail": "Function (} TArray<FRHICommandListImmediate::FQueuedCommandList,FRDGArrayAllocator> CommandLists ; UE::Tasks::FTaskEvent CommandListsEvent { UE_SOURCE_LOCATION } ; FRDGBuilder ; FRDGDispatchPassBuilder ; } ; class FRDGDispatchPassBuilder { public : FRHICommandList*)",
    "insertText": "CreateCommandList()"
  },
  {
    "label": "FRDGDispatchPassBuilder()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "FRDGDispatchPassBuilder(FRDGDispatchPass* InPass) : Pass(InPass) , StaticUniformBuffers(Pass->ParameterStruct.GetStaticUniformBuffers())"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (RenderPassInfo .)",
    "insertText": "Emplace(Pass->ParameterStruct.GetRenderPassInfo())"
  },
  {
    "label": "Finish()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Finish()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (FRDGDispatchPass* Pass ; FUniformBufferStaticBindings StaticUniformBuffers ; TOptional<FRHIRenderPassInfo> RenderPassInfo ; FRDGBuilder ; } ; template<ParameterStructType,LaunchLambdaType> class TRDGDispatchPass : public FRDGDispatchPass { int32 kMaximumLambdaCaptureSize = 1 0 2 4 ;)",
    "insertText": "static_assert(sizeof(LaunchLambdaType) <= kMaximumLambdaCaptureSize, \"The amount of data of captured for the pass looks abnormally high.\")"
  },
  {
    "label": "TRDGDispatchPass()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TRDGDispatchPass(FRDGEventName&& InName, const FShaderParametersMetadata* InParameterMetadata, const ParameterStructType* InParameterStruct, ERDGPassFlags InPassFlags, LaunchLambdaType&& InLaunchLambda) : FRDGDispatchPass(MoveTemp(InName), FRDGParameterStruct(InParameterStruct, InParameterMetadata), InPassFlags) , LaunchLambda(MoveTemp(InLaunchLambda)) #if RDG_ENABLE_DEBUG , DebugParameterStruct(InParameterStruct)"
  },
  {
    "label": "LaunchLambda()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LaunchLambda(DispatchPassBuilder)"
  },
  {
    "label": "TRDGEmptyLambdaPass()",
    "kind": "Method",
    "detail": "Function (} ; template<ExecuteLambdaType> class TRDGEmptyLambdaPass : public TRDGLambdaPass<FEmptyShaderParameters,ExecuteLambdaType> { public :)",
    "insertText": "TRDGEmptyLambdaPass(FRDGEventName&& InName, ERDGPassFlags InPassFlags, ExecuteLambdaType&& InExecuteLambda) : TRDGLambdaPass<FEmptyShaderParameters, ExecuteLambdaType>(MoveTemp(InName), FEmptyShaderParameters::FTypeInfo::GetStructMetadata(), &EmptyShaderParameters, InPassFlags, MoveTemp(InExecuteLambda))"
  },
  {
    "label": "FRDGSentinelPass()",
    "kind": "Method",
    "detail": "Function (} private : FEmptyShaderParameters EmptyShaderParameters ; class FRDGBuilder ; } ; template<ExecuteLambdaType> FEmptyShaderParameters TRDGEmptyLambdaPass<ExecuteLambdaType>::EmptyShaderParameters ; class FRDGSentinelPass final : public FRDGPass { public :)",
    "insertText": "FRDGSentinelPass(FRDGEventName&& Name, ERDGPassFlags InPassFlagsToAdd = ERDGPassFlags::None) : FRDGPass(MoveTemp(Name), FRDGParameterStruct(&EmptyShaderParameters, FEmptyShaderParameters::FTypeInfo::GetStructMetadata()), ERDGPassFlags::NeverCull | InPassFlagsToAdd, ERDGPassTaskMode::Async)"
  }
]