[
  {
    "label": "Pass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Pass"
  },
  {
    "label": "BasicBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BasicBlock"
  },
  {
    "label": "MachineFunction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineFunction"
  },
  {
    "label": "MCSymbol",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCSymbol"
  },
  {
    "label": "SlotIndexes",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SlotIndexes"
  },
  {
    "label": "StringRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StringRef"
  },
  {
    "label": "raw_ostream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "raw_ostream"
  },
  {
    "label": "MachineBranchProbabilityInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineBranchProbabilityInfo"
  },
  {
    "label": "ilist_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ilist_traits"
  },
  {
    "label": "MachineBasicBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineBasicBlock"
  },
  {
    "label": "bundle_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "bundle_iterator"
  },
  {
    "label": "OtherTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OtherTy"
  },
  {
    "label": "OtherIterTy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OtherIterTy"
  },
  {
    "label": "LivenessQueryResult",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "LivenessQueryResult"
  },
  {
    "label": "MBB2NumberFunctor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MBB2NumberFunctor"
  },
  {
    "label": "GraphTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GraphTraits"
  },
  {
    "label": "MachineInstrSpan",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineInstrSpan"
  },
  {
    "label": "createSentinel()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_CODEGEN_MACHINEBASICBLOCK_H # define LLVM_CODEGEN_MACHINEBASICBLOCK_H # include \" llvm / ADT / GraphTraits . h \" # include \" llvm / CodeGen / MachineInstr . h \" # include \" llvm / Support / DataTypes . h \" # include<functional> namespace llvm { class Pass ; class BasicBlock ; class MachineFunction ; class MCSymbol ; class SlotIndexes ; class StringRef ; class raw_ostream ; class MachineBranchProbabilityInfo ; template<> struct ilist_traits<MachineInstr> : public ilist_default_traits<MachineInstr> { private : ilist_half_node<MachineInstr> Sentinel ; class MachineBasicBlock ; MachineBasicBlock* Parent ; public : MachineInstr*)",
    "insertText": "createSentinel()"
  },
  {
    "label": "destroySentinel()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "destroySentinel(MachineInstr *)"
  },
  {
    "label": "provideInitialHead()",
    "kind": "Method",
    "detail": "Function (} MachineInstr*)",
    "insertText": "provideInitialHead()"
  },
  {
    "label": "ensureHead()",
    "kind": "Method",
    "detail": "Function (} MachineInstr*)",
    "insertText": "ensureHead(MachineInstr*)"
  },
  {
    "label": "noteHead()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "noteHead(MachineInstr*, MachineInstr*)"
  },
  {
    "label": "addNodeToList()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addNodeToList(MachineInstr* N)"
  },
  {
    "label": "removeNodeFromList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "removeNodeFromList(MachineInstr* N)"
  },
  {
    "label": "transferNodesFromList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transferNodesFromList(ilist_traits &SrcTraits, ilist_iterator<MachineInstr> first, ilist_iterator<MachineInstr> last)"
  },
  {
    "label": "deleteNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deleteNode(MachineInstr *N)"
  },
  {
    "label": "createNode()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "createNode(const MachineInstr &)"
  },
  {
    "label": "MachineBasicBlock()",
    "kind": "Method",
    "detail": "Function (} ; class MachineBasicBlock : public ilist_node<MachineBasicBlock> { typedef ilist<MachineInstr> Instructions ; Instructions Insts ; const BasicBlock* BB ; int Number ; MachineFunction* xParent ; std::vector<MachineBasicBlock*> Predecessors ; std::vector<MachineBasicBlock*> Successors ; std::vector<uint32_t> Weights ; typedef std::vector<uint32_t>::iterator weight_iterator ; typedef std::vector<uint32_t>::const_iterator const_weight_iterator ; std::vector<unsigned> LiveIns ; unsigned Alignment ; bool IsLandingPad ; bool AddressTaken ; MCSymbol* CachedMCSymbol ;)",
    "insertText": "MachineBasicBlock()"
  },
  {
    "label": "MachineBasicBlock()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MachineBasicBlock(MachineFunction &mf, const BasicBlock *bb)"
  },
  {
    "label": "getBasicBlock()",
    "kind": "Method",
    "detail": "Function (class MachineFunction ; public : const BasicBlock*)",
    "insertText": "getBasicBlock()"
  },
  {
    "label": "getFullName()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "getFullName()"
  },
  {
    "label": "hasAddressTaken()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasAddressTaken()"
  },
  {
    "label": "getParent()",
    "kind": "Method",
    "detail": "Function (AddressTaken = true ; } const MachineFunction*)",
    "insertText": "getParent()"
  },
  {
    "label": "bundle_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "bundle_iterator(Ty &mi) : MII(mi)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!mi.isBundledWithPred() && \"It's not legal to initialize bundle_iterator with a bundled MI\")"
  },
  {
    "label": "bundle_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "bundle_iterator(Ty *mi) : MII(mi)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((!mi || !mi->isBundledWithPred()) && \"It's not legal to initialize bundle_iterator with a bundled MI\")"
  },
  {
    "label": "bundle_iterator()",
    "kind": "Method",
    "detail": "Function (} template<class OtherTy,class OtherIterTy>)",
    "insertText": "bundle_iterator(const bundle_iterator<OtherTy, OtherIterTy> &I) : MII(I.getInstrIterator())"
  },
  {
    "label": "bundle_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "bundle_iterator() : MII(nullptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Ty&)",
    "insertText": "operator()"
  },
  {
    "label": "Ty()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "Ty()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + MII ; return* this ; } bundle_iterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "getInstrIterator()",
    "kind": "Method",
    "detail": "Function (bundle_iterator tmp =* this ; + +* this ; return tmp ; } IterTy)",
    "insertText": "getInstrIterator()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "instr_front()",
    "kind": "Method",
    "detail": "Function (} MachineInstr&)",
    "insertText": "instr_front()"
  },
  {
    "label": "instr_back()",
    "kind": "Method",
    "detail": "Function (} MachineInstr&)",
    "insertText": "instr_back()"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (} MachineInstr&)",
    "insertText": "front()"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} MachineInstr&)",
    "insertText": "back()"
  },
  {
    "label": "instr_begin()",
    "kind": "Method",
    "detail": "Function (} instr_iterator)",
    "insertText": "instr_begin()"
  },
  {
    "label": "instr_end()",
    "kind": "Method",
    "detail": "Function (} instr_iterator)",
    "insertText": "instr_end()"
  },
  {
    "label": "instr_rbegin()",
    "kind": "Method",
    "detail": "Function (} reverse_instr_iterator)",
    "insertText": "instr_rbegin()"
  },
  {
    "label": "instr_rend()",
    "kind": "Method",
    "detail": "Function (} reverse_instr_iterator)",
    "insertText": "instr_rend()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rbegin()"
  },
  {
    "label": "rend()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rend()"
  },
  {
    "label": "terminators()",
    "kind": "Method",
    "detail": "Function (} iterator_range<iterator>)",
    "insertText": "terminators()"
  },
  {
    "label": "pred_begin()",
    "kind": "Method",
    "detail": "Function (} typedef std::vector<MachineBasicBlock*>::iterator pred_iterator ; typedef std::vector<MachineBasicBlock*>::const_iterator const_pred_iterator ; typedef std::vector<MachineBasicBlock*>::iterator succ_iterator ; typedef std::vector<MachineBasicBlock*>::const_iterator const_succ_iterator ; typedef std::vector<MachineBasicBlock*>::reverse_iterator pred_reverse_iterator ; typedef std::vector<MachineBasicBlock*>::const_reverse_iterator const_pred_reverse_iterator ; typedef std::vector<MachineBasicBlock*>::reverse_iterator succ_reverse_iterator ; typedef std::vector<MachineBasicBlock*>::const_reverse_iterator const_succ_reverse_iterator ; pred_iterator)",
    "insertText": "pred_begin()"
  },
  {
    "label": "pred_end()",
    "kind": "Method",
    "detail": "Function (} pred_iterator)",
    "insertText": "pred_end()"
  },
  {
    "label": "pred_rbegin()",
    "kind": "Method",
    "detail": "Function (} pred_reverse_iterator)",
    "insertText": "pred_rbegin()"
  },
  {
    "label": "pred_rend()",
    "kind": "Method",
    "detail": "Function (} pred_reverse_iterator)",
    "insertText": "pred_rend()"
  },
  {
    "label": "pred_size()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "pred_size()"
  },
  {
    "label": "pred_empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "pred_empty()"
  },
  {
    "label": "succ_begin()",
    "kind": "Method",
    "detail": "Function (} succ_iterator)",
    "insertText": "succ_begin()"
  },
  {
    "label": "succ_end()",
    "kind": "Method",
    "detail": "Function (} succ_iterator)",
    "insertText": "succ_end()"
  },
  {
    "label": "succ_rbegin()",
    "kind": "Method",
    "detail": "Function (} succ_reverse_iterator)",
    "insertText": "succ_rbegin()"
  },
  {
    "label": "succ_rend()",
    "kind": "Method",
    "detail": "Function (} succ_reverse_iterator)",
    "insertText": "succ_rend()"
  },
  {
    "label": "succ_size()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "succ_size()"
  },
  {
    "label": "succ_empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "succ_empty()"
  },
  {
    "label": "predecessors()",
    "kind": "Method",
    "detail": "Function (} iterator_range<pred_iterator>)",
    "insertText": "predecessors()"
  },
  {
    "label": "successors()",
    "kind": "Method",
    "detail": "Function (} iterator_range<succ_iterator>)",
    "insertText": "successors()"
  },
  {
    "label": "addLiveIn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addLiveIn(unsigned Reg)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (LiveIns .)",
    "insertText": "push_back(Reg)"
  },
  {
    "label": "sortUniqueLiveIns()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "sortUniqueLiveIns()"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort(LiveIns.begin(), LiveIns.end())"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (LiveIns .)",
    "insertText": "erase(std::unique(LiveIns.begin(), LiveIns.end()), LiveIns.end())"
  },
  {
    "label": "addLiveIn()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "addLiveIn(unsigned PhysReg, const TargetRegisterClass *RC)"
  },
  {
    "label": "removeLiveIn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "removeLiveIn(unsigned Reg)"
  },
  {
    "label": "isLiveIn()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLiveIn(unsigned Reg)"
  },
  {
    "label": "livein_begin()",
    "kind": "Method",
    "detail": "Function (typedef std::vector<unsigned>::const_iterator livein_iterator ; livein_iterator)",
    "insertText": "livein_begin()"
  },
  {
    "label": "livein_end()",
    "kind": "Method",
    "detail": "Function (} livein_iterator)",
    "insertText": "livein_end()"
  },
  {
    "label": "livein_empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "livein_empty()"
  },
  {
    "label": "getAlignment()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getAlignment()"
  },
  {
    "label": "isLandingPad()",
    "kind": "Method",
    "detail": "Function (Alignment = Align ; } bool)",
    "insertText": "isLandingPad()"
  },
  {
    "label": "getLandingPadSuccessor()",
    "kind": "Method",
    "detail": "Function (IsLandingPad = V ; } const MachineBasicBlock*)",
    "insertText": "getLandingPadSuccessor()"
  },
  {
    "label": "moveBefore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "moveBefore(MachineBasicBlock *NewAfter)"
  },
  {
    "label": "moveAfter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "moveAfter(MachineBasicBlock *NewBefore)"
  },
  {
    "label": "updateTerminator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateTerminator()"
  },
  {
    "label": "addSuccessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addSuccessor(MachineBasicBlock *succ, uint32_t weight = 0)"
  },
  {
    "label": "setSuccWeight()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setSuccWeight(succ_iterator I, uint32_t weight)"
  },
  {
    "label": "removeSuccessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "removeSuccessor(MachineBasicBlock *succ)"
  },
  {
    "label": "removeSuccessor()",
    "kind": "Method",
    "detail": "Function (succ_iterator)",
    "insertText": "removeSuccessor(succ_iterator I)"
  },
  {
    "label": "replaceSuccessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replaceSuccessor(MachineBasicBlock *Old, MachineBasicBlock *New)"
  },
  {
    "label": "transferSuccessors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transferSuccessors(MachineBasicBlock *fromMBB)"
  },
  {
    "label": "transferSuccessorsAndUpdatePHIs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "transferSuccessorsAndUpdatePHIs(MachineBasicBlock *fromMBB)"
  },
  {
    "label": "isPredecessor()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isPredecessor(const MachineBasicBlock *MBB)"
  },
  {
    "label": "isSuccessor()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isSuccessor(const MachineBasicBlock *MBB)"
  },
  {
    "label": "isLayoutSuccessor()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLayoutSuccessor(const MachineBasicBlock *MBB)"
  },
  {
    "label": "canFallThrough()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "canFallThrough()"
  },
  {
    "label": "getFirstNonPHI()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "getFirstNonPHI()"
  },
  {
    "label": "SkipPHIsAndLabels()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "SkipPHIsAndLabels(iterator I)"
  },
  {
    "label": "getFirstTerminator()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "getFirstTerminator()"
  },
  {
    "label": "getFirstInstrTerminator()",
    "kind": "Method",
    "detail": "Function (} instr_iterator)",
    "insertText": "getFirstInstrTerminator()"
  },
  {
    "label": "getFirstNonDebugInstr()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "getFirstNonDebugInstr()"
  },
  {
    "label": "getLastNonDebugInstr()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "getLastNonDebugInstr()"
  },
  {
    "label": "SplitCriticalEdge()",
    "kind": "Method",
    "detail": "Function (} MachineBasicBlock*)",
    "insertText": "SplitCriticalEdge(MachineBasicBlock *Succ, Pass *P)"
  },
  {
    "label": "pop_front()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pop_front()"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "pop_back()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_back(MachineInstr *MI)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Insts .)",
    "insertText": "push_back(MI)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} instr_iterator)",
    "insertText": "insert(instr_iterator I, MachineInstr *M)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (template<IT> void)",
    "insertText": "insert(iterator I, IT S, IT E)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((I == end() || I->getParent() == this) && \"iterator points outside of basic block\")"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (Insts .)",
    "insertText": "insert(I.getInstrIterator(), S, E)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insert(iterator I, MachineInstr *MI)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!MI->isBundledWithPred() && !MI->isBundledWithSucc() && \"Cannot insert instruction with bundle flags\")"
  },
  {
    "label": "insertAfter()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "insertAfter(iterator I, MachineInstr *MI)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} instr_iterator)",
    "insertText": "erase(instr_iterator I)"
  },
  {
    "label": "erase_instr()",
    "kind": "Method",
    "detail": "Function (instr_iterator)",
    "insertText": "erase_instr(MachineInstr *I)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "erase(iterator I, iterator E)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "erase(iterator I)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "erase(MachineInstr *I)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (} MachineInstr*)",
    "insertText": "remove(MachineInstr *I)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!I->isBundled() && \"Cannot remove bundled instructions\")"
  },
  {
    "label": "remove_instr()",
    "kind": "Method",
    "detail": "Function (} MachineInstr*)",
    "insertText": "remove_instr(MachineInstr *I)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "splice()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "splice(iterator Where, MachineBasicBlock *Other, iterator From)"
  },
  {
    "label": "splice()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "splice(iterator Where, MachineBasicBlock *Other, iterator From, iterator To)"
  },
  {
    "label": "splice()",
    "kind": "Method",
    "detail": "Function (Insts .)",
    "insertText": "splice(Where.getInstrIterator(), Other->Insts, From.getInstrIterator(), To.getInstrIterator())"
  },
  {
    "label": "removeFromParent()",
    "kind": "Method",
    "detail": "Function (} MachineBasicBlock*)",
    "insertText": "removeFromParent()"
  },
  {
    "label": "eraseFromParent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eraseFromParent()"
  },
  {
    "label": "ReplaceUsesOfBlockWith()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReplaceUsesOfBlockWith(MachineBasicBlock *Old, MachineBasicBlock *New)"
  },
  {
    "label": "CorrectExtraCFGEdges()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CorrectExtraCFGEdges(MachineBasicBlock *DestA, MachineBasicBlock *DestB, bool isCond)"
  },
  {
    "label": "findDebugLoc()",
    "kind": "Method",
    "detail": "Function (DebugLoc)",
    "insertText": "findDebugLoc(instr_iterator MBBI)"
  },
  {
    "label": "findDebugLoc()",
    "kind": "Method",
    "detail": "Function (DebugLoc)",
    "insertText": "findDebugLoc(iterator MBBI)"
  },
  {
    "label": "computeRegisterLiveness()",
    "kind": "Method",
    "detail": "Function (} enum LivenessQueryResult { LQR_Live,LQR_OverlappingLive,LQR_Dead,LQR_Unknown } ; LivenessQueryResult)",
    "insertText": "computeRegisterLiveness(const TargetRegisterInfo *TRI, unsigned Reg, const_iterator Before, unsigned Neighborhood=10)"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dump()"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS, SlotIndexes* = nullptr)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS, ModuleSlotTracker &MST, SlotIndexes * = nullptr)"
  },
  {
    "label": "printAsOperand()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printAsOperand(raw_ostream &OS, bool PrintType = true)"
  },
  {
    "label": "getNumber()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "getNumber()"
  },
  {
    "label": "getSymbol()",
    "kind": "Method",
    "detail": "Function (Number = N ; } MCSymbol*)",
    "insertText": "getSymbol()"
  },
  {
    "label": "getWeightIterator()",
    "kind": "Method",
    "detail": "Function (private : weight_iterator)",
    "insertText": "getWeightIterator(succ_iterator I)"
  },
  {
    "label": "getWeightIterator()",
    "kind": "Method",
    "detail": "Function (const_weight_iterator)",
    "insertText": "getWeightIterator(const_succ_iterator I)"
  },
  {
    "label": "getSuccWeight()",
    "kind": "Method",
    "detail": "Function (class MachineBranchProbabilityInfo ; uint32_t)",
    "insertText": "getSuccWeight(const_succ_iterator Succ)"
  },
  {
    "label": "addPredecessor()",
    "kind": "Method",
    "detail": "Function (struct ilist_traits<MachineBasicBlock> ; void)",
    "insertText": "addPredecessor(MachineBasicBlock *pred)"
  },
  {
    "label": "removePredecessor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "removePredecessor(MachineBasicBlock *pred)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; raw_ostream&)",
    "insertText": "operator(raw_ostream &OS, const MachineBasicBlock &MBB)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (struct MBB2NumberFunctor { unsigned)",
    "insertText": "operator()(const MachineBasicBlock *MBB)"
  },
  {
    "label": "getEntryNode()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct GraphTraits<MachineBasicBlock*> { typedef MachineBasicBlock NodeType ; typedef MachineBasicBlock::succ_iterator ChildIteratorType ; NodeType*)",
    "insertText": "getEntryNode(MachineBasicBlock *BB)"
  },
  {
    "label": "child_end()",
    "kind": "Method",
    "detail": "Function (} ChildIteratorType)",
    "insertText": "child_end(NodeType *N)"
  },
  {
    "label": "getEntryNode()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct GraphTraits<const MachineBasicBlock*> { typedef const MachineBasicBlock NodeType ; typedef MachineBasicBlock::const_succ_iterator ChildIteratorType ; NodeType*)",
    "insertText": "getEntryNode(const MachineBasicBlock *BB)"
  },
  {
    "label": "getEntryNode()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct GraphTraits<Inverse<MachineBasicBlock*>> { typedef MachineBasicBlock NodeType ; typedef MachineBasicBlock::pred_iterator ChildIteratorType ; NodeType*)",
    "insertText": "getEntryNode(Inverse<MachineBasicBlock *> G)"
  },
  {
    "label": "getEntryNode()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct GraphTraits<Inverse<const MachineBasicBlock*>> { typedef const MachineBasicBlock NodeType ; typedef MachineBasicBlock::const_pred_iterator ChildIteratorType ; NodeType*)",
    "insertText": "getEntryNode(Inverse<const MachineBasicBlock*> G)"
  },
  {
    "label": "MachineInstrSpan()",
    "kind": "Method",
    "detail": "Function (} } ; class MachineInstrSpan { MachineBasicBlock& MBB ; MachineBasicBlock::iterator I,B,E ; public :)",
    "insertText": "MachineInstrSpan(MachineBasicBlock::iterator I) : MBB(*I->getParent()), I(I), B(I == MBB.begin() ? MBB.end() : std::prev(I)), E(std::next(I))"
  },
  {
    "label": "getInitial()",
    "kind": "Method",
    "detail": "Function (} MachineBasicBlock::iterator)",
    "insertText": "getInitial()"
  }
]