[
  {
    "label": "OBJECT_ARRAY",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OBJECT_ARRAY"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "CParticleView",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CParticleView"
  },
  {
    "label": "ComputeBoundsThickness()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Array . h \" # include \" Chaos / Box . h \" # include \" Chaos / Defines . h \" # include \" Chaos / Framework / Parallel . h \" # include \" Chaos / GeometryParticles . h \" # include \" Chaos / ParticleHandle . h \" # include \" Chaos / PBDRigidParticles . h \" # include \" Chaos / Particles . h \" # include \" Chaos / Sphere . h \" # include \" Chaos / Transform . h \" # define MIN_NUM_OBJECTS 5 namespace Chaos { float Chaos_Bounds_MaxInflationScale ; FVec3)",
    "insertText": "ComputeBoundsThickness(FVec3 Vel, FReal Dt, FReal MinBoundsThickness, FReal MaxBoundsThickness, FReal BoundsVelocityInflation)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const FReal BoundsThickness =)",
    "insertText": "Abs(Vel[i])"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (Vel [ i ] =)",
    "insertText": "Clamp(BoundsThickness, MinBoundsThickness, MaxBoundsThickness)"
  },
  {
    "label": "ComputeBoundsThickness()",
    "kind": "Method",
    "detail": "Function (} return Vel ; } FVec3)",
    "insertText": "ComputeBoundsThickness(const TPBDRigidParticles<FReal, 3>& InParticles, FReal Dt, int32 BodyIndex, FReal MinBoundsThickness, FReal BoundsVelocityInflation)"
  },
  {
    "label": "HasBounds()",
    "kind": "Method",
    "detail": "Function (const bool bIsBounded = InParticles .)",
    "insertText": "HasBounds(BodyIndex)"
  },
  {
    "label": "ControlFlags()",
    "kind": "Method",
    "detail": "Function (const bool bIsCCD = InParticles .)",
    "insertText": "ControlFlags(BodyIndex).GetCCDEnabled()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (} FReal MaxBoundsThickness = TNumericLimits<FReal)",
    "insertText": "Max()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (BoundsVelocityInflation =)",
    "insertText": "Max(FReal(1), BoundsVelocityInflation)"
  },
  {
    "label": "LocalBounds()",
    "kind": "Method",
    "detail": "Function (} else { MaxBoundsThickness = Chaos_Bounds_MaxInflationScale* InParticles .)",
    "insertText": "LocalBounds(BodyIndex).Extents().GetMax()"
  },
  {
    "label": "ComputeBoundsThickness()",
    "kind": "Method",
    "detail": "Function (} } return)",
    "insertText": "ComputeBoundsThickness(InParticles.GetV(BodyIndex), Dt, MinBoundsThickness, MaxBoundsThickness, BoundsVelocityInflation)"
  },
  {
    "label": "ComputeBoundsThickness()",
    "kind": "Method",
    "detail": "Function (} template<THandle> FVec3)",
    "insertText": "ComputeBoundsThickness(const THandle& ParticleHandle, FReal Dt, FReal MinBoundsThickness, FReal BoundsVelocityInflation)"
  },
  {
    "label": "CastToRigidParticle()",
    "kind": "Method",
    "detail": "Function (const THandle::FDynamicParticleHandleType* RigidParticle = ParticleHandle .)",
    "insertText": "CastToRigidParticle()"
  },
  {
    "label": "CastToKinematicParticle()",
    "kind": "Method",
    "detail": "Function (const THandle::FKinematicParticleHandleType* KinematicParticle = ParticleHandle .)",
    "insertText": "CastToKinematicParticle()"
  },
  {
    "label": "HasBounds()",
    "kind": "Method",
    "detail": "Function (const bool bIsBounded = ParticleHandle .)",
    "insertText": "HasBounds()"
  },
  {
    "label": "bIsCCD()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bIsCCD(RigidParticle != nullptr) && RigidParticle->CCDEnabled()"
  },
  {
    "label": "LocalBounds()",
    "kind": "Method",
    "detail": "Function (} else { MaxBoundsThickness = Chaos_Bounds_MaxInflationScale* ParticleHandle .)",
    "insertText": "LocalBounds().Extents().GetMax()"
  },
  {
    "label": "Vel()",
    "kind": "Method",
    "detail": "Function (} } FVec3)",
    "insertText": "Vel(0)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (Vel = KinematicParticle ->)",
    "insertText": "V()"
  },
  {
    "label": "ComputeBoundsThickness()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "ComputeBoundsThickness(Vel, Dt, MinBoundsThickness, MaxBoundsThickness, BoundsVelocityInflation)"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<class OBJECT_ARRAY> bool)",
    "insertText": "HasBoundingBox(const OBJECT_ARRAY& Objects, const int32 i)"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> bool)",
    "insertText": "HasBoundingBox(const TParticles<T, d>& Objects, const int32 i)"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> bool)",
    "insertText": "HasBoundingBox(const TPBDRigidParticles<T, d>& Objects, const int32 i)"
  },
  {
    "label": "CollisionParticles()",
    "kind": "Method",
    "detail": "Function (} return Objects .)",
    "insertText": "CollisionParticles(i) != nullptr && Objects.CollisionParticles(i)->Size()"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<Generic> bool)",
    "insertText": "HasBoundingBox(const Generic& Item)"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<T,int d,bool bPersistent> bool)",
    "insertText": "HasBoundingBox(const TGeometryParticleHandleImp<T, d, bPersistent>& Handle)"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<T,int d,bool bPersistent> bool)",
    "insertText": "HasBoundingBox(const TPBDRigidParticleHandleImp<T, d, bPersistent>& Handle)"
  },
  {
    "label": "GetWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<class OBJECT_ARRAY,class T,int d> const TAABB<T,d>)",
    "insertText": "GetWorldSpaceBoundingBox(const OBJECT_ARRAY& Objects, const int32 i, const TMap<int32, TAABB<T, d>>& WorldSpaceBoxes)"
  },
  {
    "label": "GetWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> const TAABB<T,d>&)",
    "insertText": "GetWorldSpaceBoundingBox(const TParticles<T, d>& Objects, const int32 i, const TMap<int32, TAABB<T, d>>& WorldSpaceBoxes)"
  },
  {
    "label": "GetWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> const TAABB<T,d>)",
    "insertText": "GetWorldSpaceBoundingBox(const TPBDRigidParticles<T, d>& Objects, const int32 i, const TMap<int32, TAABB<T, d>>& WorldSpaceBoxes)"
  },
  {
    "label": "ComputeWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> TAABB<T,d>)",
    "insertText": "ComputeWorldSpaceBoundingBox(const TParticles<T, d>& Objects, const int32 i, bool bUseVelocity = false, T Dt = 0)"
  },
  {
    "label": "ComputeWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> TAABB<T,d>)",
    "insertText": "ComputeWorldSpaceBoundingBox(const TGeometryParticles<T, d>& Objects, const int32 i, bool bUseVelocity = false, T Dt = 0)"
  },
  {
    "label": "LocalToWorld()",
    "kind": "Method",
    "detail": "Function (TRigidTransform<T,d>)",
    "insertText": "LocalToWorld(Objects.GetX(i), Objects.GetR(i))"
  },
  {
    "label": "GetGeometry()",
    "kind": "Method",
    "detail": "Function (const auto& LocalBoundingBox = Objects .)",
    "insertText": "GetGeometry(i)->BoundingBox()"
  },
  {
    "label": "ComputeWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> TAABB<T,d>)",
    "insertText": "ComputeWorldSpaceBoundingBox(const TPBDRigidParticles<T, d>& Objects, const int32 i, bool bUseVelocity = false, T Dt = 0)"
  },
  {
    "label": "LocalToWorld()",
    "kind": "Method",
    "detail": "Function (TRigidTransform<T,d>)",
    "insertText": "LocalToWorld(Objects.GetP(i), Objects.GetQ(i))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TAABB<T,d> WorldSpaceBox ;)",
    "insertText": "if(Objects.GetGeometry(i))"
  },
  {
    "label": "TransformedAABB()",
    "kind": "Method",
    "detail": "Function (WorldSpaceBox = LocalBoundingBox .)",
    "insertText": "TransformedAABB(LocalToWorld)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "check(Objects.CollisionParticles(i) && Objects.CollisionParticles(i)->Size())"
  },
  {
    "label": "LocalBoundingBox()",
    "kind": "Method",
    "detail": "Function (TAABB<T,d>)",
    "insertText": "LocalBoundingBox(Objects.CollisionParticles(i)->GetX(0), Objects.CollisionParticles(i)->GetX(0))"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (LocalBoundingBox .)",
    "insertText": "GrowToInclude(Objects.CollisionParticles(i)->GetX(j))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bUseVelocity)"
  },
  {
    "label": "ThickenSymmetrically()",
    "kind": "Method",
    "detail": "Function (WorldSpaceBox .)",
    "insertText": "ThickenSymmetrically(ComputeBoundsThickness(Objects, Dt, i, 0, 1))"
  },
  {
    "label": "ComputeWorldSpaceBoundingBoxForHandle()",
    "kind": "Method",
    "detail": "Function (} return WorldSpaceBox ; } template<THandle,T,int d,bool bPersistent> TAABB<T,d>)",
    "insertText": "ComputeWorldSpaceBoundingBoxForHandle(const THandle& Handle)"
  },
  {
    "label": "ObjectState()",
    "kind": "Method",
    "detail": "Function (const bool bIsRigidDynamic = PBDRigid&& PBDRigid ->)",
    "insertText": "ObjectState()"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (TRigidTransform<T,d> LocalToWorld = bIsRigidDynamic ? TRigidTransform<T,)",
    "insertText": "d(PBDRigid->P(), PBDRigid->Q()) : TRigidTransform<T, d>(Handle.X(), Handle.R())"
  },
  {
    "label": "Geometry()",
    "kind": "Method",
    "detail": "Function (const auto& LocalBoundingBox = Handle .)",
    "insertText": "Geometry()->BoundingBox()"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(PBDRigid)"
  },
  {
    "label": "LocalBoundingBox()",
    "kind": "Method",
    "detail": "Function (TAABB<T,d>)",
    "insertText": "LocalBoundingBox(PBDRigid->CollisionParticles()->X(0), PBDRigid->CollisionParticles()->X(0))"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (LocalBoundingBox .)",
    "insertText": "GrowToInclude(PBDRigid->CollisionParticles()->X(j))"
  },
  {
    "label": "TransformedBox()",
    "kind": "Method",
    "detail": "Function (} return LocalBoundingBox .)",
    "insertText": "TransformedBox(LocalToWorld)"
  },
  {
    "label": "ComputeWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<T,int d,bool bPersistent> TAABB<T,d>)",
    "insertText": "ComputeWorldSpaceBoundingBox(const TGeometryParticleHandleImp<T, d, bPersistent>& Handle, bool bUseVelocity = false, T Dt = 0)"
  },
  {
    "label": "ComputeWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<T,int d,bool bPersistent> TAABB<T,d>)",
    "insertText": "ComputeWorldSpaceBoundingBox(const TPBDRigidParticleHandleImp<T, d, bPersistent>& Handle, bool bUseVelocity = false, T Dt = 0)"
  },
  {
    "label": "ComputeWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<T,GenericEntry> TAABB<T,3>)",
    "insertText": "ComputeWorldSpaceBoundingBox(const GenericEntry& InEntry, bool bUseVelocity = false, T Dt = 0)"
  },
  {
    "label": "ComputeGlobalBoxAndSplitAxis()",
    "kind": "Method",
    "detail": "Function (} template<OBJECT_ARRAY,T,int d> const TAABB<T,d>)",
    "insertText": "ComputeGlobalBoxAndSplitAxis(const OBJECT_ARRAY& Objects, const TArray<int32>& AllObjects, const TMap<int32, TAABB<T, d>>& WorldSpaceBoxes, bool bAllowMultipleSplitting, int32& OutAxis)"
  },
  {
    "label": "GetWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (TAABB<T,d> GlobalBox =)",
    "insertText": "GetWorldSpaceBoundingBox(Objects, AllObjects[0], WorldSpaceBoxes)"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (GlobalBox .)",
    "insertText": "GrowToInclude(GetWorldSpaceBoundingBox(Objects, AllObjects[i], WorldSpaceBoxes))"
  },
  {
    "label": "Extents()",
    "kind": "Method",
    "detail": "Function (} int32 Axis = 0 ; TVector<T,d> GlobalExtents = GlobalBox .)",
    "insertText": "Extents()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Axis = 2 ; } else)",
    "insertText": "if(GlobalExtents[1] > GlobalExtents[0])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Axis = 1 ; })",
    "insertText": "if(bAllowMultipleSplitting && GlobalExtents[Axis] < GlobalExtents[(Axis + 1) % 3] * 1.25 && GlobalExtents[Axis] < GlobalExtents[(Axis + 2) % 3] * 1.25 && AllObjects.Num() > 4 * MIN_NUM_OBJECTS)"
  },
  {
    "label": "ComputeGlobalBoxAndSplitAxis()",
    "kind": "Method",
    "detail": "Function (Axis = - 1 ; } OutAxis = Axis ; return GlobalBox ; } template<T,int d> const TAABB<T,d>)",
    "insertText": "ComputeGlobalBoxAndSplitAxis(const TParticles<T,d>& Objects, const TArray<int32>& AllObjects, const TMap<int32, TAABB<T, d>>& WorldSpaceBoxes, bool bAllowMultipleSplitting, int32& OutAxis)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TPair<int32,int32> Counts [ d ] ;)",
    "insertText": "for(int32 i = 0; i < d; ++i)"
  },
  {
    "label": "CountLambda()",
    "kind": "Method",
    "detail": "Function (Counts [ i ] . Key = 0 ; Counts [ i ] . Value = 0 ; } ; auto)",
    "insertText": "CountLambda(const TVector<T, d>& Point)"
  },
  {
    "label": "CountLambda()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CountLambda(GlobalBox.Center())"
  },
  {
    "label": "GetWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (TAABB<T,d> PtBox =)",
    "insertText": "GetWorldSpaceBoundingBox(Objects, AllObjects[i], WorldSpaceBoxes)"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (GlobalBox .)",
    "insertText": "GrowToInclude(PtBox)"
  },
  {
    "label": "CountLambda()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CountLambda(PtBox.Center())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} int32 BestAxis = 0 ; int32 MaxCulled = 0 ;)",
    "insertText": "for(int32 Axis = 0; Axis < d; ++Axis)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (int32 CulledWorstCase =)",
    "insertText": "Min(Counts[Axis].Key, Counts[Axis].Value)"
  },
  {
    "label": "ComputeAllWorldSpaceBoundingBoxes()",
    "kind": "Method",
    "detail": "Function (MaxCulled = CulledWorstCase ; BestAxis = Axis ; } } OutAxis = BestAxis ; return GlobalBox ; } template<class OBJECT_ARRAY,class T,int d> void)",
    "insertText": "ComputeAllWorldSpaceBoundingBoxes(const OBJECT_ARRAY& Objects, const TArray<int32>& AllObjects, const bool bUseVelocity, const T Dt, TMap<int32, TAABB<T, d>>& WorldSpaceBoxes)"
  },
  {
    "label": "ComputeAllWorldSpaceBoundingBoxes()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> void)",
    "insertText": "ComputeAllWorldSpaceBoundingBoxes(const TParticles<T, d>& Objects, const TArray<int32>& AllObjects, const bool bUseVelocity, const T Dt, TMap<int32, TAABB<T, d>>& WorldSpaceBoxes)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (WorldSpaceBoxes .)",
    "insertText": "Reserve(AllObjects.Num())"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (WorldSpaceBoxes .)",
    "insertText": "FindOrAdd(i) = ComputeWorldSpaceBoundingBox(Objects, i)"
  },
  {
    "label": "ComputeAllWorldSpaceBoundingBoxes()",
    "kind": "Method",
    "detail": "Function (} } template<class T,int d> void)",
    "insertText": "ComputeAllWorldSpaceBoundingBoxes(const TGeometryParticles<T, d>& Objects, const TArray<int32>& AllObjects, const bool bUseVelocity, const T Dt, TMap<int32, TAABB<T, d>>& WorldSpaceBoxes)"
  },
  {
    "label": "ComputeAllWorldSpaceBoundingBoxes()",
    "kind": "Method",
    "detail": "Function (} } template<class T,int d> void)",
    "insertText": "ComputeAllWorldSpaceBoundingBoxes(const TPBDRigidParticles<T, d>& Objects, const TArray<int32>& AllObjects, const bool bUseVelocity, const T Dt, TMap<int32, TAABB<T, d>>& WorldSpaceBoxes)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (const int32 BodyIndex = AllObjects [ i ] ; TAABB<T,d>& WorldSpaceBox = WorldSpaceBoxes .)",
    "insertText": "FindOrAdd(BodyIndex)"
  },
  {
    "label": "ComputeWorldSpaceBoundingBox()",
    "kind": "Method",
    "detail": "Function (WorldSpaceBox =)",
    "insertText": "ComputeWorldSpaceBoundingBox(Objects, BodyIndex, bUseVelocity, Dt)"
  },
  {
    "label": "Requires()",
    "kind": "Method",
    "detail": "Function (} } struct CParticleView { template<T> auto)",
    "insertText": "Requires() -> decltype(T::THandleType)"
  },
  {
    "label": "ComputeAllWorldSpaceBoundingBoxes()",
    "kind": "Method",
    "detail": "Function (} ; template<ParticleView,T,int d> TEnableIf<TModels_V<CParticleView,ParticleView>>::Type)",
    "insertText": "ComputeAllWorldSpaceBoundingBoxes(const ParticleView& Particles, const TArray<bool>& RequiresBounds, const bool bUseVelocity, const T Dt, TArray<TAABB<T, d>>& WorldSpaceBoxes)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (WorldSpaceBoxes .)",
    "insertText": "AddUninitialized(Particles.Num())"
  },
  {
    "label": "ParticlesParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParticlesParallelFor(Particles, [&RequiresBounds, &WorldSpaceBoxes, bUseVelocity, Dt](const auto& Particle, int32 Index) { if (RequiresBounds[Index]) { WorldSpaceBoxes[Index] = ComputeWorldSpaceBoundingBox(Particle); if (bUseVelocity) { if (const auto PBDRigid = Particle.AsDynamic()) { WorldSpaceBoxes.Last().ThickenSymmetrically(ComputeBoundsThickness(*PBDRigid, Dt, 0, 1)); } } } })"
  },
  {
    "label": "ParticlesParallelFor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ParticlesParallelFor(Particles, [&RequiresBounds, &WorldSpaceBoxes, bUseVelocity, Dt](const auto& Particle, int32 Index) { if(RequiresBounds[Index]) { WorldSpaceBoxes[Index] = ComputeWorldSpaceBoundingBox(Particle); } })"
  },
  {
    "label": "GetObjectCount()",
    "kind": "Method",
    "detail": "Function (} template<class OBJECT_ARRAY> int32)",
    "insertText": "GetObjectCount(const OBJECT_ARRAY& Objects)"
  },
  {
    "label": "GetObjectCount()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> int32)",
    "insertText": "GetObjectCount(const TParticles<T, d>& Objects)"
  },
  {
    "label": "GetObjectCount()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> int32)",
    "insertText": "GetObjectCount(const TGeometryParticles<T, d>& Objects)"
  },
  {
    "label": "GetObjectCount()",
    "kind": "Method",
    "detail": "Function (} template<class T,int d> int32)",
    "insertText": "GetObjectCount(const TPBDRigidParticles<T, d>& Objects)"
  },
  {
    "label": "IsDisabled()",
    "kind": "Method",
    "detail": "Function (} template<class OBJECT_ARRAY> bool)",
    "insertText": "IsDisabled(const OBJECT_ARRAY& Objects, const uint32 Index)"
  }
]