[
  {
    "label": "PassNameParser",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PassNameParser"
  },
  {
    "label": "FilteredPassNameParser",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FilteredPassNameParser"
  },
  {
    "label": "PassArgFilter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PassArgFilter"
  },
  {
    "label": "PassNameParser()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_IR_LEGACYPASSNAMEPARSER_H # define LLVM_IR_LEGACYPASSNAMEPARSER_H # include \" llvm / ADT / STLExtras . h \" # include \" llvm / Pass . h \" # include \" llvm / Support / CommandLine . h \" # include \" llvm / Support / ErrorHandling . h \" # include \" llvm / Support / raw_ostream . h \" # include<cstring> namespace llvm { class PassNameParser : public PassRegistrationListener,public cl::parser<const PassInfo*> { public :)",
    "insertText": "PassNameParser(cl::Option &O)"
  },
  {
    "label": "PassNameParser()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "PassNameParser()"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initialize()"
  },
  {
    "label": "enumeratePasses()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "enumeratePasses()"
  },
  {
    "label": "ignorablePassImpl()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ignorablePassImpl(const PassInfo *P)"
  },
  {
    "label": "passRegistered()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "passRegistered(const PassInfo *P)"
  },
  {
    "label": "errs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "errs() << \"Two passes with the same argument (-\" << P->getPassArgument() << \")"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(nullptr)"
  },
  {
    "label": "addLiteralOption()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "addLiteralOption(P->getPassArgument(), P, P->getPassName().data())"
  },
  {
    "label": "passEnumerate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "passEnumerate(const PassInfo *P)"
  },
  {
    "label": "passRegistered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "passRegistered(P)"
  },
  {
    "label": "printOptionInfo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "printOptionInfo(const cl::Option &O, size_t GlobalWidth)"
  },
  {
    "label": "PassNameParser()",
    "kind": "Method",
    "detail": "Function (PassNameParser* PNP = const_cast<)",
    "insertText": "PassNameParser(this)"
  },
  {
    "label": "array_pod_sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "array_pod_sort(PNP->Values.begin(), PNP->Values.end(), ValLessThan)"
  },
  {
    "label": "printOptionInfo()",
    "kind": "Method",
    "detail": "Function (cl::parser<const PassInfo*)",
    "insertText": "printOptionInfo(O, GlobalWidth)"
  },
  {
    "label": "ValLessThan()",
    "kind": "Method",
    "detail": "Function (} private : int __cdecl)",
    "insertText": "ValLessThan(const PassNameParser::OptionInfo *VT1, const PassNameParser::OptionInfo *VT2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<const char* Args> class PassArgFilter { public : bool)",
    "insertText": "operator()(const PassInfo &P)"
  }
]