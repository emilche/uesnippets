[
  {
    "label": "heap_relax_snode()",
    "kind": "Method",
    "detail": "Function (# ifndef SPARSELU_HEAP_RELAX_SNODE_H # define SPARSELU_HEAP_RELAX_SNODE_H namespace Eigen { namespace internal { template<Scalar,StorageIndex> void SparseLUImpl<Scalar,StorageIndex)",
    "insertText": "heap_relax_snode(const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)"
  },
  {
    "label": "treePostorder()",
    "kind": "Method",
    "detail": "Function (IndexVector post ;)",
    "insertText": "treePostorder(StorageIndex(n), et, post)"
  },
  {
    "label": "inv_post()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "inv_post(n+1)"
  },
  {
    "label": "iwork()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "iwork(n)"
  },
  {
    "label": "et_save()",
    "kind": "Method",
    "detail": "Function (IndexVector)",
    "insertText": "et_save(n+1)"
  },
  {
    "label": "iwork()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iwork(post(i)) = post(et(i))"
  },
  {
    "label": "setConstant()",
    "kind": "Method",
    "detail": "Function (} et_save = et ; et = iwork ; relax_end .)",
    "insertText": "setConstant(emptyIdxLU)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (Index j,parent ; descendants .)",
    "insertText": "setZero()"
  },
  {
    "label": "et()",
    "kind": "Method",
    "detail": "Function (parent =)",
    "insertText": "et(j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} Index snode_start ; StorageIndex k ; Index nsuper_et_post = 0 ; Index nsuper_et = 0 ; StorageIndex l ;)",
    "insertText": "for(j = 0; j < n;)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (snode_start = j ;)",
    "insertText": "while(parent != n && descendants(parent) < relax_columns)"
  },
  {
    "label": "StorageIndex()",
    "kind": "Method",
    "detail": "Function (} + + nsuper_et_post ; k =)",
    "insertText": "StorageIndex(n)"
  },
  {
    "label": "inv_post()",
    "kind": "Method",
    "detail": "Function (l =)",
    "insertText": "inv_post(j)"
  },
  {
    "label": "relax_end()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "relax_end(k)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (+ + nsuper_et ; } else {)",
    "insertText": "for(Index i = snode_start; i <= j; ++i)"
  },
  {
    "label": "inv_post()",
    "kind": "Method",
    "detail": "Function (l =)",
    "insertText": "inv_post(i)"
  },
  {
    "label": "relax_end()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "relax_end(l)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + nsuper_et ; } } } j + + ;)",
    "insertText": "while(descendants(j) != 0 && j < n)"
  }
]