[
  {
    "label": "Enum",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Enum"
  },
  {
    "label": "ModulePacket",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ModulePacket"
  },
  {
    "label": "Allocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Allocator"
  },
  {
    "label": "ContextSwitch",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ContextSwitch"
  },
  {
    "label": "DynamicString",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DynamicString"
  },
  {
    "label": "Array",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Array"
  },
  {
    "label": "RelaxedAtomic",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RelaxedAtomic"
  },
  {
    "label": "CustomStatTimer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CustomStatTimer"
  },
  {
    "label": "TimerScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TimerScope"
  },
  {
    "label": "TimerScopeW",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TimerScopeW"
  },
  {
    "label": "ConditionalParentTimerScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConditionalParentTimerScope"
  },
  {
    "label": "IdTimerScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IdTimerScope"
  },
  {
    "label": "StringLiteralNamedTimerScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StringLiteralNamedTimerScope"
  },
  {
    "label": "ConditionalTimerScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConditionalTimerScope"
  },
  {
    "label": "ConditionalTimerScopeId",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConditionalTimerScopeId"
  },
  {
    "label": "ConditionalTimerScopeW",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConditionalTimerScopeW"
  },
  {
    "label": "ConditionalBoolTimerScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConditionalBoolTimerScope"
  },
  {
    "label": "ConditionalBoolTimerScopeId",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConditionalBoolTimerScopeId"
  },
  {
    "label": "ConditionalBoolTimerScopeW",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConditionalBoolTimerScopeW"
  },
  {
    "label": "StringLiteralNamedConditionalTimerScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StringLiteralNamedConditionalTimerScope"
  },
  {
    "label": "CustomStatTimerScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CustomStatTimerScope"
  },
  {
    "label": "HiResTimerScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HiResTimerScope"
  },
  {
    "label": "ThreadScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadScope"
  },
  {
    "label": "WaitEventScope",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "WaitEventScope"
  },
  {
    "label": "FRAMEPRO_FRAME_START()",
    "kind": "Method",
    "detail": "Function (# ifndef FRAMEPRO_H_INCLUDED # define FRAMEPRO_H_INCLUDED # ifndef FRAMEPRO_ENABLED # ifdef __UNREAL__ # define FRAMEPRO_ENABLED 0 # else # define FRAMEPRO_ENABLED 1 # endif # endif # if FRAMEPRO_ENABLED # define)",
    "insertText": "FRAMEPRO_FRAME_START() FramePro::FrameStart() #define FRAMEPRO_SHUTDOWN() FramePro::Shutdown() #define FRAMEPRO_SET_PORT(port) FramePro::SetPort(port) #define FRAMEPRO_SESSION_INFO(name, value) FramePro::SendSessionInfo(name, value) #define FRAMEPRO_SET_ALLOCATOR(p_allocator) FramePro::SetAllocator(p_allocator) #define FRAMEPRO_SET_THREAD_NAME(name) FramePro::SetThreadName(name) #define FRAMEPRO_SET_THREAD_ID_NAME(thread_id, name) FramePro::SetThreadName(thread_id, name) #define FRAMEPRO_THREAD_ORDER(thread_name) FramePro::SetThreadOrder(FramePro::RegisterString(thread_name)) #define FRAMEPRO_REGISTER_STRING(str) FramePro::RegisterString(str) #define FRAMEPRO_START_RECORDING(filename, context_switches, callstacks, max_file_size) FramePro::StartRecording(filename, context_switches, callstacks, max_file_size) #define FRAMEPRO_STOP_RECORDING() FramePro::StopRecording() #define FRAMEPRO_REGISTER_CONNECTION_CHANGED_CALLBACK(callback, context) FramePro::RegisterConnectionChangedCallback(callback, context) #define FRAMEPRO_UNREGISTER_CONNECTION_CHANGED_CALLBACK(callback) FramePro::UnregisterConnectionChangedcallback(callback) #define FRAMEPRO_SET_THREAD_PRIORITY(priority) FramePro::SetThreadPriority(priority) #define FRAMEPRO_SET_THREAD_AFFINITY(affinity) FramePro::SetThreadAffinity(affinity) #define FRAMEPRO_BLOCK_SOCKETS() FramePro::BlockSockets() #define FRAMEPRO_UNBLOCK_SOCKETS() FramePro::UnblockSockets() #define FRAMEPRO_CLEANUP_THREAD() FramePro::CleanupThread() #define FRAMEPRO_THREAD_SCOPE(thread_name) FramePro::ThreadScope framepro_thread_scope(thread_name) #define FRAMEPRO_LOG(message) FramePro::Log(message) #define FRAMEPRO_COLOUR(r, g, b) ((FramePro::uint)((((FramePro::uint)((r)&0xff))<<16) | (((FramePro::uint)((g)&0xff))<<8) | ((b)&0xff))) #define FRAMEPRO_SET_CONDITIONAL_SCOPE_MIN_TIME(microseconds) FramePro::SetConditionalScopeMinTimeInMicroseconds(microseconds) #define FRAMEPRO_SCOPE() FramePro::TimerScope FRAMEPRO_UNIQUE(timer_scope)(FRAMEPRO_FUNCTION_NAME_LITERAL \"|\" FRAMEPRO_SOURCE_STRING) #define FRAMEPRO_NAMED_SCOPE(name) FramePro::TimerScope FRAMEPRO_UNIQUE(timer_scope)(name \"|\" FRAMEPRO_SOURCE_STRING) #define FRAMEPRO_NAMED_SCOPE_W(name) FramePro::TimerScopeW FRAMEPRO_UNIQUE(timer_scope)(name L\"|\" FRAMEPRO_SOURCE_STRING_W) #define FRAMEPRO_ID_SCOPE(name_id) FramePro::IdTimerScope FRAMEPRO_UNIQUE(timer_scope)(name_id, FRAMEPRO_SOURCE_STRING) #define FRAMEPRO_DYNAMIC_SCOPE(dynamic_string) FramePro::IdTimerScope FRAMEPRO_UNIQUE(timer_scope)(FramePro::IsConnected() ? FramePro::RegisterString(dynamic_string) : -1, FRAMEPRO_SOURCE_STRING) #define FRAMEPRO_CONDITIONAL_SCOPE() FramePro::ConditionalTimerScope FRAMEPRO_UNIQUE(timer_scope)(FRAMEPRO_FUNCTION_NAME_LITERAL \"|\" FRAMEPRO_SOURCE_STRING) #define FRAMEPRO_CONDITIONAL_ID_SCOPE(name) FramePro::ConditionalTimerScopeId FRAMEPRO_UNIQUE(timer_scope)(name, FRAMEPRO_SOURCE_STRING) #define FRAMEPRO_CONDITIONAL_NAMED_SCOPE(name) FramePro::ConditionalTimerScope FRAMEPRO_UNIQUE(timer_scope)(name \"|\" FRAMEPRO_SOURCE_STRING) #define FRAMEPRO_CONDITIONAL_NAMED_SCOPE_W(name) FramePro::ConditionalTimerScopeW FRAMEPRO_UNIQUE(timer_scope)(name L\"|\" FRAMEPRO_SOURCE_STRING_W) #define FRAMEPRO_CONDITIONAL_BOOL_SCOPE(b) FramePro::ConditionalBoolTimerScope FRAMEPRO_UNIQUE(timer_scope)(FRAMEPRO_FUNCTION_NAME_LITERAL \"|\" FRAMEPRO_SOURCE_STRING, (b)) #define FRAMEPRO_CONDITIONAL_BOOL_ID_SCOPE(name, b) FramePro::ConditionalBoolTimerScopeId FRAMEPRO_UNIQUE(timer_scope)(name, FRAMEPRO_SOURCE_STRING, (b)) #define FRAMEPRO_CONDITIONAL_BOOL_NAMED_SCOPE(name, b) FramePro::ConditionalBoolTimerScope FRAMEPRO_UNIQUE(timer_scope)(name \"|\" FRAMEPRO_SOURCE_STRING, (b)) #define FRAMEPRO_CONDITIONAL_BOOL_NAMED_SCOPE_W(name, b) FramePro::ConditionalBoolTimerScopeW FRAMEPRO_UNIQUE(timer_scope)(name L\"|\" FRAMEPRO_SOURCE_STRING_W, (b)) #define FRAMEPRO_START_NAMED_SCOPE(name)"
  },
  {
    "label": "MULTI_STATEMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MULTI_STATEMENT(if(FramePro::IsConnected()) { FRAMEPRO_GET_CLOCK_COUNT(framepro_start_##name); FramePro::StartScope(); } ) #define FRAMEPRO_STOP_NAMED_SCOPE(name) MULTI_STATEMENT( if(FramePro::IsConnected()) { FramePro::int64 framepro_end_##name; FRAMEPRO_GET_CLOCK_COUNT(framepro_end_##name); FramePro::AddTimeSpan(#name \"|\" FRAMEPRO_SOURCE_STRING, framepro_start_##name, framepro_end_##name); FramePro::StopScope(); } ) #define FRAMEPRO_CONDITIONAL_START_SCOPE()"
  },
  {
    "label": "MULTI_STATEMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MULTI_STATEMENT(if(FramePro::IsConnected()) { FRAMEPRO_GET_CLOCK_COUNT(framepro_start); FramePro::StartScope(); } ) #define FRAMEPRO_CONDITIONAL_STOP_NAMED_SCOPE(name) MULTI_STATEMENT( if(FramePro::IsConnected()) { FramePro::int64 framepro_end; FRAMEPRO_GET_CLOCK_COUNT(framepro_end); if(framepro_end - framepro_start > FramePro::GetConditionalScopeMinTime()) FramePro::AddTimeSpan(name \"|\" FRAMEPRO_SOURCE_STRING, framepro_start, framepro_end); FramePro::StopScope();} ) #define FRAMEPRO_CONDITIONAL_STOP_DYNAMIC_SCOPE(dynamic_string) MULTI_STATEMENT( if(FramePro::IsConnected()) { FramePro::int64 framepro_end; FRAMEPRO_GET_CLOCK_COUNT(framepro_end); if(framepro_end - framepro_start > FramePro::GetConditionalScopeMinTime()) FramePro::AddTimeSpan(FramePro::RegisterString(dynamic_string), FRAMEPRO_SOURCE_STRING, framepro_start, framepro_end); FramePro::StopScope(); } ) #define FRAMEPRO_CONDITIONAL_PARENT_SCOPE(name, callback, pre_duration, post_duration) FramePro::ConditionalParentTimerScope FRAMEPRO_UNIQUE(timer_scope)(name, FRAMEPRO_SOURCE_STRING, callback, pre_duration, post_duration) #define FRAMEPRO_SET_SCOPE_COLOUR(name, colour) MULTI_STATEMENT( FramePro::SetScopeColour(FramePro::RegisterString(name), colour); ) #define FRAMEPRO_CALLSTACK() FramePro::SendScopeCallstack() #define FRAMEPRO_IDLE_SCOPE() FramePro::TimerScope FRAMEPRO_UNIQUE(timer_scope)(FRAMEPRO_FUNCTION_NAME_LITERAL \"|\" FRAMEPRO_SOURCE_STRING_IDLE) #define FRAMEPRO_IDLE_NAMED_SCOPE(name) FramePro::TimerScope FRAMEPRO_UNIQUE(timer_scope)(name \"|\" FRAMEPRO_SOURCE_STRING_IDLE) #define FRAMEPRO_IDLE_NAMED_SCOPE_W(name) FramePro::TimerScopeW FRAMEPRO_UNIQUE(timer_scope)(name L\"|\" FRAMEPRO_SOURCE_STRING_IDLE_W) #define FRAMEPRO_IDLE_ID_SCOPE(name_id) FramePro::IdTimerScope FRAMEPRO_UNIQUE(timer_scope)(name_id, FRAMEPRO_SOURCE_STRING_IDLE) #define FRAMEPRO_IDLE_DYNAMIC_SCOPE(dynamic_string) FramePro::IdTimerScope FRAMEPRO_UNIQUE(timer_scope)(FramePro::IsConnected() ? FramePro::RegisterString(dynamic_string) : -1, FRAMEPRO_SOURCE_STRING_IDLE) #define FRAMEPRO_IDLE_CONDITIONAL_SCOPE() FramePro::ConditionalTimerScope FRAMEPRO_UNIQUE(timer_scope)(FRAMEPRO_FUNCTION_NAME_LITERAL \"|\" FRAMEPRO_SOURCE_STRING_IDLE) #define FRAMEPRO_IDLE_CONDITIONAL_ID_SCOPE(name) FramePro::ConditionalTimerScopeId FRAMEPRO_UNIQUE(timer_scope)(name, FRAMEPRO_SOURCE_STRING_IDLE) #define FRAMEPRO_IDLE_CONDITIONAL_NAMED_SCOPE(name) FramePro::ConditionalTimerScope FRAMEPRO_UNIQUE(timer_scope)(name \"|\" FRAMEPRO_SOURCE_STRING_IDLE) #define FRAMEPRO_IDLE_CONDITIONAL_NAMED_SCOPE_W(name) FramePro::ConditionalTimerScopeW FRAMEPRO_UNIQUE(timer_scope)(name L\"|\" FRAMEPRO_SOURCE_STRING_IDLE_W) #define FRAMEPRO_IDLE_START_NAMED_SCOPE(name)"
  },
  {
    "label": "FRAMEPRO_GET_CLOCK_COUNT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRAMEPRO_GET_CLOCK_COUNT(framepro_start_##name)"
  },
  {
    "label": "StartScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartScope()"
  },
  {
    "label": "FRAMEPRO_IDLE_STOP_NAMED_SCOPE()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "FRAMEPRO_IDLE_STOP_NAMED_SCOPE(name) MULTI_STATEMENT( if(FramePro::IsConnected()) { FramePro::int64 framepro_end_##name; FRAMEPRO_GET_CLOCK_COUNT(framepro_end_##name); FramePro::AddTimeSpan(#name \"|\" FRAMEPRO_SOURCE_STRING_IDLE, framepro_start_##name, framepro_end_##name); FramePro::StopScope(); } ) #define FRAMEPRO_IDLE_CONDITIONAL_START_SCOPE()"
  },
  {
    "label": "MULTI_STATEMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MULTI_STATEMENT(if(FramePro::IsConnected()) { FRAMEPRO_GET_CLOCK_COUNT(framepro_start); FramePro::StartScope(); } ) #define FRAMEPRO_IDLE_CONDITIONAL_STOP_NAMED_SCOPE(name) MULTI_STATEMENT( if(FramePro::IsConnected()) { FramePro::int64 framepro_end; FRAMEPRO_GET_CLOCK_COUNT(framepro_end); if(framepro_end - framepro_start > FramePro::GetConditionalScopeMinTime()) FramePro::AddTimeSpan(name \"|\" FRAMEPRO_SOURCE_STRING_IDLE, framepro_start, framepro_end); FramePro::StopScope(); } ) #define FRAMEPRO_IDLE_CONDITIONAL_STOP_DYNAMIC_SCOPE(dynamic_string) MULTI_STATEMENT( if(FramePro::IsConnected()) { FramePro::int64 framepro_end; FRAMEPRO_GET_CLOCK_COUNT(framepro_end); if(framepro_end - framepro_start > FramePro::GetConditionalScopeMinTime()) FramePro::AddTimeSpan(FramePro::RegisterString(dynamic_string), FRAMEPRO_SOURCE_STRING_IDLE, framepro_start, framepro_end); FramePro::StopScope(); } ) #define FRAMEPRO_CUSTOM_STAT(name, value, graph, unit, colour) MULTI_STATEMENT( if(FramePro::IsConnected()) FramePro::AddCustomStat(name, value, graph, unit, colour); ) #define FRAMEPRO_DYNAMIC_CUSTOM_STAT(name, value, graph, unit, colour) MULTI_STATEMENT( if(FramePro::IsConnected()) FramePro::AddCustomStat(FramePro::RegisterString(name), value, FramePro::RegisterString(graph), FramePro::RegisterString(unit), colour); ) #define FRAMEPRO_SCOPE_CUSTOM_STAT(name, value, graph, unit, colour) MULTI_STATEMENT( if(FramePro::IsConnected()) FramePro::SetScopeCustomStat(name, value, graph, unit, colour); ) #define FRAMEPRO_SET_CUSTOM_STAT_GRAPH(name, graph) MULTI_STATEMENT( FramePro::SetCustomStatGraph(FramePro::RegisterString(name), FramePro::RegisterString(graph)); ) #define FRAMEPRO_SET_CUSTOM_STAT_UNIT(name, unit) MULTI_STATEMENT( FramePro::SetCustomStatUnit(FramePro::RegisterString(name), FramePro::RegisterString(unit)); ) #define FRAMEPRO_SET_CUSTOM_STAT_COLOUR(name, colour) MULTI_STATEMENT( FramePro::SetCustomStatColour(FramePro::RegisterString(name), colour); ) #define FRAMEPRO_HIRES_SCOPE(name) FramePro::HiResTimerScope FRAMEPRO_UNIQUE(hires_scope)(name) #define FRAMEPRO_DECL_CUSTOM_STAT_TIMER(name) FramePro::CustomStatTimer g_FrameProCustomStatTimer##name(#name) #define FRAMEPRO_EXTERN_CUSTOM_STAT_TIMER(name) extern FramePro::CustomStatTimer g_FrameProCustomStatTimer##name #define FRAMEPRO_CUSTOM_STAT_TIMER_SCOPE(name) FramePro::CustomStatTimerScope FRAMEPRO_UNIQUE(timer_scope)(g_FrameProCustomStatTimer##name) #define FRAMEPRO_EVENT(name, colour) FramePro::AddEvent(name, colour) #define FRAMEPRO_WAIT_EVENT_SCOPE(event_id) FramePro::WaitEventScope FRAMEPRO_UNIQUE(timer_scope)((FramePro::int64)event_id) #define FRAMEPRO_TRIGGER_WAIT_EVENT(event_id) FramePro::TriggerWaitEvent((FramePro::int64)event_id)"
  },
  {
    "label": "FRAMEPRO_FRAME_START()",
    "kind": "Method",
    "detail": "Function (# else # define)",
    "insertText": "FRAMEPRO_FRAME_START() ((void)0) #define FRAMEPRO_SHUTDOWN() ((void)0) #define FRAMEPRO_SET_PORT(port) ((void)0) #define FRAMEPRO_SESSION_INFO(name, id) ((void)0) #define FRAMEPRO_SET_ALLOCATOR(p_allocator) ((void)0) #define FRAMEPRO_SET_THREAD_NAME(name) ((void)0) #define FRAMEPRO_SET_THREAD_ID_NAME(thread_id, name) ((void)0) #define FRAMEPRO_THREAD_ORDER(thread_name) ((void)0) #define FRAMEPRO_REGISTER_STRING(str) 0 #define FRAMEPRO_START_RECORDING(filename, context_switches, callstacks, max_file_size) ((void)0) #define FRAMEPRO_STOP_RECORDING() ((void)0) #define FRAMEPRO_REGISTER_CONNECTION_CHANGED_CALLBACK(callback, context) ((void)0) #define FRAMEPRO_UNREGISTER_CONNECTION_CHANGED_CALLBACK(callback) ((void)0) #define FRAMEPRO_SET_THREAD_PRIORITY(priority) ((void)0) #define FRAMEPRO_SET_THREAD_AFFINITY(affinity) ((void)0) #define FRAMEPRO_UNBLOCK_SOCKETS() ((void)0) #define FRAMEPRO_CLEANUP_THREAD() ((void)0) #define FRAMEPRO_THREAD_SCOPE(thread_name) ((void)0) #define FRAMEPRO_LOG(message) ((void)0) #define FRAMEPRO_COLOUR(r, g, b) ((void)0) #define FRAMEPRO_SET_CONDITIONAL_SCOPE_MIN_TIME(microseconds) ((void)0) #define FRAMEPRO_SCOPE() ((void)0) #define FRAMEPRO_NAMED_SCOPE(name) ((void)0) #define FRAMEPRO_NAMED_SCOPE_W(name) ((void)0) #define FRAMEPRO_ID_SCOPE(name_id) ((void)name_id) #define FRAMEPRO_DYNAMIC_SCOPE(dynamic_string) ((void)0) #define FRAMEPRO_CONDITIONAL_SCOPE() ((void)0) #define FRAMEPRO_CONDITIONAL_ID_SCOPE(name) ((void)0) #define FRAMEPRO_CONDITIONAL_NAMED_SCOPE(name) ((void)0) #define FRAMEPRO_CONDITIONAL_NAMED_SCOPE_W(name) ((void)0) #define FRAMEPRO_CONDITIONAL_BOOL_SCOPE(b) ((void)0) #define FRAMEPRO_CONDITIONAL_BOOL_ID_SCOPE(name, b) ((void)0) #define FRAMEPRO_CONDITIONAL_BOOL_NAMED_SCOPE(name, b) ((void)0) #define FRAMEPRO_CONDITIONAL_BOOL_NAMED_SCOPE_W(name, b) ((void)0) #define FRAMEPRO_START_NAMED_SCOPE(name) ((void)0) #define FRAMEPRO_STOP_NAMED_SCOPE(name) ((void)0) #define FRAMEPRO_CONDITIONAL_START_SCOPE() ((void)0) #define FRAMEPRO_CONDITIONAL_STOP_NAMED_SCOPE(name) ((void)0) #define FRAMEPRO_CONDITIONAL_STOP_DYNAMIC_SCOPE(dynamic_string) ((void)0) #define FRAMEPRO_CONDITIONAL_PARENT_SCOPE(name, callback, pre_duration, post_duration) ((void)0) #define FRAMEPRO_SET_SCOPE_COLOUR(name, colour) ((void)0) #define FRAMEPRO_CALLSTACK() ((void)0) #define FRAMEPRO_IDLE_SCOPE() ((void)0) #define FRAMEPRO_IDLE_NAMED_SCOPE(name) ((void)0) #define FRAMEPRO_IDLE_NAMED_SCOPE_W(name) ((void)0) #define FRAMEPRO_IDLE_ID_SCOPE(name_id) ((void)name_id) #define FRAMEPRO_IDLE_DYNAMIC_SCOPE(dynamic_string) ((void)0) #define FRAMEPRO_IDLE_CONDITIONAL_SCOPE() ((void)0) #define FRAMEPRO_IDLE_CONDITIONAL_ID_SCOPE(name) ((void)0) #define FRAMEPRO_IDLE_CONDITIONAL_NAMED_SCOPE(name) ((void)0) #define FRAMEPRO_IDLE_CONDITIONAL_NAMED_SCOPE_W(name) ((void)0) #define FRAMEPRO_IDLE_START_NAMED_SCOPE(name) ((void)0) #define FRAMEPRO_IDLE_STOP_NAMED_SCOPE(name) ((void)0) #define FRAMEPRO_IDLE_CONDITIONAL_START_SCOPE() ((void)0) #define FRAMEPRO_IDLE_CONDITIONAL_STOP_NAMED_SCOPE(name) ((void)0) #define FRAMEPRO_IDLE_CONDITIONAL_STOP_DYNAMIC_SCOPE(dynamic_string) ((void)0) #define FRAMEPRO_CUSTOM_STAT(name, value, graph, unit, colour) ((void)0) #define FRAMEPRO_DYNAMIC_CUSTOM_STAT(name, value, graph, unit, colour) ((void)0) #define FRAMEPRO_SCOPE_CUSTOM_STAT(name, value, graph, unit, colour) ((void)0) #define FRAMEPRO_SET_CUSTOM_STAT_GRAPH(name, graph) ((void)0) #define FRAMEPRO_SET_CUSTOM_STAT_UNIT(name, unit) ((void)0) #define FRAMEPRO_SET_CUSTOM_STAT_COLOUR(name, colour) ((void)0) #define FRAMEPRO_HIRES_SCOPE(name) ((void)0) #define FRAMEPRO_DECL_CUSTOM_STAT_TIMER(name) #define FRAMEPRO_EXTERN_CUSTOM_STAT_TIMER(name) #define FRAMEPRO_CUSTOM_STAT_TIMER_SCOPE(name) ((void)0) #define FRAMEPRO_EVENT(name, colour) ((void)0) #define FRAMEPRO_WAIT_EVENT_SCOPE(event_id) ((void)0) #define FRAMEPRO_TRIGGER_WAIT_EVENT(event_id) ((void)0)"
  },
  {
    "label": "FRAMEPRO_MAX_MEMORY()",
    "kind": "Method",
    "detail": "Function (typedef long long StringId ; } # define FRAMEPRO_SOCKETS_ENABLED 1 # define FRAMEPRO_MAX_SEND_DELAY 3 0 # define FRAMEPRO_DEBUG_TCP 0 # define)",
    "insertText": "FRAMEPRO_MAX_MEMORY(50*1024*1024) #define FRAMEPRO_SOCKETS_BLOCKED_BY_DEFAULT false #define FRAMEPRO_SCOPE_MIN_TIME 10 #define FRAMEPRO_WAIT_EVENT_MIN_TIME 10 #define FRAMEPRO_ENABLE_CONTEXT_SWITCH_TRACKING 1 #define FRAMEPRO_ENABLE_CALLSTACKS 0 #define FRAMEPRO_DETECT_HASH_COLLISIONS 0 #define FRAMEPRO_STACK_TRACE_SIZE 128 #define FRAMEPRO_ALLOW_UNPARENTED_HIRES_SCOPES 0 #if FRAMEPRO_ENABLED #include <stdlib.h> #ifndef FRAMEPRO_DEBUG #if defined(DEBUG) || defined(_DEBUG) #define FRAMEPRO_DEBUG 1 #else #define FRAMEPRO_DEBUG 0 #endif #endif #define FRAMEPRO_STRINGIZE(x) FRAMEPRO_STRINGIZE2(x) #define FRAMEPRO_STRINGIZE2(x) #x #define FRAMEPRO_JOIN(a, b) FRAMEPRO_JOIN2(a, b) #define FRAMEPRO_JOIN2(a, b) a##b #define FRAMEPRO_UNIQUE(a) FRAMEPRO_JOIN(a, __LINE__) #define FRAMEPRO_WIDESTR(s) FRAMEPRO_WIDESTR2(s) #define FRAMEPRO_WIDESTR2(s) L##s #if defined(__UNREAL__) #define FRAMEPRO_PLATFORM_UE4 1 #define FRAMEPRO_PLATFORM_XBOXONE 0 #define FRAMEPRO_PLATFORM_UWP 0 #define FRAMEPRO_PLATFORM_WIN 0 #define FRAMEPRO_PLATFORM_LINUX 0 #define FRAMEPRO_PLATFORM_PS4 0 #define FRAMEPRO_PLATFORM_ANDROID 0 #elif defined(_XBOX_ONE) || defined(_DURANGO) #define FRAMEPRO_PLATFORM_UE4 0 #define FRAMEPRO_PLATFORM_XBOXONE 1 #define FRAMEPRO_PLATFORM_UWP 0 #define FRAMEPRO_PLATFORM_WIN 0 #define FRAMEPRO_PLATFORM_LINUX 0 #define FRAMEPRO_PLATFORM_PS4 0 #define FRAMEPRO_PLATFORM_ANDROID 0 #elif defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP) #define FRAMEPRO_PLATFORM_UE4 0 #define FRAMEPRO_PLATFORM_XBOXONE 0 #define FRAMEPRO_PLATFORM_UWP 1 #define FRAMEPRO_PLATFORM_WIN 0 #define FRAMEPRO_PLATFORM_LINUX 0 #define FRAMEPRO_PLATFORM_PS4 0 #define FRAMEPRO_PLATFORM_ANDROID 0 #elif defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64) || defined(__WIN32__) || defined(__WINDOWS__) #define FRAMEPRO_PLATFORM_UE4 0 #define FRAMEPRO_PLATFORM_XBOXONE 0 #define FRAMEPRO_PLATFORM_UWP 0 #define FRAMEPRO_PLATFORM_WIN 1 #define FRAMEPRO_PLATFORM_LINUX 0 #define FRAMEPRO_PLATFORM_PS4 0 #define FRAMEPRO_PLATFORM_ANDROID 0 #elif defined(__ORBIS__) #define FRAMEPRO_PLATFORM_UE4 0 #define FRAMEPRO_PLATFORM_XBOXONE 0 #define FRAMEPRO_PLATFORM_UWP 0 #define FRAMEPRO_PLATFORM_WIN 0 #define FRAMEPRO_PLATFORM_LINUX 0 #define FRAMEPRO_PLATFORM_PS4 1 #define FRAMEPRO_PLATFORM_ANDROID 0 #elif defined(__ANDROID__) #define FRAMEPRO_PLATFORM_UE4 0 #define FRAMEPRO_PLATFORM_XBOXONE 0 #define FRAMEPRO_PLATFORM_UWP 0 #define FRAMEPRO_PLATFORM_WIN 0 #define FRAMEPRO_PLATFORM_LINUX 0 #define FRAMEPRO_PLATFORM_PS4 0 #define FRAMEPRO_PLATFORM_ANDROID 1 #elif defined(unix) || defined(__unix__) || defined(__unix) #define FRAMEPRO_PLATFORM_UE4 0 #define FRAMEPRO_PLATFORM_XBOXONE 0 #define FRAMEPRO_PLATFORM_UWP 0 #define FRAMEPRO_PLATFORM_WIN 0 #define FRAMEPRO_PLATFORM_LINUX 1 #define FRAMEPRO_PLATFORM_PS4 0 #define FRAMEPRO_PLATFORM_ANDROID 0 #else #error FramePro platform not defined #endif #define FRAMEPRO_SOURCE_STRING __FILE__ \"|\" FRAMEPRO_FUNCTION_NAME_LITERAL \"|\" FRAMEPRO_STRINGIZE(__LINE__) \"|\" #define FRAMEPRO_SOURCE_STRING_W FRAMEPRO_WIDESTR(__FILE__) L\"|\" FRAMEPRO_WIDESTR(FRAMEPRO_FUNCTION_NAME_LITERAL) L\"|\" FRAMEPRO_WIDESTR(FRAMEPRO_STRINGIZE(__LINE__)) L\"|\" #define FRAMEPRO_SOURCE_STRING_IDLE __FILE__ \"|\" FRAMEPRO_FUNCTION_NAME_LITERAL \"|\" FRAMEPRO_STRINGIZE(__LINE__) \"|Idle\" #define FRAMEPRO_SOURCE_STRING_IDLE_W FRAMEPRO_WIDESTR(__FILE__) L\"|\" FRAMEPRO_WIDESTR(FRAMEPRO_FUNCTION_NAME_LITERAL) L\"|\" FRAMEPRO_WIDESTR(FRAMEPRO_STRINGIZE(__LINE__)) L\"|Idle\" #if FRAMEPRO_DEBUG #define FRAMEPRO_ASSERT(b) if(!(b)) FramePro::DebugBreak() #else #define FRAMEPRO_ASSERT(b) ((void)0) #endif #define FRAMEPRO_UNREFERENCED(s) (void)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (typedef long long int64 ; typedef unsigned long long uint64 ; typedef unsigned int uint ; } # define FRAMEPRO_DEFAULT_COND_SCOPE_MIN_TIME 5 0 # define FRAMEPRO_MAX_INLINE_STRING_LENGTH 2 5 6 namespace FramePro { typedef)",
    "insertText": "int(*ThreadMain)(void*)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} namespace FramePro { namespace PacketType { enum Enum { Connect = 0 xaabb,FrameStart,TimeSpan,TimeSpanW,NamedTimeSpan,StringLiteralNamedTimeSpan,ThreadName,ThreadOrder,StringPacket,WStringPacket,NameAndSourceInfoPacket,NameAndSourceInfoPacketW,SourceInfoPacket,MainThreadPacket,RequestStringLiteralPacket,SetConditionalScopeMinTimePacket,ConnectResponsePacket,SessionStatsPacket,RequestRecordedDataPacket,legacy_SessionDetailsPacket,ContextSwitchPacket,ContextSwitchRecordingStartedPacket,ProcessNamePacket,CustomStatPacket_Depreciated,StringLiteralTimerNamePacket,HiResTimerScopePacket,LogPacket,EventPacket,StartWaitEventPacket,StopWaitEventPacket,TriggerWaitEventPacket,TimeSpanCustomStatPacket_Depreciated,TimeSpanWithCallstack,TimeSpanWWithCallstack,NamedTimeSpanWithCallstack,StringLiteralNamedTimeSpanWithCallstack,ModulePacket,SetCallstackRecordingEnabledPacket,CustomStatPacketW_Depreciated2,TimeSpanCustomStatPacketW,CustomStatPacket_Depreciated2,TimeSpanCustomStatPacket,ScopeColourPacket,CustomStatColourPacket,CustomStatGraphPacket,CustomStatUnitPacket,CallstackPacket,SessionInfoPacket,CustomStatPacket,CustomStatPacketW,} ; } ; } namespace FramePro { struct ModulePacket { PacketType::Enum m_PacketType ; int m_UseLookupFunctionForBaseAddress ; int64 m_ModuleBase ; char m_Sig [ 1 6 ] ; int m_Age ; int m_Padding ; char m_ModuleName [ FRAMEPRO_MAX_INLINE_STRING_LENGTH ] ; char m_SymbolFilename [ FRAMEPRO_MAX_INLINE_STRING_LENGTH ] ; } ; } namespace FramePro { namespace Platform { enum Enum { Windows = 0,Windows_UWP,XBoxOne,Unused,Linux,PS4,Android,Mac,iOS,Switch,} ; } } # ifndef # if)",
    "insertText": "defined(FRAMEPRO_DLL_EXPORT) #define FRAMEPRO_API __declspec(dllexport) #elif defined(FRAMEPRO_DLL) #define FRAMEPRO_API __declspec(dllimport) #else #define FRAMEPRO_API #endif #endif #if FRAMEPRO_ENABLED #include <stdarg.h> #include <time.h> #if FRAMEPRO_PLATFORM_UE4 #include \"FramePro/FrameProUE4.h\" #elif FRAMEPRO_PLATFORM_WIN FRAMEPRO_API __int64 FramePro_QueryPerformanceCounter()"
  },
  {
    "label": "FRAMEPRO_GET_CLOCK_COUNT()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "FRAMEPRO_GET_CLOCK_COUNT(time) time = FramePro_QueryPerformanceCounter() #define FRAMEPRO_WIN_BASED_PLATFORM 1 #define FRAMEPRO_LINUX_BASED_PLATFORM 0 #define FRAMEPRO_USE_TLS_SLOTS 0 #define FRAMEPRO_PORT \"8428\" #if defined(_WIN64) || defined(__LP64__) || defined(__x86_64__) || defined(__ppc64__) #define FRAMEPRO_X64 1 #else #define FRAMEPRO_X64 0 #endif #define FRAMEPRO_MAX_PATH 260 #include <tchar.h> #define FRAMEPRO_TCHAR _TCHAR #define MULTI_STATEMENT(s)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (s })",
    "insertText": "while(true,false) #if !defined(__clang__) #define FRAMEPRO_FUNCTION_DEFINE_IS_STRING_LITERAL 1 #else #define FRAMEPRO_FUNCTION_DEFINE_IS_STRING_LITERAL 0 #endif #define FRAMEPRO_NO_INLINE __declspec(noinline) #define FRAMEPRO_FORCE_INLINE __forceinline #define LIMIT_RECORDING_FILE_SIZE 1 #define FRAMEPRO_ALIGN_STRUCT(a) #define FRAMEPRO_ENUMERATE_ALL_MODULES (FRAMEPRO_X64 && 1) #elif FRAMEPRO_PLATFORM_UWP __int64 FramePro_QueryPerformanceCounter()"
  },
  {
    "label": "FRAMEPRO_GET_CLOCK_COUNT()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "FRAMEPRO_GET_CLOCK_COUNT(time) time = FramePro_QueryPerformanceCounter() #define FRAMEPRO_WIN_BASED_PLATFORM 1 #define FRAMEPRO_LINUX_BASED_PLATFORM 0 #define FRAMEPRO_USE_TLS_SLOTS 0 #define FRAMEPRO_PORT \"8428\" #define FRAMEPRO_X64 1 #define FRAMEPRO_MAX_PATH 260 #include <tchar.h> #define FRAMEPRO_TCHAR _TCHAR #define MULTI_STATEMENT(s)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (s })",
    "insertText": "while(true,false) #if !defined(__clang__) #define FRAMEPRO_FUNCTION_DEFINE_IS_STRING_LITERAL 1 #else #define FRAMEPRO_FUNCTION_DEFINE_IS_STRING_LITERAL 0 #endif #define FRAMEPRO_NO_INLINE __declspec(noinline) #define FRAMEPRO_FORCE_INLINE __forceinline #define LIMIT_RECORDING_FILE_SIZE 1 #define FRAMEPRO_ALIGN_STRUCT(a) #define FRAMEPRO_ENUMERATE_ALL_MODULES (FRAMEPRO_X64 && 1) #elif FRAMEPRO_PLATFORM_ANDROID #define FRAMEPRO_GET_CLOCK_COUNT(time) \\ timespec FRAMEPRO_UNIQUE(ts)"
  },
  {
    "label": "clock_gettime()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "clock_gettime(CLOCK_MONOTONIC, &FRAMEPRO_UNIQUE(ts))"
  },
  {
    "label": "FRAMEPRO_UNIQUE()",
    "kind": "Method",
    "detail": "Function (\\ time =)",
    "insertText": "FRAMEPRO_UNIQUE(ts).tv_sec * 1000000000LL + FRAMEPRO_UNIQUE(ts).tv_nsec #define FRAMEPRO_WIN_BASED_PLATFORM 0 #define FRAMEPRO_LINUX_BASED_PLATFORM 1 #define FRAMEPRO_USE_TLS_SLOTS 0 #define FRAMEPRO_PORT \"8428\" #if defined(__LP64__) || defined(__x86_64__) || defined(__ppc64__) #define FRAMEPRO_X64 1 #else #define FRAMEPRO_X64 0 #endif #define FRAMEPRO_MAX_PATH 260 #define MULTI_STATEMENT(s)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (s })",
    "insertText": "while(false)"
  },
  {
    "label": "FRAMEPRO_ALIGN_STRUCT()",
    "kind": "Method",
    "detail": "Function (typedef char FRAMEPRO_TCHAR ; } # define FRAMEPRO_FUNCTION_DEFINE_IS_STRING_LITERAL 0 # define FRAMEPRO_NO_INLINE # define FRAMEPRO_FORCE_INLINE # define LIMIT_RECORDING_FILE_SIZE 1 # define)",
    "insertText": "FRAMEPRO_ALIGN_STRUCT(a) __attribute__ ((aligned(a))) #define FRAMEPRO_ENUMERATE_ALL_MODULES (FRAMEPRO_X64 && 1) #elif FRAMEPRO_PLATFORM_LINUX #define FRAMEPRO_GET_CLOCK_COUNT(time) \\ timespec FRAMEPRO_UNIQUE(ts)"
  },
  {
    "label": "FRAMEPRO_ALIGN_STRUCT()",
    "kind": "Method",
    "detail": "Function (typedef char FRAMEPRO_TCHAR ; } # define FRAMEPRO_FUNCTION_DEFINE_IS_STRING_LITERAL 0 # define FRAMEPRO_NO_INLINE # define FRAMEPRO_FORCE_INLINE # define LIMIT_RECORDING_FILE_SIZE 1 # define)",
    "insertText": "FRAMEPRO_ALIGN_STRUCT(a) __attribute__ ((aligned(a))) #define FRAMEPRO_ENUMERATE_ALL_MODULES (FRAMEPRO_X64 && 1)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (class Allocator ; struct ContextSwitch ; class DynamicString ; struct ModulePacket ; template<T> class Array ; namespace Platform { typedef)",
    "insertText": "void(*ContextSwitchCallbackFunction)(const ContextSwitch&, void*)"
  },
  {
    "label": "GetTimerFrequency()",
    "kind": "Method",
    "detail": "Function (enum Enum ; int64)",
    "insertText": "GetTimerFrequency()"
  },
  {
    "label": "DebugBreak()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DebugBreak()"
  },
  {
    "label": "GetCore()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetCore()"
  },
  {
    "label": "GetProcessName()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetProcessName(int process_id, char* p_name, int max_name_length)"
  },
  {
    "label": "GetPlatformEnum()",
    "kind": "Method",
    "detail": "Function (Platform::Enum)",
    "insertText": "GetPlatformEnum()"
  },
  {
    "label": "CreateContextSwitchRecorder()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "CreateContextSwitchRecorder(Allocator* p_allocator)"
  },
  {
    "label": "DestroyContextSwitchRecorder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroyContextSwitchRecorder(void* p_context_switch_recorder, Allocator* p_allocator)"
  },
  {
    "label": "StartRecordingContextSitches()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "StartRecordingContextSitches(void* p_context_switch_recorder, ContextSwitchCallbackFunction p_callback, void* p_context, DynamicString& error, Allocator* p_allocator)"
  },
  {
    "label": "StopRecordingContextSitches()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StopRecordingContextSitches(void* p_context_switch_recorder)"
  },
  {
    "label": "FlushContextSwitches()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushContextSwitches(void* p_context_switch_recorder)"
  },
  {
    "label": "EnumerateModules()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnumerateModules(Array<ModulePacket*>& module_packets, Allocator* p_allocator)"
  },
  {
    "label": "GetStackTrace()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetStackTrace(void** stack, int& stack_size, unsigned int& hash)"
  },
  {
    "label": "GetCurrentThreadId()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetCurrentThreadId()"
  },
  {
    "label": "DebugWrite()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DebugWrite(const char* p_string)"
  },
  {
    "label": "GetLocalTime()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetLocalTime(tm* p_tm, const time_t *p_time)"
  },
  {
    "label": "GetCurrentProcessId()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetCurrentProcessId()"
  },
  {
    "label": "VSPrintf()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VSPrintf(char* p_buffer, size_t const buffer_size, const char* p_format, va_list arg_list)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ToString(int value, char* p_dest, int dest_size)"
  },
  {
    "label": "CreateLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateLock(void* p_os_lock_mem, int os_lock_mem_size)"
  },
  {
    "label": "DestroyLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroyLock(void* p_os_lock_mem)"
  },
  {
    "label": "TakeLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TakeLock(void* p_os_lock_mem)"
  },
  {
    "label": "ReleaseLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseLock(void* p_os_lock_mem)"
  },
  {
    "label": "CreateEventX()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateEventX(void* p_os_event_mem, int os_event_mem_size, bool initial_state, bool auto_reset)"
  },
  {
    "label": "DestroyEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroyEvent(void* p_os_event_mem)"
  },
  {
    "label": "SetEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetEvent(void* p_os_event_mem)"
  },
  {
    "label": "ResetEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetEvent(void* p_os_event_mem)"
  },
  {
    "label": "WaitEvent()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "WaitEvent(void* p_os_event_mem, int timeout)"
  },
  {
    "label": "InitialiseSocketSystem()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "InitialiseSocketSystem()"
  },
  {
    "label": "UninitialiseSocketSystem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UninitialiseSocketSystem()"
  },
  {
    "label": "CreateSocket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CreateSocket(void* p_os_socket_mem, int os_socket_mem_size)"
  },
  {
    "label": "DestroySocket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroySocket(void* p_os_socket_mem)"
  },
  {
    "label": "DisconnectSocket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisconnectSocket(void* p_os_socket_mem, bool stop_listening)"
  },
  {
    "label": "StartSocketListening()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "StartSocketListening(void* p_os_socket_mem)"
  },
  {
    "label": "BindSocket()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "BindSocket(void* p_os_socket_mem, const char* p_port)"
  },
  {
    "label": "AcceptSocket()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AcceptSocket(void* p_source_os_socket_mem, void* p_target_os_socket_mem)"
  },
  {
    "label": "SocketSend()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SocketSend(void* p_os_socket_mem, const void* p_buffer, int size, int& bytes_sent)"
  },
  {
    "label": "SocketReceive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SocketReceive(void* p_os_socket_mem, const void* p_buffer, int size, int& bytes_received)"
  },
  {
    "label": "IsSocketValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsSocketValid(const void* p_os_socket_mem)"
  },
  {
    "label": "HandleSocketError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleSocketError()"
  },
  {
    "label": "CreateThread()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CreateThread(void* p_os_thread_mem, int os_thread_mem_size, ThreadMain p_thread_main, void* p_context, Allocator* p_allocator)"
  },
  {
    "label": "DestroyThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroyThread(void* p_os_thread_mem)"
  },
  {
    "label": "SetThreadPriority()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetThreadPriority(void* p_os_thread_mem, int priority)"
  },
  {
    "label": "SetThreadAffinity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetThreadAffinity(void* p_os_thread_mem, int affinity)"
  },
  {
    "label": "OpenFileForRead()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OpenFileForRead(void* p_os_file_mem, int os_file_mem_size, const char* p_filename)"
  },
  {
    "label": "OpenFileForRead()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OpenFileForRead(void* p_os_file_mem, int os_file_mem_size, const wchar_t* p_filename)"
  },
  {
    "label": "OpenFileForWrite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OpenFileForWrite(void* p_os_file_mem, int os_file_mem_size, const char* p_filename)"
  },
  {
    "label": "OpenFileForWrite()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "OpenFileForWrite(void* p_os_file_mem, int os_file_mem_size, const wchar_t* p_filename)"
  },
  {
    "label": "CloseFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CloseFile(void* p_os_file_mem)"
  },
  {
    "label": "ReadFromFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReadFromFile(void* p_os_file_mem, void* p_data, size_t size)"
  },
  {
    "label": "WriteToFile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WriteToFile(void* p_os_file_mem, const void* p_data, size_t size)"
  },
  {
    "label": "GetFileSize()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetFileSize(const void* p_os_file_mem)"
  },
  {
    "label": "AllocateTLSSlot()",
    "kind": "Method",
    "detail": "Function (uint)",
    "insertText": "AllocateTLSSlot()"
  },
  {
    "label": "GetTLSValue()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "GetTLSValue(uint slot)"
  },
  {
    "label": "SetTLSValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTLSValue(uint slot, void* p_value)"
  },
  {
    "label": "GetRecordingFolder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetRecordingFolder(char* p_path, int max_path_length)"
  },
  {
    "label": "FRAMEPRO_SCOPE()",
    "kind": "Method",
    "detail": "Function (} } # endif # include<atomic> # if FRAMEPRO_WIN_BASED_PLATFORM # define FRAMEPRO_FUNCTION_NAME __FUNCSIG__ # else # define FRAMEPRO_FUNCTION_NAME __PRETTY_FUNCTION__ # endif # if FRAMEPRO_FUNCTION_DEFINE_IS_STRING_LITERAL # define FRAMEPRO_FUNCTION_NAME_LITERAL FRAMEPRO_FUNCTION_NAME # else # define FRAMEPRO_FUNCTION_NAME_LITERAL \" \" # ifdef FRAMEPRO_SCOPE # undef FRAMEPRO_SCOPE # define)",
    "insertText": "FRAMEPRO_SCOPE() FramePro::StringLiteralNamedTimerScope FRAMEPRO_UNIQUE(timer_scope)(FRAMEPRO_FUNCTION_NAME, FRAMEPRO_SOURCE_STRING) #endif #ifdef FRAMEPRO_CONDITIONAL_SCOPE #undef FRAMEPRO_CONDITIONAL_SCOPE #define FRAMEPRO_CONDITIONAL_SCOPE() FramePro::StringLiteralNamedConditionalTimerScope FRAMEPRO_UNIQUE(timer_scope)(FRAMEPRO_FUNCTION_NAME, FRAMEPRO_SOURCE_STRING) #endif #ifdef FRAMEPRO_IDLE_SCOPE #undef FRAMEPRO_IDLE_SCOPE #define FRAMEPRO_IDLE_SCOPE() FramePro::StringLiteralNamedTimerScope FRAMEPRO_UNIQUE(timer_scope)(FRAMEPRO_FUNCTION_NAME, FRAMEPRO_SOURCE_STRING_IDLE) #endif #ifdef FRAMEPRO_IDLE_CONDITIONAL_SCOPE #undef FRAMEPRO_IDLE_CONDITIONAL_SCOPE #define FRAMEPRO_IDLE_CONDITIONAL_SCOPE() FramePro::StringLiteralNamedConditionalTimerScope FRAMEPRO_UNIQUE(timer_scope)(FRAMEPRO_FUNCTION_NAME, FRAMEPRO_SOURCE_STRING_IDLE)"
  },
  {
    "label": "RelaxedAtomic()",
    "kind": "Method",
    "detail": "Function (template<T> class RelaxedAtomic { public :)",
    "insertText": "RelaxedAtomic()"
  },
  {
    "label": "FRAMEPRO_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRAMEPRO_ASSERT((((FramePro::uint64)this) % sizeof(T) == 0))"
  },
  {
    "label": "RelaxedAtomic()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RelaxedAtomic(T value) : m_Value(value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator(T value)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (m_Value = value ; } operator)",
    "insertText": "T()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (typedef)",
    "insertText": "bool(*ConditionalParentScopeCallback)(const char* p_name, int64 start_time, int64 end_time, int64 ticks_per_second)"
  },
  {
    "label": "IsConnected()",
    "kind": "Method",
    "detail": "Function (RelaxedAtomic<bool> g_Connected ; RelaxedAtomic<unsigned int> g_ConditionalScopeMinTime ; bool)",
    "insertText": "IsConnected()"
  },
  {
    "label": "SetPort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPort(int port)"
  },
  {
    "label": "SendSessionInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SendSessionInfo(const char* p_name, const char* p_value)"
  },
  {
    "label": "SendSessionInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SendSessionInfo(const wchar_t* p_name, const wchar_t* p_value)"
  },
  {
    "label": "SetAllocator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetAllocator(class Allocator* p_allocator)"
  },
  {
    "label": "FrameStart()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FrameStart()"
  },
  {
    "label": "AddTimeSpan()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTimeSpan(const char* p_name_file_and_line, int64 start_time, int64 end_time)"
  },
  {
    "label": "AddTimeSpan()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTimeSpan(const wchar_t* p_name_file_and_line, int64 start_time, int64 end_time)"
  },
  {
    "label": "AddTimeSpan()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTimeSpan(const char* p_name, const char* p_file_and_line, int64 start_time, int64 end_time)"
  },
  {
    "label": "AddTimeSpan()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTimeSpan(StringId name_id, const char* p_file_and_line, int64 start_time, int64 end_time)"
  },
  {
    "label": "AddTimeSpan()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTimeSpan(StringId name_id, const char* p_file_and_line, int64 start_time, int64 end_time, int thread_id, int core)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(const char* p_name, int value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(const char* p_name, int64 value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(const char* p_name, float value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(const char* p_name, double value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(const wchar_t* p_name, int value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(const wchar_t* p_name, int64 value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(const wchar_t* p_name, float value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(const wchar_t* p_name, double value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, int value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, int64 value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, float value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, double value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, int value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, int64 value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, float value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, double value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, int value, StringId graph, StringId unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, int64 value, StringId graph, StringId unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, float value, StringId graph, StringId unit, uint colour)"
  },
  {
    "label": "AddCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStat(StringId name, double value, StringId graph, StringId unit, uint colour)"
  },
  {
    "label": "AddEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddEvent(const char* p_name, uint colour)"
  },
  {
    "label": "AddWaitEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddWaitEvent(int64 event_id, int64 start_time, int start_core, int64 end_time, int end_core)"
  },
  {
    "label": "TriggerWaitEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TriggerWaitEvent(int64 event_id)"
  },
  {
    "label": "SetThreadName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetThreadName(const char* p_name)"
  },
  {
    "label": "SetThreadName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetThreadName(int thread_id, const char* p_name)"
  },
  {
    "label": "SetThreadOrder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetThreadOrder(StringId thread_name)"
  },
  {
    "label": "RegisterString()",
    "kind": "Method",
    "detail": "Function (StringId)",
    "insertText": "RegisterString(const char* p_str)"
  },
  {
    "label": "RegisterString()",
    "kind": "Method",
    "detail": "Function (StringId)",
    "insertText": "RegisterString(const wchar_t* p_str)"
  },
  {
    "label": "RegisterConnectionChangedCallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RegisterConnectionChangedCallback(ConnectionChangedCallback p_callback, void* p_context)"
  },
  {
    "label": "UnregisterConnectionChangedcallback()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnregisterConnectionChangedcallback(ConnectionChangedCallback p_callback)"
  },
  {
    "label": "StartRecording()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartRecording(const char* p_filename, bool context_switches, bool callstacks, int64 max_file_size)"
  },
  {
    "label": "StartRecording()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartRecording(const wchar_t* p_filename, bool context_switches, bool callstacks, int64 max_file_size)"
  },
  {
    "label": "StopRecording()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StopRecording()"
  },
  {
    "label": "SetThreadPriority()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetThreadPriority(int priority)"
  },
  {
    "label": "SetThreadAffinity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetThreadAffinity(int affinity)"
  },
  {
    "label": "BlockSockets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BlockSockets()"
  },
  {
    "label": "UnblockSockets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UnblockSockets()"
  },
  {
    "label": "AddCustomStatTimer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCustomStatTimer(class CustomStatTimer* p_timer)"
  },
  {
    "label": "CleanupThread()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CleanupThread()"
  },
  {
    "label": "PushConditionalParentScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PushConditionalParentScope(const char* p_name, int64 pre_duration, int64 post_duration)"
  },
  {
    "label": "PopConditionalParentScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopConditionalParentScope(bool add_children)"
  },
  {
    "label": "CallConditionalParentScopeCallback()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CallConditionalParentScopeCallback(ConditionalParentScopeCallback p_callback, const char* p_name, int64 start_time, int64 end_time)"
  },
  {
    "label": "StartHiResTimer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartHiResTimer(const char* p_name)"
  },
  {
    "label": "StopHiResTimer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StopHiResTimer()"
  },
  {
    "label": "Log()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Log(const char* p_message)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(const char* p_name, int value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(const wchar_t* p_name, int value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(StringId name, int value, StringId graph, StringId unit, uint colour)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(const char* p_name, int64 value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(const wchar_t* p_name, int64 value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(StringId name, int64 value, StringId graph, StringId unit, uint colour)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(const char* p_name, float value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(const wchar_t* p_name, float value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(StringId name, float value, StringId graph, StringId unit, uint colour)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(const char* p_name, double value, const char* p_graph, const char* p_unit, uint colour)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(const wchar_t* p_name, double value, const wchar_t* p_graph, const wchar_t* p_unit, uint colour)"
  },
  {
    "label": "SetScopeCustomStat()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeCustomStat(StringId name, double value, StringId graph, StringId unit, uint colour)"
  },
  {
    "label": "SetConditionalScopeMinTimeInMicroseconds()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetConditionalScopeMinTimeInMicroseconds(int64 value)"
  },
  {
    "label": "SetScopeColour()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetScopeColour(StringId name, uint colour)"
  },
  {
    "label": "SetCustomStatGraph()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCustomStatGraph(StringId name, StringId graph)"
  },
  {
    "label": "SetCustomStatUnit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCustomStatUnit(StringId name, StringId unit)"
  },
  {
    "label": "SetCustomStatColour()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCustomStatColour(StringId name, uint colour)"
  },
  {
    "label": "SendScopeCallstack()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SendScopeCallstack()"
  },
  {
    "label": "StopScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StopScope()"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (} # endif } namespace FramePro { class Allocator { public : void*)",
    "insertText": "Alloc(size_t size)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(void* p)"
  },
  {
    "label": "Allocator()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "Allocator()"
  },
  {
    "label": "TimerScope()",
    "kind": "Method",
    "detail": "Function (} } ; class TimerScope { public :)",
    "insertText": "TimerScope(const char* p_name_and_source_info)"
  },
  {
    "label": "FRAMEPRO_GET_CLOCK_COUNT()",
    "kind": "Method",
    "detail": "Function (mp_NameAndSourceInfo = p_name_and_source_info ;)",
    "insertText": "FRAMEPRO_GET_CLOCK_COUNT(m_StartTime)"
  },
  {
    "label": "TimerScope()",
    "kind": "Method",
    "detail": "Function (} else { mp_NameAndSourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "TimerScope()"
  },
  {
    "label": "FRAMEPRO_GET_CLOCK_COUNT()",
    "kind": "Method",
    "detail": "Function (int64 end_time = 0 ;)",
    "insertText": "FRAMEPRO_GET_CLOCK_COUNT(end_time)"
  },
  {
    "label": "AddTimeSpan()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTimeSpan(mp_NameAndSourceInfo, m_StartTime, end_time)"
  },
  {
    "label": "TimerScopeW()",
    "kind": "Method",
    "detail": "Function (} } private : const char* mp_NameAndSourceInfo ; int64 m_StartTime ; } ; class TimerScopeW { public :)",
    "insertText": "TimerScopeW(const wchar_t* p_name_and_source_info)"
  },
  {
    "label": "TimerScopeW()",
    "kind": "Method",
    "detail": "Function (} else { mp_NameAndSourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "TimerScopeW()"
  },
  {
    "label": "ConditionalParentTimerScope()",
    "kind": "Method",
    "detail": "Function (} } private : const wchar_t* mp_NameAndSourceInfo ; int64 m_StartTime ; } ; class ConditionalParentTimerScope { public :)",
    "insertText": "ConditionalParentTimerScope(const char* p_name, const char* p_source_info, ConditionalParentScopeCallback p_callback, int64 pre_duration, int64 post_duration) : mp_Callback(p_callback)"
  },
  {
    "label": "PushConditionalParentScope()",
    "kind": "Method",
    "detail": "Function (mp_Name = p_name ; mp_SourceInfo = p_source_info ;)",
    "insertText": "PushConditionalParentScope(p_name, pre_duration, post_duration)"
  },
  {
    "label": "ConditionalParentTimerScope()",
    "kind": "Method",
    "detail": "Function (} else { mp_Name = nullptr ; mp_SourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "ConditionalParentTimerScope()"
  },
  {
    "label": "CallConditionalParentScopeCallback()",
    "kind": "Method",
    "detail": "Function (bool add_children =)",
    "insertText": "CallConditionalParentScopeCallback(mp_Callback, mp_Name, m_StartTime, end_time)"
  },
  {
    "label": "PopConditionalParentScope()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopConditionalParentScope(add_children)"
  },
  {
    "label": "AddTimeSpan()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTimeSpan(mp_Name, mp_SourceInfo, m_StartTime, end_time)"
  },
  {
    "label": "IdTimerScope()",
    "kind": "Method",
    "detail": "Function (} } private : const char* mp_Name ; const char* mp_SourceInfo ; int64 m_StartTime ; ConditionalParentScopeCallback mp_Callback ; } ; class IdTimerScope { public :)",
    "insertText": "IdTimerScope(StringId name, const char* p_source_info)"
  },
  {
    "label": "IdTimerScope()",
    "kind": "Method",
    "detail": "Function (} else { m_Name = 0 ; mp_SourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "IdTimerScope()"
  },
  {
    "label": "AddTimeSpan()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddTimeSpan(m_Name, mp_SourceInfo, m_StartTime, end_time)"
  },
  {
    "label": "StringLiteralNamedTimerScope()",
    "kind": "Method",
    "detail": "Function (} } private : StringId m_Name ; const char* mp_SourceInfo ; int64 m_StartTime ; } ; class StringLiteralNamedTimerScope { public :)",
    "insertText": "StringLiteralNamedTimerScope(const char* p_name, const char* p_source_info)"
  },
  {
    "label": "StringLiteralNamedTimerScope()",
    "kind": "Method",
    "detail": "Function (} else { mp_Name = nullptr ; mp_SourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "StringLiteralNamedTimerScope()"
  },
  {
    "label": "ConditionalTimerScope()",
    "kind": "Method",
    "detail": "Function (} } private : const char* mp_Name ; const char* mp_SourceInfo ; int64 m_StartTime ; } ; class ConditionalTimerScope { public :)",
    "insertText": "ConditionalTimerScope(const char* p_name_and_source_info)"
  },
  {
    "label": "ConditionalTimerScope()",
    "kind": "Method",
    "detail": "Function (} else { mp_NameAndSourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "ConditionalTimerScope()"
  },
  {
    "label": "ConditionalTimerScopeId()",
    "kind": "Method",
    "detail": "Function (} } private : const char* mp_NameAndSourceInfo ; int64 m_StartTime ; } ; class ConditionalTimerScopeId { public :)",
    "insertText": "ConditionalTimerScopeId(StringId name, const char* p_source_info)"
  },
  {
    "label": "ConditionalTimerScopeId()",
    "kind": "Method",
    "detail": "Function (} else { m_Name = 0 ; mp_SourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "ConditionalTimerScopeId()"
  },
  {
    "label": "ConditionalTimerScopeW()",
    "kind": "Method",
    "detail": "Function (} } private : StringId m_Name ; const char* mp_SourceInfo ; int64 m_StartTime ; } ; class ConditionalTimerScopeW { public :)",
    "insertText": "ConditionalTimerScopeW(const wchar_t* p_name_and_source_info)"
  },
  {
    "label": "ConditionalTimerScopeW()",
    "kind": "Method",
    "detail": "Function (} else { mp_NameAndSourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "ConditionalTimerScopeW()"
  },
  {
    "label": "ConditionalBoolTimerScope()",
    "kind": "Method",
    "detail": "Function (} } private : const wchar_t* mp_NameAndSourceInfo ; int64 m_StartTime ; } ; class ConditionalBoolTimerScope { public :)",
    "insertText": "ConditionalBoolTimerScope(const char* p_name_and_source_info, bool b)"
  },
  {
    "label": "ConditionalBoolTimerScope()",
    "kind": "Method",
    "detail": "Function (} else { mp_NameAndSourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "ConditionalBoolTimerScope()"
  },
  {
    "label": "ConditionalBoolTimerScopeId()",
    "kind": "Method",
    "detail": "Function (} } private : const char* mp_NameAndSourceInfo ; int64 m_StartTime ; } ; class ConditionalBoolTimerScopeId { public :)",
    "insertText": "ConditionalBoolTimerScopeId(StringId name, const char* p_source_info, bool b)"
  },
  {
    "label": "ConditionalBoolTimerScopeId()",
    "kind": "Method",
    "detail": "Function (} else { m_Name = 0 ; mp_SourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "ConditionalBoolTimerScopeId()"
  },
  {
    "label": "ConditionalBoolTimerScopeW()",
    "kind": "Method",
    "detail": "Function (} } private : StringId m_Name ; const char* mp_SourceInfo ; int64 m_StartTime ; } ; class ConditionalBoolTimerScopeW { public :)",
    "insertText": "ConditionalBoolTimerScopeW(const wchar_t* p_name_and_source_info, bool b)"
  },
  {
    "label": "ConditionalBoolTimerScopeW()",
    "kind": "Method",
    "detail": "Function (} else { mp_NameAndSourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "ConditionalBoolTimerScopeW()"
  },
  {
    "label": "StringLiteralNamedConditionalTimerScope()",
    "kind": "Method",
    "detail": "Function (} } private : const wchar_t* mp_NameAndSourceInfo ; int64 m_StartTime ; } ; class StringLiteralNamedConditionalTimerScope { public :)",
    "insertText": "StringLiteralNamedConditionalTimerScope(const char* p_name, const char* p_source_info)"
  },
  {
    "label": "StringLiteralNamedConditionalTimerScope()",
    "kind": "Method",
    "detail": "Function (} else { mp_Name = nullptr ; mp_SourceInfo = nullptr ; m_StartTime = 0 ; } } ~)",
    "insertText": "StringLiteralNamedConditionalTimerScope()"
  },
  {
    "label": "CustomStatTimer()",
    "kind": "Method",
    "detail": "Function (} } private : const char* mp_Name ; const char* mp_SourceInfo ; int64 m_StartTime ; } ; class CustomStatTimer { public :)",
    "insertText": "CustomStatTimer(const char* p_name) : m_Value(0), mp_Next(NULL)"
  },
  {
    "label": "AddCustomStatTimer()",
    "kind": "Method",
    "detail": "Function (mp_Name = p_name ;)",
    "insertText": "AddCustomStatTimer(this)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Add(uint value)"
  },
  {
    "label": "load()",
    "kind": "Method",
    "detail": "Function (uint64 existing_value = m_Value .)",
    "insertText": "load(std::memory_order_relaxed)"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (uint64 new_value ; do { uint64 duration = existing_value& 0 xffffffffff ; uint64)",
    "insertText": "count(existing_value >> 40)"
  },
  {
    "label": "new_value()",
    "kind": "Method",
    "detail": "Function (duration + = value ; + + count ;)",
    "insertText": "new_value(count << 40)"
  },
  {
    "label": "FRAMEPRO_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRAMEPRO_ASSERT(count <= 0xffffff)"
  },
  {
    "label": "FRAMEPRO_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRAMEPRO_ASSERT(duration <= 0xffffffffffL)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(!m_Value.compare_exchange_weak(existing_value, new_value, std::memory_order_relaxed, std::memory_order_relaxed))"
  },
  {
    "label": "GetAndClear()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "GetAndClear(uint64& value, uint& count)"
  },
  {
    "label": "SetNext()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetNext(CustomStatTimer* p_next)"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (mp_Next = p_next ; } CustomStatTimer*)",
    "insertText": "GetNext()"
  },
  {
    "label": "CustomStatTimerScope()",
    "kind": "Method",
    "detail": "Function (} else { mp_Timer = nullptr ; } } ~)",
    "insertText": "CustomStatTimerScope()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (mp_Timer ->)",
    "insertText": "Add((uint)(end_time - m_StartTime))"
  },
  {
    "label": "CustomStatTimerScope()",
    "kind": "Method",
    "detail": "Function (} } private :)",
    "insertText": "CustomStatTimerScope(const CustomStatTimerScope&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CustomStatTimerScope&)",
    "insertText": "operator(const CustomStatTimerScope&)"
  },
  {
    "label": "HiResTimerScope()",
    "kind": "Method",
    "detail": "Function (int64 m_StartTime ; CustomStatTimer* mp_Timer ; } ; class HiResTimerScope { public :)",
    "insertText": "HiResTimerScope(const char* p_name)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_Connected = connected ;)",
    "insertText": "if(connected) FramePro::StartHiResTimer(p_name)"
  },
  {
    "label": "HiResTimerScope()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "HiResTimerScope()"
  },
  {
    "label": "ThreadScope()",
    "kind": "Method",
    "detail": "Function (} private : bool m_Connected ; } ; class ThreadScope { public :)",
    "insertText": "ThreadScope(const char* p_thread_name)"
  },
  {
    "label": "SetThreadName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetThreadName(p_thread_name)"
  },
  {
    "label": "ThreadScope()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ThreadScope()"
  },
  {
    "label": "WaitEventScope()",
    "kind": "Method",
    "detail": "Function (} } ; class WaitEventScope { public :)",
    "insertText": "WaitEventScope(int64 event_id)"
  },
  {
    "label": "WaitEventScope()",
    "kind": "Method",
    "detail": "Function (} else { m_EventId = 0 ; m_StartCore = 0 ; m_StartTime = 0 ; } } ~)",
    "insertText": "WaitEventScope()"
  },
  {
    "label": "AddWaitEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddWaitEvent(m_EventId, m_StartTime, m_StartCore, end_time, FramePro::GetCore())"
  },
  {
    "label": "GetHashAndStackSize()",
    "kind": "Method",
    "detail": "Function (} } private : int64 m_EventId ; int64 m_StartTime ; int m_StartCore ; } ; unsigned int)",
    "insertText": "GetHashAndStackSize(void** p_stack, int& stack_size)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# if FRAMEPRO_X64 const unsigned int prime = 0 x01000193 ; unsigned int hash = prime ; stack_size = 0 ; void** p = p_stack ;)",
    "insertText": "while(*p)"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (uint64)",
    "insertText": "key(uint64)(*p++)"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "key(~key) + (key << 18)"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (key =)",
    "insertText": "key(key >> 31)"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (key = key* 2 1 ; key =)",
    "insertText": "key(key >> 11)"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (key =)",
    "insertText": "key(key << 6)"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (key =)",
    "insertText": "key(key >> 22)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (hash =)",
    "insertText": "hash(unsigned int)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + stack_size ; } return hash ; # else const unsigned int prime = 0 x01000193 ; unsigned int hash = prime ; stack_size = 0 ;)",
    "insertText": "while(p_stack[stack_size])"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "hash(hash * prime) ^ (unsigned int)"
  },
  {
    "label": "Array()",
    "kind": "Method",
    "detail": "Function (+ + stack_size ; } return hash ; # endif } namespace ThreadState { enum Enum { Initialized = 0,Ready,Running,Standby,Terminated,Waiting,Transition,DeferredReady,Reserved1,Reserved2,Reserved3,Reserved4,Reserved5,Reserved6,Reserved7,Reserved8,Reserved9,Reserved10,Reserved11,Reserved12,} ; } namespace ThreadWaitReason { enum Enum { Executive = 0,FreePage,PageIn,PoolAllocation,DelayExecution,Suspended,UserRequest,WrExecutive,WrFreePage,WrPageIn,WrPoolAllocation,WrDelayExecution,WrSuspended,WrUserRequest,WrEventPair,WrQueue,WrLpcReceive,WrLpcReply,WrVirtualMemory,WrPageOut,WrRendezvous,WrKeyedEvent,WrTerminated,WrProcessInSwap,WrCpuRateControl,WrCalloutStack,WrKernel,WrResource,WrPushLock,WrMutex,WrQuantumEnd,WrDispatchInt,WrPreempted,WrYieldExecution,WrFastMutex,WrGuardedMutex,WrRundown,MaximumWaitReason,} ; } struct ContextSwitch { int64 m_Timestamp ; int m_ProcessId ; int m_CPUId ; int m_OldThreadId ; int m_NewThreadId ; ThreadState::Enum m_OldThreadState ; ThreadWaitReason::Enum m_OldThreadWaitReason ; } ; } # include<memory . h> # if FRAMEPRO_ENABLED namespace FramePro { template<T> class Array { public :)",
    "insertText": "Array() : mp_Array(NULL), m_Count(0), m_Capacity(0), mp_Allocator(NULL)"
  },
  {
    "label": "Array()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "Array()"
  },
  {
    "label": "FRAMEPRO_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRAMEPRO_ASSERT(!mp_Array)"
  },
  {
    "label": "GetCount()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetCount()"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (mp_Allocator ->)",
    "insertText": "Free(mp_Array)"
  },
  {
    "label": "ClearNoFree()",
    "kind": "Method",
    "detail": "Function (mp_Array = NULL ; } m_Count = 0 ; m_Capacity = 0 ; } void)",
    "insertText": "ClearNoFree()"
  },
  {
    "label": "SetAllocator()",
    "kind": "Method",
    "detail": "Function (m_Count = 0 ; } void)",
    "insertText": "SetAllocator(Allocator* p_allocator)"
  },
  {
    "label": "FRAMEPRO_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRAMEPRO_ASSERT(mp_Allocator == p_allocator || !(mp_Allocator != NULL && p_allocator != NULL))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (mp_Allocator = p_allocator ; } bool)",
    "insertText": "Add(const T& value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} mp_Array [ m_Count ] = value ; + + m_Count ; return true ; } const T&)",
    "insertText": "operator(int index)"
  },
  {
    "label": "FRAMEPRO_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRAMEPRO_ASSERT(index >= 0 && index < m_Count)"
  },
  {
    "label": "RemoveLast()",
    "kind": "Method",
    "detail": "Function (- - m_Count ; } T)",
    "insertText": "RemoveLast()"
  },
  {
    "label": "FRAMEPRO_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRAMEPRO_ASSERT(m_Count)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int new_capacity = m_Count + count ;)",
    "insertText": "if(new_capacity > m_Capacity)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (m_Capacity = m_Capacity ? 2* m_Capacity : 3 2 ;)",
    "insertText": "while(m_Capacity < new_capacity)"
  },
  {
    "label": "p_new_array()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "p_new_array(T*)mp_Allocator->Alloc(sizeof(T)*m_Capacity)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mp_Array = NULL ; return false ; })",
    "insertText": "if(mp_Array) memcpy(p_new_array, mp_Array, sizeof(T)*m_Count)"
  },
  {
    "label": "Grow()",
    "kind": "Method",
    "detail": "Function (mp_Array = p_new_array ; } m_Count = count ; return true ; } private : bool)",
    "insertText": "Grow()"
  }
]