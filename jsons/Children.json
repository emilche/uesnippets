[
  {
    "label": "FCombinedChildren",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCombinedChildren"
  },
  {
    "label": "FNoChildren",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNoChildren"
  },
  {
    "label": "SWidget",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SWidget"
  },
  {
    "label": "TWeakChild",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TWeakChild"
  },
  {
    "label": "TSingleWidgetChildrenWithSlot",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSingleWidgetChildrenWithSlot"
  },
  {
    "label": "FSlotArguments",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSlotArguments"
  },
  {
    "label": "FSingleWidgetChildrenWithSlot",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSingleWidgetChildrenWithSlot"
  },
  {
    "label": "TSingleWidgetChildrenWithBasicLayoutSlot",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSingleWidgetChildrenWithBasicLayoutSlot"
  },
  {
    "label": "FSingleWidgetChildrenWithBasicLayoutSlot",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSingleWidgetChildrenWithBasicLayoutSlot"
  },
  {
    "label": "TPanelChildren",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPanelChildren"
  },
  {
    "label": "PREDICATE_CLASS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PREDICATE_CLASS"
  },
  {
    "label": "FScopedWidgetSlotArguments",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FScopedWidgetSlotArguments"
  },
  {
    "label": "TPanelChildrenConstIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPanelChildrenConstIterator"
  },
  {
    "label": "TSlotlessChildren",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSlotlessChildren"
  },
  {
    "label": "TOneDynamicChild",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TOneDynamicChild"
  },
  {
    "label": "AddChildren()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Widgets / SNullWidget . h \" # include \" SlotBase . h \" # include \" Layout / ChildrenBase . h \" # include \" Layout / BasicLayoutWidgetSlot . h \" # include \" Widgets / SWidget . h \" class FCombinedChildren final : public FChildren { public : using FChildren::FChildren ; void)",
    "insertText": "AddChildren(FChildren& InLinkedChildren)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (LinkedChildren .)",
    "insertText": "Add(&InLinkedChildren)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Num()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 TotalNum = 0 ;)",
    "insertText": "for(const FChildren* Children : LinkedChildren)"
  },
  {
    "label": "GetChildAt()",
    "kind": "Method",
    "detail": "Function (} return TotalNum ; } TSharedRef<SWidget>)",
    "insertText": "GetChildAt(int32 Index)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 TotalNum = 0 ;)",
    "insertText": "for(FChildren* Children : LinkedChildren)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} TotalNum = NewTotal ; })",
    "insertText": "check(false)"
  },
  {
    "label": "NumSlot()",
    "kind": "Method",
    "detail": "Function (TotalNum + = Children ->)",
    "insertText": "NumSlot()"
  },
  {
    "label": "GetSlotAt()",
    "kind": "Method",
    "detail": "Function (} return TotalNum ; } const FSlotBase&)",
    "insertText": "GetSlotAt(int32 ChildIndex)"
  },
  {
    "label": "GetChildRefAt()",
    "kind": "Method",
    "detail": "Function (FSlotBase NullSlot ; return NullSlot ; } FWidgetRef)",
    "insertText": "GetChildRefAt(int32 Index)"
  },
  {
    "label": "FNoChildren()",
    "kind": "Method",
    "detail": "Function (} protected : TArray<FChildren*> LinkedChildren ; } ; class FNoChildren final : public FChildren { public : FNoChildren NoChildrenInstance ; public :)",
    "insertText": "FNoChildren(SWidget* InOwner) : FChildren(InOwner)"
  },
  {
    "label": "FNoChildren()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FNoChildren(SWidget* InOwner, FName InName) : FChildren(InOwner, InName)"
  },
  {
    "label": "GetChildAt()",
    "kind": "Method",
    "detail": "Function (} TSharedRef<SWidget>)",
    "insertText": "GetChildAt(int32 ChildIndex)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (FSlotBase NullSlot ;)",
    "insertText": "check(ChildIndex == 0)"
  },
  {
    "label": "Pin()",
    "kind": "Method",
    "detail": "Function (TSharedPtr<SWidget> Widget = WidgetPtr .)",
    "insertText": "Pin()"
  },
  {
    "label": "GetChildRefAt()",
    "kind": "Method",
    "detail": "Function (} FConstWidgetRef)",
    "insertText": "GetChildRefAt(int32 ChildIndex)"
  },
  {
    "label": "AttachWidget()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "AttachWidget(const TSharedPtr<SWidget>& InWidget)"
  },
  {
    "label": "GetOwner()",
    "kind": "Method",
    "detail": "Function (WidgetPtr = InWidget ;)",
    "insertText": "GetOwner().Invalidate(EInvalidateWidgetReason::ChildOrder)"
  },
  {
    "label": "AssignParentWidget()",
    "kind": "Method",
    "detail": "Function (InWidget ->)",
    "insertText": "AssignParentWidget(GetOwner().AsShared())"
  },
  {
    "label": "DetachWidget()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "DetachWidget()"
  },
  {
    "label": "ConditionallyDetatchParentWidget()",
    "kind": "Method",
    "detail": "Function (Widget ->)",
    "insertText": "ConditionallyDetatchParentWidget(&GetOwner())"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} WidgetPtr .)",
    "insertText": "Reset()"
  },
  {
    "label": "GetWidget()",
    "kind": "Method",
    "detail": "Function (} } TSharedRef<SWidget>)",
    "insertText": "GetWidget()"
  },
  {
    "label": "TSingleWidgetChildrenWithSlot()",
    "kind": "Method",
    "detail": "Function (} private : TWeakPtr<ChildType> WidgetPtr ; } ; template<SlotType> class TSingleWidgetChildrenWithSlot : public FChildren,protected TSlotBase<SlotType> { public :)",
    "insertText": "TSingleWidgetChildrenWithSlot(SWidget* InOwner) : FChildren(InOwner) , TSlotBase<SlotType>(static_cast<const FChildren&>(*this))"
  },
  {
    "label": "TSingleWidgetChildrenWithSlot()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSingleWidgetChildrenWithSlot(SWidget* InOwner, FName InName) : FChildren(InOwner, InName) , TSlotBase<SlotType>(static_cast<const FChildren&>(*this))"
  },
  {
    "label": "TSingleWidgetChildrenWithSlot()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSingleWidgetChildrenWithSlot(std::nullptr_t)"
  },
  {
    "label": "FSlotArguments()",
    "kind": "Method",
    "detail": "Function (} public : struct FSlotArguments : protected TSlotBase<SlotType>::FSlotArguments {)",
    "insertText": "FSlotArguments() : TSlotBase<SlotType>::FSlotArguments(TSlotBase<SlotType>::ConstructSlotIsFChildren)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TSingleWidgetChildrenWithSlot ; SlotType::FSlotArguments&)",
    "insertText": "operator(const TSharedRef<SWidget>& InChildWidget)"
  },
  {
    "label": "AttachWidget()",
    "kind": "Method",
    "detail": "Function (TSlotBase<SlotType>::)",
    "insertText": "AttachWidget(InChildWidget)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (} } ; void)",
    "insertText": "Construct(FSlotArguments&& InArgs)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (TSlotBase<SlotType)",
    "insertText": "Construct(*this, MoveTemp(InArgs))"
  },
  {
    "label": "AsSlot()",
    "kind": "Method",
    "detail": "Function (} public : TSlotBase<SlotType>&)",
    "insertText": "AsSlot()"
  },
  {
    "label": "Expose()",
    "kind": "Method",
    "detail": "Function (} SlotType&)",
    "insertText": "Expose(SlotType*& OutVarToInit)"
  },
  {
    "label": "SlotType()",
    "kind": "Method",
    "detail": "Function (OutVarToInit = static_cast<)",
    "insertText": "SlotType(this)"
  },
  {
    "label": "TSingleWidgetChildrenWithBasicLayoutSlot()",
    "kind": "Method",
    "detail": "Function (} } ; class FSingleWidgetChildrenWithSlot final : public TSingleWidgetChildrenWithSlot<FSingleWidgetChildrenWithSlot> { public : using TSingleWidgetChildrenWithSlot<FSingleWidgetChildrenWithSlot>::TSingleWidgetChildrenWithSlot ; } ; template<EInvalidateWidgetReason InPaddingInvalidationReason = EInvalidateWidgetReason::Layout> class TSingleWidgetChildrenWithBasicLayoutSlot : public TSingleWidgetChildrenWithSlot<TSingleWidgetChildrenWithBasicLayoutSlot<InPaddingInvalidationReason>>,public TPaddingSingleWidgetSlotMixin<TSingleWidgetChildrenWithBasicLayoutSlot<InPaddingInvalidationReason>,InPaddingInvalidationReason>,public TAlignmentSingleWidgetSlotMixin<TSingleWidgetChildrenWithBasicLayoutSlot<InPaddingInvalidationReason>> { private : using ParentType = TSingleWidgetChildrenWithSlot<TSingleWidgetChildrenWithBasicLayoutSlot<InPaddingInvalidationReason>> ; using PaddingMixinType = TPaddingSingleWidgetSlotMixin<TSingleWidgetChildrenWithBasicLayoutSlot<InPaddingInvalidationReason>,InPaddingInvalidationReason> ; using AlignmentMixinType = TAlignmentSingleWidgetSlotMixin<TSingleWidgetChildrenWithBasicLayoutSlot<InPaddingInvalidationReason>> ; public : template<WidgetType,V = std::enable_if<std::is_base_of<SWidget,WidgetType>::value>::type>)",
    "insertText": "TSingleWidgetChildrenWithBasicLayoutSlot(WidgetType* InOwner) : ParentType(InOwner) , PaddingMixinType(*InOwner) , AlignmentMixinType(*InOwner, HAlign_Fill, VAlign_Fill)"
  },
  {
    "label": "TSingleWidgetChildrenWithBasicLayoutSlot()",
    "kind": "Method",
    "detail": "Function (} template<WidgetType,V = std::enable_if<std::is_base_of<SWidget,WidgetType>::value>::type>)",
    "insertText": "TSingleWidgetChildrenWithBasicLayoutSlot(WidgetType* InOwner, const EHorizontalAlignment InHAlign, const EVerticalAlignment InVAlign) : ParentType(InOwner) , PaddingMixinType(*InOwner) , AlignmentMixinType(*InOwner, InHAlign, InVAlign)"
  },
  {
    "label": "TSingleWidgetChildrenWithBasicLayoutSlot()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSingleWidgetChildrenWithBasicLayoutSlot(std::nullptr_t)"
  },
  {
    "label": "TSingleWidgetChildrenWithBasicLayoutSlot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TSingleWidgetChildrenWithBasicLayoutSlot(std::nullptr_t, const EHorizontalAlignment InHAlign, const EVerticalAlignment InVAlign)"
  },
  {
    "label": "SLATE_SLOT_BEGIN_ARGS_TwoMixins()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "SLATE_SLOT_BEGIN_ARGS_TwoMixins(TSingleWidgetChildrenWithBasicLayoutSlot, ParentType, PaddingMixinType, AlignmentMixinType) SLATE_SLOT_END_ARGS() void Construct(FSlotArguments&& InArgs)"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Construct(MoveTemp(InArgs))"
  },
  {
    "label": "ConstructMixin()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ConstructMixin(MoveTemp(InArgs))"
  },
  {
    "label": "SupportSlotWithSlateAttribute()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "SupportSlotWithSlateAttribute()"
  },
  {
    "label": "StealSlot()",
    "kind": "Method",
    "detail": "Function (TUniquePtr<SlotType> NewSlot = SlotArgument .)",
    "insertText": "StealSlot()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (int32 Result = Children .)",
    "insertText": "Add(MoveTemp(NewSlot))"
  },
  {
    "label": "Construct()",
    "kind": "Method",
    "detail": "Function (Children [ Result ] ->)",
    "insertText": "Construct(*this, MoveTemp(SlotArgument))"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "Reserve(Children.Num() + SlotArguments.Num())"
  },
  {
    "label": "AddSlot()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddSlot(MoveTemp(Arg))"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RemoveAt(int32 Index)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (TUniquePtr<SlotType> SlotToRemove =)",
    "insertText": "MoveTemp(Children[Index])"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "RemoveAt(Index)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Remove(const TSharedRef<SWidget>& SlotWidget)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "RemoveAt(SlotIdx)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (TArray<TUniquePtr<SlotType>> ChildrenCopy =)",
    "insertText": "MoveTemp(Children)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "Empty()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (ChildrenCopy .)",
    "insertText": "Empty(Slack)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (Children =)",
    "insertText": "MoveTemp(ChildrenCopy)"
  },
  {
    "label": "InsertSlot()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InsertSlot(typename SlotType::FSlotArguments&& SlotArgument, int32 Index)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "Insert(MoveTemp(NewSlot), Index)"
  },
  {
    "label": "Move()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Move(int32 IndexToMove, int32 IndexToDestination)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function ({ TUniquePtr<SlotType> SlotToMove =)",
    "insertText": "MoveTemp(Children[IndexToMove])"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "RemoveAt(IndexToMove)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "Insert(MoveTemp(SlotToMove), IndexToDestination)"
  },
  {
    "label": "RequestSortAttribute()",
    "kind": "Method",
    "detail": "Function (Children [ 0 ] ->)",
    "insertText": "RequestSortAttribute()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reserve(int32 NumToReserve)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "Reserve(NumToReserve)"
  },
  {
    "label": "IsValidIndex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValidIndex(int32 Index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const SlotType&)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "Sort([&Predicate](const TUniquePtr<SlotType>& One, const TUniquePtr<SlotType>& Two) { return Predicate(*One, *Two); })"
  },
  {
    "label": "StableSort()",
    "kind": "Method",
    "detail": "Function (} } template<class PREDICATE_CLASS> void)",
    "insertText": "StableSort(const PREDICATE_CLASS& Predicate)"
  },
  {
    "label": "StableSort()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "StableSort([&Predicate](const TUniquePtr<SlotType>& One, const TUniquePtr<SlotType>& Two) { return Predicate(*One, *Two); })"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "Swap(int32 IndexA, int32 IndexB)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "Swap(IndexA, IndexB)"
  },
  {
    "label": "FScopedWidgetSlotArguments()",
    "kind": "Method",
    "detail": "Function (} public : struct FScopedWidgetSlotArguments final : public SlotType::FSlotArguments { public :)",
    "insertText": "FScopedWidgetSlotArguments(TUniquePtr<SlotType> InSlot, TPanelChildren<SlotType>& InChildren, int32 InIndex) : SlotType::FSlotArguments(MoveTemp(InSlot)) , Children(InChildren) , Index(InIndex)"
  },
  {
    "label": "FScopedWidgetSlotArguments()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FScopedWidgetSlotArguments(TUniquePtr<SlotType> InSlot, TPanelChildren<SlotType>& InChildren, int32 InIndex, TFunction<void(const SlotType*, int32)> OnAdded) : SlotType::FSlotArguments(MoveTemp(InSlot)) , Children(InChildren) , Index(InIndex) , Added(OnAdded)"
  },
  {
    "label": "FScopedWidgetSlotArguments()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FScopedWidgetSlotArguments(const FScopedWidgetSlotArguments&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FScopedWidgetSlotArguments&)",
    "insertText": "operator(const FScopedWidgetSlotArguments&)"
  },
  {
    "label": "FScopedWidgetSlotArguments()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FScopedWidgetSlotArguments(FScopedWidgetSlotArguments&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FScopedWidgetSlotArguments&)",
    "insertText": "operator(FScopedWidgetSlotArguments&&)"
  },
  {
    "label": "FScopedWidgetSlotArguments()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FScopedWidgetSlotArguments()"
  },
  {
    "label": "AddSlot()",
    "kind": "Method",
    "detail": "Function (Index = Children .)",
    "insertText": "AddSlot(MoveTemp(*this))"
  },
  {
    "label": "InsertSlot()",
    "kind": "Method",
    "detail": "Function (} else { Children .)",
    "insertText": "InsertSlot(MoveTemp(*this), Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Added)"
  },
  {
    "label": "Added()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Added(SlotPtr, Index)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} } } private : TPanelChildren<SlotType>& Children ; int32 Index ; TFunction<)",
    "insertText": "void(const SlotType*, int32)"
  },
  {
    "label": "TPanelChildrenConstIterator()",
    "kind": "Method",
    "detail": "Function (} ; } ; template<SlotType> class TPanelChildrenConstIterator { public :)",
    "insertText": "TPanelChildrenConstIterator(const TPanelChildren<SlotType>& InContainer, EFlowDirection InLayoutFlow) : Container(InContainer) , LayoutFlow(InLayoutFlow)"
  },
  {
    "label": "TPanelChildrenConstIterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TPanelChildrenConstIterator(const TPanelChildren<SlotType>& InContainer, EOrientation InOrientation, EFlowDirection InLayoutFlow) : Container(InContainer) , LayoutFlow(InOrientation == Orient_Vertical ? EFlowDirection::LeftToRight : InLayoutFlow)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TPanelChildrenConstIterator<SlotType>&)",
    "insertText": "operator()"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetIndex()"
  },
  {
    "label": "SetToEnd()",
    "kind": "Method",
    "detail": "Function (break ; } } void)",
    "insertText": "SetToEnd()"
  },
  {
    "label": "TSlotlessChildren()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "TSlotlessChildren(SWidget* InOwner, bool InbChangesInvalidatePrepass = true) : FChildren(InOwner) , bChangesInvalidatePrepass(InbChangesInvalidatePrepass)"
  },
  {
    "label": "TSlotlessChildren()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TSlotlessChildren(std::nullptr_t, bool InbChangesInvalidatePrepass = true)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} int32 Index = Children .)",
    "insertText": "Add(Child)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} return Index ; } void)",
    "insertText": "Reset(int32 NewSize = 0)"
  },
  {
    "label": "GetChildAt()",
    "kind": "Method",
    "detail": "Function (TSharedRef<SWidget> Child =)",
    "insertText": "GetChildAt(ChildIndex)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (ChildrenCopy .)",
    "insertText": "Reset(NewSize)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Empty(int32 Slack = 0)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Insert(const TSharedRef<ChildType>& Child, int32 Index)"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (} Children .)",
    "insertText": "Insert(Child, Index)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} } int32)",
    "insertText": "Remove(const TSharedRef<ChildType>& Child)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} return Children .)",
    "insertText": "Remove(Child)"
  },
  {
    "label": "GetChildAt()",
    "kind": "Method",
    "detail": "Function (TSharedRef<SWidget> Child =)",
    "insertText": "GetChildAt(Index)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Find(const TSharedRef<ChildType>& Item)"
  },
  {
    "label": "AsArrayCopy()",
    "kind": "Method",
    "detail": "Function (} TArray<TSharedRef<ChildType>>)",
    "insertText": "AsArrayCopy()"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "Sort(Predicate)"
  },
  {
    "label": "TOneDynamicChild()",
    "kind": "Method",
    "detail": "Function (} } private : bool bChangesInvalidatePrepass ; } ; template<SlotType> class TOneDynamicChild final : public FChildren { public :)",
    "insertText": "TOneDynamicChild(SWidget* InOwner, TPanelChildren<SlotType>* InAllChildren, const TAttribute<int32>* InWidgetIndex) : FChildren(InOwner) , AllChildren(InAllChildren) , WidgetIndex(InWidgetIndex)"
  },
  {
    "label": "TOneDynamicChild()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TOneDynamicChild(SWidget* InOwner, TPanelChildren<SlotType>* InAllChildren, std::nullptr_t)"
  },
  {
    "label": "TOneDynamicChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TOneDynamicChild(SWidget* InOwner, std::nullptr_t, const TAttribute<int32>* InWidgetIndex)"
  },
  {
    "label": "TOneDynamicChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TOneDynamicChild(SWidget* InOwner, std::nullptr_t, std::nullptr_t)"
  },
  {
    "label": "TOneDynamicChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TOneDynamicChild(std::nullptr_t, TPanelChildren<SlotType>* InAllChildren, std::nullptr_t)"
  },
  {
    "label": "TOneDynamicChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TOneDynamicChild(std::nullptr_t, std::nullptr_t, const TAttribute<int32>* InWidgetIndex)"
  },
  {
    "label": "TOneDynamicChild()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TOneDynamicChild(std::nullptr_t, std::nullptr_t, std::nullptr_t)"
  }
]