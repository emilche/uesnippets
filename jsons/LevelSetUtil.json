[
  {
    "label": "GridType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GridType"
  },
  {
    "label": "GridOrTreeType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GridOrTreeType"
  },
  {
    "label": "MaskInteriorVoxels",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskInteriorVoxels"
  },
  {
    "label": "MaskInteriorTiles",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskInteriorTiles"
  },
  {
    "label": "PopulateTree",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PopulateTree"
  },
  {
    "label": "LabelBoundaryVoxels",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LabelBoundaryVoxels"
  },
  {
    "label": "FlipRegionSign",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FlipRegionSign"
  },
  {
    "label": "FindMinVoxelValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FindMinVoxelValue"
  },
  {
    "label": "FindMinTileValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FindMinTileValue"
  },
  {
    "label": "SDFVoxelsToFogVolume",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SDFVoxelsToFogVolume"
  },
  {
    "label": "SDFTilesToFogVolume",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SDFTilesToFogVolume"
  },
  {
    "label": "FillMaskBoundary",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FillMaskBoundary"
  },
  {
    "label": "TreeType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TreeType"
  },
  {
    "label": "MaskIsovalueCrossingVoxels",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskIsovalueCrossingVoxels"
  },
  {
    "label": "NodeMaskSegment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NodeMaskSegment"
  },
  {
    "label": "SegmentNodeMask",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SegmentNodeMask"
  },
  {
    "label": "ConnectNodeMaskSegments",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ConnectNodeMaskSegments"
  },
  {
    "label": "MaskSegmentGroup",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskSegmentGroup"
  },
  {
    "label": "ExpandLeafNodeRegion",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpandLeafNodeRegion"
  },
  {
    "label": "FillLeafNodeVoxels",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FillLeafNodeVoxels"
  },
  {
    "label": "ExpandNarrowbandMask",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ExpandNarrowbandMask"
  },
  {
    "label": "FloodFillSign",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FloodFillSign"
  },
  {
    "label": "MaskedCopy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskedCopy"
  },
  {
    "label": "Copy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Copy"
  },
  {
    "label": "ComputeActiveVoxelCount",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ComputeActiveVoxelCount"
  },
  {
    "label": "GreaterCount",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GreaterCount"
  },
  {
    "label": "GridOrTreeConstructor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GridOrTreeConstructor"
  },
  {
    "label": "lsutilGridMax()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TOOLS_LEVEL_SET_UTIL_HAS_BEEN_INCLUDED # define OPENVDB_TOOLS_LEVEL_SET_UTIL_HAS_BEEN_INCLUDED # include \" MeshToVolume . h \" # include \" SignedFloodFill . h \" # include<openvdb / Types . h> # include<openvdb / Grid . h> # include<tbb / blocked_range . h> # include<tbb / parallel_for . h> # include<tbb / parallel_reduce . h> # include<tbb / parallel_sort . h> # include<algorithm> # include<cmath> # include<cstdlib> # include<deque> # include<limits> # include<memory> # include<set> # include<vector> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tools { namespace { template<GridType> GridType::ValueType)",
    "insertText": "lsutilGridMax()"
  },
  {
    "label": "lsutilGridZero()",
    "kind": "Method",
    "detail": "Function (} template<GridType> GridType::ValueType)",
    "insertText": "lsutilGridZero()"
  },
  {
    "label": "sdfToFogVolume()",
    "kind": "Method",
    "detail": "Function (} } template<class GridType> void)",
    "insertText": "sdfToFogVolume(GridType& grid, typename GridType::ValueType cutoffDistance = lsutilGridMax<GridType>())"
  },
  {
    "label": "sdfInteriorMask()",
    "kind": "Method",
    "detail": "Function (template<class GridOrTreeType> GridOrTreeType::template ValueConverter<bool>::Type::Ptr)",
    "insertText": "sdfInteriorMask(const GridOrTreeType& volume, typename GridOrTreeType::ValueType isovalue = lsutilGridZero<GridOrTreeType>())"
  },
  {
    "label": "extractEnclosedRegion()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeType> GridOrTreeType::template ValueConverter<bool>::Type::Ptr)",
    "insertText": "extractEnclosedRegion(const GridOrTreeType& volume, typename GridOrTreeType::ValueType isovalue = lsutilGridZero<GridOrTreeType>(), const typename TreeAdapter<GridOrTreeType>::TreeType::template ValueConverter<bool>::Type* fillMask = nullptr)"
  },
  {
    "label": "extractIsosurfaceMask()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeType> GridOrTreeType::template ValueConverter<bool>::Type::Ptr)",
    "insertText": "extractIsosurfaceMask(const GridOrTreeType& volume, typename GridOrTreeType::ValueType isovalue)"
  },
  {
    "label": "extractActiveVoxelSegmentMasks()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeType> void)",
    "insertText": "extractActiveVoxelSegmentMasks(const GridOrTreeType& volume, std::vector<typename GridOrTreeType::template ValueConverter<bool>::Type::Ptr>& masks)"
  },
  {
    "label": "segmentActiveVoxels()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeType> void)",
    "insertText": "segmentActiveVoxels(const GridOrTreeType& volume, std::vector<typename GridOrTreeType::Ptr>& segments)"
  },
  {
    "label": "segmentSDF()",
    "kind": "Method",
    "detail": "Function (template<GridOrTreeType> void)",
    "insertText": "segmentSDF(const GridOrTreeType& volume, std::vector<typename GridOrTreeType::Ptr>& segments)"
  },
  {
    "label": "MaskInteriorVoxels()",
    "kind": "Method",
    "detail": "Function (namespace level_set_util_internal { template<LeafNodeType> struct MaskInteriorVoxels { using ValueType = LeafNodeType::ValueType ; using BoolLeafNodeType = tree::LeafNode<bool,LeafNodeType::LOG2DIM> ;)",
    "insertText": "MaskInteriorVoxels(ValueType isovalue, const LeafNodeType ** nodes, BoolLeafNodeType ** maskNodes) : mNodes(nodes), mMaskNodes(maskNodes), mIsovalue(isovalue)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const tbb::blocked_range<size_t>& range)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (BoolLeafNodeType* maskNodePt = nullptr ;)",
    "insertText": "for(size_t n = range.begin(), N = range.end(); n < N; ++n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mMaskNodes [ n ] = nullptr ; const LeafNodeType& node =* mNodes [ n ] ;)",
    "insertText": "if(!maskNodePt)"
  },
  {
    "label": "BoolLeafNodeType()",
    "kind": "Method",
    "detail": "Function (maskNodePt = new)",
    "insertText": "BoolLeafNodeType(node.origin(), false)"
  },
  {
    "label": "setOrigin()",
    "kind": "Method",
    "detail": "Function (} else { maskNodePt ->)",
    "insertText": "setOrigin(node.origin())"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} const ValueType* values =& node .)",
    "insertText": "getValue(0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(maskNodePt->onVoxelCount() > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mMaskNodes [ n ] = maskNodePt ; maskNodePt = nullptr ; } })",
    "insertText": "if(maskNodePt)"
  },
  {
    "label": "MaskInteriorTiles()",
    "kind": "Method",
    "detail": "Function (} LeafNodeType const* const* const mNodes ; BoolLeafNodeType** const mMaskNodes ; ValueType const mIsovalue ; } ; template<TreeType,InternalNodeType> struct MaskInteriorTiles { using ValueType = TreeType::ValueType ;)",
    "insertText": "MaskInteriorTiles(ValueType isovalue, const TreeType& tree, InternalNodeType ** maskNodes) : mTree(&tree), mMaskNodes(maskNodes), mIsovalue(isovalue)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const TreeType>)",
    "insertText": "acc(*mTree)"
  },
  {
    "label": "beginValueAll()",
    "kind": "Method",
    "detail": "Function (InternalNodeType::ValueAllIter it = mMaskNodes [ n ] ->)",
    "insertText": "beginValueAll()"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (it .)",
    "insertText": "setValue(true)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (it .)",
    "insertText": "setValueOn(true)"
  },
  {
    "label": "PopulateTree()",
    "kind": "Method",
    "detail": "Function (} } } } TreeType const* const mTree ; InternalNodeType** const mMaskNodes ; ValueType const mIsovalue ; } ; template<TreeType> struct PopulateTree { using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ;)",
    "insertText": "PopulateTree(TreeType& tree, LeafNodeType** leafnodes, const size_t * nodexIndexMap, ValueType background) : mNewTree(background) , mTreePt(&tree) , mNodes(leafnodes) , mNodeIndexMap(nodexIndexMap)"
  },
  {
    "label": "PopulateTree()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PopulateTree(PopulateTree& rhs, tbb::split) : mNewTree(rhs.mNewTree.background()) , mTreePt(&mNewTree) , mNodes(rhs.mNodes) , mNodeIndexMap(rhs.mNodeIndexMap)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<TreeType>)",
    "insertText": "acc(*mTreePt)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (acc .)",
    "insertText": "addLeaf(mNodes[n])"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "join(PopulateTree& rhs)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (mTreePt ->)",
    "insertText": "merge(*rhs.mTreePt)"
  },
  {
    "label": "LabelBoundaryVoxels()",
    "kind": "Method",
    "detail": "Function (} private : TreeType mNewTree ; TreeType* const mTreePt ; LeafNodeType** const mNodes ; size_t const* const mNodeIndexMap ; } ; template<LeafNodeType> struct LabelBoundaryVoxels { using ValueType = LeafNodeType::ValueType ; using CharLeafNodeType = tree::LeafNode<char,LeafNodeType::LOG2DIM> ;)",
    "insertText": "LabelBoundaryVoxels(ValueType isovalue, const LeafNodeType ** nodes, CharLeafNodeType ** maskNodes) : mNodes(nodes), mMaskNodes(maskNodes), mIsovalue(isovalue)"
  },
  {
    "label": "CharLeafNodeType()",
    "kind": "Method",
    "detail": "Function (maskNodePt = new)",
    "insertText": "CharLeafNodeType(node.origin(), 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} LeafNodeType::ValueOnCIter it ;)",
    "insertText": "for(it = node.cbeginValueOn(); it; ++it)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (maskNodePt ->)",
    "insertText": "setValueOn(it.pos(), ((*it - mIsovalue) < 0.0) ? 0 : 1)"
  },
  {
    "label": "FlipRegionSign()",
    "kind": "Method",
    "detail": "Function (} LeafNodeType const* const* const mNodes ; CharLeafNodeType** const mMaskNodes ; ValueType const mIsovalue ; } ; template<LeafNodeType> struct FlipRegionSign { using ValueType = LeafNodeType::ValueType ;)",
    "insertText": "FlipRegionSign(LeafNodeType ** nodes) : mNodes(nodes)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (ValueType* values = const_cast<)",
    "insertText": "ValueType(&mNodes[n]->getValue(0))"
  },
  {
    "label": "FindMinVoxelValue()",
    "kind": "Method",
    "detail": "Function (values [ i ] = values [ i ]<0 ? 1 : - 1 ; } } } LeafNodeType** const mNodes ; } ; template<LeafNodeType> struct FindMinVoxelValue { using ValueType = LeafNodeType::ValueType ;)",
    "insertText": "FindMinVoxelValue(LeafNodeType const * const * const leafnodes) : minValue(std::numeric_limits<ValueType>::max()) , mNodes(leafnodes)"
  },
  {
    "label": "FindMinVoxelValue()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FindMinVoxelValue(FindMinVoxelValue& rhs, tbb::split) : minValue(std::numeric_limits<ValueType>::max()) , mNodes(rhs.mNodes)"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (const ValueType* data = mNodes [ n ] ->)",
    "insertText": "buffer().data()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (minValue =)",
    "insertText": "min(minValue, data[i])"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "join(FindMinVoxelValue& rhs)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (minValue =)",
    "insertText": "min(minValue, rhs.minValue)"
  },
  {
    "label": "FindMinTileValue()",
    "kind": "Method",
    "detail": "Function (} ValueType minValue ; LeafNodeType const* const* const mNodes ; } ; template<InternalNodeType> struct FindMinTileValue { using ValueType = InternalNodeType::ValueType ;)",
    "insertText": "FindMinTileValue(InternalNodeType const * const * const nodes) : minValue(std::numeric_limits<ValueType>::max()) , mNodes(nodes)"
  },
  {
    "label": "FindMinTileValue()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FindMinTileValue(FindMinTileValue& rhs, tbb::split) : minValue(std::numeric_limits<ValueType>::max()) , mNodes(rhs.mNodes)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (minValue =)",
    "insertText": "min(minValue, *it)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "join(FindMinTileValue& rhs)"
  },
  {
    "label": "SDFVoxelsToFogVolume()",
    "kind": "Method",
    "detail": "Function (} ValueType minValue ; InternalNodeType const* const* const mNodes ; } ; template<LeafNodeType> struct SDFVoxelsToFogVolume { using ValueType = LeafNodeType::ValueType ;)",
    "insertText": "SDFVoxelsToFogVolume(LeafNodeType ** nodes, ValueType cutoffDistance) : mNodes(nodes), mWeight(ValueType(1.0) / cutoffDistance)"
  },
  {
    "label": "setValuesOff()",
    "kind": "Method",
    "detail": "Function (LeafNodeType& node =* mNodes [ n ] ; node .)",
    "insertText": "setValuesOff()"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (values [ i ] = values [ i ]>)",
    "insertText": "ValueType(0.0) ? ValueType(0.0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(node.onVoxelCount() == 0)"
  },
  {
    "label": "SDFTilesToFogVolume()",
    "kind": "Method",
    "detail": "Function (delete mNodes [ n ] ; mNodes [ n ] = nullptr ; } } } LeafNodeType** const mNodes ; ValueType const mWeight ; } ; template<TreeType,InternalNodeType> struct SDFTilesToFogVolume {)",
    "insertText": "SDFTilesToFogVolume(const TreeType& tree, InternalNodeType ** nodes) : mTree(&tree), mNodes(nodes)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (it .)",
    "insertText": "setValue(ValueType(1.0))"
  },
  {
    "label": "FillMaskBoundary()",
    "kind": "Method",
    "detail": "Function (} } } } TreeType const* const mTree ; InternalNodeType** const mNodes ; } ; template<TreeType> struct FillMaskBoundary { using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ; using BoolTreeType = TreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ;)",
    "insertText": "FillMaskBoundary(const TreeType& tree, ValueType isovalue, const BoolTreeType& fillMask, const BoolLeafNodeType ** fillNodes, BoolLeafNodeType ** newNodes) : mTree(&tree) , mFillMask(&fillMask) , mFillNodes(fillNodes) , mNewNodes(newNodes) , mIsovalue(isovalue)"
  },
  {
    "label": "maskAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const BoolTreeType>)",
    "insertText": "maskAcc(*mFillMask)"
  },
  {
    "label": "distAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const TreeType>)",
    "insertText": "distAcc(*mTree)"
  },
  {
    "label": "valueMask()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<char [ ]>)",
    "insertText": "valueMask(new char[BoolLeafNodeType::SIZE])"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (mNewNodes [ n ] = nullptr ; const BoolLeafNodeType& node =* mFillNodes [ n ] ; const Coord& origin = node .)",
    "insertText": "origin()"
  },
  {
    "label": "isDense()",
    "kind": "Method",
    "detail": "Function (const bool denseNode = node .)",
    "insertText": "isDense()"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (int denseNeighbors = 0 ; const BoolLeafNodeType* neighborNode = maskAcc .)",
    "insertText": "probeConstLeaf(origin.offsetBy(-1, 0, 0))"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (neighborNode = maskAcc .)",
    "insertText": "probeConstLeaf(origin.offsetBy(BoolLeafNodeType::DIM, 0, 0))"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (neighborNode = maskAcc .)",
    "insertText": "probeConstLeaf(origin.offsetBy(0, -1, 0))"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (neighborNode = maskAcc .)",
    "insertText": "probeConstLeaf(origin.offsetBy(0, BoolLeafNodeType::DIM, 0))"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (neighborNode = maskAcc .)",
    "insertText": "probeConstLeaf(origin.offsetBy(0, 0, -1))"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (neighborNode = maskAcc .)",
    "insertText": "probeConstLeaf(origin.offsetBy(0, 0, BoolLeafNodeType::DIM))"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "memset(valueMask.get(), 0, sizeof(char) * BoolLeafNodeType::SIZE)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (const TreeType::LeafNodeType* distNode = distAcc .)",
    "insertText": "probeConstLeaf(origin)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool earlyTermination = false ;)",
    "insertText": "if(!denseNode)"
  },
  {
    "label": "evalInternalNeighborsP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalInternalNeighborsP(valueMask.get(), node, *distNode)"
  },
  {
    "label": "evalInternalNeighborsN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalInternalNeighborsN(valueMask.get(), node, *distNode)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(distAcc.getValue(origin) > mIsovalue)"
  },
  {
    "label": "evalInternalNeighborsP()",
    "kind": "Method",
    "detail": "Function (earlyTermination =)",
    "insertText": "evalInternalNeighborsP(valueMask.get(), node)"
  },
  {
    "label": "evalInternalNeighborsN()",
    "kind": "Method",
    "detail": "Function (earlyTermination =)",
    "insertText": "evalInternalNeighborsN(valueMask.get(), node)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(!earlyTermination)"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (evalExternalNeighborsX<)",
    "insertText": "true(valueMask.get(), node, maskAcc, distAcc)"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (evalExternalNeighborsX<)",
    "insertText": "false(valueMask.get(), node, maskAcc, distAcc)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} int numBoundaryValues = 0 ;)",
    "insertText": "for(Index i = 0, I = BoolLeafNodeType::SIZE; i < I; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (numBoundaryValues + = valueMask [ i ] = = 1 ; })",
    "insertText": "if(numBoundaryValues > 0)"
  },
  {
    "label": "BoolLeafNodeType()",
    "kind": "Method",
    "detail": "Function (mNewNodes [ n ] = new)",
    "insertText": "BoolLeafNodeType(origin, false)"
  },
  {
    "label": "evalInternalNeighborsP()",
    "kind": "Method",
    "detail": "Function (} } } } private : void)",
    "insertText": "evalInternalNeighborsP(char* valueMask, const BoolLeafNodeType& node, const LeafNodeType& distNode)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (const Index xPos =)",
    "insertText": "x(2 * BoolLeafNodeType::LOG2DIM)"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (const Index yPos =)",
    "insertText": "xPos(y << BoolLeafNodeType::LOG2DIM)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index pos = yPos + z ;)",
    "insertText": "if(valueMask[pos] != 0 || !node.isValueOn(pos))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (valueMask [ pos ] = 1 ; } } } })",
    "insertText": "for(Index x = 0; x < BoolLeafNodeType::DIM; ++x)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (valueMask [ pos ] = 1 ; } } } })",
    "insertText": "for(Index x = 0; x < BoolLeafNodeType::DIM - 1; ++x)"
  },
  {
    "label": "evalInternalNeighborsP()",
    "kind": "Method",
    "detail": "Function (valueMask [ pos ] = 1 ; } } } } } bool)",
    "insertText": "evalInternalNeighborsP(char* valueMask, const BoolLeafNodeType& node)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index pos = yPos + z ;)",
    "insertText": "if(node.isValueOn(pos) && !node.isValueOn(pos + 1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index pos = yPos + z ;)",
    "insertText": "if(node.isValueOn(pos) && !node.isValueOn(pos + BoolLeafNodeType::DIM))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index pos = yPos + z ;)",
    "insertText": "if(node.isValueOn(pos) && !node.isValueOn(pos + BoolLeafNodeType::DIM * BoolLeafNodeType::DIM))"
  },
  {
    "label": "evalInternalNeighborsN()",
    "kind": "Method",
    "detail": "Function (valueMask [ pos ] = 1 ; return true ; } } } } return false ; } void)",
    "insertText": "evalInternalNeighborsN(char* valueMask, const BoolLeafNodeType& node, const LeafNodeType& distNode)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (valueMask [ pos ] = 1 ; } } } })",
    "insertText": "for(Index x = 1; x < BoolLeafNodeType::DIM; ++x)"
  },
  {
    "label": "evalInternalNeighborsN()",
    "kind": "Method",
    "detail": "Function (valueMask [ pos ] = 1 ; } } } } } bool)",
    "insertText": "evalInternalNeighborsN(char* valueMask, const BoolLeafNodeType& node)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index pos = yPos + z ;)",
    "insertText": "if(node.isValueOn(pos) && !node.isValueOn(pos - 1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index pos = yPos + z ;)",
    "insertText": "if(node.isValueOn(pos) && !node.isValueOn(pos - BoolLeafNodeType::DIM))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index pos = yPos + z ;)",
    "insertText": "if(node.isValueOn(pos) && !node.isValueOn(pos - BoolLeafNodeType::DIM * BoolLeafNodeType::DIM))"
  },
  {
    "label": "evalExternalNeighborsX()",
    "kind": "Method",
    "detail": "Function (valueMask [ pos ] = 1 ; return true ; } } } } return false ; } template<bool UpWind> void)",
    "insertText": "evalExternalNeighborsX(char* valueMask, const BoolLeafNodeType& node, const tree::ValueAccessor<const BoolTreeType>& maskAcc, const tree::ValueAccessor<const TreeType>& distAcc)"
  },
  {
    "label": "ijk()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "ijk(0, 0, 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int step = - 1 ;)",
    "insertText": "if(UpWind)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (step = 1 ; ijk [ 0 ] =)",
    "insertText": "int(BoolLeafNodeType::DIM)"
  },
  {
    "label": "ijk()",
    "kind": "Method",
    "detail": "Function (} const Index xPos =)",
    "insertText": "ijk(2 * int(BoolLeafNodeType::LOG2DIM))"
  },
  {
    "label": "xPos()",
    "kind": "Method",
    "detail": "Function (const Index yPos =)",
    "insertText": "xPos(ijk[1] << int(BoolLeafNodeType::LOG2DIM))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index pos = yPos + ijk [ 2 ] ;)",
    "insertText": "if(valueMask[pos] == 0 && node.isValueOn(pos))"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (nijk = origin + ijk .)",
    "insertText": "offsetBy(step, 0, 0)"
  },
  {
    "label": "evalExternalNeighborsY()",
    "kind": "Method",
    "detail": "Function (valueMask [ pos ] = 1 ; } } } } } template<bool UpWind> void)",
    "insertText": "evalExternalNeighborsY(char* valueMask, const BoolLeafNodeType& node, const tree::ValueAccessor<const BoolTreeType>& maskAcc, const tree::ValueAccessor<const TreeType>& distAcc)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} const Index yPos = ijk [ 1 ]<<)",
    "insertText": "int(BoolLeafNodeType::LOG2DIM)"
  },
  {
    "label": "yPos()",
    "kind": "Method",
    "detail": "Function (const Index xPos =)",
    "insertText": "yPos(ijk[0] << (2 * int(BoolLeafNodeType::LOG2DIM)))"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (nijk = origin + ijk .)",
    "insertText": "offsetBy(0, step, 0)"
  },
  {
    "label": "evalExternalNeighborsZ()",
    "kind": "Method",
    "detail": "Function (valueMask [ pos ] = 1 ; } } } } } template<bool UpWind> void)",
    "insertText": "evalExternalNeighborsZ(char* valueMask, const BoolLeafNodeType& node, const tree::ValueAccessor<const BoolTreeType>& maskAcc, const tree::ValueAccessor<const TreeType>& distAcc)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(ijk[0] = 0; ijk[0] < int(BoolLeafNodeType::DIM); ++ijk[0])"
  },
  {
    "label": "offsetBy()",
    "kind": "Method",
    "detail": "Function (nijk = origin + ijk .)",
    "insertText": "offsetBy(0, 0, step)"
  },
  {
    "label": "computeEnclosedRegionMask()",
    "kind": "Method",
    "detail": "Function (valueMask [ pos ] = 1 ; } } } } } TreeType const* const mTree ; BoolTreeType const* const mFillMask ; BoolLeafNodeType const* const* const mFillNodes ; BoolLeafNodeType** const mNewNodes ; ValueType const mIsovalue ; } ; template<class TreeType> TreeType::template ValueConverter<char>::Type::Ptr)",
    "insertText": "computeEnclosedRegionMask(const TreeType& tree, typename TreeType::ValueType isovalue, const typename TreeType::template ValueConverter<bool>::Type* fillMask)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (using LeafNodeType = TreeType::LeafNodeType ; using RootNodeType = TreeType::RootNodeType ; using NodeChainType = RootNodeType::NodeChainType ; using InternalNodeType = NodeChainType::template Get<1> ; using CharTreeType = TreeType::template ValueConverter<char>::Type ; using CharLeafNodeType = CharTreeType::LeafNodeType ; using BoolTreeType = TreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ; const TreeType* treePt =& tree ; size_t numLeafNodes = 0,numInternalNodes = 0 ; std::vector<const LeafNodeType*> nodes ; std::vector<size_t> leafnodeCount ; { std::vector<const InternalNodeType*> internalNodes ; treePt ->)",
    "insertText": "getNodes(internalNodes)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (numInternalNodes = internalNodes .)",
    "insertText": "size()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (leafnodeCount .)",
    "insertText": "push_back(0)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (leafnodeCount .)",
    "insertText": "push_back(leafnodeCount.back() + internalNodes[n]->leafCount())"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (} numLeafNodes = leafnodeCount .)",
    "insertText": "back()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (nodes .)",
    "insertText": "reserve(numLeafNodes)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (internalNodes [ n ] ->)",
    "insertText": "getNodes(nodes)"
  },
  {
    "label": "maskNodes()",
    "kind": "Method",
    "detail": "Function (} } std::unique_ptr<CharLeafNodeType* [ ]>)",
    "insertText": "maskNodes(new CharLeafNodeType*[numLeafNodes])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, numLeafNodes), LabelBoundaryVoxels<LeafNodeType>(isovalue, nodes.data(), maskNodes.get()))"
  },
  {
    "label": "maskTree()",
    "kind": "Method",
    "detail": "Function (CharTreeType::Ptr)",
    "insertText": "maskTree(new CharTreeType(1))"
  },
  {
    "label": "populate()",
    "kind": "Method",
    "detail": "Function (PopulateTree<CharTreeType>)",
    "insertText": "populate(*maskTree, maskNodes.get(), leafnodeCount.data(), 1)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, numInternalNodes), populate)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (std::vector<CharLeafNodeType*> extraMaskNodes ;)",
    "insertText": "if(fillMask)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (std::vector<const BoolLeafNodeType*> fillMaskNodes ; fillMask ->)",
    "insertText": "getNodes(fillMaskNodes)"
  },
  {
    "label": "boundaryMaskNodes()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<BoolLeafNodeType* [ ]>)",
    "insertText": "boundaryMaskNodes(new BoolLeafNodeType*[fillMaskNodes.size()])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, fillMaskNodes.size()), FillMaskBoundary<TreeType>(tree, isovalue, *fillMask, fillMaskNodes.data(), boundaryMaskNodes.get()))"
  },
  {
    "label": "maskAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<CharTreeType>)",
    "insertText": "maskAcc(*maskTree)"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (CharLeafNodeType* maskNodePt = maskAcc .)",
    "insertText": "probeLeaf(origin)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (maskNodePt = maskAcc .)",
    "insertText": "touchLeaf(origin)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (extraMaskNodes .)",
    "insertText": "push_back(maskNodePt)"
  },
  {
    "label": "cbeginValueOn()",
    "kind": "Method",
    "detail": "Function (BoolLeafNodeType::ValueOnCIter it = boundaryNode .)",
    "insertText": "cbeginValueOn()"
  },
  {
    "label": "traceExteriorBoundaries()",
    "kind": "Method",
    "detail": "Function (} delete boundaryMaskNodes [ n ] ; } })",
    "insertText": "traceExteriorBoundaries(*maskTree)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, numLeafNodes), FlipRegionSign<CharLeafNodeType>(maskNodes.get()))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, extraMaskNodes.size()), FlipRegionSign<CharLeafNodeType>(extraMaskNodes.data()))"
  },
  {
    "label": "signedFloodFill()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "signedFloodFill(*maskTree)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ; using RootNodeType = TreeType::RootNodeType ; using NodeChainType = RootNodeType::NodeChainType ; using InternalNodeType = NodeChainType::template Get<1> ; using BoolTreeType = TreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ; using BoolRootNodeType = BoolTreeType::RootNodeType ; using BoolNodeChainType = BoolRootNodeType::NodeChainType ; using BoolInternalNodeType = BoolNodeChainType::template Get<1> ; iso =)",
    "insertText": "min(iso, static_cast<ValueType>(tree.background() - math::Tolerance<ValueType>::value()))"
  },
  {
    "label": "maskNodes()",
    "kind": "Method",
    "detail": "Function (} } std::unique_ptr<BoolLeafNodeType* [ ]>)",
    "insertText": "maskNodes(new BoolLeafNodeType*[numLeafNodes])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, numLeafNodes), MaskInteriorVoxels<LeafNodeType>(iso, nodes.data(), maskNodes.get()))"
  },
  {
    "label": "maskTree()",
    "kind": "Method",
    "detail": "Function (BoolTreeType::Ptr)",
    "insertText": "maskTree(new BoolTreeType(false))"
  },
  {
    "label": "populate()",
    "kind": "Method",
    "detail": "Function (PopulateTree<BoolTreeType>)",
    "insertText": "populate(*maskTree, maskNodes.get(), leafnodeCount.data(), false)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (std::vector<BoolInternalNodeType*> internalMaskNodes ; maskTree ->)",
    "insertText": "getNodes(internalMaskNodes)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, internalMaskNodes.size()), MaskInteriorTiles<TreeType, BoolInternalNodeType>(iso, tree, internalMaskNodes.data()))"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const TreeType>)",
    "insertText": "acc(tree)"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (BoolTreeType::ValueAllIter)",
    "insertText": "it(*maskTree)"
  },
  {
    "label": "setMaxDepth()",
    "kind": "Method",
    "detail": "Function (it .)",
    "insertText": "setMaxDepth(BoolTreeType::ValueAllIter::LEAF_DEPTH - 2)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (it .)",
    "insertText": "setActiveState(true)"
  },
  {
    "label": "MaskIsovalueCrossingVoxels()",
    "kind": "Method",
    "detail": "Function (} } return maskTree ; } template<InputTreeType> struct MaskIsovalueCrossingVoxels { using InputValueType = InputTreeType::ValueType ; using InputLeafNodeType = InputTreeType::LeafNodeType ; using BoolTreeType = InputTreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ;)",
    "insertText": "MaskIsovalueCrossingVoxels(const InputTreeType& inputTree, const std::vector<const InputLeafNodeType*>& inputLeafNodes, BoolTreeType& maskTree, InputValueType iso) : mInputAccessor(inputTree) , mInputNodes(!inputLeafNodes.empty() ? &inputLeafNodes.front() : nullptr) , mMaskTree(false) , mMaskAccessor(maskTree) , mIsovalue(iso)"
  },
  {
    "label": "MaskIsovalueCrossingVoxels()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MaskIsovalueCrossingVoxels(MaskIsovalueCrossingVoxels& rhs, tbb::split) : mInputAccessor(rhs.mInputAccessor.tree()) , mInputNodes(rhs.mInputNodes) , mMaskTree(false) , mMaskAccessor(mMaskTree) , mIsovalue(rhs.mIsovalue)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (BoolLeafNodeType* maskNodePt = nullptr ;)",
    "insertText": "for(size_t n = range.begin(); mInputNodes && (n != range.end()); ++n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const InputLeafNodeType& node =* mInputNodes [ n ] ;)",
    "insertText": "if(!maskNodePt) maskNodePt = new BoolLeafNodeType(node.origin(), false)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool collectedData = false ;)",
    "insertText": "for(typename InputLeafNodeType::ValueOnCIter it = node.cbeginValueOn(); it; ++it)"
  },
  {
    "label": "getCoord()",
    "kind": "Method",
    "detail": "Function (bool isUnder =* it<iso ; ijk = it .)",
    "insertText": "getCoord()"
  },
  {
    "label": "isUnder()",
    "kind": "Method",
    "detail": "Function (+ + ijk [ 2 ] ; bool signChange =)",
    "insertText": "isUnder(mInputAccessor.getValue(ijk) < iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - ijk [ 2 ] ;)",
    "insertText": "if(!signChange)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + ijk [ 0 ] ; })",
    "insertText": "if(signChange)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (collectedData = true ; maskNodePt ->)",
    "insertText": "setValueOn(it.pos(), true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(collectedData)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (mMaskAccessor .)",
    "insertText": "addLeaf(maskNodePt)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "join(MaskIsovalueCrossingVoxels& rhs)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (mMaskAccessor .)",
    "insertText": "tree().merge(rhs.mMaskAccessor.tree())"
  },
  {
    "label": "NodeMaskSegment()",
    "kind": "Method",
    "detail": "Function (} private : tree::ValueAccessor<const InputTreeType> mInputAccessor ; InputLeafNodeType const* const* const mInputNodes ; BoolTreeType mMaskTree ; tree::ValueAccessor<BoolTreeType> mMaskAccessor ; InputValueType mIsovalue ; } ; template<NodeType> struct NodeMaskSegment { using Ptr = SharedPtr<NodeMaskSegment> ; using NodeMaskType = NodeType::NodeMaskType ;)",
    "insertText": "NodeMaskSegment() : connections(), mask(false), origin(0,0,0), visited(false)"
  },
  {
    "label": "nodeMaskSegmentation()",
    "kind": "Method",
    "detail": "Function (} std::vector<NodeMaskSegment*> connections ; NodeMaskType mask ; Coord origin ; bool visited ; } ; template<NodeType> void)",
    "insertText": "nodeMaskSegmentation(const NodeType& node, std::vector<typename NodeMaskSegment<NodeType>::Ptr>& segments)"
  },
  {
    "label": "nodeMask()",
    "kind": "Method",
    "detail": "Function (using NodeMaskType = NodeType::NodeMaskType ; using NodeMaskSegmentType = NodeMaskSegment<NodeType> ; using NodeMaskSegmentTypePtr = NodeMaskSegmentType::Ptr ; NodeMaskType)",
    "insertText": "nodeMask(node.getValueMask())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (std::deque<Index> indexList ;)",
    "insertText": "while(!nodeMask.isOff())"
  },
  {
    "label": "segment()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentTypePtr)",
    "insertText": "segment(new NodeMaskSegmentType())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (NodeMaskType& mask = segment -> mask ; indexList .)",
    "insertText": "push_back(nodeMask.findFirstOn())"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (nodeMask .)",
    "insertText": "setOff(indexList.back())"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (indexList .)",
    "insertText": "pop_back()"
  },
  {
    "label": "setOn()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "setOn(pos)"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (ijk =)",
    "insertText": "offsetToLocalCoord(pos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index npos = pos - 1 ;)",
    "insertText": "if(ijk[2] != 0 && nodeMask.isOn(npos))"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (nodeMask .)",
    "insertText": "setOff(npos)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (indexList .)",
    "insertText": "push_back(npos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} npos = pos + 1 ;)",
    "insertText": "if(ijk[2] != (NodeType::DIM - 1) && nodeMask.isOn(npos))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} npos = pos - NodeType::DIM ;)",
    "insertText": "if(ijk[1] != 0 && nodeMask.isOn(npos))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} npos = pos + NodeType::DIM ;)",
    "insertText": "if(ijk[1] != (NodeType::DIM - 1) && nodeMask.isOn(npos))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} npos = pos - NodeType::DIM* NodeType::DIM ;)",
    "insertText": "if(ijk[0] != 0 && nodeMask.isOn(npos))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} npos = pos + NodeType::DIM* NodeType::DIM ;)",
    "insertText": "if(ijk[0] != (NodeType::DIM - 1) && nodeMask.isOn(npos))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} } segments .)",
    "insertText": "push_back(segment)"
  },
  {
    "label": "SegmentNodeMask()",
    "kind": "Method",
    "detail": "Function (} } template<NodeType> struct SegmentNodeMask { using NodeMaskSegmentType = NodeMaskSegment<NodeType> ; using NodeMaskSegmentTypePtr = NodeMaskSegmentType::Ptr ; using NodeMaskSegmentVector = std::vector<NodeMaskSegmentTypePtr> ;)",
    "insertText": "SegmentNodeMask(std::vector<NodeType*>& nodes, NodeMaskSegmentVector* nodeMaskArray) : mNodes(!nodes.empty() ? &nodes.front() : nullptr) , mNodeMaskArray(nodeMaskArray)"
  },
  {
    "label": "nodeMaskSegmentation()",
    "kind": "Method",
    "detail": "Function (NodeType& node =* mNodes [ n ] ;)",
    "insertText": "nodeMaskSegmentation(node, mNodeMaskArray[n])"
  },
  {
    "label": "Coord()",
    "kind": "Method",
    "detail": "Function (Coord& origin = const_cast<)",
    "insertText": "Coord(node.origin())"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (origin [ 0 ] = static_cast<)",
    "insertText": "int(n)"
  },
  {
    "label": "ConnectNodeMaskSegments()",
    "kind": "Method",
    "detail": "Function (} } NodeType* const* const mNodes ; NodeMaskSegmentVector* const mNodeMaskArray ; } ; template<TreeType,NodeType> struct ConnectNodeMaskSegments { using NodeMaskType = NodeType::NodeMaskType ; using NodeMaskSegmentType = NodeMaskSegment<NodeType> ; using NodeMaskSegmentTypePtr = NodeMaskSegmentType::Ptr ; using NodeMaskSegmentVector = std::vector<NodeMaskSegmentTypePtr> ;)",
    "insertText": "ConnectNodeMaskSegments(const TreeType& tree, NodeMaskSegmentVector* nodeMaskArray) : mTree(&tree) , mNodeMaskArray(nodeMaskArray)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentVector& segments = mNodeMaskArray [ n ] ;)",
    "insertText": "if(segments.empty())"
  },
  {
    "label": "connections()",
    "kind": "Method",
    "detail": "Function (std::vector<std::set<NodeMaskSegmentType*>>)",
    "insertText": "connections(segments.size())"
  },
  {
    "label": "NodeType()",
    "kind": "Method",
    "detail": "Function (Coord ijk = segments [ 0 ] -> origin ; const NodeType* node = acc . template probeConstNode<)",
    "insertText": "NodeType(ijk)"
  },
  {
    "label": "ijk()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ijk(NodeType::DIM + NodeType::DIM)"
  },
  {
    "label": "getValueMask()",
    "kind": "Method",
    "detail": "Function (ijk [ 0 ] + = NodeType::DIM ; const Index startPos = node ->)",
    "insertText": "getValueMask().findFirstOn()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef _MSC_FULL_VER # if _MSC_FULL_VER> = 1 9 0 0 0 0 0 0 0&& _MSC_FULL_VER<1 9 0 0 2 4 2 1 0 volatile Index npos = 0 ; # else Index npos = 0 ; # endif # else Index npos = 0 ; # endif)",
    "insertText": "if(ijk[2] == 0)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (npos =)",
    "insertText": "pos(NodeType::DIM - 1)"
  },
  {
    "label": "findNodeMaskSegment()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentType* nsegment =)",
    "insertText": "findNodeMaskSegment(mNodeMaskArray[getNodeOffset(*nodeZDown)], npos)"
  },
  {
    "label": "findNodeMaskSegmentIndex()",
    "kind": "Method",
    "detail": "Function (const Index idx =)",
    "insertText": "findNodeMaskSegmentIndex(segments, pos)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (connections [ idx ] .)",
    "insertText": "insert(nsegment)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(ijk[2] == (NodeType::DIM - 1))"
  },
  {
    "label": "findNodeMaskSegment()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentType* nsegment =)",
    "insertText": "findNodeMaskSegment(mNodeMaskArray[getNodeOffset(*nodeZUp)], npos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(ijk[1] == 0)"
  },
  {
    "label": "findNodeMaskSegment()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentType* nsegment =)",
    "insertText": "findNodeMaskSegment(mNodeMaskArray[getNodeOffset(*nodeYDown)], npos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(ijk[1] == (NodeType::DIM - 1))"
  },
  {
    "label": "findNodeMaskSegment()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentType* nsegment =)",
    "insertText": "findNodeMaskSegment(mNodeMaskArray[getNodeOffset(*nodeYUp)], npos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(ijk[0] == 0)"
  },
  {
    "label": "findNodeMaskSegment()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentType* nsegment =)",
    "insertText": "findNodeMaskSegment(mNodeMaskArray[getNodeOffset(*nodeXDown)], npos)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(ijk[0] == (NodeType::DIM - 1))"
  },
  {
    "label": "findNodeMaskSegment()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentType* nsegment =)",
    "insertText": "findNodeMaskSegment(mNodeMaskArray[getNodeOffset(*nodeXUp)], npos)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "for(size_t i = 0, I = connections.size(); i < I; ++i)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (std::set<NodeMaskSegmentType*>::iterator it = connections [ i ] .)",
    "insertText": "begin(), end = connections[i].end()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::vector<NodeMaskSegmentType*>& segmentConnections = segments [ i ] -> connections ; segmentConnections .)",
    "insertText": "reserve(connections.size())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (segmentConnections .)",
    "insertText": "push_back(*it)"
  },
  {
    "label": "getNodeOffset()",
    "kind": "Method",
    "detail": "Function (} } } } private : size_t)",
    "insertText": "getNodeOffset(const NodeType& node)"
  },
  {
    "label": "findNodeMaskSegment()",
    "kind": "Method",
    "detail": "Function (} NodeMaskSegmentType*)",
    "insertText": "findNodeMaskSegment(NodeMaskSegmentVector& segments, Index pos)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentType* segment = nullptr ;)",
    "insertText": "for(size_t n = 0, N = segments.size(); n < N; ++n)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (segment = segments [ n ] .)",
    "insertText": "get()"
  },
  {
    "label": "findNodeMaskSegmentIndex()",
    "kind": "Method",
    "detail": "Function (break ; } } return segment ; } Index)",
    "insertText": "findNodeMaskSegmentIndex(NodeMaskSegmentVector& segments, Index pos)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "Index(-1)"
  },
  {
    "label": "MaskSegmentGroup()",
    "kind": "Method",
    "detail": "Function (} TreeType const* const mTree ; NodeMaskSegmentVector* const mNodeMaskArray ; } ; template<TreeType> struct MaskSegmentGroup { using LeafNodeType = TreeType::LeafNodeType ; using TreeTypePtr = TreeType::Ptr ; using NodeMaskSegmentType = NodeMaskSegment<LeafNodeType> ;)",
    "insertText": "MaskSegmentGroup(const std::vector<NodeMaskSegmentType*>& segments) : mSegments(!segments.empty() ? &segments.front() : nullptr) , mTree(new TreeType(false))"
  },
  {
    "label": "MaskSegmentGroup()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MaskSegmentGroup(const MaskSegmentGroup& rhs, tbb::split) : mSegments(rhs.mSegments) , mTree(new TreeType(false))"
  },
  {
    "label": "mask()",
    "kind": "Method",
    "detail": "Function (} TreeTypePtr&)",
    "insertText": "mask()"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (mTree ->)",
    "insertText": "merge(*rhs.mTree)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentType& segment =* mSegments [ n ] ; LeafNodeType* node = acc .)",
    "insertText": "touchLeaf(segment.origin)"
  },
  {
    "label": "getValueMask()",
    "kind": "Method",
    "detail": "Function (node ->)",
    "insertText": "getValueMask()"
  },
  {
    "label": "ExpandLeafNodeRegion()",
    "kind": "Method",
    "detail": "Function (} } private : NodeMaskSegmentType* const* const mSegments ; TreeTypePtr mTree ; } ; template<TreeType> struct ExpandLeafNodeRegion { using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ; using NodeMaskType = LeafNodeType::NodeMaskType ; using BoolTreeType = TreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ;)",
    "insertText": "ExpandLeafNodeRegion(const TreeType& distTree, BoolTreeType& maskTree, std::vector<BoolLeafNodeType*>& maskNodes) : mDistTree(&distTree) , mMaskTree(&maskTree) , mMaskNodes(!maskNodes.empty() ? &maskNodes.front() : nullptr) , mNewMaskTree(false)"
  },
  {
    "label": "ExpandLeafNodeRegion()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ExpandLeafNodeRegion(const ExpandLeafNodeRegion& rhs, tbb::split) : mDistTree(rhs.mDistTree) , mMaskTree(rhs.mMaskTree) , mMaskNodes(rhs.mMaskNodes) , mNewMaskTree(false)"
  },
  {
    "label": "newMaskTree()",
    "kind": "Method",
    "detail": "Function (} BoolTreeType&)",
    "insertText": "newMaskTree()"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (mNewMaskTree .)",
    "insertText": "merge(rhs.mNewMaskTree)"
  },
  {
    "label": "distAcc()",
    "kind": "Method",
    "detail": "Function (using NodeType = LeafNodeType ; tree::ValueAccessor<const TreeType>)",
    "insertText": "distAcc(*mDistTree)"
  },
  {
    "label": "maskAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const BoolTreeType>)",
    "insertText": "maskAcc(*mMaskTree)"
  },
  {
    "label": "newMaskAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<BoolTreeType>)",
    "insertText": "newMaskAcc(mNewMaskTree)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BoolLeafNodeType& maskNode =* mMaskNodes [ n ] ;)",
    "insertText": "if(maskNode.isEmpty())"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (const LeafNodeType* distNode = distAcc .)",
    "insertText": "probeConstLeaf(ijk)"
  },
  {
    "label": "getData()",
    "kind": "Method",
    "detail": "Function (const ValueType* dataZUp = nullptr,* dataZDown = nullptr,* dataYUp = nullptr,* dataYDown = nullptr,* dataXUp = nullptr,* dataXDown = nullptr ; ijk [ 2 ] + = NodeType::DIM ;)",
    "insertText": "getData(ijk, distAcc, maskAcc, maskZUp, dataZUp)"
  },
  {
    "label": "getData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getData(ijk, distAcc, maskAcc, maskZDown, dataZDown)"
  },
  {
    "label": "getData()",
    "kind": "Method",
    "detail": "Function (ijk [ 2 ] + = NodeType::DIM ; ijk [ 1 ] + = NodeType::DIM ;)",
    "insertText": "getData(ijk, distAcc, maskAcc, maskYUp, dataYUp)"
  },
  {
    "label": "getData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getData(ijk, distAcc, maskAcc, maskYDown, dataYDown)"
  },
  {
    "label": "getData()",
    "kind": "Method",
    "detail": "Function (ijk [ 1 ] + = NodeType::DIM ; ijk [ 0 ] + = NodeType::DIM ;)",
    "insertText": "getData(ijk, distAcc, maskAcc, maskXUp, dataXUp)"
  },
  {
    "label": "getData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getData(ijk, distAcc, maskAcc, maskXDown, dataXDown)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (ijk [ 0 ] + = NodeType::DIM ;)",
    "insertText": "for(typename BoolLeafNodeType::ValueOnIter it = maskNode.beginValueOn(); it; ++it)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (const Index pos = it .)",
    "insertText": "pos()"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (const ValueType val =)",
    "insertText": "abs(distNode->getValue(pos))"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (newMaskAcc .)",
    "insertText": "setValueOn(nijk.offsetBy(0, 0, 1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(dataZDown && ijk[2] == 0)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (newMaskAcc .)",
    "insertText": "setValueOn(nijk.offsetBy(0, 0, -1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(dataYUp && ijk[1] == (BoolLeafNodeType::DIM - 1))"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (newMaskAcc .)",
    "insertText": "setValueOn(nijk.offsetBy(0, 1, 0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(dataYDown && ijk[1] == 0)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (newMaskAcc .)",
    "insertText": "setValueOn(nijk.offsetBy(0, -1, 0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(dataXUp && ijk[0] == (BoolLeafNodeType::DIM - 1))"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (newMaskAcc .)",
    "insertText": "setValueOn(nijk.offsetBy(1, 0, 0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(dataXDown && ijk[0] == 0)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (newMaskAcc .)",
    "insertText": "setValueOn(nijk.offsetBy(-1, 0, 0))"
  },
  {
    "label": "getData()",
    "kind": "Method",
    "detail": "Function (} } } } } private : void)",
    "insertText": "getData(const Coord& ijk, tree::ValueAccessor<const TreeType>& distAcc, tree::ValueAccessor<const BoolTreeType>& maskAcc, NodeMaskType& mask, const ValueType*& data)"
  },
  {
    "label": "FillLeafNodeVoxels()",
    "kind": "Method",
    "detail": "Function (} } TreeType const* const mDistTree ; BoolTreeType* const mMaskTree ; BoolLeafNodeType** const mMaskNodes ; BoolTreeType mNewMaskTree ; } ; template<TreeType> struct FillLeafNodeVoxels { using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ; using NodeMaskType = LeafNodeType::NodeMaskType ; using BoolLeafNodeType = tree::LeafNode<bool,LeafNodeType::LOG2DIM> ;)",
    "insertText": "FillLeafNodeVoxels(const TreeType& tree, std::vector<BoolLeafNodeType*>& maskNodes) : mTree(&tree), mMaskNodes(!maskNodes.empty() ? &maskNodes.front() : nullptr)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::vector<Index> indexList ; indexList .)",
    "insertText": "reserve(NodeMaskType::SIZE)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (BoolLeafNodeType& maskNode =* mMaskNodes [ n ] ; const LeafNodeType* distNode = distAcc .)",
    "insertText": "probeConstLeaf(maskNode.origin())"
  },
  {
    "label": "mask()",
    "kind": "Method",
    "detail": "Function (NodeMaskType)",
    "insertText": "mask(distNode->getValueMask())"
  },
  {
    "label": "setOff()",
    "kind": "Method",
    "detail": "Function (} mask - = narrowbandMask ; narrowbandMask .)",
    "insertText": "setOff()"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (const ValueType dist =)",
    "insertText": "abs(data[pos])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index npos = pos - 1 ;)",
    "insertText": "if(ijk[2] != 0 && mask.isOn(npos) && std::abs(data[npos]) > dist)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} npos = pos + 1 ;)",
    "insertText": "if((ijk[2] != (LeafNodeType::DIM - 1)) && mask.isOn(npos) && std::abs(data[npos]) > dist)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} npos = pos - LeafNodeType::DIM ;)",
    "insertText": "if(ijk[1] != 0 && mask.isOn(npos) && std::abs(data[npos]) > dist)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} npos = pos + LeafNodeType::DIM ;)",
    "insertText": "if((ijk[1] != (LeafNodeType::DIM - 1)) && mask.isOn(npos) && std::abs(data[npos]) > dist)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} npos = pos - LeafNodeType::DIM* LeafNodeType::DIM ;)",
    "insertText": "if(ijk[0] != 0 && mask.isOn(npos) && std::abs(data[npos]) > dist)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} npos = pos + LeafNodeType::DIM* LeafNodeType::DIM ;)",
    "insertText": "if((ijk[0] != (LeafNodeType::DIM - 1)) && mask.isOn(npos) && std::abs(data[npos]) > dist)"
  },
  {
    "label": "ExpandNarrowbandMask()",
    "kind": "Method",
    "detail": "Function (} } } } TreeType const* const mTree ; BoolLeafNodeType** const mMaskNodes ; } ; template<TreeType> struct ExpandNarrowbandMask { using BoolTreeType = TreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ; using BoolTreeTypePtr = BoolTreeType::Ptr ;)",
    "insertText": "ExpandNarrowbandMask(const TreeType& tree, std::vector<BoolTreeTypePtr>& segments) : mTree(&tree), mSegments(!segments.empty() ? &segments.front() : nullptr)"
  },
  {
    "label": "candidateMask()",
    "kind": "Method",
    "detail": "Function (BoolTreeType& narrowBandMask =* mSegments [ n ] ; BoolTreeType)",
    "insertText": "candidateMask(narrowBandMask, false, TopologyCopy())"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (nodes .)",
    "insertText": "clear()"
  },
  {
    "label": "nodeRange()",
    "kind": "Method",
    "detail": "Function (const tbb::blocked_range<size_t>)",
    "insertText": "nodeRange(0, nodes.size())"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(nodeRange, FillLeafNodeVoxels<TreeType>(distTree, nodes))"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (narrowBandMask .)",
    "insertText": "topologyUnion(candidateMask)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (ExpandLeafNodeRegion<TreeType>)",
    "insertText": "op(distTree, narrowBandMask, nodes)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(nodeRange, op)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (candidateMask .)",
    "insertText": "merge(op.newMaskTree())"
  },
  {
    "label": "FloodFillSign()",
    "kind": "Method",
    "detail": "Function (} } } TreeType const* const mTree ; BoolTreeTypePtr* const mSegments ; } ; template<TreeType> struct FloodFillSign { using TreeTypePtr = TreeType::Ptr ; using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ; using RootNodeType = TreeType::RootNodeType ; using NodeChainType = RootNodeType::NodeChainType ; using InternalNodeType = NodeChainType::template Get<1> ;)",
    "insertText": "FloodFillSign(const TreeType& tree, std::vector<TreeTypePtr>& segments) : mTree(&tree) , mSegments(!segments.empty() ? &segments.front() : nullptr) , mMinValue(ValueType(0.0))"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (ValueType minSDFValue = std::numeric_limits<ValueType)",
    "insertText": "max()"
  },
  {
    "label": "minOp()",
    "kind": "Method",
    "detail": "Function (FindMinTileValue<InternalNodeType>)",
    "insertText": "minOp(nodes.data())"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, nodes.size()), minOp)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (minSDFValue =)",
    "insertText": "min(minSDFValue, minOp.minValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(minSDFValue > ValueType(0.0))"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (const ValueType interiorValue = -)",
    "insertText": "abs(mMinValue)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (const ValueType exteriorValue =)",
    "insertText": "abs(mTree->background())"
  },
  {
    "label": "signedFloodFillWithValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "signedFloodFillWithValues(*mSegments[n], exteriorValue, interiorValue)"
  },
  {
    "label": "MaskedCopy()",
    "kind": "Method",
    "detail": "Function (} } private : TreeType const* const mTree ; TreeTypePtr* const mSegments ; ValueType mMinValue ; } ; template<TreeType> struct MaskedCopy { using TreeTypePtr = TreeType::Ptr ; using ValueType = TreeType::ValueType ; using LeafNodeType = TreeType::LeafNodeType ; using BoolTreeType = TreeType::template ValueConverter<bool>::Type ; using BoolTreeTypePtr = BoolTreeType::Ptr ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ;)",
    "insertText": "MaskedCopy(const TreeType& tree, std::vector<TreeTypePtr>& segments, std::vector<BoolTreeTypePtr>& masks) : mTree(&tree) , mSegments(!segments.empty() ? &segments.front() : nullptr) , mMasks(!masks.empty() ? &masks.front() : nullptr)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (Copy)",
    "insertText": "op(*mTree, nodes)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, nodes.size()), op)"
  },
  {
    "label": "outputTree()",
    "kind": "Method",
    "detail": "Function (mSegments [ n ] = op .)",
    "insertText": "outputTree()"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (} } private : struct Copy {)",
    "insertText": "Copy(const TreeType& inputTree, std::vector<const BoolLeafNodeType*>& maskNodes) : mInputTree(&inputTree) , mMaskNodes(!maskNodes.empty() ? &maskNodes.front() : nullptr) , mOutputTreePtr(new TreeType(inputTree.background()))"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Copy(const Copy& rhs, tbb::split) : mInputTree(rhs.mInputTree) , mMaskNodes(rhs.mMaskNodes) , mOutputTreePtr(new TreeType(mInputTree->background()))"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (mOutputTreePtr ->)",
    "insertText": "merge(*rhs.mOutputTreePtr)"
  },
  {
    "label": "inputAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const TreeType>)",
    "insertText": "inputAcc(*mInputTree)"
  },
  {
    "label": "outputAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<TreeType>)",
    "insertText": "outputAcc(*mOutputTreePtr)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (LeafNodeType* outputNode = outputAcc .)",
    "insertText": "touchLeaf(ijk)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (outputNode ->)",
    "insertText": "setValueOn(idx, inputNode->getValue(idx))"
  },
  {
    "label": "getValueDepth()",
    "kind": "Method",
    "detail": "Function (} } else { const int valueDepth = inputAcc .)",
    "insertText": "getValueDepth(ijk)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (outputAcc .)",
    "insertText": "addTile(TreeType::RootNodeType::LEVEL - valueDepth, ijk, inputAcc.getValue(ijk), true)"
  },
  {
    "label": "ComputeActiveVoxelCount()",
    "kind": "Method",
    "detail": "Function (} } } } private : TreeType const* const mInputTree ; BoolLeafNodeType const* const* const mMaskNodes ; TreeTypePtr mOutputTreePtr ; } ; TreeType const* const mTree ; TreeTypePtr* const mSegments ; BoolTreeTypePtr* const mMasks ; } ; template<VolumePtrType> struct ComputeActiveVoxelCount {)",
    "insertText": "ComputeActiveVoxelCount(std::vector<VolumePtrType>& segments, size_t *countArray) : mSegments(!segments.empty() ? &segments.front() : nullptr) , mCountArray(countArray)"
  },
  {
    "label": "activeVoxelCount()",
    "kind": "Method",
    "detail": "Function (mCountArray [ n ] = mSegments [ n ] ->)",
    "insertText": "activeVoxelCount()"
  },
  {
    "label": "GreaterCount()",
    "kind": "Method",
    "detail": "Function (} } VolumePtrType* const mSegments ; size_t* const mCountArray ; } ; struct GreaterCount {)",
    "insertText": "GreaterCount(const size_t *countArray) : mCountArray(countArray)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator() (const size_t& lhs, const size_t& rhs)"
  },
  {
    "label": "constructMask()",
    "kind": "Method",
    "detail": "Function (} size_t const* const mCountArray ; } ; template<TreeType> struct GridOrTreeConstructor { using TreeTypePtr = TreeType::Ptr ; using BoolTreePtrType = TreeType::template ValueConverter<bool>::Type::Ptr ; BoolTreePtrType)",
    "insertText": "constructMask(const TreeType&, BoolTreePtrType& maskTree)"
  },
  {
    "label": "maskGrid()",
    "kind": "Method",
    "detail": "Function (BoolGridPtrType)",
    "insertText": "maskGrid(BoolGridType::create(maskTree))"
  },
  {
    "label": "setTransform()",
    "kind": "Method",
    "detail": "Function (maskGrid ->)",
    "insertText": "setTransform(grid.transform().copy())"
  },
  {
    "label": "maskGrid()",
    "kind": "Method",
    "detail": "Function (GridTypePtr)",
    "insertText": "maskGrid(GridType::create(maskTree))"
  },
  {
    "label": "insertMeta()",
    "kind": "Method",
    "detail": "Function (maskGrid ->)",
    "insertText": "insertMeta(grid)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (using ValueType = GridType::ValueType ; using TreeType = GridType::TreeType ; using LeafNodeType = TreeType::LeafNodeType ; using RootNodeType = TreeType::RootNodeType ; using NodeChainType = RootNodeType::NodeChainType ; using InternalNodeType = NodeChainType::template Get<1> ; TreeType& tree = grid .)",
    "insertText": "tree()"
  },
  {
    "label": "stealNodes()",
    "kind": "Method",
    "detail": "Function (internalNodes [ n ] ->)",
    "insertText": "stealNodes(nodes, tree.background(), false)"
  },
  {
    "label": "minOp()",
    "kind": "Method",
    "detail": "Function ({ level_set_util_internal::FindMinTileValue<InternalNodeType>)",
    "insertText": "minOp(internalNodes.data())"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, internalNodes.size()), minOp)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (} cutoffDistance = -)",
    "insertText": "abs(cutoffDistance)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (cutoffDistance = minSDFValue> cutoffDistance ? minSDFValue : cutoffDistance ; })",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, nodes.size()), level_set_util_internal::SDFVoxelsToFogVolume<LeafNodeType>(nodes.data(), cutoffDistance))"
  },
  {
    "label": "newTree()",
    "kind": "Method",
    "detail": "Function (TreeType::Ptr)",
    "insertText": "newTree(new TreeType(ValueType(0.0)))"
  },
  {
    "label": "populate()",
    "kind": "Method",
    "detail": "Function (level_set_util_internal::PopulateTree<TreeType>)",
    "insertText": "populate(*newTree, nodes.data(), leafnodeCount.data(), 0)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, internalNodes.size()), level_set_util_internal::SDFTilesToFogVolume<TreeType, InternalNodeType>( tree, internalNodes.data()))"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (TreeType::ValueAllIter)",
    "insertText": "it(*newTree)"
  },
  {
    "label": "setMaxDepth()",
    "kind": "Method",
    "detail": "Function (it .)",
    "insertText": "setMaxDepth(TreeType::ValueAllIter::LEAF_DEPTH - 2)"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (} } } { TreeType::ValueAllIter)",
    "insertText": "it(tree)"
  },
  {
    "label": "setMaxDepth()",
    "kind": "Method",
    "detail": "Function (it .)",
    "insertText": "setMaxDepth(TreeType::ValueAllIter::ROOT_DEPTH)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (newTree ->)",
    "insertText": "addTile(TreeType::ValueAllIter::ROOT_LEVEL, it.getCoord(), ValueType(1.0), true)"
  },
  {
    "label": "setTree()",
    "kind": "Method",
    "detail": "Function (} } } grid .)",
    "insertText": "setTree(newTree)"
  },
  {
    "label": "setGridClass()",
    "kind": "Method",
    "detail": "Function (grid .)",
    "insertText": "setGridClass(GRID_FOG_VOLUME)"
  },
  {
    "label": "sdfInteriorMask()",
    "kind": "Method",
    "detail": "Function (} template<class GridOrTreeType> GridOrTreeType::template ValueConverter<bool>::Type::Ptr)",
    "insertText": "sdfInteriorMask(const GridOrTreeType& volume, typename GridOrTreeType::ValueType isovalue)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (using TreeType = TreeAdapter<GridOrTreeType>::TreeType ; const TreeType& tree = TreeAdapter<GridOrTreeType)",
    "insertText": "tree(volume)"
  },
  {
    "label": "computeInteriorMask()",
    "kind": "Method",
    "detail": "Function (using BoolTreePtrType = TreeType::template ValueConverter<bool>::Type::Ptr ; BoolTreePtrType mask =)",
    "insertText": "computeInteriorMask(tree, isovalue)"
  },
  {
    "label": "extractEnclosedRegion()",
    "kind": "Method",
    "detail": "Function (} template<GridOrTreeType> GridOrTreeType::template ValueConverter<bool>::Type::Ptr)",
    "insertText": "extractEnclosedRegion(const GridOrTreeType& volume, typename GridOrTreeType::ValueType isovalue, const typename TreeAdapter<GridOrTreeType>::TreeType::template ValueConverter<bool>::Type* fillMask)"
  },
  {
    "label": "computeEnclosedRegionMask()",
    "kind": "Method",
    "detail": "Function (using CharTreePtrType = TreeType::template ValueConverter<char>::Type::Ptr ; CharTreePtrType regionMask =)",
    "insertText": "computeEnclosedRegionMask(tree, isovalue, fillMask)"
  },
  {
    "label": "computeInteriorMask()",
    "kind": "Method",
    "detail": "Function (using BoolTreePtrType = TreeType::template ValueConverter<bool>::Type::Ptr ; BoolTreePtrType mask =)",
    "insertText": "computeInteriorMask(*regionMask, 0)"
  },
  {
    "label": "mask()",
    "kind": "Method",
    "detail": "Function (using BoolTreeType = TreeType::template ValueConverter<bool>::Type ; BoolTreeType::Ptr)",
    "insertText": "mask(new BoolTreeType(false))"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (level_set_util_internal::MaskIsovalueCrossingVoxels<TreeType>)",
    "insertText": "op(tree, nodes, *mask, isovalue)"
  },
  {
    "label": "topologyMask()",
    "kind": "Method",
    "detail": "Function (BoolTreeType)",
    "insertText": "topologyMask(tree, false, TopologyCopy())"
  },
  {
    "label": "pruneInactive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pruneInactive(topologyMask)"
  },
  {
    "label": "voxelizeActiveTiles()",
    "kind": "Method",
    "detail": "Function (topologyMask .)",
    "insertText": "voxelizeActiveTiles()"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (} std::vector<BoolLeafNodeType*> leafnodes ; topologyMask .)",
    "insertText": "getNodes(leafnodes)"
  },
  {
    "label": "nodeSegmentArray()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<NodeMaskSegmentPtrVector [ ]>)",
    "insertText": "nodeSegmentArray(new NodeMaskSegmentPtrVector[leafnodes.size()])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, leafnodes.size()), level_set_util_internal::SegmentNodeMask<BoolLeafNodeType>( leafnodes, nodeSegmentArray.get()))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, leafnodes.size()), level_set_util_internal::ConnectNodeMaskSegments<BoolTreeType, BoolLeafNodeType>( topologyMask, nodeSegmentArray.get()))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t nodeSegmentCount = 0 ;)",
    "insertText": "for(size_t n = 0, N = leafnodes.size(); n < N; ++n)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (nodeSegmentGroups .)",
    "insertText": "push_back(NodeMaskSegmentRawPtrVector())"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (segmentGroup .)",
    "insertText": "reserve(nodeSegmentCount)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (std::deque<NodeMaskSegmentType*> segmentQueue ; segmentQueue .)",
    "insertText": "push_back(nextSegment)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (nextSegment = nullptr ;)",
    "insertText": "while(!segmentQueue.empty())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (std::vector<NodeMaskSegmentType*>& connections = segment -> connections ;)",
    "insertText": "for(size_t n = 0, N = connections.size(); n < N; ++n)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentPtrVector& nodeSegments = nodeSegmentArray [ n ] ;)",
    "insertText": "for(size_t i = 0, I = nodeSegments.size(); i < I; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(nodeSegmentGroups.size() == 1)"
  },
  {
    "label": "mask()",
    "kind": "Method",
    "detail": "Function (BoolTreePtrType)",
    "insertText": "mask(new BoolTreeType(tree, false, TopologyCopy()))"
  },
  {
    "label": "pruneInactive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pruneInactive(*mask)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} masks .)",
    "insertText": "push_back(level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask( volume, mask))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(nodeSegmentGroups.size() > 1)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (NodeMaskSegmentRawPtrVector& segmentGroup = nodeSegmentGroups [ n ] ; level_set_util_internal::MaskSegmentGroup<BoolTreeType>)",
    "insertText": "op(segmentGroup)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, segmentGroup.size()), op)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (masks .)",
    "insertText": "push_back(level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask( volume, op.mask()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(masks.size() > 1)"
  },
  {
    "label": "segmentOrderArray()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<size_t [ ]>)",
    "insertText": "segmentOrderArray(new size_t[segmentCount])"
  },
  {
    "label": "voxelCountArray()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<size_t [ ]>)",
    "insertText": "voxelCountArray(new size_t[segmentCount])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (segmentOrderArray [ n ] = n ; })",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, segmentCount), level_set_util_internal::ComputeActiveVoxelCount<BoolTreePtrType>( masks, voxelCountArray.get()))"
  },
  {
    "label": "parallel_sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_sort(begin, begin + masks.size(), level_set_util_internal::GreaterCount( voxelCountArray.get()))"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::vector<BoolTreePtrType> orderedMasks ; orderedMasks .)",
    "insertText": "reserve(masks.size())"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (orderedMasks .)",
    "insertText": "push_back(masks[segmentOrderArray[n]])"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} masks .)",
    "insertText": "swap(orderedMasks)"
  },
  {
    "label": "extractActiveVoxelSegmentMasks()",
    "kind": "Method",
    "detail": "Function (std::vector<BoolTreePtrType> maskSegmentArray ;)",
    "insertText": "extractActiveVoxelSegmentMasks(inputTree, maskSegmentArray)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (const size_t numSegments =)",
    "insertText": "max(size_t(1), maskSegmentArray.size())"
  },
  {
    "label": "outputSegmentArray()",
    "kind": "Method",
    "detail": "Function (std::vector<TreePtrType>)",
    "insertText": "outputSegmentArray(numSegments)"
  },
  {
    "label": "TreePtrType()",
    "kind": "Method",
    "detail": "Function (outputSegmentArray [ 0 ] =)",
    "insertText": "TreePtrType(new TreeType(inputTree.background()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(numSegments == 1)"
  },
  {
    "label": "segment()",
    "kind": "Method",
    "detail": "Function (TreePtrType)",
    "insertText": "segment(new TreeType(inputTree))"
  },
  {
    "label": "topologyIntersection()",
    "kind": "Method",
    "detail": "Function (segment ->)",
    "insertText": "topologyIntersection(*maskSegmentArray[0])"
  },
  {
    "label": "segmentRange()",
    "kind": "Method",
    "detail": "Function (} outputSegmentArray [ 0 ] = segment ; } else { const tbb::blocked_range<size_t>)",
    "insertText": "segmentRange(0, numSegments)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(segmentRange, level_set_util_internal::MaskedCopy<TreeType>(inputTree, outputSegmentArray, maskSegmentArray))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(auto& segment : outputSegmentArray)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (segments .)",
    "insertText": "push_back(level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct( volume, segment))"
  },
  {
    "label": "extractIsosurfaceMask()",
    "kind": "Method",
    "detail": "Function (BoolTreePtrType mask =)",
    "insertText": "extractIsosurfaceMask(inputTree, lsutilGridZero<GridOrTreeType>())"
  },
  {
    "label": "extractActiveVoxelSegmentMasks()",
    "kind": "Method",
    "detail": "Function (std::vector<BoolTreePtrType> maskSegmentArray ;)",
    "insertText": "extractActiveVoxelSegmentMasks(*mask, maskSegmentArray)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(segmentRange, level_set_util_internal::ExpandNarrowbandMask<TreeType>(inputTree, maskSegmentArray))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(segmentRange, level_set_util_internal::MaskedCopy<TreeType>( inputTree, outputSegmentArray, maskSegmentArray))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(segmentRange, level_set_util_internal::FloodFillSign<TreeType>(inputTree, outputSegmentArray))"
  }
]