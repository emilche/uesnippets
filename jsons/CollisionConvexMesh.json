[
  {
    "label": "FConvexBuilder",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConvexBuilder"
  },
  {
    "label": "EBuildMethod",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EBuildMethod"
  },
  {
    "label": "Params",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Params"
  },
  {
    "label": "FMemPool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMemPool"
  },
  {
    "label": "FHalfEdge",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHalfEdge"
  },
  {
    "label": "FConvexFace",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConvexFace"
  },
  {
    "label": "TPair",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TPair"
  },
  {
    "label": "FPointSegment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPointSegment"
  },
  {
    "label": "TriQuadPrismInflation()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Chaos / Box . h \" # include \" TriangleMesh . h \" # include \" Particles . h \" # include \" ChaosLog . h \" # include \" Containers / ChunkedArray . h \" # include \" CompGeom / ConvexHull3 . h \" # define DEBUG_HULL_GENERATION 0 # define DEBUG_HULL_GENERATION_HULLSTEPS_TO_OBJ 0 # define DEBUG_HULL_GENERATION_BUILDHORIZON_TO_OBJ 0 namespace Chaos { FRealSingle)",
    "insertText": "TriQuadPrismInflation()"
  },
  {
    "label": "SuggestEpsilon()",
    "kind": "Method",
    "detail": "Function (} FRealType HorizonEpsilon ; } ; FRealType)",
    "insertText": "SuggestEpsilon(const TArray<FVec3Type>& InVertices)"
  },
  {
    "label": "MaxAxes()",
    "kind": "Method",
    "detail": "Function (} FVec3Type)",
    "insertText": "MaxAxes(TNumericLimits<FRealType>::Lowest())"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 NumVertices = InVertices .)",
    "insertText": "Num()"
  },
  {
    "label": "GetAbs()",
    "kind": "Method",
    "detail": "Function (FVec3Type PositionAbs = InVertices [ Index ] .)",
    "insertText": "GetAbs()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MaxAxes [ 0 ] =)",
    "insertText": "Max(MaxAxes[0], PositionAbs[0])"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MaxAxes [ 1 ] =)",
    "insertText": "Max(MaxAxes[1], PositionAbs[1])"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MaxAxes [ 2 ] =)",
    "insertText": "Max(MaxAxes[2], PositionAbs[2])"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (} return 3 . 0)",
    "insertText": "f(MaxAxes[0] + MaxAxes[1] + MaxAxes[2])"
  },
  {
    "label": "IsValidTriangle()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValidTriangle(const FVec3Type& A, const FVec3Type& B, const FVec3Type& C, FVec3Type& OutNormal)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const FVec3Type BA = B - A ; const FVec3Type CA = C - A ; const FVec3Type Cross =)",
    "insertText": "CrossProduct(BA, CA)"
  },
  {
    "label": "GetUnsafeNormal()",
    "kind": "Method",
    "detail": "Function (OutNormal = Cross .)",
    "insertText": "GetUnsafeNormal()"
  },
  {
    "label": "IsValidTriangle()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValidTriangle(const FVec3Type& A, const FVec3Type& B, const FVec3Type& C)"
  },
  {
    "label": "Normal()",
    "kind": "Method",
    "detail": "Function (FVec3Type)",
    "insertText": "Normal(0)"
  },
  {
    "label": "IsValidQuad()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValidQuad(const FVec3Type& A, const FVec3Type& B, const FVec3Type& C, const FVec3Type& D, FVec3Type& OutNormal)"
  },
  {
    "label": "TriPlane()",
    "kind": "Method",
    "detail": "Function (const UE::Math::TPlane<FRealType>)",
    "insertText": "TriPlane(A, B, C)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const FRealType DPointDistance =)",
    "insertText": "Abs(TriPlane.PlaneDot(D))"
  },
  {
    "label": "FVec3Type()",
    "kind": "Method",
    "detail": "Function (OutNormal =)",
    "insertText": "FVec3Type(TriPlane.X, TriPlane.Y, TriPlane.Z)"
  },
  {
    "label": "IsPlanarShape()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsPlanarShape(const TArray<FVec3Type>& InVertices, FVec3Type& OutNormal)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const FRealType PointPlaneDot =)",
    "insertText": "Abs(TriPlane.PlaneDot(InVertices[Index]))"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset(FacePlane)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset(const FPlaneType& FacePlane)"
  },
  {
    "label": "FConvexFace()",
    "kind": "Method",
    "detail": "Function (ConflictList = nullptr ; Plane = FacePlane ; })",
    "insertText": "FConvexFace()"
  },
  {
    "label": "FHalfEdge()",
    "kind": "Method",
    "detail": "Function (FMemPool ; TChunkedArray<FConvexFace> ; } ; struct FHalfEdge { int32 Vertex ; FHalfEdge* Prev ; FHalfEdge* Next ; FHalfEdge* Twin ; FConvexFace* Face ; int32 PoolIdx ; private :)",
    "insertText": "FHalfEdge(int32 InPoolIdx, int32 InVertex) : PoolIdx(InPoolIdx)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset(InVertex)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset(int32 InVertex)"
  },
  {
    "label": "FHalfEdge()",
    "kind": "Method",
    "detail": "Function (Vertex = InVertex ; })",
    "insertText": "FHalfEdge()"
  },
  {
    "label": "AllocHalfEdge()",
    "kind": "Method",
    "detail": "Function (FMemPool ; TChunkedArray<FHalfEdge> ; } ; class FMemPool { public : FHalfEdge*)",
    "insertText": "AllocHalfEdge(int32 InVertex =-1)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (const uint32 Idx = HalfEdgesFreeIndices .)",
    "insertText": "Pop(EAllowShrinking::No)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (HalfEdgesFreeIndices .)",
    "insertText": "Add(HalfEdge->PoolIdx)"
  },
  {
    "label": "FreeConvexFace()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FreeConvexFace(FConvexFace* Face)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (FacesFreeIndices .)",
    "insertText": "Add(Face->PoolIdx)"
  },
  {
    "label": "Build()",
    "kind": "Method",
    "detail": "Function (} private : TArray<int32> HalfEdgesFreeIndices ; TChunkedArray<FHalfEdge> HalfEdges ; TArray<int32> FacesFreeIndices ; TChunkedArray<FConvexFace> Faces ; } ; public : void)",
    "insertText": "Build(const TArray<FVec3Type>& InVertices, TArray<FPlaneType>& OutPlanes, TArray<TArray<int32>>& OutFaceIndices, TArray<FVec3Type>& OutVertices, FAABB3Type& OutLocalBounds, EBuildMethod BuildMethod = EBuildMethod::Default)"
  },
  {
    "label": "UseConvexHull3()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UseConvexHull3(EBuildMethod BuildMethod)"
  },
  {
    "label": "UseConvexHull3Simplifier()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UseConvexHull3Simplifier(EBuildMethod BuildMethod)"
  },
  {
    "label": "BuildIndices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildIndices(const TArray<FVec3Type>& InVertices, TArray<int32>& OutResultIndexData, EBuildMethod BuildMethod = EBuildMethod::Default)"
  },
  {
    "label": "BuildConvexHull()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildConvexHull(const TArray<FVec3Type>& InVertices, TArray<TVec3<int32>>& OutIndices, const Params& InParams = Params())"
  },
  {
    "label": "TRACE_CPUPROFILER_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_CPUPROFILER_EVENT_SCOPE(Chaos::BuildConvexHull)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (OutIndices .)",
    "insertText": "Reset()"
  },
  {
    "label": "BuildInitialHull()",
    "kind": "Method",
    "detail": "Function (FMemPool Pool ; FConvexFace* Faces =)",
    "insertText": "BuildInitialHull(Pool, InVertices)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (FConvexFace* Current = Faces ;)",
    "insertText": "while(Current)"
  },
  {
    "label": "Printf()",
    "kind": "Method",
    "detail": "Function (InitialFacesString + =)",
    "insertText": "Printf(TEXT(\"(%d %d %d) \"), Current->FirstEdge->Vertex, Current->FirstEdge->Next->Vertex, Current->FirstEdge->Prev->Vertex)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (Current = Current -> Next ; })",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"%s\"), *InitialFacesString)"
  },
  {
    "label": "AllocConvexFace()",
    "kind": "Method",
    "detail": "Function (# endif FConvexFace* DummyFace = Pool .)",
    "insertText": "AllocConvexFace(Faces->Plane)"
  },
  {
    "label": "FindConflictVertex()",
    "kind": "Method",
    "detail": "Function (DummyFace -> Prev = nullptr ; DummyFace -> Next = Faces ; Faces -> Prev = DummyFace ; FHalfEdge* ConflictV =)",
    "insertText": "FindConflictVertex(InVertices, DummyFace->Next)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (# if DEBUG_HULL_GENERATION # if DEBUG_HULL_GENERATION_HULLSTEPS_TO_OBJ)",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"# ======================================================\"))"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (const FVec3Type ConflictPos = InVertices [ ConflictV -> Vertex ] ;)",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"# GENERATED HULL before adding Vtx %d (%f %f %f)\"), ConflictV->Vertex, ConflictPos.X, ConflictPos.Y, ConflictPos.Z)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (FConvexFace* Face = DummyFace -> Next ;)",
    "insertText": "while(Face)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (const FVector P1 = InVertices [ Face -> FirstEdge -> Prev -> Vertex ] ; const FVector P2 = InVertices [ Face -> FirstEdge -> Next -> Vertex ] ; const FVector P3 = InVertices [ Face -> FirstEdge -> Vertex ] ;)",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"v %f %f %f\"), P1.X, P1.Y, P1.Z)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Face = Face -> Next ; } # endif # endif)",
    "insertText": "if(!AddVertex(Pool, InVertices, ConflictV, InParams))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} FConvexFace* Cur = DummyFace -> Next ;)",
    "insertText": "while(Cur)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutIndices .)",
    "insertText": "Add(TVec3<int32>(Cur->FirstEdge->Vertex, Cur->FirstEdge->Next->Vertex, Cur->FirstEdge->Next->Next->Vertex))"
  },
  {
    "label": "BuildConvexHullTriMesh()",
    "kind": "Method",
    "detail": "Function (FConvexFace* Next = Cur -> Next ; Cur = Next ; } } FTriangleMesh)",
    "insertText": "BuildConvexHullTriMesh(const TArray<FVec3Type>& InVertices)"
  },
  {
    "label": "BuildConvexHull()",
    "kind": "Method",
    "detail": "Function (TArray<TVec3<int32>> Indices ;)",
    "insertText": "BuildConvexHull(InVertices, Indices)"
  },
  {
    "label": "IsPerformanceWarning()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsPerformanceWarning(int32 NumPlanes, int32 NumVertices)"
  },
  {
    "label": "IsGeometryReductionEnabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsGeometryReductionEnabled()"
  },
  {
    "label": "PerformanceWarningString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "PerformanceWarningString(int32 NumPlanes, int32 NumVertices)"
  },
  {
    "label": "Simplify()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Simplify(TArray<FPlaneType>& InOutPlanes, TArray<TArray<int32>>& InOutFaces, TArray<FVec3Type>& InOutVertices, FAABB3Type& InOutLocalBounds)"
  },
  {
    "label": "TPair()",
    "kind": "Method",
    "detail": "Function (struct TPair {)",
    "insertText": "TPair() : A(-1), B(-1)"
  },
  {
    "label": "Vertices()",
    "kind": "Method",
    "detail": "Function (TArray<FVec3Type>)",
    "insertText": "Vertices(InOutVertices)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (IsDeleted .)",
    "insertText": "Init(false, Size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TPair ClosestPair ; FRealType ClosestDistSqr = FLT_MAX ;)",
    "insertText": "for(int32 A = 0; A < (Size - 1); A++)"
  },
  {
    "label": "SizeSquared()",
    "kind": "Method",
    "detail": "Function (FVec3Type Vec = Vertices [ A ] - Vertices [ B ] ; FRealType LengthSqr = Vec .)",
    "insertText": "SizeSquared()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ClosestDistSqr = LengthSqr ; ClosestPair . A = A ; ClosestPair . B = B ; } } } } })",
    "insertText": "if(ClosestPair.A != -1)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (Vertices [ ClosestPair . A ] = Vertices [ ClosestPair .)",
    "insertText": "A(Vertices[ClosestPair.B] - Vertices[ClosestPair.A])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (IsDeleted [ ClosestPair . B ] = true ; } } } TArray<FVec3Type> TmpVertices ;)",
    "insertText": "for(int Idx = 0; Idx < Vertices.Num(); Idx++)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (TmpVertices .)",
    "insertText": "Add(Vertices[Idx])"
  },
  {
    "label": "Build()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "Build(TmpVertices, InOutPlanes, InOutFaces, InOutVertices, InOutLocalBounds)"
  },
  {
    "label": "IsFaceOutlineConvex()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsFaceOutlineConvex(const FPlaneType& Plane, const TArray<int32>& Indices, const TArray<FVec3Type>& Vertices)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<int8> Signs ; Signs .)",
    "insertText": "SetNum(Indices.Num())"
  },
  {
    "label": "Indices()",
    "kind": "Method",
    "detail": "Function (const int32 Index0 = Indices [ PointIndex ] ; const int32 Index1 =)",
    "insertText": "Indices(PointIndex + 1) % Indices.Num()"
  },
  {
    "label": "Indices()",
    "kind": "Method",
    "detail": "Function (const int32 Index2 =)",
    "insertText": "Indices(PointIndex + 2) % Indices.Num()"
  },
  {
    "label": "Segment0()",
    "kind": "Method",
    "detail": "Function (const FVec3Type Point0 = Vertices [ Index0 ] ; const FVec3Type Point1 = Vertices [ Index1 ] ; const FVec3Type Point2 = Vertices [ Index2 ] ; const FVec3Type)",
    "insertText": "Segment0(Point1 - Point0)"
  },
  {
    "label": "Segment1()",
    "kind": "Method",
    "detail": "Function (const FVec3Type)",
    "insertText": "Segment1(Point2 - Point1)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (const FVec3Type Cross =)",
    "insertText": "CrossProduct(Segment0, Segment1)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FRealType Dot =)",
    "insertText": "DotProduct(Cross, Plane.Normal())"
  },
  {
    "label": "int8()",
    "kind": "Method",
    "detail": "Function (Signs [ PointIndex ] = static_cast<)",
    "insertText": "int8(FMath::Sign(Dot))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} int8 RefSign = 0 ;)",
    "insertText": "for(const int8 Sign : Signs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (RefSign = Sign ; })",
    "insertText": "if(Sign != 0 && RefSign != Sign)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 PlaneIndex = 0 ;)",
    "insertText": "while(PlaneIndex < InOutPlanes.Num())"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (InOutFaceVertexIndices .)",
    "insertText": "RemoveAtSwap(PlaneIndex)"
  },
  {
    "label": "MergeFaces()",
    "kind": "Method",
    "detail": "Function (} else { + + PlaneIndex ; } } } void)",
    "insertText": "MergeFaces(TArray<FPlaneType>& InOutPlanes, TArray<TArray<int32>>& InOutFaceVertexIndices, const TArray<FVec3Type>& Vertices, FRealType DistanceThreshold)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const FRealType NormalThreshold = 1 . e - 4 f ;)",
    "insertText": "for(int32 PlaneIndex0 = 0; PlaneIndex0 < InOutPlanes.Num(); ++PlaneIndex0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const FPlaneType& Plane0 = InOutPlanes [ PlaneIndex0 ] ; TArray<int32>& Vertices0 = InOutFaceVertexIndices [ PlaneIndex0 ] ;)",
    "insertText": "for(int32 PlaneIndex1 = PlaneIndex0 + 1; PlaneIndex1 < InOutPlanes.Num(); ++PlaneIndex1)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FPlaneType& Plane1 = InOutPlanes [ PlaneIndex1 ] ; const TArray<int32>& Vertices1 = InOutFaceVertexIndices [ PlaneIndex1 ] ; const FRealType PlaneNormalDot =)",
    "insertText": "DotProduct(Plane0.Normal(), Plane1.Normal())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bWithinDistanceThreshold = true ;)",
    "insertText": "for(int32 Plane0VertexIndex : Vertices0)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const FVec3Type Plane0Vertex = Vertices [ Plane0VertexIndex ] ; const FRealType Plane0VertexDistance =)",
    "insertText": "Abs(FVec3Type::DotProduct(Plane1.X() - Plane0Vertex, Plane1.Normal()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bWithinDistanceThreshold = false ; break ; } })",
    "insertText": "if(bWithinDistanceThreshold)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const FVec3Type Plane1Vertex = Vertices [ Plane1VertexIndex ] ; const FRealType Plane1VertexDistance =)",
    "insertText": "Abs(FVec3Type::DotProduct(Plane0.X() - Plane1Vertex, Plane0.Normal()))"
  },
  {
    "label": "AddUnique()",
    "kind": "Method",
    "detail": "Function (Vertices0 .)",
    "insertText": "AddUnique(Vertices1[VertexIndex1])"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (} InOutPlanes .)",
    "insertText": "RemoveAtSwap(PlaneIndex1, EAllowShrinking::No)"
  },
  {
    "label": "FinalizeFaces()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FinalizeFaces(InOutPlanes[PlaneIndex0], InOutFaceVertexIndices[PlaneIndex0], Vertices)"
  },
  {
    "label": "ensure()",
    "kind": "Method",
    "detail": "Function (# if DEBUG_HULL_GENERATION)",
    "insertText": "ensure(IsFaceOutlineConvex(InOutPlanes[PlaneIndex0], InOutFaceVertexIndices[PlaneIndex0], Vertices))"
  },
  {
    "label": "RemoveInvalidFaces()",
    "kind": "Method",
    "detail": "Function (# endif })",
    "insertText": "RemoveInvalidFaces(InOutPlanes, InOutFaceVertexIndices)"
  },
  {
    "label": "MergeColinearEdges()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MergeColinearEdges(TArray<FPlaneType>& InOutPlanes, TArray<TArray<int32>>& InOutFaceVertexIndices, TArray<FVec3Type>& InOutVertices, FRealType AngleToleranceCos)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<int32> VertexIndexMap ; VertexIndexMap .)",
    "insertText": "SetNum(InOutVertices.Num())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (VertexIndex = INDEX_NONE ; })",
    "insertText": "for(int32 PlaneIndex0 = 0; PlaneIndex0 < InOutFaceVertexIndices.Num(); ++PlaneIndex0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<int32>& FaceVertexIndices = InOutFaceVertexIndices [ PlaneIndex0 ] ;)",
    "insertText": "if(FaceVertexIndices.Num() > 2)"
  },
  {
    "label": "Edge0()",
    "kind": "Method",
    "detail": "Function (int32 VertexIndex2 = FaceVertexIndices [ FaceVertexIndex ] ; const FVec3)",
    "insertText": "Edge0(InOutVertices[VertexIndex1] - InOutVertices[VertexIndex0]).GetSafeNormal()"
  },
  {
    "label": "Edge1()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "Edge1(InOutVertices[VertexIndex2] - InOutVertices[VertexIndex1]).GetSafeNormal()"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FReal CosAngle =)",
    "insertText": "DotProduct(Edge0, Edge1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (VertexIndexMap [ VertexIndex1 ] = VertexIndex1 ; } VertexIndex0 = VertexIndex1 ; VertexIndex1 = VertexIndex2 ; } } } int32 NumVerticesRemoved = 0 ;)",
    "insertText": "for(int32 VertexIndex = 0; VertexIndex < InOutVertices.Num(); ++VertexIndex)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (InOutFaceVertexIndices [ PlaneIndex0 ] .)",
    "insertText": "Remove(VertexIndex)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (InOutFaceVertexIndices .)",
    "insertText": "RemoveAt(PlaneIndex0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } + + NumVerticesRemoved ; } else { VertexIndexMap [ VertexIndex ] = VertexIndex - NumVerticesRemoved ; } })",
    "insertText": "if(NumVerticesRemoved > 0)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (InOutVertices .)",
    "insertText": "RemoveAt(VertexIndex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (TArray<int32>& FaceVertexIndices = InOutFaceVertexIndices [ PlaneIndex0 ] ;)",
    "insertText": "for(int32 FaceVertexIndex = FaceVertexIndices.Num() - 1; FaceVertexIndex >= 0; --FaceVertexIndex)"
  },
  {
    "label": "RemoveInsideFaceVertices()",
    "kind": "Method",
    "detail": "Function (FaceVertexIndices [ FaceVertexIndex ] = VertexIndexMap [ FaceVertexIndices [ FaceVertexIndex ] ] ; } } } } void)",
    "insertText": "RemoveInsideFaceVertices(const FPlaneType& Face, TArray<int32>& InOutFaceVertexIndices, const TArray<FVec3Type>& Vertices, const FVec3Type& Centroid)"
  },
  {
    "label": "SquaredDistance()",
    "kind": "Method",
    "detail": "Function (const FRealType)",
    "insertText": "SquaredDistance(Vertices[InOutFaceVertexIndices[Index]] - Centroid).SquaredLength()"
  },
  {
    "label": "InOutFaceVertexIndices()",
    "kind": "Method",
    "detail": "Function (struct FPointSegment { int32 VtxIndex ; FVec3Type Segment ; } ; const int32 VtxStartIndex = InOutFaceVertexIndices [ StartIndex ] ; int32 VtxIndex0 = VtxStartIndex ; int32 VtxIndex1 =)",
    "insertText": "InOutFaceVertexIndices(StartIndex + 1)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (TArray<FPointSegment> Stack ; Stack .)",
    "insertText": "Push({ VtxIndex0, FVec3Type{0} })"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (Stack .)",
    "insertText": "Push({ VtxIndex1, Vertices[VtxIndex1] - Vertices[VtxIndex0] })"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 Step = 2 ;)",
    "insertText": "while(Step <= VtxCount)"
  },
  {
    "label": "NextIndex()",
    "kind": "Method",
    "detail": "Function (const int32)",
    "insertText": "NextIndex(StartIndex + Step)"
  },
  {
    "label": "Last()",
    "kind": "Method",
    "detail": "Function (const FPointSegment& LastOnStack = Stack .)",
    "insertText": "Last()"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (VtxIndex0 = LastOnStack . VtxIndex ; VtxIndex1 = InOutFaceVertexIndices [ NextIndex ] ; const FVec3Type Segment = Vertices [ VtxIndex1 ] - Vertices [ VtxIndex0 ] ; const FVec3 Cross =)",
    "insertText": "CrossProduct(LastOnStack.Segment, Segment)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (Stack .)",
    "insertText": "Push({ VtxIndex1, Segment })"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (} Step + + ; } else { Stack .)",
    "insertText": "Pop()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (InOutFaceVertexIndices .)",
    "insertText": "Add(PointSegment.VtxIndex)"
  },
  {
    "label": "SortFaceVerticesCCW()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "SortFaceVerticesCCW(const FPlaneType& Face, TArray<int32>& InOutFaceVertexIndices, const TArray<FVec3Type>& Vertices, const FVec3Type& Centroid)"
  },
  {
    "label": "FaceMatrix()",
    "kind": "Method",
    "detail": "Function (const FMatrix33)",
    "insertText": "FaceMatrix(FMatrix44f)FRotationMatrix::MakeFromZ(FVector(Face.Normal()))"
  },
  {
    "label": "Vertices()",
    "kind": "Method",
    "detail": "Function (auto VertexScore = [& Centroid,& FaceMatrix,&)",
    "insertText": "Vertices(int32 VertexIndex)"
  },
  {
    "label": "CentroidOffsetDir()",
    "kind": "Method",
    "detail": "Function (const FVec3Type)",
    "insertText": "CentroidOffsetDir(Vertices[VertexIndex] - Centroid).GetSafeNormal()"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FRealType DotX =)",
    "insertText": "DotProduct(CentroidOffsetDir, FaceMatrix.GetAxis(0))"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FRealType DotY =)",
    "insertText": "DotProduct(CentroidOffsetDir, FaceMatrix.GetAxis(1))"
  },
  {
    "label": "Score()",
    "kind": "Method",
    "detail": "Function (const FRealType)",
    "insertText": "Score(DotX >= 0.0f)"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (} ; InOutFaceVertexIndices .)",
    "insertText": "Sort(VertexSortPredicate)"
  },
  {
    "label": "FinalizeFaces()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FinalizeFaces(const FPlaneType& Face, TArray<int32>& InOutFaceVertexIndices, const TArray<FVec3Type>& Vertices)"
  },
  {
    "label": "Centroid()",
    "kind": "Method",
    "detail": "Function (FVec3Type)",
    "insertText": "Centroid(0)"
  },
  {
    "label": "FRealType()",
    "kind": "Method",
    "detail": "Function (Centroid + = Vertices [ InOutFaceVertexIndices [ VertexIndex ] ] ; } Centroid / =)",
    "insertText": "FRealType(InOutFaceVertexIndices.Num())"
  },
  {
    "label": "SortFaceVerticesCCW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SortFaceVerticesCCW(Face, InOutFaceVertexIndices, Vertices, Centroid)"
  },
  {
    "label": "RemoveInsideFaceVertices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveInsideFaceVertices(Face, InOutFaceVertexIndices, Vertices, Centroid)"
  },
  {
    "label": "BuildPlaneVertexIndices()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BuildPlaneVertexIndices(TArray<FPlaneType>& InPlanes, const TArray<FVec3Type>& Vertices, TArray<TArray<int32>>& OutFaceVertexIndices, const FRealType DistanceTolerance = 1.e-3f)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (OutFaceVertexIndices .)",
    "insertText": "Reset(InPlanes.Num())"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FRealType PlaneVertexDistance =)",
    "insertText": "DotProduct(InPlanes[PlaneIndex].Normal(), Vertices[VertexIndex] - InPlanes[PlaneIndex].X())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutFaceVertexIndices [ PlaneIndex ] .)",
    "insertText": "Add(VertexIndex)"
  },
  {
    "label": "FinalizeFaces()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "FinalizeFaces(InPlanes[PlaneIndex], OutFaceVertexIndices[PlaneIndex], Vertices)"
  },
  {
    "label": "RemoveInvalidFaces()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RemoveInvalidFaces(InPlanes, OutFaceVertexIndices)"
  },
  {
    "label": "ComputeFaceNormal()",
    "kind": "Method",
    "detail": "Function (} int32 PerformGeometryCheck ; int32 PerformGeometryReduction ; int32 VerticesThreshold ; int32 ComputeHorizonEpsilonFromMeshExtends ; bool bUseGeometryTConvexHull3 ; bool bUseSimplifierForTConvexHull3 ; private : FVec3Type)",
    "insertText": "ComputeFaceNormal(const FVec3Type& A, const FVec3Type& B, const FVec3Type& C)"
  },
  {
    "label": "CreateFace()",
    "kind": "Method",
    "detail": "Function (} FConvexFace*)",
    "insertText": "CreateFace(FMemPool& Pool, const TArray<FVec3Type>& InVertices, FHalfEdge* RS, FHalfEdge* ST, FHalfEdge* TR)"
  },
  {
    "label": "ComputeFaceNormal()",
    "kind": "Method",
    "detail": "Function (RS -> Prev = TR ; RS -> Next = ST ; ST -> Prev = RS ; ST -> Next = TR ; TR -> Prev = ST ; TR -> Next = RS ; FVec3Type RSTNormal =)",
    "insertText": "ComputeFaceNormal(InVertices[RS->Vertex], InVertices[ST->Vertex], InVertices[TR->Vertex])"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (const FRealType RSTNormalSize = RSTNormal .)",
    "insertText": "Size()"
  },
  {
    "label": "RSTNormal()",
    "kind": "Method",
    "detail": "Function (RSTNormal =)",
    "insertText": "RSTNormal(1 / RSTNormalSize)"
  },
  {
    "label": "Normal()",
    "kind": "Method",
    "detail": "Function (} else { RSTNormal = RS -> Twin -> Face -> Plane .)",
    "insertText": "Normal()"
  },
  {
    "label": "AllocConvexFace()",
    "kind": "Method",
    "detail": "Function (} FConvexFace* RST = Pool .)",
    "insertText": "AllocConvexFace(FPlaneType(InVertices[RS->Vertex], RSTNormal))"
  },
  {
    "label": "StealConflictList()",
    "kind": "Method",
    "detail": "Function (RST -> FirstEdge = RS ; RS -> Face = RST ; ST -> Face = RST ; TR -> Face = RST ; return RST ; } void)",
    "insertText": "StealConflictList(FMemPool& Pool, const TArray<FVec3Type>& InVertices, FHalfEdge* OldList, FConvexFace** Faces, int32 NumFaces)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FRealType MaxD = 1 e - 4 f ; int32 MaxIdx = - 1 ;)",
    "insertText": "for(int32 Idx = 0; Idx < NumFaces; ++Idx)"
  },
  {
    "label": "SignedDistance()",
    "kind": "Method",
    "detail": "Function (FRealType Distance = Faces [ Idx ] -> Plane .)",
    "insertText": "SignedDistance(InVertices[Cur->Vertex])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MaxD = Distance ; MaxIdx = Idx ; } } bool bDeleteVertex = MaxIdx = = - 1 ;)",
    "insertText": "if(!bDeleteVertex)"
  },
  {
    "label": "InVertices()",
    "kind": "Method",
    "detail": "Function (auto PretendNormal = [&)",
    "insertText": "InVertices(FHalfEdge* A, FHalfEdge* B, FHalfEdge* C)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ; FHalfEdge* Edge = Faces [ MaxIdx ] -> FirstEdge ; do {)",
    "insertText": "if(PretendNormal(Edge->Prev, Edge, Cur) < 1e-4)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (bDeleteVertex = true ; break ; } Edge = Edge -> Next ; })",
    "insertText": "while(Edge != Faces[MaxIdx]->FirstEdge)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FHalfEdge* Next = Cur -> Next ; FHalfEdge*& ConflictList = Faces [ MaxIdx ] -> ConflictList ;)",
    "insertText": "if(ConflictList)"
  },
  {
    "label": "FreeHalfEdge()",
    "kind": "Method",
    "detail": "Function (ConflictList -> Prev = Cur ; } Cur -> Next = ConflictList ; ConflictList = Cur ; Cur -> Prev = nullptr ; Cur = Next ; } else { FHalfEdge* Next = Cur -> Next ; Pool .)",
    "insertText": "FreeHalfEdge(Cur)"
  },
  {
    "label": "BuildInitialHull()",
    "kind": "Method",
    "detail": "Function (Cur = Next ; } } } FConvexFace*)",
    "insertText": "BuildInitialHull(FMemPool& Pool, const TArray<FVec3Type>& InVertices)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (FRealType MinX = TNumericLimits<FRealType)",
    "insertText": "Max()"
  },
  {
    "label": "Lowest()",
    "kind": "Method",
    "detail": "Function (FRealType MaxX = TNumericLimits<FRealType)",
    "insertText": "Lowest()"
  },
  {
    "label": "AllocHalfEdge()",
    "kind": "Method",
    "detail": "Function (FHalfEdge* A = nullptr ; FHalfEdge* B = nullptr ; FHalfEdge* DummyHalfEdge = Pool .)",
    "insertText": "AllocHalfEdge(-1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (DummyHalfEdge -> Prev = nullptr ; DummyHalfEdge -> Next = nullptr ; FHalfEdge* Prev = DummyHalfEdge ;)",
    "insertText": "for(int32 i = 0; i < NumVertices; ++i)"
  },
  {
    "label": "AllocHalfEdge()",
    "kind": "Method",
    "detail": "Function (FHalfEdge* VHalf = Pool .)",
    "insertText": "AllocHalfEdge(i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Prev -> Next = VHalf ; VHalf -> Prev = Prev ; VHalf -> Next = nullptr ; const FVec3Type& V = InVertices [ i ] ;)",
    "insertText": "if(V[0] < MinX)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MinX = V [ 0 ] ; A = VHalf ; })",
    "insertText": "if(V[0] > MaxX)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (MaxX = V [ 0 ] ; B = VHalf ; } Prev = VHalf ; })",
    "insertText": "check(A && B)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (A -> Next -> Prev = A -> Prev ; } B -> Prev -> Next = B -> Next ;)",
    "insertText": "if(B->Next)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (B -> Next -> Prev = B -> Prev ; } FRealType MaxTriSize = Epsilon ; const FVec3Type AToB = InVertices [ B -> Vertex ] - InVertices [ A -> Vertex ] ; FHalfEdge* C = nullptr ;)",
    "insertText": "for(FHalfEdge* V = DummyHalfEdge->Next; V; V = V->Next)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (FRealType TriSize =)",
    "insertText": "CrossProduct(AToB, InVertices[V->Vertex] - InVertices[A->Vertex]).SizeSquared()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MaxTriSize = TriSize ; C = V ; } })",
    "insertText": "if(C == nullptr)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (C -> Next -> Prev = C -> Prev ; } const FVec3Type AToC = InVertices [ C -> Vertex ] - InVertices [ A -> Vertex ] ; const FVec3Type Normal =)",
    "insertText": "CrossProduct(AToB, AToC).GetSafeNormal()"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (FRealType Dot =)",
    "insertText": "DotProduct(InVertices[V->Vertex] - InVertices[A->Vertex], Normal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MaxPosDistance = Dot ; PosD = V ; })",
    "insertText": "if(-Dot > MaxNegDistance)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MaxNegDistance = - Dot ; NegD = V ; } })",
    "insertText": "if(MaxNegDistance == Epsilon && MaxPosDistance == Epsilon)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (D -> Prev -> Next = D -> Next ;)",
    "insertText": "if(D->Next)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (D -> Next -> Prev = D -> Prev ; } FHalfEdge* Edges [ 4 ] = { A,B,C,D } ;)",
    "insertText": "if(bPositive)"
  },
  {
    "label": "CreateFace()",
    "kind": "Method",
    "detail": "Function (FHalfEdge* Tmp = Edges [ 0 ] ; Edges [ 0 ] = Edges [ 1 ] ; Edges [ 1 ] = Tmp ; } FConvexFace* Faces [ 4 ] ; Faces [ 0 ] =)",
    "insertText": "CreateFace(Pool, InVertices, Edges[0], Edges[1], Edges[2])"
  },
  {
    "label": "CreateFace()",
    "kind": "Method",
    "detail": "Function (Faces [ 1 ] =)",
    "insertText": "CreateFace(Pool, InVertices, Pool.AllocHalfEdge(Edges[1]->Vertex), Pool.AllocHalfEdge(Edges[0]->Vertex), Edges[3])"
  },
  {
    "label": "CreateFace()",
    "kind": "Method",
    "detail": "Function (Faces [ 2 ] =)",
    "insertText": "CreateFace(Pool, InVertices, Pool.AllocHalfEdge(Edges[0]->Vertex), Pool.AllocHalfEdge(Edges[2]->Vertex), Pool.AllocHalfEdge(Edges[3]->Vertex))"
  },
  {
    "label": "CreateFace()",
    "kind": "Method",
    "detail": "Function (Faces [ 3 ] =)",
    "insertText": "CreateFace(Pool, InVertices, Pool.AllocHalfEdge(Edges[2]->Vertex), Pool.AllocHalfEdge(Edges[1]->Vertex), Pool.AllocHalfEdge(Edges[3]->Vertex))"
  },
  {
    "label": "MakeTwins()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "MakeTwins(FHalfEdge* E1, FHalfEdge* E2)"
  },
  {
    "label": "MakeTwins()",
    "kind": "Method",
    "detail": "Function (E1 -> Twin = E2 ; E2 -> Twin = E1 ; } ;)",
    "insertText": "MakeTwins(Edges[0], Faces[1]->FirstEdge)"
  },
  {
    "label": "MakeTwins()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MakeTwins(Edges[1], Faces[3]->FirstEdge)"
  },
  {
    "label": "MakeTwins()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MakeTwins(Edges[2], Faces[2]->FirstEdge)"
  },
  {
    "label": "MakeTwins()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MakeTwins(Faces[1]->FirstEdge->Next, Faces[2]->FirstEdge->Prev)"
  },
  {
    "label": "MakeTwins()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MakeTwins(Faces[1]->FirstEdge->Prev, Faces[3]->FirstEdge->Next)"
  },
  {
    "label": "MakeTwins()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MakeTwins(Faces[2]->FirstEdge->Next, Faces[3]->FirstEdge->Prev)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Faces [ 0 ] -> Prev = nullptr ;)",
    "insertText": "for(int i = 1; i < 4; ++i)"
  },
  {
    "label": "StealConflictList()",
    "kind": "Method",
    "detail": "Function (Faces [ i - 1 ] -> Next = Faces [ i ] ; Faces [ i ] -> Prev = Faces [ i - 1 ] ; } Faces [ 3 ] -> Next = nullptr ;)",
    "insertText": "StealConflictList(Pool, InVertices, DummyHalfEdge->Next, Faces, 4)"
  },
  {
    "label": "UE_CLOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_CLOG(DEBUG_HULL_GENERATION, LogChaos, VeryVerbose, TEXT(\"Finding conflict vertex\"))"
  },
  {
    "label": "UE_CLOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_CLOG(DEBUG_HULL_GENERATION, LogChaos, VeryVerbose, TEXT(\"\\tTesting Face (%d %d %d)\"), CurFace->FirstEdge->Vertex, CurFace->FirstEdge->Next->Vertex, CurFace->FirstEdge->Prev->Vertex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FHalfEdge* MaxV = nullptr ;)",
    "insertText": "for(FHalfEdge* CurFaceVertex = CurFace->ConflictList; CurFaceVertex; CurFaceVertex = CurFaceVertex->Next)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (FRealType Dist =)",
    "insertText": "DotProduct(InVertices[CurFaceVertex->Vertex], CurFace->Plane.Normal())"
  },
  {
    "label": "UE_CLOG()",
    "kind": "Method",
    "detail": "Function (MaxD = Dist ; MaxV = CurFaceVertex ; } })",
    "insertText": "UE_CLOG((DEBUG_HULL_GENERATION && !MaxV), LogChaos, VeryVerbose, TEXT(\"\\t\\tNo Conflict List\"))"
  },
  {
    "label": "UE_CLOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_CLOG((DEBUG_HULL_GENERATION && MaxV), LogChaos, VeryVerbose, TEXT(\"\\t\\tFound %d at distance %f\"), MaxV->Vertex, MaxD)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MaxV -> Prev -> Next = MaxV -> Next ; })",
    "insertText": "if(MaxV->Next)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (MaxV -> Next -> Prev = MaxV -> Prev ; })",
    "insertText": "if(MaxV == CurFace->ConflictList)"
  },
  {
    "label": "BuildHorizon()",
    "kind": "Method",
    "detail": "Function (CurFace -> ConflictList = MaxV -> Next ; } MaxV -> Face = CurFace ; return MaxV ; } } return nullptr ; } void)",
    "insertText": "BuildHorizon(const TArray<FVec3Type>& InVertices, FHalfEdge* ConflictV, TArray<FHalfEdge*>& HorizonEdges, TArray<FConvexFace*>& FacesToDelete, const Params& InParams)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (# if DEBUG_HULL_GENERATION)",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"Generate horizon - START\"))"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (# endif const FRealType Epsilon = InParams . HorizonEpsilon ; const FVec3Type V = InVertices [ ConflictV -> Vertex ] ; TSet<FConvexFace*> Processed ; TArray<FHalfEdge*> Queue ;)",
    "insertText": "check(ConflictV->Face)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Queue .)",
    "insertText": "Add(ConflictV->Face->FirstEdge->Prev)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Queue .)",
    "insertText": "Add(ConflictV->Face->FirstEdge->Next)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Queue .)",
    "insertText": "Add(ConflictV->Face->FirstEdge)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (FacesToDelete .)",
    "insertText": "Add(ConflictV->Face)"
  },
  {
    "label": "QueueString()",
    "kind": "Method",
    "detail": "Function (# if DEBUG_HULL_GENERATION FString)",
    "insertText": "QueueString(TEXT(\"\\t Queue (\")); for (const FHalfEdge* QueuedEdge : Queue) { QueueString += FString::Printf(TEXT(\" [%d - %d] \"), QueuedEdge->Vertex, QueuedEdge->Next->Vertex); } QueueString += TEXT(\")\")"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Processed .)",
    "insertText": "Add(Edge->Face)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (FHalfEdge* Twin = Edge -> Twin ; FConvexFace* NextFace = Twin -> Face ; # if DEBUG_HULL_GENERATION)",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"\\tPop edge [%d - %d] from queue\"), Edge->Vertex, Edge->Next->Vertex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(Processed.Contains(NextFace))"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (# if DEBUG_HULL_GENERATION)",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"\\tTwin Face [%d] already processed - skip\"), NextFace)"
  },
  {
    "label": "SignedDistance()",
    "kind": "Method",
    "detail": "Function (# endif continue ; } const FRealType Distance = NextFace -> Plane .)",
    "insertText": "SignedDistance(V)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (# if DEBUG_HULL_GENERATION)",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"\\tDistance [%f] > Epsilon [%f] - add to queue\"), Distance, Epsilon)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (# endif Queue .)",
    "insertText": "Add(Twin->Prev)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Queue .)",
    "insertText": "Add(Twin->Next)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (FacesToDelete .)",
    "insertText": "Add(NextFace)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (} else { # if DEBUG_HULL_GENERATION)",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"\\tAdd [%d - %d] to horizon \"), Edge->Vertex, Edge->Next->Vertex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(HorizonEdges.Num() == 0 || Edge->Vertex == HorizonEdges[HorizonEdges.Num()-1]->Next->Vertex)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (HorizonEdges .)",
    "insertText": "Add(Edge)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (} else { # if DEBUG_HULL_GENERATION)",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"\\tNON VALID EDGE LOOP - internal horizon edge detected [%d - %d] - skipping \"), Edge->Vertex, Edge->Next->Vertex)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (const FVec3Type ConflictPos = InVertices [ ConflictV -> Vertex ] ;)",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"# BUILD_HORIZON - Conflict Vertex = %d (%f %f %f)\"), ConflictV->Vertex, ConflictPos.X, ConflictPos.Y, ConflictPos.Z)"
  },
  {
    "label": "HorizonString()",
    "kind": "Method",
    "detail": "Function (} # endif FString)",
    "insertText": "HorizonString(TEXT(\"> Final Horizon: (\")); for (const FHalfEdge* HorizonEdge : HorizonEdges) { HorizonString += FString::Printf(TEXT(\"%d (%d)\"), HorizonEdge->Vertex, HorizonEdge->Next->Vertex); } HorizonString += TEXT(\")\")"
  },
  {
    "label": "BuildFaces()",
    "kind": "Method",
    "detail": "Function (# endif } bool)",
    "insertText": "BuildFaces(FMemPool& Pool, const TArray<FVec3Type>& InVertices, const FHalfEdge* ConflictV, const TArray<FHalfEdge*>& HorizonEdges, const TArray<FConvexFace*>& OldFaces, TArray<FConvexFace*>& NewFaces)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FHalfEdge* PrevEdge = nullptr ;)",
    "insertText": "for(int32 HorizonIdx = 0; HorizonIdx < HorizonEdges.Num(); ++HorizonIdx)"
  },
  {
    "label": "AllocHalfEdge()",
    "kind": "Method",
    "detail": "Function (FHalfEdge* OriginalEdge = HorizonEdges [ HorizonIdx ] ; FHalfEdge* NewHorizonEdge = Pool .)",
    "insertText": "AllocHalfEdge(OriginalEdge->Vertex)"
  },
  {
    "label": "AllocHalfEdge()",
    "kind": "Method",
    "detail": "Function (NewHorizonEdge -> Twin = OriginalEdge -> Twin ; NewHorizonEdge -> Twin -> Twin = NewHorizonEdge ; FHalfEdge* HorizonNext = Pool .)",
    "insertText": "AllocHalfEdge(OriginalEdge->Next->Vertex)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (V -> Twin = PrevEdge ;)",
    "insertText": "if(PrevEdge)"
  },
  {
    "label": "CreateFace()",
    "kind": "Method",
    "detail": "Function (PrevEdge -> Twin = V ; } PrevEdge = HorizonNext ; FConvexFace* NewFace =)",
    "insertText": "CreateFace(Pool, InVertices, NewHorizonEdge, HorizonNext, V)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { NewFace -> Prev = nullptr ; } NewFaces .)",
    "insertText": "Add(NewFace)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!PrevEdge)"
  },
  {
    "label": "StealConflictList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StealConflictList(Pool, InVertices, OldFace->ConflictList, &NewFaces[0], NewFaces.Num())"
  },
  {
    "label": "AddVertex()",
    "kind": "Method",
    "detail": "Function (OldFace -> Next -> Prev = EndFace ; } EndFace -> Next = OldFace -> Next ; OldFace -> Next = StartFace ; StartFace -> Prev = OldFace ; return true ; } bool)",
    "insertText": "AddVertex(FMemPool& Pool, const TArray<FVec3Type>& InVertices, FHalfEdge* ConflictV, const Params& InParams)"
  },
  {
    "label": "UE_CLOG()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_CLOG(DEBUG_HULL_GENERATION, LogChaos, VeryVerbose, TEXT(\"Adding Vertex %d\"), ConflictV->Vertex)"
  },
  {
    "label": "BuildHorizon()",
    "kind": "Method",
    "detail": "Function (TArray<FHalfEdge*> HorizonEdges ; TArray<FConvexFace*> FacesToDelete ;)",
    "insertText": "BuildHorizon(InVertices, ConflictV, HorizonEdges, FacesToDelete, InParams)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<FConvexFace*> NewFaces ;)",
    "insertText": "if(!ensure(BuildFaces(Pool, InVertices, ConflictV, HorizonEdges, FacesToDelete, NewFaces)))"
  },
  {
    "label": "Printf()",
    "kind": "Method",
    "detail": "Function (NewFaceString + =)",
    "insertText": "Printf(TEXT(\"(%d %d %d) \"), Face->FirstEdge->Vertex, Face->FirstEdge->Next->Vertex, Face->FirstEdge->Prev->Vertex)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"%s\"), *NewFaceString)"
  },
  {
    "label": "DeleteFaceString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "DeleteFaceString(TEXT(\"\\tDelete Faces: \"))"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "UE_LOG(LogChaos, VeryVerbose, TEXT(\"%s\"), *DeleteFaceString)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "for(FConvexFace* Face : FacesToDelete)"
  },
  {
    "label": "FreeHalfEdge()",
    "kind": "Method",
    "detail": "Function (FHalfEdge* Edge = Face -> FirstEdge ; do { FHalfEdge* Next = Edge -> Next ; Pool .)",
    "insertText": "FreeHalfEdge(Next)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Edge = Next ; })",
    "insertText": "while(Edge != Face->FirstEdge)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Face -> Prev -> Next = Face -> Next ; })",
    "insertText": "if(Face->Next)"
  },
  {
    "label": "FreeConvexFace()",
    "kind": "Method",
    "detail": "Function (Face -> Next -> Prev = Face -> Prev ; } Pool .)",
    "insertText": "FreeConvexFace(Face)"
  }
]