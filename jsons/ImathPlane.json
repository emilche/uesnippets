[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "IMATH_EXPORT_TEMPLATE_TYPE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMATH_EXPORT_TEMPLATE_TYPE"
  },
  {
    "label": "Plane3()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHPLANE_H # define INCLUDED_IMATHPLANE_H # include \" ImathExport . h \" # include \" ImathNamespace . h \" # include \" ImathLine . h \" # include \" ImathVec . h \" IMATH_INTERNAL_NAMESPACE_HEADER_ENTER template<class T> class IMATH_EXPORT_TEMPLATE_TYPE Plane3 { public : Vec3<T> normal ; T distance ; IMATH_HOSTDEVICE)",
    "insertText": "Plane3()"
  },
  {
    "label": "Plane3()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Plane3(const Vec3<T>& normal, T distance)"
  },
  {
    "label": "Plane3()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Plane3(const Vec3<T>& point, const Vec3<T>& normal)"
  },
  {
    "label": "Plane3()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Plane3(const Vec3<T>& point1, const Vec3<T>& point2, const Vec3<T>& point3)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "set(const Vec3<T>& normal, T distance)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "set(const Vec3<T>& point, const Vec3<T>& normal)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE void)",
    "insertText": "set(const Vec3<T>& point1, const Vec3<T>& point2, const Vec3<T>& point3)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "intersect(const Line3<T>& line, Vec3<T>& intersection)"
  },
  {
    "label": "intersectT()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "intersectT(const Line3<T>& line, T& parameter)"
  },
  {
    "label": "distanceTo()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "distanceTo(const Vec3<T>& point)"
  },
  {
    "label": "reflectPoint()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Vec3<T>)",
    "insertText": "reflectPoint(const Vec3<T>& point)"
  },
  {
    "label": "reflectVector()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Vec3<T>)",
    "insertText": "reflectVector(const Vec3<T>& vec)"
  },
  {
    "label": "Plane3()",
    "kind": "Method",
    "detail": "Function (} ; typedef Plane3<float> Plane3f ; typedef Plane3<double> Plane3d ; template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Plane3<T)",
    "insertText": "Plane3(const Vec3<T>& p0, const Vec3<T>& p1, const Vec3<T>& p2)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(p0, p1, p2)"
  },
  {
    "label": "Plane3()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Plane3<T)",
    "insertText": "Plane3(const Vec3<T>& n, T d)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(n, d)"
  },
  {
    "label": "Plane3()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Plane3<T)",
    "insertText": "Plane3(const Vec3<T>& p, const Vec3<T>& n)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set(p, n)"
  },
  {
    "label": "normal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "normal(point2 - point1) % (point3 - point1)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (normal .)",
    "insertText": "normalize()"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (distance = normal ^ point1 ; } template<class T> IMATH_HOSTDEVICE void Plane3<T)",
    "insertText": "set(const Vec3<T>& point, const Vec3<T>& n)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (distance = normal ^ point ; } template<class T> IMATH_HOSTDEVICE void Plane3<T)",
    "insertText": "set(const Vec3<T>& n, T d)"
  },
  {
    "label": "reflectVector()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Vec3<T> Plane3<T)",
    "insertText": "reflectVector(const Vec3<T>& v)"
  },
  {
    "label": "intersect()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool Plane3<T)",
    "insertText": "intersect(const Line3<T>& line, Vec3<T>& point)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T d = normal ^ line . dir ;)",
    "insertText": "if(d == 0.0)"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "t((normal ^ line.pos) - distance)"
  },
  {
    "label": "line()",
    "kind": "Method",
    "detail": "Function (point =)",
    "insertText": "line(t)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 Plane3<T>)",
    "insertText": "operator(const Plane3<T>& plane, const Matrix44<T>& M)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Vec3<T> dir1 = Vec3<)",
    "insertText": "T(1, 0, 0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (T dir1Len = dir1 ^ dir1 ; Vec3<T> tmp = Vec3<)",
    "insertText": "T(0, 1, 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T tmpLen = tmp ^ tmp ;)",
    "insertText": "if(tmpLen > dir1Len)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (dir1 = tmp ; dir1Len = tmpLen ; } tmp = Vec3<)",
    "insertText": "T(0, 0, 1)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (dir1 = tmp ; } Vec3<T> dir2 = dir1 % plane . normal ; Vec3<T> point = plane . distance* plane . normal ; return Plane3<)",
    "insertText": "T(point * M, (point + dir2) * M, (point + dir1) * M)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Plane3<T>)",
    "insertText": "operator(const Plane3<T>& plane)"
  }
]