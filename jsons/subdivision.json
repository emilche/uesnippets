[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "HbrFace",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrFace"
  },
  {
    "label": "HbrVertex",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrVertex"
  },
  {
    "label": "HbrHalfedge",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrHalfedge"
  },
  {
    "label": "HbrMesh",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrMesh"
  },
  {
    "label": "HbrSubdivision",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrSubdivision"
  },
  {
    "label": "CreaseSubdivision",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "CreaseSubdivision"
  },
  {
    "label": "SmoothSubdivisionVertexOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmoothSubdivisionVertexOperator"
  },
  {
    "label": "CreaseSubdivisionHalfedgeOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CreaseSubdivisionHalfedgeOperator"
  },
  {
    "label": "RefineFaceAtVertexOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RefineFaceAtVertexOperator"
  },
  {
    "label": "ChaikinEdgeCreaseOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ChaikinEdgeCreaseOperator"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENSUBDIV3_HBRSUBDIVISION_H # define OPENSUBDIV3_HBRSUBDIVISION_H # include \" . . / version . h \" namespace OpenSubdiv { namespace OPENSUBDIV_VERSION { template<class T> class HbrFace ; template<class T> class HbrVertex ; template<class T> class HbrHalfedge ; template<class T> class HbrMesh ; template<class T> class HbrSubdivision { public : HbrSubdivision<)",
    "insertText": "T() : creaseSubdivision(k_CreaseNormal)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} ~ HbrSubdivision<)",
    "insertText": "T()"
  },
  {
    "label": "Clone()",
    "kind": "Method",
    "detail": "Function (} HbrSubdivision<T>*)",
    "insertText": "Clone()"
  },
  {
    "label": "Refine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Refine(HbrMesh<T>* mesh, HbrFace<T>* face)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (HbrFace<T>*)",
    "insertText": "RefineFaceAtVertex(HbrMesh<T>* mesh, HbrFace<T>* face, HbrVertex<T>* vertex)"
  },
  {
    "label": "RefineAtVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RefineAtVertex(HbrMesh<T>* mesh, HbrVertex<T>* vertex)"
  },
  {
    "label": "GuaranteeNeighbor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbor(HbrMesh<T>* mesh, HbrHalfedge<T>* edge)"
  },
  {
    "label": "GuaranteeNeighbors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbors(HbrMesh<T>* mesh, HbrVertex<T>* vertex)"
  },
  {
    "label": "HasLimit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasLimit(HbrMesh<T>* , HbrFace<T>*)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "Subdivide(HbrMesh<T>* mesh, HbrHalfedge<T>* edge)"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>*)",
    "insertText": "Subdivide(HbrMesh<T>* mesh, HbrVertex<T>* vertex)"
  },
  {
    "label": "VertexIsExtraordinary()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "VertexIsExtraordinary(HbrMesh<T> const * , HbrVertex<T>*)"
  },
  {
    "label": "SubdivideCreaseWeight()",
    "kind": "Method",
    "detail": "Function (creaseSubdivision = method ; } void)",
    "insertText": "SubdivideCreaseWeight(HbrHalfedge<T>* edge, HbrVertex<T>* vertex, HbrHalfedge<T>* subedge)"
  },
  {
    "label": "GetFaceChildrenCount()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "GetFaceChildrenCount(int nvertices)"
  },
  {
    "label": "AddSurroundingVerticesWithWeight()",
    "kind": "Method",
    "detail": "Function (protected : CreaseSubdivision creaseSubdivision ; void)",
    "insertText": "AddSurroundingVerticesWithWeight(HbrMesh<T>* mesh, HbrVertex<T>* vertex, float weight, T* data)"
  },
  {
    "label": "AddCreaseEdgesWithWeight()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddCreaseEdgesWithWeight(HbrMesh<T>* mesh, HbrVertex<T>* vertex, bool next, float weight, T* data)"
  },
  {
    "label": "SmoothSubdivisionVertexOperator()",
    "kind": "Method",
    "detail": "Function (private : class SmoothSubdivisionVertexOperator : public HbrVertexOperator<T> { public :)",
    "insertText": "SmoothSubdivisionVertexOperator(T* data, bool meshHasEdits, float weight) : m_data(data), m_meshHasEdits(meshHasEdits), m_weight(weight)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator() (HbrVertex<T> &vertex)"
  },
  {
    "label": "GuaranteeNeighbors()",
    "kind": "Method",
    "detail": "Function (vertex .)",
    "insertText": "GuaranteeNeighbors()"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (} m_data ->)",
    "insertText": "AddWithWeight(vertex.GetData(), m_weight)"
  },
  {
    "label": "CreaseSubdivisionHalfedgeOperator()",
    "kind": "Method",
    "detail": "Function (} private : T* m_data ; const bool m_meshHasEdits ; const float m_weight ; } ; class CreaseSubdivisionHalfedgeOperator : public HbrHalfedgeOperator<T> { public :)",
    "insertText": "CreaseSubdivisionHalfedgeOperator(HbrVertex<T> *vertex, T* data, bool meshHasEdits, bool next, float weight) : m_vertex(vertex), m_data(data), m_meshHasEdits(meshHasEdits), m_next(next), m_weight(weight), m_count(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator() (HbrHalfedge<T> &edge)"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* a = edge .)",
    "insertText": "GetDestVertex()"
  },
  {
    "label": "AddWithWeight()",
    "kind": "Method",
    "detail": "Function (} m_data ->)",
    "insertText": "AddWithWeight(a->GetData(), m_weight)"
  },
  {
    "label": "RefineFaceAtVertexOperator()",
    "kind": "Method",
    "detail": "Function (m_count + + ; } } private : HbrVertex<T>* m_vertex ; T* m_data ; const bool m_meshHasEdits ; const bool m_next ; const float m_weight ; int m_count ; } ; private : class RefineFaceAtVertexOperator : public HbrFaceOperator<T> { public :)",
    "insertText": "RefineFaceAtVertexOperator(HbrSubdivision<T>* subdivision, HbrMesh<T>* mesh, HbrVertex<T> *vertex) : m_subdivision(subdivision), m_mesh(mesh), m_vertex(vertex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator() (HbrFace<T> &face)"
  },
  {
    "label": "RefineFaceAtVertex()",
    "kind": "Method",
    "detail": "Function (m_subdivision ->)",
    "insertText": "RefineFaceAtVertex(m_mesh, &face, m_vertex)"
  },
  {
    "label": "GuaranteeNeighbors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbors(mesh, vertex)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (RefineFaceAtVertexOperator)",
    "insertText": "op(this, mesh, vertex)"
  },
  {
    "label": "ApplyOperatorSurroundingFaces()",
    "kind": "Method",
    "detail": "Function (vertex ->)",
    "insertText": "ApplyOperatorSurroundingFaces(op)"
  },
  {
    "label": "GetSharpness()",
    "kind": "Method",
    "detail": "Function (float sharpness = edge ->)",
    "insertText": "GetSharpness()"
  },
  {
    "label": "SetSharpness()",
    "kind": "Method",
    "detail": "Function (subedge ->)",
    "insertText": "SetSharpness(HbrHalfedge<T>::k_InfinitelySharp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(creaseSubdivision == HbrSubdivision<T>::k_CreaseChaikin)"
  },
  {
    "label": "ChaikinEdgeCreaseOperator()",
    "kind": "Method",
    "detail": "Function (float childsharp = 0 . 0 f ; int n = 0 ; class ChaikinEdgeCreaseOperator : public HbrHalfedgeOperator<T> { public :)",
    "insertText": "ChaikinEdgeCreaseOperator(HbrHalfedge<T> const * edge, float & childsharp, int & count) : m_edge(edge), m_childsharp(childsharp), m_count(count)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (+ + m_count ; } } private : HbrHalfedge<T> const* m_edge ; float& m_childsharp ; int& m_count ; } ; ChaikinEdgeCreaseOperator)",
    "insertText": "op(edge, childsharp, n)"
  },
  {
    "label": "ApplyOperatorSurroundingEdges()",
    "kind": "Method",
    "detail": "Function (vertex ->)",
    "insertText": "ApplyOperatorSurroundingEdges(op)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (childsharp = childsharp* 0 . 2 5 f /)",
    "insertText": "float(n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} childsharp + = sharpness* 0 . 7 5 f ; childsharp - = 1 . 0 f ;)",
    "insertText": "if(childsharp < (float) HbrHalfedge<T>::k_Smooth)"
  },
  {
    "label": "childsharp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "childsharp(float)"
  },
  {
    "label": "SetSharpness()",
    "kind": "Method",
    "detail": "Function (} subedge ->)",
    "insertText": "SetSharpness(childsharp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { sharpness - = 1 . 0 f ;)",
    "insertText": "if(sharpness < (float) HbrHalfedge<T>::k_Smooth)"
  },
  {
    "label": "sharpness()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sharpness(float)"
  },
  {
    "label": "SetSharpness()",
    "kind": "Method",
    "detail": "Function (} subedge ->)",
    "insertText": "SetSharpness(sharpness)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (SmoothSubdivisionVertexOperator)",
    "insertText": "op(data, mesh->HasVertexEdits(), weight)"
  },
  {
    "label": "ApplyOperatorSurroundingVertices()",
    "kind": "Method",
    "detail": "Function (vertex ->)",
    "insertText": "ApplyOperatorSurroundingVertices(op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (CreaseSubdivisionHalfedgeOperator)",
    "insertText": "op(vertex, data, mesh->HasVertexEdits(), next, weight)"
  }
]