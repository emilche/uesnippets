[
  {
    "label": "quad_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "quad_traits"
  },
  {
    "label": "symm_pack_rhs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "symm_pack_rhs"
  },
  {
    "label": "symm_pack_lhs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "symm_pack_lhs"
  },
  {
    "label": "dhs_cpack",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "dhs_cpack"
  },
  {
    "label": "dhs_pack",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "dhs_pack"
  },
  {
    "label": "gemm_pack_lhs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gemm_pack_lhs"
  },
  {
    "label": "gemm_pack_rhs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gemm_pack_rhs"
  },
  {
    "label": "gebp_kernel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gebp_kernel"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_MATRIX_PRODUCT_ALTIVEC_H # define EIGEN_MATRIX_PRODUCT_ALTIVEC_H # ifndef EIGEN_ALTIVEC_USE_CUSTOM_PACK # define EIGEN_ALTIVEC_USE_CUSTOM_PACK 1 # endif # include \" MatrixProductCommon . h \" # if EIGEN_COMP_LLVM # if !)",
    "insertText": "defined(EIGEN_ALTIVEC_DISABLE_MMA) && !defined(EIGEN_ALTIVEC_MMA_ONLY) #ifdef __MMA__ #define EIGEN_ALTIVEC_MMA_ONLY #else #define EIGEN_ALTIVEC_DISABLE_MMA #endif #endif #endif #ifdef __has_builtin #if __has_builtin(__builtin_mma_assemble_acc) #define ALTIVEC_MMA_SUPPORT #endif #endif #if defined(ALTIVEC_MMA_SUPPORT) && !defined(EIGEN_ALTIVEC_DISABLE_MMA)"
  },
  {
    "label": "getAdjointVal()",
    "kind": "Method",
    "detail": "Function (namespace internal { template<Scalar> struct quad_traits { typedef packet_traits<Scalar>::type vectortype ; typedef PacketBlock<vectortype,4> type ; typedef vectortype rhstype ; enum { vectorsize = packet_traits<Scalar>::size,size = 4,rows = 4 } ; } ; template<> struct quad_traits<double> { typedef Packet2d vectortype ; typedef PacketBlock<vectortype,4> type ; typedef PacketBlock<Packet2d,2> rhstype ; enum { vectorsize = packet_traits<double>::size,size = 2,rows = 4 } ; } ; const Packet16uc p16uc_GETREAL32 = { 0,1,2,3,8,9,1 0,1 1,1 6,1 7,1 8,1 9,2 4,2 5,2 6,2 7 } ; const Packet16uc p16uc_GETIMAG32 = { 4,5,6,7,1 2,1 3,1 4,1 5,2 0,2 1,2 2,2 3,2 8,2 9,3 0,3 1 } ; const Packet16uc p16uc_GETREAL64 = { 0,1,2,3,4,5,6,7,1 6,1 7,1 8,1 9,2 0,2 1,2 2,2 3 } ; const Packet16uc p16uc_GETIMAG64 = { 8,9,1 0,1 1,1 2,1 3,1 4,1 5,2 4,2 5,2 6,2 7,2 8,2 9,3 0,3 1 } ; template<Scalar,Index,int StorageOrder> EIGEN_ALWAYS_INLINE std::complex<Scalar>)",
    "insertText": "getAdjointVal(Index i, Index j, const_blas_data_mapper<std::complex<Scalar>, Index, StorageOrder>& dt)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (std::complex<Scalar> v ;)",
    "insertText": "if(i < j)"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "real(dt(j,i).real())"
  },
  {
    "label": "imag()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "imag(-dt(j,i).imag())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(i > j)"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "real(dt(i,j).real())"
  },
  {
    "label": "imag()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "imag(dt(i,j).imag())"
  },
  {
    "label": "imag()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "imag((Scalar)0.0)"
  },
  {
    "label": "symm_pack_complex_rhs_helper()",
    "kind": "Method",
    "detail": "Function (} return v ; } template<Scalar,Index,int StorageOrder,int N> EIGEN_STRONG_INLINE void)",
    "insertText": "symm_pack_complex_rhs_helper(std::complex<Scalar>* blockB, const std::complex<Scalar>* _rhs, Index rhsStride, Index rows, Index cols, Index k2)"
  },
  {
    "label": "rhs()",
    "kind": "Method",
    "detail": "Function (const Index depth = k2 + rows ; const_blas_data_mapper<std::complex<Scalar>,Index,StorageOrder>)",
    "insertText": "rhs(_rhs, rhsStride)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (const Index vectorSize = N* quad_traits<Scalar>::vectorsize ; const Index vectorDelta = vectorSize* rows ; Scalar* blockBf = reinterpret_cast<)",
    "insertText": "Scalar(blockB)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index rir = 0,rii,j = 0 ;)",
    "insertText": "for(; j + vectorSize <= cols; j+=vectorSize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (rii = rir + vectorDelta ;)",
    "insertText": "for(Index i = k2; i < depth; i++)"
  },
  {
    "label": "StorageOrder()",
    "kind": "Method",
    "detail": "Function (std::complex<Scalar> v = getAdjointVal<Scalar,Index,)",
    "insertText": "StorageOrder(i, j + k, rhs)"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (blockBf [ rir + k ] = v .)",
    "insertText": "real()"
  },
  {
    "label": "imag()",
    "kind": "Method",
    "detail": "Function (blockBf [ rii + k ] = v .)",
    "insertText": "imag()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} rir + = vectorSize ; rii + = vectorSize ; } rir + = vectorDelta ; })",
    "insertText": "if(j < cols)"
  },
  {
    "label": "rir()",
    "kind": "Method",
    "detail": "Function (rii =)",
    "insertText": "rir((cols - j) * rows)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index k = j ;)",
    "insertText": "for(; k < cols; k++)"
  },
  {
    "label": "StorageOrder()",
    "kind": "Method",
    "detail": "Function (std::complex<Scalar> v = getAdjointVal<Scalar,Index,)",
    "insertText": "StorageOrder(i, k, rhs)"
  },
  {
    "label": "symm_pack_complex_lhs_helper()",
    "kind": "Method",
    "detail": "Function (rir + = 1 ; rii + = 1 ; } } } } template<Scalar,Index,int StorageOrder> EIGEN_STRONG_INLINE void)",
    "insertText": "symm_pack_complex_lhs_helper(std::complex<Scalar>* blockA, const std::complex<Scalar>* _lhs, Index lhsStride, Index cols, Index rows)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (const Index depth = cols ; const_blas_data_mapper<std::complex<Scalar>,Index,StorageOrder>)",
    "insertText": "lhs(_lhs, lhsStride)"
  },
  {
    "label": "blockAf()",
    "kind": "Method",
    "detail": "Function (const Index vectorSize = quad_traits<Scalar>::vectorsize ; const Index vectorDelta = vectorSize* depth ; Scalar*)",
    "insertText": "blockAf(Scalar *)(blockA)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index rir = 0,rii,j = 0 ;)",
    "insertText": "for(; j + vectorSize <= rows; j+=vectorSize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (rii = rir + vectorDelta ;)",
    "insertText": "for(Index i = 0; i < depth; i++)"
  },
  {
    "label": "StorageOrder()",
    "kind": "Method",
    "detail": "Function (std::complex<Scalar> v = getAdjointVal<Scalar,Index,)",
    "insertText": "StorageOrder(j+k, i, lhs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} rir + = vectorSize ; rii + = vectorSize ; } rir + = vectorDelta ; })",
    "insertText": "if(j < rows)"
  },
  {
    "label": "rir()",
    "kind": "Method",
    "detail": "Function (rii =)",
    "insertText": "rir((rows - j) * depth)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index k = j ;)",
    "insertText": "for(; k < rows; k++)"
  },
  {
    "label": "StorageOrder()",
    "kind": "Method",
    "detail": "Function (std::complex<Scalar> v = getAdjointVal<Scalar,Index,)",
    "insertText": "StorageOrder(k, i, lhs)"
  },
  {
    "label": "symm_pack_rhs_helper()",
    "kind": "Method",
    "detail": "Function (rir + = 1 ; rii + = 1 ; } } } } template<Scalar,Index,int StorageOrder,int N> EIGEN_STRONG_INLINE void)",
    "insertText": "symm_pack_rhs_helper(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const Index vectorSize = quad_traits<Scalar>::vectorsize ; Index ri = 0,j = 0 ;)",
    "insertText": "for(; j + N*vectorSize <= cols; j+=N*vectorSize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index i = k2 ;)",
    "insertText": "for(; i < depth; i++)"
  },
  {
    "label": "symm_pack_lhs_helper()",
    "kind": "Method",
    "detail": "Function (ri + = 1 ; } } } } template<Scalar,Index,int StorageOrder> EIGEN_STRONG_INLINE void)",
    "insertText": "symm_pack_lhs_helper(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ri + = 1 ; } } } } template<Index,int nr,int StorageOrder> struct symm_pack_rhs<std::complex<float>,Index,nr,StorageOrder> { void)",
    "insertText": "operator()(std::complex<float>* blockB, const std::complex<float>* _rhs, Index rhsStride, Index rows, Index cols, Index k2)"
  },
  {
    "label": "StorageOrder()",
    "kind": "Method",
    "detail": "Function (symm_pack_complex_rhs_helper<float,Index,)",
    "insertText": "StorageOrder(blockB, _rhs, rhsStride, rows, cols, k2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Index,int Pack1,int Pack2_dummy,int StorageOrder> struct symm_pack_lhs<std::complex<float>,Index,Pack1,Pack2_dummy,StorageOrder> { void)",
    "insertText": "operator()(std::complex<float>* blockA, const std::complex<float>* _lhs, Index lhsStride, Index cols, Index rows)"
  },
  {
    "label": "StorageOrder()",
    "kind": "Method",
    "detail": "Function (symm_pack_complex_lhs_helper<float,Index,)",
    "insertText": "StorageOrder(blockA, _lhs, lhsStride, cols, rows)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Index,int nr,int StorageOrder> struct symm_pack_rhs<std::complex<double>,Index,nr,StorageOrder> { void)",
    "insertText": "operator()(std::complex<double>* blockB, const std::complex<double>* _rhs, Index rhsStride, Index rows, Index cols, Index k2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Index,int Pack1,int Pack2_dummy,int StorageOrder> struct symm_pack_lhs<std::complex<double>,Index,Pack1,Pack2_dummy,StorageOrder> { void)",
    "insertText": "operator()(std::complex<double>* blockA, const std::complex<double>* _lhs, Index lhsStride, Index cols, Index rows)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Index,int nr,int StorageOrder> struct symm_pack_rhs<float,Index,nr,StorageOrder> { void)",
    "insertText": "operator()(float* blockB, const float* _rhs, Index rhsStride, Index rows, Index cols, Index k2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Index,int Pack1,int Pack2_dummy,int StorageOrder> struct symm_pack_lhs<float,Index,Pack1,Pack2_dummy,StorageOrder> { void)",
    "insertText": "operator()(float* blockA, const float* _lhs, Index lhsStride, Index cols, Index rows)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Index,int nr,int StorageOrder> struct symm_pack_rhs<double,Index,nr,StorageOrder> { void)",
    "insertText": "operator()(double* blockB, const double* _rhs, Index rhsStride, Index rows, Index cols, Index k2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<Index,int Pack1,int Pack2_dummy,int StorageOrder> struct symm_pack_lhs<double,Index,Pack1,Pack2_dummy,StorageOrder> { void)",
    "insertText": "operator()(double* blockA, const double* _lhs, Index lhsStride, Index cols, Index rows)"
  },
  {
    "label": "storeBlock()",
    "kind": "Method",
    "detail": "Function (} } ; template<Scalar,Packet,Index> EIGEN_ALWAYS_INLINE void)",
    "insertText": "storeBlock(Scalar* to, PacketBlock<Packet,4>& block)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const Index size = 1 6 /)",
    "insertText": "sizeof(Scalar)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "Scalar(to + (0 * size), block.packet[0])"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "Scalar(to + (1 * size), block.packet[1])"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "Scalar(to + (2 * size), block.packet[2])"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "Scalar(to + (3 * size), block.packet[3])"
  },
  {
    "label": "storeBlock()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,Packet,Index> EIGEN_ALWAYS_INLINE void)",
    "insertText": "storeBlock(Scalar* to, PacketBlock<Packet,2>& block)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,Index,DataMapper,Packet,PacketC,int StorageOrder,bool Conjugate,bool PanelMode,bool UseLhs> struct dhs_cpack { EIGEN_STRONG_INLINE void)",
    "insertText": "operator()(std::complex<Scalar>* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride, Index offset)"
  },
  {
    "label": "vectorSize()",
    "kind": "Method",
    "detail": "Function (const Index vectorSize = quad_traits<Scalar>::vectorsize ; const Index vectorDelta =)",
    "insertText": "vectorSize((PanelMode) ? stride : depth)"
  },
  {
    "label": "rir()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "rir((PanelMode) ? (vectorSize*offset) : 0)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (Scalar* blockAt = reinterpret_cast<)",
    "insertText": "Scalar(blockA)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index i = 0 ; rii = rir + vectorDelta ;)",
    "insertText": "for(; i + vectorSize <= depth; i+=vectorSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (PacketBlock<Packet,4> blockr,blocki ; PacketBlock<PacketC,8> cblock ;)",
    "insertText": "if(UseLhs)"
  },
  {
    "label": "StorageOrder()",
    "kind": "Method",
    "detail": "Function (bload<DataMapper,PacketC,Index,2,0,)",
    "insertText": "StorageOrder(cblock, lhs, j, i)"
  },
  {
    "label": "StorageOrder()",
    "kind": "Method",
    "detail": "Function (} else { bload<DataMapper,PacketC,Index,2,0,)",
    "insertText": "StorageOrder(cblock, lhs, i, j)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (} blockr . packet [ 0 ] =)",
    "insertText": "vec_perm(cblock.packet[0].v, cblock.packet[4].v, p16uc_GETREAL32)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blockr . packet [ 1 ] =)",
    "insertText": "vec_perm(cblock.packet[1].v, cblock.packet[5].v, p16uc_GETREAL32)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blockr . packet [ 2 ] =)",
    "insertText": "vec_perm(cblock.packet[2].v, cblock.packet[6].v, p16uc_GETREAL32)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blockr . packet [ 3 ] =)",
    "insertText": "vec_perm(cblock.packet[3].v, cblock.packet[7].v, p16uc_GETREAL32)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 0 ] =)",
    "insertText": "vec_perm(cblock.packet[0].v, cblock.packet[4].v, p16uc_GETIMAG32)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 1 ] =)",
    "insertText": "vec_perm(cblock.packet[1].v, cblock.packet[5].v, p16uc_GETIMAG32)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 2 ] =)",
    "insertText": "vec_perm(cblock.packet[2].v, cblock.packet[6].v, p16uc_GETIMAG32)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 3 ] =)",
    "insertText": "vec_perm(cblock.packet[3].v, cblock.packet[7].v, p16uc_GETIMAG32)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 0 ] = - blocki . packet [ 0 ] ; blocki . packet [ 1 ] = - blocki . packet [ 1 ] ; blocki . packet [ 2 ] = - blocki . packet [ 2 ] ; blocki . packet [ 3 ] = - blocki . packet [ 3 ] ; })",
    "insertText": "if(((StorageOrder == RowMajor) && UseLhs) || (((StorageOrder == ColMajor) && !UseLhs)))"
  },
  {
    "label": "ptranspose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ptranspose(blockr)"
  },
  {
    "label": "ptranspose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ptranspose(blocki)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (} storeBlock<Scalar,Packet,)",
    "insertText": "Index(blockAt + rir, blockr)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (storeBlock<Scalar,Packet,)",
    "insertText": "Index(blockAt + rii, blocki)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (PacketBlock<Packet,1> blockr,blocki ; PacketBlock<PacketC,2> cblock ;)",
    "insertText": "if(((StorageOrder == ColMajor) && UseLhs) || (((StorageOrder == RowMajor) && !UseLhs)))"
  },
  {
    "label": "PacketC()",
    "kind": "Method",
    "detail": "Function (cblock . packet [ 0 ] = lhs . template loadPacket<)",
    "insertText": "PacketC(j + 0, i)"
  },
  {
    "label": "PacketC()",
    "kind": "Method",
    "detail": "Function (cblock . packet [ 1 ] = lhs . template loadPacket<)",
    "insertText": "PacketC(j + 2, i)"
  },
  {
    "label": "PacketC()",
    "kind": "Method",
    "detail": "Function (} else { cblock . packet [ 0 ] = lhs . template loadPacket<)",
    "insertText": "PacketC(i, j + 0)"
  },
  {
    "label": "PacketC()",
    "kind": "Method",
    "detail": "Function (cblock . packet [ 1 ] = lhs . template loadPacket<)",
    "insertText": "PacketC(i, j + 2)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (lhs0 =)",
    "insertText": "lhs(j + 0, i)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (lhs1 =)",
    "insertText": "lhs(j + 1, i)"
  },
  {
    "label": "pload2()",
    "kind": "Method",
    "detail": "Function (cblock . packet [ 0 ] =)",
    "insertText": "pload2(&lhs0, &lhs1)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (lhs0 =)",
    "insertText": "lhs(j + 2, i)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (lhs1 =)",
    "insertText": "lhs(j + 3, i)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (} else { lhs0 =)",
    "insertText": "lhs(i, j + 0)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (lhs1 =)",
    "insertText": "lhs(i, j + 1)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (lhs0 =)",
    "insertText": "lhs(i, j + 2)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (lhs1 =)",
    "insertText": "lhs(i, j + 3)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (} } blockr . packet [ 0 ] =)",
    "insertText": "vec_perm(cblock.packet[0].v, cblock.packet[1].v, p16uc_GETREAL32)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 0 ] =)",
    "insertText": "vec_perm(cblock.packet[0].v, cblock.packet[1].v, p16uc_GETIMAG32)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 0 ] = - blocki . packet [ 0 ] ; } pstore<)",
    "insertText": "Scalar(blockAt + rir, blockr.packet[0])"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "Scalar(blockAt + rii, blocki.packet[0])"
  },
  {
    "label": "rir()",
    "kind": "Method",
    "detail": "Function (rir + = vectorSize ; rii + = vectorSize ; })",
    "insertText": "rir((PanelMode) ? (vectorSize*(2*stride - depth)) : vectorDelta)"
  },
  {
    "label": "rir()",
    "kind": "Method",
    "detail": "Function (rii =)",
    "insertText": "rir(((PanelMode) ? stride : depth) * (rows - j))"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (blockAt [ rir ] =)",
    "insertText": "lhs(k, i).real()"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (} else { blockAt [ rir ] =)",
    "insertText": "lhs(i, k).real()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} rir + = 1 ; rii + = 1 ; } } } } } ; template<Scalar,Index,DataMapper,Packet,int StorageOrder,bool PanelMode,bool UseLhs> struct dhs_pack { EIGEN_STRONG_INLINE void)",
    "insertText": "operator()(Scalar* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride, Index offset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index i = 0 ;)",
    "insertText": "if(PanelMode)"
  },
  {
    "label": "StorageOrder()",
    "kind": "Method",
    "detail": "Function (bload<DataMapper,Packet,Index,4,0,)",
    "insertText": "StorageOrder(block, lhs, j, i)"
  },
  {
    "label": "StorageOrder()",
    "kind": "Method",
    "detail": "Function (} else { bload<DataMapper,Packet,Index,4,0,)",
    "insertText": "StorageOrder(block, lhs, i, j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(((StorageOrder == RowMajor) && UseLhs) || ((StorageOrder == ColMajor) && !UseLhs))"
  },
  {
    "label": "ptranspose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ptranspose(block)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (} storeBlock<Scalar,Packet,)",
    "insertText": "Index(blockA + ri, block)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (blockA [ ri + 0 ] =)",
    "insertText": "lhs(j+0, i)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (blockA [ ri + 1 ] =)",
    "insertText": "lhs(j+1, i)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (blockA [ ri + 2 ] =)",
    "insertText": "lhs(j+2, i)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (blockA [ ri + 3 ] =)",
    "insertText": "lhs(j+3, i)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (} else { blockA [ ri + 0 ] =)",
    "insertText": "lhs(i, j+0)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (blockA [ ri + 1 ] =)",
    "insertText": "lhs(i, j+1)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (blockA [ ri + 2 ] =)",
    "insertText": "lhs(i, j+2)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (blockA [ ri + 3 ] =)",
    "insertText": "lhs(i, j+3)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (lhsV = lhs . template loadPacket<)",
    "insertText": "Packet(j, i)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (} else { lhsV = lhs . template loadPacket<)",
    "insertText": "Packet(i, j)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (} pstore<)",
    "insertText": "Scalar(blockA + ri, lhsV)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ri + = vectorSize ; })",
    "insertText": "if(PanelMode) ri += vectorSize*(stride - offset - depth)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (blockA [ ri ] =)",
    "insertText": "lhs(k, i)"
  },
  {
    "label": "lhs()",
    "kind": "Method",
    "detail": "Function (} else { blockA [ ri ] =)",
    "insertText": "lhs(i, k)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ri + = 1 ; } } } } } ; template<Index,DataMapper,int StorageOrder,bool PanelMode> struct dhs_pack<double,Index,DataMapper,Packet2d,StorageOrder,PanelMode,true> { EIGEN_STRONG_INLINE void)",
    "insertText": "operator()(double* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride, Index offset)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (PacketBlock<Packet2d,2> block ;)",
    "insertText": "if(StorageOrder == RowMajor)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (block . packet [ 0 ] = lhs . template loadPacket<)",
    "insertText": "Packet2d(j + 0, i)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (block . packet [ 1 ] = lhs . template loadPacket<)",
    "insertText": "Packet2d(j + 1, i)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (} else { block . packet [ 0 ] = lhs . template loadPacket<)",
    "insertText": "Packet2d(j, i + 0)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (block . packet [ 1 ] = lhs . template loadPacket<)",
    "insertText": "Packet2d(j, i + 1)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (} else { Packet2d lhsV = lhs . template loadPacket<)",
    "insertText": "Packet2d(j, i)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "double(blockA + ri, lhsV)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ri + = 1 ; } } } } } ; template<Index,DataMapper,int StorageOrder,bool PanelMode> struct dhs_pack<double,Index,DataMapper,Packet2d,StorageOrder,PanelMode,false> { EIGEN_STRONG_INLINE void)",
    "insertText": "operator()(double* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride, Index offset)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const Index vectorSize = quad_traits<double>::vectorsize ; Index ri = 0,j = 0 ;)",
    "insertText": "for(; j + 2*vectorSize <= cols; j+=2*vectorSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index i = 0 ;)",
    "insertText": "if(PanelMode) ri += offset*(2*vectorSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (PacketBlock<Packet2d,4> block ;)",
    "insertText": "if(StorageOrder == ColMajor)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (PacketBlock<Packet2d,2> block1,block2 ; block1 . packet [ 0 ] = rhs . template loadPacket<)",
    "insertText": "Packet2d(i, j + 0)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (block1 . packet [ 1 ] = rhs . template loadPacket<)",
    "insertText": "Packet2d(i, j + 1)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (block2 . packet [ 0 ] = rhs . template loadPacket<)",
    "insertText": "Packet2d(i, j + 2)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (block2 . packet [ 1 ] = rhs . template loadPacket<)",
    "insertText": "Packet2d(i, j + 3)"
  },
  {
    "label": "ptranspose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ptranspose(block1)"
  },
  {
    "label": "ptranspose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ptranspose(block2)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "double(blockB + ri , block1.packet[0])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "double(blockB + ri + 2, block2.packet[0])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "double(blockB + ri + 4, block1.packet[1])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "double(blockB + ri + 6, block2.packet[1])"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (} else { block . packet [ 0 ] = rhs . template loadPacket<)",
    "insertText": "Packet2d(i + 0, j + 0)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (block . packet [ 1 ] = rhs . template loadPacket<)",
    "insertText": "Packet2d(i + 0, j + 2)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (block . packet [ 2 ] = rhs . template loadPacket<)",
    "insertText": "Packet2d(i + 1, j + 0)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (block . packet [ 3 ] = rhs . template loadPacket<)",
    "insertText": "Packet2d(i + 1, j + 2)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (storeBlock<double,Packet2d,)",
    "insertText": "Index(blockB + ri, block)"
  },
  {
    "label": "rhs()",
    "kind": "Method",
    "detail": "Function (blockB [ ri + 0 ] =)",
    "insertText": "rhs(i, j+0)"
  },
  {
    "label": "rhs()",
    "kind": "Method",
    "detail": "Function (blockB [ ri + 1 ] =)",
    "insertText": "rhs(i, j+1)"
  },
  {
    "label": "rhs()",
    "kind": "Method",
    "detail": "Function (ri + = vectorSize ; blockB [ ri + 0 ] =)",
    "insertText": "rhs(i, j+2)"
  },
  {
    "label": "rhs()",
    "kind": "Method",
    "detail": "Function (blockB [ ri + 1 ] =)",
    "insertText": "rhs(i, j+3)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (} else { Packet2d rhsV = rhs . template loadPacket<)",
    "insertText": "Packet2d(i, j)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "double(blockB + ri, rhsV)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ri + = vectorSize ; })",
    "insertText": "if(PanelMode) ri += (2*vectorSize)*(stride - offset - depth)"
  },
  {
    "label": "rhs()",
    "kind": "Method",
    "detail": "Function (blockB [ ri ] =)",
    "insertText": "rhs(i, k)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ri + = 1 ; } } } } } ; template<Index,DataMapper,Packet,PacketC,int StorageOrder,bool Conjugate,bool PanelMode> struct dhs_cpack<double,Index,DataMapper,Packet,PacketC,StorageOrder,Conjugate,PanelMode,true> { EIGEN_STRONG_INLINE void)",
    "insertText": "operator()(std::complex<double>* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride, Index offset)"
  },
  {
    "label": "PacketC()",
    "kind": "Method",
    "detail": "Function (cblock . packet [ 0 ] = lhs . template loadPacket<)",
    "insertText": "PacketC(j, i + 0)"
  },
  {
    "label": "PacketC()",
    "kind": "Method",
    "detail": "Function (cblock . packet [ 1 ] = lhs . template loadPacket<)",
    "insertText": "PacketC(j, i + 1)"
  },
  {
    "label": "PacketC()",
    "kind": "Method",
    "detail": "Function (cblock . packet [ 2 ] = lhs . template loadPacket<)",
    "insertText": "PacketC(j + 1, i + 0)"
  },
  {
    "label": "PacketC()",
    "kind": "Method",
    "detail": "Function (cblock . packet [ 3 ] = lhs . template loadPacket<)",
    "insertText": "PacketC(j + 1, i + 1)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blockr . packet [ 0 ] =)",
    "insertText": "vec_perm(cblock.packet[0].v, cblock.packet[2].v, p16uc_GETREAL64)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blockr . packet [ 1 ] =)",
    "insertText": "vec_perm(cblock.packet[1].v, cblock.packet[3].v, p16uc_GETREAL64)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 0 ] =)",
    "insertText": "vec_perm(cblock.packet[0].v, cblock.packet[2].v, p16uc_GETIMAG64)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 1 ] =)",
    "insertText": "vec_perm(cblock.packet[1].v, cblock.packet[3].v, p16uc_GETIMAG64)"
  },
  {
    "label": "PacketC()",
    "kind": "Method",
    "detail": "Function (cblock . packet [ 1 ] = lhs . template loadPacket<)",
    "insertText": "PacketC(j + 1, i)"
  },
  {
    "label": "PacketC()",
    "kind": "Method",
    "detail": "Function (cblock . packet [ 2 ] = lhs . template loadPacket<)",
    "insertText": "PacketC(j + 0, i + 1)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blockr . packet [ 0 ] =)",
    "insertText": "vec_perm(cblock.packet[0].v, cblock.packet[1].v, p16uc_GETREAL64)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blockr . packet [ 1 ] =)",
    "insertText": "vec_perm(cblock.packet[2].v, cblock.packet[3].v, p16uc_GETREAL64)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 0 ] =)",
    "insertText": "vec_perm(cblock.packet[0].v, cblock.packet[1].v, p16uc_GETIMAG64)"
  },
  {
    "label": "vec_perm()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 1 ] =)",
    "insertText": "vec_perm(cblock.packet[2].v, cblock.packet[3].v, p16uc_GETIMAG64)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Conjugate)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 0 ] = - blocki . packet [ 0 ] ; } pstore<)",
    "insertText": "double(blockAt + rir, blockr.packet[0])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (pstore<)",
    "insertText": "double(blockAt + rii, blocki.packet[0])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (rir + = 1 ; rii + = 1 ; } } } } } ; template<Index,DataMapper,Packet,PacketC,int StorageOrder,bool Conjugate,bool PanelMode> struct dhs_cpack<double,Index,DataMapper,Packet,PacketC,StorageOrder,Conjugate,PanelMode,false> { EIGEN_STRONG_INLINE void)",
    "insertText": "operator()(std::complex<double>* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride, Index offset)"
  },
  {
    "label": "rir()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "rir((PanelMode) ? (2*vectorSize*offset) : 0)"
  },
  {
    "label": "ColMajor()",
    "kind": "Method",
    "detail": "Function (PacketBlock<PacketC,4> cblock ; PacketBlock<Packet,2> blockr,blocki ; bload<DataMapper,PacketC,Index,2,0,)",
    "insertText": "ColMajor(cblock, rhs, i, j)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (blocki . packet [ 0 ] = - blocki . packet [ 0 ] ; blocki . packet [ 1 ] = - blocki . packet [ 1 ] ; } storeBlock<double,Packet,)",
    "insertText": "Index(blockBt + rir, blockr)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (storeBlock<double,Packet,)",
    "insertText": "Index(blockBt + rii, blocki)"
  },
  {
    "label": "rir()",
    "kind": "Method",
    "detail": "Function (rir + = 2* vectorSize ; rii + = 2* vectorSize ; })",
    "insertText": "rir((PanelMode) ? (2*vectorSize*(2*stride - depth)) : vectorDelta)"
  },
  {
    "label": "rir()",
    "kind": "Method",
    "detail": "Function (rii =)",
    "insertText": "rir(((PanelMode) ? stride : depth) * (cols - j))"
  },
  {
    "label": "rhs()",
    "kind": "Method",
    "detail": "Function (blockBt [ rir ] =)",
    "insertText": "rhs(i, k).real()"
  },
  {
    "label": "pger_common()",
    "kind": "Method",
    "detail": "Function (rir + = 1 ; rii + = 1 ; } } } } } ; template<Packet,bool NegativeAccumulate> EIGEN_ALWAYS_INLINE void)",
    "insertText": "pger_common(PacketBlock<Packet,4>* acc, const Packet& lhsV, const Packet* rhsV)"
  },
  {
    "label": "vec_nmsub()",
    "kind": "Method",
    "detail": "Function (acc -> packet [ 0 ] =)",
    "insertText": "vec_nmsub(lhsV, rhsV[0], acc->packet[0])"
  },
  {
    "label": "vec_nmsub()",
    "kind": "Method",
    "detail": "Function (acc -> packet [ 1 ] =)",
    "insertText": "vec_nmsub(lhsV, rhsV[1], acc->packet[1])"
  },
  {
    "label": "vec_nmsub()",
    "kind": "Method",
    "detail": "Function (acc -> packet [ 2 ] =)",
    "insertText": "vec_nmsub(lhsV, rhsV[2], acc->packet[2])"
  },
  {
    "label": "vec_nmsub()",
    "kind": "Method",
    "detail": "Function (acc -> packet [ 3 ] =)",
    "insertText": "vec_nmsub(lhsV, rhsV[3], acc->packet[3])"
  },
  {
    "label": "vec_madd()",
    "kind": "Method",
    "detail": "Function (} else { acc -> packet [ 0 ] =)",
    "insertText": "vec_madd(lhsV, rhsV[0], acc->packet[0])"
  },
  {
    "label": "vec_madd()",
    "kind": "Method",
    "detail": "Function (acc -> packet [ 1 ] =)",
    "insertText": "vec_madd(lhsV, rhsV[1], acc->packet[1])"
  },
  {
    "label": "vec_madd()",
    "kind": "Method",
    "detail": "Function (acc -> packet [ 2 ] =)",
    "insertText": "vec_madd(lhsV, rhsV[2], acc->packet[2])"
  },
  {
    "label": "vec_madd()",
    "kind": "Method",
    "detail": "Function (acc -> packet [ 3 ] =)",
    "insertText": "vec_madd(lhsV, rhsV[3], acc->packet[3])"
  },
  {
    "label": "pger_common()",
    "kind": "Method",
    "detail": "Function (} } template<Packet,bool NegativeAccumulate> EIGEN_ALWAYS_INLINE void)",
    "insertText": "pger_common(PacketBlock<Packet,1>* acc, const Packet& lhsV, const Packet* rhsV)"
  },
  {
    "label": "pger()",
    "kind": "Method",
    "detail": "Function (} } template<int N,Scalar,Packet,bool NegativeAccumulate> EIGEN_ALWAYS_INLINE void)",
    "insertText": "pger(PacketBlock<Packet,N>* acc, const Scalar* lhs, const Packet* rhsV)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet lhsV = pload<)",
    "insertText": "Packet(lhs)"
  },
  {
    "label": "NegativeAccumulate()",
    "kind": "Method",
    "detail": "Function (pger_common<Packet,)",
    "insertText": "NegativeAccumulate(acc, lhsV, rhsV)"
  },
  {
    "label": "loadPacketRemaining()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,Packet,Index> EIGEN_ALWAYS_INLINE void)",
    "insertText": "loadPacketRemaining(const Scalar* lhs, Packet &lhsV, Index remaining_rows)"
  },
  {
    "label": "vec_xl_len()",
    "kind": "Method",
    "detail": "Function (# ifdef _ARCH_PWR9 lhsV =)",
    "insertText": "vec_xl_len((Scalar *)lhs, remaining_rows * sizeof(Scalar))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# else Index i = 0 ; do { lhsV [ i ] = lhs [ i ] ; })",
    "insertText": "while(++i < remaining_rows)"
  },
  {
    "label": "pger()",
    "kind": "Method",
    "detail": "Function (# endif } template<int N,Scalar,Packet,Index,bool NegativeAccumulate> EIGEN_ALWAYS_INLINE void)",
    "insertText": "pger(PacketBlock<Packet,N>* acc, const Scalar* lhs, const Packet* rhsV, Index remaining_rows)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (Packet lhsV ; loadPacketRemaining<Scalar,Packet,)",
    "insertText": "Index(lhs, lhsV, remaining_rows)"
  },
  {
    "label": "pgerc_common()",
    "kind": "Method",
    "detail": "Function (} template<int N,Packet,bool ConjugateLhs,bool ConjugateRhs,bool LhsIsReal,bool RhsIsReal> EIGEN_ALWAYS_INLINE void)",
    "insertText": "pgerc_common(PacketBlock<Packet,N>* accReal, PacketBlock<Packet,N>* accImag, const Packet &lhsV, const Packet &lhsVi, const Packet* rhsV, const Packet* rhsVi)"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (pger_common<Packet,)",
    "insertText": "false(accReal, lhsV, rhsV)"
  },
  {
    "label": "ConjugateRhs()",
    "kind": "Method",
    "detail": "Function (pger_common<Packet,)",
    "insertText": "ConjugateRhs(accImag, lhsV, rhsVi)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(lhsVi)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(!RhsIsReal)"
  },
  {
    "label": "ConjugateRhs()",
    "kind": "Method",
    "detail": "Function (pger_common<Packet,ConjugateLhs = =)",
    "insertText": "ConjugateRhs(accReal, lhsVi, rhsVi)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "EIGEN_UNUSED_VARIABLE(rhsVi)"
  },
  {
    "label": "ConjugateLhs()",
    "kind": "Method",
    "detail": "Function (} pger_common<Packet,)",
    "insertText": "ConjugateLhs(accImag, lhsVi, rhsV)"
  },
  {
    "label": "pgerc()",
    "kind": "Method",
    "detail": "Function (} } template<int N,Scalar,Packet,bool ConjugateLhs,bool ConjugateRhs,bool LhsIsReal,bool RhsIsReal> EIGEN_ALWAYS_INLINE void)",
    "insertText": "pgerc(PacketBlock<Packet,N>* accReal, PacketBlock<Packet,N>* accImag, const Scalar* lhs_ptr, const Scalar* lhs_ptr_imag, const Packet* rhsV, const Packet* rhsVi)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet lhsV = ploadLhs<Scalar,)",
    "insertText": "Packet(lhs_ptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Packet lhsVi ;)",
    "insertText": "if(!LhsIsReal) lhsVi = ploadLhs<Scalar, Packet>(lhs_ptr_imag)"
  },
  {
    "label": "RhsIsReal()",
    "kind": "Method",
    "detail": "Function (pgerc_common<N,Packet,ConjugateLhs,ConjugateRhs,LhsIsReal,)",
    "insertText": "RhsIsReal(accReal, accImag, lhsV, lhsVi, rhsV, rhsVi)"
  },
  {
    "label": "loadPacketRemaining()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,Packet,Index,bool LhsIsReal> EIGEN_ALWAYS_INLINE void)",
    "insertText": "loadPacketRemaining(const Scalar* lhs_ptr, const Scalar* lhs_ptr_imag, Packet &lhsV, Packet &lhsVi, Index remaining_rows)"
  },
  {
    "label": "vec_xl_len()",
    "kind": "Method",
    "detail": "Function (# ifdef _ARCH_PWR9 lhsV =)",
    "insertText": "vec_xl_len((Scalar *)lhs_ptr, remaining_rows * sizeof(Scalar))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# else Index i = 0 ; do { lhsV [ i ] = lhs_ptr [ i ] ;)",
    "insertText": "if(!LhsIsReal)"
  },
  {
    "label": "pgerc()",
    "kind": "Method",
    "detail": "Function (# endif } template<int N,Scalar,Packet,Index,bool ConjugateLhs,bool ConjugateRhs,bool LhsIsReal,bool RhsIsReal> EIGEN_ALWAYS_INLINE void)",
    "insertText": "pgerc(PacketBlock<Packet,N>* accReal, PacketBlock<Packet,N>* accImag, const Scalar* lhs_ptr, const Scalar* lhs_ptr_imag, const Packet* rhsV, const Packet* rhsVi, Index remaining_rows)"
  },
  {
    "label": "LhsIsReal()",
    "kind": "Method",
    "detail": "Function (Packet lhsV,lhsVi ; loadPacketRemaining<Scalar,Packet,Index,)",
    "insertText": "LhsIsReal(lhs_ptr, lhs_ptr_imag, lhsV, lhsVi, remaining_rows)"
  },
  {
    "label": "ploadLhs()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,Packet> EIGEN_ALWAYS_INLINE Packet)",
    "insertText": "ploadLhs(const Scalar* lhs)"
  },
  {
    "label": "bsetzero()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,Packet> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bsetzero(PacketBlock<Packet,4>& acc)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 0 ] = pset1<)",
    "insertText": "Packet((Scalar)0)"
  },
  {
    "label": "bsetzero()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,Packet> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bsetzero(PacketBlock<Packet,1>& acc)"
  },
  {
    "label": "bscale()",
    "kind": "Method",
    "detail": "Function (} template<Packet> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bscale(PacketBlock<Packet,4>& acc, PacketBlock<Packet,4>& accZ, const Packet& pAlpha)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 0 ] =)",
    "insertText": "pmadd(pAlpha, accZ.packet[0], acc.packet[0])"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 1 ] =)",
    "insertText": "pmadd(pAlpha, accZ.packet[1], acc.packet[1])"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 2 ] =)",
    "insertText": "pmadd(pAlpha, accZ.packet[2], acc.packet[2])"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 3 ] =)",
    "insertText": "pmadd(pAlpha, accZ.packet[3], acc.packet[3])"
  },
  {
    "label": "bscale()",
    "kind": "Method",
    "detail": "Function (} template<Packet> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bscale(PacketBlock<Packet,1>& acc, PacketBlock<Packet,1>& accZ, const Packet& pAlpha)"
  },
  {
    "label": "bscalec_common()",
    "kind": "Method",
    "detail": "Function (} template<Packet> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bscalec_common(PacketBlock<Packet,4>& acc, PacketBlock<Packet,4>& accZ, const Packet& pAlpha)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 0 ] = pmul<)",
    "insertText": "Packet(accZ.packet[0], pAlpha)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 1 ] = pmul<)",
    "insertText": "Packet(accZ.packet[1], pAlpha)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 2 ] = pmul<)",
    "insertText": "Packet(accZ.packet[2], pAlpha)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 3 ] = pmul<)",
    "insertText": "Packet(accZ.packet[3], pAlpha)"
  },
  {
    "label": "bscalec_common()",
    "kind": "Method",
    "detail": "Function (} template<Packet> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bscalec_common(PacketBlock<Packet,1>& acc, PacketBlock<Packet,1>& accZ, const Packet& pAlpha)"
  },
  {
    "label": "bscalec()",
    "kind": "Method",
    "detail": "Function (} template<Packet,int N> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bscalec(PacketBlock<Packet,N>& aReal, PacketBlock<Packet,N>& aImag, const Packet& bReal, const Packet& bImag, PacketBlock<Packet,N>& cReal, PacketBlock<Packet,N>& cImag)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (bscalec_common<)",
    "insertText": "Packet(cReal, aReal, bReal)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (bscalec_common<)",
    "insertText": "Packet(cImag, aImag, bReal)"
  },
  {
    "label": "true()",
    "kind": "Method",
    "detail": "Function (pger_common<Packet,)",
    "insertText": "true(&cReal, bImag, aImag.packet)"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (pger_common<Packet,)",
    "insertText": "false(&cImag, bImag, aReal.packet)"
  },
  {
    "label": "band()",
    "kind": "Method",
    "detail": "Function (} template<Packet> EIGEN_ALWAYS_INLINE void)",
    "insertText": "band(PacketBlock<Packet,4>& acc, const Packet& pMask)"
  },
  {
    "label": "pand()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 0 ] =)",
    "insertText": "pand(acc.packet[0], pMask)"
  },
  {
    "label": "pand()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 1 ] =)",
    "insertText": "pand(acc.packet[1], pMask)"
  },
  {
    "label": "pand()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 2 ] =)",
    "insertText": "pand(acc.packet[2], pMask)"
  },
  {
    "label": "pand()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 3 ] =)",
    "insertText": "pand(acc.packet[3], pMask)"
  },
  {
    "label": "bscalec()",
    "kind": "Method",
    "detail": "Function (} template<Packet> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bscalec(PacketBlock<Packet,4>& aReal, PacketBlock<Packet,4>& aImag, const Packet& bReal, const Packet& bImag, PacketBlock<Packet,4>& cReal, PacketBlock<Packet,4>& cImag, const Packet& pMask)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (band<)",
    "insertText": "Packet(aReal, pMask)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (band<)",
    "insertText": "Packet(aImag, pMask)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (bscalec<)",
    "insertText": "Packet(aReal, aImag, bReal, bImag, cReal, cImag)"
  },
  {
    "label": "bload()",
    "kind": "Method",
    "detail": "Function (} template<DataMapper,Packet,Index,const Index accCols,int N,int StorageOrder> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bload(PacketBlock<Packet,4>& acc, const DataMapper& res, Index row, Index col)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 0 ] = res . template loadPacket<)",
    "insertText": "Packet(row + 0, col + N*accCols)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 1 ] = res . template loadPacket<)",
    "insertText": "Packet(row + 1, col + N*accCols)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 2 ] = res . template loadPacket<)",
    "insertText": "Packet(row + 2, col + N*accCols)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 3 ] = res . template loadPacket<)",
    "insertText": "Packet(row + 3, col + N*accCols)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (} else { acc . packet [ 0 ] = res . template loadPacket<)",
    "insertText": "Packet(row + N*accCols, col + 0)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 1 ] = res . template loadPacket<)",
    "insertText": "Packet(row + N*accCols, col + 1)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 2 ] = res . template loadPacket<)",
    "insertText": "Packet(row + N*accCols, col + 2)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 3 ] = res . template loadPacket<)",
    "insertText": "Packet(row + N*accCols, col + 3)"
  },
  {
    "label": "bload()",
    "kind": "Method",
    "detail": "Function (} } template<DataMapper,Packet,Index,const Index accCols,int N,int StorageOrder> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bload(PacketBlock<Packet,8>& acc, const DataMapper& res, Index row, Index col)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 4 ] = res . template loadPacket<)",
    "insertText": "Packet(row + 0, col + (N+1)*accCols)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 5 ] = res . template loadPacket<)",
    "insertText": "Packet(row + 1, col + (N+1)*accCols)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 6 ] = res . template loadPacket<)",
    "insertText": "Packet(row + 2, col + (N+1)*accCols)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 7 ] = res . template loadPacket<)",
    "insertText": "Packet(row + 3, col + (N+1)*accCols)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 4 ] = res . template loadPacket<)",
    "insertText": "Packet(row + (N+1)*accCols, col + 0)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 5 ] = res . template loadPacket<)",
    "insertText": "Packet(row + (N+1)*accCols, col + 1)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 6 ] = res . template loadPacket<)",
    "insertText": "Packet(row + (N+1)*accCols, col + 2)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ 7 ] = res . template loadPacket<)",
    "insertText": "Packet(row + (N+1)*accCols, col + 3)"
  },
  {
    "label": "bload()",
    "kind": "Method",
    "detail": "Function (} } template<DataMapper,Packet,Index,const Index accCols,int N,int StorageOrder> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bload(PacketBlock<Packet,2>& acc, const DataMapper& res, Index row, Index col)"
  },
  {
    "label": "bmask()",
    "kind": "Method",
    "detail": "Function (} const Packet4i mask41 = { - 1,0,0,0 } ; const Packet4i mask42 = { - 1,- 1,0,0 } ; const Packet4i mask43 = { - 1,- 1,- 1,0 } ; const Packet2l mask21 = { - 1,0 } ; template<Packet> EIGEN_ALWAYS_INLINE Packet)",
    "insertText": "bmask(const int remaining_rows)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "switch(remaining_rows)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (default : return)",
    "insertText": "Packet(mask43)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (} } } template<> EIGEN_ALWAYS_INLINE Packet2d bmask<)",
    "insertText": "Packet2d(const int remaining_rows)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "Packet2d(mask21)"
  },
  {
    "label": "bscale()",
    "kind": "Method",
    "detail": "Function (} } template<Packet> EIGEN_ALWAYS_INLINE void)",
    "insertText": "bscale(PacketBlock<Packet,4>& acc, PacketBlock<Packet,4>& accZ, const Packet& pAlpha, const Packet& pMask)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (band<)",
    "insertText": "Packet(accZ, pMask)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (bscale<)",
    "insertText": "Packet(acc, accZ, pAlpha)"
  },
  {
    "label": "pbroadcast4_old()",
    "kind": "Method",
    "detail": "Function (} template<Packet> EIGEN_ALWAYS_INLINE void)",
    "insertText": "pbroadcast4_old(const __UNPACK_TYPE__(Packet)* a, Packet& a0, Packet& a1, Packet& a2, Packet& a3)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (pbroadcast4<)",
    "insertText": "Packet(a, a0, a1, a2, a3)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (} template<> EIGEN_ALWAYS_INLINE void pbroadcast4_old<)",
    "insertText": "Packet2d(const double* a, Packet2d& a0, Packet2d& a1, Packet2d& a2, Packet2d& a3)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (a1 = pload<)",
    "insertText": "Packet2d(a)"
  },
  {
    "label": "Packet2d()",
    "kind": "Method",
    "detail": "Function (a3 = pload<)",
    "insertText": "Packet2d(a + 2)"
  },
  {
    "label": "vec_splat()",
    "kind": "Method",
    "detail": "Function (a0 =)",
    "insertText": "vec_splat(a1, 0)"
  },
  {
    "label": "vec_splat()",
    "kind": "Method",
    "detail": "Function (a1 =)",
    "insertText": "vec_splat(a1, 1)"
  },
  {
    "label": "vec_splat()",
    "kind": "Method",
    "detail": "Function (a2 =)",
    "insertText": "vec_splat(a3, 0)"
  },
  {
    "label": "vec_splat()",
    "kind": "Method",
    "detail": "Function (a3 =)",
    "insertText": "vec_splat(a3, 1)"
  },
  {
    "label": "MICRO_EXTRA_COL()",
    "kind": "Method",
    "detail": "Function (} # define PEEL 7 template<Scalar,Packet,Index> EIGEN_ALWAYS_INLINE void)",
    "insertText": "MICRO_EXTRA_COL(const Scalar* &lhs_ptr, const Scalar* &rhs_ptr, PacketBlock<Packet,1> &accZero, Index remaining_rows, Index remaining_cols)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet rhsV [ 1 ] ; rhsV [ 0 ] = pset1<)",
    "insertText": "Packet(rhs_ptr[0])"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (pger<1,Scalar,Packet,)",
    "insertText": "false(&accZero, lhs_ptr, rhsV)"
  },
  {
    "label": "gemm_extra_col()",
    "kind": "Method",
    "detail": "Function (lhs_ptr + = remaining_rows ; rhs_ptr + = remaining_cols ; } template<Scalar,Packet,DataMapper,Index,const Index accRows> EIGEN_STRONG_INLINE void)",
    "insertText": "gemm_extra_col(const DataMapper& res, const Scalar* lhs_base, const Scalar* rhs_base, Index depth, Index strideA, Index offsetA, Index row, Index col, Index remaining_rows, Index remaining_cols, const Packet& pAlpha)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Scalar* rhs_ptr = rhs_base ; const Scalar* lhs_ptr = lhs_base + row* strideA + remaining_rows* offsetA ; PacketBlock<Packet,1> accZero ; bsetzero<Scalar,)",
    "insertText": "Packet(accZero)"
  },
  {
    "label": "remaining_depth()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "remaining_depth(depth & -accRows)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index k = 0 ;)",
    "insertText": "for(; k + PEEL <= remaining_depth; k+= PEEL)"
  },
  {
    "label": "EIGEN_POWER_PREFETCH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_POWER_PREFETCH(rhs_ptr)"
  },
  {
    "label": "EIGEN_POWER_PREFETCH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_POWER_PREFETCH(lhs_ptr)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (MICRO_EXTRA_COL<Scalar,Packet,)",
    "insertText": "Index(lhs_ptr, rhs_ptr, accZero, remaining_rows, remaining_cols)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(; k < remaining_depth; k++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(; k < depth; k++)"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (pger<1,Scalar,Packet,Index,)",
    "insertText": "false(&accZero, lhs_ptr, rhsV, remaining_rows)"
  },
  {
    "label": "vec_mul()",
    "kind": "Method",
    "detail": "Function (lhs_ptr + = remaining_rows ; rhs_ptr + = remaining_cols ; } accZero . packet [ 0 ] =)",
    "insertText": "vec_mul(pAlpha, accZero.packet[0])"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(row + i, col)"
  },
  {
    "label": "MICRO_EXTRA_ROW()",
    "kind": "Method",
    "detail": "Function (} } template<Scalar,Packet,Index,const Index accRows> EIGEN_ALWAYS_INLINE void)",
    "insertText": "MICRO_EXTRA_ROW(const Scalar* &lhs_ptr, const Scalar* &rhs_ptr, PacketBlock<Packet,4> &accZero, Index remaining_rows)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet rhsV [ 4 ] ; pbroadcast4<)",
    "insertText": "Packet(rhs_ptr, rhsV[0], rhsV[1], rhsV[2], rhsV[3])"
  },
  {
    "label": "gemm_extra_row()",
    "kind": "Method",
    "detail": "Function (lhs_ptr + = remaining_rows ; rhs_ptr + = accRows ; } template<Scalar,Packet,DataMapper,Index,const Index accRows,const Index accCols> EIGEN_STRONG_INLINE void)",
    "insertText": "gemm_extra_row(const DataMapper& res, const Scalar* lhs_base, const Scalar* rhs_base, Index depth, Index strideA, Index offsetA, Index row, Index col, Index rows, Index cols, Index remaining_rows, const Packet& pAlpha, const Packet& pMask)"
  },
  {
    "label": "remaining_depth()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "remaining_depth(col + accRows < cols) ? depth : (depth & -accRows)"
  },
  {
    "label": "accRows()",
    "kind": "Method",
    "detail": "Function (MICRO_EXTRA_ROW<Scalar,Packet,Index,)",
    "insertText": "accRows(lhs_ptr, rhs_ptr, accZero, remaining_rows)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((remaining_depth == depth) && (rows >= accCols))"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (acc . packet [ j ] = res . template loadPacket<)",
    "insertText": "Packet(row, col + j)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (} bscale<)",
    "insertText": "Packet(acc, accZero, pAlpha, pMask)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (res . template storePacketBlock<)",
    "insertText": "Packet(row, col, acc)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (lhs_ptr + = remaining_rows ; rhs_ptr + = accRows ; })",
    "insertText": "for(Index j = 0; j < 4; j++)"
  },
  {
    "label": "vec_mul()",
    "kind": "Method",
    "detail": "Function (accZero . packet [ j ] =)",
    "insertText": "vec_mul(pAlpha, accZero.packet[j])"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(row + i, col + j)"
  },
  {
    "label": "MICRO_UNROLL()",
    "kind": "Method",
    "detail": "Function (} } } } # define)",
    "insertText": "MICRO_UNROLL(func) \\ func(0) func(1) func(2) func(3) func(4) func(5) func(6) func(7) #define MICRO_UNROLL_WORK(func, func2, peel) \\ MICRO_UNROLL(func2)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "func(0,peel) func(1,peel) func(2,peel) func(3,peel) \\ func(4,peel) func(5,peel) func(6,peel) func(7,peel) #define MICRO_LOAD_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ lhsV # # iter = ploadLhs<Scalar,)",
    "insertText": "Packet(lhs_ptr##iter)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (\\ lhs_ptr # # iter + = accCols ; \\ } else { \\)",
    "insertText": "EIGEN_UNUSED_VARIABLE(lhsV##iter)"
  },
  {
    "label": "MICRO_WORK_ONE()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "MICRO_WORK_ONE(iter, peel) \\ if (unroll_factor > iter)"
  },
  {
    "label": "false()",
    "kind": "Method",
    "detail": "Function (\\ pger_common<Packet,)",
    "insertText": "false(&accZero##iter, lhsV##iter, rhsV##peel)"
  },
  {
    "label": "MICRO_TYPE_PEEL4()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "MICRO_TYPE_PEEL4(func, func2, peel) \\ if (PEEL > peel)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ Packet lhsV0,lhsV1,lhsV2,lhsV3,lhsV4,lhsV5,lhsV6,lhsV7 ; \\ pbroadcast4<)",
    "insertText": "Packet(rhs_ptr + (accRows * peel), rhsV##peel[0], rhsV##peel[1], rhsV##peel[2], rhsV##peel[3])"
  },
  {
    "label": "MICRO_UNROLL_WORK()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "MICRO_UNROLL_WORK(func, func2, peel)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_UNUSED_VARIABLE(rhsV##peel)"
  },
  {
    "label": "MICRO_TYPE_PEEL1()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "MICRO_TYPE_PEEL1(func, func2, peel) \\ if (PEEL > peel)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ Packet lhsV0,lhsV1,lhsV2,lhsV3,lhsV4,lhsV5,lhsV6,lhsV7 ; \\ rhsV # # peel [ 0 ] = pset1<)",
    "insertText": "Packet(rhs_ptr[remaining_cols * peel])"
  },
  {
    "label": "MICRO_UNROLL_TYPE_PEEL()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "MICRO_UNROLL_TYPE_PEEL(M, func, func1, func2)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "func(func1,func2,0)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "func(func1,func2,1)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "func(func1,func2,2)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "func(func1,func2,3)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "func(func1,func2,4)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "func(func1,func2,5)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "func(func1,func2,6)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "func(func1,func2,7)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "func(func1,func2,8)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "func(func1,func2,9)"
  },
  {
    "label": "MICRO_UNROLL_TYPE_ONE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "MICRO_UNROLL_TYPE_ONE(M, func, func1, func2)"
  },
  {
    "label": "MICRO_UNROLL_TYPE_PEEL()",
    "kind": "Method",
    "detail": "Function (# define MICRO_ONE_PEEL4 \\)",
    "insertText": "MICRO_UNROLL_TYPE_PEEL(4, MICRO_TYPE_PEEL4, MICRO_WORK_ONE, MICRO_LOAD_ONE)"
  },
  {
    "label": "rhs_ptr()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "rhs_ptr(accRows * PEEL)"
  },
  {
    "label": "MICRO_UNROLL_TYPE_ONE()",
    "kind": "Method",
    "detail": "Function (# define MICRO_ONE4 \\)",
    "insertText": "MICRO_UNROLL_TYPE_ONE(4, MICRO_TYPE_PEEL4, MICRO_WORK_ONE, MICRO_LOAD_ONE)"
  },
  {
    "label": "MICRO_UNROLL_TYPE_PEEL()",
    "kind": "Method",
    "detail": "Function (\\ rhs_ptr + = accRows ; # define MICRO_ONE_PEEL1 \\)",
    "insertText": "MICRO_UNROLL_TYPE_PEEL(1, MICRO_TYPE_PEEL1, MICRO_WORK_ONE, MICRO_LOAD_ONE)"
  },
  {
    "label": "rhs_ptr()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "rhs_ptr(remaining_cols * PEEL)"
  },
  {
    "label": "MICRO_UNROLL_TYPE_ONE()",
    "kind": "Method",
    "detail": "Function (# define MICRO_ONE1 \\)",
    "insertText": "MICRO_UNROLL_TYPE_ONE(1, MICRO_TYPE_PEEL1, MICRO_WORK_ONE, MICRO_LOAD_ONE)"
  },
  {
    "label": "MICRO_DST_PTR_ONE()",
    "kind": "Method",
    "detail": "Function (\\ rhs_ptr + = remaining_cols ; # define)",
    "insertText": "MICRO_DST_PTR_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ bsetzero<Scalar,)",
    "insertText": "Packet(accZero##iter)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (\\ } else { \\)",
    "insertText": "EIGEN_UNUSED_VARIABLE(accZero##iter)"
  },
  {
    "label": "MICRO_UNROLL()",
    "kind": "Method",
    "detail": "Function (\\ } # define MICRO_DST_PTR)",
    "insertText": "MICRO_UNROLL(MICRO_DST_PTR_ONE) #define MICRO_SRC_PTR_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "lhs_base()",
    "kind": "Method",
    "detail": "Function (\\ lhs_ptr # # iter =)",
    "insertText": "lhs_base((row/accCols) + iter)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (\\ } else { \\)",
    "insertText": "EIGEN_UNUSED_VARIABLE(lhs_ptr##iter)"
  },
  {
    "label": "MICRO_UNROLL()",
    "kind": "Method",
    "detail": "Function (\\ } # define MICRO_SRC_PTR)",
    "insertText": "MICRO_UNROLL(MICRO_SRC_PTR_ONE) #define MICRO_PREFETCH_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "EIGEN_POWER_PREFETCH()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_POWER_PREFETCH(lhs_ptr##iter)"
  },
  {
    "label": "MICRO_UNROLL()",
    "kind": "Method",
    "detail": "Function (\\ } # define MICRO_PREFETCH)",
    "insertText": "MICRO_UNROLL(MICRO_PREFETCH_ONE) #define MICRO_STORE_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ acc . packet [ 0 ] = res . template loadPacket<)",
    "insertText": "Packet(row + iter*accCols, col + 0)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ acc . packet [ 1 ] = res . template loadPacket<)",
    "insertText": "Packet(row + iter*accCols, col + 1)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ acc . packet [ 2 ] = res . template loadPacket<)",
    "insertText": "Packet(row + iter*accCols, col + 2)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ acc . packet [ 3 ] = res . template loadPacket<)",
    "insertText": "Packet(row + iter*accCols, col + 3)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ bscale<)",
    "insertText": "Packet(acc, accZero##iter, pAlpha)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ res . template storePacketBlock<)",
    "insertText": "Packet(row + iter*accCols, col, acc)"
  },
  {
    "label": "MICRO_UNROLL()",
    "kind": "Method",
    "detail": "Function (\\ } # define MICRO_STORE)",
    "insertText": "MICRO_UNROLL(MICRO_STORE_ONE) #define MICRO_COL_STORE_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "MICRO_UNROLL()",
    "kind": "Method",
    "detail": "Function (\\ } # define MICRO_COL_STORE)",
    "insertText": "MICRO_UNROLL(MICRO_COL_STORE_ONE) template<int unroll_factor, typename Scalar, typename Packet, typename DataMapper, typename Index, const Index accRows, const Index accCols> EIGEN_STRONG_INLINE void gemm_unrolled_iteration( const DataMapper& res, const Scalar* lhs_base, const Scalar* rhs_base, Index depth, Index strideA, Index offsetA, Index& row, Index col, const Packet& pAlpha)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const Scalar* rhs_ptr = rhs_base ; const Scalar* lhs_ptr0 = NULL,* lhs_ptr1 = NULL,* lhs_ptr2 = NULL,* lhs_ptr3 = NULL,* lhs_ptr4 = NULL,* lhs_ptr5 = NULL,* lhs_ptr6 = NULL,* lhs_ptr7 = NULL ; PacketBlock<Packet,4> accZero0,accZero1,accZero2,accZero3,accZero4,accZero5,accZero6,accZero7 ; PacketBlock<Packet,4> acc ; MICRO_SRC_PTR MICRO_DST_PTR Index k = 0 ;)",
    "insertText": "for(; k + PEEL <= depth; k+= PEEL)"
  },
  {
    "label": "gemm_unrolled_col_iteration()",
    "kind": "Method",
    "detail": "Function (MICRO_ONE4 } MICRO_STORE row + = unroll_factor* accCols ; } template<int unroll_factor,Scalar,Packet,DataMapper,Index,const Index accCols> EIGEN_STRONG_INLINE void)",
    "insertText": "gemm_unrolled_col_iteration(const DataMapper& res, const Scalar* lhs_base, const Scalar* rhs_base, Index depth, Index strideA, Index offsetA, Index& row, Index col, Index remaining_cols, const Packet& pAlpha)"
  },
  {
    "label": "gemm_unrolled_col()",
    "kind": "Method",
    "detail": "Function (MICRO_ONE1 } MICRO_COL_STORE row + = unroll_factor* accCols ; } template<Scalar,Packet,DataMapper,Index,const Index accCols> EIGEN_STRONG_INLINE void)",
    "insertText": "gemm_unrolled_col(const DataMapper& res, const Scalar* lhs_base, const Scalar* rhs_base, Index depth, Index strideA, Index offsetA, Index& row, Index rows, Index col, Index remaining_cols, const Packet& pAlpha)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# define MAX_UNROLL 6)",
    "insertText": "while(row + MAX_UNROLL*accCols <= rows)"
  },
  {
    "label": "accCols()",
    "kind": "Method",
    "detail": "Function (gemm_unrolled_col_iteration<MAX_UNROLL,Scalar,Packet,DataMapper,Index,)",
    "insertText": "accCols(res, lhs_base, rhs_base, depth, strideA, offsetA, row, col, remaining_cols, pAlpha)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "switch((rows-row)/accCols)"
  },
  {
    "label": "gemm()",
    "kind": "Method",
    "detail": "Function (break ; # endif default : break ; } # undef MAX_UNROLL } template<Scalar,Index,Packet,RhsPacket,DataMapper,const Index accRows,const Index accCols> EIGEN_STRONG_INLINE void)",
    "insertText": "gemm(const DataMapper& res, const Scalar* blockA, const Scalar* blockB, Index rows, Index depth, Index cols, Scalar alpha, Index strideA, Index strideB, Index offsetA, Index offsetB)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index remaining_rows = rows % accCols ; const Index remaining_cols = cols % accRows ;)",
    "insertText": "if(strideA == -1)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet pAlpha = pset1<)",
    "insertText": "Packet(alpha)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet pMask = bmask<)",
    "insertText": "Packet((const int)(remaining_rows))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index col = 0 ;)",
    "insertText": "for(; col + accRows <= cols; col += accRows)"
  },
  {
    "label": "accCols()",
    "kind": "Method",
    "detail": "Function (gemm_unrolled_iteration<MAX_UNROLL,Scalar,Packet,DataMapper,Index,accRows,)",
    "insertText": "accCols(res, lhs_base, rhs_base, depth, strideA, offsetA, row, col, pAlpha)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; # endif default : break ; } # undef MAX_UNROLL)",
    "insertText": "if(remaining_rows > 0)"
  },
  {
    "label": "accCols()",
    "kind": "Method",
    "detail": "Function (gemm_extra_row<Scalar,Packet,DataMapper,Index,accRows,)",
    "insertText": "accCols(res, lhs_base, rhs_base, depth, strideA, offsetA, row, col, rows, cols, remaining_rows, pAlpha, pMask)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(remaining_cols > 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const Scalar* rhs_base = blockB + col* strideB + remaining_cols* offsetB ; const Scalar* lhs_base = blockA ;)",
    "insertText": "for(; col < cols; col++)"
  },
  {
    "label": "accCols()",
    "kind": "Method",
    "detail": "Function (Index row = 0 ; gemm_unrolled_col<Scalar,Packet,DataMapper,Index,)",
    "insertText": "accCols(res, lhs_base, rhs_base, depth, strideA, offsetA, row, rows, col, remaining_cols, pAlpha)"
  },
  {
    "label": "accRows()",
    "kind": "Method",
    "detail": "Function (gemm_extra_col<Scalar,Packet,DataMapper,Index,)",
    "insertText": "accRows(res, lhs_base, rhs_base, depth, strideA, offsetA, row, col, remaining_rows, remaining_cols, pAlpha)"
  },
  {
    "label": "accColsC()",
    "kind": "Method",
    "detail": "Function (} rhs_base + + ; } } } # define)",
    "insertText": "accColsC(accCols / 2) #define advanceRows ((LhsIsReal) ? 1 : 2) #define advanceCols ((RhsIsReal) ? 1 : 2) #define PEEL_COMPLEX 3 template<typename Scalar, typename Packet, typename Index, const Index accRows, bool ConjugateLhs, bool ConjugateRhs, bool LhsIsReal, bool RhsIsReal> EIGEN_ALWAYS_INLINE void MICRO_COMPLEX_EXTRA_COL( const Scalar* &lhs_ptr_real, const Scalar* &lhs_ptr_imag, const Scalar* &rhs_ptr_real, const Scalar* &rhs_ptr_imag, PacketBlock<Packet,1> &accReal, PacketBlock<Packet,1> &accImag, Index remaining_rows, Index remaining_cols)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet rhsV [ 1 ],rhsVi [ 1 ] ; rhsV [ 0 ] = pset1<)",
    "insertText": "Packet(rhs_ptr_real[0])"
  },
  {
    "label": "RhsIsReal()",
    "kind": "Method",
    "detail": "Function (pgerc<1,Scalar,Packet,ConjugateLhs,ConjugateRhs,LhsIsReal,)",
    "insertText": "RhsIsReal(&accReal, &accImag, lhs_ptr_real, lhs_ptr_imag, rhsV, rhsVi)"
  },
  {
    "label": "gemm_complex_extra_col()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,Packet,Packetc,DataMapper,Index,const Index accRows,const Index accCols,bool ConjugateLhs,bool ConjugateRhs,bool LhsIsReal,bool RhsIsReal> EIGEN_STRONG_INLINE void)",
    "insertText": "gemm_complex_extra_col(const DataMapper& res, const Scalar* lhs_base, const Scalar* rhs_base, Index depth, Index strideA, Index offsetA, Index strideB, Index row, Index col, Index remaining_rows, Index remaining_cols, const Packet& pAlphaReal, const Packet& pAlphaImag)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (PacketBlock<Packet,1> accReal,accImag ; PacketBlock<Packet,1> taccReal,taccImag ; PacketBlock<Packetc,1> acc0,acc1 ; bsetzero<Scalar,)",
    "insertText": "Packet(accReal)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (bsetzero<Scalar,)",
    "insertText": "Packet(accImag)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index k = 0 ;)",
    "insertText": "for(; k + PEEL_COMPLEX <= remaining_depth; k+= PEEL_COMPLEX)"
  },
  {
    "label": "EIGEN_POWER_PREFETCH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_POWER_PREFETCH(rhs_ptr_real)"
  },
  {
    "label": "EIGEN_POWER_PREFETCH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_POWER_PREFETCH(rhs_ptr_imag)"
  },
  {
    "label": "EIGEN_POWER_PREFETCH()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "EIGEN_POWER_PREFETCH(lhs_ptr_real)"
  },
  {
    "label": "EIGEN_POWER_PREFETCH()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_POWER_PREFETCH(lhs_ptr_imag)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int l = 0; l < PEEL_COMPLEX; l++)"
  },
  {
    "label": "RhsIsReal()",
    "kind": "Method",
    "detail": "Function (MICRO_COMPLEX_EXTRA_COL<Scalar,Packet,Index,accRows,ConjugateLhs,ConjugateRhs,LhsIsReal,)",
    "insertText": "RhsIsReal(lhs_ptr_real, lhs_ptr_imag, rhs_ptr_real, rhs_ptr_imag, accReal, accImag, remaining_rows, remaining_cols)"
  },
  {
    "label": "RhsIsReal()",
    "kind": "Method",
    "detail": "Function (pgerc<1,Scalar,Packet,Index,ConjugateLhs,ConjugateRhs,LhsIsReal,)",
    "insertText": "RhsIsReal(&accReal, &accImag, lhs_ptr_real, lhs_ptr_imag, rhsV, rhsVi, remaining_rows)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (} bscalec<)",
    "insertText": "Packet(accReal, accImag, pAlphaReal, pAlphaImag, taccReal, taccImag)"
  },
  {
    "label": "Packetc()",
    "kind": "Method",
    "detail": "Function (bcouple_common<Packet,)",
    "insertText": "Packetc(taccReal, taccImag, acc0, acc1)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(row + 0, col + 0) += pfirst<Packetc>(acc0.packet[0])"
  },
  {
    "label": "Packetc()",
    "kind": "Method",
    "detail": "Function (} else { acc0 . packet [ 0 ] + = res . template loadPacket<)",
    "insertText": "Packetc(row + 0, col + 0)"
  },
  {
    "label": "Packetc()",
    "kind": "Method",
    "detail": "Function (res . template storePacketBlock<)",
    "insertText": "Packetc(row + 0, col + 0, acc0)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(row + accColsC, col + 0) += pfirst<Packetc>(acc1.packet[0])"
  },
  {
    "label": "MICRO_COMPLEX_EXTRA_ROW()",
    "kind": "Method",
    "detail": "Function (} } } template<Scalar,Packet,Index,const Index accRows,bool ConjugateLhs,bool ConjugateRhs,bool LhsIsReal,bool RhsIsReal> EIGEN_ALWAYS_INLINE void)",
    "insertText": "MICRO_COMPLEX_EXTRA_ROW(const Scalar* &lhs_ptr_real, const Scalar* &lhs_ptr_imag, const Scalar* &rhs_ptr_real, const Scalar* &rhs_ptr_imag, PacketBlock<Packet,4> &accReal, PacketBlock<Packet,4> &accImag, Index remaining_rows)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet rhsV [ 4 ],rhsVi [ 4 ] ; pbroadcast4_old<)",
    "insertText": "Packet(rhs_ptr_real, rhsV[0], rhsV[1], rhsV[2], rhsV[3])"
  },
  {
    "label": "gemm_complex_extra_row()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,Packet,Packetc,DataMapper,Index,const Index accRows,const Index accCols,bool ConjugateLhs,bool ConjugateRhs,bool LhsIsReal,bool RhsIsReal> EIGEN_STRONG_INLINE void)",
    "insertText": "gemm_complex_extra_row(const DataMapper& res, const Scalar* lhs_base, const Scalar* rhs_base, Index depth, Index strideA, Index offsetA, Index strideB, Index row, Index col, Index rows, Index cols, Index remaining_rows, const Packet& pAlphaReal, const Packet& pAlphaImag, const Packet& pMask)"
  },
  {
    "label": "RhsIsReal()",
    "kind": "Method",
    "detail": "Function (MICRO_COMPLEX_EXTRA_ROW<Scalar,Packet,Index,accRows,ConjugateLhs,ConjugateRhs,LhsIsReal,)",
    "insertText": "RhsIsReal(lhs_ptr_real, lhs_ptr_imag, rhs_ptr_real, rhs_ptr_imag, accReal, accImag, remaining_rows)"
  },
  {
    "label": "ColMajor()",
    "kind": "Method",
    "detail": "Function (bload<DataMapper,Packetc,Index,accColsC,0,)",
    "insertText": "ColMajor(tRes, res, row, col)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (bscalec<)",
    "insertText": "Packet(accReal, accImag, pAlphaReal, pAlphaImag, taccReal, taccImag, pMask)"
  },
  {
    "label": "Packetc()",
    "kind": "Method",
    "detail": "Function (bcouple<Packet,)",
    "insertText": "Packetc(taccReal, taccImag, tRes, acc0, acc1)"
  },
  {
    "label": "Packetc()",
    "kind": "Method",
    "detail": "Function (res . template storePacketBlock<)",
    "insertText": "Packetc(row + 0, col, acc0)"
  },
  {
    "label": "Packetc()",
    "kind": "Method",
    "detail": "Function (res . template storePacketBlock<)",
    "insertText": "Packetc(row + accColsC, col, acc1)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(row + 0, col + j) += pfirst<Packetc>(acc0.packet[j])"
  },
  {
    "label": "Packetc()",
    "kind": "Method",
    "detail": "Function (PacketBlock<Packetc,1> acc2 ; acc2 . packet [ 0 ] = res . template loadPacket<)",
    "insertText": "Packetc(row + 0, col + j)"
  },
  {
    "label": "Packetc()",
    "kind": "Method",
    "detail": "Function (res . template storePacketBlock<)",
    "insertText": "Packetc(row + 0, col + j, acc2)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(row + accColsC, col + j) += pfirst<Packetc>(acc1.packet[j])"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL()",
    "kind": "Method",
    "detail": "Function (} } } } } # define)",
    "insertText": "MICRO_COMPLEX_UNROLL(func) \\ func(0) func(1) func(2) func(3) func(4) #define MICRO_COMPLEX_UNROLL_WORK(func, func2, peel) \\ MICRO_COMPLEX_UNROLL(func2)"
  },
  {
    "label": "func()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "func(0,peel) func(1,peel) func(2,peel) func(3,peel) func(4,peel) #define MICRO_COMPLEX_LOAD_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ lhsV # # iter = ploadLhs<Scalar,)",
    "insertText": "Packet(lhs_ptr_real##iter)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ lhsVi # # iter = ploadLhs<Scalar,)",
    "insertText": "Packet(lhs_ptr_imag##iter)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (\\ lhs_ptr_imag # # iter + = accCols ; \\ } else { \\)",
    "insertText": "EIGEN_UNUSED_VARIABLE(lhsVi##iter)"
  },
  {
    "label": "MICRO_COMPLEX_WORK_ONE4()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "MICRO_COMPLEX_WORK_ONE4(iter, peel) \\ if (unroll_factor > iter)"
  },
  {
    "label": "RhsIsReal()",
    "kind": "Method",
    "detail": "Function (\\ pgerc_common<4,Packet,ConjugateLhs,ConjugateRhs,LhsIsReal,)",
    "insertText": "RhsIsReal(&accReal##iter, &accImag##iter, lhsV##iter, lhsVi##iter, rhsV##peel, rhsVi##peel)"
  },
  {
    "label": "MICRO_COMPLEX_WORK_ONE1()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "MICRO_COMPLEX_WORK_ONE1(iter, peel) \\ if (unroll_factor > iter)"
  },
  {
    "label": "MICRO_COMPLEX_TYPE_PEEL4()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "MICRO_COMPLEX_TYPE_PEEL4(func, func2, peel) \\ if (PEEL_COMPLEX > peel)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ Packet lhsV0,lhsV1,lhsV2,lhsV3,lhsV4 ; \\ Packet lhsVi0,lhsVi1,lhsVi2,lhsVi3,lhsVi4 ; \\ pbroadcast4_old<)",
    "insertText": "Packet(rhs_ptr_real + (accRows * peel), rhsV##peel[0], rhsV##peel[1], rhsV##peel[2], rhsV##peel[3])"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ pbroadcast4_old<)",
    "insertText": "Packet(rhs_ptr_imag + (accRows * peel), rhsVi##peel[0], rhsVi##peel[1], rhsVi##peel[2], rhsVi##peel[3])"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (\\ } else { \\)",
    "insertText": "EIGEN_UNUSED_VARIABLE(rhsVi##peel)"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL_WORK()",
    "kind": "Method",
    "detail": "Function (\\ } \\)",
    "insertText": "MICRO_COMPLEX_UNROLL_WORK(func, func2, peel)"
  },
  {
    "label": "MICRO_COMPLEX_TYPE_PEEL1()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "MICRO_COMPLEX_TYPE_PEEL1(func, func2, peel) \\ if (PEEL_COMPLEX > peel)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ Packet lhsV0,lhsV1,lhsV2,lhsV3,lhsV4 ; \\ Packet lhsVi0,lhsVi1,lhsVi2,lhsVi3,lhsVi4 ; \\ rhsV # # peel [ 0 ] = pset1<)",
    "insertText": "Packet(rhs_ptr_real[remaining_cols * peel])"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ rhsVi # # peel [ 0 ] = pset1<)",
    "insertText": "Packet(rhs_ptr_imag[remaining_cols * peel])"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL_TYPE_PEEL()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "MICRO_COMPLEX_UNROLL_TYPE_PEEL(M, func, func1, func2)"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL_TYPE_ONE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "MICRO_COMPLEX_UNROLL_TYPE_ONE(M, func, func1, func2)"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL_TYPE_PEEL()",
    "kind": "Method",
    "detail": "Function (# define MICRO_COMPLEX_ONE_PEEL4 \\)",
    "insertText": "MICRO_COMPLEX_UNROLL_TYPE_PEEL(4, MICRO_COMPLEX_TYPE_PEEL4, MICRO_COMPLEX_WORK_ONE4, MICRO_COMPLEX_LOAD_ONE)"
  },
  {
    "label": "rhs_ptr_real()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "rhs_ptr_real(accRows * PEEL_COMPLEX)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(!RhsIsReal) rhs_ptr_imag += (accRows * PEEL_COMPLEX)"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL_TYPE_ONE()",
    "kind": "Method",
    "detail": "Function (# define MICRO_COMPLEX_ONE4 \\)",
    "insertText": "MICRO_COMPLEX_UNROLL_TYPE_ONE(4, MICRO_COMPLEX_TYPE_PEEL4, MICRO_COMPLEX_WORK_ONE4, MICRO_COMPLEX_LOAD_ONE)"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL_TYPE_PEEL()",
    "kind": "Method",
    "detail": "Function (# define MICRO_COMPLEX_ONE_PEEL1 \\)",
    "insertText": "MICRO_COMPLEX_UNROLL_TYPE_PEEL(1, MICRO_COMPLEX_TYPE_PEEL1, MICRO_COMPLEX_WORK_ONE1, MICRO_COMPLEX_LOAD_ONE)"
  },
  {
    "label": "rhs_ptr_real()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "rhs_ptr_real(remaining_cols * PEEL_COMPLEX)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(!RhsIsReal) rhs_ptr_imag += (remaining_cols * PEEL_COMPLEX)"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL_TYPE_ONE()",
    "kind": "Method",
    "detail": "Function (# define MICRO_COMPLEX_ONE1 \\)",
    "insertText": "MICRO_COMPLEX_UNROLL_TYPE_ONE(1, MICRO_COMPLEX_TYPE_PEEL1, MICRO_COMPLEX_WORK_ONE1, MICRO_COMPLEX_LOAD_ONE)"
  },
  {
    "label": "MICRO_COMPLEX_DST_PTR_ONE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "MICRO_COMPLEX_DST_PTR_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ bsetzero<Scalar,)",
    "insertText": "Packet(accReal##iter)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ bsetzero<Scalar,)",
    "insertText": "Packet(accImag##iter)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (\\ } else { \\)",
    "insertText": "EIGEN_UNUSED_VARIABLE(accReal##iter)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_UNUSED_VARIABLE(accImag##iter)"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL()",
    "kind": "Method",
    "detail": "Function (\\ } # define MICRO_COMPLEX_DST_PTR)",
    "insertText": "MICRO_COMPLEX_UNROLL(MICRO_COMPLEX_DST_PTR_ONE) #define MICRO_COMPLEX_SRC_PTR_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "lhs_base()",
    "kind": "Method",
    "detail": "Function (\\ lhs_ptr_real # # iter =)",
    "insertText": "lhs_base(((advanceRows*row)/accCols) + iter*advanceRows)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (\\ lhs_ptr_imag # # iter = lhs_ptr_real # # iter + accCols* strideA ; \\ } else { \\)",
    "insertText": "EIGEN_UNUSED_VARIABLE(lhs_ptr_imag##iter)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } else { \\)",
    "insertText": "EIGEN_UNUSED_VARIABLE(lhs_ptr_real##iter)"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL()",
    "kind": "Method",
    "detail": "Function (\\ } # define MICRO_COMPLEX_SRC_PTR)",
    "insertText": "MICRO_COMPLEX_UNROLL(MICRO_COMPLEX_SRC_PTR_ONE) #define MICRO_COMPLEX_PREFETCH_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "EIGEN_POWER_PREFETCH()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_POWER_PREFETCH(lhs_ptr_real##iter)"
  },
  {
    "label": "EIGEN_POWER_PREFETCH()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_POWER_PREFETCH(lhs_ptr_imag##iter)"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL()",
    "kind": "Method",
    "detail": "Function (\\ } \\ } # define MICRO_COMPLEX_PREFETCH)",
    "insertText": "MICRO_COMPLEX_UNROLL(MICRO_COMPLEX_PREFETCH_ONE) #define MICRO_COMPLEX_STORE_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "ColMajor()",
    "kind": "Method",
    "detail": "Function (\\ bload<DataMapper,Packetc,Index,accColsC,0,)",
    "insertText": "ColMajor(tRes, res, row + iter*accCols, col)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (\\ bscalec<)",
    "insertText": "Packet(accReal##iter, accImag##iter, pAlphaReal, pAlphaImag, taccReal, taccImag)"
  },
  {
    "label": "Packetc()",
    "kind": "Method",
    "detail": "Function (\\ res . template storePacketBlock<)",
    "insertText": "Packetc(row + iter*accCols + 0, col, acc0)"
  },
  {
    "label": "Packetc()",
    "kind": "Method",
    "detail": "Function (\\ res . template storePacketBlock<)",
    "insertText": "Packetc(row + iter*accCols + accColsC, col, acc1)"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL()",
    "kind": "Method",
    "detail": "Function (\\ } # define MICRO_COMPLEX_STORE)",
    "insertText": "MICRO_COMPLEX_UNROLL(MICRO_COMPLEX_STORE_ONE) #define MICRO_COMPLEX_COL_STORE_ONE(iter) \\ if (unroll_factor > iter)"
  },
  {
    "label": "MICRO_COMPLEX_UNROLL()",
    "kind": "Method",
    "detail": "Function (\\ } # define MICRO_COMPLEX_COL_STORE)",
    "insertText": "MICRO_COMPLEX_UNROLL(MICRO_COMPLEX_COL_STORE_ONE) template<int unroll_factor, typename Scalar, typename Packet, typename Packetc, typename DataMapper, typename Index, const Index accRows, const Index accCols, bool ConjugateLhs, bool ConjugateRhs, bool LhsIsReal, bool RhsIsReal> EIGEN_STRONG_INLINE void gemm_complex_unrolled_iteration( const DataMapper& res, const Scalar* lhs_base, const Scalar* rhs_base, Index depth, Index strideA, Index offsetA, Index strideB, Index& row, Index col, const Packet& pAlphaReal, const Packet& pAlphaImag)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (rhs_ptr_imag = rhs_base + accRows* strideB ; } else {)",
    "insertText": "EIGEN_UNUSED_VARIABLE(rhs_ptr_imag)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} const Scalar* lhs_ptr_real0 = NULL,* lhs_ptr_imag0 = NULL,* lhs_ptr_real1 = NULL,* lhs_ptr_imag1 = NULL ; const Scalar* lhs_ptr_real2 = NULL,* lhs_ptr_imag2 = NULL,* lhs_ptr_real3 = NULL,* lhs_ptr_imag3 = NULL ; const Scalar* lhs_ptr_real4 = NULL,* lhs_ptr_imag4 = NULL ; PacketBlock<Packet,4> accReal0,accImag0,accReal1,accImag1 ; PacketBlock<Packet,4> accReal2,accImag2,accReal3,accImag3 ; PacketBlock<Packet,4> accReal4,accImag4 ; PacketBlock<Packet,4> taccReal,taccImag ; PacketBlock<Packetc,4> acc0,acc1 ; PacketBlock<Packetc,8> tRes ; MICRO_COMPLEX_SRC_PTR MICRO_COMPLEX_DST_PTR Index k = 0 ;)",
    "insertText": "for(; k + PEEL_COMPLEX <= depth; k+= PEEL_COMPLEX)"
  },
  {
    "label": "gemm_complex_unrolled_col_iteration()",
    "kind": "Method",
    "detail": "Function (MICRO_COMPLEX_ONE4 } MICRO_COMPLEX_STORE row + = unroll_factor* accCols ; } template<int unroll_factor,Scalar,Packet,Packetc,DataMapper,Index,const Index accCols,bool ConjugateLhs,bool ConjugateRhs,bool LhsIsReal,bool RhsIsReal> EIGEN_STRONG_INLINE void)",
    "insertText": "gemm_complex_unrolled_col_iteration(const DataMapper& res, const Scalar* lhs_base, const Scalar* rhs_base, Index depth, Index strideA, Index offsetA, Index strideB, Index& row, Index col, Index remaining_cols, const Packet& pAlphaReal, const Packet& pAlphaImag)"
  },
  {
    "label": "gemm_complex_unrolled_col()",
    "kind": "Method",
    "detail": "Function (MICRO_COMPLEX_ONE1 } MICRO_COMPLEX_COL_STORE row + = unroll_factor* accCols ; } template<Scalar,Packet,Packetc,DataMapper,Index,const Index accCols,bool ConjugateLhs,bool ConjugateRhs,bool LhsIsReal,bool RhsIsReal> EIGEN_STRONG_INLINE void)",
    "insertText": "gemm_complex_unrolled_col(const DataMapper& res, const Scalar* lhs_base, const Scalar* rhs_base, Index depth, Index strideA, Index offsetA, Index strideB, Index& row, Index rows, Index col, Index remaining_cols, const Packet& pAlphaReal, const Packet& pAlphaImag)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# define MAX_COMPLEX_UNROLL 3)",
    "insertText": "while(row + MAX_COMPLEX_UNROLL*accCols <= rows)"
  },
  {
    "label": "RhsIsReal()",
    "kind": "Method",
    "detail": "Function (gemm_complex_unrolled_col_iteration<MAX_COMPLEX_UNROLL,Scalar,Packet,Packetc,DataMapper,Index,accCols,ConjugateLhs,ConjugateRhs,LhsIsReal,)",
    "insertText": "RhsIsReal(res, lhs_base, rhs_base, depth, strideA, offsetA, strideB, row, col, remaining_cols, pAlphaReal, pAlphaImag)"
  },
  {
    "label": "gemm_complex()",
    "kind": "Method",
    "detail": "Function (break ; # endif default : break ; } # undef MAX_COMPLEX_UNROLL } template<LhsScalar,RhsScalar,Scalarc,Scalar,Index,Packet,Packetc,RhsPacket,DataMapper,const Index accRows,const Index accCols,bool ConjugateLhs,bool ConjugateRhs,bool LhsIsReal,bool RhsIsReal> EIGEN_STRONG_INLINE void)",
    "insertText": "gemm_complex(const DataMapper& res, const LhsScalar* blockAc, const RhsScalar* blockBc, Index rows, Index depth, Index cols, Scalarc alpha, Index strideA, Index strideB, Index offsetA, Index offsetB)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet pAlphaReal = pset1<)",
    "insertText": "Packet(alpha.real())"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (const Packet pAlphaImag = pset1<)",
    "insertText": "Packet(alpha.imag())"
  },
  {
    "label": "blockA()",
    "kind": "Method",
    "detail": "Function (const Scalar*)",
    "insertText": "blockA(Scalar *)"
  },
  {
    "label": "blockB()",
    "kind": "Method",
    "detail": "Function (const Scalar*)",
    "insertText": "blockB(Scalar *)"
  },
  {
    "label": "RhsIsReal()",
    "kind": "Method",
    "detail": "Function (gemm_complex_unrolled_iteration<MAX_COMPLEX_UNROLL,Scalar,Packet,Packetc,DataMapper,Index,accRows,accCols,ConjugateLhs,ConjugateRhs,LhsIsReal,)",
    "insertText": "RhsIsReal(res, lhs_base, rhs_base, depth, strideA, offsetA, strideB, row, col, pAlphaReal, pAlphaImag)"
  },
  {
    "label": "RhsIsReal()",
    "kind": "Method",
    "detail": "Function (gemm_complex_extra_row<Scalar,Packet,Packetc,DataMapper,Index,accRows,accCols,ConjugateLhs,ConjugateRhs,LhsIsReal,)",
    "insertText": "RhsIsReal(res, lhs_base, rhs_base, depth, strideA, offsetA, strideB, row, col, rows, cols, remaining_rows, pAlphaReal, pAlphaImag, pMask)"
  },
  {
    "label": "RhsIsReal()",
    "kind": "Method",
    "detail": "Function (Index row = 0 ; gemm_complex_unrolled_col<Scalar,Packet,Packetc,DataMapper,Index,accCols,ConjugateLhs,ConjugateRhs,LhsIsReal,)",
    "insertText": "RhsIsReal(res, lhs_base, rhs_base, depth, strideA, offsetA, strideB, row, rows, col, remaining_cols, pAlphaReal, pAlphaImag)"
  },
  {
    "label": "RhsIsReal()",
    "kind": "Method",
    "detail": "Function (gemm_complex_extra_col<Scalar,Packet,Packetc,DataMapper,Index,accRows,accCols,ConjugateLhs,ConjugateRhs,LhsIsReal,)",
    "insertText": "RhsIsReal(res, lhs_base, rhs_base, depth, strideA, offsetA, strideB, row, col, remaining_rows, remaining_cols, pAlphaReal, pAlphaImag)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} rhs_base + + ; } } } # undef accColsC # undef advanceCols # undef advanceRows template<Index,DataMapper,int Pack1,int Pack2,Packet,bool Conjugate,bool PanelMode> struct gemm_pack_lhs<double,Index,DataMapper,Pack1,Pack2,Packet,ColMajor,Conjugate,PanelMode> { void)",
    "insertText": "operator()(double* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride=0, Index offset=0)"
  },
  {
    "label": "pack()",
    "kind": "Method",
    "detail": "Function (dhs_pack<double,Index,DataMapper,Packet2d,ColMajor,PanelMode,true> pack ;)",
    "insertText": "pack(blockA, lhs, depth, rows, stride, offset)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # if EIGEN_ALTIVEC_USE_CUSTOM_PACK template<Index,DataMapper,int nr,bool Conjugate,bool PanelMode> struct gemm_pack_rhs<double,Index,DataMapper,nr,ColMajor,Conjugate,PanelMode> { void)",
    "insertText": "operator()(double* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride=0, Index offset=0)"
  },
  {
    "label": "pack()",
    "kind": "Method",
    "detail": "Function (dhs_pack<double,Index,DataMapper,Packet2d,ColMajor,PanelMode,false> pack ;)",
    "insertText": "pack(blockB, rhs, depth, cols, stride, offset)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif template<Index,DataMapper,int Pack1,int Pack2,Packet,bool Conjugate,bool PanelMode> struct gemm_pack_lhs<float,Index,DataMapper,Pack1,Pack2,Packet,RowMajor,Conjugate,PanelMode> { void)",
    "insertText": "operator()(float* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride=0, Index offset=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int Pack1,int Pack2,Packet,bool Conjugate,bool PanelMode> void gemm_pack_lhs<float,Index,DataMapper,Pack1,Pack2,Packet,RowMajor,Conjugate,PanelMode)",
    "insertText": "operator()(float* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride, Index offset)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index,DataMapper,int Pack1,int Pack2,Packet,bool Conjugate,bool PanelMode> struct gemm_pack_lhs<std::complex<float>,Index,DataMapper,Pack1,Pack2,Packet,RowMajor,Conjugate,PanelMode> { void)",
    "insertText": "operator()(std::complex<float>* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride=0, Index offset=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int Pack1,int Pack2,Packet,bool Conjugate,bool PanelMode> void gemm_pack_lhs<std::complex<float>,Index,DataMapper,Pack1,Pack2,Packet,RowMajor,Conjugate,PanelMode)",
    "insertText": "operator()(std::complex<float>* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride, Index offset)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # if EIGEN_ALTIVEC_USE_CUSTOM_PACK template<Index,DataMapper,int nr,bool Conjugate,bool PanelMode> struct gemm_pack_rhs<float,Index,DataMapper,nr,ColMajor,Conjugate,PanelMode> { void)",
    "insertText": "operator()(float* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride=0, Index offset=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int nr,bool Conjugate,bool PanelMode> void gemm_pack_rhs<float,Index,DataMapper,nr,ColMajor,Conjugate,PanelMode)",
    "insertText": "operator()(float* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride, Index offset)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} # endif template<Index,DataMapper,int nr,bool Conjugate,bool PanelMode> struct gemm_pack_rhs<std::complex<float>,Index,DataMapper,nr,ColMajor,Conjugate,PanelMode> { void)",
    "insertText": "operator()(std::complex<float>* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride=0, Index offset=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int nr,bool Conjugate,bool PanelMode> void gemm_pack_rhs<std::complex<float>,Index,DataMapper,nr,ColMajor,Conjugate,PanelMode)",
    "insertText": "operator()(std::complex<float>* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride, Index offset)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index,DataMapper,int Pack1,int Pack2,Packet,bool Conjugate,bool PanelMode> struct gemm_pack_lhs<std::complex<double>,Index,DataMapper,Pack1,Pack2,Packet,RowMajor,Conjugate,PanelMode> { void)",
    "insertText": "operator()(std::complex<double>* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride=0, Index offset=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index,DataMapper,int nr,bool Conjugate,bool PanelMode> struct gemm_pack_rhs<std::complex<double>,Index,DataMapper,nr,ColMajor,Conjugate,PanelMode> { void)",
    "insertText": "operator()(std::complex<double>* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride=0, Index offset=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> struct gebp_kernel<float,float,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs> { typedef quad_traits<float>::vectortype Packet ; typedef quad_traits<float>::rhstype RhsPacket ; void)",
    "insertText": "operator()(const DataMapper& res, const float* blockA, const float* blockB, Index rows, Index depth, Index cols, float alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> void gebp_kernel<float,float,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs)",
    "insertText": "operator()(const DataMapper& res, const float* blockA, const float* blockB, Index rows, Index depth, Index cols, float alpha, Index strideA, Index strideB, Index offsetA, Index offsetB)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (const Index accRows = quad_traits<float>::rows ; const Index accCols = quad_traits<float>::size ;)",
    "insertText": "void(*gemm_function)(const DataMapper&, const float*, const float*, Index, Index, Index, float, Index, Index, Index, Index)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_ALTIVEC_MMA_ONLY gemm_function =& Eigen::internal::gemmMMA<float,Index,Packet,RhsPacket,DataMapper,accRows,accCols> ; # elif)",
    "insertText": "defined(ALTIVEC_MMA_SUPPORT) && !defined(EIGEN_ALTIVEC_DISABLE_MMA) if (__builtin_cpu_supports (\"arch_3_1\") && __builtin_cpu_supports (\"mma\"))"
  },
  {
    "label": "gemm_function()",
    "kind": "Method",
    "detail": "Function (gemm_function =& Eigen::internal::gemmMMA<float,Index,Packet,RhsPacket,DataMapper,accRows,accCols> ; } else { gemm_function =& Eigen::internal::gemm<float,Index,Packet,RhsPacket,DataMapper,accRows,accCols> ; } # else gemm_function =& Eigen::internal::gemm<float,Index,Packet,RhsPacket,DataMapper,accRows,accCols> ; # endif)",
    "insertText": "gemm_function(res, blockA, blockB, rows, depth, cols, alpha, strideA, strideB, offsetA, offsetB)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> struct gebp_kernel<std::complex<float>,std::complex<float>,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs> { typedef Packet4f Packet ; typedef Packet2cf Packetc ; typedef Packet4f RhsPacket ; void)",
    "insertText": "operator()(const DataMapper& res, const std::complex<float>* blockA, const std::complex<float>* blockB, Index rows, Index depth, Index cols, std::complex<float> alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> void gebp_kernel<std::complex<float>,std::complex<float>,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs)",
    "insertText": "operator()(const DataMapper& res, const std::complex<float>* blockA, const std::complex<float>* blockB, Index rows, Index depth, Index cols, std::complex<float> alpha, Index strideA, Index strideB, Index offsetA, Index offsetB)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (const Index accRows = quad_traits<float>::rows ; const Index accCols = quad_traits<float>::size ;)",
    "insertText": "void(*gemm_function)(const DataMapper&, const std::complex<float>*, const std::complex<float>*, Index, Index, Index, std::complex<float>, Index, Index, Index, Index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> struct gebp_kernel<float,std::complex<float>,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs> { typedef Packet4f Packet ; typedef Packet2cf Packetc ; typedef Packet4f RhsPacket ; void)",
    "insertText": "operator()(const DataMapper& res, const float* blockA, const std::complex<float>* blockB, Index rows, Index depth, Index cols, std::complex<float> alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> void gebp_kernel<float,std::complex<float>,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs)",
    "insertText": "operator()(const DataMapper& res, const float* blockA, const std::complex<float>* blockB, Index rows, Index depth, Index cols, std::complex<float> alpha, Index strideA, Index strideB, Index offsetA, Index offsetB)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (const Index accRows = quad_traits<float>::rows ; const Index accCols = quad_traits<float>::size ;)",
    "insertText": "void(*gemm_function)(const DataMapper&, const float*, const std::complex<float>*, Index, Index, Index, std::complex<float>, Index, Index, Index, Index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> struct gebp_kernel<std::complex<float>,float,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs> { typedef Packet4f Packet ; typedef Packet2cf Packetc ; typedef Packet4f RhsPacket ; void)",
    "insertText": "operator()(const DataMapper& res, const std::complex<float>* blockA, const float* blockB, Index rows, Index depth, Index cols, std::complex<float> alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> void gebp_kernel<std::complex<float>,float,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs)",
    "insertText": "operator()(const DataMapper& res, const std::complex<float>* blockA, const float* blockB, Index rows, Index depth, Index cols, std::complex<float> alpha, Index strideA, Index strideB, Index offsetA, Index offsetB)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (const Index accRows = quad_traits<float>::rows ; const Index accCols = quad_traits<float>::size ;)",
    "insertText": "void(*gemm_function)(const DataMapper&, const std::complex<float>*, const float*, Index, Index, Index, std::complex<float>, Index, Index, Index, Index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> struct gebp_kernel<double,double,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs> { typedef quad_traits<double>::vectortype Packet ; typedef quad_traits<double>::rhstype RhsPacket ; void)",
    "insertText": "operator()(const DataMapper& res, const double* blockA, const double* blockB, Index rows, Index depth, Index cols, double alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> void gebp_kernel<double,double,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs)",
    "insertText": "operator()(const DataMapper& res, const double* blockA, const double* blockB, Index rows, Index depth, Index cols, double alpha, Index strideA, Index strideB, Index offsetA, Index offsetB)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (const Index accRows = quad_traits<double>::rows ; const Index accCols = quad_traits<double>::size ;)",
    "insertText": "void(*gemm_function)(const DataMapper&, const double*, const double*, Index, Index, Index, double, Index, Index, Index, Index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> struct gebp_kernel<std::complex<double>,std::complex<double>,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs> { typedef quad_traits<double>::vectortype Packet ; typedef Packet1cd Packetc ; typedef quad_traits<double>::rhstype RhsPacket ; void)",
    "insertText": "operator()(const DataMapper& res, const std::complex<double>* blockA, const std::complex<double>* blockB, Index rows, Index depth, Index cols, std::complex<double> alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> void gebp_kernel<std::complex<double>,std::complex<double>,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs)",
    "insertText": "operator()(const DataMapper& res, const std::complex<double>* blockA, const std::complex<double>* blockB, Index rows, Index depth, Index cols, std::complex<double> alpha, Index strideA, Index strideB, Index offsetA, Index offsetB)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (const Index accRows = quad_traits<double>::rows ; const Index accCols = quad_traits<double>::size ;)",
    "insertText": "void(*gemm_function)(const DataMapper&, const std::complex<double>*, const std::complex<double>*, Index, Index, Index, std::complex<double>, Index, Index, Index, Index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> struct gebp_kernel<std::complex<double>,double,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs> { typedef quad_traits<double>::vectortype Packet ; typedef Packet1cd Packetc ; typedef quad_traits<double>::rhstype RhsPacket ; void)",
    "insertText": "operator()(const DataMapper& res, const std::complex<double>* blockA, const double* blockB, Index rows, Index depth, Index cols, std::complex<double> alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> void gebp_kernel<std::complex<double>,double,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs)",
    "insertText": "operator()(const DataMapper& res, const std::complex<double>* blockA, const double* blockB, Index rows, Index depth, Index cols, std::complex<double> alpha, Index strideA, Index strideB, Index offsetA, Index offsetB)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (const Index accRows = quad_traits<double>::rows ; const Index accCols = quad_traits<double>::size ;)",
    "insertText": "void(*gemm_function)(const DataMapper&, const std::complex<double>*, const double*, Index, Index, Index, std::complex<double>, Index, Index, Index, Index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> struct gebp_kernel<double,std::complex<double>,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs> { typedef quad_traits<double>::vectortype Packet ; typedef Packet1cd Packetc ; typedef quad_traits<double>::rhstype RhsPacket ; void)",
    "insertText": "operator()(const DataMapper& res, const double* blockA, const std::complex<double>* blockB, Index rows, Index depth, Index cols, std::complex<double> alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> void gebp_kernel<double,std::complex<double>,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs)",
    "insertText": "operator()(const DataMapper& res, const double* blockA, const std::complex<double>* blockB, Index rows, Index depth, Index cols, std::complex<double> alpha, Index strideA, Index strideB, Index offsetA, Index offsetB)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (const Index accRows = quad_traits<double>::rows ; const Index accCols = quad_traits<double>::size ;)",
    "insertText": "void(*gemm_function)(const DataMapper&, const double*, const std::complex<double>*, Index, Index, Index, std::complex<double>, Index, Index, Index, Index)"
  }
]