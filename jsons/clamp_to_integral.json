[
  {
    "label": "_IntT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_IntT"
  },
  {
    "label": "_FloatT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_FloatT"
  },
  {
    "label": "_RealT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_RealT"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___RANDOM_CLAMP_TO_INTEGRAL_H # define _LIBCPP___RANDOM_CLAMP_TO_INTEGRAL_H # include<__config> # include<cmath> # include<limits> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER) # pragma GCC system_header #endif _LIBCPP_PUSH_MACROS #include <__undef_macros> _LIBCPP_BEGIN_NAMESPACE_STD template <class _IntT, class _FloatT, bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits), int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR _IntT __max_representable_int_for_float()"
  },
  {
    "label": "__clamp_to_integral()",
    "kind": "Method",
    "detail": "Function (} template<class _IntT,class _RealT> _LIBCPP_INLINE_VISIBILITY _IntT)",
    "insertText": "__clamp_to_integral(_RealT __r)"
  },
  {
    "label": "_RealT()",
    "kind": "Method",
    "detail": "Function (using _Lim = numeric_limits<_IntT> ; const _IntT _MaxVal = __max_representable_int_for_float<_IntT,)",
    "insertText": "_RealT()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(__r <= _Lim::lowest())"
  },
  {
    "label": "_IntT()",
    "kind": "Method",
    "detail": "Function (} return static_cast<)",
    "insertText": "_IntT(__r)"
  }
]