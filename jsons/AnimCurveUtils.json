[
  {
    "label": "FCurveUtils",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCurveUtils"
  },
  {
    "label": "ElementPassesFilter()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" AnimBulkCurves . h \" # include \" AnimCurveTypes . h \" # include \" AnimCurveFilter . h \" namespace UE::Anim { struct FCurveUtils { private : bool)",
    "insertText": "ElementPassesFilter(ECurveFilterMode InFilterMode, ECurveFilterFlags InFilterFlags)"
  },
  {
    "label": "BuildSortedFiltered()",
    "kind": "Method",
    "detail": "Function (} return false ; } ; template<NamePredicateType,ValuePredicateType,CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildSortedFiltered(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, int32 InNumElements, NamePredicateType InNamePredicate, ValuePredicateType InValuePredicate, const FCurveFilter& InFilter)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (OutCurve .)",
    "insertText": "Empty()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OutCurve .)",
    "insertText": "Reserve(InNumElements)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 NumElements0 = InNumElements ; const int32 NumElements1 = InFilter . Elements .)",
    "insertText": "Num()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 ElementIndex0 = 0 ; int32 ElementIndex1 = 0 ; # if DO_ANIM_NAMED_VALUE_SORTING_CHECKS FName LastCurveName ; # endif)",
    "insertText": "while(ElementIndex0 < NumElements0 || ElementIndex1 < NumElements1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } else)",
    "insertText": "if(ElementIndex1 == NumElements1 && ElementIndex0 < NumElements0)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OutCurve . Elements .)",
    "insertText": "Reserve(OutCurve.Elements.Num() + (NumElements0 - ElementIndex0))"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (OutCurve . Elements .)",
    "insertText": "Emplace(InNamePredicate(ElementIndex0), InValuePredicate(ElementIndex0))"
  },
  {
    "label": "InNamePredicate()",
    "kind": "Method",
    "detail": "Function (} } break ; } const FName CurveName =)",
    "insertText": "InNamePredicate(ElementIndex0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FCurveFilterElement* RESTRICT Element1 =& InFilter . Elements [ ElementIndex1 ] ; # if DO_ANIM_NAMED_VALUE_SORTING_CHECKS)",
    "insertText": "if(ElementIndex0 > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(CurveName == Element1->Name)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (OutCurve . Elements .)",
    "insertText": "Emplace(CurveName, InValuePredicate(ElementIndex0))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} + + ElementIndex0 ; + + ElementIndex1 ; } else)",
    "insertText": "if(CurveName.FastLess(Element1->Name))"
  },
  {
    "label": "CheckDuplicates()",
    "kind": "Method",
    "detail": "Function (} + + ElementIndex0 ; } else { + + ElementIndex1 ; } } OutCurve .)",
    "insertText": "CheckDuplicates()"
  },
  {
    "label": "BuildLinearUnfiltered()",
    "kind": "Method",
    "detail": "Function (} template<NamePredicateType,ValuePredicateType,CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildLinearUnfiltered(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, int32 InNumElements, NamePredicateType InNamePredicate, ValuePredicateType InValuePredicate)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (OutCurve . Elements .)",
    "insertText": "Emplace(InNamePredicate(ElementIndex), InValuePredicate(ElementIndex))"
  },
  {
    "label": "BuildLinearUnfiltered()",
    "kind": "Method",
    "detail": "Function (} template<NamePredicateType,ValuePredicateType,ValidityPredicateType,CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildLinearUnfiltered(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, int32 InNumElements, NamePredicateType InNamePredicate, ValuePredicateType InValuePredicate, ValidityPredicateType InValidityPredicate)"
  },
  {
    "label": "BuildSorted()",
    "kind": "Method",
    "detail": "Function (} public : template<NamePredicateType,ValuePredicateType,CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildSorted(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, int32 InNumElements, NamePredicateType InNamePredicate, ValuePredicateType InValuePredicate, const FCurveFilter* InFilter = nullptr)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FCurveUtils_BuildSorted)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OutCurve . bSorted = true ;)",
    "insertText": "if(InFilter != nullptr && !InFilter->IsEmpty())"
  },
  {
    "label": "BuildSortedFiltered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildSortedFiltered(OutCurve, InNumElements, InNamePredicate, InValuePredicate, *InFilter)"
  },
  {
    "label": "CheckSorted()",
    "kind": "Method",
    "detail": "Function (OutCurve .)",
    "insertText": "CheckSorted()"
  },
  {
    "label": "BuildLinearUnfiltered()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "BuildLinearUnfiltered(OutCurve, InNumElements, InNamePredicate, InValuePredicate)"
  },
  {
    "label": "BuildUnsortedUnfiltered()",
    "kind": "Method",
    "detail": "Function (} } template<NamePredicateType,ValuePredicateType,CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildUnsortedUnfiltered(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, int32 InNumElements, NamePredicateType InNamePredicate, ValuePredicateType InValuePredicate)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FCurveUtils_BuildUnsortedUnfiltered)"
  },
  {
    "label": "BuildUnsorted()",
    "kind": "Method",
    "detail": "Function (} template<CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildUnsorted(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, const TMap<FName, float>& InMap)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FCurveUtils_BuildUnsortedFromMap)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OutCurve .)",
    "insertText": "Reserve(InMap.Num())"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (OutCurve . Elements .)",
    "insertText": "Emplace(NameValuePair.Key, NameValuePair.Value)"
  },
  {
    "label": "BuildUnsorted()",
    "kind": "Method",
    "detail": "Function (} } template<CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildUnsorted(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, TConstArrayView<TTuple<FName, float>> InInputArrayView)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FCurveUtils_BuildUnsortedFromArrayView)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OutCurve .)",
    "insertText": "Reserve(InInputArrayView.Num())"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (OutCurve . Elements .)",
    "insertText": "Emplace(NameValueTuple.Get<0>(), NameValueTuple.Get<1>())"
  },
  {
    "label": "BuildUnsorted()",
    "kind": "Method",
    "detail": "Function (} template<CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildUnsorted(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, std::initializer_list<TTuple<FName, float>> InInputArgs)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (OutCurve .)",
    "insertText": "Reserve(InInputArgs.size())"
  },
  {
    "label": "BuildUnsorted()",
    "kind": "Method",
    "detail": "Function (} template<CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildUnsorted(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, std::initializer_list<TTuple<FName, UE::Anim::ECurveElementFlags>> InInputArgs)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (OutCurve . Elements .)",
    "insertText": "Emplace(NameFlagTuple.Get<0>(), NameFlagTuple.Get<1>())"
  },
  {
    "label": "BuildUnsorted()",
    "kind": "Method",
    "detail": "Function (} template<CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildUnsorted(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, std::initializer_list<TTuple<FName, float, UE::Anim::ECurveElementFlags>> InInputArgs)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (OutCurve . Elements .)",
    "insertText": "Emplace(NameValueFlagTuple.Get<0>(), NameValueFlagTuple.Get<1>(), NameValueFlagTuple.Get<2>())"
  },
  {
    "label": "BuildUnsorted()",
    "kind": "Method",
    "detail": "Function (} template<NamePredicateType,ValuePredicateType,CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildUnsorted(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, int32 InNumElements, NamePredicateType InNamePredicate, ValuePredicateType InValuePredicate, const FCurveFilter* InFilter = nullptr)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FCurveUtils_BuildUnsorted)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<int32,FAnimStackAllocator> SortedIndices ; SortedIndices .)",
    "insertText": "SetNumUninitialized(InNumElements)"
  },
  {
    "label": "Sort()",
    "kind": "Method",
    "detail": "Function (SortedIndices [ NameIndex ] = NameIndex ; } SortedIndices .)",
    "insertText": "Sort([&InNamePredicate](int32 InLHS, int32 InRHS) { return InNamePredicate(InLHS).FastLess(InNamePredicate(InRHS)); })"
  },
  {
    "label": "InNamePredicate()",
    "kind": "Method",
    "detail": "Function (auto GetSortedName = [& SortedIndices,&)",
    "insertText": "InNamePredicate(int32 InIndex)"
  },
  {
    "label": "InValuePredicate()",
    "kind": "Method",
    "detail": "Function (} ; auto GetSortedValue = [& SortedIndices,&)",
    "insertText": "InValuePredicate(int32 InIndex)"
  },
  {
    "label": "BuildSortedFiltered()",
    "kind": "Method",
    "detail": "Function (} ; OutCurve . bSorted = true ;)",
    "insertText": "BuildSortedFiltered(OutCurve, InNumElements, GetSortedName, GetSortedValue, *InFilter)"
  },
  {
    "label": "BuildUnsortedValidated()",
    "kind": "Method",
    "detail": "Function (} } template<NamePredicateType,ValuePredicateType,ValidityPredicateType,CurveAllocatorType,CurveElementType> void)",
    "insertText": "BuildUnsortedValidated(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& OutCurve, int32 InNumElements, NamePredicateType InNamePredicate, ValuePredicateType InValuePredicate, ValidityPredicateType InValidityPredicate)"
  },
  {
    "label": "BuildLinearUnfiltered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildLinearUnfiltered(OutCurve, InNumElements, InNamePredicate, InValuePredicate, InValidityPredicate)"
  },
  {
    "label": "Filter()",
    "kind": "Method",
    "detail": "Function (} template<CurveAllocatorType,CurveElementType> void)",
    "insertText": "Filter(TBaseBlendedCurve<CurveAllocatorType, CurveElementType>& InOutCurve, const FCurveFilter& InFilter)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FCurveUtils_Filter)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (InOutCurve . Elements .)",
    "insertText": "Reset()"
  },
  {
    "label": "SortElementsIfRequired()",
    "kind": "Method",
    "detail": "Function (InFilter .)",
    "insertText": "SortElementsIfRequired()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 ElementIndex0 = 0 ; int32 ElementIndex1 = 0 ;)",
    "insertText": "while(true)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (InOutCurve . Elements .)",
    "insertText": "RemoveAt(ElementIndex0, EAllowShrinking::No)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { + + ElementIndex0 ; } } break ; } else)",
    "insertText": "if(ElementIndex0 == NumElements0 && ElementIndex1 == NumElements1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } const CurveElementType* RESTRICT Element0 =& InOutCurve . Elements [ ElementIndex0 ] ; const FCurveFilterElement* RESTRICT Element1 =& InFilter . Elements [ ElementIndex1 ] ;)",
    "insertText": "if(Element0->Name == Element1->Name)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + ElementIndex1 ; } else { + + ElementIndex0 ; + + ElementIndex1 ; } } else)",
    "insertText": "if(Element0->Name.FastLess(Element1->Name))"
  },
  {
    "label": "BulkGet()",
    "kind": "Method",
    "detail": "Function (} template<CurveType0,CurveType1,ValuePredicateType> void)",
    "insertText": "BulkGet(const CurveType0& InCurve, const CurveType1& InBulkCurves, ValuePredicateType InValuePredicate)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FCurveUtils_BulkGet)"
  },
  {
    "label": "Intersection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Intersection(InCurve, InBulkCurves, [&InValuePredicate](const typename CurveType0::ElementType& InElement0, const typename CurveType1::ElementType& InElement1) { InValuePredicate(InElement1, InElement0.Value); })"
  },
  {
    "label": "BulkSet()",
    "kind": "Method",
    "detail": "Function (} template<CurveType0,CurveType1,ValuePredicateType> void)",
    "insertText": "BulkSet(CurveType0& InCurve, const CurveType1& InBulkCurves, ValuePredicateType InValuePredicate)"
  },
  {
    "label": "CURVE_PROFILE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CURVE_PROFILE_CYCLE_COUNTER(FCurveUtils_BulkSet)"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Union(InCurve, InBulkCurves, [&InValuePredicate](typename CurveType0::ElementType& InOutElement0, const typename CurveType1::ElementType& InElement1, UE::Anim::ENamedValueUnionFlags InFlags) { if(EnumHasAllFlags(InFlags, UE::Anim::ENamedValueUnionFlags::ValidArg1)) { InOutElement0.Value = InValuePredicate(InElement1); } })"
  }
]