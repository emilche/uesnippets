[
  {
    "label": "FReferenceCollector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FReferenceCollector"
  },
  {
    "label": "FDynamicallyTypedValueType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDynamicallyTypedValueType"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FDynamicallyTypedValue",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FDynamicallyTypedValue"
  },
  {
    "label": "FTypeReferenceCollector",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTypeReferenceCollector"
  },
  {
    "label": "FDynamicallyTypedValueType()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" HAL / UnrealMemory . h \" # include \" Math / UnrealMathSSE . h \" # include \" Misc / AssertionMacros . h \" # include \" Serialization / StructuredArchive . h \" # include \" Templates / UnrealTemplate . h \" # include \" UObject / Object . h \" # include \" UObject / UObjectGlobals . h \" # include \" AutoRTFM / AutoRTFM . h \" class FReferenceCollector ; namespace UE { struct FDynamicallyTypedValueType { enum class EContainsReferences : bool { DoesNot,Maybe,} ;)",
    "insertText": "FDynamicallyTypedValueType(SIZE_T InNumBytes, uint8 InMinAlignmentLogTwo, EContainsReferences InContainsReferences) : NumBytes(InNumBytes) , MinAlignmentLogTwo(InMinAlignmentLogTwo) , ContainsReferences(InContainsReferences)"
  },
  {
    "label": "MarkReachable()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MarkReachable(FReferenceCollector& Collector)"
  },
  {
    "label": "MarkValueReachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MarkValueReachable(void* Data, FReferenceCollector& Collector)"
  },
  {
    "label": "InitializeValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeValue(void* Data)"
  },
  {
    "label": "InitializeValueFromCopy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeValueFromCopy(void* DestData, const void* SourceData)"
  },
  {
    "label": "DestroyValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroyValue(void* Data)"
  },
  {
    "label": "SerializeValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SerializeValue(FStructuredArchive::FSlot Slot, void* Data, const void* DefaultData)"
  },
  {
    "label": "GetValueHash()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "GetValueHash(const void* Data)"
  },
  {
    "label": "AreIdentical()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AreIdentical(const void* DataA, const void* DataB)"
  },
  {
    "label": "GetNumBytes()",
    "kind": "Method",
    "detail": "Function (SIZE_T)",
    "insertText": "GetNumBytes()"
  },
  {
    "label": "FDynamicallyTypedValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FDynamicallyTypedValue()"
  },
  {
    "label": "InitializeToNull()",
    "kind": "Method",
    "detail": "Function (UE_AUTORTFM_OPEN {)",
    "insertText": "InitializeToNull()"
  },
  {
    "label": "FDynamicallyTypedValue()",
    "kind": "Method",
    "detail": "Function (} ; })",
    "insertText": "FDynamicallyTypedValue(const FDynamicallyTypedValue& Copyee)"
  },
  {
    "label": "InitializeFromCopy()",
    "kind": "Method",
    "detail": "Function (UE_AUTORTFM_OPEN {)",
    "insertText": "InitializeFromCopy(Copyee)"
  },
  {
    "label": "FDynamicallyTypedValue()",
    "kind": "Method",
    "detail": "Function (} ; })",
    "insertText": "FDynamicallyTypedValue(FDynamicallyTypedValue&& Movee)"
  },
  {
    "label": "InitializeFromMove()",
    "kind": "Method",
    "detail": "Function (UE_AUTORTFM_OPEN {)",
    "insertText": "InitializeFromMove(MoveTemp(Movee))"
  },
  {
    "label": "Deinit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deinit()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FDynamicallyTypedValue&)",
    "insertText": "operator(const FDynamicallyTypedValue& Copyee)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return* this ; } FDynamicallyTypedValue&)",
    "insertText": "operator(FDynamicallyTypedValue&& Movee)"
  },
  {
    "label": "GetDataPointer()",
    "kind": "Method",
    "detail": "Function (} return* this ; } const void*)",
    "insertText": "GetDataPointer()"
  },
  {
    "label": "GetType()",
    "kind": "Method",
    "detail": "Function (} FDynamicallyTypedValueType&)",
    "insertText": "GetType()"
  },
  {
    "label": "InitializeAsType()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitializeAsType(FDynamicallyTypedValueType& NewType)"
  },
  {
    "label": "AllocateData()",
    "kind": "Method",
    "detail": "Function (Type =& NewType ;)",
    "insertText": "AllocateData()"
  },
  {
    "label": "InitializeValue()",
    "kind": "Method",
    "detail": "Function (Type ->)",
    "insertText": "InitializeValue(GetDataPointer())"
  },
  {
    "label": "MarkTypeReachableIfIncrementalReachabilityPending()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MarkTypeReachableIfIncrementalReachabilityPending()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] uint32)",
    "insertText": "GetTypeHash(const FDynamicallyTypedValue& DynamicallyTypedValue)"
  },
  {
    "label": "IsIgnoringArchetypeRef()",
    "kind": "Method",
    "detail": "Function (struct FTypeReferenceCollector final : public FReferenceCollector { bool)",
    "insertText": "IsIgnoringArchetypeRef()"
  },
  {
    "label": "MarkAsReachable()",
    "kind": "Method",
    "detail": "Function (UE::)",
    "insertText": "MarkAsReachable(InObject)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } ;)",
    "insertText": "if(UE::GC::GIsIncrementalReachabilityPending && Type)"
  },
  {
    "label": "MarkReachable()",
    "kind": "Method",
    "detail": "Function (FTypeReferenceCollector Collector ; Type ->)",
    "insertText": "MarkReachable(Collector)"
  },
  {
    "label": "NullType()",
    "kind": "Method",
    "detail": "Function (Type =&)",
    "insertText": "NullType()"
  },
  {
    "label": "DestroyValue()",
    "kind": "Method",
    "detail": "Function (Type ->)",
    "insertText": "DestroyValue(GetDataPointer())"
  },
  {
    "label": "FreeData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeData()"
  },
  {
    "label": "InitializeFromCopy()",
    "kind": "Method",
    "detail": "Function (Type = nullptr ; } void)",
    "insertText": "InitializeFromCopy(const FDynamicallyTypedValue& Copyee)"
  },
  {
    "label": "InitializeValueFromCopy()",
    "kind": "Method",
    "detail": "Function (Type ->)",
    "insertText": "InitializeValueFromCopy(GetDataPointer(), Copyee.GetDataPointer())"
  },
  {
    "label": "InitializeFromMove()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitializeFromMove(FDynamicallyTypedValue&& Movee)"
  },
  {
    "label": "IsInline()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsInline()"
  },
  {
    "label": "Malloc()",
    "kind": "Method",
    "detail": "Function (InlineData = 0 ; } else { HeapData =)",
    "insertText": "Malloc(Type->GetNumBytes(), Type->GetMinAlignment())"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(HeapData)"
  }
]