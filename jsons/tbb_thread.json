[
  {
    "label": "tbb_thread_v3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "tbb_thread_v3"
  },
  {
    "label": "thread_closure_base",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "thread_closure_base"
  },
  {
    "label": "F",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "F"
  },
  {
    "label": "thread_closure_0",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "thread_closure_0"
  },
  {
    "label": "X",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "X"
  },
  {
    "label": "thread_closure_1",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "thread_closure_1"
  },
  {
    "label": "Y",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Y"
  },
  {
    "label": "thread_closure_2",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "thread_closure_2"
  },
  {
    "label": "id",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "id"
  },
  {
    "label": "charT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "charT"
  },
  {
    "label": "traits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "traits"
  },
  {
    "label": "__TBB_NATIVE_THREAD_ROUTINE_PTR()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_tbb_thread_H # define __TBB_tbb_thread_H # include \" tbb_stddef . h \" # if _WIN32 | | _WIN64 # include \" machine / windows_api . h \" # define __TBB_NATIVE_THREAD_ROUTINE unsigned WINAPI # define)",
    "insertText": "__TBB_NATIVE_THREAD_ROUTINE_PTR(r) unsigned (WINAPI* r)( void*)"
  },
  {
    "label": "__TBB_NATIVE_THREAD_ROUTINE_PTR()",
    "kind": "Method",
    "detail": "Function (namespace internal { # if __TBB_WIN8UI_SUPPORT typedef size_t thread_id_type ; # else typedef DWORD thread_id_type ; # endif } } # else # define __TBB_NATIVE_THREAD_ROUTINE void* # define)",
    "insertText": "__TBB_NATIVE_THREAD_ROUTINE_PTR(r) void* (*r)( void*)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (namespace internal { typedef pthread_t thread_id_type ; } } # endif # include \" atomic . h \" # include \" internal / _tbb_hash_compare_impl . h \" # include \" tick_count . h \" # include __TBB_STD_SWAP_HEADER # include<iosfwd> namespace tbb { namespace internal { class tbb_thread_v3 ; } void)",
    "insertText": "swap(internal::tbb_thread_v3& t1, internal::tbb_thread_v3& t2 ) __TBB_NOEXCEPT(true)"
  },
  {
    "label": "allocate_closure_v3()",
    "kind": "Method",
    "detail": "Function (namespace internal { void* __TBB_EXPORTED_FUNC)",
    "insertText": "allocate_closure_v3(size_t size)"
  },
  {
    "label": "free_closure_v3()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "free_closure_v3(void*)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (struct thread_closure_base { void* operator)",
    "insertText": "new(size_t size)"
  },
  {
    "label": "delete()",
    "kind": "Method",
    "detail": "Function (} void operator)",
    "insertText": "delete(void* ptr)"
  },
  {
    "label": "free_closure_v3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "free_closure_v3(ptr)"
  },
  {
    "label": "start_routine()",
    "kind": "Method",
    "detail": "Function (} } ; template<class F> struct thread_closure_0 : thread_closure_base { F function ; __TBB_NATIVE_THREAD_ROUTINE)",
    "insertText": "start_routine(void* c)"
  },
  {
    "label": "thread_closure_0()",
    "kind": "Method",
    "detail": "Function (thread_closure_0* self = static_cast<)",
    "insertText": "thread_closure_0(c)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (self ->)",
    "insertText": "function()"
  },
  {
    "label": "thread_closure_0()",
    "kind": "Method",
    "detail": "Function (delete self ; return 0 ; })",
    "insertText": "thread_closure_0(const F& f ) : function(f)"
  },
  {
    "label": "thread_closure_1()",
    "kind": "Method",
    "detail": "Function (thread_closure_1* self = static_cast<)",
    "insertText": "thread_closure_1(c)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (self ->)",
    "insertText": "function(self->arg1)"
  },
  {
    "label": "thread_closure_1()",
    "kind": "Method",
    "detail": "Function (delete self ; return 0 ; })",
    "insertText": "thread_closure_1(const F& f, const X& x ) : function(f), arg1(x)"
  },
  {
    "label": "thread_closure_2()",
    "kind": "Method",
    "detail": "Function (thread_closure_2* self = static_cast<)",
    "insertText": "thread_closure_2(c)"
  },
  {
    "label": "function()",
    "kind": "Method",
    "detail": "Function (self ->)",
    "insertText": "function(self->arg1, self->arg2)"
  },
  {
    "label": "thread_closure_2()",
    "kind": "Method",
    "detail": "Function (delete self ; return 0 ; })",
    "insertText": "thread_closure_2(const F& f, const X& x, const Y& y ) : function(f), arg1(x), arg2(y)"
  },
  {
    "label": "tbb_thread_v3()",
    "kind": "Method",
    "detail": "Function (} } ; class tbb_thread_v3 { # if __TBB_IF_NO_COPY_CTOR_MOVE_SEMANTICS_BROKEN public : # endif)",
    "insertText": "tbb_thread_v3(const tbb_thread_v3&)"
  },
  {
    "label": "tbb_thread_v3()",
    "kind": "Method",
    "detail": "Function (public : # if _WIN32 | | _WIN64 typedef HANDLE native_handle_type ; # else typedef pthread_t native_handle_type ; # endif class id ;)",
    "insertText": "tbb_thread_v3() __TBB_NOEXCEPT(true) : my_handle(0) #if _WIN32||_WIN64 , my_thread_id(0)"
  },
  {
    "label": "tbb_thread_v3()",
    "kind": "Method",
    "detail": "Function (} template<class F>)",
    "insertText": "tbb_thread_v3(F f)"
  },
  {
    "label": "internal_start()",
    "kind": "Method",
    "detail": "Function (typedef internal::thread_closure_0<F> closure_type ;)",
    "insertText": "internal_start(closure_type::start_routine, new closure_type(f))"
  },
  {
    "label": "tbb_thread_v3()",
    "kind": "Method",
    "detail": "Function (} template<class F,class X>)",
    "insertText": "tbb_thread_v3(F f, X x)"
  },
  {
    "label": "internal_start()",
    "kind": "Method",
    "detail": "Function (typedef internal::thread_closure_1<F,X> closure_type ;)",
    "insertText": "internal_start(closure_type::start_routine, new closure_type(f,x))"
  },
  {
    "label": "tbb_thread_v3()",
    "kind": "Method",
    "detail": "Function (} template<class F,class X,class Y>)",
    "insertText": "tbb_thread_v3(F f, X x, Y y)"
  },
  {
    "label": "internal_start()",
    "kind": "Method",
    "detail": "Function (typedef internal::thread_closure_2<F,X,Y> closure_type ;)",
    "insertText": "internal_start(closure_type::start_routine, new closure_type(f,x,y))"
  },
  {
    "label": "tbb_thread_v3()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_CPP11_RVALUE_REF_PRESENT)",
    "insertText": "tbb_thread_v3(tbb_thread_v3&& x) __TBB_NOEXCEPT(true) : my_handle(x.my_handle) #if _WIN32||_WIN64 , my_thread_id(x.my_thread_id)"
  },
  {
    "label": "internal_wipe()",
    "kind": "Method",
    "detail": "Function (x .)",
    "insertText": "internal_wipe()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} tbb_thread_v3&)",
    "insertText": "operator(tbb_thread_v3&& x) __TBB_NOEXCEPT(true)"
  },
  {
    "label": "internal_move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "internal_move(x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (public : # else tbb_thread_v3&)",
    "insertText": "operator(tbb_thread_v3& x)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(*this, t)"
  },
  {
    "label": "joinable()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "joinable() const __TBB_NOEXCEPT(true)"
  },
  {
    "label": "detach()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_METHOD)",
    "insertText": "detach()"
  },
  {
    "label": "tbb_thread_v3()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "tbb_thread_v3()"
  },
  {
    "label": "get_id()",
    "kind": "Method",
    "detail": "Function (} id)",
    "insertText": "get_id() const __TBB_NOEXCEPT(true)"
  },
  {
    "label": "native_handle()",
    "kind": "Method",
    "detail": "Function (native_handle_type)",
    "insertText": "native_handle()"
  },
  {
    "label": "internal_wipe()",
    "kind": "Method",
    "detail": "Function (private : native_handle_type my_handle ; # if _WIN32 | | _WIN64 thread_id_type my_thread_id ; # endif void)",
    "insertText": "internal_wipe() __TBB_NOEXCEPT(true)"
  },
  {
    "label": "internal_move()",
    "kind": "Method",
    "detail": "Function (my_handle = 0 ; # if _WIN32 | | _WIN64 my_thread_id = 0 ; # endif } void)",
    "insertText": "internal_move(tbb_thread_v3& x) __TBB_NOEXCEPT(true)"
  },
  {
    "label": "internal_start()",
    "kind": "Method",
    "detail": "Function (} void __TBB_EXPORTED_METHOD)",
    "insertText": "internal_start(__TBB_NATIVE_THREAD_ROUTINE_PTR(start_routine), void* closure)"
  },
  {
    "label": "move_v3()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "move_v3(tbb_thread_v3& t1, tbb_thread_v3& t2)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(tbb_thread_v3& t1, tbb_thread_v3& t2 ) __TBB_NOEXCEPT(true)"
  },
  {
    "label": "id()",
    "kind": "Method",
    "detail": "Function (} ; class tbb_thread_v3::id { thread_id_type my_id ;)",
    "insertText": "id(thread_id_type id_ ) : my_id(id_)"
  },
  {
    "label": "id()",
    "kind": "Method",
    "detail": "Function (} class tbb_thread_v3 ; public :)",
    "insertText": "id() __TBB_NOEXCEPT(true) : my_id(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(tbb_thread_v3::id x, tbb_thread_v3::id y ) __TBB_NOEXCEPT(true)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class charT,class traits> std::basic_ostream<charT,traits>&)",
    "insertText": "operator(std::basic_ostream<charT, traits> &out, tbb_thread_v3::id id)"
  },
  {
    "label": "thread_get_id_v3()",
    "kind": "Method",
    "detail": "Function (out<<id . my_id ; return out ; } tbb_thread_v3::id __TBB_EXPORTED_FUNC)",
    "insertText": "thread_get_id_v3()"
  },
  {
    "label": "tbb_hasher()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "tbb_hasher(const tbb_thread_v3::id& id)"
  },
  {
    "label": "__TBB_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBB_STATIC_ASSERT(sizeof(id.my_id) <= sizeof(size_t), \"Implementation assumes that thread_id_type fits into machine word\")"
  },
  {
    "label": "atomic_compare_and_swap()",
    "kind": "Method",
    "detail": "Function (} id)",
    "insertText": "atomic_compare_and_swap(id& location, const id& value, const id& comparand)"
  },
  {
    "label": "id()",
    "kind": "Method",
    "detail": "Function (# if _WIN32 | | _WIN64 return)",
    "insertText": "id(my_thread_id)"
  },
  {
    "label": "id()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "id(my_handle)"
  },
  {
    "label": "thread_yield_v3()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "thread_yield_v3()"
  },
  {
    "label": "thread_sleep_v3()",
    "kind": "Method",
    "detail": "Function (void __TBB_EXPORTED_FUNC)",
    "insertText": "thread_sleep_v3(const tick_count::interval_t &i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(tbb_thread_v3::id x, tbb_thread_v3::id y) __TBB_NOEXCEPT(true)"
  },
  {
    "label": "move_v3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "move_v3(t1, t2)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(t1.my_handle, t2.my_handle)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (# if _WIN32 | | _WIN64)",
    "insertText": "swap(t1.my_thread_id, t2.my_thread_id)"
  },
  {
    "label": "get_id()",
    "kind": "Method",
    "detail": "Function (# endif } namespace this_tbb_thread { tbb_thread::id)",
    "insertText": "get_id()"
  },
  {
    "label": "yield()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "yield()"
  },
  {
    "label": "sleep()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "sleep(const tick_count::interval_t &i)"
  },
  {
    "label": "thread_sleep_v3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "thread_sleep_v3(i)"
  }
]