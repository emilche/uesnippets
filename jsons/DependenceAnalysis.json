[
  {
    "label": "AliasAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AliasAnalysis"
  },
  {
    "label": "Loop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Loop"
  },
  {
    "label": "LoopInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoopInfo"
  },
  {
    "label": "ScalarEvolution",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScalarEvolution"
  },
  {
    "label": "SCEV",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SCEV"
  },
  {
    "label": "SCEVConstant",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SCEVConstant"
  },
  {
    "label": "raw_ostream",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "raw_ostream"
  },
  {
    "label": "represents",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "represents"
  },
  {
    "label": "Dependence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Dependence"
  },
  {
    "label": "DVEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DVEntry"
  },
  {
    "label": "DependenceAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DependenceAnalysis"
  },
  {
    "label": "represents",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "represents"
  },
  {
    "label": "FullDependence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FullDependence"
  },
  {
    "label": "DependenceAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DependenceAnalysis"
  },
  {
    "label": "is",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "is"
  },
  {
    "label": "DependenceAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DependenceAnalysis"
  },
  {
    "label": "represents",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "represents"
  },
  {
    "label": "Subscript",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Subscript"
  },
  {
    "label": "ClassificationKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ClassificationKind"
  },
  {
    "label": "CoefficientInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CoefficientInfo"
  },
  {
    "label": "BoundInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "BoundInfo"
  },
  {
    "label": "represents",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "represents"
  },
  {
    "label": "Constraint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Constraint"
  },
  {
    "label": "ConstraintKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ConstraintKind"
  },
  {
    "label": "DependenceAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DependenceAnalysis"
  },
  {
    "label": "isInput()",
    "kind": "Method",
    "detail": "Function (return)",
    "insertText": "isInput()"
  },
  {
    "label": "FullDependence()",
    "kind": "Method",
    "detail": "Function (public:)",
    "insertText": "FullDependence(Instruction *Src, Instruction *Dst, bool LoopIndependent,\n                   unsigned Levels)"
  },
  {
    "label": "depends()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<Dependence>)",
    "insertText": "depends(Instruction *Src,\n                                        Instruction *Dst,\n                                        bool PossiblyLoopIndependent)"
  },
  {
    "label": "setPoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setPoint(const SCEV *X, const SCEV *Y, const Loop *CurrentLoop)"
  },
  {
    "label": "setLine()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setLine(const SCEV *A, const SCEV *B,\n                   const SCEV *C, const Loop *CurrentLoop)"
  },
  {
    "label": "setDistance()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setDistance(const SCEV *D, const Loop *CurrentLoop)"
  },
  {
    "label": "setEmpty()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setEmpty()"
  },
  {
    "label": "setAny()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setAny(ScalarEvolution *SE)"
  },
  {
    "label": "establishNestingLevels()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "establishNestingLevels(const Instruction *Src,\n                                const Instruction *Dst)"
  },
  {
    "label": "unifySubscriptType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unifySubscriptType(ArrayRef<Subscript *> Pairs)"
  },
  {
    "label": "removeMatchingExtensions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "removeMatchingExtensions(Subscript *Pair)"
  },
  {
    "label": "checkSrcSubscript()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "checkSrcSubscript(const SCEV *Src,\n                           const Loop *LoopNest,\n                           SmallBitVector &Loops)"
  },
  {
    "label": "checkDstSubscript()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "checkDstSubscript(const SCEV *Dst,\n                           const Loop *LoopNest,\n                           SmallBitVector &Loops)"
  },
  {
    "label": "classifyPair()",
    "kind": "Method",
    "detail": "Function (Subscript::ClassificationKind)",
    "insertText": "classifyPair(const SCEV *Src,\n                                           const Loop *SrcLoopNest,\n                                           const SCEV *Dst,\n                                           const Loop *DstLoopNest,\n                                           SmallBitVector &Loops)"
  },
  {
    "label": "intersectConstraints()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "intersectConstraints(Constraint *X,\n                              const Constraint *Y)"
  },
  {
    "label": "propagate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "propagate(const SCEV *&Src,\n                   const SCEV *&Dst,\n                   SmallBitVector &Loops,\n                   SmallVectorImpl<Constraint> &Constraints,\n                   bool &Consistent)"
  },
  {
    "label": "propagateDistance()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "propagateDistance(const SCEV *&Src,\n                           const SCEV *&Dst,\n                           Constraint &CurConstraint,\n                           bool &Consistent)"
  },
  {
    "label": "propagatePoint()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "propagatePoint(const SCEV *&Src,\n                        const SCEV *&Dst,\n                        Constraint &CurConstraint)"
  },
  {
    "label": "propagateLine()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "propagateLine(const SCEV *&Src,\n                       const SCEV *&Dst,\n                       Constraint &CurConstraint,\n                       bool &Consistent)"
  },
  {
    "label": "tryDelinearize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "tryDelinearize(const SCEV *SrcSCEV, const SCEV *DstSCEV,\n                        SmallVectorImpl<Subscript> &Pair,\n                        const SCEV *ElementSize)"
  }
]