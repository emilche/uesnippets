[
  {
    "label": "EClassFlagMatchType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EClassFlagMatchType"
  },
  {
    "label": "FClassTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FClassTree"
  },
  {
    "label": "FScopedRecurseDepthCounter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FScopedRecurseDepthCounter"
  },
  {
    "label": "Comparator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Comparator"
  },
  {
    "label": "AddChildClass()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / Object . h \" # include \" UObject / Class . h \" # include \" Containers / List . h \" # include \" UObject / UObjectHash . h \" # include \" UObject / UObjectIterator . h \" enum EClassFlagMatchType { MATCH_Any,MATCH_All,} ; class FClassTree { UClass* Class ; FClassTree* Parent ; TArray<FClassTree*> Children ; TDoubleLinkedList<UObject*> Instances ; bool)",
    "insertText": "AddChildClass(UClass* ChildClass)"
  },
  {
    "label": "ReplaceChild()",
    "kind": "Method",
    "detail": "Function (Parent ->)",
    "insertText": "ReplaceChild(ChildClass,this)"
  },
  {
    "label": "FClassTree()",
    "kind": "Method",
    "detail": "Function (} FClassTree* NewChild = new)",
    "insertText": "FClassTree(ChildClass)"
  },
  {
    "label": "AddChildNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddChildNode(NewChild)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (NewChild -> Parent = this ; int32 i = Children .)",
    "insertText": "Find(NewChild)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FClassTree* Child = Children [ i ] ;)",
    "insertText": "if(FCString::Stricmp(*Child->GetClass()->GetName(), *NewChild->GetClass()->GetName()) >= 0)"
  },
  {
    "label": "InsertUninitialized()",
    "kind": "Method",
    "detail": "Function (break ; } } Children .)",
    "insertText": "InsertUninitialized(i)"
  },
  {
    "label": "ReplaceChild()",
    "kind": "Method",
    "detail": "Function (Children [ i ] = NewChild ; } return i ; } void)",
    "insertText": "ReplaceChild(UClass* NewChild, FClassTree* CurrentChild)"
  },
  {
    "label": "FClassTree()",
    "kind": "Method",
    "detail": "Function (FClassTree* NewChildNode = new)",
    "insertText": "FClassTree(NewChild)"
  },
  {
    "label": "Find()",
    "kind": "Method",
    "detail": "Function (int32 OldIndex = Children .)",
    "insertText": "Find(CurrentChild)"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "RemoveAt(OldIndex)"
  },
  {
    "label": "GetClass()",
    "kind": "Method",
    "detail": "Function (FClassTree* ChildNode = Children [ ChildIndex ] ; UClass* ChildClass = ChildNode ->)",
    "insertText": "GetClass()"
  },
  {
    "label": "RemoveAt()",
    "kind": "Method",
    "detail": "Function (Children .)",
    "insertText": "RemoveAt(ChildIndex)"
  },
  {
    "label": "AddChildNode()",
    "kind": "Method",
    "detail": "Function (NewChildNode ->)",
    "insertText": "AddChildNode(ChildNode)"
  },
  {
    "label": "AddChildNode()",
    "kind": "Method",
    "detail": "Function (} } int32 NewIndex =)",
    "insertText": "AddChildNode(NewChildNode)"
  },
  {
    "label": "AddChildNode()",
    "kind": "Method",
    "detail": "Function (Children [ NewIndex ] ->)",
    "insertText": "AddChildNode(CurrentChild)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (} FClassTree*)",
    "insertText": "GetNode(UClass* SearchClass, bool bBruteForce)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (FClassTree*)",
    "insertText": "Result(NULL)"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (Result = Children [ i ] ->)",
    "insertText": "GetNode(SearchClass,bBruteForce)"
  },
  {
    "label": "FindChildIndex()",
    "kind": "Method",
    "detail": "Function (} } return Result ; } int32)",
    "insertText": "FindChildIndex(UClass* SearchClass)"
  },
  {
    "label": "PopulateTree()",
    "kind": "Method",
    "detail": "Function (} return INDEX_NONE ; } public : void)",
    "insertText": "PopulateTree()"
  },
  {
    "label": "GetRootNode()",
    "kind": "Method",
    "detail": "Function (FClassTree* RootNode =)",
    "insertText": "GetRootNode()"
  },
  {
    "label": "AddClass()",
    "kind": "Method",
    "detail": "Function (RootNode ->)",
    "insertText": "AddClass(*It)"
  },
  {
    "label": "AddClass()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "AddClass(UClass* ChildClass)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FClassTree* ReceivingNode ;)",
    "insertText": "for(ReceivingNode = this; ReceivingNode->Parent != NULL; ReceivingNode = ReceivingNode->Parent)"
  },
  {
    "label": "FScopedRecurseDepthCounter()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FScopedRecurseDepthCounter()"
  },
  {
    "label": "GetChildClasses()",
    "kind": "Method",
    "detail": "Function (} } ; public : void)",
    "insertText": "GetChildClasses(TArray<FClassTree*>& ChildClasses, bool bRecurse=false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int32 RecurseDepth = 0 ;)",
    "insertText": "if(RecurseDepth == 0)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (ChildClasses .)",
    "insertText": "Empty()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 i = 0; i < Children.Num(); i++)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ChildClasses .)",
    "insertText": "Add(Children[i])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bRecurse)"
  },
  {
    "label": "Counter()",
    "kind": "Method",
    "detail": "Function (FScopedRecurseDepthCounter)",
    "insertText": "Counter(&RecurseDepth)"
  },
  {
    "label": "GetChildClasses()",
    "kind": "Method",
    "detail": "Function (Children [ i ] ->)",
    "insertText": "GetChildClasses(ChildClasses, bRecurse)"
  },
  {
    "label": "GetChildClasses()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "GetChildClasses(TArray<const FClassTree*>& ChildClasses, bool bRecurse=false)"
  },
  {
    "label": "GetChildClasses()",
    "kind": "Method",
    "detail": "Function (} } } template<class Comparator> void)",
    "insertText": "GetChildClasses(TArray<UClass*>& ChildClasses, const Comparator& Mask, bool bRecurse=false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FClassTree* ChildNode = Children [ i ] ;)",
    "insertText": "if(Mask(ChildNode->GetClass()))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ChildClasses .)",
    "insertText": "Add(ChildNode->GetClass())"
  },
  {
    "label": "GetChildClasses()",
    "kind": "Method",
    "detail": "Function (ChildNode ->)",
    "insertText": "GetChildClasses(ChildClasses, Mask, bRecurse)"
  },
  {
    "label": "GenerateMaskedClassTree()",
    "kind": "Method",
    "detail": "Function (} } } template<class Comparator> FClassTree*)",
    "insertText": "GenerateMaskedClassTree(const Comparator& Mask)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FClassTree* ResultTree = NULL ;)",
    "insertText": "if(Mask.IsValidClass(this))"
  },
  {
    "label": "FClassTree()",
    "kind": "Method",
    "detail": "Function (ResultTree = new)",
    "insertText": "FClassTree(Class)"
  },
  {
    "label": "GenerateMaskedClassTree()",
    "kind": "Method",
    "detail": "Function (FClassTree* ChildNode = Children [ ChildIndex ] ->)",
    "insertText": "GenerateMaskedClassTree(Mask)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ChildNode -> Parent = ResultTree ; ResultTree -> Children .)",
    "insertText": "Add(ChildNode)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FClassTree* RootNode ;)",
    "insertText": "for(RootNode = this; RootNode->Parent != NULL; RootNode = RootNode->Parent)"
  },
  {
    "label": "FindNode()",
    "kind": "Method",
    "detail": "Function (} const FClassTree*)",
    "insertText": "FindNode(UClass* SearchClass)"
  },
  {
    "label": "ChangeParentClass()",
    "kind": "Method",
    "detail": "Function (} return NULL ; } bool)",
    "insertText": "ChangeParentClass(UClass* SearchClass, UClass* InNewParentClass=NULL)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(SearchClass)"
  },
  {
    "label": "GetSuperClass()",
    "kind": "Method",
    "detail": "Function (UClass* NewParentClass = InNewParentClass ? InNewParentClass : SearchClass ->)",
    "insertText": "GetSuperClass()"
  },
  {
    "label": "GetNode()",
    "kind": "Method",
    "detail": "Function (FClassTree* NewParentNode =)",
    "insertText": "GetNode(NewParentClass)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "check(NewParentNode)"
  },
  {
    "label": "RemoveSingle()",
    "kind": "Method",
    "detail": "Function (ClassNode -> Parent -> Children .)",
    "insertText": "RemoveSingle(ClassNode)"
  },
  {
    "label": "AddChildNode()",
    "kind": "Method",
    "detail": "Function (} return NewParentNode ->)",
    "insertText": "AddChildNode(ClassNode)"
  },
  {
    "label": "AddClass()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "AddClass(SearchClass)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Num()"
  },
  {
    "label": "Validate()",
    "kind": "Method",
    "detail": "Function (} return Count ; } void)",
    "insertText": "Validate()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Parent->GetClass() == UObject::StaticClass())"
  },
  {
    "label": "GetChildClasses()",
    "kind": "Method",
    "detail": "Function (TArray<const FClassTree*> ChildClasses ; Parent ->)",
    "insertText": "GetChildClasses(ChildClasses)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "check(Class->GetSuperClass() == Parent->GetClass())"
  },
  {
    "label": "FClassTree()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "FClassTree(UClass* BaseClass ) : Class(BaseClass), Parent(NULL)"
  },
  {
    "label": "FClassTree()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FClassTree()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FClassTree* p = Children [ i ] ;)",
    "insertText": "if(p != NULL)"
  },
  {
    "label": "DumpClassTree()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DumpClassTree(int32 IndentCount, FOutputDevice& Ar)"
  },
  {
    "label": "Logf()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Logf(TEXT(\"%s%s\"), FCString::Spc(IndentCount), *Class->GetName())"
  },
  {
    "label": "DumpClassTree()",
    "kind": "Method",
    "detail": "Function (FClassTree* ChildNode = Children [ ChildIndex ] ; ChildNode ->)",
    "insertText": "DumpClassTree(IndentCount + 2, Ar)"
  },
  {
    "label": "NumChildren()",
    "kind": "Method",
    "detail": "Function (} } int32)",
    "insertText": "NumChildren()"
  },
  {
    "label": "GetChild()",
    "kind": "Method",
    "detail": "Function (} const FClassTree*)",
    "insertText": "GetChild(int32 Index)"
  }
]