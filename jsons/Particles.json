[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TPBDRigidsEvolution",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TPBDRigidsEvolution"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "TParticles",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TParticles"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / ArrayCollection . h \" # include \" Chaos / ArrayCollectionArray . h \" # include \" Chaos / Core . h \" # include \" Chaos / Particle / ObjectState . h \" # include \" Chaos / Vector . h \" # include \" ChaosArchive . h \" # include \" HAL / LowLevelMemTracker . h \" #)",
    "insertText": "if(UE_BUILD_SHIPPING || UE_BUILD_TEST)"
  },
  {
    "label": "TParticles()",
    "kind": "Method",
    "detail": "Function (template<class T,int d> class TPBDRigidsEvolution ; enum class ERemoveParticleBehavior : uint8 { RemoveAtSwap,Remove } ; template<class T,int d> class TParticles : public TArrayCollection { public :)",
    "insertText": "TParticles() : MRemoveParticleBehavior(ERemoveParticleBehavior::RemoveAtSwap)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MX)"
  },
  {
    "label": "TParticles()",
    "kind": "Method",
    "detail": "Function (# if PARTICLE_ITERATOR_RANGED_FOR_CHECK MDirtyValidationCount = 0 ; # endif })",
    "insertText": "TParticles(const TParticles<T, d>& Other)"
  },
  {
    "label": "TParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TParticles(TParticles<T, d>&& Other) : TArrayCollection(), MX(MoveTemp(Other.MX)) , MRemoveParticleBehavior(Other.MRemoveParticleBehavior)"
  },
  {
    "label": "AddParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddParticles(Other.Size())"
  },
  {
    "label": "TParticles()",
    "kind": "Method",
    "detail": "Function (Other . MSize = 0 ; # if PARTICLE_ITERATOR_RANGED_FOR_CHECK MDirtyValidationCount = 0 ; # endif })",
    "insertText": "TParticles(TArray<TVector<T, d>>&& Positions) : TArrayCollection(), MX(MoveTemp(Positions)) , MRemoveParticleBehavior(ERemoveParticleBehavior::RemoveAtSwap)"
  },
  {
    "label": "AddParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddParticles(MX.Num())"
  },
  {
    "label": "TParticles()",
    "kind": "Method",
    "detail": "Function (# if PARTICLE_ITERATOR_RANGED_FOR_CHECK MDirtyValidationCount = 0 ; # endif } ~)",
    "insertText": "TParticles()"
  },
  {
    "label": "AddParticles()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddParticles(const int32 Num)"
  },
  {
    "label": "AddElementsHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElementsHelper(Num)"
  },
  {
    "label": "IncrementDirtyValidation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IncrementDirtyValidation()"
  },
  {
    "label": "DestroyParticle()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DestroyParticle(const int32 Idx)"
  },
  {
    "label": "RemoveAtSwapHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAtSwapHelper(Idx)"
  },
  {
    "label": "RemoveAtHelper()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "RemoveAtHelper(Idx, 1)"
  },
  {
    "label": "RemoveParticleBehavior()",
    "kind": "Method",
    "detail": "Function (} ERemoveParticleBehavior)",
    "insertText": "RemoveParticleBehavior()"
  },
  {
    "label": "MoveToOtherArrayCollection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MoveToOtherArrayCollection(Idx, Other)"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Resize(const int32 Num)"
  },
  {
    "label": "ResizeHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeHelper(Num)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TParticles&)",
    "insertText": "operator(TParticles<T, d>&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MX =)",
    "insertText": "MoveTemp(Other.MX)"
  },
  {
    "label": "ResizeHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeHelper(Other.Size())"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (Other . MSize = 0 ; # if PARTICLE_ITERATOR_RANGED_FOR_CHECK MDirtyValidationCount = 0 ; + + Other . MDirtyValidationCount ; # endif return* this ; } const TArrayCollectionArray<TVector<T,d>>&)",
    "insertText": "X()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bSerialize = true ; Ar<<bSerialize ;)",
    "insertText": "if(ensureMsgf(bSerialize, TEXT(\"Cannot serialize shared views. Refactor needed to reduce memory\")))"
  },
  {
    "label": "ResizeHelper()",
    "kind": "Method",
    "detail": "Function (Ar<<MX ;)",
    "insertText": "ResizeHelper(MX.Num())"
  },
  {
    "label": "XArray()",
    "kind": "Method",
    "detail": "Function (} const TArrayCollectionArray<TVector<T,d>>&)",
    "insertText": "XArray()"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (MX [ Index ] = InX ; } FString)",
    "insertText": "ToString(int32 index)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetTypeHash()"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (uint32 OutHash = 0 ; const int32 NumXEntries = MX .)",
    "insertText": "Num()"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (OutHash = UE::)",
    "insertText": "GetTypeHash(MX[0])"
  },
  {
    "label": "HashCombine()",
    "kind": "Method",
    "detail": "Function (OutHash =)",
    "insertText": "HashCombine(OutHash, UE::Math::GetTypeHash(MX[XIndex]))"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} } return OutHash ; } SIZE_T)",
    "insertText": "GetAllocatedSize()"
  },
  {
    "label": "DirtyValidationCount()",
    "kind": "Method",
    "detail": "Function (} # if PARTICLE_ITERATOR_RANGED_FOR_CHECK int32)",
    "insertText": "DirtyValidationCount()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# if PARTICLE_ITERATOR_RANGED_FOR_CHECK + + MDirtyValidationCount ; # endif } FArchive&)",
    "insertText": "operator(FArchive& Ar, TParticles<T, d>& InParticles)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (InParticles .)",
    "insertText": "Serialize(Ar)"
  }
]