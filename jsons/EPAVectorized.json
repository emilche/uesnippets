[
  {
    "label": "VectorTEPAEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VectorTEPAEntry"
  },
  {
    "label": "VectorMinkowskiVert()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" # include \" Chaos / SimplexVectorized . h \" # include \" Chaos / EPA . h \" # include<queue> # include \" ChaosCheck . h \" # include \" ChaosLog . h \" # include \" Templates / Function . h \" # include \" Math / VectorRegister . h \" namespace Chaos { const VectorRegister4Float)",
    "insertText": "VectorMinkowskiVert(const VectorRegister4Float* VertsABuffer, const VectorRegister4Float* VertsBBuffer, const int32 Idx)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} struct VectorTEPAEntry { VectorRegister4Float PlaneNormal ; VectorRegister4Float Distance ; int32 IdxBuffer [ 3 ] ; TVector<int32,3> AdjFaces ; TVector<int32,3> AdjEdges ; bool bObsolete ; bool)",
    "insertText": "operator(const VectorTEPAEntry& Other)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Initialize(const VectorRegister4Float* VerticesA, const VectorRegister4Float* VerticesB, int32 InIdx0, int32 InIdx1, int32 InIdx2, const TVector<int32, 3>& InAdjFaces, const TVector<int32, 3>& InAdjEdges)"
  },
  {
    "label": "VectorMinkowskiVert()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float V0 =)",
    "insertText": "VectorMinkowskiVert(VerticesA, VerticesB, InIdx0)"
  },
  {
    "label": "VectorMinkowskiVert()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float V1 =)",
    "insertText": "VectorMinkowskiVert(VerticesA, VerticesB, InIdx1)"
  },
  {
    "label": "VectorMinkowskiVert()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float V2 =)",
    "insertText": "VectorMinkowskiVert(VerticesA, VerticesB, InIdx2)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float V0V1 =)",
    "insertText": "VectorSubtract(V1, V0)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float V0V2 =)",
    "insertText": "VectorSubtract(V2, V0)"
  },
  {
    "label": "VectorCross()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Norm =)",
    "insertText": "VectorCross(V0V1, V0V2)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float NormLenSq =)",
    "insertText": "VectorDot3(Norm, Norm)"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Eps =)",
    "insertText": "MakeVectorRegisterFloatConstant(1e-4f, 1e-4f, 1e-4f, 1e-4f)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float EpsGTNormLenSq =)",
    "insertText": "VectorCompareGT(Eps, NormLenSq)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (IdxBuffer [ 0 ] = InIdx0 ; IdxBuffer [ 1 ] = InIdx1 ; IdxBuffer [ 2 ] = InIdx2 ; AdjFaces = InAdjFaces ; AdjEdges = InAdjEdges ; Distance =)",
    "insertText": "VectorDot3(PlaneNormal, V0)"
  },
  {
    "label": "SwapWinding()",
    "kind": "Method",
    "detail": "Function (bObsolete = false ; return true ; } void)",
    "insertText": "SwapWinding(VectorTEPAEntry* Entries)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(IdxBuffer[0], IdxBuffer[1])"
  },
  {
    "label": "this()",
    "kind": "Method",
    "detail": "Function (auto UpdateAdjEdge = [ Entries,)",
    "insertText": "this(int32 Old, int32 New)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (VectorTEPAEntry& AdjFace = Entries [ AdjFaces [ Old ] ] ; int32& StaleAdjIdx = AdjFace . AdjEdges [ AdjEdges [ Old ] ] ;)",
    "insertText": "check(StaleAdjIdx == Old)"
  },
  {
    "label": "UpdateAdjEdge()",
    "kind": "Method",
    "detail": "Function (StaleAdjIdx = New ; } ;)",
    "insertText": "UpdateAdjEdge(1, 2)"
  },
  {
    "label": "UpdateAdjEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateAdjEdge(2, 1)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(AdjFaces[1], AdjFaces[2])"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(AdjEdges[1], AdjEdges[2])"
  },
  {
    "label": "VectorNegate()",
    "kind": "Method",
    "detail": "Function (PlaneNormal =)",
    "insertText": "VectorNegate(PlaneNormal)"
  },
  {
    "label": "VectorNegate()",
    "kind": "Method",
    "detail": "Function (Distance =)",
    "insertText": "VectorNegate(Distance)"
  },
  {
    "label": "DistanceToPlane()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "DistanceToPlane(const VectorRegister4Float& X)"
  },
  {
    "label": "IsOriginProjectedInside()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsOriginProjectedInside(const VectorRegister4Float* VertsABuffer, const VectorRegister4Float* VertsBBuffer, const VectorRegister4Float Epsilon)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PN =)",
    "insertText": "VectorMultiply(Distance, PlaneNormal)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PA =)",
    "insertText": "VectorSubtract(VectorMinkowskiVert(VertsABuffer, VertsBBuffer, IdxBuffer[0]), PN)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PB =)",
    "insertText": "VectorSubtract(VectorMinkowskiVert(VertsABuffer, VertsBBuffer, IdxBuffer[1]), PN)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PC =)",
    "insertText": "VectorSubtract(VectorMinkowskiVert(VertsABuffer, VertsBBuffer, IdxBuffer[2]), PN)"
  },
  {
    "label": "VectorCross()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PACNormal =)",
    "insertText": "VectorCross(PA, PC)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PACSign =)",
    "insertText": "VectorDot3(PACNormal, PlaneNormal)"
  },
  {
    "label": "VectorCross()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PCBNormal =)",
    "insertText": "VectorCross(PC, PB)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PCBSign =)",
    "insertText": "VectorDot3(PCBNormal, PlaneNormal)"
  },
  {
    "label": "VectorNegate()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float MinusEps =)",
    "insertText": "VectorNegate(Epsilon)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float MinusEpsGTPACSign =)",
    "insertText": "VectorCompareGT(MinusEps, PACSign)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PCBSignGTEps =)",
    "insertText": "VectorCompareGT(PCBSign, Epsilon)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PACSignGTEps =)",
    "insertText": "VectorCompareGT(PACSign, Epsilon)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float MinusEpsGTPCBSign =)",
    "insertText": "VectorCompareGT(MinusEps, PCBSign)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float InterACCB =)",
    "insertText": "VectorBitwiseAnd(MinusEpsGTPACSign, PCBSignGTEps)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float InterCBAC =)",
    "insertText": "VectorBitwiseAnd(PACSignGTEps, MinusEpsGTPCBSign)"
  },
  {
    "label": "VectorBitwiseOr()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float IsFalse1 =)",
    "insertText": "VectorBitwiseOr(InterACCB, InterCBAC)"
  },
  {
    "label": "VectorCross()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PBANormal =)",
    "insertText": "VectorCross(PB, PA)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PBASign =)",
    "insertText": "VectorDot3(PBANormal, PlaneNormal)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float PBASignGTEps =)",
    "insertText": "VectorCompareGT(PBASign, Epsilon)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float MinusEpsGTPBASign =)",
    "insertText": "VectorCompareGT(MinusEps, PBASign)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float InterACBA =)",
    "insertText": "VectorBitwiseAnd(MinusEpsGTPACSign, PBASignGTEps)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float InterBAAC =)",
    "insertText": "VectorBitwiseAnd(PACSignGTEps, MinusEpsGTPBASign)"
  },
  {
    "label": "VectorBitwiseOr()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float IsFalse2 =)",
    "insertText": "VectorBitwiseOr(InterACBA, InterBAAC)"
  },
  {
    "label": "VectorBitwiseOr()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float IsFalse =)",
    "insertText": "VectorBitwiseOr(IsFalse1, IsFalse2)"
  },
  {
    "label": "VectorInitializeEPA()",
    "kind": "Method",
    "detail": "Function (} } ; template<SupportALambda,SupportBLambda> bool)",
    "insertText": "VectorInitializeEPA(TArray<VectorRegister4Float>& VertsA, TArray<VectorRegister4Float>& VertsB, const SupportALambda& SupportA, const SupportBLambda& SupportB, TEPAWorkingArray<VectorTEPAEntry>& OutEntries, VectorRegister4Float& OutTouchNormal)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 NumVerts = VertsA .)",
    "insertText": "Num()"
  },
  {
    "label": "AddFartherPoint()",
    "kind": "Method",
    "detail": "Function (auto)",
    "insertText": "AddFartherPoint(const VectorRegister4Float& Dir)"
  },
  {
    "label": "VectorNegate()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float NegDir =)",
    "insertText": "VectorNegate(Dir)"
  },
  {
    "label": "SupportA()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float A0 =)",
    "insertText": "SupportA(Dir)"
  },
  {
    "label": "SupportA()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float A1 =)",
    "insertText": "SupportA(NegDir)"
  },
  {
    "label": "SupportB()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float B0 =)",
    "insertText": "SupportB(NegDir)"
  },
  {
    "label": "SupportB()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float B1 =)",
    "insertText": "SupportB(Dir)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float W0 =)",
    "insertText": "VectorSubtract(A0, B0)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float W1 =)",
    "insertText": "VectorSubtract(A1, B1)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Dist0 =)",
    "insertText": "VectorDot3(W0, Dir)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Dist1 =)",
    "insertText": "VectorDot3(W1, NegDir)"
  },
  {
    "label": "VectorCompareGE()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float IsDist1GEDist0 =)",
    "insertText": "VectorCompareGE(Dist1, Dist0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsA .)",
    "insertText": "Add(A1)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsB .)",
    "insertText": "Add(B1)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { VertsA .)",
    "insertText": "Add(A0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsB .)",
    "insertText": "Add(B0)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (} } ; OutEntries .)",
    "insertText": "AddUninitialized(4)"
  },
  {
    "label": "MakeVectorRegisterFloat()",
    "kind": "Method",
    "detail": "Function (OutTouchNormal =)",
    "insertText": "MakeVectorRegisterFloat(0.0f, 0.0f, 1.0f, 0.0f)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (bool bValid = false ;)",
    "insertText": "switch(NumVerts)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (} case 2 : { const VectorRegister4Float Dir =)",
    "insertText": "VectorSubtract(VectorMinkowskiVert(VertsA.GetData(), VertsB.GetData(), 1), VectorMinkowskiVert(VertsA.GetData(), VertsB.GetData(), 0))"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Valid =)",
    "insertText": "VectorCompareGT(VectorDot3(Dir, Dir), Eps)"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float DirAbs =)",
    "insertText": "VectorAbs(Dir)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float DirAbs0 =)",
    "insertText": "VectorSwizzle(DirAbs, 0, 0, 0, 0)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float DirAbs1 =)",
    "insertText": "VectorSwizzle(DirAbs, 1, 1, 1, 1)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float DirAbs2 =)",
    "insertText": "VectorSwizzle(DirAbs, 2, 2, 2, 2)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Dir0GTDir1 =)",
    "insertText": "VectorCompareGT(DirAbs0, DirAbs1)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Dir0GTDir2 =)",
    "insertText": "VectorCompareGT(DirAbs0, DirAbs2)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Dir1GTDir2 =)",
    "insertText": "VectorCompareGT(DirAbs1, DirAbs2)"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Axis1 =)",
    "insertText": "MakeVectorRegisterFloatConstant(0.0f, 1.0f, 0.0f, 0.0f)"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Axis2 =)",
    "insertText": "MakeVectorRegisterFloatConstant(0.0f, 0.0f, 1.0f, 0.0f)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Axis01 =)",
    "insertText": "VectorSelect(Dir0GTDir1, Axis1, GlobalVectorConstants::Float1000)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Axis02 =)",
    "insertText": "VectorSelect(Dir0GTDir2, Axis2, GlobalVectorConstants::Float1000)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float OtherAxis =)",
    "insertText": "VectorSelect(Dir1GTDir2, Axis02, Axis01)"
  },
  {
    "label": "VectorCross()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Orthog =)",
    "insertText": "VectorCross(Dir, OtherAxis)"
  },
  {
    "label": "VectorCross()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Orthog2 =)",
    "insertText": "VectorCross(Orthog, Dir)"
  },
  {
    "label": "AddFartherPoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddFartherPoint(Orthog)"
  },
  {
    "label": "AddFartherPoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddFartherPoint(Orthog2)"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (bValid = OutEntries [ 0 ] .)",
    "insertText": "Initialize(VertsA.GetData(), VertsB.GetData(), 1, 2, 3, { 3,1,2 }, { 1,1,1 })"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (bValid& = OutEntries [ 1 ] .)",
    "insertText": "Initialize(VertsA.GetData(), VertsB.GetData(), 0, 3, 2, { 2,0,3 }, { 2,1,0 })"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (bValid& = OutEntries [ 2 ] .)",
    "insertText": "Initialize(VertsA.GetData(), VertsB.GetData(), 0, 1, 3, { 3,0,1 }, { 2,2,0 })"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (bValid& = OutEntries [ 3 ] .)",
    "insertText": "Initialize(VertsA.GetData(), VertsB.GetData(), 0, 2, 1, { 1,0,2 }, { 2,0,0 })"
  },
  {
    "label": "VectorNormalizeAccurate()",
    "kind": "Method",
    "detail": "Function (OutTouchNormal =)",
    "insertText": "VectorNormalizeAccurate(Orthog)"
  },
  {
    "label": "AddFartherPoint()",
    "kind": "Method",
    "detail": "Function (const VectorTEPAEntry& Base = OutEntries [ 3 ] ;)",
    "insertText": "AddFartherPoint(Base.PlaneNormal)"
  },
  {
    "label": "CHAOS_ENSURE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CHAOS_ENSURE(false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; } })",
    "insertText": "if(bValid)"
  },
  {
    "label": "VectorZero()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float MaxSignedDistance =)",
    "insertText": "VectorZero()"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float AbsDistance =)",
    "insertText": "VectorAbs(Entry.Distance)"
  },
  {
    "label": "VectorAbs()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float AbsMaxSignedDistance =)",
    "insertText": "VectorAbs(MaxSignedDistance)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float AbsDistGTMax =)",
    "insertText": "VectorCompareGT(AbsDistance, AbsMaxSignedDistance)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (MaxSignedDistance =)",
    "insertText": "VectorSelect(AbsDistGTMax, Entry.Distance, MaxSignedDistance)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float MaxSignedDistanceNeg =)",
    "insertText": "VectorCompareGT(VectorZero(), MaxSignedDistance)"
  },
  {
    "label": "SwapWinding()",
    "kind": "Method",
    "detail": "Function (Entry .)",
    "insertText": "SwapWinding(OutEntries.GetData())"
  },
  {
    "label": "VectorEPAComputeVisibilityBorder()",
    "kind": "Method",
    "detail": "Function (} } } return bValid ; } void)",
    "insertText": "VectorEPAComputeVisibilityBorder(TEPAWorkingArray<VectorTEPAEntry>& Entries, int32 EntryIdx, const VectorRegister4Float& W, TEPAWorkingArray<FEPAFloodEntry>& OutBorderEdges, TEPAWorkingArray<FEPAFloodEntry>& ToVisitStack)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({ VectorTEPAEntry& Entry = Entries [ EntryIdx ] ;)",
    "insertText": "for(int i = 0; i < 3; ++i)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ToVisitStack .)",
    "insertText": "Add({ Entry.AdjFaces[i], Entry.AdjEdges[i] })"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} } int32 Iteration = 0 ; const int32 MaxIteration = 1 0 0 0 0 ;)",
    "insertText": "while(ToVisitStack.Num() && Iteration++ < MaxIteration)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (const FEPAFloodEntry FloodEntry = ToVisitStack .)",
    "insertText": "Pop(EAllowShrinking::No)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VectorTEPAEntry& Entry = Entries [ FloodEntry . EntryIdx ] ;)",
    "insertText": "if(!Entry.bObsolete)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutBorderEdges .)",
    "insertText": "Add(FloodEntry)"
  },
  {
    "label": "Idx1()",
    "kind": "Method",
    "detail": "Function (} else { Entry . bObsolete = true ; const int32 Idx0 = FloodEntry . EdgeIdx ; const int32)",
    "insertText": "Idx1(Idx0 + 1)"
  },
  {
    "label": "Idx2()",
    "kind": "Method",
    "detail": "Function (const int32)",
    "insertText": "Idx2(Idx0 + 2)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ToVisitStack .)",
    "insertText": "Add({ Entry.AdjFaces[Idx1], Entry.AdjEdges[Idx1] })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ToVisitStack .)",
    "insertText": "Add({ Entry.AdjFaces[Idx2], Entry.AdjEdges[Idx2] })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(Iteration >= MaxIteration)"
  },
  {
    "label": "VectorComputeEPAResults()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "VectorComputeEPAResults(const VectorRegister4Float* VertsA, const VectorRegister4Float* VertsB, const VectorTEPAEntry& Entry, VectorRegister4Float& OutPenetration, VectorRegister4Float& OutDir, VectorRegister4Float& OutA, VectorRegister4Float& OutB, EEPAResult& ResultStatus)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float As [ 4 ] = { VertsA [ Entry . IdxBuffer [ 0 ] ],VertsA [ Entry . IdxBuffer [ 1 ] ],VertsA [ Entry . IdxBuffer [ 2 ] ] } ; VectorRegister4Float Bs [ 4 ] = { VertsB [ Entry . IdxBuffer [ 0 ] ],VertsB [ Entry . IdxBuffer [ 1 ] ],VertsB [ Entry . IdxBuffer [ 2 ] ] } ; VectorRegister4Float Simplex [ 4 ] = {)",
    "insertText": "VectorSubtract(As[0], Bs[0]), VectorSubtract(As[1], Bs[1]), VectorSubtract(As[2], Bs[2])"
  },
  {
    "label": "VectorSimplexFindClosestToOrigin()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Barycentric ; int32 NumVerts = 3 ; OutDir =)",
    "insertText": "VectorSimplexFindClosestToOrigin(Simplex, NumVerts, Barycentric, As, Bs)"
  },
  {
    "label": "VectorDot4()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float DotDir =)",
    "insertText": "VectorDot4(OutDir, OutDir)"
  },
  {
    "label": "VectorSqrt()",
    "kind": "Method",
    "detail": "Function (ResultStatus = EEPAResult::NoValidContact ; } OutPenetration =)",
    "insertText": "VectorSqrt(DotDir)"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (float EpsFloat = 1 e - 4 f ; VectorRegister4Float Eps =)",
    "insertText": "MakeVectorRegisterFloatConstant(EpsFloat, EpsFloat, EpsFloat, EpsFloat)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OutDir = Entry . PlaneNormal ;)",
    "insertText": "if(VectorMaskBits(VectorCompareGT(VectorZero(), Entry.Distance)))"
  },
  {
    "label": "VectorNegate()",
    "kind": "Method",
    "detail": "Function (OutPenetration =)",
    "insertText": "VectorNegate(OutPenetration)"
  },
  {
    "label": "VectorDivide()",
    "kind": "Method",
    "detail": "Function (} } else { OutDir =)",
    "insertText": "VectorDivide(OutDir, OutPenetration)"
  },
  {
    "label": "VectorNegate()",
    "kind": "Method",
    "detail": "Function (OutDir =)",
    "insertText": "VectorNegate(OutDir)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Barycentrics [ 4 ] ; Barycentrics [ 0 ] =)",
    "insertText": "VectorSwizzle(Barycentric, 0, 0, 0, 0)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (Barycentrics [ 1 ] =)",
    "insertText": "VectorSwizzle(Barycentric, 1, 1, 1, 1)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (Barycentrics [ 2 ] =)",
    "insertText": "VectorSwizzle(Barycentric, 2, 2, 2, 2)"
  },
  {
    "label": "VectorSwizzle()",
    "kind": "Method",
    "detail": "Function (Barycentrics [ 3 ] =)",
    "insertText": "VectorSwizzle(Barycentric, 3, 3, 3, 3)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (OutA =)",
    "insertText": "VectorMultiplyAdd(As[i], Barycentrics[i], OutA)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (OutB =)",
    "insertText": "VectorMultiplyAdd(Bs[i], Barycentrics[i], OutB)"
  },
  {
    "label": "VectorEPA()",
    "kind": "Method",
    "detail": "Function (} } template<TSupportA,TSupportB> EEPAResult)",
    "insertText": "VectorEPA(TArray<VectorRegister4Float>& VertsABuffer, TArray<VectorRegister4Float>& VertsBBuffer, const TSupportA& SupportA, const TSupportB& SupportB, VectorRegister4Float& OutPenetration, VectorRegister4Float& OutDir, VectorRegister4Float& WitnessA, VectorRegister4Float& WitnessB)"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float EpsRel =)",
    "insertText": "MakeVectorRegisterFloatConstant(1.e-2f, 1.e-2f, 1.e-2f, 1.e-2f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TEPAWorkingArray<VectorTEPAEntry> Entries ;)",
    "insertText": "if(!VectorInitializeEPA(VertsABuffer, VertsBBuffer, SupportA, SupportB, Entries, OutDir))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsWBuffer .)",
    "insertText": "Add(VectorMinkowskiVert(VertsABuffer.GetData(), VertsBBuffer.GetData(), Idx))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} # endif TEPAWorkingArray<int32> Queue ;)",
    "insertText": "for(int32 Idx = 0; Idx < Entries.Num(); ++Idx)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (const bool bIsZeroGTDist = static_cast<)",
    "insertText": "bool(VectorMaskBits(VectorCompareGE(VectorZero(), Entries[Idx].Distance)))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Queue .)",
    "insertText": "Add(Idx)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} } TEPAWorkingArray<FEPAFloodEntry> VisibilityBorder ; TEPAWorkingArray<FEPAFloodEntry> VisibilityBorderToVisitStack ; VectorTEPAEntry LastEntry = Queue .)",
    "insertText": "Num() > 0 ? Entries[Queue.Last()"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float MaxLimit =)",
    "insertText": "MakeVectorRegisterFloatConstant(TNumericLimits<FRealSingle>::Max(), TNumericLimits<FRealSingle>::Max(), TNumericLimits<FRealSingle>::Max(), TNumericLimits<FRealSingle>::Max())"
  },
  {
    "label": "MakeVectorRegisterFloatConstant()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float MinLimit =)",
    "insertText": "MakeVectorRegisterFloatConstant(TNumericLimits<FRealSingle>::Lowest(), TNumericLimits<FRealSingle>::Lowest(), TNumericLimits<FRealSingle>::Lowest(), TNumericLimits<FRealSingle>::Lowest())"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float UpperBound = MaxLimit ; VectorRegister4Float LowerBound = MinLimit ; bool bQueueDirty = true ; int32 Iteration = 0 ; int32 MaxIterations = 1 2 8 ; EEPAResult ResultStatus = EEPAResult::MaxIterations ;)",
    "insertText": "while(Queue.Num() && (Iteration++ < MaxIterations))"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort(Queue.GetData(), Queue.GetData() + Queue.Num(), [&Entries](const int32 L, const int32 R) { return Entries[L] > Entries[R]; })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VectorTEPAEntry& Entry = Entries [ EntryIdx ] ; { })",
    "insertText": "if(Entry.bObsolete)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (continue ; })",
    "insertText": "if(VectorMaskBits(VectorCompareGT(Entry.Distance, UpperBound)))"
  },
  {
    "label": "SupportA()",
    "kind": "Method",
    "detail": "Function (ResultStatus = EEPAResult::Ok ; break ; } const VectorRegister4Float ASupport =)",
    "insertText": "SupportA(Entry.PlaneNormal)"
  },
  {
    "label": "SupportB()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float BSupport =)",
    "insertText": "SupportB(VectorNegate(Entry.PlaneNormal))"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float W =)",
    "insertText": "VectorSubtract(ASupport, BSupport)"
  },
  {
    "label": "VectorDot3()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float DistanceToSupportPlane =)",
    "insertText": "VectorDot3(Entry.PlaneNormal, W)"
  },
  {
    "label": "VectorMin()",
    "kind": "Method",
    "detail": "Function (UpperBound =)",
    "insertText": "VectorMin(DistanceToSupportPlane, UpperBound)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (LowerBound = Entry . Distance ; const VectorRegister4Float UpperBoundTolerance =)",
    "insertText": "VectorMultiply(VectorAdd(VectorOneFloat(), EpsRel), VectorAbs(LowerBound))"
  },
  {
    "label": "VectorCompareLE()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float UpperBoundLEUpperBoundTolerance =)",
    "insertText": "VectorCompareLE(UpperBound, UpperBoundTolerance)"
  },
  {
    "label": "VectorCompareGT()",
    "kind": "Method",
    "detail": "Function (ResultStatus = EEPAResult::Ok ; LastEntry = Entry ; break ; } const VectorRegister4Float LowGTUp =)",
    "insertText": "VectorCompareGT(LowerBound, UpperBound)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ResultStatus = EEPAResult::Ok ; break ; } LastEntry = Entry ; const int32 NewVertIdx = VertsABuffer .)",
    "insertText": "Add(ASupport)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (VertsBBuffer .)",
    "insertText": "Add(BSupport)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (# if DEBUG_EPA VertsWBuffer .)",
    "insertText": "Add(VectorMinkowskiVert(VertsABuffer.GetData(), VertsBBuffer.GetData(), NewVertIdx))"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (# endif Entry . bObsolete = true ; VisibilityBorder .)",
    "insertText": "Reset()"
  },
  {
    "label": "VectorEPAComputeVisibilityBorder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorEPAComputeVisibilityBorder(Entries, EntryIdx, W, VisibilityBorder, VisibilityBorderToVisitStack)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (int32 NewIdx = FirstIdxInBatch ; Entries .)",
    "insertText": "AddUninitialized(NumBorderEdges)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool bTerminate = false ;)",
    "insertText": "for(int32 VisibilityIdx = 0; VisibilityIdx < NumBorderEdges; ++VisibilityIdx)"
  },
  {
    "label": "BorderEdgeIdx1()",
    "kind": "Method",
    "detail": "Function (const FEPAFloodEntry& BorderInfo = VisibilityBorder [ VisibilityIdx ] ; VectorTEPAEntry& NewEntry = Entries [ NewIdx ] ; const int32 BorderEntryIdx = BorderInfo . EntryIdx ; VectorTEPAEntry& BorderEntry = Entries [ BorderEntryIdx ] ; const int32 BorderEdgeIdx0 = BorderInfo . EdgeIdx ; const int32)",
    "insertText": "BorderEdgeIdx1(BorderEdgeIdx0 + 1)"
  },
  {
    "label": "NextEntryIdx()",
    "kind": "Method",
    "detail": "Function (const int32)",
    "insertText": "NextEntryIdx(VisibilityIdx + 1) < VisibilityBorder.Num()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (const int32 PrevEntryIdx = NewIdx> FirstIdxInBatch ? NewIdx - 1 : FirstIdxInBatch + NumBorderEdges - 1 ; const bool bValidTri = NewEntry .)",
    "insertText": "Initialize(VertsABuffer.GetData(), VertsBBuffer.GetData(), BorderEntry.IdxBuffer[BorderEdgeIdx1], BorderEntry.IdxBuffer[BorderEdgeIdx0], NewVertIdx, { BorderEntryIdx, PrevEntryIdx, NextEntryIdx }, { BorderEdgeIdx0, 2, 1 })"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BorderEntry . AdjFaces [ BorderEdgeIdx0 ] = NewIdx ; BorderEntry . AdjEdges [ BorderEdgeIdx0 ] = 0 ;)",
    "insertText": "if(!bValidTri)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ResultStatus = EEPAResult::Degenerate ; bTerminate = true ; break ; })",
    "insertText": "if(bValidTri && VectorMaskBits(VectorCompareGE(UpperBound, NewEntry.Distance)))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Queue .)",
    "insertText": "Add(NewIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bQueueDirty = true ; } } + + NewIdx ; })",
    "insertText": "if(bTerminate)"
  },
  {
    "label": "VectorComputeEPAResults()",
    "kind": "Method",
    "detail": "Function (break ; } } else { ResultStatus = EEPAResult::Degenerate ; break ; } })",
    "insertText": "VectorComputeEPAResults(VertsABuffer.GetData(), VertsBBuffer.GetData(), LastEntry, OutPenetration, OutDir, WitnessA, WitnessB, ResultStatus)"
  }
]