[
  {
    "label": "FBinaryHeap",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FBinaryHeap"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" HAL / UnrealMemory . h \" # include \" Math / UnrealMathUtility . h \" # include<type_traits> template<KeyType,IndexType = uint32> class FBinaryHeap { public :)",
    "insertText": "static_assert(std::is_unsigned_v<IndexType>, \"FBinaryHeap only supports unsigned index types\")"
  },
  {
    "label": "FBinaryHeap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBinaryHeap()"
  },
  {
    "label": "FBinaryHeap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBinaryHeap(uint32 InHeapSize, uint32 InIndexSize)"
  },
  {
    "label": "FBinaryHeap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBinaryHeap(const FBinaryHeap&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const FBinaryHeap&)"
  },
  {
    "label": "FBinaryHeap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBinaryHeap(FBinaryHeap&& Other)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear()"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free()"
  },
  {
    "label": "Resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Resize(uint32 NewHeapSize, uint32 NewIndexSize)"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "GetKey()",
    "kind": "Method",
    "detail": "Function (KeyType)",
    "insertText": "GetKey(IndexType Index)"
  },
  {
    "label": "Peek()",
    "kind": "Method",
    "detail": "Function (IndexType)",
    "insertText": "Peek(IndexType Index)"
  },
  {
    "label": "Top()",
    "kind": "Method",
    "detail": "Function (IndexType)",
    "insertText": "Top()"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Pop()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Add(KeyType Key, IndexType Index)"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Update(KeyType Key, IndexType Index)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Remove(IndexType Index)"
  },
  {
    "label": "ResizeHeap()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "ResizeHeap(uint32 NewHeapSize)"
  },
  {
    "label": "ResizeIndexes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeIndexes(uint32 NewIndexSize)"
  },
  {
    "label": "UpHeap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpHeap(IndexType HeapIndex)"
  },
  {
    "label": "DownHeap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DownHeap(IndexType HeapIndex)"
  },
  {
    "label": "ResetInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetInternal()"
  },
  {
    "label": "FBinaryHeap()",
    "kind": "Method",
    "detail": "Function (} template<KeyType,IndexType> FBinaryHeap<KeyType,IndexType)",
    "insertText": "FBinaryHeap(uint32 InHeapSize, uint32 InIndexSize ) : HeapNum(0) , HeapSize( InHeapSize ) , IndexSize( InIndexSize)"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (Heap = new IndexType [ HeapSize ] ; Keys = new KeyType [ IndexSize ] ; HeapIndexes = new IndexType [ IndexSize ] ;)",
    "insertText": "Memset(HeapIndexes, 0xff, IndexSize * sizeof( IndexType ))"
  },
  {
    "label": "FBinaryHeap()",
    "kind": "Method",
    "detail": "Function (} template<KeyType,IndexType> FBinaryHeap<KeyType,IndexType)",
    "insertText": "FBinaryHeap(FBinaryHeap< KeyType, IndexType >&& Other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (HeapNum = 0 ; HeapSize = 0 ; delete [ ] Heap ; Heap = nullptr ; return ; } IndexType* NewHeap = new IndexType [ NewHeapSize ] ;)",
    "insertText": "if(HeapSize != 0)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(NewHeap, Heap, HeapSize * sizeof( IndexType ))"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (delete [ ] Heap ; } HeapNum =)",
    "insertText": "Min(HeapNum, NewHeapSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (IndexSize = 0 ; delete [ ] Keys ; delete [ ] HeapIndexes ; Keys = nullptr ; HeapIndexes = nullptr ; return ; } KeyType* NewKeys = new KeyType [ NewIndexSize ] ; IndexType* NewHeapIndexes = new IndexType [ NewIndexSize ] ;)",
    "insertText": "if(IndexSize != 0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (NewKeys [ i ] = Keys [ i ] ; NewHeapIndexes [ i ] = HeapIndexes [ i ] ; } delete [ ] Keys ; delete [ ] HeapIndexes ; })",
    "insertText": "for(uint32 i = IndexSize; i < NewIndexSize; i++)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (NewHeapIndexes [)",
    "insertText": "i(IndexType)"
  },
  {
    "label": "ResizeHeap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeHeap(NewHeapSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(NewIndexSize != IndexSize)"
  },
  {
    "label": "ResizeIndexes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeIndexes(NewIndexSize)"
  },
  {
    "label": "IsPresent()",
    "kind": "Method",
    "detail": "Function (} } template<KeyType,IndexType> bool FBinaryHeap<KeyType,IndexType)",
    "insertText": "IsPresent(IndexType Index)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (IndexType Index = Heap [ 0 ] ; Heap [ 0 ] = Heap [ - - HeapNum ] ; HeapIndexes [ Heap [ 0 ] ] = 0 ; HeapIndexes [)",
    "insertText": "Index(IndexType)"
  },
  {
    "label": "ResizeHeap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeHeap(FMath::Max<uint32>( 32u, HeapSize * 2 ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Index >= IndexSize)"
  },
  {
    "label": "ResizeIndexes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeIndexes(FMath::Max<uint32>(32u, FMath::RoundUpToPowerOfTwo(Index + 1)))"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "checkSlow(!IsPresent( Index ))"
  },
  {
    "label": "UpHeap()",
    "kind": "Method",
    "detail": "Function (IndexType HeapIndex = HeapNum + + ; Heap [ HeapIndex ] = Index ; Keys [ Index ] = Key ; HeapIndexes [ Index ] = HeapIndex ;)",
    "insertText": "UpHeap(HeapIndex)"
  },
  {
    "label": "Parent()",
    "kind": "Method",
    "detail": "Function (Keys [ Index ] = Key ; IndexType HeapIndex = HeapIndexes [ Index ] ; IndexType)",
    "insertText": "Parent(HeapIndex - 1)"
  },
  {
    "label": "DownHeap()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "DownHeap(HeapIndex)"
  },
  {
    "label": "Parent()",
    "kind": "Method",
    "detail": "Function (IndexType Moving = Heap [ HeapIndex ] ; IndexType i = HeapIndex ; IndexType)",
    "insertText": "Parent(i - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(i != HeapIndex)"
  },
  {
    "label": "Left()",
    "kind": "Method",
    "detail": "Function (IndexType Moving = Heap [ HeapIndex ] ; IndexType i = HeapIndex ; IndexType)",
    "insertText": "Left(i << 1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (IndexType Right = Left + 1 ;)",
    "insertText": "while(Left < HeapNum)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (IndexType Smallest = Left ;)",
    "insertText": "if(Right < HeapNum)"
  },
  {
    "label": "Smallest()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Smallest(Keys[ Heap[Left] ] < Keys[ Heap[Right] ])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Keys[ Heap[Smallest] ] < Keys[ Moving ])"
  }
]