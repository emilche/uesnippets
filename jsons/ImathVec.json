[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "Vec2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Vec2"
  },
  {
    "label": "Vec3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Vec3"
  },
  {
    "label": "Vec4",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Vec4"
  },
  {
    "label": "IMATH_EXPORT_ENUM",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "IMATH_EXPORT_ENUM"
  },
  {
    "label": "IMATH_EXPORT_TEMPLATE_TYPE",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IMATH_EXPORT_TEMPLATE_TYPE"
  },
  {
    "label": "S",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "S"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHVEC_H # define INCLUDED_IMATHVEC_H # include \" ImathExport . h \" # include \" ImathNamespace . h \" # include \" ImathTypeTraits . h \" # include \" ImathMath . h \" # include<iostream> # include<limits> # include<cstdint> # include<stdexcept> #)",
    "insertText": "if(defined _WIN32 || defined _WIN64) && defined _MSC_VER # pragma warning(push) # pragma warning(disable : 4290)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> class Vec3 ; template<class T> class Vec4 ; enum IMATH_EXPORT_ENUM InfException { INF_EXCEPTION } ; template<class T> class IMATH_EXPORT_TEMPLATE_TYPE Vec2 { public : T x,y ; IMATH_HOSTDEVICE IMATH_CONSTEXPR14 T&)",
    "insertText": "operator(int i)"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec2()"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec2(T a)"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec2(T a, T b)"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec2(const Vec2& v)"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE)",
    "insertText": "Vec2(const Vec2<S>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Vec2&)",
    "insertText": "operator(const Vec2& v)"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (# if IMATH_FOREIGN_VECTOR_INTEROP template<V,)",
    "insertText": "IMATH_ENABLE_IF(has_xy<V,T>::value)> IMATH_HOSTDEVICE explicit constexpr Vec2 (const V& v) IMATH_NOEXCEPT : Vec2(T(v.x), T(v.y))"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (} template<V,)",
    "insertText": "IMATH_ENABLE_IF(has_subscript<V,T,2>::value && !has_xy<V,T>::value)> IMATH_HOSTDEVICE explicit Vec2 (const V& v) : Vec2(T(v[0]), T(v[1]))"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (} template<V,)",
    "insertText": "IMATH_ENABLE_IF(has_xy<V,T>::value)> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Vec2& operator= (const V& v)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x =)",
    "insertText": "T(v.x)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (y =)",
    "insertText": "T(v.y)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x =)",
    "insertText": "T(v[0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (y =)",
    "insertText": "T(v[1])"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "setValue(const Vec2<S>& v)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "getValue(S& a, S& b)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "getValue(Vec2<S>& v)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T*)",
    "insertText": "getValue()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE bool)",
    "insertText": "operator(const Vec2<S>& v)"
  },
  {
    "label": "equalWithAbsError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithAbsError(const Vec2<T>& v, T e)"
  },
  {
    "label": "equalWithRelError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithRelError(const Vec2<T>& v, T e)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "dot(const Vec2& v)"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "cross(const Vec2& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Vec2)",
    "insertText": "operator()"
  },
  {
    "label": "negate()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Vec2&)",
    "insertText": "negate()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Vec2&)",
    "insertText": "operator(T a)"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "length()"
  },
  {
    "label": "length2()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "length2()"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE const Vec2&)",
    "insertText": "normalize()"
  },
  {
    "label": "normalizeExc()",
    "kind": "Method",
    "detail": "Function (const Vec2&)",
    "insertText": "normalizeExc()"
  },
  {
    "label": "normalizeNonNull()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE const Vec2&)",
    "insertText": "normalizeNonNull()"
  },
  {
    "label": "normalized()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Vec2<T>)",
    "insertText": "normalized()"
  },
  {
    "label": "normalizedExc()",
    "kind": "Method",
    "detail": "Function (Vec2<T>)",
    "insertText": "normalizedExc()"
  },
  {
    "label": "normalizedNonNull()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Vec2<T>)",
    "insertText": "normalizedNonNull()"
  },
  {
    "label": "baseTypeLowest()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "baseTypeLowest()"
  },
  {
    "label": "baseTypeMax()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE T)",
    "insertText": "baseTypeMax()"
  },
  {
    "label": "baseTypeSmallest()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE T)",
    "insertText": "baseTypeSmallest()"
  },
  {
    "label": "baseTypeEpsilon()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE T)",
    "insertText": "baseTypeEpsilon()"
  },
  {
    "label": "dimensions()",
    "kind": "Method",
    "detail": "Function (} IMATH_HOSTDEVICE unsigned int)",
    "insertText": "dimensions()"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec3()"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec3(T a)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec3(T a, T b, T c)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec3(const Vec3& v)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE)",
    "insertText": "Vec3(const Vec3<S>& v)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE)",
    "insertText": "Vec3(const Vec4<S>& v)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE IMATH_CONSTEXPR14)",
    "insertText": "Vec3(const Vec4<S>& v, InfException)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Vec3&)",
    "insertText": "operator(const Vec3& v)"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (# if IMATH_FOREIGN_VECTOR_INTEROP template<V,)",
    "insertText": "IMATH_ENABLE_IF(has_xyz<V,T>::value)> IMATH_HOSTDEVICE explicit constexpr Vec3 (const V& v) IMATH_NOEXCEPT : Vec3(T(v.x), T(v.y), T(v.z))"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (} template<V,)",
    "insertText": "IMATH_ENABLE_IF(has_subscript<V,T,3>::value && !has_xyz<V,T>::value)> IMATH_HOSTDEVICE explicit Vec3 (const V& v) : Vec3(T(v[0]), T(v[1]), T(v[2]))"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (} template<V,)",
    "insertText": "IMATH_ENABLE_IF(has_xyz<V,T>::value)> IMATH_HOSTDEVICE const Vec3& operator= (const V& v)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (z =)",
    "insertText": "T(v.z)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (z =)",
    "insertText": "T(v[2])"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "setValue(const Vec3<S>& v)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "getValue(S& a, S& b, S& c)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE void)",
    "insertText": "getValue(Vec3<S>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE bool)",
    "insertText": "operator(const Vec3<S>& v)"
  },
  {
    "label": "equalWithAbsError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithAbsError(const Vec3<T>& v, T e)"
  },
  {
    "label": "equalWithRelError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithRelError(const Vec3<T>& v, T e)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "dot(const Vec3& v)"
  },
  {
    "label": "cross()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE Vec3)",
    "insertText": "cross(const Vec3& v)"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec4()"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec4(T a)"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec4(T a, T b, T c, T d)"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE)",
    "insertText": "Vec4(const Vec4& v)"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE)",
    "insertText": "Vec4(const Vec4<S>& v)"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE)",
    "insertText": "Vec4(const Vec3<S>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Vec4&)",
    "insertText": "operator(const Vec4& v)"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (# if IMATH_FOREIGN_VECTOR_INTEROP template<V,)",
    "insertText": "IMATH_ENABLE_IF(has_xyzw<V,T>::value)> IMATH_HOSTDEVICE explicit constexpr Vec4 (const V& v) IMATH_NOEXCEPT : Vec4(T(v.x), T(v.y), T(v.z), T(v.w))"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (} template<V,)",
    "insertText": "IMATH_ENABLE_IF(has_subscript<V,T,4>::value && !has_xyzw<V,T>::value)> IMATH_HOSTDEVICE explicit Vec4 (const V& v) : Vec4(T(v[0]), T(v[1]), T(v[2]), T(v[3]))"
  },
  {
    "label": "IMATH_ENABLE_IF()",
    "kind": "Method",
    "detail": "Function (} template<V,)",
    "insertText": "IMATH_ENABLE_IF(has_xyzw<V,T>::value)> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 const Vec4& operator= (const V& v)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (w =)",
    "insertText": "T(v.w)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (w =)",
    "insertText": "T(v[3])"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class S> IMATH_HOSTDEVICE bool)",
    "insertText": "operator(const Vec4<S>& v)"
  },
  {
    "label": "equalWithAbsError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithAbsError(const Vec4<T>& v, T e)"
  },
  {
    "label": "equalWithRelError()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE IMATH_CONSTEXPR14 bool)",
    "insertText": "equalWithRelError(const Vec4<T>& v, T e)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (IMATH_HOSTDEVICE T)",
    "insertText": "dot(const Vec4& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& s, const Vec2<T>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& s, const Vec3<T>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& s, const Vec4<T>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE Vec2<T>)",
    "insertText": "operator(T a, const Vec2<T>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE Vec3<T>)",
    "insertText": "operator(T a, const Vec3<T>& v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (template<class T> IMATH_HOSTDEVICE Vec4<T>)",
    "insertText": "operator(T a, const Vec4<T>& v)"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Vec2<T)",
    "insertText": "Vec2(T a) IMATH_NOEXCEPT : x(a), y(a)"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Vec2<T)",
    "insertText": "Vec2(T a, T b) IMATH_NOEXCEPT : x(a), y(b)"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Vec2<T)",
    "insertText": "Vec2(const Vec2& v) IMATH_NOEXCEPT : x(v.x), y(v.y)"
  },
  {
    "label": "Vec2()",
    "kind": "Method",
    "detail": "Function (} template<class T> template<class S> IMATH_HOSTDEVICE Vec2<T)",
    "insertText": "Vec2(const Vec2<S>& v) IMATH_NOEXCEPT : x(T(v.x)), y(T(v.y))"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (x = v . x ; y = v . y ; return* this ; } template<class T> template<class S> IMATH_HOSTDEVICE void Vec2<T)",
    "insertText": "setValue(S a, S b)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (x =)",
    "insertText": "T(a)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (y =)",
    "insertText": "T(b)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (a =)",
    "insertText": "S(x)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (b =)",
    "insertText": "S(y)"
  },
  {
    "label": "lengthTiny()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE IMATH_CONSTEXPR14 T Vec2<T)",
    "insertText": "lengthTiny()"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (T absX =)",
    "insertText": "abs(x)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (T absY =)",
    "insertText": "abs(y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T max = absX ;)",
    "insertText": "if(max < absY)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (absX / = max ; absY / = max ; return max*)",
    "insertText": "sqrt(absX * absX + absY * absY)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (T length2 =)",
    "insertText": "dot(*this)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Vec3<T)",
    "insertText": "Vec3(T a) IMATH_NOEXCEPT : x(a), y(a), z(a)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Vec3<T)",
    "insertText": "Vec3(T a, T b, T c) IMATH_NOEXCEPT : x(a), y(b), z(c)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Vec3<T)",
    "insertText": "Vec3(const Vec3& v) IMATH_NOEXCEPT : x(v.x), y(v.y), z(v.z)"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (} template<class T> template<class S> IMATH_HOSTDEVICE Vec3<T)",
    "insertText": "Vec3(const Vec3<S>& v) IMATH_NOEXCEPT : x(T(v.x)), y(T(v.y)), z(T(v.z))"
  },
  {
    "label": "Vec3()",
    "kind": "Method",
    "detail": "Function (x = v . x ; y = v . y ; z = v . z ; return* this ; } template<class T> template<class S> IMATH_HOSTDEVICE Vec3<T)",
    "insertText": "Vec3(const Vec4<S>& v) IMATH_NOEXCEPT : x(T(v.x/v.w)), y(T(v.y/v.w)), z(T(v.z/v.w))"
  },
  {
    "label": "absW()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "absW(vw >= T (0))"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} x = vx / vw ; y = vy / vw ; z = vz / vw ; } template<class T> template<class S> IMATH_HOSTDEVICE void Vec3<T)",
    "insertText": "setValue(S a, S b, S c)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (z =)",
    "insertText": "T(c)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (c =)",
    "insertText": "S(z)"
  },
  {
    "label": "absX()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "absX(x >= T (0))"
  },
  {
    "label": "absY()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "absY(y >= T (0))"
  },
  {
    "label": "absZ()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "absZ(z >= T (0))"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (absX / = max ; absY / = max ; absZ / = max ; return max*)",
    "insertText": "sqrt(absX * absX + absY * absY + absZ * absZ)"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Vec4<T)",
    "insertText": "Vec4(T a) IMATH_NOEXCEPT : x(a), y(a), z(a), w(a)"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Vec4<T)",
    "insertText": "Vec4(T a, T b, T c, T d) IMATH_NOEXCEPT : x(a), y(b), z(c), w(d)"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (} template<class T> IMATH_HOSTDEVICE Vec4<T)",
    "insertText": "Vec4(const Vec4& v) IMATH_NOEXCEPT : x(v.x), y(v.y), z(v.z), w(v.w)"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (} template<class T> template<class S> IMATH_HOSTDEVICE Vec4<T)",
    "insertText": "Vec4(const Vec4<S>& v) IMATH_NOEXCEPT : x(T(v.x)), y(T(v.y)), z(T(v.z)), w(T(v.w))"
  },
  {
    "label": "Vec4()",
    "kind": "Method",
    "detail": "Function (x = v . x ; y = v . y ; z = v . z ; w = v . w ; return* this ; } template<class T> template<class S> IMATH_HOSTDEVICE Vec4<T)",
    "insertText": "Vec4(const Vec3<S>& v) IMATH_NOEXCEPT : x(T(v.x)), y(T(v.y)), z(T(v.z)), w(T(1))"
  },
  {
    "label": "absW()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "absW(w >= T (0))"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (absX / = max ; absY / = max ; absZ / = max ; absW / = max ; return max*)",
    "insertText": "sqrt(absX * absX + absY * absY + absZ * absZ + absW * absW)"
  }
]