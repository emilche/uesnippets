[
  {
    "label": "TriangleMeshType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TriangleMeshType"
  },
  {
    "label": "TFastWindingTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TFastWindingTree"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FNegativeSpaceSampleSettings",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FNegativeSpaceSampleSettings"
  },
  {
    "label": "FSphereCovering",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSphereCovering"
  },
  {
    "label": "FConvexDecomposition3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FConvexDecomposition3"
  },
  {
    "label": "FPreprocessMeshOptions",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPreprocessMeshOptions"
  },
  {
    "label": "FConvexPart",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FConvexPart"
  },
  {
    "label": "FMergeSettings",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMergeSettings"
  },
  {
    "label": "FProximity",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FProximity"
  },
  {
    "label": "FNegativeSpaceSampleSettings()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" BoxTypes . h \" # include \" Containers / Array . h \" # include \" Containers / IndirectArray . h \" # include \" Containers / Map . h \" # include \" CoreMinimal . h \" # include \" DynamicMesh / DynamicMesh3 . h \" # include \" IndexTypes . h \" # include \" Math / UnrealMathSSE . h \" # include \" Math / Vector . h \" # include \" MathUtil . h \" # include \" Misc / AssertionMacros . h \" # include \" PlaneTypes . h \" # include \" TransformTypes . h \" # include \" VectorTypes . h \" namespace UE { namespace Geometry { template<class TriangleMeshType> class TFastWindingTree ; enum class EConvexErrorMethod { RelativeVolume } ; struct FNegativeSpaceSampleSettings {)",
    "insertText": "FNegativeSpaceSampleSettings()"
  },
  {
    "label": "FNegativeSpaceSampleSettings()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FNegativeSpaceSampleSettings(int32 TargetNumSamples, double MinSpacing, double ReduceRadiusMargin) : TargetNumSamples(TargetNumSamples), MinSpacing(MinSpacing), ReduceRadiusMargin(ReduceRadiusMargin)"
  },
  {
    "label": "ApplyDefaults()",
    "kind": "Method",
    "detail": "Function (} enum class ESampleMethod : uint8 { Uniform,VoxelSearch,NavigableVoxelSearch } ; enum class EConfigDefaults : uint8 { Latest } ; void)",
    "insertText": "ApplyDefaults(EConfigDefaults Settings = EConfigDefaults::Latest)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (SampleMethod = ESampleMethod::NavigableVoxelSearch ; MarchingCubesGridScale = 1 . 0 ; MaxVoxelsPerDim = 1 0 2 4 ; MinSpacing = 0 . 0 ; TargetNumSamples = 0 ; VoxelExpandBoundsFactor = UE_DOUBLE_KINDA_SMALL_NUMBER ; } ESampleMethod SampleMethod = ESampleMethod::Uniform ; int32 TargetNumSamples = 3 0 ; double MinSpacing = 3 . 0 ; bool bAllowSamplesInsideSpheres = false ; double ReduceRadiusMargin = 3 . 0 ; double MinRadius = 1 0 . 0 ; bool bRequireSearchSampleCoverage = false ; bool bOnlyConnectedToHull = false ; int32 MaxVoxelsPerDim = 1 2 8 ; bool bDeterministic = true ; double MarchingCubesGridScale = . 5 ; bool bAllowSamplesInsideMesh = false ; double VoxelExpandBoundsFactor = 1 . 0 ; TFunction<)",
    "insertText": "double(FVector Pos)"
  },
  {
    "label": "RescaleSettings()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RescaleSettings(ScaleFactor)"
  },
  {
    "label": "SetResultTransform()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetResultTransform(FTransform InResultTransform)"
  },
  {
    "label": "RescaleSettings()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RescaleSettings(ResultTransform.GetScale3D().X / InResultTransform.GetScale3D().X)"
  },
  {
    "label": "GetResultTransform()",
    "kind": "Method",
    "detail": "Function (ResultTransform = InResultTransform ; } FTransform)",
    "insertText": "GetResultTransform()"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (TargetNumSamples =)",
    "insertText": "Max(1, TargetNumSamples)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MinSpacing =)",
    "insertText": "Max(0.0, MinSpacing)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (ReduceRadiusMargin =)",
    "insertText": "Max(0.0, ReduceRadiusMargin)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MinRadius =)",
    "insertText": "Max(0.0, MinRadius)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (MaxVoxelsPerDim =)",
    "insertText": "Clamp(MaxVoxelsPerDim, 4, 1290)"
  },
  {
    "label": "ObstacleDistance()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "ObstacleDistance(const FVector3d& LocalPos)"
  },
  {
    "label": "TransformPosition()",
    "kind": "Method",
    "detail": "Function (FVector3d WorldPos = ResultTransform .)",
    "insertText": "TransformPosition(LocalPos)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (MinSpacing* = ScaleFactor ; ReduceRadiusMargin* = ScaleFactor ; MinRadius* = ScaleFactor ; AppliedScaleFactor* = ScaleFactor ; } } ; class FSphereCovering { public : int32)",
    "insertText": "Num()"
  },
  {
    "label": "GetCenter()",
    "kind": "Method",
    "detail": "Function (} FVector3d)",
    "insertText": "GetCenter(int32 Idx)"
  },
  {
    "label": "AddNegativeSpace()",
    "kind": "Method",
    "detail": "Function (Radius [ Idx ] = UpdateRadius ; } bool)",
    "insertText": "AddNegativeSpace(const TFastWindingTree<FDynamicMesh3>& Spatial, const FNegativeSpaceSampleSettings& Settings, bool bHasFlippedTriangles)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset()"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Append(const FSphereCovering& Other)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (Position .)",
    "insertText": "Append(Other.Position)"
  },
  {
    "label": "Append()",
    "kind": "Method",
    "detail": "Function (Radius .)",
    "insertText": "Append(Other.Radius)"
  },
  {
    "label": "RemoveSmaller()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RemoveSmaller(double MinRadius)"
  },
  {
    "label": "RemoveAtSwap()",
    "kind": "Method",
    "detail": "Function (Radius .)",
    "insertText": "RemoveAtSwap(Idx, EAllowShrinking::No)"
  },
  {
    "label": "AppendSpheres()",
    "kind": "Method",
    "detail": "Function (- - Idx ; } } } void)",
    "insertText": "AppendSpheres(TArrayView<const FSphere> Spheres)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Position .)",
    "insertText": "SetNum(AddCount + OrigCount)"
  },
  {
    "label": "AddSphere()",
    "kind": "Method",
    "detail": "Function (Position [ Idx + OrigCount ] = Spheres [ Idx ] . Center ; Radius [ Idx + OrigCount ] = Spheres [ Idx ] . W ; } } void)",
    "insertText": "AddSphere(FVector3d InCenter, double InRadius)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Position .)",
    "insertText": "Add(InCenter)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Radius .)",
    "insertText": "Add(InRadius)"
  },
  {
    "label": "FConvexDecomposition3()",
    "kind": "Method",
    "detail": "Function (} private : TArray<FVector3d> Position ; TArray<double> Radius ; } ; class FConvexDecomposition3 { public :)",
    "insertText": "FConvexDecomposition3() : ResultTransform(FTransformSRT3d::Identity())"
  },
  {
    "label": "FConvexDecomposition3()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FConvexDecomposition3(const FDynamicMesh3& SourceMesh, bool bMergeEdges = true)"
  },
  {
    "label": "InitializeFromMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeFromMesh(SourceMesh, bMergeEdges)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} struct FPreprocessMeshOptions { bool bMergeEdges = true ; TUniqueFunction<)",
    "insertText": "void(FDynamicMesh3& Mesh, const FAxisAlignedBox3d& Bounds)"
  },
  {
    "label": "FConvexDecomposition3()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "FConvexDecomposition3(const FDynamicMesh3& SourceMesh, const FPreprocessMeshOptions& Options)"
  },
  {
    "label": "InitializeFromMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeFromMesh(SourceMesh, Options)"
  },
  {
    "label": "IsInputSolid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsInputSolid()"
  },
  {
    "label": "InitializeFromHulls()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitializeFromHulls(int32 NumHulls, TFunctionRef<double(int32)> HullVolumes, TFunctionRef<int32(int32)> HullNumVertices, TFunctionRef<FVector3d(int32, int32)> HullVertices, TArrayView<const TPair<int32, int32>> Proximity)"
  },
  {
    "label": "InitializeProximityFromDecompositionBoundingBoxOverlaps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeProximityFromDecompositionBoundingBoxOverlaps(double BoundsExpandByMinDimFactor, double BoundsExpandByMaxDimFactor, double MinBoundsExpand)"
  },
  {
    "label": "InitializeFromMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeFromMesh(const FDynamicMesh3& SourceMesh, bool bMergeEdges)"
  },
  {
    "label": "InitializeFromMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeFromMesh(const FDynamicMesh3& SourceMesh, const FPreprocessMeshOptions& Options)"
  },
  {
    "label": "InitializeFromIndexMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitializeFromIndexMesh(TArrayView<const FVector3f> Vertices, TArrayView<const FIntVector> Faces, bool bMergeEdges, int32 FaceVertexOffset = 0)"
  },
  {
    "label": "InitializeNegativeSpace()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "InitializeNegativeSpace(const FNegativeSpaceSampleSettings& Settings, TArrayView<const FVector3d> RequestedSamples = TArrayView<const FVector3d>())"
  },
  {
    "label": "SplitWorst()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "SplitWorst(bool bCanSkipUnreliableGeoVolumes = false, double ErrorTolerance = 0.0, bool bOnlySplitIfNegativeSpaceCovered = false, double MinSplitSizeInWorldSpace = -1)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (struct FConvexPart ; struct FMergeSettings { int32 TargetNumParts = 1 ; double ErrorTolerance = 0 ; bool bErrorToleranceOverridesNumParts = true ; int32 MaxOutputHulls = - 1 ; double MinThicknessTolerance = 0 ; bool bAllowCompact = true ; bool bRequireHullTriangles = false ; const FSphereCovering* OptionalNegativeSpace = nullptr ; const FTransform* OptionalTransformIntoNegativeSpace = nullptr ; TFunction<)",
    "insertText": "void(int32, int32)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (TFunction<)",
    "insertText": "bool(const FConvexDecomposition3::FConvexPart& A, const FConvexDecomposition3::FConvexPart& B)"
  },
  {
    "label": "MergeBest()",
    "kind": "Method",
    "detail": "Function (} ; int32)",
    "insertText": "MergeBest(int32 TargetNumParts, double ErrorTolerance = 0, double MinThicknessTolerance = 0, bool bAllowCompact = true, bool bRequireHullTriangles = false, int32 MaxOutputHulls = -1, const FSphereCovering* OptionalNegativeSpace = nullptr, const FTransform* OptionalTransformIntoNegativeSpace = nullptr)"
  },
  {
    "label": "MergeBest()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "MergeBest(const FMergeSettings& Settings)"
  },
  {
    "label": "ConvertDistanceToleranceToLocalVolumeTolerance()",
    "kind": "Method",
    "detail": "Function (double)",
    "insertText": "ConvertDistanceToleranceToLocalVolumeTolerance(double DistTolerance)"
  },
  {
    "label": "Compact()",
    "kind": "Method",
    "detail": "Function (ScaleFactor = FMathd::Epsilon ; } double LocalDist = DistTolerance / ScaleFactor ; return LocalDist ; } void)",
    "insertText": "Compact()"
  },
  {
    "label": "NumHulls()",
    "kind": "Method",
    "detail": "Function (} } int32)",
    "insertText": "NumHulls()"
  },
  {
    "label": "GetTriangles()",
    "kind": "Method",
    "detail": "Function (} TArray<FIndex3i> const&)",
    "insertText": "GetTriangles(int32 HullIdx)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (TArray<TVector<RealType>> Vertices ; Vertices .)",
    "insertText": "SetNum(Decomposition[HullIdx].InternalGeo.MaxVertexID())"
  },
  {
    "label": "VID()",
    "kind": "Method",
    "detail": "Function (Vertices [)",
    "insertText": "VID(TVector<RealType>) ResultTransform.TransformPosition(Decomposition[HullIdx].InternalGeo.GetVertex(VID))"
  },
  {
    "label": "GetHullMesh()",
    "kind": "Method",
    "detail": "Function (} } return Vertices ; } FDynamicMesh3)",
    "insertText": "GetHullMesh(int32 HullIdx)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (FDynamicMesh3 HullMesh ;)",
    "insertText": "for(int32 VID = 0; VID < Decomposition[HullIdx].InternalGeo.MaxVertexID(); VID++)"
  },
  {
    "label": "AppendVertex()",
    "kind": "Method",
    "detail": "Function (HullMesh .)",
    "insertText": "AppendVertex(ResultTransform.TransformPosition(Decomposition[HullIdx].InternalGeo.GetVertex(VID)))"
  },
  {
    "label": "AppendVertex()",
    "kind": "Method",
    "detail": "Function (} else { HullMesh .)",
    "insertText": "AppendVertex(FVector3d::ZeroVector)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(const FIndex3i& Tri : Decomposition[HullIdx].HullTriangles)"
  },
  {
    "label": "AppendTriangle()",
    "kind": "Method",
    "detail": "Function (HullMesh .)",
    "insertText": "AppendTriangle(Tri)"
  },
  {
    "label": "GetInternalMesh()",
    "kind": "Method",
    "detail": "Function (} return HullMesh ; } const FDynamicMesh3&)",
    "insertText": "GetInternalMesh(int32 HullIdx)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 Count = 0 ;)",
    "insertText": "for(int32 HullIdx = 0; HullIdx < Decomposition.Num(); ++HullIdx)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (Count + =)",
    "insertText": "int32(Decomposition[HullIdx].HullSourceID < 0)"
  },
  {
    "label": "FConvexPart()",
    "kind": "Method",
    "detail": "Function (} return Count ; } struct FConvexPart {)",
    "insertText": "FConvexPart()"
  },
  {
    "label": "FConvexPart()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FConvexPart(const FDynamicMesh3& SourceMesh, bool bMergeEdges, FTransformSRT3d& TransformOut)"
  },
  {
    "label": "FConvexPart()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FConvexPart(const FDynamicMesh3& SourceMesh, const FConvexDecomposition3::FPreprocessMeshOptions& Options, FTransformSRT3d& TransformOut)"
  },
  {
    "label": "FConvexPart()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FConvexPart(TArrayView<const FVector3f> Vertices, TArrayView<const FIntVector3> Faces, bool bMergeEdges, FTransformSRT3d& TransformOut, int32 FaceVertexOffset = 0)"
  },
  {
    "label": "FConvexPart()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FConvexPart(bool bIsCompact) : bIsCompact(bIsCompact)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (InternalGeo .)",
    "insertText": "Clear()"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (HullVolume = 0 ; GeoVolume = 0 ; SumHullsVolume = - FMathd::MaxReal ; GeoCenter = FVector3d::ZeroVector ; Bounds =)",
    "insertText": "Empty()"
  },
  {
    "label": "IsCompact()",
    "kind": "Method",
    "detail": "Function (HullError = FMathd::MaxReal ; bIsCompact = false ; bFailed = false ; bGeometryVolumeUnreliable = false ; bMustMerge = false ; } FDynamicMesh3 InternalGeo ; bool)",
    "insertText": "IsCompact()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FPlane3d& Plane = HullPlanes [ Idx ] ;)",
    "insertText": "if(Plane.Normal == FVector3d::ZeroVector)"
  },
  {
    "label": "DistanceTo()",
    "kind": "Method",
    "detail": "Function (continue ; } double Dist = Plane .)",
    "insertText": "DistanceTo(Pt)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (MaxDist =)",
    "insertText": "Max(Dist, MaxDist)"
  },
  {
    "label": "ComputeHull()",
    "kind": "Method",
    "detail": "Function (} return MaxDist = = - FMathd::MaxReal ? 0 : - MaxDist ; } bool)",
    "insertText": "ComputeHull(bool bComputePlanes = true)"
  },
  {
    "label": "ComputeStats()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeStats()"
  },
  {
    "label": "InitializeFromInternalGeo()",
    "kind": "Method",
    "detail": "Function (protected : bool bIsCompact = false ; bool bFailed = false ; private : void)",
    "insertText": "InitializeFromInternalGeo(const FConvexDecomposition3::FPreprocessMeshOptions& Preprocess, FTransformSRT3d& TransformOut)"
  },
  {
    "label": "Identity()",
    "kind": "Method",
    "detail": "Function (} ; TIndirectArray<FConvexPart> Decomposition ; FTransformSRT3d ResultTransform =)",
    "insertText": "Identity()"
  },
  {
    "label": "FProximity()",
    "kind": "Method",
    "detail": "Function (struct FProximity {)",
    "insertText": "FProximity()"
  },
  {
    "label": "FProximity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FProximity(const FIndex2i& Link, const FPlane3d& Plane, bool bPlaneSeparates) : Link(Link), Plane(Plane), bPlaneSeparates(bPlaneSeparates)"
  },
  {
    "label": "VolumeNotComputed()",
    "kind": "Method",
    "detail": "Function (} FIndex2i Link { - 1,- 1 } ; FPlane3d Plane ; bool bPlaneSeparates = false ; bool bIsValidLink = true ; double MergedVolume =)",
    "insertText": "VolumeNotComputed()"
  },
  {
    "label": "ClearMergedVolume()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearMergedVolume()"
  },
  {
    "label": "UpdateProximitiesAfterSplit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateProximitiesAfterSplit(int32 SplitIdx, int32 NewIdxStart, FPlane3d CutPlane, int32 SecondSideIdxStart, double OrigHullVolume)"
  },
  {
    "label": "FixHullOverlapsInNegativeSpace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FixHullOverlapsInNegativeSpace(double NegativeSpaceTolerance = UE_DOUBLE_KINDA_SMALL_NUMBER, double NegativeSpaceMinRadius = UE_DOUBLE_KINDA_SMALL_NUMBER)"
  },
  {
    "label": "ConvexPartVsSphereOverlap()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ConvexPartVsSphereOverlap(const FConvexPart& Part, FVector3d Center, double Radius, const FTransform* TransformIntoSphereSpace = nullptr, double* OutDistanceSq = nullptr)"
  },
  {
    "label": "GetNegativeSpace()",
    "kind": "Method",
    "detail": "Function (const FSphereCovering&)",
    "insertText": "GetNegativeSpace()"
  },
  {
    "label": "SplitWorstHelper()",
    "kind": "Method",
    "detail": "Function (FSphereCovering NegativeSpace ; bool)",
    "insertText": "SplitWorstHelper(bool bCanSkipUnreliableGeoVolumes, double ErrorTolerance, bool bOnlySplitIfNegativeSpaceCovered, double MinSplitSizeInWorldSpace)"
  }
]