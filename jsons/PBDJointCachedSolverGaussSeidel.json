[
  {
    "label": "FAxisConstraintDatas",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAxisConstraintDatas"
  },
  {
    "label": "alignas",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "alignas"
  },
  {
    "label": "FData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FData"
  },
  {
    "label": "FPBDJointCachedSolver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDJointCachedSolver"
  },
  {
    "label": "FAxisConstraintDatas()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Chaos / DenseMatrix . h \" # include \" Chaos / Evolution / SolverBody . h \" # include \" Chaos / ParticleHandleFwd . h \" # include \" Chaos / PBDJointConstraintTypes . h \" # include \" Chaos / PBDJointConstraintUtilities . h \" # include \" Chaos / Utilities . h \" namespace Chaos { struct FAxisConstraintDatas {)",
    "insertText": "FAxisConstraintDatas()"
  },
  {
    "label": "FAxisConstraintDatas()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAxisConstraintDatas(const FAxisConstraintDatas&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FAxisConstraintDatas&)",
    "insertText": "operator(const FAxisConstraintDatas&)"
  },
  {
    "label": "FAxisConstraintDatas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAxisConstraintDatas(FAxisConstraintDatas&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FAxisConstraintDatas&)",
    "insertText": "operator(FAxisConstraintDatas&&)"
  },
  {
    "label": "InitDatas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitDatas(const int32 ConstraintIndex, const bool bHasSoftLimits, const FReal SoftStiffness, const FReal SoftDamping, const FReal HardStiffness, const bool bResetLambdas = true)"
  },
  {
    "label": "SetMaxForce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMaxForce(const int32 ConstraintIndex, const FReal InMaxForce, const FReal Dt)"
  },
  {
    "label": "UpdateDatas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateDatas(const int32 ConstraintIndex, const FVec3& DatasAxis, const FReal DatasCX, const FReal DatasRestitution, const bool bCheckLimit = true, const FVec3& DatasArm0 = FVec3::Zero(), const FVec3& DatasArm1 = FVec3::Zero(), const FReal DatasVX = 0.0)"
  },
  {
    "label": "UpdateMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateMass(const int32 ConstraintIndex, const FVec3& DatasIA0, const FVec3& DatasIA1, const FReal DatasIM, const FReal Dt, const bool bUsePositionBasedDrives)"
  },
  {
    "label": "ApplyMaxLambda()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyMaxLambda(const int32 ConstraintIndex, FReal& DeltaLambda, FReal& Lambda)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (struct)",
    "insertText": "alignas(16)"
  },
  {
    "label": "FDataSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FDataSimd() : ConstraintSoftStiffness(VectorZeroFloat()) , ConstraintSoftDamping(VectorZeroFloat()) , ConstraintLimits(VectorZeroFloat())"
  },
  {
    "label": "GetValidDatas()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float ConstraintHardStiffness ; VectorRegister4Float ConstraintSoftStiffness ; VectorRegister4Float ConstraintSoftDamping ; VectorRegister4Float ConstraintArms [ 2 ] ; VectorRegister4Float ConstraintAxis [ 3 ] ; VectorRegister4Float ConstraintLimits ; VectorRegister4Float ConstraintSoftIM ; VectorRegister4Float ConstraintHardIM ; VectorRegister4Float ConstraintDRAxis [ 3 ] [ 2 ] ; VectorRegister4Float ConstraintCX ; VectorRegister4Float ConstraintLambda ; } ; struct FData { FVec3 ConstraintHardStiffness ; FVec3 ConstraintSoftStiffness ; FVec3 ConstraintSoftDamping ; FVec3 ConstraintArms [ 3 ] [ 2 ] ; FVec3 ConstraintAxis [ 3 ] ; FVec3 ConstraintLimits ; FVec3 ConstraintSoftIM ; FVec3 ConstraintHardIM ; FVec3 ConstraintDRAxis [ 3 ] [ 2 ] ; FVec3 ConstraintCX ; FVec3 ConstraintLambda ; } ; union { FDataSimd Simd ; FData Data ; } ; FVec3 ConstraintMaxLambda ; FVec3 SettingsSoftDamping ; FVec3 SettingsSoftStiffness ; FVec3 ConstraintVX ; FVec3 ConstraintRestitution ; FVec3 ConstraintLambdaVelocity ; uint8 bValidDatas0 : 1 ; uint8 bValidDatas1 : 1 ; uint8 bValidDatas2 : 1 ; uint8 bLimitsCheck0 : 1 ; uint8 bLimitsCheck1 : 1 ; uint8 bLimitsCheck2 : 1 ; uint8 bSoftLimit0 : 1 ; uint8 bSoftLimit1 : 1 ; uint8 bSoftLimit2 : 1 ; uint8 bAccelerationMode : 1 ; uint8 bUseSimd : 1 ; uint8 MotionType0 : 2 ; uint8 MotionType1 : 2 ; uint8 MotionType2 : 2 ; bool)",
    "insertText": "GetValidDatas(int32 Index)"
  },
  {
    "label": "check()",
    "kind": "Method",
    "detail": "Function (default :)",
    "insertText": "check(false)"
  },
  {
    "label": "SetValidDatas()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetValidDatas(int32 Index, bool bValue)"
  },
  {
    "label": "SetLimitsCheck()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetLimitsCheck(int32 Index, bool bValue)"
  },
  {
    "label": "SetSoftLimit()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetSoftLimit(int32 Index, bool bValue)"
  },
  {
    "label": "SetMotionType()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetMotionType(int32 Index, EJointMotionType Value)"
  },
  {
    "label": "uint8()",
    "kind": "Method",
    "detail": "Function (break ; case 1 : MotionType1 =)",
    "insertText": "uint8(Value)"
  },
  {
    "label": "Body()",
    "kind": "Method",
    "detail": "Function (} } } ; class FPBDJointCachedSolver { public : const int32 MaxConstrainedBodies = 2 ; FConstraintSolverBody&)",
    "insertText": "Body(int32 BodyIndex)"
  },
  {
    "label": "R()",
    "kind": "Method",
    "detail": "Function (} const FRotation3)",
    "insertText": "R(int BodyIndex)"
  },
  {
    "label": "P()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "P(int BodyIndex)"
  },
  {
    "label": "Q()",
    "kind": "Method",
    "detail": "Function (} const FRotation3)",
    "insertText": "Q(int BodyIndex)"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "V(int BodyIndex)"
  },
  {
    "label": "W()",
    "kind": "Method",
    "detail": "Function (} const FVec3)",
    "insertText": "W(int BodyIndex)"
  },
  {
    "label": "InvM()",
    "kind": "Method",
    "detail": "Function (} FReal)",
    "insertText": "InvM(int32 BodyIndex)"
  },
  {
    "label": "GetNetLinearImpulse()",
    "kind": "Method",
    "detail": "Function (} FVec3)",
    "insertText": "GetNetLinearImpulse()"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (FVec3 Impulse =)",
    "insertText": "FVec3(0)"
  },
  {
    "label": "VectorZeroFloat()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float ImpulseSimd =)",
    "insertText": "VectorZeroFloat()"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float ConstraintLambdas [ 3 ] ; ConstraintLambdas [ 0 ] =)",
    "insertText": "VectorReplicate(PositionConstraints.Simd.ConstraintLambda, 0)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (ConstraintLambdas [ 1 ] =)",
    "insertText": "VectorReplicate(PositionConstraints.Simd.ConstraintLambda, 1)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (ConstraintLambdas [ 2 ] =)",
    "insertText": "VectorReplicate(PositionConstraints.Simd.ConstraintLambda, 2)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (ImpulseSimd =)",
    "insertText": "VectorMultiplyAdd(ConstraintLambdas[Axis], PositionConstraints.Simd.ConstraintAxis[Axis], ImpulseSimd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(PositionDrives.bUseSimd)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float ConstraintLambdas [ 3 ] ; ConstraintLambdas [ 0 ] =)",
    "insertText": "VectorReplicate(PositionDrives.Simd.ConstraintLambda, 0)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (ConstraintLambdas [ 1 ] =)",
    "insertText": "VectorReplicate(PositionDrives.Simd.ConstraintLambda, 1)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (ConstraintLambdas [ 2 ] =)",
    "insertText": "VectorReplicate(PositionDrives.Simd.ConstraintLambda, 2)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (ImpulseSimd =)",
    "insertText": "VectorMultiplyAdd(ConstraintLambdas[Axis], PositionDrives.Simd.ConstraintAxis[Axis], ImpulseSimd)"
  },
  {
    "label": "VectorStoreFloat3()",
    "kind": "Method",
    "detail": "Function (} } FVec3f Impulsef ;)",
    "insertText": "VectorStoreFloat3(ImpulseSimd, &Impulsef[0])"
  },
  {
    "label": "FVec3()",
    "kind": "Method",
    "detail": "Function (Impulse =)",
    "insertText": "FVec3(Impulsef)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int32 Axis = 0; Axis < 3; ++Axis)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Impulse + = PositionConstraints . Data . ConstraintLambda [ Axis ]* PositionConstraints . Data . ConstraintAxis [ Axis ] ; })",
    "insertText": "if(!PositionDrives.bUseSimd && PositionDrives.GetValidDatas(Axis))"
  },
  {
    "label": "GetNetAngularImpulse()",
    "kind": "Method",
    "detail": "Function (Impulse + = PositionDrives . Data . ConstraintLambda [ Axis ]* PositionDrives . Data . ConstraintAxis [ Axis ] ; } } return Impulse ; } FVec3)",
    "insertText": "GetNetAngularImpulse()"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float ConstraintLambdas [ 3 ] ; ConstraintLambdas [ 0 ] =)",
    "insertText": "VectorReplicate(RotationConstraints.Simd.ConstraintLambda, 0)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (ConstraintLambdas [ 1 ] =)",
    "insertText": "VectorReplicate(RotationConstraints.Simd.ConstraintLambda, 1)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (ConstraintLambdas [ 2 ] =)",
    "insertText": "VectorReplicate(RotationConstraints.Simd.ConstraintLambda, 2)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (ImpulseSimd =)",
    "insertText": "VectorMultiplyAdd(ConstraintLambdas[Axis], RotationConstraints.Simd.ConstraintAxis[Axis], ImpulseSimd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(RotationDrives.bUseSimd)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float ConstraintLambdas [ 3 ] ; ConstraintLambdas [ 0 ] =)",
    "insertText": "VectorReplicate(RotationDrives.Simd.ConstraintLambda, 0)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (ConstraintLambdas [ 1 ] =)",
    "insertText": "VectorReplicate(RotationDrives.Simd.ConstraintLambda, 1)"
  },
  {
    "label": "VectorReplicate()",
    "kind": "Method",
    "detail": "Function (ConstraintLambdas [ 2 ] =)",
    "insertText": "VectorReplicate(RotationDrives.Simd.ConstraintLambda, 2)"
  },
  {
    "label": "VectorMultiplyAdd()",
    "kind": "Method",
    "detail": "Function (ImpulseSimd =)",
    "insertText": "VectorMultiplyAdd(ConstraintLambdas[Axis], RotationDrives.Simd.ConstraintAxis[Axis], ImpulseSimd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Impulse + = RotationConstraints . Data . ConstraintLambda [ Axis ]* RotationConstraints . Data . ConstraintAxis [ Axis ] ; })",
    "insertText": "if(!RotationDrives.bUseSimd && RotationDrives.GetValidDatas(Axis))"
  },
  {
    "label": "GetLinearViolationSq()",
    "kind": "Method",
    "detail": "Function (Impulse + = RotationDrives . Data . ConstraintLambda [ Axis ]* RotationDrives . Data . ConstraintAxis [ Axis ] ; } } return Impulse ; } FReal)",
    "insertText": "GetLinearViolationSq()"
  },
  {
    "label": "GetIsActive()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetIsActive()"
  },
  {
    "label": "SetSolverBodies()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetSolverBodies(FSolverBody* SolverBody0, FSolverBody* SolverBody1)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (SolverBodies [ 0 ] =* SolverBody0 ; SolverBodies [ 1 ] =* SolverBody1 ; } void)",
    "insertText": "Init(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings, const FRigidTransform3& XL0, const FRigidTransform3& XL1)"
  },
  {
    "label": "InitProjection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitProjection(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "Deinit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deinit()"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Update(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "ApplyConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyConstraints(const FReal Dt, const FReal InSolverStiffness, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "ApplyVelocityConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyVelocityConstraints(const FReal Dt, const FReal InSolverStiffness, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "ApplyProjections()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyProjections(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings, const bool bLastIteration)"
  },
  {
    "label": "ApplyPositionProjection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionProjection(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "ApplyAxisPositionProjection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAxisPositionProjection(const FReal LinearProjection, const int32 ConstraintIndex)"
  },
  {
    "label": "ApplyPositionProjectionSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionProjectionSimd(const FReal LinearProjection)"
  },
  {
    "label": "ApplyRotationProjection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRotationProjection(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "ApplyAxisRotationProjection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAxisRotationProjection(const FReal AngularProjection, const bool bLinearLocked, const int32 ConstraintIndex)"
  },
  {
    "label": "ApplyRotationProjectionSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRotationProjectionSimd(const FRealSingle AngularProjection, const bool bLinearLocked)"
  },
  {
    "label": "ApplyTeleports()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyTeleports(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "ApplyPositionTeleport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionTeleport(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "ApplyAxisPositionTeleport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAxisPositionTeleport(const FReal TeleportDistance, const int32 ConstraintIndex)"
  },
  {
    "label": "ApplyPositionTeleportSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionTeleportSimd(const FRealSingle TeleportDistance)"
  },
  {
    "label": "ApplyRotationTeleport()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRotationTeleport(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "SetShockPropagationScales()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetShockPropagationScales(const FReal InvMScale0, const FReal InvMScale1, const FReal Dt)"
  },
  {
    "label": "SetIsBroken()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetIsBroken(const bool bInIsBroken)"
  },
  {
    "label": "IsBroken()",
    "kind": "Method",
    "detail": "Function (bIsBroken = bInIsBroken ; } bool)",
    "insertText": "IsBroken()"
  },
  {
    "label": "IsViolating()",
    "kind": "Method",
    "detail": "Function (bIsViolating = bInIsViolating ; } bool)",
    "insertText": "IsViolating()"
  },
  {
    "label": "InitDerivedState()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "InitDerivedState()"
  },
  {
    "label": "UpdateDerivedState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateDerivedState(const int32 BodyIndex)"
  },
  {
    "label": "UpdateDerivedState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateDerivedState()"
  },
  {
    "label": "UpdateMass0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateMass0(const FReal& InInvM, const FVec3& InInvIL)"
  },
  {
    "label": "UpdateMass1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateMass1(const FReal& InInvM, const FVec3& InInvIL)"
  },
  {
    "label": "UpdateIsActive()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "UpdateIsActive()"
  },
  {
    "label": "ApplyPositionDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionDelta(const int32 BodyIndex, const FVec3& DP)"
  },
  {
    "label": "ApplyRotationDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRotationDelta(const int32 BodyIndex, const FVec3& DR)"
  },
  {
    "label": "InitPositionConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitPositionConstraints(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings, const bool bResetLambdas)"
  },
  {
    "label": "InitPositionDatasMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitPositionDatasMass(FAxisConstraintDatas& PositionDatas, const int32 ConstraintIndex, const FReal Dt)"
  },
  {
    "label": "InitPositionConstraintDatas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitPositionConstraintDatas(const int32 ConstraintIndex, const FVec3& ConstraintAxis, const FReal& ConstraintDelta, const FReal ConstraintRestitution, const FReal Dt, const FReal ConstraintLimit, const EJointMotionType JointType, const FVec3& ConstraintArm0, const FVec3& ConstraintArm1)"
  },
  {
    "label": "InitLockedPositionConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitLockedPositionConstraint(const FPBDJointSettings& JointSettings, const FReal Dt, const TVec3<EJointMotionType>& LinearMotion)"
  },
  {
    "label": "InitLockedPositionConstraintSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitLockedPositionConstraintSimd(const FPBDJointSettings& JointSettings, const FReal Dt, const TVec3<EJointMotionType>& LinearMotion)"
  },
  {
    "label": "InitSphericalPositionConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitSphericalPositionConstraint(const FPBDJointSettings& JointSettings, const FReal Dt)"
  },
  {
    "label": "InitCylindricalPositionConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitCylindricalPositionConstraint(const FPBDJointSettings& JointSettings, const FReal Dt, const int32 AxisIndex)"
  },
  {
    "label": "InitPlanarPositionConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitPlanarPositionConstraint(const FPBDJointSettings& JointSettings, const FReal Dt, const int32 AxisIndex)"
  },
  {
    "label": "ApplyPositionConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionConstraints(const FReal Dt)"
  },
  {
    "label": "ApplyAxisPositionConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAxisPositionConstraint(const int32 ConstraintIndex, const FReal Dt)"
  },
  {
    "label": "ApplyPositionConstraintsSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionConstraintsSimd(const FReal Dt)"
  },
  {
    "label": "SolvePositionConstraintDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolvePositionConstraintDelta(const int32 ConstraintIndex, const FReal DeltaLambda, const FAxisConstraintDatas& ConstraintDatas)"
  },
  {
    "label": "SolvePositionConstraintHard()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolvePositionConstraintHard(const int32 ConstraintIndex, const FReal DeltaConstraint)"
  },
  {
    "label": "SolvePositionConstraintSoft()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolvePositionConstraintSoft(const int32 ConstraintIndex, const FReal DeltaConstraint, const FReal Dt, const FReal TargetVel)"
  },
  {
    "label": "ApplyLinearVelocityConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyLinearVelocityConstraints()"
  },
  {
    "label": "ApplyAxisVelocityConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAxisVelocityConstraint(const int32 ConstraintIndex)"
  },
  {
    "label": "ApplyVelocityConstraintSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyVelocityConstraintSimd()"
  },
  {
    "label": "SolveLinearVelocityConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolveLinearVelocityConstraint(const int32 ConstraintIndex, const FReal TargetVel)"
  },
  {
    "label": "InitRotationConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitRotationConstraints(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings, const bool bResetLambdas)"
  },
  {
    "label": "InitRotationConstraintsSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitRotationConstraintsSimd(const FPBDJointSettings& JointSettings, const FRealSingle Dt)"
  },
  {
    "label": "CorrectAxisAngleConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CorrectAxisAngleConstraint(const FPBDJointSettings& JointSettings, const int32 ConstraintIndex, FVec3& ConstraintAxis, FReal& ConstraintAngle)"
  },
  {
    "label": "InitRotationConstraintDatas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitRotationConstraintDatas(const FPBDJointSettings& JointSettings, const int32 ConstraintIndex, const FVec3& ConstraintAxis, const FReal ConstraintAngle, const FReal ConstraintRestitution, const FReal Dt, const bool bCheckLimit)"
  },
  {
    "label": "InitRotationDatasMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitRotationDatasMass(FAxisConstraintDatas& RotationDatas, const int32 ConstraintIndex, const FReal Dt)"
  },
  {
    "label": "InitTwistConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitTwistConstraint(const FPBDJointSettings& JointSettings, const FReal Dt)"
  },
  {
    "label": "InitConeConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitConeConstraint(const FPBDJointSettings& JointSettings, const FReal Dt)"
  },
  {
    "label": "InitPyramidSwingConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitPyramidSwingConstraint(const FPBDJointSettings& JointSettings, const FReal Dt, const bool bApplySwing1, const bool bApplySwing2)"
  },
  {
    "label": "InitSingleLockedSwingConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitSingleLockedSwingConstraint(const FPBDJointSettings& JointSettings, const FReal Dt, const EJointAngularConstraintIndex SwingConstraintIndex)"
  },
  {
    "label": "InitDualConeSwingConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitDualConeSwingConstraint(const FPBDJointSettings& JointSettings, const FReal Dt, const EJointAngularConstraintIndex SwingConstraintIndex)"
  },
  {
    "label": "InitSwingConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitSwingConstraint(const FPBDJointSettings& JointSettings, const FPBDJointSolverSettings& SolverSettings, const FReal Dt, const EJointAngularConstraintIndex SwingConstraintIndex)"
  },
  {
    "label": "InitLockedRotationConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitLockedRotationConstraints(const FPBDJointSettings& JointSettings, const FReal Dt, const bool bApplyTwist, const bool bApplySwing1, const bool bApplySwing2)"
  },
  {
    "label": "ApplyRotationConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRotationConstraints(const FReal Dt)"
  },
  {
    "label": "ApplyRotationConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRotationConstraint(const int32 ConstraintIndex, const FReal Dt)"
  },
  {
    "label": "ApplyRotationSoftConstraintsSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRotationSoftConstraintsSimd(const FReal Dt)"
  },
  {
    "label": "SolveRotationConstraintDelta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolveRotationConstraintDelta(const int32 ConstraintIndex, const FReal DeltaLambda, const bool bIsSoftConstraint, const FAxisConstraintDatas& ConstraintDatas)"
  },
  {
    "label": "SolveRotationConstraintHard()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolveRotationConstraintHard(const int32 ConstraintIndex, const FReal DeltaConstraint)"
  },
  {
    "label": "SolveRotationConstraintSoft()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolveRotationConstraintSoft(const int32 ConstraintIndex, const FReal DeltaConstraint, const FReal Dt, const FReal TargetVel)"
  },
  {
    "label": "ApplyAngularVelocityConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAngularVelocityConstraints()"
  },
  {
    "label": "SolveAngularVelocityConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolveAngularVelocityConstraint(const int32 ConstraintIndex, const FReal TargetVel)"
  },
  {
    "label": "ApplyAngularVelocityConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAngularVelocityConstraint(const int32 ConstraintIndex)"
  },
  {
    "label": "ApplyAngularVelocityConstraintSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAngularVelocityConstraintSimd()"
  },
  {
    "label": "InitPositionDrives()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitPositionDrives(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "InitAxisPositionDrive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitAxisPositionDrive(const int32 ConstraintIndex, const FVec3& ConstraintAxis, const FVec3& DeltaPosition, const FVec3& DeltaVelocity, const FReal Dt)"
  },
  {
    "label": "ApplyPositionDrives()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionDrives(const FReal Dt)"
  },
  {
    "label": "ApplyAxisPositionDrive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAxisPositionDrive(const int32 ConstraintIndex, const FReal Dt)"
  },
  {
    "label": "ApplyPositionVelocityDrives()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionVelocityDrives(const FReal Dt)"
  },
  {
    "label": "ApplyAxisPositionVelocityDrive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAxisPositionVelocityDrive(const int32 ConstraintIndex, const FReal Dt)"
  },
  {
    "label": "InitRotationDrives()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitRotationDrives(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "InitRotationConstraintDrive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitRotationConstraintDrive(const int32 ConstraintIndex, const FVec3& ConstraintAxis, const FReal Dt, const FReal DeltaAngle)"
  },
  {
    "label": "InitRotationConstraintDriveSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitRotationConstraintDriveSimd(FVec3 ConstraintAxes[3], const FRealSingle Dt, const FVec3 DeltaAngles)"
  },
  {
    "label": "InitSwingTwistDrives()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitSwingTwistDrives(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings, const bool bTwistDriveEnabled, const bool bSwing1DriveEnabled, const bool bSwing2DriveEnabled)"
  },
  {
    "label": "InitSLerpDrive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitSLerpDrive(const FReal Dt, const FPBDJointSolverSettings& SolverSettings, const FPBDJointSettings& JointSettings)"
  },
  {
    "label": "ApplyRotationDrives()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRotationDrives(const FReal Dt)"
  },
  {
    "label": "ApplyAxisRotationDrive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAxisRotationDrive(const int32 ConstraintIndex, const FReal Dt)"
  },
  {
    "label": "ApplyRotationDrivesSimd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRotationDrivesSimd(const FReal Dt)"
  },
  {
    "label": "ApplyRotationVelocityDrives()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRotationVelocityDrives(const FReal Dt)"
  },
  {
    "label": "ApplyAxisRotationVelocityDrive()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAxisRotationVelocityDrive(const int32 ConstraintIndex, const FReal Dt)"
  },
  {
    "label": "SetInitConstraintVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetInitConstraintVelocity(const FVec3& ConstraintArm0, const FVec3& ConstraintArm1)"
  },
  {
    "label": "ComputeBodyState()",
    "kind": "Method",
    "detail": "Function (FConstraintSolverBody SolverBodies [ MaxConstrainedBodies ] ; FRigidTransform3 LocalConnectorXs [ MaxConstrainedBodies ] ; FVec3 ConnectorXs [ MaxConstrainedBodies ] ; FRotation3 ConnectorRs [ MaxConstrainedBodies ] ; FVec3 ConnectorWDts [ MaxConstrainedBodies ] ; VectorRegister4Float ConnectorWDtsSimd [ MaxConstrainedBodies ] ; FVec3 InitConnectorXs [ MaxConstrainedBodies ] ; FRotation3 InitConnectorRs [ MaxConstrainedBodies ] ; FVec3 InitConstraintVelocity ; FReal InvMs [ MaxConstrainedBodies ] ; FMatrix33 InvIs [ MaxConstrainedBodies ] ; FReal SolverStiffness ; FReal PositionTolerance ; FReal AngleTolerance ; FVec3 LastDPs [ MaxConstrainedBodies ] ; FVec3 LastDQs [ MaxConstrainedBodies ] ; FVec3 CurrentPs [ MaxConstrainedBodies ] ; FRotation3 CurrentQs [ MaxConstrainedBodies ] ; FVec3 InitConstraintAxisLinearVelocities ; FVec3 InitConstraintAxisAngularVelocities ; int32 NumActiveConstraints ; bool bIsActive ; bool bUsePositionBasedDrives ; FAxisConstraintDatas PositionConstraints ; FAxisConstraintDatas RotationConstraints ; FAxisConstraintDatas PositionDrives ; FAxisConstraintDatas RotationDrives ; bool bIsBroken ; bool bIsViolating ; bool bUseSimd ; int32 PointPositionConstraintIndex = 0 ; int32 SphericalPositionConstraintIndex = 0 ; int32 PlanarPositionConstraintIndex = 0 ; private : void)",
    "insertText": "ComputeBodyState(const int32 BodyIndex)"
  }
]