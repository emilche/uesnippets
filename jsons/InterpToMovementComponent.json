[
  {
    "label": "FHitResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHitResult"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FInterpControlPoint",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FInterpControlPoint"
  },
  {
    "label": "UInterpToMovementComponent",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UInterpToMovementComponent"
  },
  {
    "label": "ELevelTick",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ELevelTick"
  },
  {
    "label": "CheckStillInWorld()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CheckStillInWorld()"
  },
  {
    "label": "StopSimulating()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StopSimulating(const FHitResult& HitResult)"
  },
  {
    "label": "AddControlPointPosition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddControlPointPosition(FVector Pos, bool bPositionIsRelative = true)"
  },
  {
    "label": "RestartMovement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RestartMovement(float InitialDirection = 1.0f)"
  },
  {
    "label": "FinaliseControlPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FinaliseControlPoints()"
  },
  {
    "label": "ResetControlPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetControlPoints()"
  },
  {
    "label": "HandleHitWall()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HandleHitWall(const FHitResult& Hit, float TimeTick, const FVector& MoveDelta)"
  },
  {
    "label": "ReverseDirection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReverseDirection(const FHitResult& Hit, float Time, bool InBroadcastEvent)"
  },
  {
    "label": "stopped()",
    "kind": "Method",
    "detail": "Function (we)",
    "insertText": "stopped(because we hit something, or reached the end of the cycle */\n\tbool bStopped;\n\n\t/* Are there any actor control points in use*/\n\tbool bContainsActorControlPoints;\n\n\t/** Minimum delta time considered when ticking. Delta times below this are not considered. This is a very small non-zero positive value to avoid potential divide-by-zero in simulation code. */\n\tstatic ENGINE_API const float MIN_TICK_TIME;\n\t\n\t/* Update the control points. Adjusts the positions of there are any actor control points as well as updating the spline type */\n\tENGINE_API virtual void UpdateControlPoints(bool InForceUpdate)"
  },
  {
    "label": "CalculateNewTime()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "CalculateNewTime( float TimeNow, float Delta, FHitResult& HitResult, bool InBroadcastEvent, bool& OutStopped, float& OutTimeRemainder )"
  }
]