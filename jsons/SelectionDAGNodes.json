[
  {
    "label": "SelectionDAG",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SelectionDAG"
  },
  {
    "label": "GlobalValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GlobalValue"
  },
  {
    "label": "MachineBasicBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineBasicBlock"
  },
  {
    "label": "MachineConstantPoolValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineConstantPoolValue"
  },
  {
    "label": "SDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SDNode"
  },
  {
    "label": "Value",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Value"
  },
  {
    "label": "MCSymbol",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCSymbol"
  },
  {
    "label": "DenseMapInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DenseMapInfo"
  },
  {
    "label": "simplify_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "simplify_type"
  },
  {
    "label": "ilist_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ilist_traits"
  },
  {
    "label": "SDVTList",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SDVTList"
  },
  {
    "label": "SDValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SDValue"
  },
  {
    "label": "isPodLike",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "isPodLike"
  },
  {
    "label": "SDUse",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SDUse"
  },
  {
    "label": "use_iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "use_iterator"
  },
  {
    "label": "value_op_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "value_op_iterator"
  },
  {
    "label": "SDLoc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SDLoc"
  },
  {
    "label": "SDNodeFlags",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SDNodeFlags"
  },
  {
    "label": "UnarySDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UnarySDNode"
  },
  {
    "label": "BinarySDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BinarySDNode"
  },
  {
    "label": "BinaryWithFlagsSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BinaryWithFlagsSDNode"
  },
  {
    "label": "TernarySDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TernarySDNode"
  },
  {
    "label": "HandleSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HandleSDNode"
  },
  {
    "label": "AddrSpaceCastSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AddrSpaceCastSDNode"
  },
  {
    "label": "MemSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MemSDNode"
  },
  {
    "label": "AtomicSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AtomicSDNode"
  },
  {
    "label": "MemIntrinsicSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MemIntrinsicSDNode"
  },
  {
    "label": "ShuffleVectorSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ShuffleVectorSDNode"
  },
  {
    "label": "ConstantSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstantSDNode"
  },
  {
    "label": "ConstantFPSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstantFPSDNode"
  },
  {
    "label": "GlobalAddressSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GlobalAddressSDNode"
  },
  {
    "label": "FrameIndexSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FrameIndexSDNode"
  },
  {
    "label": "JumpTableSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "JumpTableSDNode"
  },
  {
    "label": "ConstantPoolSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ConstantPoolSDNode"
  },
  {
    "label": "TargetIndexSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetIndexSDNode"
  },
  {
    "label": "BasicBlockSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BasicBlockSDNode"
  },
  {
    "label": "BuildVectorSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BuildVectorSDNode"
  },
  {
    "label": "SrcValueSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SrcValueSDNode"
  },
  {
    "label": "MDNodeSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MDNodeSDNode"
  },
  {
    "label": "RegisterSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RegisterSDNode"
  },
  {
    "label": "RegisterMaskSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RegisterMaskSDNode"
  },
  {
    "label": "BlockAddressSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BlockAddressSDNode"
  },
  {
    "label": "EHLabelSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "EHLabelSDNode"
  },
  {
    "label": "ExternalSymbolSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ExternalSymbolSDNode"
  },
  {
    "label": "MCSymbolSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCSymbolSDNode"
  },
  {
    "label": "CondCodeSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CondCodeSDNode"
  },
  {
    "label": "CvtRndSatSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CvtRndSatSDNode"
  },
  {
    "label": "VTSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "VTSDNode"
  },
  {
    "label": "LSBaseSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LSBaseSDNode"
  },
  {
    "label": "LoadSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LoadSDNode"
  },
  {
    "label": "StoreSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StoreSDNode"
  },
  {
    "label": "MaskedLoadStoreSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaskedLoadStoreSDNode"
  },
  {
    "label": "MaskedLoadSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaskedLoadSDNode"
  },
  {
    "label": "MaskedStoreSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaskedStoreSDNode"
  },
  {
    "label": "MaskedGatherScatterSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaskedGatherScatterSDNode"
  },
  {
    "label": "MaskedGatherSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaskedGatherSDNode"
  },
  {
    "label": "MaskedScatterSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MaskedScatterSDNode"
  },
  {
    "label": "MachineSDNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineSDNode"
  },
  {
    "label": "SDNodeIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SDNodeIterator"
  },
  {
    "label": "GraphTraits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GraphTraits"
  },
  {
    "label": "checkForCycles()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_CODEGEN_SELECTIONDAGNODES_H # define LLVM_CODEGEN_SELECTIONDAGNODES_H # include \" llvm / ADT / BitVector . h \" # include \" llvm / ADT / FoldingSet . h \" # include \" llvm / ADT / GraphTraits . h \" # include \" llvm / ADT / STLExtras . h \" # include \" llvm / ADT / SmallPtrSet . h \" # include \" llvm / ADT / SmallVector . h \" # include \" llvm / ADT / ilist_node . h \" # include \" llvm / ADT / iterator_range . h \" # include \" llvm / CodeGen / ISDOpcodes . h \" # include \" llvm / CodeGen / MachineMemOperand . h \" # include \" llvm / CodeGen / ValueTypes . h \" # include \" llvm / IR / Constants . h \" # include \" llvm / IR / DebugLoc . h \" # include \" llvm / IR / Instructions . h \" # include \" llvm / Support / DataTypes . h \" # include \" llvm / Support / MathExtras . h \" # include<cassert> namespace llvm { class SelectionDAG ; class GlobalValue ; class MachineBasicBlock ; class MachineConstantPoolValue ; class SDNode ; class Value ; class MCSymbol ; template<T> struct DenseMapInfo ; template<T> struct simplify_type ; template<T> struct ilist_traits ; void)",
    "insertText": "checkForCycles(const SDNode *N, const SelectionDAG *DAG = nullptr, bool force = false)"
  },
  {
    "label": "isBuildVectorAllOnes()",
    "kind": "Method",
    "detail": "Function (struct SDVTList { const EVT* VTs ; unsigned int NumVTs ; } ; namespace ISD { bool)",
    "insertText": "isBuildVectorAllOnes(const SDNode *N)"
  },
  {
    "label": "isBuildVectorAllZeros()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isBuildVectorAllZeros(const SDNode *N)"
  },
  {
    "label": "isBuildVectorOfConstantSDNodes()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isBuildVectorOfConstantSDNodes(const SDNode *N)"
  },
  {
    "label": "isBuildVectorOfConstantFPSDNodes()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isBuildVectorOfConstantFPSDNodes(const SDNode *N)"
  },
  {
    "label": "isScalarToVector()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isScalarToVector(const SDNode *N)"
  },
  {
    "label": "allOperandsUndef()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "allOperandsUndef(const SDNode *N)"
  },
  {
    "label": "SDValue()",
    "kind": "Method",
    "detail": "Function (} class SDValue { struct DenseMapInfo<SDValue> ; SDNode* Node ; unsigned ResNo ; public :)",
    "insertText": "SDValue() : Node(nullptr), ResNo(0)"
  },
  {
    "label": "SDValue()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SDValue(SDNode *node, unsigned resno)"
  },
  {
    "label": "getResNo()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getResNo()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Node = N ; } SDNode*)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const SDValue &O)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "isOperandOf()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isOperandOf(const SDNode *N)"
  },
  {
    "label": "getValueType()",
    "kind": "Method",
    "detail": "Function (EVT)",
    "insertText": "getValueType()"
  },
  {
    "label": "getSimpleValueType()",
    "kind": "Method",
    "detail": "Function (MVT)",
    "insertText": "getSimpleValueType()"
  },
  {
    "label": "getValueSizeInBits()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getValueSizeInBits()"
  },
  {
    "label": "getScalarValueSizeInBits()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getScalarValueSizeInBits()"
  },
  {
    "label": "getOpcode()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getOpcode()"
  },
  {
    "label": "getNumOperands()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getNumOperands()"
  },
  {
    "label": "getOperand()",
    "kind": "Method",
    "detail": "Function (const SDValue&)",
    "insertText": "getOperand(unsigned i)"
  },
  {
    "label": "getConstantOperandVal()",
    "kind": "Method",
    "detail": "Function (uint64_t)",
    "insertText": "getConstantOperandVal(unsigned i)"
  },
  {
    "label": "isTargetMemoryOpcode()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isTargetMemoryOpcode()"
  },
  {
    "label": "isTargetOpcode()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isTargetOpcode()"
  },
  {
    "label": "isMachineOpcode()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isMachineOpcode()"
  },
  {
    "label": "getMachineOpcode()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getMachineOpcode()"
  },
  {
    "label": "getDebugLoc()",
    "kind": "Method",
    "detail": "Function (const DebugLoc&)",
    "insertText": "getDebugLoc()"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dump()"
  },
  {
    "label": "dumpr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dumpr()"
  },
  {
    "label": "reachesChainWithoutSideEffects()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "reachesChainWithoutSideEffects(SDValue Dest, unsigned Depth = 2)"
  },
  {
    "label": "use_empty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "use_empty()"
  },
  {
    "label": "hasOneUse()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasOneUse()"
  },
  {
    "label": "getEmptyKey()",
    "kind": "Method",
    "detail": "Function (} ; template<> struct DenseMapInfo<SDValue> { SDValue)",
    "insertText": "getEmptyKey()"
  },
  {
    "label": "getTombstoneKey()",
    "kind": "Method",
    "detail": "Function (SDValue V ; V . ResNo = - 1 U ; return V ; } SDValue)",
    "insertText": "getTombstoneKey()"
  },
  {
    "label": "getHashValue()",
    "kind": "Method",
    "detail": "Function (SDValue V ; V . ResNo = - 2 U ; return V ; } unsigned)",
    "insertText": "getHashValue(const SDValue &Val)"
  },
  {
    "label": "isEqual()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isEqual(const SDValue &LHS, const SDValue &RHS)"
  },
  {
    "label": "getSimplifiedValue()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct simplify_type<const SDValue> { typedef SDNode* SimpleType ; SimpleType)",
    "insertText": "getSimplifiedValue(const SDValue &Val)"
  },
  {
    "label": "SDUse()",
    "kind": "Method",
    "detail": "Function (} } ; class SDUse { SDValue Val ; SDNode* User ; SDUse** Prev,* Next ;)",
    "insertText": "SDUse(const SDUse &U)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const SDUse &U)"
  },
  {
    "label": "SDUse()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "SDUse() : Val(), User(nullptr), Prev(nullptr), Next(nullptr)"
  },
  {
    "label": "SDValue()",
    "kind": "Method",
    "detail": "Function (} operator const)",
    "insertText": "SDValue()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const SDValue &V)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (User = p ; } void)",
    "insertText": "set(const SDValue &V)"
  },
  {
    "label": "setInitial()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setInitial(const SDValue &V)"
  },
  {
    "label": "setNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setNode(SDNode *N)"
  },
  {
    "label": "addToList()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addToList(SDUse **List)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Prev = &Next)",
    "insertText": "if(Next)"
  },
  {
    "label": "removeFromList()",
    "kind": "Method",
    "detail": "Function (Prev = List ;* List = this ; } void)",
    "insertText": "removeFromList()"
  },
  {
    "label": "getSimplifiedValue()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct simplify_type<SDUse> { typedef SDNode* SimpleType ; SimpleType)",
    "insertText": "getSimplifiedValue(SDUse &Val)"
  },
  {
    "label": "getValueTypeList()",
    "kind": "Method",
    "detail": "Function (} } ; class SDNode : public FoldingSetNode,public ilist_node<SDNode> { private : int16_t NodeType ; uint16_t OperandsNeedDelete : 1 ; uint16_t HasDebugValue : 1 ; protected : uint16_t SubclassData : 1 4 ; private : int NodeId ; SDUse* OperandList ; const EVT* ValueList ; SDUse* UseList ; unsigned short NumOperands,NumValues ; unsigned IROrder ; DebugLoc debugLoc ; const EVT*)",
    "insertText": "getValueTypeList(EVT VT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isMachineOpcode() && \"Not a MachineInstr opcode!\")"
  },
  {
    "label": "use_size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "use_size()"
  },
  {
    "label": "getNodeId()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "getNodeId()"
  },
  {
    "label": "getIROrder()",
    "kind": "Method",
    "detail": "Function (NodeId = Id ; } unsigned)",
    "insertText": "getIROrder()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (debugLoc =)",
    "insertText": "move(dl)"
  },
  {
    "label": "use_iterator()",
    "kind": "Method",
    "detail": "Function (} class use_iterator { SDUse* Op ;)",
    "insertText": "use_iterator(SDUse *op) : Op(op)"
  },
  {
    "label": "use_iterator()",
    "kind": "Method",
    "detail": "Function (} class SDNode ; public : using iterator_category = std::forward_iterator_tag ; using value_type = SDUse ; using difference_type = std::ptrdiff_t ; using pointer = value_type* ; using reference = value_type& ;)",
    "insertText": "use_iterator(const use_iterator &I) : Op(I.Op)"
  },
  {
    "label": "use_iterator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "use_iterator() : Op(nullptr)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const use_iterator &x)"
  },
  {
    "label": "atEnd()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "atEnd()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Op && \"Cannot increment end iterator!\")"
  },
  {
    "label": "getNext()",
    "kind": "Method",
    "detail": "Function (Op = Op ->)",
    "insertText": "getNext()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Op && \"Cannot dereference end iterator!\")"
  },
  {
    "label": "getUse()",
    "kind": "Method",
    "detail": "Function (} SDUse&)",
    "insertText": "getUse()"
  },
  {
    "label": "use_begin()",
    "kind": "Method",
    "detail": "Function (} } ; use_iterator)",
    "insertText": "use_begin()"
  },
  {
    "label": "use_end()",
    "kind": "Method",
    "detail": "Function (} use_iterator)",
    "insertText": "use_end()"
  },
  {
    "label": "uses()",
    "kind": "Method",
    "detail": "Function (} iterator_range<use_iterator>)",
    "insertText": "uses()"
  },
  {
    "label": "hasNUsesOfValue()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasNUsesOfValue(unsigned NUses, unsigned Value)"
  },
  {
    "label": "hasAnyUseOfValue()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasAnyUseOfValue(unsigned Value)"
  },
  {
    "label": "isOnlyUserOf()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isOnlyUserOf(const SDNode *N)"
  },
  {
    "label": "isPredecessorOf()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isPredecessorOf(const SDNode *N)"
  },
  {
    "label": "hasPredecessor()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasPredecessor(const SDNode *N)"
  },
  {
    "label": "hasPredecessorHelper()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasPredecessorHelper(const SDNode *N, SmallPtrSetImpl<const SDNode *> &Visited, SmallVectorImpl<const SDNode *> &Worklist)"
  },
  {
    "label": "getOperand()",
    "kind": "Method",
    "detail": "Function (const SDValue&)",
    "insertText": "getOperand(unsigned Num)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Num < NumOperands && \"Invalid child # of SDNode!\")"
  },
  {
    "label": "value_op_iterator()",
    "kind": "Method",
    "detail": "Function (} struct value_op_iterator : iterator_adaptor_base<value_op_iterator,op_iterator,std::random_access_iterator_tag,SDValue,ptrdiff_t,value_op_iterator*,value_op_iterator*> {)",
    "insertText": "value_op_iterator(SDUse *U = nullptr) : iterator_adaptor_base(U)"
  },
  {
    "label": "op_values()",
    "kind": "Method",
    "detail": "Function (} } ; iterator_range<value_op_iterator>)",
    "insertText": "op_values()"
  },
  {
    "label": "getVTList()",
    "kind": "Method",
    "detail": "Function (} SDVTList)",
    "insertText": "getVTList()"
  },
  {
    "label": "getGluedNode()",
    "kind": "Method",
    "detail": "Function (SDVTList X = { ValueList,NumValues } ; return X ; } SDNode*)",
    "insertText": "getGluedNode()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const SDNode* FoundNode = this ;)",
    "insertText": "while(!FoundNode->isMachineOpcode())"
  },
  {
    "label": "getGluedUser()",
    "kind": "Method",
    "detail": "Function (FoundNode = N ; } return FoundNode ; } SDNode*)",
    "insertText": "getGluedUser()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(ResNo < NumValues && \"Illegal result number!\")"
  },
  {
    "label": "getValueSizeInBits()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getValueSizeInBits(unsigned ResNo)"
  },
  {
    "label": "value_begin()",
    "kind": "Method",
    "detail": "Function (} typedef const EVT* value_iterator ; value_iterator)",
    "insertText": "value_begin()"
  },
  {
    "label": "getIndexedModeName()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "getIndexedModeName(ISD::MemIndexedMode AM)"
  },
  {
    "label": "print_types()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print_types(raw_ostream &OS, const SelectionDAG *G)"
  },
  {
    "label": "print_details()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print_details(raw_ostream &OS, const SelectionDAG *G)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "print(raw_ostream &OS, const SelectionDAG *G = nullptr)"
  },
  {
    "label": "printr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printr(raw_ostream &OS, const SelectionDAG *G = nullptr)"
  },
  {
    "label": "printrFull()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printrFull(raw_ostream &O, const SelectionDAG *G = nullptr)"
  },
  {
    "label": "printrWithDepth()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "printrWithDepth(raw_ostream &O, const SelectionDAG *G = nullptr, unsigned depth = 100)"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dump(const SelectionDAG *G)"
  },
  {
    "label": "dumpr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dumpr(const SelectionDAG *G)"
  },
  {
    "label": "dumprFull()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dumprFull(const SelectionDAG *G = nullptr)"
  },
  {
    "label": "dumprWithDepth()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dumprWithDepth(const SelectionDAG *G = nullptr, unsigned depth = 100)"
  },
  {
    "label": "Profile()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Profile(FoldingSetNodeID &ID)"
  },
  {
    "label": "addUse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addUse(SDUse &U)"
  },
  {
    "label": "addToList()",
    "kind": "Method",
    "detail": "Function (U .)",
    "insertText": "addToList(&UseList)"
  },
  {
    "label": "getSDVTList()",
    "kind": "Method",
    "detail": "Function (} protected : SDVTList)",
    "insertText": "getSDVTList(EVT VT)"
  },
  {
    "label": "getValueTypeList()",
    "kind": "Method",
    "detail": "Function (SDVTList Ret = {)",
    "insertText": "getValueTypeList(VT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(debugLoc.hasTrivialDestructor() && \"Expected trivial destructor\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(NumOperands == Ops.size() && \"NumOperands wasn't wide enough for its operands!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(NumValues == VTs.NumVTs && \"NumValues wasn't wide enough for its operands!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(OperandList && \"no operands available\")"
  },
  {
    "label": "setUser()",
    "kind": "Method",
    "detail": "Function (OperandList [ i ] .)",
    "insertText": "setUser(this)"
  },
  {
    "label": "setInitial()",
    "kind": "Method",
    "detail": "Function (OperandList [ i ] .)",
    "insertText": "setInitial(Ops[i])"
  },
  {
    "label": "checkForCycles()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "checkForCycles(this)"
  },
  {
    "label": "SDNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTs) : NodeType(Opc), OperandsNeedDelete(false), HasDebugValue(false), SubclassData(0), NodeId(-1), OperandList(nullptr), ValueList(VTs.VTs), UseList(nullptr), NumOperands(0), NumValues(VTs.NumVTs), IROrder(Order), debugLoc(std::move(dl))"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitOperands(SDUse *Ops, const SDValue &Op0)"
  },
  {
    "label": "setInitial()",
    "kind": "Method",
    "detail": "Function (Ops [ 0 ] .)",
    "insertText": "setInitial(Op0)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitOperands(SDUse *Ops, const SDValue &Op0, const SDValue &Op1)"
  },
  {
    "label": "setInitial()",
    "kind": "Method",
    "detail": "Function (Ops [ 1 ] .)",
    "insertText": "setInitial(Op1)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitOperands(SDUse *Ops, const SDValue &Op0, const SDValue &Op1, const SDValue &Op2)"
  },
  {
    "label": "setInitial()",
    "kind": "Method",
    "detail": "Function (Ops [ 2 ] .)",
    "insertText": "setInitial(Op2)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitOperands(SDUse *Ops, const SDValue &Op0, const SDValue &Op1, const SDValue &Op2, const SDValue &Op3)"
  },
  {
    "label": "setInitial()",
    "kind": "Method",
    "detail": "Function (Ops [ 3 ] .)",
    "insertText": "setInitial(Op3)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitOperands(SDUse *Ops, const SDValue *Vals, unsigned N)"
  },
  {
    "label": "setInitial()",
    "kind": "Method",
    "detail": "Function (Ops [ i ] .)",
    "insertText": "setInitial(Vals[i])"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (} NumOperands = N ;)",
    "insertText": "assert(NumOperands == N && \"NumOperands wasn't wide enough for its operands!\")"
  },
  {
    "label": "DropOperands()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DropOperands()"
  },
  {
    "label": "SDLoc()",
    "kind": "Method",
    "detail": "Function (} ; class SDLoc { private : const void* Ptr ; int IROrder ; public :)",
    "insertText": "SDLoc() : Ptr(nullptr), IROrder(0)"
  },
  {
    "label": "SDLoc()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SDLoc(const SDNode *N) : Ptr(N), IROrder(-1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(N && \"null SDNode\")"
  },
  {
    "label": "SDLoc()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SDLoc(const SDValue V) : Ptr(V.getNode()), IROrder(-1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Ptr && \"null SDNode\")"
  },
  {
    "label": "SDLoc()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SDLoc(const Instruction *I, int Order) : Ptr(I), IROrder(Order)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Order >= 0 && \"bad IROrder\")"
  },
  {
    "label": "N()",
    "kind": "Method",
    "detail": "Function (} const SDNode*)",
    "insertText": "N(const SDNode*)(Ptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(IROrder >= 0)"
  },
  {
    "label": "I()",
    "kind": "Method",
    "detail": "Function (const Instruction*)",
    "insertText": "I(const Instruction*)(Ptr)"
  },
  {
    "label": "SDValue()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "SDValue(SDNode *node, unsigned resno) : Node(node), ResNo(resno)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((!Node || ResNo < Node->getNumValues()) && \"Invalid result number for the given node!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(ResNo < -2U && \"Cannot use result numbers reserved for DenseMaps.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Val = V ;)",
    "insertText": "if(V.getNode()) V.getNode()->addUse(*this)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (Val = V ; V .)",
    "insertText": "getNode()->addUse(*this)"
  },
  {
    "label": "setNode()",
    "kind": "Method",
    "detail": "Function (Val .)",
    "insertText": "setNode(N)"
  },
  {
    "label": "SDNodeFlags()",
    "kind": "Method",
    "detail": "Function (} struct SDNodeFlags { private : bool NoUnsignedWrap : 1 ; bool NoSignedWrap : 1 ; bool Exact : 1 ; bool UnsafeAlgebra : 1 ; bool NoNaNs : 1 ; bool NoInfs : 1 ; bool NoSignedZeros : 1 ; bool AllowReciprocal : 1 ; public :)",
    "insertText": "SDNodeFlags()"
  },
  {
    "label": "setNoUnsignedWrap()",
    "kind": "Method",
    "detail": "Function (NoUnsignedWrap = false ; NoSignedWrap = false ; Exact = false ; UnsafeAlgebra = false ; NoNaNs = false ; NoInfs = false ; NoSignedZeros = false ; AllowReciprocal = false ; } void)",
    "insertText": "setNoUnsignedWrap(bool b)"
  },
  {
    "label": "setNoSignedWrap()",
    "kind": "Method",
    "detail": "Function (NoUnsignedWrap = b ; } void)",
    "insertText": "setNoSignedWrap(bool b)"
  },
  {
    "label": "setExact()",
    "kind": "Method",
    "detail": "Function (NoSignedWrap = b ; } void)",
    "insertText": "setExact(bool b)"
  },
  {
    "label": "setUnsafeAlgebra()",
    "kind": "Method",
    "detail": "Function (Exact = b ; } void)",
    "insertText": "setUnsafeAlgebra(bool b)"
  },
  {
    "label": "setNoNaNs()",
    "kind": "Method",
    "detail": "Function (UnsafeAlgebra = b ; } void)",
    "insertText": "setNoNaNs(bool b)"
  },
  {
    "label": "setNoInfs()",
    "kind": "Method",
    "detail": "Function (NoNaNs = b ; } void)",
    "insertText": "setNoInfs(bool b)"
  },
  {
    "label": "setNoSignedZeros()",
    "kind": "Method",
    "detail": "Function (NoInfs = b ; } void)",
    "insertText": "setNoSignedZeros(bool b)"
  },
  {
    "label": "setAllowReciprocal()",
    "kind": "Method",
    "detail": "Function (NoSignedZeros = b ; } void)",
    "insertText": "setAllowReciprocal(bool b)"
  },
  {
    "label": "hasNoUnsignedWrap()",
    "kind": "Method",
    "detail": "Function (AllowReciprocal = b ; } bool)",
    "insertText": "hasNoUnsignedWrap()"
  },
  {
    "label": "UnarySDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class UnarySDNode : public SDNode { SDUse Op ; public :)",
    "insertText": "UnarySDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTs, SDValue X) : SDNode(Opc, Order, dl, VTs)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitOperands(&Op, X)"
  },
  {
    "label": "BinarySDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class BinarySDNode : public SDNode { SDUse Ops [ 2 ] ; public :)",
    "insertText": "BinarySDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTs, SDValue X, SDValue Y) : SDNode(Opc, Order, dl, VTs)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitOperands(Ops, X, Y)"
  },
  {
    "label": "isBinOpWithFlags()",
    "kind": "Method",
    "detail": "Function (} } ; bool)",
    "insertText": "isBinOpWithFlags(unsigned Opcode)"
  },
  {
    "label": "classof()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "classof(const SDNode *N)"
  },
  {
    "label": "TernarySDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class TernarySDNode : public SDNode { SDUse Ops [ 3 ] ; public :)",
    "insertText": "TernarySDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTs, SDValue X, SDValue Y, SDValue Z) : SDNode(Opc, Order, dl, VTs)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitOperands(Ops, X, Y, Z)"
  },
  {
    "label": "HandleSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class HandleSDNode : public SDNode { SDUse Op ; public :)",
    "insertText": "HandleSDNode(SDValue X) : SDNode(ISD::HANDLENODE, 0, DebugLoc(), getSDVTList(MVT::Other))"
  },
  {
    "label": "HandleSDNode()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "HandleSDNode()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const SDValue&)",
    "insertText": "getValue()"
  },
  {
    "label": "getSrcAddressSpace()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getSrcAddressSpace()"
  },
  {
    "label": "MemSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class MemSDNode : public SDNode { private : EVT MemoryVT ; protected : MachineMemOperand* MMO ; public :)",
    "insertText": "MemSDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTs, EVT MemoryVT, MachineMemOperand *MMO)"
  },
  {
    "label": "MemSDNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MemSDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTs, ArrayRef<SDValue> Ops, EVT MemoryVT, MachineMemOperand *MMO)"
  },
  {
    "label": "readMem()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "readMem()"
  },
  {
    "label": "writeMem()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "writeMem()"
  },
  {
    "label": "getOriginalAlignment()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getOriginalAlignment()"
  },
  {
    "label": "getAlignment()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getAlignment()"
  },
  {
    "label": "getRawSubclassData()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getRawSubclassData()"
  },
  {
    "label": "isNonTemporal()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isNonTemporal()"
  },
  {
    "label": "isInvariant()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isInvariant()"
  },
  {
    "label": "getOrdering()",
    "kind": "Method",
    "detail": "Function (} AtomicOrdering)",
    "insertText": "getOrdering()"
  },
  {
    "label": "getSynchScope()",
    "kind": "Method",
    "detail": "Function (} SynchronizationScope)",
    "insertText": "getSynchScope()"
  },
  {
    "label": "getSrcValueOffset()",
    "kind": "Method",
    "detail": "Function (} int64_t)",
    "insertText": "getSrcValueOffset()"
  },
  {
    "label": "getAAInfo()",
    "kind": "Method",
    "detail": "Function (} AAMDNodes)",
    "insertText": "getAAInfo()"
  },
  {
    "label": "getRanges()",
    "kind": "Method",
    "detail": "Function (} const MDNode*)",
    "insertText": "getRanges()"
  },
  {
    "label": "getMemoryVT()",
    "kind": "Method",
    "detail": "Function (} EVT)",
    "insertText": "getMemoryVT()"
  },
  {
    "label": "getAddressSpace()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getAddressSpace()"
  },
  {
    "label": "refineAlignment()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "refineAlignment(const MachineMemOperand *NewMMO)"
  },
  {
    "label": "refineAlignment()",
    "kind": "Method",
    "detail": "Function (MMO ->)",
    "insertText": "refineAlignment(NewMMO)"
  },
  {
    "label": "getChain()",
    "kind": "Method",
    "detail": "Function (} const SDValue&)",
    "insertText": "getChain()"
  },
  {
    "label": "getBasePtr()",
    "kind": "Method",
    "detail": "Function (} const SDValue&)",
    "insertText": "getBasePtr()"
  },
  {
    "label": "InitAtomic()",
    "kind": "Method",
    "detail": "Function (} } ; class AtomicSDNode : public MemSDNode { SDUse Ops [ 4 ] ; AtomicOrdering FailureOrdering ; void)",
    "insertText": "InitAtomic(AtomicOrdering SuccessOrdering, AtomicOrdering FailureOrdering, SynchronizationScope SynchScope)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((SuccessOrdering & 15) == SuccessOrdering && \"Ordering may not require more than 4 bits!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((FailureOrdering & 15) == FailureOrdering && \"Ordering may not require more than 4 bits!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((SynchScope & 1) == SynchScope && \"SynchScope may not require more than 1 bit!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (SubclassData | = SuccessOrdering<<8 ; SubclassData | = SynchScope<<1 2 ; this -> FailureOrdering = FailureOrdering ;)",
    "insertText": "assert(getSuccessOrdering() == SuccessOrdering && \"Ordering encoding error!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getFailureOrdering() == FailureOrdering && \"Ordering encoding error!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getSynchScope() == SynchScope && \"Synch-scope encoding error!\")"
  },
  {
    "label": "AtomicSDNode()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "AtomicSDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTL, EVT MemVT, SDValue Chain, SDValue Ptr, SDValue Cmp, SDValue Swp, MachineMemOperand *MMO, AtomicOrdering Ordering, SynchronizationScope SynchScope) : MemSDNode(Opc, Order, dl, VTL, MemVT, MMO)"
  },
  {
    "label": "InitAtomic()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitAtomic(Ordering, Ordering, SynchScope)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitOperands(Ops, Chain, Ptr, Cmp, Swp)"
  },
  {
    "label": "AtomicSDNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AtomicSDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTL, EVT MemVT, SDValue Chain, SDValue Ptr, SDValue Val, MachineMemOperand *MMO, AtomicOrdering Ordering, SynchronizationScope SynchScope) : MemSDNode(Opc, Order, dl, VTL, MemVT, MMO)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitOperands(Ops, Chain, Ptr, Val)"
  },
  {
    "label": "AtomicSDNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AtomicSDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTL, EVT MemVT, SDValue Chain, SDValue Ptr, MachineMemOperand *MMO, AtomicOrdering Ordering, SynchronizationScope SynchScope) : MemSDNode(Opc, Order, dl, VTL, MemVT, MMO)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitOperands(Ops, Chain, Ptr)"
  },
  {
    "label": "AtomicSDNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "AtomicSDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTL, EVT MemVT, const SDValue* AllOps, SDUse *DynOps, unsigned NumOps, MachineMemOperand *MMO, AtomicOrdering SuccessOrdering, AtomicOrdering FailureOrdering, SynchronizationScope SynchScope) : MemSDNode(Opc, Order, dl, VTL, MemVT, MMO)"
  },
  {
    "label": "InitAtomic()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitAtomic(SuccessOrdering, FailureOrdering, SynchScope)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((DynOps || NumOps <= array_lengthof(Ops)) && \"Too many ops for internal storage!\")"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitOperands(DynOps ? DynOps : Ops, AllOps, NumOps)"
  },
  {
    "label": "getVal()",
    "kind": "Method",
    "detail": "Function (} const SDValue&)",
    "insertText": "getVal()"
  },
  {
    "label": "getSuccessOrdering()",
    "kind": "Method",
    "detail": "Function (} AtomicOrdering)",
    "insertText": "getSuccessOrdering()"
  },
  {
    "label": "getFailureOrdering()",
    "kind": "Method",
    "detail": "Function (} AtomicOrdering)",
    "insertText": "getFailureOrdering()"
  },
  {
    "label": "MemIntrinsicSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class MemIntrinsicSDNode : public MemSDNode { public :)",
    "insertText": "MemIntrinsicSDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTs, ArrayRef<SDValue> Ops, EVT MemoryVT, MachineMemOperand *MMO) : MemSDNode(Opc, Order, dl, VTs, Ops, MemoryVT, MMO)"
  },
  {
    "label": "ShuffleVectorSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class ShuffleVectorSDNode : public SDNode { SDUse Ops [ 2 ] ; const int* Mask ; protected : class SelectionDAG ;)",
    "insertText": "ShuffleVectorSDNode(EVT VT, unsigned Order, DebugLoc dl, SDValue N1, SDValue N2, const int *M) : SDNode(ISD::VECTOR_SHUFFLE, Order, dl, getSDVTList(VT)), Mask(M)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitOperands(Ops, N1, N2)"
  },
  {
    "label": "getMask()",
    "kind": "Method",
    "detail": "Function (} public : ArrayRef<int>)",
    "insertText": "getMask()"
  },
  {
    "label": "getValueType()",
    "kind": "Method",
    "detail": "Function (EVT VT =)",
    "insertText": "getValueType(0)"
  },
  {
    "label": "getMaskElt()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "getMaskElt(unsigned Idx)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Idx < getValueType(0).getVectorNumElements() && \"Idx out of range!\")"
  },
  {
    "label": "getSplatIndex()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "getSplatIndex()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isSplat() && \"Cannot get splat index for non-splat!\")"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "llvm_unreachable(\"Splat with all undef indices?\")"
  },
  {
    "label": "isSplatMask()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isSplatMask(const int *Mask, EVT VT)"
  },
  {
    "label": "commuteMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "commuteMask(SmallVectorImpl<int> &Mask)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (unsigned NumElems = Mask .)",
    "insertText": "size()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int idx = Mask [ i ] ;)",
    "insertText": "if(idx < 0)"
  },
  {
    "label": "ConstantSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class ConstantSDNode : public SDNode { const ConstantInt* Value ; class SelectionDAG ;)",
    "insertText": "ConstantSDNode(bool isTarget, bool isOpaque, const ConstantInt *val, DebugLoc DL, EVT VT) : SDNode(isTarget ? ISD::TargetConstant : ISD::Constant, 0, DL, getSDVTList(VT)), Value(val)"
  },
  {
    "label": "SubclassData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubclassData(uint16_t)"
  },
  {
    "label": "getConstantIntValue()",
    "kind": "Method",
    "detail": "Function (} public : const ConstantInt*)",
    "insertText": "getConstantIntValue()"
  },
  {
    "label": "getZExtValue()",
    "kind": "Method",
    "detail": "Function (} uint64_t)",
    "insertText": "getZExtValue()"
  },
  {
    "label": "getSExtValue()",
    "kind": "Method",
    "detail": "Function (} int64_t)",
    "insertText": "getSExtValue()"
  },
  {
    "label": "isOne()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isOne()"
  },
  {
    "label": "isNullValue()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isNullValue()"
  },
  {
    "label": "isAllOnesValue()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isAllOnesValue()"
  },
  {
    "label": "isOpaque()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isOpaque()"
  },
  {
    "label": "ConstantFPSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class ConstantFPSDNode : public SDNode { const ConstantFP* Value ; class SelectionDAG ;)",
    "insertText": "ConstantFPSDNode(bool isTarget, const ConstantFP *val, DebugLoc DL, EVT VT) : SDNode(isTarget ? ISD::TargetConstantFP : ISD::ConstantFP, 0, DL, getSDVTList(VT)), Value(val)"
  },
  {
    "label": "getValueAPF()",
    "kind": "Method",
    "detail": "Function (} public : const APFloat&)",
    "insertText": "getValueAPF()"
  },
  {
    "label": "getConstantFPValue()",
    "kind": "Method",
    "detail": "Function (} const ConstantFP*)",
    "insertText": "getConstantFPValue()"
  },
  {
    "label": "isNaN()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isNaN()"
  },
  {
    "label": "isInfinity()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isInfinity()"
  },
  {
    "label": "isNegative()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isNegative()"
  },
  {
    "label": "isExactlyValue()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isExactlyValue(double V)"
  },
  {
    "label": "Tmp()",
    "kind": "Method",
    "detail": "Function (bool ignored ; APFloat)",
    "insertText": "Tmp(V)"
  },
  {
    "label": "convert()",
    "kind": "Method",
    "detail": "Function (Tmp .)",
    "insertText": "convert(Value->getValueAPF().getSemantics(), APFloat::rmNearestTiesToEven, &ignored)"
  },
  {
    "label": "isExactlyValue()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isExactlyValue(const APFloat& V)"
  },
  {
    "label": "isValueValidForType()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isValueValidForType(EVT VT, const APFloat& Val)"
  },
  {
    "label": "GlobalAddressSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class GlobalAddressSDNode : public SDNode { const GlobalValue* TheGlobal ; int64_t Offset ; unsigned char TargetFlags ; class SelectionDAG ;)",
    "insertText": "GlobalAddressSDNode(unsigned Opc, unsigned Order, DebugLoc DL, const GlobalValue *GA, EVT VT, int64_t o, unsigned char TargetFlags)"
  },
  {
    "label": "getGlobal()",
    "kind": "Method",
    "detail": "Function (public : const GlobalValue*)",
    "insertText": "getGlobal()"
  },
  {
    "label": "FrameIndexSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class FrameIndexSDNode : public SDNode { int FI ; class SelectionDAG ;)",
    "insertText": "FrameIndexSDNode(int fi, EVT VT, bool isTarg) : SDNode(isTarg ? ISD::TargetFrameIndex : ISD::FrameIndex, 0, DebugLoc(), getSDVTList(VT)), FI(fi)"
  },
  {
    "label": "getIndex()",
    "kind": "Method",
    "detail": "Function (} public : int)",
    "insertText": "getIndex()"
  },
  {
    "label": "JumpTableSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class JumpTableSDNode : public SDNode { int JTI ; unsigned char TargetFlags ; class SelectionDAG ;)",
    "insertText": "JumpTableSDNode(int jti, EVT VT, bool isTarg, unsigned char TF) : SDNode(isTarg ? ISD::TargetJumpTable : ISD::JumpTable, 0, DebugLoc(), getSDVTList(VT)), JTI(jti), TargetFlags(TF)"
  },
  {
    "label": "ConstantPoolSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class ConstantPoolSDNode : public SDNode { union { const Constant* ConstVal ; MachineConstantPoolValue* MachineCPVal ; } Val ; int Offset ; unsigned Alignment ; unsigned char TargetFlags ; class SelectionDAG ;)",
    "insertText": "ConstantPoolSDNode(bool isTarget, const Constant *c, EVT VT, int o, unsigned Align, unsigned char TF) : SDNode(isTarget ? ISD::TargetConstantPool : ISD::ConstantPool, 0, DebugLoc(), getSDVTList(VT)), Offset(o), Alignment(Align), TargetFlags(TF)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Offset >= 0 && \"Offset is too large\")"
  },
  {
    "label": "ConstantPoolSDNode()",
    "kind": "Method",
    "detail": "Function (Val . ConstVal = c ; })",
    "insertText": "ConstantPoolSDNode(bool isTarget, MachineConstantPoolValue *v, EVT VT, int o, unsigned Align, unsigned char TF) : SDNode(isTarget ? ISD::TargetConstantPool : ISD::ConstantPool, 0, DebugLoc(), getSDVTList(VT)), Offset(o), Alignment(Align), TargetFlags(TF)"
  },
  {
    "label": "Offset()",
    "kind": "Method",
    "detail": "Function (Val . MachineCPVal = v ;)",
    "insertText": "Offset(sizeof(unsigned)*CHAR_BIT-1)"
  },
  {
    "label": "isMachineConstantPoolEntry()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "isMachineConstantPoolEntry()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!isMachineConstantPoolEntry() && \"Wrong constantpool type\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isMachineConstantPoolEntry() && \"Wrong constantpool type\")"
  },
  {
    "label": "TargetIndexSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class TargetIndexSDNode : public SDNode { unsigned char TargetFlags ; int Index ; int64_t Offset ; class SelectionDAG ; public :)",
    "insertText": "TargetIndexSDNode(int Idx, EVT VT, int64_t Ofs, unsigned char TF) : SDNode(ISD::TargetIndex, 0, DebugLoc(), getSDVTList(VT)), TargetFlags(TF), Index(Idx), Offset(Ofs)"
  },
  {
    "label": "getTargetFlags()",
    "kind": "Method",
    "detail": "Function (} public : unsigned char)",
    "insertText": "getTargetFlags()"
  },
  {
    "label": "BasicBlockSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class BasicBlockSDNode : public SDNode { MachineBasicBlock* MBB ; class SelectionDAG ;)",
    "insertText": "BasicBlockSDNode(MachineBasicBlock *mbb) : SDNode(ISD::BasicBlock, 0, DebugLoc(), getSDVTList(MVT::Other)), MBB(mbb)"
  },
  {
    "label": "getBasicBlock()",
    "kind": "Method",
    "detail": "Function (} public : MachineBasicBlock*)",
    "insertText": "getBasicBlock()"
  },
  {
    "label": "BuildVectorSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class BuildVectorSDNode : public SDNode {)",
    "insertText": "BuildVectorSDNode()"
  },
  {
    "label": "isConstantSplat()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "isConstantSplat(APInt &SplatValue, APInt &SplatUndef, unsigned &SplatBitSize, bool &HasAnyUndefs, unsigned MinSplatBits = 0, bool isBigEndian = false)"
  },
  {
    "label": "getSplatValue()",
    "kind": "Method",
    "detail": "Function (SDValue)",
    "insertText": "getSplatValue(BitVector *UndefElements = nullptr)"
  },
  {
    "label": "getConstantSplatNode()",
    "kind": "Method",
    "detail": "Function (ConstantSDNode*)",
    "insertText": "getConstantSplatNode(BitVector *UndefElements = nullptr)"
  },
  {
    "label": "getConstantFPSplatNode()",
    "kind": "Method",
    "detail": "Function (ConstantFPSDNode*)",
    "insertText": "getConstantFPSplatNode(BitVector *UndefElements = nullptr)"
  },
  {
    "label": "isConstant()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isConstant()"
  },
  {
    "label": "SrcValueSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class SrcValueSDNode : public SDNode { const Value* V ; class SelectionDAG ;)",
    "insertText": "SrcValueSDNode(const Value *v) : SDNode(ISD::SRCVALUE, 0, DebugLoc(), getSDVTList(MVT::Other)), V(v)"
  },
  {
    "label": "MDNodeSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class MDNodeSDNode : public SDNode { const MDNode* MD ; class SelectionDAG ;)",
    "insertText": "MDNodeSDNode(const MDNode *md) : SDNode(ISD::MDNODE_SDNODE, 0, DebugLoc(), getSDVTList(MVT::Other)), MD(md)"
  },
  {
    "label": "getMD()",
    "kind": "Method",
    "detail": "Function (} public : const MDNode*)",
    "insertText": "getMD()"
  },
  {
    "label": "RegisterSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class RegisterSDNode : public SDNode { unsigned Reg ; class SelectionDAG ;)",
    "insertText": "RegisterSDNode(unsigned reg, EVT VT) : SDNode(ISD::Register, 0, DebugLoc(), getSDVTList(VT)), Reg(reg)"
  },
  {
    "label": "getReg()",
    "kind": "Method",
    "detail": "Function (} public : unsigned)",
    "insertText": "getReg()"
  },
  {
    "label": "RegisterMaskSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class RegisterMaskSDNode : public SDNode { const uint32_t* RegMask ; class SelectionDAG ;)",
    "insertText": "RegisterMaskSDNode(const uint32_t *mask) : SDNode(ISD::RegisterMask, 0, DebugLoc(), getSDVTList(MVT::Untyped)), RegMask(mask)"
  },
  {
    "label": "getRegMask()",
    "kind": "Method",
    "detail": "Function (} public : const uint32_t*)",
    "insertText": "getRegMask()"
  },
  {
    "label": "BlockAddressSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class BlockAddressSDNode : public SDNode { const BlockAddress* BA ; int64_t Offset ; unsigned char TargetFlags ; class SelectionDAG ;)",
    "insertText": "BlockAddressSDNode(unsigned NodeTy, EVT VT, const BlockAddress *ba, int64_t o, unsigned char Flags) : SDNode(NodeTy, 0, DebugLoc(), getSDVTList(VT)), BA(ba), Offset(o), TargetFlags(Flags)"
  },
  {
    "label": "getBlockAddress()",
    "kind": "Method",
    "detail": "Function (} public : const BlockAddress*)",
    "insertText": "getBlockAddress()"
  },
  {
    "label": "EHLabelSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class EHLabelSDNode : public SDNode { SDUse Chain ; MCSymbol* Label ; class SelectionDAG ;)",
    "insertText": "EHLabelSDNode(unsigned Order, DebugLoc dl, SDValue ch, MCSymbol *L) : SDNode(ISD::EH_LABEL, Order, dl, getSDVTList(MVT::Other)), Label(L)"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitOperands(&Chain, ch)"
  },
  {
    "label": "getLabel()",
    "kind": "Method",
    "detail": "Function (} public : MCSymbol*)",
    "insertText": "getLabel()"
  },
  {
    "label": "ExternalSymbolSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class ExternalSymbolSDNode : public SDNode { const char* Symbol ; unsigned char TargetFlags ; class SelectionDAG ;)",
    "insertText": "ExternalSymbolSDNode(bool isTarget, const char *Sym, unsigned char TF, EVT VT) : SDNode(isTarget ? ISD::TargetExternalSymbol : ISD::ExternalSymbol, 0, DebugLoc(), getSDVTList(VT)), Symbol(Sym), TargetFlags(TF)"
  },
  {
    "label": "getSymbol()",
    "kind": "Method",
    "detail": "Function (} public : const char*)",
    "insertText": "getSymbol()"
  },
  {
    "label": "MCSymbolSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class MCSymbolSDNode : public SDNode { MCSymbol* Symbol ; class SelectionDAG ;)",
    "insertText": "MCSymbolSDNode(MCSymbol *Symbol, EVT VT) : SDNode(ISD::MCSymbol, 0, DebugLoc(), getSDVTList(VT)), Symbol(Symbol)"
  },
  {
    "label": "getMCSymbol()",
    "kind": "Method",
    "detail": "Function (} public : MCSymbol*)",
    "insertText": "getMCSymbol()"
  },
  {
    "label": "CondCodeSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class CondCodeSDNode : public SDNode { ISD::CondCode Condition ; class SelectionDAG ;)",
    "insertText": "CondCodeSDNode(ISD::CondCode Cond) : SDNode(ISD::CONDCODE, 0, DebugLoc(), getSDVTList(MVT::Other)), Condition(Cond)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} public : ISD::CondCode)",
    "insertText": "get()"
  },
  {
    "label": "CvtRndSatSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class CvtRndSatSDNode : public SDNode { ISD::CvtCode CvtCode ; class SelectionDAG ;)",
    "insertText": "CvtRndSatSDNode(EVT VT, unsigned Order, DebugLoc dl, ArrayRef<SDValue> Ops, ISD::CvtCode Code) : SDNode(ISD::CONVERT_RNDSAT, Order, dl, getSDVTList(VT), Ops), CvtCode(Code)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Ops.size() == 5 && \"wrong number of operations\")"
  },
  {
    "label": "getCvtCode()",
    "kind": "Method",
    "detail": "Function (} public : ISD::CvtCode)",
    "insertText": "getCvtCode()"
  },
  {
    "label": "VTSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class VTSDNode : public SDNode { EVT ValueType ; class SelectionDAG ;)",
    "insertText": "VTSDNode(EVT VT) : SDNode(ISD::VALUETYPE, 0, DebugLoc(), getSDVTList(MVT::Other)), ValueType(VT)"
  },
  {
    "label": "getVT()",
    "kind": "Method",
    "detail": "Function (} public : EVT)",
    "insertText": "getVT()"
  },
  {
    "label": "LSBaseSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class LSBaseSDNode : public MemSDNode { SDUse Ops [ 4 ] ; public :)",
    "insertText": "LSBaseSDNode(ISD::NodeType NodeTy, unsigned Order, DebugLoc dl, SDValue *Operands, unsigned numOperands, SDVTList VTs, ISD::MemIndexedMode AM, EVT MemVT, MachineMemOperand *MMO) : MemSDNode(NodeTy, Order, dl, VTs, MemVT, MMO)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (SubclassData | = AM<<2 ;)",
    "insertText": "assert(getAddressingMode() == AM && \"MemIndexedMode encoding error!\")"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitOperands(Ops, Operands, numOperands)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((getOffset().getOpcode() == ISD::UNDEF || isIndexed()) && \"Only indexed loads and stores have a non-undef offset operand\")"
  },
  {
    "label": "getOffset()",
    "kind": "Method",
    "detail": "Function (} const SDValue&)",
    "insertText": "getOffset()"
  },
  {
    "label": "getAddressingMode()",
    "kind": "Method",
    "detail": "Function (} ISD::MemIndexedMode)",
    "insertText": "getAddressingMode()"
  },
  {
    "label": "isIndexed()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isIndexed()"
  },
  {
    "label": "isUnindexed()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isUnindexed()"
  },
  {
    "label": "LoadSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class LoadSDNode : public LSBaseSDNode { class SelectionDAG ;)",
    "insertText": "LoadSDNode(SDValue *ChainPtrOff, unsigned Order, DebugLoc dl, SDVTList VTs, ISD::MemIndexedMode AM, ISD::LoadExtType ETy, EVT MemVT, MachineMemOperand *MMO) : LSBaseSDNode(ISD::LOAD, Order, dl, ChainPtrOff, 3, VTs, AM, MemVT, MMO)"
  },
  {
    "label": "SubclassData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SubclassData(unsigned short)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getExtensionType() == ETy && \"LoadExtType encoding error!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(readMem() && \"Load MachineMemOperand is not a load!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!writeMem() && \"Load MachineMemOperand is a store!\")"
  },
  {
    "label": "getExtensionType()",
    "kind": "Method",
    "detail": "Function (} public : ISD::LoadExtType)",
    "insertText": "getExtensionType()"
  },
  {
    "label": "StoreSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class StoreSDNode : public LSBaseSDNode { class SelectionDAG ;)",
    "insertText": "StoreSDNode(SDValue *ChainValuePtrOff, unsigned Order, DebugLoc dl, SDVTList VTs, ISD::MemIndexedMode AM, bool isTrunc, EVT MemVT, MachineMemOperand *MMO) : LSBaseSDNode(ISD::STORE, Order, dl, ChainValuePtrOff, 4, VTs, AM, MemVT, MMO)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isTruncatingStore() == isTrunc && \"isTrunc encoding error!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!readMem() && \"Store MachineMemOperand is a load!\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(writeMem() && \"Store MachineMemOperand is not a store!\")"
  },
  {
    "label": "isTruncatingStore()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "isTruncatingStore()"
  },
  {
    "label": "MaskedLoadStoreSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class MaskedLoadStoreSDNode : public MemSDNode { SDUse Ops [ 4 ] ; public : class SelectionDAG ;)",
    "insertText": "MaskedLoadStoreSDNode(ISD::NodeType NodeTy, unsigned Order, DebugLoc dl, SDValue *Operands, unsigned numOperands, SDVTList VTs, EVT MemVT, MachineMemOperand *MMO) : MemSDNode(NodeTy, Order, dl, VTs, MemVT, MMO)"
  },
  {
    "label": "MaskedLoadSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class MaskedLoadSDNode : public MaskedLoadStoreSDNode { public : class SelectionDAG ;)",
    "insertText": "MaskedLoadSDNode(unsigned Order, DebugLoc dl, SDValue *Operands, unsigned numOperands, SDVTList VTs, ISD::LoadExtType ETy, EVT MemVT, MachineMemOperand *MMO) : MaskedLoadStoreSDNode(ISD::MLOAD, Order, dl, Operands, numOperands, VTs, MemVT, MMO)"
  },
  {
    "label": "getSrc0()",
    "kind": "Method",
    "detail": "Function (} const SDValue&)",
    "insertText": "getSrc0()"
  },
  {
    "label": "MaskedStoreSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class MaskedStoreSDNode : public MaskedLoadStoreSDNode { public : class SelectionDAG ;)",
    "insertText": "MaskedStoreSDNode(unsigned Order, DebugLoc dl, SDValue *Operands, unsigned numOperands, SDVTList VTs, bool isTrunc, EVT MemVT, MachineMemOperand *MMO) : MaskedLoadStoreSDNode(ISD::MSTORE, Order, dl, Operands, numOperands, VTs, MemVT, MMO)"
  },
  {
    "label": "MaskedGatherScatterSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class MaskedGatherScatterSDNode : public MemSDNode { SDUse Ops [ 5 ] ; public : class SelectionDAG ;)",
    "insertText": "MaskedGatherScatterSDNode(ISD::NodeType NodeTy, unsigned Order, DebugLoc dl, ArrayRef<SDValue> Operands, SDVTList VTs, EVT MemVT, MachineMemOperand *MMO) : MemSDNode(NodeTy, Order, dl, VTs, MemVT, MMO)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Operands.size() == 5 && \"Incompatible number of operands\")"
  },
  {
    "label": "InitOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitOperands(Ops, Operands.data(), Operands.size())"
  },
  {
    "label": "MaskedGatherSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class MaskedGatherSDNode : public MaskedGatherScatterSDNode { public : class SelectionDAG ;)",
    "insertText": "MaskedGatherSDNode(unsigned Order, DebugLoc dl, ArrayRef<SDValue> Operands, SDVTList VTs, EVT MemVT, MachineMemOperand *MMO) : MaskedGatherScatterSDNode(ISD::MGATHER, Order, dl, Operands, VTs, MemVT, MMO)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getValue().getValueType() == getValueType(0) && \"Incompatible type of the PathThru value in MaskedGatherSDNode\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getMask().getValueType().getVectorNumElements() == getValueType(0).getVectorNumElements() && \"Vector width mismatch between mask and data\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getMask().getValueType().getScalarType() == MVT::i1 && \"Vector width mismatch between mask and data\")"
  },
  {
    "label": "MaskedScatterSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class MaskedScatterSDNode : public MaskedGatherScatterSDNode { public : class SelectionDAG ;)",
    "insertText": "MaskedScatterSDNode(unsigned Order, DebugLoc dl,ArrayRef<SDValue> Operands, SDVTList VTs, EVT MemVT, MachineMemOperand *MMO) : MaskedGatherScatterSDNode(ISD::MSCATTER, Order, dl, Operands, VTs, MemVT, MMO)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getMask().getValueType().getVectorNumElements() == getValue().getValueType().getVectorNumElements() && \"Vector width mismatch between mask and data\")"
  },
  {
    "label": "MachineSDNode()",
    "kind": "Method",
    "detail": "Function (} } ; class MachineSDNode : public SDNode { public : typedef MachineMemOperand** mmo_iterator ; private : class SelectionDAG ;)",
    "insertText": "MachineSDNode(unsigned Opc, unsigned Order, const DebugLoc DL, SDVTList VTs) : SDNode(Opc, Order, DL, VTs), MemRefs(nullptr), MemRefsEnd(nullptr)"
  },
  {
    "label": "memoperands_begin()",
    "kind": "Method",
    "detail": "Function (} SDUse LocalOperands [ 4 ] ; mmo_iterator MemRefs ; mmo_iterator MemRefsEnd ; public : mmo_iterator)",
    "insertText": "memoperands_begin()"
  },
  {
    "label": "SDNodeIterator()",
    "kind": "Method",
    "detail": "Function (} } ; class SDNodeIterator { const SDNode* Node ; unsigned Operand ;)",
    "insertText": "SDNodeIterator(const SDNode *N, unsigned Op) : Node(N), Operand(Op)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} public : using iterator_category = std::forward_iterator_tag ; using value_type = SDNode ; using difference_type = std::ptrdiff_t ; using pointer = value_type* ; using reference = value_type& ; bool)",
    "insertText": "operator(const SDNodeIterator& x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (+ + Operand ; return* this ; } SDNodeIterator)",
    "insertText": "operator(int)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (SDNodeIterator tmp =* this ; + +* this ; return tmp ; } size_t)",
    "insertText": "operator(SDNodeIterator Other)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Node == Other.Node && \"Cannot compare iterators of two different nodes!\")"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} SDNodeIterator)",
    "insertText": "end(const SDNode *N)"
  },
  {
    "label": "getOperand()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getOperand()"
  },
  {
    "label": "child_end()",
    "kind": "Method",
    "detail": "Function (} ChildIteratorType)",
    "insertText": "child_end(NodeType *N)"
  },
  {
    "label": "isNormalLoad()",
    "kind": "Method",
    "detail": "Function (} } ; typedef MaskedGatherScatterSDNode LargestSDNode ; typedef GlobalAddressSDNode MostAlignedSDNode ; namespace ISD { bool)",
    "insertText": "isNormalLoad(const SDNode *N)"
  },
  {
    "label": "LoadSDNode()",
    "kind": "Method",
    "detail": "Function (const LoadSDNode* Ld = dyn_cast<)",
    "insertText": "LoadSDNode(N)"
  },
  {
    "label": "isNON_EXTLoad()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isNON_EXTLoad(const SDNode *N)"
  },
  {
    "label": "isEXTLoad()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isEXTLoad(const SDNode *N)"
  },
  {
    "label": "isSEXTLoad()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isSEXTLoad(const SDNode *N)"
  },
  {
    "label": "isZEXTLoad()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isZEXTLoad(const SDNode *N)"
  },
  {
    "label": "isUNINDEXEDLoad()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isUNINDEXEDLoad(const SDNode *N)"
  },
  {
    "label": "isNormalStore()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isNormalStore(const SDNode *N)"
  },
  {
    "label": "StoreSDNode()",
    "kind": "Method",
    "detail": "Function (const StoreSDNode* St = dyn_cast<)",
    "insertText": "StoreSDNode(N)"
  },
  {
    "label": "isNON_TRUNCStore()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isNON_TRUNCStore(const SDNode *N)"
  },
  {
    "label": "isTRUNCStore()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isTRUNCStore(const SDNode *N)"
  },
  {
    "label": "isUNINDEXEDStore()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isUNINDEXEDStore(const SDNode *N)"
  }
]