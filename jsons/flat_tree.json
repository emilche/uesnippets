[
  {
    "label": "sorted_unique_t",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "sorted_unique_t"
  },
  {
    "label": "Iterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Iterator"
  },
  {
    "label": "IsTransparentCompare",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsTransparentCompare"
  },
  {
    "label": "Key",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Key"
  },
  {
    "label": "GetKeyFromValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GetKeyFromValue"
  },
  {
    "label": "KeyCompare",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "KeyCompare"
  },
  {
    "label": "Container",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Container"
  },
  {
    "label": "flat_tree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "flat_tree"
  },
  {
    "label": "value_compare",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "value_compare"
  },
  {
    "label": "InputIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InputIterator"
  },
  {
    "label": "K",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "K"
  },
  {
    "label": "KeyValueCompare",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "KeyValueCompare"
  },
  {
    "label": "V",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "V"
  },
  {
    "label": "sorted_unique_t()",
    "kind": "Method",
    "detail": "Function (# ifndef RTC_BASE_CONTAINERS_FLAT_TREE_H_ # define RTC_BASE_CONTAINERS_FLAT_TREE_H_ # include<algorithm> # include<iterator> # include<type_traits> # include<utility> # include<vector> # include \" absl / algorithm / container . h \" # include \" rtc_base / checks . h \" # include \" rtc_base / system / no_unique_address . h \" namespace webrtc { struct sorted_unique_t {)",
    "insertText": "sorted_unique_t()"
  },
  {
    "label": "is_sorted_and_unique()",
    "kind": "Method",
    "detail": "Function (} ; sorted_unique_t sorted_unique ; namespace flat_containers_internal { template<Range,Comp> bool)",
    "insertText": "is_sorted_and_unique(const Range& range, Comp comp)"
  },
  {
    "label": "ToArrayImpl()",
    "kind": "Method",
    "detail": "Function (} template<class Iterator> using is_multipass = std::is_base_of<std::forward_iterator_tag,std::iterator_traits<Iterator>::iterator_category> ; template<T,= void> struct IsTransparentCompare : std::false_type { } ; template<T> struct IsTransparentCompare<T,std::void_t<T::is_transparent>> : std::true_type { } ; template<U,T,size_t N,size_t . . . I> std::array<U,N>)",
    "insertText": "ToArrayImpl(const T (&data)[N], std::index_sequence<I...>)"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "Assign(T& lhs, T&& rhs)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (lhs =)",
    "insertText": "move(rhs)"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (} template<T,U> void)",
    "insertText": "Assign(std::pair<T, U>& lhs, std::pair<T, U>&& rhs)"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Assign(lhs.first, std::move(rhs.first))"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Assign(lhs.second, std::move(rhs.second))"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (} template<T> void)",
    "insertText": "Swap(T& lhs, T& rhs)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (T tmp =)",
    "insertText": "move(lhs)"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Assign(lhs, std::move(rhs))"
  },
  {
    "label": "Assign()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Assign(rhs, std::move(tmp))"
  },
  {
    "label": "Prev()",
    "kind": "Method",
    "detail": "Function (} template<BidirIt> BidirIt)",
    "insertText": "Prev(BidirIt it)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } template<class Key,class GetKeyFromValue,class KeyCompare,class Container> class flat_tree { public : using key_type = Key ; using key_compare = KeyCompare ; using value_type = Container::value_type ; struct value_compare { bool)",
    "insertText": "operator()(const value_type& left, const value_type& right)"
  },
  {
    "label": "comp()",
    "kind": "Method",
    "detail": "Function (GetKeyFromValue extractor ; return)",
    "insertText": "comp(extractor(left), extractor(right))"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (} RTC_NO_UNIQUE_ADDRESS key_compare comp ; } ; using pointer = Container::pointer ; using const_pointer = Container::const_pointer ; using reference = Container::reference ; using const_reference = Container::const_reference ; using size_type = Container::size_type ; using difference_type = Container::difference_type ; using iterator = Container::iterator ; using const_iterator = Container::const_iterator ; using reverse_iterator = Container::reverse_iterator ; using const_reverse_iterator = Container::const_reverse_iterator ; using container_type = Container ;)",
    "insertText": "flat_tree()"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "flat_tree(const flat_tree&)"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "flat_tree(flat_tree&&)"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "flat_tree(const key_compare& comp)"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (template<class InputIterator>)",
    "insertText": "flat_tree(InputIterator first, InputIterator last, const key_compare& comp = key_compare())"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "flat_tree(const container_type& items, const key_compare& comp = key_compare())"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "flat_tree(container_type&& items, const key_compare& comp = key_compare())"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "flat_tree(std::initializer_list<value_type> ilist, const key_compare& comp = key_compare())"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (template<class InputIterator>)",
    "insertText": "flat_tree(sorted_unique_t, InputIterator first, InputIterator last, const key_compare& comp = key_compare())"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "flat_tree(sorted_unique_t, const container_type& items, const key_compare& comp = key_compare())"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "flat_tree(sorted_unique_t, container_type&& items, const key_compare& comp = key_compare())"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "flat_tree(sorted_unique_t, std::initializer_list<value_type> ilist, const key_compare& comp = key_compare())"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (flat_tree&)",
    "insertText": "operator(const flat_tree&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (flat_tree&)",
    "insertText": "operator(flat_tree&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (flat_tree&)",
    "insertText": "operator(std::initializer_list<value_type> ilist)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reserve(size_type new_capacity)"
  },
  {
    "label": "capacity()",
    "kind": "Method",
    "detail": "Function (size_type)",
    "insertText": "capacity()"
  },
  {
    "label": "shrink_to_fit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "shrink_to_fit()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_type)",
    "insertText": "size()"
  },
  {
    "label": "max_size()",
    "kind": "Method",
    "detail": "Function (size_type)",
    "insertText": "max_size()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "empty()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "begin()"
  },
  {
    "label": "cbegin()",
    "kind": "Method",
    "detail": "Function (const_iterator)",
    "insertText": "cbegin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "end()"
  },
  {
    "label": "cend()",
    "kind": "Method",
    "detail": "Function (const_iterator)",
    "insertText": "cend()"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (reverse_iterator)",
    "insertText": "rbegin()"
  },
  {
    "label": "crbegin()",
    "kind": "Method",
    "detail": "Function (const_reverse_iterator)",
    "insertText": "crbegin()"
  },
  {
    "label": "rend()",
    "kind": "Method",
    "detail": "Function (reverse_iterator)",
    "insertText": "rend()"
  },
  {
    "label": "crend()",
    "kind": "Method",
    "detail": "Function (const_reverse_iterator)",
    "insertText": "crend()"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (std::pair<iterator,bool>)",
    "insertText": "insert(const value_type& val)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (std::pair<iterator,bool>)",
    "insertText": "insert(value_type&& val)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "insert(const_iterator position_hint, const value_type& x)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "insert(const_iterator position_hint, value_type&& x)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (template<class InputIterator> void)",
    "insertText": "insert(InputIterator first, InputIterator last)"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (template<class . . . Args> std::pair<iterator,bool>)",
    "insertText": "emplace(Args&&... args)"
  },
  {
    "label": "emplace_hint()",
    "kind": "Method",
    "detail": "Function (template<class . . . Args> iterator)",
    "insertText": "emplace_hint(const_iterator position_hint, Args&&... args)"
  },
  {
    "label": "extract()",
    "kind": "Method",
    "detail": "Function (container_type)",
    "insertText": "extract()"
  },
  {
    "label": "replace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replace(container_type&& body)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "erase(iterator position)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (template<DummyT = void> iterator)",
    "insertText": "erase(const_iterator position)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "erase(const_iterator first, const_iterator last)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (template<K> size_type)",
    "insertText": "erase(const K& key)"
  },
  {
    "label": "key_comp()",
    "kind": "Method",
    "detail": "Function (key_compare)",
    "insertText": "key_comp()"
  },
  {
    "label": "value_comp()",
    "kind": "Method",
    "detail": "Function (value_compare)",
    "insertText": "value_comp()"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (template<K> size_type)",
    "insertText": "count(const K& key)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (template<K> iterator)",
    "insertText": "find(const K& key)"
  },
  {
    "label": "contains()",
    "kind": "Method",
    "detail": "Function (template<K> bool)",
    "insertText": "contains(const K& key)"
  },
  {
    "label": "equal_range()",
    "kind": "Method",
    "detail": "Function (template<K> std::pair<iterator,iterator>)",
    "insertText": "equal_range(const K& key)"
  },
  {
    "label": "lower_bound()",
    "kind": "Method",
    "detail": "Function (template<K> iterator)",
    "insertText": "lower_bound(const K& key)"
  },
  {
    "label": "upper_bound()",
    "kind": "Method",
    "detail": "Function (template<K> iterator)",
    "insertText": "upper_bound(const K& key)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(flat_tree& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const flat_tree& lhs, const flat_tree& rhs)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "swap(flat_tree& lhs, flat_tree& rhs)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (lhs .)",
    "insertText": "swap(rhs)"
  },
  {
    "label": "unsafe_emplace()",
    "kind": "Method",
    "detail": "Function (} protected : template<class . . . Args> iterator)",
    "insertText": "unsafe_emplace(const_iterator position, Args&&... args)"
  },
  {
    "label": "emplace_key_args()",
    "kind": "Method",
    "detail": "Function (template<class K,class . . . Args> std::pair<iterator,bool>)",
    "insertText": "emplace_key_args(const K& key, Args&&... args)"
  },
  {
    "label": "emplace_hint_key_args()",
    "kind": "Method",
    "detail": "Function (template<class K,class . . . Args> std::pair<iterator,bool>)",
    "insertText": "emplace_hint_key_args(const_iterator hint, const K& key, Args&&... args)"
  },
  {
    "label": "KeyValueCompare()",
    "kind": "Method",
    "detail": "Function (private : struct KeyValueCompare {)",
    "insertText": "KeyValueCompare(const key_compare& comp) : comp_(comp)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,U> bool)",
    "insertText": "operator()(const T& lhs, const U& rhs)"
  },
  {
    "label": "extract_if_value_type()",
    "kind": "Method",
    "detail": "Function (} private : const key_type&)",
    "insertText": "extract_if_value_type(const value_type& v)"
  },
  {
    "label": "extractor()",
    "kind": "Method",
    "detail": "Function (GetKeyFromValue extractor ; return)",
    "insertText": "extractor(v)"
  },
  {
    "label": "extract_if_value_type()",
    "kind": "Method",
    "detail": "Function (} template<K> const K&)",
    "insertText": "extract_if_value_type(const K& k)"
  },
  {
    "label": "distance()",
    "kind": "Method",
    "detail": "Function (auto distance =)",
    "insertText": "distance(cbegin(), c_it)"
  },
  {
    "label": "insert_or_assign()",
    "kind": "Method",
    "detail": "Function (} template<class V> std::pair<iterator,bool>)",
    "insertText": "insert_or_assign(V&& val)"
  },
  {
    "label": "lower_bound()",
    "kind": "Method",
    "detail": "Function (auto position =)",
    "insertText": "lower_bound(GetKeyFromValue()(val))"
  },
  {
    "label": "emplace()",
    "kind": "Method",
    "detail": "Function (body_ .)",
    "insertText": "emplace(position, std::forward<V>(val))"
  },
  {
    "label": "V()",
    "kind": "Method",
    "detail": "Function (* position = std::forward<)",
    "insertText": "V(val)"
  },
  {
    "label": "lower_bound()",
    "kind": "Method",
    "detail": "Function (auto position =)",
    "insertText": "lower_bound(first, last, val, value_comp())"
  },
  {
    "label": "distance()",
    "kind": "Method",
    "detail": "Function (const difference_type distance =)",
    "insertText": "distance(begin(), position)"
  },
  {
    "label": "emplace_back()",
    "kind": "Method",
    "detail": "Function (body_ .)",
    "insertText": "emplace_back(std::forward<V>(val))"
  },
  {
    "label": "sort_and_unique()",
    "kind": "Method",
    "detail": "Function (} return { position,false } ; } void)",
    "insertText": "sort_and_unique(iterator first, iterator last)"
  },
  {
    "label": "stable_sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stable_sort(first, last, value_comp())"
  },
  {
    "label": "not_fn()",
    "kind": "Method",
    "detail": "Function (auto equal_comp =)",
    "insertText": "not_fn(value_comp())"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase(std::unique(first, last, equal_comp), last)"
  },
  {
    "label": "sort_and_unique()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "sort_and_unique()"
  },
  {
    "label": "sort_and_unique()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort_and_unique(begin(), end())"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (} RTC_NO_UNIQUE_ADDRESS key_compare comp_ ; container_type body_ ; template<K> using KeyTypeOrK = std::conditional<IsTransparentCompare<key_compare>::value,K,key_type>::type ; } ; template<class Key,class GetKeyFromValue,class KeyCompare,class Container> flat_tree<Key,GetKeyFromValue,KeyCompare,Container)",
    "insertText": "flat_tree(const KeyCompare& comp) : comp_(comp)"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (} template<class Key,class GetKeyFromValue,class KeyCompare,class Container> template<class InputIterator> flat_tree<Key,GetKeyFromValue,KeyCompare,Container)",
    "insertText": "flat_tree(InputIterator first, InputIterator last, const KeyCompare& comp) : comp_(comp), body_(first, last)"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (} template<class Key,class GetKeyFromValue,class KeyCompare,class Container> flat_tree<Key,GetKeyFromValue,KeyCompare,Container)",
    "insertText": "flat_tree(const container_type& items, const KeyCompare& comp) : comp_(comp), body_(items)"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (} template<class Key,class GetKeyFromValue,class KeyCompare,class Container> flat_tree<Key,GetKeyFromValue,KeyCompare,Container)",
    "insertText": "flat_tree(container_type&& items, const KeyCompare& comp) : comp_(comp), body_(std::move(items))"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (} template<class Key,class GetKeyFromValue,class KeyCompare,class Container> flat_tree<Key,GetKeyFromValue,KeyCompare,Container)",
    "insertText": "flat_tree(std::initializer_list<value_type> ilist, const KeyCompare& comp) : flat_tree(std::begin(ilist), std::end(ilist), comp)"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (} template<class Key,class GetKeyFromValue,class KeyCompare,class Container> template<class InputIterator> flat_tree<Key,GetKeyFromValue,KeyCompare,Container)",
    "insertText": "flat_tree(sorted_unique_t, InputIterator first, InputIterator last, const KeyCompare& comp) : comp_(comp), body_(first, last)"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(is_sorted_and_unique(*this, value_comp()))"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (} template<class Key,class GetKeyFromValue,class KeyCompare,class Container> flat_tree<Key,GetKeyFromValue,KeyCompare,Container)",
    "insertText": "flat_tree(sorted_unique_t, const container_type& items, const KeyCompare& comp) : comp_(comp), body_(items)"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (} template<class Key,class GetKeyFromValue,class KeyCompare,class Container> flat_tree<Key,GetKeyFromValue,KeyCompare,Container)",
    "insertText": "flat_tree(sorted_unique_t, container_type&& items, const KeyCompare& comp) : comp_(comp), body_(std::move(items))"
  },
  {
    "label": "flat_tree()",
    "kind": "Method",
    "detail": "Function (} template<class Key,class GetKeyFromValue,class KeyCompare,class Container> flat_tree<Key,GetKeyFromValue,KeyCompare,Container)",
    "insertText": "flat_tree(sorted_unique_t, std::initializer_list<value_type> ilist, const KeyCompare& comp) : flat_tree(sorted_unique, std::begin(ilist), std::end(ilist), comp)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (body_ .)",
    "insertText": "reserve(new_capacity)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "insert(const_iterator position_hint, const value_type& val)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "insert(const_iterator position_hint, value_type&& val)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(end(), *first)"
  },
  {
    "label": "append_unique()",
    "kind": "Method",
    "detail": "Function (std::pair<iterator,bool> result =)",
    "insertText": "append_unique(begin(), middle(), *first)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (pos_first_new =)",
    "insertText": "min(pos_first_new, std::distance(begin(), result.first))"
  },
  {
    "label": "sort_and_unique()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "sort_and_unique(middle(), end())"
  },
  {
    "label": "inplace_merge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "inplace_merge(std::next(begin(), pos_first_new), middle(), end(), value_comp())"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(is_sorted_and_unique(body, value_comp()))"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (body_ =)",
    "insertText": "move(body)"
  },
  {
    "label": "RTC_CHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_CHECK(position != body_.end())"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (size_type)",
    "insertText": "erase(const K& val)"
  },
  {
    "label": "equal_range()",
    "kind": "Method",
    "detail": "Function (auto eq_range =)",
    "insertText": "equal_range(val)"
  },
  {
    "label": "distance()",
    "kind": "Method",
    "detail": "Function (auto res =)",
    "insertText": "distance(eq_range.first, eq_range.second)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase(eq_range.first, eq_range.second)"
  },
  {
    "label": "equal_range()",
    "kind": "Method",
    "detail": "Function (auto eq_range =)",
    "insertText": "equal_range(key)"
  },
  {
    "label": "lower_bound()",
    "kind": "Method",
    "detail": "Function (auto lower =)",
    "insertText": "lower_bound(key)"
  },
  {
    "label": "as_const()",
    "kind": "Method",
    "detail": "Function (auto res =)",
    "insertText": "as_const(*this).equal_range(key)"
  },
  {
    "label": "comp()",
    "kind": "Method",
    "detail": "Function (KeyValueCompare)",
    "insertText": "comp(comp_)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (lower,lower } ; return { lower,)",
    "insertText": "next(lower)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(*this, other)"
  },
  {
    "label": "unsafe_emplace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "unsafe_emplace(lower, std::forward<Args>(args)...)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!comp(*hint, key))"
  },
  {
    "label": "emplace_key_args()",
    "kind": "Method",
    "detail": "Function (} } return)",
    "insertText": "emplace_key_args(key, std::forward<Args>(args)...)"
  },
  {
    "label": "EraseIf()",
    "kind": "Method",
    "detail": "Function (} template<class Key,class GetKeyFromValue,class KeyCompare,class Container,Predicate> size_t)",
    "insertText": "EraseIf(webrtc::flat_containers_internal:: flat_tree<Key, GetKeyFromValue, KeyCompare, Container>& container, Predicate pred)"
  },
  {
    "label": "remove_if()",
    "kind": "Method",
    "detail": "Function (auto it =)",
    "insertText": "remove_if(container.begin(), container.end(), std::forward<Predicate>(pred))"
  },
  {
    "label": "distance()",
    "kind": "Method",
    "detail": "Function (size_t removed =)",
    "insertText": "distance(it, container.end())"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (container .)",
    "insertText": "erase(it, container.end())"
  }
]