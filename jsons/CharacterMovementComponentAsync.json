[
  {
    "label": "FCharacterMovementComponentAsyncOutput",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCharacterMovementComponentAsyncOutput"
  },
  {
    "label": "FCharacterMovementComponentAsyncInput",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCharacterMovementComponentAsyncInput"
  },
  {
    "label": "EShrinkCapsuleExtent",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EShrinkCapsuleExtent"
  },
  {
    "label": "FFindFloorResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFindFloorResult"
  },
  {
    "label": "FStepDownResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FStepDownResult"
  },
  {
    "label": "FCharacterAsyncOutput",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCharacterAsyncOutput"
  },
  {
    "label": "FUpdatedComponentAsyncOutput",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUpdatedComponentAsyncOutput"
  },
  {
    "label": "FCachedMovementBaseAsyncData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCachedMovementBaseAsyncData"
  },
  {
    "label": "FRootMotionAsyncData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRootMotionAsyncData"
  },
  {
    "label": "FCharacterAsyncInput",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCharacterAsyncInput"
  },
  {
    "label": "FUpdatedComponentAsyncInput",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUpdatedComponentAsyncInput"
  },
  {
    "label": "FCharacterMovementGTInputs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCharacterMovementGTInputs"
  },
  {
    "label": "FHitResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FHitResult"
  },
  {
    "label": "FCollisionShape",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCollisionShape"
  },
  {
    "label": "FCollisionQueryParams",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCollisionQueryParams"
  },
  {
    "label": "FCollisionResponseParams",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCollisionResponseParams"
  },
  {
    "label": "FCharacterMovementComponentAsyncCallback",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCharacterMovementComponentAsyncCallback"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" GameFramework / RootMotionSource . h \" # include \" Chaos / SimCallbackObject . h \" # include \" CollisionQueryParams . h \" # include \" CollisionShape . h \" # include \" Components / SceneComponent . h \" # include \" Engine / OverlapInfo . h \" # include \" CharacterMovementComponentAsync . generated . h \" struct FCharacterMovementComponentAsyncOutput ; struct FCharacterMovementComponentAsyncInput ; enum EShrinkCapsuleExtent { SHRINK_None,SHRINK_RadiusCustom,SHRINK_HeightCustom,SHRINK_AllCustom,} ;)",
    "insertText": "USTRUCT(BlueprintType)"
  },
  {
    "label": "GENERATED_USTRUCT_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_USTRUCT_BODY() UPROPERTY(VisibleInstanceOnly, BlueprintReadOnly, Category = CharacterFloor)"
  },
  {
    "label": "FFindFloorResult()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FFindFloorResult() : bBlockingHit(false) , bWalkableFloor(false) , bLineTrace(false) , FloorDist(0.f) , LineDist(0.f) , HitResult(1.f)"
  },
  {
    "label": "IsWalkableFloor()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsWalkableFloor()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (bBlockingHit = false ; bWalkableFloor = false ; bLineTrace = false ; FloorDist = 0 . f ; LineDist = 0 . f ; HitResult .)",
    "insertText": "Reset(1.f, false)"
  },
  {
    "label": "GetDistanceToFloor()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetDistanceToFloor()"
  },
  {
    "label": "SetFromLineTrace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFromLineTrace(const FHitResult& InHit, const float InSweepFloorDist, const float InLineDist, const bool bIsWalkableFloor)"
  },
  {
    "label": "FStepDownResult()",
    "kind": "Method",
    "detail": "Function (} ; struct FStepDownResult { uint32 bComputedFloor : 1 ; FFindFloorResult FloorResult ;)",
    "insertText": "FStepDownResult() : bComputedFloor(false)"
  },
  {
    "label": "FCharacterAsyncOutput()",
    "kind": "Method",
    "detail": "Function (} } ; struct FCharacterAsyncOutput { ~)",
    "insertText": "FCharacterAsyncOutput()"
  },
  {
    "label": "IndexOfOverlap()",
    "kind": "Method",
    "detail": "Function (} FRotator Rotation ; int32 JumpCurrentCountPreJump ; int32 JumpCurrentCount ; float JumpForceTimeRemaining ; float JumpKeyHoldTime ; bool bWasJumping ; bool bPressedJump ; bool bClearJumpInput ; } ; struct FUpdatedComponentAsyncOutput { TArray<FOverlapInfo> SpeculativeOverlaps ; int32)",
    "insertText": "IndexOfOverlap(const FOverlapInfo& SearchItem)"
  },
  {
    "label": "AddUniqueSpeculativeOverlap()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddUniqueSpeculativeOverlap(const FOverlapInfo& NewOverlap)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (SpeculativeOverlaps .)",
    "insertText": "Add(NewOverlap)"
  },
  {
    "label": "FCharacterMovementComponentAsyncOutput()",
    "kind": "Method",
    "detail": "Function (} } } ; struct FCharacterMovementComponentAsyncOutput : public Chaos::FSimCallbackOutput { using FCharacterOutput = FCharacterAsyncOutput ;)",
    "insertText": "FCharacterMovementComponentAsyncOutput() : FSimCallbackOutput() , bIsValid(false)"
  },
  {
    "label": "FCharacterOutput()",
    "kind": "Method",
    "detail": "Function (CharacterOutput = MakeUnique<)",
    "insertText": "FCharacterOutput()"
  },
  {
    "label": "FCharacterMovementComponentAsyncOutput()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FCharacterMovementComponentAsyncOutput(TUniquePtr<FCharacterOutput>&& InCharacterOutput) : FSimCallbackOutput() , CharacterOutput(MoveTemp(InCharacterOutput)) , bIsValid(false)"
  },
  {
    "label": "FCharacterMovementComponentAsyncOutput()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FCharacterMovementComponentAsyncOutput()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} public : void)",
    "insertText": "Reset()"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (bIsValid = false ; } void)",
    "insertText": "Copy(const FCharacterMovementComponentAsyncOutput& Value)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "GetAxisDeltaRotation()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetAxisDeltaRotation(float InAxisRotationRate, float InDeltaTime)"
  },
  {
    "label": "Validate()",
    "kind": "Method",
    "detail": "Function (bool bWasSimulatingRootMotion ; EMovementMode MovementMode ; EMovementMode GroundMovementMode ; uint8 CustomMovementMode ; FVector Acceleration ; float AnalogInputModifier ; FVector LastUpdateLocation ; FQuat LastUpdateRotation ; FVector LastUpdateVelocity ; bool bForceNextFloorCheck ; FVector Velocity ; FVector LastPreAdditiveVelocity ; bool bIsAdditiveVelocityApplied ; bool bDeferUpdateBasedMovement ; EMoveComponentFlags MoveComponentFlags ; FVector PendingForceToApply ; FVector PendingImpulseToApply ; FVector PendingLaunchVelocity ; bool bCrouchMaintainsBaseLocation ; bool bJustTeleported ; float ScaledCapsuleRadius ; float ScaledCapsuleHalfHeight ; bool bIsCrouched ; bool bWantsToCrouch ; bool bMovementInProgress ; FFindFloorResult CurrentFloor ; bool bHasRequestedVelocity ; bool bRequestedMoveWithMaxSpeed ; FVector RequestedVelocity ; FVector LastUpdateRequestedVelocity ; int32 NumJumpApexAttempts ; FVector AnimRootMotionVelocity ; bool bShouldApplyDeltaToMeshPhysicsTransforms ; FVector DeltaPosition ; FQuat DeltaQuat ; float DeltaTime ; FVector OldVelocity ; FVector OldLocation ; FRotator ModifiedRotationRate ; bool bUsingModifiedRotationRate = false ; bool bShouldDisablePostPhysicsTick ; bool bShouldEnablePostPhysicsTick ; bool bShouldAddMovementBaseTickDependency ; bool bShouldRemoveMovementBaseTickDependency ; UPrimitiveComponent* NewMovementBase ; AActor* NewMovementBaseOwner ; FUpdatedComponentAsyncOutput UpdatedComponentOutput ; TUniquePtr<FCharacterAsyncOutput> CharacterOutput ; bool bIsValid ; } ; struct FCachedMovementBaseAsyncData { UPrimitiveComponent* CachedMovementBase ; bool bMovementBaseUsesRelativeLocationCached ; bool bMovementBaseIsSimulatedCached ; bool bMovementBaseIsValidCached ; bool bMovementBaseOwnerIsValidCached ; bool bMovementBaseIsDynamicCached ; bool bIsBaseTransformValid ; FQuat BaseQuat ; FVector BaseLocation ; FQuat OldBaseQuat ; FVector OldBaseLocation ; void)",
    "insertText": "Validate(const FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (} } ; struct FRootMotionAsyncData { bool bHasAnimRootMotion ; bool bHasOverrideRootMotion ; bool bHasOverrideWithIgnoreZAccumulate ; bool bHasAdditiveRootMotion ; bool bUseSensitiveLiftoff ; FVector AdditiveVelocity ; FVector OverrideVelocity ; FQuat OverrideRotation ; FTransform AnimTransform ; float TimeAccumulated ; void)",
    "insertText": "Clear()"
  },
  {
    "label": "FRootMotionAsyncData()",
    "kind": "Method",
    "detail": "Function (TimeAccumulated = 0 . f ; bHasAnimRootMotion = false ; bHasOverrideRootMotion = false ; bHasOverrideWithIgnoreZAccumulate = false ; bHasAdditiveRootMotion = false ; bUseSensitiveLiftoff = false ; AdditiveVelocity = FVector::ZeroVector ; OverrideVelocity = FVector::ZeroVector ; OverrideRotation = FQuat::Identity ; AnimTransform = FTransform::Identity ; })",
    "insertText": "FRootMotionAsyncData()"
  },
  {
    "label": "FCharacterAsyncInput()",
    "kind": "Method",
    "detail": "Function (} } ; struct FCharacterAsyncInput { ~)",
    "insertText": "FCharacterAsyncInput()"
  },
  {
    "label": "FaceRotation()",
    "kind": "Method",
    "detail": "Function (} float JumpMaxHoldTime ; int32 JumpMaxCount ; ENetRole LocalRole ; ENetRole RemoteRole ; bool bIsLocallyControlled ; bool bIsPlayingNetworkedRootMontage ; bool bUseControllerRotationPitch ; bool bUseControllerRotationYaw ; bool bUseControllerRotationRoll ; FRotator ControllerDesiredRotation ; void)",
    "insertText": "FaceRotation(FRotator NewControlRotation, float DeltaTime, const FCharacterMovementComponentAsyncInput& Input, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "CheckJumpInput()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckJumpInput(float DeltaSeconds, const FCharacterMovementComponentAsyncInput& Input, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ClearJumpInput()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearJumpInput(float DeltaSeconds, const FCharacterMovementComponentAsyncInput& Input, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "CanJump()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanJump(const FCharacterMovementComponentAsyncInput& Input, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ResetJumpState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetJumpState(const FCharacterMovementComponentAsyncInput& Input, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "OnMovementModeChanged()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnMovementModeChanged(EMovementMode PrevMovementMode, const FCharacterMovementComponentAsyncInput& Input, FCharacterMovementComponentAsyncOutput& Output, uint8 PreviousCustomMode = 0)"
  },
  {
    "label": "FUpdatedComponentAsyncInput()",
    "kind": "Method",
    "detail": "Function (} ; struct FUpdatedComponentAsyncInput { ~)",
    "insertText": "FUpdatedComponentAsyncInput()"
  },
  {
    "label": "MoveComponent()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "MoveComponent(const FVector& Delta, const FQuat& NewRotationQuat, bool bSweep, FHitResult* OutHit, EMoveComponentFlags MoveFlags, ETeleportType Teleport, const FCharacterMovementComponentAsyncInput& Input, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "AreSymmetricRotations()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "AreSymmetricRotations(const FQuat& A, const FQuat& B, const FVector& Scale3D)"
  },
  {
    "label": "PullBackHit()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PullBackHit(FHitResult& Hit, const FVector& Start, const FVector& End, const float Dist)"
  },
  {
    "label": "ShouldCheckOverlapFlagToQueueOverlaps()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldCheckOverlapFlagToQueueOverlaps(const UPrimitiveComponent& ThisComponent)"
  },
  {
    "label": "ShouldIgnoreHitResult()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldIgnoreHitResult(const UWorld* InWorld, FHitResult const& TestHit, FVector const& MovementDirDenormalized, const AActor* MovingActor, EMoveComponentFlags MoveFlags)"
  },
  {
    "label": "ShouldIgnoreOverlapResult()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldIgnoreOverlapResult(const UWorld* World, const AActor* ThisActor, const UPrimitiveComponent& ThisComponent, const AActor* OtherActor, const UPrimitiveComponent& OtherComponent)"
  },
  {
    "label": "GetForwardVector()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetForwardVector()"
  },
  {
    "label": "GetRightVector()",
    "kind": "Method",
    "detail": "Function (} FVector)",
    "insertText": "GetRightVector()"
  },
  {
    "label": "GetUpVector()",
    "kind": "Method",
    "detail": "Function (} FVector)",
    "insertText": "GetUpVector()"
  },
  {
    "label": "SetPosition()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetPosition(const FVector& Position)"
  },
  {
    "label": "GetPosition()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetPosition()"
  },
  {
    "label": "SetRotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetRotation(const FQuat& Rotation)"
  },
  {
    "label": "GetRotation()",
    "kind": "Method",
    "detail": "Function (FQuat)",
    "insertText": "GetRotation()"
  },
  {
    "label": "UpdateOutput()",
    "kind": "Method",
    "detail": "Function (bool bIsQueryCollisionEnabled ; bool bIsSimulatingPhysics ; FComponentQueryParams MoveComponentQueryParams ; FCollisionResponseParams MoveComponentCollisionResponseParams ; UPrimitiveComponent* UpdatedComponent ; FPhysicsActorHandle PhysicsHandle ; FCollisionShape CollisionShape ; bool bForceGatherOverlaps ; bool bGatherOverlaps ; FVector Scale ; } ; struct FCharacterMovementGTInputs { bool bWantsToCrouch ; bool bValidMovementMode ; EMovementMode MovementMode ; bool bPressedJump ; void)",
    "insertText": "UpdateOutput(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Output . bWantsToCrouch = bWantsToCrouch ;)",
    "insertText": "if(bValidMovementMode)"
  },
  {
    "label": "FCharacterMovementComponentAsyncInput()",
    "kind": "Method",
    "detail": "Function (Output . MovementMode = MovementMode ; } Output . CharacterOutput -> bPressedJump = bPressedJump ; } } ; struct FCharacterMovementComponentAsyncInput : public Chaos::FSimCallbackInput { using FCharacterInput = FCharacterAsyncInput ; using FUpdatedComponentInput = FUpdatedComponentAsyncInput ; bool bInitialized = false ; FVector InputVector ; ENetworkSmoothingMode NetworkSmoothingMode ; bool bIsNetModeClient ; bool bWasSimulatingRootMotion ; bool bRunPhysicsWithNoController ; bool bForceMaxAccel ; float MaxAcceleration ; float MinAnalogWalkSpeed ; bool bIgnoreBaseRotation ; bool bOrientRotationToMovement ; bool bUseControllerDesiredRotation ; bool bConstrainToPlane ; FVector PlaneConstraintOrigin ; FVector PlaneConstraintNormal ; bool bHasValidData ; float MaxStepHeight ; bool bAlwaysCheckFloor ; float WalkableFloorZ ; bool bUseFlatBaseForFloorChecks ; float GravityZ ; bool bCanEverCrouch ; int32 MaxSimulationIterations ; float MaxSimulationTimeStep ; bool bMaintainHorizontalGroundVelocity ; bool bUseSeparateBrakingFriction ; float GroundFriction ; float BrakingFrictionFactor ; float BrakingFriction ; float BrakingSubStepTime ; float BrakingDecelerationWalking ; float BrakingDecelerationFalling ; float BrakingDecelerationSwimming ; float BrakingDecelerationFlying ; float MaxDepenetrationWithGeometryAsProxy ; float MaxDepenetrationWithGeometry ; float MaxDepenetrationWithPawn ; float MaxDepenetrationWithPawnAsProxy ; bool bCanWalkOffLedgesWhenCrouching ; bool bCanWalkOffLedges ; float LedgeCheckThreshold ; float PerchRadiusThreshold ; float AirControl ; float AirControlBoostMultiplier ; float AirControlBoostVelocityThreshold ; bool bDontFallBelowJumpZVelocityDuringJump ; bool bApplyGravityWhileJumping ; float PhysicsVolumeTerminalVelocity ; int32 MaxJumpApexAttemptsPerSimulation ; EMovementMode DefaultLandMovementMode ; float FallingLateralFriction ; float JumpZVelocity ; bool bAllowPhysicsRotationDuringAnimRootMotion ; bool bDeferUpdateMoveComponent ; bool bRequestedMoveUseAcceleration ; float PerchAdditionalHeight ; bool bNavAgentPropsCanJump ; bool bMovementStateCanJump ; float MaxWalkSpeedCrouched ; float MaxWalkSpeed ; float MaxSwimSpeed ; float MaxFlySpeed ; float MaxCustomMovementSpeed ; FRotator RotationRate ; FRootMotionAsyncData RootMotion ; FCachedMovementBaseAsyncData MovementBaseAsyncData ; TUniquePtr<FUpdatedComponentAsyncInput> UpdatedComponentInput ; TUniquePtr<FCharacterAsyncInput> CharacterInput ; UWorld* World ; FComponentQueryParams QueryParams ; FCollisionResponseParams CollisionResponseParams ; ECollisionChannel CollisionChannel ; FCollisionQueryParams CapsuleParams ; FRandomStream RandomStream ; TSharedPtr<FCharacterMovementComponentAsyncOutput,ESPMode::ThreadSafe> AsyncSimState ; FCharacterMovementGTInputs GTInputs ; ~)",
    "insertText": "FCharacterMovementComponentAsyncInput()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} template<FCharacterInput,FUpdatedComponentInput> void)",
    "insertText": "Initialize()"
  },
  {
    "label": "FCharacterInput()",
    "kind": "Method",
    "detail": "Function (CharacterInput = MakeUnique<)",
    "insertText": "FCharacterInput()"
  },
  {
    "label": "FUpdatedComponentInput()",
    "kind": "Method",
    "detail": "Function (UpdatedComponentInput = MakeUnique<)",
    "insertText": "FUpdatedComponentInput()"
  },
  {
    "label": "UpdateAsyncStateFromGTInputs_Internal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UpdateAsyncStateFromGTInputs_Internal()"
  },
  {
    "label": "UpdateOutput()",
    "kind": "Method",
    "detail": "Function (GTInputs .)",
    "insertText": "UpdateOutput(*AsyncSimState)"
  },
  {
    "label": "Simulate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Simulate(const float DeltaSeconds, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ControlledCharacterMove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ControlledCharacterMove(const float DeltaSeconds, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "PerformMovement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PerformMovement(float DeltaSeconds, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "MaybeUpdateBasedMovement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeUpdateBasedMovement(float DeltaSeconds, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "UpdateBasedMovement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateBasedMovement(float DeltaSeconds, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "StartNewPhysics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartNewPhysics(float deltaTime, int32 Iterations, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "PhysWalking()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PhysWalking(float deltaTime, int32 Iterations, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "PhysFalling()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PhysFalling(float deltaTime, int32 Iterations, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "PhysicsRotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PhysicsRotation(float DeltaTime, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "MoveAlongFloor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MoveAlongFloor(const FVector& InVelocity, float DeltaSeconds, FStepDownResult* OutStepDownResult, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ComputeGroundMovementDelta()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "ComputeGroundMovementDelta(const FVector& Delta, const FHitResult& RampHit, const bool bHitFromLineTrace, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "CanCrouchInCurrentState()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanCrouchInCurrentState(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ConstrainInputAcceleration()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "ConstrainInputAcceleration(FVector InputAcceleration, const FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ScaleInputAcceleration()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "ScaleInputAcceleration(FVector InputAcceleration, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ComputeAnalogInputModifier()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "ComputeAnalogInputModifier(FVector Acceleration)"
  },
  {
    "label": "ConstrainLocationToPlane()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "ConstrainLocationToPlane(FVector Location)"
  },
  {
    "label": "ConstrainDirectionToPlane()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "ConstrainDirectionToPlane(FVector Direction)"
  },
  {
    "label": "ConstrainNormalToPlane()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "ConstrainNormalToPlane(FVector Normal)"
  },
  {
    "label": "MaintainHorizontalGroundVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaintainHorizontalGroundVelocity(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "MoveUpdatedComponent()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "MoveUpdatedComponent(const FVector& Delta, const FQuat& NewRotation, bool bSweep, FCharacterMovementComponentAsyncOutput& Output, FHitResult* OutHitResult = nullptr, ETeleportType TeleportType = ETeleportType::None)"
  },
  {
    "label": "SafeMoveUpdatedComponent()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "SafeMoveUpdatedComponent(const FVector& Delta, const FQuat& NewRotation, bool bSweep, FHitResult& OutHit, FCharacterMovementComponentAsyncOutput& Output, ETeleportType Teleport = ETeleportType::None)"
  },
  {
    "label": "ApplyAccumulatedForces()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyAccumulatedForces(float DeltaSeconds, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ClearAccumulatedForces()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearAccumulatedForces(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "SetMovementMode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetMovementMode(EMovementMode NewMovementMode, FCharacterMovementComponentAsyncOutput& Output, uint8 NewCustomMode = 0)"
  },
  {
    "label": "OnMovementModeChanged()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnMovementModeChanged(EMovementMode PreviousMovementMode, uint8 PreviousCustomMode, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "FindFloor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FindFloor(const FVector& CapsuleLocation, FFindFloorResult& OutFloorResult, bool bCanUseCachedLocation, FCharacterMovementComponentAsyncOutput& Output, const FHitResult* DownwardSweepResult = nullptr)"
  },
  {
    "label": "ComputeFloorDist()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeFloorDist(const FVector& CapsuleLocation, float LineDistance, float SweepDistance, FFindFloorResult& OutFloorResult, float SweepRadius, FCharacterMovementComponentAsyncOutput& Output, const FHitResult* DownwardSweepResult = nullptr)"
  },
  {
    "label": "FloorSweepTest()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "FloorSweepTest(struct FHitResult& OutHit, const FVector& Start, const FVector& End, ECollisionChannel TraceChannel, const struct FCollisionShape& CollisionShape, const struct FCollisionQueryParams& Params, const struct FCollisionResponseParams& ResponseParam, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "IsWithinEdgeTolerance()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsWithinEdgeTolerance(const FVector& CapsuleLocation, const FVector& TestImpactPoint, const float CapsuleRadius)"
  },
  {
    "label": "IsWalkable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsWalkable(const FHitResult& Hit)"
  },
  {
    "label": "UpdateCharacterStateAfterMovement()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateCharacterStateAfterMovement(float DeltaSeconds, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "GetSimulationTimeStep()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetSimulationTimeStep(float RemainingTime, int32 Iterations)"
  },
  {
    "label": "CalcVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ApplyRequestedMove()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ApplyRequestedMove(float DeltaTime, float MaxAccel, float MaxSpeed, float Friction, float BrakingDeceleration, FVector& OutAcceleration, float& OutRequestedSpeed, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ShouldComputeAccelerationToReachRequestedVelocity()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldComputeAccelerationToReachRequestedVelocity(const float RequestedSpeed, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "GetMinAnalogSpeed()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetMinAnalogSpeed(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "GetMaxBrakingDeceleration()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetMaxBrakingDeceleration(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ApplyVelocityBraking()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyVelocityBraking(float DeltaTime, float Friction, float BrakingDeceleration, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "GetPenetrationAdjustment()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetPenetrationAdjustment(FHitResult& HitResult)"
  },
  {
    "label": "ResolvePenetration()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ResolvePenetration(const FVector& Adjustment, const FHitResult& Hit, const FQuat& NewRotation, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "HandleImpact()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleImpact(const FHitResult& Impact, FCharacterMovementComponentAsyncOutput& Output, float TimeSlice = 0.0f, const FVector& MoveDelta = FVector::ZeroVector)"
  },
  {
    "label": "SlideAlongSurface()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "SlideAlongSurface(const FVector& Delta, float Time, const FVector& InNormal, FHitResult& Hit, bool bHandleImpact, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ComputeSlideVector()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "ComputeSlideVector(const FVector& Delta, const float Time, const FVector& Normal, const FHitResult& Hit, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "HandleSlopeBoosting()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "HandleSlopeBoosting(const FVector& SlideResult, const FVector& Delta, const float Time, const FVector& Normal, const FHitResult& Hit, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "OnCharacterStuckInGeometry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnCharacterStuckInGeometry(const FHitResult* Hit, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "CanStepUp()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanStepUp(const FHitResult& Hit, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "StepUp()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "StepUp(const FVector& GravDir, const FVector& Delta, const FHitResult& Hit, FCharacterMovementComponentAsyncOutput& Output, FStepDownResult* OutStepDownResult = nullptr)"
  },
  {
    "label": "CanWalkOffLedges()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanWalkOffLedges(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "GetLedgeMove()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetLedgeMove(const FVector& OldLocation, const FVector& Delta, const FVector& GravDir, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "CheckLedgeDirection()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CheckLedgeDirection(const FVector& OldLocation, const FVector& SideStep, const FVector& GravDir, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "GetPawnCapsuleExtent()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetPawnCapsuleExtent(const EShrinkCapsuleExtent ShrinkMode, const float CustomShrinkAmount, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "GetPawnCapsuleCollisionShape()",
    "kind": "Method",
    "detail": "Function (FCollisionShape)",
    "insertText": "GetPawnCapsuleCollisionShape(const EShrinkCapsuleExtent ShrinkMode, FCharacterMovementComponentAsyncOutput& Output, const float CustomShrinkAmount = 0.0f)"
  },
  {
    "label": "TwoWallAdjust()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TwoWallAdjust(FVector& OutDelta, const FHitResult& Hit, const FVector& OldHitNormal, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "RevertMove()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RevertMove(const FVector& OldLocation, UPrimitiveComponent* OldBase, const FVector& PreviousBaseLocation, const FFindFloorResult& OldFloor, bool bFailMove, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "GetTeleportType()",
    "kind": "Method",
    "detail": "Function (ETeleportType)",
    "insertText": "GetTeleportType(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "HandleWalkingOffLedge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "HandleWalkingOffLedge(const FVector& PreviousFloorImpactNormal, const FVector& PreviousFloorContactNormal, const FVector& PreviousLocation, float TimeDelta)"
  },
  {
    "label": "ShouldCatchAir()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldCatchAir(const FFindFloorResult& OldFloor, const FFindFloorResult& NewFloor)"
  },
  {
    "label": "StartFalling()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StartFalling(int32 Iterations, float remainingTime, float timeTick, const FVector& Delta, const FVector& subLoc, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "AdjustFloorHeight()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AdjustFloorHeight(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "SetBaseFromFloor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetBaseFromFloor(const FFindFloorResult& FloorResult, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ShouldComputePerchResult()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldComputePerchResult(const FHitResult& InHit, FCharacterMovementComponentAsyncOutput& Output, bool bCheckRadius = true)"
  },
  {
    "label": "ComputePerchResult()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ComputePerchResult(const float TestRadius, const FHitResult& InHit, const float InMaxFloorDist, FFindFloorResult& OutPerchFloorResult, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "GetPerchRadiusThreshold()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetPerchRadiusThreshold()"
  },
  {
    "label": "GetValidPerchRadius()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetValidPerchRadius(const FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "CheckFall()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CheckFall(const FFindFloorResult& OldFloor, const FHitResult& Hit, const FVector& Delta, const FVector& OldLocation, float remainingTime, float timeTick, int32 Iterations, bool bMustJump, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "GetFallingLateralAcceleration()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetFallingLateralAcceleration(float DeltaTime, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "GetAirControl()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "GetAirControl(float DeltaTime, float TickAirControl, const FVector& FallAcceleration, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "BoostAirControl()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "BoostAirControl(float DeltaTime, float TickAirControl, const FVector& FallAcceleration, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ShouldLimitAirControl()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldLimitAirControl(float DeltaTime, const FVector& FallAcceleration, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "LimitAirControl()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "LimitAirControl(float DeltaTime, const FVector& FallAcceleration, const FHitResult& HitResult, bool bCheckForValidLandingSpot, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "RestorePreAdditiveRootMotionVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RestorePreAdditiveRootMotionVelocity(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ApplyRootMotionToVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyRootMotionToVelocity(float deltaTime, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "NewFallVelocity()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "NewFallVelocity(const FVector& InitialVelocity, const FVector& Gravity, float DeltaTime, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "IsValidLandingSpot()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValidLandingSpot(const FVector& CapsuleLocation, const FHitResult& Hit, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ProcessLanded()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ProcessLanded(const FHitResult& Hit, float remainingTime, int32 Iterations, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "SetPostLandedPhysics()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetPostLandedPhysics(const FHitResult& Hit, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "SetDefaultMovementMode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetDefaultMovementMode(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ShouldCheckForValidLandingSpot()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldCheckForValidLandingSpot(float DeltaTime, const FVector& Delta, const FHitResult& Hit, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ComputeOrientToMovementRotation()",
    "kind": "Method",
    "detail": "Function (FRotator)",
    "insertText": "ComputeOrientToMovementRotation(const FRotator& CurrentRotation, float DeltaTime, FRotator& DeltaRotation, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ShouldRemainVertical()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldRemainVertical(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "CanAttemptJump()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanAttemptJump(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "DoJump()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "DoJump(bool bReplayingMoves, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "IsJumpAllowed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsJumpAllowed()"
  },
  {
    "label": "GetMaxSpeed()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetMaxSpeed(FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "IsCrouching()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsCrouching(const FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "IsFalling()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFalling(const FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "IsFlying()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFlying(const FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "IsMovingOnGround()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsMovingOnGround(const FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "IsExceedingMaxSpeed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsExceedingMaxSpeed(float MaxSpeed, const FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "MoveComponent_GetPenetrationAdjustment()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "MoveComponent_GetPenetrationAdjustment(FHitResult& HitResult)"
  },
  {
    "label": "MoveComponent_SlideAlongSurface()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "MoveComponent_SlideAlongSurface(const FVector& Delta, float Time, const FVector& Normal, FHitResult& Hit, FCharacterMovementComponentAsyncOutput& Output, bool bHandleImpact = false)"
  },
  {
    "label": "MoveComponent_ComputeSlideVector()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "MoveComponent_ComputeSlideVector(const FVector& Delta, const float Time, const FVector& Normal, const FHitResult& Hit, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "ConstrainAnimRootMotionVelocity()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "ConstrainAnimRootMotionVelocity(const FVector& RootMotionVelocity, const FVector& CurrentVelocity, FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "CalcAnimRootMotionVelocity()",
    "kind": "Method",
    "detail": "Function (FVector)",
    "insertText": "CalcAnimRootMotionVelocity(const FVector& RootMotionDeltaMove, float DeltaSeconds, const FVector& CurrentVelocity)"
  },
  {
    "label": "GetRotationRate()",
    "kind": "Method",
    "detail": "Function (const FRotator&)",
    "insertText": "GetRotationRate(const FCharacterMovementComponentAsyncOutput& Output)"
  },
  {
    "label": "OnPreSimulate_Internal()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "OnPreSimulate_Internal()"
  },
  {
    "label": "PreSimulateImpl()",
    "kind": "Method",
    "detail": "Function (} ; template<FAsyncCallbackInput,FAsyncCallbackOutput,FAsyncCallback> void)",
    "insertText": "PreSimulateImpl(FAsyncCallback& Callback)"
  },
  {
    "label": "GetConsumerInput_Internal()",
    "kind": "Method",
    "detail": "Function (const FAsyncCallbackInput* Input = Callback .)",
    "insertText": "GetConsumerInput_Internal()"
  },
  {
    "label": "Simulate()",
    "kind": "Method",
    "detail": "Function (Input -> AsyncSimState -> CharacterOutput -> bClearJumpInput = false ; } else { Input -> AsyncSimState -> CharacterOutput -> bPressedJump = false ; } } Input ->)",
    "insertText": "Simulate(Callback.GetDeltaTime_Internal(), static_cast<FAsyncCallbackOutput&>(*Input->AsyncSimState))"
  },
  {
    "label": "GetProducerOutputData_Internal()",
    "kind": "Method",
    "detail": "Function (FAsyncCallbackOutput& Output = Callback .)",
    "insertText": "GetProducerOutputData_Internal()"
  },
  {
    "label": "Copy()",
    "kind": "Method",
    "detail": "Function (Output .)",
    "insertText": "Copy(static_cast<FAsyncCallbackOutput&>(*Input->AsyncSimState))"
  }
]