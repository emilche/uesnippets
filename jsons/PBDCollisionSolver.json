[
  {
    "label": "FManifoldPoint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FManifoldPoint"
  },
  {
    "label": "FPBDCollisionConstraint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDCollisionConstraint"
  },
  {
    "label": "FPBDCollisionSolver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDCollisionSolver"
  },
  {
    "label": "FPBDCollisionSolverManifoldPoint",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDCollisionSolverManifoldPoint"
  },
  {
    "label": "FState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FState"
  },
  {
    "label": "MakeInitialized()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" # include \" Chaos / Collision / ContactPoint . h \" # include \" Chaos / Defines . h \" # include \" Chaos / Evolution / SolverBody . h \" namespace Chaos { class FManifoldPoint ; class FPBDCollisionConstraint ; namespace Private { class FPBDCollisionSolver ; } namespace CVars { bool bChaos_PBDCollisionSolver_Velocity_AveragePointEnabled ; bool bChaos_PBDCollisionSolver_Velocity_FrictionEnabled ; float Chaos_PBDCollisionSolver_Position_StaticFrictionStiffness ; float Chaos_PBDCollisionSolver_Velocity_StaticFrictionStiffness ; } namespace Private { class FPBDCollisionSolverManifoldPoint { public : FSolverVec3 RelativeContactPoints [ 2 ] ; FSolverVec3 ContactNormal ; FSolverVec3 ContactTangentU ; FSolverVec3 ContactTangentV ; FSolverReal ContactDeltaNormal ; FSolverReal ContactDeltaTangentU ; FSolverReal ContactDeltaTangentV ; FSolverReal ContactTargetVelocityNormal ; FSolverVec3 ContactRxNormal0 ; FSolverVec3 ContactRxNormal1 ; FSolverVec3 ContactRxTangentU0 ; FSolverVec3 ContactRxTangentV0 ; FSolverVec3 ContactRxTangentU1 ; FSolverVec3 ContactRxTangentV1 ; FSolverVec3 ContactNormalAngular0 ; FSolverVec3 ContactTangentUAngular0 ; FSolverVec3 ContactTangentVAngular0 ; FSolverVec3 ContactNormalAngular1 ; FSolverVec3 ContactTangentUAngular1 ; FSolverVec3 ContactTangentVAngular1 ; FSolverReal ContactMassNormal ; FSolverReal ContactMassTangentU ; FSolverReal ContactMassTangentV ; FSolverReal NetPushOutNormal ; FSolverReal NetPushOutTangentU ; FSolverReal NetPushOutTangentV ; FSolverReal NetImpulseNormal ; FSolverReal NetImpulseTangentU ; FSolverReal NetImpulseTangentV ; FSolverReal NetSoftPushOutNormal ; FSolverReal StaticFrictionRatio ; uint32 bApplyFriction : 1 ; } ; class FPBDCollisionSolver { public : const int32 MaxConstrainedBodies = 2 ; FPBDCollisionSolver)",
    "insertText": "MakeInitialized()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (FPBDCollisionSolver Solver ; Solver . State .)",
    "insertText": "Init()"
  },
  {
    "label": "FPBDCollisionSolver()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FPBDCollisionSolver()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset(FPBDCollisionSolverManifoldPoint* InManifoldPoints, const int32 InMaxManifoldPoints)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (State . SolverBodies [ 0 ] .)",
    "insertText": "Reset()"
  },
  {
    "label": "ResetManifold()",
    "kind": "Method",
    "detail": "Function (State . ManifoldPoints = InManifoldPoints ; State . NumManifoldPoints = 0 ; State . MaxManifoldPoints = InMaxManifoldPoints ; } void)",
    "insertText": "ResetManifold()"
  },
  {
    "label": "GetStaticFriction()",
    "kind": "Method",
    "detail": "Function (State . NumManifoldPoints = 0 ; } FSolverReal)",
    "insertText": "GetStaticFriction()"
  },
  {
    "label": "SetStiffness()",
    "kind": "Method",
    "detail": "Function (State . StaticFriction = InStaticFriction ; State . DynamicFriction = InDynamicFriction ; State . VelocityFriction = InVelocityFriction ; State . MinMaxFrictionPushout = InMinMaxFrictionPushOut ; } void)",
    "insertText": "SetStiffness(const FSolverReal InStiffness)"
  },
  {
    "label": "SetHardContact()",
    "kind": "Method",
    "detail": "Function (State . Stiffness = InStiffness ; } void)",
    "insertText": "SetHardContact()"
  },
  {
    "label": "SetSoftContact()",
    "kind": "Method",
    "detail": "Function (State . SoftPhi = 0 ; } void)",
    "insertText": "SetSoftContact(const FSolverReal SoftPhi)"
  },
  {
    "label": "SetSolverBodies()",
    "kind": "Method",
    "detail": "Function (State . SoftPhi = SoftPhi ; } void)",
    "insertText": "SetSolverBodies(FSolverBody& SolverBody0, FSolverBody& SolverBody1)"
  },
  {
    "label": "SetSolverBody()",
    "kind": "Method",
    "detail": "Function (State . SolverBodies [ 0 ] .)",
    "insertText": "SetSolverBody(SolverBody0)"
  },
  {
    "label": "SetSolverBody()",
    "kind": "Method",
    "detail": "Function (State . SolverBodies [ 1 ] .)",
    "insertText": "SetSolverBody(SolverBody1)"
  },
  {
    "label": "NumManifoldPoints()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "NumManifoldPoints()"
  },
  {
    "label": "FinalizeManifold()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FinalizeManifold()"
  },
  {
    "label": "SolverBody0()",
    "kind": "Method",
    "detail": "Function (FConstraintSolverBody&)",
    "insertText": "SolverBody0()"
  },
  {
    "label": "SolvePositionWithFriction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolvePositionWithFriction(const FSolverReal Dt, const FSolverReal MaxPushOut)"
  },
  {
    "label": "SolveVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolveVelocity(const FSolverReal Dt, const bool bApplyDynamicFriction)"
  },
  {
    "label": "UpdateMass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateMass()"
  },
  {
    "label": "UpdateMassNormal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateMassNormal()"
  },
  {
    "label": "GetDynamicMassProperties()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "GetDynamicMassProperties(FSolverReal& OutInvM0, FSolverMatrix33& OutInvI0, FSolverReal& OutInvM1, FSolverMatrix33& OutInvI1)"
  },
  {
    "label": "InvM()",
    "kind": "Method",
    "detail": "Function (OutInvM0 = Body0 .)",
    "insertText": "InvM()"
  },
  {
    "label": "InvI()",
    "kind": "Method",
    "detail": "Function (OutInvI0 = Body0 .)",
    "insertText": "InvI()"
  },
  {
    "label": "SolverBody1()",
    "kind": "Method",
    "detail": "Function (} FConstraintSolverBody& Body1 =)",
    "insertText": "SolverBody1()"
  },
  {
    "label": "IsDynamic()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "IsDynamic(const int32 BodyIndex)"
  },
  {
    "label": "CalculateContactPositionCorrectionNormal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "CalculateContactPositionCorrectionNormal(const FPBDCollisionSolverManifoldPoint& ManifoldPoint, const FSolverReal MaxPushOut, FSolverReal& OutContactDeltaNormal)"
  },
  {
    "label": "CalculateContactPositionErrorTangential()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculateContactPositionErrorTangential(const FPBDCollisionSolverManifoldPoint& ManifoldPoint, FSolverReal& OutContactDeltaTangentU, FSolverReal& OutContactDeltaTangentV)"
  },
  {
    "label": "CalculateContactVelocityError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculateContactVelocityError(const FPBDCollisionSolverManifoldPoint& ManifoldPoint, const FSolverReal DynamicFriction, const FSolverReal Dt, FSolverReal& OutContactVelocityDeltaNormal, FSolverReal& OutContactVelocityDeltaTangent0, FSolverReal& OutContactVelocityDeltaTangent1)"
  },
  {
    "label": "CalculateContactVelocityErrorNormal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculateContactVelocityErrorNormal(const FPBDCollisionSolverManifoldPoint& ManifoldPoint, FSolverReal& OutContactVelocityDeltaNormal)"
  },
  {
    "label": "ShouldSolveVelocity()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldSolveVelocity(const FPBDCollisionSolverManifoldPoint& ManifoldPoint)"
  },
  {
    "label": "CalculatePositionCorrectionNormal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculatePositionCorrectionNormal(const FSolverReal Stiffness, const FSolverReal ContactDeltaNormal, const FSolverReal ContactMassNormal, const FSolverReal NetPushOutNormal, FSolverReal& OutPushOutNormal)"
  },
  {
    "label": "CalculatePositionCorrectionTangent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculatePositionCorrectionTangent(const FSolverReal Stiffness, const FSolverReal ContactDeltaTangent, const FSolverReal ContactMassTangent, const FSolverReal NetPushOutTangent, FSolverReal& OutPushOutTangent)"
  },
  {
    "label": "ApplyFrictionCone()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyFrictionCone(const FSolverReal StaticFriction, const FSolverReal DynamicFriction, const FSolverReal MaxFrictionPushOut, FSolverReal& InOutPushOutTangentU, FSolverReal& InOutPushOutTangentV, FSolverReal& InOutNetPushOutTangentU, FSolverReal& InOutNetPushOutTangentV, FSolverReal& OutStaticFrictionRatio)"
  },
  {
    "label": "ApplyPositionCorrectionTangential()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionCorrectionTangential(const FSolverReal Stiffness, const FSolverReal StaticFriction, const FSolverReal DynamicFriction, const FSolverReal MaxFrictionPushOut, const FSolverReal ContactDeltaTangentU, const FSolverReal ContactDeltaTangentV, FPBDCollisionSolverManifoldPoint& ManifoldPoint)"
  },
  {
    "label": "ApplyPositionCorrectionNormal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionCorrectionNormal(const FSolverReal Stiffness, const FSolverReal ContactDeltaNormal, FPBDCollisionSolverManifoldPoint& ManifoldPoint)"
  },
  {
    "label": "ApplySoftPositionCorrectionNormal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplySoftPositionCorrectionNormal(const FSolverReal Stiffness, const FSolverReal ContactDeltaNormal, const FSolverReal ContactVelocityNormalDt, FPBDCollisionSolverManifoldPoint& ManifoldPoint)"
  },
  {
    "label": "ApplyVelocityCorrection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyVelocityCorrection(const FSolverReal Stiffness, const FSolverReal Dt, const FSolverReal DynamicFriction, const FSolverReal ContactVelocityDeltaNormal, const FSolverReal ContactVelocityDeltaTangent0, const FSolverReal ContactVelocityDeltaTangent1, const FSolverReal MinImpulseNormal, FPBDCollisionSolverManifoldPoint& ManifoldPoint)"
  },
  {
    "label": "ApplyVelocityCorrectionNormal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyVelocityCorrectionNormal(const FSolverReal Stiffness, const FSolverReal ContactVelocityDeltaNormal, const FSolverReal MinImpulseNormal, FPBDCollisionSolverManifoldPoint& ManifoldPoint)"
  },
  {
    "label": "SolveVelocityAverage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolveVelocityAverage(const FSolverReal Dt)"
  },
  {
    "label": "FState()",
    "kind": "Method",
    "detail": "Function (struct FState {)",
    "insertText": "FState()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FSolverReal PushOutNormal = - Stiffness* ContactDeltaNormal* ContactMassNormal ;)",
    "insertText": "if((NetPushOutNormal + PushOutNormal) > FSolverReal(0))"
  },
  {
    "label": "FSolverReal()",
    "kind": "Method",
    "detail": "Function (FSolverReal ClampedPushOutTangentU = InOutPushOutTangentU ; FSolverReal ClampedPushOutTangentV = InOutPushOutTangentV ; FSolverReal ClampedNetPushOutTangentU = InOutNetPushOutTangentU + InOutPushOutTangentU ; FSolverReal ClampedNetPushOutTangentV = InOutNetPushOutTangentV + InOutPushOutTangentV ; FSolverReal ClampedStaticFrictionRatio =)",
    "insertText": "FSolverReal(1)"
  },
  {
    "label": "FSolverReal()",
    "kind": "Method",
    "detail": "Function (ClampedPushOutTangentU = - InOutNetPushOutTangentU ; ClampedPushOutTangentV = - InOutNetPushOutTangentV ; ClampedNetPushOutTangentU =)",
    "insertText": "FSolverReal(0)"
  },
  {
    "label": "Square()",
    "kind": "Method",
    "detail": "Function (} else { const FSolverReal MaxStaticPushOutTangentSq =)",
    "insertText": "Square(StaticFriction * MaxFrictionPushOut)"
  },
  {
    "label": "Square()",
    "kind": "Method",
    "detail": "Function (const FSolverReal NetPushOutTangentSq =)",
    "insertText": "Square(ClampedNetPushOutTangentU) + FMath::Square(ClampedNetPushOutTangentV)"
  },
  {
    "label": "InvSqrt()",
    "kind": "Method",
    "detail": "Function (const FSolverReal MaxDynamicPushOutTangent = DynamicFriction* MaxFrictionPushOut ; const FSolverReal FrictionMultiplier = MaxDynamicPushOutTangent*)",
    "insertText": "InvSqrt(NetPushOutTangentSq)"
  },
  {
    "label": "CalculatePositionCorrectionTangent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculatePositionCorrectionTangent(Stiffness, ContactDeltaTangentU, ManifoldPoint.ContactMassTangentU, ManifoldPoint.NetPushOutTangentU, PushOutTangentU)"
  },
  {
    "label": "CalculatePositionCorrectionTangent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculatePositionCorrectionTangent(Stiffness, ContactDeltaTangentV, ManifoldPoint.ContactMassTangentV, ManifoldPoint.NetPushOutTangentV, PushOutTangentV)"
  },
  {
    "label": "ApplyFrictionCone()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyFrictionCone(StaticFriction, DynamicFriction, MaxFrictionPushOut, PushOutTangentU, PushOutTangentV, ManifoldPoint.NetPushOutTangentU, ManifoldPoint.NetPushOutTangentV, ManifoldPoint.StaticFrictionRatio)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FVec3 PushOut = PushOutTangentU* ManifoldPoint . ContactTangentU + PushOutTangentV* ManifoldPoint . ContactTangentV ;)",
    "insertText": "if(IsDynamic(0))"
  },
  {
    "label": "ApplyPositionDelta()",
    "kind": "Method",
    "detail": "Function (Body0 .)",
    "insertText": "ApplyPositionDelta(DX0)"
  },
  {
    "label": "ApplyRotationDelta()",
    "kind": "Method",
    "detail": "Function (Body0 .)",
    "insertText": "ApplyRotationDelta(DR0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(IsDynamic(1))"
  },
  {
    "label": "ApplyPositionDelta()",
    "kind": "Method",
    "detail": "Function (Body1 .)",
    "insertText": "ApplyPositionDelta(DX1)"
  },
  {
    "label": "ApplyRotationDelta()",
    "kind": "Method",
    "detail": "Function (Body1 .)",
    "insertText": "ApplyRotationDelta(DR1)"
  },
  {
    "label": "CalculatePositionCorrectionNormal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CalculatePositionCorrectionNormal(Stiffness, ContactDeltaNormal, ManifoldPoint.ContactMassNormal, ManifoldPoint.NetPushOutNormal, PushOutNormal)"
  },
  {
    "label": "DX0()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3)",
    "insertText": "DX0(State.InvMs[0] * PushOutNormal)"
  },
  {
    "label": "DX1()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3)",
    "insertText": "DX1(State.InvMs[1] * -PushOutNormal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FSolverReal ImpulseNormal = - Stiffness* ManifoldPoint . ContactMassNormal* ContactVelocityDeltaNormal ;)",
    "insertText": "if((ManifoldPoint.NetImpulseNormal + ImpulseNormal) < MinImpulseNormal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ImpulseNormal = MinImpulseNormal - ManifoldPoint . NetImpulseNormal ; } ManifoldPoint . NetImpulseNormal + = ImpulseNormal ; FSolverVec3 Impulse = ImpulseNormal* ManifoldPoint . ContactNormal ; FSolverReal ImpulseTangentU = 0 ; FSolverReal ImpulseTangentV = 0 ;)",
    "insertText": "if((DynamicFriction > 0) && (Dt > 0))"
  },
  {
    "label": "ImpulseNormal()",
    "kind": "Method",
    "detail": "Function (const FSolverReal FrictionStiffness = Stiffness* CVars::Chaos_PBDCollisionSolver_Velocity_StaticFrictionStiffness ; ImpulseTangentU = - FrictionStiffness* ManifoldPoint . ContactMassTangentU* ContactVelocityDeltaTangent0 ; ImpulseTangentV = - FrictionStiffness* ManifoldPoint . ContactMassTangentV* ContactVelocityDeltaTangent1 ; const FSolverReal TotalImpulseNormal = ManifoldPoint . NetImpulseNormal +)",
    "insertText": "ImpulseNormal(ManifoldPoint.NetSoftPushOutNormal + ManifoldPoint.NetPushOutNormal)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const FSolverReal MinMaxFrictionImpulse = State . MinMaxFrictionPushout / Dt ; const FSolverReal MaxImpulseTangent = DynamicFriction*)",
    "insertText": "Max(MinMaxFrictionImpulse, TotalImpulseNormal)"
  },
  {
    "label": "Square()",
    "kind": "Method",
    "detail": "Function (const FSolverReal MaxImpulseTangentSq =)",
    "insertText": "Square(MaxImpulseTangent)"
  },
  {
    "label": "Square()",
    "kind": "Method",
    "detail": "Function (const FSolverReal ImpulseTangentSq =)",
    "insertText": "Square(ImpulseTangentU) + FMath::Square(ImpulseTangentV)"
  },
  {
    "label": "InvSqrt()",
    "kind": "Method",
    "detail": "Function (const FSolverReal ImpulseTangentScale = MaxImpulseTangent*)",
    "insertText": "InvSqrt(ImpulseTangentSq)"
  },
  {
    "label": "ApplyVelocityDelta()",
    "kind": "Method",
    "detail": "Function (Body0 .)",
    "insertText": "ApplyVelocityDelta(DV0, DW0)"
  },
  {
    "label": "ApplyVelocityDelta()",
    "kind": "Method",
    "detail": "Function (Body1 .)",
    "insertText": "ApplyVelocityDelta(DV1, DW1)"
  },
  {
    "label": "ImpulseNormal()",
    "kind": "Method",
    "detail": "Function (FSolverReal)",
    "insertText": "ImpulseNormal(Stiffness * ManifoldPoint.ContactMassNormal)"
  },
  {
    "label": "GetDynamicMassProperties()",
    "kind": "Method",
    "detail": "Function (FSolverReal InvM0,InvM1 ; FSolverMatrix33 InvI0,InvI1 ;)",
    "insertText": "GetDynamicMassProperties(InvM0, InvI0, InvM1, InvI1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (State . InvMs [ 0 ] = InvM0 ; State . InvMs [ 1 ] = InvM1 ;)",
    "insertText": "for(int32 PointIndex = 0; PointIndex < NumManifoldPoints(); ++PointIndex)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3& R0xN = ManifoldPoint . ContactRxNormal0 ; const FSolverVec3& R0xU = ManifoldPoint . ContactRxTangentU0 ; const FSolverVec3& R0xV = ManifoldPoint . ContactRxTangentV0 ; ManifoldPoint . ContactNormalAngular0 = InvI0* R0xN ; ManifoldPoint . ContactTangentUAngular0 = InvI0* R0xU ; ManifoldPoint . ContactTangentVAngular0 = InvI0* R0xV ; ContactMassInvNormal + =)",
    "insertText": "DotProduct(R0xN, ManifoldPoint.ContactNormalAngular0)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactMassInvTangentU + =)",
    "insertText": "DotProduct(R0xU, ManifoldPoint.ContactTangentUAngular0)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactMassInvTangentV + =)",
    "insertText": "DotProduct(R0xV, ManifoldPoint.ContactTangentVAngular0)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const FSolverVec3& R1xN = ManifoldPoint . ContactRxNormal1 ; const FSolverVec3& R1xU = ManifoldPoint . ContactRxTangentU1 ; const FSolverVec3& R1xV = ManifoldPoint . ContactRxTangentV1 ; ManifoldPoint . ContactNormalAngular1 = InvI1* R1xN ; ManifoldPoint . ContactTangentUAngular1 = InvI1* R1xU ; ManifoldPoint . ContactTangentVAngular1 = InvI1* R1xV ; ContactMassInvNormal + =)",
    "insertText": "DotProduct(R1xN, ManifoldPoint.ContactNormalAngular1)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactMassInvTangentU + =)",
    "insertText": "DotProduct(R1xU, ManifoldPoint.ContactTangentUAngular1)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactMassInvTangentV + =)",
    "insertText": "DotProduct(R1xV, ManifoldPoint.ContactTangentVAngular1)"
  },
  {
    "label": "ContactMassNormal()",
    "kind": "Method",
    "detail": "Function (} ManifoldPoint .)",
    "insertText": "ContactMassNormal(ContactMassInvNormal > FSolverReal(UE_SMALL_NUMBER)) ? FSolverReal(1) / ContactMassInvNormal : FSolverReal(0)"
  },
  {
    "label": "ContactMassTangentU()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint .)",
    "insertText": "ContactMassTangentU(ContactMassInvTangentU > FSolverReal(UE_SMALL_NUMBER)) ? FSolverReal(1) / ContactMassInvTangentU : FSolverReal(0)"
  },
  {
    "label": "ContactMassTangentV()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint .)",
    "insertText": "ContactMassTangentV(ContactMassInvTangentV > FSolverReal(UE_SMALL_NUMBER)) ? FSolverReal(1) / ContactMassInvTangentV : FSolverReal(0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FSolverReal ContactDelta = 0 ;)",
    "insertText": "if(IsDynamic(0) && IsDynamic(1))"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDelta + =)",
    "insertText": "DotProduct(Body0.DP() - Body1.DP(), ManifoldPoint.ContactNormal)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDelta + =)",
    "insertText": "DotProduct(Body0.DQ(), ManifoldPoint.ContactRxNormal0)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDelta - =)",
    "insertText": "DotProduct(Body1.DQ(), ManifoldPoint.ContactRxNormal1)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDelta + =)",
    "insertText": "DotProduct(Body0.DP(), ManifoldPoint.ContactNormal)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDelta - =)",
    "insertText": "DotProduct(Body1.DP(), ManifoldPoint.ContactNormal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((MaxPushOut > 0) && (ContactDelta < -MaxPushOut))"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDeltaU + =)",
    "insertText": "DotProduct(Body0.DP() - Body1.DP(), ManifoldPoint.ContactTangentU)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDeltaU + =)",
    "insertText": "DotProduct(Body0.DQ(), ManifoldPoint.ContactRxTangentU0)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDeltaU - =)",
    "insertText": "DotProduct(Body1.DQ(), ManifoldPoint.ContactRxTangentU1)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDeltaV + =)",
    "insertText": "DotProduct(Body0.DP() - Body1.DP(), ManifoldPoint.ContactTangentV)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDeltaV + =)",
    "insertText": "DotProduct(Body0.DQ(), ManifoldPoint.ContactRxTangentV0)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDeltaV - =)",
    "insertText": "DotProduct(Body1.DQ(), ManifoldPoint.ContactRxTangentV1)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDeltaU + =)",
    "insertText": "DotProduct(Body0.DP(), ManifoldPoint.ContactTangentU)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDeltaV + =)",
    "insertText": "DotProduct(Body0.DP(), ManifoldPoint.ContactTangentV)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDeltaU - =)",
    "insertText": "DotProduct(Body1.DP(), ManifoldPoint.ContactTangentU)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactDeltaV - =)",
    "insertText": "DotProduct(Body1.DP(), ManifoldPoint.ContactTangentV)"
  },
  {
    "label": "CalculateContactVelocityError()",
    "kind": "Method",
    "detail": "Function (} OutContactDeltaTangentU = ContactDeltaU ; OutContactDeltaTangentV = ContactDeltaV ; } void)",
    "insertText": "CalculateContactVelocityError(const FPBDCollisionSolverManifoldPoint& ManifoldPoint, const FSolverReal DynamicFriction, const FSolverReal Dt, FSolverReal& OutContactVelocityDeltaNormal, FSolverReal& OutContactVelocityDeltaTangentU, FSolverReal& OutContactVelocityDeltaTangentV)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactVelN + =)",
    "insertText": "DotProduct(Body0.V() - Body1.V(), ManifoldPoint.ContactNormal)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactVelN + =)",
    "insertText": "DotProduct(Body0.W(), ManifoldPoint.ContactRxNormal0)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactVelN - =)",
    "insertText": "DotProduct(Body1.W(), ManifoldPoint.ContactRxNormal1)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactVelU + =)",
    "insertText": "DotProduct(Body0.V() - Body1.V(), ManifoldPoint.ContactTangentU)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactVelU + =)",
    "insertText": "DotProduct(Body0.W(), ManifoldPoint.ContactRxTangentU0)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactVelU - =)",
    "insertText": "DotProduct(Body1.W(), ManifoldPoint.ContactRxTangentU1)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactVelV + =)",
    "insertText": "DotProduct(Body0.V() - Body1.V(), ManifoldPoint.ContactTangentV)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactVelV + =)",
    "insertText": "DotProduct(Body0.W(), ManifoldPoint.ContactRxTangentV0)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (ContactVelV - =)",
    "insertText": "DotProduct(Body1.W(), ManifoldPoint.ContactRxTangentV1)"
  },
  {
    "label": "InitManifoldPoint()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitManifoldPoint(const int32 PointIndex, const FSolverReal Dt, const FSolverVec3& InRelativeContactPosition0, const FSolverVec3& InRelativeContactPosition1, const FSolverVec3& InWorldContactNormal, const FSolverVec3& InWorldContactTangentU, const FSolverVec3& InWorldContactTangentV, const FSolverReal InWorldContactDeltaNormal, const FSolverReal InWorldContactDeltaTangentU, const FSolverReal InWorldContactDeltaTangentV, const FSolverReal InWorldContactVelocityTargetNormal)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (FPBDCollisionSolverManifoldPoint& ManifoldPoint = State . ManifoldPoints [ PointIndex ] ; ManifoldPoint . RelativeContactPoints [ 0 ] = InRelativeContactPosition0 ; ManifoldPoint . RelativeContactPoints [ 1 ] = InRelativeContactPosition1 ; ManifoldPoint . ContactNormal = InWorldContactNormal ; ManifoldPoint . ContactTangentU = InWorldContactTangentU ; ManifoldPoint . ContactTangentV = InWorldContactTangentV ; ManifoldPoint . ContactDeltaNormal = InWorldContactDeltaNormal ; ManifoldPoint . ContactDeltaTangentU = InWorldContactDeltaTangentU ; ManifoldPoint . ContactDeltaTangentV = InWorldContactDeltaTangentV ; ManifoldPoint . ContactTargetVelocityNormal = InWorldContactVelocityTargetNormal ; ManifoldPoint . ContactRxNormal0 =)",
    "insertText": "CrossProduct(InRelativeContactPosition0, InWorldContactNormal)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . ContactRxTangentU0 =)",
    "insertText": "CrossProduct(InRelativeContactPosition0, InWorldContactTangentU)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . ContactRxTangentV0 =)",
    "insertText": "CrossProduct(InRelativeContactPosition0, InWorldContactTangentV)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . ContactRxNormal1 =)",
    "insertText": "CrossProduct(InRelativeContactPosition1, InWorldContactNormal)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . ContactRxTangentU1 =)",
    "insertText": "CrossProduct(InRelativeContactPosition1, InWorldContactTangentU)"
  },
  {
    "label": "CrossProduct()",
    "kind": "Method",
    "detail": "Function (ManifoldPoint . ContactRxTangentV1 =)",
    "insertText": "CrossProduct(InRelativeContactPosition1, InWorldContactTangentV)"
  },
  {
    "label": "SolvePositionNoFriction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolvePositionNoFriction(Dt, MaxPushOut)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const FSolverReal FrictionStiffness = State . Stiffness* CVars::Chaos_PBDCollisionSolver_Position_StaticFrictionStiffness ;)",
    "insertText": "if(FrictionStiffness > 0)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (FPBDCollisionSolverManifoldPoint& SolverManifoldPoint = State . ManifoldPoints [ PointIndex ] ; const FSolverReal TotalPushOutNormal = SolverManifoldPoint . NetPushOutNormal + SolverManifoldPoint . NetSoftPushOutNormal ; const FSolverReal FrictionMaxPushOut =)",
    "insertText": "Max(State.MinMaxFrictionPushout, TotalPushOutNormal)"
  },
  {
    "label": "bApplyFriction()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bApplyFriction(FrictionMaxPushOut > 0) || (SolverManifoldPoint.NetPushOutTangentU != 0) || (SolverManifoldPoint.NetPushOutTangentV != 0)"
  },
  {
    "label": "CalculateContactPositionErrorTangential()",
    "kind": "Method",
    "detail": "Function (FSolverReal ContactDeltaTangentU,ContactDeltaTangentV ;)",
    "insertText": "CalculateContactPositionErrorTangential(SolverManifoldPoint, ContactDeltaTangentU, ContactDeltaTangentV)"
  },
  {
    "label": "ApplyPositionCorrectionTangential()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionCorrectionTangential(FrictionStiffness, State.StaticFriction, State.DynamicFriction, FrictionMaxPushOut, ContactDeltaTangentU, ContactDeltaTangentV, SolverManifoldPoint)"
  },
  {
    "label": "SolvePositionNoFriction()",
    "kind": "Method",
    "detail": "Function (} } } } void)",
    "insertText": "SolvePositionNoFriction(const FSolverReal Dt, const FSolverReal MaxPushOut)"
  },
  {
    "label": "CalculateContactPositionCorrectionNormal()",
    "kind": "Method",
    "detail": "Function (FPBDCollisionSolverManifoldPoint& SolverManifoldPoint = State . ManifoldPoints [ PointIndex ] ; FSolverReal ContactCorrectionNormal ;)",
    "insertText": "CalculateContactPositionCorrectionNormal(SolverManifoldPoint, MaxPushOut, ContactCorrectionNormal)"
  },
  {
    "label": "bProcessManifoldPoint()",
    "kind": "Method",
    "detail": "Function (const FSolverReal HardContactErrorNormal = SolverManifoldPoint . ContactDeltaNormal + ContactCorrectionNormal - State . SoftPhi ; const bool)",
    "insertText": "bProcessManifoldPoint(HardContactErrorNormal < FSolverReal(0)) || (SolverManifoldPoint.NetPushOutNormal > FSolverReal(UE_SMALL_NUMBER))"
  },
  {
    "label": "ApplyPositionCorrectionNormal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyPositionCorrectionNormal(State.Stiffness, HardContactErrorNormal, SolverManifoldPoint)"
  },
  {
    "label": "bSolveAverageContact()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bSolveAverageContact(NumManifoldPoints() > 1)"
  },
  {
    "label": "SolveVelocityAverage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SolveVelocityAverage(Dt)"
  },
  {
    "label": "DynamicFriction()",
    "kind": "Method",
    "detail": "Function (} const FSolverReal)",
    "insertText": "DynamicFriction(bApplyDynamicFriction && (Dt > 0) && CVars::bChaos_PBDCollisionSolver_Velocity_FrictionEnabled) ? State.VelocityFriction : FSolverReal(0)"
  },
  {
    "label": "bShouldSolveNormalVelocity()",
    "kind": "Method",
    "detail": "Function (FPBDCollisionSolverManifoldPoint& SolverManifoldPoint = State . ManifoldPoints [ PointIndex ] ; const bool)",
    "insertText": "bShouldSolveNormalVelocity(SolverManifoldPoint.NetPushOutNormal > FSolverReal(0))"
  },
  {
    "label": "bShouldSolveTangentVelocity()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "bShouldSolveTangentVelocity(DynamicFriction > 0) && (bShouldSolveNormalVelocity || (SolverManifoldPoint.ContactDeltaNormal < State.SoftPhi) || (SolverManifoldPoint.NetSoftPushOutNormal > FSolverReal(0)))"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (const FSolverReal MinImpulseNormal =)",
    "insertText": "Min(FSolverReal(0), -(SolverManifoldPoint.NetPushOutNormal + SolverManifoldPoint.NetSoftPushOutNormal) / Dt)"
  },
  {
    "label": "CalculateContactVelocityError()",
    "kind": "Method",
    "detail": "Function (FSolverReal ContactVelocityDeltaNormal,ContactVelocityDeltaTangentU,ContactVelocityDeltaTangentV ;)",
    "insertText": "CalculateContactVelocityError(SolverManifoldPoint, DynamicFriction, Dt, ContactVelocityDeltaNormal, ContactVelocityDeltaTangentU, ContactVelocityDeltaTangentV)"
  },
  {
    "label": "ApplyVelocityCorrection()",
    "kind": "Method",
    "detail": "Function (ContactVelocityDeltaNormal = 0 ; })",
    "insertText": "ApplyVelocityCorrection(State.Stiffness, Dt, DynamicFriction, ContactVelocityDeltaNormal, ContactVelocityDeltaTangentU, ContactVelocityDeltaTangentV, MinImpulseNormal, SolverManifoldPoint)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(bShouldSolveNormalVelocity)"
  },
  {
    "label": "CalculateContactVelocityErrorNormal()",
    "kind": "Method",
    "detail": "Function (FSolverReal ContactVelocityDeltaNormal ;)",
    "insertText": "CalculateContactVelocityErrorNormal(SolverManifoldPoint, ContactVelocityDeltaNormal)"
  },
  {
    "label": "ApplyVelocityCorrectionNormal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyVelocityCorrectionNormal(State.Stiffness, ContactVelocityDeltaNormal, MinImpulseNormal, SolverManifoldPoint)"
  }
]