[
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "_Iter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Iter"
  },
  {
    "label": "_LIBCPP_TEMPLATE_VIS",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_LIBCPP_TEMPLATE_VIS"
  },
  {
    "label": "__iter_traits_cache",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iter_traits_cache"
  },
  {
    "label": "__iter_concept_concept_test",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iter_concept_concept_test"
  },
  {
    "label": "__iter_concept_category_test",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iter_concept_category_test"
  },
  {
    "label": "__iter_concept_random_fallback",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iter_concept_random_fallback"
  },
  {
    "label": "_Tester",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tester"
  },
  {
    "label": "__test_iter_concept",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__test_iter_concept"
  },
  {
    "label": "__iter_concept_cache",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iter_concept_cache"
  },
  {
    "label": "__has_iterator_typedefs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_iterator_typedefs"
  },
  {
    "label": "_Up",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Up"
  },
  {
    "label": "__has_iterator_category",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_iterator_category"
  },
  {
    "label": "__has_iterator_concept",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_iterator_concept"
  },
  {
    "label": "_Ip",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Ip"
  },
  {
    "label": "__iterator_traits_member_pointer_or_void",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iterator_traits_member_pointer_or_void"
  },
  {
    "label": "__iterator_traits_member_pointer_or_arrow_or_void",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iterator_traits_member_pointer_or_arrow_or_void"
  },
  {
    "label": "__iterator_traits_member_reference",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iterator_traits_member_reference"
  },
  {
    "label": "__deduce_iterator_category",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__deduce_iterator_category"
  },
  {
    "label": "__iterator_traits_iterator_category",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iterator_traits_iterator_category"
  },
  {
    "label": "__iterator_traits_difference_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iterator_traits_difference_type"
  },
  {
    "label": "__iterator_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iterator_traits"
  },
  {
    "label": "iterator_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "iterator_traits"
  },
  {
    "label": "__iterator_traits_impl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__iterator_traits_impl"
  },
  {
    "label": "__has_iterator_category_convertible_to",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_iterator_category_convertible_to"
  },
  {
    "label": "__has_iterator_concept_convertible_to",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__has_iterator_concept_convertible_to"
  },
  {
    "label": "__is_cpp17_input_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_cpp17_input_iterator"
  },
  {
    "label": "__is_cpp17_forward_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_cpp17_forward_iterator"
  },
  {
    "label": "__is_cpp17_bidirectional_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_cpp17_bidirectional_iterator"
  },
  {
    "label": "__is_cpp17_random_access_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_cpp17_random_access_iterator"
  },
  {
    "label": "__is_cpp17_contiguous_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_cpp17_contiguous_iterator"
  },
  {
    "label": "__wrap_iter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "__wrap_iter"
  },
  {
    "label": "__is_exactly_cpp17_input_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_exactly_cpp17_input_iterator"
  },
  {
    "label": "__is_exactly_cpp17_forward_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_exactly_cpp17_forward_iterator"
  },
  {
    "label": "__is_exactly_cpp17_bidirectional_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_exactly_cpp17_bidirectional_iterator"
  },
  {
    "label": "_InputIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_InputIterator"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___ITERATOR_ITERATOR_TRAITS_H # define _LIBCPP___ITERATOR_ITERATOR_TRAITS_H # include<__config> # include<__iterator / incrementable_traits . h> # include<__iterator / readable_traits . h> # include<concepts> # include<cstddef> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (template<class _Tp> concept __can_reference = requires { __with_reference<_Tp> ; } ; template<class _Tp> concept __dereferenceable =)",
    "insertText": "requires(_Tp& __t)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function ({* __t } -> __can_reference ; } ; template<__dereferenceable _Tp> using iter_reference_t =)",
    "insertText": "decltype(*declval<_Tp&>())"
  },
  {
    "label": "__test()",
    "kind": "Method",
    "detail": "Function (# endif template<class _Iter> struct _LIBCPP_TEMPLATE_VIS iterator_traits ; struct _LIBCPP_TEMPLATE_VIS input_iterator_tag { } ; struct _LIBCPP_TEMPLATE_VIS output_iterator_tag { } ; struct _LIBCPP_TEMPLATE_VIS forward_iterator_tag : public input_iterator_tag { } ; struct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag { } ; struct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag { } ; # if _LIBCPP_STD_VER> 1 7 struct _LIBCPP_TEMPLATE_VIS contiguous_iterator_tag : public random_access_iterator_tag { } ; # endif template<class _Iter> struct __iter_traits_cache { using type = _If<__is_primary_template<iterator_traits<_Iter>>::value,_Iter,iterator_traits<_Iter>> ; } ; template<class _Iter> using _ITER_TRAITS = __iter_traits_cache<_Iter>::type ; struct __iter_concept_concept_test { template<class _Iter> using _Apply = _ITER_TRAITS<_Iter>::iterator_concept ; } ; struct __iter_concept_category_test { template<class _Iter> using _Apply = _ITER_TRAITS<_Iter>::iterator_category ; } ; struct __iter_concept_random_fallback { template<class _Iter> using _Apply = __enable_if_t<__is_primary_template<iterator_traits<_Iter>>::value,random_access_iterator_tag> ; } ; template<class _Iter,class _Tester> struct __test_iter_concept : _IsValidExpansion<_Tester::template _Apply,_Iter>,_Tester { } ; template<class _Iter> struct __iter_concept_cache { using type = _Or<__test_iter_concept<_Iter,__iter_concept_concept_test>,__test_iter_concept<_Iter,__iter_concept_category_test>,__test_iter_concept<_Iter,__iter_concept_random_fallback>> ; } ; template<class _Iter> using _ITER_CONCEPT = __iter_concept_cache<_Iter>::type::template _Apply<_Iter> ; template<class _Tp> struct __has_iterator_typedefs { private : template<class _Up> false_type)",
    "insertText": "__test(...)"
  },
  {
    "label": "__test()",
    "kind": "Method",
    "detail": "Function (template<class _Up> true_type)",
    "insertText": "__test(typename __void_t<typename _Up::iterator_category>::type* = 0, typename __void_t<typename _Up::difference_type>::type* = 0, typename __void_t<typename _Up::value_type>::type* = 0, typename __void_t<typename _Up::reference>::type* = 0, typename __void_t<typename _Up::pointer>::type* = 0)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (public : const bool value =)",
    "insertText": "decltype(__test<_Tp>(0,0,0,0,0))"
  },
  {
    "label": "__test()",
    "kind": "Method",
    "detail": "Function (template<class _Up> true_type)",
    "insertText": "__test(typename _Up::iterator_category* = nullptr)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (public : const bool value =)",
    "insertText": "decltype(__test<_Tp>(nullptr))"
  },
  {
    "label": "__test()",
    "kind": "Method",
    "detail": "Function (template<class _Up> true_type)",
    "insertText": "__test(typename _Up::iterator_concept* = nullptr)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function (} ; # if _LIBCPP_STD_VER> 1 7 namespace __iterator_traits_detail { template<class _Ip> concept __cpp17_iterator =)",
    "insertText": "requires(_Ip __i)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (incrementable_traits<_Ip>::difference_type ; indirectly_readable_traits<_Ip>::value_type ; common_reference_t<iter_reference_t<_Ip>&&,indirectly_readable_traits<_Ip>::value_type&> ; common_reference_t<)",
    "insertText": "decltype(*__i++)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function ({ - - __i } -> same_as<_Ip&> ; { __i - - } -> convertible_to<_Ip const&> ; {* __i - - } -> same_as<iter_reference_t<_Ip>> ; } ; template<class _Ip> concept __cpp17_random_access_iterator = __cpp17_bidirectional_iterator<_Ip>&& totally_ordered<_Ip>&&)",
    "insertText": "requires(_Ip __i, typename incrementable_traits<_Ip>::difference_type __n)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function ({ __i + = __n } -> same_as<_Ip&> ; { __i - = __n } -> same_as<_Ip&> ; { __i + __n } -> same_as<_Ip> ; { __n + __i } -> same_as<_Ip> ; { __i - __n } -> same_as<_Ip> ; { __i - __i } -> same_as<)",
    "insertText": "decltype(__n)"
  },
  {
    "label": "requires()",
    "kind": "Method",
    "detail": "Function ({ __i [ __n ] } -> convertible_to<iter_reference_t<_Ip>> ; } ; } template<class _Ip> concept __has_member_reference = requires { _Ip::reference ; } ; template<class _Ip> concept __has_member_pointer = requires { _Ip::pointer ; } ; template<class _Ip> concept __has_member_iterator_category = requires { _Ip::iterator_category ; } ; template<class _Ip> concept __specifies_members = requires { _Ip::value_type ; _Ip::difference_type ; requires __has_member_reference<_Ip> ; requires __has_member_iterator_category<_Ip> ; } ; template<class> struct __iterator_traits_member_pointer_or_void { using type = void ; } ; template<__has_member_pointer _Tp> struct __iterator_traits_member_pointer_or_void<_Tp> { using type = _Tp::pointer ; } ; template<class _Tp> concept __cpp17_iterator_missing_members = ! __specifies_members<_Tp>&& __iterator_traits_detail::__cpp17_iterator<_Tp> ; template<class _Tp> concept __cpp17_input_iterator_missing_members = __cpp17_iterator_missing_members<_Tp>&& __iterator_traits_detail::__cpp17_input_iterator<_Tp> ; template<class> struct __iterator_traits_member_pointer_or_arrow_or_void { using type = void ; } ; template<__has_member_pointer _Ip> struct __iterator_traits_member_pointer_or_arrow_or_void<_Ip> { using type = _Ip::pointer ; } ; template<class _Ip> requires)",
    "insertText": "requires(_Ip& __i)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (__i .)",
    "insertText": "operator()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (using type =)",
    "insertText": "decltype(declval<_Ip&>().operator->())"
  }
]