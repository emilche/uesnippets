[
  {
    "label": "UHashtable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UHashtable"
  },
  {
    "label": "UStringTrieBuildOption",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "UStringTrieBuildOption"
  },
  {
    "label": "U_COMMON_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U_COMMON_API"
  },
  {
    "label": "Node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Node"
  },
  {
    "label": "FinalValueNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FinalValueNode"
  },
  {
    "label": "ValueNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueNode"
  },
  {
    "label": "IntermediateValueNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IntermediateValueNode"
  },
  {
    "label": "LinearMatchNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LinearMatchNode"
  },
  {
    "label": "BranchNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BranchNode"
  },
  {
    "label": "ListBranchNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ListBranchNode"
  },
  {
    "label": "SplitBranchNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SplitBranchNode"
  },
  {
    "label": "BranchHeadNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BranchHeadNode"
  },
  {
    "label": "hashNode()",
    "kind": "Method",
    "detail": "Function (# ifndef __STRINGTRIEBUILDER_H__ # define __STRINGTRIEBUILDER_H__ # include \" unicode / utypes . h \" # include \" unicode / uobject . h \" struct UHashtable ; typedef struct UHashtable UHashtable ; enum UStringTrieBuildOption { USTRINGTRIE_BUILD_FAST,USTRINGTRIE_BUILD_SMALL } ; U_NAMESPACE_BEGIN class StringTrieBuilder : public UObject { public : # ifndef int32_t)",
    "insertText": "hashNode(const void *node)"
  },
  {
    "label": "equalNodes()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "equalNodes(const void *left, const void *right)"
  },
  {
    "label": "StringTrieBuilder()",
    "kind": "Method",
    "detail": "Function (# endif protected :)",
    "insertText": "StringTrieBuilder()"
  },
  {
    "label": "createCompactBuilder()",
    "kind": "Method",
    "detail": "Function (# ifndef void)",
    "insertText": "createCompactBuilder(int32_t sizeGuess, UErrorCode &errorCode)"
  },
  {
    "label": "deleteCompactBuilder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deleteCompactBuilder()"
  },
  {
    "label": "build()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "build(UStringTrieBuildOption buildOption, int32_t elementsLength, UErrorCode &errorCode)"
  },
  {
    "label": "writeNode()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "writeNode(int32_t start, int32_t limit, int32_t unitIndex)"
  },
  {
    "label": "writeBranchSubNode()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "writeBranchSubNode(int32_t start, int32_t limit, int32_t unitIndex, int32_t length)"
  },
  {
    "label": "makeNode()",
    "kind": "Method",
    "detail": "Function (# endif class Node ; # ifndef Node*)",
    "insertText": "makeNode(int32_t start, int32_t limit, int32_t unitIndex, UErrorCode &errorCode)"
  },
  {
    "label": "makeBranchSubNode()",
    "kind": "Method",
    "detail": "Function (Node*)",
    "insertText": "makeBranchSubNode(int32_t start, int32_t limit, int32_t unitIndex, int32_t length, UErrorCode &errorCode)"
  },
  {
    "label": "getElementStringLength()",
    "kind": "Method",
    "detail": "Function (# endif int32_t)",
    "insertText": "getElementStringLength(int32_t i)"
  },
  {
    "label": "getElementUnit()",
    "kind": "Method",
    "detail": "Function (char16_t)",
    "insertText": "getElementUnit(int32_t i, int32_t unitIndex)"
  },
  {
    "label": "getElementValue()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getElementValue(int32_t i)"
  },
  {
    "label": "getLimitOfLinearMatch()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getLimitOfLinearMatch(int32_t first, int32_t last, int32_t unitIndex)"
  },
  {
    "label": "countElementUnits()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "countElementUnits(int32_t start, int32_t limit, int32_t unitIndex)"
  },
  {
    "label": "skipElementsBySomeUnits()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "skipElementsBySomeUnits(int32_t i, int32_t unitIndex, int32_t count)"
  },
  {
    "label": "indexOfElementWithNextUnit()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "indexOfElementWithNextUnit(int32_t i, int32_t unitIndex, char16_t unit)"
  },
  {
    "label": "matchNodesCanHaveValues()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "matchNodesCanHaveValues()"
  },
  {
    "label": "getMaxBranchLinearSubNodeLength()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getMaxBranchLinearSubNodeLength()"
  },
  {
    "label": "getMinLinearMatch()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getMinLinearMatch()"
  },
  {
    "label": "getMaxLinearMatchLength()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getMaxLinearMatchLength()"
  },
  {
    "label": "registerNode()",
    "kind": "Method",
    "detail": "Function (# ifndef const int32_t kMaxBranchLinearSubNodeLength = 5 ; const int32_t kMaxSplitBranchLevels = 1 4 ; Node*)",
    "insertText": "registerNode(Node *newNode, UErrorCode &errorCode)"
  },
  {
    "label": "registerFinalValue()",
    "kind": "Method",
    "detail": "Function (Node*)",
    "insertText": "registerFinalValue(int32_t value, UErrorCode &errorCode)"
  },
  {
    "label": "Node()",
    "kind": "Method",
    "detail": "Function (# endif UHashtable* nodes ; class Node : public UObject { public :)",
    "insertText": "Node(int32_t initialHash) : hash(initialHash), offset(0)"
  },
  {
    "label": "hashCode()",
    "kind": "Method",
    "detail": "Function (} int32_t)",
    "insertText": "hashCode()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} UBool)",
    "insertText": "operator(const Node &other)"
  },
  {
    "label": "markRightEdgesFirst()",
    "kind": "Method",
    "detail": "Function (} int32_t)",
    "insertText": "markRightEdgesFirst(int32_t edgeNumber)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "write(StringTrieBuilder &builder)"
  },
  {
    "label": "writeUnlessInsideRightEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeUnlessInsideRightEdge(int32_t firstRight, int32_t lastRight, StringTrieBuilder &builder)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "write(builder)"
  },
  {
    "label": "getOffset()",
    "kind": "Method",
    "detail": "Function (} } int32_t)",
    "insertText": "getOffset()"
  },
  {
    "label": "ValueNode()",
    "kind": "Method",
    "detail": "Function (protected : int32_t value ; } ; # endif class ValueNode : public Node { public :)",
    "insertText": "ValueNode(int32_t initialHash) : Node(initialHash), hasValue(FALSE), value(0)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValue(int32_t v)"
  },
  {
    "label": "IntermediateValueNode()",
    "kind": "Method",
    "detail": "Function (hasValue = TRUE ; value = v ; hash = hash* 3 7 u + v ; } protected : UBool hasValue ; int32_t value ; } ; # ifndef class IntermediateValueNode : public ValueNode { public :)",
    "insertText": "IntermediateValueNode(int32_t v, Node *nextNode) : ValueNode(0x222222u*37u+hashCode(nextNode)), next(nextNode)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValue(v)"
  },
  {
    "label": "LinearMatchNode()",
    "kind": "Method",
    "detail": "Function (protected : Node* next ; } ; # endif class LinearMatchNode : public ValueNode { public :)",
    "insertText": "LinearMatchNode(int32_t len, Node *nextNode) : ValueNode((0x333333u*37u+len)*37u+hashCode(nextNode)), length(len), next(nextNode)"
  },
  {
    "label": "BranchNode()",
    "kind": "Method",
    "detail": "Function (protected : int32_t length ; Node* next ; } ; # ifndef class BranchNode : public Node { public :)",
    "insertText": "BranchNode(int32_t initialHash) : Node(initialHash)"
  },
  {
    "label": "ListBranchNode()",
    "kind": "Method",
    "detail": "Function (} protected : int32_t firstEdgeNumber ; } ; class ListBranchNode : public BranchNode { public :)",
    "insertText": "ListBranchNode() : BranchNode(0x444444), length(0)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "add(int32_t c, int32_t value)"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (units [)",
    "insertText": "length(char16_t)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (equal [ length ] = NULL ; values [ length ] = value ; + + length ;)",
    "insertText": "hash(hash*37u+c)"
  },
  {
    "label": "add()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "add(int32_t c, Node *node)"
  },
  {
    "label": "hash()",
    "kind": "Method",
    "detail": "Function (equal [ length ] = node ; values [ length ] = 0 ; + + length ;)",
    "insertText": "hash(hash*37u+c)*37u+hashCode(node)"
  },
  {
    "label": "SplitBranchNode()",
    "kind": "Method",
    "detail": "Function (} protected : Node* equal [ kMaxBranchLinearSubNodeLength ] ; int32_t length ; int32_t values [ kMaxBranchLinearSubNodeLength ] ; char16_t units [ kMaxBranchLinearSubNodeLength ] ; } ; class SplitBranchNode : public BranchNode { public :)",
    "insertText": "SplitBranchNode(char16_t middleUnit, Node *lessThanNode, Node *greaterOrEqualNode) : BranchNode(((0x555555u*37u+middleUnit)*37u+ hashCode(lessThanNode))*37u+hashCode(greaterOrEqualNode)), unit(middleUnit), lessThan(lessThanNode), greaterOrEqual(greaterOrEqualNode)"
  },
  {
    "label": "BranchHeadNode()",
    "kind": "Method",
    "detail": "Function (protected : char16_t unit ; Node* lessThan ; Node* greaterOrEqual ; } ; class BranchHeadNode : public ValueNode { public :)",
    "insertText": "BranchHeadNode(int32_t len, Node *subNode) : ValueNode((0x666666u*37u+len)*37u+hashCode(subNode)), length(len), next(subNode)"
  },
  {
    "label": "createLinearMatchNode()",
    "kind": "Method",
    "detail": "Function (protected : int32_t length ; Node* next ; } ; # endif Node*)",
    "insertText": "createLinearMatchNode(int32_t i, int32_t unitIndex, int32_t length, Node *nextNode)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "write(int32_t unit)"
  },
  {
    "label": "writeElementUnits()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "writeElementUnits(int32_t i, int32_t unitIndex, int32_t length)"
  },
  {
    "label": "writeValueAndFinal()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "writeValueAndFinal(int32_t i, UBool isFinal)"
  },
  {
    "label": "writeValueAndType()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "writeValueAndType(UBool hasValue, int32_t value, int32_t node)"
  },
  {
    "label": "writeDeltaTo()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "writeDeltaTo(int32_t jumpTarget)"
  }
]