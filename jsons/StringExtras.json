[
  {
    "label": "SmallVectorImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallVectorImpl"
  },
  {
    "label": "hexdigit()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ADT_STRINGEXTRAS_H # define LLVM_ADT_STRINGEXTRAS_H # include \" llvm / ADT / StringRef . h \" # include \" llvm / Support / DataTypes . h \" # include<iterator> namespace llvm { template<T> class SmallVectorImpl ; char)",
    "insertText": "hexdigit(unsigned X, bool LowerCase = false)"
  },
  {
    "label": "toStringRef()",
    "kind": "Method",
    "detail": "Function (const char HexChar = LowerCase ? ' a ' : ' A ' ; return X<1 0 ? ' 0 ' + X : HexChar + X - 1 0 ; } StringRef)",
    "insertText": "toStringRef(bool B)"
  },
  {
    "label": "hexDigitValue()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "hexDigitValue(char C)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (char* BufPtr = BufferEnd ;* - - BufPtr = 0 ;)",
    "insertText": "if(X == 0)"
  },
  {
    "label": "prefast()",
    "kind": "Method",
    "detail": "Function (# pragma)",
    "insertText": "prefast(suppress: 22102, \"buffer for BufferEnd always has room for one char\")"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (unsigned char Mod = static_cast<unsigned)",
    "insertText": "char(X)"
  },
  {
    "label": "prefast()",
    "kind": "Method",
    "detail": "Function (# pragma)",
    "insertText": "prefast(suppress: 22103, \"X runs down to zero before end of buffer depending on type - cannot express for template in SAL\") *--BufPtr = hexdigit(Mod, LowerCase)"
  },
  {
    "label": "utohexstr()",
    "kind": "Method",
    "detail": "Function (X>> = 4 ; } return BufPtr ; } std::string)",
    "insertText": "utohexstr(uint64_t X, bool LowerCase = false)"
  },
  {
    "label": "utohex_buffer()",
    "kind": "Method",
    "detail": "Function (char Buffer [ 1 7 ] ; return)",
    "insertText": "utohex_buffer(X, Buffer+17, LowerCase)"
  },
  {
    "label": "utostr_32()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "utostr_32(uint32_t X, bool isNeg = false)"
  },
  {
    "label": "prefast()",
    "kind": "Method",
    "detail": "Function (# pragma)",
    "insertText": "prefast(suppress: 22102, \"X runs down to zero before end of buffer\") *--BufPtr = '0' + char(X % 10)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (X / = 1 0 ; })",
    "insertText": "if(isNeg)"
  },
  {
    "label": "utostr()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "utostr(uint64_t X, bool isNeg = false)"
  },
  {
    "label": "itostr()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "itostr(int64_t X)"
  },
  {
    "label": "StrInStrNoCase()",
    "kind": "Method",
    "detail": "Function (} StringRef::size_type)",
    "insertText": "StrInStrNoCase(StringRef s1, StringRef s2)"
  },
  {
    "label": "getToken()",
    "kind": "Method",
    "detail": "Function (std::pair<StringRef,StringRef>)",
    "insertText": "getToken(StringRef Source, StringRef Delimiters = \" \\t\\n\\v\\f\\r\")"
  },
  {
    "label": "SplitString()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SplitString(StringRef Source, SmallVectorImpl<StringRef> &OutFragments, StringRef Delimiters = \" \\t\\n\\v\\f\\r\")"
  },
  {
    "label": "HashString()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "HashString(StringRef Str, unsigned Result = 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (std::string S ;)",
    "insertText": "if(Begin == End)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "S(*Begin)"
  },
  {
    "label": "join_impl()",
    "kind": "Method",
    "detail": "Function (} return S ; } template<IteratorT> std::string)",
    "insertText": "join_impl(IteratorT Begin, IteratorT End, StringRef Separator, std::forward_iterator_tag)"
  },
  {
    "label": "Len()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "Len(std::distance(Begin, End) - 1) * Separator.size()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (S .)",
    "insertText": "reserve(Len)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} return S ; } template<IteratorT> std::string)",
    "insertText": "join(IteratorT Begin, IteratorT End, StringRef Separator)"
  },
  {
    "label": "join_impl()",
    "kind": "Method",
    "detail": "Function (typedef std::iterator_traits<IteratorT>::iterator_category tag ; return)",
    "insertText": "join_impl(Begin, End, Separator, tag())"
  }
]