[
  {
    "label": "FTriangleRegister",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTriangleRegister"
  },
  {
    "label": "FTriangleRegister()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Core . h \" # include \" Math / VectorRegister . h \" # include \" Chaos / AABB . h \" namespace Chaos { class FTriangleRegister { public :)",
    "insertText": "FTriangleRegister()"
  },
  {
    "label": "FTriangleRegister()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FTriangleRegister(const VectorRegister4Float& InA, const VectorRegister4Float& InB, const VectorRegister4Float& InC) : A(InA) , B(InB) , C(InC)"
  },
  {
    "label": "SupportCoreSimd()",
    "kind": "Method",
    "detail": "Function (} VectorRegister4Float)",
    "insertText": "SupportCoreSimd(const VectorRegister4Float& Direction, const FReal InMargin)"
  },
  {
    "label": "VectorDot4()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float DotA =)",
    "insertText": "VectorDot4(A, Direction)"
  },
  {
    "label": "VectorDot4()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float DotB =)",
    "insertText": "VectorDot4(B, Direction)"
  },
  {
    "label": "VectorDot4()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float DotC =)",
    "insertText": "VectorDot4(C, Direction)"
  },
  {
    "label": "VectorCompareGE()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float DotAGEDotB =)",
    "insertText": "VectorCompareGE(DotA, DotB)"
  },
  {
    "label": "VectorCompareGE()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float DotAGEDotC =)",
    "insertText": "VectorCompareGE(DotA, DotC)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float DotAG =)",
    "insertText": "VectorBitwiseAnd(DotAGEDotB, DotAGEDotC)"
  },
  {
    "label": "VectorCompareGE()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float DotBGEDotA =)",
    "insertText": "VectorCompareGE(DotB, DotA)"
  },
  {
    "label": "VectorCompareGE()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float DotBGEDotC =)",
    "insertText": "VectorCompareGE(DotB, DotC)"
  },
  {
    "label": "VectorBitwiseAnd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float DotBG =)",
    "insertText": "VectorBitwiseAnd(DotBGEDotA, DotBGEDotC)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float Result =)",
    "insertText": "VectorSelect(DotAG, A, C)"
  },
  {
    "label": "VectorSelect()",
    "kind": "Method",
    "detail": "Function (Result =)",
    "insertText": "VectorSelect(DotBG, B, Result)"
  },
  {
    "label": "VectorMin()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float MinSimd =)",
    "insertText": "VectorMin(VectorMin(A, B), C)"
  },
  {
    "label": "VectorMax()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float MaxSimd =)",
    "insertText": "VectorMax(VectorMax(A, B), C)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alignas(32)"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreAligned(MinSimd, AlignedArray)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "Min(static_cast<FReal>(AlignedArray[0]), static_cast<FReal>(AlignedArray[1]), static_cast<FReal>(AlignedArray[2]))"
  },
  {
    "label": "VectorStoreAligned()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStoreAligned(MaxSimd, AlignedArray)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const FVec3)",
    "insertText": "Max(static_cast<FReal>(AlignedArray[0]), static_cast<FReal>(AlignedArray[1]), static_cast<FReal>(AlignedArray[2]))"
  },
  {
    "label": "IsTooBigForSinglePrecision()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsTooBigForSinglePrecision()"
  },
  {
    "label": "VectorMax()",
    "kind": "Method",
    "detail": "Function (FRealSingle SqrSideThreshold = 1 0 0 0 0 0 . 0 f* 1 0 0 0 0 0 . 0 f ; const VectorRegister4Float BigSide =)",
    "insertText": "VectorMax(VectorAbs(VectorSubtract(A, B)), VectorAbs(VectorSubtract(B, C)))"
  }
]