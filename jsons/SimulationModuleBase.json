[
  {
    "label": "CHAOSVEHICLESCORE_API",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CHAOSVEHICLESCORE_API"
  },
  {
    "label": "FSimModuleTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSimModuleTree"
  },
  {
    "label": "FModuleNetData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FModuleNetData"
  },
  {
    "label": "FSimOutputData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSimOutputData"
  },
  {
    "label": "FClusterUnionPhysicsProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FClusterUnionPhysicsProxy"
  },
  {
    "label": "FCollisionContactModifier",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCollisionContactModifier"
  },
  {
    "label": "TSimModuleSettings",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSimModuleSettings"
  },
  {
    "label": "eSimModuleState",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "eSimModuleState"
  },
  {
    "label": "eSimModuleTypeFlags",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "eSimModuleTypeFlags"
  },
  {
    "label": "EWheelAxis",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EWheelAxis"
  },
  {
    "label": "TSimulationModuleTypeableBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSimulationModuleTypeableBase"
  },
  {
    "label": "TSimulationModuleTypeable",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSimulationModuleTypeable"
  },
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "TSimModuleTypeIsRecursive",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TSimModuleTypeIsRecursive"
  },
  {
    "label": "FSimulationModuleTypeContainer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSimulationModuleTypeContainer"
  },
  {
    "label": "TSimFactoryAutoRegister",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSimFactoryAutoRegister"
  },
  {
    "label": "FSimFactoryModule",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSimFactoryModule"
  },
  {
    "label": "DECLARE_LOG_CATEGORY_EXTERN()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / GeometryParticlesfwd . h \" # include \" Chaos / ParticleHandleFwd . h \" # include \" Logging / LogMacros . h \" # include \" SimModule / ModuleFactoryRegister . h \" # include \" SimModule / ModuleInput . h \" # include \" SimModule / VehicleBlackboard . h \")",
    "insertText": "DECLARE_LOG_CATEGORY_EXTERN(LogSimulationModule, Warning, All)"
  },
  {
    "label": "TSIMMODULETYPEABLE()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "TSIMMODULETYPEABLE(clazz) Chaos::TSimulationModuleTypeableExt<clazz,&FName(#clazz)"
  },
  {
    "label": "HandbrakeControlName()",
    "kind": "Method",
    "detail": "Function (bool ShowMass = false ; bool ShowForces = false ; float DrawForceScaling = 0 . 0 0 0 4 f ; float LevelSlopeThreshold = 0 . 8 6 f ; bool DisableForces = false ; } ; namespace Chaos { class FSimModuleTree ; struct FModuleNetData ; struct FSimOutputData ; class FClusterUnionPhysicsProxy ; class FCollisionContactModifier ; const FName)",
    "insertText": "HandbrakeControlName(\"Handbrake\")"
  },
  {
    "label": "ThrottleControlName()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "ThrottleControlName(\"Throttle\")"
  },
  {
    "label": "SteeringControlName()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "SteeringControlName(\"Steering\")"
  },
  {
    "label": "BrakeControlName()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "BrakeControlName(\"Brake\")"
  },
  {
    "label": "ClutchControlName()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "ClutchControlName(\"Clutch\")"
  },
  {
    "label": "BoostControlName()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "BoostControlName(\"Boost\")"
  },
  {
    "label": "ReverseControlName()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "ReverseControlName(\"Reverse\")"
  },
  {
    "label": "ChangeUpControlName()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "ChangeUpControlName(\"ChangeUp\")"
  },
  {
    "label": "ChangeDownControlName()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "ChangeDownControlName(\"ChangeDown\")"
  },
  {
    "label": "PitchControlName()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "PitchControlName(\"Pitch\")"
  },
  {
    "label": "RollControlName()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "RollControlName(\"Roll\")"
  },
  {
    "label": "YawControlName()",
    "kind": "Method",
    "detail": "Function (const FName)",
    "insertText": "YawControlName(\"Yaw\")"
  },
  {
    "label": "GetControls()",
    "kind": "Method",
    "detail": "Function (struct FModuleHitResults { int SimIndex ; FVector ImpactPoint ; float Distance ; bool bBlockingHit ; } ; struct FAllInputs { FInputInterface&)",
    "insertText": "GetControls()"
  },
  {
    "label": "AccessSetup()",
    "kind": "Method",
    "detail": "Function (SetupData = SetupIn ; } T&)",
    "insertText": "AccessSetup()"
  },
  {
    "label": "Setup()",
    "kind": "Method",
    "detail": "Function (} const T&)",
    "insertText": "Setup()"
  },
  {
    "label": "NonFunctional()",
    "kind": "Method",
    "detail": "Function (} private : T SetupData ; } ; enum eSimModuleState { Disabled,Enabled } ; enum eSimModuleTypeFlags {)",
    "insertText": "NonFunctional(1 << 0), Raycast = (1 << 1), TorqueBased = (1 << 2), Velocity = (1 << 3)"
  },
  {
    "label": "TSimulationModuleTypeableBase()",
    "kind": "Method",
    "detail": "Function (enum EWheelAxis { X,Y } ; template<_To> class TSimulationModuleTypeableBase { public :)",
    "insertText": "TSimulationModuleTypeableBase()"
  },
  {
    "label": "_To()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "_To(this)->AddType(StaticSimTypeBase())"
  },
  {
    "label": "StaticSimTypeBase()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "StaticSimTypeBase()"
  },
  {
    "label": "TSimulationModuleTypeable()",
    "kind": "Method",
    "detail": "Function (} } ; template<_To,. . . _Rest> class TSimulationModuleTypeable ; template<_To> class TSimulationModuleTypeable<_To> { public :)",
    "insertText": "TSimulationModuleTypeable()"
  },
  {
    "label": "_To()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "_To(this)->AddType(StaticSimType())"
  },
  {
    "label": "StaticSimType()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "StaticSimType()"
  },
  {
    "label": "_From()",
    "kind": "Method",
    "detail": "Function (static_cast<)",
    "insertText": "_From(this)->AddType(StaticSimType())"
  },
  {
    "label": "RecurseSimType()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "RecurseSimType()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T,class = void> struct TSimModuleTypeIsRecursive : std::false_type { } ; template<class T> struct TSimModuleTypeIsRecursive<T,std::enable_if_t<std::is_invocable_r<FName,)",
    "insertText": "decltype(T::RecurseSimType)"
  },
  {
    "label": "AddType()",
    "kind": "Method",
    "detail": "Function (} ; template<class T> bool TSimModuleTypeIsRecursive_v = TSimModuleTypeIsRecursive<T>::value ; class FSimulationModuleTypeContainer { public : TSet<FName> MyTypes ; FName MostRecentAdd = NAME_None ; void)",
    "insertText": "AddType(FName InType)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (MyTypes .)",
    "insertText": "Emplace(InType)"
  },
  {
    "label": "IsSimType()",
    "kind": "Method",
    "detail": "Function (MostRecentAdd = InType ; } bool)",
    "insertText": "IsSimType(FName InType)"
  },
  {
    "label": "GetSimType()",
    "kind": "Method",
    "detail": "Function (} FName)",
    "insertText": "GetSimType()"
  },
  {
    "label": "IsSimType()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "IsSimType(TSimulationModuleTypeable<U>::StaticSimType())"
  },
  {
    "label": "Cast()",
    "kind": "Method",
    "detail": "Function (} } template<U> U*)",
    "insertText": "Cast()"
  },
  {
    "label": "DEFINE_CHAOSSIMTYPENAME()",
    "kind": "Method",
    "detail": "Function (} return nullptr ; } } ; # define)",
    "insertText": "DEFINE_CHAOSSIMTYPENAME(cls) \\ static FName _CHAOSTYPENAMERETRIVAL_()"
  },
  {
    "label": "DEFINE_CHAOSSIMTYPENAME()",
    "kind": "Method",
    "detail": "Function (} class ISimulationModuleBase : public FSimulationModuleTypeContainer,public TSimulationModuleTypeableBase<ISimulationModuleBase> { FSimOutputData ; public :)",
    "insertText": "DEFINE_CHAOSSIMTYPENAME(ISimulationModuleBase)"
  },
  {
    "label": "ISimulationModuleBase()",
    "kind": "Method",
    "detail": "Function (const int INVALID_IDX = - 1 ;)",
    "insertText": "ISimulationModuleBase() : SimModuleTree(nullptr) , BoneName(NAME_None) , AnimationSetupIndex(-1) , SimTreeIndex(INVALID_IDX) , StateFlags(Enabled) , TransformIndex(INVALID_IDX) , ParticleIdx(INVALID_IDX) , LocalLinearVelocity(FVector::ZeroVector) , LocalAngularVelocity(FVector::ZeroVector) , bClustered(true) , bAnimationEnabled(true) , AppliedForce(FVector::ZeroVector) , Guid(INDEX_NONE) , CachedParticle(nullptr)"
  },
  {
    "label": "ISimulationModuleBase()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ISimulationModuleBase()"
  },
  {
    "label": "GetGuid()",
    "kind": "Method",
    "detail": "Function (} const int)",
    "insertText": "GetGuid()"
  },
  {
    "label": "GetDebugName()",
    "kind": "Method",
    "detail": "Function (Guid = GuidIn ; } const FString)",
    "insertText": "GetDebugName()"
  },
  {
    "label": "IsBehaviourType()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsBehaviourType(eSimModuleTypeFlags InType)"
  },
  {
    "label": "IsEnabled()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsEnabled()"
  },
  {
    "label": "SetStateFlags()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetStateFlags(eSimModuleState StateFlagsIn)"
  },
  {
    "label": "OnConstruction_External()",
    "kind": "Method",
    "detail": "Function (StateFlags = StateFlagsIn ; } void)",
    "insertText": "OnConstruction_External(Chaos::FClusterUnionPhysicsProxy* Proxy)"
  },
  {
    "label": "OnTermination_External()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnTermination_External()"
  },
  {
    "label": "Simulate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Simulate(Chaos::FClusterUnionPhysicsProxy* Proxy, float DeltaTime, const FAllInputs& Inputs, FSimModuleTree& VehicleModuleSystem)"
  },
  {
    "label": "Simulate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Simulate(DeltaTime, Inputs, VehicleModuleSystem)"
  },
  {
    "label": "OnContactModification()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "OnContactModification(Chaos::FCollisionContactModifier& Modifier, Chaos::FClusterUnionPhysicsProxy* Proxy)"
  },
  {
    "label": "Simulate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Simulate(float DeltaTime, const FAllInputs& Inputs, FSimModuleTree& VehicleModuleSystem)"
  },
  {
    "label": "Animate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Animate(Chaos::FClusterUnionPhysicsProxy* Proxy)"
  },
  {
    "label": "SetAnimationEnabled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetAnimationEnabled(bool bInEnabled)"
  },
  {
    "label": "IsAnimationEnabled()",
    "kind": "Method",
    "detail": "Function (bAnimationEnabled = bInEnabled ; } bool)",
    "insertText": "IsAnimationEnabled()"
  },
  {
    "label": "GetAnimationOffset()",
    "kind": "Method",
    "detail": "Function (const FVector&)",
    "insertText": "GetAnimationOffset()"
  },
  {
    "label": "GetDebugString()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "GetDebugString(FString& StringOut)"
  },
  {
    "label": "SetTransformIndex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTransformIndex(int TransformIndexIn)"
  },
  {
    "label": "GetTransformIndex()",
    "kind": "Method",
    "detail": "Function (TransformIndex = TransformIndexIn ; } const int)",
    "insertText": "GetTransformIndex()"
  },
  {
    "label": "GetParticleIndex()",
    "kind": "Method",
    "detail": "Function (ParticleIdx = ParticleIndexIn ; } const FUniqueIdx)",
    "insertText": "GetParticleIndex()"
  },
  {
    "label": "GetTreeIndex()",
    "kind": "Method",
    "detail": "Function (SimTreeIndex = TreeIndexIn ; } int)",
    "insertText": "GetTreeIndex()"
  },
  {
    "label": "AddLocalForceAtPosition()",
    "kind": "Method",
    "detail": "Function (SimModuleTree = SimModuleTreeIn ; } void)",
    "insertText": "AddLocalForceAtPosition(const FVector& Force, const FVector& Position, bool bAllowSubstepping = true, bool bIsLocalForce = false, bool bLevelSlope = false, const FColor& DebugColorIn = FColor::Blue)"
  },
  {
    "label": "AddForceAtCOMPosition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddForceAtCOMPosition(const FVector& Force, const FVector& OffsetFromCOM = FVector::ZeroVector, bool bAllowSubstepping = true, bool bLevelSlope = false, const FColor& DebugColorIn = FColor::Blue)"
  },
  {
    "label": "AddLocalForce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddLocalForce(const FVector& Force, bool bAllowSubstepping = true, bool bIsLocalForce = false, bool bLevelSlope = false, const FColor& DebugColorIn = FColor::Blue)"
  },
  {
    "label": "AddLocalTorque()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddLocalTorque(const FVector& Torque, bool bAllowSubstepping = true, bool bAccelChangeIn = true, const FColor& DebugColorIn = FColor::Magenta)"
  },
  {
    "label": "SetClustered()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetClustered(bool IsClusteredIn)"
  },
  {
    "label": "IsClustered()",
    "kind": "Method",
    "detail": "Function (bClustered = IsClusteredIn ; } bool)",
    "insertText": "IsClustered()"
  },
  {
    "label": "GetClusteredTransform()",
    "kind": "Method",
    "detail": "Function (ClusteredCOMRelativeTransform = TransformIn ; } const FTransform&)",
    "insertText": "GetClusteredTransform()"
  },
  {
    "label": "GetInitialParticleTransform()",
    "kind": "Method",
    "detail": "Function (InitialParticleTransform = TransformIn ; } const FTransform&)",
    "insertText": "GetInitialParticleTransform()"
  },
  {
    "label": "GetComponentTransform()",
    "kind": "Method",
    "detail": "Function (ComponentTransform = TransformIn ; } const FTransform&)",
    "insertText": "GetComponentTransform()"
  },
  {
    "label": "GetIntactTransform()",
    "kind": "Method",
    "detail": "Function (IntactCOMRelativeTransform = TransformIn ; IsInitialized = true ; } const FTransform&)",
    "insertText": "GetIntactTransform()"
  },
  {
    "label": "SetLocalLinearVelocity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLocalLinearVelocity(const FVector& VelocityIn)"
  },
  {
    "label": "GetLocalLinearVelocity()",
    "kind": "Method",
    "detail": "Function (LocalLinearVelocity = VelocityIn ; } const FVector&)",
    "insertText": "GetLocalLinearVelocity()"
  },
  {
    "label": "GetLocalAngularVelocity()",
    "kind": "Method",
    "detail": "Function (LocalAngularVelocity = VelocityIn ; } const FVector&)",
    "insertText": "GetLocalAngularVelocity()"
  },
  {
    "label": "GetFirstChild()",
    "kind": "Method",
    "detail": "Function (ISimulationModuleBase*)",
    "insertText": "GetFirstChild()"
  },
  {
    "label": "GetSimBlackboard()",
    "kind": "Method",
    "detail": "Function (FVehicleBlackboard*)",
    "insertText": "GetSimBlackboard()"
  },
  {
    "label": "GetAppliedForce()",
    "kind": "Method",
    "detail": "Function (const FVector&)",
    "insertText": "GetAppliedForce()"
  },
  {
    "label": "GenerateOutputData()",
    "kind": "Method",
    "detail": "Function (FSimOutputData*)",
    "insertText": "GenerateOutputData()"
  },
  {
    "label": "GetParticleFromUniqueIndex()",
    "kind": "Method",
    "detail": "Function (Chaos::FPBDRigidParticleHandle*)",
    "insertText": "GetParticleFromUniqueIndex(int32 ParticleUniqueIdx, TArray<Chaos::FPBDRigidParticleHandle*>& Particles)"
  },
  {
    "label": "DEFINE_CHAOSSIMTYPENAME()",
    "kind": "Method",
    "detail": "Function (protected : FSimModuleTree* SimModuleTree ; FName BoneName ; int AnimationSetupIndex ; int SimTreeIndex ; eSimModuleState StateFlags ; int TransformIndex ; FUniqueIdx ParticleIdx ; FTransform InitialParticleTransform ; FTransform RelativeOffsetTransform ; FTransform ComponentTransform ; FTransform ClusteredCOMRelativeTransform ; FTransform IntactCOMRelativeTransform ; FVector LocalLinearVelocity ; FVector LocalAngularVelocity ; bool bClustered ; bool bAnimationEnabled ; FVector AnimationOffset ; FVector AnimationRotation ; FVector AppliedForce ; int Guid ; FPBDRigidClusteredParticleHandle* CachedParticle ; } ; struct FModuleNetData : public FSimulationModuleTypeContainer,public TSimulationModuleTypeableBase<FModuleNetData> {)",
    "insertText": "DEFINE_CHAOSSIMTYPENAME(FModuleNetData)"
  },
  {
    "label": "FModuleNetData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FModuleNetData(int InSimArrayIndex, const FString& InDebugString = FString()) : SimArrayIndex(InSimArrayIndex) #if !(UE_BUILD_SHIPPING || UE_BUILD_TEST) , DebugString(InDebugString)"
  },
  {
    "label": "FModuleNetData()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FModuleNetData()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Serialize(FArchive& Ar)"
  },
  {
    "label": "FillNetState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FillNetState(const ISimulationModuleBase* SimModule)"
  },
  {
    "label": "FillSimState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FillSimState(ISimulationModuleBase* SimModule)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Lerp(const float LerpFactor, const FModuleNetData& Max, const FModuleNetData& MaxValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int SimArrayIndex = - 1 ; #)",
    "insertText": "if(UE_BUILD_SHIPPING || UE_BUILD_TEST) virtual FString ToString()"
  },
  {
    "label": "DEFINE_CHAOSSIMTYPENAME()",
    "kind": "Method",
    "detail": "Function (FString DebugString ; # endif } ; using FModuleNetDataArray = TArray<TSharedPtr<FModuleNetData>> ; namespace EAnimationFlags { uint16 AnimateNone = 0 x00000000 ; uint16 AnimatePosition = 0 x00000001 ; uint16 AnimateRotation = 0 x00000002 ; } struct FSimOutputData : public FSimulationModuleTypeContainer,public TSimulationModuleTypeableBase<FSimOutputData> {)",
    "insertText": "DEFINE_CHAOSSIMTYPENAME(FSimOutputData)"
  },
  {
    "label": "FSimOutputData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSimOutputData()"
  },
  {
    "label": "FillOutputState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FillOutputState(const ISimulationModuleBase* SimModule)"
  },
  {
    "label": "Lerp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Lerp(const FSimOutputData& InCurrent, const FSimOutputData& InNext, float Alpha)"
  },
  {
    "label": "DEFINE_CHAOSSIMTYPENAME()",
    "kind": "Method",
    "detail": "Function (} FString DebugString ; # endif } ; class IFactoryModule : public FSimulationModuleTypeContainer,public TSimulationModuleTypeableBase<IFactoryModule> { public :)",
    "insertText": "DEFINE_CHAOSSIMTYPENAME(IFactoryModule)"
  },
  {
    "label": "IFactoryModule()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "IFactoryModule()"
  },
  {
    "label": "GenerateNetData()",
    "kind": "Method",
    "detail": "Function (} TSharedPtr<Chaos::FModuleNetData>)",
    "insertText": "GenerateNetData(const int32 SimArrayIndex)"
  },
  {
    "label": "_To()",
    "kind": "Method",
    "detail": "Function (} ; template<_To> class TSimFactoryAutoRegister { private : bool bSimFactoryRegistered = RegisterFactoryHelper<)",
    "insertText": "_To()"
  },
  {
    "label": "FSimFactoryModule()",
    "kind": "Method",
    "detail": "Function (} ; template<T> class FSimFactoryModule : public IFactoryModule { public :)",
    "insertText": "FSimFactoryModule(const FString& DebugNameIn)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (#)",
    "insertText": "if(UE_BUILD_SHIPPING || UE_BUILD_TEST)"
  }
]