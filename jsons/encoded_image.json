[
  {
    "label": "EncodedImageBufferInterface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "EncodedImageBufferInterface"
  },
  {
    "label": "RTC_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RTC_EXPORT"
  },
  {
    "label": "Timing",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Timing"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (# ifndef API_VIDEO_ENCODED_IMAGE_H_ # define API_VIDEO_ENCODED_IMAGE_H_ # include<stdint . h> # include<map> # include<utility> # include \" absl / types / optional . h \" # include \" api / rtp_packet_infos . h \" # include \" api / scoped_refptr . h \" # include \" api / video / color_space . h \" # include \" api / video / video_codec_constants . h \" # include \" api / video / video_content_type . h \" # include \" api / video / video_frame_type . h \" # include \" api / video / video_rotation . h \" # include \" api / video / video_timing . h \" # include \" rtc_base / checks . h \" # include \" rtc_base / ref_count . h \" # include \" rtc_base / system / rtc_export . h \" namespace webrtc { class EncodedImageBufferInterface : public rtc::RefCountInterface { public : const uint8_t*)",
    "insertText": "data()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "size()"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (} ; class RTC_EXPORT EncodedImageBuffer : public EncodedImageBufferInterface { public : rtc::scoped_refptr<EncodedImageBuffer>)",
    "insertText": "Create()"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (} rtc::scoped_refptr<EncodedImageBuffer>)",
    "insertText": "Create(size_t size)"
  },
  {
    "label": "Create()",
    "kind": "Method",
    "detail": "Function (rtc::scoped_refptr<EncodedImageBuffer>)",
    "insertText": "Create(const uint8_t* data, size_t size)"
  },
  {
    "label": "Realloc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Realloc(size_t t)"
  },
  {
    "label": "EncodedImageBuffer()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "EncodedImageBuffer(size_t size)"
  },
  {
    "label": "EncodedImageBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EncodedImageBuffer(const uint8_t* data, size_t size)"
  },
  {
    "label": "EncodedImageBuffer()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "EncodedImageBuffer()"
  },
  {
    "label": "EncodedImage()",
    "kind": "Method",
    "detail": "Function (size_t size_ ; uint8_t* buffer_ ; } ; class RTC_EXPORT EncodedImage { public :)",
    "insertText": "EncodedImage()"
  },
  {
    "label": "EncodedImage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EncodedImage(EncodedImage&&)"
  },
  {
    "label": "EncodedImage()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EncodedImage(const EncodedImage&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (EncodedImage&)",
    "insertText": "operator(EncodedImage&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (EncodedImage&)",
    "insertText": "operator(const EncodedImage&)"
  },
  {
    "label": "SetTimestamp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetTimestamp(uint32_t timestamp)"
  },
  {
    "label": "Timestamp()",
    "kind": "Method",
    "detail": "Function (timestamp_rtp_ = timestamp ; } uint32_t)",
    "insertText": "Timestamp()"
  },
  {
    "label": "NtpTimeMs()",
    "kind": "Method",
    "detail": "Function (int64_t)",
    "insertText": "NtpTimeMs()"
  },
  {
    "label": "RTC_DCHECK_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_GE(spatial_index.value_or(0), 0)"
  },
  {
    "label": "RTC_DCHECK_LT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_LT(spatial_index.value_or(0), kMaxSpatialLayers)"
  },
  {
    "label": "TemporalIndex()",
    "kind": "Method",
    "detail": "Function (spatial_index_ = spatial_index ; } absl::optional<int>)",
    "insertText": "TemporalIndex()"
  },
  {
    "label": "RTC_DCHECK_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_GE(temporal_index_.value_or(0), 0)"
  },
  {
    "label": "RTC_DCHECK_LT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_LT(temporal_index_.value_or(0), kMaxTemporalStreams)"
  },
  {
    "label": "SpatialLayerFrameSize()",
    "kind": "Method",
    "detail": "Function (temporal_index_ = temporal_index ; } absl::optional<size_t>)",
    "insertText": "SpatialLayerFrameSize(int spatial_index)"
  },
  {
    "label": "SetSpatialLayerFrameSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetSpatialLayerFrameSize(int spatial_index, size_t size_bytes)"
  },
  {
    "label": "ColorSpace()",
    "kind": "Method",
    "detail": "Function (const webrtc::ColorSpace*)",
    "insertText": "ColorSpace()"
  },
  {
    "label": "VideoFrameTrackingId()",
    "kind": "Method",
    "detail": "Function (color_space_ = color_space ; } absl::optional<uint16_t>)",
    "insertText": "VideoFrameTrackingId()"
  },
  {
    "label": "PacketInfos()",
    "kind": "Method",
    "detail": "Function (video_frame_tracking_id_ = tracking_id ; } const RtpPacketInfos&)",
    "insertText": "PacketInfos()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (packet_infos_ =)",
    "insertText": "move(packet_infos)"
  },
  {
    "label": "RetransmissionAllowed()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "RetransmissionAllowed()"
  },
  {
    "label": "RTC_DCHECK_LE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_LE(new_size, new_size == 0 ? 0 : capacity())"
  },
  {
    "label": "SetEncodedData()",
    "kind": "Method",
    "detail": "Function (size_ = new_size ; } void)",
    "insertText": "SetEncodedData(rtc::scoped_refptr<EncodedImageBufferInterface> encoded_data)"
  },
  {
    "label": "ClearEncodedData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ClearEncodedData()"
  },
  {
    "label": "GetEncodedData()",
    "kind": "Method",
    "detail": "Function (encoded_data_ = nullptr ; size_ = 0 ; } rtc::scoped_refptr<EncodedImageBufferInterface>)",
    "insertText": "GetEncodedData()"
  },
  {
    "label": "IsAtTargetQuality()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsAtTargetQuality()"
  },
  {
    "label": "capacity()",
    "kind": "Method",
    "detail": "Function (at_target_quality_ = at_target_quality ; } uint32_t _encodedWidth = 0 ; uint32_t _encodedHeight = 0 ; int64_t ntp_time_ms_ = 0 ; int64_t capture_time_ms_ = 0 ; VideoFrameType _frameType = VideoFrameType::kVideoFrameDelta ; VideoRotation rotation_ = kVideoRotation_0 ; VideoContentType content_type_ = VideoContentType::UNSPECIFIED ; int qp_ = - 1 ; VideoPlayoutDelay playout_delay_ ; struct Timing { uint8_t flags = VideoSendTiming::kInvalid ; int64_t encode_start_ms = 0 ; int64_t encode_finish_ms = 0 ; int64_t packetization_finish_ms = 0 ; int64_t pacer_exit_ms = 0 ; int64_t network_timestamp_ms = 0 ; int64_t network2_timestamp_ms = 0 ; int64_t receive_start_ms = 0 ; int64_t receive_finish_ms = 0 ; } timing_ ; private : size_t)",
    "insertText": "capacity()"
  }
]