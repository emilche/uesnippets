[
  {
    "label": "Function",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Function"
  },
  {
    "label": "GlobalValue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GlobalValue"
  },
  {
    "label": "Loop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Loop"
  },
  {
    "label": "PreservedAnalyses",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PreservedAnalyses"
  },
  {
    "label": "Type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Type"
  },
  {
    "label": "User",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "User"
  },
  {
    "label": "Value",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Value"
  },
  {
    "label": "MemIntrinsicInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MemIntrinsicInfo"
  },
  {
    "label": "TargetTransformInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetTransformInfo"
  },
  {
    "label": "TargetCostConstants",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "TargetCostConstants"
  },
  {
    "label": "UnrollingPreferences",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UnrollingPreferences"
  },
  {
    "label": "PopcntSupportKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "PopcntSupportKind"
  },
  {
    "label": "ShuffleKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ShuffleKind"
  },
  {
    "label": "OperandValueKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "OperandValueKind"
  },
  {
    "label": "OperandValueProperties",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "OperandValueProperties"
  },
  {
    "label": "Concept",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Concept"
  },
  {
    "label": "Model",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Model"
  },
  {
    "label": "TargetIRAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetIRAnalysis"
  },
  {
    "label": "TargetTransformInfoWrapperPass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetTransformInfoWrapperPass"
  },
  {
    "label": "MemIntrinsicInfo()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ANALYSIS_TARGETTRANSFORMINFO_H # define LLVM_ANALYSIS_TARGETTRANSFORMINFO_H # include \" llvm / ADT / Optional . h \" # include \" llvm / IR / IntrinsicInst . h \" # include \" llvm / IR / Intrinsics . h \" # include \" llvm / Pass . h \" # include \" llvm / Support / DataTypes . h \" # include<functional> namespace llvm { class Function ; class GlobalValue ; class Loop ; class PreservedAnalyses ; class Type ; class User ; class Value ; struct MemIntrinsicInfo {)",
    "insertText": "MemIntrinsicInfo() : ReadMem(false), WriteMem(false), Vol(false), MatchingId(0), NumMemRefs(0), PtrVal(nullptr)"
  },
  {
    "label": "TargetTransformInfo()",
    "kind": "Method",
    "detail": "Function (} bool ReadMem ; bool WriteMem ; bool Vol ; unsigned short MatchingId ; int NumMemRefs ; Value* PtrVal ; } ; class TargetTransformInfo { public : template<T>)",
    "insertText": "TargetTransformInfo(T Impl)"
  },
  {
    "label": "TargetTransformInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TargetTransformInfo(const DataLayout &DL)"
  },
  {
    "label": "TargetTransformInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TargetTransformInfo(TargetTransformInfo &&Arg)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TargetTransformInfo&)",
    "insertText": "operator(TargetTransformInfo &&RHS)"
  },
  {
    "label": "TargetTransformInfo()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "TargetTransformInfo()"
  },
  {
    "label": "invalidate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "invalidate(Function &, const PreservedAnalyses &)"
  },
  {
    "label": "getGEPCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getGEPCost(const Value *Ptr, ArrayRef<const Value *> Operands)"
  },
  {
    "label": "getCallCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCallCost(FunctionType *FTy, int NumArgs = -1)"
  },
  {
    "label": "getCallCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCallCost(const Function *F, int NumArgs = -1)"
  },
  {
    "label": "getCallCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCallCost(const Function *F, ArrayRef<const Value *> Arguments)"
  },
  {
    "label": "getIntrinsicCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getIntrinsicCost(Intrinsic::ID IID, Type *RetTy, ArrayRef<Type *> ParamTys)"
  },
  {
    "label": "getIntrinsicCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getIntrinsicCost(Intrinsic::ID IID, Type *RetTy, ArrayRef<const Value *> Arguments)"
  },
  {
    "label": "getUserCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getUserCost(const User *U)"
  },
  {
    "label": "hasBranchDivergence()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasBranchDivergence()"
  },
  {
    "label": "isSourceOfDivergence()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isSourceOfDivergence(const Value *V)"
  },
  {
    "label": "isLoweredToCall()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLoweredToCall(const Function *F)"
  },
  {
    "label": "getUnrollingPreferences()",
    "kind": "Method",
    "detail": "Function (struct UnrollingPreferences { unsigned Threshold ; unsigned PercentDynamicCostSavedThreshold ; unsigned DynamicCostSavingsDiscount ; unsigned OptSizeThreshold ; unsigned PartialThreshold ; unsigned PartialOptSizeThreshold ; unsigned Count ; unsigned MaxCount ; bool Partial ; bool Runtime ; bool AllowExpensiveTripCount ; } ; void)",
    "insertText": "getUnrollingPreferences(Loop *L, UnrollingPreferences &UP)"
  },
  {
    "label": "isLegalAddImmediate()",
    "kind": "Method",
    "detail": "Function (enum PopcntSupportKind { PSK_Software,PSK_SlowHardware,PSK_FastHardware } ; bool)",
    "insertText": "isLegalAddImmediate(int64_t Imm)"
  },
  {
    "label": "isLegalICmpImmediate()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLegalICmpImmediate(int64_t Imm)"
  },
  {
    "label": "isLegalAddressingMode()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset, bool HasBaseReg, int64_t Scale, unsigned AddrSpace = 0)"
  },
  {
    "label": "isLegalMaskedStore()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLegalMaskedStore(Type *DataType, int Consecutive)"
  },
  {
    "label": "isLegalMaskedLoad()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLegalMaskedLoad(Type *DataType, int Consecutive)"
  },
  {
    "label": "getScalingFactorCost()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "getScalingFactorCost(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset, bool HasBaseReg, int64_t Scale, unsigned AddrSpace = 0)"
  },
  {
    "label": "isTruncateFree()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isTruncateFree(Type *Ty1, Type *Ty2)"
  },
  {
    "label": "isProfitableToHoist()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isProfitableToHoist(Instruction *I)"
  },
  {
    "label": "isTypeLegal()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isTypeLegal(Type *Ty)"
  },
  {
    "label": "getJumpBufAlignment()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getJumpBufAlignment()"
  },
  {
    "label": "getJumpBufSize()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getJumpBufSize()"
  },
  {
    "label": "shouldBuildLookupTables()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "shouldBuildLookupTables()"
  },
  {
    "label": "enableAggressiveInterleaving()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "enableAggressiveInterleaving(bool LoopHasReductions)"
  },
  {
    "label": "getPopcntSupport()",
    "kind": "Method",
    "detail": "Function (PopcntSupportKind)",
    "insertText": "getPopcntSupport(unsigned IntTyWidthInBit)"
  },
  {
    "label": "haveFastSqrt()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "haveFastSqrt(Type *Ty)"
  },
  {
    "label": "getFPOpCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getFPOpCost(Type *Ty)"
  },
  {
    "label": "getIntImmCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getIntImmCost(const APInt &Imm, Type *Ty)"
  },
  {
    "label": "getIntImmCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getIntImmCost(unsigned Opc, unsigned Idx, const APInt &Imm, Type *Ty)"
  },
  {
    "label": "getIntImmCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getIntImmCost(Intrinsic::ID IID, unsigned Idx, const APInt &Imm, Type *Ty)"
  },
  {
    "label": "getNumberOfRegisters()",
    "kind": "Method",
    "detail": "Function (enum ShuffleKind { SK_Broadcast,SK_Reverse,SK_Alternate,SK_InsertSubvector,SK_ExtractSubvector } ; enum OperandValueKind { OK_AnyValue,OK_UniformValue,OK_UniformConstantValue,OK_NonUniformConstantValue } ; enum OperandValueProperties { OP_None = 0,OP_PowerOf2 = 1 } ; unsigned)",
    "insertText": "getNumberOfRegisters(bool Vector)"
  },
  {
    "label": "getRegisterBitWidth()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getRegisterBitWidth(bool Vector)"
  },
  {
    "label": "getMaxInterleaveFactor()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getMaxInterleaveFactor(unsigned VF)"
  },
  {
    "label": "getArithmeticInstrCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getArithmeticInstrCost(unsigned Opcode, Type *Ty, OperandValueKind Opd1Info = OK_AnyValue, OperandValueKind Opd2Info = OK_AnyValue, OperandValueProperties Opd1PropInfo = OP_None, OperandValueProperties Opd2PropInfo = OP_None)"
  },
  {
    "label": "getShuffleCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getShuffleCost(ShuffleKind Kind, Type *Tp, int Index = 0, Type *SubTp = nullptr)"
  },
  {
    "label": "getCastInstrCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src)"
  },
  {
    "label": "getCFInstrCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCFInstrCost(unsigned Opcode)"
  },
  {
    "label": "getCmpSelInstrCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy = nullptr)"
  },
  {
    "label": "getVectorInstrCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getVectorInstrCost(unsigned Opcode, Type *Val, unsigned Index = -1)"
  },
  {
    "label": "getMemoryOpCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getMemoryOpCost(unsigned Opcode, Type *Src, unsigned Alignment, unsigned AddressSpace)"
  },
  {
    "label": "getMaskedMemoryOpCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getMaskedMemoryOpCost(unsigned Opcode, Type *Src, unsigned Alignment, unsigned AddressSpace)"
  },
  {
    "label": "getInterleavedMemoryOpCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getInterleavedMemoryOpCost(unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices, unsigned Alignment, unsigned AddressSpace)"
  },
  {
    "label": "getReductionCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getReductionCost(unsigned Opcode, Type *Ty, bool IsPairwiseForm)"
  },
  {
    "label": "getIntrinsicInstrCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getIntrinsicInstrCost(Intrinsic::ID ID, Type *RetTy, ArrayRef<Type *> Tys)"
  },
  {
    "label": "getCallInstrCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCallInstrCost(Function *F, Type *RetTy, ArrayRef<Type *> Tys)"
  },
  {
    "label": "getNumberOfParts()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getNumberOfParts(Type *Tp)"
  },
  {
    "label": "getAddressComputationCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getAddressComputationCost(Type *Ty, bool IsComplex = false)"
  },
  {
    "label": "getCostOfKeepingLiveOverCall()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys)"
  },
  {
    "label": "getTgtMemIntrinsic()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "getTgtMemIntrinsic(IntrinsicInst *Inst, MemIntrinsicInfo &Info)"
  },
  {
    "label": "getOrCreateResultFromMemIntrinsic()",
    "kind": "Method",
    "detail": "Function (Value*)",
    "insertText": "getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst, Type *ExpectedType)"
  },
  {
    "label": "hasCompatibleFunctionAttributes()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasCompatibleFunctionAttributes(const Function *Caller, const Function *Callee)"
  },
  {
    "label": "Concept()",
    "kind": "Method",
    "detail": "Function (private : class Concept ; template<T> class Model ; std::unique_ptr<Concept> TTIImpl ; } ; class TargetTransformInfo::Concept { public : ~)",
    "insertText": "Concept()"
  },
  {
    "label": "getDataLayout()",
    "kind": "Method",
    "detail": "Function (const DataLayout&)",
    "insertText": "getDataLayout()"
  },
  {
    "label": "getOperationCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getOperationCost(unsigned Opcode, Type *Ty, Type *OpTy)"
  },
  {
    "label": "getCallCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCallCost(FunctionType *FTy, int NumArgs)"
  },
  {
    "label": "getCallCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCallCost(const Function *F, int NumArgs)"
  },
  {
    "label": "isLegalAddressingMode()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset, bool HasBaseReg, int64_t Scale, unsigned AddrSpace)"
  },
  {
    "label": "getScalingFactorCost()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "getScalingFactorCost(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset, bool HasBaseReg, int64_t Scale, unsigned AddrSpace)"
  },
  {
    "label": "getArithmeticInstrCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getArithmeticInstrCost(unsigned Opcode, Type *Ty, OperandValueKind Opd1Info, OperandValueKind Opd2Info, OperandValueProperties Opd1PropInfo, OperandValueProperties Opd2PropInfo)"
  },
  {
    "label": "getShuffleCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getShuffleCost(ShuffleKind Kind, Type *Tp, int Index, Type *SubTp)"
  },
  {
    "label": "getCmpSelInstrCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy)"
  },
  {
    "label": "getVectorInstrCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getVectorInstrCost(unsigned Opcode, Type *Val, unsigned Index)"
  },
  {
    "label": "getAddressComputationCost()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getAddressComputationCost(Type *Ty, bool IsComplex)"
  },
  {
    "label": "Model()",
    "kind": "Method",
    "detail": "Function (} ; template<T> class TargetTransformInfo::Model final : public TargetTransformInfo::Concept { T Impl ; public :)",
    "insertText": "Model(T Impl) : Impl(std::move(Impl))"
  },
  {
    "label": "Model()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "Model()"
  },
  {
    "label": "TargetTransformInfo()",
    "kind": "Method",
    "detail": "Function (} } ; template<T>)",
    "insertText": "TargetTransformInfo(T Impl) : TTIImpl(new Model<T>(Impl))"
  },
  {
    "label": "ID()",
    "kind": "Method",
    "detail": "Function (} class TargetIRAnalysis { public : typedef TargetTransformInfo Result ; void*)",
    "insertText": "ID()"
  },
  {
    "label": "name()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "name()"
  },
  {
    "label": "TargetIRAnalysis()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TargetIRAnalysis(std::function<Result(Function &)> TTICallback)"
  },
  {
    "label": "TargetIRAnalysis()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TargetIRAnalysis(const TargetIRAnalysis &Arg) : TTICallback(Arg.TTICallback)"
  },
  {
    "label": "TargetIRAnalysis()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TargetIRAnalysis(TargetIRAnalysis &&Arg) : TTICallback(std::move(Arg.TTICallback))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TargetIRAnalysis&)",
    "insertText": "operator(const TargetIRAnalysis &RHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TTICallback = RHS . TTICallback ; return* this ; } TargetIRAnalysis&)",
    "insertText": "operator(TargetIRAnalysis &&RHS)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (TTICallback =)",
    "insertText": "move(RHS.TTICallback)"
  },
  {
    "label": "Result()",
    "kind": "Method",
    "detail": "Function (private : char PassID ; std::function<)",
    "insertText": "Result(Function &)"
  },
  {
    "label": "getDefaultTTI()",
    "kind": "Method",
    "detail": "Function (Result)",
    "insertText": "getDefaultTTI(Function &F)"
  },
  {
    "label": "anchor()",
    "kind": "Method",
    "detail": "Function (} ; class TargetTransformInfoWrapperPass : public ImmutablePass { TargetIRAnalysis TIRA ; Optional<TargetTransformInfo> TTI ; void)",
    "insertText": "anchor()"
  },
  {
    "label": "TargetTransformInfoWrapperPass()",
    "kind": "Method",
    "detail": "Function (public : char ID ;)",
    "insertText": "TargetTransformInfoWrapperPass()"
  },
  {
    "label": "TargetTransformInfoWrapperPass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TargetTransformInfoWrapperPass(TargetIRAnalysis TIRA)"
  },
  {
    "label": "getTTI()",
    "kind": "Method",
    "detail": "Function (TargetTransformInfo&)",
    "insertText": "getTTI(Function &F)"
  },
  {
    "label": "createTargetTransformInfoWrapperPass()",
    "kind": "Method",
    "detail": "Function (} ; ImmutablePass*)",
    "insertText": "createTargetTransformInfoWrapperPass(TargetIRAnalysis TIRA)"
  }
]