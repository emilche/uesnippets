[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "closestPoints()",
    "kind": "Method",
    "detail": "Function (# ifndef INCLUDED_IMATHLINEALGO_H # define INCLUDED_IMATHLINEALGO_H # include \" ImathFun . h \" # include \" ImathLine . h \" # include \" ImathNamespace . h \" # include \" ImathVecAlgo . h \" IMATH_INTERNAL_NAMESPACE_HEADER_ENTER template<class T> IMATH_CONSTEXPR14 bool)",
    "insertText": "closestPoints(const Line3<T>& line1, const Line3<T>& line2, Vec3<T>& point1, Vec3<T>& point2)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (Vec3<T> w = line1 . pos - line2 . pos ; T d1w = line1 . dir ^ w ; T d2w = line2 . dir ^ w ; T d1d2 = line1 . dir ^ line2 . dir ; T n1 = d1d2* d2w - d1w ; T n2 = d2w - d1d2* d1w ; T d = 1 - d1d2* d1d2 ; T absD =)",
    "insertText": "abs(d)"
  },
  {
    "label": "line1()",
    "kind": "Method",
    "detail": "Function (point1 =)",
    "insertText": "line1(n1 / d)"
  },
  {
    "label": "line2()",
    "kind": "Method",
    "detail": "Function (point2 =)",
    "insertText": "line2(n2 / d)"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (Vec3<T> edge0 = v1 - v0 ; Vec3<T> edge1 = v2 - v1 ; Vec3<T> normal = edge1 % edge0 ; T l = normal .)",
    "insertText": "length()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T nd = normal ^ line . dir ;)",
    "insertText": "if(abs (nd) > 1 || abs (d) < std::numeric_limits<T>::max() * abs (nd)) pt = line (d / nd)"
  },
  {
    "label": "c()",
    "kind": "Method",
    "detail": "Function (Vec3<T> a = pt - v0 ; Vec3<T> b = v2 - v0 ; Vec3<T>)",
    "insertText": "c(a - en * (en ^ a))"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "d(b - en * (en ^ b))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (T e = c ^ d ; T f = d ^ d ;)",
    "insertText": "if(e >= 0 && e <= f)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "front((line.dir ^ normal) < 0)"
  },
  {
    "label": "neardot()",
    "kind": "Method",
    "detail": "Function (Vec3<T> nearest = v0 ; T)",
    "insertText": "neardot(v0 - l.closestPointTo (v0)).length2()"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (T)",
    "insertText": "tmp(v1 - l.closestPointTo (v1)).length2()"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (neardot = tmp ; nearest = v1 ; })",
    "insertText": "tmp(v2 - l.closestPointTo (v2)).length2()"
  },
  {
    "label": "rotatePoint()",
    "kind": "Method",
    "detail": "Function (neardot = tmp ; nearest = v2 ; } return nearest ; } template<class T> IMATH_CONSTEXPR14 Vec3<T>)",
    "insertText": "rotatePoint(const Vec3<T> p, Line3<T> l, T angle)"
  },
  {
    "label": "closestPointTo()",
    "kind": "Method",
    "detail": "Function (Vec3<T> q = l .)",
    "insertText": "closestPointTo(p)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (x .)",
    "insertText": "normalize()"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (Vec3<T>)",
    "insertText": "y(x % l.dir).normalize()"
  },
  {
    "label": "cos()",
    "kind": "Method",
    "detail": "Function (T cosangle =)",
    "insertText": "cos(angle)"
  },
  {
    "label": "sin()",
    "kind": "Method",
    "detail": "Function (T sinangle =)",
    "insertText": "sin(angle)"
  }
]