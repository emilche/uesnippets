[
  {
    "label": "DiagonalPreconditioner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DiagonalPreconditioner"
  },
  {
    "label": "LeastSquareDiagonalPreconditioner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LeastSquareDiagonalPreconditioner"
  },
  {
    "label": "IdentityPreconditioner",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IdentityPreconditioner"
  },
  {
    "label": "DiagonalPreconditioner()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_BASIC_PRECONDITIONERS_H # define EIGEN_BASIC_PRECONDITIONERS_H namespace Eigen { template<_Scalar> class DiagonalPreconditioner { typedef _Scalar Scalar ; typedef Matrix<Scalar,Dynamic,1> Vector ; public : typedef Vector::StorageIndex StorageIndex ; enum { ColsAtCompileTime = Dynamic,MaxColsAtCompileTime = Dynamic } ;)",
    "insertText": "DiagonalPreconditioner() : m_isInitialized(false)"
  },
  {
    "label": "DiagonalPreconditioner()",
    "kind": "Method",
    "detail": "Function (} template<MatType>)",
    "insertText": "DiagonalPreconditioner(const MatType& mat) : m_invdiag(mat.cols())"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compute(mat)"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (} EIGEN_CONSTEXPR Index)",
    "insertText": "rows()"
  },
  {
    "label": "cols()",
    "kind": "Method",
    "detail": "Function (} EIGEN_CONSTEXPR Index)",
    "insertText": "cols()"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (} template<MatType> DiagonalPreconditioner&)",
    "insertText": "analyzePattern(const MatType&)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_invdiag .)",
    "insertText": "resize(mat.cols())"
  },
  {
    "label": "it()",
    "kind": "Method",
    "detail": "Function (MatType::InnerIterator)",
    "insertText": "it(mat,j)"
  },
  {
    "label": "compute()",
    "kind": "Method",
    "detail": "Function (} m_isInitialized = true ; return* this ; } template<MatType> DiagonalPreconditioner&)",
    "insertText": "compute(const MatType& mat)"
  },
  {
    "label": "_solve_impl()",
    "kind": "Method",
    "detail": "Function (} template<Rhs,Dest> void)",
    "insertText": "_solve_impl(const Rhs& b, Dest& x)"
  },
  {
    "label": "array()",
    "kind": "Method",
    "detail": "Function (x = m_invdiag .)",
    "insertText": "array() * b.array()"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (} template<Rhs> const Solve<DiagonalPreconditioner,Rhs>)",
    "insertText": "solve(const MatrixBase<Rhs>& b)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_isInitialized && \"DiagonalPreconditioner is not initialized.\")"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(m_invdiag.size()==b.rows() && \"DiagonalPreconditioner::solve(): invalid number of rows of the right hand side matrix b\")"
  },
  {
    "label": "info()",
    "kind": "Method",
    "detail": "Function (} ComputationInfo)",
    "insertText": "info()"
  },
  {
    "label": "LeastSquareDiagonalPreconditioner()",
    "kind": "Method",
    "detail": "Function (} template<MatType>)",
    "insertText": "LeastSquareDiagonalPreconditioner(const MatType& mat) : Base()"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (m_invdiag .)",
    "insertText": "setZero()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Index j=0; j<mat.cols(); ++j) if(numext::real(m_invdiag(j))>RealScalar(0)) m_invdiag(j) = RealScalar(1)/numext::real(m_invdiag(j))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "for(Index j=0; j<mat.outerSize(); ++j)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (RealScalar sum = mat .)",
    "insertText": "col(j).squaredNorm()"
  },
  {
    "label": "IdentityPreconditioner()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType>)",
    "insertText": "IdentityPreconditioner(const MatrixType&)"
  },
  {
    "label": "analyzePattern()",
    "kind": "Method",
    "detail": "Function (} template<MatrixType> IdentityPreconditioner&)",
    "insertText": "analyzePattern(const MatrixType&)"
  }
]