[
  {
    "label": "AnimationKeyFormat",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "AnimationKeyFormat"
  },
  {
    "label": "FMemoryReader",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMemoryReader"
  },
  {
    "label": "FMemoryWriter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMemoryWriter"
  },
  {
    "label": "UAnimCompress",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimCompress"
  },
  {
    "label": "UAnimCurveCompressionSettings",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimCurveCompressionSettings"
  },
  {
    "label": "UAnimBoneCompressionSettings",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimBoneCompressionSettings"
  },
  {
    "label": "UAnimBoneCompressionCodec",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimBoneCompressionCodec"
  },
  {
    "label": "USkeleton",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "USkeleton"
  },
  {
    "label": "FCompactPose",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompactPose"
  },
  {
    "label": "FBoneAnimationTrack",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBoneAnimationTrack"
  },
  {
    "label": "FCompressedOffsetDataBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompressedOffsetDataBase"
  },
  {
    "label": "FAnimationErrorStats",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimationErrorStats"
  },
  {
    "label": "FArcToHexString",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FArcToHexString"
  },
  {
    "label": "FCompressedOffsetData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompressedOffsetData"
  },
  {
    "label": "FCancelCompressionSignal",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCancelCompressionSignal"
  },
  {
    "label": "FCompressibleAnimData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompressibleAnimData"
  },
  {
    "label": "UAnimSequence",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimSequence"
  },
  {
    "label": "FCompressedAnimSequence",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompressedAnimSequence"
  },
  {
    "label": "TArrayMaker",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TArrayMaker"
  },
  {
    "label": "TNonConstArrayViewMaker",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TNonConstArrayViewMaker"
  },
  {
    "label": "TArrayViewMaker",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TArrayViewMaker"
  },
  {
    "label": "ContainerTypeMakerTemplate",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ContainerTypeMakerTemplate"
  },
  {
    "label": "FCompressedAnimDataBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompressedAnimDataBase"
  },
  {
    "label": "AnimEncoding",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AnimEncoding"
  },
  {
    "label": "OtherContainerMaker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "OtherContainerMaker"
  },
  {
    "label": "ICompressedAnimData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ICompressedAnimData"
  },
  {
    "label": "FArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FArchive"
  },
  {
    "label": "FCompressibleAnimDataResult",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCompressibleAnimDataResult"
  },
  {
    "label": "FUECompressedAnimDataMutable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUECompressedAnimDataMutable"
  },
  {
    "label": "FUECompressedAnimData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FUECompressedAnimData"
  },
  {
    "label": "TMaybeMappedAllocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMaybeMappedAllocator"
  },
  {
    "label": "ForAnyElementType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ForAnyElementType"
  },
  {
    "label": "ForElementType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ForElementType"
  },
  {
    "label": "TMaybeMappedArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TMaybeMappedArray"
  },
  {
    "label": "TIsContiguousContainer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsContiguousContainer"
  },
  {
    "label": "FAnimCompressedCurveIndexedName",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimCompressedCurveIndexedName"
  },
  {
    "label": "FTrackToSkeletonMap",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTrackToSkeletonMap"
  },
  {
    "label": "FSmartName",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSmartName"
  },
  {
    "label": "UAnimCurveCompressionCodec",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimCurveCompressionCodec"
  },
  {
    "label": "FRootMotionReset",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRootMotionReset"
  },
  {
    "label": "FAnimDDCKeyArgs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimDDCKeyArgs"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" UObject / ObjectMacros . h \" # include \" Misc / Guid . h \" # include \" Misc / MemStack . h \" # include \" Animation / AnimTypes . h \" # include \" Animation / AnimCurveTypes . h \" # include \" Animation / AnimationAsset . h \" # include \" Async / MappedFileHandle . h \" # include \" HAL / ThreadSafeBool . h \" # include \" HAL / PlatformFileManager . h \" # include \" GenericPlatform / GenericPlatformFile . h \" # include \" Misc / Paths . h \" # include \" Serialization / BulkData . h \" # include \" Serialization / MemoryReader . h \" # include \" Serialization / MemoryWriter . h \" # include \" ProfilingDebugging / CsvProfiler . h \" # include \" Animation / AnimationDecompression . h \" # include \" BoneContainer . h \" # if WITH_EDITOR # include \" ReferenceSkeleton . h \" # endif # include \" AnimCompressionTypes . generated . h \")",
    "insertText": "UENUM()"
  },
  {
    "label": "FCompressedOffsetDataBase()",
    "kind": "Method",
    "detail": "Function (AKF_ConstantKeyLerp,AKF_VariableKeyLerp,AKF_PerTrackCompression,AKF_MAX,} ; class FMemoryReader ; class FMemoryWriter ; class UAnimCompress ; class UAnimCurveCompressionSettings ; class UAnimBoneCompressionSettings ; class UAnimBoneCompressionCodec ; class USkeleton ; struct FCompactPose ; struct FBoneAnimationTrack ; template<ArrayClass> struct FCompressedOffsetDataBase { ArrayClass OffsetData ; int32 StripSize ;)",
    "insertText": "FCompressedOffsetDataBase(int32 InStripSize = 2) : StripSize(InStripSize)"
  },
  {
    "label": "SetStripSize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetStripSize(int32 InStripSize)"
  },
  {
    "label": "GetOffsetData()",
    "kind": "Method",
    "detail": "Function (StripSize = InStripSize ; } const int32)",
    "insertText": "GetOffsetData(int32 StripIndex, int32 Offset)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (OffsetData [ StripIndex* StripSize + Offset ] = Value ; } void)",
    "insertText": "AddUninitialized(int32 NumOfTracks)"
  },
  {
    "label": "AddUninitialized()",
    "kind": "Method",
    "detail": "Function (OffsetData .)",
    "insertText": "AddUninitialized(NumOfTracks*StripSize)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Empty(int32 NumOfTracks = 0)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (OffsetData .)",
    "insertText": "Empty(NumOfTracks*StripSize)"
  },
  {
    "label": "GetMemorySize()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetMemorySize()"
  },
  {
    "label": "GetNumTracks()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetNumTracks()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "USTRUCT()"
  },
  {
    "label": "GENERATED_USTRUCT_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_USTRUCT_BODY()"
  },
  {
    "label": "FAnimationErrorStats()",
    "kind": "Method",
    "detail": "Function (float MaxError ; float MaxErrorTime ; int32 MaxErrorBone ;)",
    "insertText": "FAnimationErrorStats() : AverageError(0.f) , MaxError(0.f) , MaxErrorTime(0.f) , MaxErrorBone(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; FArchive&)",
    "insertText": "operator(FArchive& Ar, FAnimationErrorStats& ErrorStats)"
  },
  {
    "label": "FArcToHexString()",
    "kind": "Method",
    "detail": "Function (struct FArcToHexString { private : TArray<uint8> TempBytes ; public : FMemoryWriter Ar ;)",
    "insertText": "FArcToHexString() : Ar(TempBytes)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TempBytes .)",
    "insertText": "Reserve(64)"
  },
  {
    "label": "MakeString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "MakeString()"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (FString Key ; const uint8* SettingsAsBytes = TempBytes .)",
    "insertText": "GetData()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (Key .)",
    "insertText": "Reserve(TempBytes.Num() + 1)"
  },
  {
    "label": "ByteToHex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ByteToHex(SettingsAsBytes[ByteIndex], Key)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return Key ; } } ; struct FCompressedOffsetData : public FCompressedOffsetDataBase<TArray<int32>> { } ; FArchive&)",
    "insertText": "operator(FArchive& Ar, FCompressedOffsetData& D)"
  },
  {
    "label": "FCancelCompressionSignal()",
    "kind": "Method",
    "detail": "Function (struct FCancelCompressionSignal { private : FThreadSafeBool Signal ; public :)",
    "insertText": "FCancelCompressionSignal()"
  },
  {
    "label": "FCancelCompressionSignal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FCancelCompressionSignal(const FCancelCompressionSignal&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FCancelCompressionSignal&)",
    "insertText": "operator(const FCancelCompressionSignal& Other)"
  },
  {
    "label": "Signal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Signal(bool)"
  },
  {
    "label": "IsCancelled()",
    "kind": "Method",
    "detail": "Function (Signal = true ; } bool)",
    "insertText": "IsCancelled()"
  },
  {
    "label": "FCompressibleAnimData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FCompressibleAnimData(UAnimBoneCompressionSettings* InBoneCompressionSettings, UAnimCurveCompressionSettings* InCurveCompressionSettings, USkeleton* InSkeleton, EAnimInterpolationType InInterpolation, float InSequenceLength, int32 InNumberOfKeys, const ITargetPlatform* InTargetPlatform)"
  },
  {
    "label": "FCompressibleAnimData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FCompressibleAnimData(class UAnimSequence* InSeq, const bool bPerformStripping, const ITargetPlatform* InTargetPlatform)"
  },
  {
    "label": "FCompressibleAnimData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FCompressibleAnimData(const FCompressibleAnimData&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FCompressibleAnimData&)",
    "insertText": "operator(const FCompressibleAnimData&)"
  },
  {
    "label": "GetNumberOfFrames()",
    "kind": "Method",
    "detail": "Function (int32 NumberOfKeys ; int32)",
    "insertText": "GetNumberOfFrames()"
  },
  {
    "label": "GetApproxRawDataArraySize()",
    "kind": "Method",
    "detail": "Function (} EAdditiveAnimationType AdditiveType = AAT_None ; bool bIsValidAdditive ; float ErrorThresholdScale ; FString Name ; FString FullName ; FName AnimFName ; FFrameRate SampledFrameRate ; FCancelCompressionSignal IsCancelledSignal ; bool bShouldPerformStripping = false ; TWeakObjectPtr<UAnimSequence> WeakSequence ; bool bDataFetched = false ; const ITargetPlatform* TargetPlatform = nullptr ; int64)",
    "insertText": "GetApproxRawDataArraySize(const TArray<FRawAnimSequenceTrack>& AnimData)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (int64 Total =)",
    "insertText": "sizeof(FRawAnimSequenceTrack) * int64(AnimData.Num())"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const FRawAnimSequenceTrack& RawTrack = AnimData [ i ] ; Total + =)",
    "insertText": "sizeof(FVector) * int64(RawTrack.PosKeys.Num()) + sizeof(FQuat) * int64(RawTrack.RotKeys.Num()) + sizeof(FVector) * int64(RawTrack.ScaleKeys.Num())"
  },
  {
    "label": "GetApproxRawBoneSize()",
    "kind": "Method",
    "detail": "Function (} return Total ; } int64)",
    "insertText": "GetApproxRawBoneSize()"
  },
  {
    "label": "GetApproxRawCurveSize()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "GetApproxRawCurveSize()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int64 Total = 0 ;)",
    "insertText": "for(const FFloatCurve& Curve : RawFloatCurves)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (Total + =)",
    "insertText": "sizeof(FFloatCurve)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (Total + =)",
    "insertText": "sizeof(FRichCurveKey) * int64(Curve.FloatCurve.Keys.Num())"
  },
  {
    "label": "GetApproxRawSize()",
    "kind": "Method",
    "detail": "Function (} return Total ; } int64)",
    "insertText": "GetApproxRawSize()"
  },
  {
    "label": "GetApproxMemoryUsage()",
    "kind": "Method",
    "detail": "Function (} uint64)",
    "insertText": "GetApproxMemoryUsage()"
  },
  {
    "label": "GetApproxRawSize()",
    "kind": "Method",
    "detail": "Function (const uint64 MemUsage =)",
    "insertText": "GetApproxRawSize() + TrackToSkeletonMapTable.GetAllocatedSize() + GetApproxRawDataArraySize(AdditiveBaseAnimationData) + BoneData.GetAllocatedSize()"
  },
  {
    "label": "Update()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Update(struct FCompressedAnimSequence& CompressedData)"
  },
  {
    "label": "AddReferencedObjects()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddReferencedObjects(FReferenceCollector& Collector)"
  },
  {
    "label": "AddReferencedObject()",
    "kind": "Method",
    "detail": "Function (Collector .)",
    "insertText": "AddReferencedObject(BoneCompressionSettings)"
  },
  {
    "label": "AddReferencedObject()",
    "kind": "Method",
    "detail": "Function (Collector .)",
    "insertText": "AddReferencedObject(CurveCompressionSettings)"
  },
  {
    "label": "BakeOutAdditiveIntoRawData()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "BakeOutAdditiveIntoRawData(const FFrameRate& SampleRate, TArray<FBoneAnimationTrack>& ResampledTrackData, TArray<FFloatCurve>& FloatCurves)"
  },
  {
    "label": "ResampleAnimationTrackData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResampleAnimationTrackData(const FFrameRate& SampleRate, TArray<FBoneAnimationTrack>& ResampledTrackData)"
  },
  {
    "label": "WriteCompressionDataToJSON()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "WriteCompressionDataToJSON(TArrayView<FName> OriginalTrackNames, TArrayView<FRawAnimSequenceTrack> FinalRawAnimationData, TArrayView<FName> FinalTrackNames)"
  },
  {
    "label": "FCompressedAnimDataBase()",
    "kind": "Method",
    "detail": "Function (} ; typedef TSharedPtr<FCompressibleAnimData,ESPMode::ThreadSafe> FCompressibleAnimPtr ; typedef TSharedRef<FCompressibleAnimData,ESPMode::ThreadSafe> FCompressibleAnimRef ; # endif template<T> struct TArrayMaker { using Type = TArray<T> ; } ; template<T> struct TNonConstArrayViewMaker { using Type = TArrayView<T> ; } ; template<T> struct TArrayViewMaker { using Type = TArrayView<const T> ; } ; template<template<> class ContainerTypeMakerTemplate> struct FCompressedAnimDataBase { ContainerTypeMakerTemplate<int32>::Type CompressedTrackOffsets ; FCompressedOffsetDataBase<ContainerTypeMakerTemplate<int32>::Type> CompressedScaleOffsets ; ContainerTypeMakerTemplate<uint8>::Type CompressedByteStream ; class AnimEncoding* TranslationCodec ; class AnimEncoding* RotationCodec ; class AnimEncoding* ScaleCodec ; enum AnimationKeyFormat KeyEncodingFormat ; AnimationCompressionFormat TranslationCompressionFormat ; AnimationCompressionFormat RotationCompressionFormat ; AnimationCompressionFormat ScaleCompressionFormat ; template<template<> class OtherContainerMaker>)",
    "insertText": "FCompressedAnimDataBase(FCompressedAnimDataBase<OtherContainerMaker>& InCompressedData) : CompressedTrackOffsets(InCompressedData.CompressedTrackOffsets) , CompressedByteStream(InCompressedData.CompressedByteStream) , TranslationCodec(InCompressedData.TranslationCodec) , RotationCodec(InCompressedData.RotationCodec) , ScaleCodec(InCompressedData.ScaleCodec) , KeyEncodingFormat(InCompressedData.KeyEncodingFormat) , TranslationCompressionFormat(InCompressedData.TranslationCompressionFormat) , RotationCompressionFormat(InCompressedData.RotationCompressionFormat) , ScaleCompressionFormat(InCompressedData.ScaleCompressionFormat)"
  },
  {
    "label": "FCompressedAnimDataBase()",
    "kind": "Method",
    "detail": "Function (CompressedScaleOffsets . OffsetData = InCompressedData . CompressedScaleOffsets . OffsetData ; CompressedScaleOffsets . StripSize = InCompressedData . CompressedScaleOffsets . StripSize ; })",
    "insertText": "FCompressedAnimDataBase() : TranslationCodec(nullptr) , RotationCodec(nullptr) , ScaleCodec(nullptr) , KeyEncodingFormat((AnimationKeyFormat)0) , TranslationCompressionFormat((AnimationCompressionFormat)0) , RotationCompressionFormat((AnimationCompressionFormat)0) , ScaleCompressionFormat((AnimationCompressionFormat)0)"
  },
  {
    "label": "ICompressedAnimData()",
    "kind": "Method",
    "detail": "Function (FAnimationErrorStats BoneCompressionErrorStats ; # endif)",
    "insertText": "ICompressedAnimData()"
  },
  {
    "label": "ICompressedAnimData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ICompressedAnimData(const ICompressedAnimData&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ICompressedAnimData&)",
    "insertText": "operator(const ICompressedAnimData&)"
  },
  {
    "label": "SerializeCompressedData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SerializeCompressedData(UObject* DataOwner, class FArchive& Ar)"
  },
  {
    "label": "Bind()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Bind(const TArrayView<uint8> BulkData)"
  },
  {
    "label": "GetApproxCompressedSize()",
    "kind": "Method",
    "detail": "Function (int64)",
    "insertText": "GetApproxCompressedSize()"
  },
  {
    "label": "GetDebugString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "GetDebugString()"
  },
  {
    "label": "FCompressibleAnimDataResult()",
    "kind": "Method",
    "detail": "Function (} ; struct FCompressibleAnimDataResult { TArray<uint8> CompressedByteStream ; TUniquePtr<ICompressedAnimData> AnimData ; UAnimBoneCompressionCodec* Codec ; void* CompressionUserData ;)",
    "insertText": "FCompressibleAnimDataResult() : CompressedByteStream() , AnimData() , Codec(nullptr) , CompressionUserData(nullptr)"
  },
  {
    "label": "RebaseTArrayView()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> TArrayView<T>)",
    "insertText": "RebaseTArrayView(const TArrayView<T>& ArrayView, const uint8* OriginalBase, const uint8* NewBase)"
  },
  {
    "label": "NewData()",
    "kind": "Method",
    "detail": "Function (T*)",
    "insertText": "NewData(T*)(NewBase + Offset)"
  },
  {
    "label": "FUECompressedAnimDataMutable()",
    "kind": "Method",
    "detail": "Function (} return ArrayView ; } struct FUECompressedAnimDataMutable : public ICompressedAnimData,public FCompressedAnimDataBase<TArrayMaker> {)",
    "insertText": "FUECompressedAnimDataMutable()"
  },
  {
    "label": "BuildFinalBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BuildFinalBuffer(TArray<uint8>& OutCompressedByteStream)"
  },
  {
    "label": "FUECompressedAnimData()",
    "kind": "Method",
    "detail": "Function (} } ; struct FUECompressedAnimData : public ICompressedAnimData,public FCompressedAnimDataBase<TNonConstArrayViewMaker> {)",
    "insertText": "FUECompressedAnimData()"
  },
  {
    "label": "FUECompressedAnimData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FUECompressedAnimData(FUECompressedAnimDataMutable& InCompressedData) : ICompressedAnimData(InCompressedData) , FCompressedAnimDataBase(InCompressedData)"
  },
  {
    "label": "InitViewsFromBuffer()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InitViewsFromBuffer(const TArrayView<uint8> BulkData)"
  },
  {
    "label": "ByteSwapData()",
    "kind": "Method",
    "detail": "Function (template<TArchive> void)",
    "insertText": "ByteSwapData(TArrayView<uint8> CompresedData, TArchive& MemoryStream)"
  },
  {
    "label": "ByteSwapIn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ByteSwapIn(TArrayView<uint8> CompressedData, FMemoryReader& MemoryStream)"
  },
  {
    "label": "ByteSwapData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ByteSwapData(CompressedData, MemoryStream)"
  },
  {
    "label": "ByteSwapOut()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ByteSwapOut(TArrayView<uint8> CompressedData, FMemoryWriter& MemoryStream)"
  },
  {
    "label": "SerializeCompressedData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SerializeCompressedData(class FArchive& Ar)"
  },
  {
    "label": "InitViewsFromBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "InitViewsFromBuffer(BulkData)"
  },
  {
    "label": "OnInvalidMaybeMappedAllocatorNum()",
    "kind": "Method",
    "detail": "Function (} } ; namespace UE::Animation::Private { [ [ noreturn ] ] void)",
    "insertText": "OnInvalidMaybeMappedAllocatorNum(int32 NewNum, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "ForAnyElementType()",
    "kind": "Method",
    "detail": "Function (} template<uint32 Alignment = DEFAULT_ALIGNMENT> class TMaybeMappedAllocator { public : using SizeType = int32 ; enum { NeedsElementType = false } ; enum { RequireRangeCheck = true } ; class ForAnyElementType { public :)",
    "insertText": "ForAnyElementType() : Data(nullptr) , MappedHandle(nullptr) , MappedRegion(nullptr)"
  },
  {
    "label": "MoveToEmpty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MoveToEmpty(ForAnyElementType& Other)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "ForAnyElementType()",
    "kind": "Method",
    "detail": "Function (Data = Other . Data ; Other . Data = nullptr ; MappedRegion = Other . MappedRegion ; Other . MappedRegion = nullptr ; MappedHandle = Other . MappedHandle ; Other . MappedHandle = nullptr ; } ~)",
    "insertText": "ForAnyElementType()"
  },
  {
    "label": "GetAllocation()",
    "kind": "Method",
    "detail": "Function (} FScriptContainerElement*)",
    "insertText": "GetAllocation()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (delete MappedRegion ; delete MappedHandle ; MappedRegion = nullptr ; MappedHandle = nullptr ; Data = nullptr ; } else)",
    "insertText": "if(Data || NewMax)"
  },
  {
    "label": "OnInvalidMaybeMappedAllocatorNum()",
    "kind": "Method",
    "detail": "Function (UE::Animation::)",
    "insertText": "OnInvalidMaybeMappedAllocatorNum(NewMax, NumBytesPerElement)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Data(FScriptContainerElement*)FMemory::Realloc(Data, NewMax*NumBytesPerElement, Alignment)"
  },
  {
    "label": "CalculateSlackReserve()",
    "kind": "Method",
    "detail": "Function (} } SizeType)",
    "insertText": "CalculateSlackReserve(SizeType NewMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackShrink()",
    "kind": "Method",
    "detail": "Function (} SizeType)",
    "insertText": "CalculateSlackShrink(SizeType NewMax, SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "CalculateSlackGrow()",
    "kind": "Method",
    "detail": "Function (} SizeType)",
    "insertText": "CalculateSlackGrow(SizeType NewMax, SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "GetAllocatedSize()",
    "kind": "Method",
    "detail": "Function (} SIZE_T)",
    "insertText": "GetAllocatedSize(SizeType CurrentMax, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (MappedHandle = InMappedHandle ; MappedRegion = InMappedRegion ;)",
    "insertText": "Data(FScriptContainerElement*)MappedRegion->GetMappedPtr()"
  },
  {
    "label": "Data()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "Data(FScriptContainerElement*)"
  },
  {
    "label": "IsMapped()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "IsMapped()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (delete MappedRegion ; delete MappedHandle ; MappedRegion = nullptr ; MappedHandle = nullptr ; Data = nullptr ; })",
    "insertText": "if(Data)"
  },
  {
    "label": "Free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Free(Data)"
  },
  {
    "label": "ForAnyElementType()",
    "kind": "Method",
    "detail": "Function (Data = nullptr ; } })",
    "insertText": "ForAnyElementType(const ForAnyElementType&)"
  },
  {
    "label": "ForElementType()",
    "kind": "Method",
    "detail": "Function (} ; template<ElementType> class ForElementType : public ForAnyElementType { public :)",
    "insertText": "ForElementType()"
  },
  {
    "label": "ResizeAllocation()",
    "kind": "Method",
    "detail": "Function (} } ; } ; template FORCENOINLINE void TMaybeMappedAllocator<DEFAULT_ALIGNMENT>::)",
    "insertText": "ResizeAllocation(SizeType PreviousNumElements, SizeType NumElements, SIZE_T NumBytesPerElement)"
  },
  {
    "label": "TMaybeMappedArray()",
    "kind": "Method",
    "detail": "Function (template<T,uint32 Alignment = DEFAULT_ALIGNMENT> class TMaybeMappedArray : public TArray<T,TMaybeMappedAllocator<Alignment>> { public :)",
    "insertText": "TMaybeMappedArray()"
  },
  {
    "label": "TMaybeMappedArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TMaybeMappedArray(TMaybeMappedArray&&)"
  },
  {
    "label": "TMaybeMappedArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TMaybeMappedArray(const TMaybeMappedArray&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TMaybeMappedArray&)",
    "insertText": "operator(TMaybeMappedArray&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TMaybeMappedArray&)",
    "insertText": "operator(const TMaybeMappedArray&)"
  },
  {
    "label": "AcceptOwnedBulkDataPtr()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AcceptOwnedBulkDataPtr(FOwnedBulkDataPtr* OwnedPtr, int32 Num)"
  },
  {
    "label": "AcceptFileMapping()",
    "kind": "Method",
    "detail": "Function (this -> ArrayNum = Num ; this -> ArrayMax = Num ; this -> AllocatorInstance .)",
    "insertText": "AcceptFileMapping(OwnedPtr->GetMappedHandle(), OwnedPtr->GetMappedRegion(), (void*)OwnedPtr->GetPointer())"
  },
  {
    "label": "RelinquishOwnership()",
    "kind": "Method",
    "detail": "Function (OwnedPtr ->)",
    "insertText": "RelinquishOwnership()"
  },
  {
    "label": "GENERATED_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_BODY() FAnimCompressedCurveIndexedName()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "operator(const FAnimCompressedCurveIndexedName& InOther)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FArchive&)",
    "insertText": "operator(FArchive& Ar, FAnimCompressedCurveIndexedName& Item)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Ar<<Item . CurveName ;)",
    "insertText": "if(Ar.IsCountingMemory())"
  },
  {
    "label": "UE_NONCOPYABLE()",
    "kind": "Method",
    "detail": "Function (int32 CurveIndex = INDEX_NONE ; } ; struct FCompressedAnimSequence { public :)",
    "insertText": "UE_NONCOPYABLE(FCompressedAnimSequence)"
  },
  {
    "label": "FCompressedAnimSequence()",
    "kind": "Method",
    "detail": "Function (TArray<FAnimCompressedCurveIndexedName> IndexedCurveNames ; # if WITH_EDITOR TArray<uint8> CompressedByteStream ; FByteBulkData OptionalBulk ; # else TMaybeMappedArray<uint8> CompressedByteStream ; # endif TArray<uint8> CompressedCurveByteStream ; TUniquePtr<ICompressedAnimData> CompressedDataStructure ; TObjectPtr<class UAnimBoneCompressionCodec> BoneCompressionCodec ; TObjectPtr<class UAnimCurveCompressionCodec> CurveCompressionCodec ; int32 CompressedRawDataSize ; # if WITH_EDITOR TArray<FRawAnimSequenceTrack> CompressedRawData ; FName OwnerName ; # endif)",
    "insertText": "FCompressedAnimSequence() : BoneCompressionCodec(nullptr) , CurveCompressionCodec(nullptr) , CompressedRawDataSize(0)"
  },
  {
    "label": "SerializeCompressedData()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SerializeCompressedData(FArchive& Ar, bool bDDCData, UObject* DataOwner, USkeleton* Skeleton, UAnimBoneCompressionSettings* BoneCompressionSettings, UAnimCurveCompressionSettings* CurveCompressionSettings, bool bCanUseBulkData=true)"
  },
  {
    "label": "RebuildCurveIndexTable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RebuildCurveIndexTable()"
  },
  {
    "label": "GetSkeletonIndexFromTrackIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetSkeletonIndexFromTrackIndex(const int32 TrackIndex)"
  },
  {
    "label": "ClearCompressedBoneData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearCompressedBoneData()"
  },
  {
    "label": "ClearCompressedCurveData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearCompressedCurveData()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValid(const UAnimSequence* AnimSequence, bool bLogInformation=false)"
  },
  {
    "label": "FRootMotionReset()",
    "kind": "Method",
    "detail": "Function (} ; struct FRootMotionReset {)",
    "insertText": "FRootMotionReset(bool bInEnableRootMotion, ERootMotionRootLock::Type InRootMotionRootLock, bool bInForceRootLock, FTransform InAnimFirstFrame, bool bInIsValidAdditive) : AnimFirstFrame(InAnimFirstFrame) , RootMotionRootLock(InRootMotionRootLock) , bEnableRootMotion(bInEnableRootMotion) , bForceRootLock(bInForceRootLock) , bIsValidAdditive(bInIsValidAdditive)"
  },
  {
    "label": "ResetRootBoneForRootMotion()",
    "kind": "Method",
    "detail": "Function (} FTransform AnimFirstFrame ; ERootMotionRootLock::Type RootMotionRootLock ; bool bEnableRootMotion ; bool bForceRootLock ; bool bIsValidAdditive ; void)",
    "insertText": "ResetRootBoneForRootMotion(FTransform& BoneTransform, const FTransform& RefPoseRootTransform)"
  },
  {
    "label": "SetScale3D()",
    "kind": "Method",
    "detail": "Function (BoneTransform .)",
    "insertText": "SetScale3D(BoneTransform.GetScale3D() - FVector(1.f))"
  },
  {
    "label": "ResetRootBoneForRootMotion()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ResetRootBoneForRootMotion(FTransform& BoneTransform, const FBoneContainer& RequiredBones)"
  },
  {
    "label": "ResetRootBoneForRootMotion()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResetRootBoneForRootMotion(BoneTransform, RequiredBones.GetRefPoseArray()[0])"
  },
  {
    "label": "FAnimDDCKeyArgs()",
    "kind": "Method",
    "detail": "Function (} } ; # if WITH_EDITORONLY_DATA namespace UE::Anim::Compression { struct FAnimDDCKeyArgs {)",
    "insertText": "FAnimDDCKeyArgs(const UAnimSequenceBase& AnimSequence)"
  },
  {
    "label": "FAnimDDCKeyArgs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAnimDDCKeyArgs(const UAnimSequenceBase& AnimSequence, const ITargetPlatform* TargetPlatform)"
  },
  {
    "label": "GetCompressionFrameRate()",
    "kind": "Method",
    "detail": "Function (const UAnimSequenceBase& AnimSequence ; const ITargetPlatform* TargetPlatform ; } ; FFrameRate)",
    "insertText": "GetCompressionFrameRate(const UAnimSequence& AnimSequence, const ITargetPlatform* TargetPlatform)"
  },
  {
    "label": "GenerateGuidFromRawAnimData()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITOR FGuid)",
    "insertText": "GenerateGuidFromRawAnimData(const TArray<FRawAnimSequenceTrack>& RawAnimationData, const FRawCurveTracks& RawCurveData)"
  }
]