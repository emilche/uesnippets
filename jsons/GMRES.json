[
  {
    "label": "GMRES",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GMRES"
  },
  {
    "label": "traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "traits"
  },
  {
    "label": "gmres()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_GMRES_H # define EIGEN_GMRES_H namespace Eigen { namespace internal { template<MatrixType,Rhs,Dest,Preconditioner> bool)",
    "insertText": "gmres(const MatrixType & mat, const Rhs & rhs, Dest & x, const Preconditioner & precond, Index &iters, const Index &restart, typename Dest::RealScalar & tol_error)"
  },
  {
    "label": "considerAsZero()",
    "kind": "Method",
    "detail": "Function (using std::sqrt ; using std::abs ; typedef Dest::RealScalar RealScalar ; typedef Dest::Scalar Scalar ; typedef Matrix<Scalar,Dynamic,1> VectorType ; typedef Matrix<Scalar,Dynamic,Dynamic,ColMajor> FMatrixType ; const RealScalar)",
    "insertText": "considerAsZero(std::numeric_limits<RealScalar>::min)()"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (x .)",
    "insertText": "setZero()"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (tol_error = 0 ; return true ; } RealScalar tol = tol_error ; const Index maxIters = iters ; iters = 0 ; const Index m = mat .)",
    "insertText": "rows()"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (VectorType p0 = rhs - mat* x ; VectorType r0 = precond .)",
    "insertText": "solve(p0)"
  },
  {
    "label": "norm()",
    "kind": "Method",
    "detail": "Function (const RealScalar r0Norm = r0 .)",
    "insertText": "norm()"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (tol_error = 0 ; return true ; } FMatrixType H =)",
    "insertText": "Zero(m, restart + 1)"
  },
  {
    "label": "Zero()",
    "kind": "Method",
    "detail": "Function (VectorType w =)",
    "insertText": "Zero(restart + 1)"
  },
  {
    "label": "G()",
    "kind": "Method",
    "detail": "Function (std::vector<JacobiRotation<Scalar>>)",
    "insertText": "G(restart)"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (VectorType)",
    "insertText": "t(m), v(m), workspace(m), x_new(m)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (Ref<VectorType> H0_tail = H .)",
    "insertText": "col(0).tail(m - 1)"
  },
  {
    "label": "makeHouseholder()",
    "kind": "Method",
    "detail": "Function (RealScalar beta ; r0 .)",
    "insertText": "makeHouseholder(H0_tail, tau.coeffRef(0), beta)"
  },
  {
    "label": "w()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "w(0) = Scalar(beta)"
  },
  {
    "label": "Unit()",
    "kind": "Method",
    "detail": "Function (+ + iters ; v =)",
    "insertText": "Unit(m, k - 1)"
  },
  {
    "label": "tail()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "tail(m - i).applyHouseholderOnTheLeft(H.col(i).tail(m - i - 1), tau.coeffRef(i), workspace.data())"
  },
  {
    "label": "noalias()",
    "kind": "Method",
    "detail": "Function (} t .)",
    "insertText": "noalias()"
  },
  {
    "label": "solve()",
    "kind": "Method",
    "detail": "Function (v = precond .)",
    "insertText": "solve(t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(v.tail(m - k).norm() != 0.0)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (Ref<VectorType> Hk_tail = H .)",
    "insertText": "col(k).tail(m - k - 1)"
  },
  {
    "label": "tail()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "tail(m - k).makeHouseholder(Hk_tail, tau.coeffRef(k), beta)"
  },
  {
    "label": "tail()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "tail(m - k).applyHouseholderOnTheLeft(Hk_tail, tau.coeffRef(k), workspace.data())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(k > 1)"
  },
  {
    "label": "applyOnTheLeft()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "applyOnTheLeft(i, i + 1, G[i].adjoint())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(k<m && v(k) != (Scalar) 0)"
  },
  {
    "label": "makeGivens()",
    "kind": "Method",
    "detail": "Function (G [ k - 1 ] .)",
    "insertText": "makeGivens(v(k - 1), v(k))"
  },
  {
    "label": "applyOnTheLeft()",
    "kind": "Method",
    "detail": "Function (v .)",
    "insertText": "applyOnTheLeft(k - 1, k, G[k - 1].adjoint())"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (} H .)",
    "insertText": "col(k-1).head(k) = v.head(k)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (tol_error =)",
    "insertText": "abs(w(k))"
  },
  {
    "label": "stop()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "stop(k==m || tol_error < tol || iters == maxIters)"
  },
  {
    "label": "head()",
    "kind": "Method",
    "detail": "Function (Ref<VectorType> y = w .)",
    "insertText": "head(k)"
  },
  {
    "label": "topLeftCorner()",
    "kind": "Method",
    "detail": "Function (H .)",
    "insertText": "topLeftCorner(k, k).template triangularView <Upper>().solveInPlace(y)"
  },
  {
    "label": "x_new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "x_new(i) += y(i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} x + = x_new ;)",
    "insertText": "if(stop)"
  },
  {
    "label": "GMRES()",
    "kind": "Method",
    "detail": "Function (} } } return false ; } } template<_MatrixType,_Preconditioner = DiagonalPreconditioner<_MatrixType::Scalar>> class GMRES ; namespace internal { template<_MatrixType,_Preconditioner> struct traits<GMRES<_MatrixType,_Preconditioner>> { typedef _MatrixType MatrixType ; typedef _Preconditioner Preconditioner ; } ; } template<_MatrixType,_Preconditioner> class GMRES : public IterativeSolverBase<GMRES<_MatrixType,_Preconditioner>> { typedef IterativeSolverBase<GMRES> Base ; using Base::matrix ; using Base::m_error ; using Base::m_iterations ; using Base::m_info ; using Base::m_isInitialized ; private : Index m_restart ; public : using Base::_solve_impl ; typedef _MatrixType MatrixType ; typedef MatrixType::Scalar Scalar ; typedef MatrixType::RealScalar RealScalar ; typedef _Preconditioner Preconditioner ; public :)",
    "insertText": "GMRES() : Base(), m_restart(30)"
  },
  {
    "label": "GMRES()",
    "kind": "Method",
    "detail": "Function (} template<MatrixDerived>)",
    "insertText": "GMRES(const EigenBase<MatrixDerived>& A) : Base(A.derived()), m_restart(30)"
  },
  {
    "label": "GMRES()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "GMRES()"
  },
  {
    "label": "get_restart()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "get_restart()"
  },
  {
    "label": "_solve_vector_with_guess_impl()",
    "kind": "Method",
    "detail": "Function (m_restart = restart ; } template<Rhs,Dest> void)",
    "insertText": "_solve_vector_with_guess_impl(const Rhs& b, Dest& x)"
  },
  {
    "label": "maxIterations()",
    "kind": "Method",
    "detail": "Function (m_iterations =)",
    "insertText": "maxIterations()"
  },
  {
    "label": "gmres()",
    "kind": "Method",
    "detail": "Function (m_error = Base::m_tolerance ; bool ret =)",
    "insertText": "gmres(matrix(), b, x, Base::m_preconditioner, m_iterations, m_restart, m_error)"
  },
  {
    "label": "m_info()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m_info(!ret)"
  }
]