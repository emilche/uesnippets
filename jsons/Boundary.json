[
  {
    "label": "CADKERNEL_API",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CADKERNEL_API"
  },
  {
    "label": "FLinearBoundary()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Core / Types . h \" # include \" Geo / GeoEnum . h \" # include \" Math / MathConst . h \" # include \" Math / Point . h \" namespace UE::CADKernel { # define MINIMAL_UNIT_LINEAR_TOLERANCE 1 e - 5 struct FLinearBoundary { const FLinearBoundary DefaultBoundary ; double Min ; double Max ;)",
    "insertText": "FLinearBoundary()"
  },
  {
    "label": "FLinearBoundary()",
    "kind": "Method",
    "detail": "Function (Min = 0 . ; Max = 1 . ; })",
    "insertText": "FLinearBoundary(const FLinearBoundary& Boundary) : Min(Boundary.Min) , Max(Boundary.Max)"
  },
  {
    "label": "FLinearBoundary()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FLinearBoundary(const double UMin, const double UMax)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(UMin, UMax)"
  },
  {
    "label": "FLinearBoundary()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FLinearBoundary(const FLinearBoundary& Boundary, const double OffsetTolerance) : Min(Boundary.Min - OffsetTolerance) , Max(Boundary.Max + OffsetTolerance)"
  },
  {
    "label": "FLinearBoundary()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FLinearBoundary(const double UMin, const double UMax, const double OffsetTolerance)"
  },
  {
    "label": "Offset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Offset(OffsetTolerance)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FArchive&)",
    "insertText": "operator(FArchive& Ar, FLinearBoundary& Boundary)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Serialize(&Boundary, sizeof(FLinearBoundary))"
  },
  {
    "label": "GetMiddle()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "GetMiddle()"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "Size()"
  },
  {
    "label": "GetMinMax()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetMinMax(Coordinates, Max, Min, Max)"
  },
  {
    "label": "SetMax()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetMax(const double Coordinates)"
  },
  {
    "label": "GetMinMax()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetMinMax(Min, Coordinates, Min, Max)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(const double InUMin = 0., const double InUMax = 1.)"
  },
  {
    "label": "GetMinMax()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetMinMax(InUMin, InUMax, Min, Max)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(const TArray<double>& Coordinates)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Init()"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExtendTo(Coordinate)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "Length()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "Length()"
  },
  {
    "label": "IsDegenerated()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDegenerated()"
  },
  {
    "label": "ComputeMinimalTolerance()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "ComputeMinimalTolerance()"
  },
  {
    "label": "MoveInsideIfNot()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MoveInsideIfNot(double& Coordinate, const double Tolerance = DOUBLE_SMALL_NUMBER)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Coordinate = Min + Tolerance ; } else)",
    "insertText": "if(Coordinate >= Max)"
  },
  {
    "label": "Offset()",
    "kind": "Method",
    "detail": "Function (Coordinate = Max - Tolerance ; } } void)",
    "insertText": "Offset(const double Tolerance = DOUBLE_SMALL_NUMBER)"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (Min = HUGE_VALUE ; Max = - HUGE_VALUE ; } void)",
    "insertText": "ExtendTo(double MinCoordinate, double MaxCoordinate)"
  },
  {
    "label": "GetMinMax()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetMinMax(MinCoordinate, MaxCoordinate)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Min =)",
    "insertText": "Min(Min, MinCoordinate)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Max =)",
    "insertText": "Max(Max, MaxCoordinate)"
  },
  {
    "label": "TrimAt()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TrimAt(const FLinearBoundary& MaxBound)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (* this = MaxBound ; return ; } Min =)",
    "insertText": "Max(Min, MaxBound.Min)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Max =)",
    "insertText": "Min(Max, MaxBound.Max)"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExtendTo(const FLinearBoundary& MaxBound)"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (Min =)",
    "insertText": "Min(Min, MaxBound.Min)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (Max =)",
    "insertText": "Max(Max, MaxBound.Max)"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExtendTo(const double Coordinate)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Min = Coordinate ; })",
    "insertText": "if(Coordinate > Max)"
  },
  {
    "label": "RestrictTo()",
    "kind": "Method",
    "detail": "Function (Max = Coordinate ; } } void)",
    "insertText": "RestrictTo(const FLinearBoundary& MaxBound)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Min = MaxBound . Min ; })",
    "insertText": "if(MaxBound.Max < Max)"
  },
  {
    "label": "WidenIfDegenerated()",
    "kind": "Method",
    "detail": "Function (Max = MaxBound . Max ; } } void)",
    "insertText": "WidenIfDegenerated()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Min - = DOUBLE_SMALL_NUMBER ; Max + = DOUBLE_SMALL_NUMBER ; } } FLinearBoundary&)",
    "insertText": "operator(const FLinearBoundary& InBounds)"
  },
  {
    "label": "FSurfacicBoundary()",
    "kind": "Method",
    "detail": "Function (Min = InBounds . Min ; Max = InBounds . Max ; return* this ; } } ; class FSurfacicBoundary { private : FLinearBoundary UVBoundaries [ 2 ] ; public : const FSurfacicBoundary DefaultBoundary ;)",
    "insertText": "FSurfacicBoundary()"
  },
  {
    "label": "FSurfacicBoundary()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSurfacicBoundary(const double InUMin, const double InUMax, const double InVMin, const double InVMax)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoU ] .)",
    "insertText": "Set(InUMin, InUMax)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoV ] .)",
    "insertText": "Set(InVMin, InVMax)"
  },
  {
    "label": "FSurfacicBoundary()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSurfacicBoundary(const double InUMin, const double InUMax, const double InVMin, const double InVMax, const double OffsetTolerance)"
  },
  {
    "label": "FSurfacicBoundary()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSurfacicBoundary(const FPoint2D& Point1, const FPoint2D& Point2)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Set(Point1, Point2)"
  },
  {
    "label": "FSurfacicBoundary()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FSurfacicBoundary(const FPoint2D& Point1, const FPoint2D& Point2, const double OffsetTolerance)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(const FPoint2D& Point1, const FPoint2D& Point2)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoU ] .)",
    "insertText": "Set(Point1.U, Point2.U)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoV ] .)",
    "insertText": "Set(Point1.V, Point2.V)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FArchive&)",
    "insertText": "operator(FArchive& Ar, FSurfacicBoundary& Boundary)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (Ar<<Boundary [ EIso::IsoU ] ; Ar<<Boundary [ EIso::IsoV ] ; return Ar ; } void)",
    "insertText": "Set(const FLinearBoundary& BoundU, const FLinearBoundary& BoundV)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoU ] = BoundU ; UVBoundaries [ EIso::IsoV ] = BoundV ; } void)",
    "insertText": "Set(const double InUMin, const double InUMax, const double InVMin, const double InVMax)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set()"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Set(const TArray<FPoint2D>& Points)"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExtendTo(Point)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (} } const FLinearBoundary&)",
    "insertText": "Get(EIso Type)"
  },
  {
    "label": "IsInside()",
    "kind": "Method",
    "detail": "Function (} ESituation)",
    "insertText": "IsInside(const FSurfacicBoundary& OtherBoundary, const FSurfacicTolerance& Tolerance2D)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (int32 Inside = 0 ; int32 Outside = 0 ; TFunction<)",
    "insertText": "void(double, double, double)> CheckInside = [&](double LeftSide, double RigthSide, double Tolerance)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Inside + + ; } else)",
    "insertText": "if(RigthSide + Tolerance < LeftSide)"
  },
  {
    "label": "CheckInside()",
    "kind": "Method",
    "detail": "Function (Outside + + ; } } ;)",
    "insertText": "CheckInside(OtherBoundary[EIso::IsoU].GetMin(), UVBoundaries[EIso::IsoU].GetMin(), Tolerance2D[EIso::IsoU])"
  },
  {
    "label": "TrimAt()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "TrimAt(const FSurfacicBoundary& MaxLimit)"
  },
  {
    "label": "TrimAt()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoU ] .)",
    "insertText": "TrimAt(MaxLimit[EIso::IsoU])"
  },
  {
    "label": "TrimAt()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoV ] .)",
    "insertText": "TrimAt(MaxLimit[EIso::IsoV])"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExtendTo(const FSurfacicBoundary& MaxLimit)"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoU ] .)",
    "insertText": "ExtendTo(MaxLimit[EIso::IsoU])"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoV ] .)",
    "insertText": "ExtendTo(MaxLimit[EIso::IsoV])"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExtendTo(const FPoint2D& Point)"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoU ] .)",
    "insertText": "ExtendTo(Point.U)"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoV ] .)",
    "insertText": "ExtendTo(Point.V)"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ExtendTo(const FPoint& Point)"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoU ] .)",
    "insertText": "ExtendTo(Point.X)"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoV ] .)",
    "insertText": "ExtendTo(Point.Y)"
  },
  {
    "label": "RestrictTo()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RestrictTo(const FSurfacicBoundary& MaxBound)"
  },
  {
    "label": "RestrictTo()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoU ] .)",
    "insertText": "RestrictTo(MaxBound.UVBoundaries[EIso::IsoU])"
  },
  {
    "label": "RestrictTo()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoV ] .)",
    "insertText": "RestrictTo(MaxBound.UVBoundaries[EIso::IsoV])"
  },
  {
    "label": "MoveInsideIfNot()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MoveInsideIfNot(FPoint& Point, const double Tolerance = DOUBLE_SMALL_NUMBER)"
  },
  {
    "label": "MoveInsideIfNot()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoU ] .)",
    "insertText": "MoveInsideIfNot(Point.X, Tolerance)"
  },
  {
    "label": "MoveInsideIfNot()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoV ] .)",
    "insertText": "MoveInsideIfNot(Point.Y, Tolerance)"
  },
  {
    "label": "MoveInsideIfNot()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "MoveInsideIfNot(FPoint2D& Point, const double Tolerance = DOUBLE_SMALL_NUMBER)"
  },
  {
    "label": "MoveInsideIfNot()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoU ] .)",
    "insertText": "MoveInsideIfNot(Point.U, Tolerance)"
  },
  {
    "label": "MoveInsideIfNot()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoV ] .)",
    "insertText": "MoveInsideIfNot(Point.V, Tolerance)"
  },
  {
    "label": "Length()",
    "kind": "Method",
    "detail": "Function (} double)",
    "insertText": "Length(const EIso& Iso)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const FLinearBoundary&)",
    "insertText": "operator(const EIso& Iso)"
  },
  {
    "label": "Offset()",
    "kind": "Method",
    "detail": "Function (UVBoundaries [ EIso::IsoU ] .)",
    "insertText": "Offset(Tolerance)"
  }
]