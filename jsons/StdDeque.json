[
  {
    "label": "deque",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "deque"
  },
  {
    "label": "EIGEN_DEFINE_STL_DEQUE_SPECIALIZATION()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_STDDEQUE_H # define EIGEN_STDDEQUE_H # include \" details . h \" # define)",
    "insertText": "EIGEN_DEFINE_STL_DEQUE_SPECIALIZATION(...)"
  },
  {
    "label": "deque()",
    "kind": "Method",
    "detail": "Function (\\ template<> \\ class deque<__VA_ARGS__,std::allocator<__VA_ARGS__>> \\ : public deque<__VA_ARGS__,EIGEN_ALIGNED_ALLOCATOR<__VA_ARGS__>> \\ { \\ typedef deque<__VA_ARGS__,EIGEN_ALIGNED_ALLOCATOR<__VA_ARGS__>> deque_base ; \\ public : \\ typedef __VA_ARGS__ value_type ; \\ typedef deque_base::allocator_type allocator_type ; \\ typedef deque_base::size_type size_type ; \\ typedef deque_base::iterator iterator ; \\)",
    "insertText": "deque(const allocator_type& a = allocator_type()) : deque_base(a)"
  },
  {
    "label": "deque()",
    "kind": "Method",
    "detail": "Function (} \\ template<InputIterator> \\)",
    "insertText": "deque(InputIterator first, InputIterator last, const allocator_type& a = allocator_type()) : deque_base(first, last, a)"
  },
  {
    "label": "deque()",
    "kind": "Method",
    "detail": "Function (} \\)",
    "insertText": "deque(const deque& c) : deque_base(c)"
  },
  {
    "label": "deque()",
    "kind": "Method",
    "detail": "Function (} \\)",
    "insertText": "deque(size_type num, const value_type& val = value_type()) : deque_base(num, val)"
  },
  {
    "label": "deque()",
    "kind": "Method",
    "detail": "Function (} \\)",
    "insertText": "deque(iterator start_, iterator end_) : deque_base(start_, end_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} \\ deque&)",
    "insertText": "operator(const deque& x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "operator(x)"
  },
  {
    "label": "EIGEN_HAS_CXX11_CONTAINERS()",
    "kind": "Method",
    "detail": "Function (\\ return* this ; \\ } \\ } ; \\ } # if !)",
    "insertText": "EIGEN_HAS_CXX11_CONTAINERS(defined(_GLIBCXX_DEQUE) && (!EIGEN_GNUC_AT_LEAST(4,1)))"
  },
  {
    "label": "deque()",
    "kind": "Method",
    "detail": "Function (} \\ template<InputIterator> \\)",
    "insertText": "deque(InputIterator first, InputIterator last, const allocator_type& a = allocator_type()) \\ : deque_base(first, last, a)"
  },
  {
    "label": "EIGEN_WORKAROUND_MSVC_STL_SUPPORT()",
    "kind": "Method",
    "detail": "Function (\\ return* this ; \\ } template<T> class deque<T,EIGEN_ALIGNED_ALLOCATOR<T>> : public deque<)",
    "insertText": "EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T), Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (EIGEN_STD_DEQUE_SPECIALIZATION_BODY void)",
    "insertText": "resize(size_type new_size)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resize(new_size, T())"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if)",
    "insertText": "defined(_DEQUE_) void resize(size_type new_size, const value_type& x)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_back(const value_type& x)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "push_back(x)"
  },
  {
    "label": "push_front()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push_front(const value_type& x)"
  },
  {
    "label": "push_front()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "push_front(x)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} using deque_base::insert ; iterator)",
    "insertText": "insert(const_iterator position, const value_type& x)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "insert(const_iterator position, size_type new_size, const value_type& x)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insert(position, new_size, x)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} # else void)",
    "insertText": "resize(size_type new_size, const value_type& x)"
  }
]