[
  {
    "label": "WorkerThreadObserver",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "WorkerThreadObserver"
  },
  {
    "label": "TaskTracker",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TaskTracker"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "ScopedCommandsExecutor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScopedCommandsExecutor"
  },
  {
    "label": "WorkerThreadDelegateImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "WorkerThreadDelegateImpl"
  },
  {
    "label": "ThreadGroupImplBlockingTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadGroupImplBlockingTest"
  },
  {
    "label": "ThreadGroupImplMayBlockTest",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ThreadGroupImplMayBlockTest"
  },
  {
    "label": "InitializedInStart",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InitializedInStart"
  },
  {
    "label": "ThreadGroupImpl()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TASK_THREAD_POOL_THREAD_GROUP_IMPL_H_ # define BASE_TASK_THREAD_POOL_THREAD_GROUP_IMPL_H_ # include<stddef . h> # include<memory> # include<string> # include<vector> # include \" base / base_export . h \" # include \" base / check . h \" # include \" base / compiler_specific . h \" # include \" base / dcheck_is_on . h \" # include \" base / gtest_prod_util . h \" # include \" base / memory / raw_ptr . h \" # include \" base / strings / string_piece . h \" # include \" base / synchronization / condition_variable . h \" # include \" base / synchronization / waitable_event . h \" # include \" base / task / sequenced_task_runner . h \" # include \" base / task / task_features . h \" # include \" base / task / thread_pool / task . h \" # include \" base / task / thread_pool / task_source . h \" # include \" base / task / thread_pool / thread_group . h \" # include \" base / task / thread_pool / tracked_ref . h \" # include \" base / task / thread_pool / worker_thread . h \" # include \" base / task / thread_pool / worker_thread_stack . h \" # include \" base / time / time . h \" # include \" third_party / abseil - cpp / absl / types / optional . h \" namespace base { class WorkerThreadObserver ; namespace internal { class TaskTracker ; class BASE_EXPORT ThreadGroupImpl : public ThreadGroup { public :)",
    "insertText": "ThreadGroupImpl(StringPiece histogram_label, StringPiece thread_group_label, ThreadType thread_type_hint, TrackedRef<TaskTracker> task_tracker, TrackedRef<Delegate> delegate)"
  },
  {
    "label": "Start()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Start(size_t max_tasks, size_t max_best_effort_tasks, TimeDelta suggested_reclaim_time, scoped_refptr<SingleThreadTaskRunner> service_thread_task_runner, WorkerThreadObserver* worker_thread_observer, WorkerEnvironment worker_environment, bool synchronous_thread_start_for_testing = false, absl::optional<TimeDelta> may_block_threshold = absl::optional<TimeDelta>())"
  },
  {
    "label": "ThreadGroupImpl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ThreadGroupImpl(const ThreadGroupImpl&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ThreadGroupImpl&)",
    "insertText": "operator(const ThreadGroupImpl&)"
  },
  {
    "label": "ThreadGroupImpl()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ThreadGroupImpl()"
  },
  {
    "label": "JoinForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "JoinForTesting()"
  },
  {
    "label": "GetMaxConcurrentNonBlockedTasksDeprecated()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetMaxConcurrentNonBlockedTasksDeprecated()"
  },
  {
    "label": "DidUpdateCanRunPolicy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DidUpdateCanRunPolicy()"
  },
  {
    "label": "OnShutdownStarted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OnShutdownStarted()"
  },
  {
    "label": "WaitForWorkersIdleForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitForWorkersIdleForTesting(size_t n)"
  },
  {
    "label": "WaitForWorkersIdleLockRequiredForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitForWorkersIdleLockRequiredForTesting(size_t n) EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "WaitForAllWorkersIdleForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitForAllWorkersIdleForTesting()"
  },
  {
    "label": "WaitForWorkersCleanedUpForTesting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitForWorkersCleanedUpForTesting(size_t n)"
  },
  {
    "label": "NumberOfWorkersForTesting()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "NumberOfWorkersForTesting()"
  },
  {
    "label": "GetMaxTasksForTesting()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetMaxTasksForTesting()"
  },
  {
    "label": "GetMaxBestEffortTasksForTesting()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetMaxBestEffortTasksForTesting()"
  },
  {
    "label": "NumberOfIdleWorkersForTesting()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "NumberOfIdleWorkersForTesting()"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (private : class ScopedCommandsExecutor ; class WorkerThreadDelegateImpl ; class ThreadGroupImplBlockingTest ; class ThreadGroupImplMayBlockTest ;)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(ThreadGroupImplBlockingTest, ThreadBlockUnblockPremature)"
  },
  {
    "label": "FRIEND_TEST_ALL_PREFIXES()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRIEND_TEST_ALL_PREFIXES(ThreadGroupImplBlockingTest, ThreadBlockUnblockPrematureBestEffort)"
  },
  {
    "label": "UpdateSortKey()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateSortKey(TaskSource::Transaction transaction)"
  },
  {
    "label": "PushTaskSourceAndWakeUpWorkers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PushTaskSourceAndWakeUpWorkers(TransactionWithRegisteredTaskSource transaction_with_task_source)"
  },
  {
    "label": "EnsureEnoughWorkersLockRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnsureEnoughWorkersLockRequired(BaseScopedCommandsExecutor* executor) override EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "MaintainAtLeastOneIdleWorkerLockRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaintainAtLeastOneIdleWorkerLockRequired(ScopedCommandsExecutor* executor) EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "CanWorkerCleanupForTestingLockRequired()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CanWorkerCleanupForTestingLockRequired() EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "CreateAndRegisterWorkerLockRequired()",
    "kind": "Method",
    "detail": "Function (scoped_refptr<WorkerThread>)",
    "insertText": "CreateAndRegisterWorkerLockRequired(ScopedCommandsExecutor* executor) EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "GetNumAwakeWorkersLockRequired()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetNumAwakeWorkersLockRequired() const EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "GetDesiredNumAwakeWorkersLockRequired()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "GetDesiredNumAwakeWorkersLockRequired() const EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "AdjustMaxTasks()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AdjustMaxTasks()"
  },
  {
    "label": "may_block_threshold_for_testing()",
    "kind": "Method",
    "detail": "Function (TimeDelta)",
    "insertText": "may_block_threshold_for_testing()"
  },
  {
    "label": "blocked_workers_poll_period_for_testing()",
    "kind": "Method",
    "detail": "Function (} TimeDelta)",
    "insertText": "blocked_workers_poll_period_for_testing()"
  },
  {
    "label": "ScheduleAdjustMaxTasks()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ScheduleAdjustMaxTasks()"
  },
  {
    "label": "MaybeScheduleAdjustMaxTasksLockRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaybeScheduleAdjustMaxTasksLockRequired(ScopedCommandsExecutor* executor) EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "ShouldPeriodicallyAdjustMaxTasksLockRequired()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShouldPeriodicallyAdjustMaxTasksLockRequired() EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "UpdateMinAllowedPriorityLockRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UpdateMinAllowedPriorityLockRequired() EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "IsOnIdleStackLockRequired()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsOnIdleStackLockRequired(WorkerThread* worker) const EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "DecrementTasksRunningLockRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecrementTasksRunningLockRequired(TaskPriority priority) EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "IncrementTasksRunningLockRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IncrementTasksRunningLockRequired(TaskPriority priority) EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "DecrementMaxTasksLockRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecrementMaxTasksLockRequired() EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "IncrementMaxTasksLockRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IncrementMaxTasksLockRequired() EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "DecrementMaxBestEffortTasksLockRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecrementMaxBestEffortTasksLockRequired() EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "IncrementMaxBestEffortTasksLockRequired()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IncrementMaxBestEffortTasksLockRequired() EXCLUSIVE_LOCKS_REQUIRED(lock_)"
  },
  {
    "label": "InitializedInStart()",
    "kind": "Method",
    "detail": "Function (struct InitializedInStart {)",
    "insertText": "InitializedInStart()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON()"
  },
  {
    "label": "in_start()",
    "kind": "Method",
    "detail": "Function (# endif size_t initial_max_tasks = 0 ; TimeDelta suggested_reclaim_time ; bool no_worker_reclaim = false ; WorkerEnvironment worker_environment = WorkerEnvironment::NONE ; scoped_refptr<SingleThreadTaskRunner> service_thread_task_runner ; raw_ptr<WorkerThreadObserver> worker_thread_observer = nullptr ; TimeDelta may_block_threshold ; TimeDelta blocked_workers_poll_period ; } initialized_in_start_ ; InitializedInStart&)",
    "insertText": "in_start()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() DCHECK(!initialized_in_start_.initialized)"
  },
  {
    "label": "after_start()",
    "kind": "Method",
    "detail": "Function (# endif return initialized_in_start_ ; } const InitializedInStart&)",
    "insertText": "after_start()"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() DCHECK(initialized_in_start_.initialized)"
  },
  {
    "label": "GUARDED_BY()",
    "kind": "Method",
    "detail": "Function (# endif return initialized_in_start_ ; } const std::string thread_group_label_ ; const ThreadType thread_type_hint_ ; std::vector<scoped_refptr<WorkerThread>> workers_)",
    "insertText": "GUARDED_BY(lock_)"
  },
  {
    "label": "DCHECK_IS_ON()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "DCHECK_IS_ON() bool some_workers_cleaned_up_for_testing_ GUARDED_BY(lock_)"
  }
]