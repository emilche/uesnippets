[
  {
    "label": "ApmDataDumper",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ApmDataDumper"
  },
  {
    "label": "MatchedFilterLagAggregator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MatchedFilterLagAggregator"
  },
  {
    "label": "PreEchoLagAggregator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PreEchoLagAggregator"
  },
  {
    "label": "HighestPeakAggregator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HighestPeakAggregator"
  },
  {
    "label": "MatchedFilterLagAggregator()",
    "kind": "Method",
    "detail": "Function (# ifndef MODULES_AUDIO_PROCESSING_AEC3_MATCHED_FILTER_LAG_AGGREGATOR_H_ # define MODULES_AUDIO_PROCESSING_AEC3_MATCHED_FILTER_LAG_AGGREGATOR_H_ # include<vector> # include \" absl / types / optional . h \" # include \" api / audio / echo_canceller3_config . h \" # include \" modules / audio_processing / aec3 / delay_estimate . h \" # include \" modules / audio_processing / aec3 / matched_filter . h \" namespace webrtc { class ApmDataDumper ; class MatchedFilterLagAggregator { public :)",
    "insertText": "MatchedFilterLagAggregator(ApmDataDumper* data_dumper, size_t max_filter_lag, const EchoCanceller3Config::Delay& delay_config)"
  },
  {
    "label": "MatchedFilterLagAggregator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MatchedFilterLagAggregator()"
  },
  {
    "label": "MatchedFilterLagAggregator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MatchedFilterLagAggregator(const MatchedFilterLagAggregator&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MatchedFilterLagAggregator&)",
    "insertText": "operator(const MatchedFilterLagAggregator&)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset(bool hard_reset)"
  },
  {
    "label": "Aggregate()",
    "kind": "Method",
    "detail": "Function (absl::optional<DelayEstimate>)",
    "insertText": "Aggregate(const absl::optional<const MatchedFilter::LagEstimate>& lag_estimate)"
  },
  {
    "label": "ReliableDelayFound()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ReliableDelayFound()"
  },
  {
    "label": "PreEchoLagAggregator()",
    "kind": "Method",
    "detail": "Function (} private : class PreEchoLagAggregator { public :)",
    "insertText": "PreEchoLagAggregator(size_t max_filter_lag, size_t down_sampling_factor)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "Aggregate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Aggregate(int pre_echo_lag)"
  },
  {
    "label": "pre_echo_candidate()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "pre_echo_candidate()"
  },
  {
    "label": "HighestPeakAggregator()",
    "kind": "Method",
    "detail": "Function (private : const int block_size_log2_ ; std::array<int,2 5 0> histogram_data_ ; std::vector<int> histogram_ ; int histogram_data_index_ = 0 ; int pre_echo_candidate_ = 0 ; } ; class HighestPeakAggregator { public :)",
    "insertText": "HighestPeakAggregator(size_t max_filter_lag)"
  },
  {
    "label": "Aggregate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Aggregate(int lag)"
  },
  {
    "label": "candidate()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "candidate()"
  }
]