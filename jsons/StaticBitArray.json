[
  {
    "label": "TStaticBitReference",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TStaticBitReference"
  },
  {
    "label": "TConstStaticBitReference",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TConstStaticBitReference"
  },
  {
    "label": "TStaticBitArray",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TStaticBitArray"
  },
  {
    "label": "FBoolType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBoolType"
  },
  {
    "label": "TStaticBitReference()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Misc / AssertionMacros . h \" # include \" HAL / UnrealMemory . h \" # include \" Math / UnrealMathUtility . h \" # include \" Containers / UnrealString . h \" template<T> class TStaticBitReference { public :)",
    "insertText": "TStaticBitReference(T& InData,T InMask) : Data(InData) , Mask(InMask)"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} operator)",
    "insertText": "bool()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator(const bool NewValue)"
  },
  {
    "label": "TConstStaticBitReference()",
    "kind": "Method",
    "detail": "Function (Data | = Mask ; } else { Data& = ~ Mask ; } } private : T& Data ; T Mask ; } ; template<T> class TConstStaticBitReference { public :)",
    "insertText": "TConstStaticBitReference(const T& InData,T InMask) : Data(InData) , Mask(InMask)"
  },
  {
    "label": "TStaticBitArray()",
    "kind": "Method",
    "detail": "Function (} private : const T& Data ; T Mask ; } ; template<uint32 NumBits> class TStaticBitArray { typedef uint64 WordType ; struct FBoolType ; typedef int32* FBoolType::* UnspecifiedBoolType ; typedef float* FBoolType::* UnspecifiedZeroType ; public :)",
    "insertText": "TStaticBitArray()"
  },
  {
    "label": "Clear_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear_()"
  },
  {
    "label": "TStaticBitArray()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TStaticBitArray(bool, uint32 InBitIndex)"
  },
  {
    "label": "Word()",
    "kind": "Method",
    "detail": "Function (uint32 DestWordIndex = InBitIndex / NumBitsPerWord ; WordType)",
    "insertText": "Word(WordType)1 << (InBitIndex & (NumBitsPerWord - 1))"
  },
  {
    "label": "Word()",
    "kind": "Method",
    "detail": "Function (Words [ WordIndex ] = WordIndex = = DestWordIndex ?)",
    "insertText": "Word(WordType)"
  },
  {
    "label": "TStaticBitArray()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "TStaticBitArray(const FString& Str)"
  },
  {
    "label": "Len()",
    "kind": "Method",
    "detail": "Function (int32 Length = Str .)",
    "insertText": "Len()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 Pos = Length ;)",
    "insertText": "for(int32 Index = 0; Index < Length; ++Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const TCHAR ch = Str [ - - Pos ] ;)",
    "insertText": "if(ch == TEXT('1'))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(Index)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(ch != TEXT('0'))"
  },
  {
    "label": "ErrorInvalid_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ErrorInvalid_()"
  },
  {
    "label": "HasAnyBitsSet()",
    "kind": "Method",
    "detail": "Function (} } } bool)",
    "insertText": "HasAnyBitsSet()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (WordType And = 0 ;)",
    "insertText": "for(int32 Index = 0; Index < NumWords; ++Index)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Num()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} const TConstStaticBitReference<WordType>)",
    "insertText": "operator(int32 Index)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} TStaticBitArray&)",
    "insertText": "operator(const TStaticBitArray& Other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Words [ Index ] ^ = Other . Words [ Index ] ; } return* this ; } TStaticBitArray<NumBits>)",
    "insertText": "operator(const TStaticBitArray<NumBits>& A)"
  },
  {
    "label": "Trim_()",
    "kind": "Method",
    "detail": "Function (Result . Words [ Index ] = ~ A . Words [ Index ] ; } Result .)",
    "insertText": "Trim_()"
  },
  {
    "label": "Results()",
    "kind": "Method",
    "detail": "Function (TStaticBitArray)",
    "insertText": "Results(0)"
  },
  {
    "label": "APtr()",
    "kind": "Method",
    "detail": "Function (const WordType* RESTRICT)",
    "insertText": "APtr(const WordType* RESTRICT)"
  },
  {
    "label": "BPtr()",
    "kind": "Method",
    "detail": "Function (const WordType* RESTRICT)",
    "insertText": "BPtr(const WordType* RESTRICT)"
  },
  {
    "label": "ResultsPtr()",
    "kind": "Method",
    "detail": "Function (WordType* RESTRICT)",
    "insertText": "ResultsPtr(WordType* RESTRICT)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ResultsPtr [ Index ] = APtr [ Index ] | BPtr [ Index ] ; } return Results ; } TStaticBitArray<NumBits>)",
    "insertText": "operator(const TStaticBitArray<NumBits>& A, const TStaticBitArray<NumBits>& B)"
  },
  {
    "label": "Results()",
    "kind": "Method",
    "detail": "Function (TStaticBitArray)",
    "insertText": "Results(A)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Results ^ = B ; return Results ; } bool)",
    "insertText": "operator(const TStaticBitArray<NumBits>& B)"
  },
  {
    "label": "FindFirstClearBit()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "FindFirstClearBit()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const int32 LocalNumBits = NumBits ; int32 WordIndex = 0 ;)",
    "insertText": "while(WordIndex < NumWords && Words[WordIndex] == WordType(-1))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + WordIndex ; })",
    "insertText": "if(WordIndex < NumWords)"
  },
  {
    "label": "Bits()",
    "kind": "Method",
    "detail": "Function (const WordType)",
    "insertText": "Bits(Words[WordIndex])"
  },
  {
    "label": "UE_ASSUME()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UE_ASSUME(Bits != 0)"
  },
  {
    "label": "CountTrailingZeros64()",
    "kind": "Method",
    "detail": "Function (const int32 LowestBitIndex =)",
    "insertText": "CountTrailingZeros64(Bits) + (WordIndex << NumBitsPerWordLog2)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (const int32 LocalNumBits = NumBits ; int32 WordIndex = 0 ;)",
    "insertText": "while(WordIndex < NumWords && Words[WordIndex] == WordType(0))"
  },
  {
    "label": "LowestBitIndex()",
    "kind": "Method",
    "detail": "Function (const int32)",
    "insertText": "LowestBitIndex(int32)FMath::CountTrailingZeros64(Bits) + (WordIndex << NumBitsPerWordLog2)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (FString Str ; Str .)",
    "insertText": "Empty(NumBits)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (Str + =)",
    "insertText": "operator(Index) ? TEXT('1') : TEXT('0')"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} return Str ; } uint32 NumOfBits = NumBits ; private : uint32 NumBitsPerWord =)",
    "insertText": "sizeof(WordType)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (uint32 NumBitsPerWordLog2 = 6 ;)",
    "insertText": "static_assert(NumBitsPerWord == (1u << NumBitsPerWordLog2), \"Update NumBitsPerWordLog2 to reflect WordType\")"
  },
  {
    "label": "NumWords()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "NumWords((NumBits + NumBitsPerWord - 1) & ~(NumBitsPerWord - 1))"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (uint32 NumOverflowBits = NumBits % NumBitsPerWord ; if)",
    "insertText": "constexpr(NumOverflowBits != 0)"
  },
  {
    "label": "NumWords()",
    "kind": "Method",
    "detail": "Function (Words [)",
    "insertText": "NumWords(WordType(1) << NumOverflowBits)"
  },
  {
    "label": "LowLevelFatalError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LowLevelFatalError(TEXT(\"invalid TStaticBitArray<NumBits> character\"))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<uint32 NumBits> FArchive&)",
    "insertText": "operator(FArchive& Ar, TStaticBitArray<NumBits>& BitArray)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint32 ArchivedNumWords = BitArray . NumWords ; Ar<<ArchivedNumWords ;)",
    "insertText": "if(Ar.IsLoading())"
  },
  {
    "label": "Memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memset(BitArray.Words, 0, sizeof(BitArray.Words))"
  },
  {
    "label": "Min()",
    "kind": "Method",
    "detail": "Function (ArchivedNumWords =)",
    "insertText": "Min(BitArray.NumWords, ArchivedNumWords)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} Ar .)",
    "insertText": "Serialize(BitArray.Words, ArchivedNumWords * sizeof(BitArray.Words[0]))"
  }
]