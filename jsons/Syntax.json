[
  {
    "label": "Syntax",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Syntax"
  },
  {
    "label": "TypeSyntax",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypeSyntax"
  },
  {
    "label": "TypeDesc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TypeDesc"
  },
  {
    "label": "ShaderPort",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ShaderPort"
  },
  {
    "label": "MX_GENSHADER_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MX_GENSHADER_API"
  },
  {
    "label": "Punctuation",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Punctuation"
  },
  {
    "label": "Syntax()",
    "kind": "Method",
    "detail": "Function (# ifndef MATERIALX_SYNTAX_H # define MATERIALX_SYNTAX_H # include<MaterialXGenShader / Export . h> # include<MaterialXCore / Definition . h> # include<MaterialXCore / Library . h> # include<MaterialXCore / Value . h> MATERIALX_NAMESPACE_BEGIN class Syntax ; class TypeSyntax ; class TypeDesc ; class ShaderPort ; using SyntaxPtr = shared_ptr<Syntax> ; using ConstSyntaxPtr = shared_ptr<const Syntax> ; using TypeSyntaxPtr = shared_ptr<TypeSyntax> ; using IdentifierMap = std::unordered_map<string,size_t> ; class Syntax { public : enum Punctuation { PARENTHESES,CURLY_BRACKETS,SQUARE_BRACKETS,DOUBLE_SQUARE_BRACKETS } ; public : ~)",
    "insertText": "Syntax()"
  },
  {
    "label": "registerTypeSyntax()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "registerTypeSyntax(const TypeDesc* type, TypeSyntaxPtr syntax)"
  },
  {
    "label": "registerReservedWords()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerReservedWords(const StringSet& names)"
  },
  {
    "label": "registerInvalidTokens()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerInvalidTokens(const StringMap& tokens)"
  },
  {
    "label": "getReservedWords()",
    "kind": "Method",
    "detail": "Function (const StringSet&)",
    "insertText": "getReservedWords()"
  },
  {
    "label": "getTypeSyntaxes()",
    "kind": "Method",
    "detail": "Function (const vector<TypeSyntaxPtr>&)",
    "insertText": "getTypeSyntaxes()"
  },
  {
    "label": "getTypeName()",
    "kind": "Method",
    "detail": "Function (const string&)",
    "insertText": "getTypeName(const TypeDesc* type)"
  },
  {
    "label": "getOutputTypeName()",
    "kind": "Method",
    "detail": "Function (string)",
    "insertText": "getOutputTypeName(const TypeDesc* type)"
  },
  {
    "label": "getTypeAlias()",
    "kind": "Method",
    "detail": "Function (const string&)",
    "insertText": "getTypeAlias(const TypeDesc* type)"
  },
  {
    "label": "getTypeDefinition()",
    "kind": "Method",
    "detail": "Function (const string&)",
    "insertText": "getTypeDefinition(const TypeDesc* type)"
  },
  {
    "label": "getDefaultValue()",
    "kind": "Method",
    "detail": "Function (const string&)",
    "insertText": "getDefaultValue(const TypeDesc* type, bool uniform = false)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (string)",
    "insertText": "getValue(const TypeDesc* type, const Value& value, bool uniform = false)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (string)",
    "insertText": "getValue(const ShaderPort* port, bool uniform = false)"
  },
  {
    "label": "getSwizzledVariable()",
    "kind": "Method",
    "detail": "Function (string)",
    "insertText": "getSwizzledVariable(const string& srcName, const TypeDesc* srcType, const string& channels, const TypeDesc* dstType)"
  },
  {
    "label": "getSwizzledValue()",
    "kind": "Method",
    "detail": "Function (ValuePtr)",
    "insertText": "getSwizzledValue(ValuePtr value, const TypeDesc* srcType, const string& channels, const TypeDesc* dstType)"
  },
  {
    "label": "getInputQualifier()",
    "kind": "Method",
    "detail": "Function (const string&)",
    "insertText": "getInputQualifier()"
  },
  {
    "label": "getUniformQualifier()",
    "kind": "Method",
    "detail": "Function (const string&)",
    "insertText": "getUniformQualifier()"
  },
  {
    "label": "getArrayTypeSuffix()",
    "kind": "Method",
    "detail": "Function (string)",
    "insertText": "getArrayTypeSuffix(const TypeDesc*, const Value&)"
  },
  {
    "label": "typeSupported()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "typeSupported(const TypeDesc* type)"
  },
  {
    "label": "makeValidName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "makeValidName(string& name)"
  },
  {
    "label": "makeIdentifier()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "makeIdentifier(string& name, IdentifierMap& identifiers)"
  },
  {
    "label": "getVariableName()",
    "kind": "Method",
    "detail": "Function (string)",
    "insertText": "getVariableName(const string& name, const TypeDesc* type, IdentifierMap& identifiers)"
  },
  {
    "label": "remapEnumeration()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "remapEnumeration(const string& value, const TypeDesc* type, const string& enumNames, std::pair<const TypeDesc*, ValuePtr>& result)"
  },
  {
    "label": "TypeSyntax()",
    "kind": "Method",
    "detail": "Function (vector<TypeSyntaxPtr> _typeSyntaxes ; std::unordered_map<const TypeDesc*,size_t> _typeSyntaxByType ; StringSet _reservedWords ; StringMap _invalidTokens ; const string INDENTATION ; const string STRING_QUOTE ; const string INCLUDE_STATEMENT ; const string SINGLE_LINE_COMMENT ; const string BEGIN_MULTI_LINE_COMMENT ; const string END_MULTI_LINE_COMMENT ; const std::unordered_map<char,size_t> CHANNELS_MAPPING ; } ; class TypeSyntax { public : ~)",
    "insertText": "TypeSyntax()"
  },
  {
    "label": "getName()",
    "kind": "Method",
    "detail": "Function (} const string&)",
    "insertText": "getName()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (string)",
    "insertText": "getValue(const Value& value, bool uniform)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (string)",
    "insertText": "getValue(const StringVec& values, bool uniform)"
  },
  {
    "label": "TypeSyntax()",
    "kind": "Method",
    "detail": "Function (protected :)",
    "insertText": "TypeSyntax(const string& name, const string& defaultValue, const string& uniformDefaultValue, const string& typeAlias, const string& typeDefinition, const StringVec& members)"
  },
  {
    "label": "ScalarTypeSyntax()",
    "kind": "Method",
    "detail": "Function (string _name ; string _defaultValue ; string _uniformDefaultValue ; string _typeAlias ; string _typeDefinition ; StringVec _members ; const StringVec EMPTY_MEMBERS ; } ; class ScalarTypeSyntax : public TypeSyntax { public :)",
    "insertText": "ScalarTypeSyntax(const string& name, const string& defaultValue, const string& uniformDefaultValue, const string& typeAlias = EMPTY_STRING, const string& typeDefinition = EMPTY_STRING)"
  },
  {
    "label": "StringTypeSyntax()",
    "kind": "Method",
    "detail": "Function (} ; class StringTypeSyntax : public ScalarTypeSyntax { public :)",
    "insertText": "StringTypeSyntax(const string& name, const string& defaultValue, const string& uniformDefaultValue, const string& typeAlias = EMPTY_STRING, const string& typeDefinition = EMPTY_STRING)"
  },
  {
    "label": "AggregateTypeSyntax()",
    "kind": "Method",
    "detail": "Function (} ; class AggregateTypeSyntax : public TypeSyntax { public :)",
    "insertText": "AggregateTypeSyntax(const string& name, const string& defaultValue, const string& uniformDefaultValue, const string& typeAlias = EMPTY_STRING, const string& typeDefinition = EMPTY_STRING, const StringVec& members = EMPTY_MEMBERS)"
  }
]