[
  {
    "label": "AliasAnalysis",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AliasAnalysis"
  },
  {
    "label": "LiveIntervals",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LiveIntervals"
  },
  {
    "label": "MachineDominatorTree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineDominatorTree"
  },
  {
    "label": "MachineLoopInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineLoopInfo"
  },
  {
    "label": "RegisterClassInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RegisterClassInfo"
  },
  {
    "label": "ScheduleDAGInstrs",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScheduleDAGInstrs"
  },
  {
    "label": "SchedDFSResult",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SchedDFSResult"
  },
  {
    "label": "ScheduleHazardRecognizer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScheduleHazardRecognizer"
  },
  {
    "label": "MachineSchedContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MachineSchedContext"
  },
  {
    "label": "MachineSchedRegistry",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineSchedRegistry"
  },
  {
    "label": "ScheduleDAGMI",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScheduleDAGMI"
  },
  {
    "label": "MachineSchedPolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MachineSchedPolicy"
  },
  {
    "label": "MachineSchedStrategy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineSchedStrategy"
  },
  {
    "label": "ScheduleDAGMutation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScheduleDAGMutation"
  },
  {
    "label": "ScheduleDAGMILive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ScheduleDAGMILive"
  },
  {
    "label": "ReadyQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ReadyQueue"
  },
  {
    "label": "SchedRemainder",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SchedRemainder"
  },
  {
    "label": "SchedBoundary",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SchedBoundary"
  },
  {
    "label": "GenericSchedulerBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GenericSchedulerBase"
  },
  {
    "label": "CandReason",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "CandReason"
  },
  {
    "label": "CandPolicy",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CandPolicy"
  },
  {
    "label": "SchedResourceDelta",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SchedResourceDelta"
  },
  {
    "label": "SchedCandidate",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SchedCandidate"
  },
  {
    "label": "GenericScheduler",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "GenericScheduler"
  },
  {
    "label": "PostGenericScheduler",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PostGenericScheduler"
  },
  {
    "label": "MachineSchedContext()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_CODEGEN_MACHINESCHEDULER_H # define LLVM_CODEGEN_MACHINESCHEDULER_H # include \" llvm / CodeGen / MachinePassRegistry . h \" # include \" llvm / CodeGen / RegisterPressure . h \" # include \" llvm / CodeGen / ScheduleDAGInstrs . h \" # include<memory> namespace llvm { cl::opt<bool> ForceTopDown ; cl::opt<bool> ForceBottomUp ; class AliasAnalysis ; class LiveIntervals ; class MachineDominatorTree ; class MachineLoopInfo ; class RegisterClassInfo ; class ScheduleDAGInstrs ; class SchedDFSResult ; class ScheduleHazardRecognizer ; struct MachineSchedContext { MachineFunction* MF ; const MachineLoopInfo* MLI ; const MachineDominatorTree* MDT ; const TargetPassConfig* PassConfig ; AliasAnalysis* AA ; LiveIntervals* LIS ; RegisterClassInfo* RegClassInfo ;)",
    "insertText": "MachineSchedContext()"
  },
  {
    "label": "ScheduleDAGInstrs()",
    "kind": "Method",
    "detail": "Function (} ; class MachineSchedRegistry : public MachinePassRegistryNode { public : typedef)",
    "insertText": "ScheduleDAGInstrs(*ScheduleDAGCtor)(MachineSchedContext *)"
  },
  {
    "label": "MachineSchedRegistry()",
    "kind": "Method",
    "detail": "Function (typedef ScheduleDAGCtor FunctionPassCtor ; MachinePassRegistry Registry ;)",
    "insertText": "MachineSchedRegistry(const char *N, const char *D, ScheduleDAGCtor C) : MachinePassRegistryNode(N, D, (MachinePassCtor)C)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Registry .)",
    "insertText": "Add(this)"
  },
  {
    "label": "MachineSchedRegistry()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "MachineSchedRegistry()"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (Registry .)",
    "insertText": "Remove(this)"
  },
  {
    "label": "getNext()",
    "kind": "Method",
    "detail": "Function (} MachineSchedRegistry*)",
    "insertText": "getNext()"
  },
  {
    "label": "getList()",
    "kind": "Method",
    "detail": "Function (} MachineSchedRegistry*)",
    "insertText": "getList()"
  },
  {
    "label": "setListener()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setListener(MachinePassRegistryListener *L)"
  },
  {
    "label": "setListener()",
    "kind": "Method",
    "detail": "Function (Registry .)",
    "insertText": "setListener(L)"
  },
  {
    "label": "MachineSchedPolicy()",
    "kind": "Method",
    "detail": "Function (} } ; class ScheduleDAGMI ; struct MachineSchedPolicy { bool ShouldTrackPressure ; bool OnlyTopDown ; bool OnlyBottomUp ;)",
    "insertText": "MachineSchedPolicy(): ShouldTrackPressure(false), OnlyTopDown(false), OnlyBottomUp(false)"
  },
  {
    "label": "anchor()",
    "kind": "Method",
    "detail": "Function (} } ; class MachineSchedStrategy { void)",
    "insertText": "anchor()"
  },
  {
    "label": "MachineSchedStrategy()",
    "kind": "Method",
    "detail": "Function (public : ~)",
    "insertText": "MachineSchedStrategy()"
  },
  {
    "label": "initPolicy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "initPolicy(MachineBasicBlock::iterator Begin, MachineBasicBlock::iterator End, unsigned NumRegionInstrs)"
  },
  {
    "label": "shouldTrackPressure()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "shouldTrackPressure()"
  },
  {
    "label": "registerRoots()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "registerRoots()"
  },
  {
    "label": "pickNode()",
    "kind": "Method",
    "detail": "Function (} SUnit*)",
    "insertText": "pickNode(bool &IsTopNode)"
  },
  {
    "label": "scheduleTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "scheduleTree(unsigned SubtreeID)"
  },
  {
    "label": "schedNode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "schedNode(SUnit *SU, bool IsTopNode)"
  },
  {
    "label": "releaseTopNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releaseTopNode(SUnit *SU)"
  },
  {
    "label": "releaseBottomNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releaseBottomNode(SUnit *SU)"
  },
  {
    "label": "ScheduleDAGMutation()",
    "kind": "Method",
    "detail": "Function (public : ~)",
    "insertText": "ScheduleDAGMutation()"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "apply(ScheduleDAGMI *DAG)"
  },
  {
    "label": "ScheduleDAGMI()",
    "kind": "Method",
    "detail": "Function (} ; class ScheduleDAGMI : public ScheduleDAGInstrs { protected : AliasAnalysis* AA ; std::unique_ptr<MachineSchedStrategy> SchedImpl ; ScheduleDAGTopologicalSort Topo ; std::vector<std::unique_ptr<ScheduleDAGMutation>> Mutations ; MachineBasicBlock::iterator CurrentTop ; MachineBasicBlock::iterator CurrentBottom ; const SUnit* NextClusterPred ; const SUnit* NextClusterSucc ; # ifndef NDEBUG unsigned NumInstrsScheduled ; # endif public :)",
    "insertText": "ScheduleDAGMI(MachineSchedContext *C, std::unique_ptr<MachineSchedStrategy> S, bool IsPostRA) : ScheduleDAGInstrs(*C->MF, C->MLI, IsPostRA, IsPostRA, C->LIS), AA(C->AA), SchedImpl(std::move(S)), Topo(SUnits, &ExitSU), CurrentTop(), CurrentBottom(), NextClusterPred(nullptr), NextClusterSucc(nullptr)"
  },
  {
    "label": "ScheduleDAGMI()",
    "kind": "Method",
    "detail": "Function (# ifndef NDEBUG NumInstrsScheduled = 0 ; # endif } ~)",
    "insertText": "ScheduleDAGMI()"
  },
  {
    "label": "hasVRegLiveness()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasVRegLiveness()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Mutations .)",
    "insertText": "push_back(std::move(Mutation))"
  },
  {
    "label": "canAddEdge()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "canAddEdge(SUnit *SuccSU, SUnit *PredSU)"
  },
  {
    "label": "addEdge()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "addEdge(SUnit *SuccSU, const SDep &PredDep)"
  },
  {
    "label": "top()",
    "kind": "Method",
    "detail": "Function (MachineBasicBlock::iterator)",
    "insertText": "top()"
  },
  {
    "label": "schedule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "schedule()"
  },
  {
    "label": "moveInstruction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "moveInstruction(MachineInstr *MI, MachineBasicBlock::iterator InsertPos)"
  },
  {
    "label": "getNextClusterPred()",
    "kind": "Method",
    "detail": "Function (const SUnit*)",
    "insertText": "getNextClusterPred()"
  },
  {
    "label": "viewGraph()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "viewGraph()"
  },
  {
    "label": "postprocessDAG()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "postprocessDAG()"
  },
  {
    "label": "initQueues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initQueues(ArrayRef<SUnit*> TopRoots, ArrayRef<SUnit*> BotRoots)"
  },
  {
    "label": "updateQueues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateQueues(SUnit *SU, bool IsTopNode)"
  },
  {
    "label": "placeDebugValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "placeDebugValues()"
  },
  {
    "label": "dumpSchedule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dumpSchedule()"
  },
  {
    "label": "checkSchedLimit()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "checkSchedLimit()"
  },
  {
    "label": "findRootsAndBiasEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "findRootsAndBiasEdges(SmallVectorImpl<SUnit*> &TopRoots, SmallVectorImpl<SUnit*> &BotRoots)"
  },
  {
    "label": "releaseSucc()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releaseSucc(SUnit *SU, SDep *SuccEdge)"
  },
  {
    "label": "releaseSuccessors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releaseSuccessors(SUnit *SU)"
  },
  {
    "label": "releasePred()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releasePred(SUnit *SU, SDep *PredEdge)"
  },
  {
    "label": "releasePredecessors()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releasePredecessors(SUnit *SU)"
  },
  {
    "label": "ScheduleDAGMILive()",
    "kind": "Method",
    "detail": "Function (} ; class ScheduleDAGMILive : public ScheduleDAGMI { protected : RegisterClassInfo* RegClassInfo ; SchedDFSResult* DFSResult ; BitVector ScheduledTrees ; MachineBasicBlock::iterator LiveRegionEnd ; PressureDiffs SUPressureDiffs ; bool ShouldTrackPressure ; IntervalPressure RegPressure ; RegPressureTracker RPTracker ; std::vector<PressureChange> RegionCriticalPSets ; IntervalPressure TopPressure ; RegPressureTracker TopRPTracker ; IntervalPressure BotPressure ; RegPressureTracker BotRPTracker ; public :)",
    "insertText": "ScheduleDAGMILive(MachineSchedContext *C, std::unique_ptr<MachineSchedStrategy> S) : ScheduleDAGMI(C, std::move(S), false), RegClassInfo(C->RegClassInfo), DFSResult(nullptr), ShouldTrackPressure(false), RPTracker(RegPressure), TopRPTracker(TopPressure), BotRPTracker(BotPressure)"
  },
  {
    "label": "ScheduleDAGMILive()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ScheduleDAGMILive()"
  },
  {
    "label": "getDFSResult()",
    "kind": "Method",
    "detail": "Function (const SchedDFSResult*)",
    "insertText": "getDFSResult()"
  },
  {
    "label": "computeCyclicCriticalPath()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "computeCyclicCriticalPath()"
  },
  {
    "label": "buildDAGWithRegPressure()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "buildDAGWithRegPressure()"
  },
  {
    "label": "scheduleMI()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "scheduleMI(SUnit *SU, bool IsTopNode)"
  },
  {
    "label": "initRegPressure()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initRegPressure()"
  },
  {
    "label": "updatePressureDiffs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updatePressureDiffs(ArrayRef<unsigned> LiveUses)"
  },
  {
    "label": "updateScheduledPressure()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateScheduledPressure(const SUnit *SU, const std::vector<unsigned> &NewMaxPressure)"
  },
  {
    "label": "ReadyQueue()",
    "kind": "Method",
    "detail": "Function (} ; class ReadyQueue { unsigned ID ; std::string Name ; std::vector<SUnit*> Queue ; public :)",
    "insertText": "ReadyQueue(unsigned id, const Twine &name): ID(id), Name(name.str())"
  },
  {
    "label": "getID()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getID()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "empty()"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clear()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "size()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} typedef std::vector<SUnit*>::iterator iterator ; iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "elements()",
    "kind": "Method",
    "detail": "Function (} ArrayRef<SUnit*>)",
    "insertText": "elements()"
  },
  {
    "label": "push()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "push(SUnit *SU)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (Queue .)",
    "insertText": "push_back(SU)"
  },
  {
    "label": "remove()",
    "kind": "Method",
    "detail": "Function (SU -> NodeQueueId | = ID ; } iterator)",
    "insertText": "remove(iterator I)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (* I = Queue .)",
    "insertText": "back()"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (Queue .)",
    "insertText": "pop_back()"
  },
  {
    "label": "dump()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "dump()"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} ; struct SchedRemainder { unsigned CriticalPath ; unsigned CyclicCritPath ; unsigned RemIssueCount ; bool IsAcyclicLatencyLimited ; SmallVector<unsigned,1 6> RemainingCounts ; void)",
    "insertText": "reset()"
  },
  {
    "label": "SchedRemainder()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "SchedRemainder()"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "init(ScheduleDAGMI *DAG, const TargetSchedModel *SchedModel)"
  },
  {
    "label": "SchedBoundary()",
    "kind": "Method",
    "detail": "Function (} ; class SchedBoundary { public : enum { TopQID = 1,BotQID = 2,LogMaxQID = 2 } ; ScheduleDAGMI* DAG ; const TargetSchedModel* SchedModel ; SchedRemainder* Rem ; ReadyQueue Available ; ReadyQueue Pending ; ScheduleHazardRecognizer* HazardRec ; private : bool CheckPending ; SmallPtrSet<const SUnit*,8> NextSUs ; unsigned CurrCycle ; unsigned CurrMOps ; unsigned MinReadyCycle ; unsigned ExpectedLatency ; unsigned DependentLatency ; unsigned RetiredMOps ; SmallVector<unsigned,1 6> ExecutedResCounts ; unsigned MaxExecutedResCount ; unsigned ZoneCritResIdx ; bool IsResourceLimited ; SmallVector<unsigned,1 6> ReservedCycles ; # ifndef NDEBUG unsigned MaxObservedStall ; # endif public :)",
    "insertText": "SchedBoundary(unsigned ID, const Twine &Name): DAG(nullptr), SchedModel(nullptr), Rem(nullptr), Available(ID, Name+\".A\"), Pending(ID << LogMaxQID, Name+\".P\"), HazardRec(nullptr)"
  },
  {
    "label": "SchedBoundary()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "SchedBoundary()"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init(ScheduleDAGMI *dag, const TargetSchedModel *smodel, SchedRemainder *rem)"
  },
  {
    "label": "isTop()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isTop()"
  },
  {
    "label": "getCurrCycle()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getCurrCycle()"
  },
  {
    "label": "getDependentLatency()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getDependentLatency()"
  },
  {
    "label": "getUnscheduledLatency()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getUnscheduledLatency(SUnit *SU)"
  },
  {
    "label": "getResourceCount()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getResourceCount(unsigned ResIdx)"
  },
  {
    "label": "getExecutedCount()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getExecutedCount()"
  },
  {
    "label": "getZoneCritResIdx()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getZoneCritResIdx()"
  },
  {
    "label": "getNextResourceCycle()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getNextResourceCycle(unsigned PIdx, unsigned Cycles)"
  },
  {
    "label": "checkHazard()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "checkHazard(SUnit *SU)"
  },
  {
    "label": "findMaxLatency()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "findMaxLatency(ArrayRef<SUnit*> ReadySUs)"
  },
  {
    "label": "getOtherResourceCount()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getOtherResourceCount(unsigned &OtherCritIdx)"
  },
  {
    "label": "releaseNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releaseNode(SUnit *SU, unsigned ReadyCycle)"
  },
  {
    "label": "bumpCycle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bumpCycle(unsigned NextCycle)"
  },
  {
    "label": "incExecutedResources()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "incExecutedResources(unsigned PIdx, unsigned Count)"
  },
  {
    "label": "countResource()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "countResource(unsigned PIdx, unsigned Cycles, unsigned ReadyCycle)"
  },
  {
    "label": "bumpNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bumpNode(SUnit *SU)"
  },
  {
    "label": "releasePending()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "releasePending()"
  },
  {
    "label": "removeReady()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "removeReady(SUnit *SU)"
  },
  {
    "label": "pickOnlyChoice()",
    "kind": "Method",
    "detail": "Function (SUnit*)",
    "insertText": "pickOnlyChoice()"
  },
  {
    "label": "dumpScheduledState()",
    "kind": "Method",
    "detail": "Function (# ifndef NDEBUG void)",
    "insertText": "dumpScheduledState()"
  },
  {
    "label": "getReasonStr()",
    "kind": "Method",
    "detail": "Function (# endif } ; class GenericSchedulerBase : public MachineSchedStrategy { public : enum CandReason { NoCand,PhysRegCopy,RegExcess,RegCritical,Stall,Cluster,Weak,RegMax,ResourceReduce,ResourceDemand,BotHeightReduce,BotPathReduce,TopDepthReduce,TopPathReduce,NextDefUse,NodeOrder } ; # ifndef NDEBUG const char*)",
    "insertText": "getReasonStr(GenericSchedulerBase::CandReason Reason)"
  },
  {
    "label": "CandPolicy()",
    "kind": "Method",
    "detail": "Function (# endif struct CandPolicy { bool ReduceLatency ; unsigned ReduceResIdx ; unsigned DemandResIdx ;)",
    "insertText": "CandPolicy(): ReduceLatency(false), ReduceResIdx(0), DemandResIdx(0)"
  },
  {
    "label": "SchedResourceDelta()",
    "kind": "Method",
    "detail": "Function (} } ; struct SchedResourceDelta { unsigned CritResources ; unsigned DemandedResources ;)",
    "insertText": "SchedResourceDelta(): CritResources(0), DemandedResources(0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const SchedResourceDelta &RHS)"
  },
  {
    "label": "SchedCandidate()",
    "kind": "Method",
    "detail": "Function (} } ; struct SchedCandidate { CandPolicy Policy ; SUnit* SU ; CandReason Reason ; uint32_t RepeatReasonSet ; RegPressureDelta RPDelta ; SchedResourceDelta ResDelta ;)",
    "insertText": "SchedCandidate(const CandPolicy &policy) : Policy(policy), SU(nullptr), Reason(NoCand), RepeatReasonSet(0)"
  },
  {
    "label": "isValid()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValid()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Best.Reason != NoCand && \"uninitialized Sched candidate\")"
  },
  {
    "label": "isRepeat()",
    "kind": "Method",
    "detail": "Function (SU = Best . SU ; Reason = Best . Reason ; RPDelta = Best . RPDelta ; ResDelta = Best . ResDelta ; } bool)",
    "insertText": "isRepeat(CandReason R)"
  },
  {
    "label": "setRepeat()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setRepeat(CandReason R)"
  },
  {
    "label": "RepeatReasonSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RepeatReasonSet(1 << R)"
  },
  {
    "label": "initResourceDelta()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "initResourceDelta(const ScheduleDAGMI *DAG, const TargetSchedModel *SchedModel)"
  },
  {
    "label": "GenericSchedulerBase()",
    "kind": "Method",
    "detail": "Function (} ; protected : const MachineSchedContext* Context ; const TargetSchedModel* SchedModel ; const TargetRegisterInfo* TRI ; SchedRemainder Rem ; protected :)",
    "insertText": "GenericSchedulerBase(const MachineSchedContext *C): Context(C), SchedModel(nullptr), TRI(nullptr)"
  },
  {
    "label": "setPolicy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setPolicy(CandPolicy &Policy, bool IsPostRA, SchedBoundary &CurrZone, SchedBoundary *OtherZone)"
  },
  {
    "label": "traceCandidate()",
    "kind": "Method",
    "detail": "Function (# ifndef NDEBUG void)",
    "insertText": "traceCandidate(const SchedCandidate &Cand)"
  },
  {
    "label": "GenericScheduler()",
    "kind": "Method",
    "detail": "Function (# endif } ; class GenericScheduler : public GenericSchedulerBase { ScheduleDAGMILive* DAG ; SchedBoundary Top ; SchedBoundary Bot ; MachineSchedPolicy RegionPolicy ; public :)",
    "insertText": "GenericScheduler(const MachineSchedContext *C): GenericSchedulerBase(C), DAG(nullptr), Top(SchedBoundary::TopQID, \"TopQ\"), Bot(SchedBoundary::BotQID, \"BotQ\")"
  },
  {
    "label": "releaseTopNode()",
    "kind": "Method",
    "detail": "Function (Top .)",
    "insertText": "releaseTopNode(SU)"
  },
  {
    "label": "releaseBottomNode()",
    "kind": "Method",
    "detail": "Function (Bot .)",
    "insertText": "releaseBottomNode(SU)"
  },
  {
    "label": "checkAcyclicLatency()",
    "kind": "Method",
    "detail": "Function (protected : void)",
    "insertText": "checkAcyclicLatency()"
  },
  {
    "label": "tryCandidate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tryCandidate(SchedCandidate &Cand, SchedCandidate &TryCand, SchedBoundary &Zone, const RegPressureTracker &RPTracker, RegPressureTracker &TempTracker)"
  },
  {
    "label": "pickNodeBidirectional()",
    "kind": "Method",
    "detail": "Function (SUnit*)",
    "insertText": "pickNodeBidirectional(bool &IsTopNode)"
  },
  {
    "label": "pickNodeFromQueue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pickNodeFromQueue(SchedBoundary &Zone, const RegPressureTracker &RPTracker, SchedCandidate &Candidate)"
  },
  {
    "label": "reschedulePhysRegCopies()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reschedulePhysRegCopies(SUnit *SU, bool isTop)"
  },
  {
    "label": "PostGenericScheduler()",
    "kind": "Method",
    "detail": "Function (} ; class PostGenericScheduler : public GenericSchedulerBase { ScheduleDAGMI* DAG ; SchedBoundary Top ; SmallVector<SUnit*,8> BotRoots ; public :)",
    "insertText": "PostGenericScheduler(const MachineSchedContext *C): GenericSchedulerBase(C), Top(SchedBoundary::TopQID, \"TopQ\")"
  },
  {
    "label": "PostGenericScheduler()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "PostGenericScheduler()"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"PostRA scheduler does not support subtree analysis.\")"
  },
  {
    "label": "tryCandidate()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "tryCandidate(SchedCandidate &Cand, SchedCandidate &TryCand)"
  },
  {
    "label": "pickNodeFromQueue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pickNodeFromQueue(SchedCandidate &Cand)"
  }
]