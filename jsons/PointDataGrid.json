[
  {
    "label": "TestPointDataLeaf",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TestPointDataLeaf"
  },
  {
    "label": "SameLeafConfig",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SameLeafConfig"
  },
  {
    "label": "PointDataLeafNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PointDataLeafNode"
  },
  {
    "label": "tree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "tree"
  },
  {
    "label": "Local",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Local"
  },
  {
    "label": "PointDataNodeChain",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PointDataNodeChain"
  },
  {
    "label": "TreeConverter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TreeConverter"
  },
  {
    "label": "readCompressedValues()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_POINTS_POINT_DATA_GRID_HAS_BEEN_INCLUDED # define OPENVDB_POINTS_POINT_DATA_GRID_HAS_BEEN_INCLUDED # include<openvdb / version . h> # include<openvdb / Grid . h> # include<openvdb / tree / Tree . h> # include<openvdb / tree / LeafNode . h> # include<openvdb / tools / PointIndexGrid . h> # include \" AttributeArray . h \" # include \" AttributeArrayString . h \" # include \" AttributeGroup . h \" # include \" AttributeSet . h \" # include \" StreamCompression . h \" # include<cstring> # include<iostream> # include<limits> # include<memory> # include<type_traits> # include<utility> # include<vector> class TestPointDataLeaf ; namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace io { template<> void)",
    "insertText": "readCompressedValues(std::istream& is, PointDataIndex32* destBuf, Index destCount, const util::NodeMask<3>& , bool)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (using compression::bloscDecompress ; const bool seek = destBuf = = nullptr ; const size_t destBytes = destCount*)",
    "insertText": "sizeof(PointDataIndex32)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (const size_t maximumBytes = std::numeric_limits<uint16_t)",
    "insertText": "max()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(openvdb::IoError, \"Cannot read more than \" << maximumBytes << \" bytes in voxel values.\")"
  },
  {
    "label": "getStreamMetadataPtr()",
    "kind": "Method",
    "detail": "Function (const io::StreamMetadata::Ptr meta =)",
    "insertText": "getStreamMetadataPtr(is)"
  },
  {
    "label": "uint16_t()",
    "kind": "Method",
    "detail": "Function (bytes16 = static_cast<)",
    "insertText": "uint16_t(meta->pass())"
  },
  {
    "label": "seekg()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "seekg(sizeof(uint16_t), std::ios_base::cur)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} else { is .)",
    "insertText": "read(reinterpret_cast<char*>(&bytes16), sizeof(uint16_t))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(bytes16 == std::numeric_limits<uint16_t>::max())"
  },
  {
    "label": "seekg()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "seekg(destBytes, std::ios_base::cur)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} else { is .)",
    "insertText": "read(reinterpret_cast<char*>(destBuf), destBytes)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(seek)"
  },
  {
    "label": "seekg()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "seekg(int(bytes16), std::ios_base::cur)"
  },
  {
    "label": "bloscBuffer()",
    "kind": "Method",
    "detail": "Function (} else { std::unique_ptr<char [ ]>)",
    "insertText": "bloscBuffer(new char[int(bytes16)])"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(bloscBuffer.get(), bytes16)"
  },
  {
    "label": "bloscDecompress()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<char [ ]> buffer =)",
    "insertText": "bloscDecompress(bloscBuffer.get(), destBytes, false)"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(destBuf, buffer.get(), destBytes)"
  },
  {
    "label": "writeCompressedValues()",
    "kind": "Method",
    "detail": "Function (} } } template<> void)",
    "insertText": "writeCompressedValues(std::ostream& os, PointDataIndex32* srcBuf, Index srcCount, const util::NodeMask<3>& , const util::NodeMask<3>& , bool)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(openvdb::IoError, \"Cannot write more than \" << maximumBytes << \" bytes in voxel values.\") } const char* charBuffer = reinterpret_cast<const char*>(srcBuf)"
  },
  {
    "label": "bloscCompress()",
    "kind": "Method",
    "detail": "Function (size_t compressedBytes ; std::unique_ptr<char [ ]> buffer =)",
    "insertText": "bloscCompress(charBuffer, srcBytes, compressedBytes, false)"
  },
  {
    "label": "uint16_t()",
    "kind": "Method",
    "detail": "Function (auto bytes16 = static_cast<)",
    "insertText": "uint16_t(compressedBytes)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&bytes16), sizeof(uint16_t))"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(buffer.get()), compressedBytes)"
  },
  {
    "label": "uint16_t()",
    "kind": "Method",
    "detail": "Function (} else { auto bytes16 = static_cast<)",
    "insertText": "uint16_t(maximumBytes)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(srcBuf), srcBytes)"
  },
  {
    "label": "writeCompressedValuesSize()",
    "kind": "Method",
    "detail": "Function (} } template<T> void)",
    "insertText": "writeCompressedValuesSize(std::ostream& os, const T* srcBuf, Index srcCount)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (using compression::bloscCompressedSize ; const size_t srcBytes = srcCount*)",
    "insertText": "sizeof(T)"
  },
  {
    "label": "bloscCompressedSize()",
    "kind": "Method",
    "detail": "Function (size_t compressedBytes =)",
    "insertText": "bloscCompressedSize(charBuffer, srcBytes)"
  },
  {
    "label": "makeDescriptorUnique()",
    "kind": "Method",
    "detail": "Function (} } } namespace tree { template<Index,> struct SameLeafConfig ; } namespace points { template<T,Index Log2Dim> class PointDataLeafNode ; # ifndef OPENVDB_DISABLE_POINT_DATA_TREE_ALIAS using PointDataTree = tree::Tree<tree::RootNode<tree::InternalNode<tree::InternalNode<PointDataLeafNode<PointDataIndex32,3>,4>,5>>> ; using PointDataGrid = Grid<PointDataTree> ; # endif template<PointDataTreeT> AttributeSet::Descriptor::Ptr)",
    "insertText": "makeDescriptorUnique(PointDataTreeT& tree)"
  },
  {
    "label": "setStreamingMode()",
    "kind": "Method",
    "detail": "Function (template<PointDataTreeT> void)",
    "insertText": "setStreamingMode(PointDataTreeT& tree, bool on = true)"
  },
  {
    "label": "prefetch()",
    "kind": "Method",
    "detail": "Function (template<PointDataTreeT> void)",
    "insertText": "prefetch(PointDataTreeT& tree, bool position = true, bool otherAttributes = true)"
  },
  {
    "label": "PointDataLeafNode()",
    "kind": "Method",
    "detail": "Function (template<T,Index Log2Dim> class PointDataLeafNode : public tree::LeafNode<T,Log2Dim>,io::MultiPass { public : using LeafNodeType = PointDataLeafNode<T,Log2Dim> ; using Ptr = std::shared_ptr<PointDataLeafNode> ; using ValueType = T ; using ValueTypePair = std::pair<ValueType,ValueType> ; using IndexArray = std::vector<ValueType> ; using Descriptor = AttributeSet::Descriptor ; using BaseLeaf = tree::LeafNode<T,Log2Dim> ; using NodeMaskType = util::NodeMask<Log2Dim> ; using BaseLeaf::LOG2DIM ; using BaseLeaf::TOTAL ; using BaseLeaf::DIM ; using BaseLeaf::NUM_VALUES ; using BaseLeaf::NUM_VOXELS ; using BaseLeaf::SIZE ; using BaseLeaf::LEVEL ;)",
    "insertText": "PointDataLeafNode() : mAttributeSet(new AttributeSet)"
  },
  {
    "label": "PointDataLeafNode()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "PointDataLeafNode()"
  },
  {
    "label": "PointDataLeafNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PointDataLeafNode(const PointDataLeafNode& other) : BaseLeaf(other) , mAttributeSet(new AttributeSet(*other.mAttributeSet))"
  },
  {
    "label": "PointDataLeafNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PointDataLeafNode(const Coord& coords, const T& value = zeroVal<T>(), bool active = false) : BaseLeaf(coords, zeroVal<T>(), active) , mAttributeSet(new AttributeSet)"
  },
  {
    "label": "assertNonModifiableUnlessZero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assertNonModifiableUnlessZero(value)"
  },
  {
    "label": "PointDataLeafNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PointDataLeafNode(const PointDataLeafNode& other, const Coord& coords, const T& value = zeroVal<T>(), bool active = false) : BaseLeaf(coords, zeroVal<T>(), active) , mAttributeSet(new AttributeSet(*other.mAttributeSet))"
  },
  {
    "label": "PointDataLeafNode()",
    "kind": "Method",
    "detail": "Function (} template<OtherValueType>)",
    "insertText": "PointDataLeafNode(const tools::PointIndexLeafNode<OtherValueType, Log2Dim>& other) : BaseLeaf(other) , mAttributeSet(new AttributeSet)"
  },
  {
    "label": "PointDataLeafNode()",
    "kind": "Method",
    "detail": "Function (} template<ValueType>)",
    "insertText": "PointDataLeafNode(const tree::LeafNode<ValueType, Log2Dim>& other, const T& value, TopologyCopy) : BaseLeaf(other, zeroVal<T>(), TopologyCopy()) , mAttributeSet(new AttributeSet)"
  },
  {
    "label": "PointDataLeafNode()",
    "kind": "Method",
    "detail": "Function (} template<ValueType>)",
    "insertText": "PointDataLeafNode(const tree::LeafNode<ValueType, Log2Dim>& other, const T& , const T& , TopologyCopy) : BaseLeaf(other, zeroVal<T>(), zeroVal<T>(), TopologyCopy()) , mAttributeSet(new AttributeSet)"
  },
  {
    "label": "PointDataLeafNode()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PointDataLeafNode(PartialCreate, const Coord& coords, const T& value = zeroVal<T>(), bool active = false) : BaseLeaf(PartialCreate(), coords, value, active) , mAttributeSet(new AttributeSet)"
  },
  {
    "label": "attributeSet()",
    "kind": "Method",
    "detail": "Function (} public : const AttributeSet&)",
    "insertText": "attributeSet()"
  },
  {
    "label": "initializeAttributes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initializeAttributes(const Descriptor::Ptr& descriptor, const Index arrayLength, const AttributeArray::ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "clearAttributes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clearAttributes(const bool updateValueMask = true, const AttributeArray::ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "hasAttribute()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasAttribute(const size_t pos)"
  },
  {
    "label": "hasAttribute()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasAttribute(const Name& attributeName)"
  },
  {
    "label": "appendAttribute()",
    "kind": "Method",
    "detail": "Function (AttributeArray::Ptr)",
    "insertText": "appendAttribute(const Descriptor& expected, Descriptor::Ptr& replacement, const size_t pos, const Index strideOrTotalSize = 1, const bool constantStride = true, const Metadata* metadata = nullptr, const AttributeArray::ScopedRegistryLock* lock = nullptr)"
  },
  {
    "label": "dropAttributes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dropAttributes(const std::vector<size_t>& pos, const Descriptor& expected, Descriptor::Ptr& replacement)"
  },
  {
    "label": "reorderAttributes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reorderAttributes(const Descriptor::Ptr& replacement)"
  },
  {
    "label": "renameAttributes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "renameAttributes(const Descriptor& expected, Descriptor::Ptr& replacement)"
  },
  {
    "label": "compactAttributes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "compactAttributes()"
  },
  {
    "label": "replaceAttributeSet()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replaceAttributeSet(AttributeSet* attributeSet, bool allowMismatchingDescriptors = false)"
  },
  {
    "label": "resetDescriptor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resetDescriptor(const Descriptor::Ptr& replacement)"
  },
  {
    "label": "setOffsets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOffsets(const std::vector<ValueType>& offsets, const bool updateValueMask = true)"
  },
  {
    "label": "validateOffsets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "validateOffsets()"
  },
  {
    "label": "attributeArray()",
    "kind": "Method",
    "detail": "Function (AttributeArray&)",
    "insertText": "attributeArray(const size_t pos)"
  },
  {
    "label": "constAttributeArray()",
    "kind": "Method",
    "detail": "Function (const AttributeArray&)",
    "insertText": "constAttributeArray(const size_t pos)"
  },
  {
    "label": "attributeArray()",
    "kind": "Method",
    "detail": "Function (AttributeArray&)",
    "insertText": "attributeArray(const Name& attributeName)"
  },
  {
    "label": "constAttributeArray()",
    "kind": "Method",
    "detail": "Function (const AttributeArray&)",
    "insertText": "constAttributeArray(const Name& attributeName)"
  },
  {
    "label": "groupHandle()",
    "kind": "Method",
    "detail": "Function (GroupHandle)",
    "insertText": "groupHandle(const AttributeSet::Descriptor::GroupIndex& index)"
  },
  {
    "label": "groupHandle()",
    "kind": "Method",
    "detail": "Function (GroupHandle)",
    "insertText": "groupHandle(const Name& group)"
  },
  {
    "label": "groupWriteHandle()",
    "kind": "Method",
    "detail": "Function (GroupWriteHandle)",
    "insertText": "groupWriteHandle(const AttributeSet::Descriptor::GroupIndex& index)"
  },
  {
    "label": "groupWriteHandle()",
    "kind": "Method",
    "detail": "Function (GroupWriteHandle)",
    "insertText": "groupWriteHandle(const Name& name)"
  },
  {
    "label": "pointCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "pointCount()"
  },
  {
    "label": "onPointCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "onPointCount()"
  },
  {
    "label": "offPointCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "offPointCount()"
  },
  {
    "label": "groupPointCount()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "groupPointCount(const Name& groupName)"
  },
  {
    "label": "updateValueMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "updateValueMask()"
  },
  {
    "label": "setOffsetOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOffsetOn(Index offset, const ValueType& val)"
  },
  {
    "label": "setOffsetOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOffsetOnly(Index offset, const ValueType& val)"
  },
  {
    "label": "hasSameTopology()",
    "kind": "Method",
    "detail": "Function (template<OtherType,Index OtherLog2Dim> bool)",
    "insertText": "hasSameTopology(const PointDataLeafNode<OtherType, OtherLog2Dim>* other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const PointDataLeafNode& other)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addLeaf(PointDataLeafNode*)"
  },
  {
    "label": "addLeafAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "addLeafAndCache(PointDataLeafNode*, AccessorT&)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (} PointDataLeafNode*)",
    "insertText": "touchLeaf(const Coord&)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(!(std::is_same<NodeT,PointDataLeafNode>::value))"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } PointDataLeafNode*)",
    "insertText": "probeLeaf(const Coord&)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_END } void)",
    "insertText": "readTopology(std::istream& is, bool fromHalf = false)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeTopology(std::ostream& os, bool toHalf = false)"
  },
  {
    "label": "buffers()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "buffers()"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream& is, bool fromHalf = false)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(std::istream& is, const CoordBBox&, bool fromHalf = false)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(std::ostream& os, bool toHalf = false)"
  },
  {
    "label": "memUsage()",
    "kind": "Method",
    "detail": "Function (Index64)",
    "insertText": "memUsage()"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalActiveBoundingBox(CoordBBox& bbox, bool visitVoxels = true)"
  },
  {
    "label": "getNodeBoundingBox()",
    "kind": "Method",
    "detail": "Function (CoordBBox)",
    "insertText": "getNodeBoundingBox()"
  },
  {
    "label": "assertNonmodifiable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assertNonmodifiable()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(false && \"Cannot modify voxel values in a PointDataTree.\")"
  },
  {
    "label": "assertNonModifiableUnlessZero()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "assertNonModifiableUnlessZero(const ValueType& value)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setActiveState(const Coord& xyz, bool on)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setActiveState(xyz, on)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setActiveState(Index offset, bool on)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setActiveState(offset, on)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOnly(const Coord&, const ValueType&)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOnly(Index, const ValueType&)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(const Coord& xyz)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOff(xyz)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(Index offset)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOff(offset)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(const Coord&, const ValueType&)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(Index, const ValueType&)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(const Coord& xyz)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOn(xyz)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(Index offset)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setValueOn(offset)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(const Coord&, const ValueType&)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(Index, const ValueType&)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValue(const Coord&, const ValueType&)"
  },
  {
    "label": "setValuesOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValuesOn()"
  },
  {
    "label": "setValuesOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValuesOff()"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValue(Index, const ModifyOp&)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValue(const Coord&, const ModifyOp&)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValueAndActiveState(const Coord&, const ModifyOp&)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clip(const CoordBBox&, const ValueType& value)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "fill(const CoordBBox&, const ValueType&, bool)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(const ValueType& value)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "fill(const ValueType&, bool)"
  },
  {
    "label": "setValueOnlyAndCache()",
    "kind": "Method",
    "detail": "Function (template<AccessorT> void)",
    "insertText": "setValueOnlyAndCache(const Coord&, const ValueType&, AccessorT&)"
  },
  {
    "label": "modifyValueAndActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp,AccessorT> void)",
    "insertText": "modifyValueAndActiveStateAndCache(const Coord&, const ModifyOp&, AccessorT&)"
  },
  {
    "label": "setValueOffAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setValueOffAndCache(const Coord&, const ValueType&, AccessorT&)"
  },
  {
    "label": "setActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "setActiveStateAndCache(const Coord& xyz, bool on, AccessorT& parent)"
  },
  {
    "label": "setActiveStateAndCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setActiveStateAndCache(xyz, on, parent)"
  },
  {
    "label": "resetBackground()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "resetBackground(const ValueType&, const ValueType& newBackground)"
  },
  {
    "label": "assertNonModifiableUnlessZero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assertNonModifiableUnlessZero(newBackground)"
  },
  {
    "label": "signedFloodFill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "signedFloodFill(const ValueType&)"
  },
  {
    "label": "signedFloodFill()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "signedFloodFill(const ValueType&, const ValueType&)"
  },
  {
    "label": "negate()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "negate()"
  },
  {
    "label": "beginValueVoxel()",
    "kind": "Method",
    "detail": "Function (} class::TestPointDataLeaf ; using ValueOn = BaseLeaf::ValueOn ; using ValueOff = BaseLeaf::ValueOff ; using ValueAll = BaseLeaf::ValueAll ; private : AttributeSet::UniquePtr mAttributeSet ; uint16_t mVoxelBufferSize = 0 ; protected : using ChildOn = BaseLeaf::ChildOn ; using ChildOff = BaseLeaf::ChildOff ; using ChildAll = BaseLeaf::ChildAll ; using MaskOnIterator = NodeMaskType::OnIterator ; using MaskOffIterator = NodeMaskType::OffIterator ; using MaskDenseIterator = NodeMaskType::DenseIterator ; template<,Index> class PointDataLeafNode ; class tree::IteratorBase<MaskOnIterator,PointDataLeafNode> ; class tree::IteratorBase<MaskOffIterator,PointDataLeafNode> ; class tree::IteratorBase<MaskDenseIterator,PointDataLeafNode> ; public : ValueVoxelCIter)",
    "insertText": "beginValueVoxel(const Coord& ijk)"
  },
  {
    "label": "beginIndexAll()",
    "kind": "Method",
    "detail": "Function (public : using ValueOnIter = BaseLeaf::template ValueIter<MaskOnIterator,PointDataLeafNode,const ValueType,ValueOn> ; using ValueOnCIter = BaseLeaf::template ValueIter<MaskOnIterator,const PointDataLeafNode,const ValueType,ValueOn> ; using ValueOffIter = BaseLeaf::template ValueIter<MaskOffIterator,PointDataLeafNode,const ValueType,ValueOff> ; using ValueOffCIter = BaseLeaf::template ValueIter<MaskOffIterator,const PointDataLeafNode,const ValueType,ValueOff> ; using ValueAllIter = BaseLeaf::template ValueIter<MaskDenseIterator,PointDataLeafNode,const ValueType,ValueAll> ; using ValueAllCIter = BaseLeaf::template ValueIter<MaskDenseIterator,const PointDataLeafNode,const ValueType,ValueAll> ; using ChildOnIter = BaseLeaf::template ChildIter<MaskOnIterator,PointDataLeafNode,ChildOn> ; using ChildOnCIter = BaseLeaf::template ChildIter<MaskOnIterator,const PointDataLeafNode,ChildOn> ; using ChildOffIter = BaseLeaf::template ChildIter<MaskOffIterator,PointDataLeafNode,ChildOff> ; using ChildOffCIter = BaseLeaf::template ChildIter<MaskOffIterator,const PointDataLeafNode,ChildOff> ; using ChildAllIter = BaseLeaf::template DenseIter<PointDataLeafNode,ValueType,ChildAll> ; using ChildAllCIter = BaseLeaf::template DenseIter<const PointDataLeafNode,const ValueType,ChildAll> ; using IndexVoxelIter = IndexIter<ValueVoxelCIter,NullFilter> ; using IndexAllIter = IndexIter<ValueAllCIter,NullFilter> ; using IndexOnIter = IndexIter<ValueOnCIter,NullFilter> ; using IndexOffIter = IndexIter<ValueOffCIter,NullFilter> ; IndexAllIter)",
    "insertText": "beginIndexAll()"
  },
  {
    "label": "NullFilter()",
    "kind": "Method",
    "detail": "Function (NullFilter filter ; return this -> beginIndex<ValueAllCIter,)",
    "insertText": "NullFilter(filter)"
  },
  {
    "label": "beginIndexOn()",
    "kind": "Method",
    "detail": "Function (} IndexOnIter)",
    "insertText": "beginIndexOn()"
  },
  {
    "label": "beginIndexOff()",
    "kind": "Method",
    "detail": "Function (} IndexOffIter)",
    "insertText": "beginIndexOff()"
  },
  {
    "label": "beginIndex()",
    "kind": "Method",
    "detail": "Function (} template<IterT,FilterT> IndexIter<IterT,FilterT>)",
    "insertText": "beginIndex(const FilterT& filter)"
  },
  {
    "label": "beginIndexAll()",
    "kind": "Method",
    "detail": "Function (template<FilterT> IndexIter<ValueAllCIter,FilterT>)",
    "insertText": "beginIndexAll(const FilterT& filter)"
  },
  {
    "label": "beginIndexOn()",
    "kind": "Method",
    "detail": "Function (} template<FilterT> IndexIter<ValueOnCIter,FilterT>)",
    "insertText": "beginIndexOn(const FilterT& filter)"
  },
  {
    "label": "beginIndexOff()",
    "kind": "Method",
    "detail": "Function (} template<FilterT> IndexIter<ValueOffCIter,FilterT>)",
    "insertText": "beginIndexOff(const FilterT& filter)"
  },
  {
    "label": "beginIndexVoxel()",
    "kind": "Method",
    "detail": "Function (} IndexVoxelIter)",
    "insertText": "beginIndexVoxel(const Coord& ijk)"
  },
  {
    "label": "beginIndexVoxel()",
    "kind": "Method",
    "detail": "Function (template<FilterT> IndexIter<ValueVoxelCIter,FilterT>)",
    "insertText": "beginIndexVoxel(const Coord& ijk, const FilterT& filter)"
  },
  {
    "label": "getValueMask()",
    "kind": "Method",
    "detail": "Function (# define VMASK_ this ->)",
    "insertText": "getValueMask() ValueOnCIter cbeginValueOn()"
  },
  {
    "label": "beginValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "beginValueOn()"
  },
  {
    "label": "cbeginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cbeginValueOff()"
  },
  {
    "label": "beginValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "beginValueOff()"
  },
  {
    "label": "cbeginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cbeginValueAll()"
  },
  {
    "label": "beginValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "beginValueAll()"
  },
  {
    "label": "cendValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "cendValueOn()"
  },
  {
    "label": "endValueOn()",
    "kind": "Method",
    "detail": "Function (} ValueOnCIter)",
    "insertText": "endValueOn()"
  },
  {
    "label": "cendValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "cendValueOff()"
  },
  {
    "label": "endValueOff()",
    "kind": "Method",
    "detail": "Function (} ValueOffCIter)",
    "insertText": "endValueOff()"
  },
  {
    "label": "cendValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "cendValueAll()"
  },
  {
    "label": "endValueAll()",
    "kind": "Method",
    "detail": "Function (} ValueAllCIter)",
    "insertText": "endValueAll()"
  },
  {
    "label": "cbeginChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "cbeginChildOn()"
  },
  {
    "label": "beginChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "beginChildOn()"
  },
  {
    "label": "cbeginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "cbeginChildOff()"
  },
  {
    "label": "beginChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "beginChildOff()"
  },
  {
    "label": "cbeginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "cbeginChildAll()"
  },
  {
    "label": "beginChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "beginChildAll()"
  },
  {
    "label": "cendChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "cendChildOn()"
  },
  {
    "label": "endChildOn()",
    "kind": "Method",
    "detail": "Function (} ChildOnCIter)",
    "insertText": "endChildOn()"
  },
  {
    "label": "cendChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "cendChildOff()"
  },
  {
    "label": "endChildOff()",
    "kind": "Method",
    "detail": "Function (} ChildOffCIter)",
    "insertText": "endChildOff()"
  },
  {
    "label": "cendChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "cendChildAll()"
  },
  {
    "label": "endChildAll()",
    "kind": "Method",
    "detail": "Function (} ChildAllCIter)",
    "insertText": "endChildAll()"
  },
  {
    "label": "stealAttributeSet()",
    "kind": "Method",
    "detail": "Function (} # undef VMASK_ } ; template<T,Index Log2Dim> AttributeSet::UniquePtr PointDataLeafNode<T,Log2Dim)",
    "insertText": "stealAttributeSet()"
  },
  {
    "label": "AttributeSet()",
    "kind": "Method",
    "detail": "Function (AttributeSet::UniquePtr ptr = std::make_unique<)",
    "insertText": "AttributeSet()"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(ptr, mAttributeSet)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(IndexError, \"Initializing attributes only allowed with one Vec3f position attribute.\")"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} mAttributeSet .)",
    "insertText": "reset(new AttributeSet(descriptor, arrayLength, lock))"
  },
  {
    "label": "clearAttributes()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void PointDataLeafNode<T,Log2Dim)",
    "insertText": "clearAttributes(const bool updateValueMask, const AttributeArray::ScopedRegistryLock* lock)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mAttributeSet .)",
    "insertText": "reset(new AttributeSet(*mAttributeSet, 0, lock))"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "buffer().fill(ValueType(0))"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (const size_t pos = mAttributeSet ->)",
    "insertText": "find(attributeName)"
  },
  {
    "label": "dropAttributes()",
    "kind": "Method",
    "detail": "Function (mAttributeSet ->)",
    "insertText": "dropAttributes(pos, expected, replacement)"
  },
  {
    "label": "reorderAttributes()",
    "kind": "Method",
    "detail": "Function (mAttributeSet ->)",
    "insertText": "reorderAttributes(replacement)"
  },
  {
    "label": "renameAttributes()",
    "kind": "Method",
    "detail": "Function (mAttributeSet ->)",
    "insertText": "renameAttributes(expected, replacement)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (AttributeArray* array = mAttributeSet ->)",
    "insertText": "get(i)"
  },
  {
    "label": "compact()",
    "kind": "Method",
    "detail": "Function (array ->)",
    "insertText": "compact()"
  },
  {
    "label": "replaceAttributeSet()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> void PointDataLeafNode<T,Log2Dim)",
    "insertText": "replaceAttributeSet(AttributeSet* attributeSet, bool allowMismatchingDescriptors)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ValueError, \"Cannot replace with a null attribute set\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!allowMismatchingDescriptors && mAttributeSet->descriptor() != attributeSet->descriptor())"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ValueError, \"Attribute set descriptors are not equal.\")"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} mAttributeSet .)",
    "insertText": "reset(attributeSet)"
  },
  {
    "label": "resetDescriptor()",
    "kind": "Method",
    "detail": "Function (mAttributeSet ->)",
    "insertText": "resetDescriptor(replacement)"
  },
  {
    "label": "setOffsets()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void PointDataLeafNode<T,Log2Dim)",
    "insertText": "setOffsets(const std::vector<ValueType>& offsets, const bool updateValueMask)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ValueError, \"Offset vector size doesn't match number of voxels.\") } for (Index index = 0; index < offsets.size(); ++index)"
  },
  {
    "label": "setOffsetOnly()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOffsetOnly(index, offsets[index])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(updateValueMask) this->updateValueMask()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ValueError, \"Voxel offset values are not monotonically increasing\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(size_t attributeIndex = 1; attributeIndex < mAttributeSet->size(); ++attributeIndex)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ValueError, \"Attribute arrays have inconsistent length\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(mAttributeSet->size() > 0 && this->getValue(BaseLeaf::SIZE-1) != mAttributeSet->getConst(0)->size())"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ValueError, \"Last voxel offset value does not match attribute array length\")"
  },
  {
    "label": "attributeArray()",
    "kind": "Method",
    "detail": "Function (const AttributeArray& array = this ->)",
    "insertText": "attributeArray(index.first)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(isGroup(array))"
  },
  {
    "label": "cast()",
    "kind": "Method",
    "detail": "Function (const GroupAttributeArray& groupArray =)",
    "insertText": "cast(array)"
  },
  {
    "label": "groupHandle()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> GroupHandle PointDataLeafNode<T,Log2Dim)",
    "insertText": "groupHandle(const Name& name)"
  },
  {
    "label": "attributeSet()",
    "kind": "Method",
    "detail": "Function (const AttributeSet::Descriptor::GroupIndex index = this ->)",
    "insertText": "attributeSet().groupIndex(name)"
  },
  {
    "label": "newFilter()",
    "kind": "Method",
    "detail": "Function (} FilterT)",
    "insertText": "newFilter(filter)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (newFilter .)",
    "insertText": "reset(*this)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (using IterTraitsT = tree::IterTraits<LeafNodeType,ValueIterT> ; ValueIterT valueIter =)",
    "insertText": "begin(*this)"
  },
  {
    "label": "coordToOffset()",
    "kind": "Method",
    "detail": "Function (const Index index =)",
    "insertText": "coordToOffset(ijk)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(index < BaseLeaf::SIZE)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const ValueType end = this ->)",
    "insertText": "getValue(index)"
  },
  {
    "label": "start()",
    "kind": "Method",
    "detail": "Function (const ValueType)",
    "insertText": "start(index == 0) ? ValueType(0) : this->getValue(index - 1)"
  },
  {
    "label": "beginValueVoxel()",
    "kind": "Method",
    "detail": "Function (ValueVoxelCIter iter = this ->)",
    "insertText": "beginValueVoxel(ijk)"
  },
  {
    "label": "filter()",
    "kind": "Method",
    "detail": "Function (} GroupFilter)",
    "insertText": "filter(groupName, this->attributeSet())"
  },
  {
    "label": "iterCount()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "iterCount(this->beginIndexAll(filter))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (ValueType start = 0,end = 0 ;)",
    "insertText": "for(Index n = 0; n < LeafNodeType::NUM_VALUES; n++)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (end = this ->)",
    "insertText": "getValue(n)"
  },
  {
    "label": "setValueMask()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueMask(n, (end - start) > 0)"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "buffer().setValue(offset, val)"
  },
  {
    "label": "setValueMaskOn()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueMaskOn(offset)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void PointDataLeafNode<T,Log2Dim)",
    "insertText": "readTopology(std::istream& is, bool fromHalf)"
  },
  {
    "label": "readTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readTopology(is, fromHalf)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void PointDataLeafNode<T,Log2Dim)",
    "insertText": "writeTopology(std::ostream& os, bool toHalf)"
  },
  {
    "label": "writeTopology()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeTopology(os, toHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void PointDataLeafNode<T,Log2Dim)",
    "insertText": "readBuffers(std::istream& is, bool fromHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "readBuffers(is, CoordBBox::inf(), fromHalf)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void PointDataLeafNode<T,Log2Dim)",
    "insertText": "readBuffers(std::istream& is, const CoordBBox& , bool fromHalf)"
  },
  {
    "label": "destroyPagedStream()",
    "kind": "Method",
    "detail": "Function (struct Local { void)",
    "insertText": "destroyPagedStream(const io::StreamMetadata::AuxDataMap& auxData, const Index index)"
  },
  {
    "label": "key()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "key(\"paged:\" + std::to_string(index))"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (auto it = auxData .)",
    "insertText": "find(key)"
  },
  {
    "label": "getOrInsertPagedStream()",
    "kind": "Method",
    "detail": "Function (} } compression::PagedInputStream&)",
    "insertText": "getOrInsertPagedStream(const io::StreamMetadata::AuxDataMap& auxData, const Index index)"
  },
  {
    "label": "PagedInputStream()",
    "kind": "Method",
    "detail": "Function (} else { compression::PagedInputStream::Ptr pagedStream = std::make_shared<)",
    "insertText": "PagedInputStream()"
  },
  {
    "label": "matchingKey()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "matchingKey(\"hasMatchingDescriptor\")"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (auto itMatching = auxData .)",
    "insertText": "find(matchingKey)"
  },
  {
    "label": "clearMatchingDescriptor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clearMatchingDescriptor(const io::StreamMetadata::AuxDataMap& auxData)"
  },
  {
    "label": "descriptorKey()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "descriptorKey(\"descriptorPtr\")"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (auto itDescriptor = auxData .)",
    "insertText": "find(descriptorKey)"
  },
  {
    "label": "insertDescriptor()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "insertDescriptor(const io::StreamMetadata::AuxDataMap& auxData, const Descriptor::Ptr descriptor)"
  },
  {
    "label": "retrieveMatchingDescriptor()",
    "kind": "Method",
    "detail": "Function (} } AttributeSet::Descriptor::Ptr)",
    "insertText": "retrieveMatchingDescriptor(const io::StreamMetadata::AuxDataMap& auxData)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(itDescriptor != auxData.end())"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (const Descriptor::Ptr descriptor = boost::any_cast<AttributeSet::)",
    "insertText": "Ptr(itDescriptor->second)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(IoError, \"Cannot read in a PointDataLeaf without StreamMetadata.\")"
  },
  {
    "label": "pass()",
    "kind": "Method",
    "detail": "Function (} const Index)",
    "insertText": "pass(static_cast<uint16_t>(meta->pass()))"
  },
  {
    "label": "maximumPass()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "maximumPass(static_cast<uint16_t>(meta->pass() >> 16))"
  },
  {
    "label": "attributes()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "attributes(maximumPass - 4)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&mVoxelBufferSize), sizeof(uint16_t))"
  },
  {
    "label": "clearMatchingDescriptor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clearMatchingDescriptor(meta->auxData())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(pass == 1)"
  },
  {
    "label": "retrieveMatchingDescriptor()",
    "kind": "Method",
    "detail": "Function (AttributeSet::Descriptor::Ptr descriptor =)",
    "insertText": "retrieveMatchingDescriptor(meta->auxData())"
  },
  {
    "label": "resetDescriptor()",
    "kind": "Method",
    "detail": "Function (mAttributeSet ->)",
    "insertText": "resetDescriptor(descriptor, true)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (} else { uint8_t header ; is .)",
    "insertText": "read(reinterpret_cast<char*>(&header), sizeof(uint8_t))"
  },
  {
    "label": "readDescriptor()",
    "kind": "Method",
    "detail": "Function (mAttributeSet ->)",
    "insertText": "readDescriptor(is)"
  },
  {
    "label": "descriptorPtr()",
    "kind": "Method",
    "detail": "Function (AttributeSet::DescriptorPtr descriptor = mAttributeSet ->)",
    "insertText": "descriptorPtr()"
  },
  {
    "label": "insertDescriptor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insertDescriptor(meta->auxData(), descriptor)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(header & uint8_t(2))"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (uint64_t bytesToSkip ; is .)",
    "insertText": "read(reinterpret_cast<char*>(&bytesToSkip), sizeof(uint64_t))"
  },
  {
    "label": "seekg()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "seekg(bytesToSkip, std::ios_base::cur)"
  },
  {
    "label": "tempData()",
    "kind": "Method",
    "detail": "Function (} else { std::vector<uint8_t>)",
    "insertText": "tempData(bytesToSkip)"
  },
  {
    "label": "read()",
    "kind": "Method",
    "detail": "Function (is .)",
    "insertText": "read(reinterpret_cast<char*>(&tempData[0]), bytesToSkip)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(header > uint8_t(3))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(IoError, \"Unrecognised header flags in PointDataLeafNode\")"
  },
  {
    "label": "readMetadata()",
    "kind": "Method",
    "detail": "Function (} } mAttributeSet ->)",
    "insertText": "readMetadata(is)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(pass < (attributes + 2))"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (const size_t attributeIndex = pass - 2 ; AttributeArray* array = attributeIndex<mAttributeSet ->)",
    "insertText": "size() ? mAttributeSet->get(attributeIndex)"
  },
  {
    "label": "getOrInsertPagedStream()",
    "kind": "Method",
    "detail": "Function (compression::PagedInputStream& pagedStream =)",
    "insertText": "getOrInsertPagedStream(meta->auxData(), static_cast<Index>(attributeIndex))"
  },
  {
    "label": "setInputStream()",
    "kind": "Method",
    "detail": "Function (pagedStream .)",
    "insertText": "setInputStream(is)"
  },
  {
    "label": "setSizeOnly()",
    "kind": "Method",
    "detail": "Function (pagedStream .)",
    "insertText": "setSizeOnly(true)"
  },
  {
    "label": "readPagedBuffers()",
    "kind": "Method",
    "detail": "Function (array ->)",
    "insertText": "readPagedBuffers(pagedStream)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(pass == attributes + 2)"
  },
  {
    "label": "passValue()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "passValue(meta->pass())"
  },
  {
    "label": "StreamMetadata()",
    "kind": "Method",
    "detail": "Function (io::StreamMetadata& nonConstMeta = const_cast<)",
    "insertText": "StreamMetadata(*meta)"
  },
  {
    "label": "setPass()",
    "kind": "Method",
    "detail": "Function (nonConstMeta .)",
    "insertText": "setPass(mVoxelBufferSize)"
  },
  {
    "label": "readBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "readBuffers(is, fromHalf)"
  },
  {
    "label": "setPass()",
    "kind": "Method",
    "detail": "Function (nonConstMeta .)",
    "insertText": "setPass(passValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(pass < (attributes*2 + 3))"
  },
  {
    "label": "getOrInsertPagedStream()",
    "kind": "Method",
    "detail": "Function (compression::PagedInputStream& pagedStream =)",
    "insertText": "getOrInsertPagedStream(meta->auxData(), attributeIndex)"
  },
  {
    "label": "setSizeOnly()",
    "kind": "Method",
    "detail": "Function (pagedStream .)",
    "insertText": "setSizeOnly(false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(pass > attributes + 3)"
  },
  {
    "label": "destroyPagedStream()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "destroyPagedStream(meta->auxData(), attributeIndex-1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else)",
    "insertText": "if(pass < buffers())"
  },
  {
    "label": "destroyPagedStream()",
    "kind": "Method",
    "detail": "Function (const Index attributeIndex = pass - attributes - 4 ;)",
    "insertText": "destroyPagedStream(meta->auxData(), attributeIndex)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (} } template<T,Index Log2Dim> void PointDataLeafNode<T,Log2Dim)",
    "insertText": "writeBuffers(std::ostream& os, bool toHalf)"
  },
  {
    "label": "stream()",
    "kind": "Method",
    "detail": "Function (compression::PagedOutputStream&)",
    "insertText": "stream(boost::any_cast<compression::PagedOutputStream::Ptr>(it->second))"
  },
  {
    "label": "flush()",
    "kind": "Method",
    "detail": "Function (stream .)",
    "insertText": "flush()"
  },
  {
    "label": "PagedOutputStream()",
    "kind": "Method",
    "detail": "Function (} else { compression::PagedOutputStream::Ptr pagedStream = std::make_shared<)",
    "insertText": "PagedOutputStream()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(itDescriptor == auxData.end())"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (} else { bool matching = boost::any_cast<)",
    "insertText": "bool(itMatching->second)"
  },
  {
    "label": "hasMatchingDescriptor()",
    "kind": "Method",
    "detail": "Function (} } } bool)",
    "insertText": "hasMatchingDescriptor(const io::StreamMetadata::AuxDataMap& auxData)"
  },
  {
    "label": "getStreamMetadataPtr()",
    "kind": "Method",
    "detail": "Function (} } ; const io::StreamMetadata::Ptr meta =)",
    "insertText": "getStreamMetadataPtr(os)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(IoError, \"Cannot write out a PointDataLeaf without StreamMetadata.\")"
  },
  {
    "label": "setPass()",
    "kind": "Method",
    "detail": "Function (meta ->)",
    "insertText": "setPass(requiredPasses)"
  },
  {
    "label": "writeCompressedValuesSize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeCompressedValuesSize(os, this->buffer().data(), SIZE)"
  },
  {
    "label": "insertDescriptor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "insertDescriptor(meta->auxData(), mAttributeSet->descriptorPtr())"
  },
  {
    "label": "hasMatchingDescriptor()",
    "kind": "Method",
    "detail": "Function (bool matchingDescriptor =)",
    "insertText": "hasMatchingDescriptor(meta->auxData())"
  },
  {
    "label": "header()",
    "kind": "Method",
    "detail": "Function (uint8_t)",
    "insertText": "header(1)"
  },
  {
    "label": "write()",
    "kind": "Method",
    "detail": "Function (os .)",
    "insertText": "write(reinterpret_cast<const char*>(&header), sizeof(uint8_t))"
  },
  {
    "label": "writeDescriptor()",
    "kind": "Method",
    "detail": "Function (mAttributeSet ->)",
    "insertText": "writeDescriptor(os, false)"
  },
  {
    "label": "header()",
    "kind": "Method",
    "detail": "Function (} } else { uint8_t)",
    "insertText": "header(0)"
  },
  {
    "label": "writeMetadata()",
    "kind": "Method",
    "detail": "Function (} mAttributeSet ->)",
    "insertText": "writeMetadata(os, false, true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(pass < attributes + 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index attributeIndex = pass - 2 ;)",
    "insertText": "if(pass > 2)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} const AttributeArray* array = attributeIndex<mAttributeSet ->)",
    "insertText": "size() ? mAttributeSet->getConst(attributeIndex)"
  },
  {
    "label": "setOutputStream()",
    "kind": "Method",
    "detail": "Function (pagedStream .)",
    "insertText": "setOutputStream(os)"
  },
  {
    "label": "writePagedBuffers()",
    "kind": "Method",
    "detail": "Function (array ->)",
    "insertText": "writePagedBuffers(pagedStream, false)"
  },
  {
    "label": "writeBuffers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "writeBuffers(os, toHalf)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index attributeIndex = pass - attributes - 3 ;)",
    "insertText": "if(pass > attributes + 2)"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void PointDataLeafNode<T,Log2Dim)",
    "insertText": "evalActiveBoundingBox(CoordBBox& bbox, bool visitVoxels)"
  },
  {
    "label": "evalActiveBoundingBox()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalActiveBoundingBox(bbox, visitVoxels)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} template<T,Index Log2Dim> void PointDataLeafNode<T,Log2Dim)",
    "insertText": "fill(const CoordBBox& bbox, const ValueType& value, bool active)"
  },
  {
    "label": "offsetX()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "offsetX(x & (DIM-1u))"
  },
  {
    "label": "offsetX()",
    "kind": "Method",
    "detail": "Function (const Index offsetXY =)",
    "insertText": "offsetX((y & (DIM-1u)) << Log2Dim)"
  },
  {
    "label": "offsetXY()",
    "kind": "Method",
    "detail": "Function (const Index offset =)",
    "insertText": "offsetXY(z & (DIM-1u))"
  },
  {
    "label": "setValueMask()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setValueMask(offset, active)"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (} } } } template<T,Index Log2Dim> void PointDataLeafNode<T,Log2Dim)",
    "insertText": "fill(const ValueType& value, bool active)"
  },
  {
    "label": "beginLeaf()",
    "kind": "Method",
    "detail": "Function (auto leafIter = tree .)",
    "insertText": "beginLeaf()"
  },
  {
    "label": "attributeSet()",
    "kind": "Method",
    "detail": "Function (const AttributeSet::Descriptor& descriptor = leafIter ->)",
    "insertText": "attributeSet().descriptor()"
  },
  {
    "label": "Descriptor()",
    "kind": "Method",
    "detail": "Function (auto newDescriptor = std::make_shared<)",
    "insertText": "Descriptor(descriptor)"
  },
  {
    "label": "resetDescriptor()",
    "kind": "Method",
    "detail": "Function (leafIter ->)",
    "insertText": "resetDescriptor(newDescriptor)"
  },
  {
    "label": "setStreamingMode()",
    "kind": "Method",
    "detail": "Function (} return newDescriptor ; } template<PointDataTreeT> void)",
    "insertText": "setStreamingMode(PointDataTreeT& tree, bool on)"
  },
  {
    "label": "attributeArray()",
    "kind": "Method",
    "detail": "Function (leafIter ->)",
    "insertText": "attributeArray(i).setStreaming(on)"
  },
  {
    "label": "prefetch()",
    "kind": "Method",
    "detail": "Function (} } } template<PointDataTreeT> void)",
    "insertText": "prefetch(PointDataTreeT& tree, bool position, bool otherAttributes)"
  },
  {
    "label": "cbeginLeaf()",
    "kind": "Method",
    "detail": "Function (auto leaf = tree .)",
    "insertText": "cbeginLeaf()"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (leaf ->)",
    "insertText": "buffer().data()"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} size_t positionIndex = attributeSet .)",
    "insertText": "find(\"P\")"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(leaf->hasAttribute(positionIndex))"
  },
  {
    "label": "constAttributeArray()",
    "kind": "Method",
    "detail": "Function (leaf ->)",
    "insertText": "constAttributeArray(positionIndex).loadData()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(otherAttributes)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (const size_t attributes = attributeSet .)",
    "insertText": "size()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(leaf->hasAttribute(attributeIndex))"
  },
  {
    "label": "constAttributeArray()",
    "kind": "Method",
    "detail": "Function (leaf ->)",
    "insertText": "constAttributeArray(attributeIndex).loadData()"
  },
  {
    "label": "initialize()",
    "kind": "Method",
    "detail": "Function (} } } } namespace internal { void)",
    "insertText": "initialize()"
  },
  {
    "label": "uninitialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "uninitialize()"
  }
]