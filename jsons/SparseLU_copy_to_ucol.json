[
  {
    "label": "copy_to_ucol()",
    "kind": "Method",
    "detail": "Function (# ifndef SPARSELU_COPY_TO_UCOL_H # define SPARSELU_COPY_TO_UCOL_H namespace Eigen { namespace internal { template<Scalar,StorageIndex> Index SparseLUImpl<Scalar,StorageIndex)",
    "insertText": "copy_to_ucol(const Index jcol, const Index nseg, IndexVector& segrep, BlockIndexVector repfnz ,IndexVector& perm_r, BlockScalarVector dense, GlobalLU_t& glu)"
  },
  {
    "label": "supno()",
    "kind": "Method",
    "detail": "Function (Index ksub,krep,ksupno ; Index jsupno = glu .)",
    "insertText": "supno(jcol)"
  },
  {
    "label": "xusub()",
    "kind": "Method",
    "detail": "Function (Index k = nseg - 1,i ; StorageIndex nextu = glu .)",
    "insertText": "xusub(jcol)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index kfnz,isub,segsize ; Index new_next,irow ; Index fsupc,mem ;)",
    "insertText": "for(ksub = 0; ksub < nseg; ksub++)"
  },
  {
    "label": "segrep()",
    "kind": "Method",
    "detail": "Function (krep =)",
    "insertText": "segrep(k)"
  },
  {
    "label": "supno()",
    "kind": "Method",
    "detail": "Function (k - - ; ksupno = glu .)",
    "insertText": "supno(krep)"
  },
  {
    "label": "repfnz()",
    "kind": "Method",
    "detail": "Function (kfnz =)",
    "insertText": "repfnz(krep)"
  },
  {
    "label": "xsup()",
    "kind": "Method",
    "detail": "Function (fsupc = glu .)",
    "insertText": "xsup(ksupno)"
  },
  {
    "label": "xlsub()",
    "kind": "Method",
    "detail": "Function (isub = glu .)",
    "insertText": "xlsub(fsupc)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (segsize = krep - kfnz + 1 ; new_next = nextu + segsize ;)",
    "insertText": "while(new_next > glu.nzumax)"
  },
  {
    "label": "ScalarVector()",
    "kind": "Method",
    "detail": "Function (mem = memXpand<)",
    "insertText": "ScalarVector(glu.ucol, glu.nzumax, nextu, UCOL, glu.num_expansions)"
  },
  {
    "label": "IndexVector()",
    "kind": "Method",
    "detail": "Function (mem = memXpand<)",
    "insertText": "IndexVector(glu.usub, glu.nzumax, nextu, USUB, glu.num_expansions)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = 0; i < segsize; i++)"
  },
  {
    "label": "lsub()",
    "kind": "Method",
    "detail": "Function (irow = glu .)",
    "insertText": "lsub(isub)"
  },
  {
    "label": "usub()",
    "kind": "Method",
    "detail": "Function (glu .)",
    "insertText": "usub(nextu) = perm_r(irow)"
  },
  {
    "label": "ucol()",
    "kind": "Method",
    "detail": "Function (glu .)",
    "insertText": "ucol(nextu) = dense(irow)"
  },
  {
    "label": "dense()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "dense(irow) = Scalar(0.0)"
  },
  {
    "label": "xusub()",
    "kind": "Method",
    "detail": "Function (nextu + + ; isub + + ; } } } } glu .)",
    "insertText": "xusub(jcol + 1)"
  }
]