[
  {
    "label": "Project",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Project"
  },
  {
    "label": "CSemanticProgram",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CSemanticProgram"
  },
  {
    "label": "CSemanticAnalyzerImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CSemanticAnalyzerImpl"
  },
  {
    "label": "SBuildContext",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SBuildContext"
  },
  {
    "label": "CSemanticAnalyzer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CSemanticAnalyzer"
  },
  {
    "label": "CSemanticAnalyzer()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" uLang / Common / Containers / SharedPointer . h \" # include \" uLang / Common / Containers / UniquePointer . h \" # include \" uLang / Common / Text / Symbol . h \" # include \" uLang / CompilerPasses / SemanticAnalyzerPassUtils . h \" namespace Verse { namespace Vst { struct Project ; } } namespace uLang { class CSemanticProgram ; class CSemanticAnalyzerImpl ; struct SBuildContext ; int32_t MaxNumPersistentVarsDefault = 2 ; class CSemanticAnalyzer { public :)",
    "insertText": "CSemanticAnalyzer(const TSRef<CSemanticProgram>&, const SBuildContext&)"
  },
  {
    "label": "CSemanticAnalyzer()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CSemanticAnalyzer()"
  },
  {
    "label": "ProcessVst()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ProcessVst(const Verse::Vst::Project& Vst, const ESemanticPass Stage)"
  },
  {
    "label": "GetSemanticProgram()",
    "kind": "Method",
    "detail": "Function (const TSRef<CSemanticProgram>&)",
    "insertText": "GetSemanticProgram()"
  }
]