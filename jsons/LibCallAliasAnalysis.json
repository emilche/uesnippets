[
  {
    "label": "LibCallInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LibCallInfo"
  },
  {
    "label": "LibCallFunctionInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LibCallFunctionInfo"
  },
  {
    "label": "LibCallAliasAnalysis",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LibCallAliasAnalysis"
  },
  {
    "label": "LibCallAliasAnalysis()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ANALYSIS_LIBCALLALIASANALYSIS_H # define LLVM_ANALYSIS_LIBCALLALIASANALYSIS_H # include \" llvm / Analysis / AliasAnalysis . h \" # include \" llvm / IR / Module . h \" # include \" llvm / Pass . h \" namespace llvm { class LibCallInfo ; struct LibCallFunctionInfo ; struct LibCallAliasAnalysis : public FunctionPass,public AliasAnalysis { char ID ; LibCallInfo* LCI ;)",
    "insertText": "LibCallAliasAnalysis(LibCallInfo *LC = nullptr) : FunctionPass(ID), LCI(LC)"
  },
  {
    "label": "initializeLibCallAliasAnalysisPass()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "initializeLibCallAliasAnalysisPass(*PassRegistry::getPassRegistry())"
  },
  {
    "label": "LibCallAliasAnalysis()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "LibCallAliasAnalysis(char &ID, LibCallInfo *LC) : FunctionPass(ID), LCI(LC)"
  },
  {
    "label": "LibCallAliasAnalysis()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "LibCallAliasAnalysis()"
  },
  {
    "label": "getModRefInfo()",
    "kind": "Method",
    "detail": "Function (ModRefResult)",
    "insertText": "getModRefInfo(ImmutableCallSite CS, const MemoryLocation &Loc)"
  },
  {
    "label": "getModRefInfo()",
    "kind": "Method",
    "detail": "Function (ModRefResult)",
    "insertText": "getModRefInfo(ImmutableCallSite CS1, ImmutableCallSite CS2)"
  },
  {
    "label": "getAnalysisUsage()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "getAnalysisUsage(AnalysisUsage &AU)"
  },
  {
    "label": "runOnFunction()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "runOnFunction(Function &F)"
  },
  {
    "label": "getAdjustedAnalysisPointer()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "getAdjustedAnalysisPointer(const void *PI)"
  }
]