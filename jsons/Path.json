[
  {
    "label": "_Tp",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Tp"
  },
  {
    "label": "__can_convert_char",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__can_convert_char"
  },
  {
    "label": "_ECharT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_ECharT"
  },
  {
    "label": "_NullSentinel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_NullSentinel"
  },
  {
    "label": "__is_pathable_string",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_pathable_string"
  },
  {
    "label": "_Traits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Traits"
  },
  {
    "label": "_Alloc",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Alloc"
  },
  {
    "label": "_Source",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Source"
  },
  {
    "label": "_DS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_DS"
  },
  {
    "label": "_UnqualPtrType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_UnqualPtrType"
  },
  {
    "label": "__is_pathable_char_array",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_pathable_char_array"
  },
  {
    "label": "_UPtr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_UPtr"
  },
  {
    "label": "_Iter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Iter"
  },
  {
    "label": "__is_pathable_iter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_pathable_iter"
  },
  {
    "label": "__is_pathable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__is_pathable"
  },
  {
    "label": "_PathCVT",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_PathCVT"
  },
  {
    "label": "_PathExport",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_PathExport"
  },
  {
    "label": "_Str",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Str"
  },
  {
    "label": "_LIBCPP_TYPE_VIS",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_LIBCPP_TYPE_VIS"
  },
  {
    "label": "_SourceOrIter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_SourceOrIter"
  },
  {
    "label": "_LIBCPP_ENUM_VIS",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "_LIBCPP_ENUM_VIS"
  },
  {
    "label": "_InputIt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_InputIt"
  },
  {
    "label": "_Allocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Allocator"
  },
  {
    "label": "_CharT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_CharT"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___FILESYSTEM_PATH_H # define _LIBCPP___FILESYSTEM_PATH_H # include<__algorithm / replace . h> # include<__algorithm / replace_copy . h> # include<__availability> # include<__config> # include<__iterator / back_insert_iterator . h> # include<__iterator / iterator_traits . h> # include<cstddef> # include<string> # include<string_view> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_LOCALIZATION) # include <iomanip> # include <locale> #endif #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)"
  },
  {
    "label": "__is_separator()",
    "kind": "Method",
    "detail": "Function (const bool value = false ; } ; template<class _Tp> struct __can_convert_char<const _Tp> : public __can_convert_char<_Tp> { } ; template<> struct __can_convert_char<char> { const bool value = true ; using __char_type = char ; } ; template<> struct __can_convert_char<wchar_t> { const bool value = true ; using __char_type = wchar_t ; } ; # ifndef _LIBCPP_HAS_NO_CHAR8_T template<> struct __can_convert_char<char8_t> { const bool value = true ; using __char_type = char8_t ; } ; # endif template<> struct __can_convert_char<char16_t> { const bool value = true ; using __char_type = char16_t ; } ; template<> struct __can_convert_char<char32_t> { const bool value = true ; using __char_type = char32_t ; } ; template<class _ECharT> _LIBCPP_HIDE_FROM_ABI enable_if<__can_convert_char<_ECharT>::value,bool>::type)",
    "insertText": "__is_separator(_ECharT __e)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_LIBCPP_WIN32API) return __e == _ECharT('/') || __e == _ECharT('\\\\')"
  },
  {
    "label": "_ECharT()",
    "kind": "Method",
    "detail": "Function (# else return __e = =)",
    "insertText": "_ECharT('/')"
  },
  {
    "label": "__range_begin()",
    "kind": "Method",
    "detail": "Function (# endif } # ifndef _LIBCPP_HAS_NO_CHAR8_T typedef u8string __u8_string ; # else typedef string __u8_string ; # endif struct _NullSentinel { } ; template<class _Tp> using _Void = void ; template<class _Tp,class = void> struct __is_pathable_string : public false_type { } ; template<class _ECharT,class _Traits,class _Alloc> struct __is_pathable_string<basic_string<_ECharT,_Traits,_Alloc>,_Void<__can_convert_char<_ECharT>::__char_type>> : public __can_convert_char<_ECharT> { using _Str = basic_string<_ECharT,_Traits,_Alloc> ; using _Base = __can_convert_char<_ECharT> ; _LIBCPP_HIDE_FROM_ABI _ECharT const*)",
    "insertText": "__range_begin(_Str const& __s)"
  },
  {
    "label": "__range_end()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI _ECharT const*)",
    "insertText": "__range_end(_Str const& __s)"
  },
  {
    "label": "__first_or_null()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI _ECharT)",
    "insertText": "__first_or_null(_Str const& __s)"
  },
  {
    "label": "__range_begin()",
    "kind": "Method",
    "detail": "Function (} : __s [ 0 ] ; } } ; template<class _Source,class _DS = decay<_Source>::type,class _UnqualPtrType = remove_const<remove_pointer<_DS>::type>::type,bool _IsCharPtr = is_pointer<_DS>::value&& __can_convert_char<_UnqualPtrType>::value> struct __is_pathable_char_array : false_type { } ; template<class _Source,class _ECharT,class _UPtr> struct __is_pathable_char_array<_Source,_ECharT*,_UPtr,true> : __can_convert_char<remove_const<_ECharT>::type> { using _Base = __can_convert_char<remove_const<_ECharT>::type> ; _LIBCPP_HIDE_FROM_ABI _ECharT const*)",
    "insertText": "__range_begin(const _ECharT* __b)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (using _Iter = const _ECharT* ; const _ECharT __sentinel = _ECharT { } ; _Iter __e = __b ;)",
    "insertText": "for(; *__e != __sentinel; ++__e)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} ; template<class _Tp> struct __is_pathable<_Tp,true,false,false> : __is_pathable_string<_Tp> { } ; template<class _Tp> struct __is_pathable<_Tp,false,true,false> : __is_pathable_char_array<_Tp> { } ; template<class _Tp> struct __is_pathable<_Tp,false,false,true> : __is_pathable_iter<_Tp> { } ; # if)",
    "insertText": "defined(_LIBCPP_WIN32API)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (typedef wchar_t __path_value ; # else typedef string __path_string ; typedef char __path_value ; # endif # if)",
    "insertText": "defined(_LIBCPP_WIN32API) _LIBCPP_FUNC_VIS size_t __wide_to_char(const wstring&, char*, size_t)"
  },
  {
    "label": "__char_to_wide()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_FUNC_VIS size_t)",
    "insertText": "__char_to_wide(const string&, wchar_t*, size_t)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif template<class _ECharT> struct _PathCVT ; # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_LOCALIZATION)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (typedef __narrow_to_utf8<)",
    "insertText": "sizeof(_ECharT)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_LIBCPP_WIN32API) typedef __widen_from_utf8<sizeof(wchar_t)"
  },
  {
    "label": "__append_range()",
    "kind": "Method",
    "detail": "Function (# endif _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "__append_range(__path_string& __dest, _ECharT const* __b, _ECharT const* __e)"
  },
  {
    "label": "_Narrower()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_Narrower()(back_inserter(__utf8), __b, __e)"
  },
  {
    "label": "_Widener()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_Widener()(back_inserter(__dest), __utf8.data(), __utf8.data() + __utf8.size())"
  },
  {
    "label": "_Narrower()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "_Narrower()(back_inserter(__dest), __b, __e)"
  },
  {
    "label": "__append_range()",
    "kind": "Method",
    "detail": "Function (# endif } template<class _Iter> _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "__append_range(__path_string& __dest, _Iter __b, _Iter __e)"
  },
  {
    "label": "__tmp()",
    "kind": "Method",
    "detail": "Function (basic_string<_ECharT>)",
    "insertText": "__tmp(__b, __e)"
  },
  {
    "label": "_Narrower()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_Narrower()(back_inserter(__utf8), __tmp.data(), __tmp.data() + __tmp.length())"
  },
  {
    "label": "_Narrower()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "_Narrower()(back_inserter(__dest), __tmp.data(), __tmp.data() + __tmp.length())"
  },
  {
    "label": "__append_range()",
    "kind": "Method",
    "detail": "Function (# endif } template<class _Iter> _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "__append_range(__path_string& __dest, _Iter __b, _NullSentinel)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const _ECharT __sentinel = _ECharT { } ;)",
    "insertText": "if(*__b == __sentinel)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (basic_string<_ECharT> __tmp ;)",
    "insertText": "for(; *__b != __sentinel; ++__b) __tmp.push_back(*__b)"
  },
  {
    "label": "__append_source()",
    "kind": "Method",
    "detail": "Function (# endif } template<class _Source> _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "__append_source(__path_string& __dest, _Source const& __s)"
  },
  {
    "label": "__append_range()",
    "kind": "Method",
    "detail": "Function (using _Traits = __is_pathable<_Source> ;)",
    "insertText": "__append_range(__dest, _Traits::__range_begin(__s), _Traits::__range_end(__s))"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (__dest .)",
    "insertText": "append(__b, __e)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const char __sentinel = char { } ;)",
    "insertText": "for(; *__b != __sentinel; ++__b) __dest.push_back(*__b)"
  },
  {
    "label": "__append_string()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "__append_string(__path_string& __dest, const basic_string<char> &__str)"
  },
  {
    "label": "__char_to_wide()",
    "kind": "Method",
    "detail": "Function (size_t __size =)",
    "insertText": "__char_to_wide(__str, nullptr, 0)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_t __pos = __dest .)",
    "insertText": "size()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (__dest .)",
    "insertText": "resize(__pos + __size)"
  },
  {
    "label": "__char_to_wide()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__char_to_wide(__str, const_cast<__path_value*>(__dest.data()) + __pos, __size)"
  },
  {
    "label": "__append_string()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__append_string(__dest, __tmp)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} } ; template<class _ECharT> struct _PathExport { typedef __narrow_to_utf8<)",
    "insertText": "sizeof(wchar_t)"
  },
  {
    "label": "__append()",
    "kind": "Method",
    "detail": "Function (template<class _Str> _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "__append(_Str& __dest, const __path_string& __src)"
  },
  {
    "label": "_Narrower()",
    "kind": "Method",
    "detail": "Function (string __utf8 ;)",
    "insertText": "_Narrower()(back_inserter(__utf8), __src.data(), __src.data() + __src.size())"
  },
  {
    "label": "__wide_to_char()",
    "kind": "Method",
    "detail": "Function (size_t __size =)",
    "insertText": "__wide_to_char(__src, nullptr, 0)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (__dest .)",
    "insertText": "resize(__size)"
  },
  {
    "label": "__wide_to_char()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__wide_to_char(__src, const_cast<char*>(__dest.data()) + __pos, __size)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (__dest .)",
    "insertText": "append(__src.begin(), __src.end())"
  },
  {
    "label": "_Narrower()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_Narrower()(back_inserter(__dest), __src.data(), __src.data() + __src.size())"
  },
  {
    "label": "path()",
    "kind": "Method",
    "detail": "Function (value_type preferred_separator = L ' \\ \\ ' ; # else typedef char value_type ; value_type preferred_separator = ' / ' ; # endif typedef basic_string<value_type> string_type ; typedef basic_string_view<value_type> __string_view ; enum _LIBCPP_ENUM_VIS format : unsigned char { auto_format,native_format,generic_format } ; _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "path()"
  },
  {
    "label": "path()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "path(const path& __p) : __pn_(__p.__pn_)"
  },
  {
    "label": "path()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "path(path&& __p) noexcept : __pn_(_VSTD::move(__p.__pn_))"
  },
  {
    "label": "path()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "path(string_type&& __s, format = format::auto_format) noexcept : __pn_(_VSTD::move(__s))"
  },
  {
    "label": "path()",
    "kind": "Method",
    "detail": "Function (} template<class _Source,class = _EnableIfPathable<_Source,void>> _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "path(const _Source& __src, format = format::auto_format)"
  },
  {
    "label": "__append_source()",
    "kind": "Method",
    "detail": "Function (_SourceCVT<_Source)",
    "insertText": "__append_source(__pn_, __src)"
  },
  {
    "label": "path()",
    "kind": "Method",
    "detail": "Function (} template<class _InputIt> _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "path(_InputIt __first, _InputIt __last, format = format::auto_format)"
  },
  {
    "label": "__append_range()",
    "kind": "Method",
    "detail": "Function (typedef iterator_traits<_InputIt>::value_type _ItVal ; _PathCVT<_ItVal)",
    "insertText": "__append_range(__pn_, __first, __last)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI path&)",
    "insertText": "operator(const path& __p)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (__pn_ = __p . __pn_ ; return* this ; } _LIBCPP_HIDE_FROM_ABI path&)",
    "insertText": "operator(path&& __p)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (__pn_ =)",
    "insertText": "move(__p.__pn_)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (__pn_ =)",
    "insertText": "move(__s)"
  },
  {
    "label": "assign()",
    "kind": "Method",
    "detail": "Function (} template<class _Source> _LIBCPP_HIDE_FROM_ABI _EnableIfPathable<_Source>)",
    "insertText": "assign(const _Source& __src)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (__pn_ .)",
    "insertText": "clear()"
  },
  {
    "label": "__root_name()",
    "kind": "Method",
    "detail": "Function (auto __p_root_name = __p .)",
    "insertText": "__root_name()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__pn_ = __p . __pn_ ; return* this ; })",
    "insertText": "if(__p.has_root_directory())"
  },
  {
    "label": "root_name()",
    "kind": "Method",
    "detail": "Function (path __root_name_str =)",
    "insertText": "root_name()"
  },
  {
    "label": "native()",
    "kind": "Method",
    "detail": "Function (__pn_ = __root_name_str .)",
    "insertText": "native()"
  },
  {
    "label": "__string_view()",
    "kind": "Method",
    "detail": "Function (__pn_ + =)",
    "insertText": "__string_view(__p.__pn_).substr(__p_root_name_size)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (} template<class _Source> _LIBCPP_HIDE_FROM_ABI _EnableIfPathable<_Source>)",
    "insertText": "append(const _Source& __src)"
  },
  {
    "label": "append()",
    "kind": "Method",
    "detail": "Function (} template<class _InputIt> _LIBCPP_HIDE_FROM_ABI path&)",
    "insertText": "append(_InputIt __first, _InputIt __last)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__pn_ = __p . __pn_ ; return* this ; })",
    "insertText": "if(has_filename())"
  },
  {
    "label": "__is_separator()",
    "kind": "Method",
    "detail": "Function (using _Traits = __is_pathable<_Source> ; using _CVT = _PathCVT<_SourceChar<_Source>> ; bool __source_is_absolute =)",
    "insertText": "__is_separator(_Traits::__first_or_null(__src))"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (typedef iterator_traits<_InputIt>::value_type _ItVal ;)",
    "insertText": "static_assert(__can_convert_char<_ItVal>::value, \"Must convertible\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using _CVT = _PathCVT<_ItVal> ;)",
    "insertText": "if(__first != __last && __is_separator(*__first)) __pn_.clear()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (__pn_ + = __x . __pn_ ; return* this ; } _LIBCPP_HIDE_FROM_ABI path&)",
    "insertText": "operator(const string_type& __x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (__pn_ + = __x ; return* this ; } _LIBCPP_HIDE_FROM_ABI path&)",
    "insertText": "operator(__string_view __x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (__pn_ + = __x ; return* this ; } _LIBCPP_HIDE_FROM_ABI path&)",
    "insertText": "operator(const value_type* __x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (__pn_ + = __x ; return* this ; } _LIBCPP_HIDE_FROM_ABI path&)",
    "insertText": "operator(value_type __x)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (__pn_ + = __x ; return* this ; } template<class _ECharT> _LIBCPP_HIDE_FROM_ABI enable_if<__can_convert_char<_ECharT>::value,path&>::type)",
    "insertText": "operator(_ECharT __x)"
  },
  {
    "label": "__append_source()",
    "kind": "Method",
    "detail": "Function (_PathCVT<_ECharT)",
    "insertText": "__append_source(__pn_, basic_string_view<_ECharT>(&__x, 1))"
  },
  {
    "label": "concat()",
    "kind": "Method",
    "detail": "Function (} template<class _Source> _LIBCPP_HIDE_FROM_ABI _EnableIfPathable<_Source>)",
    "insertText": "concat(const _Source& __x)"
  },
  {
    "label": "__append_source()",
    "kind": "Method",
    "detail": "Function (_SourceCVT<_Source)",
    "insertText": "__append_source(__pn_, __x)"
  },
  {
    "label": "make_preferred()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI path&)",
    "insertText": "make_preferred()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_LIBCPP_WIN32API) _VSTD::replace(__pn_.begin(), __pn_.end(), L'/', L'\\\\')"
  },
  {
    "label": "remove_filename()",
    "kind": "Method",
    "detail": "Function (# endif return* this ; } _LIBCPP_HIDE_FROM_ABI path&)",
    "insertText": "remove_filename()"
  },
  {
    "label": "__filename()",
    "kind": "Method",
    "detail": "Function (auto __fname =)",
    "insertText": "__filename()"
  },
  {
    "label": "replace_extension()",
    "kind": "Method",
    "detail": "Function (} path&)",
    "insertText": "replace_extension(const path& __replacement = path())"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "swap(path& __rhs)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (__pn_ .)",
    "insertText": "swap(__rhs.__pn_)"
  },
  {
    "label": "__reserve()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "__reserve(size_t __s)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (__pn_ .)",
    "insertText": "reserve(__s)"
  },
  {
    "label": "string_type()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI operator)",
    "insertText": "string_type()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (_VSTD::wstring __s ; __s .)",
    "insertText": "resize(__pn_.size())"
  },
  {
    "label": "replace_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replace_copy(__pn_.begin(), __pn_.end(), __s.begin(), '\\\\', '/')"
  },
  {
    "label": "__s()",
    "kind": "Method",
    "detail": "Function (using _Str = basic_string<_ECharT,_Traits,_Allocator> ; _Str)",
    "insertText": "__s(__a)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (__s .)",
    "insertText": "reserve(__pn_.size())"
  },
  {
    "label": "__append()",
    "kind": "Method",
    "detail": "Function (_PathExport<_ECharT)",
    "insertText": "__append(__s, __pn_)"
  },
  {
    "label": "u8string()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI __u8_string)",
    "insertText": "u8string()"
  },
  {
    "label": "_CVT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_CVT()(back_inserter(__s), __pn_.data(), __pn_.data() + __pn_.size())"
  },
  {
    "label": "u32string()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI _VSTD::u32string)",
    "insertText": "u32string()"
  },
  {
    "label": "generic_string()",
    "kind": "Method",
    "detail": "Function (} template<class _ECharT,class _Traits = char_traits<_ECharT>,class _Allocator = allocator<_ECharT>> _LIBCPP_HIDE_FROM_ABI basic_string<_ECharT,_Traits,_Allocator>)",
    "insertText": "generic_string(const _Allocator& __a = _Allocator())"
  },
  {
    "label": "_Allocator()",
    "kind": "Method",
    "detail": "Function (using _Str = basic_string<_ECharT,_Traits,_Allocator> ; _Str __s = string<_ECharT,_Traits,)",
    "insertText": "_Allocator(__a)"
  },
  {
    "label": "replace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replace(__s.begin(), __s.end(), static_cast<_ECharT>('\\\\'), static_cast<_ECharT>('/'))"
  },
  {
    "label": "generic_u16string()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI _VSTD::u16string)",
    "insertText": "generic_u16string()"
  },
  {
    "label": "generic_u32string()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI _VSTD::u32string)",
    "insertText": "generic_u32string()"
  },
  {
    "label": "generic_u8string()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI __u8_string)",
    "insertText": "generic_u8string()"
  },
  {
    "label": "replace()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "replace(__s.begin(), __s.end(), '\\\\', '/')"
  },
  {
    "label": "u16string()",
    "kind": "Method",
    "detail": "Function (} # endif _LIBCPP_HIDE_FROM_ABI _VSTD::u16string)",
    "insertText": "u16string()"
  },
  {
    "label": "generic_string()",
    "kind": "Method",
    "detail": "Function (} # endif _LIBCPP_HIDE_FROM_ABI _VSTD::string)",
    "insertText": "generic_string()"
  },
  {
    "label": "generic_wstring()",
    "kind": "Method",
    "detail": "Function (} # ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS _LIBCPP_HIDE_FROM_ABI _VSTD::wstring)",
    "insertText": "generic_wstring()"
  },
  {
    "label": "__compare()",
    "kind": "Method",
    "detail": "Function (} # endif # endif private : int)",
    "insertText": "__compare(__string_view)"
  },
  {
    "label": "__root_directory()",
    "kind": "Method",
    "detail": "Function (__string_view)",
    "insertText": "__root_directory()"
  },
  {
    "label": "__root_path_raw()",
    "kind": "Method",
    "detail": "Function (__string_view)",
    "insertText": "__root_path_raw()"
  },
  {
    "label": "__relative_path()",
    "kind": "Method",
    "detail": "Function (__string_view)",
    "insertText": "__relative_path()"
  },
  {
    "label": "__parent_path()",
    "kind": "Method",
    "detail": "Function (__string_view)",
    "insertText": "__parent_path()"
  },
  {
    "label": "__stem()",
    "kind": "Method",
    "detail": "Function (__string_view)",
    "insertText": "__stem()"
  },
  {
    "label": "__extension()",
    "kind": "Method",
    "detail": "Function (__string_view)",
    "insertText": "__extension()"
  },
  {
    "label": "compare()",
    "kind": "Method",
    "detail": "Function (public : _LIBCPP_HIDE_FROM_ABI int)",
    "insertText": "compare(const path& __p)"
  },
  {
    "label": "compare()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI int)",
    "insertText": "compare(const string_type& __s)"
  },
  {
    "label": "compare()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI int)",
    "insertText": "compare(__string_view __s)"
  },
  {
    "label": "compare()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI int)",
    "insertText": "compare(const value_type* __s)"
  },
  {
    "label": "root_directory()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI path)",
    "insertText": "root_directory()"
  },
  {
    "label": "root_path()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI path)",
    "insertText": "root_path()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_LIBCPP_WIN32API) return string_type(__root_path_raw())"
  },
  {
    "label": "root_name()",
    "kind": "Method",
    "detail": "Function (# else return)",
    "insertText": "root_name().append(string_type(__root_directory()))"
  },
  {
    "label": "relative_path()",
    "kind": "Method",
    "detail": "Function (# endif } _LIBCPP_HIDE_FROM_ABI path)",
    "insertText": "relative_path()"
  },
  {
    "label": "parent_path()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI path)",
    "insertText": "parent_path()"
  },
  {
    "label": "filename()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI path)",
    "insertText": "filename()"
  },
  {
    "label": "stem()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI path)",
    "insertText": "stem()"
  },
  {
    "label": "extension()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI path)",
    "insertText": "extension()"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "empty()"
  },
  {
    "label": "has_root_name()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "has_root_name()"
  },
  {
    "label": "has_root_directory()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "has_root_directory()"
  },
  {
    "label": "has_root_path()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "has_root_path()"
  },
  {
    "label": "has_relative_path()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "has_relative_path()"
  },
  {
    "label": "has_parent_path()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "has_parent_path()"
  },
  {
    "label": "has_filename()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "has_filename()"
  },
  {
    "label": "has_stem()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "has_stem()"
  },
  {
    "label": "has_extension()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "has_extension()"
  },
  {
    "label": "is_absolute()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "is_absolute()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_LIBCPP_WIN32API) __string_view __root_name_str = __root_name()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(__root_name_str.empty())"
  },
  {
    "label": "is_relative()",
    "kind": "Method",
    "detail": "Function (# endif } _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "is_relative()"
  },
  {
    "label": "lexically_normal()",
    "kind": "Method",
    "detail": "Function (} path)",
    "insertText": "lexically_normal()"
  },
  {
    "label": "lexically_relative()",
    "kind": "Method",
    "detail": "Function (path)",
    "insertText": "lexically_relative(const path& __base)"
  },
  {
    "label": "lexically_proximate()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI path)",
    "insertText": "lexically_proximate(const path& __base)"
  },
  {
    "label": "lexically_relative()",
    "kind": "Method",
    "detail": "Function (path __result = this ->)",
    "insertText": "lexically_relative(__base)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "end()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_LOCALIZATION) template <class _CharT, class _Traits> _LIBCPP_HIDE_FROM_ABI friend typename enable_if<is_same<_CharT, value_type>::value && is_same<_Traits, char_traits<value_type> >::value, basic_ostream<_CharT, _Traits>&>::type operator<<(basic_ostream<_CharT, _Traits>& __os, const path& __p)"
  },
  {
    "label": "__quoted()",
    "kind": "Method",
    "detail": "Function (__os<<)",
    "insertText": "__quoted(__p.native())"
  },
  {
    "label": "__quoted()",
    "kind": "Method",
    "detail": "Function (__os<<)",
    "insertText": "__quoted(__p.string<_CharT, _Traits>())"
  },
  {
    "label": "__quoted()",
    "kind": "Method",
    "detail": "Function (basic_string<_CharT,_Traits> __tmp ; __is>>)",
    "insertText": "__quoted(__tmp)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (__p = __tmp ; return __is ; } # endif _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "operator(const path& __lhs, const path& __rhs)"
  },
  {
    "label": "__result()",
    "kind": "Method",
    "detail": "Function (path)",
    "insertText": "__result(__lhs)"
  },
  {
    "label": "__assign_view()",
    "kind": "Method",
    "detail": "Function (__result / = __rhs ; return __result ; } private : _LIBCPP_HIDE_FROM_ABI path&)",
    "insertText": "__assign_view(__string_view const& __s)"
  },
  {
    "label": "string_type()",
    "kind": "Method",
    "detail": "Function (__pn_ =)",
    "insertText": "string_type(__s)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (__lhs .)",
    "insertText": "swap(__rhs)"
  },
  {
    "label": "hash_value()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_FUNC_VIS size_t)",
    "insertText": "hash_value(const path& __p)"
  }
]