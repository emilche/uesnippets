[
  {
    "label": "TRange",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TRange"
  },
  {
    "label": "FArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FArchive"
  },
  {
    "label": "Name",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Name"
  },
  {
    "label": "TIsBitwiseConstructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TIsBitwiseConstructible"
  },
  {
    "label": "TRange()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Containers / Array . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / DateTime . h \" # include \" Math / RangeBound . h \" # include \" Misc / FrameNumber . h \" # include \" Serialization / Archive . h \" template<ElementType> class TRange { public : typedef TRangeBound<ElementType> BoundsType ; typedef TCallTraits<ElementType>::ParamType ElementValueOrConstRef ;)",
    "insertText": "TRange()"
  },
  {
    "label": "TRange()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TRange(ElementValueOrConstRef A) : LowerBound(BoundsType::Inclusive(A)) , UpperBound(BoundsType::Inclusive(A))"
  },
  {
    "label": "TRange()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TRange(ElementValueOrConstRef A, ElementValueOrConstRef B) : LowerBound(BoundsType::Inclusive(A)) , UpperBound(BoundsType::Exclusive(B))"
  },
  {
    "label": "TRange()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TRange(const BoundsType& InLowerBound, const BoundsType& InUpperBound) : LowerBound(InLowerBound) , UpperBound(InUpperBound)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "operator(const TRange& Other)"
  },
  {
    "label": "Adjoins()",
    "kind": "Method",
    "detail": "Function (} public : bool)",
    "insertText": "Adjoins(const TRange& Other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!Other.UpperBound.IsOpen() && !LowerBound.IsOpen() && Other.UpperBound.GetValue() == LowerBound.GetValue())"
  },
  {
    "label": "Conjoins()",
    "kind": "Method",
    "detail": "Function (} return false ; } bool)",
    "insertText": "Conjoins(const TRange& X, const TRange& Y)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(ElementValueOrConstRef Element)"
  },
  {
    "label": "Contains()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contains(const TRange& Other)"
  },
  {
    "label": "Contiguous()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Contiguous(const TRange& Other)"
  },
  {
    "label": "GetLowerBound()",
    "kind": "Method",
    "detail": "Function (} BoundsType)",
    "insertText": "GetLowerBound()"
  },
  {
    "label": "SetLowerBoundValue()",
    "kind": "Method",
    "detail": "Function (LowerBound = NewLowerBound ; } void)",
    "insertText": "SetLowerBoundValue(ElementValueOrConstRef NewLowerBoundValue)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (LowerBound .)",
    "insertText": "SetValue(NewLowerBoundValue)"
  },
  {
    "label": "GetLowerBoundValue()",
    "kind": "Method",
    "detail": "Function (} ElementValueOrConstRef)",
    "insertText": "GetLowerBoundValue()"
  },
  {
    "label": "GetUpperBound()",
    "kind": "Method",
    "detail": "Function (} BoundsType)",
    "insertText": "GetUpperBound()"
  },
  {
    "label": "SetUpperBoundValue()",
    "kind": "Method",
    "detail": "Function (UpperBound = NewUpperBound ; } void)",
    "insertText": "SetUpperBoundValue(ElementValueOrConstRef NewUpperBoundValue)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (UpperBound .)",
    "insertText": "SetValue(NewUpperBoundValue)"
  },
  {
    "label": "GetUpperBoundValue()",
    "kind": "Method",
    "detail": "Function (} ElementValueOrConstRef)",
    "insertText": "GetUpperBoundValue()"
  },
  {
    "label": "HasLowerBound()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasLowerBound()"
  },
  {
    "label": "HasUpperBound()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasUpperBound()"
  },
  {
    "label": "IsDegenerate()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsDegenerate()"
  },
  {
    "label": "IsEmpty()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsEmpty()"
  },
  {
    "label": "Overlaps()",
    "kind": "Method",
    "detail": "Function (} return false ; } bool)",
    "insertText": "Overlaps(const TRange& Other)"
  },
  {
    "label": "IsOpen()",
    "kind": "Method",
    "detail": "Function (bool bLowerOpen = LowerBound .)",
    "insertText": "IsOpen() || Other.UpperBound.IsOpen()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bUpperValid = true ; bool bLowerValid = true ;)",
    "insertText": "if(!bUpperOpen)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (bool bUpperGreaterThan = UpperBound .)",
    "insertText": "GetValue() > Other.LowerBound.GetValue()"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (bool bUpperGreaterThanOrEqualTo = UpperBound .)",
    "insertText": "GetValue() >= Other.LowerBound.GetValue()"
  },
  {
    "label": "IsInclusive()",
    "kind": "Method",
    "detail": "Function (bool bUpperBothInclusive = UpperBound .)",
    "insertText": "IsInclusive() && Other.LowerBound.IsInclusive()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bUpperValid = bUpperBothInclusive ? bUpperGreaterThanOrEqualTo : bUpperGreaterThan ; })",
    "insertText": "if(!bLowerOpen)"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (bool bLowerLessThan = LowerBound .)",
    "insertText": "GetValue() < Other.UpperBound.GetValue()"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (bool bLowerLessThanOrEqualTo = LowerBound .)",
    "insertText": "GetValue() <= Other.UpperBound.GetValue()"
  },
  {
    "label": "IsInclusive()",
    "kind": "Method",
    "detail": "Function (bool bLowerBothInclusive = LowerBound .)",
    "insertText": "IsInclusive() && Other.UpperBound.IsInclusive()"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (bLowerValid = bLowerBothInclusive ? bLowerLessThanOrEqualTo : bLowerLessThan ; } return bUpperValid&& bLowerValid ; } template<DifferenceType> DifferenceType)",
    "insertText": "Size()"
  },
  {
    "label": "Split()",
    "kind": "Method",
    "detail": "Function (} TArray<TRange>)",
    "insertText": "Split(ElementValueOrConstRef Element)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<TRange> Result ;)",
    "insertText": "if(Contains(Element))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Result .)",
    "insertText": "Add(TRange(LowerBound, BoundsType::Exclusive(Element)))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Result .)",
    "insertText": "Add(TRange(BoundsType::Inclusive(Element), UpperBound))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { Result .)",
    "insertText": "Add(*this)"
  },
  {
    "label": "Difference()",
    "kind": "Method",
    "detail": "Function (} return Result ; } public : TArray<TRange>)",
    "insertText": "Difference(const TRange& X, const TRange& Y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<TRange> Result ;)",
    "insertText": "if(X.Overlaps(Y))"
  },
  {
    "label": "TRange()",
    "kind": "Method",
    "detail": "Function (TRange LowerRange =)",
    "insertText": "TRange(X.LowerBound, BoundsType::FlipInclusion(Y.LowerBound))"
  },
  {
    "label": "TRange()",
    "kind": "Method",
    "detail": "Function (TRange UpperRange =)",
    "insertText": "TRange(BoundsType::FlipInclusion(Y.UpperBound), X.UpperBound)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Result .)",
    "insertText": "Add(LowerRange)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!UpperRange.IsEmpty())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (Result .)",
    "insertText": "Add(UpperRange)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} } else { Result .)",
    "insertText": "Add(X)"
  },
  {
    "label": "Hull()",
    "kind": "Method",
    "detail": "Function (} return Result ; } TRange)",
    "insertText": "Hull(const TRange& X, const TRange& Y)"
  },
  {
    "label": "Hull()",
    "kind": "Method",
    "detail": "Function (} TRange)",
    "insertText": "Hull(const TArray<TRange>& Ranges)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} TRange Bounds = Ranges [ 0 ] ;)",
    "insertText": "for(int32 i = 1; i < Ranges.Num(); ++i)"
  },
  {
    "label": "Hull()",
    "kind": "Method",
    "detail": "Function (Bounds =)",
    "insertText": "Hull(Bounds, Ranges[i])"
  },
  {
    "label": "Intersection()",
    "kind": "Method",
    "detail": "Function (} return Bounds ; } TRange)",
    "insertText": "Intersection(const TRange& X, const TRange& Y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(Y.IsEmpty())"
  },
  {
    "label": "TRange()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "TRange(BoundsType::MaxLower(X.LowerBound, Y.LowerBound), BoundsType::MinUpper(X.UpperBound, Y.UpperBound))"
  },
  {
    "label": "Intersection()",
    "kind": "Method",
    "detail": "Function (} TRange)",
    "insertText": "Intersection(const TArray<TRange>& Ranges)"
  },
  {
    "label": "Intersection()",
    "kind": "Method",
    "detail": "Function (Bounds =)",
    "insertText": "Intersection(Bounds, Ranges[i])"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (} return Bounds ; } TArray<TRange>)",
    "insertText": "Union(const TRange& X, const TRange& Y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TArray<TRange> OutRanges ;)",
    "insertText": "if(X.Contiguous(Y))"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutRanges .)",
    "insertText": "Add(TRange(BoundsType::MinLower(X.LowerBound, Y.LowerBound), BoundsType::MaxUpper(X.UpperBound, Y.UpperBound)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(!X.IsEmpty())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!Y.IsEmpty())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (OutRanges .)",
    "insertText": "Add(Y)"
  },
  {
    "label": "All()",
    "kind": "Method",
    "detail": "Function (} } return OutRanges ; } public : TRange)",
    "insertText": "All()"
  },
  {
    "label": "AtLeast()",
    "kind": "Method",
    "detail": "Function (} TRange)",
    "insertText": "AtLeast(ElementValueOrConstRef Value)"
  },
  {
    "label": "AtMost()",
    "kind": "Method",
    "detail": "Function (} TRange)",
    "insertText": "AtMost(ElementValueOrConstRef Value)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} TRange)",
    "insertText": "Empty()"
  },
  {
    "label": "Exclusive()",
    "kind": "Method",
    "detail": "Function (} TRange)",
    "insertText": "Exclusive(ElementValueOrConstRef Min, ElementValueOrConstRef Max)"
  },
  {
    "label": "GreaterThan()",
    "kind": "Method",
    "detail": "Function (} TRange)",
    "insertText": "GreaterThan(ElementValueOrConstRef Value)"
  },
  {
    "label": "Inclusive()",
    "kind": "Method",
    "detail": "Function (} TRange)",
    "insertText": "Inclusive(ElementValueOrConstRef Min, ElementValueOrConstRef Max)"
  },
  {
    "label": "LessThan()",
    "kind": "Method",
    "detail": "Function (} TRange)",
    "insertText": "LessThan(ElementValueOrConstRef Value)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} public : class FArchive&)",
    "insertText": "operator(class FArchive& Ar, TRange& Range)"
  },
  {
    "label": "DEFINE_RANGE_WRAPPER_STRUCT()",
    "kind": "Method",
    "detail": "Function (} private : BoundsType LowerBound ; BoundsType UpperBound ; } ; # define)",
    "insertText": "DEFINE_RANGE_WRAPPER_STRUCT(Name, ElementType)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ private : \\ typedef TRange<ElementType> Super ; \\ \\ public : \\)",
    "insertText": "Name() \\ : Super()"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\)",
    "insertText": "Name(const Super& Rhs) \\ : Super(Rhs)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\)",
    "insertText": "Name(ElementValueOrConstRef A) \\ : Super(A)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\)",
    "insertText": "Name(ElementValueOrConstRef A, ElementValueOrConstRef B) \\ : Super(A, B)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\)",
    "insertText": "Name(const TRangeBound<ElementType>& InLowerBound, const TRangeBound<ElementType>& InUpperBound) \\ : Super(InLowerBound, InUpperBound)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ return TArray<)",
    "insertText": "Name(Super::Split(Element))"
  },
  {
    "label": "Difference()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\ TArray<Name>)",
    "insertText": "Difference(const Name& X, const Name& Y)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ return TArray<)",
    "insertText": "Name(Super::Difference(X, Y))"
  },
  {
    "label": "Hull()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\ Name)",
    "insertText": "Hull(const Name& X, const Name& Y)"
  },
  {
    "label": "Hull()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "Hull(X, Y)"
  },
  {
    "label": "Hull()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\ Name)",
    "insertText": "Hull(const TArray<Name>& Ranges)"
  },
  {
    "label": "Hull()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "Hull(reinterpret_cast<const TArray<Super>&>(Ranges))"
  },
  {
    "label": "Intersection()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\ Name)",
    "insertText": "Intersection(const Name& X, const Name& Y)"
  },
  {
    "label": "Intersection()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "Intersection(X, Y)"
  },
  {
    "label": "Intersection()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\ Name)",
    "insertText": "Intersection(const TArray<Name>& Ranges)"
  },
  {
    "label": "Intersection()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "Intersection(reinterpret_cast<const TArray<Super>&>(Ranges))"
  },
  {
    "label": "Union()",
    "kind": "Method",
    "detail": "Function (\\ } \\ \\ TArray<Name>)",
    "insertText": "Union(const Name& X, const Name& Y)"
  },
  {
    "label": "Name()",
    "kind": "Method",
    "detail": "Function (\\ return TArray<)",
    "insertText": "Name(Super::Union(X, Y))"
  },
  {
    "label": "AtLeast()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "AtLeast(Value)"
  },
  {
    "label": "AtMost()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "AtMost(Value)"
  },
  {
    "label": "GreaterThan()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "GreaterThan(Value)"
  },
  {
    "label": "LessThan()",
    "kind": "Method",
    "detail": "Function (\\ return)",
    "insertText": "LessThan(Value)"
  }
]