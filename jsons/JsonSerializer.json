[
  {
    "label": "Error",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Error"
  },
  {
    "label": "FJsonSerializer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FJsonSerializer"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "CharType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CharType"
  },
  {
    "label": "PrintPolicy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PrintPolicy"
  },
  {
    "label": "StackState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "StackState"
  },
  {
    "label": "FElement",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FElement"
  },
  {
    "label": "Deserialize()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Dom / JsonValue . h \" # include \" Dom / JsonObject . h \" # include \" Serialization / JsonReader . h \" # include \" Serialization / JsonTypes . h \" # include \" Serialization / JsonWriter . h \" class Error ; class FJsonSerializer { public : enum class EFlags { None = 0,StoreNumbersAsStrings = 1,} ; template<class CharType> bool)",
    "insertText": "Deserialize(const TSharedRef<TJsonReader<CharType>>& Reader, TArray<TSharedPtr<FJsonValue>>& OutArray, EFlags InOptions = EFlags::None)"
  },
  {
    "label": "Deserialize()",
    "kind": "Method",
    "detail": "Function (} template<class CharType> bool)",
    "insertText": "Deserialize(TJsonReader<CharType>& Reader, TArray<TSharedPtr<FJsonValue>>& OutArray, EFlags InOptions = EFlags::None)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (StackState State ;)",
    "insertText": "if(!Deserialize(Reader, State, InOptions))"
  },
  {
    "label": "Deserialize()",
    "kind": "Method",
    "detail": "Function (} template<class CharType> bool)",
    "insertText": "Deserialize(TJsonReader<CharType>& Reader, TSharedPtr<FJsonObject>& OutObject, EFlags InOptions = EFlags::None)"
  },
  {
    "label": "Deserialize()",
    "kind": "Method",
    "detail": "Function (} template<class CharType> bool)",
    "insertText": "Deserialize(TJsonReader<CharType>& Reader, TSharedPtr<FJsonValue>& OutValue, EFlags InOptions = EFlags::None)"
  },
  {
    "label": "FJsonValueArray()",
    "kind": "Method",
    "detail": "Function (break ; case EJson::Array : OutValue = MakeShared<)",
    "insertText": "FJsonValueArray(State.Array)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (break ; default : return false ; } return true ; } template<class CharType,class PrintPolicy> bool)",
    "insertText": "Serialize(const TArray<TSharedPtr<FJsonValue>>& Array, const TSharedRef<TJsonWriter<CharType, PrintPolicy>>& Writer, bool bCloseWriter = true)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} template<class CharType,class PrintPolicy> bool)",
    "insertText": "Serialize(const TArray<TSharedPtr<FJsonValue>>& Array, TJsonWriter<CharType, PrintPolicy>& Writer, bool bCloseWriter = true)"
  },
  {
    "label": "FElement()",
    "kind": "Method",
    "detail": "Function (const TSharedRef<FElement> StartingElement = MakeShared<)",
    "insertText": "FElement(Array)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} template<class CharType,class PrintPolicy> bool)",
    "insertText": "Serialize(const TSharedRef<FJsonObject>& Object, const TSharedRef<TJsonWriter<CharType, PrintPolicy>>& Writer, bool bCloseWriter = true)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} template<class CharType,class PrintPolicy> bool)",
    "insertText": "Serialize(const TSharedRef<FJsonObject>& Object, TJsonWriter<CharType, PrintPolicy>& Writer, bool bCloseWriter = true)"
  },
  {
    "label": "FElement()",
    "kind": "Method",
    "detail": "Function (const TSharedRef<FElement> StartingElement = MakeShared<)",
    "insertText": "FElement(Object)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} template<class CharType,class PrintPolicy> bool)",
    "insertText": "Serialize(const TSharedPtr<FJsonValue>& Value, const FString& Identifier, const TSharedRef<TJsonWriter<CharType, PrintPolicy>>& Writer, bool bCloseWriter = true)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (} template<class CharType,class PrintPolicy> bool)",
    "insertText": "Serialize(const TSharedPtr<FJsonValue>& Value, const FString& Identifier, TJsonWriter<CharType, PrintPolicy>& Writer, bool bCloseWriter = true)"
  },
  {
    "label": "FElement()",
    "kind": "Method",
    "detail": "Function (const TSharedRef<FElement> StartingElement = MakeShared<)",
    "insertText": "FElement(Identifier, Value)"
  },
  {
    "label": "FElement()",
    "kind": "Method",
    "detail": "Function (} private : struct StackState { EJson Type ; FString Identifier ; TArray<TSharedPtr<FJsonValue>> Array ; TSharedPtr<FJsonObject> Object ; } ; struct FElement {)",
    "insertText": "FElement(const TSharedPtr<FJsonValue>& InValue ) : Identifier() , Value(InValue)"
  },
  {
    "label": "FElement()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FElement(const TSharedRef<FJsonObject>& Object ) : Identifier() , Value(MakeShared<FJsonValueObject>(Object))"
  },
  {
    "label": "FElement()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FElement(const TArray<TSharedPtr<FJsonValue>>& Array ) : Identifier() , Value(MakeShared<FJsonValueArray>(Array))"
  },
  {
    "label": "FElement()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FElement(const FString& InIdentifier, const TSharedPtr< FJsonValue >& InValue ) : Identifier( InIdentifier ) , Value( InValue ) , bIsKeyValuePair( true)"
  },
  {
    "label": "Deserialize()",
    "kind": "Method",
    "detail": "Function (} FString Identifier ; TSharedPtr<FJsonValue> Value ; bool bHasBeenProcessed = false ; bool bIsKeyValuePair = false ; } ; private : template<class CharType> bool)",
    "insertText": "Deserialize(TJsonReader<CharType>& Reader, StackState& OutStackState, EFlags InOptions)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (TArray<TSharedRef<StackState>> ScopeStack ; TSharedPtr<StackState> CurrentState ; TSharedPtr<FJsonValue> NewValue ; EJsonNotation Notation ;)",
    "insertText": "while(Reader.ReadNext(Notation))"
  },
  {
    "label": "GetIdentifier()",
    "kind": "Method",
    "detail": "Function (FString Identifier = Reader .)",
    "insertText": "GetIdentifier()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (NewValue .)",
    "insertText": "Reset()"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (ScopeStack .)",
    "insertText": "Push(CurrentState.ToSharedRef())"
  },
  {
    "label": "StackState()",
    "kind": "Method",
    "detail": "Function (} CurrentState = MakeShared<)",
    "insertText": "StackState()"
  },
  {
    "label": "FJsonObject()",
    "kind": "Method",
    "detail": "Function (CurrentState -> Type = EJson::Object ; CurrentState -> Identifier = Identifier ; CurrentState -> Object = MakeShared<)",
    "insertText": "FJsonObject()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} break ; case EJsonNotation::ObjectEnd : {)",
    "insertText": "if(ScopeStack.Num() > 0)"
  },
  {
    "label": "FJsonValueObject()",
    "kind": "Method",
    "detail": "Function (Identifier = CurrentState -> Identifier ; NewValue = MakeShared<)",
    "insertText": "FJsonValueObject(CurrentState->Object)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (CurrentState = ScopeStack .)",
    "insertText": "Pop()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } break ; case EJsonNotation::ArrayStart : {)",
    "insertText": "if(CurrentState.IsValid())"
  },
  {
    "label": "FJsonValueArray()",
    "kind": "Method",
    "detail": "Function (Identifier = CurrentState -> Identifier ; NewValue = MakeShared<)",
    "insertText": "FJsonValueArray(CurrentState->Array)"
  },
  {
    "label": "FJsonValueBoolean()",
    "kind": "Method",
    "detail": "Function (} } break ; case EJsonNotation::Boolean : NewValue = MakeShared<)",
    "insertText": "FJsonValueBoolean(Reader.GetValueAsBoolean())"
  },
  {
    "label": "FJsonValueString()",
    "kind": "Method",
    "detail": "Function (break ; case EJsonNotation::String : NewValue = MakeShared<)",
    "insertText": "FJsonValueString(Reader.GetValueAsString())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case EJsonNotation::Number :)",
    "insertText": "if(EnumHasAnyFlags(InOptions, EFlags::StoreNumbersAsStrings))"
  },
  {
    "label": "FJsonValueNumberString()",
    "kind": "Method",
    "detail": "Function (NewValue = MakeShared<)",
    "insertText": "FJsonValueNumberString(Reader.GetValueAsNumberString())"
  },
  {
    "label": "FJsonValueNumber()",
    "kind": "Method",
    "detail": "Function (} else { NewValue = MakeShared<)",
    "insertText": "FJsonValueNumber(Reader.GetValueAsNumber())"
  },
  {
    "label": "FJsonValueNull()",
    "kind": "Method",
    "detail": "Function (} break ; case EJsonNotation::Null : NewValue = MakeShared<)",
    "insertText": "FJsonValueNull()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case EJsonNotation::Error : return false ; break ; })",
    "insertText": "if(NewValue.IsValid() && CurrentState.IsValid())"
  },
  {
    "label": "SetField()",
    "kind": "Method",
    "detail": "Function (CurrentState -> Object ->)",
    "insertText": "SetField(Identifier, NewValue)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (} else { CurrentState -> Array .)",
    "insertText": "Add(NewValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "if(!CurrentState.IsValid() || !Reader.GetErrorMessage().IsEmpty())"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (TArray<TSharedRef<FElement>> ElementStack ; ElementStack .)",
    "insertText": "Push(StartingElement)"
  },
  {
    "label": "bIsKeyValuePair()",
    "kind": "Method",
    "detail": "Function (const bool bWriteValueOnly = ! Element ->)",
    "insertText": "bIsKeyValuePair(Element->Identifier.IsEmpty() && Writer.GetCurrentElementType() != EJson::Object)"
  },
  {
    "label": "WriteRawJSONValue()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteRawJSONValue(Element->Value->AsString())"
  },
  {
    "label": "WriteValue()",
    "kind": "Method",
    "detail": "Function (} else { Writer .)",
    "insertText": "WriteValue(Element->Value->AsNumber())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(Element->Value->PreferStringRepresentation())"
  },
  {
    "label": "WriteRawJSONValue()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteRawJSONValue(Element->Identifier, Element->Value->AsString())"
  },
  {
    "label": "WriteValue()",
    "kind": "Method",
    "detail": "Function (} else { Writer .)",
    "insertText": "WriteValue(Element->Identifier, Element->Value->AsNumber())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } break ; case EJson::Boolean : {)",
    "insertText": "if(bWriteValueOnly)"
  },
  {
    "label": "WriteValue()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteValue(Element->Value->AsBool())"
  },
  {
    "label": "WriteValue()",
    "kind": "Method",
    "detail": "Function (} else { Writer .)",
    "insertText": "WriteValue(Element->Identifier, Element->Value->AsBool())"
  },
  {
    "label": "WriteValue()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteValue(Element->Value->AsString())"
  },
  {
    "label": "WriteValue()",
    "kind": "Method",
    "detail": "Function (} else { Writer .)",
    "insertText": "WriteValue(Element->Identifier, Element->Value->AsString())"
  },
  {
    "label": "WriteNull()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteNull()"
  },
  {
    "label": "WriteNull()",
    "kind": "Method",
    "detail": "Function (} else { Writer .)",
    "insertText": "WriteNull(Element->Identifier)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } break ; case EJson::Array : {)",
    "insertText": "if(Element->bHasBeenProcessed)"
  },
  {
    "label": "WriteArrayEnd()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteArrayEnd()"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (} else { Element -> bHasBeenProcessed = true ; ElementStack .)",
    "insertText": "Push(Element)"
  },
  {
    "label": "WriteArrayStart()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteArrayStart()"
  },
  {
    "label": "WriteArrayStart()",
    "kind": "Method",
    "detail": "Function (} else { Writer .)",
    "insertText": "WriteArrayStart(Element->Identifier)"
  },
  {
    "label": "AsArray()",
    "kind": "Method",
    "detail": "Function (} TArray<TSharedPtr<FJsonValue>> Values = Element -> Value ->)",
    "insertText": "AsArray()"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (ElementStack .)",
    "insertText": "Push(MakeShared<FElement>(Values[Index]))"
  },
  {
    "label": "WriteObjectEnd()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteObjectEnd()"
  },
  {
    "label": "WriteObjectStart()",
    "kind": "Method",
    "detail": "Function (Writer .)",
    "insertText": "WriteObjectStart()"
  },
  {
    "label": "WriteObjectStart()",
    "kind": "Method",
    "detail": "Function (} else { Writer .)",
    "insertText": "WriteObjectStart(Element->Identifier)"
  },
  {
    "label": "AsObject()",
    "kind": "Method",
    "detail": "Function (} TArray<FString> Keys ; TArray<TSharedPtr<FJsonValue>> Values ; TSharedPtr<FJsonObject> ElementObject = Element -> Value ->)",
    "insertText": "AsObject()"
  },
  {
    "label": "GenerateKeyArray()",
    "kind": "Method",
    "detail": "Function (ElementObject -> Values .)",
    "insertText": "GenerateKeyArray(Keys)"
  },
  {
    "label": "GenerateValueArray()",
    "kind": "Method",
    "detail": "Function (ElementObject -> Values .)",
    "insertText": "GenerateValueArray(Values)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (ElementStack .)",
    "insertText": "Push(MakeShared<FElement>(Keys[Index], Values[Index]))"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (} } } break ; default :)",
    "insertText": "UE_LOG(LogJson, Fatal,TEXT(\"Could not print Json Value, unrecognized type.\"))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(bCloseWriter)"
  }
]