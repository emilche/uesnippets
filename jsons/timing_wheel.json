[
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "TimingWheel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TimingWheel"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_TASK_SEQUENCE_MANAGER_TIMING_WHEEL_H_ # define BASE_TASK_SEQUENCE_MANAGER_TIMING_WHEEL_H_ # include<algorithm> # include<array> # include<limits> # include<memory> # include<vector> # include \" base / notreached . h \" # include \" base / time / time . h \" namespace base::sequence_manager::internal { class BASE_EXPORT TimingWheelHandle { public : enum : size_t { kInvalidIndex = std::numeric_limits<size_t)",
    "insertText": "max()"
  },
  {
    "label": "TimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TimingWheelHandle()"
  },
  {
    "label": "TimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TimingWheelHandle(const TimingWheelHandle& other)"
  },
  {
    "label": "TimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TimingWheelHandle(TimingWheelHandle&& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TimingWheelHandle&)",
    "insertText": "operator(const TimingWheelHandle& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TimingWheelHandle&)",
    "insertText": "operator(TimingWheelHandle&& other)"
  },
  {
    "label": "Invalid()",
    "kind": "Method",
    "detail": "Function (TimingWheelHandle)",
    "insertText": "Invalid()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "bucket_index()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "bucket_index()"
  },
  {
    "label": "element_index()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "element_index()"
  },
  {
    "label": "TimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (private : template<T,size_t WheelSize,TimingWheelHandleAccessor,GetDelayedRunTime> class TimingWheel ;)",
    "insertText": "TimingWheelHandle(size_t bucket_index, size_t element_index)"
  },
  {
    "label": "TimingWheel()",
    "kind": "Method",
    "detail": "Function (size_t bucket_index_ = kInvalidIndex ; size_t element_index_ = kInvalidIndex ; } ; template<T,size_t WheelSize,TimingWheelHandleAccessor,GetDelayedRunTime> class TimingWheel { public :)",
    "insertText": "TimingWheel(TimeDelta time_delta_per_bucket, const GetDelayedRunTime& get_delayed_run_time = GetDelayedRunTime()) : time_delta_per_bucket_(time_delta_per_bucket), last_updated_bucket_index_(0), time_passed_(Microseconds(0)), get_delayed_run_time_(get_delayed_run_time)"
  },
  {
    "label": "TimingWheel()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TimingWheel(TimingWheel&&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TimingWheel&)",
    "insertText": "operator(TimingWheel&&)"
  },
  {
    "label": "TimingWheel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TimingWheel(const TimingWheel&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TimingWheel&)",
    "insertText": "operator(const TimingWheel&)"
  },
  {
    "label": "TimingWheel()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "TimingWheel()"
  },
  {
    "label": "Insert()",
    "kind": "Method",
    "detail": "Function (std::vector<T>::const_iterator)",
    "insertText": "Insert(T element, const TimeDelta delay)"
  },
  {
    "label": "DCHECK_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_GE(delay, time_delta_per_bucket_)"
  },
  {
    "label": "DCHECK_LT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK_LT(delay, time_delta_per_bucket_ * WheelSize)"
  },
  {
    "label": "CalculateBucketIndex()",
    "kind": "Method",
    "detail": "Function (const size_t bucket_index =)",
    "insertText": "CalculateBucketIndex(delay)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (auto& bucket = buckets_ [ bucket_index ] ; bucket .)",
    "insertText": "push_back(std::move(element))"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (const size_t element_index = bucket .)",
    "insertText": "size()"
  },
  {
    "label": "SetTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (timing_wheel_handle_accessor .)",
    "insertText": "SetTimingWheelHandle(&buckets_[bucket_index][element_index], TimingWheelHandle(bucket_index, element_index))"
  },
  {
    "label": "cend()",
    "kind": "Method",
    "detail": "Function (total_elements_ + = 1 ; return bucket .)",
    "insertText": "cend()"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Remove(TimingWheelHandle handle)"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(handle.IsValid())"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(IsBounded(bucket_index, element_index))"
  },
  {
    "label": "SetTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (timing_wheel_handle_accessor .)",
    "insertText": "SetTimingWheelHandle(&bucket[last_index_of_bucket], TimingWheelHandle(bucket_index, element_index))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(bucket[element_index], bucket[last_index_of_bucket])"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (} bucket .)",
    "insertText": "pop_back()"
  },
  {
    "label": "AdvanceTimeAndRemoveExpiredElements()",
    "kind": "Method",
    "detail": "Function (total_elements_ - = 1 ; } void)",
    "insertText": "AdvanceTimeAndRemoveExpiredElements(const TimeDelta time_delta, std::vector<T>& expired_elements)"
  },
  {
    "label": "nb_buckets_passed()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "nb_buckets_passed(time_passed_ + time_delta)"
  },
  {
    "label": "new_bucket_index()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "new_bucket_index(last_updated_bucket_index_ + nb_buckets_passed)"
  },
  {
    "label": "new_time_passed()",
    "kind": "Method",
    "detail": "Function (const TimeDelta)",
    "insertText": "new_time_passed(time_passed_ + time_delta)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (const size_t nb_buckets_to_traverse =)",
    "insertText": "min(nb_buckets_passed, WheelSize)"
  },
  {
    "label": "last_updated_bucket_index_()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "last_updated_bucket_index_(last_updated_bucket_index_ + 1)"
  },
  {
    "label": "ExtractElementsFromBucket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ExtractElementsFromBucket(last_updated_bucket_index_, expired_elements)"
  },
  {
    "label": "Top()",
    "kind": "Method",
    "detail": "Function (} last_updated_bucket_index_ = new_bucket_index ; time_passed_ = new_time_passed ; } std::vector<T>::const_reference)",
    "insertText": "Top()"
  },
  {
    "label": "DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DCHECK(total_elements_ != 0)"
  },
  {
    "label": "bucket_index()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "bucket_index(i + last_updated_bucket_index_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (auto& bucket = buckets_ [ bucket_index ] ;)",
    "insertText": "if(bucket.size() == 0)"
  },
  {
    "label": "min_element()",
    "kind": "Method",
    "detail": "Function (continue ; } auto it =)",
    "insertText": "min_element(bucket.begin(), bucket.end(), [this](const T& a, const T& b) { return get_delayed_run_time_(a) > get_delayed_run_time_(b); })"
  },
  {
    "label": "time_delta_per_bucket()",
    "kind": "Method",
    "detail": "Function (} TimeDelta)",
    "insertText": "time_delta_per_bucket()"
  },
  {
    "label": "CalculateBucketIndex()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "CalculateBucketIndex(const TimeDelta delay)"
  },
  {
    "label": "nb_buckets_passed()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "nb_buckets_passed(delay + time_passed_)"
  },
  {
    "label": "ExtractElementsFromBucket()",
    "kind": "Method",
    "detail": "Function (const size_t bucket_index = last_updated_bucket_index_ + nb_buckets_passed ; return bucket_index % WheelSize ; } void)",
    "insertText": "ExtractElementsFromBucket(const size_t bucket_index, std::vector<T>& expired_elements)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::vector<T>& bucket = buckets_ [ bucket_index ] ; expired_elements .)",
    "insertText": "reserve(expired_elements.size() + bucket.size())"
  },
  {
    "label": "ClearTimingWheelHandle()",
    "kind": "Method",
    "detail": "Function (timing_wheel_handle_accessor .)",
    "insertText": "ClearTimingWheelHandle(&element)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (bucket .)",
    "insertText": "clear()"
  }
]