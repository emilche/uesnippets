[
  {
    "label": "GEBPPacketSizeType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "GEBPPacketSizeType"
  },
  {
    "label": "gebp_traits",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "gebp_traits"
  },
  {
    "label": "CacheSizes",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CacheSizes"
  },
  {
    "label": "RhsPanelHelper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "RhsPanelHelper"
  },
  {
    "label": "QuadPacket",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "QuadPacket"
  },
  {
    "label": "packet_conditional",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "packet_conditional"
  },
  {
    "label": "DoublePacket",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DoublePacket"
  },
  {
    "label": "unpacket_traits",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "unpacket_traits"
  },
  {
    "label": "gebp_kernel",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gebp_kernel"
  },
  {
    "label": "last_row_process_16_packets",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "last_row_process_16_packets"
  },
  {
    "label": "lhs_process_one_packet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lhs_process_one_packet"
  },
  {
    "label": "lhs_process_fraction_of_packet",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "lhs_process_fraction_of_packet"
  },
  {
    "label": "gemm_pack_lhs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gemm_pack_lhs"
  },
  {
    "label": "gemm_pack_rhs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "gemm_pack_rhs"
  },
  {
    "label": "manage_caching_sizes_helper()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_GENERAL_BLOCK_PANEL_H # define EIGEN_GENERAL_BLOCK_PANEL_H namespace Eigen { namespace internal { enum GEBPPacketSizeType { GEBPPacketFull = 0,GEBPPacketHalf,GEBPPacketQuarter } ; template<_LhsScalar,_RhsScalar,bool _ConjLhs = false,bool _ConjRhs = false,int Arch = Architecture::Target,int _PacketSize = GEBPPacketFull> class gebp_traits ; std::ptrdiff_t)",
    "insertText": "manage_caching_sizes_helper(std::ptrdiff_t a, std::ptrdiff_t b)"
  },
  {
    "label": "EIGEN_SET_DEFAULT_L2_CACHE_SIZE()",
    "kind": "Method",
    "detail": "Function (const std::ptrdiff_t defaultL2CacheSize =)",
    "insertText": "EIGEN_SET_DEFAULT_L2_CACHE_SIZE(256*1024)"
  },
  {
    "label": "EIGEN_SET_DEFAULT_L3_CACHE_SIZE()",
    "kind": "Method",
    "detail": "Function (const std::ptrdiff_t defaultL3CacheSize =)",
    "insertText": "EIGEN_SET_DEFAULT_L3_CACHE_SIZE(2*1024*1024)"
  },
  {
    "label": "EIGEN_SET_DEFAULT_L1_CACHE_SIZE()",
    "kind": "Method",
    "detail": "Function (# elif EIGEN_ARCH_PPC const std::ptrdiff_t defaultL1CacheSize =)",
    "insertText": "EIGEN_SET_DEFAULT_L1_CACHE_SIZE(64*1024)"
  },
  {
    "label": "EIGEN_SET_DEFAULT_L2_CACHE_SIZE()",
    "kind": "Method",
    "detail": "Function (const std::ptrdiff_t defaultL2CacheSize =)",
    "insertText": "EIGEN_SET_DEFAULT_L2_CACHE_SIZE(512*1024)"
  },
  {
    "label": "EIGEN_SET_DEFAULT_L3_CACHE_SIZE()",
    "kind": "Method",
    "detail": "Function (const std::ptrdiff_t defaultL3CacheSize =)",
    "insertText": "EIGEN_SET_DEFAULT_L3_CACHE_SIZE(4*1024*1024)"
  },
  {
    "label": "EIGEN_SET_DEFAULT_L1_CACHE_SIZE()",
    "kind": "Method",
    "detail": "Function (# else const std::ptrdiff_t defaultL1CacheSize =)",
    "insertText": "EIGEN_SET_DEFAULT_L1_CACHE_SIZE(16*1024)"
  },
  {
    "label": "EIGEN_SET_DEFAULT_L3_CACHE_SIZE()",
    "kind": "Method",
    "detail": "Function (const std::ptrdiff_t defaultL3CacheSize =)",
    "insertText": "EIGEN_SET_DEFAULT_L3_CACHE_SIZE(512*1024)"
  },
  {
    "label": "CacheSizes()",
    "kind": "Method",
    "detail": "Function (# endif # undef EIGEN_SET_DEFAULT_L1_CACHE_SIZE # undef EIGEN_SET_DEFAULT_L2_CACHE_SIZE # undef EIGEN_SET_DEFAULT_L3_CACHE_SIZE struct CacheSizes {)",
    "insertText": "CacheSizes(): m_l1(-1),m_l2(-1),m_l3(-1)"
  },
  {
    "label": "queryCacheSizes()",
    "kind": "Method",
    "detail": "Function (int l1CacheSize,l2CacheSize,l3CacheSize ;)",
    "insertText": "queryCacheSizes(l1CacheSize, l2CacheSize, l3CacheSize)"
  },
  {
    "label": "manage_caching_sizes_helper()",
    "kind": "Method",
    "detail": "Function (m_l1 =)",
    "insertText": "manage_caching_sizes_helper(l1CacheSize, defaultL1CacheSize)"
  },
  {
    "label": "manage_caching_sizes_helper()",
    "kind": "Method",
    "detail": "Function (m_l2 =)",
    "insertText": "manage_caching_sizes_helper(l2CacheSize, defaultL2CacheSize)"
  },
  {
    "label": "manage_caching_sizes_helper()",
    "kind": "Method",
    "detail": "Function (m_l3 =)",
    "insertText": "manage_caching_sizes_helper(l3CacheSize, defaultL3CacheSize)"
  },
  {
    "label": "manage_caching_sizes()",
    "kind": "Method",
    "detail": "Function (} std::ptrdiff_t m_l1 ; std::ptrdiff_t m_l2 ; std::ptrdiff_t m_l3 ; } ; void)",
    "insertText": "manage_caching_sizes(Action action, std::ptrdiff_t* l1, std::ptrdiff_t* l2, std::ptrdiff_t* l3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (CacheSizes m_cacheSizes ;)",
    "insertText": "if(action==SetAction)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(l1!=0 && l2!=0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (m_cacheSizes . m_l1 =* l1 ; m_cacheSizes . m_l2 =* l2 ; m_cacheSizes . m_l3 =* l3 ; } else)",
    "insertText": "if(action==GetAction)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (* l1 = m_cacheSizes . m_l1 ;* l2 = m_cacheSizes . m_l2 ;* l3 = m_cacheSizes . m_l3 ; } else {)",
    "insertText": "eigen_internal_assert(false)"
  },
  {
    "label": "evaluateProductBlockingSizesHeuristic()",
    "kind": "Method",
    "detail": "Function (} } template<LhsScalar,RhsScalar,int KcFactor,Index> void)",
    "insertText": "evaluateProductBlockingSizesHeuristic(Index& k, Index& m, Index& n, Index num_threads = 1)"
  },
  {
    "label": "manage_caching_sizes()",
    "kind": "Method",
    "detail": "Function (typedef gebp_traits<LhsScalar,RhsScalar> Traits ; std::ptrdiff_t l1,l2,l3 ;)",
    "insertText": "manage_caching_sizes(GetAction, &l1, &l2, &l3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_VECTORIZE_AVX512 l1* = 4 ; # endif)",
    "insertText": "if(num_threads > 1)"
  },
  {
    "label": "KcFactor()",
    "kind": "Method",
    "detail": "Function (typedef Traits::ResScalar ResScalar ; enum { kdiv =)",
    "insertText": "KcFactor(Traits::mr * sizeof(LhsScalar) + Traits::nr * sizeof(RhsScalar)), ksub = Traits::mr * Traits::nr * sizeof(ResScalar)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (const Index k_cache = numext::maxi<)",
    "insertText": "Index(kr, (numext::mini<Index>)((l1-ksub)/kdiv, 320))"
  },
  {
    "label": "k_cache()",
    "kind": "Method",
    "detail": "Function (k =)",
    "insertText": "k_cache(k_cache % kr)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(k > 0)"
  },
  {
    "label": "n_cache()",
    "kind": "Method",
    "detail": "Function (} const Index)",
    "insertText": "n_cache(l2-l1) / (nr * sizeof(RhsScalar) * k)"
  },
  {
    "label": "div_ceil()",
    "kind": "Method",
    "detail": "Function (const Index n_per_thread =)",
    "insertText": "div_ceil(n, num_threads)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(n_cache >= static_cast<Index>(nr))"
  },
  {
    "label": "n_cache()",
    "kind": "Method",
    "detail": "Function (n =)",
    "insertText": "n_cache(n_cache % nr)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(n > 0)"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "n(numext::mini<Index>)(n, (n_per_thread + nr - 1) - ((n_per_thread + nr - 1) % nr))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(l3 > l2)"
  },
  {
    "label": "m_cache()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "m_cache(l3-l2) / (sizeof(LhsScalar) * k * num_threads)"
  },
  {
    "label": "div_ceil()",
    "kind": "Method",
    "detail": "Function (const Index m_per_thread =)",
    "insertText": "div_ceil(m, num_threads)"
  },
  {
    "label": "m_cache()",
    "kind": "Method",
    "detail": "Function (m =)",
    "insertText": "m_cache(m_cache % mr)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(m > 0)"
  },
  {
    "label": "m()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "m(numext::mini<Index>)(m, (m_per_thread + mr - 1) - ((m_per_thread + mr - 1) % mr))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else { # ifdef EIGEN_DEBUG_SMALL_PRODUCT_BLOCKS l1 = 9* 1 0 2 4 ; l2 = 3 2* 1 0 2 4 ; l3 = 5 1 2* 1 0 2 4 ; # endif)",
    "insertText": "if((numext::maxi)(k,(numext::maxi)(m,n))<48)"
  },
  {
    "label": "KcFactor()",
    "kind": "Method",
    "detail": "Function (typedef Traits::ResScalar ResScalar ; enum { k_peeling = 8,k_div =)",
    "insertText": "KcFactor(Traits::mr * sizeof(LhsScalar) + Traits::nr * sizeof(RhsScalar)), k_sub = Traits::mr * Traits::nr * sizeof(ResScalar)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (const Index max_kc = numext::maxi<)",
    "insertText": "Index(((l1-k_sub)/k_div) & (~(k_peeling-1)),1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index old_k = k ;)",
    "insertText": "if(k>max_kc)"
  },
  {
    "label": "k()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "k(k%max_kc)==0 ? max_kc : max_kc - k_peeling * ((max_kc-1-(k%max_kc))/(k_peeling*(k/max_kc+1)))"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(((old_k/k) == (old_k/max_kc)) && \"the number of sweeps has to remain the same\")"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} # ifdef EIGEN_DEBUG_SMALL_PRODUCT_BLOCKS const Index actual_l2 = l3 ; # else const Index actual_l2 = 1 5 7 2 8 6 4 ; # endif Index max_nc ; const Index lhs_bytes = m* k*)",
    "insertText": "sizeof(LhsScalar)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Index remaining_l1 = l1 - k_sub - lhs_bytes ;)",
    "insertText": "if(remaining_l1 >= Index(Traits::nr*sizeof(RhsScalar))*k)"
  },
  {
    "label": "remaining_l1()",
    "kind": "Method",
    "detail": "Function (max_nc =)",
    "insertText": "remaining_l1(k*sizeof(RhsScalar))"
  },
  {
    "label": "max_nc()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "max_nc(3*actual_l2)/(2*2*max_kc*sizeof(RhsScalar))"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (} Index nc = numext::mini<)",
    "insertText": "Index(actual_l2/(2*k*sizeof(RhsScalar)), max_nc) & (~(Traits::nr-1))"
  },
  {
    "label": "n()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "n(n%nc)==0 ? nc : (nc - Traits::nr * ((nc -(n%nc))/(Traits::nr*(n/nc+1))))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(old_k==k)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index actual_lm = actual_l2 ; Index max_mc = m ;)",
    "insertText": "if(problem_size<=1024)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (actual_lm = l1 ; } else)",
    "insertText": "if(l3!=0 && problem_size<=32768)"
  },
  {
    "label": "max_mc()",
    "kind": "Method",
    "detail": "Function (actual_lm = l2 ;)",
    "insertText": "max_mc(numext::mini<Index>)(576,max_mc)"
  },
  {
    "label": "mc()",
    "kind": "Method",
    "detail": "Function (} Index)",
    "insertText": "mc(numext::mini<Index>)(actual_lm/(3*k*sizeof(LhsScalar)), max_mc)"
  },
  {
    "label": "m()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "m(m%mc)==0 ? mc : (mc - Traits::mr * ((mc -(m%mc))/(Traits::mr*(m/mc+1))))"
  },
  {
    "label": "useSpecificBlockingSizes()",
    "kind": "Method",
    "detail": "Function (} } } template<Index> bool)",
    "insertText": "useSpecificBlockingSizes(Index& k, Index& m, Index& n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef EIGEN_TEST_SPECIFIC_BLOCKING_SIZES)",
    "insertText": "if(EIGEN_TEST_SPECIFIC_BLOCKING_SIZES)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (k = numext::mini<)",
    "insertText": "Index(k, EIGEN_TEST_SPECIFIC_BLOCKING_SIZE_K)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (m = numext::mini<)",
    "insertText": "Index(m, EIGEN_TEST_SPECIFIC_BLOCKING_SIZE_M)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (n = numext::mini<)",
    "insertText": "Index(n, EIGEN_TEST_SPECIFIC_BLOCKING_SIZE_N)"
  },
  {
    "label": "computeProductBlockingSizes()",
    "kind": "Method",
    "detail": "Function (} template<LhsScalar,RhsScalar,int KcFactor,Index> void)",
    "insertText": "computeProductBlockingSizes(Index& k, Index& m, Index& n, Index num_threads = 1)"
  },
  {
    "label": "Index()",
    "kind": "Method",
    "detail": "Function (evaluateProductBlockingSizesHeuristic<LhsScalar,RhsScalar,KcFactor,)",
    "insertText": "Index(k, m, n, num_threads)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (} template<RhsPacket,RhsPacketx4,int registers_taken> struct RhsPanelHelper { private : const int remaining_registers = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS - registers_taken ; public : typedef conditional<remaining_registers> = 4,RhsPacketx4,RhsPacket>::type type ; } ; template<Packet> struct QuadPacket { Packet B_0,B1,B2,B3 ; const Packet&)",
    "insertText": "get(const FixedInt<0>&)"
  },
  {
    "label": "PACKET_DECL_COND_PREFIX()",
    "kind": "Method",
    "detail": "Function (public : typedef _LhsScalar LhsScalar ; typedef _RhsScalar RhsScalar ; typedef ScalarBinaryOpTraits<LhsScalar,RhsScalar>::ReturnType ResScalar ;)",
    "insertText": "PACKET_DECL_COND_PREFIX(_, Lhs, _PacketSize)"
  },
  {
    "label": "PACKET_DECL_COND_PREFIX()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PACKET_DECL_COND_PREFIX(_, Rhs, _PacketSize)"
  },
  {
    "label": "PACKET_DECL_COND_PREFIX()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PACKET_DECL_COND_PREFIX(_, Res, _PacketSize)"
  },
  {
    "label": "default_mr()",
    "kind": "Method",
    "detail": "Function (enum { ConjLhs = _ConjLhs,ConjRhs = _ConjRhs,Vectorizable = unpacket_traits<_LhsPacket>::vectorizable&& unpacket_traits<_RhsPacket>::vectorizable,LhsPacketSize = Vectorizable ? unpacket_traits<_LhsPacket>::size : 1,RhsPacketSize = Vectorizable ? unpacket_traits<_RhsPacket>::size : 1,ResPacketSize = Vectorizable ? unpacket_traits<_ResPacket>::size : 1,NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,nr = 4,)",
    "insertText": "default_mr(EIGEN_PLAIN_ENUM_MIN(16,NumberOfRegisters)/2/nr)*LhsPacketSize, #if defined(EIGEN_HAS_SINGLE_INSTRUCTION_MADD) && !defined(EIGEN_VECTORIZE_ALTIVEC) && !defined(EIGEN_VECTORIZE_VSX) \\ && ((!EIGEN_COMP_MSVC) || (EIGEN_COMP_MSVC>=1914))"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (typedef conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket ; typedef conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket ; typedef conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket ; typedef LhsPacket LhsPacket4Packing ; typedef QuadPacket<RhsPacket> RhsPacketx4 ; typedef ResPacket AccPacket ; EIGEN_STRONG_INLINE void)",
    "insertText": "initAcc(AccPacket& p)"
  },
  {
    "label": "ResPacket()",
    "kind": "Method",
    "detail": "Function (p = pset1<)",
    "insertText": "ResPacket(ResScalar(0))"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (} template<RhsPacketType> EIGEN_STRONG_INLINE void)",
    "insertText": "loadRhs(const RhsScalar* b, RhsPacketType& dest)"
  },
  {
    "label": "RhsPacketType()",
    "kind": "Method",
    "detail": "Function (dest = pset1<)",
    "insertText": "RhsPacketType(*b)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "loadRhs(const RhsScalar* b, RhsPacketx4& dest)"
  },
  {
    "label": "pbroadcast4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pbroadcast4(b, dest.B_0, dest.B1, dest.B2, dest.B3)"
  },
  {
    "label": "updateRhs()",
    "kind": "Method",
    "detail": "Function (} template<RhsPacketType> EIGEN_STRONG_INLINE void)",
    "insertText": "updateRhs(const RhsScalar* b, RhsPacketType& dest)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "loadRhs(b, dest)"
  },
  {
    "label": "updateRhs()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "updateRhs(const RhsScalar*, RhsPacketx4&)"
  },
  {
    "label": "loadRhsQuad()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "loadRhsQuad(const RhsScalar* b, RhsPacket& dest)"
  },
  {
    "label": "RhsPacket()",
    "kind": "Method",
    "detail": "Function (dest = ploadquad<)",
    "insertText": "RhsPacket(b)"
  },
  {
    "label": "loadLhs()",
    "kind": "Method",
    "detail": "Function (} template<LhsPacketType> EIGEN_STRONG_INLINE void)",
    "insertText": "loadLhs(const LhsScalar* a, LhsPacketType& dest)"
  },
  {
    "label": "LhsPacketType()",
    "kind": "Method",
    "detail": "Function (dest = pload<)",
    "insertText": "LhsPacketType(a)"
  },
  {
    "label": "loadLhsUnaligned()",
    "kind": "Method",
    "detail": "Function (} template<LhsPacketType> EIGEN_STRONG_INLINE void)",
    "insertText": "loadLhsUnaligned(const LhsScalar* a, LhsPacketType& dest)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (} template<LhsPacketType,RhsPacketType,AccPacketType,LaneIdType> EIGEN_STRONG_INLINE void)",
    "insertText": "madd(const LhsPacketType& a, const RhsPacketType& b, AccPacketType& c, RhsPacketType& tmp, const LaneIdType&)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (conj_helper<LhsPacketType,RhsPacketType,ConjLhs,ConjRhs> cj ; # ifdef EIGEN_HAS_SINGLE_INSTRUCTION_MADD)",
    "insertText": "EIGEN_UNUSED_VARIABLE(tmp)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (c = cj .)",
    "insertText": "pmadd(a,b,c)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (# else tmp = b ; tmp = cj .)",
    "insertText": "pmul(a,tmp)"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (c =)",
    "insertText": "padd(c,tmp)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (# endif } template<LhsPacketType,AccPacketType,LaneIdType> EIGEN_STRONG_INLINE void)",
    "insertText": "madd(const LhsPacketType& a, const RhsPacketx4& b, AccPacketType& c, RhsPacket& tmp, const LaneIdType& lane)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "madd(a, b.get(lane), c, tmp, lane)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (r =)",
    "insertText": "pmadd(c,alpha,r)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (} template<ResPacketHalf> EIGEN_STRONG_INLINE void)",
    "insertText": "acc(const ResPacketHalf& c, const ResPacketHalf& alpha, ResPacketHalf& r)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (enum { ConjLhs = _ConjLhs,ConjRhs = false,Vectorizable = unpacket_traits<_LhsPacket>::vectorizable&& unpacket_traits<_RhsPacket>::vectorizable,LhsPacketSize = Vectorizable ? unpacket_traits<_LhsPacket>::size : 1,RhsPacketSize = Vectorizable ? unpacket_traits<_RhsPacket>::size : 1,ResPacketSize = Vectorizable ? unpacket_traits<_ResPacket>::size : 1,NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,nr = 4,# if)",
    "insertText": "defined(EIGEN_HAS_SINGLE_INSTRUCTION_MADD) && !defined(EIGEN_VECTORIZE_ALTIVEC) && !defined(EIGEN_VECTORIZE_VSX) mr = 3*LhsPacketSize, #else mr = (EIGEN_PLAIN_ENUM_MIN(16,NumberOfRegisters)/2/nr)"
  },
  {
    "label": "loadRhsQuad_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "loadRhsQuad_impl(b,dest, typename conditional<RhsPacketSize==16,true_type,false_type>::type())"
  },
  {
    "label": "loadRhsQuad_impl()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "loadRhsQuad_impl(const RhsScalar* b, RhsPacket& dest, const true_type&)"
  },
  {
    "label": "RhsPacket()",
    "kind": "Method",
    "detail": "Function (RhsScalar tmp [ 4 ] = { b [ 0 ],b [ 0 ],b [ 1 ],b [ 1 ] } ; dest = ploadquad<)",
    "insertText": "RhsPacket(tmp)"
  },
  {
    "label": "loadRhsQuad_impl()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "loadRhsQuad_impl(const RhsScalar* b, RhsPacket& dest, const false_type&)"
  },
  {
    "label": "eigen_internal_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_internal_assert(RhsPacketSize<=8)"
  },
  {
    "label": "RhsPacket()",
    "kind": "Method",
    "detail": "Function (dest = pset1<)",
    "insertText": "RhsPacket(*b)"
  },
  {
    "label": "loadLhs()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "loadLhs(const LhsScalar* a, LhsPacket& dest)"
  },
  {
    "label": "LhsPacket()",
    "kind": "Method",
    "detail": "Function (dest = pload<)",
    "insertText": "LhsPacket(a)"
  },
  {
    "label": "madd_impl()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "madd_impl(a, b, c, tmp, typename conditional<Vectorizable,true_type,false_type>::type())"
  },
  {
    "label": "madd_impl()",
    "kind": "Method",
    "detail": "Function (} template<LhsPacketType,RhsPacketType,AccPacketType> EIGEN_STRONG_INLINE void)",
    "insertText": "madd_impl(const LhsPacketType& a, const RhsPacketType& b, AccPacketType& c, RhsPacketType& tmp, const true_type&)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (c . v =)",
    "insertText": "pmadd(a.v,b,c.v)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (# else tmp = b ; tmp =)",
    "insertText": "pmul(a.v,tmp)"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (c . v =)",
    "insertText": "padd(c.v,tmp)"
  },
  {
    "label": "madd_impl()",
    "kind": "Method",
    "detail": "Function (# endif } EIGEN_STRONG_INLINE void)",
    "insertText": "madd_impl(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& , const false_type&)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (} template<ResPacketType,AccPacketType> EIGEN_STRONG_INLINE void)",
    "insertText": "acc(const AccPacketType& c, const ResPacketType& alpha, ResPacketType& r)"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (} protected : } ; template<Packet> struct DoublePacket { Packet first ; Packet second ; } ; template<Packet> DoublePacket<Packet>)",
    "insertText": "padd(const DoublePacket<Packet> &a, const DoublePacket<Packet> &b)"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (res . second =)",
    "insertText": "padd(a.second,b.second)"
  },
  {
    "label": "predux_half_dowto4()",
    "kind": "Method",
    "detail": "Function (res . second =)",
    "insertText": "predux_half_dowto4(CplxPacket(a.second))"
  },
  {
    "label": "RealPacket()",
    "kind": "Method",
    "detail": "Function (dest . first = pset1<)",
    "insertText": "RealPacket(numext::real(*b))"
  },
  {
    "label": "RealPacket()",
    "kind": "Method",
    "detail": "Function (dest . second = pset1<)",
    "insertText": "RealPacket(numext::imag(*b))"
  },
  {
    "label": "loadQuadToDoublePacket()",
    "kind": "Method",
    "detail": "Function (} template<Scalar,RealPacket> void)",
    "insertText": "loadQuadToDoublePacket(const Scalar* b, DoublePacket<RealPacket>& dest, typename enable_if<unpacket_traits<RealPacket>::size==16>::type* = 0)"
  },
  {
    "label": "real()",
    "kind": "Method",
    "detail": "Function (typedef NumTraits<Scalar>::Real RealScalar ; RealScalar r [ 4 ] = {)",
    "insertText": "real(b[0]), numext::real(b[0]), numext::real(b[1]), numext::real(b[1])"
  },
  {
    "label": "imag()",
    "kind": "Method",
    "detail": "Function (RealScalar i [ 4 ] = {)",
    "insertText": "imag(b[0]), numext::imag(b[0]), numext::imag(b[1]), numext::imag(b[1])"
  },
  {
    "label": "RealPacket()",
    "kind": "Method",
    "detail": "Function (dest . first = ploadquad<)",
    "insertText": "RealPacket(r)"
  },
  {
    "label": "RealPacket()",
    "kind": "Method",
    "detail": "Function (dest . second = ploadquad<)",
    "insertText": "RealPacket(i)"
  },
  {
    "label": "PACKET_DECL_COND()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PACKET_DECL_COND(Real, _PacketSize)"
  },
  {
    "label": "PACKET_DECL_COND_SCALAR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PACKET_DECL_COND_SCALAR(_PacketSize)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (enum { ConjLhs = _ConjLhs,ConjRhs = _ConjRhs,Vectorizable = unpacket_traits<RealPacket>::vectorizable&& unpacket_traits<ScalarPacket>::vectorizable,ResPacketSize = Vectorizable ? unpacket_traits<_ResPacket>::size : 1,LhsPacketSize = Vectorizable ? unpacket_traits<_LhsPacket>::size : 1,RhsPacketSize = Vectorizable ? unpacket_traits<RhsScalar>::size : 1,RealPacketSize = Vectorizable ? unpacket_traits<RealPacket>::size : 1,nr = 4,mr = ResPacketSize,LhsProgress = ResPacketSize,RhsProgress = 1 } ; typedef DoublePacket<RealPacket> DoublePacketType ; typedef conditional<Vectorizable,ScalarPacket,Scalar>::type LhsPacket4Packing ; typedef conditional<Vectorizable,RealPacket,Scalar>::type LhsPacket ; typedef conditional<Vectorizable,DoublePacketType,Scalar>::type RhsPacket ; typedef conditional<Vectorizable,ScalarPacket,Scalar>::type ResPacket ; typedef conditional<Vectorizable,DoublePacketType,Scalar>::type AccPacket ; typedef QuadPacket<RhsPacket> RhsPacketx4 ; EIGEN_STRONG_INLINE void)",
    "insertText": "initAcc(Scalar& p)"
  },
  {
    "label": "Scalar()",
    "kind": "Method",
    "detail": "Function (p =)",
    "insertText": "Scalar(0)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "initAcc(DoublePacketType& p)"
  },
  {
    "label": "RealPacket()",
    "kind": "Method",
    "detail": "Function (p . first = pset1<)",
    "insertText": "RealPacket(RealScalar(0))"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "loadRhs(const RhsScalar* b, ScalarPacket& dest)"
  },
  {
    "label": "ScalarPacket()",
    "kind": "Method",
    "detail": "Function (dest = pset1<)",
    "insertText": "ScalarPacket(*b)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (} template<RealPacketType> EIGEN_STRONG_INLINE void)",
    "insertText": "loadRhs(const RhsScalar* b, DoublePacket<RealPacketType>& dest)"
  },
  {
    "label": "RealPacketType()",
    "kind": "Method",
    "detail": "Function (dest . first = pset1<)",
    "insertText": "RealPacketType(numext::real(*b))"
  },
  {
    "label": "RealPacketType()",
    "kind": "Method",
    "detail": "Function (dest . second = pset1<)",
    "insertText": "RealPacketType(numext::imag(*b))"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "loadRhs(b, dest.B_0)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "loadRhs(b + 1, dest.B1)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "loadRhs(b + 2, dest.B2)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "loadRhs(b + 3, dest.B3)"
  },
  {
    "label": "updateRhs()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "updateRhs(const RhsScalar* b, ScalarPacket& dest)"
  },
  {
    "label": "updateRhs()",
    "kind": "Method",
    "detail": "Function (} template<RealPacketType> EIGEN_STRONG_INLINE void)",
    "insertText": "updateRhs(const RhsScalar* b, DoublePacket<RealPacketType>& dest)"
  },
  {
    "label": "loadRhsQuad()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "loadRhsQuad(const RhsScalar* b, ResPacket& dest)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "loadRhs(b,dest)"
  },
  {
    "label": "loadRhsQuad()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "loadRhsQuad(const RhsScalar* b, DoublePacketType& dest)"
  },
  {
    "label": "loadQuadToDoublePacket()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "loadQuadToDoublePacket(b,dest)"
  },
  {
    "label": "LhsPacket()",
    "kind": "Method",
    "detail": "Function (dest = pload<)",
    "insertText": "LhsPacket((const typename unpacket_traits<LhsPacket>::type*)(a))"
  },
  {
    "label": "LhsPacketType()",
    "kind": "Method",
    "detail": "Function (dest = ploadu<)",
    "insertText": "LhsPacketType((const typename unpacket_traits<LhsPacketType>::type*)(a))"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (} template<LhsPacketType,RhsPacketType,ResPacketType,TmpType,LaneIdType> EIGEN_STRONG_INLINE enable_if<! is_same<RhsPacketType,RhsPacketx4>::value>::type)",
    "insertText": "madd(const LhsPacketType& a, const RhsPacketType& b, DoublePacket<ResPacketType>& c, TmpType& , const LaneIdType&)"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (c . first =)",
    "insertText": "padd(pmul(a,b.first), c.first)"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (c . second =)",
    "insertText": "padd(pmul(a,b.second),c.second)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (} template<LaneIdType> EIGEN_STRONG_INLINE void)",
    "insertText": "madd(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& , const LaneIdType&)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "acc(const Scalar& c, const Scalar& alpha, Scalar& r)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (r + = alpha* c ; } template<RealPacketType,ResPacketType> EIGEN_STRONG_INLINE void)",
    "insertText": "acc(const DoublePacket<RealPacketType>& c, const ResPacketType& alpha, ResPacketType& r)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ResPacketType tmp ;)",
    "insertText": "if((!ConjLhs)&&(!ConjRhs))"
  },
  {
    "label": "pcplxflip()",
    "kind": "Method",
    "detail": "Function (tmp =)",
    "insertText": "pcplxflip(pconj(ResPacketType(c.second)))"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (tmp =)",
    "insertText": "padd(ResPacketType(c.first),tmp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((!ConjLhs)&&(ConjRhs))"
  },
  {
    "label": "pconj()",
    "kind": "Method",
    "detail": "Function (tmp =)",
    "insertText": "pconj(pcplxflip(ResPacketType(c.second)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((ConjLhs)&&(!ConjRhs))"
  },
  {
    "label": "pcplxflip()",
    "kind": "Method",
    "detail": "Function (tmp =)",
    "insertText": "pcplxflip(ResPacketType(c.second))"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (tmp =)",
    "insertText": "padd(pconj(ResPacketType(c.first)),tmp)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((ConjLhs)&&(ConjRhs))"
  },
  {
    "label": "psub()",
    "kind": "Method",
    "detail": "Function (tmp =)",
    "insertText": "psub(pconj(ResPacketType(c.first)),tmp)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (} r =)",
    "insertText": "pmadd(tmp,alpha,r)"
  },
  {
    "label": "PACKET_DECL_COND_PREFIX()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PACKET_DECL_COND_PREFIX(_, Real, _PacketSize)"
  },
  {
    "label": "PACKET_DECL_COND_SCALAR_PREFIX()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PACKET_DECL_COND_SCALAR_PREFIX(_, _PacketSize)"
  },
  {
    "label": "mr()",
    "kind": "Method",
    "detail": "Function (# undef PACKET_DECL_COND_SCALAR_PREFIX # undef PACKET_DECL_COND_PREFIX # undef PACKET_DECL_COND_SCALAR # undef PACKET_DECL_COND enum { ConjLhs = false,ConjRhs = _ConjRhs,Vectorizable = unpacket_traits<_RealPacket>::vectorizable&& unpacket_traits<_ScalarPacket>::vectorizable,LhsPacketSize = Vectorizable ? unpacket_traits<_LhsPacket>::size : 1,RhsPacketSize = Vectorizable ? unpacket_traits<_RhsPacket>::size : 1,ResPacketSize = Vectorizable ? unpacket_traits<_ResPacket>::size : 1,NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,nr = 4,)",
    "insertText": "mr(EIGEN_PLAIN_ENUM_MIN(16,NumberOfRegisters)/2/nr)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (c . v =)",
    "insertText": "pmadd(a,b.v,c.v)"
  },
  {
    "label": "pmul()",
    "kind": "Method",
    "detail": "Function (# else tmp = b ; tmp . v =)",
    "insertText": "pmul(a,tmp.v)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (conj_helper<ResPacketType,ResPacketType,false,ConjRhs> cj ; r = cj .)",
    "insertText": "pmadd(alpha,c,r)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} protected : } ; template<LhsScalar,RhsScalar,Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> struct gebp_kernel { typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs,Architecture::Target> Traits ; typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs,Architecture::Target,GEBPPacketHalf> HalfTraits ; typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs,Architecture::Target,GEBPPacketQuarter> QuarterTraits ; typedef Traits::ResScalar ResScalar ; typedef Traits::LhsPacket LhsPacket ; typedef Traits::RhsPacket RhsPacket ; typedef Traits::ResPacket ResPacket ; typedef Traits::AccPacket AccPacket ; typedef Traits::RhsPacketx4 RhsPacketx4 ; typedef RhsPanelHelper<RhsPacket,RhsPacketx4,1 5>::type RhsPanel15 ; typedef gebp_traits<RhsScalar,LhsScalar,ConjugateRhs,ConjugateLhs,Architecture::Target> SwappedTraits ; typedef SwappedTraits::ResScalar SResScalar ; typedef SwappedTraits::LhsPacket SLhsPacket ; typedef SwappedTraits::RhsPacket SRhsPacket ; typedef SwappedTraits::ResPacket SResPacket ; typedef SwappedTraits::AccPacket SAccPacket ; typedef HalfTraits::LhsPacket LhsPacketHalf ; typedef HalfTraits::RhsPacket RhsPacketHalf ; typedef HalfTraits::ResPacket ResPacketHalf ; typedef HalfTraits::AccPacket AccPacketHalf ; typedef QuarterTraits::LhsPacket LhsPacketQuarter ; typedef QuarterTraits::RhsPacket RhsPacketQuarter ; typedef QuarterTraits::ResPacket ResPacketQuarter ; typedef QuarterTraits::AccPacket AccPacketQuarter ; typedef DataMapper::LinearMapper LinearMapper ; enum { Vectorizable = Traits::Vectorizable,LhsProgress = Traits::LhsProgress,LhsProgressHalf = HalfTraits::LhsProgress,LhsProgressQuarter = QuarterTraits::LhsProgress,RhsProgress = Traits::RhsProgress,RhsProgressHalf = HalfTraits::RhsProgress,RhsProgressQuarter = QuarterTraits::RhsProgress,ResPacketSize = Traits::ResPacketSize } ; EIGEN_DONT_INLINE void)",
    "insertText": "operator()(const DataMapper& res, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha, Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<LhsScalar,RhsScalar,Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs,int SwappedLhsProgress = gebp_traits<RhsScalar,LhsScalar,ConjugateRhs,ConjugateLhs,Architecture::Target>::LhsProgress> struct last_row_process_16_packets { typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs,Architecture::Target> Traits ; typedef gebp_traits<RhsScalar,LhsScalar,ConjugateRhs,ConjugateLhs,Architecture::Target> SwappedTraits ; typedef Traits::ResScalar ResScalar ; typedef SwappedTraits::LhsPacket SLhsPacket ; typedef SwappedTraits::RhsPacket SRhsPacket ; typedef SwappedTraits::ResPacket SResPacket ; typedef SwappedTraits::AccPacket SAccPacket ; EIGEN_STRONG_INLINE void)",
    "insertText": "operator()(const DataMapper& res, SwappedTraits &straits, const LhsScalar* blA, const RhsScalar* blB, Index depth, const Index endk, Index i, Index j2, ResScalar alpha, SAccPacket &C0)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(res)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(straits)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(blA)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(blB)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(depth)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(endk)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(i)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(j2)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(alpha)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(C0)"
  },
  {
    "label": "SResPacketQuarter()",
    "kind": "Method",
    "detail": "Function (typedef unpacket_traits<unpacket_traits<SResPacket>::half>::half SResPacketQuarter ; typedef unpacket_traits<unpacket_traits<SLhsPacket>::half>::half SLhsPacketQuarter ; typedef unpacket_traits<unpacket_traits<SRhsPacket>::half>::half SRhsPacketQuarter ; typedef unpacket_traits<unpacket_traits<SAccPacket>::half>::half SAccPacketQuarter ; SResPacketQuarter R = res . template gatherPacket<)",
    "insertText": "SResPacketQuarter(i, j2)"
  },
  {
    "label": "SResPacketQuarter()",
    "kind": "Method",
    "detail": "Function (SResPacketQuarter alphav = pset1<)",
    "insertText": "SResPacketQuarter(alpha)"
  },
  {
    "label": "predux_half_dowto4()",
    "kind": "Method",
    "detail": "Function (SAccPacketQuarter c0 =)",
    "insertText": "predux_half_dowto4(predux_half_dowto4(C0))"
  },
  {
    "label": "loadLhsUnaligned()",
    "kind": "Method",
    "detail": "Function (SLhsPacketQuarter a0 ; SRhsPacketQuarter b0 ; straits .)",
    "insertText": "loadLhsUnaligned(blB, a0)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "loadRhs(blA, b0)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "madd(a0,b0,c0,b0, fix<0>)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (blB + = SwappedTraits::LhsProgress / 4 ; blA + = 1 ; } straits .)",
    "insertText": "acc(c0, alphav, R)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (} else { straits .)",
    "insertText": "acc(predux_half_dowto4(predux_half_dowto4(C0)), alphav, R)"
  },
  {
    "label": "scatterPacket()",
    "kind": "Method",
    "detail": "Function (} res .)",
    "insertText": "scatterPacket(i, j2, R)"
  },
  {
    "label": "peeled_kc_onestep()",
    "kind": "Method",
    "detail": "Function (} } ; template<int nr,Index LhsProgress,Index RhsProgress,LhsScalar,RhsScalar,ResScalar,AccPacket,LhsPacket,RhsPacket,ResPacket,GEBPTraits,LinearMapper,DataMapper> struct lhs_process_one_packet { typedef GEBPTraits::RhsPacketx4 RhsPacketx4 ; EIGEN_STRONG_INLINE void)",
    "insertText": "peeled_kc_onestep(Index K, const LhsScalar* blA, const RhsScalar* blB, GEBPTraits traits, LhsPacket *A0, RhsPacketx4 *rhs_panel, RhsPacket *T0, AccPacket *C0, AccPacket *C1, AccPacket *C2, AccPacket *C3)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin step of gebp micro kernel 1X4\")"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"Note: these asm comments work around bug 935!\")"
  },
  {
    "label": "loadLhs()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "loadLhs(&blA[(0+1*K)*LhsProgress], *A0)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "loadRhs(&blB[(0+4*K)*RhsProgress], *rhs_panel)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "madd(*A0, *rhs_panel, *C0, *T0, fix<0>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "madd(*A0, *rhs_panel, *C1, *T0, fix<1>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "madd(*A0, *rhs_panel, *C2, *T0, fix<2>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "madd(*A0, *rhs_panel, *C3, *T0, fix<3>)"
  },
  {
    "label": "EIGEN_GNUC_AT_LEAST()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "EIGEN_GNUC_AT_LEAST(6,0) && defined(EIGEN_VECTORIZE_SSE) __asm__ (\"\" : \"+x,m\" (*A0))"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "EIGEN_ASM_COMMENT(\"end step of gebp micro kernel 1X4\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_STRONG_INLINE void)",
    "insertText": "operator()( const DataMapper& res, const LhsScalar* blockA, const RhsScalar* blockB, ResScalar alpha, Index peelStart, Index peelEnd, Index strideA, Index strideB, Index offsetA, Index offsetB, int prefetch_res_offset, Index peeled_kc, Index pk, Index cols, Index depth, Index packet_cols4)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (GEBPTraits traits ;)",
    "insertText": "for(Index i=peelStart; i<peelEnd; i+=LhsProgress)"
  },
  {
    "label": "offsetA()",
    "kind": "Method",
    "detail": "Function (const LhsScalar* blA =& blockA [ i* strideA +)",
    "insertText": "offsetA(LhsProgress)"
  },
  {
    "label": "prefetch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prefetch(&blA[0])"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (AccPacket C0,C1,C2,C3 ; traits .)",
    "insertText": "initAcc(C0)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(C1)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(C2)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(C3)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (AccPacket D0,D1,D2,D3 ; traits .)",
    "insertText": "initAcc(D0)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(D1)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(D2)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(D3)"
  },
  {
    "label": "getLinearMapper()",
    "kind": "Method",
    "detail": "Function (LinearMapper r0 = res .)",
    "insertText": "getLinearMapper(i, j2 + 0)"
  },
  {
    "label": "getLinearMapper()",
    "kind": "Method",
    "detail": "Function (LinearMapper r1 = res .)",
    "insertText": "getLinearMapper(i, j2 + 1)"
  },
  {
    "label": "getLinearMapper()",
    "kind": "Method",
    "detail": "Function (LinearMapper r2 = res .)",
    "insertText": "getLinearMapper(i, j2 + 2)"
  },
  {
    "label": "getLinearMapper()",
    "kind": "Method",
    "detail": "Function (LinearMapper r3 = res .)",
    "insertText": "getLinearMapper(i, j2 + 3)"
  },
  {
    "label": "prefetch()",
    "kind": "Method",
    "detail": "Function (r0 .)",
    "insertText": "prefetch(prefetch_res_offset)"
  },
  {
    "label": "prefetch()",
    "kind": "Method",
    "detail": "Function (const RhsScalar* blB =& blockB [ j2* strideB + offsetB* nr ] ;)",
    "insertText": "prefetch(&blB[0])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (LhsPacket A0,A1 ;)",
    "insertText": "for(Index k=0; k<peeled_kc; k+=pk)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin gebp micro kernel 1/half/quarterX4\")"
  },
  {
    "label": "prefetch()",
    "kind": "Method",
    "detail": "Function (RhsPacketx4 rhs_panel ; RhsPacket T0 ;)",
    "insertText": "prefetch(blB+(48+0))"
  },
  {
    "label": "peeled_kc_onestep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "peeled_kc_onestep(0, blA, blB, traits, &A0, &rhs_panel, &T0, &C0, &C1, &C2, &C3)"
  },
  {
    "label": "peeled_kc_onestep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "peeled_kc_onestep(1, blA, blB, traits, &A1, &rhs_panel, &T0, &D0, &D1, &D2, &D3)"
  },
  {
    "label": "peeled_kc_onestep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "peeled_kc_onestep(2, blA, blB, traits, &A0, &rhs_panel, &T0, &C0, &C1, &C2, &C3)"
  },
  {
    "label": "peeled_kc_onestep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "peeled_kc_onestep(3, blA, blB, traits, &A1, &rhs_panel, &T0, &D0, &D1, &D2, &D3)"
  },
  {
    "label": "prefetch()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "prefetch(blB+(48+16))"
  },
  {
    "label": "peeled_kc_onestep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "peeled_kc_onestep(4, blA, blB, traits, &A0, &rhs_panel, &T0, &C0, &C1, &C2, &C3)"
  },
  {
    "label": "peeled_kc_onestep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "peeled_kc_onestep(5, blA, blB, traits, &A1, &rhs_panel, &T0, &D0, &D1, &D2, &D3)"
  },
  {
    "label": "peeled_kc_onestep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "peeled_kc_onestep(6, blA, blB, traits, &A0, &rhs_panel, &T0, &C0, &C1, &C2, &C3)"
  },
  {
    "label": "peeled_kc_onestep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "peeled_kc_onestep(7, blA, blB, traits, &A1, &rhs_panel, &T0, &D0, &D1, &D2, &D3)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (blB + = pk* 4* RhsProgress ; blA + = pk* LhsProgress ;)",
    "insertText": "EIGEN_ASM_COMMENT(\"end gebp micro kernel 1/half/quarterX4\")"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (} C0 =)",
    "insertText": "padd(C0,D0)"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (C1 =)",
    "insertText": "padd(C1,D1)"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (C2 =)",
    "insertText": "padd(C2,D2)"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (C3 =)",
    "insertText": "padd(C3,D3)"
  },
  {
    "label": "ResPacket()",
    "kind": "Method",
    "detail": "Function (blB + = 4* RhsProgress ; blA + = LhsProgress ; } ResPacket R0,R1 ; ResPacket alphav = pset1<)",
    "insertText": "ResPacket(alpha)"
  },
  {
    "label": "ResPacket()",
    "kind": "Method",
    "detail": "Function (R0 = r0 . template loadPacket<)",
    "insertText": "ResPacket(0)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C0, alphav, R0)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C1, alphav, R1)"
  },
  {
    "label": "storePacket()",
    "kind": "Method",
    "detail": "Function (r0 .)",
    "insertText": "storePacket(0, R0)"
  },
  {
    "label": "storePacket()",
    "kind": "Method",
    "detail": "Function (r1 .)",
    "insertText": "storePacket(0, R1)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C2, alphav, R0)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C3, alphav, R1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Index j2=packet_cols4; j2<cols; j2++)"
  },
  {
    "label": "getLinearMapper()",
    "kind": "Method",
    "detail": "Function (LinearMapper r0 = res .)",
    "insertText": "getLinearMapper(i, j2)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const RhsScalar* blB =& blockB [ j2* strideB + offsetB ] ; LhsPacket A0 ;)",
    "insertText": "for(Index k= 0; k<peeled_kc; k+=pk)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin gebp micro kernel 1/half/quarterX1\")"
  },
  {
    "label": "EIGEN_GEBGP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (RhsPacket B_0 ; # define)",
    "insertText": "EIGEN_GEBGP_ONESTEP(K)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin step of gebp micro kernel 1/half/quarterX1\")"
  },
  {
    "label": "loadLhsUnaligned()",
    "kind": "Method",
    "detail": "Function (\\ \\ traits .)",
    "insertText": "loadLhsUnaligned(&blA[(0+1*K)*LhsProgress], A0)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "loadRhs(&blB[(0+K)*RhsProgress], B_0)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A0, B_0, C0, B_0, fix<0>)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_ASM_COMMENT(\"end step of gebp micro kernel 1/half/quarterX1\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(false)"
  },
  {
    "label": "EIGEN_GEBGP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBGP_ONESTEP(0)"
  },
  {
    "label": "EIGEN_GEBGP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBGP_ONESTEP(1)"
  },
  {
    "label": "EIGEN_GEBGP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBGP_ONESTEP(2)"
  },
  {
    "label": "EIGEN_GEBGP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBGP_ONESTEP(3)"
  },
  {
    "label": "EIGEN_GEBGP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBGP_ONESTEP(4)"
  },
  {
    "label": "EIGEN_GEBGP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBGP_ONESTEP(5)"
  },
  {
    "label": "EIGEN_GEBGP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBGP_ONESTEP(6)"
  },
  {
    "label": "EIGEN_GEBGP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBGP_ONESTEP(7)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (blB + = pk* RhsProgress ; blA + = pk* LhsProgress ;)",
    "insertText": "EIGEN_ASM_COMMENT(\"end gebp micro kernel 1/half/quarterX1\")"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(Index k=peeled_kc; k<depth; k++)"
  },
  {
    "label": "peeled_kc_onestep()",
    "kind": "Method",
    "detail": "Function (} } } } ; template<int nr,Index LhsProgress,Index RhsProgress,LhsScalar,RhsScalar,ResScalar,AccPacket,LhsPacket,RhsPacket,ResPacket,GEBPTraits,LinearMapper,DataMapper> struct lhs_process_fraction_of_packet : lhs_process_one_packet<nr,LhsProgress,RhsProgress,LhsScalar,RhsScalar,ResScalar,AccPacket,LhsPacket,RhsPacket,ResPacket,GEBPTraits,LinearMapper,DataMapper> { EIGEN_STRONG_INLINE void)",
    "insertText": "peeled_kc_onestep(Index K, const LhsScalar* blA, const RhsScalar* blB, GEBPTraits traits, LhsPacket *A0, RhsPacket *B_0, RhsPacket *B1, RhsPacket *B2, RhsPacket *B3, AccPacket *C0, AccPacket *C1, AccPacket *C2, AccPacket *C3)"
  },
  {
    "label": "loadLhsUnaligned()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "loadLhsUnaligned(&blA[(0+1*K)*(LhsProgress)], *A0)"
  },
  {
    "label": "broadcastRhs()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "broadcastRhs(&blB[(0+4*K)*RhsProgress], *B_0, *B1, *B2, *B3)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "madd(*A0, *B_0, *C0, *B_0)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "madd(*A0, *B1, *C1, *B1)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "madd(*A0, *B2, *C2, *B2)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "madd(*A0, *B3, *C3, *B3)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<LhsScalar,RhsScalar,Index,DataMapper,int mr,int nr,bool ConjugateLhs,bool ConjugateRhs> EIGEN_DONT_INLINE void gebp_kernel<LhsScalar,RhsScalar,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs)",
    "insertText": "operator()(const DataMapper& res, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha, Index strideA, Index strideB, Index offsetA, Index offsetB)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Traits traits ; SwappedTraits straits ;)",
    "insertText": "if(strideA==-1)"
  },
  {
    "label": "nr()",
    "kind": "Method",
    "detail": "Function (conj_helper<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> cj ; Index packet_cols4 =)",
    "insertText": "nr(cols/4)"
  },
  {
    "label": "LhsProgress()",
    "kind": "Method",
    "detail": "Function (const Index peeled_mc3 = mr> = 3*)",
    "insertText": "LhsProgress(rows/(3*LhsProgress))*(3*LhsProgress)"
  },
  {
    "label": "peeled_mc3()",
    "kind": "Method",
    "detail": "Function (const Index peeled_mc2 = mr> = 2* Traits::LhsProgress ?)",
    "insertText": "peeled_mc3((rows-peeled_mc3)/(2*LhsProgress))*(2*LhsProgress)"
  },
  {
    "label": "peeled_mc2()",
    "kind": "Method",
    "detail": "Function (const Index peeled_mc1 = mr> = 1* Traits::LhsProgress ?)",
    "insertText": "peeled_mc2((rows-peeled_mc2)/(1*LhsProgress))*(1*LhsProgress)"
  },
  {
    "label": "peeled_mc1()",
    "kind": "Method",
    "detail": "Function (const Index peeled_mc_half = mr> = LhsProgressHalf ?)",
    "insertText": "peeled_mc1((rows-peeled_mc1)/(LhsProgressHalf))*(LhsProgressHalf)"
  },
  {
    "label": "peeled_mc_half()",
    "kind": "Method",
    "detail": "Function (const Index peeled_mc_quarter = mr> = LhsProgressQuarter ?)",
    "insertText": "peeled_mc_half((rows-peeled_mc_half)/(LhsProgressQuarter))*(LhsProgressQuarter)"
  },
  {
    "label": "depth()",
    "kind": "Method",
    "detail": "Function (enum { pk = 8 } ; const Index peeled_kc =)",
    "insertText": "depth(pk-1)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const int prefetch_res_offset = 3 2 /)",
    "insertText": "sizeof(ResScalar)"
  },
  {
    "label": "actual_panel_rows()",
    "kind": "Method",
    "detail": "Function (const Index l1 = defaultL1CacheSize ; const Index)",
    "insertText": "actual_panel_rows(3*LhsProgress) * std::max<Index>(1,( (l1 - sizeof(ResScalar)*mr*nr - depth*nr*sizeof(RhsScalar)) / (depth * sizeof(LhsScalar) * 3*LhsProgress) ))"
  },
  {
    "label": "actual_panel_end()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "actual_panel_end(std::min)(i1+actual_panel_rows, peeled_mc3)"
  },
  {
    "label": "offsetA()",
    "kind": "Method",
    "detail": "Function (const LhsScalar* blA =& blockA [ i* strideA +)",
    "insertText": "offsetA(3*LhsProgress)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(C4)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(C5)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(C6)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(C7)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(C8)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(C9)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(C10)"
  },
  {
    "label": "initAcc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "initAcc(C11)"
  },
  {
    "label": "prefetch()",
    "kind": "Method",
    "detail": "Function (r0 .)",
    "insertText": "prefetch(0)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin gebp micro kernel 3pX4\")"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (RhsPanel15 rhs_panel ; RhsPacket T0 ; LhsPacket A2 ; # if EIGEN_COMP_GNUC_STRICT&& EIGEN_ARCH_ARM64&&)",
    "insertText": "defined(EIGEN_VECTORIZE_NEON) && !(EIGEN_GNUC_AT_LEAST(9,0)) #define EIGEN_GEBP_3PX4_REGISTER_ALLOC_WORKAROUND __asm__ (\"\" : \"+w,m\" (A0), \"+w,m\" (A1), \"+w,m\" (A2))"
  },
  {
    "label": "EIGEN_GEBP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (# else # define EIGEN_GEBP_3PX4_REGISTER_ALLOC_WORKAROUND # endif # define)",
    "insertText": "EIGEN_GEBP_ONESTEP(K)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin step of gebp micro kernel 3pX4\")"
  },
  {
    "label": "prefetch()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "prefetch(blA + (3 * K + 16) * LhsProgress)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if(EIGEN_ARCH_ARM || EIGEN_ARCH_MIPS)"
  },
  {
    "label": "prefetch()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "prefetch(blB + (4 * K + 16) * RhsProgress)"
  },
  {
    "label": "loadLhs()",
    "kind": "Method",
    "detail": "Function (\\ } \\ traits .)",
    "insertText": "loadLhs(&blA[(0 + 3 * K) * LhsProgress], A0)"
  },
  {
    "label": "loadLhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "loadLhs(&blA[(1 + 3 * K) * LhsProgress], A1)"
  },
  {
    "label": "loadLhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "loadLhs(&blA[(2 + 3 * K) * LhsProgress], A2)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (\\ EIGEN_GEBP_3PX4_REGISTER_ALLOC_WORKAROUND \\ traits .)",
    "insertText": "loadRhs(blB + (0+4*K) * Traits::RhsProgress, rhs_panel)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A0, rhs_panel, C0, T0, fix<0>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A1, rhs_panel, C4, T0, fix<0>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A2, rhs_panel, C8, T0, fix<0>)"
  },
  {
    "label": "updateRhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "updateRhs(blB + (1+4*K) * Traits::RhsProgress, rhs_panel)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A0, rhs_panel, C1, T0, fix<1>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A1, rhs_panel, C5, T0, fix<1>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A2, rhs_panel, C9, T0, fix<1>)"
  },
  {
    "label": "updateRhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "updateRhs(blB + (2+4*K) * Traits::RhsProgress, rhs_panel)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A0, rhs_panel, C2, T0, fix<2>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A1, rhs_panel, C6, T0, fix<2>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A2, rhs_panel, C10, T0, fix<2>)"
  },
  {
    "label": "updateRhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "updateRhs(blB + (3+4*K) * Traits::RhsProgress, rhs_panel)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A0, rhs_panel, C3, T0, fix<3>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A1, rhs_panel, C7, T0, fix<3>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A2, rhs_panel, C11, T0, fix<3>)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_ASM_COMMENT(\"end step of gebp micro kernel 3pX4\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(false) internal::prefetch(blB)"
  },
  {
    "label": "EIGEN_GEBP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBP_ONESTEP(0)"
  },
  {
    "label": "EIGEN_GEBP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBP_ONESTEP(1)"
  },
  {
    "label": "EIGEN_GEBP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBP_ONESTEP(2)"
  },
  {
    "label": "EIGEN_GEBP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBP_ONESTEP(3)"
  },
  {
    "label": "EIGEN_GEBP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBP_ONESTEP(4)"
  },
  {
    "label": "EIGEN_GEBP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBP_ONESTEP(5)"
  },
  {
    "label": "EIGEN_GEBP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBP_ONESTEP(6)"
  },
  {
    "label": "EIGEN_GEBP_ONESTEP()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_GEBP_ONESTEP(7)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (blB + = pk* 4* RhsProgress ; blA + = pk* 3* Traits::LhsProgress ;)",
    "insertText": "EIGEN_ASM_COMMENT(\"end gebp micro kernel 3pX4\")"
  },
  {
    "label": "ResPacket()",
    "kind": "Method",
    "detail": "Function (R0 = r0 . template loadPacket<)",
    "insertText": "ResPacket(0 * Traits::ResPacketSize)"
  },
  {
    "label": "ResPacket()",
    "kind": "Method",
    "detail": "Function (R1 = r0 . template loadPacket<)",
    "insertText": "ResPacket(1 * Traits::ResPacketSize)"
  },
  {
    "label": "ResPacket()",
    "kind": "Method",
    "detail": "Function (R2 = r0 . template loadPacket<)",
    "insertText": "ResPacket(2 * Traits::ResPacketSize)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C4, alphav, R1)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C8, alphav, R2)"
  },
  {
    "label": "storePacket()",
    "kind": "Method",
    "detail": "Function (r0 .)",
    "insertText": "storePacket(0 * Traits::ResPacketSize, R0)"
  },
  {
    "label": "storePacket()",
    "kind": "Method",
    "detail": "Function (r0 .)",
    "insertText": "storePacket(1 * Traits::ResPacketSize, R1)"
  },
  {
    "label": "storePacket()",
    "kind": "Method",
    "detail": "Function (r0 .)",
    "insertText": "storePacket(2 * Traits::ResPacketSize, R2)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C1, alphav, R0)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C5, alphav, R1)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C9, alphav, R2)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C6, alphav, R1)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C10, alphav, R2)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C3, alphav, R0)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C7, alphav, R1)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C11, alphav, R2)"
  },
  {
    "label": "offsetA()",
    "kind": "Method",
    "detail": "Function (const LhsScalar* blA =& blockA [ i* strideA +)",
    "insertText": "offsetA(3*Traits::LhsProgress)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin gebp micro kernel 3pX1\")"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin step of gebp micro kernel 3pX1\")"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "loadRhs(&blB[(0 + K) * RhsProgress], B_0)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A1, B_0, C4, B_0, fix<0>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A2, B_0, C8, B_0, fix<0>)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_ASM_COMMENT(\"end step of gebp micro kernel 3pX1\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(false) EIGEN_GEBGP_ONESTEP(0)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (blB + =)",
    "insertText": "int(pk) * int(RhsProgress)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (blA + =)",
    "insertText": "int(pk) * 3 * int(Traits::LhsProgress)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"end gebp micro kernel 3pX1\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } })",
    "insertText": "if(mr>=2*Traits::LhsProgress)"
  },
  {
    "label": "actual_panel_rows()",
    "kind": "Method",
    "detail": "Function (const Index l1 = defaultL1CacheSize ; Index)",
    "insertText": "actual_panel_rows(2*LhsProgress) * std::max<Index>(1,( (l1 - sizeof(ResScalar)*mr*nr - depth*nr*sizeof(RhsScalar)) / (depth * sizeof(LhsScalar) * 2*LhsProgress) ))"
  },
  {
    "label": "actual_panel_end()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "actual_panel_end(std::min)(i1+actual_panel_rows, peeled_mc2)"
  },
  {
    "label": "offsetA()",
    "kind": "Method",
    "detail": "Function (const LhsScalar* blA =& blockA [ i* strideA +)",
    "insertText": "offsetA(2*Traits::LhsProgress)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin gebp micro kernel 2pX4\")"
  },
  {
    "label": "EIGEN_GNUC_AT_LEAST()",
    "kind": "Method",
    "detail": "Function (RhsPacketx4 rhs_panel ; RhsPacket T0 ; # if)",
    "insertText": "EIGEN_GNUC_AT_LEAST(6,0) && defined(EIGEN_VECTORIZE_SSE) #define EIGEN_GEBP_2PX4_SPILLING_WORKAROUND __asm__ (\"\" : [a0] \"+x,m\" (A0),[a1] \"+x,m\" (A1))"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin step of gebp micro kernel 2pX4\")"
  },
  {
    "label": "loadLhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "loadLhs(&blA[(0 + 2 * K) * LhsProgress], A0)"
  },
  {
    "label": "loadLhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "loadLhs(&blA[(1 + 2 * K) * LhsProgress], A1)"
  },
  {
    "label": "loadRhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "loadRhs(&blB[(0 + 4 * K) * RhsProgress], rhs_panel)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (\\ EIGEN_GEBP_2PX4_SPILLING_WORKAROUND \\)",
    "insertText": "EIGEN_ASM_COMMENT(\"end step of gebp micro kernel 2pX4\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(false) internal::prefetch(blB+(48+0))"
  },
  {
    "label": "pk()",
    "kind": "Method",
    "detail": "Function (blB + = pk* 4* RhsProgress ; blA + =)",
    "insertText": "pk(2*Traits::LhsProgress)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"end gebp micro kernel 2pX4\")"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C1, alphav, R2)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C5, alphav, R3)"
  },
  {
    "label": "storePacket()",
    "kind": "Method",
    "detail": "Function (r1 .)",
    "insertText": "storePacket(0 * Traits::ResPacketSize, R2)"
  },
  {
    "label": "storePacket()",
    "kind": "Method",
    "detail": "Function (r1 .)",
    "insertText": "storePacket(1 * Traits::ResPacketSize, R3)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C3, alphav, R2)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (traits .)",
    "insertText": "acc(C7, alphav, R3)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin gebp micro kernel 2pX1\")"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_ASM_COMMENT(\"begin step of gebp micro kernel 2pX1\")"
  },
  {
    "label": "loadLhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "loadLhs(&blA[(0+2*K)*LhsProgress], A0)"
  },
  {
    "label": "loadLhs()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "loadLhs(&blA[(1+2*K)*LhsProgress], A1)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (\\ traits .)",
    "insertText": "madd(A0, B_0, C0, B1, fix<0>)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "EIGEN_ASM_COMMENT(\"end step of gebp micro kernel 2pX1\")"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (blA + =)",
    "insertText": "int(pk) * 2 * int(Traits::LhsProgress)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"end gebp micro kernel 2pX1\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } })",
    "insertText": "if(mr>=1*Traits::LhsProgress)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (lhs_process_one_packet<nr,LhsProgress,RhsProgress,LhsScalar,RhsScalar,ResScalar,AccPacket,LhsPacket,RhsPacket,ResPacket,Traits,LinearMapper,DataMapper> p ;)",
    "insertText": "p(res, blockA, blockB, alpha, peeled_mc2, peeled_mc1, strideA, strideB, offsetA, offsetB, prefetch_res_offset, peeled_kc, pk, cols, depth, packet_cols4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((LhsProgressHalf < LhsProgress) && mr>=LhsProgressHalf)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (lhs_process_fraction_of_packet<nr,LhsProgressHalf,RhsProgressHalf,LhsScalar,RhsScalar,ResScalar,AccPacketHalf,LhsPacketHalf,RhsPacketHalf,ResPacketHalf,HalfTraits,LinearMapper,DataMapper> p ;)",
    "insertText": "p(res, blockA, blockB, alpha, peeled_mc1, peeled_mc_half, strideA, strideB, offsetA, offsetB, prefetch_res_offset, peeled_kc, pk, cols, depth, packet_cols4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if((LhsProgressQuarter < LhsProgressHalf) && mr>=LhsProgressQuarter)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (lhs_process_fraction_of_packet<nr,LhsProgressQuarter,RhsProgressQuarter,LhsScalar,RhsScalar,ResScalar,AccPacketQuarter,LhsPacketQuarter,RhsPacketQuarter,ResPacketQuarter,QuarterTraits,LinearMapper,DataMapper> p ;)",
    "insertText": "p(res, blockA, blockB, alpha, peeled_mc_half, peeled_mc_quarter, strideA, strideB, offsetA, offsetB, prefetch_res_offset, peeled_kc, pk, cols, depth, packet_cols4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(peeled_mc_quarter<rows)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const RhsScalar* blB =& blockB [ j2* strideB + offsetB* nr ] ; const int SResPacketHalfSize = unpacket_traits<unpacket_traits<SResPacket>::half>::size ; const int SResPacketQuarterSize = unpacket_traits<unpacket_traits<unpacket_traits<SResPacket>::half>::half>::size ;)",
    "insertText": "if((SwappedTraits::LhsProgress % 4) == 0 && (SwappedTraits::LhsProgress<=16) && (SwappedTraits::LhsProgress!=8 || SResPacketHalfSize==nr) && (SwappedTraits::LhsProgress!=16 || SResPacketQuarterSize==nr))"
  },
  {
    "label": "spk()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "spk(std::max)(1,SwappedTraits::LhsProgress/4)"
  },
  {
    "label": "endk()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "endk(depth/spk)"
  },
  {
    "label": "endk4()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "endk4(depth/(spk*4))*(spk*4)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index k = 0 ;)",
    "insertText": "for(; k<endk4; k+=4*spk)"
  },
  {
    "label": "loadLhsUnaligned()",
    "kind": "Method",
    "detail": "Function (SLhsPacket A0,A1 ; SRhsPacket B_0,B_1 ; straits .)",
    "insertText": "loadLhsUnaligned(blB+0*SwappedTraits::LhsProgress, A0)"
  },
  {
    "label": "loadLhsUnaligned()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "loadLhsUnaligned(blB+1*SwappedTraits::LhsProgress, A1)"
  },
  {
    "label": "loadRhsQuad()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "loadRhsQuad(blA+0*spk, B_0)"
  },
  {
    "label": "loadRhsQuad()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "loadRhsQuad(blA+1*spk, B_1)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "madd(A0,B_0,C0,B_0, fix<0>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "madd(A1,B_1,C1,B_1, fix<0>)"
  },
  {
    "label": "loadLhsUnaligned()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "loadLhsUnaligned(blB+2*SwappedTraits::LhsProgress, A0)"
  },
  {
    "label": "loadLhsUnaligned()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "loadLhsUnaligned(blB+3*SwappedTraits::LhsProgress, A1)"
  },
  {
    "label": "loadRhsQuad()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "loadRhsQuad(blA+2*spk, B_0)"
  },
  {
    "label": "loadRhsQuad()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "loadRhsQuad(blA+3*spk, B_1)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "madd(A0,B_0,C2,B_0, fix<0>)"
  },
  {
    "label": "madd()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "madd(A1,B_1,C3,B_1, fix<0>)"
  },
  {
    "label": "padd()",
    "kind": "Method",
    "detail": "Function (blB + = 4* SwappedTraits::LhsProgress ; blA + = 4* spk ; } C0 =)",
    "insertText": "padd(padd(C0,C1),padd(C2,C3))"
  },
  {
    "label": "loadLhsUnaligned()",
    "kind": "Method",
    "detail": "Function (SLhsPacket A0 ; SRhsPacket B_0 ; straits .)",
    "insertText": "loadLhsUnaligned(blB, A0)"
  },
  {
    "label": "loadRhsQuad()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "loadRhsQuad(blA, B_0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (blB + = SwappedTraits::LhsProgress ; blA + = spk ; })",
    "insertText": "if(SwappedTraits::LhsProgress==8)"
  },
  {
    "label": "SResPacketHalf()",
    "kind": "Method",
    "detail": "Function (typedef conditional<SwappedTraits::LhsProgress> = 8,unpacket_traits<SResPacket>::half,SResPacket>::type SResPacketHalf ; typedef conditional<SwappedTraits::LhsProgress> = 8,unpacket_traits<SLhsPacket>::half,SLhsPacket>::type SLhsPacketHalf ; typedef conditional<SwappedTraits::LhsProgress> = 8,unpacket_traits<SRhsPacket>::half,SRhsPacket>::type SRhsPacketHalf ; typedef conditional<SwappedTraits::LhsProgress> = 8,unpacket_traits<SAccPacket>::half,SAccPacket>::type SAccPacketHalf ; SResPacketHalf R = res . template gatherPacket<)",
    "insertText": "SResPacketHalf(i, j2)"
  },
  {
    "label": "SResPacketHalf()",
    "kind": "Method",
    "detail": "Function (SResPacketHalf alphav = pset1<)",
    "insertText": "SResPacketHalf(alpha)"
  },
  {
    "label": "predux_half_dowto4()",
    "kind": "Method",
    "detail": "Function (SAccPacketHalf c0 =)",
    "insertText": "predux_half_dowto4(C0)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (} else { straits .)",
    "insertText": "acc(predux_half_dowto4(C0), alphav, R)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(SwappedTraits::LhsProgress==16)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (last_row_process_16_packets<LhsScalar,RhsScalar,Index,DataMapper,mr,nr,ConjugateLhs,ConjugateRhs> p ;)",
    "insertText": "p(res, straits, blA, blB, depth, endk, i, j2,alpha, C0)"
  },
  {
    "label": "SResPacket()",
    "kind": "Method",
    "detail": "Function (} else { SResPacket R = res . template gatherPacket<)",
    "insertText": "SResPacket(i, j2)"
  },
  {
    "label": "SResPacket()",
    "kind": "Method",
    "detail": "Function (SResPacket alphav = pset1<)",
    "insertText": "SResPacket(alpha)"
  },
  {
    "label": "acc()",
    "kind": "Method",
    "detail": "Function (straits .)",
    "insertText": "acc(C0, alphav, R)"
  },
  {
    "label": "C0()",
    "kind": "Method",
    "detail": "Function (} } else { ResScalar)",
    "insertText": "C0(0), C1(0), C2(0), C3(0)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (LhsScalar A0 ; RhsScalar B_0,B_1 ; A0 = blA [ k ] ; B_0 = blB [ 0 ] ; B_1 = blB [ 1 ] ; C0 = cj .)",
    "insertText": "pmadd(A0,B_0,C0)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (C1 = cj .)",
    "insertText": "pmadd(A0,B_1,C1)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (B_0 = blB [ 2 ] ; B_1 = blB [ 3 ] ; C2 = cj .)",
    "insertText": "pmadd(A0,B_0,C2)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (C3 = cj .)",
    "insertText": "pmadd(A0,B_1,C3)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (blB + = 4 ; })",
    "insertText": "res(i, j2 + 0)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(i, j2 + 1)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(i, j2 + 2)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "res(i, j2 + 3)"
  },
  {
    "label": "C0()",
    "kind": "Method",
    "detail": "Function (ResScalar)",
    "insertText": "C0(0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const RhsScalar* blB =& blockB [ j2* strideB + offsetB ] ;)",
    "insertText": "for(Index k=0; k<depth; k++)"
  },
  {
    "label": "pmadd()",
    "kind": "Method",
    "detail": "Function (LhsScalar A0 = blA [ k ] ; RhsScalar B_0 = blB [ k ] ; C0 = cj .)",
    "insertText": "pmadd(A0, B_0, C0)"
  },
  {
    "label": "res()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "res(i, j2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } } } template<Scalar,Index,DataMapper,int Pack1,int Pack2,Packet,bool Conjugate,bool PanelMode> struct gemm_pack_lhs<Scalar,Index,DataMapper,Pack1,Pack2,Packet,ColMajor,Conjugate,PanelMode> { typedef DataMapper::LinearMapper LinearMapper ; EIGEN_DONT_INLINE void)",
    "insertText": "operator()(Scalar* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride=0, Index offset=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Scalar,Index,DataMapper,int Pack1,int Pack2,Packet,bool Conjugate,bool PanelMode> EIGEN_DONT_INLINE void gemm_pack_lhs<Scalar,Index,DataMapper,Pack1,Pack2,Packet,ColMajor,Conjugate,PanelMode)",
    "insertText": "operator()(Scalar* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride, Index offset)"
  },
  {
    "label": "HasHalf()",
    "kind": "Method",
    "detail": "Function (typedef unpacket_traits<Packet>::half HalfPacket ; typedef unpacket_traits<unpacket_traits<Packet>::half>::half QuarterPacket ; enum { PacketSize = unpacket_traits<Packet>::size,HalfPacketSize = unpacket_traits<HalfPacket>::size,QuarterPacketSize = unpacket_traits<QuarterPacket>::size,)",
    "insertText": "HasHalf(int)HalfPacketSize < (int)PacketSize, HasQuarter = (int)QuarterPacketSize < (int)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"EIGEN PRODUCT PACK LHS\")"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(stride)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(offset)"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride))"
  },
  {
    "label": "eigen_assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "eigen_assert(((Pack1%PacketSize)==0 && Pack1<=4*PacketSize) || (Pack1<=4))"
  },
  {
    "label": "PacketSize()",
    "kind": "Method",
    "detail": "Function (conj_if<NumTraits<Scalar>::IsComplex&& Conjugate> cj ; Index count = 0 ; const Index peeled_mc3 = Pack1> = 3*)",
    "insertText": "PacketSize(rows/(3*PacketSize))*(3*PacketSize)"
  },
  {
    "label": "peeled_mc3()",
    "kind": "Method",
    "detail": "Function (const Index peeled_mc2 = Pack1> = 2* PacketSize ?)",
    "insertText": "peeled_mc3((rows-peeled_mc3)/(2*PacketSize))*(2*PacketSize)"
  },
  {
    "label": "peeled_mc2()",
    "kind": "Method",
    "detail": "Function (const Index peeled_mc1 = Pack1> = 1* PacketSize ?)",
    "insertText": "peeled_mc2((rows-peeled_mc2)/(1*PacketSize))*(1*PacketSize)"
  },
  {
    "label": "peeled_mc1()",
    "kind": "Method",
    "detail": "Function (const Index peeled_mc_half = Pack1> = HalfPacketSize ?)",
    "insertText": "peeled_mc1((rows-peeled_mc1)/(HalfPacketSize))*(HalfPacketSize)"
  },
  {
    "label": "QuarterPacketSize()",
    "kind": "Method",
    "detail": "Function (const Index peeled_mc_quarter = Pack1> =)",
    "insertText": "QuarterPacketSize(rows/(QuarterPacketSize))*(QuarterPacketSize)"
  },
  {
    "label": "peeled_mc_quarter()",
    "kind": "Method",
    "detail": "Function (const Index last_lhs_progress = rows>)",
    "insertText": "peeled_mc_quarter(rows - peeled_mc_quarter)"
  },
  {
    "label": "last_lhs_progress()",
    "kind": "Method",
    "detail": "Function (const Index peeled_mc0 = Pack2> = PacketSize ? peeled_mc_quarter : Pack2> 1&&)",
    "insertText": "last_lhs_progress(rows/last_lhs_progress)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index i = 0 ;)",
    "insertText": "if(Pack1>=3*PacketSize)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet A,B,C ; A = lhs . template loadPacket<)",
    "insertText": "Packet(i+0*PacketSize, k)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (B = lhs . template loadPacket<)",
    "insertText": "Packet(i+1*PacketSize, k)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (C = lhs . template loadPacket<)",
    "insertText": "Packet(i+2*PacketSize, k)"
  },
  {
    "label": "pstore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstore(blockA+count, cj.pconj(A))"
  },
  {
    "label": "pstore()",
    "kind": "Method",
    "detail": "Function (count + = PacketSize ;)",
    "insertText": "pstore(blockA+count, cj.pconj(B))"
  },
  {
    "label": "pstore()",
    "kind": "Method",
    "detail": "Function (count + = PacketSize ;)",
    "insertText": "pstore(blockA+count, cj.pconj(C))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (count + = PacketSize ; })",
    "insertText": "if(PanelMode) count += (3*PacketSize) * (stride-offset-depth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(Pack1>=2*PacketSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (count + = PacketSize ; })",
    "insertText": "if(PanelMode) count += (2*PacketSize) * (stride-offset-depth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(Pack1>=1*PacketSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (count + = PacketSize ; })",
    "insertText": "if(PanelMode) count += (1*PacketSize) * (stride-offset-depth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(HasHalf && Pack1>=HalfPacketSize)"
  },
  {
    "label": "HalfPacket()",
    "kind": "Method",
    "detail": "Function (HalfPacket A ; A = lhs . template loadPacket<)",
    "insertText": "HalfPacket(i+0*(HalfPacketSize), k)"
  },
  {
    "label": "pstoreu()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstoreu(blockA+count, cj.pconj(A))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (count + = HalfPacketSize ; })",
    "insertText": "if(PanelMode) count += (HalfPacketSize) * (stride-offset-depth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(HasQuarter && Pack1>=QuarterPacketSize)"
  },
  {
    "label": "QuarterPacket()",
    "kind": "Method",
    "detail": "Function (QuarterPacket A ; A = lhs . template loadPacket<)",
    "insertText": "QuarterPacket(i+0*(QuarterPacketSize), k)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (count + = QuarterPacketSize ; })",
    "insertText": "if(PanelMode) count += (QuarterPacketSize) * (stride-offset-depth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(Pack2<PacketSize && Pack2>1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(; i<rows; i++)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (conj_if<NumTraits<Scalar>::IsComplex&& Conjugate> cj ; Index count = 0 ; bool gone_half = false,gone_quarter = false,gone_last = false ; Index i = 0 ; int pack = Pack1 ; int psize = PacketSize ;)",
    "insertText": "while(pack>0)"
  },
  {
    "label": "Pack2()",
    "kind": "Method",
    "detail": "Function (Index remaining_rows = rows - i ; Index peeled_mc = gone_last ?)",
    "insertText": "Pack2(rows/pack)*pack : 0 : i+(remaining_rows/pack)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index starting_pos = i ;)",
    "insertText": "for(; i<peeled_mc; i+=pack)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index k = 0 ;)",
    "insertText": "if(pack>=psize && psize >= QuarterPacketSize)"
  },
  {
    "label": "peeled_k()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "peeled_k(depth/psize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (PacketBlock<Packet> kernel ;)",
    "insertText": "for(int p = 0; p < psize; ++p) kernel.packet[p] = lhs.template loadPacket<Packet>(i+p+m, k)"
  },
  {
    "label": "ptranspose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ptranspose(kernel)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(HasHalf && psize == HalfPacketSize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (gone_half = true ; PacketBlock<HalfPacket> kernel_half ;)",
    "insertText": "for(int p = 0; p < psize; ++p) kernel_half.packet[p] = lhs.template loadPacket<HalfPacket>(i+p+m, k)"
  },
  {
    "label": "ptranspose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ptranspose(kernel_half)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(HasQuarter && psize == QuarterPacketSize)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (gone_quarter = true ; PacketBlock<QuarterPacket> kernel_quarter ;)",
    "insertText": "for(int p = 0; p < psize; ++p) kernel_quarter.packet[p] = lhs.template loadPacket<QuarterPacket>(i+p+m, k)"
  },
  {
    "label": "ptranspose()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ptranspose(kernel_quarter)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } count + = psize* pack ; } })",
    "insertText": "for(; k<depth; k++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index w = 0 ;)",
    "insertText": "for(; w<pack-3; w+=4)"
  },
  {
    "label": "a()",
    "kind": "Method",
    "detail": "Function (Scalar)",
    "insertText": "a(cj(lhs(i+w+0, k))), b(cj(lhs(i+w+1, k))), c(cj(lhs(i+w+2, k))), d(cj(lhs(i+w+3, k)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (blockA [ count + + ] = a ; blockA [ count + + ] = b ; blockA [ count + + ] = c ; blockA [ count + + ] = d ; })",
    "insertText": "if(pack%4) for(;w<pack;++w) blockA[count++] = cj(lhs(i+w, k))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(PanelMode) count += pack * (stride-offset-depth)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} pack - = psize ; Index left = rows - i ;)",
    "insertText": "if(pack <= 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (psize / = 2 ; pack = psize ; continue ; })",
    "insertText": "if(Pack2 < PacketSize && !gone_last)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } template<Scalar,Index,DataMapper,int nr,bool Conjugate,bool PanelMode> struct gemm_pack_rhs<Scalar,Index,DataMapper,nr,ColMajor,Conjugate,PanelMode> { typedef packet_traits<Scalar>::type Packet ; typedef DataMapper::LinearMapper LinearMapper ; enum { PacketSize = packet_traits<Scalar>::size } ; EIGEN_DONT_INLINE void)",
    "insertText": "operator()(Scalar* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride=0, Index offset=0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<Scalar,Index,DataMapper,int nr,bool Conjugate,bool PanelMode> EIGEN_DONT_INLINE void gemm_pack_rhs<Scalar,Index,DataMapper,nr,ColMajor,Conjugate,PanelMode)",
    "insertText": "operator()(Scalar* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride, Index offset)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"EIGEN PRODUCT PACK RHS COLMAJOR\")"
  },
  {
    "label": "nr()",
    "kind": "Method",
    "detail": "Function (conj_if<NumTraits<Scalar>::IsComplex&& Conjugate> cj ; Index packet_cols8 =)",
    "insertText": "nr(cols/8)"
  },
  {
    "label": "peeled_k()",
    "kind": "Method",
    "detail": "Function (Index count = 0 ; const Index)",
    "insertText": "peeled_k(depth/PacketSize)"
  },
  {
    "label": "getLinearMapper()",
    "kind": "Method",
    "detail": "Function (const LinearMapper dm0 = rhs .)",
    "insertText": "getLinearMapper(0, j2 + 0)"
  },
  {
    "label": "getLinearMapper()",
    "kind": "Method",
    "detail": "Function (const LinearMapper dm1 = rhs .)",
    "insertText": "getLinearMapper(0, j2 + 1)"
  },
  {
    "label": "getLinearMapper()",
    "kind": "Method",
    "detail": "Function (const LinearMapper dm2 = rhs .)",
    "insertText": "getLinearMapper(0, j2 + 2)"
  },
  {
    "label": "getLinearMapper()",
    "kind": "Method",
    "detail": "Function (const LinearMapper dm3 = rhs .)",
    "insertText": "getLinearMapper(0, j2 + 3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index k = 0 ;)",
    "insertText": "if((PacketSize%4)==0)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (PacketBlock<)",
    "insertText": "Packet(PacketSize%4)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (kernel . packet [ 0 ] = dm0 . template loadPacket<)",
    "insertText": "Packet(k)"
  },
  {
    "label": "pstoreu()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstoreu(blockB+count+0*PacketSize, cj.pconj(kernel.packet[0]))"
  },
  {
    "label": "pstoreu()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstoreu(blockB+count+1*PacketSize, cj.pconj(kernel.packet[1%PacketSize]))"
  },
  {
    "label": "pstoreu()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstoreu(blockB+count+2*PacketSize, cj.pconj(kernel.packet[2%PacketSize]))"
  },
  {
    "label": "pstoreu()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstoreu(blockB+count+3*PacketSize, cj.pconj(kernel.packet[3%PacketSize]))"
  },
  {
    "label": "cj()",
    "kind": "Method",
    "detail": "Function (blockB [ count + 0 ] =)",
    "insertText": "cj(dm0(k))"
  },
  {
    "label": "cj()",
    "kind": "Method",
    "detail": "Function (blockB [ count + 1 ] =)",
    "insertText": "cj(dm1(k))"
  },
  {
    "label": "cj()",
    "kind": "Method",
    "detail": "Function (blockB [ count + 2 ] =)",
    "insertText": "cj(dm2(k))"
  },
  {
    "label": "cj()",
    "kind": "Method",
    "detail": "Function (blockB [ count + 3 ] =)",
    "insertText": "cj(dm3(k))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (count + = 4 ; })",
    "insertText": "if(PanelMode) count += 4 * (stride-offset-depth)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(Index j2=packet_cols4; j2<cols; ++j2)"
  },
  {
    "label": "getLinearMapper()",
    "kind": "Method",
    "detail": "Function (const LinearMapper dm0 = rhs .)",
    "insertText": "getLinearMapper(0, j2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (count + = 1 ; })",
    "insertText": "if(PanelMode) count += (stride-offset-depth)"
  },
  {
    "label": "EIGEN_ASM_COMMENT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_ASM_COMMENT(\"EIGEN PRODUCT PACK RHS ROWMAJOR\")"
  },
  {
    "label": "HasHalf()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "HasHalf(int)HalfPacketSize < (int)"
  },
  {
    "label": "HasQuarter()",
    "kind": "Method",
    "detail": "Function (const bool)",
    "insertText": "HasQuarter(int)QuarterPacketSize < (int)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Index count = 0 ;)",
    "insertText": "if(nr>=4)"
  },
  {
    "label": "Packet()",
    "kind": "Method",
    "detail": "Function (Packet A = rhs . template loadPacket<)",
    "insertText": "Packet(k, j2)"
  },
  {
    "label": "pstoreu()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pstoreu(blockB+count, cj.pconj(A))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (count + = PacketSize ; } else)",
    "insertText": "if(HasHalf && HalfPacketSize==4)"
  },
  {
    "label": "HalfPacket()",
    "kind": "Method",
    "detail": "Function (HalfPacket A = rhs . template loadPacket<)",
    "insertText": "HalfPacket(k, j2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (count + = HalfPacketSize ; } else)",
    "insertText": "if(HasQuarter && QuarterPacketSize==4)"
  },
  {
    "label": "QuarterPacket()",
    "kind": "Method",
    "detail": "Function (QuarterPacket A = rhs . template loadPacket<)",
    "insertText": "QuarterPacket(k, j2)"
  },
  {
    "label": "getLinearMapper()",
    "kind": "Method",
    "detail": "Function (count + = QuarterPacketSize ; } else { const LinearMapper dm0 = rhs .)",
    "insertText": "getLinearMapper(k, j2)"
  },
  {
    "label": "cj()",
    "kind": "Method",
    "detail": "Function (blockB [ count + 0 ] =)",
    "insertText": "cj(dm0(0))"
  },
  {
    "label": "cj()",
    "kind": "Method",
    "detail": "Function (blockB [ count + 1 ] =)",
    "insertText": "cj(dm0(1))"
  },
  {
    "label": "cj()",
    "kind": "Method",
    "detail": "Function (blockB [ count + 2 ] =)",
    "insertText": "cj(dm0(2))"
  },
  {
    "label": "cj()",
    "kind": "Method",
    "detail": "Function (blockB [ count + 3 ] =)",
    "insertText": "cj(dm0(3))"
  },
  {
    "label": "cj()",
    "kind": "Method",
    "detail": "Function (blockB [ count ] =)",
    "insertText": "cj(rhs(k, j2))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (count + = 1 ; })",
    "insertText": "if(PanelMode)"
  },
  {
    "label": "l1CacheSize()",
    "kind": "Method",
    "detail": "Function (} } } ; } std::ptrdiff_t)",
    "insertText": "l1CacheSize()"
  },
  {
    "label": "manage_caching_sizes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "manage_caching_sizes(SetAction, &l1, &l2, &l3)"
  }
]