[
  {
    "label": "UCurveFloat",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UCurveFloat"
  },
  {
    "label": "UAnimStateTransitionNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimStateTransitionNode"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "FTransitionEvent",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTransitionEvent"
  },
  {
    "label": "FAnimationTransitionRule",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimationTransitionRule"
  },
  {
    "label": "FAnimationStateBase",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimationStateBase"
  },
  {
    "label": "FAnimationState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimationState"
  },
  {
    "label": "FAnimationTransitionBetweenStates",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FAnimationTransitionBetweenStates"
  },
  {
    "label": "FBakedStateExitTransition",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBakedStateExitTransition"
  },
  {
    "label": "FBakedAnimationState",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBakedAnimationState"
  },
  {
    "label": "FBakedAnimationStateMachine",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBakedAnimationStateMachine"
  },
  {
    "label": "UAnimStateMachineTypes",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UAnimStateMachineTypes"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" Stats / Stats . h \" # include \" UObject / ObjectMacros . h \" # include \" UObject / Object . h \" # include \" AlphaBlend . h \" # include \" BlendProfile . h \" # include \" AnimStateMachineTypes . generated . h \" class UCurveFloat ; class UAnimStateTransitionNode ;)",
    "insertText": "UENUM(BlueprintType)"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Shared)",
    "insertText": "UMETA(ToolTip = \"Only one transition can handle this request\"), Unique UMETA(ToolTip = \"Allows multiple transitions to handle the same request\")"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (Append)",
    "insertText": "UMETA(ToolTip = \"This request is added whether or not another with the same name is already queued\"), Ignore UMETA(ToolTip = \"This request is ignored if another request with the same name is already queued\"), Overwrite UMETA(ToolTip = \"This request overwrites another request with the same name if one exists\")"
  },
  {
    "label": "UENUM()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UENUM()"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (enum Type : int { TBM_Linear)",
    "insertText": "UMETA(DisplayName=\"Linear\"), TBM_Cubic UMETA(DisplayName=\"Cubic\")"
  },
  {
    "label": "UMETA()",
    "kind": "Method",
    "detail": "Function (enum Type : int { TLT_StandardBlend)",
    "insertText": "UMETA(DisplayName=\"Standard Blend\"), TLT_Inertialization UMETA(DisplayName = \"Inertialization\"), TLT_Custom UMETA(DisplayName=\"Custom\")"
  },
  {
    "label": "FTransitionEvent()",
    "kind": "Method",
    "detail": "Function (} struct FTransitionEvent { TArray<int32,TInlineAllocator<8>> ConsumedTransitions ; double CreationTime ; double TimeToLive ; FName EventName ; ETransitionRequestQueueMode QueueMode ; ETransitionRequestOverwriteMode OverwriteMode ;)",
    "insertText": "FTransitionEvent(const FName& InEventName, const double InTimeToLive, const ETransitionRequestQueueMode& InQueueMode, const ETransitionRequestOverwriteMode& InOverwriteMode) : TimeToLive(InTimeToLive) , EventName(InEventName) , QueueMode(InQueueMode) , OverwriteMode(InOverwriteMode)"
  },
  {
    "label": "Seconds()",
    "kind": "Method",
    "detail": "Function (CreationTime =)",
    "insertText": "Seconds()"
  },
  {
    "label": "IsValidRequest()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsValidRequest()"
  },
  {
    "label": "HasExpired()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasExpired()"
  },
  {
    "label": "ToBeConsumed()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ToBeConsumed()"
  },
  {
    "label": "ToDebugString()",
    "kind": "Method",
    "detail": "Function (} FString)",
    "insertText": "ToDebugString()"
  },
  {
    "label": "JoinBy()",
    "kind": "Method",
    "detail": "Function (FString HandledByString =*)",
    "insertText": "JoinBy(ConsumedTransitions, TEXT(\", \"), [](const int32& TransitionIndex) { return FString::Printf(TEXT(\"%d\"), TransitionIndex); })"
  },
  {
    "label": "USTRUCT()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "USTRUCT()"
  },
  {
    "label": "GENERATED_USTRUCT_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_USTRUCT_BODY() UPROPERTY()"
  },
  {
    "label": "FAnimationTransitionRule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAnimationTransitionRule() : TransitionReturnVal(true) , TransitionIndex(INDEX_NONE)"
  },
  {
    "label": "FAnimationTransitionRule()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FAnimationTransitionRule(int32 InTransitionState) : TransitionIndex(InTransitionState)"
  },
  {
    "label": "FAnimationStateBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAnimationStateBase()"
  },
  {
    "label": "FAnimationState()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FAnimationState() : FAnimationStateBase() , StateRootNodeIndex(INDEX_NONE) , StartNotify(INDEX_NONE) , EndNotify(INDEX_NONE) , FullyBlendedNotify(INDEX_NONE)"
  },
  {
    "label": "FAnimationTransitionBetweenStates()",
    "kind": "Method",
    "detail": "Function (# if WITH_EDITORONLY_DATA bool ReverseTransition ; # endif)",
    "insertText": "FAnimationTransitionBetweenStates() : FAnimationStateBase() , PreviousState(INDEX_NONE) , NextState(INDEX_NONE) , CrossfadeDuration(0.0f) , StartNotify(INDEX_NONE) , EndNotify(INDEX_NONE) , InterruptNotify(INDEX_NONE) , BlendMode(EAlphaBlendOption::CubicInOut) , CustomCurve(nullptr) , BlendProfile(nullptr) , LogicType(ETransitionLogicType::TLT_StandardBlend) #if WITH_EDITOR , ReverseTransition(false)"
  },
  {
    "label": "FBakedStateExitTransition()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBakedStateExitTransition() : CanTakeDelegateIndex(INDEX_NONE) , CustomResultNodeIndex(INDEX_NONE) , TransitionIndex(INDEX_NONE) , bDesiredTransitionReturnValue(true) , bAutomaticRemainingTimeRule(false) , AutomaticRuleTriggerTime(-1.f) , SyncGroupNameToRequireValidMarkersRule(NAME_None)"
  },
  {
    "label": "FBakedAnimationState()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FBakedAnimationState() : StateRootNodeIndex(INDEX_NONE) , StartNotify(INDEX_NONE) , EndNotify(INDEX_NONE) , FullyBlendedNotify(INDEX_NONE) , bIsAConduit(false) , EntryRuleNodeIndex(INDEX_NONE) , bAlwaysResetOnEntry(false)"
  },
  {
    "label": "STAT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STAT(mutable TStatId StatID;) public: FBakedAnimationStateMachine() : InitialState(INDEX_NONE)"
  },
  {
    "label": "FindStateIndex()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "FindStateIndex(const FName& StateName)"
  },
  {
    "label": "FindTransitionIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "FindTransitionIndex(const FName& InStateNameFrom, const FName& InStateNameTo)"
  },
  {
    "label": "FindTransitionIndex()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "FindTransitionIndex(const int32 InStateIdxFrom, const int32 InStateIdxTo)"
  },
  {
    "label": "GetStatID()",
    "kind": "Method",
    "detail": "Function (# if STATS TStatId)",
    "insertText": "GetStatID()"
  },
  {
    "label": "FStatGroup_STATGROUP_Anim()",
    "kind": "Method",
    "detail": "Function (StatID = FDynamicStats::CreateStatId<)",
    "insertText": "FStatGroup_STATGROUP_Anim(MachineName)"
  },
  {
    "label": "UCLASS()",
    "kind": "Method",
    "detail": "Function (} return StatID ; } # endif } ;)",
    "insertText": "UCLASS()"
  },
  {
    "label": "GENERATED_UCLASS_BODY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GENERATED_UCLASS_BODY()"
  }
]