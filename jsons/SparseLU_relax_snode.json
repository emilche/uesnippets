[
  {
    "label": "relax_snode()",
    "kind": "Method",
    "detail": "Function (# ifndef SPARSELU_RELAX_SNODE_H # define SPARSELU_RELAX_SNODE_H namespace Eigen { namespace internal { template<Scalar,StorageIndex> void SparseLUImpl<Scalar,StorageIndex)",
    "insertText": "relax_snode(const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)"
  },
  {
    "label": "setConstant()",
    "kind": "Method",
    "detail": "Function (Index parent ; relax_end .)",
    "insertText": "setConstant(emptyIdxLU)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (descendants .)",
    "insertText": "setZero()"
  },
  {
    "label": "et()",
    "kind": "Method",
    "detail": "Function (parent =)",
    "insertText": "et(j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} Index snode_start ;)",
    "insertText": "for(Index j = 0; j < n;)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (snode_start = j ;)",
    "insertText": "while(parent != n && descendants(parent) < relax_columns)"
  },
  {
    "label": "relax_end()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "relax_end(snode_start) = StorageIndex(j)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (j + + ;)",
    "insertText": "while(descendants(j) != 0 && j < n)"
  }
]