[
  {
    "label": "Vec3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Vec3"
  },
  {
    "label": "Mat4",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mat4"
  },
  {
    "label": "Quat",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Quat"
  },
  {
    "label": "Mat3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mat3"
  },
  {
    "label": "Mat3()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_MATH_MAT3_H_HAS_BEEN_INCLUDED # define OPENVDB_MATH_MAT3_H_HAS_BEEN_INCLUDED # include<openvdb / Exceptions . h> # include \" Vec3 . h \" # include \" Mat . h \" # include<algorithm> # include<cassert> # include<cmath> # include<iomanip> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace math { template<T> class Vec3 ; template<T> class Mat4 ; template<T> class Quat ; template<T> class Mat3 : public Mat<3,T> { public : using value_type = T ; using ValueType = T ; using MyBase = Mat<3,T> ; # if OPENVDB_ABI_VERSION_NUMBER> = 8)",
    "insertText": "Mat3()"
  },
  {
    "label": "Mat3()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "Mat3(const Mat<3, T> &m)"
  },
  {
    "label": "Mat3()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ i* 3 + j ] = m [ i ] [ j ] ; } } } # endif)",
    "insertText": "Mat3(const Quat<T> &q)"
  },
  {
    "label": "setToRotation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setToRotation(q)"
  },
  {
    "label": "Mat3()",
    "kind": "Method",
    "detail": "Function (} template<Source>)",
    "insertText": "Mat3(Source a, Source b, Source c, Source d, Source e, Source f, Source g, Source h, Source i)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = static_cast<)",
    "insertText": "T(a)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 ] = static_cast<)",
    "insertText": "T(b)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 2 ] = static_cast<)",
    "insertText": "T(c)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 3 ] = static_cast<)",
    "insertText": "T(d)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 4 ] = static_cast<)",
    "insertText": "T(e)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 5 ] = static_cast<)",
    "insertText": "T(f)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 6 ] = static_cast<)",
    "insertText": "T(g)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 7 ] = static_cast<)",
    "insertText": "T(h)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 8 ] = static_cast<)",
    "insertText": "T(i)"
  },
  {
    "label": "Mat3()",
    "kind": "Method",
    "detail": "Function (} template<Source>)",
    "insertText": "Mat3(const Vec3<Source> &v1, const Vec3<Source> &v2, const Vec3<Source> &v3, bool rows = true)"
  },
  {
    "label": "setRows()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setRows(v1, v2, v3)"
  },
  {
    "label": "setColumns()",
    "kind": "Method",
    "detail": "Function (} else { this ->)",
    "insertText": "setColumns(v1, v2, v3)"
  },
  {
    "label": "Mat3()",
    "kind": "Method",
    "detail": "Function (} } template<Source>)",
    "insertText": "Mat3(Source *a)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = static_cast<)",
    "insertText": "T(a[0])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 ] = static_cast<)",
    "insertText": "T(a[1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 2 ] = static_cast<)",
    "insertText": "T(a[2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 3 ] = static_cast<)",
    "insertText": "T(a[3])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 4 ] = static_cast<)",
    "insertText": "T(a[4])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 5 ] = static_cast<)",
    "insertText": "T(a[5])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 6 ] = static_cast<)",
    "insertText": "T(a[6])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 7 ] = static_cast<)",
    "insertText": "T(a[7])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 8 ] = static_cast<)",
    "insertText": "T(a[8])"
  },
  {
    "label": "Mat3()",
    "kind": "Method",
    "detail": "Function (} template<Source>)",
    "insertText": "Mat3(const Mat3<Source> &m)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ i* 3 + j ] = static_cast<)",
    "insertText": "T(m[i][j])"
  },
  {
    "label": "Mat3()",
    "kind": "Method",
    "detail": "Function (} } })",
    "insertText": "Mat3(const Mat4<T> &m)"
  },
  {
    "label": "identity()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ i* 3 + j ] = m [ i ] [ j ] ; } } } const Mat3<T>&)",
    "insertText": "identity()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const Mat3<T> sIdentity = Mat3<)",
    "insertText": "T(1, 0, 0, 0, 1, 0, 0, 0, 1)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const Mat3<T> sZero = Mat3<)",
    "insertText": "T(0, 0, 0, 0, 0, 0, 0, 0, 0)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (int i3 = i* 3 ; MyBase::mm [ i3 + 0 ] = v [ 0 ] ; MyBase::mm [ i3 + 1 ] = v [ 1 ] ; MyBase::mm [ i3 + 2 ] = v [ 2 ] ; } Vec3<T>)",
    "insertText": "row(int i)"
  },
  {
    "label": "setCol()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setCol(int j, const Vec3<T>& v)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 + j ] = v [ 0 ] ; MyBase::mm [ 3 + j ] = v [ 1 ] ; MyBase::mm [ 6 + j ] = v [ 2 ] ; } Vec3<T>)",
    "insertText": "col(int j)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} T&)",
    "insertText": "operator()(int i, int j)"
  },
  {
    "label": "setColumns()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = v1 [ 0 ] ; MyBase::mm [ 1 ] = v1 [ 1 ] ; MyBase::mm [ 2 ] = v1 [ 2 ] ; MyBase::mm [ 3 ] = v2 [ 0 ] ; MyBase::mm [ 4 ] = v2 [ 1 ] ; MyBase::mm [ 5 ] = v2 [ 2 ] ; MyBase::mm [ 6 ] = v3 [ 0 ] ; MyBase::mm [ 7 ] = v3 [ 1 ] ; MyBase::mm [ 8 ] = v3 [ 2 ] ; } void)",
    "insertText": "setColumns(const Vec3<T> &v1, const Vec3<T> &v2, const Vec3<T> &v3)"
  },
  {
    "label": "setSymmetric()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = v1 [ 0 ] ; MyBase::mm [ 1 ] = v2 [ 0 ] ; MyBase::mm [ 2 ] = v3 [ 0 ] ; MyBase::mm [ 3 ] = v1 [ 1 ] ; MyBase::mm [ 4 ] = v2 [ 1 ] ; MyBase::mm [ 5 ] = v3 [ 1 ] ; MyBase::mm [ 6 ] = v1 [ 2 ] ; MyBase::mm [ 7 ] = v2 [ 2 ] ; MyBase::mm [ 8 ] = v3 [ 2 ] ; } void)",
    "insertText": "setSymmetric(const Vec3<T> &vdiag, const Vec3<T> &vtri)"
  },
  {
    "label": "symmetric()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = vdiag [ 0 ] ; MyBase::mm [ 1 ] = vtri [ 0 ] ; MyBase::mm [ 2 ] = vtri [ 1 ] ; MyBase::mm [ 3 ] = vtri [ 0 ] ; MyBase::mm [ 4 ] = vdiag [ 1 ] ; MyBase::mm [ 5 ] = vtri [ 2 ] ; MyBase::mm [ 6 ] = vtri [ 1 ] ; MyBase::mm [ 7 ] = vtri [ 2 ] ; MyBase::mm [ 8 ] = vdiag [ 2 ] ; } Mat3)",
    "insertText": "symmetric(const Vec3<T> &vdiag, const Vec3<T> &vtri)"
  },
  {
    "label": "setSkew()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setSkew(const Vec3<T> &v)"
  },
  {
    "label": "skew()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "skew(v)"
  },
  {
    "label": "setToRotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setToRotation(const Quat<T> &q)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (* this = rotation<Mat3<)",
    "insertText": "T(q)"
  },
  {
    "label": "setToRotation()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setToRotation(const Vec3<T> &axis, T angle)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (* this = rotation<Mat3<)",
    "insertText": "T(axis, angle)"
  },
  {
    "label": "setZero()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setZero()"
  },
  {
    "label": "setIdentity()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = 0 ; MyBase::mm [ 1 ] = 0 ; MyBase::mm [ 2 ] = 0 ; MyBase::mm [ 3 ] = 0 ; MyBase::mm [ 4 ] = 0 ; MyBase::mm [ 5 ] = 0 ; MyBase::mm [ 6 ] = 0 ; MyBase::mm [ 7 ] = 0 ; MyBase::mm [ 8 ] = 0 ; } void)",
    "insertText": "setIdentity()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = 1 ; MyBase::mm [ 1 ] = 0 ; MyBase::mm [ 2 ] = 0 ; MyBase::mm [ 3 ] = 0 ; MyBase::mm [ 4 ] = 1 ; MyBase::mm [ 5 ] = 0 ; MyBase::mm [ 6 ] = 0 ; MyBase::mm [ 7 ] = 0 ; MyBase::mm [ 8 ] = 1 ; } template<Source> const Mat3&)",
    "insertText": "operator(const Mat3<Source> &m)"
  },
  {
    "label": "asPointer()",
    "kind": "Method",
    "detail": "Function (const Source* src = m .)",
    "insertText": "asPointer()"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(src, (src + this->numElements()), MyBase::mm)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Mat3<T>)",
    "insertText": "operator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<S> const Mat3<T>&)",
    "insertText": "operator(S scalar)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ]* = scalar ; MyBase::mm [ 1 ]* = scalar ; MyBase::mm [ 2 ]* = scalar ; MyBase::mm [ 3 ]* = scalar ; MyBase::mm [ 4 ]* = scalar ; MyBase::mm [ 5 ]* = scalar ; MyBase::mm [ 6 ]* = scalar ; MyBase::mm [ 7 ]* = scalar ; MyBase::mm [ 8 ]* = scalar ; return* this ; } template<S> const Mat3<T>&)",
    "insertText": "operator(const Mat3<S> &m1)"
  },
  {
    "label": "m0()",
    "kind": "Method",
    "detail": "Function (Mat3<T>)",
    "insertText": "m0(*this)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 0 ] = static_cast<)",
    "insertText": "T(s0[0] * s1[0] + s0[1] * s1[3] + s0[2] * s1[6])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 1 ] = static_cast<)",
    "insertText": "T(s0[0] * s1[1] + s0[1] * s1[4] + s0[2] * s1[7])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 2 ] = static_cast<)",
    "insertText": "T(s0[0] * s1[2] + s0[1] * s1[5] + s0[2] * s1[8])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 3 ] = static_cast<)",
    "insertText": "T(s0[3] * s1[0] + s0[4] * s1[3] + s0[5] * s1[6])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 4 ] = static_cast<)",
    "insertText": "T(s0[3] * s1[1] + s0[4] * s1[4] + s0[5] * s1[7])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 5 ] = static_cast<)",
    "insertText": "T(s0[3] * s1[2] + s0[4] * s1[5] + s0[5] * s1[8])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 6 ] = static_cast<)",
    "insertText": "T(s0[6] * s1[0] + s0[7] * s1[3] + s0[8] * s1[6])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 7 ] = static_cast<)",
    "insertText": "T(s0[6] * s1[1] + s0[7] * s1[4] + s0[8] * s1[7])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (MyBase::mm [ 8 ] = static_cast<)",
    "insertText": "T(s0[6] * s1[2] + s0[7] * s1[5] + s0[8] * s1[8])"
  },
  {
    "label": "adjoint()",
    "kind": "Method",
    "detail": "Function (} Mat3)",
    "insertText": "adjoint()"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (} Mat3)",
    "insertText": "transpose()"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (} Mat3)",
    "insertText": "inverse(T tolerance = 0)"
  },
  {
    "label": "inv()",
    "kind": "Method",
    "detail": "Function (Mat3<T>)",
    "insertText": "inv(this->adjoint())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const T det = inv . mm [ 0 ]* MyBase::mm [ 0 ] + inv . mm [ 1 ]* MyBase::mm [ 3 ] + inv . mm [ 2 ]* MyBase::mm [ 6 ] ;)",
    "insertText": "if(isApproxEqual(det,T(0.0),tolerance))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ArithmeticError, \"Inversion of singular 3x3 matrix\")"
  },
  {
    "label": "inv()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "inv(T(1)/det)"
  },
  {
    "label": "det()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "det()"
  },
  {
    "label": "trace()",
    "kind": "Method",
    "detail": "Function (const T co00 = MyBase::mm [ 4 ]* MyBase::mm [ 8 ] - MyBase::mm [ 5 ]* MyBase::mm [ 7 ] ; const T co10 = MyBase::mm [ 5 ]* MyBase::mm [ 6 ] - MyBase::mm [ 3 ]* MyBase::mm [ 8 ] ; const T co20 = MyBase::mm [ 3 ]* MyBase::mm [ 7 ] - MyBase::mm [ 4 ]* MyBase::mm [ 6 ] ; return MyBase::mm [ 0 ]* co00 + MyBase::mm [ 1 ]* co10 + MyBase::mm [ 2 ]* co20 ; } T)",
    "insertText": "trace()"
  },
  {
    "label": "transform()",
    "kind": "Method",
    "detail": "Function (} template<T0> Vec3<T0>)",
    "insertText": "transform(const Vec3<T0> &v)"
  },
  {
    "label": "pretransform()",
    "kind": "Method",
    "detail": "Function (} template<T0> Vec3<T0>)",
    "insertText": "pretransform(const Vec3<T0> &v)"
  },
  {
    "label": "timesDiagonal()",
    "kind": "Method",
    "detail": "Function (} Mat3)",
    "insertText": "timesDiagonal(const Vec3<T>& diag)"
  },
  {
    "label": "ret()",
    "kind": "Method",
    "detail": "Function (Mat3)",
    "insertText": "ret(*this)"
  },
  {
    "label": "diag()",
    "kind": "Method",
    "detail": "Function (ret . mm [ 0 ]* =)",
    "insertText": "diag(0)"
  },
  {
    "label": "diag()",
    "kind": "Method",
    "detail": "Function (ret . mm [ 1 ]* =)",
    "insertText": "diag(1)"
  },
  {
    "label": "diag()",
    "kind": "Method",
    "detail": "Function (ret . mm [ 2 ]* =)",
    "insertText": "diag(2)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return true ; } template<T0,T1> bool)",
    "insertText": "operator(const Mat3<T0> &m0, const Mat3<T1> &m1)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<S,T> Mat3<promote<S,T>::type>)",
    "insertText": "operator(S scalar, const Mat3<T> &m)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Mat3<promote<S,T>::type>)",
    "insertText": "result(m)"
  },
  {
    "label": "result()",
    "kind": "Method",
    "detail": "Function (Mat3<promote<T0,T1>::type>)",
    "insertText": "result(m0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (result* = m1 ; return result ; } template<T,MT> Vec3<promote<T,MT>::type>)",
    "insertText": "operator(const Mat3<MT> &_m, const Vec3<T> &_v)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,MT> Vec3<promote<T,MT>::type>)",
    "insertText": "operator(const Vec3<T> &_v, const Mat3<MT> &_m)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<T,MT> Vec3<T>&)",
    "insertText": "operator(Vec3<T> &_v, const Mat3<MT> &_m)"
  },
  {
    "label": "outerProduct()",
    "kind": "Method",
    "detail": "Function (Vec3<T> mult = _v* _m ; _v = mult ; return _v ; } template<T> Mat3<T>)",
    "insertText": "outerProduct(const Vec3<T>& v1, const Vec3<T>& v2)"
  },
  {
    "label": "powLerp()",
    "kind": "Method",
    "detail": "Function (} template<T,T0> Mat3<T>)",
    "insertText": "powLerp(const Mat3<T0> &m1, const Mat3<T0> &m2, T t)"
  },
  {
    "label": "inverse()",
    "kind": "Method",
    "detail": "Function (Mat3<T> x = m1 .)",
    "insertText": "inverse()"
  },
  {
    "label": "powSolve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "powSolve(x, x, t)"
  },
  {
    "label": "pivot()",
    "kind": "Method",
    "detail": "Function (Mat3<T> m = m1* x ; return m ; } namespace mat3_internal { template<T> void)",
    "insertText": "pivot(int i, int j, Mat3<T>& S, Vec3<T>& D, Mat3<T>& Q)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (const int& n = Mat3<T>::size ; T temp ; double cotan_of_2_theta ; double tan_of_theta ; double cosin_of_theta ; double sin_of_theta ; double z ; double Sij =)",
    "insertText": "S(i,j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (tan_of_theta = Sij / Sjj_minus_Sii ; } else { cotan_of_2_theta = 0 . 5* Sjj_minus_Sii / Sij ;)",
    "insertText": "if(cotan_of_2_theta < 0.)"
  },
  {
    "label": "tan_of_theta()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "tan_of_theta(sqrt(1. + cotan_of_2_theta*cotan_of_2_theta) - cotan_of_2_theta)"
  },
  {
    "label": "tan_of_theta()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "tan_of_theta(sqrt(1. + cotan_of_2_theta*cotan_of_2_theta) + cotan_of_2_theta)"
  },
  {
    "label": "sqrt()",
    "kind": "Method",
    "detail": "Function (} } cosin_of_theta = 1 . /)",
    "insertText": "sqrt(1. + tan_of_theta * tan_of_theta)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (D [ i ] - = z ; D [ j ] + = z ;)",
    "insertText": "for(int k = 0; k < i; ++k)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (temp =)",
    "insertText": "S(k,i)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "S(k,i) = cosin_of_theta * temp - sin_of_theta * S(k,j)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "S(k,j)= sin_of_theta * temp + cosin_of_theta * S(k,j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int k = i+1; k < j; ++k)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (temp =)",
    "insertText": "S(i,k)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "S(i,k) = cosin_of_theta * temp - sin_of_theta * S(k,j)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "S(k,j) = sin_of_theta * temp + cosin_of_theta * S(k,j)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int k = j+1; k < n; ++k)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "S(i,k) = cosin_of_theta * temp - sin_of_theta * S(j,k)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "S(j,k) = sin_of_theta * temp + cosin_of_theta * S(j,k)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(int k = 0; k < n; ++k)"
  },
  {
    "label": "Q()",
    "kind": "Method",
    "detail": "Function (temp =)",
    "insertText": "Q(k,i)"
  },
  {
    "label": "Q()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Q(k,i) = cosin_of_theta * temp - sin_of_theta*Q(k,j)"
  },
  {
    "label": "Q()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Q(k,j) = sin_of_theta * temp + cosin_of_theta*Q(k,j)"
  },
  {
    "label": "diagonalizeSymmetricMatrix()",
    "kind": "Method",
    "detail": "Function (} } } template<T> bool)",
    "insertText": "diagonalizeSymmetricMatrix(const Mat3<T>& input, Mat3<T>& Q, Vec3<T>& D, unsigned int MAX_ITERATIONS=250)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (int n = Mat3<T>::size ; Mat3<T>)",
    "insertText": "S(input)"
  },
  {
    "label": "S()",
    "kind": "Method",
    "detail": "Function (D [ i ] =)",
    "insertText": "S(i,i)"
  },
  {
    "label": "iterations()",
    "kind": "Method",
    "detail": "Function (} unsigned int)",
    "insertText": "iterations(0)"
  },
  {
    "label": "fabs()",
    "kind": "Method",
    "detail": "Function (er + =)",
    "insertText": "fabs(S(i,j))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(std::abs(er) < math::Tolerance<T>::value())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(fabs(S(i,j)) > max_element)"
  },
  {
    "label": "pivot()",
    "kind": "Method",
    "detail": "Function (ip = i ; jp = j ; } } })",
    "insertText": "pivot(ip, jp, S, D, Q)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(iterations < MAX_ITERATIONS)"
  },
  {
    "label": "cwiseLessThan()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN* op =* ip + s ; OPENVDB_NO_TYPE_CONVERSION_WARNING_END } return out ; } template<T> bool)",
    "insertText": "cwiseLessThan(const Mat3<T>& m0, const Mat3<T>& m1)"
  },
  {
    "label": "cwiseGreaterThan()",
    "kind": "Method",
    "detail": "Function (} template<T> bool)",
    "insertText": "cwiseGreaterThan(const Mat3<T>& m0, const Mat3<T>& m1)"
  },
  {
    "label": "OPENVDB_IS_POD()",
    "kind": "Method",
    "detail": "Function (} using Mat3s = Mat3<float> ; using Mat3d = Mat3<double> ; using Mat3f = Mat3d ; # if OPENVDB_ABI_VERSION_NUMBER> = 8)",
    "insertText": "OPENVDB_IS_POD(Mat3s) OPENVDB_IS_POD(Mat3d) #endif } template<> inline math::Mat3s zeroVal<math::Mat3s>()"
  },
  {
    "label": "Mat3d()",
    "kind": "Method",
    "detail": "Function (} template<> math::Mat3d zeroVal<)",
    "insertText": "Mat3d()"
  }
]