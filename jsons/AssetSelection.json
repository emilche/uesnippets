[
  {
    "label": "AActor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AActor"
  },
  {
    "label": "FTypedElementHandle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTypedElementHandle"
  },
  {
    "label": "IAssetFactoryInterface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IAssetFactoryInterface"
  },
  {
    "label": "UActorFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UActorFactory"
  },
  {
    "label": "ULevel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ULevel"
  },
  {
    "label": "UMaterialInterface",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UMaterialInterface"
  },
  {
    "label": "AssetMarshalDefs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AssetMarshalDefs"
  },
  {
    "label": "FSelectedActorInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSelectedActorInfo"
  },
  {
    "label": "FActorFactoryAssetProxy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FActorFactoryAssetProxy"
  },
  {
    "label": "FMenuItem",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FMenuItem"
  },
  {
    "label": "FExtraPlaceAssetOptions",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FExtraPlaceAssetOptions"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreMinimal . h \" # include \" AssetRegistry / AssetData . h \" # include \" Input / Reply . h \" class AActor ; struct FTypedElementHandle ; class IAssetFactoryInterface ; class UActorFactory ; class ULevel ; class UMaterialInterface ; class UActorFactory ; struct AssetMarshalDefs { const TCHAR AssetDelimiter =)",
    "insertText": "TEXT('|')"
  },
  {
    "label": "TEXT()",
    "kind": "Method",
    "detail": "Function (const TCHAR NameTypeDelimiter =)",
    "insertText": "TEXT(' ')"
  },
  {
    "label": "FormatName()",
    "kind": "Method",
    "detail": "Function (const TCHAR*)",
    "insertText": "FormatName()"
  },
  {
    "label": "ExtractAssetDataFromDrag()",
    "kind": "Method",
    "detail": "Function (} } ; namespace AssetUtil { TArray<FAssetData>)",
    "insertText": "ExtractAssetDataFromDrag(const FDragDropEvent& DragDropEvent)"
  },
  {
    "label": "ExtractAssetDataFromDrag()",
    "kind": "Method",
    "detail": "Function (TArray<FAssetData>)",
    "insertText": "ExtractAssetDataFromDrag(const TSharedPtr<const FDragDropOperation>& Operation)"
  },
  {
    "label": "GetObjects()",
    "kind": "Method",
    "detail": "Function (TArray<UObject*>)",
    "insertText": "GetObjects(const TArray<FString>& AssetNames, bool* bAllWereLoaded = NULL)"
  },
  {
    "label": "GetObject()",
    "kind": "Method",
    "detail": "Function (UObject*)",
    "insertText": "GetObject(const FString& AssetName)"
  },
  {
    "label": "CanHandleAssetDrag()",
    "kind": "Method",
    "detail": "Function (FReply)",
    "insertText": "CanHandleAssetDrag(const FDragDropEvent &DragDropEvent)"
  },
  {
    "label": "FSelectedActorInfo()",
    "kind": "Method",
    "detail": "Function (} struct FSelectedActorInfo { FString SelectionStr ; UClass* SelectionClass ; ULevel* SharedLevel ; UWorld* SharedWorld ; uint32 NumSelected ; uint32 NumNavPoints ; uint32 NumSelectedUngroupedActors ; uint32 NumSimulationChanges ; uint32 bHaveAttachedActor : 1 ; uint32 bAllSelectedActorsOfSameType : 1 ; uint32 bAllSelectedAreBrushes : 1 ; uint32 bHaveSelectedLockedGroup : 1 ; uint32 bHaveSelectedUnlockedGroup : 1 ; uint32 bHaveSelectedSubGroup : 1 ; uint32 bSelectedActorsBelongToSameLevel : 1 ; uint32 bAllSelectedActorsBelongToCurrentLevel : 1 ; uint32 bAllSelectedActorsBelongToSameWorld : 1 ; uint32 bAllSelectedStaticMeshesHaveCollisionModels : 1 ; uint32 bHaveBrush : 1 ; uint32 bHaveBSPBrush : 1 ; uint32 bHaveVolume : 1 ; uint32 bHaveBuilderBrush : 1 ; uint32 bHaveStaticMeshComponent : 1 ; uint32 bHaveStaticMesh : 1 ; uint32 bHaveLight : 1 ; uint32 bHavePawn : 1 ; uint32 bHaveSkeletalMesh : 1 ; uint32 bHaveEmitter : 1 ; uint32 bHaveHidden : 1 ; uint32 bHaveLandscape : 1 ; uint32 bHaveExperimentalClass : 1 ; uint32 bHaveEarlyAccessClass : 1 ; uint32 bHaveBrowseOverride : 1 ;)",
    "insertText": "FSelectedActorInfo() : SelectionClass(NULL) , SharedLevel(NULL) , SharedWorld(NULL) , NumSelected(0) , NumNavPoints(0) , NumSelectedUngroupedActors(0) , NumSimulationChanges(0) , bHaveAttachedActor(false) , bAllSelectedActorsOfSameType(true) , bAllSelectedAreBrushes(false) , bHaveSelectedLockedGroup(false) , bHaveSelectedUnlockedGroup(false) , bHaveSelectedSubGroup(false) , bSelectedActorsBelongToSameLevel(true) , bAllSelectedActorsBelongToCurrentLevel(true) , bAllSelectedActorsBelongToSameWorld(true) , bAllSelectedStaticMeshesHaveCollisionModels(true) , bHaveBrush(false) , bHaveBSPBrush(false) , bHaveVolume(false) , bHaveBuilderBrush(false) , bHaveStaticMeshComponent(false) , bHaveStaticMesh(false) , bHaveLight(false) , bHavePawn(false) , bHaveSkeletalMesh(false) , bHaveEmitter(false) , bHaveHidden(false) , bHaveLandscape(false) , bHaveExperimentalClass(false) , bHaveEarlyAccessClass(false) , bHaveBrowseOverride(false)"
  },
  {
    "label": "HasConvertableAsset()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasConvertableAsset()"
  },
  {
    "label": "IsChildBlueprintPlaceable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsChildBlueprintPlaceable(const UClass* Class)"
  },
  {
    "label": "GetSelectedAssets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetSelectedAssets(TArray<FAssetData>& OutSelectedAssets)"
  },
  {
    "label": "BuildSelectedActorInfo()",
    "kind": "Method",
    "detail": "Function (FSelectedActorInfo)",
    "insertText": "BuildSelectedActorInfo(const TArray<AActor*>& SelectedActors)"
  },
  {
    "label": "GetSelectedActorInfo()",
    "kind": "Method",
    "detail": "Function (FSelectedActorInfo)",
    "insertText": "GetSelectedActorInfo()"
  },
  {
    "label": "GetNumSelectedSurfaces()",
    "kind": "Method",
    "detail": "Function (int32)",
    "insertText": "GetNumSelectedSurfaces(UWorld* InWorld)"
  },
  {
    "label": "IsAnySurfaceSelected()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsAnySurfaceSelected(UWorld* InWorld)"
  },
  {
    "label": "IsBuilderBrushSelected()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsBuilderBrushSelected()"
  },
  {
    "label": "IsLevelValidForActorPlacement()",
    "kind": "Method",
    "detail": "Function (} ; namespace ActorPlacementUtils { bool)",
    "insertText": "IsLevelValidForActorPlacement(ULevel* Level, TArray<FTransform>& InActorTransforms)"
  },
  {
    "label": "FMenuItem()",
    "kind": "Method",
    "detail": "Function (} class FActorFactoryAssetProxy { public : struct FMenuItem { UActorFactory* FactoryToUse ; FAssetData AssetData ;)",
    "insertText": "FMenuItem(UActorFactory* InFactoryToUse, const FAssetData& InAssetData ) : FactoryToUse( InFactoryToUse ) , AssetData( InAssetData)"
  },
  {
    "label": "GenerateActorFactoryMenuItems()",
    "kind": "Method",
    "detail": "Function (} } ; void)",
    "insertText": "GenerateActorFactoryMenuItems(const FAssetData& AssetData, TArray<FMenuItem>* OutMenuItems, bool ExcludeStandAloneFactories)"
  },
  {
    "label": "GetFactoryForAsset()",
    "kind": "Method",
    "detail": "Function (UActorFactory*)",
    "insertText": "GetFactoryForAsset(const FAssetData& DropData, bool bRequireValidObject=false)"
  },
  {
    "label": "GetFactoryForAssetObject()",
    "kind": "Method",
    "detail": "Function (UActorFactory*)",
    "insertText": "GetFactoryForAssetObject(UObject* AssetObj)"
  },
  {
    "label": "AddActorForAsset()",
    "kind": "Method",
    "detail": "Function (AActor*)",
    "insertText": "AddActorForAsset(UObject* AssetObj, bool SelectActor = true, EObjectFlags ObjectFlags = RF_Transactional, UActorFactory* FactoryToUse = NULL, const FName Name = NAME_None)"
  },
  {
    "label": "AddActorFromSelection()",
    "kind": "Method",
    "detail": "Function (AActor*)",
    "insertText": "AddActorFromSelection(UClass* ActorClass, const FVector* ActorLocation=NULL, bool SelectActor = true, EObjectFlags ObjectFlags = RF_Transactional, UActorFactory* ActorFactory = NULL, const FName Name = NAME_None)"
  },
  {
    "label": "IsActorValidForMaterialApplication()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsActorValidForMaterialApplication(AActor* TargetActor)"
  },
  {
    "label": "ApplyMaterialToActor()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ApplyMaterialToActor(AActor* TargetActor, UMaterialInterface* MaterialToApply, int32 OptionalMaterialSlot = -1)"
  },
  {
    "label": "FActorFactoryAssetProxy()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "FActorFactoryAssetProxy()"
  },
  {
    "label": "PlaceAssetInCurrentLevel()",
    "kind": "Method",
    "detail": "Function (} } ; namespace UE::AssetPlacementUtil { struct FExtraPlaceAssetOptions { bool bSelectOutput = true ; EObjectFlags ObjectFlags = RF_Transactional ; TScriptInterface<IAssetFactoryInterface> FactoryToUse = NULL ; FName Name = NAME_None ; } ; TArray<FTypedElementHandle>)",
    "insertText": "PlaceAssetInCurrentLevel(UObject* AssetObj, const FExtraPlaceAssetOptions& ExtraParams)"
  }
]