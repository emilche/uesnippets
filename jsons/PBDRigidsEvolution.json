[
  {
    "label": "FBroadPhaseConfig",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBroadPhaseConfig"
  },
  {
    "label": "FChaosArchive",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosArchive"
  },
  {
    "label": "ISpatialAccelerationCollection",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ISpatialAccelerationCollection"
  },
  {
    "label": "FEvolutionStats",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEvolutionStats"
  },
  {
    "label": "FSpatialAccelerationCacheHandle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FSpatialAccelerationCacheHandle"
  },
  {
    "label": "FSpatialAccelerationCache",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSpatialAccelerationCache"
  },
  {
    "label": "ISpatialAccelerationCollectionFactory",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ISpatialAccelerationCollectionFactory"
  },
  {
    "label": "FPBDRigidsEvolutionBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPBDRigidsEvolutionBase"
  },
  {
    "label": "FChaosAccelerationStructureTask",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FChaosAccelerationStructureTask"
  },
  {
    "label": "FTestModeParticleData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTestModeParticleData"
  },
  {
    "label": "CHAOS_EVOLUTION_COLLISION_TESTMODE()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / Character / CharacterGroundConstraintContainer . h \" # include \" Chaos / PBDCollisionConstraints . h \" # include \" Chaos / PBDRigidClustering . h \" # include \" Chaos / PBDRigidParticles . h \" # include \" Chaos / ParticleHandle . h \" # include \" Chaos / Transform . h \" # include \" Chaos / Framework / DebugSubstep . h \" # include \" HAL / Event . h \" # include \" Chaos / PBDJointConstraints . h \" # include \" Chaos / PBDRigidsSOAs . h \" # include \" Chaos / SpatialAccelerationCollection . h \" # include \" Chaos / PBDRigidsEvolutionFwd . h \" # include \" Chaos / Island / IslandManager . h \" # include \" Chaos / Island / IslandGroupManager . h \" # include \" Chaos / Defines . h \" # include \" Chaos / PendingSpatialData . h \" # include \" ProfilingDebugging / CsvProfiler . h \" # include \" RewindData . h \" # include \" ChaosVisualDebugger / ChaosVDContextProvider . h \" # define)",
    "insertText": "CHAOS_EVOLUTION_COLLISION_TESTMODE(!UE_BUILD_TEST && !UE_BUILD_SHIPPING)"
  },
  {
    "label": "FBroadPhaseConfig()",
    "kind": "Method",
    "detail": "Function (int32 ChaosRigidsEvolutionApplyPushoutAllowEarlyOutCVar ; int32 ChaosNumPushOutIterationsOverride ; int32 ChaosNumContactIterationsOverride ; namespace Chaos { int32 ForceNoCollisionIntoSQ ; struct FBroadPhaseConfig { enum { Grid = 0,Tree = 1,TreeOfGrid = 2,TreeAndGrid = 3,TreeOfGridAndGrid = 4 } ; int32 BroadphaseType ; int32 BVNumCells ; int32 MaxChildrenInLeaf ; int32 MaxTreeDepth ; int32 AABBMaxChildrenInLeaf ; int32 AABBMaxTreeDepth ; FRealSingle MaxPayloadSize ; int32 IterationsPerTimeSlice ;)",
    "insertText": "FBroadPhaseConfig()"
  },
  {
    "label": "FEvolutionStats()",
    "kind": "Method",
    "detail": "Function (BroadphaseType = Tree ; BVNumCells = 3 5 ; MaxChildrenInLeaf = 5 ; MaxTreeDepth = 2 0 0 ; AABBMaxChildrenInLeaf = 5 0 0 ; AABBMaxTreeDepth = 2 0 0 ; MaxPayloadSize = 1 0 0 0 0 0 ; IterationsPerTimeSlice = 4 0 0 0 ; } } ; FBroadPhaseConfig BroadPhaseConfig ; int32 FixBadAccelerationStructureRemoval ; class FChaosArchive ; template<TPayload,T,int d> class ISpatialAccelerationCollection ; struct FEvolutionStats { int32 ActiveCollisionPoints ; int32 ActiveShapes ; int32 ShapesForAllConstraints ; int32 CollisionPointsForAllConstraints ;)",
    "insertText": "FEvolutionStats()"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Reset()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ActiveCollisionPoints = 0 ; ActiveShapes = 0 ; ShapesForAllConstraints = 0 ; CollisionPointsForAllConstraints = 0 ; } FEvolutionStats&)",
    "insertText": "operator(const FEvolutionStats& Other)"
  },
  {
    "label": "FSpatialAccelerationCache()",
    "kind": "Method",
    "detail": "Function (ActiveCollisionPoints + = Other . ActiveCollisionPoints ; ActiveShapes + = Other . ActiveShapes ; ShapesForAllConstraints + = Other . ShapesForAllConstraints ; CollisionPointsForAllConstraints + = Other . CollisionPointsForAllConstraints ; return* this ; } } ; struct FSpatialAccelerationCacheHandle ; class FSpatialAccelerationCache : public TArrayCollection { public : using THandleType = FSpatialAccelerationCacheHandle ;)",
    "insertText": "FSpatialAccelerationCache()"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MHasBoundingBoxes)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MBounds)"
  },
  {
    "label": "AddArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddArray(&MPayloads)"
  },
  {
    "label": "FSpatialAccelerationCache()",
    "kind": "Method",
    "detail": "Function (# if PARTICLE_ITERATOR_RANGED_FOR_CHECK MDirtyValidationCount = 0 ; # endif })",
    "insertText": "FSpatialAccelerationCache(const FSpatialAccelerationCache&)"
  },
  {
    "label": "FSpatialAccelerationCache()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FSpatialAccelerationCache(FSpatialAccelerationCache&& Other) : TArrayCollection() , MHasBoundingBoxes(MoveTemp(Other.MHasBoundingBoxes)) , MBounds(MoveTemp(Other.MBounds)) , MPayloads(MoveTemp(Other.MPayloads))"
  },
  {
    "label": "ResizeHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ResizeHelper(Other.MSize)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# if PARTICLE_ITERATOR_RANGED_FOR_CHECK MDirtyValidationCount = 0 ; # endif } FSpatialAccelerationCache&)",
    "insertText": "operator(FSpatialAccelerationCache&& Other)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MHasBoundingBoxes =)",
    "insertText": "MoveTemp(Other.MHasBoundingBoxes)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MBounds =)",
    "insertText": "MoveTemp(Other.MBounds)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (MPayloads =)",
    "insertText": "MoveTemp(Other.MPayloads)"
  },
  {
    "label": "DirtyValidationCount()",
    "kind": "Method",
    "detail": "Function (Other . MSize = 0 ; # if PARTICLE_ITERATOR_RANGED_FOR_CHECK MDirtyValidationCount = 0 ; + + Other . MDirtyValidationCount ; # endif } return* this ; } # if PARTICLE_ITERATOR_RANGED_FOR_CHECK int32)",
    "insertText": "DirtyValidationCount()"
  },
  {
    "label": "AddElementsHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AddElementsHelper(Num)"
  },
  {
    "label": "IncrementDirtyValidation()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IncrementDirtyValidation()"
  },
  {
    "label": "DestroyElement()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DestroyElement(const int32 Idx)"
  },
  {
    "label": "RemoveAtSwapHelper()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveAtSwapHelper(Idx)"
  },
  {
    "label": "HasBounds()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasBounds(const int32 Idx)"
  },
  {
    "label": "FSpatialAccelerationCacheHandle()",
    "kind": "Method",
    "detail": "Function (# if PARTICLE_ITERATOR_RANGED_FOR_CHECK + + MDirtyValidationCount ; # endif } TArrayCollectionArray<bool> MHasBoundingBoxes ; TArrayCollectionArray<FAABB3> MBounds ; TArrayCollectionArray<FAccelerationStructureHandle> MPayloads ; # if PARTICLE_ITERATOR_RANGED_FOR_CHECK int32 MDirtyValidationCount ; # endif } ; struct FSpatialAccelerationCacheHandle { using THandleBase = FSpatialAccelerationCacheHandle ; using TTransientHandle = FSpatialAccelerationCacheHandle ;)",
    "insertText": "FSpatialAccelerationCacheHandle(FSpatialAccelerationCache* InCache = nullptr, int32 InEntryIdx = INDEX_NONE) : Cache(InCache) , EntryIdx(InEntryIdx)"
  },
  {
    "label": "GetPayload()",
    "kind": "Method",
    "detail": "Function (} template<TPayloadType> TPayloadType)",
    "insertText": "GetPayload(int32 Idx)"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasBoundingBox()"
  },
  {
    "label": "BoundingBox()",
    "kind": "Method",
    "detail": "Function (} const FAABB3&)",
    "insertText": "BoundingBox()"
  },
  {
    "label": "LightWeightDisabled()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "LightWeightDisabled()"
  },
  {
    "label": "IsBucketTimeSliced()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsBucketTimeSliced(uint16 BucketIdx)"
  },
  {
    "label": "CreateAccelerationPerBucket_Threaded()",
    "kind": "Method",
    "detail": "Function (TUniquePtr<ISpatialAcceleration<FAccelerationStructureHandle,FReal,3>>)",
    "insertText": "CreateAccelerationPerBucket_Threaded(const TConstParticleView<FSpatialAccelerationCache>& Particles, uint16 BucketIdx, bool ForceFullBuild, bool bDynamicTree, bool bBuildOverlapCache)"
  },
  {
    "label": "GetActiveBucketsMask()",
    "kind": "Method",
    "detail": "Function (uint8)",
    "insertText": "GetActiveBucketsMask()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Serialize(TUniquePtr<ISpatialAccelerationCollection<FAccelerationStructureHandle, FReal, 3>>& Ptr, FChaosArchive& Ar)"
  },
  {
    "label": "ISpatialAccelerationCollectionFactory()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "ISpatialAccelerationCollectionFactory()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} ; class FPBDRigidsEvolutionBase { public : using FAccelerationStructure = ISpatialAccelerationCollection<FAccelerationStructureHandle,FReal,3> ; typedef TFunction<)",
    "insertText": "void(TTransientPBDRigidParticleHandle<FReal, 3>& Particle, const FReal)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef TFunction<)",
    "insertText": "void(const TArray<FGeometryParticleHandle*>&, const FReal)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef TFunction<)",
    "insertText": "void(const TParticleView<FPBDRigidParticles>&, const FReal)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef TFunction<)",
    "insertText": "void(FPBDRigidParticles&, const FReal, const FReal, const int32)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (typedef TFunction<)",
    "insertText": "void(TParticleView<FPBDRigidParticles>&)"
  },
  {
    "label": "FPBDRigidsEvolutionBase()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPBDRigidsEvolutionBase(FPBDRigidsSOAs& InParticles, THandleArray<FChaosPhysicsMaterial>& InSolverPhysicsMaterials, bool InIsSingleThreaded = false)"
  },
  {
    "label": "FPBDRigidsEvolutionBase()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FPBDRigidsEvolutionBase()"
  },
  {
    "label": "CreateStaticParticles()",
    "kind": "Method",
    "detail": "Function (TArray<FGeometryParticleHandle*>)",
    "insertText": "CreateStaticParticles(int32 NumParticles, const FUniqueIdx* ExistingIndices = nullptr, const FGeometryParticleParameters& Params = FGeometryParticleParameters())"
  },
  {
    "label": "CreateStaticParticles()",
    "kind": "Method",
    "detail": "Function (auto NewParticles = Particles .)",
    "insertText": "CreateStaticParticles(NumParticles, ExistingIndices, Params)"
  },
  {
    "label": "DirtyParticle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DirtyParticle(*Particle)"
  },
  {
    "label": "CreateKinematicParticles()",
    "kind": "Method",
    "detail": "Function (} return NewParticles ; } TArray<FKinematicGeometryParticleHandle*>)",
    "insertText": "CreateKinematicParticles(int32 NumParticles, const FUniqueIdx* ExistingIndices = nullptr, const FKinematicGeometryParticleParameters& Params = FKinematicGeometryParticleParameters())"
  },
  {
    "label": "CreateKinematicParticles()",
    "kind": "Method",
    "detail": "Function (auto NewParticles = Particles .)",
    "insertText": "CreateKinematicParticles(NumParticles, ExistingIndices, Params)"
  },
  {
    "label": "CreateDynamicParticles()",
    "kind": "Method",
    "detail": "Function (} return NewParticles ; } TArray<FPBDRigidParticleHandle*>)",
    "insertText": "CreateDynamicParticles(int32 NumParticles, const FUniqueIdx* ExistingIndices = nullptr, const FPBDRigidParticleParameters& Params = FPBDRigidParticleParameters())"
  },
  {
    "label": "CreateDynamicParticles()",
    "kind": "Method",
    "detail": "Function (auto NewParticles = Particles .)",
    "insertText": "CreateDynamicParticles(NumParticles, ExistingIndices, Params)"
  },
  {
    "label": "CreateClusteredParticles()",
    "kind": "Method",
    "detail": "Function (} return NewParticles ; } TArray<TPBDRigidClusteredParticleHandle<FReal,3>*>)",
    "insertText": "CreateClusteredParticles(int32 NumParticles,const FUniqueIdx* ExistingIndices = nullptr, const FPBDRigidParticleParameters& Params = FPBDRigidParticleParameters())"
  },
  {
    "label": "CreateClusteredParticles()",
    "kind": "Method",
    "detail": "Function (auto NewParticles = Particles .)",
    "insertText": "CreateClusteredParticles(NumParticles, ExistingIndices, Params)"
  },
  {
    "label": "CreateGeometryCollectionParticles()",
    "kind": "Method",
    "detail": "Function (} return NewParticles ; } TArray<TPBDGeometryCollectionParticleHandle<FReal,3>*>)",
    "insertText": "CreateGeometryCollectionParticles(int32 NumParticles,const FUniqueIdx* ExistingIndices = nullptr, const FPBDRigidParticleParameters& Params = FPBDRigidParticleParameters())"
  },
  {
    "label": "CreateGeometryCollectionParticles()",
    "kind": "Method",
    "detail": "Function (auto NewParticles = Particles .)",
    "insertText": "CreateGeometryCollectionParticles(NumParticles, ExistingIndices, Params)"
  },
  {
    "label": "AddForceFunction()",
    "kind": "Method",
    "detail": "Function (} return NewParticles ; } void)",
    "insertText": "AddForceFunction(FForceRule ForceFunction)"
  },
  {
    "label": "AddImpulseFunction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddImpulseFunction(FForceRule ImpulseFunction)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (ImpulseRules .)",
    "insertText": "Add(ImpulseFunction)"
  },
  {
    "label": "SetParticleUpdatePositionFunction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetParticleUpdatePositionFunction(FUpdatePositionRule ParticleUpdate)"
  },
  {
    "label": "SetCaptureRewindDataFunction()",
    "kind": "Method",
    "detail": "Function (ParticleUpdatePosition = ParticleUpdate ; } void)",
    "insertText": "SetCaptureRewindDataFunction(FCaptureRewindRule Rule)"
  },
  {
    "label": "GetParticleHandles()",
    "kind": "Method",
    "detail": "Function (CaptureRewindData = Rule ; } TGeometryParticleHandles<FReal,3>&)",
    "insertText": "GetParticleHandles()"
  },
  {
    "label": "GetParticles()",
    "kind": "Method",
    "detail": "Function (} FPBDRigidsSOAs&)",
    "insertText": "GetParticles()"
  },
  {
    "label": "AddConstraintContainer()",
    "kind": "Method",
    "detail": "Function (} ; void)",
    "insertText": "AddConstraintContainer(FPBDConstraintContainer& InContainer, const int32 Priority = 0)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (const int32 ContainerId = ConstraintContainers .)",
    "insertText": "Add(&InContainer)"
  },
  {
    "label": "SetContainerId()",
    "kind": "Method",
    "detail": "Function (InContainer .)",
    "insertText": "SetContainerId(ContainerId)"
  },
  {
    "label": "GetIslandManager()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetIslandManager().AddConstraintContainer(InContainer)"
  },
  {
    "label": "AddConstraintContainer()",
    "kind": "Method",
    "detail": "Function (IslandGroupManager .)",
    "insertText": "AddConstraintContainer(InContainer, Priority)"
  },
  {
    "label": "SetNumPositionIterations()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetNumPositionIterations(int32 InNumIterations)"
  },
  {
    "label": "SetNumPositionIterations()",
    "kind": "Method",
    "detail": "Function (IslandGroupManager .)",
    "insertText": "SetNumPositionIterations(InNumIterations)"
  },
  {
    "label": "GetNumPositionIterations()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetNumPositionIterations()"
  },
  {
    "label": "SetNumVelocityIterations()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetNumVelocityIterations(int32 InNumIterations)"
  },
  {
    "label": "SetNumVelocityIterations()",
    "kind": "Method",
    "detail": "Function (IslandGroupManager .)",
    "insertText": "SetNumVelocityIterations(InNumIterations)"
  },
  {
    "label": "GetNumVelocityIterations()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetNumVelocityIterations()"
  },
  {
    "label": "SetNumProjectionIterations()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetNumProjectionIterations(int32 InNumIterations)"
  },
  {
    "label": "SetNumProjectionIterations()",
    "kind": "Method",
    "detail": "Function (IslandGroupManager .)",
    "insertText": "SetNumProjectionIterations(InNumIterations)"
  },
  {
    "label": "GetNumProjectionIterations()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "GetNumProjectionIterations()"
  },
  {
    "label": "RegisterParticle()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "RegisterParticle(FGeometryParticleHandle* Particle)"
  },
  {
    "label": "AddParticle()",
    "kind": "Method",
    "detail": "Function (IslandManager .)",
    "insertText": "AddParticle(Particle)"
  },
  {
    "label": "CVD_TRACE_PARTICLE()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "CVD_TRACE_PARTICLE(Particle)"
  },
  {
    "label": "EnableParticle()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EnableParticle(FGeometryParticleHandle* Particle)"
  },
  {
    "label": "EnableParticle()",
    "kind": "Method",
    "detail": "Function (Particles .)",
    "insertText": "EnableParticle(Particle)"
  },
  {
    "label": "EnableConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EnableConstraints(Particle)"
  },
  {
    "label": "DirtyParticle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DirtyParticle(*Particle, EPendingSpatialDataOperation::Add)"
  },
  {
    "label": "DisableParticle()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DisableParticle(FGeometryParticleHandle* Particle)"
  },
  {
    "label": "TestModeParticleDisabled()",
    "kind": "Method",
    "detail": "Function (# if CHAOS_EVOLUTION_COLLISION_TESTMODE)",
    "insertText": "TestModeParticleDisabled(Particle)"
  },
  {
    "label": "RemoveParticle()",
    "kind": "Method",
    "detail": "Function (# endif IslandManager .)",
    "insertText": "RemoveParticle(Particle)"
  },
  {
    "label": "RemoveParticleFromAccelerationStructure()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveParticleFromAccelerationStructure(*Particle)"
  },
  {
    "label": "DisableParticle()",
    "kind": "Method",
    "detail": "Function (Particles .)",
    "insertText": "DisableParticle(Particle)"
  },
  {
    "label": "DisableConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisableConstraints(Particle)"
  },
  {
    "label": "DestroyTransientConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DestroyTransientConstraints(Particle)"
  },
  {
    "label": "ClearIsMovingKinematic()",
    "kind": "Method",
    "detail": "Function (Rigid ->)",
    "insertText": "ClearIsMovingKinematic()"
  },
  {
    "label": "InvalidateParticle()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "InvalidateParticle(FGeometryParticleHandle* Particle)"
  },
  {
    "label": "RemoveParticleConstraints()",
    "kind": "Method",
    "detail": "Function (IslandManager .)",
    "insertText": "RemoveParticleConstraints(Particle)"
  },
  {
    "label": "FlushExternalAccelerationQueue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FlushExternalAccelerationQueue(FAccelerationStructure& Acceleration,FPendingSpatialDataQueue& ExternalQueue)"
  },
  {
    "label": "DisableParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisableParticles(TSet<FGeometryParticleHandle*> &ParticlesIn)"
  },
  {
    "label": "DirtyParticle()",
    "kind": "Method",
    "detail": "Function (} } template<bool bPersistent> void)",
    "insertText": "DirtyParticle(TGeometryParticleHandleImp<FReal, 3, bPersistent>& Particle, const EPendingSpatialDataOperation Op = EPendingSpatialDataOperation::Update)"
  },
  {
    "label": "CastToRigidParticle()",
    "kind": "Method",
    "detail": "Function (const TPBDRigidParticleHandleImp<FReal,3,bPersistent>* AsRigid = Particle .)",
    "insertText": "CastToRigidParticle()"
  },
  {
    "label": "CastToClustered()",
    "kind": "Method",
    "detail": "Function (TPBDRigidClusteredParticleHandleImp<FReal,3,bPersistent>* AsClustered = Particle .)",
    "insertText": "CastToClustered()"
  },
  {
    "label": "UniqueIdx()",
    "kind": "Method",
    "detail": "Function (const FUniqueIdx UniqueIdx = Particle .)",
    "insertText": "UniqueIdx()"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (FPendingSpatialData& SpatialData = InternalAccelerationQueue .)",
    "insertText": "FindOrAdd(UniqueIdx)"
  },
  {
    "label": "FAccelerationStructureHandle()",
    "kind": "Method",
    "detail": "Function (SpatialData . Operation = Op ; SpatialData . AccelerationHandle =)",
    "insertText": "FAccelerationStructureHandle(Particle)"
  },
  {
    "label": "SpatialIdx()",
    "kind": "Method",
    "detail": "Function (SpatialData . SpatialIdx = Particle .)",
    "insertText": "SpatialIdx()"
  },
  {
    "label": "DestroyParticle()",
    "kind": "Method",
    "detail": "Function (AsyncSpatialData = SpatialData ; } } void)",
    "insertText": "DestroyParticle(FGeometryParticleHandle* Particle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(MRewindData)"
  },
  {
    "label": "RemoveObject()",
    "kind": "Method",
    "detail": "Function (MRewindData ->)",
    "insertText": "RemoveObject(Particle)"
  },
  {
    "label": "DisconnectConstraints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisconnectConstraints(TSet<FGeometryParticleHandle*>({ Particle }))"
  },
  {
    "label": "DestroyParticle()",
    "kind": "Method",
    "detail": "Function (Particles .)",
    "insertText": "DestroyParticle(Particle)"
  },
  {
    "label": "ReserveParticles()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ReserveParticles(const int32 Num)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (InternalAccelerationQueue . PendingData .)",
    "insertText": "Reserve(InternalAccelerationQueue.Num() + NumNew)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (AsyncAccelerationQueue . PendingData .)",
    "insertText": "Reserve(AsyncAccelerationQueue.Num() + NumNew)"
  },
  {
    "label": "SetParticleObjectState()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetParticleObjectState(FPBDRigidParticleHandle* Particle, EObjectStateType ObjectState)"
  },
  {
    "label": "WakeParticle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WakeParticle(FPBDRigidParticleHandle* Particle)"
  },
  {
    "label": "SetParticleSleepType()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetParticleSleepType(FPBDRigidParticleHandle* Particle, ESleepType InSleepType)"
  },
  {
    "label": "DisableParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisableParticles(const TSet<FGeometryParticleHandle*>& InParticles)"
  },
  {
    "label": "RemoveConstraintFromConstraintGraph()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveConstraintFromConstraintGraph(FConstraintHandle* ConstraintHandle)"
  },
  {
    "label": "RemoveConstraint()",
    "kind": "Method",
    "detail": "Function (IslandManager .)",
    "insertText": "RemoveConstraint(ConstraintHandle)"
  },
  {
    "label": "RemoveConstraintsFromConstraintGraph()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "RemoveConstraintsFromConstraintGraph(const FConstraintHandleArray& Constraints)"
  },
  {
    "label": "RemoveConstraintFromConstraintGraph()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveConstraintFromConstraintGraph(ConstraintHandle)"
  },
  {
    "label": "DisconnectConstraints()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DisconnectConstraints(const TSet<FGeometryParticleHandle*>& RemovedParticles)"
  },
  {
    "label": "DisconnectConstraints()",
    "kind": "Method",
    "detail": "Function (Container ->)",
    "insertText": "DisconnectConstraints(RemovedParticles)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(FGeometryParticleHandle* ParticleHandle : RemovedParticles)"
  },
  {
    "label": "RemoveConstraintsFromConstraintGraph()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveConstraintsFromConstraintGraph(ParticleHandle->ParticleConstraints())"
  },
  {
    "label": "ParticleConstraints()",
    "kind": "Method",
    "detail": "Function (ParticleHandle ->)",
    "insertText": "ParticleConstraints().Reset()"
  },
  {
    "label": "DisableConstraints()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DisableConstraints(FGeometryParticleHandle* ParticleHandle)"
  },
  {
    "label": "OnDisableParticle()",
    "kind": "Method",
    "detail": "Function (Container ->)",
    "insertText": "OnDisableParticle(ParticleHandle)"
  },
  {
    "label": "EnableConstraints()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EnableConstraints(FGeometryParticleHandle* ParticleHandle)"
  },
  {
    "label": "OnEnableParticle()",
    "kind": "Method",
    "detail": "Function (Container ->)",
    "insertText": "OnEnableParticle(ParticleHandle)"
  },
  {
    "label": "ResetConstraints()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ResetConstraints()"
  },
  {
    "label": "GetIslandManager()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetIslandManager().Reset()"
  },
  {
    "label": "ParticleCollisions()",
    "kind": "Method",
    "detail": "Function (Particle .)",
    "insertText": "ParticleCollisions().Reset()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(FPBDConstraintContainer* Container : ConstraintContainers)"
  },
  {
    "label": "DestroyTransientConstraints()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "DestroyTransientConstraints(FGeometryParticleHandle* Particle)"
  },
  {
    "label": "DestroyTransientConstraints()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "DestroyTransientConstraints()"
  },
  {
    "label": "GetNonDisabledClusteredView()",
    "kind": "Method",
    "detail": "Function (} const TParticleView<FPBDRigidClusteredParticles>&)",
    "insertText": "GetNonDisabledClusteredView()"
  },
  {
    "label": "GetPhysicsMaterial()",
    "kind": "Method",
    "detail": "Function (} TSerializablePtr<FChaosPhysicsMaterial>)",
    "insertText": "GetPhysicsMaterial(const FGeometryParticleHandle* Particle)"
  },
  {
    "label": "GetFirstPhysicsMaterial()",
    "kind": "Method",
    "detail": "Function (} const FChaosPhysicsMaterial*)",
    "insertText": "GetFirstPhysicsMaterial(const FGeometryParticleHandle* Particle)"
  },
  {
    "label": "GetPerParticlePhysicsMaterial()",
    "kind": "Method",
    "detail": "Function (const TUniquePtr<FChaosPhysicsMaterial>&)",
    "insertText": "GetPerParticlePhysicsMaterial(const FGeometryParticleHandle* Particle)"
  },
  {
    "label": "SetPerParticlePhysicsMaterial()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetPerParticlePhysicsMaterial(FGeometryParticleHandle* Particle, TUniquePtr<FChaosPhysicsMaterial> &InMaterial)"
  },
  {
    "label": "AuxilaryValue()",
    "kind": "Method",
    "detail": "Function (Particle ->)",
    "insertText": "AuxilaryValue(PerParticlePhysicsMaterials) = MoveTemp(InMaterial)"
  },
  {
    "label": "UpdateParticleMaterial()",
    "kind": "Method",
    "detail": "Function (IslandManager .)",
    "insertText": "UpdateParticleMaterial(Particle)"
  },
  {
    "label": "SetPhysicsMaterial()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetPhysicsMaterial(FGeometryParticleHandle* Particle, TSerializablePtr<FChaosPhysicsMaterial> InMaterial)"
  },
  {
    "label": "AuxilaryValue()",
    "kind": "Method",
    "detail": "Function (Particle ->)",
    "insertText": "AuxilaryValue(PhysicsMaterials)"
  },
  {
    "label": "PrepareTick()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "PrepareTick()"
  },
  {
    "label": "UnprepareTick()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "UnprepareTick()"
  },
  {
    "label": "ApplyKinematicTargets()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ApplyKinematicTargets(const FReal Dt, const FReal StepFraction)"
  },
  {
    "label": "UpdateExternalAccelerationStructure_External()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "UpdateExternalAccelerationStructure_External(ISpatialAccelerationCollection<FAccelerationStructureHandle, FReal, 3>*& ExternalStructure, FPendingSpatialDataQueue& PendingExternal)"
  },
  {
    "label": "GetSpatialAcceleration()",
    "kind": "Method",
    "detail": "Function (ISpatialAccelerationCollection<FAccelerationStructureHandle,FReal,3>*)",
    "insertText": "GetSpatialAcceleration()"
  },
  {
    "label": "RebuildSpatialAccelerationForPerfTest()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RebuildSpatialAccelerationForPerfTest()"
  },
  {
    "label": "ComputeIntermediateSpatialAcceleration()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeIntermediateSpatialAcceleration(bool bBlock = false)"
  },
  {
    "label": "IsResimming()",
    "kind": "Method",
    "detail": "Function (bIsResim = bInResim ; } const bool)",
    "insertText": "IsResimming()"
  },
  {
    "label": "IsResetting()",
    "kind": "Method",
    "detail": "Function (bIsReset = bInReset ; } const bool)",
    "insertText": "IsResetting()"
  },
  {
    "label": "GenerateUniqueIdx()",
    "kind": "Method",
    "detail": "Function (FUniqueIdx)",
    "insertText": "GenerateUniqueIdx()"
  },
  {
    "label": "GetUniqueIndices()",
    "kind": "Method",
    "detail": "Function (FUniqueIdx Result ; UE_AUTORTFM_OPEN { Result = Particles .)",
    "insertText": "GetUniqueIndices().GenerateUniqueIdx()"
  },
  {
    "label": "OnAbort()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "OnAbort([this, Result] { this->ReleaseUniqueIdx(Result); })"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (UniqueIndicesPendingRelease .)",
    "insertText": "Add(UniqueIdx)"
  },
  {
    "label": "IsUniqueIndexPendingRelease()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsUniqueIndexPendingRelease(FUniqueIdx UniqueIdx)"
  },
  {
    "label": "KillSafeAsyncTasks()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "KillSafeAsyncTasks()"
  },
  {
    "label": "AreAnyTasksPending()",
    "kind": "Method",
    "detail": "Function (* bAccelerationStructureTaskSignalKill = true ; } } bool)",
    "insertText": "AreAnyTasksPending()"
  },
  {
    "label": "SetCanStartAsyncTasks()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCanStartAsyncTasks(bool bInCanStartAsyncTasks)"
  },
  {
    "label": "SetRewindData()",
    "kind": "Method",
    "detail": "Function (bCanStartAsyncTasks = bInCanStartAsyncTasks ; } void)",
    "insertText": "SetRewindData(FRewindData* RewindData)"
  },
  {
    "label": "GetRewindData()",
    "kind": "Method",
    "detail": "Function (MRewindData = RewindData ; } FRewindData*)",
    "insertText": "GetRewindData()"
  },
  {
    "label": "GetAllRemovals()",
    "kind": "Method",
    "detail": "Function (const TArray<FRemovalData>&)",
    "insertText": "GetAllRemovals()"
  },
  {
    "label": "SetName()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetName(const FString& InName)"
  },
  {
    "label": "GetName()",
    "kind": "Method",
    "detail": "Function (EvolutionName = InName ; } const FString&)",
    "insertText": "GetName()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 NumConstraints = 0 ;)",
    "insertText": "for(const FPBDConstraintContainer* Container : ConstraintContainers)"
  },
  {
    "label": "GetNumConstraints()",
    "kind": "Method",
    "detail": "Function (NumConstraints + = Container ->)",
    "insertText": "GetNumConstraints()"
  },
  {
    "label": "RemoveParticleFromAccelerationStructure()",
    "kind": "Method",
    "detail": "Function (} return NumConstraints ; } public : template<bool bPersistent> void)",
    "insertText": "RemoveParticleFromAccelerationStructure(TGeometryParticleHandleImp<FReal, 3, bPersistent>& ParticleHandle)"
  },
  {
    "label": "FindOrAdd()",
    "kind": "Method",
    "detail": "Function (FPendingSpatialData& SpatialData = AsyncAccelerationQueue .)",
    "insertText": "FindOrAdd(UniqueIdx, EPendingSpatialDataOperation::Delete)"
  },
  {
    "label": "FAccelerationStructureHandle()",
    "kind": "Method",
    "detail": "Function (SpatialData . AccelerationHandle =)",
    "insertText": "FAccelerationStructureHandle(ParticleHandle)"
  },
  {
    "label": "Remove()",
    "kind": "Method",
    "detail": "Function (InternalAccelerationQueue .)",
    "insertText": "Remove(UniqueIdx)"
  },
  {
    "label": "RemoveElementFrom()",
    "kind": "Method",
    "detail": "Function (InternalAcceleration ->)",
    "insertText": "RemoveElementFrom(SpatialData.AccelerationHandle, SpatialData.SpatialIdx)"
  },
  {
    "label": "UpdateConstraintPositionBasedState()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "UpdateConstraintPositionBasedState(FReal Dt)"
  },
  {
    "label": "UpdatePositionBasedState()",
    "kind": "Method",
    "detail": "Function (ConstraintContainer ->)",
    "insertText": "UpdatePositionBasedState(Dt)"
  },
  {
    "label": "CreateConstraintGraph()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "CreateConstraintGraph()"
  },
  {
    "label": "UpdateParticles()",
    "kind": "Method",
    "detail": "Function (IslandManager .)",
    "insertText": "UpdateParticles()"
  },
  {
    "label": "AddConstraintsToGraph()",
    "kind": "Method",
    "detail": "Function (ConstraintContainer ->)",
    "insertText": "AddConstraintsToGraph(GetIslandManager())"
  },
  {
    "label": "CreateIslands()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "CreateIslands()"
  },
  {
    "label": "UpdateIslands()",
    "kind": "Method",
    "detail": "Function (IslandManager .)",
    "insertText": "UpdateIslands()"
  },
  {
    "label": "FlushInternalAccelerationQueue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "FlushInternalAccelerationQueue()"
  },
  {
    "label": "FlushAsyncAccelerationQueue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FlushAsyncAccelerationQueue()"
  },
  {
    "label": "WaitOnAccelerationStructure()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "WaitOnAccelerationStructure()"
  },
  {
    "label": "CopyUnBuiltDynamicAccelerationStructures()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyUnBuiltDynamicAccelerationStructures(const TMap<FSpatialAccelerationIdx, TUniquePtr<FSpatialAccelerationCache>>& SpatialAccelerationCache, FAccelerationStructure* InternalAcceleration, FAccelerationStructure* AsyncInternalAcceleration, FAccelerationStructure* AsyncExternalAcceleration)"
  },
  {
    "label": "CopyPristineAccelerationStructures()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CopyPristineAccelerationStructures(const TMap<FSpatialAccelerationIdx, TUniquePtr<FSpatialAccelerationCache>>& SpatialAccelerationCache, FAccelerationStructure* FromStructure, FAccelerationStructure* ToStructure, bool CheckPristine)"
  },
  {
    "label": "ApplyParticlePendingData()",
    "kind": "Method",
    "detail": "Function (TArray<FForceRule> ForceRules ; TArray<FForceRule> ImpulseRules ; FUpdatePositionRule ParticleUpdatePosition ; FKinematicUpdateRule KinematicUpdate ; FCaptureRewindRule CaptureRewindData ; TArray<FPBDConstraintContainer*> ConstraintContainers ; Private::FPBDIslandManager IslandManager ; Private::FPBDIslandGroupManager IslandGroupManager ; TArrayCollectionArray<TSerializablePtr<FChaosPhysicsMaterial>> PhysicsMaterials ; TArrayCollectionArray<TUniquePtr<FChaosPhysicsMaterial>> PerParticlePhysicsMaterials ; TArrayCollectionArray<bool> Collided ; FPBDRigidsSOAs& Particles ; THandleArray<FChaosPhysicsMaterial>& SolverPhysicsMaterials ; FAccelerationStructure* InternalAcceleration ; FAccelerationStructure* AsyncInternalAcceleration ; FAccelerationStructure* AsyncExternalAcceleration ; FRewindData* MRewindData = nullptr ; TQueue<FAccelerationStructure*,EQueueMode::Spsc> ExternalStructuresQueue ; TQueue<FAccelerationStructure*,EQueueMode::Spsc> ExternalStructuresPool ; TArray<TUniquePtr<FAccelerationStructure>> AccelerationBackingBuffer ; bool bIsSingleThreaded ; bool bCanStartAsyncTasks ; TArray<FUniqueIdx> UniqueIndicesPendingRelease ; TArray<FRemovalData> MAllRemovals ; public : int32 LatestExternalTimestampConsumed_Internal ; protected : FPendingSpatialDataQueue InternalAccelerationQueue ; FPendingSpatialDataQueue AsyncAccelerationQueue ; TArrayAsMap<FUniqueIdx,uint32> ParticleToCacheInnerIdx ; TMap<FSpatialAccelerationIdx,TUniquePtr<FSpatialAccelerationCache>> SpatialAccelerationCache ; void)",
    "insertText": "ApplyParticlePendingData(const FPendingSpatialData& PendingData, FAccelerationStructure& SpatialAcceleration, bool bUpdateCache, bool bUpdateDynamicTrees)"
  },
  {
    "label": "FChaosAccelerationStructureTask()",
    "kind": "Method",
    "detail": "Function (class FChaosAccelerationStructureTask { public :)",
    "insertText": "FChaosAccelerationStructureTask(ISpatialAccelerationCollectionFactory& InSpatialCollectionFactory , const TMap<FSpatialAccelerationIdx, TUniquePtr<FSpatialAccelerationCache>>& InSpatialAccelerationCache , FAccelerationStructure* InInternalAccelerationStructure , FAccelerationStructure* InExternalAccelerationStructure , bool InForceFullBuild , bool InIsSingleThreaded , bool bNeedsReset , std::atomic<bool>** bOutStarted , std::atomic<bool>** bOutKillTask)"
  },
  {
    "label": "GetStatId()",
    "kind": "Method",
    "detail": "Function (TStatId)",
    "insertText": "GetStatId()"
  },
  {
    "label": "GetDesiredThread()",
    "kind": "Method",
    "detail": "Function (ENamedThreads::Type)",
    "insertText": "GetDesiredThread()"
  },
  {
    "label": "GetSubsequentsMode()",
    "kind": "Method",
    "detail": "Function (ESubsequentsMode::Type)",
    "insertText": "GetSubsequentsMode()"
  },
  {
    "label": "DoTask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent)"
  },
  {
    "label": "UpdateStructure()",
    "kind": "Method",
    "detail": "Function (ISpatialAccelerationCollectionFactory& SpatialCollectionFactory ; const TMap<FSpatialAccelerationIdx,TUniquePtr<FSpatialAccelerationCache>>& SpatialAccelerationCache ; FAccelerationStructure* InternalStructure ; FAccelerationStructure* ExternalStructure ; bool IsForceFullBuild ; bool bIsSingleThreaded ; bool bNeedsReset ; std::atomic<bool> bStarted ; std::atomic<bool> bKillTask ; private : void)",
    "insertText": "UpdateStructure(FAccelerationStructure* AccelerationStructure, FAccelerationStructure* CopyToAccelerationStructure = nullptr)"
  },
  {
    "label": "GetFreeSpatialAcceleration_Internal()",
    "kind": "Method",
    "detail": "Function (} ; FGraphEventRef AccelerationStructureTaskComplete ; std::atomic<bool>* bAccelerationStructureTaskStarted ; std::atomic<bool>* bAccelerationStructureTaskSignalKill ; TUniquePtr<ISpatialAccelerationCollectionFactory> SpatialCollectionFactory ; FAccelerationStructure*)",
    "insertText": "GetFreeSpatialAcceleration_Internal()"
  },
  {
    "label": "FreeSpatialAcceleration_External()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FreeSpatialAcceleration_External(FAccelerationStructure* Structure)"
  },
  {
    "label": "ReleaseIdx()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleaseIdx(FUniqueIdx Idx)"
  },
  {
    "label": "ReleasePendingIndices()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReleasePendingIndices()"
  },
  {
    "label": "TestModeStep()",
    "kind": "Method",
    "detail": "Function (TArray<FUniqueIdx> PendingReleaseIndices ; bool bIsResim = false ; bool bIsReset = false ; FString EvolutionName ; # if CHAOS_EVOLUTION_COLLISION_TESTMODE void)",
    "insertText": "TestModeStep()"
  },
  {
    "label": "TestModeParticleDisabled()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TestModeParticleDisabled(FGeometryParticleHandle* Particle)"
  },
  {
    "label": "TestModeSaveParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TestModeSaveParticles()"
  },
  {
    "label": "TestModeSaveParticle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TestModeSaveParticle(FGeometryParticleHandle* Particle)"
  },
  {
    "label": "TestModeUpdateSavedParticle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TestModeUpdateSavedParticle(FGeometryParticleHandle* Particle)"
  },
  {
    "label": "TestModeRestoreParticles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TestModeRestoreParticles()"
  },
  {
    "label": "TestModeRestoreParticle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TestModeRestoreParticle(FGeometryParticleHandle* Particle)"
  }
]