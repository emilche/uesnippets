[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "HbrFace",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrFace"
  },
  {
    "label": "HbrHalfedge",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrHalfedge"
  },
  {
    "label": "HbrVertex",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrVertex"
  },
  {
    "label": "HbrMesh",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrMesh"
  },
  {
    "label": "Mask",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Mask"
  },
  {
    "label": "adaptiveFlags",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "adaptiveFlags"
  },
  {
    "label": "HbrHalfedgeCompare",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrHalfedgeCompare"
  },
  {
    "label": "HbrHalfedgeOperator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HbrHalfedgeOperator"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENSUBDIV3_HBRHALFEDGE_H # define OPENSUBDIV3_HBRHALFEDGE_H # include<assert . h> # include<stddef . h> # include<cstring> # include<iostream> # ifdef HBRSTITCH # include \" libgprims / stitch . h \" # include \" libgprims / stitchInternal . h \" # endif # include \" . . / version . h \" namespace OpenSubdiv { namespace OPENSUBDIV_VERSION { template<class T> class HbrFace ; template<class T> class HbrHalfedge ; template<class T> class HbrVertex ; template<class T> class HbrMesh ; template<class T> std::ostream&)",
    "insertText": "operator(std::ostream& out, const HbrHalfedge<T>& edge)"
  },
  {
    "label": "HbrHalfedge()",
    "kind": "Method",
    "detail": "Function (template<class T> class HbrHalfedge { private :)",
    "insertText": "HbrHalfedge(): opposite(0), incidentVertex(-1), vchild(-1), sharpness(0.0f) #ifdef HBRSTITCH , stitchccw(1), raystitchccw(1) #endif , coarse(1)"
  },
  {
    "label": "HbrHalfedge()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "HbrHalfedge(const HbrHalfedge &)"
  },
  {
    "label": "HbrHalfedge()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "HbrHalfedge()"
  },
  {
    "label": "Clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Clear()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize(HbrHalfedge<T>* opposite, int index, HbrVertex<T>* origin, unsigned int *fvarbits, HbrFace<T>* face)"
  },
  {
    "label": "GetOpposite()",
    "kind": "Method",
    "detail": "Function (public : HbrHalfedge<T>*)",
    "insertText": "GetOpposite()"
  },
  {
    "label": "GetNext()",
    "kind": "Method",
    "detail": "Function (this -> opposite = opposite ; sharpness = opposite -> sharpness ; } HbrHalfedge<T>*)",
    "insertText": "GetNext()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const size_t edgesize =)",
    "insertText": "sizeof(HbrHalfedge<T>) + sizeof(HbrFace<T>*)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(HbrHalfedge<T>*) ((char*) this + edgesize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "if(lastedge)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(HbrHalfedge<T>*) ((char*) this + sizeof(HbrHalfedge<T>))"
  },
  {
    "label": "GetPrev()",
    "kind": "Method",
    "detail": "Function (} } } HbrHalfedge<T>*)",
    "insertText": "GetPrev()"
  },
  {
    "label": "edgesize()",
    "kind": "Method",
    "detail": "Function (const size_t)",
    "insertText": "edgesize(m_index == 4) ? (sizeof(HbrHalfedge<T>) + sizeof(HbrFace<T>*)) : sizeof(HbrHalfedge<T>)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(HbrHalfedge<T>*) ((char*) this - edgesize)"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (} } HbrVertex<T>*)",
    "insertText": "GetVertex()"
  },
  {
    "label": "GetVertex()",
    "kind": "Method",
    "detail": "Function (} HbrVertex<T>*)",
    "insertText": "GetVertex(HbrMesh<T> *mesh)"
  },
  {
    "label": "GetVertexID()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetVertexID()"
  },
  {
    "label": "GetOrgVertex()",
    "kind": "Method",
    "detail": "Function (} HbrVertex<T>*)",
    "insertText": "GetOrgVertex(HbrMesh<T> *mesh)"
  },
  {
    "label": "GetOrgVertexID()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetOrgVertexID()"
  },
  {
    "label": "GetID()",
    "kind": "Method",
    "detail": "Function (incidentVertex = v ->)",
    "insertText": "GetID()"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (} HbrVertex<T>*)",
    "insertText": "GetDestVertex()"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (} HbrVertex<T>*)",
    "insertText": "GetDestVertex(HbrMesh<T> *mesh)"
  },
  {
    "label": "GetDestVertexID()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "GetDestVertexID()"
  },
  {
    "label": "GetFace()",
    "kind": "Method",
    "detail": "Function (} HbrFace<T>*)",
    "insertText": "GetFace()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "return(HbrFace<T>*) ((char*) this - (m_index) * sizeof(HbrHalfedge<T>) - offsetof(HbrFace<T>, edges))"
  },
  {
    "label": "GetMesh()",
    "kind": "Method",
    "detail": "Function (} } HbrMesh<T>*)",
    "insertText": "GetMesh()"
  },
  {
    "label": "GetRightFace()",
    "kind": "Method",
    "detail": "Function (} HbrFace<T>*)",
    "insertText": "GetRightFace()"
  },
  {
    "label": "GetLeftFace()",
    "kind": "Method",
    "detail": "Function (} HbrFace<T>*)",
    "insertText": "GetLeftFace()"
  },
  {
    "label": "IsBoundary()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsBoundary()"
  },
  {
    "label": "infsharp()",
    "kind": "Method",
    "detail": "Function (int intindex = datum>> 4 ; unsigned int bits =)",
    "insertText": "infsharp((datum & 15) * 2)"
  },
  {
    "label": "getFVarInfSharp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getFVarInfSharp()"
  },
  {
    "label": "CopyFVarInfiniteSharpness()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "CopyFVarInfiniteSharpness(HbrHalfedge<T>* edge)"
  },
  {
    "label": "GetMesh()",
    "kind": "Method",
    "detail": "Function (const int fvarcount =)",
    "insertText": "GetMesh()->GetFVarCount()"
  },
  {
    "label": "fvarbitsSizePerEdge()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "fvarbitsSizePerEdge((fvarcount + 15) / 16)"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(fvarinfsharp, 0x55555555, fvarbitsSizePerEdge * sizeof(unsigned int))"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "memcpy(fvarinfsharp, edge->getFVarInfSharp(), fvarbitsSizePerEdge * sizeof(unsigned int))"
  },
  {
    "label": "GetFVarInfiniteSharp()",
    "kind": "Method",
    "detail": "Function (} } } bool)",
    "insertText": "GetFVarInfiniteSharp(int datum)"
  },
  {
    "label": "IsFVarInfiniteSharpAnywhere()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsFVarInfiniteSharpAnywhere()"
  },
  {
    "label": "GetFVarSharpness()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetFVarSharpness(int datum, bool ignoreGeometry=false)"
  },
  {
    "label": "GetSharpness()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetSharpness()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (sharpness = sharp)",
    "insertText": "if(opposite)"
  },
  {
    "label": "ClearMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ClearMask()"
  },
  {
    "label": "IsSharp()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsSharp(bool next)"
  },
  {
    "label": "GetOrgVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetOrgVertex()->ClearMask()"
  },
  {
    "label": "GetDestVertex()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetDestVertex()->ClearMask()"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (} HbrVertex<T>*)",
    "insertText": "Subdivide()"
  },
  {
    "label": "GuaranteeNeighbor()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GuaranteeNeighbor()"
  },
  {
    "label": "HasChild()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "HasChild()"
  },
  {
    "label": "GetStitchEdge()",
    "kind": "Method",
    "detail": "Function (vchild = - 1 ; } enum Mask { k_Smooth = 0,k_Sharp = 1,k_InfinitelySharp = 1 0 } ; # ifdef HBRSTITCH StitchEdge*)",
    "insertText": "GetStitchEdge(int i)"
  },
  {
    "label": "getStitchEdges()",
    "kind": "Method",
    "detail": "Function (StitchEdge** stitchEdge =)",
    "insertText": "getStitchEdges()"
  },
  {
    "label": "StitchGetEdge()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "StitchGetEdge(&stitchEdge[i])"
  },
  {
    "label": "DestroyStitchEdges()",
    "kind": "Method",
    "detail": "Function (} return stitchEdge [ i ] ; } } void)",
    "insertText": "DestroyStitchEdges(int stitchcount)"
  },
  {
    "label": "StitchFreeEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StitchFreeEdge(stitchEdge[i])"
  },
  {
    "label": "GetRayStitchEdge()",
    "kind": "Method",
    "detail": "Function (stitchEdge [ i ] = 0 ; } } } } StitchEdge*)",
    "insertText": "GetRayStitchEdge(int i)"
  },
  {
    "label": "SplitStitchEdge()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SplitStitchEdge(int i)"
  },
  {
    "label": "GetStitchEdge()",
    "kind": "Method",
    "detail": "Function (StitchEdge* se =)",
    "insertText": "GetStitchEdge(i)"
  },
  {
    "label": "GetOrgVertex()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* ea =)",
    "insertText": "GetOrgVertex()->Subdivide()->GetEdge(Subdivide())"
  },
  {
    "label": "Subdivide()",
    "kind": "Method",
    "detail": "Function (HbrHalfedge<T>* eb =)",
    "insertText": "Subdivide()->GetEdge(GetDestVertex()->Subdivide())"
  },
  {
    "label": "StitchSplitEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StitchSplitEdge(se, &ease[i], &ebse[i], false, 0, 0, 0)"
  },
  {
    "label": "StitchSplitEdge()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "StitchSplitEdge(se, &ebse[i], &ease[i], true, 0, 0, 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ea -> raystitchccw = eb -> raystitchccw = raystitchccw ;)",
    "insertText": "if(eb->opposite)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (eb -> opposite -> raystitchccw = raystitchccw ; })",
    "insertText": "if(ea->opposite)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ea -> opposite -> raystitchccw = raystitchccw ; } } else {)",
    "insertText": "if(!stitchccw)"
  },
  {
    "label": "SplitRayStitchEdge()",
    "kind": "Method",
    "detail": "Function (ea -> opposite -> stitchccw = stitchccw ; } } } void)",
    "insertText": "SplitRayStitchEdge(int i)"
  },
  {
    "label": "SplitStitchEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SplitStitchEdge(i + 2)"
  },
  {
    "label": "SetStitchEdge()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetStitchEdge(int i, StitchEdge* edge)"
  },
  {
    "label": "SetRayStitchEdge()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "SetRayStitchEdge(int i, StitchEdge* edge)"
  },
  {
    "label": "GetStitchData()",
    "kind": "Method",
    "detail": "Function (} } void*)",
    "insertText": "GetStitchData()"
  },
  {
    "label": "GetMesh()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "GetMesh()->SetStitchData(this, data)"
  },
  {
    "label": "GetMesh()",
    "kind": "Method",
    "detail": "Function (opposite ->)",
    "insertText": "GetMesh()->SetStitchData(opposite, data)"
  },
  {
    "label": "GetStitchCCW()",
    "kind": "Method",
    "detail": "Function (opposite -> stitchdatavalid = stitchdatavalid ; } } bool)",
    "insertText": "GetStitchCCW(bool raytraced)"
  },
  {
    "label": "ToggleStitchCCW()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "ToggleStitchCCW(bool raytraced)"
  },
  {
    "label": "SetCoarse()",
    "kind": "Method",
    "detail": "Function (} } # endif void)",
    "insertText": "SetCoarse(bool c)"
  },
  {
    "label": "IsCoarse()",
    "kind": "Method",
    "detail": "Function (coarse = c ; } bool)",
    "insertText": "IsCoarse()"
  },
  {
    "label": "fvarbitsSizePerEdge()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "fvarbitsSizePerEdge((GetMesh()->GetFVarCount() + 15) / 16)"
  },
  {
    "label": "adaptiveFlags()",
    "kind": "Method",
    "detail": "Function (} # endif # ifdef HBR_ADAPTIVE public : struct adaptiveFlags { unsigned isTransition : 1 ; unsigned isTriangleHead : 1 ; unsigned isWatertightCritical : 1 ;)",
    "insertText": "adaptiveFlags() : isTransition(0),isTriangleHead(0),isWatertightCritical(0)"
  },
  {
    "label": "IsInsideHole()",
    "kind": "Method",
    "detail": "Function (} } ; adaptiveFlags _adaptiveFlags ; bool)",
    "insertText": "IsInsideHole()"
  },
  {
    "label": "m_index()",
    "kind": "Method",
    "detail": "Function (m_index = index ; } else {)",
    "insertText": "m_index(HbrFace<T>**)((char *) this + sizeof(HbrHalfedge<T>))"
  },
  {
    "label": "lastedge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "lastedge(index == face->GetNumVertices() - 1)"
  },
  {
    "label": "firstedge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "firstedge(index == 0)"
  },
  {
    "label": "GetStitchCount()",
    "kind": "Method",
    "detail": "Function (sharpness = opposite -> sharpness ; # ifdef HBRSTITCH StitchEdge** stitchEdges = face -> stitchEdges + mesh ->)",
    "insertText": "GetStitchCount()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} stitchccw = opposite -> stitchccw ; raystitchccw = opposite -> raystitchccw ; stitchdatavalid = 0 ;)",
    "insertText": "if(stitchEdges && opposite->GetStitchData())"
  },
  {
    "label": "SetStitchData()",
    "kind": "Method",
    "detail": "Function (mesh ->)",
    "insertText": "SetStitchData(this, opposite->GetStitchData())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (stitchdatavalid = 1 ; } # endif)",
    "insertText": "if(fvarbits)"
  },
  {
    "label": "GetFVarCount()",
    "kind": "Method",
    "detail": "Function (const int fvarcount = mesh ->)",
    "insertText": "GetFVarCount()"
  },
  {
    "label": "memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memcpy(fvarbits, opposite->getFVarInfSharp(), fvarbitsSizePerEdge * sizeof(unsigned int))"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(fvarbits, 0xff, fvarbitsSizePerEdge * sizeof(unsigned int))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (opposite -> opposite = 0 ;)",
    "insertText": "if(vchild != -1)"
  },
  {
    "label": "GetMesh()",
    "kind": "Method",
    "detail": "Function (opposite -> vchild = vchild ; HbrVertex<T>* vchildVert =)",
    "insertText": "GetMesh()->GetVertex(vchild)"
  },
  {
    "label": "SetParent()",
    "kind": "Method",
    "detail": "Function (vchildVert ->)",
    "insertText": "SetParent(static_cast<HbrHalfedge*>(0))"
  },
  {
    "label": "SetParent()",
    "kind": "Method",
    "detail": "Function (vchildVert ->)",
    "insertText": "SetParent(opposite)"
  },
  {
    "label": "GetSubdivision()",
    "kind": "Method",
    "detail": "Function (HbrVertex<T>* vchildVert = mesh ->)",
    "insertText": "GetSubdivision()->Subdivide(mesh, this)"
  },
  {
    "label": "SetParent()",
    "kind": "Method",
    "detail": "Function (vchildVert ->)",
    "insertText": "SetParent(this)"
  },
  {
    "label": "GetSubdivision()",
    "kind": "Method",
    "detail": "Function (mesh ->)",
    "insertText": "GetSubdivision()->GuaranteeNeighbor(mesh, this)"
  },
  {
    "label": "shift()",
    "kind": "Method",
    "detail": "Function (int intindex = datum>> 4 ; int)",
    "insertText": "shift(datum & 15)"
  },
  {
    "label": "bits()",
    "kind": "Method",
    "detail": "Function (unsigned int)",
    "insertText": "bits(fvarinfsharp[intindex] >> shift)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(bits != 2)"
  },
  {
    "label": "bits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bits(0x3 << shift)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (fvarinfsharp [ intindex ]& = bits ;)",
    "insertText": "if(opposite) opposite->getFVarInfSharp()"
  },
  {
    "label": "bits()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bits(0x2 << shift)"
  },
  {
    "label": "GetNumVertices()",
    "kind": "Method",
    "detail": "Function (nv = left ->)",
    "insertText": "GetNumVertices()"
  },
  {
    "label": "GetFirstEdge()",
    "kind": "Method",
    "detail": "Function (} e = right ->)",
    "insertText": "GetFirstEdge()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "assert(lorg >= 0 && ldst >= 0 && rorg >= 0 && rdst >= 0)"
  },
  {
    "label": "GetMesh()",
    "kind": "Method",
    "detail": "Function (const int startindex =)",
    "insertText": "GetMesh()->GetFVarIndices()"
  },
  {
    "label": "GetMesh()",
    "kind": "Method",
    "detail": "Function (const int width =)",
    "insertText": "GetMesh()->GetFVarWidths()"
  },
  {
    "label": "GetFVarSharpness()",
    "kind": "Method",
    "detail": "Function (} return false ; } template<class T> float HbrHalfedge<T)",
    "insertText": "GetFVarSharpness(int datum, bool ignoreGeometry)"
  },
  {
    "label": "SetFVarInfiniteSharp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetFVarInfiniteSharp(datum, true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (out<<\" edge connecting \" ;)",
    "insertText": "if(edge.GetOrgVertex()) out << *edge.GetOrgVertex()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (out<<\" to \" ;)",
    "insertText": "if(edge.GetDestVertex())"
  },
  {
    "label": "out()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "out(none)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} return out ; } template<class T> class HbrHalfedgeCompare { public : bool)",
    "insertText": "operator() (const HbrHalfedge<T>* a, HbrHalfedge<T>* b)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; template<class T> class HbrHalfedgeOperator { public : void)",
    "insertText": "operator() (HbrHalfedge<T> &edge)"
  },
  {
    "label": "HbrHalfedgeOperator()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "HbrHalfedgeOperator()"
  }
]