[
  {
    "label": "FPersistentManagedFile",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPersistentManagedFile"
  },
  {
    "label": "FManagedStorageFileLockRegistry",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FManagedStorageFileLockRegistry"
  },
  {
    "label": "FManagedStorageScopeFileLock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FManagedStorageScopeFileLock"
  },
  {
    "label": "FLockData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FLockData"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "FPersistentStorageCategory",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FPersistentStorageCategory"
  },
  {
    "label": "CategoryStat",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CategoryStat"
  },
  {
    "label": "FPersistentStorageManager",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FPersistentStorageManager"
  },
  {
    "label": "FInitStorageVisitor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FInitStorageVisitor"
  },
  {
    "label": "FRootDirInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRootDirInfo"
  },
  {
    "label": "FCategoryInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FCategoryInfo"
  },
  {
    "label": "FManagedStorageFileWriteHandle",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FManagedStorageFileWriteHandle"
  },
  {
    "label": "BaseClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BaseClass"
  },
  {
    "label": "TManagedStoragePlatformFile",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TManagedStoragePlatformFile"
  },
  {
    "label": "DECLARE_LOG_CATEGORY_EXTERN()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Algo / Find . h \" # include \" Algo / IndexOf . h \" # include \" Async / Async . h \" # include \" Async / TaskGraphInterfaces . h \" # include \" Containers / Array . h \" # include \" Containers / ArrayView . h \" # include \" Containers / Map . h \" # include \" Containers / SparseArray . h \" # include \" Containers / UnrealString . h \" # include \" CoreGlobals . h \" # include \" CoreTypes . h \" # include \" GenericPlatform / GenericPlatformFile . h \" # include \" HAL / CriticalSection . h \" # include \" HAL / PlatformCrt . h \" # include \" HAL / PlatformString . h \" # include \" Logging / LogCategory . h \" # include \" Logging / LogMacros . h \" # include \" Math / NumericLimits . h \" # include \" Math / UnrealMathUtility . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / CommandLine . h \" # include \" Misc / ConfigCacheIni . h \" # include \" Misc / EnumClassFlags . h \" # include \" Misc / Optional . h \" # include \" Misc / Parse . h \" # include \" Misc / Paths . h \" # include \" Misc / ScopeLock . h \" # include \" Misc / ScopeRWLock . h \" # include \" Templates / UniquePtr . h \" # include \" Templates / UnrealTemplate . h \" # include \" Trace / Detail / Channel . h \" # include<atomic>)",
    "insertText": "DECLARE_LOG_CATEGORY_EXTERN(LogPlatformFileManagedStorage, Log, All)"
  },
  {
    "label": "IsUnderDirectory()",
    "kind": "Method",
    "detail": "Function (namespace ManagedStorageInternal { bool)",
    "insertText": "IsUnderDirectory(const FString& InPath, const FString& InDirectory)"
  },
  {
    "label": "IsValid()",
    "kind": "Method",
    "detail": "Function (} struct FPersistentManagedFile { FString FullFilename ; int32 Category = INDEX_NONE ; bool)",
    "insertText": "IsValid()"
  },
  {
    "label": "GetLock()",
    "kind": "Method",
    "detail": "Function (Category = INDEX_NONE ; } } ; class FManagedStorageFileLockRegistry { private : class FManagedStorageScopeFileLock ; FCriticalSection*)",
    "insertText": "GetLock(const FString& InFilename)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (uint32 KeyHash =)",
    "insertText": "GetTypeHash(InFilename)"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "Lock(&FileLockMapCS)"
  },
  {
    "label": "FindOrAddByHash()",
    "kind": "Method",
    "detail": "Function (FLockData& LockData = FileLockMap .)",
    "insertText": "FindOrAddByHash(KeyHash, InFilename)"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (+ + LockData . RefCount ; return LockData . CS .)",
    "insertText": "Get()"
  },
  {
    "label": "ReleaseLock()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "ReleaseLock(const FString& InFilename)"
  },
  {
    "label": "FindByHash()",
    "kind": "Method",
    "detail": "Function (FLockData* LockData = FileLockMap .)",
    "insertText": "FindByHash(KeyHash, InFilename)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - LockData -> RefCount ;)",
    "insertText": "if(LockData->RefCount == 0)"
  },
  {
    "label": "RemoveByHash()",
    "kind": "Method",
    "detail": "Function (FileLockMap .)",
    "insertText": "RemoveByHash(KeyHash, InFilename)"
  },
  {
    "label": "FCriticalSection()",
    "kind": "Method",
    "detail": "Function (} } private : struct FLockData { TUniquePtr<FCriticalSection> CS { MakeUnique<)",
    "insertText": "FCriticalSection()"
  },
  {
    "label": "FManagedStorageScopeFileLock()",
    "kind": "Method",
    "detail": "Function (int32 RefCount = 0 ; } ; TMap<FString,FLockData> FileLockMap ; FCriticalSection FileLockMapCS ; } ; class FManagedStorageScopeFileLock { public :)",
    "insertText": "FManagedStorageScopeFileLock(FPersistentManagedFile InManagedFile) : ManagedFile(MoveTemp(InManagedFile))"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Lock()"
  },
  {
    "label": "FManagedStorageScopeFileLock()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FManagedStorageScopeFileLock()"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Unlock()"
  },
  {
    "label": "FManagedStorageScopeFileLock()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FManagedStorageScopeFileLock(const FManagedStorageScopeFileLock&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FManagedStorageScopeFileLock&)",
    "insertText": "operator(const FManagedStorageScopeFileLock&)"
  },
  {
    "label": "FManagedStorageScopeFileLock()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FManagedStorageScopeFileLock(FManagedStorageScopeFileLock&& InOther)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FManagedStorageScopeFileLock&)",
    "insertText": "operator(FManagedStorageScopeFileLock&& InOther)"
  },
  {
    "label": "OnlyUpdateIfLess()",
    "kind": "Method",
    "detail": "Function (private : FPersistentManagedFile ManagedFile ; FCriticalSection* pFileCS = nullptr ; } ; enum class EPersistentStorageManagerFileSizeFlags : uint8 { None = 0,)",
    "insertText": "OnlyUpdateIfLess(1 << 0), RespectQuota = (1 << 1)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ENUM_CLASS_FLAGS(EPersistentStorageManagerFileSizeFlags)"
  },
  {
    "label": "FPersistentStorageCategory()",
    "kind": "Method",
    "detail": "Function (struct FPersistentStorageCategory { public :)",
    "insertText": "FPersistentStorageCategory(FString InCategoryName, TArray<FString> InDirectories, const int64 InQuota, const int64 InOptionalQuota) : CategoryName(MoveTemp(InCategoryName)) , Directories(MoveTemp(InDirectories)) , StorageQuota(InQuota) , OptionalStorageQuota(InOptionalQuota)"
  },
  {
    "label": "GetCategoryName()",
    "kind": "Method",
    "detail": "Function (} const FString&)",
    "insertText": "GetCategoryName()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int64 ActualStorageQuota = StorageQuota ;)",
    "insertText": "if(ActualStorageQuota >= 0)"
  },
  {
    "label": "IsInCategory()",
    "kind": "Method",
    "detail": "Function (ActualStorageQuota - = OptionalStorageQuota ; } } else { ActualStorageQuota = MAX_int64 ; } return ActualStorageQuota - UsedQuota ; } bool)",
    "insertText": "IsInCategory(const FString& Path)"
  },
  {
    "label": "IsCategoryFull()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsCategoryFull()"
  },
  {
    "label": "AddOrUpdateFile()",
    "kind": "Method",
    "detail": "Function (} EPersistentStorageManagerFileSizeFlags)",
    "insertText": "AddOrUpdateFile(const FString& Filename, const int64 FileSize, EPersistentStorageManagerFileSizeFlags Flags)"
  },
  {
    "label": "GetTypeHash()",
    "kind": "Method",
    "detail": "Function (uint32 KeyHash =)",
    "insertText": "GetTypeHash(Filename)"
  },
  {
    "label": "ScopeLock()",
    "kind": "Method",
    "detail": "Function (int64 OldFileSize = 0 ; { FReadScopeLock)",
    "insertText": "ScopeLock(FileSizesLock)"
  },
  {
    "label": "FindByHash()",
    "kind": "Method",
    "detail": "Function (int64* pOldFileSize = FileSizes .)",
    "insertText": "FindByHash(KeyHash, Filename)"
  },
  {
    "label": "TryUpdateQuota()",
    "kind": "Method",
    "detail": "Function (OldFileSize =* pOldFileSize ; } } EPersistentStorageManagerFileSizeFlags Result =)",
    "insertText": "TryUpdateQuota(OldFileSize, FileSize, Flags)"
  },
  {
    "label": "AddByHash()",
    "kind": "Method",
    "detail": "Function (FileSizes .)",
    "insertText": "AddByHash(KeyHash, Filename, FileSize)"
  },
  {
    "label": "RemoveFile()",
    "kind": "Method",
    "detail": "Function (} return Result ; } bool)",
    "insertText": "RemoveFile(const FString& Filename)"
  },
  {
    "label": "WriteLock()",
    "kind": "Method",
    "detail": "Function (FileSizesLock .)",
    "insertText": "WriteLock()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int64 OldSize ;)",
    "insertText": "if(FileSizes.RemoveAndCopyValue(Filename, OldSize))"
  },
  {
    "label": "WriteUnlock()",
    "kind": "Method",
    "detail": "Function (FileSizesLock .)",
    "insertText": "WriteUnlock()"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (UsedQuota - = OldSize ;)",
    "insertText": "UE_LOG(LogPlatformFileManagedStorage, Verbose, TEXT(\"File %s is removed from category %s\"), *Filename, *CategoryName)"
  },
  {
    "label": "Printf()",
    "kind": "Method",
    "detail": "Function (} else { return)",
    "insertText": "Printf(TEXT(\"Category %s: %.3f MiB (%\" INT64_FMT \") / %.3f MiB used\"), *CategoryName, (float)UsedSize / 1024.f / 1024.f, UsedSize, (float)TotalSize / 1024.f / 1024.f)"
  },
  {
    "label": "GetStat()",
    "kind": "Method",
    "detail": "Function (} } FString CategoryName ; int64 UsedSize = 0 ; int64 TotalSize = - 1 ; TMap<FString,int64> FileSizes ; TArray<FString> Directories ; } ; CategoryStat)",
    "insertText": "GetStat()"
  },
  {
    "label": "UsedQuota()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "UsedQuota(OldFileSize - NewFileSize)"
  },
  {
    "label": "OldUsedQuota()",
    "kind": "Method",
    "detail": "Function (int64 OldUsedQuota = UsedQuota ; int64 NewUsedQuota ; do { NewUsedQuota =)",
    "insertText": "OldUsedQuota(NewFileSize - OldFileSize)"
  },
  {
    "label": "FPersistentStorageManager()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FPersistentStorageManager()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Initialize()"
  },
  {
    "label": "TryManageFile()",
    "kind": "Method",
    "detail": "Function (bInitialized = true ; } FPersistentManagedFile)",
    "insertText": "TryManageFile(const FString& Filename)"
  },
  {
    "label": "ConvertRelativePathToFull()",
    "kind": "Method",
    "detail": "Function (FPersistentManagedFile OutFile ; OutFile . FullFilename =)",
    "insertText": "ConvertRelativePathToFull(Filename)"
  },
  {
    "label": "TryManageFileInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TryManageFileInternal(OutFile)"
  },
  {
    "label": "ConvertRelativePathToFull()",
    "kind": "Method",
    "detail": "Function (FPersistentManagedFile OutFile ; OutFile . FullFilename =)",
    "insertText": "ConvertRelativePathToFull(MoveTemp(Filename))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 CategoryIndex = 0 ;)",
    "insertText": "for(const FPersistentStorageCategory& Category : Categories.GetCategories())"
  },
  {
    "label": "FindByPredicate()",
    "kind": "Method",
    "detail": "Function (OutFile . Category = CategoryIndex ; return ; } + + CategoryIndex ; } bool bIsUnderRootDir = ! !)",
    "insertText": "FindByPredicate(RootDirectories.GetRootDirectories(), [&OutFile](const FString& RootDir) { return ManagedStorageInternal::IsUnderDirectory(OutFile.FullFilename, RootDir); })"
  },
  {
    "label": "GetDefaultCategoryIndex()",
    "kind": "Method",
    "detail": "Function (OutFile . Category = Categories .)",
    "insertText": "GetDefaultCategoryIndex()"
  },
  {
    "label": "AddOrUpdateFile()",
    "kind": "Method",
    "detail": "Function (} } public : EPersistentStorageManagerFileSizeFlags)",
    "insertText": "AddOrUpdateFile(const FPersistentManagedFile& File, const int64 FileSize, EPersistentStorageManagerFileSizeFlags Flags = EPersistentStorageManagerFileSizeFlags::None)"
  },
  {
    "label": "RemoveFileFromManager()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "RemoveFileFromManager(FPersistentManagedFile& File)"
  },
  {
    "label": "GetTotalUsedSize()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "GetTotalUsedSize()"
  },
  {
    "label": "GetUsedSize()",
    "kind": "Method",
    "detail": "Function (TotalUsedSize + = Category .)",
    "insertText": "GetUsedSize()"
  },
  {
    "label": "GetPersistentStorageUsage()",
    "kind": "Method",
    "detail": "Function (} return TotalUsedSize ; } bool)",
    "insertText": "GetPersistentStorageUsage(FString Path, int64& UsedSpace, int64 &RemainingSpace, int64& Quota, int64* OptionalQuota = nullptr)"
  },
  {
    "label": "ConvertRelativePathToFull()",
    "kind": "Method",
    "detail": "Function (FString FullPath =)",
    "insertText": "ConvertRelativePathToFull(MoveTemp(Path))"
  },
  {
    "label": "GetAvailableSize()",
    "kind": "Method",
    "detail": "Function (RemainingSpace = Category .)",
    "insertText": "GetAvailableSize()"
  },
  {
    "label": "GetCategoryQuota()",
    "kind": "Method",
    "detail": "Function (Quota = Category .)",
    "insertText": "GetCategoryQuota()"
  },
  {
    "label": "GetCategoryOptionalQuota()",
    "kind": "Method",
    "detail": "Function (* OptionalQuota = Category .)",
    "insertText": "GetCategoryOptionalQuota()"
  },
  {
    "label": "GetPersistentStorageUsageByCategory()",
    "kind": "Method",
    "detail": "Function (} return true ; } } return false ; } bool)",
    "insertText": "GetPersistentStorageUsageByCategory(const FString& InCategory, int64& UsedSpace, int64& RemainingSpace, int64& Quota, int64* OptionalQuota = nullptr)"
  },
  {
    "label": "FindBy()",
    "kind": "Method",
    "detail": "Function (FPersistentStorageCategory* Category =)",
    "insertText": "FindBy(Categories.GetCategories(), InCategory, [](const FPersistentStorageCategory& Cat) { return Cat.GetCategoryName(); })"
  },
  {
    "label": "GetPersistentStorageSize()",
    "kind": "Method",
    "detail": "Function (} return true ; } return false ; } bool)",
    "insertText": "GetPersistentStorageSize(int64& UsedSpace, int64& RequiredSpace, int64& OptionalSpace)"
  },
  {
    "label": "IsInitialized()",
    "kind": "Method",
    "detail": "Function (} return true ; } bool)",
    "insertText": "IsInitialized()"
  },
  {
    "label": "GenerateCategoryStats()",
    "kind": "Method",
    "detail": "Function (} TMap<FString,FPersistentStorageCategory::CategoryStat>)",
    "insertText": "GenerateCategoryStats()"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TMap<FString,FPersistentStorageCategory::CategoryStat> CategoryStats ; CategoryStats .)",
    "insertText": "Reserve(Categories.GetCategories().Num())"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (CategoryStats .)",
    "insertText": "Add(Category.GetCategoryName(), Category.GetStat())"
  },
  {
    "label": "GetCategoryStat()",
    "kind": "Method",
    "detail": "Function (} return CategoryStats ; } TOptional<FPersistentStorageCategory::CategoryStat>)",
    "insertText": "GetCategoryStat(const FString& InCategory)"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (Result .)",
    "insertText": "Emplace(Category.GetStat())"
  },
  {
    "label": "GetRootDirectories()",
    "kind": "Method",
    "detail": "Function (break ; } } return Result ; } TArrayView<const FString>)",
    "insertText": "GetRootDirectories()"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} private : class FManagedStorageScopeFileLock ; bool bInitialized ; struct FRootDirInfo { private : TArray<FString> RootDirectories ; public : void)",
    "insertText": "Init(TArrayView<const FPersistentStorageCategory> Categories)"
  },
  {
    "label": "FCategoryInfo()",
    "kind": "Method",
    "detail": "Function (} } ; FRootDirInfo RootDirectories ; struct FCategoryInfo { private : TArray<FPersistentStorageCategory> Categories ; int32 DefaultCategory = - 1 ; public :)",
    "insertText": "FCategoryInfo(TArray<FPersistentStorageCategory>&& InCategories, int32 InDefaultCategory)"
  },
  {
    "label": "GetCategories()",
    "kind": "Method",
    "detail": "Function (TArrayView<FPersistentStorageCategory>)",
    "insertText": "GetCategories()"
  },
  {
    "label": "GetDefaultCategory()",
    "kind": "Method",
    "detail": "Function (} FPersistentStorageCategory*)",
    "insertText": "GetDefaultCategory()"
  },
  {
    "label": "IsReady()",
    "kind": "Method",
    "detail": "Function (} ; class FManagedStorageFileWriteHandle : public IFileHandle { private : bool)",
    "insertText": "IsReady()"
  },
  {
    "label": "TryManageFile()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "TryManageFile()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (File =)",
    "insertText": "Get().TryManageFile(File.FullFilename)"
  },
  {
    "label": "FManagedStorageFileWriteHandle()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "FManagedStorageFileWriteHandle(IFileHandle* InFileHandle, FPersistentManagedFile InFile) : FileHandle(InFileHandle) , File(MoveTemp(InFile))"
  },
  {
    "label": "FManagedStorageFileWriteHandle()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FManagedStorageFileWriteHandle()"
  },
  {
    "label": "Get()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Get().AddOrUpdateFile(File, FileHandle->Size())"
  },
  {
    "label": "Tell()",
    "kind": "Method",
    "detail": "Function (} int64)",
    "insertText": "Tell()"
  },
  {
    "label": "Seek()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Seek(int64 NewPosition)"
  },
  {
    "label": "SeekFromEnd()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "SeekFromEnd(int64 NewPositionRelativeToEnd = 0)"
  },
  {
    "label": "Read()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Read(uint8* Destination, int64 BytesToRead)"
  },
  {
    "label": "ReadAt()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ReadAt(uint8* Destination, int64 BytesToRead, int64 Offset)"
  },
  {
    "label": "Write()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Write(const uint8* Source, int64 BytesToWrite)"
  },
  {
    "label": "ScopeFileLock()",
    "kind": "Method",
    "detail": "Function (FManagedStorageScopeFileLock)",
    "insertText": "ScopeFileLock(File)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (int64 NewSize =)",
    "insertText": "Max(FileHandle->Tell() + BytesToWrite, FileHandle->Size())"
  },
  {
    "label": "AddOrUpdateFile()",
    "kind": "Method",
    "detail": "Function (EPersistentStorageManagerFileSizeFlags Result = Manager .)",
    "insertText": "AddOrUpdateFile(File, NewSize, EPersistentStorageManagerFileSizeFlags::RespectQuota)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool bIsFileCategoryFull = Result ! = EPersistentStorageManagerFileSizeFlags::None ;)",
    "insertText": "if(bIsFileCategoryFull)"
  },
  {
    "label": "Size()",
    "kind": "Method",
    "detail": "Function (int64 FileSize = FileHandle ->)",
    "insertText": "Size()"
  },
  {
    "label": "Flush()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Flush(const bool bFullFlush = false)"
  },
  {
    "label": "Flush()",
    "kind": "Method",
    "detail": "Function (const bool bSuccess = FileHandle ->)",
    "insertText": "Flush(bFullFlush)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const bool bForceSizeUpdate = ! bOldIsValid ;)",
    "insertText": "if(!bSuccess || bForceSizeUpdate)"
  },
  {
    "label": "Truncate()",
    "kind": "Method",
    "detail": "Function (} } return bSuccess ; } bool)",
    "insertText": "Truncate(int64 NewSize)"
  },
  {
    "label": "Truncate()",
    "kind": "Method",
    "detail": "Function (bool bSuccess = FileHandle ->)",
    "insertText": "Truncate(NewSize)"
  },
  {
    "label": "ShrinkBuffers()",
    "kind": "Method",
    "detail": "Function (FileHandle ->)",
    "insertText": "ShrinkBuffers()"
  },
  {
    "label": "TManagedStoragePlatformFile()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "TManagedStoragePlatformFile() : BaseClass()"
  },
  {
    "label": "bUsingGenericDeleteDirectoryRecursively()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bUsingGenericDeleteDirectoryRecursively(&BaseClass::DeleteDirectoryRecursively == &IPlatformFile::DeleteDirectoryRecursively)"
  },
  {
    "label": "LowLevelFatalError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LowLevelFatalError(TEXT(\"TManagedStoragePlatformFile cannot track all deletes!\"))"
  },
  {
    "label": "bUsingGenericCopyDirectoryTree()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "bUsingGenericCopyDirectoryTree(&BaseClass::CopyDirectoryTree == &IPlatformFile::CopyDirectoryTree)"
  },
  {
    "label": "LowLevelFatalError()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LowLevelFatalError(TEXT(\"TManagedStoragePlatformFile cannot track all deletes and copies!\"))"
  },
  {
    "label": "DeleteFile()",
    "kind": "Method",
    "detail": "Function (} } bool)",
    "insertText": "DeleteFile(const TCHAR* Filename)"
  },
  {
    "label": "TryManageFile()",
    "kind": "Method",
    "detail": "Function (FPersistentManagedFile ManagedFile = Manager .)",
    "insertText": "TryManageFile(Filename)"
  },
  {
    "label": "ScopeFileLock()",
    "kind": "Method",
    "detail": "Function (FManagedStorageScopeFileLock)",
    "insertText": "ScopeFileLock(ManagedFile)"
  },
  {
    "label": "DeleteFile()",
    "kind": "Method",
    "detail": "Function (bool bSuccess =)",
    "insertText": "DeleteFile(Filename)"
  },
  {
    "label": "RemoveFileFromManager()",
    "kind": "Method",
    "detail": "Function (Manager .)",
    "insertText": "RemoveFileFromManager(ManagedFile)"
  },
  {
    "label": "DeleteFiles()",
    "kind": "Method",
    "detail": "Function (} return bSuccess ; } bool)",
    "insertText": "DeleteFiles(const TArrayView<const TCHAR*>& Filenames)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (TArray<TPair<FPersistentManagedFile,FManagedStorageScopeFileLock>> FileLocks ; FileLocks .)",
    "insertText": "Reserve(Filenames.Num())"
  },
  {
    "label": "Emplace()",
    "kind": "Method",
    "detail": "Function (FileLocks .)",
    "insertText": "Emplace(ManagedFile, MoveTemp(ManagedFile))"
  },
  {
    "label": "DeleteFiles()",
    "kind": "Method",
    "detail": "Function (} bool bSuccess =)",
    "insertText": "DeleteFiles(Filenames)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (const int32 Count = Filenames .)",
    "insertText": "Num()"
  },
  {
    "label": "RemoveFileFromManager()",
    "kind": "Method",
    "detail": "Function (Manager .)",
    "insertText": "RemoveFileFromManager(FileLocks[i].Key)"
  },
  {
    "label": "UE_LOG()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "UE_LOG(LogPlatformFileManagedStorage, Warning, TEXT(\"Not removing deleted file %s. It still exists on disk.\"), *(FileLocks[i].Key.FullFilename))"
  },
  {
    "label": "MoveFile()",
    "kind": "Method",
    "detail": "Function (} } return bSuccess ; } bool)",
    "insertText": "MoveFile(const TCHAR* To, const TCHAR* From)"
  },
  {
    "label": "TryManageFile()",
    "kind": "Method",
    "detail": "Function (FPersistentManagedFile ManagedTo = Manager .)",
    "insertText": "TryManageFile(To)"
  },
  {
    "label": "TryManageFile()",
    "kind": "Method",
    "detail": "Function (FPersistentManagedFile ManagedFrom = Manager .)",
    "insertText": "TryManageFile(From)"
  },
  {
    "label": "ScopeFileLockTo()",
    "kind": "Method",
    "detail": "Function (FManagedStorageScopeFileLock)",
    "insertText": "ScopeFileLockTo(ManagedTo)"
  },
  {
    "label": "ScopeFileLockFrom()",
    "kind": "Method",
    "detail": "Function (FManagedStorageScopeFileLock)",
    "insertText": "ScopeFileLockFrom(ManagedFrom)"
  },
  {
    "label": "FileSize()",
    "kind": "Method",
    "detail": "Function (const int64 SizeFrom = this ->)",
    "insertText": "FileSize(From)"
  },
  {
    "label": "RemoveFileFromManager()",
    "kind": "Method",
    "detail": "Function (Manager .)",
    "insertText": "RemoveFileFromManager(ManagedFrom)"
  },
  {
    "label": "AddOrUpdateFile()",
    "kind": "Method",
    "detail": "Function (Manager .)",
    "insertText": "AddOrUpdateFile(ManagedTo, SizeFrom)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(ManagedFrom && !this->FileExists(From))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ManagedTo)"
  },
  {
    "label": "RemoveFileFromManager()",
    "kind": "Method",
    "detail": "Function (Manager .)",
    "insertText": "RemoveFileFromManager(ManagedTo)"
  },
  {
    "label": "FileSize()",
    "kind": "Method",
    "detail": "Function (} else { const int64 SizeTo = this ->)",
    "insertText": "FileSize(To)"
  },
  {
    "label": "AddOrUpdateFile()",
    "kind": "Method",
    "detail": "Function (Manager .)",
    "insertText": "AddOrUpdateFile(ManagedTo, SizeTo)"
  },
  {
    "label": "OpenWrite()",
    "kind": "Method",
    "detail": "Function (} } } } return bSuccess ; } IFileHandle*)",
    "insertText": "OpenWrite(const TCHAR* Filename, bool bAppend = false, bool bAllowRead = false)"
  },
  {
    "label": "CopyFile()",
    "kind": "Method",
    "detail": "Function (} else { return InnerHandle ; } } bool)",
    "insertText": "CopyFile(const TCHAR* To, const TCHAR* From, EPlatformFileRead ReadFlags = EPlatformFileRead::None, EPlatformFileWrite WriteFlags = EPlatformFileWrite::None)"
  }
]