[
  {
    "label": "ERoundingMode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ERoundingMode"
  },
  {
    "label": "EMemoryUnitStandard",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EMemoryUnitStandard"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "is",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is"
  },
  {
    "label": "FFormatArgumentData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FFormatArgumentData"
  },
  {
    "label": "UKismetTextLibrary",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UKismetTextLibrary"
  },
  {
    "label": "UObject",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UObject"
  },
  {
    "label": "when",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "when"
  },
  {
    "label": "when",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "when"
  },
  {
    "label": "when",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "when"
  },
  {
    "label": "when",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "when"
  },
  {
    "label": "when",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "when"
  },
  {
    "label": "Conv_VectorToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_VectorToText(FVector InVec)"
  },
  {
    "label": "Conv_Vector2dToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_Vector2dToText(FVector2D InVec)"
  },
  {
    "label": "Conv_RotatorToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_RotatorToText(FRotator InRot)"
  },
  {
    "label": "Conv_TransformToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_TransformToText(const FTransform& InTrans)"
  },
  {
    "label": "Conv_ObjectToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_ObjectToText(class UObject* InObj)"
  },
  {
    "label": "Conv_ColorToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_ColorToText(FLinearColor InColor)"
  },
  {
    "label": "Conv_TextToString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "Conv_TextToString(const FText& InText)"
  },
  {
    "label": "Conv_StringToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_StringToText(const FString& InString)"
  },
  {
    "label": "Conv_NameToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_NameToText(FName InName)"
  },
  {
    "label": "MakeInvariantText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "MakeInvariantText(const FString& InString)"
  },
  {
    "label": "TextIsEmpty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TextIsEmpty(const FText& InText)"
  },
  {
    "label": "TextIsTransient()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TextIsTransient(const FText& InText)"
  },
  {
    "label": "TextIsCultureInvariant()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TextIsCultureInvariant(const FText& InText)"
  },
  {
    "label": "TextToLower()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "TextToLower(const FText& InText)"
  },
  {
    "label": "TextToUpper()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "TextToUpper(const FText& InText)"
  },
  {
    "label": "TextTrimPreceding()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "TextTrimPreceding(const FText& InText)"
  },
  {
    "label": "TextTrimTrailing()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "TextTrimTrailing(const FText& InText)"
  },
  {
    "label": "TextTrimPrecedingAndTrailing()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "TextTrimPrecedingAndTrailing(const FText& InText)"
  },
  {
    "label": "GetEmptyText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "GetEmptyText()"
  },
  {
    "label": "EqualEqual_TextText()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EqualEqual_TextText(const FText& A, const FText& B)"
  },
  {
    "label": "EqualEqual_IgnoreCase_TextText()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "EqualEqual_IgnoreCase_TextText(const FText& A, const FText& B)"
  },
  {
    "label": "NotEqual_TextText()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "NotEqual_TextText(const FText& A, const FText& B)"
  },
  {
    "label": "NotEqual_IgnoreCase_TextText()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "NotEqual_IgnoreCase_TextText(const FText& A, const FText& B)"
  },
  {
    "label": "Conv_BoolToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_BoolToText(bool InBool)"
  },
  {
    "label": "Conv_ByteToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_ByteToText(uint8 Value)"
  },
  {
    "label": "Conv_IntToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_IntToText(int32 Value, bool bAlwaysSign = false, bool bUseGrouping = true, int32 MinimumIntegralDigits = 1, int32 MaximumIntegralDigits = 324)"
  },
  {
    "label": "Conv_Int64ToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_Int64ToText(int64 Value, bool bAlwaysSign = false, bool bUseGrouping = true, int32 MinimumIntegralDigits = 1, int32 MaximumIntegralDigits = 324)"
  },
  {
    "label": "Conv_DoubleToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_DoubleToText(double Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bAlwaysSign = false, bool bUseGrouping = true, int32 MinimumIntegralDigits = 1, int32 MaximumIntegralDigits = 324, int32 MinimumFractionalDigits = 0, int32 MaximumFractionalDigits = 3)"
  },
  {
    "label": "Conv_FloatToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Conv_FloatToText(float Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bAlwaysSign = false, bool bUseGrouping = true, int32 MinimumIntegralDigits = 1, int32 MaximumIntegralDigits = 324, int32 MinimumFractionalDigits = 0, int32 MaximumFractionalDigits = 3)"
  },
  {
    "label": "AsCurrencyBase()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "AsCurrencyBase(int32 BaseValue, const FString& CurrencyCode)"
  },
  {
    "label": "AsPercent_Float()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "AsPercent_Float(float Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bAlwaysSign = false, bool bUseGrouping = true, int32 MinimumIntegralDigits = 1, int32 MaximumIntegralDigits = 324, int32 MinimumFractionalDigits = 0, int32 MaximumFractionalDigits = 3)"
  },
  {
    "label": "AsDate_DateTime()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "AsDate_DateTime(const FDateTime& InDateTime, TEnumAsByte<EDateTimeStyle::Type> InDateStyle = EDateTimeStyle::Default)"
  },
  {
    "label": "AsDateTime_DateTime()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "AsDateTime_DateTime(const FDateTime& In, TEnumAsByte<EDateTimeStyle::Type> InDateStyle = EDateTimeStyle::Default, TEnumAsByte<EDateTimeStyle::Type> InTimeStyle = EDateTimeStyle::Default)"
  },
  {
    "label": "AsTime_DateTime()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "AsTime_DateTime(const FDateTime& In, TEnumAsByte<EDateTimeStyle::Type> InTimeStyle = EDateTimeStyle::Default)"
  },
  {
    "label": "AsTimespan_Timespan()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "AsTimespan_Timespan(const FTimespan& InTimespan)"
  },
  {
    "label": "AsMemory()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "AsMemory(int64 NumBytes, TEnumAsByte<EMemoryUnitStandard> UnitStandard = EMemoryUnitStandard::IEC, bool bUseGrouping = true, int32 MinimumIntegralDigits = 1, int32 MaximumIntegralDigits = 324, int32 MinimumFractionalDigits = 0, int32 MaximumFractionalDigits = 3)"
  },
  {
    "label": "Format()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "Format(FText InPattern, TArray<FFormatArgumentData> InArgs)"
  },
  {
    "label": "TextIsFromStringTable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "TextIsFromStringTable(const FText& Text)"
  },
  {
    "label": "TextFromStringTable()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "TextFromStringTable(const FName TableId, const FString& Key)"
  },
  {
    "label": "StringTableIdAndKeyFromText()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "StringTableIdAndKeyFromText(FText Text, FName& OutTableId, FString& OutKey)"
  },
  {
    "label": "GetTextId()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetTextId(FText Text, FString& OutNamespace, FString& OutKey)"
  },
  {
    "label": "GetTextSourceString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "GetTextSourceString(FText Text)"
  },
  {
    "label": "IsPolyglotDataValid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IsPolyglotDataValid(const FPolyglotTextData& PolyglotData, bool& IsValid, FText& ErrorMessage)"
  },
  {
    "label": "PolyglotDataToText()",
    "kind": "Method",
    "detail": "Function (FText)",
    "insertText": "PolyglotDataToText(const FPolyglotTextData& PolyglotData)"
  }
]