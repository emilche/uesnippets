[
  {
    "label": "ValueAccessor0",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueAccessor0"
  },
  {
    "label": "ValueAccessor1",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueAccessor1"
  },
  {
    "label": "ValueAccessor2",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueAccessor2"
  },
  {
    "label": "ValueAccessor3",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueAccessor3"
  },
  {
    "label": "CacheItem",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CacheItem"
  },
  {
    "label": "ValueAccessorBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueAccessorBase"
  },
  {
    "label": "Tree",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Tree"
  },
  {
    "label": "ValueAccessor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueAccessor"
  },
  {
    "label": "RootNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RootNode"
  },
  {
    "label": "InternalNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "InternalNode"
  },
  {
    "label": "LeafNode",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LeafNode"
  },
  {
    "label": "ValueAccessorRW",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueAccessorRW"
  },
  {
    "label": "isSafe()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TREE_VALUEACCESSOR_HAS_BEEN_INCLUDED # define OPENVDB_TREE_VALUEACCESSOR_HAS_BEEN_INCLUDED # include<tbb / null_mutex . h> # include<tbb / spin_mutex . h> # include<openvdb / version . h> # include<openvdb / Types . h> # include<cassert> # include<limits> # include<type_traits> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tree { template<TreeType,bool IsSafe = true> class ValueAccessor0 ; template<TreeType,bool IsSafe = true,Index L0 = 0> class ValueAccessor1 ; template<TreeType,bool IsSafe = true,Index L0 = 0,Index L1 = 1> class ValueAccessor2 ; template<TreeType,bool IsSafe = true,Index L0 = 0,Index L1 = 1,Index L2 = 2> class ValueAccessor3 ; template<TreeCacheT,NodeVecT,bool AtRoot> class CacheItem ; template<TreeType,bool IsSafe> class ValueAccessorBase { public : const bool IsConstTree = std::is_const<TreeType>::value ; bool)",
    "insertText": "isSafe()"
  },
  {
    "label": "ValueAccessorBase()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "ValueAccessorBase()"
  },
  {
    "label": "getTree()",
    "kind": "Method",
    "detail": "Function (} TreeType*)",
    "insertText": "getTree()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mTree)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ValueAccessorBase&)",
    "insertText": "operator(const ValueAccessorBase& other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mTree = other . mTree ;)",
    "insertText": "if(IsSafe && mTree) mTree->attachAccessor(*this)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (} return* this ; } void)",
    "insertText": "clear()"
  },
  {
    "label": "release()",
    "kind": "Method",
    "detail": "Function (protected : template<> class Tree ; void)",
    "insertText": "release()"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (mTree = nullptr ; } TreeType* mTree ; } ; template<_TreeType,bool IsSafe = true,Index CacheLevels = _TreeType::DEPTH - 1,MutexType = tbb::null_mutex> class ValueAccessor : public ValueAccessorBase<_TreeType,IsSafe> { public :)",
    "insertText": "static_assert(CacheLevels < _TreeType::DEPTH, \"cache size exceeds tree depth\")"
  },
  {
    "label": "ValueAccessor()",
    "kind": "Method",
    "detail": "Function (using TreeType = _TreeType ; using RootNodeT = TreeType::RootNodeType ; using LeafNodeT = TreeType::LeafNodeType ; using ValueType = RootNodeT::ValueType ; using BaseT = ValueAccessorBase<TreeType,IsSafe> ; using LockT = MutexType::scoped_lock ; using BaseT::IsConstTree ;)",
    "insertText": "ValueAccessor(TreeType& tree): BaseT(tree), mCache(*this)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "insert(Coord(), &tree.root())"
  },
  {
    "label": "ValueAccessor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueAccessor(const ValueAccessor& other): BaseT(other), mCache(*this, other.mCache)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ValueAccessor&)",
    "insertText": "operator(const ValueAccessor& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "operator(other)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "copy(*this, other.mCache)"
  },
  {
    "label": "ValueAccessor()",
    "kind": "Method",
    "detail": "Function (} return* this ; } ~)",
    "insertText": "ValueAccessor()"
  },
  {
    "label": "numCacheLevels()",
    "kind": "Method",
    "detail": "Function (Index)",
    "insertText": "numCacheLevels()"
  },
  {
    "label": "lock()",
    "kind": "Method",
    "detail": "Function (LockT)",
    "insertText": "lock(mMutex)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} const ValueType&)",
    "insertText": "getValue(const Coord& xyz)"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueOn(const Coord& xyz)"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "probeValue(const Coord& xyz, ValueType& value)"
  },
  {
    "label": "getValueDepth()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "getValueDepth(const Coord& xyz)"
  },
  {
    "label": "isVoxel()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isVoxel(const Coord& xyz)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValue(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "setValue(xyz, value)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOnly(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "setValueOnly(xyz, value)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(const Coord& xyz, const ValueType& value)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "setValueOff(xyz, value)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValue(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "modifyValue()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "modifyValue(xyz, op)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (} template<ModifyOp> void)",
    "insertText": "modifyValueAndActiveState(const Coord& xyz, const ModifyOp& op)"
  },
  {
    "label": "modifyValueAndActiveState()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "modifyValueAndActiveState(xyz, op)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setActiveState(const Coord& xyz, bool on = true)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "setActiveState(xyz, on)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOn(const Coord& xyz)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setActiveState(xyz, true)"
  },
  {
    "label": "setValueOff()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValueOff(const Coord& xyz)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "setActiveState(xyz, false)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (} template<NodeType> NodeType*)",
    "insertText": "getNode()"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (NodeType* node = nullptr ; mCache .)",
    "insertText": "getNode(node)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "insert(xyz, &node)"
  },
  {
    "label": "eraseNode()",
    "kind": "Method",
    "detail": "Function (} template<NodeType> void)",
    "insertText": "eraseNode()"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (NodeType* node = nullptr ; mCache .)",
    "insertText": "erase(node)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addLeaf(LeafNodeT* leaf)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "addLeaf(leaf)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addTile(Index level, const Coord& xyz, const ValueType& value, bool state)"
  },
  {
    "label": "addTile()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "addTile(level, xyz, value, state)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (} LeafNodeT*)",
    "insertText": "touchLeaf(const Coord& xyz)"
  },
  {
    "label": "probeNode()",
    "kind": "Method",
    "detail": "Function (} template<NodeT> NodeT*)",
    "insertText": "probeNode(const Coord& xyz)"
  },
  {
    "label": "probeConstNode()",
    "kind": "Method",
    "detail": "Function (} template<NodeT> const NodeT*)",
    "insertText": "probeConstNode(const Coord& xyz)"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (} LeafNodeT*)",
    "insertText": "probeLeaf(const Coord& xyz)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (} const LeafNodeT*)",
    "insertText": "probeConstLeaf(const Coord& xyz)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} template<NodeType> void)",
    "insertText": "insert(const Coord& xyz, NodeType* node)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mCache .)",
    "insertText": "insert(xyz, node)"
  },
  {
    "label": "ValueAccessor()",
    "kind": "Method",
    "detail": "Function (} using InvTreeT = RootNodeT::NodeChainType ; int64_t First = CacheLevels ; int64_t Last = InvTreeT::template Index<RootNodeT> ; using SubtreeT = InvTreeT::template RemoveByIndex<First,Last - 1> ; using CacheItemT = CacheItem<ValueAccessor,SubtreeT,SubtreeT::Size = = 1> ; CacheItemT mCache ; MutexType mMutex ; } ; template<TreeType,bool IsSafe> class ValueAccessor<TreeType,IsSafe,0,tbb::null_mutex> : public ValueAccessor0<TreeType,IsSafe> { public :)",
    "insertText": "ValueAccessor(TreeType& tree): ValueAccessor0<TreeType, IsSafe>(tree)"
  },
  {
    "label": "ValueAccessor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueAccessor(const ValueAccessor& other): ValueAccessor0<TreeType, IsSafe>(other)"
  },
  {
    "label": "ValueAccessor()",
    "kind": "Method",
    "detail": "Function (} ; template<TreeType,bool IsSafe> class ValueAccessor<TreeType,IsSafe,1,tbb::null_mutex> : public ValueAccessor1<TreeType,IsSafe> { public :)",
    "insertText": "ValueAccessor(TreeType& tree): ValueAccessor1<TreeType, IsSafe>(tree)"
  },
  {
    "label": "ValueAccessor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueAccessor(const ValueAccessor& other): ValueAccessor1<TreeType, IsSafe>(other)"
  },
  {
    "label": "ValueAccessor()",
    "kind": "Method",
    "detail": "Function (} ; template<TreeType,bool IsSafe> class ValueAccessor<TreeType,IsSafe,2,tbb::null_mutex> : public ValueAccessor2<TreeType,IsSafe> { public :)",
    "insertText": "ValueAccessor(TreeType& tree): ValueAccessor2<TreeType, IsSafe>(tree)"
  },
  {
    "label": "ValueAccessor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueAccessor(const ValueAccessor& other): ValueAccessor2<TreeType, IsSafe>(other)"
  },
  {
    "label": "ValueAccessor()",
    "kind": "Method",
    "detail": "Function (} ; template<TreeType,bool IsSafe> class ValueAccessor<TreeType,IsSafe,3,tbb::null_mutex> : public ValueAccessor3<TreeType,IsSafe> { public :)",
    "insertText": "ValueAccessor(TreeType& tree): ValueAccessor3<TreeType, IsSafe>(tree)"
  },
  {
    "label": "ValueAccessor()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueAccessor(const ValueAccessor&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (ValueAccessor&)",
    "insertText": "operator(const ValueAccessor&)"
  },
  {
    "label": "ValueAccessorRW()",
    "kind": "Method",
    "detail": "Function (} ; template<TreeType,bool IsSafe = true> class ValueAccessorRW : public ValueAccessor<TreeType,IsSafe,TreeType::DEPTH - 1,tbb::spin_mutex> { public :)",
    "insertText": "ValueAccessorRW(TreeType& tree) : ValueAccessor<TreeType, IsSafe, TreeType::DEPTH-1, tbb::spin_mutex>(tree)"
  },
  {
    "label": "CacheItem()",
    "kind": "Method",
    "detail": "Function (} } ; template<TreeCacheT,NodeVecT,bool AtRoot> class CacheItem { public : using NodeType = NodeVecT::Front ; using ValueType = NodeType::ValueType ; using LeafNodeType = NodeType::LeafNodeType ; using CoordLimits = std::numeric_limits<Int32> ;)",
    "insertText": "CacheItem(TreeCacheT& parent): mParent(&parent), mHash(CoordLimits::max()), mNode(nullptr), mNext(parent)"
  },
  {
    "label": "CacheItem()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CacheItem(TreeCacheT& parent, const CacheItem& other): mParent(&parent), mHash(other.mHash), mNode(other.mNode), mNext(parent, other.mNext)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (} CacheItem&)",
    "insertText": "copy(TreeCacheT& parent, const CacheItem& other)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (mParent =& parent ; mHash = other . mHash ; mNode = other . mNode ; mNext .)",
    "insertText": "copy(parent, other.mNext)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "insert(const Coord& xyz, const NodeType* node)"
  },
  {
    "label": "mHash()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mHash(node != nullptr) ? xyz & ~(NodeType::DIM-1) : Coord::max()"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mNode = node ; } template<OtherNodeType> void)",
    "insertText": "insert(const Coord& xyz, const OtherNodeType* node)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "erase(const NodeType*)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (mHash =)",
    "insertText": "max()"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (mNode = nullptr ; } template<OtherNodeType> void)",
    "insertText": "erase(const OtherNodeType* node)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "getNode(const NodeType*& node)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (node = mNode ; } void)",
    "insertText": "getNode(NodeType*& node)"
  },
  {
    "label": "NodeType()",
    "kind": "Method",
    "detail": "Function (node = const_cast<)",
    "insertText": "NodeType(mNode)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (} template<OtherNodeType> void)",
    "insertText": "getNode(OtherNodeType*& node)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mNode)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} return mNext .)",
    "insertText": "getValue(xyz)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "addLeaf(LeafNodeType* leaf)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (} return mNext .)",
    "insertText": "touchLeaf(xyz)"
  },
  {
    "label": "probeLeaf()",
    "kind": "Method",
    "detail": "Function (} return mNext .)",
    "insertText": "probeLeaf(xyz)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (} return mNext .)",
    "insertText": "probeConstLeaf(xyz)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if(this->isHashed(xyz))"
  },
  {
    "label": "NodeType()",
    "kind": "Method",
    "detail": "Function (} return const_cast<)",
    "insertText": "NodeType(mNode)->template probeNodeAndCache<NodeT>(xyz, *mParent)"
  },
  {
    "label": "NodeT()",
    "kind": "Method",
    "detail": "Function (} return mNext . template probeNode<)",
    "insertText": "NodeT(xyz)"
  },
  {
    "label": "NodeT()",
    "kind": "Method",
    "detail": "Function (} return mNode -> template probeConstNodeAndCache<)",
    "insertText": "NodeT(xyz, *mParent)"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (} return mNext .)",
    "insertText": "isValueOn(xyz)"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (} return mNext .)",
    "insertText": "probeValue(xyz, value)"
  },
  {
    "label": "getValueDepth()",
    "kind": "Method",
    "detail": "Function (} else { return mNext .)",
    "insertText": "getValueDepth(xyz)"
  },
  {
    "label": "isVoxel()",
    "kind": "Method",
    "detail": "Function (} else { return mNext .)",
    "insertText": "isVoxel(xyz)"
  },
  {
    "label": "NodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeType(mNode)->setValueAndCache(xyz, value, *mParent)"
  },
  {
    "label": "NodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeType(mNode)->setValueOnlyAndCache(xyz, value, *mParent)"
  },
  {
    "label": "NodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeType(mNode)->modifyValueAndCache(xyz, op, *mParent)"
  },
  {
    "label": "NodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeType(mNode)->modifyValueAndActiveStateAndCache(xyz, op, *mParent)"
  },
  {
    "label": "NodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeType(mNode)->setValueOffAndCache(xyz, value, *mParent)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "setActiveState(const Coord& xyz, bool on)"
  },
  {
    "label": "NodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeType(mNode)->setActiveStateAndCache(xyz, on, *mParent)"
  },
  {
    "label": "CacheItem()",
    "kind": "Method",
    "detail": "Function (} } private :)",
    "insertText": "CacheItem(const CacheItem&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CacheItem&)",
    "insertText": "operator(const CacheItem&)"
  },
  {
    "label": "isHashed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isHashed(const Coord& xyz)"
  },
  {
    "label": "CacheItem()",
    "kind": "Method",
    "detail": "Function (} TreeCacheT* mParent ; Coord mHash ; const NodeType* mNode ; using RestT = NodeVecT::PopFront ; CacheItem<TreeCacheT,RestT,RestT::Size = = 1> mNext ; } ; template<TreeCacheT,NodeVecT> class CacheItem<TreeCacheT,NodeVecT,true> { public : using RootNodeType = NodeVecT::Front ; using ValueType = RootNodeType::ValueType ; using LeafNodeType = RootNodeType::LeafNodeType ;)",
    "insertText": "CacheItem(TreeCacheT& parent): mParent(&parent), mRoot(nullptr)"
  },
  {
    "label": "CacheItem()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "CacheItem(TreeCacheT& parent, const CacheItem& other): mParent(&parent), mRoot(other.mRoot)"
  },
  {
    "label": "isCached()",
    "kind": "Method",
    "detail": "Function (mParent =& parent ; mRoot = other . mRoot ; return* this ; } bool)",
    "insertText": "isCached(const Coord& xyz)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "insert(const Coord&, const RootNodeType* root)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mRoot = root ; } template<OtherNodeType> void)",
    "insertText": "insert(const Coord&, const OtherNodeType*)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "erase(const RootNodeType*)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (mRoot = nullptr ; } void)",
    "insertText": "getNode(RootNodeType*& node)"
  },
  {
    "label": "RootNodeType()",
    "kind": "Method",
    "detail": "Function (node = const_cast<)",
    "insertText": "RootNodeType(mRoot)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "getNode(const RootNodeType*& node)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mRoot)"
  },
  {
    "label": "RootNodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "RootNodeType(mRoot)->addLeafAndCache(leaf, *mParent)"
  },
  {
    "label": "RootNodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "RootNodeType(mRoot)->addTileAndCache(level, xyz, value, state, *mParent)"
  },
  {
    "label": "RootNodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "RootNodeType(mRoot)->setValueAndCache(xyz, value, *mParent)"
  },
  {
    "label": "RootNodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "RootNodeType(mRoot)->setValueOnlyAndCache(xyz, value, *mParent)"
  },
  {
    "label": "RootNodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "RootNodeType(mRoot)->modifyValueAndCache(xyz, op, *mParent)"
  },
  {
    "label": "RootNodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "RootNodeType(mRoot)->modifyValueAndActiveStateAndCache(xyz, op, *mParent)"
  },
  {
    "label": "RootNodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "RootNodeType(mRoot)->setValueOffAndCache(xyz, value, *mParent)"
  },
  {
    "label": "RootNodeType()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "RootNodeType(mRoot)->setActiveStateAndCache(xyz, on, *mParent)"
  },
  {
    "label": "isHashed()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isHashed(const Coord&)"
  },
  {
    "label": "ValueAccessor0()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueAccessor0(const ValueAccessor0& other): BaseT(other)"
  },
  {
    "label": "isCached()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isCached(const Coord&)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(BaseT::mTree)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (BaseT::mTree ->)",
    "insertText": "root().setValueOff(xyz, value)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (BaseT::mTree ->)",
    "insertText": "root().addLeaf(leaf)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (BaseT::mTree ->)",
    "insertText": "root().addTile(level, xyz, value, state)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } ; template<_TreeType,bool IsSafe,Index L0> class ValueAccessor1 : public ValueAccessorBase<_TreeType,IsSafe> { public :)",
    "insertText": "static_assert(_TreeType::DEPTH >= 2, \"cache size exceeds tree depth\")"
  },
  {
    "label": "ValueAccessor1()",
    "kind": "Method",
    "detail": "Function (using TreeType = _TreeType ; using ValueType = TreeType::ValueType ; using RootNodeT = TreeType::RootNodeType ; using LeafNodeT = TreeType::LeafNodeType ; using BaseT = ValueAccessorBase<TreeType,IsSafe> ; using InvTreeT = RootNodeT::NodeChainType ; using NodeT0 = InvTreeT::template Get<L0> ;)",
    "insertText": "ValueAccessor1(TreeType& tree) : BaseT(tree), mKey0(Coord::max()), mNode0(nullptr)"
  },
  {
    "label": "ValueAccessor1()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueAccessor1(const ValueAccessor1& other) : BaseT(other)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "copy(other)"
  },
  {
    "label": "ValueAccessor1()",
    "kind": "Method",
    "detail": "Function (} return* this ; } ~)",
    "insertText": "ValueAccessor1()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mNode0)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} return BaseT::mTree ->)",
    "insertText": "root().getValueAndCache(xyz, this->self())"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} return BaseT::mTree ->)",
    "insertText": "root().isValueOnAndCache(xyz, this->self())"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} return BaseT::mTree ->)",
    "insertText": "root().probeValueAndCache(xyz, value, this->self())"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} return BaseT::mTree ->)",
    "insertText": "root().getValueDepthAndCache(xyz, this->self())"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} return BaseT::mTree ->)",
    "insertText": "root().getValueDepthAndCache(xyz, this->self()) == static_cast<int>(RootNodeT::LEVEL)"
  },
  {
    "label": "NodeT0()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT0(mNode0)->setValueAndCache(xyz, value, *this)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} else { BaseT::mTree ->)",
    "insertText": "root().setValueAndCache(xyz, value, *this)"
  },
  {
    "label": "NodeT0()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT0(mNode0)->setValueOnlyAndCache(xyz, value, *this)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} else { BaseT::mTree ->)",
    "insertText": "root().setValueOnlyAndCache(xyz, value, *this)"
  },
  {
    "label": "NodeT0()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT0(mNode0)->setValueOffAndCache(xyz, value, *this)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} else { BaseT::mTree ->)",
    "insertText": "root().setValueOffAndCache(xyz, value, *this)"
  },
  {
    "label": "NodeT0()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT0(mNode0)->modifyValueAndCache(xyz, op, *this)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} else { BaseT::mTree ->)",
    "insertText": "root().modifyValueAndCache(xyz, op, *this)"
  },
  {
    "label": "NodeT0()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT0(mNode0)->modifyValueAndActiveStateAndCache(xyz, op, *this)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} else { BaseT::mTree ->)",
    "insertText": "root().modifyValueAndActiveStateAndCache(xyz, op, *this)"
  },
  {
    "label": "NodeT0()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT0(mNode0)->setActiveStateAndCache(xyz, on, *this)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} else { BaseT::mTree ->)",
    "insertText": "root().setActiveStateAndCache(xyz, on, *this)"
  },
  {
    "label": "insertNode()",
    "kind": "Method",
    "detail": "Function (} template<NodeT> void)",
    "insertText": "insertNode(const Coord& xyz, NodeT& node)"
  },
  {
    "label": "eraseNode()",
    "kind": "Method",
    "detail": "Function (const NodeT* node = nullptr ; this ->)",
    "insertText": "eraseNode(node)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} return BaseT::mTree ->)",
    "insertText": "root().touchLeafAndCache(xyz, *this)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN)",
    "insertText": "if((std::is_same<NodeT, NodeT0>::value))"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} return BaseT::mTree ->)",
    "insertText": "root().template probeNodeAndCache<NodeT>(xyz, *this)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} return BaseT::mTree ->)",
    "insertText": "root().template probeConstNodeAndCache<NodeT>(xyz, this->self())"
  },
  {
    "label": "self()",
    "kind": "Method",
    "detail": "Function (mNode0 = nullptr ; } private : template<> class RootNode ; template<,Index> class InternalNode ; template<,Index> class LeafNode ; template<> class Tree ; ValueAccessor1&)",
    "insertText": "self()"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "getNode(const NodeT0*& node)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (node = mNode0 ; } void)",
    "insertText": "getNode(const RootNodeT*& node)"
  },
  {
    "label": "node()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "node(BaseT::mTree ? &BaseT::mTree->root() : nullptr)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (} template<OtherNodeType> void)",
    "insertText": "getNode(const OtherNodeType*& node)"
  },
  {
    "label": "eraseNode()",
    "kind": "Method",
    "detail": "Function (node = nullptr ; } void)",
    "insertText": "eraseNode(const NodeT0*)"
  },
  {
    "label": "eraseNode()",
    "kind": "Method",
    "detail": "Function (mNode0 = nullptr ; } template<OtherNodeType> void)",
    "insertText": "eraseNode(const OtherNodeType*)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "copy(const ValueAccessor1& other)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "insert(const Coord& xyz, const NodeT0* node)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(node)"
  },
  {
    "label": "xyz()",
    "kind": "Method",
    "detail": "Function (mKey0 =)",
    "insertText": "xyz(NodeT0::DIM-1)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} Coord mKey0 ; const NodeT0* mNode0 ; } ; template<_TreeType,bool IsSafe,Index L0,Index L1> class ValueAccessor2 : public ValueAccessorBase<_TreeType,IsSafe> { public :)",
    "insertText": "static_assert(_TreeType::DEPTH >= 3, \"cache size exceeds tree depth\")"
  },
  {
    "label": "ValueAccessor2()",
    "kind": "Method",
    "detail": "Function (using TreeType = _TreeType ; using ValueType = TreeType::ValueType ; using RootNodeT = TreeType::RootNodeType ; using LeafNodeT = TreeType::LeafNodeType ; using BaseT = ValueAccessorBase<TreeType,IsSafe> ; using InvTreeT = RootNodeT::NodeChainType ; using NodeT0 = InvTreeT::template Get<L0> ; using NodeT1 = InvTreeT::template Get<L1> ;)",
    "insertText": "ValueAccessor2(TreeType& tree) : BaseT(tree), mKey0(Coord::max()), mNode0(nullptr), mKey1(Coord::max()), mNode1(nullptr)"
  },
  {
    "label": "ValueAccessor2()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueAccessor2(const ValueAccessor2& other) : BaseT(other)"
  },
  {
    "label": "ValueAccessor2()",
    "kind": "Method",
    "detail": "Function (} return* this ; } ~)",
    "insertText": "ValueAccessor2()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->isHashed1(xyz))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mNode1)"
  },
  {
    "label": "NodeT1()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT1(mNode1)->setValueAndCache(xyz, value, *this)"
  },
  {
    "label": "NodeT1()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT1(mNode1)->setValueOnlyAndCache(xyz, value, *this)"
  },
  {
    "label": "NodeT1()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT1(mNode1)->setValueOffAndCache(xyz, value, *this)"
  },
  {
    "label": "NodeT1()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT1(mNode1)->modifyValueAndCache(xyz, op, *this)"
  },
  {
    "label": "NodeT1()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT1(mNode1)->modifyValueAndActiveStateAndCache(xyz, op, *this)"
  },
  {
    "label": "NodeT1()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT1(mNode1)->setActiveStateAndCache(xyz, on, *this)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} BaseT::mTree ->)",
    "insertText": "root().addLeafAndCache(leaf, *this)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (} BaseT::mTree ->)",
    "insertText": "root().addTileAndCache(level, xyz, value, state, *this)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((std::is_same<NodeT, NodeT1>::value))"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (node = mNode0 ; } void)",
    "insertText": "getNode(const NodeT1*& node)"
  },
  {
    "label": "eraseNode()",
    "kind": "Method",
    "detail": "Function (mNode0 = nullptr ; } void)",
    "insertText": "eraseNode(const NodeT1*)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "copy(const ValueAccessor2& other)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mNode0 = node ; } void)",
    "insertText": "insert(const Coord& xyz, const NodeT1* node)"
  },
  {
    "label": "xyz()",
    "kind": "Method",
    "detail": "Function (mKey1 =)",
    "insertText": "xyz(NodeT1::DIM-1)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mNode1 = node ; } template<NodeT> void)",
    "insertText": "insert(const Coord&, const NodeT*)"
  },
  {
    "label": "isHashed0()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isHashed0(const Coord& xyz)"
  },
  {
    "label": "isHashed1()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isHashed1(const Coord& xyz)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} Coord mKey0 ; const NodeT0* mNode0 ; Coord mKey1 ; const NodeT1* mNode1 ; } ; template<_TreeType,bool IsSafe,Index L0,Index L1,Index L2> class ValueAccessor3 : public ValueAccessorBase<_TreeType,IsSafe> { public :)",
    "insertText": "static_assert(_TreeType::DEPTH >= 4, \"cache size exceeds tree depth\")"
  },
  {
    "label": "ValueAccessor3()",
    "kind": "Method",
    "detail": "Function (using TreeType = _TreeType ; using ValueType = TreeType::ValueType ; using RootNodeT = TreeType::RootNodeType ; using LeafNodeT = TreeType::LeafNodeType ; using BaseT = ValueAccessorBase<TreeType,IsSafe> ; using InvTreeT = RootNodeT::NodeChainType ; using NodeT0 = InvTreeT::template Get<L0> ; using NodeT1 = InvTreeT::template Get<L1> ; using NodeT2 = InvTreeT::template Get<L2> ;)",
    "insertText": "ValueAccessor3(TreeType& tree) : BaseT(tree), mKey0(Coord::max()), mNode0(nullptr), mKey1(Coord::max()), mNode1(nullptr), mKey2(Coord::max()), mNode2(nullptr)"
  },
  {
    "label": "ValueAccessor3()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueAccessor3(const ValueAccessor3& other) : BaseT(other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ValueAccessor3&)",
    "insertText": "operator(const ValueAccessor3& other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->isHashed2(xyz))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mNode2)"
  },
  {
    "label": "NodeT2()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT2(mNode2)->setValueAndCache(xyz, value, *this)"
  },
  {
    "label": "NodeT2()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT2(mNode2)->setValueOnlyAndCache(xyz, value, *this)"
  },
  {
    "label": "NodeT2()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT2(mNode2)->setValueOffAndCache(xyz, value, *this)"
  },
  {
    "label": "NodeT2()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT2(mNode2)->modifyValueAndCache(xyz, op, *this)"
  },
  {
    "label": "NodeT2()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT2(mNode2)->modifyValueAndActiveStateAndCache(xyz, op, *this)"
  },
  {
    "label": "NodeT2()",
    "kind": "Method",
    "detail": "Function (const_cast<)",
    "insertText": "NodeT2(mNode2)->setActiveStateAndCache(xyz, on, *this)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(this->isHashed2(leaf->origin()))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if((std::is_same<NodeT, NodeT2>::value))"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "copy(const ValueAccessor3& other)"
  },
  {
    "label": "getNode()",
    "kind": "Method",
    "detail": "Function (node = mNode1 ; } void)",
    "insertText": "getNode(const NodeT2*& node)"
  },
  {
    "label": "eraseNode()",
    "kind": "Method",
    "detail": "Function (mNode1 = nullptr ; } void)",
    "insertText": "eraseNode(const NodeT2*)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (mNode1 = node ; } void)",
    "insertText": "insert(const Coord& xyz, const NodeT2* node)"
  },
  {
    "label": "xyz()",
    "kind": "Method",
    "detail": "Function (mKey2 =)",
    "insertText": "xyz(NodeT2::DIM-1)"
  },
  {
    "label": "isHashed2()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isHashed2(const Coord& xyz)"
  }
]