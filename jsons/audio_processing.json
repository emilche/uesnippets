[
  {
    "label": "TaskQueue",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TaskQueue"
  },
  {
    "label": "AecDump",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AecDump"
  },
  {
    "label": "AudioBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AudioBuffer"
  },
  {
    "label": "StreamConfig",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StreamConfig"
  },
  {
    "label": "ProcessingConfig",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ProcessingConfig"
  },
  {
    "label": "EchoDetector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "EchoDetector"
  },
  {
    "label": "CustomAudioAnalyzer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CustomAudioAnalyzer"
  },
  {
    "label": "CustomProcessing",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CustomProcessing"
  },
  {
    "label": "RTC_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RTC_EXPORT"
  },
  {
    "label": "PreAmplifier",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PreAmplifier"
  },
  {
    "label": "CaptureLevelAdjustment",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CaptureLevelAdjustment"
  },
  {
    "label": "AnalogMicGainEmulation",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AnalogMicGainEmulation"
  },
  {
    "label": "HighPassFilter",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "HighPassFilter"
  },
  {
    "label": "EchoCanceller",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EchoCanceller"
  },
  {
    "label": "NoiseSuppression",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "NoiseSuppression"
  },
  {
    "label": "Level",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Level"
  },
  {
    "label": "TransientSuppression",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TransientSuppression"
  },
  {
    "label": "Mode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Mode"
  },
  {
    "label": "AnalogGainController",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AnalogGainController"
  },
  {
    "label": "ClippingPredictor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ClippingPredictor"
  },
  {
    "label": "FixedDigital",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FixedDigital"
  },
  {
    "label": "InputVolumeController",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "InputVolumeController"
  },
  {
    "label": "RuntimeSetting",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "RuntimeSetting"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "PlayoutAudioDeviceInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "PlayoutAudioDeviceInfo"
  },
  {
    "label": "Error",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Error"
  },
  {
    "label": "NativeRate",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "NativeRate"
  },
  {
    "label": "StreamName",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "StreamName"
  },
  {
    "label": "Metrics",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Metrics"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# ifndef MODULES_AUDIO_PROCESSING_INCLUDE_AUDIO_PROCESSING_H_ # define MODULES_AUDIO_PROCESSING_INCLUDE_AUDIO_PROCESSING_H_ # ifndef _USE_MATH_DEFINES # define _USE_MATH_DEFINES # endif # include<math . h> # include<stddef . h> # include<stdio . h> # include<string . h> # include<vector> # include \" absl / strings / string_view . h \" # include \" absl / types / optional . h \" # include \" api / array_view . h \" # include \" api / audio / echo_canceller3_config . h \" # include \" api / audio / echo_control . h \" # include \" api / scoped_refptr . h \" # include \" modules / audio_processing / include / audio_processing_statistics . h \" # include \" rtc_base / arraysize . h \" # include \" rtc_base / ref_count . h \" # include \" rtc_base / system / file_wrapper . h \" # include \" rtc_base / system / rtc_export . h \" namespace rtc { class TaskQueue ; } namespace webrtc { class AecDump ; class AudioBuffer ; class StreamConfig ; class ProcessingConfig ; class EchoDetector ; class CustomAudioAnalyzer ; class CustomProcessing ; class RTC_EXPORT AudioProcessing : public rtc::RefCountInterface { public : struct RTC_EXPORT Config { struct RTC_EXPORT Pipeline { int maximum_internal_processing_rate = 4 8 0 0 0 ; bool multi_channel_render = false ; bool multi_channel_capture = false ; } pipeline ; struct PreAmplifier { bool enabled = false ; float fixed_gain_factor = 1 . 0 f ; } pre_amplifier ; struct CaptureLevelAdjustment { bool)",
    "insertText": "operator(const CaptureLevelAdjustment& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool enabled = false ; float pre_gain_factor = 1 . 0 f ; float post_gain_factor = 1 . 0 f ; struct AnalogMicGainEmulation { bool)",
    "insertText": "operator(const AnalogMicGainEmulation& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool enabled = false ; int initial_level = 2 5 5 ; } analog_mic_gain_emulation ; } capture_level_adjustment ; struct HighPassFilter { bool enabled = false ; bool apply_in_full_band = true ; } high_pass_filter ; struct EchoCanceller { bool enabled = false ; bool mobile_mode = false ; bool export_linear_aec_output = false ; bool enforce_high_pass_filtering = true ; } echo_canceller ; struct NoiseSuppression { bool enabled = false ; enum Level { kLow,kModerate,kHigh,kVeryHigh } ; Level level = kModerate ; bool analyze_linear_aec_output_when_available = false ; } noise_suppression ; struct TransientSuppression { bool enabled = false ; } transient_suppression ; struct RTC_EXPORT GainController1 { bool)",
    "insertText": "operator(const GainController1& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool enabled = false ; enum Mode { kAdaptiveAnalog,kAdaptiveDigital,kFixedDigital } ; Mode mode = kAdaptiveAnalog ; int target_level_dbfs = 3 ; int compression_gain_db = 9 ; bool enable_limiter = true ; struct AnalogGainController { bool enabled = true ; int startup_min_volume = 0 ; int clipped_level_min = 7 0 ; bool enable_digital_adaptive = true ; int clipped_level_step = 1 5 ; float clipped_ratio_threshold = 0 . 1 f ; int clipped_wait_frames = 3 0 0 ; struct ClippingPredictor { bool enabled = false ; enum Mode { kClippingEventPrediction,kAdaptiveStepClippingPeakPrediction,kFixedStepClippingPeakPrediction,} ; Mode mode = kClippingEventPrediction ; int window_length = 5 ; int reference_window_length = 5 ; int reference_window_delay = 5 ; float clipping_threshold = - 1 . 0 f ; float crest_factor_margin = 3 . 0 f ; bool use_predicted_step = true ; } clipping_predictor ; } analog_gain_controller ; } gain_controller1 ; struct RTC_EXPORT GainController2 { bool)",
    "insertText": "operator(const GainController2& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool enabled = false ; struct FixedDigital { float gain_db = 0 . 0 f ; } fixed_digital ; struct RTC_EXPORT AdaptiveDigital { bool)",
    "insertText": "operator(const AdaptiveDigital& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool enabled = false ; bool dry_run = false ; float headroom_db = 6 . 0 f ; float max_gain_db = 3 0 . 0 f ; float initial_gain_db = 8 . 0 f ; int vad_reset_period_ms = 1 5 0 0 ; int adjacent_speech_frames_threshold = 1 2 ; float max_gain_change_db_per_second = 3 . 0 f ; float max_output_noise_level_dbfs = - 5 0 . 0 f ; } adaptive_digital ; struct InputVolumeController { bool)",
    "insertText": "operator(const InputVolumeController& rhs)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (} bool enabled = false ; } input_volume_controller ; } gain_controller2 ; std::string)",
    "insertText": "ToString()"
  },
  {
    "label": "RuntimeSetting()",
    "kind": "Method",
    "detail": "Function (} ; class RuntimeSetting { public : enum class Type { kNotSpecified,kCapturePreGain,kCaptureCompressionGain,kCaptureFixedPostGain,kPlayoutVolumeChange,kCustomRenderProcessingRuntimeSetting,kPlayoutAudioDeviceChange,kCapturePostGain,kCaptureOutputUsed } ; struct PlayoutAudioDeviceInfo { int id ; int max_volume ; } ;)",
    "insertText": "RuntimeSetting() : type_(Type::kNotSpecified), value_(0.0f)"
  },
  {
    "label": "RuntimeSetting()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "RuntimeSetting()"
  },
  {
    "label": "CreateCapturePreGain()",
    "kind": "Method",
    "detail": "Function (RuntimeSetting)",
    "insertText": "CreateCapturePreGain(float gain)"
  },
  {
    "label": "RTC_DCHECK_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_GE(gain_db, 0)"
  },
  {
    "label": "RTC_DCHECK_LE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_LE(gain_db, 90)"
  },
  {
    "label": "CreateCaptureFixedPostGain()",
    "kind": "Method",
    "detail": "Function (} RuntimeSetting)",
    "insertText": "CreateCaptureFixedPostGain(float gain_db)"
  },
  {
    "label": "RTC_DCHECK_GE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_GE(gain_db, 0.0f)"
  },
  {
    "label": "RTC_DCHECK_LE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK_LE(gain_db, 90.0f)"
  },
  {
    "label": "RTC_DCHECK()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RTC_DCHECK(value)"
  },
  {
    "label": "GetInt()",
    "kind": "Method",
    "detail": "Function (* value = value_ . float_value ; } void)",
    "insertText": "GetInt(int* value)"
  },
  {
    "label": "GetBool()",
    "kind": "Method",
    "detail": "Function (* value = value_ . int_value ; } void)",
    "insertText": "GetBool(bool* value)"
  },
  {
    "label": "GetPlayoutAudioDeviceInfo()",
    "kind": "Method",
    "detail": "Function (* value = value_ . bool_value ; } void)",
    "insertText": "GetPlayoutAudioDeviceInfo(PlayoutAudioDeviceInfo* value)"
  },
  {
    "label": "RuntimeSetting()",
    "kind": "Method",
    "detail": "Function (* value = value_ . playout_audio_device_info ; } private :)",
    "insertText": "RuntimeSetting(Type id, float value) : type_(id), value_(value)"
  },
  {
    "label": "RuntimeSetting()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RuntimeSetting(Type id, int value) : type_(id), value_(value)"
  },
  {
    "label": "RuntimeSetting()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "RuntimeSetting(Type id, PlayoutAudioDeviceInfo value) : type_(id), value_(value)"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (} Type type_ ; union U {)",
    "insertText": "U()"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "U(int value) : int_value(value)"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "U(float value) : float_value(value)"
  },
  {
    "label": "U()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "U(PlayoutAudioDeviceInfo value) : playout_audio_device_info(value)"
  },
  {
    "label": "AudioProcessing()",
    "kind": "Method",
    "detail": "Function (} float float_value ; int int_value ; bool bool_value ; PlayoutAudioDeviceInfo playout_audio_device_info ; } value_ ; } ; ~)",
    "insertText": "AudioProcessing()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "Initialize()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "Initialize(const ProcessingConfig& processing_config)"
  },
  {
    "label": "ApplyConfig()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ApplyConfig(const Config& config)"
  },
  {
    "label": "proc_sample_rate_hz()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "proc_sample_rate_hz()"
  },
  {
    "label": "proc_split_sample_rate_hz()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "proc_split_sample_rate_hz()"
  },
  {
    "label": "num_input_channels()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "num_input_channels()"
  },
  {
    "label": "num_proc_channels()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "num_proc_channels()"
  },
  {
    "label": "num_output_channels()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "num_output_channels()"
  },
  {
    "label": "num_reverse_channels()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "num_reverse_channels()"
  },
  {
    "label": "set_output_will_be_muted()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_output_will_be_muted(bool muted)"
  },
  {
    "label": "SetRuntimeSetting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetRuntimeSetting(RuntimeSetting setting)"
  },
  {
    "label": "PostRuntimeSetting()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "PostRuntimeSetting(RuntimeSetting setting)"
  },
  {
    "label": "ProcessStream()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ProcessStream(const int16_t* const src, const StreamConfig& input_config, const StreamConfig& output_config, int16_t* const dest)"
  },
  {
    "label": "ProcessStream()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ProcessStream(const float* const* src, const StreamConfig& input_config, const StreamConfig& output_config, float* const* dest)"
  },
  {
    "label": "ProcessReverseStream()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ProcessReverseStream(const int16_t* const src, const StreamConfig& input_config, const StreamConfig& output_config, int16_t* const dest)"
  },
  {
    "label": "ProcessReverseStream()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "ProcessReverseStream(const float* const* src, const StreamConfig& input_config, const StreamConfig& output_config, float* const* dest)"
  },
  {
    "label": "AnalyzeReverseStream()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "AnalyzeReverseStream(const float* const* data, const StreamConfig& reverse_config)"
  },
  {
    "label": "GetLinearAecOutput()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "GetLinearAecOutput(rtc::ArrayView<std::array<float, 160>> linear_output)"
  },
  {
    "label": "set_stream_analog_level()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_stream_analog_level(int level)"
  },
  {
    "label": "recommended_stream_analog_level()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "recommended_stream_analog_level()"
  },
  {
    "label": "set_stream_delay_ms()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "set_stream_delay_ms(int delay)"
  },
  {
    "label": "stream_delay_ms()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "stream_delay_ms()"
  },
  {
    "label": "set_stream_key_pressed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "set_stream_key_pressed(bool key_pressed)"
  },
  {
    "label": "CreateAndAttachAecDump()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CreateAndAttachAecDump(absl::string_view file_name, int64_t max_log_size_bytes, rtc::TaskQueue* worker_queue)"
  },
  {
    "label": "CreateAndAttachAecDump()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CreateAndAttachAecDump(FILE* handle, int64_t max_log_size_bytes, rtc::TaskQueue* worker_queue)"
  },
  {
    "label": "AttachAecDump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AttachAecDump(std::unique_ptr<AecDump> aec_dump)"
  },
  {
    "label": "DetachAecDump()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DetachAecDump()"
  },
  {
    "label": "GetStatistics()",
    "kind": "Method",
    "detail": "Function (AudioProcessingStats)",
    "insertText": "GetStatistics()"
  },
  {
    "label": "GetStatistics()",
    "kind": "Method",
    "detail": "Function (AudioProcessingStats)",
    "insertText": "GetStatistics(bool has_remote_tracks)"
  },
  {
    "label": "GetConfig()",
    "kind": "Method",
    "detail": "Function (AudioProcessing::Config)",
    "insertText": "GetConfig()"
  },
  {
    "label": "arraysize()",
    "kind": "Method",
    "detail": "Function (enum Error { kNoError = 0,kUnspecifiedError = - 1,kCreationFailedError = - 2,kUnsupportedComponentError = - 3,kUnsupportedFunctionError = - 4,kNullPointerError = - 5,kBadParameterError = - 6,kBadSampleRateError = - 7,kBadDataLengthError = - 8,kBadNumberChannelsError = - 9,kFileError = - 1 0,kStreamParameterNotSetError = - 1 1,kNotEnabledError = - 1 2,kBadStreamParameterWarning = - 1 3 } ; enum NativeRate { kSampleRate8kHz = 8 0 0 0,kSampleRate16kHz = 1 6 0 0 0,kSampleRate32kHz = 3 2 0 0 0,kSampleRate48kHz = 4 8 0 0 0 } ; int kNativeSampleRatesHz [ 4 ] = { kSampleRate8kHz,kSampleRate16kHz,kSampleRate32kHz,kSampleRate48kHz } ; size_t kNumNativeSampleRates =)",
    "insertText": "arraysize(kNativeSampleRatesHz)"
  },
  {
    "label": "GetFrameSize()",
    "kind": "Method",
    "detail": "Function (int kMaxNativeSampleRateHz = kNativeSampleRatesHz [ kNumNativeSampleRates - 1 ] ; int kChunkSizeMs = 1 0 ; int)",
    "insertText": "GetFrameSize(int sample_rate_hz)"
  },
  {
    "label": "AudioProcessingBuilder()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AudioProcessingBuilder(const AudioProcessingBuilder&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (AudioProcessingBuilder&)",
    "insertText": "operator(const AudioProcessingBuilder&)"
  },
  {
    "label": "AudioProcessingBuilder()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "AudioProcessingBuilder()"
  },
  {
    "label": "SetConfig()",
    "kind": "Method",
    "detail": "Function (AudioProcessingBuilder&)",
    "insertText": "SetConfig(const AudioProcessing::Config& config)"
  },
  {
    "label": "SetEchoControlFactory()",
    "kind": "Method",
    "detail": "Function (config_ = config ; return* this ; } AudioProcessingBuilder&)",
    "insertText": "SetEchoControlFactory(std::unique_ptr<EchoControlFactory> echo_control_factory)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (echo_control_factory_ =)",
    "insertText": "move(echo_control_factory)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (capture_post_processing_ =)",
    "insertText": "move(capture_post_processing)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (render_pre_processing_ =)",
    "insertText": "move(render_pre_processing)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (echo_detector_ =)",
    "insertText": "move(echo_detector)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (capture_analyzer_ =)",
    "insertText": "move(capture_analyzer)"
  },
  {
    "label": "StreamConfig()",
    "kind": "Method",
    "detail": "Function (private : AudioProcessing::Config config_ ; std::unique_ptr<EchoControlFactory> echo_control_factory_ ; std::unique_ptr<CustomProcessing> capture_post_processing_ ; std::unique_ptr<CustomProcessing> render_pre_processing_ ; rtc::scoped_refptr<EchoDetector> echo_detector_ ; std::unique_ptr<CustomAudioAnalyzer> capture_analyzer_ ; } ; class StreamConfig { public :)",
    "insertText": "StreamConfig(int sample_rate_hz = 0, size_t num_channels = 0) : sample_rate_hz_(sample_rate_hz), num_channels_(num_channels), num_frames_(calculate_frames(sample_rate_hz))"
  },
  {
    "label": "set_sample_rate_hz()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_sample_rate_hz(int value)"
  },
  {
    "label": "calculate_frames()",
    "kind": "Method",
    "detail": "Function (sample_rate_hz_ = value ; num_frames_ =)",
    "insertText": "calculate_frames(value)"
  },
  {
    "label": "set_num_channels()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_num_channels(size_t value)"
  },
  {
    "label": "sample_rate_hz()",
    "kind": "Method",
    "detail": "Function (num_channels_ = value ; } int)",
    "insertText": "sample_rate_hz()"
  },
  {
    "label": "calculate_frames()",
    "kind": "Method",
    "detail": "Function (} private : size_t)",
    "insertText": "calculate_frames(int sample_rate_hz)"
  },
  {
    "label": "input_stream()",
    "kind": "Method",
    "detail": "Function (} int sample_rate_hz_ ; size_t num_channels_ ; size_t num_frames_ ; } ; class ProcessingConfig { public : enum StreamName { kInputStream,kOutputStream,kReverseInputStream,kReverseOutputStream,kNumStreamNames,} ; const StreamConfig&)",
    "insertText": "input_stream()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} StreamConfig streams [ StreamName::kNumStreamNames ] ; } ; class CustomAudioAnalyzer { public : void)",
    "insertText": "Initialize(int sample_rate_hz, int num_channels)"
  },
  {
    "label": "Analyze()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Analyze(const AudioBuffer* audio)"
  },
  {
    "label": "CustomAudioAnalyzer()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CustomAudioAnalyzer()"
  },
  {
    "label": "Process()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Process(AudioBuffer* audio)"
  },
  {
    "label": "SetRuntimeSetting()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetRuntimeSetting(AudioProcessing::RuntimeSetting setting)"
  },
  {
    "label": "CustomProcessing()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "CustomProcessing()"
  },
  {
    "label": "Initialize()",
    "kind": "Method",
    "detail": "Function (} } ; class EchoDetector : public rtc::RefCountInterface { public : void)",
    "insertText": "Initialize(int capture_sample_rate_hz, int num_capture_channels, int render_sample_rate_hz, int num_render_channels)"
  },
  {
    "label": "AnalyzeRenderAudio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AnalyzeRenderAudio(rtc::ArrayView<const float> render_audio)"
  },
  {
    "label": "AnalyzeCaptureAudio()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AnalyzeCaptureAudio(rtc::ArrayView<const float> capture_audio)"
  },
  {
    "label": "GetMetrics()",
    "kind": "Method",
    "detail": "Function (struct Metrics { absl::optional<double> echo_likelihood ; absl::optional<double> echo_likelihood_recent_max ; } ; Metrics)",
    "insertText": "GetMetrics()"
  }
]