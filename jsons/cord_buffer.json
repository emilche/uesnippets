[
  {
    "label": "Cord",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Cord"
  },
  {
    "label": "CordBufferTestPeer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CordBufferTestPeer"
  },
  {
    "label": "CordBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CordBuffer"
  },
  {
    "label": "Rep",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Rep"
  },
  {
    "label": "Long",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Long"
  },
  {
    "label": "Short",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Short"
  },
  {
    "label": "CordBuffer()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_STRINGS_CORD_BUFFER_H_ # define ABSL_STRINGS_CORD_BUFFER_H_ # include<algorithm> # include<cassert> # include<cstddef> # include<cstdint> # include<memory> # include<utility> # include \" absl / base / config . h \" # include \" absl / base / macros . h \" # include \" absl / numeric / bits . h \" # include \" absl / strings / internal / cord_internal . h \" # include \" absl / strings / internal / cord_rep_flat . h \" # include \" absl / types / span . h \" namespace absl { ABSL_NAMESPACE_BEGIN class Cord ; class CordBufferTestPeer ; class CordBuffer { public : size_t kDefaultLimit = cord_internal::kMaxFlatLength ; size_t kCustomLimit = 6 4 U<<1 0 ;)",
    "insertText": "CordBuffer()"
  },
  {
    "label": "CordBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CordBuffer(CordBuffer&& rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CordBuffer&)",
    "insertText": "operator(CordBuffer&&)"
  },
  {
    "label": "CordBuffer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CordBuffer(const CordBuffer&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CordBuffer&)",
    "insertText": "operator(const CordBuffer&)"
  },
  {
    "label": "MaximumPayload()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "MaximumPayload()"
  },
  {
    "label": "MaximumPayload()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "MaximumPayload(size_t block_size)"
  },
  {
    "label": "CreateWithDefaultLimit()",
    "kind": "Method",
    "detail": "Function (CordBuffer)",
    "insertText": "CreateWithDefaultLimit(size_t capacity)"
  },
  {
    "label": "CreateWithCustomLimit()",
    "kind": "Method",
    "detail": "Function (CordBuffer)",
    "insertText": "CreateWithCustomLimit(size_t block_size, size_t capacity)"
  },
  {
    "label": "available()",
    "kind": "Method",
    "detail": "Function (absl::Span<char>)",
    "insertText": "available()"
  },
  {
    "label": "available_up_to()",
    "kind": "Method",
    "detail": "Function (absl::Span<char>)",
    "insertText": "available_up_to(size_t size)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (char*)",
    "insertText": "data()"
  },
  {
    "label": "length()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "length()"
  },
  {
    "label": "capacity()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "capacity()"
  },
  {
    "label": "IncreaseLengthBy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IncreaseLengthBy(size_t n)"
  },
  {
    "label": "SetLength()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetLength(size_t length)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "static_assert(kCustomLimit <= cord_internal::kMaxLargeFlatSize, \"\")"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (size_t kMaxPageSlop = 1 2 8 ; size_t kOverhead = cord_internal::kFlatOverhead ; using CordRepFlat = cord_internal::CordRepFlat ; struct Rep { size_t kInlineCapacity =)",
    "insertText": "sizeof(intptr_t)"
  },
  {
    "label": "Rep()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Rep()"
  },
  {
    "label": "Rep()",
    "kind": "Method",
    "detail": "Function (} { })",
    "insertText": "Rep(cord_internal::CordRepFlat* rep)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (rep } {)",
    "insertText": "assert(rep != nullptr)"
  },
  {
    "label": "is_short()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_short()"
  },
  {
    "label": "offsetof()",
    "kind": "Method",
    "detail": "Function (size_t offset =)",
    "insertText": "offsetof(Short, raw_size)"
  },
  {
    "label": "short_available()",
    "kind": "Method",
    "detail": "Function (} absl::Span<char>)",
    "insertText": "short_available()"
  },
  {
    "label": "short_length()",
    "kind": "Method",
    "detail": "Function (const size_t length =)",
    "insertText": "short_length()"
  },
  {
    "label": "long_available()",
    "kind": "Method",
    "detail": "Function (} absl::Span<char>)",
    "insertText": "long_available()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!is_short())"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const size_t length = long_rep . rep -> length ; return absl::Span<)",
    "insertText": "char(long_rep.rep->Data() + length, long_rep.rep->Capacity() - length)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(is_short())"
  },
  {
    "label": "set_short_length()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_short_length(size_t length)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (short_rep . raw_size = static_cast<)",
    "insertText": "char((length << 1) + 1)"
  },
  {
    "label": "add_short_length()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "add_short_length(size_t n)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (short_rep . raw_size + = static_cast<)",
    "insertText": "char(n << 1)"
  },
  {
    "label": "Long()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Long(cord_internal::CordRepFlat* rep_arg) : rep(rep_arg)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} void* padding ; cord_internal::CordRepFlat* rep ; } ; struct Short { char data [)",
    "insertText": "sizeof(Long)"
  },
  {
    "label": "IsPow2()",
    "kind": "Method",
    "detail": "Function (} ; # endif union { Long long_rep ; Short short_rep ; } ; } ; bool)",
    "insertText": "IsPow2(size_t size)"
  },
  {
    "label": "Log2Floor()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "Log2Floor(size_t size)"
  },
  {
    "label": "Log2Ceil()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "Log2Ceil(size_t size)"
  },
  {
    "label": "CreateWithCustomLimitImpl()",
    "kind": "Method",
    "detail": "Function (} template<. . . AllocationHints> CordBuffer)",
    "insertText": "CreateWithCustomLimitImpl(size_t block_size, size_t capacity, AllocationHints... hints)"
  },
  {
    "label": "ConsumeValue()",
    "kind": "Method",
    "detail": "Function (cord_internal::CordRep*)",
    "insertText": "ConsumeValue(absl::string_view& short_value)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (cord_internal::CordRep* rep = nullptr ;)",
    "insertText": "if(rep_.is_short())"
  },
  {
    "label": "string_view()",
    "kind": "Method",
    "detail": "Function (short_value =)",
    "insertText": "string_view(rep_.data(), rep_.short_length())"
  },
  {
    "label": "rep()",
    "kind": "Method",
    "detail": "Function (} else { rep = rep_ .)",
    "insertText": "rep()"
  },
  {
    "label": "set_short_length()",
    "kind": "Method",
    "detail": "Function (} rep_ .)",
    "insertText": "set_short_length(0)"
  },
  {
    "label": "New()",
    "kind": "Method",
    "detail": "Function (auto* rep = cord_internal::)",
    "insertText": "New(capacity)"
  },
  {
    "label": "CordBuffer()",
    "kind": "Method",
    "detail": "Function (rep -> length = 0 ; return)",
    "insertText": "CordBuffer(rep)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(IsPow2(block_size))"
  },
  {
    "label": "capacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "capacity(std::min)(capacity, kCustomLimit)"
  },
  {
    "label": "block_size()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "block_size(std::min)(block_size, kCustomLimit)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (capacity = block_size ; } else)",
    "insertText": "if(capacity <= kDefaultLimit)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (capacity = capacity + kOverhead ; } else)",
    "insertText": "if(!IsPow2(capacity))"
  },
  {
    "label": "Log2Ceil()",
    "kind": "Method",
    "detail": "Function (const size_t rounded_up = size_t { 1 }<<)",
    "insertText": "Log2Ceil(capacity)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const size_t slop = rounded_up - capacity ;)",
    "insertText": "if(slop >= kOverhead && slop <= kMaxPageSlop + kOverhead)"
  },
  {
    "label": "Log2Floor()",
    "kind": "Method",
    "detail": "Function (capacity = rounded_up ; } else { const size_t rounded_down = size_t { 1 }<<)",
    "insertText": "Log2Floor(capacity)"
  },
  {
    "label": "New()",
    "kind": "Method",
    "detail": "Function (capacity = rounded_down ; } } const size_t length = capacity - kOverhead ; auto* rep =)",
    "insertText": "New(CordRepFlat::Large(), length, hints...)"
  },
  {
    "label": "Delete()",
    "kind": "Method",
    "detail": "Function (cord_internal::)",
    "insertText": "Delete(rep_.rep())"
  },
  {
    "label": "CordBuffer()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "CordBuffer(CordBuffer&& rhs) noexcept : rep_(rhs.rep_)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} CordBuffer&)",
    "insertText": "operator(CordBuffer&& rhs)"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(length <= capacity())"
  },
  {
    "label": "set_short_length()",
    "kind": "Method",
    "detail": "Function (rep_ .)",
    "insertText": "set_short_length(length)"
  },
  {
    "label": "ABSL_HARDENING_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABSL_HARDENING_ASSERT(n <= capacity() && length() + n <= capacity())"
  },
  {
    "label": "add_short_length()",
    "kind": "Method",
    "detail": "Function (rep_ .)",
    "insertText": "add_short_length(n)"
  }
]