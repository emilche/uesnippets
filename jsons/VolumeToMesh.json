[
  {
    "label": "PolygonPool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PolygonPool"
  },
  {
    "label": "VolumeToMesh",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VolumeToMesh"
  },
  {
    "label": "FillArray",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FillArray"
  },
  {
    "label": "AccessorT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AccessorT"
  },
  {
    "label": "LeafType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "LeafType"
  },
  {
    "label": "ComputePoints",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ComputePoints"
  },
  {
    "label": "SeamLineWeights",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SeamLineWeights"
  },
  {
    "label": "SetSeamLineFlags",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SetSeamLineFlags"
  },
  {
    "label": "TransferSeamLineFlags",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TransferSeamLineFlags"
  },
  {
    "label": "MaskSeamLineVoxels",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskSeamLineVoxels"
  },
  {
    "label": "MergeVoxelRegions",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MergeVoxelRegions"
  },
  {
    "label": "UniformPrimBuilder",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "UniformPrimBuilder"
  },
  {
    "label": "AdaptivePrimBuilder",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AdaptivePrimBuilder"
  },
  {
    "label": "MaskTileBorders",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskTileBorders"
  },
  {
    "label": "PointListCopy",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PointListCopy"
  },
  {
    "label": "LeafNodeVoxelOffsets",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LeafNodeVoxelOffsets"
  },
  {
    "label": "VoxelEdgeAccessor",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "VoxelEdgeAccessor"
  },
  {
    "label": "IdentifyIntersectingVoxels",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IdentifyIntersectingVoxels"
  },
  {
    "label": "MaskIntersectingVoxels",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskIntersectingVoxels"
  },
  {
    "label": "MaskBorderVoxels",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskBorderVoxels"
  },
  {
    "label": "SyncMaskValues",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SyncMaskValues"
  },
  {
    "label": "MaskSurface",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskSurface"
  },
  {
    "label": "ComputeAuxiliaryData",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ComputeAuxiliaryData"
  },
  {
    "label": "LeafNodePointCount",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "LeafNodePointCount"
  },
  {
    "label": "AdaptiveLeafNodePointCount",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AdaptiveLeafNodePointCount"
  },
  {
    "label": "MapPoints",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MapPoints"
  },
  {
    "label": "ComputePolygons",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ComputePolygons"
  },
  {
    "label": "CopyArray",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CopyArray"
  },
  {
    "label": "FlagAndCountQuadsToSubdivide",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FlagAndCountQuadsToSubdivide"
  },
  {
    "label": "SubdivideQuads",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "SubdivideQuads"
  },
  {
    "label": "ReviseSeamLineFlags",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ReviseSeamLineFlags"
  },
  {
    "label": "MaskDisorientedTrianglePoints",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "MaskDisorientedTrianglePoints"
  },
  {
    "label": "volumeToMesh()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_TOOLS_VOLUME_TO_MESH_HAS_BEEN_INCLUDED # define OPENVDB_TOOLS_VOLUME_TO_MESH_HAS_BEEN_INCLUDED # include<openvdb / Platform . h> # include<openvdb / math / Operators . h> # include<openvdb / tree / ValueAccessor . h> # include<openvdb / util / Util . h> # include<tbb / blocked_range . h> # include<tbb / parallel_for . h> # include<tbb / parallel_reduce . h> # include<tbb / task_scheduler_init . h> # include<cmath> # include<map> # include<memory> # include<set> # include<type_traits> # include<vector> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace tools { template<GridType> void)",
    "insertText": "volumeToMesh(const GridType& grid, std::vector<Vec3s>& points, std::vector<Vec4I>& quads, double isovalue = 0.0)"
  },
  {
    "label": "volumeToMesh()",
    "kind": "Method",
    "detail": "Function (template<GridType> void)",
    "insertText": "volumeToMesh(const GridType& grid, std::vector<Vec3s>& points, std::vector<Vec3I>& triangles, std::vector<Vec4I>& quads, double isovalue = 0.0, double adaptivity = 0.0, bool relaxDisorientedTriangles = true)"
  },
  {
    "label": "PolygonPool()",
    "kind": "Method",
    "detail": "Function (enum { POLYFLAG_EXTERIOR = 0 x1,POLYFLAG_FRACTURE_SEAM = 0 x2,POLYFLAG_SUBDIVIDED = 0 x4 } ; class PolygonPool { public :)",
    "insertText": "PolygonPool()"
  },
  {
    "label": "PolygonPool()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PolygonPool(const size_t numQuads, const size_t numTriangles)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(const PolygonPool& rhs)"
  },
  {
    "label": "resetQuads()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resetQuads(size_t size)"
  },
  {
    "label": "clearQuads()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clearQuads()"
  },
  {
    "label": "resetTriangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resetTriangles(size_t size)"
  },
  {
    "label": "clearTriangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clearTriangles()"
  },
  {
    "label": "numQuads()",
    "kind": "Method",
    "detail": "Function (const size_t&)",
    "insertText": "numQuads()"
  },
  {
    "label": "trimTrinagles()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "trimTrinagles(const size_t n, bool reallocate = false)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "operator(const PolygonPool&)"
  },
  {
    "label": "VolumeToMesh()",
    "kind": "Method",
    "detail": "Function (} size_t mNumQuads,mNumTriangles ; std::unique_ptr<openvdb::Vec4I [ ]> mQuads ; std::unique_ptr<openvdb::Vec3I [ ]> mTriangles ; std::unique_ptr<char [ ]> mQuadFlags,mTriangleFlags ; } ; using PointList = std::unique_ptr<openvdb::Vec3s [ ]> ; using PolygonPoolList = std::unique_ptr<PolygonPool [ ]> ; struct VolumeToMesh {)",
    "insertText": "VolumeToMesh(double isovalue = 0, double adaptivity = 0, bool relaxDisorientedTriangles = true)"
  },
  {
    "label": "pointListSize()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "pointListSize()"
  },
  {
    "label": "setRefGrid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setRefGrid(const GridBase::ConstPtr& grid, double secAdaptivity = 0)"
  },
  {
    "label": "setSurfaceMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setSurfaceMask(const GridBase::ConstPtr& mask, bool invertMask = false)"
  },
  {
    "label": "setSpatialAdaptivity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setSpatialAdaptivity(const GridBase::ConstPtr& grid)"
  },
  {
    "label": "setAdaptivityMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setAdaptivityMask(const TreeBase::ConstPtr& tree)"
  },
  {
    "label": "VolumeToMesh()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "VolumeToMesh(const VolumeToMesh&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (VolumeToMesh&)",
    "insertText": "operator(const VolumeToMesh&)"
  },
  {
    "label": "findFeaturePoint()",
    "kind": "Method",
    "detail": "Function (PointList mPoints ; PolygonPoolList mPolygons ; size_t mPointListSize,mSeamPointListSize,mPolygonPoolListSize ; double mIsovalue,mPrimAdaptivity,mSecAdaptivity ; GridBase::ConstPtr mRefGrid,mSurfaceMaskGrid,mAdaptivityGrid ; TreeBase::ConstPtr mAdaptivityMaskTree ; TreeBase::Ptr mRefSignTree,mRefIdxTree ; bool mInvertSurfaceMask,mRelaxDisorientedTriangles ; std::unique_ptr<uint32_t [ ]> mQuantizedSeamPoints ; std::vector<uint8_t> mPointFlags ; } ; Vec3d)",
    "insertText": "findFeaturePoint(const std::vector<Vec3d>& points, const std::vector<Vec3d>& normals)"
  },
  {
    "label": "avgPos()",
    "kind": "Method",
    "detail": "Function (using Mat3d = math::Mat3d ; Vec3d)",
    "insertText": "avgPos(0.0)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (avgPos + = points [ n ] ; } avgPos / =)",
    "insertText": "double(points.size())"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (const Vec3d& n_ref = normals [ n ] ; m00 + = n_ref [ 0 ]* n_ref [ 0 ] ; m11 + = n_ref [ 1 ]* n_ref [ 1 ] ; m22 + = n_ref [ 2 ]* n_ref [ 2 ] ; m01 + = n_ref [ 0 ]* n_ref [ 1 ] ; m02 + = n_ref [ 0 ]* n_ref [ 2 ] ; m12 + = n_ref [ 1 ]* n_ref [ 2 ] ; rhs + = n_ref* n_ref .)",
    "insertText": "dot(points[n] - avgPos)"
  },
  {
    "label": "A()",
    "kind": "Method",
    "detail": "Function (} Mat3d)",
    "insertText": "A(m00,m01,m02, m01,m11,m12, m02,m12,m22)"
  },
  {
    "label": "diagonalizeSymmetricMatrix()",
    "kind": "Method",
    "detail": "Function (math::Mat3d eigenVectors ; Vec3d eigenValues ;)",
    "insertText": "diagonalizeSymmetricMatrix(A, eigenVectors, eigenValues, 300)"
  },
  {
    "label": "identity()",
    "kind": "Method",
    "detail": "Function (Mat3d D =)",
    "insertText": "identity()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (tolerance =)",
    "insertText": "max(tolerance, std::abs(eigenValues[2]))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (tolerance* = 0 . 0 1 ; int clamped = 0 ;)",
    "insertText": "for(int i = 0; i < 3; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (D [ i ] [ i ] = 0 . 0 ; + + clamped ; } else { D [ i ] [ i ] = 1 . 0 / eigenValues [ i ] ; } })",
    "insertText": "if(clamped < 3)"
  },
  {
    "label": "transpose()",
    "kind": "Method",
    "detail": "Function (Mat3d pseudoInv = eigenVectors* D* eigenVectors .)",
    "insertText": "transpose()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const tbb::blocked_range<size_t>& range)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const ValueType v = mValue ;)",
    "insertText": "for(size_t n = range.begin(), N = range.end(); n < N; ++n)"
  },
  {
    "label": "fillArray()",
    "kind": "Method",
    "detail": "Function (mArray [ n ] = v ; } } ValueType* const mArray ; const ValueType mValue ; } ; template<ValueType> void)",
    "insertText": "fillArray(ValueType* array, const ValueType& val, const size_t length)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (const auto grainSize = std::max<)",
    "insertText": "size_t(length / tbb::task_scheduler_init::default_num_threads(), 1024)"
  },
  {
    "label": "range()",
    "kind": "Method",
    "detail": "Function (const tbb::blocked_range<size_t>)",
    "insertText": "range(0, length, grainSize)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(range, FillArray<ValueType>(array, val), tbb::simple_partitioner())"
  },
  {
    "label": "isPlanarQuad()",
    "kind": "Method",
    "detail": "Function (} enum { SIGNS = 0 xFF,EDGES = 0 xE00,INSIDE = 0 x100,XEDGE = 0 x200,YEDGE = 0 x400,ZEDGE = 0 x800,SEAM = 0 x1000 } ; const bool sAdaptable [ 2 5 6 ] = { 1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,0,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1 } ; const unsigned char sAmbiguousFace [ 2 5 6 ] = { 0,0,0,0,0,5,0,0,0,0,5,0,0,0,0,0,0,0,1,0,0,5,1,0,4,0,0,0,4,0,0,0,0,1,0,0,2,0,0,0,0,1,5,0,2,0,0,0,0,0,0,0,2,0,0,0,4,0,0,0,0,0,0,0,0,0,2,2,0,5,0,0,3,3,0,0,0,0,0,0,6,6,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,4,3,0,3,0,0,0,5,0,0,0,0,0,0,0,1,0,3,0,0,0,0,0,0,0,0,0,0,0,6,0,6,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } ; const unsigned char sEdgeGroupTable [ 2 5 6 ] [ 1 3 ] = { { 0,0,0,0,0,0,0,0,0,0,0,0,0 },{ 1,1,0,0,1,0,0,0,0,1,0,0,0 },{ 1,1,1,0,0,0,0,0,0,0,1,0,0 },{ 1,0,1,0,1,0,0,0,0,1,1,0,0 },{ 1,0,1,1,0,0,0,0,0,0,0,1,0 },{ 1,1,1,1,1,0,0,0,0,1,0,1,0 },{ 1,1,0,1,0,0,0,0,0,0,1,1,0 },{ 1,0,0,1,1,0,0,0,0,1,1,1,0 },{ 1,0,0,1,1,0,0,0,0,0,0,0,1 },{ 1,1,0,1,0,0,0,0,0,1,0,0,1 },{ 1,1,1,1,1,0,0,0,0,0,1,0,1 },{ 1,0,1,1,0,0,0,0,0,1,1,0,1 },{ 1,0,1,0,1,0,0,0,0,0,0,1,1 },{ 1,1,1,0,0,0,0,0,0,1,0,1,1 },{ 1,1,0,0,1,0,0,0,0,0,1,1,1 },{ 1,0,0,0,0,0,0,0,0,1,1,1,1 },{ 1,0,0,0,0,1,0,0,1,1,0,0,0 },{ 1,1,0,0,1,1,0,0,1,0,0,0,0 },{ 1,1,1,0,0,1,0,0,1,1,1,0,0 },{ 1,0,1,0,1,1,0,0,1,0,1,0,0 },{ 2,0,1,1,0,2,0,0,2,2,0,1,0 },{ 1,1,1,1,1,1,0,0,1,0,0,1,0 },{ 1,1,0,1,0,1,0,0,1,1,1,1,0 },{ 1,0,0,1,1,1,0,0,1,0,1,1,0 },{ 1,0,0,1,1,1,0,0,1,1,0,0,1 },{ 1,1,0,1,0,1,0,0,1,0,0,0,1 },{ 2,2,1,1,2,1,0,0,1,2,1,0,1 },{ 1,0,1,1,0,1,0,0,1,0,1,0,1 },{ 1,0,1,0,1,1,0,0,1,1,0,1,1 },{ 1,1,1,0,0,1,0,0,1,0,0,1,1 },{ 2,1,0,0,1,2,0,0,2,1,2,2,2 },{ 1,0,0,0,0,1,0,0,1,0,1,1,1 },{ 1,0,0,0,0,1,1,0,0,0,1,0,0 },{ 1,1,0,0,1,1,1,0,0,1,1,0,0 },{ 1,1,1,0,0,1,1,0,0,0,0,0,0 },{ 1,0,1,0,1,1,1,0,0,1,0,0,0 },{ 1,0,1,1,0,1,1,0,0,0,1,1,0 },{ 2,2,2,1,1,1,1,0,0,1,2,1,0 },{ 1,1,0,1,0,1,1,0,0,0,0,1,0 },{ 1,0,0,1,1,1,1,0,0,1,0,1,0 },{ 2,0,0,2,2,1,1,0,0,0,1,0,2 },{ 1,1,0,1,0,1,1,0,0,1,1,0,1 },{ 1,1,1,1,1,1,1,0,0,0,0,0,1 },{ 1,0,1,1,0,1,1,0,0,1,0,0,1 },{ 1,0,1,0,1,1,1,0,0,0,1,1,1 },{ 2,1,1,0,0,2,2,0,0,2,1,2,2 },{ 1,1,0,0,1,1,1,0,0,0,0,1,1 },{ 1,0,0,0,0,1,1,0,0,1,0,1,1 },{ 1,0,0,0,0,0,1,0,1,1,1,0,0 },{ 1,1,0,0,1,0,1,0,1,0,1,0,0 },{ 1,1,1,0,0,0,1,0,1,1,0,0,0 },{ 1,0,1,0,1,0,1,0,1,0,0,0,0 },{ 1,0,1,1,0,0,1,0,1,1,1,1,0 },{ 2,1,1,2,2,0,2,0,2,0,1,2,0 },{ 1,1,0,1,0,0,1,0,1,1,0,1,0 },{ 1,0,0,1,1,0,1,0,1,0,0,1,0 },{ 1,0,0,1,1,0,1,0,1,1,1,0,1 },{ 1,1,0,1,0,0,1,0,1,0,1,0,1 },{ 2,1,2,2,1,0,2,0,2,1,0,0,2 },{ 1,0,1,1,0,0,1,0,1,0,0,0,1 },{ 2,0,2,0,2,0,1,0,1,2,2,1,1 },{ 2,2,2,0,0,0,1,0,1,0,2,1,1 },{ 2,2,0,0,2,0,1,0,1,2,0,1,1 },{ 1,0,0,0,0,0,1,0,1,0,0,1,1 },{ 1,0,0,0,0,0,1,1,0,0,0,1,0 },{ 2,1,0,0,1,0,2,2,0,1,0,2,0 },{ 1,1,1,0,0,0,1,1,0,0,1,1,0 },{ 1,0,1,0,1,0,1,1,0,1,1,1,0 },{ 1,0,1,1,0,0,1,1,0,0,0,0,0 },{ 1,1,1,1,1,0,1,1,0,1,0,0,0 },{ 1,1,0,1,0,0,1,1,0,0,1,0,0 },{ 1,0,0,1,1,0,1,1,0,1,1,0,0 },{ 1,0,0,1,1,0,1,1,0,0,0,1,1 },{ 1,1,0,1,0,0,1,1,0,1,0,1,1 },{ 2,1,2,2,1,0,1,1,0,0,1,2,1 },{ 2,0,1,1,0,0,2,2,0,2,2,1,2 },{ 1,0,1,0,1,0,1,1,0,0,0,0,1 },{ 1,1,1,0,0,0,1,1,0,1,0,0,1 },{ 1,1,0,0,1,0,1,1,0,0,1,0,1 },{ 1,0,0,0,0,0,1,1,0,1,1,0,1 },{ 1,0,0,0,0,1,1,1,1,1,0,1,0 },{ 1,1,0,0,1,1,1,1,1,0,0,1,0 },{ 2,1,1,0,0,2,2,1,1,1,2,1,0 },{ 2,0,2,0,2,1,1,2,2,0,1,2,0 },{ 1,0,1,1,0,1,1,1,1,1,0,0,0 },{ 2,2,2,1,1,2,2,1,1,0,0,0,0 },{ 2,2,0,2,0,1,1,2,2,2,1,0,0 },{ 2,0,0,1,1,2,2,1,1,0,2,0,0 },{ 2,0,0,1,1,1,1,2,2,1,0,1,2 },{ 2,2,0,2,0,2,2,1,1,0,0,2,1 },{ 4,3,2,2,3,4,4,1,1,3,4,2,1 },{ 3,0,2,2,0,1,1,3,3,0,1,2,3 },{ 2,0,2,0,2,2,2,1,1,2,0,0,1 },{ 2,1,1,0,0,1,1,2,2,0,0,0,2 },{ 3,1,0,0,1,2,2,3,3,1,2,0,3 },{ 2,0,0,0,0,1,1,2,2,0,1,0,2 },{ 1,0,0,0,0,1,0,1,0,0,1,1,0 },{ 1,1,0,0,1,1,0,1,0,1,1,1,0 },{ 1,1,1,0,0,1,0,1,0,0,0,1,0 },{ 1,0,1,0,1,1,0,1,0,1,0,1,0 },{ 1,0,1,1,0,1,0,1,0,0,1,0,0 },{ 2,1,1,2,2,2,0,2,0,2,1,0,0 },{ 1,1,0,1,0,1,0,1,0,0,0,0,0 },{ 1,0,0,1,1,1,0,1,0,1,0,0,0 },{ 1,0,0,1,1,1,0,1,0,0,1,1,1 },{ 2,2,0,2,0,1,0,1,0,1,2,2,1 },{ 2,2,1,1,2,2,0,2,0,0,0,1,2 },{ 2,0,2,2,0,1,0,1,0,1,0,2,1 },{ 1,0,1,0,1,1,0,1,0,0,1,0,1 },{ 2,2,2,0,0,1,0,1,0,1,2,0,1 },{ 1,1,0,0,1,1,0,1,0,0,0,0,1 },{ 1,0,0,0,0,1,0,1,0,1,0,0,1 },{ 1,0,0,0,0,0,0,1,1,1,1,1,0 },{ 1,1,0,0,1,0,0,1,1,0,1,1,0 },{ 1,1,1,0,0,0,0,1,1,1,0,1,0 },{ 1,0,1,0,1,0,0,1,1,0,0,1,0 },{ 1,0,1,1,0,0,0,1,1,1,1,0,0 },{ 2,2,2,1,1,0,0,1,1,0,2,0,0 },{ 1,1,0,1,0,0,0,1,1,1,0,0,0 },{ 1,0,0,1,1,0,0,1,1,0,0,0,0 },{ 2,0,0,2,2,0,0,1,1,2,2,2,1 },{ 2,1,0,1,0,0,0,2,2,0,1,1,2 },{ 3,2,1,1,2,0,0,3,3,2,0,1,3 },{ 2,0,1,1,0,0,0,2,2,0,0,1,2 },{ 2,0,1,0,1,0,0,2,2,1,1,0,2 },{ 2,1,1,0,0,0,0,2,2,0,1,0,2 },{ 2,1,0,0,1,0,0,2,2,1,0,0,2 },{ 1,0,0,0,0,0,0,1,1,0,0,0,1 },{ 1,0,0,0,0,0,0,1,1,0,0,0,1 },{ 1,1,0,0,1,0,0,1,1,1,0,0,1 },{ 2,1,1,0,0,0,0,2,2,0,1,0,2 },{ 1,0,1,0,1,0,0,1,1,1,1,0,1 },{ 1,0,1,1,0,0,0,1,1,0,0,1,1 },{ 2,1,1,2,2,0,0,1,1,1,0,1,2 },{ 1,1,0,1,0,0,0,1,1,0,1,1,1 },{ 2,0,0,1,1,0,0,2,2,2,2,2,1 },{ 1,0,0,1,1,0,0,1,1,0,0,0,0 },{ 1,1,0,1,0,0,0,1,1,1,0,0,0 },{ 1,1,1,1,1,0,0,1,1,0,1,0,0 },{ 1,0,1,1,0,0,0,1,1,1,1,0,0 },{ 1,0,1,0,1,0,0,1,1,0,0,1,0 },{ 1,1,1,0,0,0,0,1,1,1,0,1,0 },{ 1,1,0,0,1,0,0,1,1,0,1,1,0 },{ 1,0,0,0,0,0,0,1,1,1,1,1,0 },{ 1,0,0,0,0,1,0,1,0,1,0,0,1 },{ 1,1,0,0,1,1,0,1,0,0,0,0,1 },{ 1,1,1,0,0,1,0,1,0,1,1,0,1 },{ 1,0,1,0,1,1,0,1,0,0,1,0,1 },{ 1,0,1,1,0,1,0,1,0,1,0,1,1 },{ 2,2,2,1,1,2,0,2,0,0,0,2,1 },{ 2,1,0,1,0,2,0,2,0,1,2,2,1 },{ 2,0,0,2,2,1,0,1,0,0,1,1,2 },{ 1,0,0,1,1,1,0,1,0,1,0,0,0 },{ 1,1,0,1,0,1,0,1,0,0,0,0,0 },{ 2,1,2,2,1,2,0,2,0,1,2,0,0 },{ 1,0,1,1,0,1,0,1,0,0,1,0,0 },{ 1,0,1,0,1,1,0,1,0,1,0,1,0 },{ 1,1,1,0,0,1,0,1,0,0,0,1,0 },{ 2,2,0,0,2,1,0,1,0,2,1,1,0 },{ 1,0,0,0,0,1,0,1,0,0,1,1,0 },{ 1,0,0,0,0,1,1,1,1,0,1,0,1 },{ 2,1,0,0,1,2,1,1,2,2,1,0,1 },{ 1,1,1,0,0,1,1,1,1,0,0,0,1 },{ 2,0,2,0,2,1,2,2,1,1,0,0,2 },{ 2,0,1,1,0,1,2,2,1,0,1,2,1 },{ 4,1,1,3,3,2,4,4,2,2,1,4,3 },{ 2,2,0,2,0,2,1,1,2,0,0,1,2 },{ 3,0,0,1,1,2,3,3,2,2,0,3,1 },{ 1,0,0,1,1,1,1,1,1,0,1,0,0 },{ 2,2,0,2,0,1,2,2,1,1,2,0,0 },{ 2,2,1,1,2,2,1,1,2,0,0,0,0 },{ 2,0,1,1,0,2,1,1,2,2,0,0,0 },{ 2,0,2,0,2,2,1,1,2,0,2,1,0 },{ 3,1,1,0,0,3,2,2,3,3,1,2,0 },{ 2,1,0,0,1,1,2,2,1,0,0,2,0 },{ 2,0,0,0,0,2,1,1,2,2,0,1,0 },{ 1,0,0,0,0,0,1,1,0,1,1,0,1 },{ 1,1,0,0,1,0,1,1,0,0,1,0,1 },{ 1,1,1,0,0,0,1,1,0,1,0,0,1 },{ 1,0,1,0,1,0,1,1,0,0,0,0,1 },{ 2,0,2,2,0,0,1,1,0,2,2,1,2 },{ 3,1,1,2,2,0,3,3,0,0,1,3,2 },{ 2,1,0,1,0,0,2,2,0,1,0,2,1 },{ 2,0,0,1,1,0,2,2,0,0,0,2,1 },{ 1,0,0,1,1,0,1,1,0,1,1,0,0 },{ 1,1,0,1,0,0,1,1,0,0,1,0,0 },{ 2,2,1,1,2,0,1,1,0,2,0,0,0 },{ 1,0,1,1,0,0,1,1,0,0,0,0,0 },{ 2,0,1,0,1,0,2,2,0,1,1,2,0 },{ 2,1,1,0,0,0,2,2,0,0,1,2,0 },{ 2,1,0,0,1,0,2,2,0,1,0,2,0 },{ 1,0,0,0,0,0,1,1,0,0,0,1,0 },{ 1,0,0,0,0,0,1,0,1,0,0,1,1 },{ 1,1,0,0,1,0,1,0,1,1,0,1,1 },{ 1,1,1,0,0,0,1,0,1,0,1,1,1 },{ 2,0,2,0,2,0,1,0,1,1,1,2,2 },{ 1,0,1,1,0,0,1,0,1,0,0,0,1 },{ 2,2,2,1,1,0,2,0,2,2,0,0,1 },{ 1,1,0,1,0,0,1,0,1,0,1,0,1 },{ 2,0,0,2,2,0,1,0,1,1,1,0,2 },{ 1,0,0,1,1,0,1,0,1,0,0,1,0 },{ 1,1,0,1,0,0,1,0,1,1,0,1,0 },{ 2,2,1,1,2,0,2,0,2,0,2,1,0 },{ 2,0,2,2,0,0,1,0,1,1,1,2,0 },{ 1,0,1,0,1,0,1,0,1,0,0,0,0 },{ 1,1,1,0,0,0,1,0,1,1,0,0,0 },{ 1,1,0,0,1,0,1,0,1,0,1,0,0 },{ 1,0,0,0,0,0,1,0,1,1,1,0,0 },{ 1,0,0,0,0,1,1,0,0,1,0,1,1 },{ 1,1,0,0,1,1,1,0,0,0,0,1,1 },{ 2,2,2,0,0,1,1,0,0,2,1,2,2 },{ 2,0,1,0,1,2,2,0,0,0,2,1,1 },{ 1,0,1,1,0,1,1,0,0,1,0,0,1 },{ 2,1,1,2,2,1,1,0,0,0,0,0,2 },{ 2,1,0,1,0,2,2,0,0,1,2,0,1 },{ 2,0,0,2,2,1,1,0,0,0,1,0,2 },{ 1,0,0,1,1,1,1,0,0,1,0,1,0 },{ 1,1,0,1,0,1,1,0,0,0,0,1,0 },{ 3,1,2,2,1,3,3,0,0,1,3,2,0 },{ 2,0,1,1,0,2,2,0,0,0,2,1,0 },{ 1,0,1,0,1,1,1,0,0,1,0,0,0 },{ 1,1,1,0,0,1,1,0,0,0,0,0,0 },{ 2,2,0,0,2,1,1,0,0,2,1,0,0 },{ 1,0,0,0,0,1,1,0,0,0,1,0,0 },{ 1,0,0,0,0,1,0,0,1,0,1,1,1 },{ 2,2,0,0,2,1,0,0,1,1,2,2,2 },{ 1,1,1,0,0,1,0,0,1,0,0,1,1 },{ 2,0,1,0,1,2,0,0,2,2,0,1,1 },{ 1,0,1,1,0,1,0,0,1,0,1,0,1 },{ 3,1,1,3,3,2,0,0,2,2,1,0,3 },{ 1,1,0,1,0,1,0,0,1,0,0,0,1 },{ 2,0,0,2,2,1,0,0,1,1,0,0,2 },{ 1,0,0,1,1,1,0,0,1,0,1,1,0 },{ 2,1,0,1,0,2,0,0,2,2,1,1,0 },{ 2,1,2,2,1,1,0,0,1,0,0,2,0 },{ 2,0,1,1,0,2,0,0,2,2,0,1,0 },{ 1,0,1,0,1,1,0,0,1,0,1,0,0 },{ 2,1,1,0,0,2,0,0,2,2,1,0,0 },{ 1,1,0,0,1,1,0,0,1,0,0,0,0 },{ 1,0,0,0,0,1,0,0,1,1,0,0,0 },{ 1,0,0,0,0,0,0,0,0,1,1,1,1 },{ 1,1,0,0,1,0,0,0,0,0,1,1,1 },{ 1,1,1,0,0,0,0,0,0,1,0,1,1 },{ 1,0,1,0,1,0,0,0,0,0,0,1,1 },{ 1,0,1,1,0,0,0,0,0,1,1,0,1 },{ 2,1,1,2,2,0,0,0,0,0,1,0,2 },{ 1,1,0,1,0,0,0,0,0,1,0,0,1 },{ 1,0,0,1,1,0,0,0,0,0,0,0,1 },{ 1,0,0,1,1,0,0,0,0,1,1,1,0 },{ 1,1,0,1,0,0,0,0,0,0,1,1,0 },{ 2,1,2,2,1,0,0,0,0,1,0,2,0 },{ 1,0,1,1,0,0,0,0,0,0,0,1,0 },{ 1,0,1,0,1,0,0,0,0,1,1,0,0 },{ 1,1,1,0,0,0,0,0,0,0,1,0,0 },{ 1,1,0,0,1,0,0,0,0,1,0,0,0 },{ 0,0,0,0,0,0,0,0,0,0,0,0,0 } } ; bool)",
    "insertText": "isPlanarQuad(const Vec3d& p0, const Vec3d& p1, const Vec3d& p2, const Vec3d& p3, double epsilon = 0.001)"
  },
  {
    "label": "normal()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "normal(p2-p0).cross(p1-p3)"
  },
  {
    "label": "normalize()",
    "kind": "Method",
    "detail": "Function (normal .)",
    "insertText": "normalize()"
  },
  {
    "label": "centroid()",
    "kind": "Method",
    "detail": "Function (const Vec3d)",
    "insertText": "centroid(p0 + p1 + p2 + p3)"
  },
  {
    "label": "dot()",
    "kind": "Method",
    "detail": "Function (const double d = centroid .)",
    "insertText": "dot(normal)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (absDist =)",
    "insertText": "abs(p1.dot(normal) - d)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (absDist =)",
    "insertText": "abs(p2.dot(normal) - d)"
  },
  {
    "label": "abs()",
    "kind": "Method",
    "detail": "Function (absDist =)",
    "insertText": "abs(p3.dot(normal) - d)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (uint32_t data = 0 ;)",
    "insertText": "assert(!(v.x() > 1.0) && !(v.y() > 1.0) && !(v.z() > 1.0))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!(v.x() < 0.0) && !(v.y() < 0.0) && !(v.z() < 0.0))"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "data(uint32_t(v.x() * 1023.0) & MASK_FIRST_10_BITS)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "data(uint32_t(v.y() * 1023.0) & MASK_FIRST_10_BITS)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "data(uint32_t(v.z() * 1023.0) & MASK_FIRST_10_BITS)"
  },
  {
    "label": "z()",
    "kind": "Method",
    "detail": "Function (Vec3d v ; v .)",
    "insertText": "z() = double(data & MASK_FIRST_10_BITS)"
  },
  {
    "label": "y()",
    "kind": "Method",
    "detail": "Function (data = data>> 1 0 ; v .)",
    "insertText": "y() = double(data & MASK_FIRST_10_BITS)"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (data = data>> 1 0 ; v .)",
    "insertText": "x() = double(data & MASK_FIRST_10_BITS)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (values [ 0 ] = accessor .)",
    "insertText": "getValue(ijk)"
  },
  {
    "label": "getCellVertexValues()",
    "kind": "Method",
    "detail": "Function (} template<LeafT> void)",
    "insertText": "getCellVertexValues(const LeafT& leaf, const Index offset, math::Tuple<8, typename LeafT::ValueType>& values)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (values [ 0 ] = leaf .)",
    "insertText": "getValue(offset)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (values [ 3 ] = leaf .)",
    "insertText": "getValue(offset + 1)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (values [ 4 ] = leaf .)",
    "insertText": "getValue(offset + LeafT::DIM)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (values [ 7 ] = leaf .)",
    "insertText": "getValue(offset + LeafT::DIM + 1)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (values [ 1 ] = leaf .)",
    "insertText": "getValue(offset + (LeafT::DIM * LeafT::DIM))"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (values [ 2 ] = leaf .)",
    "insertText": "getValue(offset + (LeafT::DIM * LeafT::DIM) + 1)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (values [ 5 ] = leaf .)",
    "insertText": "getValue(offset + (LeafT::DIM * LeafT::DIM) + LeafT::DIM)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (values [ 6 ] = leaf .)",
    "insertText": "getValue(offset + (LeafT::DIM * LeafT::DIM) + LeafT::DIM + 1)"
  },
  {
    "label": "computeSignFlags()",
    "kind": "Method",
    "detail": "Function (} template<ValueType> uint8_t)",
    "insertText": "computeSignFlags(const math::Tuple<8, ValueType>& values, const ValueType iso)"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (unsigned signs = 0 ; signs | =)",
    "insertText": "isInsideValue(values[0], iso)"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (signs | =)",
    "insertText": "isInsideValue(values[1], iso)"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (signs | =)",
    "insertText": "isInsideValue(values[2], iso)"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (signs | =)",
    "insertText": "isInsideValue(values[3], iso)"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (signs | =)",
    "insertText": "isInsideValue(values[4], iso)"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (signs | =)",
    "insertText": "isInsideValue(values[5], iso)"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (signs | =)",
    "insertText": "isInsideValue(values[6], iso)"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (signs | =)",
    "insertText": "isInsideValue(values[7], iso)"
  },
  {
    "label": "evalCellSigns()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> uint8_t)",
    "insertText": "evalCellSigns(const AccessorT& accessor, const Coord& ijk, typename AccessorT::ValueType iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned signs = 0 ; Coord coord = ijk ;)",
    "insertText": "if(isInsideValue(accessor.getValue(coord), iso))"
  },
  {
    "label": "evalCellSigns()",
    "kind": "Method",
    "detail": "Function (} template<LeafT> uint8_t)",
    "insertText": "evalCellSigns(const LeafT& leaf, const Index offset, typename LeafT::ValueType iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned signs = 0 ;)",
    "insertText": "if(isInsideValue(leaf.getValue(offset), iso))"
  },
  {
    "label": "correctCellSigns()",
    "kind": "Method",
    "detail": "Function (} template<class AccessorT> void)",
    "insertText": "correctCellSigns(uint8_t& signs, uint8_t face, const AccessorT& acc, Coord ijk, typename AccessorT::ValueType iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case 2 : ijk [ 0 ] + = 1 ;)",
    "insertText": "if(sAmbiguousFace[evalCellSigns(acc, ijk, iso)] == 4) signs = uint8_t(~signs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case 3 : ijk [ 2 ] + = 1 ;)",
    "insertText": "if(sAmbiguousFace[evalCellSigns(acc, ijk, iso)] == 1) signs = uint8_t(~signs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case 4 : ijk [ 0 ] - = 1 ;)",
    "insertText": "if(sAmbiguousFace[evalCellSigns(acc, ijk, iso)] == 2) signs = uint8_t(~signs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case 5 : ijk [ 1 ] - = 1 ;)",
    "insertText": "if(sAmbiguousFace[evalCellSigns(acc, ijk, iso)] == 6) signs = uint8_t(~signs)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case 6 : ijk [ 1 ] + = 1 ;)",
    "insertText": "if(sAmbiguousFace[evalCellSigns(acc, ijk, iso)] == 5) signs = uint8_t(~signs)"
  },
  {
    "label": "isNonManifold()",
    "kind": "Method",
    "detail": "Function (break ; default : break ; } } template<class AccessorT> bool)",
    "insertText": "isNonManifold(const AccessorT& accessor, const Coord& ijk, typename AccessorT::ValueType isovalue, const int dim)"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (int hDim = dim>> 1 ; bool m,p [ 8 ] ; Coord coord = ijk ; p [ 0 ] =)",
    "insertText": "isInsideValue(accessor.getValue(coord), isovalue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned signs = 0 ;)",
    "insertText": "if(p[0])"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (int i = ijk [ 0 ],ip = ijk [ 0 ] + hDim,ipp = ijk [ 0 ] + dim ; int j = ijk [ 1 ],jp = ijk [ 1 ] + hDim,jpp = ijk [ 1 ] + dim ; int k = ijk [ 2 ],kp = ijk [ 2 ] + hDim,kpp = ijk [ 2 ] + dim ; coord .)",
    "insertText": "reset(ip, j, k)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ipp, j, kp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ip, j, kpp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(i, j, kp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ip, jpp, k)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ipp, jpp, kp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ip, jpp, kpp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(i, jpp, kp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(i, jp, k)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ipp, jp, k)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ipp, jp, kpp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(i, jp, kpp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ip, jp, k)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ipp, jp, kp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ip, jp, kpp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(i, jp, kp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ip, j, kp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ip, jpp, kp)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (coord .)",
    "insertText": "reset(ip, jp, kp)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Coord ijk,end = start ; end [ 0 ] + = dim ; end [ 1 ] + = dim ; end [ 2 ] + = dim ;)",
    "insertText": "for(ijk[0] = start[0]; ijk[0] < end[0]; ++ijk[0])"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (leaf .)",
    "insertText": "setValueOnly(ijk, regionId)"
  },
  {
    "label": "isMergable()",
    "kind": "Method",
    "detail": "Function (} } } } template<class LeafType> bool)",
    "insertText": "isMergable(LeafType& leaf, const Coord& start, int dim, typename LeafType::ValueType::value_type adaptivity)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (norms .)",
    "insertText": "push_back(leaf.getValue(ijk))"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} } } size_t N = norms .)",
    "insertText": "size()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (VecT n_i = norms [ ni ] ;)",
    "insertText": "for(size_t nj = 0; nj < N; ++nj)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VecT n_j = norms [ nj ] ;)",
    "insertText": "if((1.0 - n_i.dot(n_j)) > adaptivity)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (} } return true ; } double)",
    "insertText": "evalZeroCrossing(double v0, double v1, double iso)"
  },
  {
    "label": "collectCornerValues()",
    "kind": "Method",
    "detail": "Function (} template<LeafT> void)",
    "insertText": "collectCornerValues(const LeafT& leaf, const Index offset, std::vector<double>& values)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (values [ 0 ] =)",
    "insertText": "double(leaf.getValue(offset))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (values [ 3 ] =)",
    "insertText": "double(leaf.getValue(offset + 1))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (values [ 4 ] =)",
    "insertText": "double(leaf.getValue(offset + LeafT::DIM))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (values [ 7 ] =)",
    "insertText": "double(leaf.getValue(offset + LeafT::DIM + 1))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (values [ 1 ] =)",
    "insertText": "double(leaf.getValue(offset + (LeafT::DIM * LeafT::DIM)))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (values [ 2 ] =)",
    "insertText": "double(leaf.getValue(offset + (LeafT::DIM * LeafT::DIM) + 1))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (values [ 5 ] =)",
    "insertText": "double(leaf.getValue(offset + (LeafT::DIM * LeafT::DIM) + LeafT::DIM))"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (values [ 6 ] =)",
    "insertText": "double(leaf.getValue(offset + (LeafT::DIM * LeafT::DIM) + LeafT::DIM + 1))"
  },
  {
    "label": "collectCornerValues()",
    "kind": "Method",
    "detail": "Function (} template<AccessorT> void)",
    "insertText": "collectCornerValues(const AccessorT& acc, const Coord& ijk, std::vector<double>& values)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (Coord coord = ijk ; values [ 0 ] =)",
    "insertText": "double(acc.getValue(coord))"
  },
  {
    "label": "computePoint()",
    "kind": "Method",
    "detail": "Function (} Vec3d)",
    "insertText": "computePoint(const std::vector<double>& values, unsigned char signs, unsigned char edgeGroup, double iso)"
  },
  {
    "label": "avg()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "avg(0.0, 0.0, 0.0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int samples = 0 ;)",
    "insertText": "if(sEdgeGroupTable[signs][1] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 0 ] + =)",
    "insertText": "evalZeroCrossing(values[0], values[1], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][2] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 0 ] + = 1 . 0 ; avg [ 2 ] + =)",
    "insertText": "evalZeroCrossing(values[1], values[2], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][3] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 0 ] + =)",
    "insertText": "evalZeroCrossing(values[3], values[2], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (avg [ 2 ] + = 1 . 0 ; + + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][4] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 2 ] + =)",
    "insertText": "evalZeroCrossing(values[0], values[3], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][5] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 0 ] + =)",
    "insertText": "evalZeroCrossing(values[4], values[5], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (avg [ 1 ] + = 1 . 0 ; + + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][6] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 0 ] + = 1 . 0 ; avg [ 1 ] + = 1 . 0 ; avg [ 2 ] + =)",
    "insertText": "evalZeroCrossing(values[5], values[6], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][7] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 0 ] + =)",
    "insertText": "evalZeroCrossing(values[7], values[6], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (avg [ 1 ] + = 1 . 0 ; avg [ 2 ] + = 1 . 0 ; + + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][8] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 1 ] + = 1 . 0 ; avg [ 2 ] + =)",
    "insertText": "evalZeroCrossing(values[4], values[7], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][9] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 1 ] + =)",
    "insertText": "evalZeroCrossing(values[0], values[4], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][10] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 0 ] + = 1 . 0 ; avg [ 1 ] + =)",
    "insertText": "evalZeroCrossing(values[1], values[5], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][11] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 0 ] + = 1 . 0 ; avg [ 1 ] + =)",
    "insertText": "evalZeroCrossing(values[2], values[6], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (avg [ 2 ] + = 1 . 0 ; + + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][12] == edgeGroup)"
  },
  {
    "label": "evalZeroCrossing()",
    "kind": "Method",
    "detail": "Function (avg [ 1 ] + =)",
    "insertText": "evalZeroCrossing(values[3], values[7], iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (avg [ 2 ] + = 1 . 0 ; + + samples ; })",
    "insertText": "if(samples > 1)"
  },
  {
    "label": "computeMaskedPoint()",
    "kind": "Method",
    "detail": "Function (avg [ 0 ]* = w ; avg [ 1 ]* = w ; avg [ 2 ]* = w ; } return avg ; } int)",
    "insertText": "computeMaskedPoint(Vec3d& avg, const std::vector<double>& values, unsigned char signs, unsigned char signsMask, unsigned char edgeGroup, double iso)"
  },
  {
    "label": "Vec3d()",
    "kind": "Method",
    "detail": "Function (avg =)",
    "insertText": "Vec3d(0.0, 0.0, 0.0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int samples = 0 ;)",
    "insertText": "if(sEdgeGroupTable[signs][1] == edgeGroup && sEdgeGroupTable[signsMask][1] == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][2] == edgeGroup && sEdgeGroupTable[signsMask][2] == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][3] == edgeGroup && sEdgeGroupTable[signsMask][3] == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (avg [ 2 ] + = 1 . 0 ; + + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][4] == edgeGroup && sEdgeGroupTable[signsMask][4] == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][5] == edgeGroup && sEdgeGroupTable[signsMask][5] == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (avg [ 1 ] + = 1 . 0 ; + + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][6] == edgeGroup && sEdgeGroupTable[signsMask][6] == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][7] == edgeGroup && sEdgeGroupTable[signsMask][7] == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (avg [ 1 ] + = 1 . 0 ; avg [ 2 ] + = 1 . 0 ; + + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][8] == edgeGroup && sEdgeGroupTable[signsMask][8] == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][9] == edgeGroup && sEdgeGroupTable[signsMask][9] == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][10] == edgeGroup && sEdgeGroupTable[signsMask][10] == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][11] == edgeGroup && sEdgeGroupTable[signsMask][11] == 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (avg [ 2 ] + = 1 . 0 ; + + samples ; })",
    "insertText": "if(sEdgeGroupTable[signs][12] == edgeGroup && sEdgeGroupTable[signsMask][12] == 0)"
  },
  {
    "label": "computeWeightedPoint()",
    "kind": "Method",
    "detail": "Function (avg [ 0 ]* = w ; avg [ 1 ]* = w ; avg [ 2 ]* = w ; } return samples ; } Vec3d)",
    "insertText": "computeWeightedPoint(const Vec3d& p, const std::vector<double>& values, unsigned char signs, unsigned char edgeGroup, double iso)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (std::vector<Vec3d> samples ; samples .)",
    "insertText": "reserve(8)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (avg [ 1 ] = 0 . 0 ; avg [ 2 ] = 0 . 0 ; samples .)",
    "insertText": "push_back(avg)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (weights .)",
    "insertText": "push_back((avg-p).lengthSqr())"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (} double minWeight = std::numeric_limits<double)",
    "insertText": "max()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (minWeight =)",
    "insertText": "min(minWeight, weights[i])"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (maxWeight =)",
    "insertText": "max(maxWeight, weights[i])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} const double offset = maxWeight + minWeight* 0 . 1 ;)",
    "insertText": "for(size_t i = 0, I = weights.size(); i < I; ++i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (weightSum + = weights [ i ] ; } avg [ 0 ] = 0 . 0 ; avg [ 1 ] = 0 . 0 ; avg [ 2 ] = 0 . 0 ;)",
    "insertText": "if(samples.size() > 1)"
  },
  {
    "label": "i()",
    "kind": "Method",
    "detail": "Function (avg + = samples [)",
    "insertText": "i(weights[i] / weightSum)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (} } else { avg = samples .)",
    "insertText": "front()"
  },
  {
    "label": "computeCellPoints()",
    "kind": "Method",
    "detail": "Function (} return avg ; } void)",
    "insertText": "computeCellPoints(std::vector<Vec3d>& points, const std::vector<double>& values, unsigned char signs, double iso)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (points .)",
    "insertText": "push_back(computePoint(values, signs, uint8_t(n), iso))"
  },
  {
    "label": "matchEdgeGroup()",
    "kind": "Method",
    "detail": "Function (} } int)",
    "insertText": "matchEdgeGroup(unsigned char groupId, unsigned char lhsSigns, unsigned char rhsSigns)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int id = - 1 ;)",
    "insertText": "for(size_t i = 1; i <= 12; ++i)"
  },
  {
    "label": "computeCellPoints()",
    "kind": "Method",
    "detail": "Function (id = sEdgeGroupTable [ rhsSigns ] [ i ] ; break ; } } return id ; } void)",
    "insertText": "computeCellPoints(std::vector<Vec3d>& points, std::vector<bool>& weightedPointMask, const std::vector<double>& lhsValues, const std::vector<double>& rhsValues, unsigned char lhsSigns, unsigned char rhsSigns, double iso, size_t pointIdx, const uint32_t * seamPointArray)"
  },
  {
    "label": "matchEdgeGroup()",
    "kind": "Method",
    "detail": "Function (int id =)",
    "insertText": "matchEdgeGroup(uint8_t(n), lhsSigns, rhsSigns)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (const unsigned char e =)",
    "insertText": "uint8_t(id)"
  },
  {
    "label": "pointIdx()",
    "kind": "Method",
    "detail": "Function (const uint32_t& quantizedPoint = seamPointArray [)",
    "insertText": "pointIdx(id - 1)"
  },
  {
    "label": "unpackPoint()",
    "kind": "Method",
    "detail": "Function (Vec3d p =)",
    "insertText": "unpackPoint(quantizedPoint)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (points .)",
    "insertText": "push_back(computeWeightedPoint(p, rhsValues, rhsSigns, e, iso))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (weightedPointMask .)",
    "insertText": "push_back(true)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} else { points .)",
    "insertText": "push_back(computePoint(rhsValues, rhsSigns, e, iso))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (weightedPointMask .)",
    "insertText": "push_back(false)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (} } else { points .)",
    "insertText": "push_back(computePoint(lhsValues, lhsSigns, uint8_t(n), iso))"
  },
  {
    "label": "ComputePoints()",
    "kind": "Method",
    "detail": "Function (} } } template<InputTreeType> struct ComputePoints { using InputLeafNodeType = InputTreeType::LeafNodeType ; using InputValueType = InputLeafNodeType::ValueType ; using Int16TreeType = InputTreeType::template ValueConverter<Int16>::Type ; using Int16LeafNodeType = Int16TreeType::LeafNodeType ; using Index32TreeType = InputTreeType::template ValueConverter<Index32>::Type ; using Index32LeafNodeType = Index32TreeType::LeafNodeType ;)",
    "insertText": "ComputePoints(Vec3s * pointArray, const InputTreeType& inputTree, const std::vector<Index32LeafNodeType*>& pointIndexLeafNodes, const std::vector<Int16LeafNodeType*>& signFlagsLeafNodes, const std::unique_ptr<Index32[]>& leafNodeOffsets, const math::Transform& xform, double iso)"
  },
  {
    "label": "setRefData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setRefData(const InputTreeType& refInputTree, const Index32TreeType& refPointIndexTree, const Int16TreeType& refSignFlagsTree, const uint32_t * quantizedSeamLinePoints, uint8_t * seamLinePointsFlags)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator()(const tbb::blocked_range<size_t>&)"
  },
  {
    "label": "ComputePoints()",
    "kind": "Method",
    "detail": "Function (private : Vec3s* const mPoints ; InputTreeType const* const mInputTree ; Index32LeafNodeType* const* const mPointIndexNodes ; Int16LeafNodeType const* const* const mSignFlagsNodes ; Index32 const* const mNodeOffsets ; math::Transform const mTransform ; double const mIsovalue ; InputTreeType const* mRefInputTree ; Index32TreeType const* mRefPointIndexTree ; Int16TreeType const* mRefSignFlagsTree ; uint32_t const* mQuantizedSeamLinePoints ; uint8_t* mSeamLinePointsFlags ; } ; template<InputTreeType> ComputePoints<InputTreeType)",
    "insertText": "ComputePoints(Vec3s * pointArray, const InputTreeType& inputTree, const std::vector<Index32LeafNodeType*>& pointIndexLeafNodes, const std::vector<Int16LeafNodeType*>& signFlagsLeafNodes, const std::unique_ptr<Index32[]>& leafNodeOffsets, const math::Transform& xform, double iso) : mPoints(pointArray) , mInputTree(&inputTree) , mPointIndexNodes(pointIndexLeafNodes.data()) , mSignFlagsNodes(signFlagsLeafNodes.data()) , mNodeOffsets(leafNodeOffsets.get()) , mTransform(xform) , mIsovalue(iso) , mRefInputTree(nullptr) , mRefPointIndexTree(nullptr) , mRefSignFlagsTree(nullptr) , mQuantizedSeamLinePoints(nullptr) , mSeamLinePointsFlags(nullptr)"
  },
  {
    "label": "inputAcc()",
    "kind": "Method",
    "detail": "Function (using InputTreeAccessor = tree::ValueAccessor<const InputTreeType> ; using Index32TreeAccessor = tree::ValueAccessor<const Index32TreeType> ; using Int16TreeAccessor = tree::ValueAccessor<const Int16TreeType> ; using IndexType = Index32TreeType::ValueType ; using IndexArray = std::vector<Index> ; using IndexArrayMap = std::map<IndexType,IndexArray> ; InputTreeAccessor)",
    "insertText": "inputAcc(*mInputTree)"
  },
  {
    "label": "points()",
    "kind": "Method",
    "detail": "Function (Vec3d xyz ; Coord ijk ; std::vector<Vec3d>)",
    "insertText": "points(4)"
  },
  {
    "label": "weightedPointMask()",
    "kind": "Method",
    "detail": "Function (std::vector<bool>)",
    "insertText": "weightedPointMask(4)"
  },
  {
    "label": "values()",
    "kind": "Method",
    "detail": "Function (std::vector<double>)",
    "insertText": "values(8), refValues(8)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const double iso = mIsovalue ; std::unique_ptr<InputTreeAccessor> refInputAcc ; std::unique_ptr<Index32TreeAccessor> refPointIndexAcc ; std::unique_ptr<Int16TreeAccessor> refSignFlagsAcc ; const bool hasReferenceData = mRefInputTree&& mRefPointIndexTree&& mRefSignFlagsTree ;)",
    "insertText": "if(hasReferenceData)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (refInputAcc .)",
    "insertText": "reset(new InputTreeAccessor(*mRefInputTree))"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (refPointIndexAcc .)",
    "insertText": "reset(new Index32TreeAccessor(*mRefPointIndexTree))"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (refSignFlagsAcc .)",
    "insertText": "reset(new Int16TreeAccessor(*mRefSignFlagsTree))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(size_t n = range.begin(), N = range.end(); n != N; ++n)"
  },
  {
    "label": "origin()",
    "kind": "Method",
    "detail": "Function (Index32LeafNodeType& pointIndexNode =* mPointIndexNodes [ n ] ; const Coord& origin = pointIndexNode .)",
    "insertText": "origin()"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (const Int16LeafNodeType& signFlagsNode =* mSignFlagsNodes [ n ] ; const InputLeafNodeType* inputNode = inputAcc .)",
    "insertText": "probeConstLeaf(origin)"
  },
  {
    "label": "IndexType()",
    "kind": "Method",
    "detail": "Function (} IndexType pointOffset =)",
    "insertText": "IndexType(mNodeOffsets[n])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (IndexArrayMap regions ;)",
    "insertText": "for(auto it = pointIndexNode.beginValueOn(); it; ++it)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (const Index offset = it .)",
    "insertText": "pos()"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (const IndexType id = it .)",
    "insertText": "getValue()"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (regions [ id ] .)",
    "insertText": "push_back(offset)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (} continue ; } pointIndexNode .)",
    "insertText": "setValueOnly(offset, pointOffset)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (uint8_t signs =)",
    "insertText": "uint8_t(SIGNS & flags)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (uint8_t refSigns = 0 ;)",
    "insertText": "if((flags & SEAM) && refPointIndexNode && refSignFlagsNode)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (refSigns =)",
    "insertText": "uint8_t(SIGNS & refSignFlagsNode->getValue(offset))"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (} } ijk =)",
    "insertText": "offsetToLocalCoord(offset)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (const bool inclusiveCell = inputNode&& ijk [ 0 ]<)",
    "insertText": "int(Index32LeafNodeType::DIM - 1) && ijk[1] < int(Index32LeafNodeType::DIM - 1) && ijk[2] < int(Index32LeafNodeType::DIM - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ijk + = origin ;)",
    "insertText": "if(inclusiveCell) collectCornerValues(*inputNode, offset, values)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (points .)",
    "insertText": "clear()"
  },
  {
    "label": "computeCellPoints()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeCellPoints(points, values, signs, iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(inclusiveCell && refInputNode)"
  },
  {
    "label": "collectCornerValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collectCornerValues(*refInputNode, offset, refValues)"
  },
  {
    "label": "collectCornerValues()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "collectCornerValues(*refInputAcc, ijk, refValues)"
  },
  {
    "label": "computeCellPoints()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "computeCellPoints(points, weightedPointMask, values, refValues, signs, refSigns, iso, refPointIndexNode->getValue(offset), mQuantizedSeamLinePoints)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (} xyz [ 0 ] =)",
    "insertText": "double(ijk[0])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (xyz [ 1 ] =)",
    "insertText": "double(ijk[1])"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (xyz [ 2 ] =)",
    "insertText": "double(ijk[2])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Vec3d& point = points [ i ] ;)",
    "insertText": "if(!std::isfinite(point[0]) || !std::isfinite(point[1]) || !std::isfinite(point[2]))"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(ValueError, \"VolumeToMesh encountered NaNs or infs in the input VDB!\" \" Hint: Check the input and consider using the \\\"Diagnostics\\\" tool \" \"to detect and resolve the NaNs.\")"
  },
  {
    "label": "indexToWorld()",
    "kind": "Method",
    "detail": "Function (} point + = xyz ; point = mTransform .)",
    "insertText": "indexToWorld(point)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (Vec3s& pos = mPoints [ pointOffset ] ; pos [ 0 ] =)",
    "insertText": "float(point[0])"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (pos [ 1 ] =)",
    "insertText": "float(point[1])"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (pos [ 2 ] =)",
    "insertText": "float(point[2])"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (mSeamLinePointsFlags [ pointOffset ] =)",
    "insertText": "uint8_t(1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} + + pointOffset ; } })",
    "insertText": "for(typename IndexArrayMap::iterator it = regions.begin(); it != regions.end(); ++it)"
  },
  {
    "label": "avg()",
    "kind": "Method",
    "detail": "Function (Vec3d)",
    "insertText": "avg(0.0), point(0.0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int count = 0 ; const IndexArray& voxels = it -> second ;)",
    "insertText": "for(size_t i = 0, I = voxels.size(); i < I; ++i)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (uint8_t signs =)",
    "insertText": "uint8_t(SIGNS & signFlagsNode.getValue(offset))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + count ; })",
    "insertText": "if(count > 1)"
  },
  {
    "label": "indexToWorld()",
    "kind": "Method",
    "detail": "Function (avg [ 0 ]* = w ; avg [ 1 ]* = w ; avg [ 2 ]* = w ; } avg = mTransform .)",
    "insertText": "indexToWorld(avg)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (Vec3s& pos = mPoints [ pointOffset ] ; pos [ 0 ] =)",
    "insertText": "float(avg[0])"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (pos [ 1 ] =)",
    "insertText": "float(avg[1])"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (pos [ 2 ] =)",
    "insertText": "float(avg[2])"
  },
  {
    "label": "SeamLineWeights()",
    "kind": "Method",
    "detail": "Function (+ + pointOffset ; } } } template<InputTreeType> struct SeamLineWeights { using InputLeafNodeType = InputTreeType::LeafNodeType ; using InputValueType = InputLeafNodeType::ValueType ; using Int16TreeType = InputTreeType::template ValueConverter<Int16>::Type ; using Int16LeafNodeType = Int16TreeType::LeafNodeType ; using Index32TreeType = InputTreeType::template ValueConverter<Index32>::Type ; using Index32LeafNodeType = Index32TreeType::LeafNodeType ;)",
    "insertText": "SeamLineWeights(const std::vector<Int16LeafNodeType*>& signFlagsLeafNodes, const InputTreeType& inputTree, const Index32TreeType& refPointIndexTree, const Int16TreeType& refSignFlagsTree, uint32_t * quantizedPoints, InputValueType iso) : mSignFlagsNodes(signFlagsLeafNodes.data()) , mInputTree(&inputTree) , mRefPointIndexTree(&refPointIndexTree) , mRefSignFlagsTree(&refSignFlagsTree) , mQuantizedPoints(quantizedPoints) , mIsovalue(iso)"
  },
  {
    "label": "inputTreeAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const InputTreeType>)",
    "insertText": "inputTreeAcc(*mInputTree)"
  },
  {
    "label": "pointIndexTreeAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const Index32TreeType>)",
    "insertText": "pointIndexTreeAcc(*mRefPointIndexTree)"
  },
  {
    "label": "signFlagsTreeAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const Int16TreeType>)",
    "insertText": "signFlagsTreeAcc(*mRefSignFlagsTree)"
  },
  {
    "label": "values()",
    "kind": "Method",
    "detail": "Function (std::vector<double>)",
    "insertText": "values(8)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (const double iso =)",
    "insertText": "double(mIsovalue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ijk + = origin ;)",
    "insertText": "if((it.getValue() & SEAM) && refSignNode->isValueOn(offset))"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (uint8_t lhsSigns =)",
    "insertText": "uint8_t(SIGNS & it.getValue())"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (uint8_t rhsSigns =)",
    "insertText": "uint8_t(SIGNS & refSignNode->getValue(offset))"
  },
  {
    "label": "collectCornerValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "collectCornerValues(*inputNode, offset, values)"
  },
  {
    "label": "collectCornerValues()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "collectCornerValues(inputTreeAcc, ijk, values)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(unsigned i = 1, I = sEdgeGroupTable[lhsSigns][0] + 1; i < I; ++i)"
  },
  {
    "label": "matchEdgeGroup()",
    "kind": "Method",
    "detail": "Function (int id =)",
    "insertText": "matchEdgeGroup(uint8_t(i), lhsSigns, rhsSigns)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (uint32_t& data = mQuantizedPoints [ refPointIndexNode ->)",
    "insertText": "getValue(offset) + (id - 1)"
  },
  {
    "label": "computeMaskedPoint()",
    "kind": "Method",
    "detail": "Function (int smaples =)",
    "insertText": "computeMaskedPoint(pos, values, lhsSigns, rhsSigns, uint8_t(i), iso)"
  },
  {
    "label": "refSignFlagsTreeAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const TreeType>)",
    "insertText": "refSignFlagsTreeAcc(*mRefSignFlagsTree)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (uint8_t rhsSigns =)",
    "insertText": "uint8_t(refSignNode->getValue(offset) & SIGNS)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (uint8_t lhsSigns =)",
    "insertText": "uint8_t(value & SIGNS)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (signFlagsNode .)",
    "insertText": "setValueOnly(offset, value | SEAM)"
  },
  {
    "label": "TransferSeamLineFlags()",
    "kind": "Method",
    "detail": "Function (} } } } } private : LeafNodeType* const* const mSignFlagsNodes ; TreeType const* const mRefSignFlagsTree ; } ; template<BoolTreeType,SignDataType> struct TransferSeamLineFlags { using BoolLeafNodeType = BoolTreeType::LeafNodeType ; using SignDataTreeType = BoolTreeType::template ValueConverter<SignDataType>::Type ; using SignDataLeafNodeType = SignDataTreeType::LeafNodeType ;)",
    "insertText": "TransferSeamLineFlags(const std::vector<SignDataLeafNodeType*>& signFlagsLeafNodes, const BoolTreeType& maskTree) : mSignFlagsNodes(signFlagsLeafNodes.data()) , mMaskTree(&maskTree)"
  },
  {
    "label": "maskAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const BoolTreeType>)",
    "insertText": "maskAcc(*mMaskTree)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (using ValueOnCIter = SignDataLeafNodeType::ValueOnCIter ;)",
    "insertText": "for(ValueOnCIter it = signFlagsNode.cbeginValueOn(); it; ++it)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (signFlagsNode .)",
    "insertText": "setValueOnly(offset, it.getValue() | SEAM)"
  },
  {
    "label": "MaskSeamLineVoxels()",
    "kind": "Method",
    "detail": "Function (} } } } private : SignDataLeafNodeType* const* const mSignFlagsNodes ; BoolTreeType const* const mMaskTree ; } ; template<TreeType> struct MaskSeamLineVoxels { using LeafNodeType = TreeType::LeafNodeType ; using BoolTreeType = TreeType::template ValueConverter<bool>::Type ;)",
    "insertText": "MaskSeamLineVoxels(const std::vector<LeafNodeType*>& signFlagsLeafNodes, const TreeType& signFlagsTree, BoolTreeType& mask) : mSignFlagsNodes(signFlagsLeafNodes.data()) , mSignFlagsTree(&signFlagsTree) , mTempMask(false) , mMask(&mask)"
  },
  {
    "label": "MaskSeamLineVoxels()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MaskSeamLineVoxels(MaskSeamLineVoxels& rhs, tbb::split) : mSignFlagsNodes(rhs.mSignFlagsNodes) , mSignFlagsTree(rhs.mSignFlagsTree) , mTempMask(false) , mMask(&mTempMask)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "join(MaskSeamLineVoxels& rhs)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (mMask ->)",
    "insertText": "merge(*rhs.mMask)"
  },
  {
    "label": "signFlagsAcc()",
    "kind": "Method",
    "detail": "Function (using ValueOnCIter = LeafNodeType::ValueOnCIter ; using ValueType = LeafNodeType::ValueType ; tree::ValueAccessor<const TreeType>)",
    "insertText": "signFlagsAcc(*mSignFlagsTree)"
  },
  {
    "label": "maskAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<BoolTreeType>)",
    "insertText": "maskAcc(*mMask)"
  },
  {
    "label": "ijk()",
    "kind": "Method",
    "detail": "Function (Coord)",
    "insertText": "ijk(0, 0, 0)"
  },
  {
    "label": "getCoord()",
    "kind": "Method",
    "detail": "Function (ijk = it .)",
    "insertText": "getCoord()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (bool isSeamLineVoxel = false ;)",
    "insertText": "if(flags & XEDGE)"
  },
  {
    "label": "isSeamLineVoxel()",
    "kind": "Method",
    "detail": "Function (ijk [ 1 ] - = 1 ;)",
    "insertText": "isSeamLineVoxel(signFlagsAcc.getValue(ijk) & SEAM)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ijk [ 2 ] + = 1 ; })",
    "insertText": "if(!isSeamLineVoxel && flags & YEDGE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ijk [ 0 ] + = 1 ; })",
    "insertText": "if(!isSeamLineVoxel && flags & ZEDGE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ijk [ 0 ] + = 1 ; })",
    "insertText": "if(isSeamLineVoxel)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (maskAcc .)",
    "insertText": "setValue(it.getCoord(), true)"
  },
  {
    "label": "markSeamLineData()",
    "kind": "Method",
    "detail": "Function (} } } } } private : LeafNodeType* const* const mSignFlagsNodes ; TreeType const* const mSignFlagsTree ; BoolTreeType mTempMask ; BoolTreeType* const mMask ; } ; template<SignDataTreeType> void)",
    "insertText": "markSeamLineData(SignDataTreeType& signFlagsTree, const SignDataTreeType& refSignFlagsTree)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (using SignDataType = SignDataTreeType::ValueType ; using SignDataLeafNodeType = SignDataTreeType::LeafNodeType ; using BoolTreeType = SignDataTreeType::template ValueConverter<bool>::Type ; std::vector<SignDataLeafNodeType*> signFlagsLeafNodes ; signFlagsTree .)",
    "insertText": "getNodes(signFlagsLeafNodes)"
  },
  {
    "label": "nodeRange()",
    "kind": "Method",
    "detail": "Function (const tbb::blocked_range<size_t>)",
    "insertText": "nodeRange(0, signFlagsLeafNodes.size())"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(nodeRange, SetSeamLineFlags<SignDataTreeType>(signFlagsLeafNodes, refSignFlagsTree))"
  },
  {
    "label": "seamLineMaskTree()",
    "kind": "Method",
    "detail": "Function (BoolTreeType)",
    "insertText": "seamLineMaskTree(false)"
  },
  {
    "label": "maskSeamLine()",
    "kind": "Method",
    "detail": "Function (MaskSeamLineVoxels<SignDataTreeType>)",
    "insertText": "maskSeamLine(signFlagsLeafNodes, signFlagsTree, seamLineMaskTree)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(nodeRange, maskSeamLine)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(nodeRange, TransferSeamLineFlags<BoolTreeType, SignDataType>(signFlagsLeafNodes, seamLineMaskTree))"
  },
  {
    "label": "MergeVoxelRegions()",
    "kind": "Method",
    "detail": "Function (} template<InputGridType> struct MergeVoxelRegions { using InputTreeType = InputGridType::TreeType ; using InputLeafNodeType = InputTreeType::LeafNodeType ; using InputValueType = InputLeafNodeType::ValueType ; using FloatTreeType = InputTreeType::template ValueConverter<float>::Type ; using FloatLeafNodeType = FloatTreeType::LeafNodeType ; using FloatGridType = Grid<FloatTreeType> ; using Int16TreeType = InputTreeType::template ValueConverter<Int16>::Type ; using Int16LeafNodeType = Int16TreeType::LeafNodeType ; using Index32TreeType = InputTreeType::template ValueConverter<Index32>::Type ; using Index32LeafNodeType = Index32TreeType::LeafNodeType ; using BoolTreeType = InputTreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ;)",
    "insertText": "MergeVoxelRegions(const InputGridType& inputGrid, const Index32TreeType& pointIndexTree, const std::vector<Index32LeafNodeType*>& pointIndexLeafNodes, const std::vector<Int16LeafNodeType*>& signFlagsLeafNodes, InputValueType iso, float adaptivity, bool invertSurfaceOrientation)"
  },
  {
    "label": "setSpatialAdaptivity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setSpatialAdaptivity(const FloatGridType& grid)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (mSpatialAdaptivityTree =& grid .)",
    "insertText": "tree()"
  },
  {
    "label": "transform()",
    "kind": "Method",
    "detail": "Function (mSpatialAdaptivityTransform =& grid .)",
    "insertText": "transform()"
  },
  {
    "label": "setAdaptivityMask()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setAdaptivityMask(const BoolTreeType& mask)"
  },
  {
    "label": "setRefSignFlagsData()",
    "kind": "Method",
    "detail": "Function (mMaskTree =& mask ; } void)",
    "insertText": "setRefSignFlagsData(const Int16TreeType& signFlagsData, float internalAdaptivity)"
  },
  {
    "label": "MergeVoxelRegions()",
    "kind": "Method",
    "detail": "Function (private : InputTreeType const* const mInputTree ; math::Transform const* const mInputTransform ; Index32TreeType const* const mPointIndexTree ; Index32LeafNodeType* const* const mPointIndexNodes ; Int16LeafNodeType const* const* const mSignFlagsNodes ; InputValueType mIsovalue ; float mSurfaceAdaptivity,mInternalAdaptivity ; bool mInvertSurfaceOrientation ; FloatTreeType const* mSpatialAdaptivityTree ; BoolTreeType const* mMaskTree ; Int16TreeType const* mRefSignFlagsTree ; math::Transform const* mSpatialAdaptivityTransform ; } ; template<InputGridType> MergeVoxelRegions<InputGridType)",
    "insertText": "MergeVoxelRegions(const InputGridType& inputGrid, const Index32TreeType& pointIndexTree, const std::vector<Index32LeafNodeType*>& pointIndexLeafNodes, const std::vector<Int16LeafNodeType*>& signFlagsLeafNodes, InputValueType iso, float adaptivity, bool invertSurfaceOrientation) : mInputTree(&inputGrid.tree()) , mInputTransform(&inputGrid.transform()) , mPointIndexTree(&pointIndexTree) , mPointIndexNodes(pointIndexLeafNodes.data()) , mSignFlagsNodes(signFlagsLeafNodes.data()) , mIsovalue(iso) , mSurfaceAdaptivity(adaptivity) , mInternalAdaptivity(adaptivity) , mInvertSurfaceOrientation(invertSurfaceOrientation) , mSpatialAdaptivityTree(nullptr) , mMaskTree(nullptr) , mRefSignFlagsTree(nullptr) , mSpatialAdaptivityTransform(nullptr)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using Vec3sType = math::Vec3<float> ; using Vec3sLeafNodeType = InputLeafNodeType::template ValueConverter<Vec3sType>::Type ; using InputTreeAccessor = tree::ValueAccessor<const InputTreeType> ; using FloatTreeAccessor = tree::ValueAccessor<const FloatTreeType> ; using Index32TreeAccessor = tree::ValueAccessor<const Index32TreeType> ; using Int16TreeAccessor = tree::ValueAccessor<const Int16TreeType> ; using BoolTreeAccessor = tree::ValueAccessor<const BoolTreeType> ; std::unique_ptr<FloatTreeAccessor> spatialAdaptivityAcc ;)",
    "insertText": "if(mSpatialAdaptivityTree && mSpatialAdaptivityTransform)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (spatialAdaptivityAcc .)",
    "insertText": "reset(new FloatTreeAccessor(*mSpatialAdaptivityTree))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} std::unique_ptr<BoolTreeAccessor> maskAcc ;)",
    "insertText": "if(mMaskTree)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (maskAcc .)",
    "insertText": "reset(new BoolTreeAccessor(*mMaskTree))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} std::unique_ptr<Int16TreeAccessor> refSignFlagsAcc ;)",
    "insertText": "if(mRefSignFlagsTree)"
  },
  {
    "label": "pointIndexAcc()",
    "kind": "Method",
    "detail": "Function (Index32TreeAccessor)",
    "insertText": "pointIndexAcc(*mPointIndexTree)"
  },
  {
    "label": "InputValueType()",
    "kind": "Method",
    "detail": "Function (BoolLeafNodeType mask ; const bool invertGradientDir = mInvertSurfaceOrientation | | isBoolValue<)",
    "insertText": "InputValueType()"
  },
  {
    "label": "setValuesOff()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "setValuesOff()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (end [ 0 ] = origin [ 0 ] + LeafDim ; end [ 1 ] = origin [ 1 ] + LeafDim ; end [ 2 ] = origin [ 2 ] + LeafDim ;)",
    "insertText": "if(maskAcc)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "setActiveState(it.getCoord() & ~1u, true)"
  },
  {
    "label": "adaptivity()",
    "kind": "Method",
    "detail": "Function (} } } float)",
    "insertText": "adaptivity(refSignFlagsAcc && !refSignFlagsAcc->probeConstLeaf(origin))"
  },
  {
    "label": "adaptivityLeaf()",
    "kind": "Method",
    "detail": "Function (bool useGradients = adaptivity<1 . 0 f ; FloatLeafNodeType)",
    "insertText": "adaptivityLeaf(origin, adaptivity)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (useGradients = false ;)",
    "insertText": "for(Index offset = 0; offset < FloatLeafNodeType::NUM_VALUES; ++offset)"
  },
  {
    "label": "offsetToGlobalCoord()",
    "kind": "Method",
    "detail": "Function (ijk = adaptivityLeaf .)",
    "insertText": "offsetToGlobalCoord(offset)"
  },
  {
    "label": "worldToIndexCellCentered()",
    "kind": "Method",
    "detail": "Function (ijk = mSpatialAdaptivityTransform ->)",
    "insertText": "worldToIndexCellCentered(mInputTransform->indexToWorld(ijk))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float adaptivityValue = weight* adaptivity ;)",
    "insertText": "if(adaptivityValue < 1.0f)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (adaptivityLeaf .)",
    "insertText": "setValueOnly(offset, adaptivityValue)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "for(auto it = signFlagsNode.cbeginValueOn(); it; ++it)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (const unsigned char signs = static_cast<unsigned)",
    "insertText": "char(SIGNS & int(flags))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(flags & EDGES)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ijk [ 1 ] - = 1 ;)",
    "insertText": "if(!maskRegion && !pointIndexAcc.isValueOn(ijk))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ijk [ 2 ] + = 1 ; })",
    "insertText": "if(!maskRegion && flags & YEDGE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ijk [ 0 ] + = 1 ; })",
    "insertText": "if(!maskRegion && flags & ZEDGE)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ijk [ 0 ] + = 1 ; })",
    "insertText": "if(maskRegion)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } } int dim = 2 ;)",
    "insertText": "for(ijk[0] = origin[0]; ijk[0] < end[0]; ijk[0] += dim)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "setActiveState(ijk, true)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } })",
    "insertText": "if(useGradients)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} else { gradientNode .)",
    "insertText": "reset(new Vec3sLeafNodeType())"
  },
  {
    "label": "dir()",
    "kind": "Method",
    "detail": "Function (Vec3sType)",
    "insertText": "dir(math::ISGradient<math::CD_2ND>::result(inputAcc, ijk))"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (dir = - dir ; } gradientNode ->)",
    "insertText": "setValueOn(it.pos(), dir)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } } int regionId = 1 ;)",
    "insertText": "for(; dim <= LeafDim; dim = dim << 1)"
  },
  {
    "label": "coordMask()",
    "kind": "Method",
    "detail": "Function (const unsigned)",
    "insertText": "coordMask((dim << 1) - 1)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (mask .)",
    "insertText": "setActiveState(ijk & coordMask, true)"
  },
  {
    "label": "mergeVoxels()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "mergeVoxels(pointIndexNode, ijk, dim, regionId++)"
  },
  {
    "label": "UniformPrimBuilder()",
    "kind": "Method",
    "detail": "Function (} } } } } } } struct UniformPrimBuilder {)",
    "insertText": "UniformPrimBuilder(): mIdx(0), mPolygonPool(nullptr)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "init(const size_t upperBound, PolygonPool& quadPool)"
  },
  {
    "label": "resetQuads()",
    "kind": "Method",
    "detail": "Function (mPolygonPool =& quadPool ; mPolygonPool ->)",
    "insertText": "resetQuads(upperBound)"
  },
  {
    "label": "addPrim()",
    "kind": "Method",
    "detail": "Function (mIdx = 0 ; } template<IndexType> void)",
    "insertText": "addPrim(const math::Vec4<IndexType>& verts, bool reverse, char flags = 0)"
  },
  {
    "label": "quad()",
    "kind": "Method",
    "detail": "Function (mPolygonPool ->)",
    "insertText": "quad(mIdx)"
  },
  {
    "label": "quadFlags()",
    "kind": "Method",
    "detail": "Function (quad [ 0 ] = verts [ 3 ] ; quad [ 1 ] = verts [ 2 ] ; quad [ 2 ] = verts [ 1 ] ; quad [ 3 ] = verts [ 0 ] ; } mPolygonPool ->)",
    "insertText": "quadFlags(mIdx)"
  },
  {
    "label": "done()",
    "kind": "Method",
    "detail": "Function (+ + mIdx ; } void)",
    "insertText": "done()"
  },
  {
    "label": "trimQuads()",
    "kind": "Method",
    "detail": "Function (mPolygonPool ->)",
    "insertText": "trimQuads(mIdx)"
  },
  {
    "label": "AdaptivePrimBuilder()",
    "kind": "Method",
    "detail": "Function (} private : size_t mIdx ; PolygonPool* mPolygonPool ; } ; struct AdaptivePrimBuilder {)",
    "insertText": "AdaptivePrimBuilder() : mQuadIdx(0), mTriangleIdx(0), mPolygonPool(nullptr)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "init(const size_t upperBound, PolygonPool& polygonPool)"
  },
  {
    "label": "resetTriangles()",
    "kind": "Method",
    "detail": "Function (mPolygonPool ->)",
    "insertText": "resetTriangles(upperBound)"
  },
  {
    "label": "quadFlags()",
    "kind": "Method",
    "detail": "Function (mPolygonPool ->)",
    "insertText": "quadFlags(mQuadIdx)"
  },
  {
    "label": "addQuad()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addQuad(verts, reverse)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(verts[0] == verts[3] && verts[1] != verts[2] && verts[1] != verts[0] && verts[2] != verts[0])"
  },
  {
    "label": "triangleFlags()",
    "kind": "Method",
    "detail": "Function (mPolygonPool ->)",
    "insertText": "triangleFlags(mTriangleIdx)"
  },
  {
    "label": "addTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addTriangle(verts[0], verts[1], verts[2], reverse)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(verts[1] == verts[2] && verts[0] != verts[3] && verts[0] != verts[1] && verts[3] != verts[1])"
  },
  {
    "label": "addTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addTriangle(verts[0], verts[1], verts[3], reverse)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(verts[0] == verts[1] && verts[2] != verts[3] && verts[2] != verts[0] && verts[3] != verts[0])"
  },
  {
    "label": "addTriangle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addTriangle(verts[0], verts[2], verts[3], reverse)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(verts[2] == verts[3] && verts[0] != verts[1] && verts[0] != verts[2] && verts[1] != verts[2])"
  },
  {
    "label": "trimQuads()",
    "kind": "Method",
    "detail": "Function (mPolygonPool ->)",
    "insertText": "trimQuads(mQuadIdx, true)"
  },
  {
    "label": "trimTrinagles()",
    "kind": "Method",
    "detail": "Function (mPolygonPool ->)",
    "insertText": "trimTrinagles(mTriangleIdx, true)"
  },
  {
    "label": "addQuad()",
    "kind": "Method",
    "detail": "Function (} private : template<IndexType> void)",
    "insertText": "addQuad(const math::Vec4<IndexType>& verts, bool reverse)"
  },
  {
    "label": "quad()",
    "kind": "Method",
    "detail": "Function (mPolygonPool ->)",
    "insertText": "quad(mQuadIdx)"
  },
  {
    "label": "addTriangle()",
    "kind": "Method",
    "detail": "Function (quad [ 0 ] = verts [ 3 ] ; quad [ 1 ] = verts [ 2 ] ; quad [ 2 ] = verts [ 1 ] ; quad [ 3 ] = verts [ 0 ] ; } + + mQuadIdx ; } void)",
    "insertText": "addTriangle(unsigned v0, unsigned v1, unsigned v2, bool reverse)"
  },
  {
    "label": "triangle()",
    "kind": "Method",
    "detail": "Function (Vec3I& prim = mPolygonPool ->)",
    "insertText": "triangle(mTriangleIdx)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (prim [ 1 ] = v1 ;)",
    "insertText": "if(!reverse)"
  },
  {
    "label": "constructPolygons()",
    "kind": "Method",
    "detail": "Function (prim [ 0 ] = v0 ; prim [ 2 ] = v2 ; } else { prim [ 0 ] = v2 ; prim [ 2 ] = v0 ; } + + mTriangleIdx ; } size_t mQuadIdx,mTriangleIdx ; PolygonPool* mPolygonPool ; } ; template<SignAccT,IdxAccT,PrimBuilder> void)",
    "insertText": "constructPolygons(bool invertSurfaceOrientation, Int16 flags, Int16 refFlags, const Vec3i& offsets, const Coord& ijk, const SignAccT& signAcc, const IdxAccT& idxAcc, PrimBuilder& mesher)"
  },
  {
    "label": "IndexType()",
    "kind": "Method",
    "detail": "Function (using IndexType = IdxAccT::ValueType ; IndexType v0 =)",
    "insertText": "IndexType(util::INVALID_IDX)"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (const bool isActive = idxAcc .)",
    "insertText": "probeValue(ijk, v0)"
  },
  {
    "label": "tag()",
    "kind": "Method",
    "detail": "Function (char tag [ 2 ] ;)",
    "insertText": "tag(flags & SEAM)"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (tag [ 1 ] = tag [ 0 ] |)",
    "insertText": "char(POLYFLAG_EXTERIOR)"
  },
  {
    "label": "quad()",
    "kind": "Method",
    "detail": "Function (bool isInside = flags& INSIDE ; isInside = invertSurfaceOrientation ? ! isInside : isInside ; Coord coord = ijk ; math::Vec4<IndexType>)",
    "insertText": "quad(0,0,0,0)"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (quad [ 0 ] = v0 + offsets [ 0 ] ; coord [ 1 ] - - ; bool activeValues = idxAcc .)",
    "insertText": "probeValue(coord, quad[1])"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (uint8_t cell =)",
    "insertText": "uint8_t(SIGNS & signAcc.getValue(coord))"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (quad [ 1 ] + = sEdgeGroupTable [ cell ] [ 0 ]> 1 ? sEdgeGroupTable [ cell ] [ 5 ] - 1 : 0 ; coord [ 2 ] - - ; activeValues = activeValues&& idxAcc .)",
    "insertText": "probeValue(coord, quad[2])"
  },
  {
    "label": "probeValue()",
    "kind": "Method",
    "detail": "Function (quad [ 2 ] + = sEdgeGroupTable [ cell ] [ 0 ]> 1 ? sEdgeGroupTable [ cell ] [ 7 ] - 1 : 0 ; coord [ 1 ] + + ; activeValues = activeValues&& idxAcc .)",
    "insertText": "probeValue(coord, quad[3])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (quad [ 3 ] + = sEdgeGroupTable [ cell ] [ 0 ]> 1 ? sEdgeGroupTable [ cell ] [ 3 ] - 1 : 0 ;)",
    "insertText": "if(activeValues)"
  },
  {
    "label": "addPrim()",
    "kind": "Method",
    "detail": "Function (mesher .)",
    "insertText": "addPrim(quad, isInside, tag[bool(refFlags & XEDGE)])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} coord [ 2 ] + + ; })",
    "insertText": "if(flags & YEDGE)"
  },
  {
    "label": "addPrim()",
    "kind": "Method",
    "detail": "Function (mesher .)",
    "insertText": "addPrim(quad, isInside, tag[bool(refFlags & YEDGE)])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} coord [ 0 ] + + ; })",
    "insertText": "if(flags & ZEDGE)"
  },
  {
    "label": "addPrim()",
    "kind": "Method",
    "detail": "Function (mesher .)",
    "insertText": "addPrim(quad, !isInside, tag[bool(refFlags & ZEDGE)])"
  },
  {
    "label": "MaskTileBorders()",
    "kind": "Method",
    "detail": "Function (} } } template<InputTreeType> struct MaskTileBorders { using InputValueType = InputTreeType::ValueType ; using BoolTreeType = InputTreeType::template ValueConverter<bool>::Type ;)",
    "insertText": "MaskTileBorders(const InputTreeType& inputTree, InputValueType iso, BoolTreeType& mask, const Vec4i* tileArray) : mInputTree(&inputTree) , mIsovalue(iso) , mTempMask(false) , mMask(&mask) , mTileArray(tileArray)"
  },
  {
    "label": "MaskTileBorders()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MaskTileBorders(MaskTileBorders& rhs, tbb::split) : mInputTree(rhs.mInputTree) , mIsovalue(rhs.mIsovalue) , mTempMask(false) , mMask(&mTempMask) , mTileArray(rhs.mTileArray)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "join(MaskTileBorders& rhs)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (const Vec4i& tile = mTileArray [ n ] ; bbox .)",
    "insertText": "min()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "max() = bbox.min()"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (bbox .)",
    "insertText": "max().offset(tile[3])"
  },
  {
    "label": "background()",
    "kind": "Method",
    "detail": "Function (InputValueType value = mInputTree ->)",
    "insertText": "background()"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (const bool isInside =)",
    "insertText": "isInsideValue(inputTreeAcc.getValue(bbox.min()), mIsovalue)"
  },
  {
    "label": "getValueDepth()",
    "kind": "Method",
    "detail": "Function (const int valueDepth = inputTreeAcc .)",
    "insertText": "getValueDepth(bbox.min())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (nijk = ijk ; + + nijk [ 0 ] ; bool processRegion = true ;)",
    "insertText": "if(valueDepth >= inputTreeAcc.getValueDepth(nijk))"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (processRegion = isInside ! =)",
    "insertText": "isInsideValue(inputTreeAcc.getValue(nijk), mIsovalue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(processRegion)"
  },
  {
    "label": "expand()",
    "kind": "Method",
    "detail": "Function (region = bbox ; region .)",
    "insertText": "expand(1)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (region .)",
    "insertText": "min()[0] = region.max()"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (mMask ->)",
    "insertText": "fill(region, false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - ijk [ 0 ] ; processRegion = true ;)",
    "insertText": "if(valueDepth >= inputTreeAcc.getValueDepth(ijk))"
  },
  {
    "label": "processRegion()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "processRegion(!inputTreeAcc.probeValue(ijk, value) && isInside != isInsideValue(value, mIsovalue))"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (region .)",
    "insertText": "min()[1] = region.max()"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (region .)",
    "insertText": "min()[2] = region.max()"
  },
  {
    "label": "maskActiveTileBorders()",
    "kind": "Method",
    "detail": "Function (} } } template<InputTreeType> void)",
    "insertText": "maskActiveTileBorders(const InputTreeType& inputTree, typename InputTreeType::ValueType iso, typename InputTreeType::template ValueConverter<bool>::Type& mask)"
  },
  {
    "label": "tileIter()",
    "kind": "Method",
    "detail": "Function (InputTreeType::ValueOnCIter)",
    "insertText": "tileIter(inputTree)"
  },
  {
    "label": "setMaxDepth()",
    "kind": "Method",
    "detail": "Function (tileIter .)",
    "insertText": "setMaxDepth(InputTreeType::ValueOnCIter::LEAF_DEPTH - 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t tileCount = 0 ;)",
    "insertText": "for(; tileIter; ++tileIter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + tileCount ; })",
    "insertText": "if(tileCount > 0)"
  },
  {
    "label": "tiles()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<Vec4i [ ]>)",
    "insertText": "tiles(new Vec4i[tileCount])"
  },
  {
    "label": "cbeginValueOn()",
    "kind": "Method",
    "detail": "Function (CoordBBox bbox ; size_t index = 0 ; tileIter = inputTree .)",
    "insertText": "cbeginValueOn()"
  },
  {
    "label": "getBoundingBox()",
    "kind": "Method",
    "detail": "Function (Vec4i& tile = tiles [ index + + ] ; tileIter .)",
    "insertText": "getBoundingBox(bbox)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (tile [ 3 ] = bbox .)",
    "insertText": "max()[0] - bbox.min()"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (} MaskTileBorders<InputTreeType>)",
    "insertText": "op(inputTree, iso, mask, tiles.get())"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, tileCount), op)"
  },
  {
    "label": "PointListCopy()",
    "kind": "Method",
    "detail": "Function (} } class PointListCopy { public :)",
    "insertText": "PointListCopy(const PointList& pointsIn, std::vector<Vec3s>& pointsOut) : mPointsIn(pointsIn) , mPointsOut(pointsOut)"
  },
  {
    "label": "constructOffsetList()",
    "kind": "Method",
    "detail": "Function (mPointsOut [ n ] = mPointsIn [ n ] ; } } private : const PointList& mPointsIn ; std::vector<Vec3s>& mPointsOut ; } ; struct LeafNodeVoxelOffsets { using IndexVector = std::vector<Index> ; template<LeafNodeType> void)",
    "insertText": "constructOffsetList()"
  },
  {
    "label": "core()",
    "kind": "Method",
    "detail": "Function (const IndexVector&)",
    "insertText": "core()"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (mCore .)",
    "insertText": "reserve((LeafNodeType::DIM - 2) * (LeafNodeType::DIM - 2))"
  },
  {
    "label": "x()",
    "kind": "Method",
    "detail": "Function (const Index offsetX =)",
    "insertText": "x(2 * LeafNodeType::LOG2DIM)"
  },
  {
    "label": "offsetX()",
    "kind": "Method",
    "detail": "Function (const Index offsetXY =)",
    "insertText": "offsetX(y << LeafNodeType::LOG2DIM)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mCore .)",
    "insertText": "push_back(offsetXY + z)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (mInternalNeighborsX .)",
    "insertText": "reserve(LeafNodeType::SIZE - (LeafNodeType::DIM * LeafNodeType::DIM))"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (mMinX .)",
    "insertText": "reserve(LeafNodeType::DIM * LeafNodeType::DIM)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "for(Index y = 0; y < LeafNodeType::DIM; ++y)"
  },
  {
    "label": "offsetXY()",
    "kind": "Method",
    "detail": "Function (const Index)",
    "insertText": "offsetXY(y << LeafNodeType::LOG2DIM)"
  },
  {
    "label": "offsetX()",
    "kind": "Method",
    "detail": "Function ({ const Index)",
    "insertText": "offsetX(LeafNodeType::DIM - 1) << (2 * LeafNodeType::LOG2DIM)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "for(Index x = 0; x < LeafNodeType::DIM; ++x)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mMinY .)",
    "insertText": "push_back(offsetX + z)"
  },
  {
    "label": "offsetY()",
    "kind": "Method",
    "detail": "Function ({ const Index)",
    "insertText": "offsetY(LeafNodeType::DIM - 1)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mMaxY .)",
    "insertText": "push_back(offsetX + offsetY + z)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mMinZ .)",
    "insertText": "push_back(offsetXY)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (mMaxZ .)",
    "insertText": "push_back(offsetXY + (LeafNodeType::DIM - 1))"
  },
  {
    "label": "VoxelEdgeAccessor()",
    "kind": "Method",
    "detail": "Function (} } } } template<AccessorT,int _AXIS> struct VoxelEdgeAccessor { enum { AXIS = _AXIS } ; AccessorT& acc ;)",
    "insertText": "VoxelEdgeAccessor(AccessorT& _acc) : acc(_acc)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set(Coord ijk)"
  },
  {
    "label": "setActiveState()",
    "kind": "Method",
    "detail": "Function (acc .)",
    "insertText": "setActiveState(ijk)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(_AXIS == 1)"
  },
  {
    "label": "evalInternalVoxelEdges()",
    "kind": "Method",
    "detail": "Function (} } } ; template<VoxelEdgeAcc,LeafNode> void)",
    "insertText": "evalInternalVoxelEdges(VoxelEdgeAcc& edgeAcc, const LeafNode& leafnode, const LeafNodeVoxelOffsets& voxels, const typename LeafNode::ValueType iso)"
  },
  {
    "label": "internalNeighborsZ()",
    "kind": "Method",
    "detail": "Function (Index nvo = 1 ; const std::vector<Index>* offsets =& voxels .)",
    "insertText": "internalNeighborsZ()"
  },
  {
    "label": "internalNeighborsX()",
    "kind": "Method",
    "detail": "Function (nvo = LeafNode::DIM* LeafNode::DIM ; offsets =& voxels .)",
    "insertText": "internalNeighborsX()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(VoxelEdgeAcc::AXIS == 1)"
  },
  {
    "label": "internalNeighborsY()",
    "kind": "Method",
    "detail": "Function (nvo = LeafNode::DIM ; offsets =& voxels .)",
    "insertText": "internalNeighborsY()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(size_t n = 0, N = offsets->size(); n < N; ++n)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (const Index&)",
    "insertText": "pos(*offsets)"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (bool isActive = leafnode .)",
    "insertText": "isValueOn(pos) || leafnode.isValueOn(pos + nvo)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (edgeAcc .)",
    "insertText": "set(leafnode.offsetToGlobalCoord(pos))"
  },
  {
    "label": "evalExtrenalVoxelEdges()",
    "kind": "Method",
    "detail": "Function (} } } template<LeafNode,TreeAcc,VoxelEdgeAcc> void)",
    "insertText": "evalExtrenalVoxelEdges(VoxelEdgeAcc& edgeAcc, TreeAcc& acc, const LeafNode& lhsNode, const LeafNodeVoxelOffsets& voxels, const typename LeafNode::ValueType iso)"
  },
  {
    "label": "maxX()",
    "kind": "Method",
    "detail": "Function (const std::vector<Index>* lhsOffsets =& voxels .)",
    "insertText": "maxX()"
  },
  {
    "label": "minX()",
    "kind": "Method",
    "detail": "Function (const std::vector<Index>* rhsOffsets =& voxels .)",
    "insertText": "minX()"
  },
  {
    "label": "maxY()",
    "kind": "Method",
    "detail": "Function (ijk [ 1 ] + = LeafNode::DIM ; lhsOffsets =& voxels .)",
    "insertText": "maxY()"
  },
  {
    "label": "minY()",
    "kind": "Method",
    "detail": "Function (rhsOffsets =& voxels .)",
    "insertText": "minY()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(VoxelEdgeAcc::AXIS == 2)"
  },
  {
    "label": "maxZ()",
    "kind": "Method",
    "detail": "Function (ijk [ 2 ] + = LeafNode::DIM ; lhsOffsets =& voxels .)",
    "insertText": "maxZ()"
  },
  {
    "label": "minZ()",
    "kind": "Method",
    "detail": "Function (rhsOffsets =& voxels .)",
    "insertText": "minZ()"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (} LeafNode::ValueType value ; const LeafNode* rhsNodePt = acc .)",
    "insertText": "probeConstLeaf(ijk)"
  },
  {
    "label": "pos()",
    "kind": "Method",
    "detail": "Function (const Index&)",
    "insertText": "pos(*lhsOffsets)"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (bool isActive = lhsNode .)",
    "insertText": "isValueOn(pos) || rhsNodePt->isValueOn((*rhsOffsets)[n])"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (edgeAcc .)",
    "insertText": "set(lhsNode.offsetToGlobalCoord(pos))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else)",
    "insertText": "if(!acc.probeValue(ijk, value))"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (const bool inside =)",
    "insertText": "isInsideValue(value, iso)"
  },
  {
    "label": "evalExtrenalVoxelEdgesInv()",
    "kind": "Method",
    "detail": "Function (} } } } template<LeafNode,TreeAcc,VoxelEdgeAcc> void)",
    "insertText": "evalExtrenalVoxelEdgesInv(VoxelEdgeAcc& edgeAcc, TreeAcc& acc, const LeafNode& leafnode, const LeafNodeVoxelOffsets& voxels, const typename LeafNode::ValueType iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (LeafNode::ValueType value ;)",
    "insertText": "if(!acc.probeConstLeaf(ijk) && !acc.probeValue(ijk, value))"
  },
  {
    "label": "offsetToGlobalCoord()",
    "kind": "Method",
    "detail": "Function (ijk = leafnode .)",
    "insertText": "offsetToGlobalCoord(pos)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (edgeAcc .)",
    "insertText": "set(ijk)"
  },
  {
    "label": "IdentifyIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (} } } } template<InputTreeType> struct IdentifyIntersectingVoxels { using InputLeafNodeType = InputTreeType::LeafNodeType ; using InputValueType = InputLeafNodeType::ValueType ; using BoolTreeType = InputTreeType::template ValueConverter<bool>::Type ;)",
    "insertText": "IdentifyIntersectingVoxels(const InputTreeType& inputTree, const std::vector<const InputLeafNodeType*>& inputLeafNodes, BoolTreeType& intersectionTree, InputValueType iso)"
  },
  {
    "label": "IdentifyIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IdentifyIntersectingVoxels(IdentifyIntersectingVoxels&, tbb::split)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "join(const IdentifyIntersectingVoxels& rhs)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (mIntersectionAccessor .)",
    "insertText": "tree().merge(rhs.mIntersectionAccessor.tree())"
  },
  {
    "label": "IdentifyIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (} private : tree::ValueAccessor<const InputTreeType> mInputAccessor ; InputLeafNodeType const* const* const mInputNodes ; BoolTreeType mIntersectionTree ; tree::ValueAccessor<BoolTreeType> mIntersectionAccessor ; LeafNodeVoxelOffsets mOffsetData ; const LeafNodeVoxelOffsets* mOffsets ; InputValueType mIsovalue ; } ; template<InputTreeType> IdentifyIntersectingVoxels<InputTreeType)",
    "insertText": "IdentifyIntersectingVoxels(const InputTreeType& inputTree, const std::vector<const InputLeafNodeType*>& inputLeafNodes, BoolTreeType& intersectionTree, InputValueType iso) : mInputAccessor(inputTree) , mInputNodes(inputLeafNodes.data()) , mIntersectionTree(false) , mIntersectionAccessor(intersectionTree) , mOffsetData() , mOffsets(&mOffsetData) , mIsovalue(iso)"
  },
  {
    "label": "InputLeafNodeType()",
    "kind": "Method",
    "detail": "Function (mOffsetData . constructOffsetList<)",
    "insertText": "InputLeafNodeType()"
  },
  {
    "label": "IdentifyIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (} template<InputTreeType> IdentifyIntersectingVoxels<InputTreeType)",
    "insertText": "IdentifyIntersectingVoxels(IdentifyIntersectingVoxels& rhs, tbb::split) : mInputAccessor(rhs.mInputAccessor.tree()) , mInputNodes(rhs.mInputNodes) , mIntersectionTree(false) , mIntersectionAccessor(mIntersectionTree) , mOffsetData() , mOffsets(rhs.mOffsets) , mIsovalue(rhs.mIsovalue)"
  },
  {
    "label": "xEdgeAcc()",
    "kind": "Method",
    "detail": "Function (VoxelEdgeAccessor<tree::ValueAccessor<BoolTreeType>,0>)",
    "insertText": "xEdgeAcc(mIntersectionAccessor)"
  },
  {
    "label": "yEdgeAcc()",
    "kind": "Method",
    "detail": "Function (VoxelEdgeAccessor<tree::ValueAccessor<BoolTreeType>,1>)",
    "insertText": "yEdgeAcc(mIntersectionAccessor)"
  },
  {
    "label": "zEdgeAcc()",
    "kind": "Method",
    "detail": "Function (VoxelEdgeAccessor<tree::ValueAccessor<BoolTreeType>,2>)",
    "insertText": "zEdgeAcc(mIntersectionAccessor)"
  },
  {
    "label": "evalInternalVoxelEdges()",
    "kind": "Method",
    "detail": "Function (const InputLeafNodeType& node =* mInputNodes [ n ] ;)",
    "insertText": "evalInternalVoxelEdges(xEdgeAcc, node, *mOffsets, mIsovalue)"
  },
  {
    "label": "evalInternalVoxelEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalInternalVoxelEdges(yEdgeAcc, node, *mOffsets, mIsovalue)"
  },
  {
    "label": "evalInternalVoxelEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalInternalVoxelEdges(zEdgeAcc, node, *mOffsets, mIsovalue)"
  },
  {
    "label": "evalExtrenalVoxelEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalExtrenalVoxelEdges(xEdgeAcc, mInputAccessor, node, *mOffsets, mIsovalue)"
  },
  {
    "label": "evalExtrenalVoxelEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalExtrenalVoxelEdges(yEdgeAcc, mInputAccessor, node, *mOffsets, mIsovalue)"
  },
  {
    "label": "evalExtrenalVoxelEdges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalExtrenalVoxelEdges(zEdgeAcc, mInputAccessor, node, *mOffsets, mIsovalue)"
  },
  {
    "label": "evalExtrenalVoxelEdgesInv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalExtrenalVoxelEdgesInv(xEdgeAcc, mInputAccessor, node, *mOffsets, mIsovalue)"
  },
  {
    "label": "evalExtrenalVoxelEdgesInv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalExtrenalVoxelEdgesInv(yEdgeAcc, mInputAccessor, node, *mOffsets, mIsovalue)"
  },
  {
    "label": "evalExtrenalVoxelEdgesInv()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "evalExtrenalVoxelEdgesInv(zEdgeAcc, mInputAccessor, node, *mOffsets, mIsovalue)"
  },
  {
    "label": "identifySurfaceIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (} } template<InputTreeType> void)",
    "insertText": "identifySurfaceIntersectingVoxels(typename InputTreeType::template ValueConverter<bool>::Type& intersectionTree, const InputTreeType& inputTree, typename InputTreeType::ValueType isovalue)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (using InputLeafNodeType = InputTreeType::LeafNodeType ; std::vector<const InputLeafNodeType*> inputLeafNodes ; inputTree .)",
    "insertText": "getNodes(inputLeafNodes)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (IdentifyIntersectingVoxels<InputTreeType>)",
    "insertText": "op(inputTree, inputLeafNodes, intersectionTree, isovalue)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, inputLeafNodes.size()), op)"
  },
  {
    "label": "maskActiveTileBorders()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "maskActiveTileBorders(inputTree, isovalue, intersectionTree)"
  },
  {
    "label": "MaskIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (} template<InputTreeType> struct MaskIntersectingVoxels { using InputLeafNodeType = InputTreeType::LeafNodeType ; using InputValueType = InputLeafNodeType::ValueType ; using BoolTreeType = InputTreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ;)",
    "insertText": "MaskIntersectingVoxels(const InputTreeType& inputTree, const std::vector<BoolLeafNodeType*>& nodes, BoolTreeType& intersectionTree, InputValueType iso)"
  },
  {
    "label": "MaskIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MaskIntersectingVoxels(MaskIntersectingVoxels&, tbb::split)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "join(const MaskIntersectingVoxels& rhs)"
  },
  {
    "label": "MaskIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (} private : tree::ValueAccessor<const InputTreeType> mInputAccessor ; BoolLeafNodeType const* const* const mNodes ; BoolTreeType mIntersectionTree ; tree::ValueAccessor<BoolTreeType> mIntersectionAccessor ; InputValueType mIsovalue ; } ; template<InputTreeType> MaskIntersectingVoxels<InputTreeType)",
    "insertText": "MaskIntersectingVoxels(const InputTreeType& inputTree, const std::vector<BoolLeafNodeType*>& nodes, BoolTreeType& intersectionTree, InputValueType iso) : mInputAccessor(inputTree) , mNodes(nodes.data()) , mIntersectionTree(false) , mIntersectionAccessor(intersectionTree) , mIsovalue(iso)"
  },
  {
    "label": "MaskIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (} template<InputTreeType> MaskIntersectingVoxels<InputTreeType)",
    "insertText": "MaskIntersectingVoxels(MaskIntersectingVoxels& rhs, tbb::split) : mInputAccessor(rhs.mInputAccessor.tree()) , mNodes(rhs.mNodes) , mIntersectionTree(false) , mIntersectionAccessor(mIntersectionTree) , mIsovalue(rhs.mIsovalue)"
  },
  {
    "label": "iso()",
    "kind": "Method",
    "detail": "Function (InputValueType)",
    "insertText": "iso(mIsovalue)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const BoolLeafNodeType& node =* mNodes [ n ] ;)",
    "insertText": "for(typename BoolLeafNodeType::ValueOnCIter it = node.cbeginValueOn(); it; ++it)"
  },
  {
    "label": "isInsideValue()",
    "kind": "Method",
    "detail": "Function (const bool inside =)",
    "insertText": "isInsideValue(mInputAccessor.getValue(ijk), iso)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(inside != isInsideValue(mInputAccessor.getValue(ijk.offsetBy(0, 1, 0)), iso))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(inside != isInsideValue(mInputAccessor.getValue(ijk.offsetBy(0, 0, 1)), iso))"
  },
  {
    "label": "MaskBorderVoxels()",
    "kind": "Method",
    "detail": "Function (} } } } } template<BoolTreeType> struct MaskBorderVoxels { using BoolLeafNodeType = BoolTreeType::LeafNodeType ;)",
    "insertText": "MaskBorderVoxels(const BoolTreeType& maskTree, const std::vector<BoolLeafNodeType*>& maskNodes, BoolTreeType& borderTree) : mMaskTree(&maskTree) , mMaskNodes(maskNodes.data()) , mTmpBorderTree(false) , mBorderTree(&borderTree)"
  },
  {
    "label": "MaskBorderVoxels()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "MaskBorderVoxels(MaskBorderVoxels& rhs, tbb::split) : mMaskTree(rhs.mMaskTree) , mMaskNodes(rhs.mMaskNodes) , mTmpBorderTree(false) , mBorderTree(&mTmpBorderTree)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "join(MaskBorderVoxels& rhs)"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (mBorderTree ->)",
    "insertText": "merge(*rhs.mBorderTree)"
  },
  {
    "label": "borderAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<BoolTreeType>)",
    "insertText": "borderAcc(*mBorderTree)"
  },
  {
    "label": "isEdgeVoxel()",
    "kind": "Method",
    "detail": "Function (bool rhs = lhs ; bool isEdgeVoxel = false ; ijk [ 2 ] + = 1 ;)",
    "insertText": "isEdgeVoxel(maskAcc.probeValue(ijk, rhs) && lhs != rhs)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (ijk [ 1 ] - = 1 ; borderAcc .)",
    "insertText": "setValue(ijk, true)"
  },
  {
    "label": "SyncMaskValues()",
    "kind": "Method",
    "detail": "Function (} } } } private : BoolTreeType const* const mMaskTree ; BoolLeafNodeType const* const* const mMaskNodes ; BoolTreeType mTmpBorderTree ; BoolTreeType* const mBorderTree ; } ; template<BoolTreeType> struct SyncMaskValues { using BoolLeafNodeType = BoolTreeType::LeafNodeType ;)",
    "insertText": "SyncMaskValues(const std::vector<BoolLeafNodeType*>& nodes, const BoolTreeType& mask) : mNodes(nodes.data()) , mMaskTree(&mask)"
  },
  {
    "label": "maskTreeAcc()",
    "kind": "Method",
    "detail": "Function (using ValueOnIter = BoolLeafNodeType::ValueOnIter ; tree::ValueAccessor<const BoolTreeType>)",
    "insertText": "maskTreeAcc(*mMaskTree)"
  },
  {
    "label": "probeConstLeaf()",
    "kind": "Method",
    "detail": "Function (BoolLeafNodeType& node =* mNodes [ n ] ; const BoolLeafNodeType* maskNode = maskTreeAcc .)",
    "insertText": "probeConstLeaf(node.origin())"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (node .)",
    "insertText": "setValueOnly(pos, true)"
  },
  {
    "label": "MaskSurface()",
    "kind": "Method",
    "detail": "Function (} } } } } private : BoolLeafNodeType* const* const mNodes ; BoolTreeType const* const mMaskTree ; } ; template<BoolTreeType> struct MaskSurface { using BoolLeafNodeType = BoolTreeType::LeafNodeType ;)",
    "insertText": "MaskSurface(const std::vector<BoolLeafNodeType*>& nodes, const BoolTreeType& mask, const math::Transform& inputTransform, const math::Transform& maskTransform, bool invert) : mNodes(nodes.data()) , mMaskTree(&mask) , mInputTransform(inputTransform) , mMaskTransform(maskTransform) , mInvertMask(invert)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (BoolLeafNodeType& node =* mNodes [ n ] ;)",
    "insertText": "if(matchingTransforms)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else {)",
    "insertText": "if(maskTreeAcc.isValueOn(node.origin()) == maskState)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (node .)",
    "insertText": "setValueOnly(it.pos(), true)"
  },
  {
    "label": "worldToIndexCellCentered()",
    "kind": "Method",
    "detail": "Function (ijk = mMaskTransform .)",
    "insertText": "worldToIndexCellCentered(mInputTransform.indexToWorld(it.getCoord()))"
  },
  {
    "label": "applySurfaceMask()",
    "kind": "Method",
    "detail": "Function (} } } } } private : BoolLeafNodeType* const* const mNodes ; BoolTreeType const* const mMaskTree ; math::Transform const mInputTransform ; math::Transform const mMaskTransform ; bool const mInvertMask ; } ; template<InputGridType> void)",
    "insertText": "applySurfaceMask(typename InputGridType::TreeType::template ValueConverter<bool>::Type& intersectionTree, typename InputGridType::TreeType::template ValueConverter<bool>::Type& borderTree, const InputGridType& inputGrid, const GridBase::ConstPtr& maskGrid, bool invertMask, typename InputGridType::ValueType isovalue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (using InputTreeType = InputGridType::TreeType ; using BoolTreeType = InputTreeType::template ValueConverter<bool>::Type ; using BoolLeafNodeType = BoolTreeType::LeafNodeType ; using BoolGridType = Grid<BoolTreeType> ;)",
    "insertText": "if(maskGrid && maskGrid->type() == BoolGridType::gridType())"
  },
  {
    "label": "BoolGridType()",
    "kind": "Method",
    "detail": "Function (const BoolGridType* surfaceMask = static_cast<const)",
    "insertText": "BoolGridType(maskGrid.get())"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (std::vector<BoolLeafNodeType*> intersectionLeafNodes ; intersectionTree .)",
    "insertText": "getNodes(intersectionLeafNodes)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, intersectionLeafNodes.size()), MaskSurface<BoolTreeType>( intersectionLeafNodes, maskTree, transform, maskTransform, invertMask))"
  },
  {
    "label": "borderOp()",
    "kind": "Method",
    "detail": "Function (MaskBorderVoxels<BoolTreeType>)",
    "insertText": "borderOp(intersectionTree, intersectionLeafNodes, borderTree)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, intersectionLeafNodes.size()), borderOp)"
  },
  {
    "label": "tmpIntersectionTree()",
    "kind": "Method",
    "detail": "Function (BoolTreeType)",
    "insertText": "tmpIntersectionTree(false)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (MaskIntersectingVoxels<InputTreeType>)",
    "insertText": "op(inputTree, intersectionLeafNodes, tmpIntersectionTree, isovalue)"
  },
  {
    "label": "parallel_reduce()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_reduce(tbb::blocked_range<size_t>(0, intersectionLeafNodes.size()), op)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (std::vector<BoolLeafNodeType*> tmpIntersectionLeafNodes ; tmpIntersectionTree .)",
    "insertText": "getNodes(tmpIntersectionLeafNodes)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, tmpIntersectionLeafNodes.size()), SyncMaskValues<BoolTreeType>(tmpIntersectionLeafNodes, intersectionTree))"
  },
  {
    "label": "merge()",
    "kind": "Method",
    "detail": "Function (intersectionTree .)",
    "insertText": "merge(tmpIntersectionTree)"
  },
  {
    "label": "ComputeAuxiliaryData()",
    "kind": "Method",
    "detail": "Function (} } template<InputTreeType> struct ComputeAuxiliaryData { using InputLeafNodeType = InputTreeType::LeafNodeType ; using InputValueType = InputLeafNodeType::ValueType ; using BoolLeafNodeType = tree::LeafNode<bool,InputLeafNodeType::LOG2DIM> ; using Int16TreeType = InputTreeType::template ValueConverter<Int16>::Type ; using Index32TreeType = InputTreeType::template ValueConverter<Index32>::Type ;)",
    "insertText": "ComputeAuxiliaryData(const InputTreeType& inputTree, const std::vector<const BoolLeafNodeType*>& intersectionLeafNodes, Int16TreeType& signFlagsTree, Index32TreeType& pointIndexTree, InputValueType iso)"
  },
  {
    "label": "ComputeAuxiliaryData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeAuxiliaryData(ComputeAuxiliaryData&, tbb::split)"
  },
  {
    "label": "join()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "join(const ComputeAuxiliaryData& rhs)"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (mSignFlagsAccessor .)",
    "insertText": "tree().merge(rhs.mSignFlagsAccessor.tree())"
  },
  {
    "label": "tree()",
    "kind": "Method",
    "detail": "Function (mPointIndexAccessor .)",
    "insertText": "tree().merge(rhs.mPointIndexAccessor.tree())"
  },
  {
    "label": "ComputeAuxiliaryData()",
    "kind": "Method",
    "detail": "Function (} private : tree::ValueAccessor<const InputTreeType> mInputAccessor ; BoolLeafNodeType const* const* const mIntersectionNodes ; Int16TreeType mSignFlagsTree ; tree::ValueAccessor<Int16TreeType> mSignFlagsAccessor ; Index32TreeType mPointIndexTree ; tree::ValueAccessor<Index32TreeType> mPointIndexAccessor ; const InputValueType mIsovalue ; } ; template<InputTreeType> ComputeAuxiliaryData<InputTreeType)",
    "insertText": "ComputeAuxiliaryData(const InputTreeType& inputTree, const std::vector<const BoolLeafNodeType*>& intersectionLeafNodes, Int16TreeType& signFlagsTree, Index32TreeType& pointIndexTree, InputValueType iso) : mInputAccessor(inputTree) , mIntersectionNodes(intersectionLeafNodes.data()) , mSignFlagsTree(0) , mSignFlagsAccessor(signFlagsTree) , mPointIndexTree(std::numeric_limits<Index32>::max()) , mPointIndexAccessor(pointIndexTree) , mIsovalue(iso)"
  },
  {
    "label": "root()",
    "kind": "Method",
    "detail": "Function (pointIndexTree .)",
    "insertText": "root().setBackground(std::numeric_limits<Index32>::max(), false)"
  },
  {
    "label": "ComputeAuxiliaryData()",
    "kind": "Method",
    "detail": "Function (} template<InputTreeType> ComputeAuxiliaryData<InputTreeType)",
    "insertText": "ComputeAuxiliaryData(ComputeAuxiliaryData& rhs, tbb::split) : mInputAccessor(rhs.mInputAccessor.tree()) , mIntersectionNodes(rhs.mIntersectionNodes) , mSignFlagsTree(0) , mSignFlagsAccessor(mSignFlagsTree) , mPointIndexTree(std::numeric_limits<Index32>::max()) , mPointIndexAccessor(mPointIndexTree) , mIsovalue(rhs.mIsovalue)"
  },
  {
    "label": "signsNodePt()",
    "kind": "Method",
    "detail": "Function (using Int16LeafNodeType = Int16TreeType::LeafNodeType ; Coord ijk ; math::Tuple<8,InputValueType> cellVertexValues ; std::unique_ptr<Int16LeafNodeType>)",
    "insertText": "signsNodePt(new Int16LeafNodeType(ijk, 0))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bool updatedNode = false ;)",
    "insertText": "for(typename BoolLeafNodeType::ValueOnCIter it = maskNode.cbeginValueOn(); it; ++it)"
  },
  {
    "label": "offsetToLocalCoord()",
    "kind": "Method",
    "detail": "Function (ijk =)",
    "insertText": "offsetToLocalCoord(pos)"
  },
  {
    "label": "getCellVertexValues()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getCellVertexValues(*leafPt, pos, cellVertexValues)"
  },
  {
    "label": "getCellVertexValues()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "getCellVertexValues(mInputAccessor, origin + ijk, cellVertexValues)"
  },
  {
    "label": "computeSignFlags()",
    "kind": "Method",
    "detail": "Function (} uint8_t signFlags =)",
    "insertText": "computeSignFlags(cellVertexValues, mIsovalue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const bool inside = signFlags& 0 x1 ; int edgeFlags = inside ? INSIDE : 0 ;)",
    "insertText": "if(!it.getValue())"
  },
  {
    "label": "inside()",
    "kind": "Method",
    "detail": "Function (edgeFlags | =)",
    "insertText": "inside((signFlags & 0x02) != 0)"
  },
  {
    "label": "inside()",
    "kind": "Method",
    "detail": "Function (edgeFlags | =)",
    "insertText": "inside((signFlags & 0x10) != 0)"
  },
  {
    "label": "inside()",
    "kind": "Method",
    "detail": "Function (edgeFlags | =)",
    "insertText": "inside((signFlags & 0x08) != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} const uint8_t ambiguousCellFlags = sAmbiguousFace [ signFlags ] ;)",
    "insertText": "if(ambiguousCellFlags != 0)"
  },
  {
    "label": "correctCellSigns()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "correctCellSigns(signFlags, ambiguousCellFlags, mInputAccessor, origin + ijk, mIsovalue)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} edgeFlags | =)",
    "insertText": "int(signFlags)"
  },
  {
    "label": "setValueOn()",
    "kind": "Method",
    "detail": "Function (signsNodePt ->)",
    "insertText": "setValueOn(pos, Int16(edgeFlags))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (updatedNode = true ; } })",
    "insertText": "if(updatedNode)"
  },
  {
    "label": "touchLeaf()",
    "kind": "Method",
    "detail": "Function (Index32TreeType::LeafNodeType* idxNode = mPointIndexAccessor .)",
    "insertText": "touchLeaf(origin)"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (idxNode ->)",
    "insertText": "topologyUnion(*signsNodePt)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (idxNode ->)",
    "insertText": "setValueOnly(it.pos(), 0)"
  },
  {
    "label": "addLeaf()",
    "kind": "Method",
    "detail": "Function (} mSignFlagsAccessor .)",
    "insertText": "addLeaf(signsNodePt.release())"
  },
  {
    "label": "computeAuxiliaryData()",
    "kind": "Method",
    "detail": "Function (} } } template<InputTreeType> void)",
    "insertText": "computeAuxiliaryData(typename InputTreeType::template ValueConverter<Int16>::Type& signFlagsTree, typename InputTreeType::template ValueConverter<Index32>::Type& pointIndexTree, const typename InputTreeType::template ValueConverter<bool>::Type& intersectionTree, const InputTreeType& inputTree, typename InputTreeType::ValueType isovalue)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (ComputeAuxiliaryData<InputTreeType>)",
    "insertText": "op(inputTree, intersectionLeafNodes, signFlagsTree, pointIndexTree, isovalue)"
  },
  {
    "label": "LeafNodePointCount()",
    "kind": "Method",
    "detail": "Function (} template<Index32 LeafNodeLog2Dim> struct LeafNodePointCount { using Int16LeafNodeType = tree::LeafNode<Int16,LeafNodeLog2Dim> ;)",
    "insertText": "LeafNodePointCount(const std::vector<Int16LeafNodeType*>& leafNodes, std::unique_ptr<Index32[]>& leafNodeCount) : mLeafNodes(leafNodes.data()) , mData(leafNodeCount.get())"
  },
  {
    "label": "buffer()",
    "kind": "Method",
    "detail": "Function (Index32 count = 0 ; Int16 const* p = mLeafNodes [ n ] ->)",
    "insertText": "buffer().data()"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (Int16 const* const endP = p + Int16LeafNodeType::SIZE ;)",
    "insertText": "while(p < endP)"
  },
  {
    "label": "Index32()",
    "kind": "Method",
    "detail": "Function (count + =)",
    "insertText": "Index32(sEdgeGroupTable[(SIGNS & *p)][0])"
  },
  {
    "label": "AdaptiveLeafNodePointCount()",
    "kind": "Method",
    "detail": "Function (+ + p ; } mData [ n ] = count ; } } private : Int16LeafNodeType* const* const mLeafNodes ; Index32* mData ; } ; template<PointIndexLeafNode> struct AdaptiveLeafNodePointCount { using Int16LeafNodeType = tree::LeafNode<Int16,PointIndexLeafNode::LOG2DIM> ;)",
    "insertText": "AdaptiveLeafNodePointCount(const std::vector<PointIndexLeafNode*>& pointIndexNodes, const std::vector<Int16LeafNodeType*>& signDataNodes, std::unique_ptr<Index32[]>& leafNodeCount) : mPointIndexNodes(pointIndexNodes.data()) , mSignDataNodes(signDataNodes.data()) , mData(leafNodeCount.get())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const PointIndexLeafNode& node =* mPointIndexNodes [ n ] ; const Int16LeafNodeType& signNode =* mSignDataNodes [ n ] ; size_t count = 0 ; std::set<IndexType> uniqueRegions ;)",
    "insertText": "for(typename PointIndexLeafNode::ValueOnCIter it = node.cbeginValueOn(); it; ++it)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (count + =)",
    "insertText": "size_t(sEdgeGroupTable[(SIGNS & signNode.getValue(it.pos()))][0])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(id != IndexType(util::INVALID_IDX))"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (uniqueRegions .)",
    "insertText": "insert(id)"
  },
  {
    "label": "Index32()",
    "kind": "Method",
    "detail": "Function (} } mData [ n ] =)",
    "insertText": "Index32(count + uniqueRegions.size())"
  },
  {
    "label": "MapPoints()",
    "kind": "Method",
    "detail": "Function (} } private : PointIndexLeafNode const* const* const mPointIndexNodes ; Int16LeafNodeType const* const* const mSignDataNodes ; Index32* mData ; } ; template<PointIndexLeafNode> struct MapPoints { using Int16LeafNodeType = tree::LeafNode<Int16,PointIndexLeafNode::LOG2DIM> ;)",
    "insertText": "MapPoints(const std::vector<PointIndexLeafNode*>& pointIndexNodes, const std::vector<Int16LeafNodeType*>& signDataNodes, std::unique_ptr<Index32[]>& leafNodeCount) : mPointIndexNodes(pointIndexNodes.data()) , mSignDataNodes(signDataNodes.data()) , mData(leafNodeCount.get())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const Int16LeafNodeType& signNode =* mSignDataNodes [ n ] ; PointIndexLeafNode& indexNode =* mPointIndexNodes [ n ] ; Index32 pointOffset = mData [ n ] ;)",
    "insertText": "for(auto it = indexNode.beginValueOn(); it; ++it)"
  },
  {
    "label": "setValueOnly()",
    "kind": "Method",
    "detail": "Function (indexNode .)",
    "insertText": "setValueOnly(pos, pointOffset)"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (const int signs = SIGNS&)",
    "insertText": "int(signNode.getValue(pos))"
  },
  {
    "label": "Index32()",
    "kind": "Method",
    "detail": "Function (pointOffset + =)",
    "insertText": "Index32(sEdgeGroupTable[signs][0])"
  },
  {
    "label": "ComputePolygons()",
    "kind": "Method",
    "detail": "Function (} } } private : PointIndexLeafNode* const* const mPointIndexNodes ; Int16LeafNodeType const* const* const mSignDataNodes ; Index32* const mData ; } ; template<TreeType,PrimBuilder> struct ComputePolygons { using Int16TreeType = TreeType::template ValueConverter<Int16>::Type ; using Int16LeafNodeType = Int16TreeType::LeafNodeType ; using Index32TreeType = TreeType::template ValueConverter<Index32>::Type ; using Index32LeafNodeType = Index32TreeType::LeafNodeType ;)",
    "insertText": "ComputePolygons(const std::vector<Int16LeafNodeType*>& signFlagsLeafNodes, const Int16TreeType& signFlagsTree, const Index32TreeType& idxTree, PolygonPoolList& polygons, bool invertSurfaceOrientation)"
  },
  {
    "label": "setRefSignTree()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setRefSignTree(const Int16TreeType * r)"
  },
  {
    "label": "ComputePolygons()",
    "kind": "Method",
    "detail": "Function (private : Int16LeafNodeType* const* const mSignFlagsLeafNodes ; Int16TreeType const* const mSignFlagsTree ; Int16TreeType const* mRefSignFlagsTree ; Index32TreeType const* const mIndexTree ; PolygonPoolList* const mPolygonPoolList ; bool const mInvertSurfaceOrientation ; } ; template<TreeType,PrimBuilder> ComputePolygons<TreeType,PrimBuilder)",
    "insertText": "ComputePolygons(const std::vector<Int16LeafNodeType*>& signFlagsLeafNodes, const Int16TreeType& signFlagsTree, const Index32TreeType& idxTree, PolygonPoolList& polygons, bool invertSurfaceOrientation) : mSignFlagsLeafNodes(signFlagsLeafNodes.data()) , mSignFlagsTree(&signFlagsTree) , mRefSignFlagsTree(nullptr) , mIndexTree(&idxTree) , mPolygonPoolList(&polygons) , mInvertSurfaceOrientation(invertSurfaceOrientation)"
  },
  {
    "label": "signAcc()",
    "kind": "Method",
    "detail": "Function (using Int16ValueAccessor = tree::ValueAccessor<const Int16TreeType> ; Int16ValueAccessor)",
    "insertText": "signAcc(*mSignFlagsTree)"
  },
  {
    "label": "idxAcc()",
    "kind": "Method",
    "detail": "Function (tree::ValueAccessor<const Index32TreeType>)",
    "insertText": "idxAcc(*mIndexTree)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const bool invertSurfaceOrientation = mInvertSurfaceOrientation ; PrimBuilder mesher ; size_t edgeCount ; Coord ijk,origin ; std::unique_ptr<Int16ValueAccessor> refSignAcc ;)",
    "insertText": "if(mRefSignFlagsTree) refSignAcc.reset(new Int16ValueAccessor(*mRefSignFlagsTree))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(edgeCount == 0)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (mesher .)",
    "insertText": "init(edgeCount, (*mPolygonPoolList)[n])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Int16LeafNodeType* refSignLeafPt = nullptr ;)",
    "insertText": "if(refSignAcc) refSignLeafPt = refSignAcc->probeConstLeaf(origin)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Vec3i offsets ;)",
    "insertText": "for(iter = node.cbeginValueOn(); iter; ++iter)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Int16 refFlags = 0 ;)",
    "insertText": "if(refSignLeafPt)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (refFlags = refSignLeafPt ->)",
    "insertText": "getValue(iter.pos())"
  },
  {
    "label": "offsets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "offsets(sEdgeGroupTable[cell][1] - 1)"
  },
  {
    "label": "offsets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "offsets(sEdgeGroupTable[cell][9] - 1)"
  },
  {
    "label": "offsets()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "offsets(sEdgeGroupTable[cell][4] - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(ijk[0] > origin[0] && ijk[1] > origin[1] && ijk[2] > origin[2])"
  },
  {
    "label": "constructPolygons()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "constructPolygons(invertSurfaceOrientation, flags, refFlags, offsets, ijk, *signleafPt, *idxLeafPt, mesher)"
  },
  {
    "label": "constructPolygons()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "constructPolygons(invertSurfaceOrientation, flags, refFlags, offsets, ijk, signAcc, idxAcc, mesher)"
  },
  {
    "label": "CopyArray()",
    "kind": "Method",
    "detail": "Function (} } template<T> struct CopyArray {)",
    "insertText": "CopyArray(T * outputArray, const T * inputArray, size_t outputOffset = 0) : mOutputArray(outputArray), mInputArray(inputArray), mOutputOffset(outputOffset)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "operator()(const tbb::blocked_range<size_t>& inputArrayRange)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const size_t offset = mOutputOffset ;)",
    "insertText": "for(size_t n = inputArrayRange.begin(), N = inputArrayRange.end(); n < N; ++n)"
  },
  {
    "label": "FlagAndCountQuadsToSubdivide()",
    "kind": "Method",
    "detail": "Function (mOutputArray [ offset + n ] = mInputArray [ n ] ; } } private : T* const mOutputArray ; T const* const mInputArray ; size_t const mOutputOffset ; } ; struct FlagAndCountQuadsToSubdivide {)",
    "insertText": "FlagAndCountQuadsToSubdivide(PolygonPoolList& polygons, const std::vector<uint8_t>& pointFlags, std::unique_ptr<openvdb::Vec3s[]>& points, std::unique_ptr<unsigned[]>& numQuadsToDivide) : mPolygonPoolList(&polygons) , mPointFlags(pointFlags.data()) , mPoints(points.get()) , mNumQuadsToDivide(numQuadsToDivide.get())"
  },
  {
    "label": "polygons()",
    "kind": "Method",
    "detail": "Function (PolygonPool&)",
    "insertText": "polygons(*mPolygonPoolList)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (unsigned count = 0 ;)",
    "insertText": "for(size_t i = 0, I = polygons.numQuads(); i < I; ++i)"
  },
  {
    "label": "quadFlags()",
    "kind": "Method",
    "detail": "Function (char& flags = polygons .)",
    "insertText": "quadFlags(i)"
  },
  {
    "label": "quad()",
    "kind": "Method",
    "detail": "Function (Vec4I& quad = polygons .)",
    "insertText": "quad(i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const bool edgePoly = mPointFlags [ quad [ 0 ] ] | | mPointFlags [ quad [ 1 ] ] | | mPointFlags [ quad [ 2 ] ] | | mPointFlags [ quad [ 3 ] ] ;)",
    "insertText": "if(!edgePoly)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const Vec3s& p0 = mPoints [ quad [ 0 ] ] ; const Vec3s& p1 = mPoints [ quad [ 1 ] ] ; const Vec3s& p2 = mPoints [ quad [ 2 ] ] ; const Vec3s& p3 = mPoints [ quad [ 3 ] ] ;)",
    "insertText": "if(!isPlanarQuad(p0, p1, p2, p3, 1e-6f))"
  },
  {
    "label": "SubdivideQuads()",
    "kind": "Method",
    "detail": "Function (flags | = POLYFLAG_SUBDIVIDED ; count + + ; } } } mNumQuadsToDivide [ n ] = count ; } } private : PolygonPoolList* const mPolygonPoolList ; uint8_t const* const mPointFlags ; Vec3s const* const mPoints ; unsigned* const mNumQuadsToDivide ; } ; struct SubdivideQuads {)",
    "insertText": "SubdivideQuads(PolygonPoolList& polygons, const std::unique_ptr<openvdb::Vec3s[]>& points, size_t pointCount, std::unique_ptr<openvdb::Vec3s[]>& centroids, std::unique_ptr<unsigned[]>& numQuadsToDivide, std::unique_ptr<unsigned[]>& centroidOffsets) : mPolygonPoolList(&polygons) , mPoints(points.get()) , mCentroids(centroids.get()) , mNumQuadsToDivide(numQuadsToDivide.get()) , mCentroidOffsets(centroidOffsets.get()) , mPointCount(pointCount)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (const size_t nonplanarCount =)",
    "insertText": "size_t(mNumQuadsToDivide[n])"
  },
  {
    "label": "resetQuads()",
    "kind": "Method",
    "detail": "Function (PolygonPool tmpPolygons ; tmpPolygons .)",
    "insertText": "resetQuads(polygons.numQuads() - nonplanarCount)"
  },
  {
    "label": "resetTriangles()",
    "kind": "Method",
    "detail": "Function (tmpPolygons .)",
    "insertText": "resetTriangles(polygons.numTriangles() + size_t(4) * nonplanarCount)"
  },
  {
    "label": "unsigned()",
    "kind": "Method",
    "detail": "Function (unsigned newPointIdx =)",
    "insertText": "unsigned(offset + mPointCount)"
  },
  {
    "label": "offset()",
    "kind": "Method",
    "detail": "Function (mCentroids [)",
    "insertText": "offset(mPoints[quad[0]] + mPoints[quad[1]] + mPoints[quad[2]] + mPoints[quad[3]])"
  },
  {
    "label": "triangle()",
    "kind": "Method",
    "detail": "Function (+ + offset ; { Vec3I& triangle = tmpPolygons .)",
    "insertText": "triangle(triangleIdx)"
  },
  {
    "label": "triangleFlags()",
    "kind": "Method",
    "detail": "Function (triangle [ 0 ] = quad [ 0 ] ; triangle [ 1 ] = newPointIdx ; triangle [ 2 ] = quad [ 3 ] ; tmpPolygons .)",
    "insertText": "triangleFlags(triangleIdx)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} + + triangleIdx ; quad [ 0 ] = util::INVALID_IDX ; })",
    "insertText": "for(size_t i = 0, I = polygons.numTriangles(); i < I; ++i)"
  },
  {
    "label": "triangle()",
    "kind": "Method",
    "detail": "Function (tmpPolygons .)",
    "insertText": "triangle(triangleIdx) = polygons.triangle(i)"
  },
  {
    "label": "triangleFlags()",
    "kind": "Method",
    "detail": "Function (tmpPolygons .)",
    "insertText": "triangleFlags(triangleIdx) = polygons.triangleFlags(i)"
  },
  {
    "label": "quad()",
    "kind": "Method",
    "detail": "Function (tmpPolygons .)",
    "insertText": "quad(quadIdx)"
  },
  {
    "label": "quadFlags()",
    "kind": "Method",
    "detail": "Function (tmpPolygons .)",
    "insertText": "quadFlags(quadIdx) = polygons.quadFlags(i)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (+ + quadIdx ; } } polygons .)",
    "insertText": "copy(tmpPolygons)"
  },
  {
    "label": "subdivideNonplanarSeamLineQuads()",
    "kind": "Method",
    "detail": "Function (} } } private : PolygonPoolList* const mPolygonPoolList ; Vec3s const* const mPoints ; Vec3s* const mCentroids ; unsigned* const mNumQuadsToDivide ; unsigned* const mCentroidOffsets ; size_t const mPointCount ; } ; void)",
    "insertText": "subdivideNonplanarSeamLineQuads(PolygonPoolList& polygonPoolList, size_t polygonPoolListSize, PointList& pointList, size_t& pointListSize, std::vector<uint8_t>& pointFlags)"
  },
  {
    "label": "polygonPoolListRange()",
    "kind": "Method",
    "detail": "Function (const tbb::blocked_range<size_t>)",
    "insertText": "polygonPoolListRange(0, polygonPoolListSize)"
  },
  {
    "label": "numQuadsToDivide()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<unsigned [ ]>)",
    "insertText": "numQuadsToDivide(new unsigned[polygonPoolListSize])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(polygonPoolListRange, FlagAndCountQuadsToSubdivide(polygonPoolList, pointFlags, pointList, numQuadsToDivide))"
  },
  {
    "label": "centroidOffsets()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<unsigned [ ]>)",
    "insertText": "centroidOffsets(new unsigned[polygonPoolListSize])"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t centroidCount = 0 ; { unsigned sum = 0 ;)",
    "insertText": "for(size_t n = 0, N = polygonPoolListSize; n < N; ++n)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (centroidOffsets [ n ] = sum ; sum + = numQuadsToDivide [ n ] ; } centroidCount =)",
    "insertText": "size_t(sum)"
  },
  {
    "label": "centroidList()",
    "kind": "Method",
    "detail": "Function (} std::unique_ptr<Vec3s [ ]>)",
    "insertText": "centroidList(new Vec3s[centroidCount])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(polygonPoolListRange, SubdivideQuads(polygonPoolList, pointList, pointListSize, centroidList, numQuadsToDivide, centroidOffsets))"
  },
  {
    "label": "newPointList()",
    "kind": "Method",
    "detail": "Function (const size_t newPointListSize = centroidCount + pointListSize ; std::unique_ptr<openvdb::Vec3s [ ]>)",
    "insertText": "newPointList(new openvdb::Vec3s[newPointListSize])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, pointListSize), CopyArray<Vec3s>(newPointList.get(), pointList.get()))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, newPointListSize - pointListSize), CopyArray<Vec3s>(newPointList.get(), centroidList.get(), pointListSize))"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (pointListSize = newPointListSize ; pointList .)",
    "insertText": "swap(newPointList)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (pointFlags .)",
    "insertText": "resize(pointListSize, 0)"
  },
  {
    "label": "ReviseSeamLineFlags()",
    "kind": "Method",
    "detail": "Function (} } struct ReviseSeamLineFlags {)",
    "insertText": "ReviseSeamLineFlags(PolygonPoolList& polygons, const std::vector<uint8_t>& pointFlags) : mPolygonPoolList(&polygons) , mPointFlags(pointFlags.data())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const bool hasSeamLinePoint = mPointFlags [ verts [ 0 ] ] | | mPointFlags [ verts [ 1 ] ] | | mPointFlags [ verts [ 2 ] ] | | mPointFlags [ verts [ 3 ] ] ;)",
    "insertText": "if(!hasSeamLinePoint)"
  },
  {
    "label": "triangleFlags()",
    "kind": "Method",
    "detail": "Function (char& flags = polygons .)",
    "insertText": "triangleFlags(i)"
  },
  {
    "label": "triangle()",
    "kind": "Method",
    "detail": "Function (openvdb::Vec3I& verts = polygons .)",
    "insertText": "triangle(i)"
  },
  {
    "label": "reviseSeamLineFlags()",
    "kind": "Method",
    "detail": "Function (flags& = ~ POLYFLAG_FRACTURE_SEAM ; } } } } } private : PolygonPoolList* const mPolygonPoolList ; uint8_t const* const mPointFlags ; } ; void)",
    "insertText": "reviseSeamLineFlags(PolygonPoolList& polygonPoolList, size_t polygonPoolListSize, std::vector<uint8_t>& pointFlags)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, polygonPoolListSize), ReviseSeamLineFlags(polygonPoolList, pointFlags))"
  },
  {
    "label": "MaskDisorientedTrianglePoints()",
    "kind": "Method",
    "detail": "Function (} template<InputTreeType> struct MaskDisorientedTrianglePoints {)",
    "insertText": "MaskDisorientedTrianglePoints(const InputTreeType& inputTree, const PolygonPoolList& polygons, const PointList& pointList, std::unique_ptr<uint8_t[]>& pointMask, const math::Transform& transform, bool invertSurfaceOrientation) : mInputTree(&inputTree) , mPolygonPoolList(&polygons) , mPointList(&pointList) , mPointMask(pointMask.get()) , mTransform(transform) , mInvertSurfaceOrientation(invertSurfaceOrientation)"
  },
  {
    "label": "ValueType()",
    "kind": "Method",
    "detail": "Function (Vec3s centroid,normal ; Coord ijk ; const bool invertGradientDir = mInvertSurfaceOrientation | | isBoolValue<)",
    "insertText": "ValueType()"
  },
  {
    "label": "v0()",
    "kind": "Method",
    "detail": "Function (const Vec3s&)",
    "insertText": "v0(*mPointList)"
  },
  {
    "label": "v1()",
    "kind": "Method",
    "detail": "Function (const Vec3s&)",
    "insertText": "v1(*mPointList)"
  },
  {
    "label": "v2()",
    "kind": "Method",
    "detail": "Function (const Vec3s&)",
    "insertText": "v2(*mPointList)"
  },
  {
    "label": "normal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "normal(v2 - v0).cross((v1 - v0))"
  },
  {
    "label": "centroid()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "centroid(v0 + v1 + v2) * (1.0f / 3.0f)"
  },
  {
    "label": "worldToIndexCellCentered()",
    "kind": "Method",
    "detail": "Function (ijk = mTransform .)",
    "insertText": "worldToIndexCellCentered(centroid)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (dir = - dir ; })",
    "insertText": "if(dir.dot(normal) < -0.5f)"
  },
  {
    "label": "relaxDisorientedTriangles()",
    "kind": "Method",
    "detail": "Function (mPointMask [ verts [ 0 ] ] = 1 ; mPointMask [ verts [ 1 ] ] = 1 ; mPointMask [ verts [ 2 ] ] = 1 ; } } } } private : InputTreeType const* const mInputTree ; PolygonPoolList const* const mPolygonPoolList ; PointList const* const mPointList ; uint8_t* const mPointMask ; math::Transform const mTransform ; bool const mInvertSurfaceOrientation ; } ; template<InputTree> void)",
    "insertText": "relaxDisorientedTriangles(bool invertSurfaceOrientation, const InputTree& inputTree, const math::Transform& transform, PolygonPoolList& polygonPoolList, size_t polygonPoolListSize, PointList& pointList, const size_t pointListSize)"
  },
  {
    "label": "pointMask()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<uint8_t [ ]>)",
    "insertText": "pointMask(new uint8_t[pointListSize])"
  },
  {
    "label": "fillArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fillArray(pointMask.get(), uint8_t(0), pointListSize)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(polygonPoolListRange, MaskDisorientedTrianglePoints<InputTree>( inputTree, polygonPoolList, pointList, pointMask, transform, invertSurfaceOrientation))"
  },
  {
    "label": "pointUpdates()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<uint8_t [ ]>)",
    "insertText": "pointUpdates(new uint8_t[pointListSize])"
  },
  {
    "label": "fillArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fillArray(pointUpdates.get(), uint8_t(0), pointListSize)"
  },
  {
    "label": "newPoints()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<Vec3s [ ]>)",
    "insertText": "newPoints(new Vec3s[pointListSize])"
  },
  {
    "label": "fillArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fillArray(newPoints.get(), Vec3s(0.0f, 0.0f, 0.0f), pointListSize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (const unsigned pointIdx = verts [ v ] ;)",
    "insertText": "if(pointMask[pointIdx] == 1)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (newPoints [ pointIdx ] + = pointList [ verts [ 0 ] ] + pointList [ verts [ 1 ] ] + pointList [ verts [ 2 ] ] + pointList [ verts [ 3 ] ] ; pointUpdates [ pointIdx ] =)",
    "insertText": "uint8_t(pointUpdates[pointIdx] + 4)"
  },
  {
    "label": "uint8_t()",
    "kind": "Method",
    "detail": "Function (newPoints [ pointIdx ] + = pointList [ verts [ 0 ] ] + pointList [ verts [ 1 ] ] + pointList [ verts [ 2 ] ] ; pointUpdates [ pointIdx ] =)",
    "insertText": "uint8_t(pointUpdates[pointIdx] + 3)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } } })",
    "insertText": "for(size_t n = 0, N = pointListSize; n < N; ++n)"
  },
  {
    "label": "double()",
    "kind": "Method",
    "detail": "Function (const double weight = 1 . 0 /)",
    "insertText": "double(pointUpdates[n])"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (pointList [ n ] = newPoints [ n ]*)",
    "insertText": "float(weight)"
  },
  {
    "label": "PolygonPool()",
    "kind": "Method",
    "detail": "Function (} } } })",
    "insertText": "PolygonPool() : mNumQuads(0) , mNumTriangles(0) , mQuads(nullptr) , mTriangles(nullptr) , mQuadFlags(nullptr) , mTriangleFlags(nullptr)"
  },
  {
    "label": "PolygonPool()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "PolygonPool(const size_t numQuads, const size_t numTriangles) : mNumQuads(numQuads) , mNumTriangles(numTriangles) , mQuads(new openvdb::Vec4I[mNumQuads]) , mTriangles(new openvdb::Vec3I[mNumTriangles]) , mQuadFlags(new char[mNumQuads]) , mTriangleFlags(new char[mNumTriangles])"
  },
  {
    "label": "resetQuads()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resetQuads(rhs.numQuads())"
  },
  {
    "label": "resetTriangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "resetTriangles(rhs.numTriangles())"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (mQuads [ i ] = rhs . mQuads [ i ] ; mQuadFlags [ i ] = rhs . mQuadFlags [ i ] ; })",
    "insertText": "for(size_t i = 0; i < mNumTriangles; ++i)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mNumQuads = size ; mQuads .)",
    "insertText": "reset(new openvdb::Vec4I[mNumQuads])"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mQuadFlags .)",
    "insertText": "reset(new char[mNumQuads])"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mNumQuads = 0 ; mQuads .)",
    "insertText": "reset(nullptr)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mNumTriangles = size ; mTriangles .)",
    "insertText": "reset(new openvdb::Vec3I[mNumTriangles])"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mTriangleFlags .)",
    "insertText": "reset(new char[mNumTriangles])"
  },
  {
    "label": "trimQuads()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "trimQuads(const size_t n, bool reallocate)"
  },
  {
    "label": "quads()",
    "kind": "Method",
    "detail": "Function (} else { std::unique_ptr<openvdb::Vec4I [ ]>)",
    "insertText": "quads(new openvdb::Vec4I[n])"
  },
  {
    "label": "flags()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<char [ ]>)",
    "insertText": "flags(new char[n])"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (quads [ i ] = mQuads [ i ] ; flags [ i ] = mQuadFlags [ i ] ; } mQuads .)",
    "insertText": "swap(quads)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (mQuadFlags .)",
    "insertText": "swap(flags)"
  },
  {
    "label": "trimTrinagles()",
    "kind": "Method",
    "detail": "Function (} } mNumQuads = n ; return true ; } bool)",
    "insertText": "trimTrinagles(const size_t n, bool reallocate)"
  },
  {
    "label": "triangles()",
    "kind": "Method",
    "detail": "Function (} else { std::unique_ptr<openvdb::Vec3I [ ]>)",
    "insertText": "triangles(new openvdb::Vec3I[n])"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (triangles [ i ] = mTriangles [ i ] ; flags [ i ] = mTriangleFlags [ i ] ; } mTriangles .)",
    "insertText": "swap(triangles)"
  },
  {
    "label": "VolumeToMesh()",
    "kind": "Method",
    "detail": "Function (} } mNumTriangles = n ; return true ; })",
    "insertText": "VolumeToMesh(double isovalue, double adaptivity, bool relaxDisorientedTriangles) : mPoints(nullptr) , mPolygons() , mPointListSize(0) , mSeamPointListSize(0) , mPolygonPoolListSize(0) , mIsovalue(isovalue) , mPrimAdaptivity(adaptivity) , mSecAdaptivity(0.0) , mRefGrid(GridBase::ConstPtr()) , mSurfaceMaskGrid(GridBase::ConstPtr()) , mAdaptivityGrid(GridBase::ConstPtr()) , mAdaptivityMaskTree(TreeBase::ConstPtr()) , mRefSignTree(TreeBase::Ptr()) , mRefIdxTree(TreeBase::Ptr()) , mInvertSurfaceMask(false) , mRelaxDisorientedTriangles(relaxDisorientedTriangles) , mQuantizedSeamPoints(nullptr) , mPointFlags(0)"
  },
  {
    "label": "setRefGrid()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setRefGrid(const GridBase::ConstPtr& grid, double secAdaptivity)"
  },
  {
    "label": "Ptr()",
    "kind": "Method",
    "detail": "Function (mRefGrid = grid ; mSecAdaptivity = secAdaptivity ; mRefSignTree =)",
    "insertText": "Ptr()"
  },
  {
    "label": "setSurfaceMask()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setSurfaceMask(const GridBase::ConstPtr& mask, bool invertMask)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (mAdaptivityMaskTree = tree ; } template<InputGridType> void)",
    "insertText": "operator()(const InputGridType& inputGrid)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (using InputTreeType = InputGridType::TreeType ; using InputLeafNodeType = InputTreeType::LeafNodeType ; using InputValueType = InputLeafNodeType::ValueType ; using FloatTreeType = InputTreeType::template ValueConverter<float>::Type ; using FloatGridType = Grid<FloatTreeType> ; using BoolTreeType = InputTreeType::template ValueConverter<bool>::Type ; using Int16TreeType = InputTreeType::template ValueConverter<Int16>::Type ; using Int16LeafNodeType = Int16TreeType::LeafNodeType ; using Index32TreeType = InputTreeType::template ValueConverter<Index32>::Type ; using Index32LeafNodeType = Index32TreeType::LeafNodeType ; mPointListSize = 0 ; mPoints .)",
    "insertText": "reset()"
  },
  {
    "label": "InputValueType()",
    "kind": "Method",
    "detail": "Function (const InputValueType isovalue =)",
    "insertText": "InputValueType(mIsovalue)"
  },
  {
    "label": "float()",
    "kind": "Method",
    "detail": "Function (const float adaptivityThreshold =)",
    "insertText": "float(mPrimAdaptivity)"
  },
  {
    "label": "invertSurfaceOrientation()",
    "kind": "Method",
    "detail": "Function (const bool adaptive = mPrimAdaptivity> 1 e - 7 | | mSecAdaptivity> 1 e - 7 ; const bool)",
    "insertText": "invertSurfaceOrientation(!volume_to_mesh_internal::isBoolValue<InputValueType>() && (inputGrid.getGridClass() != openvdb::GRID_LEVEL_SET))"
  },
  {
    "label": "intersectionTree()",
    "kind": "Method",
    "detail": "Function (BoolTreeType)",
    "insertText": "intersectionTree(false), adaptivityMask(false)"
  },
  {
    "label": "BoolTreeType()",
    "kind": "Method",
    "detail": "Function (const BoolTreeType* refAdaptivityMask = static_cast<const)",
    "insertText": "BoolTreeType(mAdaptivityMaskTree.get())"
  },
  {
    "label": "topologyUnion()",
    "kind": "Method",
    "detail": "Function (adaptivityMask .)",
    "insertText": "topologyUnion(*refAdaptivityMask)"
  },
  {
    "label": "signFlagsTree()",
    "kind": "Method",
    "detail": "Function (} Int16TreeType)",
    "insertText": "signFlagsTree(0)"
  },
  {
    "label": "pointIndexTree()",
    "kind": "Method",
    "detail": "Function (Index32TreeType)",
    "insertText": "pointIndexTree(std::numeric_limits<Index32>::max())"
  },
  {
    "label": "identifySurfaceIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "identifySurfaceIntersectingVoxels(intersectionTree, inputTree, isovalue)"
  },
  {
    "label": "applySurfaceMask()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "applySurfaceMask(intersectionTree, adaptivityMask, inputGrid, mSurfaceMaskGrid, mInvertSurfaceMask, isovalue)"
  },
  {
    "label": "computeAuxiliaryData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeAuxiliaryData(signFlagsTree, pointIndexTree, intersectionTree, inputTree, isovalue)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (std::vector<Index32LeafNodeType*> pointIndexLeafNodes ; pointIndexTree .)",
    "insertText": "getNodes(pointIndexLeafNodes)"
  },
  {
    "label": "auxiliaryLeafNodeRange()",
    "kind": "Method",
    "detail": "Function (const tbb::blocked_range<size_t>)",
    "insertText": "auxiliaryLeafNodeRange(0, signFlagsLeafNodes.size())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Int16TreeType* refSignFlagsTree = nullptr ; Index32TreeType* refPointIndexTree = nullptr ; InputTreeType const* refInputTree = nullptr ;)",
    "insertText": "if(mRefGrid && mRefGrid->type() == InputGridType::gridType())"
  },
  {
    "label": "InputGridType()",
    "kind": "Method",
    "detail": "Function (const InputGridType* refGrid = static_cast<const)",
    "insertText": "InputGridType(mRefGrid.get())"
  },
  {
    "label": "refSignFlagsTreePt()",
    "kind": "Method",
    "detail": "Function (Int16TreeType::Ptr)",
    "insertText": "refSignFlagsTreePt(new Int16TreeType(0))"
  },
  {
    "label": "refPointIndexTreePt()",
    "kind": "Method",
    "detail": "Function (Index32TreeType::Ptr)",
    "insertText": "refPointIndexTreePt(new Index32TreeType(std::numeric_limits<Index32>::max()))"
  },
  {
    "label": "refIntersectionTree()",
    "kind": "Method",
    "detail": "Function (BoolTreeType)",
    "insertText": "refIntersectionTree(false)"
  },
  {
    "label": "identifySurfaceIntersectingVoxels()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "identifySurfaceIntersectingVoxels(refIntersectionTree, *refInputTree, isovalue)"
  },
  {
    "label": "computeAuxiliaryData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeAuxiliaryData(*refSignFlagsTreePt, *refPointIndexTreePt, refIntersectionTree, *refInputTree, isovalue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mRefSignTree = refSignFlagsTreePt ; mRefIdxTree = refPointIndexTreePt ; })",
    "insertText": "if(mRefSignTree && mRefIdxTree)"
  },
  {
    "label": "Int16TreeType()",
    "kind": "Method",
    "detail": "Function (refSignFlagsTree = static_cast<)",
    "insertText": "Int16TreeType(mRefSignTree.get())"
  },
  {
    "label": "Index32TreeType()",
    "kind": "Method",
    "detail": "Function (refPointIndexTree = static_cast<)",
    "insertText": "Index32TreeType(mRefIdxTree.get())"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(refSignFlagsTree && refPointIndexTree)"
  },
  {
    "label": "markSeamLineData()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "markSeamLineData(signFlagsTree, *refSignFlagsTree)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (std::vector<Int16LeafNodeType*> refSignFlagsLeafNodes ; refSignFlagsTree ->)",
    "insertText": "getNodes(refSignFlagsLeafNodes)"
  },
  {
    "label": "leafNodeOffsets()",
    "kind": "Method",
    "detail": "Function (std::unique_ptr<Index32 [ ]>)",
    "insertText": "leafNodeOffsets(new Index32[refSignFlagsLeafNodes.size()])"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, refSignFlagsLeafNodes.size()), volume_to_mesh_internal::LeafNodePointCount<Int16LeafNodeType::LOG2DIM>( refSignFlagsLeafNodes, leafNodeOffsets))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({ Index32 count = 0 ;)",
    "insertText": "for(size_t n = 0, N = refSignFlagsLeafNodes.size(); n < N; ++n)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (const Index32 tmp = leafNodeOffsets [ n ] ; leafNodeOffsets [ n ] = count ; count + = tmp ; } mSeamPointListSize =)",
    "insertText": "size_t(count)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(mSeamPointListSize != 0)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mQuantizedSeamPoints .)",
    "insertText": "reset(new uint32_t[mSeamPointListSize])"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(mQuantizedSeamPoints.get(), 0, sizeof(uint32_t) * mSeamPointListSize)"
  },
  {
    "label": "getNodes()",
    "kind": "Method",
    "detail": "Function (std::vector<Index32LeafNodeType*> refPointIndexLeafNodes ; refPointIndexTree ->)",
    "insertText": "getNodes(refPointIndexLeafNodes)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, refPointIndexLeafNodes.size()), volume_to_mesh_internal::MapPoints<Index32LeafNodeType>( refPointIndexLeafNodes, refSignFlagsLeafNodes, leafNodeOffsets))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(auxiliaryLeafNodeRange, volume_to_mesh_internal::SeamLineWeights<InputTreeType>( signFlagsLeafNodes, inputTree, *refPointIndexTree, *refSignFlagsTree, mQuantizedSeamPoints.get(), isovalue))"
  },
  {
    "label": "leafNodeOffsets()",
    "kind": "Method",
    "detail": "Function (} } } const bool referenceMeshing = refSignFlagsTree&& refPointIndexTree&& refInputTree ; std::unique_ptr<Index32 [ ]>)",
    "insertText": "leafNodeOffsets(new Index32[signFlagsLeafNodes.size()])"
  },
  {
    "label": "mergeOp()",
    "kind": "Method",
    "detail": "Function (volume_to_mesh_internal::MergeVoxelRegions<InputGridType>)",
    "insertText": "mergeOp(inputGrid, pointIndexTree, pointIndexLeafNodes, signFlagsLeafNodes, isovalue, adaptivityThreshold, invertSurfaceOrientation)"
  },
  {
    "label": "FloatGridType()",
    "kind": "Method",
    "detail": "Function (const FloatGridType* adaptivityGrid = static_cast<const)",
    "insertText": "FloatGridType(mAdaptivityGrid.get())"
  },
  {
    "label": "setSpatialAdaptivity()",
    "kind": "Method",
    "detail": "Function (mergeOp .)",
    "insertText": "setSpatialAdaptivity(*adaptivityGrid)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(!adaptivityMask.empty())"
  },
  {
    "label": "setAdaptivityMask()",
    "kind": "Method",
    "detail": "Function (mergeOp .)",
    "insertText": "setAdaptivityMask(adaptivityMask)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(referenceMeshing)"
  },
  {
    "label": "setRefSignFlagsData()",
    "kind": "Method",
    "detail": "Function (mergeOp .)",
    "insertText": "setRefSignFlagsData(*refSignFlagsTree, float(mSecAdaptivity))"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "parallel_for(auxiliaryLeafNodeRange, mergeOp)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (volume_to_mesh_internal::AdaptiveLeafNodePointCount<Index32LeafNodeType>)",
    "insertText": "op(pointIndexLeafNodes, signFlagsLeafNodes, leafNodeOffsets)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(auxiliaryLeafNodeRange, op)"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (} else { volume_to_mesh_internal::LeafNodePointCount<Int16LeafNodeType::LOG2DIM>)",
    "insertText": "op(signFlagsLeafNodes, leafNodeOffsets)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} { Index32 pointCount = 0 ;)",
    "insertText": "for(size_t n = 0, N = signFlagsLeafNodes.size(); n < N; ++n)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (const Index32 tmp = leafNodeOffsets [ n ] ; leafNodeOffsets [ n ] = pointCount ; pointCount + = tmp ; } mPointListSize =)",
    "insertText": "size_t(pointCount)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mPoints .)",
    "insertText": "reset(new openvdb::Vec3s[mPointListSize])"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (} { volume_to_mesh_internal::ComputePoints<InputTreeType>)",
    "insertText": "op(mPoints.get(), inputTree, pointIndexLeafNodes, signFlagsLeafNodes, leafNodeOffsets, transform, mIsovalue)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (mPointFlags .)",
    "insertText": "resize(mPointListSize)"
  },
  {
    "label": "setRefData()",
    "kind": "Method",
    "detail": "Function (op .)",
    "insertText": "setRefData(*refInputTree, *refPointIndexTree, *refSignFlagsTree, mQuantizedSeamPoints.get(), mPointFlags.data())"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mPolygons .)",
    "insertText": "reset(new PolygonPool[mPolygonPoolListSize])"
  },
  {
    "label": "op()",
    "kind": "Method",
    "detail": "Function (using PrimBuilder = volume_to_mesh_internal::AdaptivePrimBuilder ; volume_to_mesh_internal::ComputePolygons<Int16TreeType,PrimBuilder>)",
    "insertText": "op(signFlagsLeafNodes, signFlagsTree, pointIndexTree, mPolygons, invertSurfaceOrientation)"
  },
  {
    "label": "setRefSignTree()",
    "kind": "Method",
    "detail": "Function (op .)",
    "insertText": "setRefSignTree(refSignFlagsTree)"
  },
  {
    "label": "relaxDisorientedTriangles()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "relaxDisorientedTriangles(invertSurfaceOrientation, inputTree, transform, mPolygons, mPolygonPoolListSize, mPoints, mPointListSize)"
  },
  {
    "label": "subdivideNonplanarSeamLineQuads()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "subdivideNonplanarSeamLineQuads(mPolygons, mPolygonPoolListSize, mPoints, mPointListSize, mPointFlags)"
  },
  {
    "label": "reviseSeamLineFlags()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "reviseSeamLineFlags(mPolygons, mPolygonPoolListSize, mPointFlags)"
  },
  {
    "label": "doVolumeToMesh()",
    "kind": "Method",
    "detail": "Function (} } template<GridType> std::enable_if<std::is_scalar<GridType::ValueType>::value,void>::type)",
    "insertText": "doVolumeToMesh(const GridType& grid, std::vector<Vec3s>& points, std::vector<Vec3I>& triangles, std::vector<Vec4I>& quads, double isovalue, double adaptivity, bool relaxDisorientedTriangles)"
  },
  {
    "label": "mesher()",
    "kind": "Method",
    "detail": "Function (VolumeToMesh)",
    "insertText": "mesher(isovalue, adaptivity, relaxDisorientedTriangles)"
  },
  {
    "label": "mesher()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "mesher(grid)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (points .)",
    "insertText": "resize(mesher.pointListSize())"
  },
  {
    "label": "ptnCpy()",
    "kind": "Method",
    "detail": "Function ({ volume_to_mesh_internal::PointListCopy)",
    "insertText": "ptnCpy(mesher.pointList(), points)"
  },
  {
    "label": "parallel_for()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "parallel_for(tbb::blocked_range<size_t>(0, points.size()), ptnCpy)"
  },
  {
    "label": "pointList()",
    "kind": "Method",
    "detail": "Function (mesher .)",
    "insertText": "pointList().reset(nullptr)"
  },
  {
    "label": "polygonPoolList()",
    "kind": "Method",
    "detail": "Function (} PolygonPoolList& polygonPoolList = mesher .)",
    "insertText": "polygonPoolList()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({ size_t numQuads = 0,numTriangles = 0 ;)",
    "insertText": "for(size_t n = 0, N = mesher.polygonPoolListSize(); n < N; ++n)"
  },
  {
    "label": "numTriangles()",
    "kind": "Method",
    "detail": "Function (openvdb::tools::PolygonPool& polygons = polygonPoolList [ n ] ; numTriangles + = polygons .)",
    "insertText": "numTriangles()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (triangles .)",
    "insertText": "resize(numTriangles)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (quads .)",
    "insertText": "resize(numQuads)"
  },
  {
    "label": "doVolumeToMesh()",
    "kind": "Method",
    "detail": "Function (} } } template<GridType> std::enable_if<! std::is_scalar<GridType::ValueType>::value,void>::type)",
    "insertText": "doVolumeToMesh(const GridType&, std::vector<Vec3s>&, std::vector<Vec3I>&, std::vector<Vec4I>&, double, double, bool)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(TypeError, \"volume to mesh conversion is supported only for scalar grids\")"
  },
  {
    "label": "volumeToMesh()",
    "kind": "Method",
    "detail": "Function (} template<GridType> void)",
    "insertText": "volumeToMesh(const GridType& grid, std::vector<Vec3s>& points, std::vector<Vec3I>& triangles, std::vector<Vec4I>& quads, double isovalue, double adaptivity, bool relaxDisorientedTriangles)"
  },
  {
    "label": "volumeToMesh()",
    "kind": "Method",
    "detail": "Function (} template<GridType> void)",
    "insertText": "volumeToMesh(const GridType& grid, std::vector<Vec3s>& points, std::vector<Vec4I>& quads, double isovalue)"
  },
  {
    "label": "doVolumeToMesh()",
    "kind": "Method",
    "detail": "Function (std::vector<Vec3I> triangles ;)",
    "insertText": "doVolumeToMesh(grid, points, triangles, quads, isovalue, 0.0, true)"
  }
]