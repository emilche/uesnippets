[
  {
    "label": "UVector",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "UVector"
  },
  {
    "label": "Transition",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Transition"
  },
  {
    "label": "U_I18N_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U_I18N_API"
  },
  {
    "label": "RuleBasedTimeZone()",
    "kind": "Method",
    "detail": "Function (# ifndef RBTZ_H # define RBTZ_H # include \" unicode / utypes . h \" # if ! UCONFIG_NO_FORMATTING # include \" unicode / basictz . h \" # include \" unicode / unistr . h \" U_NAMESPACE_BEGIN class UVector ; struct Transition ; class U_I18N_API RuleBasedTimeZone : public BasicTimeZone { public :)",
    "insertText": "RuleBasedTimeZone(const UnicodeString& id, InitialTimeZoneRule* initialRule)"
  },
  {
    "label": "RuleBasedTimeZone()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RuleBasedTimeZone(const RuleBasedTimeZone& source)"
  },
  {
    "label": "RuleBasedTimeZone()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "RuleBasedTimeZone()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (RuleBasedTimeZone&)",
    "insertText": "operator(const RuleBasedTimeZone& right)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "operator(const TimeZone& that)"
  },
  {
    "label": "addTransitionRule()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "addTransitionRule(TimeZoneRule* rule, UErrorCode& status)"
  },
  {
    "label": "complete()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "complete(UErrorCode& status)"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (TimeZone*)",
    "insertText": "clone(void)"
  },
  {
    "label": "getOffset()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, UErrorCode& status)"
  },
  {
    "label": "getOffset()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, int32_t monthLength, UErrorCode& status)"
  },
  {
    "label": "getOffset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getOffset(UDate date, UBool local, int32_t& rawOffset, int32_t& dstOffset, UErrorCode& ec)"
  },
  {
    "label": "setRawOffset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setRawOffset(int32_t offsetMillis)"
  },
  {
    "label": "getRawOffset()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getRawOffset(void)"
  },
  {
    "label": "useDaylightTime()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "useDaylightTime(void)"
  },
  {
    "label": "inDaylightTime()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "inDaylightTime(UDate date, UErrorCode& status)"
  },
  {
    "label": "hasSameRules()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "hasSameRules(const TimeZone& other)"
  },
  {
    "label": "getNextTransition()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "getNextTransition(UDate base, UBool inclusive, TimeZoneTransition& result)"
  },
  {
    "label": "getPreviousTransition()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition& result)"
  },
  {
    "label": "countTransitionRules()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "countTransitionRules(UErrorCode& status)"
  },
  {
    "label": "getTimeZoneRules()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getTimeZoneRules(const InitialTimeZoneRule*& initial, const TimeZoneRule* trsrules[], int32_t& trscount, UErrorCode& status)"
  },
  {
    "label": "getOffsetFromLocal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getOffsetFromLocal(UDate date, int32_t nonExistingTimeOpt, int32_t duplicatedTimeOpt, int32_t& rawOffset, int32_t& dstOffset, UErrorCode& status)"
  },
  {
    "label": "deleteRules()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "deleteRules(void)"
  },
  {
    "label": "deleteTransitions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "deleteTransitions(void)"
  },
  {
    "label": "copyRules()",
    "kind": "Method",
    "detail": "Function (UVector*)",
    "insertText": "copyRules(UVector* source)"
  },
  {
    "label": "findRuleInFinal()",
    "kind": "Method",
    "detail": "Function (TimeZoneRule*)",
    "insertText": "findRuleInFinal(UDate date, UBool local, int32_t NonExistingTimeOpt, int32_t DuplicatedTimeOpt)"
  },
  {
    "label": "findNext()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "findNext(UDate base, UBool inclusive, UDate& time, TimeZoneRule*& from, TimeZoneRule*& to)"
  },
  {
    "label": "findPrev()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "findPrev(UDate base, UBool inclusive, UDate& time, TimeZoneRule*& from, TimeZoneRule*& to)"
  },
  {
    "label": "getLocalDelta()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getLocalDelta(int32_t rawBefore, int32_t dstBefore, int32_t rawAfter, int32_t dstAfter, int32_t NonExistingTimeOpt, int32_t DuplicatedTimeOpt)"
  },
  {
    "label": "getTransitionTime()",
    "kind": "Method",
    "detail": "Function (UDate)",
    "insertText": "getTransitionTime(Transition* transition, UBool local, int32_t NonExistingTimeOpt, int32_t DuplicatedTimeOpt)"
  },
  {
    "label": "getOffsetInternal()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getOffsetInternal(UDate date, UBool local, int32_t NonExistingTimeOpt, int32_t DuplicatedTimeOpt, int32_t& rawOffset, int32_t& dstOffset, UErrorCode& ec)"
  },
  {
    "label": "completeConst()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "completeConst(UErrorCode &status)"
  },
  {
    "label": "getStaticClassID()",
    "kind": "Method",
    "detail": "Function (InitialTimeZoneRule* fInitialRule ; UVector* fHistoricRules ; UVector* fFinalRules ; UVector* fHistoricTransitions ; UBool fUpToDate ; public : UClassID U_EXPORT2)",
    "insertText": "getStaticClassID(void)"
  },
  {
    "label": "getDynamicClassID()",
    "kind": "Method",
    "detail": "Function (UClassID)",
    "insertText": "getDynamicClassID(void)"
  }
]