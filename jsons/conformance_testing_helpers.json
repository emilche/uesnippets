[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "Fun",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Fun"
  },
  {
    "label": "IsNullaryCallableImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsNullaryCallableImpl"
  },
  {
    "label": "ValueType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueType"
  },
  {
    "label": "IsNullaryCallable",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsNullaryCallable"
  },
  {
    "label": "GeneratorType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "GeneratorType"
  },
  {
    "label": "EquivalenceClassType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "EquivalenceClassType"
  },
  {
    "label": "IsEquivalenceClass",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IsEquivalenceClass"
  },
  {
    "label": "Head",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Head"
  },
  {
    "label": "OrderedEquivalenceClasses",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "OrderedEquivalenceClasses"
  },
  {
    "label": "ResultOfGenerator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ResultOfGenerator"
  },
  {
    "label": "AreGeneratorsWithTheSameReturnTypeImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AreGeneratorsWithTheSameReturnTypeImpl"
  },
  {
    "label": "AreGeneratorsWithTheSameReturnType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AreGeneratorsWithTheSameReturnType"
  },
  {
    "label": "AreEquivalenceClassesOfTheSameType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AreEquivalenceClassesOfTheSameType"
  },
  {
    "label": "HeadNextFun",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HeadNextFun"
  },
  {
    "label": "HeadHeadFun",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "HeadHeadFun"
  },
  {
    "label": "ForEachParameterFun",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ForEachParameterFun"
  },
  {
    "label": "Tup",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Tup"
  },
  {
    "label": "ForEveryTwoImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ForEveryTwoImpl"
  },
  {
    "label": "Lhs",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Lhs"
  },
  {
    "label": "WithBoundLhs",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "WithBoundLhs"
  },
  {
    "label": "Rhs",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Rhs"
  },
  {
    "label": "Container",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Container"
  },
  {
    "label": "H",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "H"
  },
  {
    "label": "If",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "If"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifndef ABSL_TYPES_INTERNAL_CONFORMANCE_TESTING_HELPERS_H_ # define ABSL_TYPES_INTERNAL_CONFORMANCE_TESTING_HELPERS_H_ #)",
    "insertText": "if(defined(__ANDROID__) || defined(ANDROID)) && !defined(OS_ANDROID) #define ABSL_INTERNAL_OS_ANDROID #endif #if defined(OS_ANDROID) && (defined(__i386__) || defined(__x86_64__)) #define ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE 0 #elif (__GNUC__ >= 4 || (__GNUC__ >= 3 && __GNUC_MINOR__ >= 4)) && \\ !defined(__mips__) #define ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE 1 #elif defined(__clang__) && !defined(_MSC_VER)"
  },
  {
    "label": "NameOfImpl()",
    "kind": "Method",
    "detail": "Function (ABSL_NAMESPACE_BEGIN namespace types_internal { template<class T> absl::string_view)",
    "insertText": "NameOfImpl()"
  },
  {
    "label": "__cxa_demangle()",
    "kind": "Method",
    "detail": "Function (# if ABSL_TYPES_INTERNAL_HAS_CXA_DEMANGLE int status = 0 ; char* demangled_name = nullptr ; demangled_name =)",
    "insertText": "__cxa_demangle(typeid(T).name(), nullptr, nullptr, &status)"
  },
  {
    "label": "typeid()",
    "kind": "Method",
    "detail": "Function (} # else return)",
    "insertText": "typeid(T).name()"
  },
  {
    "label": "NameOf()",
    "kind": "Method",
    "detail": "Function (# endif } template<class T> std::string)",
    "insertText": "NameOf()"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (const absl::string_view result = NameOfImpl<)",
    "insertText": "T()"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} template<class Fun,class = void> struct IsNullaryCallableImpl : std::false_type { } ; template<class Fun> struct IsNullaryCallableImpl<Fun,absl::void_t<)",
    "insertText": "decltype(std::declval<const Fun&>()())"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} ; template<class Fun> using ResultOfGeneratorT = ResultOfGenerator<GeneratorType<Fun>>::type ; template<class,class . . . Funs> struct AreGeneratorsWithTheSameReturnTypeImpl : std::false_type { } ; template<> struct AreGeneratorsWithTheSameReturnTypeImpl<void> : std::true_type { } ; template<class Head,class . . . Tail> struct AreGeneratorsWithTheSameReturnTypeImpl<std::enable_if<absl::conjunction<std::is_same<ResultOfGeneratorT<Head>,ResultOfGeneratorT<Tail>> . . .>::value>::type,Head,Tail . . .> : std::true_type { } ; template<class . . . Funs> struct AreGeneratorsWithTheSameReturnType : AreGeneratorsWithTheSameReturnTypeImpl<void,Funs . . .>::type { } ; template<class . . . EqClasses> struct AreEquivalenceClassesOfTheSameType {)",
    "insertText": "static_assert(sizeof...(EqClasses) != sizeof...(EqClasses), \"\")"
  },
  {
    "label": "ForEachParameter()",
    "kind": "Method",
    "detail": "Function (} ; template<> struct AreEquivalenceClassesOfTheSameType<> : std::true_type { using self = AreEquivalenceClassesOfTheSameType ; template<class> using for_type = std::true_type ; } ; template<class . . . Funs> struct AreEquivalenceClassesOfTheSameType<EquivalenceClassType<Funs . . .>> : std::true_type { using self = AreEquivalenceClassesOfTheSameType ; template<class ValueType> using for_type = IsEquivalenceClass<EquivalenceClassType<Funs . . .>>::template for_type<ValueType> ; } ; template<class . . . TailEqClasses> struct AreEquivalenceClassesOfTheSameType<EquivalenceClassType<>,EquivalenceClassType<>,TailEqClasses . . .> : AreEquivalenceClassesOfTheSameType<TailEqClasses . . .>::self { } ; template<class HeadNextFun,class . . . TailNextFuns,class . . . TailEqClasses> struct AreEquivalenceClassesOfTheSameType<EquivalenceClassType<>,EquivalenceClassType<HeadNextFun,TailNextFuns . . .>,TailEqClasses . . .> : AreEquivalenceClassesOfTheSameType<EquivalenceClassType<HeadNextFun,TailNextFuns . . .>,TailEqClasses . . .>::self { } ; template<class HeadHeadFun,class . . . TailHeadFuns,class . . . TailEqClasses> struct AreEquivalenceClassesOfTheSameType<EquivalenceClassType<HeadHeadFun,TailHeadFuns . . .>,EquivalenceClassType<>,TailEqClasses . . .> : AreEquivalenceClassesOfTheSameType<EquivalenceClassType<HeadHeadFun,TailHeadFuns . . .>,TailEqClasses . . .>::self { } ; template<class HeadHeadFun,class . . . TailHeadFuns,class HeadNextFun,class . . . TailNextFuns,class . . . TailEqClasses> struct AreEquivalenceClassesOfTheSameType<EquivalenceClassType<HeadHeadFun,TailHeadFuns . . .>,EquivalenceClassType<HeadNextFun,TailNextFuns . . .>,TailEqClasses . . .> : absl::conditional_t<IsNullaryCallable<HeadNextFun>::template for_type<IsNullaryCallable<HeadHeadFun>::result_type>::value,AreEquivalenceClassesOfTheSameType<EquivalenceClassType<HeadHeadFun,TailHeadFuns . . .>,TailEqClasses . . .>,std::false_type> { } ; template<class Fun,class . . . Cases> void)",
    "insertText": "ForEachParameter(const Fun& fun, const Cases&... cases)"
  },
  {
    "label": "results()",
    "kind": "Method",
    "detail": "Function (const std::initializer_list<bool>)",
    "insertText": "results(static_cast<void>(fun(cases)), true)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class Fun> struct ForEachParameterFun { template<class . . . T> void)",
    "insertText": "operator()(const T&... cases)"
  },
  {
    "label": "ForEachTupleElement()",
    "kind": "Method",
    "detail": "Function (} Fun fun ; } ; template<class Fun,class Tup> void)",
    "insertText": "ForEachTupleElement(const Fun& fun, const Tup& tup)"
  },
  {
    "label": "apply()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "apply(ForEachParameterFun<Fun>{fun}, tup)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class Fun,class . . . T> struct ForEveryTwoImpl { template<class Lhs> struct WithBoundLhs { template<class Rhs> void)",
    "insertText": "operator()(const Rhs& rhs)"
  },
  {
    "label": "fun()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fun(lhs, rhs)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Fun fun ; Lhs lhs ; } ; template<class Lhs> void)",
    "insertText": "operator()(const Lhs& lhs)"
  },
  {
    "label": "ForEveryTwo()",
    "kind": "Method",
    "detail": "Function (} Fun fun ; std::tuple<T . . .> args ; } ; template<class Fun,class . . . T> void)",
    "insertText": "ForEveryTwo(const Fun& fun, std::tuple<T...> args)"
  },
  {
    "label": "InsertEach()",
    "kind": "Method",
    "detail": "Function (} template<class Container> void)",
    "insertText": "InsertEach(Container* cont)"
  },
  {
    "label": "InsertEach()",
    "kind": "Method",
    "detail": "Function (} template<class Container,class H,class . . . T> void)",
    "insertText": "InsertEach(Container* cont, H&& head, T&&... tail)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (cont ->)",
    "insertText": "insert(head)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (} template<bool Condition> struct If ; template<> struct If<false> { template<class Fun,class . . . P> void)",
    "insertText": "Invoke(const Fun& , P&&...)"
  },
  {
    "label": "Invoke()",
    "kind": "Method",
    "detail": "Function (} } ; template<> struct If<true> { template<class Fun,class . . . P> void)",
    "insertText": "Invoke(const Fun& fun, P&&... args)"
  },
  {
    "label": "fun()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fun(absl::forward<P>(args)...)"
  }
]