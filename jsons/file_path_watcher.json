[
  {
    "label": "FilePath",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FilePath"
  },
  {
    "label": "BASE_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BASE_EXPORT"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "PlatformDelegate",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "PlatformDelegate"
  },
  {
    "label": "FilePathWatcher",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FilePathWatcher"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# ifndef BASE_FILES_FILE_PATH_WATCHER_H_ # define BASE_FILES_FILE_PATH_WATCHER_H_ # include<memory> # include<utility> # include \" base / base_export . h \" # include \" base / callback_forward . h \" # include \" base / memory / scoped_refptr . h \" # include \" base / sequence_checker . h \" # include \" base / task / sequenced_task_runner . h \" # include \" build / build_config . h \" namespace base { class FilePath ; class BASE_EXPORT FilePathWatcher { public : enum class Type { kNonRecursive,kRecursive,# if)",
    "insertText": "BUILDFLAG(IS_MAC)"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (using Callback = base::RepeatingCallback<)",
    "insertText": "void(const FilePath& path, bool error)"
  },
  {
    "label": "PlatformDelegate()",
    "kind": "Method",
    "detail": "Function (class PlatformDelegate { public : using Type = FilePathWatcher::Type ;)",
    "insertText": "PlatformDelegate()"
  },
  {
    "label": "PlatformDelegate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PlatformDelegate(const PlatformDelegate&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (PlatformDelegate&)",
    "insertText": "operator(const PlatformDelegate&)"
  },
  {
    "label": "Watch()",
    "kind": "Method",
    "detail": "Function ([ [ nodiscard ] ] bool)",
    "insertText": "Watch(const FilePath& path, Type type, const Callback& callback)"
  },
  {
    "label": "Cancel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Cancel()"
  },
  {
    "label": "task_runner()",
    "kind": "Method",
    "detail": "Function (protected : class FilePathWatcher ; scoped_refptr<SequencedTaskRunner>)",
    "insertText": "task_runner()"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (task_runner_ =)",
    "insertText": "move(runner)"
  },
  {
    "label": "set_cancelled()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "set_cancelled()"
  },
  {
    "label": "is_cancelled()",
    "kind": "Method",
    "detail": "Function (cancelled_ = true ; } bool)",
    "insertText": "is_cancelled()"
  },
  {
    "label": "FilePathWatcher()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FilePathWatcher(const FilePathWatcher&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FilePathWatcher&)",
    "insertText": "operator(const FilePathWatcher&)"
  },
  {
    "label": "FilePathWatcher()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "FilePathWatcher()"
  },
  {
    "label": "RecursiveWatchAvailable()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "RecursiveWatchAvailable()"
  },
  {
    "label": "BUILDFLAG()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) static bool HasWatchesForTest()"
  },
  {
    "label": "SEQUENCE_CHECKER()",
    "kind": "Method",
    "detail": "Function (private : std::unique_ptr<PlatformDelegate> impl_ ;)",
    "insertText": "SEQUENCE_CHECKER(sequence_checker_)"
  }
]