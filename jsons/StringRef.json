[
  {
    "label": "SmallVectorImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallVectorImpl"
  },
  {
    "label": "APInt",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "APInt"
  },
  {
    "label": "hash_code",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "hash_code"
  },
  {
    "label": "StringRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "StringRef"
  },
  {
    "label": "isPodLike",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "isPodLike"
  },
  {
    "label": "is_nothrow_constructible",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "is_nothrow_constructible"
  },
  {
    "label": "getAsUnsignedInteger()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_ADT_STRINGREF_H # define LLVM_ADT_STRINGREF_H # include<algorithm> # include<cassert> # include<cstring> # include<limits> # include<string> # include<utility> namespace llvm { template<T> class SmallVectorImpl ; class APInt ; class hash_code ; class StringRef ; bool)",
    "insertText": "getAsUnsignedInteger(StringRef Str, unsigned Radix, unsigned long long &Result)"
  },
  {
    "label": "getAsSignedInteger()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "getAsSignedInteger(StringRef Str, unsigned Radix, long long &Result)"
  },
  {
    "label": "size_t()",
    "kind": "Method",
    "detail": "Function (class StringRef { public : typedef const char* iterator ; typedef const char* const_iterator ; const size_t npos = ~)",
    "insertText": "size_t(0)"
  },
  {
    "label": "compareMemory()",
    "kind": "Method",
    "detail": "Function (typedef size_t size_type ; private : const char* Data ; size_t Length ; int)",
    "insertText": "compareMemory(const char *Lhs, const char *Rhs, size_t Length)"
  },
  {
    "label": "StringRef()",
    "kind": "Method",
    "detail": "Function (} public :)",
    "insertText": "StringRef() : Data(nullptr), Length(0)"
  },
  {
    "label": "StringRef()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "StringRef(std::nullptr_t)"
  },
  {
    "label": "StringRef()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "StringRef(const char *Str) : Data(Str)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Str && \"StringRef cannot be built from a NULL argument\")"
  },
  {
    "label": "strlen()",
    "kind": "Method",
    "detail": "Function (Length)",
    "insertText": "strlen(Str)"
  },
  {
    "label": "StringRef()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "StringRef(const char *data, size_t length) : Data(data), Length(length)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((data || length == 0) && \"StringRef cannot be built from a NULL argument with non-null length\")"
  },
  {
    "label": "StringRef()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "StringRef(const std::string &Str) : Data(Str.data()), Length(Str.length())"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "begin()"
  },
  {
    "label": "bytes_end()",
    "kind": "Method",
    "detail": "Function (} const unsigned char*)",
    "insertText": "bytes_end()"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "data()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!empty())"
  },
  {
    "label": "char()",
    "kind": "Method",
    "detail": "Function (char* S = A . template Allocate<)",
    "insertText": "char(Length)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "copy(begin(), end(), S)"
  },
  {
    "label": "equals()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "equals(StringRef RHS)"
  },
  {
    "label": "equals_lower()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "equals_lower(StringRef RHS)"
  },
  {
    "label": "compare()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "compare(StringRef RHS)"
  },
  {
    "label": "compare_numeric()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "compare_numeric(StringRef RHS)"
  },
  {
    "label": "edit_distance()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "edit_distance(StringRef Other, bool AllowReplacements = true, unsigned MaxEditDistance = 0)"
  },
  {
    "label": "str()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "str()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} char)",
    "insertText": "operator(size_t Index)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Index < Length && \"Invalid index!\")"
  },
  {
    "label": "startswith()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "startswith(StringRef Prefix)"
  },
  {
    "label": "startswith_lower()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "startswith_lower(StringRef Prefix)"
  },
  {
    "label": "endswith()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "endswith(StringRef Suffix)"
  },
  {
    "label": "endswith_lower()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "endswith_lower(StringRef Suffix)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "find(char C, size_t From = 0)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (size_t FindBegin =)",
    "insertText": "min(From, Length)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (} return npos ; } size_t)",
    "insertText": "find(StringRef Str, size_t From = 0)"
  },
  {
    "label": "rfind()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "rfind(char C, size_t From = npos)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (size_t i = From ;)",
    "insertText": "while(i != 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (- - i ;)",
    "insertText": "if(Data[i] == C)"
  },
  {
    "label": "rfind()",
    "kind": "Method",
    "detail": "Function (} return npos ; } size_t)",
    "insertText": "rfind(StringRef Str)"
  },
  {
    "label": "find_first_of()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "find_first_of(char C, size_t From = 0)"
  },
  {
    "label": "find_first_of()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "find_first_of(StringRef Chars, size_t From = 0)"
  },
  {
    "label": "find_first_not_of()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "find_first_not_of(char C, size_t From = 0)"
  },
  {
    "label": "find_first_not_of()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "find_first_not_of(StringRef Chars, size_t From = 0)"
  },
  {
    "label": "find_last_of()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "find_last_of(char C, size_t From = npos)"
  },
  {
    "label": "find_last_of()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "find_last_of(StringRef Chars, size_t From = npos)"
  },
  {
    "label": "find_last_not_of()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "find_last_not_of(char C, size_t From = npos)"
  },
  {
    "label": "find_last_not_of()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "find_last_not_of(StringRef Chars, size_t From = npos)"
  },
  {
    "label": "count()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "count(char C)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (size_t Count = 0 ;)",
    "insertText": "for(size_t i = 0, e = Length; i != e; ++i) if (Data[i] == C)"
  },
  {
    "label": "getAsInteger()",
    "kind": "Method",
    "detail": "Function (template<T> std::enable_if<std::numeric_limits<T>::is_signed,bool>::type)",
    "insertText": "getAsInteger(unsigned Radix, T &Result)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (long long LLVal ;)",
    "insertText": "if(getAsSignedInteger(*this, Radix, LLVal) || static_cast<T>(LLVal) != LLVal)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned long long ULLVal ;)",
    "insertText": "if(getAsUnsignedInteger(*this, Radix, ULLVal) || static_cast<unsigned long long>(static_cast<T>(ULLVal)) != ULLVal)"
  },
  {
    "label": "getAsInteger()",
    "kind": "Method",
    "detail": "Function (Result = ULLVal ; return false ; } bool)",
    "insertText": "getAsInteger(unsigned Radix, APInt &Result)"
  },
  {
    "label": "lower()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "lower()"
  },
  {
    "label": "upper()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "upper()"
  },
  {
    "label": "substr()",
    "kind": "Method",
    "detail": "Function (StringRef)",
    "insertText": "substr(size_t Start, size_t N = npos)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (Start =)",
    "insertText": "min(Start, Length)"
  },
  {
    "label": "drop_front()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "drop_front(size_t N = 1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(size() >= N && \"Dropping more elements than exist\")"
  },
  {
    "label": "drop_back()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "drop_back(size_t N = 1)"
  },
  {
    "label": "slice()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "slice(size_t Start, size_t End)"
  },
  {
    "label": "min()",
    "kind": "Method",
    "detail": "Function (End =)",
    "insertText": "min(std::max(Start, End), Length)"
  },
  {
    "label": "split()",
    "kind": "Method",
    "detail": "Function (} std::pair<StringRef,StringRef>)",
    "insertText": "split(char Separator)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (size_t Idx =)",
    "insertText": "find(Separator)"
  },
  {
    "label": "split()",
    "kind": "Method",
    "detail": "Function (} std::pair<StringRef,StringRef>)",
    "insertText": "split(StringRef Separator)"
  },
  {
    "label": "split()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "split(SmallVectorImpl<StringRef> &A, StringRef Separator, int MaxSplit = -1, bool KeepEmpty = true)"
  },
  {
    "label": "rsplit()",
    "kind": "Method",
    "detail": "Function (std::pair<StringRef,StringRef>)",
    "insertText": "rsplit(char Separator)"
  },
  {
    "label": "rfind()",
    "kind": "Method",
    "detail": "Function (size_t Idx =)",
    "insertText": "rfind(Separator)"
  },
  {
    "label": "ltrim()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "ltrim(StringRef Chars = \" \\t\\n\\v\\f\\r\")"
  },
  {
    "label": "rtrim()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "rtrim(StringRef Chars = \" \\t\\n\\v\\f\\r\")"
  },
  {
    "label": "trim()",
    "kind": "Method",
    "detail": "Function (} StringRef)",
    "insertText": "trim(StringRef Chars = \" \\t\\n\\v\\f\\r\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } ; bool)",
    "insertText": "operator(StringRef LHS, StringRef RHS)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} std::string&)",
    "insertText": "operator(std::string &buffer, StringRef string)"
  },
  {
    "label": "hash_value()",
    "kind": "Method",
    "detail": "Function (} hash_code)",
    "insertText": "hash_value(StringRef S)"
  }
]