[
  {
    "label": "FModelMesh",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FModelMesh"
  },
  {
    "label": "FFaceMesh",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FFaceMesh"
  },
  {
    "label": "FEdge",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FEdge"
  },
  {
    "label": "FTriangle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FTriangle"
  },
  {
    "label": "CADKERNEL_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CADKERNEL_API"
  },
  {
    "label": "FTriangle()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Core / HaveStates . h \" # include \" Core / Types . h \" # include \" UI / Visu . h \" # include \" Math / Point . h \" namespace UE::CADKernel { class FModelMesh ; class FFaceMesh ; namespace Analyzer { struct FEdge ; struct FTriangle { uint32 Vertices [ 3 ] ; FVector3f Normals [ 3 ] ; FEdge* Edges [ 3 ] ; const FFaceMesh* FaceMesh ;)",
    "insertText": "FTriangle(uint32* InVertices, FEdge** InEdges, FVector3f* InNormals, const FFaceMesh* InFaceMesh) : FaceMesh(InFaceMesh)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Vertices [ Index ] = InVertices [ Index ] ; })",
    "insertText": "for(int32 Index = 0; Index < 3; ++Index)"
  },
  {
    "label": "ComputeNormal()",
    "kind": "Method",
    "detail": "Function (Normals [ Index ] = InNormals [ Index ] ; } } FPoint)",
    "insertText": "ComputeNormal(const TArray<FPoint>& NodeCoordinates)"
  },
  {
    "label": "FEdge()",
    "kind": "Method",
    "detail": "Function (} ; struct FEdge : public FHaveStates { const int32 MaxTraingleStoredCount = 2 ; uint32 VertexIndices [ 2 ] ; FTriangle* Triangles [ MaxTraingleStoredCount ] ; uint32 TriangleCount = 0 ;)",
    "insertText": "FEdge(uint32 Index0, uint32 Index1)"
  },
  {
    "label": "AddTriangle()",
    "kind": "Method",
    "detail": "Function (VertexIndices [ 0 ] = Index0 ; VertexIndices [ 1 ] = Index1 ; } void)",
    "insertText": "AddTriangle(FTriangle& Triangle)"
  },
  {
    "label": "OtherVertexIndex()",
    "kind": "Method",
    "detail": "Function (Triangles [ TriangleCount ] =& Triangle ; } TriangleCount + + ; } uint32)",
    "insertText": "OtherVertexIndex(uint32 Index)"
  },
  {
    "label": "BuildMesh()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "BuildMesh()"
  },
  {
    "label": "ComputeBorderCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeBorderCount(int32& OutBorderCount, int32& OutNonManifoldCount)"
  },
  {
    "label": "ComputeMeshGapCount()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeMeshGapCount(int32& OutCycleCount, int32& OutChainCount)"
  },
  {
    "label": "CheckOrientation()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "CheckOrientation()"
  },
  {
    "label": "Display()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Display()"
  },
  {
    "label": "DisplayTriangle()",
    "kind": "Method",
    "detail": "Function (private : void)",
    "insertText": "DisplayTriangle(const Analyzer::FTriangle& Triangle)"
  },
  {
    "label": "DisplayEdge()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DisplayEdge(const Analyzer::FEdge& Edge, EVisuProperty Property)"
  }
]