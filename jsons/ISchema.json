[
  {
    "label": "INFO",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "INFO"
  },
  {
    "label": "ISchema",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ISchema"
  },
  {
    "label": "getSchemaTitle()",
    "kind": "Method",
    "detail": "Function (# ifndef Alembic_Abc_ISchema_h # define Alembic_Abc_ISchema_h # include<Alembic / Abc / Foundation . h> # include<Alembic / Abc / OSchema . h> # include<Alembic / Abc / ICompoundProperty . h> namespace Alembic { namespace Abc { namespace ALEMBIC_VERSION_NS { template<class INFO> class ISchema : public ICompoundProperty { public : typedef INFO info_type ; typedef ISchema<INFO> this_type ; const char*)",
    "insertText": "getSchemaTitle()"
  },
  {
    "label": "getDefaultSchemaName()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "getDefaultSchemaName()"
  },
  {
    "label": "matches()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "matches(const AbcA::MetaData &iMetaData, SchemaInterpMatching iMatching = kStrictMatching)"
  },
  {
    "label": "matches()",
    "kind": "Method",
    "detail": "Function (} return false ; } bool)",
    "insertText": "matches(const AbcA::PropertyHeader &iHeader, SchemaInterpMatching iMatching = kStrictMatching)"
  },
  {
    "label": "ISchema()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ISchema()"
  },
  {
    "label": "ISchema()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ISchema(const ICompoundProperty &iParent, const std::string &iName, const Argument &iArg0 = Argument(), const Argument &iArg1 = Argument())"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init(iParent, iName, iArg0, iArg1)"
  },
  {
    "label": "ISchema()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ISchema(const ICompoundProperty &iProperty, const Argument &iArg0 = Argument(), const Argument &iArg1 = Argument() ) : ICompoundProperty( iProperty.getPtr(), GetErrorHandlerPolicy( iProperty, iArg0, iArg1 ))"
  },
  {
    "label": "ALEMBIC_ABC_SAFE_CALL_BEGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ALEMBIC_ABC_SAFE_CALL_BEGIN(\"ISchema::ISchema( wrap )\")"
  },
  {
    "label": "getHeader()",
    "kind": "Method",
    "detail": "Function (const AbcA::PropertyHeader& pheader = this ->)",
    "insertText": "getHeader()"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(matches( pheader, GetSchemaInterpMatching( iArg0, iArg1 ) ), \"Incorrect match of schema: \" << pheader.getMetaData().get( \"schema\" ) << \" to expected: \" << INFO::title())"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "init(iProperty, getDefaultSchemaName(), iArg0, iArg1)"
  },
  {
    "label": "ALEMBIC_ABC_SAFE_CALL_END_RESET()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ALEMBIC_ABC_SAFE_CALL_END_RESET()"
  },
  {
    "label": "ISchema()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ISchema(const ICompoundProperty &iProperty, WrapExistingFlag iFlag, const Argument &iArg0 = Argument(), const Argument &iArg1 = Argument())"
  },
  {
    "label": "ISchema()",
    "kind": "Method",
    "detail": "Function (* this =)",
    "insertText": "ISchema(iProperty, iArg0, iArg1)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} private : void)",
    "insertText": "init(const ICompoundProperty & iParentObject, const std::string &iName, const Argument &iArg0, const Argument &iArg1)"
  },
  {
    "label": "init()",
    "kind": "Method",
    "detail": "Function (} ; template<class INFO> void ISchema<INFO)",
    "insertText": "init(const ICompoundProperty & iParent, const std::string &iName, const Argument &iArg0, const Argument &iArg1)"
  },
  {
    "label": "setInto()",
    "kind": "Method",
    "detail": "Function (Arguments args ; iArg0 .)",
    "insertText": "setInto(args)"
  },
  {
    "label": "getErrorHandler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "getErrorHandler().setPolicy( args.getErrorHandlerPolicy())"
  },
  {
    "label": "ALEMBIC_ABC_SAFE_CALL_BEGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ALEMBIC_ABC_SAFE_CALL_BEGIN(\"ISchema::ISchema::init()\")"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(iParent, \"NULL parent passed into ISchema ctor\")"
  },
  {
    "label": "getPtr()",
    "kind": "Method",
    "detail": "Function (AbcA::CompoundPropertyReaderPtr parent = iParent .)",
    "insertText": "getPtr()"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(parent, \"NULL CompoundPropertyReaderPtr\")"
  },
  {
    "label": "getPropertyHeader()",
    "kind": "Method",
    "detail": "Function (const AbcA::PropertyHeader* pheader = parent ->)",
    "insertText": "getPropertyHeader(iName)"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(pheader != NULL, \"Nonexistent compound property: \" << iName)"
  },
  {
    "label": "ABCA_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ABCA_ASSERT(matches( *pheader, args.getSchemaInterpMatching() ), \"Incorrect match of schema: \" << pheader->getMetaData().get( \"schema\" ) << \" to expected: \" << INFO::title())"
  },
  {
    "label": "getCompoundProperty()",
    "kind": "Method",
    "detail": "Function (m_property = parent ->)",
    "insertText": "getCompoundProperty(iName)"
  }
]