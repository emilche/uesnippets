[
  {
    "label": "CallInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CallInst"
  },
  {
    "label": "CCState",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CCState"
  },
  {
    "label": "FastISel",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FastISel"
  },
  {
    "label": "FunctionLoweringInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FunctionLoweringInfo"
  },
  {
    "label": "ImmutableCallSite",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ImmutableCallSite"
  },
  {
    "label": "IntrinsicInst",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IntrinsicInst"
  },
  {
    "label": "MachineBasicBlock",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineBasicBlock"
  },
  {
    "label": "MachineFunction",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineFunction"
  },
  {
    "label": "MachineInstr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineInstr"
  },
  {
    "label": "MachineJumpTableInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineJumpTableInfo"
  },
  {
    "label": "MachineLoop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MachineLoop"
  },
  {
    "label": "Mangler",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Mangler"
  },
  {
    "label": "MCContext",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCContext"
  },
  {
    "label": "MCExpr",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCExpr"
  },
  {
    "label": "MCSymbol",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "MCSymbol"
  },
  {
    "label": "SmallVectorImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "SmallVectorImpl"
  },
  {
    "label": "DataLayout",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DataLayout"
  },
  {
    "label": "TargetRegisterClass",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetRegisterClass"
  },
  {
    "label": "TargetLibraryInfo",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetLibraryInfo"
  },
  {
    "label": "TargetLoweringObjectFile",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetLoweringObjectFile"
  },
  {
    "label": "Value",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "Value"
  },
  {
    "label": "Preference",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Preference"
  },
  {
    "label": "TargetLoweringBase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetLoweringBase"
  },
  {
    "label": "LegalizeAction",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "LegalizeAction"
  },
  {
    "label": "LegalizeTypeAction",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "LegalizeTypeAction"
  },
  {
    "label": "BooleanContent",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "BooleanContent"
  },
  {
    "label": "SelectSupportKind",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "SelectSupportKind"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "ValueTypeActionImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueTypeActionImpl"
  },
  {
    "label": "IntrinsicInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "IntrinsicInfo"
  },
  {
    "label": "AddrMode",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AddrMode"
  },
  {
    "label": "TargetLowering",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TargetLowering"
  },
  {
    "label": "TargetLoweringOpt",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TargetLoweringOpt"
  },
  {
    "label": "DAGCombinerInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DAGCombinerInfo"
  },
  {
    "label": "ArgListEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ArgListEntry"
  },
  {
    "label": "CallLoweringInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "CallLoweringInfo"
  },
  {
    "label": "ConstraintType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ConstraintType"
  },
  {
    "label": "ConstraintWeight",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ConstraintWeight"
  },
  {
    "label": "AsmOperandInfo",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AsmOperandInfo"
  },
  {
    "label": "TargetLoweringBase()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_TARGET_TARGETLOWERING_H # define LLVM_TARGET_TARGETLOWERING_H # include \" llvm / ADT / DenseMap . h \" # include \" llvm / CodeGen / DAGCombine . h \" # include \" llvm / CodeGen / RuntimeLibcalls . h \" # include \" llvm / CodeGen / SelectionDAGNodes . h \" # include \" llvm / IR / Attributes . h \" # include \" llvm / IR / CallSite . h \" # include \" llvm / IR / CallingConv . h \" # include \" llvm / IR / IRBuilder . h \" # include \" llvm / IR / InlineAsm . h \" # include \" llvm / IR / Instructions . h \" # include \" llvm / MC / MCRegisterInfo . h \" # include \" llvm / Target / TargetCallingConv . h \" # include \" llvm / Target / TargetMachine . h \" # include<climits> # include<map> # include<vector> namespace llvm { class CallInst ; class CCState ; class FastISel ; class FunctionLoweringInfo ; class ImmutableCallSite ; class IntrinsicInst ; class MachineBasicBlock ; class MachineFunction ; class MachineInstr ; class MachineJumpTableInfo ; class MachineLoop ; class Mangler ; class MCContext ; class MCExpr ; class MCSymbol ; template<T> class SmallVectorImpl ; class DataLayout ; class TargetRegisterClass ; class TargetLibraryInfo ; class TargetLoweringObjectFile ; class Value ; namespace Sched { enum Preference { None,Source,RegPressure,Hybrid,ILP,VLIW } ; } class TargetLoweringBase {)",
    "insertText": "TargetLoweringBase(const TargetLoweringBase&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const TargetLoweringBase&)"
  },
  {
    "label": "getExtendForContent()",
    "kind": "Method",
    "detail": "Function (public : enum LegalizeAction { Legal,Promote,Expand,Custom } ; enum LegalizeTypeAction { TypeLegal,TypePromoteInteger,TypeExpandInteger,TypeSoftenFloat,TypeExpandFloat,TypeScalarizeVector,TypeSplitVector,TypeWidenVector,TypePromoteFloat } ; typedef std::pair<LegalizeTypeAction,EVT> LegalizeKind ; enum BooleanContent { UndefinedBooleanContent,ZeroOrOneBooleanContent,ZeroOrNegativeOneBooleanContent } ; enum SelectSupportKind { ScalarValSelect,ScalarCondVectorVal,VectorMaskSelect } ; enum class AtomicRMWExpansionKind { None,LLSC,CmpXChg,} ; ISD::NodeType)",
    "insertText": "getExtendForContent(BooleanContent Content)"
  },
  {
    "label": "TargetLoweringBase()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TargetLoweringBase(const TargetMachine &TM)"
  },
  {
    "label": "TargetLoweringBase()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "TargetLoweringBase()"
  },
  {
    "label": "initActions()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "initActions()"
  },
  {
    "label": "getTargetMachine()",
    "kind": "Method",
    "detail": "Function (public : const TargetMachine&)",
    "insertText": "getTargetMachine()"
  },
  {
    "label": "getScalarShiftAmountTy()",
    "kind": "Method",
    "detail": "Function (} MVT)",
    "insertText": "getScalarShiftAmountTy(const DataLayout &, EVT)"
  },
  {
    "label": "getShiftAmountTy()",
    "kind": "Method",
    "detail": "Function (EVT)",
    "insertText": "getShiftAmountTy(EVT LHSTy, const DataLayout &DL)"
  },
  {
    "label": "getVectorIdxTy()",
    "kind": "Method",
    "detail": "Function (MVT)",
    "insertText": "getVectorIdxTy(const DataLayout &DL)"
  },
  {
    "label": "isSelectExpensive()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isSelectExpensive()"
  },
  {
    "label": "getBypassSlowDivWidths()",
    "kind": "Method",
    "detail": "Function (} const DenseMap<unsigned int,unsigned int>&)",
    "insertText": "getBypassSlowDivWidths()"
  },
  {
    "label": "getCmpLibcallReturnType()",
    "kind": "Method",
    "detail": "Function (MVT::SimpleValueType)",
    "insertText": "getCmpLibcallReturnType()"
  },
  {
    "label": "getBooleanContents()",
    "kind": "Method",
    "detail": "Function (BooleanContent)",
    "insertText": "getBooleanContents(bool isVec, bool isFloat)"
  },
  {
    "label": "getSchedulingPreference()",
    "kind": "Method",
    "detail": "Function (} Sched::Preference)",
    "insertText": "getSchedulingPreference()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (const TargetRegisterClass* RC = RegClassForVT [ VT . SimpleTy ] ;)",
    "insertText": "assert(RC && \"This value type is not natively supported!\")"
  },
  {
    "label": "getRepRegClassCostFor()",
    "kind": "Method",
    "detail": "Function (const TargetRegisterClass* RC = RepRegClassForVT [ VT . SimpleTy ] ; return RC ; } uint8_t)",
    "insertText": "getRepRegClassCostFor(MVT VT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!VT.isSimple() || (unsigned)VT.getSimpleVT().SimpleTy < array_lengthof(RegClassForVT))"
  },
  {
    "label": "ValueTypeActionImpl()",
    "kind": "Method",
    "detail": "Function (} class ValueTypeActionImpl { uint8_t ValueTypeActions [ MVT::LAST_VALUETYPE ] ; public :)",
    "insertText": "ValueTypeActionImpl()"
  },
  {
    "label": "fill()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "fill(std::begin(ValueTypeActions), std::end(ValueTypeActions), 0)"
  },
  {
    "label": "getTypeAction()",
    "kind": "Method",
    "detail": "Function (} LegalizeTypeAction)",
    "insertText": "getTypeAction(MVT VT)"
  },
  {
    "label": "setTypeAction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setTypeAction(MVT VT, LegalizeTypeAction Action)"
  },
  {
    "label": "getValueTypeActions()",
    "kind": "Method",
    "detail": "Function (unsigned I = VT . SimpleTy ; ValueTypeActions [ I ] = Action ; } } ; const ValueTypeActionImpl&)",
    "insertText": "getValueTypeActions()"
  },
  {
    "label": "getTypeToTransformTo()",
    "kind": "Method",
    "detail": "Function (} EVT)",
    "insertText": "getTypeToTransformTo(LLVMContext &Context, EVT VT)"
  },
  {
    "label": "getTypeToExpandTo()",
    "kind": "Method",
    "detail": "Function (} EVT)",
    "insertText": "getTypeToExpandTo(LLVMContext &Context, EVT VT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(!VT.isVector())"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (break ; default :)",
    "insertText": "llvm_unreachable(\"Type is not legal nor is it to be expanded!\")"
  },
  {
    "label": "getVectorTypeBreakdown()",
    "kind": "Method",
    "detail": "Function (} } } unsigned)",
    "insertText": "getVectorTypeBreakdown(LLVMContext &Context, EVT VT, EVT &IntermediateVT, unsigned &NumIntermediates, MVT &RegisterVT)"
  },
  {
    "label": "IntrinsicInfo()",
    "kind": "Method",
    "detail": "Function (struct IntrinsicInfo { unsigned opc ; EVT memVT ; const Value* ptrVal ; int offset ; unsigned size ; unsigned align ; bool vol ; bool readMem ; bool writeMem ;)",
    "insertText": "IntrinsicInfo() : opc(0), ptrVal(nullptr), offset(0), size(0), align(1), vol(false), readMem(false), writeMem(false)"
  },
  {
    "label": "getTgtMemIntrinsic()",
    "kind": "Method",
    "detail": "Function (} } ; bool)",
    "insertText": "getTgtMemIntrinsic(IntrinsicInfo &, const CallInst &, unsigned)"
  },
  {
    "label": "isVectorClearMaskLegal()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isVectorClearMaskLegal(const SmallVectorImpl<int> & , EVT)"
  },
  {
    "label": "I()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "I(unsigned) VT.getSimpleVT()"
  },
  {
    "label": "isOperationLegalOrCustom()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isOperationLegalOrCustom(unsigned Op, EVT VT)"
  },
  {
    "label": "isOperationLegalOrPromote()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isOperationLegalOrPromote(unsigned Op, EVT VT)"
  },
  {
    "label": "isOperationExpand()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isOperationExpand(unsigned Op, EVT VT)"
  },
  {
    "label": "isOperationLegal()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isOperationLegal(unsigned Op, EVT VT)"
  },
  {
    "label": "getLoadExtAction()",
    "kind": "Method",
    "detail": "Function (} LegalizeAction)",
    "insertText": "getLoadExtAction(unsigned ExtType, EVT ValVT, EVT MemVT)"
  },
  {
    "label": "ValI()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "ValI(unsigned) ValVT.getSimpleVT()"
  },
  {
    "label": "MemI()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "MemI(unsigned) MemVT.getSimpleVT()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValI < MVT::LAST_VALUETYPE && MemI < MVT::LAST_VALUETYPE && \"Table isn't big enough!\")"
  },
  {
    "label": "isLoadExtLegal()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isLoadExtLegal(unsigned ExtType, EVT ValVT, EVT MemVT)"
  },
  {
    "label": "isLoadExtLegalOrCustom()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isLoadExtLegalOrCustom(unsigned ExtType, EVT ValVT, EVT MemVT)"
  },
  {
    "label": "getTruncStoreAction()",
    "kind": "Method",
    "detail": "Function (} LegalizeAction)",
    "insertText": "getTruncStoreAction(EVT ValVT, EVT MemVT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(ValI < MVT::LAST_VALUETYPE && MemI < MVT::LAST_VALUETYPE && \"Table isn't big enough!\")"
  },
  {
    "label": "isTruncStoreLegal()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isTruncStoreLegal(EVT ValVT, EVT MemVT)"
  },
  {
    "label": "getIndexedLoadAction()",
    "kind": "Method",
    "detail": "Function (} LegalizeAction)",
    "insertText": "getIndexedLoadAction(unsigned IdxMode, MVT VT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(IdxMode < ISD::LAST_INDEXED_MODE && VT.isValid() && \"Table isn't big enough!\")"
  },
  {
    "label": "Ty()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "Ty(unsigned)"
  },
  {
    "label": "isIndexedLoadLegal()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isIndexedLoadLegal(unsigned IdxMode, EVT VT)"
  },
  {
    "label": "getIndexedStoreAction()",
    "kind": "Method",
    "detail": "Function (} LegalizeAction)",
    "insertText": "getIndexedStoreAction(unsigned IdxMode, MVT VT)"
  },
  {
    "label": "isIndexedStoreLegal()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isIndexedStoreLegal(unsigned IdxMode, EVT VT)"
  },
  {
    "label": "getCondCodeAction()",
    "kind": "Method",
    "detail": "Function (} LegalizeAction)",
    "insertText": "getCondCodeAction(ISD::CondCode CC, MVT VT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((unsigned)CC < array_lengthof(CondCodeActions) && ((unsigned)VT.SimpleTy >> 4) < array_lengthof(CondCodeActions[0]) && \"Table isn't big enough!\")"
  },
  {
    "label": "Shift()",
    "kind": "Method",
    "detail": "Function (uint32_t)",
    "insertText": "Shift(VT.SimpleTy & 0xF)"
  },
  {
    "label": "Action()",
    "kind": "Method",
    "detail": "Function (uint32_t Value = CondCodeActions [ CC ] [ VT . SimpleTy>> 4 ] ; LegalizeAction)",
    "insertText": "Action(LegalizeAction) ((Value >> Shift) & 0x3)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Action != Promote && \"Can't promote condition code!\")"
  },
  {
    "label": "getTypeToPromoteTo()",
    "kind": "Method",
    "detail": "Function (} MVT)",
    "insertText": "getTypeToPromoteTo(unsigned Op, MVT VT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(getOperationAction(Op, VT) == Promote && \"This operation isn't promoted!\")"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (std::map<std::pair<unsigned,MVT::SimpleValueType>,MVT::SimpleValueType>::const_iterator PTTI = PromoteToType .)",
    "insertText": "find(std::make_pair(Op, VT.SimpleTy))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((VT.isInteger() || VT.isFloatingPoint()) && \"Cannot autopromote this type, add it with AddPromotedToType.\")"
  },
  {
    "label": "NVT()",
    "kind": "Method",
    "detail": "Function (MVT NVT = VT ; do {)",
    "insertText": "NVT(MVT::SimpleValueType)(NVT.SimpleTy+1)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(NVT.isInteger() == VT.isInteger() && NVT != MVT::isVoid && \"Didn't find type to promote to!\")"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(!isTypeLegal(NVT) || getOperationAction(Op, NVT) == Promote)"
  },
  {
    "label": "VectorType()",
    "kind": "Method",
    "detail": "Function (VectorType* VTy = cast<)",
    "insertText": "VectorType(Ty)"
  },
  {
    "label": "getElementType()",
    "kind": "Method",
    "detail": "Function (Type* Elm = VTy ->)",
    "insertText": "getElementType()"
  },
  {
    "label": "PointerTy()",
    "kind": "Method",
    "detail": "Function (EVT)",
    "insertText": "PointerTy(getPointerTy(DL, PT->getAddressSpace()))"
  },
  {
    "label": "getTypeForEVT()",
    "kind": "Method",
    "detail": "Function (Elm = PointerTy .)",
    "insertText": "getTypeForEVT(Ty->getContext())"
  },
  {
    "label": "getVectorVT()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "getVectorVT(Ty->getContext(), EVT::getEVT(Elm, false), VTy->getNumElements())"
  },
  {
    "label": "getEVT()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "getEVT(Ty, AllowUnknown)"
  },
  {
    "label": "getSimpleValueType()",
    "kind": "Method",
    "detail": "Function (} MVT)",
    "insertText": "getSimpleValueType(const DataLayout &DL, Type *Ty, bool AllowUnknown = false)"
  },
  {
    "label": "getByValTypeAlignment()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getByValTypeAlignment(Type *Ty, const DataLayout &DL)"
  },
  {
    "label": "getRegisterType()",
    "kind": "Method",
    "detail": "Function (MVT)",
    "insertText": "getRegisterType(MVT VT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((unsigned)VT.SimpleTy < array_lengthof(RegisterTypeForVT))"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((unsigned)VT.getSimpleVT().SimpleTy < array_lengthof(RegisterTypeForVT))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(VT.isVector())"
  },
  {
    "label": "NumIntermediates()",
    "kind": "Method",
    "detail": "Function (EVT VT1 ; MVT RegisterVT ; unsigned)",
    "insertText": "NumIntermediates(void)getVectorTypeBreakdown(Context, VT, VT1, NumIntermediates, RegisterVT)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "llvm_unreachable(\"Unsupported extended type!\")"
  },
  {
    "label": "getNumRegisters()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getNumRegisters(LLVMContext &Context, EVT VT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((unsigned)VT.getSimpleVT().SimpleTy < array_lengthof(NumRegistersForVT))"
  },
  {
    "label": "getVectorTypeBreakdown()",
    "kind": "Method",
    "detail": "Function (EVT VT1 ; MVT VT2 ; unsigned NumIntermediates ; return)",
    "insertText": "getVectorTypeBreakdown(Context, VT, VT1, NumIntermediates, VT2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(VT.isInteger())"
  },
  {
    "label": "getSizeInBits()",
    "kind": "Method",
    "detail": "Function (unsigned BitWidth = VT .)",
    "insertText": "getSizeInBits()"
  },
  {
    "label": "getRegisterType()",
    "kind": "Method",
    "detail": "Function (unsigned RegWidth =)",
    "insertText": "getRegisterType(Context, VT).getSizeInBits()"
  },
  {
    "label": "ShouldShrinkFPConstant()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "ShouldShrinkFPConstant(EVT)"
  },
  {
    "label": "hasTargetDAGCombine()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "hasTargetDAGCombine(ISD::NodeType NT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(unsigned(NT >> 3) < array_lengthof(TargetDAGCombineArray))"
  },
  {
    "label": "getMaxStoresPerMemset()",
    "kind": "Method",
    "detail": "Function (} unsigned)",
    "insertText": "getMaxStoresPerMemset(bool OptSize)"
  },
  {
    "label": "getTypeLegalizationCost()",
    "kind": "Method",
    "detail": "Function (std::pair<unsigned,MVT>)",
    "insertText": "getTypeLegalizationCost(const DataLayout &DL, Type *Ty)"
  },
  {
    "label": "hasLoadLinkedStoreConditional()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "hasLoadLinkedStoreConditional()"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Load linked unimplemented on this target\")"
  },
  {
    "label": "emitStoreConditional()",
    "kind": "Method",
    "detail": "Function (} Value*)",
    "insertText": "emitStoreConditional(IRBuilder<> &Builder, Value *Val, Value *Addr, AtomicOrdering Ord)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Store conditional unimplemented on this target\")"
  },
  {
    "label": "emitLeadingFence()",
    "kind": "Method",
    "detail": "Function (} Instruction*)",
    "insertText": "emitLeadingFence(IRBuilder<> &Builder, AtomicOrdering Ord, bool IsStore, bool IsLoad)"
  },
  {
    "label": "getTypeAction()",
    "kind": "Method",
    "detail": "Function (LegalizeTypeAction Action =)",
    "insertText": "getTypeAction(Context, VT)"
  },
  {
    "label": "setBooleanContents()",
    "kind": "Method",
    "detail": "Function (BooleanContents = Ty ; BooleanFloatContents = Ty ; } void)",
    "insertText": "setBooleanContents(BooleanContent IntTy, BooleanContent FloatTy)"
  },
  {
    "label": "setBooleanVectorContents()",
    "kind": "Method",
    "detail": "Function (BooleanContents = IntTy ; BooleanFloatContents = FloatTy ; } void)",
    "insertText": "setBooleanVectorContents(BooleanContent Ty)"
  },
  {
    "label": "setSchedulingPreference()",
    "kind": "Method",
    "detail": "Function (BooleanVectorContents = Ty ; } void)",
    "insertText": "setSchedulingPreference(Sched::Preference Pref)"
  },
  {
    "label": "setUseUnderscoreSetJmp()",
    "kind": "Method",
    "detail": "Function (SchedPreferenceInfo = Pref ; } void)",
    "insertText": "setUseUnderscoreSetJmp(bool Val)"
  },
  {
    "label": "setUseUnderscoreLongJmp()",
    "kind": "Method",
    "detail": "Function (UseUnderscoreSetJmp = Val ; } void)",
    "insertText": "setUseUnderscoreLongJmp(bool Val)"
  },
  {
    "label": "setMinimumJumpTableEntries()",
    "kind": "Method",
    "detail": "Function (UseUnderscoreLongJmp = Val ; } void)",
    "insertText": "setMinimumJumpTableEntries(int Val)"
  },
  {
    "label": "setStackPointerRegisterToSaveRestore()",
    "kind": "Method",
    "detail": "Function (MinimumJumpTableEntries = Val ; } void)",
    "insertText": "setStackPointerRegisterToSaveRestore(unsigned R)"
  },
  {
    "label": "setExceptionPointerRegister()",
    "kind": "Method",
    "detail": "Function (StackPointerRegisterToSaveRestore = R ; } void)",
    "insertText": "setExceptionPointerRegister(unsigned R)"
  },
  {
    "label": "setExceptionSelectorRegister()",
    "kind": "Method",
    "detail": "Function (ExceptionPointerRegister = R ; } void)",
    "insertText": "setExceptionSelectorRegister(unsigned R)"
  },
  {
    "label": "setSelectIsExpensive()",
    "kind": "Method",
    "detail": "Function (ExceptionSelectorRegister = R ; } void)",
    "insertText": "setSelectIsExpensive(bool isExpensive = true)"
  },
  {
    "label": "setHasMultipleConditionRegisters()",
    "kind": "Method",
    "detail": "Function (SelectIsExpensive = isExpensive ; } void)",
    "insertText": "setHasMultipleConditionRegisters(bool hasManyRegs = true)"
  },
  {
    "label": "setHasExtractBitsInsn()",
    "kind": "Method",
    "detail": "Function (HasMultipleConditionRegisters = hasManyRegs ; } void)",
    "insertText": "setHasExtractBitsInsn(bool hasExtractInsn = true)"
  },
  {
    "label": "setJumpIsExpensive()",
    "kind": "Method",
    "detail": "Function (HasExtractBitsInsn = hasExtractInsn ; } void)",
    "insertText": "setJumpIsExpensive(bool isExpensive = true)"
  },
  {
    "label": "setIntDivIsCheap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setIntDivIsCheap(bool isCheap = true)"
  },
  {
    "label": "setFsqrtIsCheap()",
    "kind": "Method",
    "detail": "Function (IntDivIsCheap = isCheap ; } void)",
    "insertText": "setFsqrtIsCheap(bool isCheap = true)"
  },
  {
    "label": "setHasFloatingPointExceptions()",
    "kind": "Method",
    "detail": "Function (FsqrtIsCheap = isCheap ; } void)",
    "insertText": "setHasFloatingPointExceptions(bool FPExceptions = true)"
  },
  {
    "label": "addBypassSlowDiv()",
    "kind": "Method",
    "detail": "Function (HasFloatingPointExceptions = FPExceptions ; } void)",
    "insertText": "addBypassSlowDiv(unsigned int SlowBitWidth, unsigned int FastBitWidth)"
  },
  {
    "label": "setPow2SDivIsCheap()",
    "kind": "Method",
    "detail": "Function (BypassSlowDivWidths [ SlowBitWidth ] = FastBitWidth ; } void)",
    "insertText": "setPow2SDivIsCheap(bool isCheap = true)"
  },
  {
    "label": "addRegisterClass()",
    "kind": "Method",
    "detail": "Function (Pow2SDivIsCheap = isCheap ; } void)",
    "insertText": "addRegisterClass(MVT VT, const TargetRegisterClass *RC)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert((unsigned)VT.SimpleTy < array_lengthof(RegClassForVT))"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (AvailableRegClasses .)",
    "insertText": "push_back(std::make_pair(VT, RC))"
  },
  {
    "label": "clearRegisterClasses()",
    "kind": "Method",
    "detail": "Function (RegClassForVT [ VT . SimpleTy ] = RC ; } void)",
    "insertText": "clearRegisterClasses()"
  },
  {
    "label": "memset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "memset(RegClassForVT, 0,MVT::LAST_VALUETYPE * sizeof(TargetRegisterClass*))"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (AvailableRegClasses .)",
    "insertText": "clear()"
  },
  {
    "label": "clearOperationActions()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "clearOperationActions()"
  },
  {
    "label": "findRepresentativeClass()",
    "kind": "Method",
    "detail": "Function (} std::pair<const TargetRegisterClass*,uint8_t>)",
    "insertText": "findRepresentativeClass(const TargetRegisterInfo *TRI, MVT VT)"
  },
  {
    "label": "computeRegisterProperties()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeRegisterProperties(const TargetRegisterInfo *TRI)"
  },
  {
    "label": "setOperationAction()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setOperationAction(unsigned Op, MVT VT, LegalizeAction Action)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(Op < array_lengthof(OpActions[0]) && \"Table isn't big enough!\")"
  },
  {
    "label": "OpActions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OpActions(unsigned)VT.SimpleTy][Op] = (uint8_t)"
  },
  {
    "label": "setLoadExtAction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setLoadExtAction(unsigned ExtType, MVT ValVT, MVT MemVT, LegalizeAction Action)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValVT.isValid() && MemVT.isValid() && \"Table isn't big enough!\")"
  },
  {
    "label": "ExtType()",
    "kind": "Method",
    "detail": "Function (LoadExtActions [ ValVT . SimpleTy ] [ MemVT . SimpleTy ] [)",
    "insertText": "ExtType(uint8_t)"
  },
  {
    "label": "setTruncStoreAction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setTruncStoreAction(MVT ValVT, MVT MemVT, LegalizeAction Action)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(ValVT.isValid() && MemVT.isValid() && \"Table isn't big enough!\")"
  },
  {
    "label": "SimpleTy()",
    "kind": "Method",
    "detail": "Function (TruncStoreActions [ ValVT . SimpleTy ] [ MemVT .)",
    "insertText": "SimpleTy(uint8_t)"
  },
  {
    "label": "setIndexedLoadAction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setIndexedLoadAction(unsigned IdxMode, MVT VT, LegalizeAction Action)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(VT.isValid() && IdxMode < ISD::LAST_INDEXED_MODE && (unsigned)Action < 0xf && \"Table isn't big enough!\")"
  },
  {
    "label": "IndexedModeActions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IndexedModeActions(unsigned)"
  },
  {
    "label": "IndexedModeActions()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "IndexedModeActions(unsigned)VT.SimpleTy][IdxMode] |= ((uint8_t)Action)"
  },
  {
    "label": "setIndexedStoreAction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setIndexedStoreAction(unsigned IdxMode, MVT VT, LegalizeAction Action)"
  },
  {
    "label": "setCondCodeAction()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setCondCodeAction(ISD::CondCode CC, MVT VT, LegalizeAction Action)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(VT.isValid() && (unsigned)CC < array_lengthof(CondCodeActions) && \"Table isn't big enough!\")"
  },
  {
    "label": "SimpleTy()",
    "kind": "Method",
    "detail": "Function (CondCodeActions [ CC ] [ VT .)",
    "insertText": "SimpleTy((uint32_t)0x3 << Shift)"
  },
  {
    "label": "SimpleTy()",
    "kind": "Method",
    "detail": "Function (CondCodeActions [ CC ] [ VT .)",
    "insertText": "SimpleTy(uint32_t)"
  },
  {
    "label": "AddPromotedToType()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AddPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT)"
  },
  {
    "label": "make_pair()",
    "kind": "Method",
    "detail": "Function (PromoteToType [)",
    "insertText": "make_pair(Opc, OrigVT.SimpleTy)"
  },
  {
    "label": "setTargetDAGCombine()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setTargetDAGCombine(ISD::NodeType NT)"
  },
  {
    "label": "NT()",
    "kind": "Method",
    "detail": "Function (TargetDAGCombineArray [)",
    "insertText": "NT(NT&7)"
  },
  {
    "label": "setJumpBufSize()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setJumpBufSize(unsigned Size)"
  },
  {
    "label": "setJumpBufAlignment()",
    "kind": "Method",
    "detail": "Function (JumpBufSize = Size ; } void)",
    "insertText": "setJumpBufAlignment(unsigned Align)"
  },
  {
    "label": "setMinFunctionAlignment()",
    "kind": "Method",
    "detail": "Function (JumpBufAlignment = Align ; } void)",
    "insertText": "setMinFunctionAlignment(unsigned Align)"
  },
  {
    "label": "setPrefFunctionAlignment()",
    "kind": "Method",
    "detail": "Function (MinFunctionAlignment = Align ; } void)",
    "insertText": "setPrefFunctionAlignment(unsigned Align)"
  },
  {
    "label": "setPrefLoopAlignment()",
    "kind": "Method",
    "detail": "Function (PrefFunctionAlignment = Align ; } void)",
    "insertText": "setPrefLoopAlignment(unsigned Align)"
  },
  {
    "label": "setMinStackArgumentAlignment()",
    "kind": "Method",
    "detail": "Function (PrefLoopAlignment = Align ; } void)",
    "insertText": "setMinStackArgumentAlignment(unsigned Align)"
  },
  {
    "label": "setInsertFencesForAtomic()",
    "kind": "Method",
    "detail": "Function (MinStackArgumentAlignment = Align ; } void)",
    "insertText": "setInsertFencesForAtomic(bool fence)"
  },
  {
    "label": "GetAddrModeArguments()",
    "kind": "Method",
    "detail": "Function (InsertFencesForAtomic = fence ; } public : bool)",
    "insertText": "GetAddrModeArguments(IntrinsicInst * , SmallVectorImpl<Value*> & , Type *& , unsigned AddrSpace = 0)"
  },
  {
    "label": "isLegalAddressingMode()",
    "kind": "Method",
    "detail": "Function (} } ; bool)",
    "insertText": "isLegalAddressingMode(const DataLayout &DL, const AddrMode &AM, Type *Ty, unsigned AddrSpace)"
  },
  {
    "label": "getScalingFactorCost()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "getScalingFactorCost(const DataLayout &DL, const AddrMode &AM, Type *Ty, unsigned AS = 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (break ; case Instruction::ZExt :)",
    "insertText": "if(isZExtFree(I->getOperand(0)->getType(), I->getType()))"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (break ; case Instruction::SExt : break ; default :)",
    "insertText": "llvm_unreachable(\"Instruction is not an extension\")"
  },
  {
    "label": "isExtFreeImpl()",
    "kind": "Method",
    "detail": "Function (} return)",
    "insertText": "isExtFreeImpl(I)"
  },
  {
    "label": "isZExtFree()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isZExtFree(Type * , Type *)"
  },
  {
    "label": "isFPExtFree()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isFPExtFree(EVT VT)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(VT.isFloatingPoint())"
  },
  {
    "label": "getLibcallName()",
    "kind": "Method",
    "detail": "Function (LibcallRoutineNames [ Call ] = Name ; } const char*)",
    "insertText": "getLibcallName(RTLIB::Libcall Call)"
  },
  {
    "label": "getCmpLibcallCC()",
    "kind": "Method",
    "detail": "Function (CmpLibcallCCs [ Call ] = CC ; } ISD::CondCode)",
    "insertText": "getCmpLibcallCC(RTLIB::Libcall Call)"
  },
  {
    "label": "getLibcallCallingConv()",
    "kind": "Method",
    "detail": "Function (LibcallCallingConvs [ Call ] = CC ; } CallingConv::ID)",
    "insertText": "getLibcallCallingConv(RTLIB::Libcall Call)"
  },
  {
    "label": "getTypeConversion()",
    "kind": "Method",
    "detail": "Function (ValueTypeActionImpl ValueTypeActions ; private : LegalizeKind)",
    "insertText": "getTypeConversion(LLVMContext &Context, EVT VT)"
  },
  {
    "label": "TargetDAGCombineArray()",
    "kind": "Method",
    "detail": "Function (private : std::vector<std::pair<MVT,const TargetRegisterClass*>> AvailableRegClasses ; unsigned char)",
    "insertText": "TargetDAGCombineArray(ISD::BUILTIN_OP_END+CHAR_BIT-1)"
  },
  {
    "label": "isExtFreeImpl()",
    "kind": "Method",
    "detail": "Function (std::map<std::pair<unsigned,MVT::SimpleValueType>,MVT::SimpleValueType> PromoteToType ; const char* LibcallRoutineNames [ RTLIB::UNKNOWN_LIBCALL ] ; ISD::CondCode CmpLibcallCCs [ RTLIB::UNKNOWN_LIBCALL ] ; CallingConv::ID LibcallCallingConvs [ RTLIB::UNKNOWN_LIBCALL ] ; protected : bool)",
    "insertText": "isExtFreeImpl(const Instruction *I)"
  },
  {
    "label": "emitPatchPoint()",
    "kind": "Method",
    "detail": "Function (MachineBasicBlock*)",
    "insertText": "emitPatchPoint(MachineInstr *MI, MachineBasicBlock *MBB)"
  },
  {
    "label": "TargetLowering()",
    "kind": "Method",
    "detail": "Function (} ; class TargetLowering : public TargetLoweringBase {)",
    "insertText": "TargetLowering(const TargetLowering&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "operator(const TargetLowering&)"
  },
  {
    "label": "TargetLowering()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TargetLowering(const TargetMachine &TM)"
  },
  {
    "label": "getPreIndexedAddressParts()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "getPreIndexedAddressParts(SDNode * , SDValue & , SDValue & , ISD::MemIndexedMode & , SelectionDAG &)"
  },
  {
    "label": "LowerCustomJumpTableEntry()",
    "kind": "Method",
    "detail": "Function (const MCExpr*)",
    "insertText": "LowerCustomJumpTableEntry(const MachineJumpTableInfo * , const MachineBasicBlock * , unsigned , MCContext &)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Need to implement this hook if target has custom JTIs\")"
  },
  {
    "label": "getPICJumpTableRelocBase()",
    "kind": "Method",
    "detail": "Function (} SDValue)",
    "insertText": "getPICJumpTableRelocBase(SDValue Table, SelectionDAG &DAG)"
  },
  {
    "label": "getPICJumpTableRelocBaseExpr()",
    "kind": "Method",
    "detail": "Function (const MCExpr*)",
    "insertText": "getPICJumpTableRelocBaseExpr(const MachineFunction *MF, unsigned JTI, MCContext &Ctx)"
  },
  {
    "label": "isOffsetFoldingLegal()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isOffsetFoldingLegal(const GlobalAddressSDNode *GA)"
  },
  {
    "label": "isInTailCallPosition()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isInTailCallPosition(SelectionDAG &DAG, SDNode *Node, SDValue &Chain)"
  },
  {
    "label": "softenSetCCOperands()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS, SDValue &NewRHS, ISD::CondCode &CCCode, SDLoc DL)"
  },
  {
    "label": "makeLibCall()",
    "kind": "Method",
    "detail": "Function (std::pair<SDValue,SDValue>)",
    "insertText": "makeLibCall(SelectionDAG &DAG, RTLIB::Libcall LC, EVT RetVT, const SDValue *Ops, unsigned NumOps, bool isSigned, SDLoc dl, bool doesNotReturn = false, bool isReturnValueUsed = true)"
  },
  {
    "label": "TargetLoweringOpt()",
    "kind": "Method",
    "detail": "Function (struct TargetLoweringOpt { SelectionDAG& DAG ; bool LegalTys ; bool LegalOps ; SDValue Old ; SDValue New ;)",
    "insertText": "TargetLoweringOpt(SelectionDAG &InDAG, bool LT, bool LO) : DAG(InDAG), LegalTys(LT), LegalOps(LO)"
  },
  {
    "label": "LegalTypes()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "LegalTypes()"
  },
  {
    "label": "ShrinkDemandedConstant()",
    "kind": "Method",
    "detail": "Function (Old = O ; New = N ; return true ; } bool)",
    "insertText": "ShrinkDemandedConstant(SDValue Op, const APInt &Demanded)"
  },
  {
    "label": "ShrinkDemandedOp()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ShrinkDemandedOp(SDValue Op, unsigned BitWidth, const APInt &Demanded, SDLoc dl)"
  },
  {
    "label": "SimplifyDemandedBits()",
    "kind": "Method",
    "detail": "Function (} ; bool)",
    "insertText": "SimplifyDemandedBits(SDValue Op, const APInt &DemandedMask, APInt &KnownZero, APInt &KnownOne, TargetLoweringOpt &TLO, unsigned Depth = 0)"
  },
  {
    "label": "computeKnownBitsForTargetNode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "computeKnownBitsForTargetNode(const SDValue Op, APInt &KnownZero, APInt &KnownOne, const SelectionDAG &DAG, unsigned Depth = 0)"
  },
  {
    "label": "ComputeNumSignBitsForTargetNode()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "ComputeNumSignBitsForTargetNode(SDValue Op, const SelectionDAG &DAG, unsigned Depth = 0)"
  },
  {
    "label": "DAGCombinerInfo()",
    "kind": "Method",
    "detail": "Function (struct DAGCombinerInfo { void* DC ; CombineLevel Level ; bool CalledByLegalizer ; public : SelectionDAG& DAG ;)",
    "insertText": "DAGCombinerInfo(SelectionDAG &dag, CombineLevel level, bool cl, void *dc) : DC(dc), Level(level), CalledByLegalizer(cl), DAG(dag)"
  },
  {
    "label": "isBeforeLegalize()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isBeforeLegalize()"
  },
  {
    "label": "RemoveFromWorklist()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "RemoveFromWorklist(SDNode *N)"
  },
  {
    "label": "CombineTo()",
    "kind": "Method",
    "detail": "Function (SDValue)",
    "insertText": "CombineTo(SDNode *N, ArrayRef<SDValue> To, bool AddTo = true)"
  },
  {
    "label": "CombineTo()",
    "kind": "Method",
    "detail": "Function (SDValue)",
    "insertText": "CombineTo(SDNode *N, SDValue Res, bool AddTo = true)"
  },
  {
    "label": "CombineTo()",
    "kind": "Method",
    "detail": "Function (SDValue)",
    "insertText": "CombineTo(SDNode *N, SDValue Res0, SDValue Res1, bool AddTo = true)"
  },
  {
    "label": "CommitTargetLoweringOpt()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CommitTargetLoweringOpt(const TargetLoweringOpt &TLO)"
  },
  {
    "label": "isConstTrueVal()",
    "kind": "Method",
    "detail": "Function (} ; bool)",
    "insertText": "isConstTrueVal(const SDNode *N)"
  },
  {
    "label": "isConstFalseVal()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isConstFalseVal(const SDNode *N)"
  },
  {
    "label": "SimplifySetCC()",
    "kind": "Method",
    "detail": "Function (SDValue)",
    "insertText": "SimplifySetCC(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond, bool foldBooleans, DAGCombinerInfo &DCI, SDLoc dl)"
  },
  {
    "label": "isGAPlusOffset()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isGAPlusOffset(SDNode *N, const GlobalValue* &GA, int64_t &Offset)"
  },
  {
    "label": "PerformDAGCombine()",
    "kind": "Method",
    "detail": "Function (SDValue)",
    "insertText": "PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI)"
  },
  {
    "label": "isDesirableToCommuteWithShift()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "isDesirableToCommuteWithShift(const SDNode *N)"
  },
  {
    "label": "isDesirableToTransformToIntegerOp()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isDesirableToTransformToIntegerOp(unsigned , EVT)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"Not Implemented\")"
  },
  {
    "label": "ArgListEntry()",
    "kind": "Method",
    "detail": "Function (} struct ArgListEntry { SDValue Node ; Type* Ty ; bool isSExt : 1 ; bool isZExt : 1 ; bool isInReg : 1 ; bool isSRet : 1 ; bool isNest : 1 ; bool isByVal : 1 ; bool isInAlloca : 1 ; bool isReturned : 1 ; uint16_t Alignment ;)",
    "insertText": "ArgListEntry() : isSExt(false), isZExt(false), isInReg(false), isSRet(false), isNest(false), isByVal(false), isInAlloca(false), isReturned(false), Alignment(0)"
  },
  {
    "label": "setAttributes()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setAttributes(ImmutableCallSite *CS, unsigned AttrIdx)"
  },
  {
    "label": "CallLoweringInfo()",
    "kind": "Method",
    "detail": "Function (} ; typedef std::vector<ArgListEntry> ArgListTy ; struct CallLoweringInfo { SDValue Chain ; Type* RetTy ; bool RetSExt : 1 ; bool RetZExt : 1 ; bool IsVarArg : 1 ; bool IsInReg : 1 ; bool DoesNotReturn : 1 ; bool IsReturnValueUsed : 1 ; bool IsTailCall ; unsigned NumFixedArgs ; CallingConv::ID CallConv ; SDValue Callee ; ArgListTy Args ; SelectionDAG& DAG ; SDLoc DL ; ImmutableCallSite* CS ; bool IsPatchPoint ; SmallVector<ISD::OutputArg,3 2> Outs ; SmallVector<SDValue,3 2> OutVals ; SmallVector<ISD::InputArg,3 2> Ins ;)",
    "insertText": "CallLoweringInfo(SelectionDAG &DAG) : RetTy(nullptr), RetSExt(false), RetZExt(false), IsVarArg(false), IsInReg(false), DoesNotReturn(false), IsReturnValueUsed(true), IsTailCall(false), NumFixedArgs(-1), CallConv(CallingConv::C), DAG(DAG), CS(nullptr), IsPatchPoint(false)"
  },
  {
    "label": "setDebugLoc()",
    "kind": "Method",
    "detail": "Function (} CallLoweringInfo&)",
    "insertText": "setDebugLoc(SDLoc dl)"
  },
  {
    "label": "setChain()",
    "kind": "Method",
    "detail": "Function (DL = dl ; return* this ; } CallLoweringInfo&)",
    "insertText": "setChain(SDValue InChain)"
  },
  {
    "label": "setCallee()",
    "kind": "Method",
    "detail": "Function (Chain = InChain ; return* this ; } CallLoweringInfo&)",
    "insertText": "setCallee(CallingConv::ID CC, Type *ResultType, SDValue Target, ArgListTy &&ArgsList, unsigned FixedArgs = -1)"
  },
  {
    "label": "NumFixedArgs()",
    "kind": "Method",
    "detail": "Function (RetTy = ResultType ; Callee = Target ; CallConv = CC ;)",
    "insertText": "NumFixedArgs(FixedArgs == static_cast<unsigned>(-1) ? Args.size() : FixedArgs)"
  },
  {
    "label": "move()",
    "kind": "Method",
    "detail": "Function (Args =)",
    "insertText": "move(ArgsList)"
  },
  {
    "label": "paramHasAttr()",
    "kind": "Method",
    "detail": "Function (RetTy = ResultType ; IsInReg = Call .)",
    "insertText": "paramHasAttr(0, Attribute::InReg)"
  },
  {
    "label": "isVarArg()",
    "kind": "Method",
    "detail": "Function (IsVarArg = FTy ->)",
    "insertText": "isVarArg()"
  },
  {
    "label": "getInstruction()",
    "kind": "Method",
    "detail": "Function (IsReturnValueUsed = ! Call .)",
    "insertText": "getInstruction()->use_empty()"
  },
  {
    "label": "paramHasAttr()",
    "kind": "Method",
    "detail": "Function (RetSExt = Call .)",
    "insertText": "paramHasAttr(0, Attribute::SExt)"
  },
  {
    "label": "paramHasAttr()",
    "kind": "Method",
    "detail": "Function (RetZExt = Call .)",
    "insertText": "paramHasAttr(0, Attribute::ZExt)"
  },
  {
    "label": "getCallingConv()",
    "kind": "Method",
    "detail": "Function (Callee = Target ; CallConv = Call .)",
    "insertText": "getCallingConv()"
  },
  {
    "label": "getNumParams()",
    "kind": "Method",
    "detail": "Function (NumFixedArgs = FTy ->)",
    "insertText": "getNumParams()"
  },
  {
    "label": "setInRegister()",
    "kind": "Method",
    "detail": "Function (CS =& Call ; return* this ; } CallLoweringInfo&)",
    "insertText": "setInRegister(bool Value = true)"
  },
  {
    "label": "setNoReturn()",
    "kind": "Method",
    "detail": "Function (IsInReg = Value ; return* this ; } CallLoweringInfo&)",
    "insertText": "setNoReturn(bool Value = true)"
  },
  {
    "label": "setTailCall()",
    "kind": "Method",
    "detail": "Function (IsVarArg = Value ; return* this ; } CallLoweringInfo&)",
    "insertText": "setTailCall(bool Value = true)"
  },
  {
    "label": "setDiscardResult()",
    "kind": "Method",
    "detail": "Function (IsTailCall = Value ; return* this ; } CallLoweringInfo&)",
    "insertText": "setDiscardResult(bool Value = true)"
  },
  {
    "label": "setSExtResult()",
    "kind": "Method",
    "detail": "Function (IsReturnValueUsed = ! Value ; return* this ; } CallLoweringInfo&)",
    "insertText": "setSExtResult(bool Value = true)"
  },
  {
    "label": "setZExtResult()",
    "kind": "Method",
    "detail": "Function (RetSExt = Value ; return* this ; } CallLoweringInfo&)",
    "insertText": "setZExtResult(bool Value = true)"
  },
  {
    "label": "setIsPatchPoint()",
    "kind": "Method",
    "detail": "Function (RetZExt = Value ; return* this ; } CallLoweringInfo&)",
    "insertText": "setIsPatchPoint(bool Value = true)"
  },
  {
    "label": "getArgs()",
    "kind": "Method",
    "detail": "Function (IsPatchPoint = Value ; return* this ; } ArgListTy&)",
    "insertText": "getArgs()"
  },
  {
    "label": "LowerCall()",
    "kind": "Method",
    "detail": "Function (SDValue)",
    "insertText": "LowerCall(CallLoweringInfo & , SmallVectorImpl<SDValue> &)"
  },
  {
    "label": "HandleByVal()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "HandleByVal(CCState *, unsigned &, unsigned)"
  },
  {
    "label": "CanLowerReturn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "CanLowerReturn(CallingConv::ID , MachineFunction & , bool , const SmallVectorImpl<ISD::OutputArg> & , LLVMContext &)"
  },
  {
    "label": "isUsedByReturnOnly()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isUsedByReturnOnly(SDNode *, SDValue &)"
  },
  {
    "label": "report_fatal_error()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "report_fatal_error(\"Named registers not implemented for this target\")"
  },
  {
    "label": "getTypeForExtArgOrReturn()",
    "kind": "Method",
    "detail": "Function (} EVT)",
    "insertText": "getTypeForExtArgOrReturn(LLVMContext &Context, EVT VT, ISD::NodeType)"
  },
  {
    "label": "getRegisterType()",
    "kind": "Method",
    "detail": "Function (EVT MinVT =)",
    "insertText": "getRegisterType(Context, MVT::i32)"
  },
  {
    "label": "functionArgumentNeedsConsecutiveRegisters()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "functionArgumentNeedsConsecutiveRegisters(Type *Ty, CallingConv::ID CallConv, bool isVarArg)"
  },
  {
    "label": "LowerOperation()",
    "kind": "Method",
    "detail": "Function (SDValue)",
    "insertText": "LowerOperation(SDValue Op, SelectionDAG &DAG)"
  },
  {
    "label": "ReplaceNodeResults()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ReplaceNodeResults(SDNode * , SmallVectorImpl<SDValue> & , SelectionDAG &)"
  },
  {
    "label": "llvm_unreachable()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "llvm_unreachable(\"ReplaceNodeResults not implemented for this target!\")"
  },
  {
    "label": "getTargetNodeName()",
    "kind": "Method",
    "detail": "Function (} const char*)",
    "insertText": "getTargetNodeName(unsigned Opcode)"
  },
  {
    "label": "createFastISel()",
    "kind": "Method",
    "detail": "Function (FastISel*)",
    "insertText": "createFastISel(FunctionLoweringInfo &, const TargetLibraryInfo *)"
  },
  {
    "label": "ExpandInlineAsm()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "ExpandInlineAsm(CallInst *)"
  },
  {
    "label": "getMatchedOperand()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getMatchedOperand()"
  },
  {
    "label": "AsmOperandInfo()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AsmOperandInfo(InlineAsm::ConstraintInfo Info) : InlineAsm::ConstraintInfo(std::move(Info)), ConstraintType(TargetLowering::C_Unknown), CallOperandVal(nullptr), ConstraintVT(MVT::Other)"
  },
  {
    "label": "ParseConstraints()",
    "kind": "Method",
    "detail": "Function (} } ; typedef std::vector<AsmOperandInfo> AsmOperandInfoVector ; AsmOperandInfoVector)",
    "insertText": "ParseConstraints(const DataLayout &DL, const TargetRegisterInfo *TRI, ImmutableCallSite CS)"
  },
  {
    "label": "getMultipleConstraintMatchWeight()",
    "kind": "Method",
    "detail": "Function (ConstraintWeight)",
    "insertText": "getMultipleConstraintMatchWeight(AsmOperandInfo &info, int maIndex)"
  },
  {
    "label": "getSingleConstraintMatchWeight()",
    "kind": "Method",
    "detail": "Function (ConstraintWeight)",
    "insertText": "getSingleConstraintMatchWeight(AsmOperandInfo &info, const char *constraint)"
  },
  {
    "label": "ComputeConstraintToUse()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ComputeConstraintToUse(AsmOperandInfo &OpInfo, SDValue Op, SelectionDAG *DAG = nullptr)"
  },
  {
    "label": "getConstraintType()",
    "kind": "Method",
    "detail": "Function (ConstraintType)",
    "insertText": "getConstraintType(StringRef Constraint)"
  },
  {
    "label": "getRegForInlineAsmConstraint()",
    "kind": "Method",
    "detail": "Function (std::pair<unsigned,const TargetRegisterClass*>)",
    "insertText": "getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI, StringRef Constraint, MVT VT)"
  },
  {
    "label": "getInlineAsmMemConstraint()",
    "kind": "Method",
    "detail": "Function (unsigned)",
    "insertText": "getInlineAsmMemConstraint(StringRef ConstraintCode)"
  },
  {
    "label": "LowerAsmOperandForConstraint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LowerAsmOperandForConstraint(SDValue Op, std::string &Constraint, std::vector<SDValue> &Ops, SelectionDAG &DAG)"
  },
  {
    "label": "BuildSDIV()",
    "kind": "Method",
    "detail": "Function (SDValue)",
    "insertText": "BuildSDIV(SDNode *N, const APInt &Divisor, SelectionDAG &DAG, bool IsAfterLegalization, std::vector<SDNode *> *Created)"
  },
  {
    "label": "BuildUDIV()",
    "kind": "Method",
    "detail": "Function (SDValue)",
    "insertText": "BuildUDIV(SDNode *N, const APInt &Divisor, SelectionDAG &DAG, bool IsAfterLegalization, std::vector<SDNode *> *Created)"
  },
  {
    "label": "BuildSDIVPow2()",
    "kind": "Method",
    "detail": "Function (SDValue)",
    "insertText": "BuildSDIVPow2(SDNode *N, const APInt &Divisor, SelectionDAG &DAG, std::vector<SDNode *> *Created)"
  },
  {
    "label": "combineRepeatedFPDivisors()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "combineRepeatedFPDivisors(unsigned NumUsers)"
  },
  {
    "label": "getRecipEstimate()",
    "kind": "Method",
    "detail": "Function (} SDValue)",
    "insertText": "getRecipEstimate(SDValue Operand, DAGCombinerInfo &DCI, unsigned &RefinementSteps)"
  },
  {
    "label": "expandMUL()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "expandMUL(SDNode *N, SDValue &Lo, SDValue &Hi, EVT HiLoVT, SelectionDAG &DAG, SDValue LL = SDValue(), SDValue LH = SDValue(), SDValue RL = SDValue(), SDValue RH = SDValue())"
  },
  {
    "label": "expandFP_TO_SINT()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "expandFP_TO_SINT(SDNode *N, SDValue &Result, SelectionDAG &DAG)"
  },
  {
    "label": "EmitInstrWithCustomInserter()",
    "kind": "Method",
    "detail": "Function (MachineBasicBlock*)",
    "insertText": "EmitInstrWithCustomInserter(MachineInstr *MI, MachineBasicBlock *MBB)"
  },
  {
    "label": "AdjustInstrPostInstrSelection()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "AdjustInstrPostInstrSelection(MachineInstr *MI, SDNode *Node)"
  },
  {
    "label": "useLoadStackGuardNode()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "useLoadStackGuardNode()"
  }
]