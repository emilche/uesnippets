[
  {
    "label": "FDebugName",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FDebugName"
  },
  {
    "label": "class",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "class"
  },
  {
    "label": "EShaderFrequency",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EShaderFrequency"
  },
  {
    "label": "ERenderQueryType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ERenderQueryType"
  },
  {
    "label": "Type",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "Type"
  },
  {
    "label": "ESamplerFilter",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ESamplerFilter"
  },
  {
    "label": "ESamplerAddressMode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ESamplerAddressMode"
  },
  {
    "label": "ESamplerCompareFunction",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ESamplerCompareFunction"
  },
  {
    "label": "ERasterizerFillMode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ERasterizerFillMode"
  },
  {
    "label": "ERasterizerCullMode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ERasterizerCullMode"
  },
  {
    "label": "EColorWriteMask",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EColorWriteMask"
  },
  {
    "label": "ECompareFunction",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ECompareFunction"
  },
  {
    "label": "EStencilMask",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EStencilMask"
  },
  {
    "label": "EStencilOp",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EStencilOp"
  },
  {
    "label": "EBlendOperation",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EBlendOperation"
  },
  {
    "label": "EBlendFactor",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EBlendFactor"
  },
  {
    "label": "EVertexElementType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EVertexElementType"
  },
  {
    "label": "ECubeFace",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ECubeFace"
  },
  {
    "label": "EUniformBufferUsage",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EUniformBufferUsage"
  },
  {
    "label": "EUniformBufferBaseType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EUniformBufferBaseType"
  },
  {
    "label": "FRHIResourceTableEntry",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRHIResourceTableEntry"
  },
  {
    "label": "EResourceTableDefinitions",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EResourceTableDefinitions"
  },
  {
    "label": "EResourceLockMode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EResourceLockMode"
  },
  {
    "label": "ERangeCompressionMode",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ERangeCompressionMode"
  },
  {
    "label": "EPrimitiveType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EPrimitiveType"
  },
  {
    "label": "EVRSAxisShadingRate",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EVRSAxisShadingRate"
  },
  {
    "label": "EVRSShadingRate",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EVRSShadingRate"
  },
  {
    "label": "EVRSRateCombiner",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EVRSRateCombiner"
  },
  {
    "label": "EVRSImageDataType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EVRSImageDataType"
  },
  {
    "label": "ERHIResourceType",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ERHIResourceType"
  },
  {
    "label": "EAsyncComputePriority",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "EAsyncComputePriority"
  },
  {
    "label": "ETextureReallocationStatus",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ETextureReallocationStatus"
  },
  {
    "label": "FRHIDescriptorHandle",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FRHIDescriptorHandle"
  },
  {
    "label": "FScreenResolutionRHI",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FScreenResolutionRHI"
  },
  {
    "label": "FShaderCodeValidationStride",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FShaderCodeValidationStride"
  },
  {
    "label": "FShaderCodeValidationType",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FShaderCodeValidationType"
  },
  {
    "label": "FShaderCodeValidationUBSize",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FShaderCodeValidationUBSize"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" GpuProfilerTrace . h \" # include \" Math / NumericLimits . h \" # include \" Misc / AssertionMacros . h \" # include \" Misc / EnumClassFlags . h \" # include \" ProfilingDebugging / CsvProfilerConfig . h \" # include \" UObject / NameTypes . h \" # ifndef USE_STATIC_SHADER_PLATFORM_ENUMS # define USE_STATIC_SHADER_PLATFORM_ENUMS 0 # endif # define SHADER_PARAMETER_STRUCT_ALIGNMENT 1 6 # define SHADER_PARAMETER_ARRAY_ELEMENT_ALIGNMENT 1 6 # define SHADER_PARAMETER_POINTER_ALIGNMENT)",
    "insertText": "sizeof(uint64) static_assert(sizeof(void*) <= SHADER_PARAMETER_POINTER_ALIGNMENT, \"The alignment of pointer needs to match the largest pointer.\")"
  },
  {
    "label": "HAS_GPU_STATS()",
    "kind": "Method",
    "detail": "Function (# ifndef PLATFORM_DISPATCH_INDIRECT_ARGUMENT_BOUNDARY_SIZE # define PLATFORM_DISPATCH_INDIRECT_ARGUMENT_BOUNDARY_SIZE 0 # endif # ifndef USE_STATIC_SHADER_PLATFORM_INFO # define USE_STATIC_SHADER_PLATFORM_INFO 0 # endif # ifndef RHI_RAYTRACING # define RHI_RAYTRACING 0 # endif # ifndef HAS_GPU_STATS # define)",
    "insertText": "HAS_GPU_STATS((STATS || CSV_PROFILER_STATS || GPUPROFILERTRACE_ENABLED) && (!UE_BUILD_SHIPPING))"
  },
  {
    "label": "FDebugName()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "FDebugName()"
  },
  {
    "label": "FDebugName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FDebugName(FName InName)"
  },
  {
    "label": "FDebugName()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FDebugName(FName InName, int32 InNumber)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (FDebugName&)",
    "insertText": "operator(FName Other)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (FString)",
    "insertText": "ToString()"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (uint32)",
    "insertText": "ToString(TCHAR* Out, uint32 OutSize)"
  },
  {
    "label": "ToString()",
    "kind": "Method",
    "detail": "Function (template<int N> uint32)",
    "insertText": "ToString(TCHAR(&Out)[N])"
  },
  {
    "label": "IsNone()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsNone()"
  },
  {
    "label": "AppendString()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "AppendString(FStringBuilderBase& Builder)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (private : FName Name ; uint32 Number ; } ; enum class ERHIInterfaceType { Hidden,Null,D3D11,D3D12,Vulkan,Metal,Agx,OpenGL,} ; enum class ERHIFeatureSupport : uint8 { Unsupported,RuntimeDependent,RuntimeGuaranteed,Num,NumBits = 2,} ; enum class ERHIBindlessSupport : uint8 { Unsupported,RayTracingOnly,AllShaderTypes,NumBits = 2 } ; enum class ERHIStaticShaderBindingLayoutSupport : uint8 { Unsupported,RayTracingOnly,AllShaderTypes,NumBits = 2 } ; enum EShaderFrequency : uint8 { SF_Vertex = 0,SF_Mesh = 1,SF_Amplification = 2,SF_Pixel = 3,SF_Geometry = 4,SF_Compute = 5,SF_RayGen = 6,SF_RayMiss = 7,SF_RayHitGroup = 8,SF_RayCallable = 9,SF_WorkGraphRoot = 1 0,SF_WorkGraphComputeNode = 1 1,SF_NumFrequencies = 1 2,SF_NumGraphicsFrequencies = 5,SF_NumStandardFrequencies = 6,SF_NumBits = 4,} ;)",
    "insertText": "static_assert(SF_NumFrequencies <= (1 << SF_NumBits), \"SF_NumFrequencies will not fit on SF_NumBits\")"
  },
  {
    "label": "IsValidGraphicsFrequency()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsValidGraphicsFrequency(EShaderFrequency InShaderFrequency)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum { ShaderArrayElementAlignBytes = 1 6 } ; enum { MaxSimultaneousRenderTargets = 8,MaxSimultaneousRenderTargets_NumBits = 3,} ;)",
    "insertText": "static_assert(MaxSimultaneousRenderTargets <= (1 << MaxSimultaneousRenderTargets_NumBits), \"MaxSimultaneousRenderTargets will not fit on MaxSimultaneousRenderTargets_NumBits\")"
  },
  {
    "label": "IsInverted()",
    "kind": "Method",
    "detail": "Function (enum { MaxSimultaneousUAVs = 8 } ; enum class ERHIZBuffer { FarPlane = 0,NearPlane = 1,)",
    "insertText": "IsInverted(int32)((int32)ERHIZBuffer::FarPlane < (int32)ERHIZBuffer::NearPlane)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (namespace ERHIShadingPath { enum Type : int { Deferred,Forward,Mobile,Num } ; } enum ESamplerFilter { SF_Point,SF_Bilinear,SF_Trilinear,SF_AnisotropicPoint,SF_AnisotropicLinear,ESamplerFilter_Num,ESamplerFilter_NumBits = 3,} ;)",
    "insertText": "static_assert(ESamplerFilter_Num <= (1 << ESamplerFilter_NumBits), \"ESamplerFilter_Num will not fit on ESamplerFilter_NumBits\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum ESamplerAddressMode { AM_Wrap,AM_Clamp,AM_Mirror,AM_Border,ESamplerAddressMode_Num,ESamplerAddressMode_NumBits = 2,} ;)",
    "insertText": "static_assert(ESamplerAddressMode_Num <= (1 << ESamplerAddressMode_NumBits), \"ESamplerAddressMode_Num will not fit on ESamplerAddressMode_NumBits\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum ESamplerCompareFunction { SCF_Never,SCF_Less } ; enum ERasterizerFillMode { FM_Point,FM_Wireframe,FM_Solid,ERasterizerFillMode_Num,ERasterizerFillMode_NumBits = 2,} ;)",
    "insertText": "static_assert(ERasterizerFillMode_Num <= (1 << ERasterizerFillMode_NumBits), \"ERasterizerFillMode_Num will not fit on ERasterizerFillMode_NumBits\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum ERasterizerCullMode { CM_None,CM_CW,CM_CCW,ERasterizerCullMode_Num,ERasterizerCullMode_NumBits = 2,} ;)",
    "insertText": "static_assert(ERasterizerCullMode_Num <= (1 << ERasterizerCullMode_NumBits), \"ERasterizerCullMode_Num will not fit on ERasterizerCullMode_NumBits\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum class ERasterizerDepthClipMode : uint8 { DepthClip,DepthClamp,Num,NumBits = 1,} ;)",
    "insertText": "static_assert(uint32(ERasterizerDepthClipMode::Num) <= (1U << uint32(ERasterizerDepthClipMode::NumBits)), \"ERasterizerDepthClipMode::Num will not fit on ERasterizerDepthClipMode::NumBits\")"
  },
  {
    "label": "CF_DepthNearOrEqual()",
    "kind": "Method",
    "detail": "Function (enum EColorWriteMask { CW_RED = 0 x01,CW_GREEN = 0 x02,CW_BLUE = 0 x04,CW_ALPHA = 0 x08,CW_NONE = 0,CW_RGB = CW_RED | CW_GREEN | CW_BLUE,CW_RGBA = CW_RED | CW_GREEN | CW_BLUE | CW_ALPHA,CW_RG = CW_RED | CW_GREEN,CW_BA = CW_BLUE | CW_ALPHA,EColorWriteMask_NumBits = 4,} ; enum ECompareFunction { CF_Less,CF_LessEqual,CF_Greater,CF_GreaterEqual,CF_Equal,CF_NotEqual,CF_Never,CF_Always,ECompareFunction_Num,ECompareFunction_NumBits = 3,)",
    "insertText": "CF_DepthNearOrEqual(((int32)ERHIZBuffer::IsInverted != 0) ? CF_GreaterEqual : CF_LessEqual), CF_DepthNear = (((int32)ERHIZBuffer::IsInverted != 0) ? CF_Greater : CF_Less), CF_DepthFartherOrEqual = (((int32)ERHIZBuffer::IsInverted != 0) ? CF_LessEqual : CF_GreaterEqual), CF_DepthFarther = (((int32)ERHIZBuffer::IsInverted != 0) ? CF_Less : CF_Greater)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum EStencilMask { SM_Default,SM_255,SM_1,SM_2,SM_4,SM_8,SM_16,SM_32,SM_64,SM_128,SM_Count } ; enum EStencilOp { SO_Keep,SO_Zero,SO_Replace,SO_SaturatedIncrement,SO_SaturatedDecrement,SO_Invert,SO_Increment,SO_Decrement,EStencilOp_Num,EStencilOp_NumBits = 3,} ;)",
    "insertText": "static_assert(EStencilOp_Num <= (1 << EStencilOp_NumBits), \"EStencilOp_Num will not fit on EStencilOp_NumBits\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum EBlendOperation { BO_Add,BO_Subtract,BO_Min,BO_Max,BO_ReverseSubtract,EBlendOperation_Num,EBlendOperation_NumBits = 3,} ;)",
    "insertText": "static_assert(EBlendOperation_Num <= (1 << EBlendOperation_NumBits), \"EBlendOperation_Num will not fit on EBlendOperation_NumBits\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum EBlendFactor { BF_Zero,BF_One,BF_SourceColor,BF_InverseSourceColor,BF_SourceAlpha,BF_InverseSourceAlpha,BF_DestAlpha,BF_InverseDestAlpha,BF_DestColor,BF_InverseDestColor,BF_ConstantBlendFactor,BF_InverseConstantBlendFactor,BF_Source1Color,BF_InverseSource1Color,BF_Source1Alpha,BF_InverseSource1Alpha,EBlendFactor_Num,EBlendFactor_NumBits = 4,} ;)",
    "insertText": "static_assert(EBlendFactor_Num <= (1 << EBlendFactor_NumBits), \"EBlendFactor_Num will not fit on EBlendFactor_NumBits\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum EVertexElementType { VET_None,VET_Float1,VET_Float2,VET_Float3,VET_Float4,VET_PackedNormal,VET_UByte4,VET_UByte4N,VET_Color,VET_Short2,VET_Short4,VET_Short2N,VET_Half2,VET_Half4,VET_Short4N,VET_UShort2,VET_UShort4,VET_UShort2N,VET_UShort4N,VET_URGB10A2N,VET_UInt,VET_MAX,VET_NumBits = 5,} ;)",
    "insertText": "static_assert(VET_MAX <= (1 << VET_NumBits), \"VET_MAX will not fit on VET_NumBits\")"
  },
  {
    "label": "IsResourceBindingTypeSRV()",
    "kind": "Method",
    "detail": "Function (enum ECubeFace : uint32 { CubeFace_PosX = 0,CubeFace_NegX,CubeFace_PosY,CubeFace_NegY,CubeFace_PosZ,CubeFace_NegZ,CubeFace_MAX } ; enum EUniformBufferUsage { UniformBuffer_SingleDraw = 0,UniformBuffer_SingleFrame,UniformBuffer_MultiFrame,} ; enum class EUniformBufferValidation { None,ValidateResources } ; enum class EShaderCodeResourceBindingType : uint8 { Invalid,SamplerState,Texture2D,Texture2DArray,Texture2DMS,Texture3D,TextureCube,TextureCubeArray,TextureMetadata,Buffer,StructuredBuffer,ByteAddressBuffer,RaytracingAccelerationStructure,RWTexture2D,RWTexture2DArray,RWTexture3D,RWTextureCube,RWTextureMetadata,RWBuffer,RWStructuredBuffer,RWByteAddressBuffer,RasterizerOrderedTexture2D,ResourceCollection,MAX } ; bool)",
    "insertText": "IsResourceBindingTypeSRV(EShaderCodeResourceBindingType Type)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} return false ; } enum EUniformBufferBaseType : uint8 { UBMT_INVALID,UBMT_BOOL,UBMT_INT32,UBMT_UINT32,UBMT_FLOAT32,UBMT_TEXTURE,UBMT_SRV,UBMT_UAV,UBMT_SAMPLER,UBMT_RDG_TEXTURE,UBMT_RDG_TEXTURE_ACCESS,UBMT_RDG_TEXTURE_ACCESS_ARRAY,UBMT_RDG_TEXTURE_SRV,UBMT_RDG_TEXTURE_NON_PIXEL_SRV,UBMT_RDG_TEXTURE_UAV,UBMT_RDG_BUFFER_ACCESS,UBMT_RDG_BUFFER_ACCESS_ARRAY,UBMT_RDG_BUFFER_SRV,UBMT_RDG_BUFFER_UAV,UBMT_RDG_UNIFORM_BUFFER,UBMT_NESTED_STRUCT,UBMT_INCLUDED_STRUCT,UBMT_REFERENCED_STRUCT,UBMT_RENDER_TARGET_BINDING_SLOTS,UBMT_RESOURCE_COLLECTION,EUniformBufferBaseType_Num,EUniformBufferBaseType_NumBits = 5,} ;)",
    "insertText": "static_assert(EUniformBufferBaseType_Num <= (1 << EUniformBufferBaseType_NumBits), \"EUniformBufferBaseType_Num will not fit on EUniformBufferBaseType_NumBits\")"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (enum class EUniformBufferBindingFlags : uint8 { Shader = 1<<0,= 1<<1,StaticAndShader = | Shader } ;)",
    "insertText": "ENUM_CLASS_FLAGS(EUniformBufferBindingFlags)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (enum class ERHIUniformBufferFlags : uint8 { None = 0,NoEmulatedUniformBuffer = 1<<0,NeedsReflectedMembers = 1<<1,HasNonGraphOutputs = 1<<2,UniformView = 1<<3,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(ERHIUniformBufferFlags)"
  },
  {
    "label": "IsUniformBufferStaticSlotValid()",
    "kind": "Method",
    "detail": "Function (using FUniformBufferStaticSlot = uint8 ; enum { MAX_UNIFORM_BUFFER_STATIC_SLOTS = 2 5 5 } ; bool)",
    "insertText": "IsUniformBufferStaticSlotValid(const FUniformBufferStaticSlot Slot)"
  },
  {
    "label": "GetUniformBufferIndex()",
    "kind": "Method",
    "detail": "Function (} uint16)",
    "insertText": "GetUniformBufferIndex(uint32 Data)"
  },
  {
    "label": "GetResourceIndex()",
    "kind": "Method",
    "detail": "Function (} uint16)",
    "insertText": "GetResourceIndex(uint32 Data)"
  },
  {
    "label": "GetBindIndex()",
    "kind": "Method",
    "detail": "Function (} uint16)",
    "insertText": "GetBindIndex(uint32 Data)"
  },
  {
    "label": "RTD_Mask_UniformBufferIndex()",
    "kind": "Method",
    "detail": "Function (} private : enum EResourceTableDefinitions { RTD_NumBits_UniformBufferIndex = 8,RTD_NumBits_ResourceIndex = 1 6,RTD_NumBits_BindIndex = 8,)",
    "insertText": "RTD_Mask_UniformBufferIndex(1 << RTD_NumBits_UniformBufferIndex) - 1, RTD_Mask_ResourceIndex = (1 << RTD_NumBits_ResourceIndex) - 1, RTD_Mask_BindIndex = (1 << RTD_NumBits_BindIndex)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} ; enum EResourceLockMode { RLM_ReadOnly,RLM_WriteOnly,RLM_WriteOnly_NoOverwrite,RLM_Num } ; enum ERangeCompressionMode { RCM_UNorm,RCM_SNorm,RCM_MinMaxNorm,RCM_MinMax,} ; enum class EPrimitiveTopologyType : uint8 { Triangle,Patch,Line,Point,Num,NumBits = 2,} ;)",
    "insertText": "static_assert((uint32)EPrimitiveTopologyType::Num <= (1 << (uint32)EPrimitiveTopologyType::NumBits), \"EPrimitiveTopologyType::Num will not fit on EPrimitiveTopologyType::NumBits\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum EPrimitiveType { PT_TriangleList,PT_TriangleStrip,PT_LineList,PT_QuadList,PT_PointList,PT_RectList,PT_Num,PT_NumBits = 3 } ;)",
    "insertText": "static_assert(PT_Num <= (1 << 8), \"EPrimitiveType doesn't fit in a byte\")"
  },
  {
    "label": "VRSSR_1x1()",
    "kind": "Method",
    "detail": "Function (enum EVRSAxisShadingRate : uint8 { VRSASR_1X = 0 x0,VRSASR_2X = 0 x1,VRSASR_4X = 0 x2,} ; enum EVRSShadingRate : uint8 {)",
    "insertText": "VRSSR_1x1(VRSASR_1X << 2) + VRSASR_1X, VRSSR_1x2 = (VRSASR_1X << 2) + VRSASR_2X, VRSSR_2x1 = (VRSASR_2X << 2) + VRSASR_1X, VRSSR_2x2 = (VRSASR_2X << 2) + VRSASR_2X, VRSSR_2x4 = (VRSASR_2X << 2) + VRSASR_4X, VRSSR_4x2 = (VRSASR_4X << 2) + VRSASR_2X, VRSSR_4x4 = (VRSASR_4X << 2)"
  },
  {
    "label": "RayTracingScratch()",
    "kind": "Method",
    "detail": "Function (enum EVRSRateCombiner : uint8 { VRSRB_Passthrough,VRSRB_Override,VRSRB_Min,VRSRB_Max,VRSRB_Sum,} ; enum EVRSImageDataType : uint8 { VRSImage_NotSupported,VRSImage_Palette,VRSImage_Fractional,} ; enum class EBufferUsageFlags : uint32 { None = 0,= 1<<0,Dynamic = 1<<1,Volatile = 1<<2,UnorderedAccess = 1<<3,ByteAddressBuffer = 1<<4,SourceCopy = 1<<5,UNUSED_BIT_6 = 1<<6,DrawIndirect = 1<<7,ShaderResource = 1<<8,KeepCPUAccessible = 1<<9,FastVRAM = 1<<1 0,NNE = 1<<1 1,Shared = 1<<1 2,AccelerationStructure = 1<<1 3,VertexBuffer = 1<<1 4,IndexBuffer = 1<<1 5,StructuredBuffer = 1<<1 6,MultiGPUAllocate = 1<<1 7,MultiGPUGraphIgnore = 1<<1 8,)",
    "insertText": "RayTracingScratch(1 << 19) | UnorderedAccess, NullResource = 1 << 20, UniformBuffer = 1 << 21, ReservedResource = 1 << 22, AnyDynamic = (Dynamic | Volatile)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ENUM_CLASS_FLAGS(EBufferUsageFlags)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ENUM_CLASS_FLAGS(ETextureCreateFlags)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (# define TexCreate_None ETextureCreateFlags::None # define TexCreate_RenderTargetable ETextureCreateFlags::RenderTargetable # define TexCreate_ResolveTargetable ETextureCreateFlags::ResolveTargetable # define TexCreate_DepthStencilTargetable ETextureCreateFlags::DepthStencilTargetable # define TexCreate_ShaderResource ETextureCreateFlags::ShaderResource # define TexCreate_SRGB ETextureCreateFlags::SRGB # define TexCreate_CPUWritable ETextureCreateFlags::CPUWritable # define TexCreate_NoTiling ETextureCreateFlags::NoTiling # define TexCreate_VideoDecode ETextureCreateFlags::VideoDecode # define TexCreate_Dynamic ETextureCreateFlags::Dynamic # define TexCreate_InputAttachmentRead ETextureCreateFlags::InputAttachmentRead # define TexCreate_Foveation ETextureCreateFlags::Foveation # define TexCreate_3DTiling ETextureCreateFlags::Tiling3D # define TexCreate_Memoryless ETextureCreateFlags::Memoryless # define TexCreate_GenerateMipCapable ETextureCreateFlags::GenerateMipCapable # define TexCreate_FastVRAMPartialAlloc ETextureCreateFlags::FastVRAMPartialAlloc # define TexCreate_DisableSRVCreation ETextureCreateFlags::DisableSRVCreation # define TexCreate_DisableDCC ETextureCreateFlags::DisableDCC # define TexCreate_UAV ETextureCreateFlags::UAV # define TexCreate_Presentable ETextureCreateFlags::Presentable # define TexCreate_CPUReadback ETextureCreateFlags::CPUReadback # define TexCreate_OfflineProcessed ETextureCreateFlags::OfflineProcessed # define TexCreate_FastVRAM ETextureCreateFlags::FastVRAM # define TexCreate_HideInVisualizeTexture ETextureCreateFlags::HideInVisualizeTexture # define TexCreate_Virtual ETextureCreateFlags::# define TexCreate_TargetArraySlicesIndependently ETextureCreateFlags::TargetArraySlicesIndependently # define TexCreate_Shared ETextureCreateFlags::Shared # define TexCreate_NoFastClear ETextureCreateFlags::NoFastClear # define TexCreate_DepthStencilResolveTarget ETextureCreateFlags::DepthStencilResolveTarget # define TexCreate_Streamable ETextureCreateFlags::Streamable # define TexCreate_NoFastClearFinalize ETextureCreateFlags::NoFastClearFinalize # define TexCreate_ReduceMemoryWithTilingMode ETextureCreateFlags::ReduceMemoryWithTilingMode # define TexCreate_Transient ETextureCreateFlags::Transient # define TexCreate_AtomicCompatible ETextureCreateFlags::AtomicCompatible # define TexCreate_External ETextureCreateFlags::External # define TexCreate_MultiGPUGraphIgnore ETextureCreateFlags::MultiGPUGraphIgnore # define TexCreate_ReservedResource ETextureCreateFlags::ReservedResource # define TexCreate_ImmediateCommit ETextureCreateFlags::ImmediateCommit # define TexCreate_Invalid ETextureCreateFlags::Invalid enum EAsyncComputePriority { AsyncComputePriority_Default = 0,AsyncComputePriority_High,} ; enum ETextureReallocationStatus { TexRealloc_Succeeded = 0,TexRealloc_Failed,TexRealloc_InProgress,} ; enum class ERenderTargetLoadAction : uint8 { ENoAction,ELoad,EClear,Num,NumBits = 2,} ;)",
    "insertText": "static_assert((uint32)ERenderTargetLoadAction::Num <= (1 << (uint32)ERenderTargetLoadAction::NumBits), \"ERenderTargetLoadAction::Num will not fit on ERenderTargetLoadAction::NumBits\")"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (enum class ERenderTargetStoreAction : uint8 { ENoAction,EStore,EMultisampleResolve,Num,NumBits = 2,} ;)",
    "insertText": "static_assert((uint32)ERenderTargetStoreAction::Num <= (1 << (uint32)ERenderTargetStoreAction::NumBits), \"ERenderTargetStoreAction::Num will not fit on ERenderTargetStoreAction::NumBits\")"
  },
  {
    "label": "FRHIDescriptorHandle()",
    "kind": "Method",
    "detail": "Function (enum class ESimpleRenderTargetMode { EExistingColorAndDepth,EUninitializedColorAndDepth,EUninitializedColorExistingDepth,EUninitializedColorClearDepth,EClearColorExistingDepth,EClearColorAndDepth,EExistingContents_NoDepthStore,EExistingColorAndClearDepth,EExistingColorAndDepthAndClearStencil,} ; enum class EClearDepthStencil { Depth,Stencil,DepthStencil,} ; enum class EAsyncComputeBudget { ELeast_0,EGfxHeavy_1,EBalanced_2,EComputeHeavy_3,EAll_4,} ; enum class ERHIDescriptorHeapType : uint8 { Standard,Sampler,RenderTarget,DepthStencil,Count,Invalid = MAX_uint8 } ; struct FRHIDescriptorHandle {)",
    "insertText": "FRHIDescriptorHandle()"
  },
  {
    "label": "FRHIDescriptorHandle()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FRHIDescriptorHandle(ERHIDescriptorHeapType InType, uint32 InIndex) : Index(InIndex) , Type((uint8)InType)"
  },
  {
    "label": "FRHIDescriptorHandle()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "FRHIDescriptorHandle(uint8 InType, uint32 InIndex) : Index(InIndex) , Type(InType)"
  },
  {
    "label": "GetIndex()",
    "kind": "Method",
    "detail": "Function (} uint32)",
    "insertText": "GetIndex()"
  },
  {
    "label": "GetRawType()",
    "kind": "Method",
    "detail": "Function (} uint8)",
    "insertText": "GetRawType()"
  },
  {
    "label": "Type()",
    "kind": "Method",
    "detail": "Function (} private : uint32 Index { MAX_uint32 } ; uint8)",
    "insertText": "Type(uint8)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (} ; enum class ERHIBindlessConfiguration { Disabled,AllShaders,RayTracingShaders,} ; enum class EColorSpaceAndEOTF { EUnknown = 0,EColorSpace_Rec709 = 1,EColorSpace_Rec2020 = 2,EColorSpace_DCIP3 = 3,EEColorSpace_MASK = 0 xf,EEOTF_Linear = 1<<4,EEOTF_sRGB = 2<<4,EEOTF_PQ = 3<<4,EEOTF_MASK = 0 xf<<4,ERec709_sRGB = EColorSpace_Rec709 | EEOTF_sRGB,ERec709_Linear = EColorSpace_Rec709 | EEOTF_Linear,ERec2020_PQ = EColorSpace_Rec2020 | EEOTF_PQ,ERec2020_Linear = EColorSpace_Rec2020 | EEOTF_Linear,EDCIP3_PQ = EColorSpace_DCIP3 | EEOTF_PQ,EDCIP3_Linear = EColorSpace_DCIP3 | EEOTF_Linear,} ; enum class ERHITransitionCreateFlags { None = 0,NoFence = 1<<0,NoSplit = 1<<1,BeginSimpleMode } ;)",
    "insertText": "ENUM_CLASS_FLAGS(ERHITransitionCreateFlags)"
  },
  {
    "label": "Mask()",
    "kind": "Method",
    "detail": "Function (enum class EResourceTransitionFlags { None = 0,MaintainCompression = 1<<0,Discard = 1<<1,Clear = 1<<2,Last = Clear,)",
    "insertText": "Mask(Last << 1)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ENUM_CLASS_FLAGS(EResourceTransitionFlags)"
  },
  {
    "label": "ENUM_CLASS_FLAGS()",
    "kind": "Method",
    "detail": "Function (enum class ERequestedGPUCrash : uint8 { None = 0,Type_Hang = 1<<0,Type_PageFault = 1<<1,Type_PlatformBreak = 1<<2,Type_Assert = 1<<3,Queue_Direct = 1<<4,Queue_Compute = 1<<5,} ;)",
    "insertText": "ENUM_CLASS_FLAGS(ERequestedGPUCrash)"
  },
  {
    "label": "IsRDGTextureReferenceShaderParameterType()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "IsRDGTextureReferenceShaderParameterType(EUniformBufferBaseType BaseType)"
  },
  {
    "label": "IsShaderParameterTypeReadOnlyRHIResource()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsShaderParameterTypeReadOnlyRHIResource(EUniformBufferBaseType BaseType)"
  },
  {
    "label": "IsShaderParameterTypeForUniformBufferLayout()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsShaderParameterTypeForUniformBufferLayout(EUniformBufferBaseType BaseType)"
  },
  {
    "label": "IsShaderParameterTypeIgnoredByRHI()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsShaderParameterTypeIgnoredByRHI(EUniformBufferBaseType BaseType)"
  },
  {
    "label": "RHIConvertToGpuVendorId()",
    "kind": "Method",
    "detail": "Function (} EGpuVendorId)",
    "insertText": "RHIConvertToGpuVendorId(uint32 VendorId)"
  },
  {
    "label": "IsGeometryPipelineShaderFrequency()",
    "kind": "Method",
    "detail": "Function (default : break ; } return EGpuVendorId::Unknown ; } bool)",
    "insertText": "IsGeometryPipelineShaderFrequency(EShaderFrequency Frequency)"
  }
]