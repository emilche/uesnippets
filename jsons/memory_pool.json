[
  {
    "label": "pool_base",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "pool_base"
  },
  {
    "label": "memory_pool_allocator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "memory_pool_allocator"
  },
  {
    "label": "rebind",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "rebind"
  },
  {
    "label": "memory_pool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "memory_pool"
  },
  {
    "label": "fixed_pool",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "fixed_pool"
  },
  {
    "label": "__TBBMALLOC_ASSERT()",
    "kind": "Method",
    "detail": "Function (# ifndef __TBB_memory_pool_H # define __TBB_memory_pool_H # if ! TBB_PREVIEW_MEMORY_POOL # error Set TBB_PREVIEW_MEMORY_POOL to include memory_pool . h # endif # include \" scalable_allocator . h \" # include<new> # include<stdexcept> # include<string> # if __TBB_ALLOCATOR_CONSTRUCT_VARIADIC # include<utility> # endif # if __TBB_EXTRA_DEBUG # define __TBBMALLOC_ASSERT ASSERT # else # define)",
    "insertText": "__TBBMALLOC_ASSERT(a,b) ((void)0)"
  },
  {
    "label": "recycle()",
    "kind": "Method",
    "detail": "Function (namespace interface6 { namespace internal { class pool_base : tbb::internal::no_copy { public : void)",
    "insertText": "recycle()"
  },
  {
    "label": "pool_reset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pool_reset(my_pool)"
  },
  {
    "label": "malloc()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "malloc(size_t size)"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "free(void* ptr)"
  },
  {
    "label": "pool_free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pool_free(my_pool, ptr)"
  },
  {
    "label": "realloc()",
    "kind": "Method",
    "detail": "Function (} void*)",
    "insertText": "realloc(void* ptr, size_t size)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (} protected : void)",
    "insertText": "destroy()"
  },
  {
    "label": "pool_destroy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pool_destroy(my_pool)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} rml::MemoryPool* my_pool ; } ; } # if _MSC_VER&& !)",
    "insertText": "defined(__INTEL_COMPILER) #pragma warning (push) #pragma warning (disable: 4100)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (protected : typedef P pool_type ; pool_type* my_pool ; template<U,R> class memory_pool_allocator ; template<V,U,R> bool)",
    "insertText": "operator(const memory_pool_allocator<V,R>& a, const memory_pool_allocator<U,R>& b)"
  },
  {
    "label": "memory_pool_allocator()",
    "kind": "Method",
    "detail": "Function (public : typedef tbb::internal::allocator_type<T>::value_type value_type ; typedef value_type* pointer ; typedef const value_type* const_pointer ; typedef value_type& reference ; typedef const value_type& const_reference ; typedef size_t size_type ; typedef ptrdiff_t difference_type ; template<U> struct rebind { typedef memory_pool_allocator<U,P> other ; } ;)",
    "insertText": "memory_pool_allocator(pool_type &pool) throw() : my_pool(&pool)"
  },
  {
    "label": "memory_pool_allocator()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "memory_pool_allocator(const memory_pool_allocator& src) throw() : my_pool(src.my_pool)"
  },
  {
    "label": "memory_pool_allocator()",
    "kind": "Method",
    "detail": "Function (} template<U>)",
    "insertText": "memory_pool_allocator(const memory_pool_allocator<U,P>& src) throw() : my_pool(src.my_pool)"
  },
  {
    "label": "address()",
    "kind": "Method",
    "detail": "Function (} pointer)",
    "insertText": "address(reference x)"
  },
  {
    "label": "pointer()",
    "kind": "Method",
    "detail": "Function (pointer p = static_cast<)",
    "insertText": "pointer(my_pool->malloc( n*sizeof(value_type) ))"
  },
  {
    "label": "free()",
    "kind": "Method",
    "detail": "Function (my_pool ->)",
    "insertText": "free(p)"
  },
  {
    "label": "max_size()",
    "kind": "Method",
    "detail": "Function (} size_type)",
    "insertText": "max_size() const throw()"
  },
  {
    "label": "size_type()",
    "kind": "Method",
    "detail": "Function (size_type max = static_cast<)",
    "insertText": "size_type(-1) / sizeof (value_type)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} # if __TBB_ALLOCATOR_CONSTRUCT_VARIADIC template<U,. . . Args> void)",
    "insertText": "construct(U *p, Args&&... args)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void *)p) U(std::forward<Args>(args)...)"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} # else # if __TBB_CPP11_RVALUE_REF_PRESENT void)",
    "insertText": "construct(pointer p, value_type&& value)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)(p)) value_type(std::move(value))"
  },
  {
    "label": "construct()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "construct(pointer p, const value_type& value)"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "new((void*)(p)) value_type(value)"
  },
  {
    "label": "destroy()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "destroy(pointer p)"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (p -> ~)",
    "insertText": "value_type()"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # if _MSC_VER&& !)",
    "insertText": "defined(__INTEL_COMPILER) #pragma warning (pop)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ; template<T,U,P> bool)",
    "insertText": "operator(const memory_pool_allocator<T,P>& a, const memory_pool_allocator<U,P>& b)"
  },
  {
    "label": "deallocate_request()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "deallocate_request(intptr_t pool_id, void*, size_t raw_bytes)"
  },
  {
    "label": "memory_pool()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "memory_pool(const Alloc &src = Alloc())"
  },
  {
    "label": "memory_pool()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "memory_pool()"
  },
  {
    "label": "allocate_request()",
    "kind": "Method",
    "detail": "Function (} } ; class fixed_pool : public internal::pool_base { void* my_buffer ; size_t my_size ; void*)",
    "insertText": "allocate_request(intptr_t pool_id, size_t & bytes)"
  },
  {
    "label": "fixed_pool()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "fixed_pool(void *buf, size_t size)"
  },
  {
    "label": "fixed_pool()",
    "kind": "Method",
    "detail": "Function (~)",
    "insertText": "fixed_pool()"
  },
  {
    "label": "memory_pool()",
    "kind": "Method",
    "detail": "Function (} } ; template<Alloc> memory_pool<Alloc)",
    "insertText": "memory_pool(const Alloc &src) : my_alloc(src)"
  },
  {
    "label": "args()",
    "kind": "Method",
    "detail": "Function (rml::MemPoolPolicy)",
    "insertText": "args(allocate_request, deallocate_request, sizeof(typename Alloc::value_type))"
  },
  {
    "label": "pool_create_v1()",
    "kind": "Method",
    "detail": "Function (rml::MemPoolError res =)",
    "insertText": "pool_create_v1(intptr_t(this), &args, &my_pool)"
  },
  {
    "label": "Alloc()",
    "kind": "Method",
    "detail": "Function (memory_pool<Alloc>& self =* reinterpret_cast<memory_pool<)",
    "insertText": "Alloc(pool_id)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (const size_t unit_size =)",
    "insertText": "sizeof(typename Alloc::value_type)"
  },
  {
    "label": "__TBBMALLOC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBBMALLOC_ASSERT(0 == bytes%unit_size, NULL)"
  },
  {
    "label": "allocate()",
    "kind": "Method",
    "detail": "Function (void* ptr ; __TBB_TRY { ptr = self . my_alloc .)",
    "insertText": "allocate(bytes/unit_size)"
  },
  {
    "label": "__TBB_CATCH()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "__TBB_CATCH(...)"
  },
  {
    "label": "__TBBMALLOC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBBMALLOC_ASSERT(0 == raw_bytes%unit_size, NULL)"
  },
  {
    "label": "deallocate()",
    "kind": "Method",
    "detail": "Function (self . my_alloc .)",
    "insertText": "deallocate(static_cast<typename Alloc::value_type*>(raw_ptr), raw_bytes/unit_size)"
  },
  {
    "label": "args()",
    "kind": "Method",
    "detail": "Function (rml::MemPoolPolicy)",
    "insertText": "args(allocate_request, 0, size, true)"
  },
  {
    "label": "fixed_pool()",
    "kind": "Method",
    "detail": "Function (fixed_pool& self =* reinterpret_cast<)",
    "insertText": "fixed_pool(pool_id)"
  },
  {
    "label": "__TBBMALLOC_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__TBBMALLOC_ASSERT(0 != self.my_size, \"The buffer must not be used twice.\")"
  }
]