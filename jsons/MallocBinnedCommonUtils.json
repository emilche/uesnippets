[
  {
    "label": "FNoAllocScopeCycleCounter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FNoAllocScopeCycleCounter"
  },
  {
    "label": "TGlobalRecycler",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TGlobalRecycler"
  },
  {
    "label": "FBundlePointer",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "FBundlePointer"
  },
  {
    "label": "FMallocBinnedCommonUtils",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FMallocBinnedCommonUtils"
  },
  {
    "label": "AllocType",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AllocType"
  },
  {
    "label": "FNoAllocScopeCycleCounter()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" CoreTypes . h \" # include \" Async / TaskGraphInterfaces . h \" # include \" HAL / MallocBinnedCommon . h \" # include \" Misc / App . h \" # include \" Stats / Stats . h \" # include \" FramePro / FrameProProfiler . h \" # if FRAMEPRO_ENABLED class FNoAllocScopeCycleCounter { public :)",
    "insertText": "FNoAllocScopeCycleCounter(const ANSICHAR* InStatString)"
  },
  {
    "label": "PushEvent()",
    "kind": "Method",
    "detail": "Function (StatString = InStatString ;)",
    "insertText": "PushEvent(StatString)"
  },
  {
    "label": "FNoAllocScopeCycleCounter()",
    "kind": "Method",
    "detail": "Function (} } ~)",
    "insertText": "FNoAllocScopeCycleCounter()"
  },
  {
    "label": "PopEvent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "PopEvent(StatString)"
  },
  {
    "label": "NOALLOC_SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (} } private : const ANSICHAR* StatString = nullptr ; } ; # define)",
    "insertText": "NOALLOC_SCOPE_CYCLE_COUNTER(Stat) FNoAllocScopeCycleCounter NoAllocCycleCounter_##Stat(#Stat) #else # define NOALLOC_SCOPE_CYCLE_COUNTER(Stat)"
  },
  {
    "label": "PushBundle()",
    "kind": "Method",
    "detail": "Function (template<int NumSmallPools> struct TGlobalRecycler { bool)",
    "insertText": "PushBundle(uint32 InPoolIndex, FMallocBinnedCommonBase::FBundleNode* InBundle)"
  },
  {
    "label": "uint32()",
    "kind": "Method",
    "detail": "Function (const uint32 NumCachedBundles = FMath::Min<)",
    "insertText": "uint32(GMallocBinnedMaxBundlesBeforeRecycle, UE_DEFAULT_GMallocBinnedMaxBundlesBeforeRecycle)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (FMallocBinnedCommonBase::FBundleNode* Result = Bundles [ InPoolIndex ] . FreeBundles [ Slot ] ;)",
    "insertText": "if(Result)"
  },
  {
    "label": "FBundlePointer()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBundlePointer()"
  },
  {
    "label": "FBundleNode()",
    "kind": "Method",
    "detail": "Function (DefaultConstructItems<)",
    "insertText": "FBundleNode(FreeBundles, UE_DEFAULT_GMallocBinnedMaxBundlesBeforeRecycle)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } ;)",
    "insertText": "static_assert(sizeof(FBundlePointer) == PLATFORM_CACHE_LINE_SIZE, \"FBundlePointer should be the same size as a cache line\")"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alignas(PLATFORM_CACHE_LINE_SIZE)"
  },
  {
    "label": "TrimThreadFreeBlockLists()",
    "kind": "Method",
    "detail": "Function (} ; } class FMallocBinnedCommonUtils { public : template<class AllocType> void)",
    "insertText": "TrimThreadFreeBlockLists(AllocType& Allocator, typename AllocType::FPerThreadFreeBlockLists* FreeBlockLists)"
  },
  {
    "label": "TRACE_CPUPROFILER_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_CPUPROFILER_EVENT_SCOPE(FMallocBinnedCommonUtils::TrimThreadFreeBlockLists)"
  },
  {
    "label": "PopBundles()",
    "kind": "Method",
    "detail": "Function (AllocType::FBundleNode* Bundles = FreeBlockLists ->)",
    "insertText": "PopBundles(PoolIndex)"
  },
  {
    "label": "FreeBundles()",
    "kind": "Method",
    "detail": "Function (Allocator .)",
    "insertText": "FreeBundles(Bundles, PoolIndex)"
  },
  {
    "label": "FlushCurrentThreadCache()",
    "kind": "Method",
    "detail": "Function (} } } } template<class AllocType> void)",
    "insertText": "FlushCurrentThreadCache(AllocType& Allocator, bool bNewEpochOnly = false)"
  },
  {
    "label": "TRACE_CPUPROFILER_EVENT_SCOPE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TRACE_CPUPROFILER_EVENT_SCOPE(FMallocBinnedCommonUtils::FlushCurrentThreadCache)"
  },
  {
    "label": "QUICK_SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "QUICK_SCOPE_CYCLE_COUNTER(STAT_FMallocBinnedCommonUtils_FlushCurrentThreadCache)"
  },
  {
    "label": "Seconds()",
    "kind": "Method",
    "detail": "Function (const double StartTimeInner =)",
    "insertText": "Seconds()"
  },
  {
    "label": "TrimThreadFreeBlockLists()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TrimThreadFreeBlockLists(Allocator, Lists)"
  },
  {
    "label": "Trim()",
    "kind": "Method",
    "detail": "Function (} } } } template<class AllocType> void)",
    "insertText": "Trim(AllocType& Allocator)"
  },
  {
    "label": "fetch_add()",
    "kind": "Method",
    "detail": "Function (Allocator . MemoryTrimEpoch .)",
    "insertText": "fetch_add(1, std::memory_order_relaxed)"
  },
  {
    "label": "QUICK_SCOPE_CYCLE_COUNTER()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "QUICK_SCOPE_CYCLE_COUNTER(STAT_FMallocBinnedCommonUtils_Trim)"
  },
  {
    "label": "FreeBlockLock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "FreeBlockLock(&AllocType::GetFreeBlockListsRegistrationMutex())"
  },
  {
    "label": "TrimThreadFreeBlockLists()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "TrimThreadFreeBlockLists(Allocator, BlockList)"
  },
  {
    "label": "Unlock()",
    "kind": "Method",
    "detail": "Function (} BlockList ->)",
    "insertText": "Unlock()"
  },
  {
    "label": "void()",
    "kind": "Method",
    "detail": "Function (} } } TFunction<)",
    "insertText": "void(ENamedThreads::Type CurrentThread)> Broadcast = [&Allocator](ENamedThreads::Type MyThread)"
  },
  {
    "label": "FlushCurrentThreadCache()",
    "kind": "Method",
    "detail": "Function (const bool bNewEpochOnly = true ;)",
    "insertText": "FlushCurrentThreadCache(Allocator, bNewEpochOnly)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} ;)",
    "insertText": "if(PLATFORM_DESKTOP)"
  },
  {
    "label": "BroadcastSlow_OnlyUseForSpecialPurposes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BroadcastSlow_OnlyUseForSpecialPurposes(false, false, Broadcast)"
  },
  {
    "label": "BroadcastSlow_OnlyUseForSpecialPurposes()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "BroadcastSlow_OnlyUseForSpecialPurposes(FPlatformProcess::SupportsMultithreading() && FApp::ShouldUseThreadingForPerformance(), false, Broadcast)"
  }
]