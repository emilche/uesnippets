[
  {
    "label": "FModelMesh",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FModelMesh"
  },
  {
    "label": "FTopologicalFace",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTopologicalFace"
  },
  {
    "label": "FTopologyReport",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FTopologyReport"
  },
  {
    "label": "CADKERNEL_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CADKERNEL_API"
  },
  {
    "label": "FCoreTechBridge",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FCoreTechBridge"
  },
  {
    "label": "GetKioId()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Core / CADKernelArchive . h \" # include \" Core / CADEntity . h \" # include \" Core / HaveStates . h \" # include \" Core / Types . h \" namespace UE::CADKernel { class FModelMesh ; class FTopologicalFace ; class FTopologyReport ; class FTopologicalEntity : public FEntity { class FCoreTechBridge ; protected : FIdent CtKioId = 0 ; public : FIdent)",
    "insertText": "GetKioId()"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "GetInfo()",
    "kind": "Method",
    "detail": "Function (Ar<<CtKioId ; } # ifdef CADKERNEL_DEV FInfoEntity&)",
    "insertText": "GetInfo(FInfoEntity&)"
  },
  {
    "label": "IsApplyCriteria()",
    "kind": "Method",
    "detail": "Function (# endif const bool)",
    "insertText": "IsApplyCriteria()"
  },
  {
    "label": "SetApplyCriteriaMarker()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetApplyCriteriaMarker()"
  },
  {
    "label": "ResetApplyCriteria()",
    "kind": "Method",
    "detail": "Function (States | = EHaveStates::IsApplyCriteria ; } void)",
    "insertText": "ResetApplyCriteria()"
  },
  {
    "label": "IsNotMeshable()",
    "kind": "Method",
    "detail": "Function (States& = ~ EHaveStates::IsApplyCriteria ; } bool)",
    "insertText": "IsNotMeshable()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (EHaveStates MeshedOrDeletedOrDegenerated = EHaveStates::IsMeshed | EHaveStates::Degenerated | EHaveStates::IsDeleted ;)",
    "insertText": "return((States & MeshedOrDeletedOrDegenerated) != EHaveStates::None)"
  },
  {
    "label": "IsMeshable()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsMeshable()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (EHaveStates MeshedOrDeletedOrDegenerated = EHaveStates::IsMeshed | EHaveStates::Degenerated | EHaveStates::IsDeleted ;)",
    "insertText": "return((States & MeshedOrDeletedOrDegenerated) == EHaveStates::None)"
  },
  {
    "label": "IsPreMeshed()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsPreMeshed()"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (EHaveStates MeshedOrPreMeshed = EHaveStates::IsMeshed | EHaveStates::IsPreMeshed ;)",
    "insertText": "return((States & MeshedOrPreMeshed) != EHaveStates::None)"
  },
  {
    "label": "IsMeshed()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "IsMeshed()"
  },
  {
    "label": "SetPreMeshedMarker()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetPreMeshedMarker()"
  },
  {
    "label": "SetMeshedMarker()",
    "kind": "Method",
    "detail": "Function (States | = EHaveStates::IsPreMeshed ; } void)",
    "insertText": "SetMeshedMarker()"
  },
  {
    "label": "ResetPreMeshed()",
    "kind": "Method",
    "detail": "Function (EHaveStates MeshedOrPreMeshed = EHaveStates::IsMeshed | EHaveStates::IsPreMeshed ; States | = MeshedOrPreMeshed ; } void)",
    "insertText": "ResetPreMeshed()"
  }
]