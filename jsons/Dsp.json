[
  {
    "label": "FSinOsc2DRotation",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FSinOsc2DRotation"
  },
  {
    "label": "FExponentialEase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FExponentialEase"
  },
  {
    "label": "FLinearEase",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FLinearEase"
  },
  {
    "label": "TParams",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TParams"
  },
  {
    "label": "DisjointedArrayView",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "DisjointedArrayView"
  },
  {
    "label": "TCircularAudioBuffer",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TCircularAudioBuffer"
  },
  {
    "label": "TGetPower",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "TGetPower"
  },
  {
    "label": "TSample",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSample"
  },
  {
    "label": "TSampleRef",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TSampleRef"
  },
  {
    "label": "CHECK_SAMPLE()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Containers / Array . h \" # include \" DSP / AlignedBuffer . h \" # include \" HAL / Platform . h \" # include \" HAL / UnrealMemory . h \" # include \" Logging / LogMacros . h \" # include \" Math / UnrealMath . h \" # include \" Misc / ScopeLock . h \" # include \" SignalProcessingModule . h \" # include \" Templates / IsFloatingPoint . h \" # include \" Templates / IsIntegral . h \" # include \" Templates / IsSigned . h \" # if 0 # define)",
    "insertText": "CHECK_SAMPLE(VALUE) #define CHECK_SAMPLE2(VALUE) #else #define CHECK_SAMPLE(VALUE) Audio::CheckSample(VALUE) #define CHECK_SAMPLE2(VALUE) Audio::CheckSample(VALUE)"
  },
  {
    "label": "CheckSample()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CheckSample(float InSample, float Threshold = 0.001f)"
  },
  {
    "label": "ConvertToLinear()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "ConvertToLinear(const float InDecibels)"
  },
  {
    "label": "GetGainFromVelocity()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetGainFromVelocity(const float InVelocity)"
  },
  {
    "label": "FastSin()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "FastSin(const float X)"
  },
  {
    "label": "FastSin2()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "FastSin2(const float X)"
  },
  {
    "label": "FastSin()",
    "kind": "Method",
    "detail": "Function (float X2 =)",
    "insertText": "FastSin(X)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (X2 = 0 . 2 2 5)",
    "insertText": "f(X2* FMath::Abs(X2) - X2)"
  },
  {
    "label": "Abs()",
    "kind": "Method",
    "detail": "Function (const float AbsX =)",
    "insertText": "Abs(X)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (const float Numerator = 1 6 . 0 f*)",
    "insertText": "X(UE_PI - AbsX)"
  },
  {
    "label": "AbsX()",
    "kind": "Method",
    "detail": "Function (const float Denominator = 5 . 0 f* UE_PI* UE_PI - 4 . 0 f*)",
    "insertText": "AbsX(UE_PI - AbsX)"
  },
  {
    "label": "FSinOsc2DRotation()",
    "kind": "Method",
    "detail": "Function (LastPhasePerSample = - 1 ; LastPhase = InStartingPhaseRadians ; })",
    "insertText": "FSinOsc2DRotation(FSinOsc2DRotation const& other)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(this, &other, sizeof(FSinOsc2DRotation))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FSinOsc2DRotation&)",
    "insertText": "operator(FSinOsc2DRotation const& other)"
  },
  {
    "label": "PhasePerSample()",
    "kind": "Method",
    "detail": "Function (const float)",
    "insertText": "PhasePerSample(ClampedFrequency * (2 * UE_PI)) / (SampleRate)"
  },
  {
    "label": "Cos()",
    "kind": "Method",
    "detail": "Function (float QuadDx =)",
    "insertText": "Cos(PhasePerSample * 4)"
  },
  {
    "label": "Sin()",
    "kind": "Method",
    "detail": "Function (float QuadDy =)",
    "insertText": "Sin(PhasePerSample * 4)"
  },
  {
    "label": "VectorLoadFloat1()",
    "kind": "Method",
    "detail": "Function (QuadDxVec =)",
    "insertText": "VectorLoadFloat1(&QuadDx)"
  },
  {
    "label": "VectorLoadFloat1()",
    "kind": "Method",
    "detail": "Function (QuadDyVec =)",
    "insertText": "VectorLoadFloat1(&QuadDy)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (LastPhasePerSample = PhasePerSample ; } float* Write = Buffer ;)",
    "insertText": "while(BufferSampleCount)"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alignas(16)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (PhaseSource [ 0 ] = LastPhase + 0* PhasePerSample ; PhaseSource [ 1 ] = LastPhase + 1* PhasePerSample ; PhaseSource [ 2 ] = LastPhase + 2* PhasePerSample ; PhaseSource [ 3 ] = LastPhase + 3* PhasePerSample ; VectorRegister4Float PhaseVec =)",
    "insertText": "VectorLoad(PhaseSource)"
  },
  {
    "label": "VectorSinCos()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float XVector,YVector ;)",
    "insertText": "VectorSinCos(&YVector, &XVector, &PhaseVec)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float LocalDxVec = QuadDxVec ; VectorRegister4Float LocalDyVec = QuadDyVec ; int32 BlockSampleCount = BufferSampleCount ;)",
    "insertText": "if(BlockSampleCount > 480)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int32 Block4 = BlockSampleCount>> 2 ;)",
    "insertText": "while(Block4)"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStore(YVector, Write)"
  },
  {
    "label": "VectorSubtract()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float NewX =)",
    "insertText": "VectorSubtract(VectorMultiply(LocalDxVec, XVector), VectorMultiply(LocalDyVec, YVector))"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float NewY =)",
    "insertText": "VectorAdd(VectorMultiply(LocalDyVec, XVector), VectorMultiply(LocalDxVec, YVector))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (XVector = NewX ; YVector = NewY ; Write + = 4 ; Block4 - - ; } int32 SIMD_MASK = 0 x00000003 ;)",
    "insertText": "if(BlockSampleCount & SIMD_MASK)"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStore(YVector, YFloats)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int32 Remn = BlockSampleCount& SIMD_MASK ;)",
    "insertText": "for(int32 i = 0; i < Remn; i++)"
  },
  {
    "label": "LastPhase()",
    "kind": "Method",
    "detail": "Function (Write [ i ] = YFloats [ i ] ; } } float PhaseInRadians =)",
    "insertText": "LastPhase(float)"
  },
  {
    "label": "FloorToFloat()",
    "kind": "Method",
    "detail": "Function (PhaseInRadians - =)",
    "insertText": "FloorToFloat(PhaseInRadians / (2 * UE_PI)) * (2 * UE_PI)"
  },
  {
    "label": "FastTanh()",
    "kind": "Method",
    "detail": "Function (LastPhase = PhaseInRadians ; BufferSampleCount - = BlockSampleCount ; } } private : VectorRegister4Float QuadDxVec,QuadDyVec ; float LastPhasePerSample ; float LastPhase ; float Dx,Dy ; } ; float)",
    "insertText": "FastTanh(float X)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (const float InputSquared = X* X ; return)",
    "insertText": "X(27.0f + InputSquared) / (27.0f + 9.0f * InputSquared)"
  },
  {
    "label": "FastTan()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "FastTan(float X)"
  },
  {
    "label": "X()",
    "kind": "Method",
    "detail": "Function (const float Num =)",
    "insertText": "X(1.0f - FMath::Abs(X) / UE_PI)"
  },
  {
    "label": "Den()",
    "kind": "Method",
    "detail": "Function (const float)",
    "insertText": "Den(X + 0.5f * UE_PI) * (1.0f - FMath::Abs(X + 0.5f * UE_PI) / UE_PI)"
  },
  {
    "label": "VectorSetFloat1()",
    "kind": "Method",
    "detail": "Function (const VectorRegister4Float Half =)",
    "insertText": "VectorSetFloat1(0.5f)"
  },
  {
    "label": "VectorLoad()",
    "kind": "Method",
    "detail": "Function (VectorRegister4Float V =)",
    "insertText": "VectorLoad(InAlignedBuffer)"
  },
  {
    "label": "VectorMultiply()",
    "kind": "Method",
    "detail": "Function (V =)",
    "insertText": "VectorMultiply(V, Half)"
  },
  {
    "label": "VectorAdd()",
    "kind": "Method",
    "detail": "Function (V =)",
    "insertText": "VectorAdd(V, Half)"
  },
  {
    "label": "VectorStore()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "VectorStore(V, InAlignedBuffer)"
  },
  {
    "label": "GetFrequencyFromMidi()",
    "kind": "Method",
    "detail": "Function (} } float)",
    "insertText": "GetFrequencyFromMidi(const float InMidiNote)"
  },
  {
    "label": "GetLogFrequencyClamped()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetLogFrequencyClamped(const float InValue, const FVector2D& Domain, const FVector2D& Range)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InValue >= Domain.Y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(FMath::IsNaN(InValue))"
  },
  {
    "label": "RangeLog()",
    "kind": "Method",
    "detail": "Function (} const FVector2D)",
    "insertText": "RangeLog(FMath::Max(FMath::Loge(Range.X), UE_SMALL_NUMBER), FMath::Min(FMath::Loge(Range.Y), UE_BIG_NUMBER))"
  },
  {
    "label": "FreqLinear()",
    "kind": "Method",
    "detail": "Function (const float)",
    "insertText": "FreqLinear(float)FMath::GetMappedRangeValueUnclamped(Domain, RangeLog, (FVector2D::FReal)InValue)"
  },
  {
    "label": "GetLinearFrequencyClamped()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetLinearFrequencyClamped(const float InFrequencyValue, const FVector2D& Domain, const FVector2D& Range)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(InFrequencyValue >= Range.Y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(FMath::IsNaN(InFrequencyValue))"
  },
  {
    "label": "Loge()",
    "kind": "Method",
    "detail": "Function (const FVector2D::FReal FrequencyLog =)",
    "insertText": "Loge(InFrequencyValue)"
  },
  {
    "label": "GetMidiFromFrequency()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetMidiFromFrequency(const float InFrequency)"
  },
  {
    "label": "GetPitchScaleFromMIDINote()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetPitchScaleFromMIDINote(int32 BaseMidiNote, int32 TargetMidiNote)"
  },
  {
    "label": "GetFrequencyFromMidi()",
    "kind": "Method",
    "detail": "Function (const float BaseFrequency =)",
    "insertText": "GetFrequencyFromMidi(FMath::Clamp((float)BaseMidiNote, 0.0f, 127.0f))"
  },
  {
    "label": "Pow()",
    "kind": "Method",
    "detail": "Function (const float TargetFrequency = 4 4 0 . 0 f*)",
    "insertText": "Pow(2.0f, ((float)TargetMidiNote - 69.0f) / 12.0f)"
  },
  {
    "label": "GetFrequencyMultiplier()",
    "kind": "Method",
    "detail": "Function (const float PitchScale = TargetFrequency / BaseFrequency ; return PitchScale ; } float)",
    "insertText": "GetFrequencyMultiplier(const float InPitchSemitones)"
  },
  {
    "label": "GetSemitones()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetSemitones(const float InMultiplier)"
  },
  {
    "label": "Log2()",
    "kind": "Method",
    "detail": "Function (} return 1 2 . 0 f*)",
    "insertText": "Log2(InMultiplier)"
  },
  {
    "label": "GetStereoPan()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "GetStereoPan(const float InLinearPan, float& OutLeft, float& OutRight)"
  },
  {
    "label": "UE_PI()",
    "kind": "Method",
    "detail": "Function (const float LeftPhase = 0 . 5 f*)",
    "insertText": "UE_PI(0.5f * (InLinearPan + 1.0f) + 1.0f)"
  },
  {
    "label": "UE_PI()",
    "kind": "Method",
    "detail": "Function (const float RightPhase = 0 . 2 5 f*)",
    "insertText": "UE_PI(InLinearPan + 1.0f)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (OutLeft =)",
    "insertText": "Clamp(FastSin(LeftPhase), 0.0f, 1.0f)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (OutRight =)",
    "insertText": "Clamp(FastSin(RightPhase), 0.0f, 1.0f)"
  },
  {
    "label": "EncodeMidSide()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "EncodeMidSide(float& LeftChannel, float& RightChannel)"
  },
  {
    "label": "Temp()",
    "kind": "Method",
    "detail": "Function (const float)",
    "insertText": "Temp(LeftChannel - RightChannel)"
  },
  {
    "label": "LeftChannel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "LeftChannel(LeftChannel + RightChannel)"
  },
  {
    "label": "EncodeMidSide()",
    "kind": "Method",
    "detail": "Function (RightChannel = Temp ; } void)",
    "insertText": "EncodeMidSide(const FAlignedFloatBuffer& InLeftChannel, const FAlignedFloatBuffer& InRightChannel, FAlignedFloatBuffer& OutMidChannel, FAlignedFloatBuffer& OutSideChannel)"
  },
  {
    "label": "DecodeMidSide()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "DecodeMidSide(float& MidChannel, float& SideChannel)"
  },
  {
    "label": "Temp()",
    "kind": "Method",
    "detail": "Function (const float)",
    "insertText": "Temp(MidChannel - SideChannel)"
  },
  {
    "label": "MidChannel()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "MidChannel(MidChannel + SideChannel)"
  },
  {
    "label": "DecodeMidSide()",
    "kind": "Method",
    "detail": "Function (SideChannel = Temp ; } void)",
    "insertText": "DecodeMidSide(const FAlignedFloatBuffer& InMidChannel, const FAlignedFloatBuffer& InSideChannel, FAlignedFloatBuffer& OutLeftChannel, FAlignedFloatBuffer& OutRightChannel)"
  },
  {
    "label": "GetBandwidthFromQ()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "GetBandwidthFromQ(const float InQ)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const float Q =)",
    "insertText": "Max(UE_KINDA_SMALL_NUMBER, InQ)"
  },
  {
    "label": "f()",
    "kind": "Method",
    "detail": "Function (const float Arg = 0 . 5)",
    "insertText": "f((1.0f / Q) + FMath::Sqrt(1.0f / (Q*Q) + 4.0f))"
  },
  {
    "label": "LogX()",
    "kind": "Method",
    "detail": "Function (const float OutBandwidth = 2 . 0 f*)",
    "insertText": "LogX(2.0f, Arg)"
  },
  {
    "label": "Max()",
    "kind": "Method",
    "detail": "Function (const float InBandwidthClamped =)",
    "insertText": "Max(UE_KINDA_SMALL_NUMBER, InBandwidth)"
  },
  {
    "label": "Pow()",
    "kind": "Method",
    "detail": "Function (const float Temp =)",
    "insertText": "Pow(2.0f, InBandwidthClamped)"
  },
  {
    "label": "Sqrt()",
    "kind": "Method",
    "detail": "Function (const float OutQ =)",
    "insertText": "Sqrt(Temp) / (Temp - 1.0f)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float Denom = InValues [ 0 ] - 2 . f* InValues [ 1 ] + InValues [ 2 ] ;)",
    "insertText": "if(Denom >= 0.f)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (float Lagrangian = 1 . 0 f ; float Output = 0 . 0 f ; const int32 NumPoints = Points .)",
    "insertText": "Num()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Lagrangian = 1 . 0 f ;)",
    "insertText": "for(int32 j = 0; j < NumPoints; ++j)"
  },
  {
    "label": "UE_REAL_TO_FLOAT()",
    "kind": "Method",
    "detail": "Function (float Denom =)",
    "insertText": "UE_REAL_TO_FLOAT(Points[i].X - Points[j].X)"
  },
  {
    "label": "Lagrangian()",
    "kind": "Method",
    "detail": "Function (Denom = UE_SMALL_NUMBER ; })",
    "insertText": "Lagrangian(Alpha - UE_REAL_TO_FLOAT(Points[j].X))"
  },
  {
    "label": "UE_REAL_TO_FLOAT()",
    "kind": "Method",
    "detail": "Function (} } Output + = Lagrangian*)",
    "insertText": "UE_REAL_TO_FLOAT(Points[i].Y)"
  },
  {
    "label": "FExponentialEase()",
    "kind": "Method",
    "detail": "Function (} return Output ; } class FExponentialEase { public :)",
    "insertText": "FExponentialEase(float InInitValue = 0.0f, float InEaseFactor = 0.001f, float InThreshold = UE_KINDA_SMALL_NUMBER) : CurrentValue(InInitValue) , Threshold(InThreshold) , TargetValue(InInitValue) , EaseFactor(InEaseFactor) , OneMinusEase(1.0f - InEaseFactor) , EaseTimesTarget(EaseFactor * InInitValue)"
  },
  {
    "label": "Init()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Init(float InInitValue, float InEaseFactor = 0.001f)"
  },
  {
    "label": "IsDone()",
    "kind": "Method",
    "detail": "Function (CurrentValue = InInitValue ; TargetValue = InInitValue ; EaseFactor = InEaseFactor ; OneMinusEase = 1 . 0 f - EaseFactor ; EaseTimesTarget = TargetValue* EaseFactor ; } bool)",
    "insertText": "IsDone()"
  },
  {
    "label": "GetNextValue()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "GetNextValue()"
  },
  {
    "label": "PeekCurrentValue()",
    "kind": "Method",
    "detail": "Function (CurrentValue = OneMinusEase* CurrentValue + EaseTimesTarget ; - - NumTicksToJumpAhead ; } return CurrentValue ; } float)",
    "insertText": "PeekCurrentValue()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (EaseFactor = InEaseFactor ; OneMinusEase = 1 . 0 f - EaseFactor ; } void)",
    "insertText": "operator(const float& InValue)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetValue(InValue)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetValue(const float InValue, const bool bIsInit = false)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (TargetValue = InValue ; EaseTimesTarget = EaseFactor* TargetValue ;)",
    "insertText": "if(bIsInit)"
  },
  {
    "label": "GetFactorForTau()",
    "kind": "Method",
    "detail": "Function (CurrentValue = TargetValue ; } } float)",
    "insertText": "GetFactorForTau(float InTau, float InSampleRate)"
  },
  {
    "label": "FLinearEase()",
    "kind": "Method",
    "detail": "Function (} private : float CurrentValue ; float Threshold ; float TargetValue ; float EaseFactor ; float OneMinusEase ; float EaseTimesTarget ; } ; class FLinearEase { public :)",
    "insertText": "FLinearEase() : StartValue(0.0f) , CurrentValue(0.0f) , DeltaValue(0.0f) , SampleRate(44100.0f) , DurationTicks(0) , DefaultDurationTicks(0) , CurrentTick(0) , bIsInit(true)"
  },
  {
    "label": "FLinearEase()",
    "kind": "Method",
    "detail": "Function (} ~)",
    "insertText": "FLinearEase()"
  },
  {
    "label": "SetValueRange()",
    "kind": "Method",
    "detail": "Function (SampleRate = InSampleRate ; bIsInit = true ; } void)",
    "insertText": "SetValueRange(const float Start, const float End, const float InTimeSec)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (StartValue = Start ; CurrentValue = Start ;)",
    "insertText": "SetValue(End, InTimeSec)"
  },
  {
    "label": "GetNextValue()",
    "kind": "Method",
    "detail": "Function (+ + CurrentTick ; return CurrentValue ; } float)",
    "insertText": "GetNextValue(int32 NumTicksToJumpAhead)"
  },
  {
    "label": "DeltaValue()",
    "kind": "Method",
    "detail": "Function (CurrentValue =)",
    "insertText": "DeltaValue(float)CurrentTick / (float)"
  },
  {
    "label": "SetValue()",
    "kind": "Method",
    "detail": "Function (CurrentValue = InValue ; } else { DurationTicks = DurationTicks - CurrentTick ; CurrentTick = 0 ; DeltaValue = InValue - CurrentValue ; StartValue = CurrentValue ; } } void)",
    "insertText": "SetValue(const float InValue, float InTimeSec = 0.0f)"
  },
  {
    "label": "DurationTicks()",
    "kind": "Method",
    "detail": "Function (bIsInit = false ; DurationTicks = 0 ; } else {)",
    "insertText": "DurationTicks(int32)(SampleRate * InTimeSec)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} CurrentTick = 0 ;)",
    "insertText": "if(DurationTicks == 0)"
  },
  {
    "label": "TParams()",
    "kind": "Method",
    "detail": "Function (CurrentValue = InValue ; } else { DeltaValue = InValue - CurrentValue ; StartValue = CurrentValue ; } } private : float StartValue ; float CurrentValue ; float DeltaValue ; float SampleRate ; int32 DurationTicks ; int32 DefaultDurationTicks ; int32 CurrentTick ; bool bIsInit ; } ; template<T> class TParams { public :)",
    "insertText": "TParams() : bChanged(false)"
  },
  {
    "label": "SetParams()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetParams(const T& InParams)"
  },
  {
    "label": "Lock()",
    "kind": "Method",
    "detail": "Function (FScopeLock)",
    "insertText": "Lock(&CritSect)"
  },
  {
    "label": "GetParams()",
    "kind": "Method",
    "detail": "Function (bChanged = true ; CurrentParams = InParams ; } bool)",
    "insertText": "GetParams(T* OutParamsCopy)"
  },
  {
    "label": "CopyParams()",
    "kind": "Method",
    "detail": "Function (bChanged = false ;* OutParamsCopy = CurrentParams ; return true ; } return false ; } void)",
    "insertText": "CopyParams(T& OutParamsCopy)"
  },
  {
    "label": "DisjointedArrayView()",
    "kind": "Method",
    "detail": "Function (OutParamsCopy = CurrentParams ; } bool bChanged ; T CurrentParams ; FCriticalSection CritSect ; } ; template<SampleType> struct DisjointedArrayView {)",
    "insertText": "DisjointedArrayView(TArrayView<SampleType> && InFirstBuffer, TArrayView<SampleType> && InSecondBuffer) : FirstBuffer(MoveTemp(InFirstBuffer)) , SecondBuffer(MoveTemp(InSecondBuffer))"
  },
  {
    "label": "SplitOtherToMatch()",
    "kind": "Method",
    "detail": "Function (} template<OtherSampleType> DisjointedArrayView<OtherSampleType>)",
    "insertText": "SplitOtherToMatch(OtherSampleType* Other, int32 InNum)"
  },
  {
    "label": "FirstNum()",
    "kind": "Method",
    "detail": "Function (const int32 FirstChunkNum =)",
    "insertText": "FirstNum()"
  },
  {
    "label": "CopyIntoBuffer()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "CopyIntoBuffer(SampleType* InDestination, int32 InNumSamples)"
  },
  {
    "label": "FirstNum()",
    "kind": "Method",
    "detail": "Function (const int32 FirstCopySize =)",
    "insertText": "FirstNum() * sizeof(SampleType)"
  },
  {
    "label": "SecondNum()",
    "kind": "Method",
    "detail": "Function (const int32 SecondCopySize =)",
    "insertText": "SecondNum() * sizeof(SampleType)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(InDestination, FirstBuffer.GetData(), FirstCopySize)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(InDestination + FirstNum(), SecondBuffer.GetData(), SecondCopySize)"
  },
  {
    "label": "SecondNum()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "SecondNum()"
  },
  {
    "label": "TCircularAudioBuffer()",
    "kind": "Method",
    "detail": "Function (} TArrayView<SampleType> FirstBuffer ; TArrayView<SampleType> SecondBuffer ; } ; template<SampleType,size_t Alignment = 1 6> class TCircularAudioBuffer { private : TArray<SampleType,TAlignedHeapAllocator<Alignment>> InternalBuffer ; uint32 Capacity ; FThreadSafeCounter ReadCounter ; FThreadSafeCounter WriteCounter ; public :)",
    "insertText": "TCircularAudioBuffer()"
  },
  {
    "label": "SetCapacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCapacity(0)"
  },
  {
    "label": "TCircularAudioBuffer()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TCircularAudioBuffer(const TCircularAudioBuffer<SampleType, Alignment>& InOther)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (* this = InOther ; } TCircularAudioBuffer&)",
    "insertText": "operator(const TCircularAudioBuffer<SampleType, Alignment>& InOther)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (InternalBuffer = InOther . InternalBuffer ; Capacity = InOther . Capacity ; ReadCounter .)",
    "insertText": "Set(InOther.ReadCounter.GetValue())"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (WriteCounter .)",
    "insertText": "Set(InOther.WriteCounter.GetValue())"
  },
  {
    "label": "SetCapacity()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetCapacity(InCapacity)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reset(uint32 InCapacity = 0)"
  },
  {
    "label": "Empty()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Empty()"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (ReadCounter .)",
    "insertText": "Set(0)"
  },
  {
    "label": "SetCapacity()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "SetCapacity(uint32 InCapacity)"
  },
  {
    "label": "Reset()",
    "kind": "Method",
    "detail": "Function (InternalBuffer .)",
    "insertText": "Reset()"
  },
  {
    "label": "AddZeroed()",
    "kind": "Method",
    "detail": "Function (InternalBuffer .)",
    "insertText": "AddZeroed(Capacity)"
  },
  {
    "label": "Reserve()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "Reserve(uint32 InMinimumCapacity, bool bRetainExistingSamples)"
  },
  {
    "label": "checkf()",
    "kind": "Method",
    "detail": "Function (uint32 NewCapacity = InMinimumCapacity + 1 ;)",
    "insertText": "checkf(NewCapacity < (uint32)TNumericLimits<int32>::Max(), TEXT(\"Max capacity overflow. Requested %d. Maximum allowed %d\"), NewCapacity, TNumericLimits<int32>::Max())"
  },
  {
    "label": "AddZeroed()",
    "kind": "Method",
    "detail": "Function (uint32 NumToAdd = NewCapacity - Capacity ; InternalBuffer .)",
    "insertText": "AddZeroed(NumToAdd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Capacity = NewCapacity ; })",
    "insertText": "if(!bRetainExistingSamples)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (} } int32)",
    "insertText": "Push(TArrayView<const SampleType> InBuffer)"
  },
  {
    "label": "Push()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Push(const SampleType* InBuffer, uint32 NumSamples)"
  },
  {
    "label": "GetData()",
    "kind": "Method",
    "detail": "Function (SampleType* DestBuffer = InternalBuffer .)",
    "insertText": "GetData()"
  },
  {
    "label": "GetValue()",
    "kind": "Method",
    "detail": "Function (const uint32 ReadIndex = ReadCounter .)",
    "insertText": "GetValue()"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (int32 NumToCopy = FMath::Min<)",
    "insertText": "int32(NumSamples, Remainder())"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (const int32 NumToWrite = FMath::Min<)",
    "insertText": "int32(NumToCopy, Capacity - WriteIndex)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(&DestBuffer[WriteIndex], InBuffer, NumToWrite * sizeof(SampleType))"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(&DestBuffer[0], &InBuffer[NumToWrite], (NumToCopy - NumToWrite) * sizeof(SampleType))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (WriteCounter .)",
    "insertText": "Set((WriteIndex + NumToCopy) % Capacity)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (int32 NumToZeroEnd = FMath::Min<)",
    "insertText": "int32(NumSamplesOfZeros, Remainder())"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (const int32 NumToZeroBegin = FMath::Min<)",
    "insertText": "int32(NumToZeroEnd, Capacity - WriteIndex)"
  },
  {
    "label": "Memzero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memzero(&DestBuffer[WriteIndex], NumToZeroBegin * sizeof(SampleType))"
  },
  {
    "label": "Memzero()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memzero(&DestBuffer[0], (NumToZeroEnd - NumToZeroBegin) * sizeof(SampleType))"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (WriteCounter .)",
    "insertText": "Set((WriteIndex + NumToZeroEnd) % Capacity)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (DestBuffer [ WriteIndex ] = InElement ; WriteCounter .)",
    "insertText": "Set((WriteIndex + 1) % Capacity)"
  },
  {
    "label": "MoveTemp()",
    "kind": "Method",
    "detail": "Function (DestBuffer [ WriteIndex ] =)",
    "insertText": "MoveTemp(InElement)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (int32 NumToCopy = FMath::Min<)",
    "insertText": "int32(NumSamples, Num())"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (const int32 NumRead = FMath::Min<)",
    "insertText": "int32(NumToCopy, Capacity - ReadIndex)"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(OutBuffer, &SrcBuffer[ReadIndex], NumRead * sizeof(SampleType))"
  },
  {
    "label": "Memcpy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Memcpy(&OutBuffer[NumRead], &SrcBuffer[0], (NumToCopy - NumRead) * sizeof(SampleType))"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (const int32 NumRead = FMath::Min<)",
    "insertText": "int32(NumToView, Capacity - ReadIndex)"
  },
  {
    "label": "Peek()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Peek(SampleType& OutElement)"
  },
  {
    "label": "Pop()",
    "kind": "Method",
    "detail": "Function (OutElement = SrcBuffer [ ReadIndex ] ; return true ; } } int32)",
    "insertText": "Pop(SampleType* OutBuffer, uint32 NumSamples)"
  },
  {
    "label": "Peek()",
    "kind": "Method",
    "detail": "Function (int32 NumSamplesRead =)",
    "insertText": "Peek(OutBuffer, NumSamples)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (ReadCounter .)",
    "insertText": "Set((ReadCounter.GetValue() + NumSamplesRead) % Capacity)"
  },
  {
    "label": "PeekInPlace()",
    "kind": "Method",
    "detail": "Function (DisjointedArrayView<const SampleType> View =)",
    "insertText": "PeekInPlace(NumSamples)"
  },
  {
    "label": "MoveTempIfPossible()",
    "kind": "Method",
    "detail": "Function (SampleType PoppedValue =)",
    "insertText": "MoveTempIfPossible(InternalBuffer[ReadIndex])"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (ReadCounter .)",
    "insertText": "Set((ReadCounter.GetValue() + 1) % Capacity)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (WriteCounter .)",
    "insertText": "Set((ReadCounter.GetValue() + NumSamples) % Capacity)"
  },
  {
    "label": "ReadCounterNum()",
    "kind": "Method",
    "detail": "Function (} else { int64)",
    "insertText": "ReadCounterNum((int32)WriteCounter.GetValue()) - ((int32) NumSamples)"
  },
  {
    "label": "Set()",
    "kind": "Method",
    "detail": "Function (ReadCounterNum = Capacity + ReadCounterNum ; } ReadCounter .)",
    "insertText": "Set(ReadCounterNum)"
  },
  {
    "label": "static_assert()",
    "kind": "Method",
    "detail": "Function (} } ; template<int Base,int Exp> struct TGetPower {)",
    "insertText": "static_assert(Exp >= 0, \"TGetPower only supports positive exponents.\")"
  },
  {
    "label": "Q()",
    "kind": "Method",
    "detail": "Function (const int64 Value = Base* TGetPower<Base,Exp - 1>::Value ; } ; template<int Base> struct TGetPower<Base,0> { const int64 Value = 1 ; } ; template<SampleType,uint32)",
    "insertText": "Q(sizeof(SampleType) * 8 - 1)"
  },
  {
    "label": "CheckValidityOfSampleType()",
    "kind": "Method",
    "detail": "Function (SampleType Sample ; template<SampleTypeToCheck> void)",
    "insertText": "CheckValidityOfSampleType()"
  },
  {
    "label": "bIsTypeValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bIsTypeValid(TIsFloatingPoint<SampleTypeToCheck>::Value || TIsIntegral<SampleTypeToCheck>::Value)"
  },
  {
    "label": "CheckValidityOfQ()",
    "kind": "Method",
    "detail": "Function (} template<SampleTypeToCheck,uint32 QToCheck> void)",
    "insertText": "CheckValidityOfQ()"
  },
  {
    "label": "bIsTypeValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bIsTypeValid(TIsFloatingPoint<SampleTypeToCheck>::Value || ((sizeof(SampleTypeToCheck) * 8) > QToCheck))"
  },
  {
    "label": "TGetPower()",
    "kind": "Method",
    "detail": "Function (} float QFactor = TGetPower<2,Q>::Value - 1 ; float MaxValue =)",
    "insertText": "TGetPower(sizeof(SampleType) * 8 - Q)"
  },
  {
    "label": "Value()",
    "kind": "Method",
    "detail": "Function (float MinValue = ! ! TIsSigned<SampleType)",
    "insertText": "Value(-1.0f * MaxValue)"
  },
  {
    "label": "TSample()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TSample(SampleType& InSample) : Sample(InSample)"
  },
  {
    "label": "AsFloat()",
    "kind": "Method",
    "detail": "Function (} template<ReturnType = float> ReturnType)",
    "insertText": "AsFloat()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(TIsIntegral<SampleType>::Value)"
  },
  {
    "label": "checkNoEntry()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "checkNoEntry()"
  },
  {
    "label": "ReturnQ()",
    "kind": "Method",
    "detail": "Function (} } template<ReturnType,uint32)",
    "insertText": "ReturnQ(sizeof(SampleType) * 8 - 1)> ReturnType AsFixedPrecisionInt()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(Q < ReturnQ)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else { return Sample ; } } else)",
    "insertText": "if(TIsFloatingPoint<SampleType>::Value)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (float ReturnQFactor = TGetPower<2,ReturnQ>::Value - 1 ;)",
    "insertText": "return(ReturnType)(Sample * ReturnQFactor)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } template<OtherSampleType> TSample<SampleType,Q>&)",
    "insertText": "operator(const OtherSampleType InSample)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (Sample = InSample ; return* this ; } else)",
    "insertText": "if(TIsIntegral<OtherSampleType>::Value && TIsFloatingPoint<SampleType>::Value)"
  },
  {
    "label": "Sample()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Sample((SampleType)InSample)"
  },
  {
    "label": "SampleType()",
    "kind": "Method",
    "detail": "Function (Sample = static_cast<)",
    "insertText": "SampleType(InSample * QFactor)"
  },
  {
    "label": "FloatRHS()",
    "kind": "Method",
    "detail": "Function (SampleType)",
    "insertText": "FloatRHS((SampleType)RHS)"
  },
  {
    "label": "FloatLHS()",
    "kind": "Method",
    "detail": "Function (OtherSampleType)",
    "insertText": "FloatLHS((OtherSampleType)LHS.Sample)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (OtherSampleType Result =)",
    "insertText": "Clamp(FloatLHS * RHS, MinValue, MaxValue)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(TIsIntegral<OtherSampleType>::Value)"
  },
  {
    "label": "FloatLHS()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "FloatLHS((float)LHS.Sample)"
  },
  {
    "label": "FloatRHS()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "FloatRHS((float)RHS)"
  },
  {
    "label": "Clamp()",
    "kind": "Method",
    "detail": "Function (float Result =)",
    "insertText": "Clamp(FloatLHS * FloatRHS, MinValue, MaxValue)"
  },
  {
    "label": "bIsTypeValid()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "bIsTypeValid(TIsFloatingPoint<SampleTypeToCheck>::Value || (sizeof(SampleTypeToCheck) * 8) > QToCheck)"
  },
  {
    "label": "TSampleRef()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "TSampleRef(SampleType& InSample) : Sample(InSample)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (SampleType ReturnQFactor = TGetPower<2,ReturnQ>::Value - 1 ;)",
    "insertText": "return(ReturnType) (Sample * ReturnQFactor)"
  },
  {
    "label": "Sample()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Sample(SampleType)(InSample * QFactor)"
  }
]