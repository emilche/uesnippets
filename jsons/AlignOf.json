[
  {
    "label": "AlignmentCalcImpl",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AlignmentCalcImpl"
  },
  {
    "label": "AlignOf",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AlignOf"
  },
  {
    "label": "AlignedCharArray",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AlignedCharArray"
  },
  {
    "label": "AlignerImpl",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "AlignerImpl"
  },
  {
    "label": "AlignedCharArrayUnion",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "AlignedCharArrayUnion"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef LLVM_SUPPORT_ALIGNOF_H # define LLVM_SUPPORT_ALIGNOF_H # include \" llvm / Support / Compiler . h \" # include<cstddef> namespace llvm { template<T> struct AlignmentCalcImpl { char x ; # if)",
    "insertText": "defined(_MSC_VER) #pragma warning(suppress : 4324)"
  },
  {
    "label": "AlignmentCalcImpl()",
    "kind": "Method",
    "detail": "Function (private :)",
    "insertText": "AlignmentCalcImpl()"
  },
  {
    "label": "int()",
    "kind": "Method",
    "detail": "Function (} } ; template<T> struct AlignOf { # ifndef _MSC_VER unsigned Alignment = static_cast<unsigned)",
    "insertText": "int(sizeof(AlignmentCalcImpl<T>) - sizeof(T))"
  },
  {
    "label": "alignOf()",
    "kind": "Method",
    "detail": "Function (# endif enum { Alignment_GreaterEqual_2Bytes = Alignment> = 2 ? 1 : 0 } ; enum { Alignment_GreaterEqual_4Bytes = Alignment> = 4 ? 1 : 0 } ; enum { Alignment_GreaterEqual_8Bytes = Alignment> = 8 ? 1 : 0 } ; enum { Alignment_GreaterEqual_16Bytes = Alignment> = 1 6 ? 1 : 0 } ; enum { Alignment_LessEqual_2Bytes = Alignment<= 2 ? 1 : 0 } ; enum { Alignment_LessEqual_4Bytes = Alignment<= 4 ? 1 : 0 } ; enum { Alignment_LessEqual_8Bytes = Alignment<= 8 ? 1 : 0 } ; enum { Alignment_LessEqual_16Bytes = Alignment<= 1 6 ? 1 : 0 } ; } ; # ifndef _MSC_VER template<T> unsigned AlignOf<T>::Alignment ; # endif template<T> unsigned)",
    "insertText": "alignOf()"
  },
  {
    "label": "alignas()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alignas(Alignment)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} ; # elif)",
    "insertText": "defined(__GNUC__) || defined(__IBM_ATTRIBUTES)"
  },
  {
    "label": "LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(x)"
  },
  {
    "label": "__attribute__()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "__attribute__((aligned(x)))"
  },
  {
    "label": "LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT()",
    "kind": "Method",
    "detail": "Function (\\ } ;)",
    "insertText": "LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(1) LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(2) LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(4) LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(8) LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(16) LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(32) LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(64) LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(128)"
  },
  {
    "label": "__declspec()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "__declspec(align(x))"
  },
  {
    "label": "LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT()",
    "kind": "Method",
    "detail": "Function (\\ } ;)",
    "insertText": "LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(16) LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(32) LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(64) LLVM_ALIGNEDCHARARRAY_TEMPLATE_ALIGNMENT(128)"
  },
  {
    "label": "AlignerImpl()",
    "kind": "Method",
    "detail": "Function (template<T1,T2 = char,T3 = char,T4 = char,T5 = char,T6 = char,T7 = char,T8 = char,T9 = char,T10 = char> class AlignerImpl { T1 t1 ; T2 t2 ; T3 t3 ; T4 t4 ; T5 t5 ; T6 t6 ; T7 t7 ; T8 t8 ; T9 t9 ; T10 t10 ;)",
    "insertText": "AlignerImpl()"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} ; template<T1,T2 = char,T3 = char,T4 = char,T5 = char,T6 = char,T7 = char,T8 = char,T9 = char,T10 = char> union SizerImpl { char arr1 [)",
    "insertText": "sizeof(T1)], arr2[sizeof(T2)], arr3[sizeof(T3)], arr4[sizeof(T4)], arr5[sizeof(T5)], arr6[sizeof(T6)], arr7[sizeof(T7)], arr8[sizeof(T8)], arr9[sizeof(T9)], arr10[sizeof(T10)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (} ; } template<T1,T2 = char,T3 = char,T4 = char,T5 = char,T6 = char,T7 = char,T8 = char,T9 = char,T10 = char> struct AlignedCharArrayUnion : llvm::AlignedCharArray<AlignOf<detail::AlignerImpl<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>>::Alignment,)",
    "insertText": "sizeof(detail::SizerImpl<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>)"
  }
]