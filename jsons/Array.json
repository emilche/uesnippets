[
  {
    "label": "T",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "T"
  },
  {
    "label": "ST_DLL_LINK",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ST_DLL_LINK"
  },
  {
    "label": "CompareFunctor",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CompareFunctor"
  },
  {
    "label": "CDefaultArraySort",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CDefaultArraySort"
  },
  {
    "label": "CReverseArraySort",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CReverseArraySort"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Core / ExportBegin . h \" # include<cstdlib> # include<cassert> # include<typeinfo> # ifndef SPEEDTREE_NO_ALLOCATORS # include \" Core / Memory . h \" # endif # if)",
    "insertText": "defined(__GNUC__) || defined(__psp2__) #include <string.h> #else #include <cstring> #endif #ifdef ST_SETS_PACKING_INTERNALLY #pragma pack(push, 4)"
  },
  {
    "label": "CArray()",
    "kind": "Method",
    "detail": "Function (template<class T,bool bUseCustomAllocator = true> class ST_DLL_LINK CArray { public :)",
    "insertText": "CArray()"
  },
  {
    "label": "CArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CArray(size_t uiSize, const T& tDefault = T( ))"
  },
  {
    "label": "CArray()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "CArray(const CArray& cCopy)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear(void)"
  },
  {
    "label": "empty()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "empty(void)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "size(void)"
  },
  {
    "label": "capacity()",
    "kind": "Method",
    "detail": "Function (size_t)",
    "insertText": "capacity(void)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "resize(size_t uiSize)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "resize(size_t uiSize, const T& tDefault)"
  },
  {
    "label": "reserve()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "reserve(size_t uiSize)"
  },
  {
    "label": "push_back()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "push_back(const T& tNew)"
  },
  {
    "label": "pop_back()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "pop_back(void)"
  },
  {
    "label": "clip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clip(void)"
  },
  {
    "label": "erase_all()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "erase_all(const T& tErase)"
  },
  {
    "label": "front()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "front(void)"
  },
  {
    "label": "back()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "back(void)"
  },
  {
    "label": "at()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "at(size_t uiIndex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (T&)",
    "insertText": "operator(size_t uiIndex)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (CArray&)",
    "insertText": "operator(const CArray& cRight)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (template<class CompareFunctor> void)",
    "insertText": "sort(const CompareFunctor& Compare, bool bMemorySwap = false)"
  },
  {
    "label": "sort()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sort(bool bMemorySwap = false)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (typedef T* iterator ; typedef T const* const_iterator ; iterator)",
    "insertText": "begin(void)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "end(void)"
  },
  {
    "label": "erase()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "erase(iterator iterWhere)"
  },
  {
    "label": "insert()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "insert(iterator iterWhere, const T& tData)"
  },
  {
    "label": "lower()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "lower(const T& tData)"
  },
  {
    "label": "higher()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "higher(const T& tData)"
  },
  {
    "label": "lower_and_higher()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "lower_and_higher(const T& tData, iterator& iterLower, iterator& iterHigher)"
  },
  {
    "label": "insert_sorted()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "insert_sorted(const T& tData)"
  },
  {
    "label": "insert_sorted_unique()",
    "kind": "Method",
    "detail": "Function (iterator)",
    "insertText": "insert_sorted_unique(const T& tData)"
  },
  {
    "label": "SetExternalMemory()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetExternalMemory(unsigned char* pMemory, size_t uiSize)"
  },
  {
    "label": "SetHeapDescription()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "SetHeapDescription(const char* pDesc)"
  },
  {
    "label": "Allocate()",
    "kind": "Method",
    "detail": "Function (protected : T*)",
    "insertText": "Allocate(size_t uiSize)"
  },
  {
    "label": "Deallocate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Deallocate(T* pData)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (T* m_pData ; protected : size_t m_uiSize ; size_t m_uiDataSize ; const char* m_pHeapDesc ; bool m_bExternalMemory ; } ; class CDefaultArraySort { public : template<class T> bool)",
    "insertText": "operator() (const T& tLeft, const T& tRight)"
  }
]