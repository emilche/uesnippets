[
  {
    "label": "_mesa_glsl_parse_state",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "_mesa_glsl_parse_state"
  },
  {
    "label": "YYLTYPE",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "YYLTYPE"
  },
  {
    "label": "ast_node",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_node"
  },
  {
    "label": "ast_operators",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ast_operators"
  },
  {
    "label": "ast_expression",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_expression"
  },
  {
    "label": "ast_type_specifier",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_type_specifier"
  },
  {
    "label": "ast_expression_bin",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_expression_bin"
  },
  {
    "label": "ast_function_expression",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_function_expression"
  },
  {
    "label": "ast_initializer_list_expression",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_initializer_list_expression"
  },
  {
    "label": "ast_compound_statement",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_compound_statement"
  },
  {
    "label": "ast_declaration",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_declaration"
  },
  {
    "label": "ast_type_qualifier",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "ast_type_qualifier"
  },
  {
    "label": "ast_struct_specifier",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_struct_specifier"
  },
  {
    "label": "ast_cbuffer_declaration",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_cbuffer_declaration"
  },
  {
    "label": "glsl_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "glsl_type"
  },
  {
    "label": "ast_fully_specified_type",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_fully_specified_type"
  },
  {
    "label": "ast_declarator_list",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_declarator_list"
  },
  {
    "label": "ast_parameter_declarator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_parameter_declarator"
  },
  {
    "label": "ast_function",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_function"
  },
  {
    "label": "ir_function_signature",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_function_signature"
  },
  {
    "label": "ast_function_definition",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_function_definition"
  },
  {
    "label": "ast_expression_statement",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_expression_statement"
  },
  {
    "label": "ast_case_label",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_case_label"
  },
  {
    "label": "ast_case_label_list",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_case_label_list"
  },
  {
    "label": "ast_case_statement",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_case_statement"
  },
  {
    "label": "ast_case_statement_list",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_case_statement_list"
  },
  {
    "label": "ast_switch_body",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_switch_body"
  },
  {
    "label": "ast_selection_statement",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_selection_statement"
  },
  {
    "label": "ast_switch_statement",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_switch_statement"
  },
  {
    "label": "ast_iteration_statement",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_iteration_statement"
  },
  {
    "label": "ast_iteration_modes",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ast_iteration_modes"
  },
  {
    "label": "ir_loop",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ir_loop"
  },
  {
    "label": "ast_jump_statement",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_jump_statement"
  },
  {
    "label": "ast_jump_modes",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "ast_jump_modes"
  },
  {
    "label": "ast_attribute",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_attribute"
  },
  {
    "label": "ast_attribute_arg",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ast_attribute_arg"
  },
  {
    "label": "new()",
    "kind": "Method",
    "detail": "Function (# pragma once # ifndef AST_H # define AST_H # include \" cclist . h \" # include \" glsl_parser_extras . h \" struct _mesa_glsl_parse_state ; struct YYLTYPE ; class ast_node { public : void* operator)",
    "insertText": "new(size_t size, void *ctx)"
  },
  {
    "label": "rzalloc_size()",
    "kind": "Method",
    "detail": "Function (void* node ; node =)",
    "insertText": "rzalloc_size(ctx, size)"
  },
  {
    "label": "ralloc_free()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ralloc_free(table)"
  },
  {
    "label": "print()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "print(void)"
  },
  {
    "label": "hir()",
    "kind": "Method",
    "detail": "Function (ir_rvalue*)",
    "insertText": "hir(exec_list *instructions, struct _mesa_glsl_parse_state *state)"
  },
  {
    "label": "get_location()",
    "kind": "Method",
    "detail": "Function (struct YYLTYPE)",
    "insertText": "get_location(void)"
  },
  {
    "label": "set_location()",
    "kind": "Method",
    "detail": "Function (struct YYLTYPE locp ; locp . source_file = this -> location . source_file ; locp . first_line = this -> location . line ; locp . first_column = this -> location . column ; locp . last_line = locp . first_line ; locp . last_column = locp . first_column ; return locp ; } void)",
    "insertText": "set_location(const struct YYLTYPE &locp)"
  },
  {
    "label": "print_attributes()",
    "kind": "Method",
    "detail": "Function (this -> location . source_file = locp . source_file ; this -> location . line = locp . first_line ; this -> location . column = locp . first_column ; } void)",
    "insertText": "print_attributes()"
  },
  {
    "label": "GetSourceLocation()",
    "kind": "Method",
    "detail": "Function (struct { const char* source_file ; unsigned line ; unsigned column ; } location ; SSourceLocation)",
    "insertText": "GetSourceLocation(const _mesa_glsl_parse_state* State)"
  },
  {
    "label": "source_file()",
    "kind": "Method",
    "detail": "Function (SSourceLocation Location ; Location . SourceFile = location . source_file ? location .)",
    "insertText": "source_file(State->current_source_file ? State->current_source_file : State->base_source_file)"
  },
  {
    "label": "ast_node()",
    "kind": "Method",
    "detail": "Function (Location . Line = location . line ; Location . Column = location . column ; return Location ; } exec_list attributes ; exec_node link ; protected :)",
    "insertText": "ast_node(void)"
  },
  {
    "label": "ast_expression()",
    "kind": "Method",
    "detail": "Function (} ; enum ast_operators { ast_assign,ast_plus,ast_neg,ast_add,ast_sub,ast_mul,ast_div,ast_mod,ast_lshift,ast_rshift,ast_less,ast_greater,ast_lequal,ast_gequal,ast_equal,ast_nequal,ast_bit_and,ast_bit_xor,ast_bit_or,ast_bit_not,ast_logic_and,ast_logic_xor,ast_logic_or,ast_logic_not,ast_mul_assign,ast_div_assign,ast_mod_assign,ast_add_assign,ast_sub_assign,ast_ls_assign,ast_rs_assign,ast_and_assign,ast_xor_assign,ast_or_assign,ast_conditional,ast_pre_inc,ast_pre_dec,ast_post_inc,ast_post_dec,ast_field_selection,ast_array_index,ast_function_call,ast_initializer_list,ast_identifier,ast_int_constant,ast_uint_constant,ast_float_constant,ast_bool_constant,ast_sequence,ast_type_cast,} ; class ast_expression : public ast_node { public :)",
    "insertText": "ast_expression(int oper, ast_expression *, ast_expression *, ast_expression *)"
  },
  {
    "label": "ast_expression()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ast_expression(const char *identifier) : oper(ast_identifier)"
  },
  {
    "label": "operator_string()",
    "kind": "Method",
    "detail": "Function (subexpressions [ 0 ] = NULL ; subexpressions [ 1 ] = NULL ; subexpressions [ 2 ] = NULL ; primary_expression . identifier = identifier ; this -> non_lvalue_description = NULL ; } const char*)",
    "insertText": "operator_string(enum ast_operators op)"
  },
  {
    "label": "initializer_hir()",
    "kind": "Method",
    "detail": "Function (ir_rvalue*)",
    "insertText": "initializer_hir(exec_list *instructions, _mesa_glsl_parse_state *state, const glsl_type *initializer_type)"
  },
  {
    "label": "ast_expression_bin()",
    "kind": "Method",
    "detail": "Function (enum ast_operators oper ; ast_expression* subexpressions [ 3 ] ; union { const char* identifier ; class ast_type_specifier* type_specifier ; int int_constant ; float float_constant ; unsigned uint_constant ; int bool_constant ; } primary_expression ; exec_list expressions ; const char* non_lvalue_description ; } ; class ast_expression_bin : public ast_expression { public :)",
    "insertText": "ast_expression_bin(int oper, ast_expression *, ast_expression *)"
  },
  {
    "label": "ast_function_expression()",
    "kind": "Method",
    "detail": "Function (} ; class ast_function_expression : public ast_expression { public :)",
    "insertText": "ast_function_expression(ast_expression *callee) : ast_expression(ast_function_call, callee, NULL, NULL), cons(false)"
  },
  {
    "label": "ast_function_expression()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ast_function_expression(class ast_type_specifier *type) : ast_expression(ast_function_call, (ast_expression *)type, NULL, NULL), cons(true)"
  },
  {
    "label": "is_constructor()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "is_constructor()"
  },
  {
    "label": "ast_initializer_list_expression()",
    "kind": "Method",
    "detail": "Function (private : bool cons ; } ; class ast_initializer_list_expression : public ast_expression { public :)",
    "insertText": "ast_initializer_list_expression() : ast_expression(ast_initializer_list, NULL, NULL, NULL)"
  },
  {
    "label": "hir()",
    "kind": "Method",
    "detail": "Function (} ir_rvalue*)",
    "insertText": "hir(exec_list *instructions, _mesa_glsl_parse_state *state)"
  },
  {
    "label": "AST_NUM_OPERATORS()",
    "kind": "Method",
    "detail": "Function (} ; # define)",
    "insertText": "AST_NUM_OPERATORS(ast_type_cast + 1)"
  },
  {
    "label": "ast_compound_statement()",
    "kind": "Method",
    "detail": "Function (public :)",
    "insertText": "ast_compound_statement(int new_scope, ast_node *statements)"
  },
  {
    "label": "ast_declaration()",
    "kind": "Method",
    "detail": "Function (int new_scope ; exec_list statements ; } ; class ast_declaration : public ast_node { public :)",
    "insertText": "ast_declaration(const char *identifier, int is_array, ast_expression *array_size, ast_expression *initializer)"
  },
  {
    "label": "has_interpolation()",
    "kind": "Method",
    "detail": "Function (const char* identifier ; const char* semantic ; int is_array ; int is_unsized_array ; ast_expression* array_size ; ast_expression* initializer ; } ; enum { ast_precision_none = 0,ast_precision_high,ast_precision_medium,ast_precision_low } ; struct ast_type_qualifier { union { struct { unsigned is_static : 1 ; unsigned invariant : 1 ; unsigned constant : 1 ; unsigned attribute : 1 ; unsigned varying : 1 ; unsigned in : 1 ; unsigned out : 1 ; unsigned centroid : 1 ; unsigned uniform : 1 ; unsigned smooth : 1 ; unsigned flat : 1 ; unsigned noperspective : 1 ; unsigned row_major : 1 ; unsigned column_major : 1 ; unsigned coherent : 1 ; unsigned shared : 1 ; unsigned precise : 1 ; unsigned origin_upper_left : 1 ; unsigned pixel_center_integer : 1 ; unsigned explicit_location : 1 ; unsigned depth_any : 1 ; unsigned depth_greater : 1 ; unsigned depth_less : 1 ; unsigned depth_unchanged : 1 ; unsigned gs_point : 1 ; unsigned gs_line : 1 ; unsigned gs_lineadj : 1 ; unsigned gs_triangle : 1 ; unsigned gs_triangleadj : 1 ; } q ; unsigned i ; } flags ; int location ; bool)",
    "insertText": "has_interpolation()"
  },
  {
    "label": "interpolation_string()",
    "kind": "Method",
    "detail": "Function (const char*)",
    "insertText": "interpolation_string()"
  },
  {
    "label": "ast_struct_specifier()",
    "kind": "Method",
    "detail": "Function (} ; class ast_struct_specifier : public ast_node { public :)",
    "insertText": "ast_struct_specifier(const char *identifier, ast_node *declarator_list)"
  },
  {
    "label": "ast_struct_specifier()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ast_struct_specifier(const char *identifier, const char *parent, ast_node *declarator_list)"
  },
  {
    "label": "ast_cbuffer_declaration()",
    "kind": "Method",
    "detail": "Function (const char* name ; const char* parent_name ; exec_list declarations ; } ; class ast_cbuffer_declaration : public ast_node { public :)",
    "insertText": "ast_cbuffer_declaration(const char *identifier, ast_node *declarator_list)"
  },
  {
    "label": "ast_type_specifier()",
    "kind": "Method",
    "detail": "Function (const char* name ; exec_list declarations ; } ; class ast_type_specifier : public ast_node { public :)",
    "insertText": "ast_type_specifier(const char *name) : type_name(name), inner_type(NULL), structure(NULL), texture_ms_num_samples(1), patch_size(0), is_array(false), is_unsized_array(0), array_size(NULL), is_precision_statement(false), precision(ast_precision_none)"
  },
  {
    "label": "ast_type_specifier()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ast_type_specifier(const char *name, const char *inner_type_name) : type_name(name), inner_type(inner_type_name), structure(NULL), texture_ms_num_samples(1), patch_size(0), is_array(false), is_unsized_array(0), array_size(NULL), is_precision_statement(false), precision(ast_precision_none)"
  },
  {
    "label": "ast_type_specifier()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ast_type_specifier(const char *name, ast_struct_specifier* inner_type) : type_name(name), inner_type(nullptr), structure(NULL), InnerStructure(inner_type), texture_ms_num_samples(1), patch_size(0), is_array(false), is_unsized_array(0), array_size(NULL), is_precision_statement(false), precision(ast_precision_none)"
  },
  {
    "label": "ast_type_specifier()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ast_type_specifier(ast_struct_specifier *s) : type_name(s->name), inner_type(NULL), structure(s), texture_ms_num_samples(1), patch_size(0), is_array(false), is_unsized_array(0), array_size(NULL), is_precision_statement(false), precision(ast_precision_none)"
  },
  {
    "label": "glsl_type()",
    "kind": "Method",
    "detail": "Function (} const struct glsl_type*)",
    "insertText": "glsl_type(const char **name, struct _mesa_glsl_parse_state *state)"
  },
  {
    "label": "hir()",
    "kind": "Method",
    "detail": "Function (ir_rvalue*)",
    "insertText": "hir(exec_list *, struct _mesa_glsl_parse_state *)"
  },
  {
    "label": "IsStructuredOrRWStructuredBuffer()",
    "kind": "Method",
    "detail": "Function (const char* type_name ; const char* inner_type ; ast_struct_specifier* structure ; ast_struct_specifier* InnerStructure = nullptr ; int texture_ms_num_samples ; int patch_size ; int is_array ; int is_unsized_array ; ast_expression* array_size ; bool is_precision_statement ; unsigned precision : 2 ; bool)",
    "insertText": "IsStructuredOrRWStructuredBuffer()"
  },
  {
    "label": "strcmp()",
    "kind": "Method",
    "detail": "Function (const bool bStructuredBuffer = !)",
    "insertText": "strcmp(this->type_name, \"StructuredBuffer\")"
  },
  {
    "label": "strcmp()",
    "kind": "Method",
    "detail": "Function (const bool bRWStructuredBuffer = !)",
    "insertText": "strcmp(this->type_name, \"RWStructuredBuffer\")"
  },
  {
    "label": "has_qualifiers()",
    "kind": "Method",
    "detail": "Function (bool)",
    "insertText": "has_qualifiers()"
  },
  {
    "label": "ast_declarator_list()",
    "kind": "Method",
    "detail": "Function (ast_type_qualifier qualifier ; ast_type_specifier* specifier ; } ; class ast_declarator_list : public ast_node { public :)",
    "insertText": "ast_declarator_list(ast_fully_specified_type *)"
  },
  {
    "label": "ast_parameter_declarator()",
    "kind": "Method",
    "detail": "Function (ast_fully_specified_type* type ; exec_list declarations ; int invariant ; } ; class ast_parameter_declarator : public ast_node { public :)",
    "insertText": "ast_parameter_declarator()"
  },
  {
    "label": "parameters_to_hir()",
    "kind": "Method",
    "detail": "Function (ast_fully_specified_type* type ; const char* identifier ; const char* semantic ; int is_array ; ast_expression* array_size ; ast_expression* default_value ; void)",
    "insertText": "parameters_to_hir(exec_list *ast_parameters, bool formal, exec_list *ir_parameters, unsigned *num_params, exec_list *ir_defaults, unsigned *num_defaults, struct _mesa_glsl_parse_state *state)"
  },
  {
    "label": "ast_function()",
    "kind": "Method",
    "detail": "Function (private : bool formal_parameter ; bool is_void ; } ; class ast_function : public ast_node { public :)",
    "insertText": "ast_function(void)"
  },
  {
    "label": "ast_expression_statement()",
    "kind": "Method",
    "detail": "Function (ast_fully_specified_type* return_type ; const char* identifier ; const char* return_semantic ; exec_list parameters ; private : bool is_definition ; class ir_function_signature* signature ; class ast_function_definition ; } ; class ast_expression_statement : public ast_node { public :)",
    "insertText": "ast_expression_statement(ast_expression *)"
  },
  {
    "label": "ast_case_label()",
    "kind": "Method",
    "detail": "Function (ast_expression* expression ; } ; class ast_case_label : public ast_node { public :)",
    "insertText": "ast_case_label(ast_expression *test_value)"
  },
  {
    "label": "ast_case_label_list()",
    "kind": "Method",
    "detail": "Function (ast_expression* test_value ; } ; class ast_case_label_list : public ast_node { public :)",
    "insertText": "ast_case_label_list(void)"
  },
  {
    "label": "ast_case_statement()",
    "kind": "Method",
    "detail": "Function (exec_list labels ; } ; class ast_case_statement : public ast_node { public :)",
    "insertText": "ast_case_statement(ast_case_label_list *labels)"
  },
  {
    "label": "ast_case_statement_list()",
    "kind": "Method",
    "detail": "Function (ast_case_label_list* labels ; exec_list stmts ; } ; class ast_case_statement_list : public ast_node { public :)",
    "insertText": "ast_case_statement_list(void)"
  },
  {
    "label": "sortlabels()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "sortlabels()"
  },
  {
    "label": "ast_switch_body()",
    "kind": "Method",
    "detail": "Function (exec_list cases ; } ; class ast_switch_body : public ast_node { public :)",
    "insertText": "ast_switch_body(ast_case_statement_list *stmts)"
  },
  {
    "label": "ast_selection_statement()",
    "kind": "Method",
    "detail": "Function (ast_case_statement_list* stmts ; } ; class ast_selection_statement : public ast_node { public :)",
    "insertText": "ast_selection_statement(ast_expression *condition, ast_node *then_statement, ast_node *else_statement)"
  },
  {
    "label": "ast_switch_statement()",
    "kind": "Method",
    "detail": "Function (ast_expression* condition ; ast_node* then_statement ; ast_node* else_statement ; } ; class ast_switch_statement : public ast_node { public :)",
    "insertText": "ast_switch_statement(ast_expression *test_expression, ast_node *body)"
  },
  {
    "label": "test_to_hir()",
    "kind": "Method",
    "detail": "Function (ast_expression* test_expression ; ast_node* body ; protected : void)",
    "insertText": "test_to_hir(exec_list *, struct _mesa_glsl_parse_state *)"
  },
  {
    "label": "ast_iteration_statement()",
    "kind": "Method",
    "detail": "Function (} ; class ast_iteration_statement : public ast_node { public :)",
    "insertText": "ast_iteration_statement(int mode, ast_node *init, ast_node *condition, ast_expression *rest_expression, ast_node *body)"
  },
  {
    "label": "condition_to_hir()",
    "kind": "Method",
    "detail": "Function (enum ast_iteration_modes { ast_for,ast_while,ast_do_while } mode ; ast_node* init_statement ; ast_node* condition ; ast_expression* rest_expression ; ast_node* body ; private : void)",
    "insertText": "condition_to_hir(class ir_loop *, struct _mesa_glsl_parse_state *)"
  },
  {
    "label": "ast_jump_statement()",
    "kind": "Method",
    "detail": "Function (} ; class ast_jump_statement : public ast_node { public :)",
    "insertText": "ast_jump_statement(int mode, ast_expression *return_value)"
  },
  {
    "label": "convert_attribute_args()",
    "kind": "Method",
    "detail": "Function (ast_function* prototype ; ast_compound_statement* body ; private : template<Type> bool)",
    "insertText": "convert_attribute_args(ast_attribute * attrib, Type* results, const int expected_arg_count, const char* expected_type, bool (glsl_type::*type_check)(void) const, struct _mesa_glsl_parse_state * state)"
  },
  {
    "label": "convert_enum_attribute_args()",
    "kind": "Method",
    "detail": "Function (template<T> void)",
    "insertText": "convert_enum_attribute_args(ast_attribute * attrib, T& result, const char** strings, const T* values, const size_t num_values, struct _mesa_glsl_parse_state * state)"
  },
  {
    "label": "ast_attribute_arg()",
    "kind": "Method",
    "detail": "Function (} ; class ast_attribute_arg : public ast_node { public :)",
    "insertText": "ast_attribute_arg(const char *arg) : is_string(true)"
  },
  {
    "label": "ast_attribute_arg()",
    "kind": "Method",
    "detail": "Function (argument . string_argument = arg ; })",
    "insertText": "ast_attribute_arg(ast_expression *exp) : is_string(false)"
  },
  {
    "label": "ast_attribute()",
    "kind": "Method",
    "detail": "Function (bool is_string ; union { const char* string_argument ; ast_expression* exp_argument ; } argument ; } ; class ast_attribute : public ast_node { public :)",
    "insertText": "ast_attribute(const char* name) : attribute_name(name)"
  },
  {
    "label": "_mesa_ast_to_hir()",
    "kind": "Method",
    "detail": "Function (const char* attribute_name ; exec_list arguments ; } ; void)",
    "insertText": "_mesa_ast_to_hir(exec_list *instructions, struct _mesa_glsl_parse_state *state)"
  },
  {
    "label": "_mesa_ast_print()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mesa_ast_print(struct _mesa_glsl_parse_state *state)"
  },
  {
    "label": "_mesa_ast_field_selection_to_hir()",
    "kind": "Method",
    "detail": "Function (ir_rvalue*)",
    "insertText": "_mesa_ast_field_selection_to_hir(const ast_expression *expr, exec_list *instructions, struct _mesa_glsl_parse_state *state)"
  },
  {
    "label": "emit_function()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "emit_function(_mesa_glsl_parse_state *state, ir_function *f)"
  },
  {
    "label": "convert_component()",
    "kind": "Method",
    "detail": "Function (ir_rvalue*)",
    "insertText": "convert_component(ir_rvalue *src, const glsl_type *desired_type)"
  }
]