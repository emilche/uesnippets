[
  {
    "label": "ALEMBIC_EXPORT",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ALEMBIC_EXPORT"
  },
  {
    "label": "TokenMap()",
    "kind": "Method",
    "detail": "Function (# ifndef Alembic_Util_TokenMap_h # define Alembic_Util_TokenMap_h # include<Alembic / Util / Export . h> # include<Alembic / Util / Exception . h> # include<Alembic / Util / Foundation . h> namespace Alembic { namespace Util { namespace ALEMBIC_VERSION_NS { class ALEMBIC_EXPORT TokenMap { public : typedef std::map<std::string,std::string> map_type ; typedef map_type::key_type key_type ; typedef std::string data_type ; typedef map_type::value_type value_type ; typedef map_type::iterator iterator ; typedef map_type::const_iterator const_iterator ; typedef map_type::reverse_iterator reverse_iterator ; typedef map_type::const_reverse_iterator const_reverse_iterator ; typedef map_type::reference reference ; typedef map_type::const_reference const_reference ;)",
    "insertText": "TokenMap()"
  },
  {
    "label": "TokenMap()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TokenMap(const std::string &config, char pairSeparator = ';', char assignSeparator = '=', bool unique = false, bool quiet = true)"
  },
  {
    "label": "setUnique()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setUnique(config, pairSeparator, assignSeparator, quiet)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "set(config, pairSeparator, assignSeparator)"
  },
  {
    "label": "set()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "set(const std::string &config, char pairSeparator = ';', char assignSeparator = '=')"
  },
  {
    "label": "setUnique()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setUnique(const std::string &config, char pairSeparator = ';', char assignSeparator = '=', bool quiet = true)"
  },
  {
    "label": "get()",
    "kind": "Method",
    "detail": "Function (std::string)",
    "insertText": "get(char pairSeparator = ';', char assignSeparator = '=', bool check = false)"
  },
  {
    "label": "clear()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "clear()"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (} size_t)",
    "insertText": "size()"
  },
  {
    "label": "tokenExists()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "tokenExists(const std::string &token)"
  },
  {
    "label": "value()",
    "kind": "Method",
    "detail": "Function (} std::string)",
    "insertText": "value(const std::string &token)"
  },
  {
    "label": "find()",
    "kind": "Method",
    "detail": "Function (const_iterator fiter = m_map .)",
    "insertText": "find(token)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} else { return \" \" ; } } std::string)",
    "insertText": "operator(const std::string &token)"
  },
  {
    "label": "setValue()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "setValue(const std::string &keyStr, const std::string &valueStr)"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (m_map [ keyStr ] = valueStr ; } iterator)",
    "insertText": "begin()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} iterator)",
    "insertText": "end()"
  },
  {
    "label": "rbegin()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rbegin()"
  },
  {
    "label": "rend()",
    "kind": "Method",
    "detail": "Function (} reverse_iterator)",
    "insertText": "rend()"
  },
  {
    "label": "exactMatch()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "exactMatch(const TokenMap &iOther)"
  }
]