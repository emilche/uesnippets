[
  {
    "label": "mv_bias()",
    "kind": "Method",
    "detail": "Function (# ifndef VPX_VP8_COMMON_FINDNEARMV_H_ # define VPX_VP8_COMMON_FINDNEARMV_H_ # include \" . / vpx_config . h \" # include \" mv . h \" # include \" blockd . h \" # include \" modecont . h \" # include \" treecoder . h \" # ifdef __cplusplus \" C \" { # endif void)",
    "insertText": "mv_bias(int refmb_ref_frame_sign_bias, int refframe, int_mv *mvp, const int *ref_frame_sign_bias)"
  },
  {
    "label": "LEFT_TOP_MARGIN()",
    "kind": "Method",
    "detail": "Function (mvp -> as_mv . row* = - 1 ; mvp -> as_mv . col* = - 1 ; } } # define)",
    "insertText": "LEFT_TOP_MARGIN(16 << 3) #define RIGHT_BOTTOM_MARGIN (16 << 3) static INLINE void vp8_clamp_mv2(int_mv *mv, const MACROBLOCKD *xd)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mv -> as_mv . col = xd -> mb_to_left_edge - LEFT_TOP_MARGIN ; } else)",
    "insertText": "if(mv->as_mv.col > xd->mb_to_right_edge + RIGHT_BOTTOM_MARGIN)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mv -> as_mv . col = xd -> mb_to_right_edge + RIGHT_BOTTOM_MARGIN ; })",
    "insertText": "if(mv->as_mv.row < (xd->mb_to_top_edge - LEFT_TOP_MARGIN))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mv -> as_mv . row = xd -> mb_to_top_edge - LEFT_TOP_MARGIN ; } else)",
    "insertText": "if(mv->as_mv.row > xd->mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN)"
  },
  {
    "label": "vp8_clamp_mv()",
    "kind": "Method",
    "detail": "Function (mv -> as_mv . row = xd -> mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN ; } } void)",
    "insertText": "vp8_clamp_mv(int_mv *mv, int mb_to_left_edge, int mb_to_right_edge, int mb_to_top_edge, int mb_to_bottom_edge)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (as_mv.col)",
    "insertText": "col(mv->as_mv.col < mb_to_left_edge)"
  },
  {
    "label": "col()",
    "kind": "Method",
    "detail": "Function (as_mv.col)",
    "insertText": "col(mv->as_mv.col > mb_to_right_edge)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (as_mv.row)",
    "insertText": "row(mv->as_mv.row < mb_to_top_edge)"
  },
  {
    "label": "row()",
    "kind": "Method",
    "detail": "Function (as_mv.row)",
    "insertText": "row(mv->as_mv.row > mb_to_bottom_edge)"
  },
  {
    "label": "vp8_check_mv_bounds()",
    "kind": "Method",
    "detail": "Function (} unsigned int)",
    "insertText": "vp8_check_mv_bounds(int_mv *mv, int mb_to_left_edge, int mb_to_right_edge, int mb_to_top_edge, int mb_to_bottom_edge)"
  },
  {
    "label": "need_to_clamp()",
    "kind": "Method",
    "detail": "Function (unsigned int need_to_clamp ;)",
    "insertText": "need_to_clamp(mv->as_mv.col < mb_to_left_edge)"
  },
  {
    "label": "need_to_clamp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "need_to_clamp(mv->as_mv.col > mb_to_right_edge)"
  },
  {
    "label": "need_to_clamp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "need_to_clamp(mv->as_mv.row < mb_to_top_edge)"
  },
  {
    "label": "need_to_clamp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "need_to_clamp(mv->as_mv.row > mb_to_bottom_edge)"
  },
  {
    "label": "vp8_find_near_mvs_bias()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "vp8_find_near_mvs_bias(MACROBLOCKD *xd, const MODE_INFO *here, int_mv mode_mv_sb[2][MB_MODE_COUNT], int_mv best_mv_sb[2], int cnt[4], int refframe, int *ref_frame_sign_bias)"
  },
  {
    "label": "vp8_mv_ref_probs()",
    "kind": "Method",
    "detail": "Function (vp8_prob*)",
    "insertText": "vp8_mv_ref_probs(vp8_prob p[VP8_MVREFS - 1], const int near_mv_ref_ct[4])"
  },
  {
    "label": "left_block_mv()",
    "kind": "Method",
    "detail": "Function (const unsigned char vp8_mbsplit_offset [ 4 ] [ 1 6 ] ; uint32_t)",
    "insertText": "left_block_mv(const MODE_INFO *cur_mb, int b)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mbmi.mv.as_int)",
    "insertText": "if(cur_mb->mbmi.mode != SPLITMV)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (mv.as_int)",
    "insertText": "return(cur_mb->bmi + b - 1)"
  },
  {
    "label": "above_block_mv()",
    "kind": "Method",
    "detail": "Function (} uint32_t)",
    "insertText": "above_block_mv(const MODE_INFO *cur_mb, int b, int mi_stride)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (mv.as_int)",
    "insertText": "return(cur_mb->bmi + (b - 4))"
  },
  {
    "label": "left_block_mode()",
    "kind": "Method",
    "detail": "Function (} B_PREDICTION_MODE)",
    "insertText": "left_block_mode(const MODE_INFO *cur_mb, int b)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (- - cur_mb ;)",
    "insertText": "switch(cur_mb->mbmi.mode)"
  },
  {
    "label": "above_block_mode()",
    "kind": "Method",
    "detail": "Function (} B_PREDICTION_MODE)",
    "insertText": "above_block_mode(const MODE_INFO *cur_mb, int b, int mi_stride)"
  }
]