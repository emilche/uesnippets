[
  {
    "label": "constructor_without_unaligned_array_assert",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "constructor_without_unaligned_array_assert"
  },
  {
    "label": "plain_array",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_array"
  },
  {
    "label": "plain_array_helper",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "plain_array_helper"
  },
  {
    "label": "DenseStorage",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "DenseStorage"
  },
  {
    "label": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN()",
    "kind": "Method",
    "detail": "Function (# ifndef EIGEN_MATRIXSTORAGE_H # define EIGEN_MATRIXSTORAGE_H # ifdef EIGEN_DENSE_STORAGE_CTOR_PLUGIN # define)",
    "insertText": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(X)"
  },
  {
    "label": "check_static_allocation_size()",
    "kind": "Method",
    "detail": "Function (namespace internal { struct constructor_without_unaligned_array_assert { } ; template<T,int Size> EIGEN_DEVICE_FUNC void)",
    "insertText": "check_static_allocation_size()"
  },
  {
    "label": "EIGEN_STATIC_ASSERT()",
    "kind": "Method",
    "detail": "Function (# if EIGEN_STACK_ALLOCATION_LIMIT)",
    "insertText": "EIGEN_STATIC_ASSERT(Size * sizeof(T) <= EIGEN_STACK_ALLOCATION_LIMIT, OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG)"
  },
  {
    "label": "Alignment()",
    "kind": "Method",
    "detail": "Function (# endif } template<T,int Size,int MatrixOrArrayOptions,int)",
    "insertText": "Alignment(MatrixOrArrayOptions&DontAlign)"
  },
  {
    "label": "plain_array()",
    "kind": "Method",
    "detail": "Function (T array [ Size ] ; EIGEN_DEVICE_FUNC)",
    "insertText": "plain_array()"
  },
  {
    "label": "plain_array()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "plain_array(constructor_without_unaligned_array_assert)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } ; # if)",
    "insertText": "defined(EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT) #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) #elif EIGEN_GNUC_AT_LEAST(4,7) template<typename PtrType> EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array)"
  },
  {
    "label": "EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT()",
    "kind": "Method",
    "detail": "Function (# else # define)",
    "insertText": "EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \\ eigen_assert((internal::UIntPtr(array) & (sizemask)) == 0 \\ && \"this assertion is explained here: \" \\ \"http: \" **** READ THIS WEB PAGE !!! ****\")"
  },
  {
    "label": "EIGEN_ALIGN_TO_BOUNDARY()",
    "kind": "Method",
    "detail": "Function (# endif template<T,int Size,int MatrixOrArrayOptions> struct plain_array<T,Size,MatrixOrArrayOptions,8> {)",
    "insertText": "EIGEN_ALIGN_TO_BOUNDARY(8)"
  },
  {
    "label": "EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(7)"
  },
  {
    "label": "EIGEN_ALIGN_TO_BOUNDARY()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,int Size,int MatrixOrArrayOptions> struct plain_array<T,Size,MatrixOrArrayOptions,1 6> {)",
    "insertText": "EIGEN_ALIGN_TO_BOUNDARY(16)"
  },
  {
    "label": "EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(15)"
  },
  {
    "label": "EIGEN_ALIGN_TO_BOUNDARY()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,int Size,int MatrixOrArrayOptions> struct plain_array<T,Size,MatrixOrArrayOptions,3 2> {)",
    "insertText": "EIGEN_ALIGN_TO_BOUNDARY(32)"
  },
  {
    "label": "EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(31)"
  },
  {
    "label": "EIGEN_ALIGN_TO_BOUNDARY()",
    "kind": "Method",
    "detail": "Function (} } ; template<T,int Size,int MatrixOrArrayOptions> struct plain_array<T,Size,MatrixOrArrayOptions,6 4> {)",
    "insertText": "EIGEN_ALIGN_TO_BOUNDARY(64)"
  },
  {
    "label": "EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(63)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (} } ; struct plain_array_helper { template<T,int Size,int MatrixOrArrayOptions,int Alignment> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "copy(const plain_array<T, Size, MatrixOrArrayOptions, Alignment>& src, const Eigen::Index size, plain_array<T, Size, MatrixOrArrayOptions, Alignment>& dst)"
  },
  {
    "label": "smart_copy()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_copy(src.array, src.array + size, dst.array)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} template<T,int Size,int MatrixOrArrayOptions,int Alignment> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "swap(plain_array<T, Size, MatrixOrArrayOptions, Alignment>& a, const Eigen::Index a_size, plain_array<T, Size, MatrixOrArrayOptions, Alignment>& b, const Eigen::Index b_size)"
  },
  {
    "label": "swap_ranges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap_ranges(b.array, b.array + a_size, a.array)"
  },
  {
    "label": "smart_move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_move(b.array + a_size, b.array + b_size, a.array + a_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else)",
    "insertText": "if(a_size > b_size)"
  },
  {
    "label": "swap_ranges()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap_ranges(a.array, a.array + b_size, b.array)"
  },
  {
    "label": "smart_move()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "smart_move(a.array + b_size, a.array + a_size, b.array + b_size)"
  },
  {
    "label": "swap_ranges()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "swap_ranges(a.array, a.array + a_size, b.array)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} } } ; } template<T,int Size,int _Rows,int _Cols,int _Options> class DenseStorage ; template<T,int Size,int _Rows,int _Cols,int _Options> class DenseStorage { internal::plain_array<T,Size,_Options> m_data ; public : EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage()"
  },
  {
    "label": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size) } EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(internal::constructor_without_unaligned_array_assert())"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # if ! EIGEN_HAS_CXX11 | |)",
    "insertText": "defined(EIGEN_DENSE_STORAGE_CTOR_PLUGIN) EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data)"
  },
  {
    "label": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size) } #else EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (# endif # if ! EIGEN_HAS_CXX11 EIGEN_DEVICE_FUNC DenseStorage&)",
    "insertText": "operator(const DenseStorage& other)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (# endif # if EIGEN_HAS_RVALUE_REFERENCES # if ! EIGEN_HAS_CXX11 EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT : m_data(std::move(other.m_data))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC DenseStorage&)",
    "insertText": "operator(DenseStorage&& other)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (EIGEN_DEVICE_FUNC DenseStorage&)",
    "insertText": "operator(DenseStorage&&)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (# endif # endif EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(Index size, Index rows, Index cols)"
  },
  {
    "label": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({}) eigen_internal_assert(size==rows*cols && rows==_Rows && cols==_Cols)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(size)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(rows)"
  },
  {
    "label": "EIGEN_UNUSED_VARIABLE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_UNUSED_VARIABLE(cols)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC void)",
    "insertText": "swap(DenseStorage& other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_data, other.m_data)"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index)",
    "insertText": "rows(void)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC void)",
    "insertText": "resize(Index,Index,Index)"
  },
  {
    "label": "data()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC const T*)",
    "insertText": "data()"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(internal::constructor_without_unaligned_array_assert)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(const DenseStorage&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC DenseStorage&)",
    "insertText": "operator(const DenseStorage&)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC void)",
    "insertText": "swap(DenseStorage&)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(0), m_cols(0)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(const DenseStorage& other) : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(other.m_rows), m_cols(other.m_cols)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (internal::)",
    "insertText": "copy(other.m_data, m_rows * m_cols, m_data)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} return* this ; } EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(Index, Index rows, Index cols) : m_rows(rows), m_cols(cols)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (internal::)",
    "insertText": "swap(m_data, m_rows * m_cols, other.m_data, other.m_rows * other.m_cols)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_rows,other.m_rows)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_cols,other.m_cols)"
  },
  {
    "label": "rows()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC Index)",
    "insertText": "rows()"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_rows = rows ; m_cols = cols ; } EIGEN_DEVICE_FUNC void)",
    "insertText": "resize(Index, Index rows, Index cols)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(0)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(const DenseStorage& other) : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(other.m_rows)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (internal::)",
    "insertText": "copy(other.m_data, m_rows * _Cols, m_data)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} return* this ; } EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(Index, Index rows, Index) : m_rows(rows)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (internal::)",
    "insertText": "swap(m_data, m_rows * _Cols, other.m_data, other.m_rows * _Cols)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_rows, other.m_rows)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_rows = rows ; } EIGEN_DEVICE_FUNC void)",
    "insertText": "resize(Index, Index rows, Index)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(internal::constructor_without_unaligned_array_assert()), m_cols(0)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(const DenseStorage& other) : m_data(internal::constructor_without_unaligned_array_assert()), m_cols(other.m_cols)"
  },
  {
    "label": "copy()",
    "kind": "Method",
    "detail": "Function (internal::)",
    "insertText": "copy(other.m_data, _Rows * m_cols, m_data)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} return* this ; } EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(Index, Index, Index cols) : m_cols(cols)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (internal::)",
    "insertText": "swap(m_data, _Rows * m_cols, other.m_data, _Rows * other.m_cols)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_cols, other.m_cols)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_cols = cols ; } EIGEN_DEVICE_FUNC void)",
    "insertText": "resize(Index, Index, Index cols)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0), m_cols(0)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows), m_cols(cols)"
  },
  {
    "label": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({}) eigen_internal_assert(size==rows*cols && rows>=0 && cols >=0)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(const DenseStorage& other) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(other.m_rows*other.m_cols)) , m_rows(other.m_rows) , m_cols(other.m_cols)"
  },
  {
    "label": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = m_rows*m_cols) internal::smart_copy(other.m_data, other.m_data+other.m_rows*other.m_cols, m_data)"
  },
  {
    "label": "tmp()",
    "kind": "Method",
    "detail": "Function (DenseStorage)",
    "insertText": "tmp(other)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "swap(tmp)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} return* this ; } # if EIGEN_HAS_RVALUE_REFERENCES EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT : m_data(std::move(other.m_data)) , m_rows(std::move(other.m_rows)) , m_cols(std::move(other.m_cols))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (internal::conditional_aligned_delete_auto<)",
    "insertText": "T(_Options&DontAlign)==0>(m_data, m_rows*m_cols)"
  },
  {
    "label": "swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "swap(m_data,other.m_data)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (m_data = internal::conditional_aligned_realloc_new_auto<)",
    "insertText": "T(_Options&DontAlign)==0>(m_data, size, m_rows*m_cols)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_rows = rows ; m_cols = cols ; } EIGEN_DEVICE_FUNC void)",
    "insertText": "resize(Index size, Index rows, Index cols)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_cols(cols)"
  },
  {
    "label": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({}) eigen_internal_assert(size==rows*cols && rows==_Rows && cols >=0)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(const DenseStorage& other) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(_Rows*other.m_cols)) , m_cols(other.m_cols)"
  },
  {
    "label": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = m_cols*_Rows) internal::smart_copy(other.m_data, other.m_data+_Rows*m_cols, m_data)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} return* this ; } # if EIGEN_HAS_RVALUE_REFERENCES EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT : m_data(std::move(other.m_data)) , m_cols(std::move(other.m_cols))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (internal::conditional_aligned_delete_auto<)",
    "insertText": "T(_Options&DontAlign)==0>(m_data, _Rows*m_cols)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (m_data = internal::conditional_aligned_realloc_new_auto<)",
    "insertText": "T(_Options&DontAlign)==0>(m_data, size, _Rows*m_cols)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_cols = cols ; } EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "resize(Index size, Index, Index cols)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows)"
  },
  {
    "label": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({}) eigen_internal_assert(size==rows*cols && rows>=0 && cols == _Cols)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(const DenseStorage& other) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(other.m_rows*_Cols)) , m_rows(other.m_rows)"
  },
  {
    "label": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = m_rows*_Cols) internal::smart_copy(other.m_data, other.m_data+other.m_rows*_Cols, m_data)"
  },
  {
    "label": "DenseStorage()",
    "kind": "Method",
    "detail": "Function (} return* this ; } # if EIGEN_HAS_RVALUE_REFERENCES EIGEN_DEVICE_FUNC)",
    "insertText": "DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT : m_data(std::move(other.m_data)) , m_rows(std::move(other.m_rows))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (internal::conditional_aligned_delete_auto<)",
    "insertText": "T(_Options&DontAlign)==0>(m_data, _Cols*m_rows)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (m_data = internal::conditional_aligned_realloc_new_auto<)",
    "insertText": "T(_Options&DontAlign)==0>(m_data, size, m_rows*_Cols)"
  },
  {
    "label": "resize()",
    "kind": "Method",
    "detail": "Function (m_rows = rows ; } EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void)",
    "insertText": "resize(Index size, Index rows, Index)"
  }
]