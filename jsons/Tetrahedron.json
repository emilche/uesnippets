[
  {
    "label": "TTetrahedron",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "TTetrahedron"
  },
  {
    "label": "TTetrahedron()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Chaos / AABB . h \" # include \" Chaos / Core . h \" # include \" Chaos / Triangle . h \" # include \" Chaos / Plane . h \" # include \" Chaos / Math / Poisson . h \" # include \" GenericPlatform / GenericPlatformMath . h \" # include<limits> namespace Chaos { template<T> class TTetrahedron { public :)",
    "insertText": "TTetrahedron()"
  },
  {
    "label": "TTetrahedron()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "TTetrahedron(const TVec3<T>& In1, const TVec3<T>& In2, const TVec3<T>& In3, const TVec3<T>& In4)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (In1,In2,In3,In4 } { } TVec3<T>&)",
    "insertText": "operator(uint32 InIndex)"
  },
  {
    "label": "Swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Swap(X[0], X[1])"
  },
  {
    "label": "GetCenter()",
    "kind": "Method",
    "detail": "Function (} TVec3<T>)",
    "insertText": "GetCenter()"
  },
  {
    "label": "HasBoundingBox()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "HasBoundingBox()"
  },
  {
    "label": "GetBoundingBox()",
    "kind": "Method",
    "detail": "Function (} TAABB<T,3>)",
    "insertText": "GetBoundingBox()"
  },
  {
    "label": "EmptyAABB()",
    "kind": "Method",
    "detail": "Function (TAABB<T,3> Box = TAABB<T,3)",
    "insertText": "EmptyAABB()"
  },
  {
    "label": "GrowToInclude()",
    "kind": "Method",
    "detail": "Function (Box .)",
    "insertText": "GrowToInclude(X[i])"
  },
  {
    "label": "GetMinEdgeLengthSquared()",
    "kind": "Method",
    "detail": "Function (} return Box ; } T)",
    "insertText": "GetMinEdgeLengthSquared()"
  },
  {
    "label": "GetMinEdgeLength()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetMinEdgeLength()"
  },
  {
    "label": "GetMaxEdgeLengthSquared()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetMaxEdgeLengthSquared()"
  },
  {
    "label": "GetMaxEdgeLength()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetMaxEdgeLength()"
  },
  {
    "label": "GetVolume()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetVolume()"
  },
  {
    "label": "GetSignedVolume()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetSignedVolume()"
  },
  {
    "label": "TripleProduct()",
    "kind": "Method",
    "detail": "Function (TVec3<T> U = X [ 1 ] - X [ 0 ] ; TVec3<T> V = X [ 2 ] - X [ 0 ] ; TVec3<T> W = X [ 3 ] - X [ 0 ] ; return)",
    "insertText": "TripleProduct(U, V, W)"
  },
  {
    "label": "GetMinimumAltitude()",
    "kind": "Method",
    "detail": "Function (} T)",
    "insertText": "GetMinimumAltitude(int32* MinAltitudeVertex=nullptr)"
  },
  {
    "label": "GetTriangles()",
    "kind": "Method",
    "detail": "Function (TArray<TTriangle<T>> Tris =)",
    "insertText": "GetTriangles()"
  },
  {
    "label": "Distance()",
    "kind": "Method",
    "detail": "Function (TVec4<T>)",
    "insertText": "Distance(0, 0, 0, 0)"
  },
  {
    "label": "PhiWithNormal()",
    "kind": "Method",
    "detail": "Function (const TTriangle<T>& Tri = Tris [ i ] ; TVec3<T> Norm ; Distance [ i ] = - Tri .)",
    "insertText": "PhiWithNormal(X[3 - i], Norm)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(MinAltitudeVertex)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} T MinAltitude = Distance [ 0 ] ;)",
    "insertText": "for(int32 i = 0; i < 4; i++)"
  },
  {
    "label": "GetAspectRatio()",
    "kind": "Method",
    "detail": "Function (} return MinAltitude ; } T)",
    "insertText": "GetAspectRatio()"
  },
  {
    "label": "GetFirstThreeBarycentricCoordinates()",
    "kind": "Method",
    "detail": "Function (} TVec3<T>)",
    "insertText": "GetFirstThreeBarycentricCoordinates(const TVec3<T>& Location)"
  },
  {
    "label": "RowMaj3x3RobustSolveLinearSystem()",
    "kind": "Method",
    "detail": "Function (TVec3<T> L1 = X [ 0 ] - X [ 3 ] ; TVec3<T> L2 = X [ 1 ] - X [ 3 ] ; TVec3<T> L3 = X [ 2 ] - X [ 3 ] ; TVec3<T> RHS = Location - X [ 3 ] ; T Matrix [ 9 ] = { L1 [ 0 ],L2 [ 0 ],L3 [ 0 ],L1 [ 1 ],L2 [ 1 ],L3 [ 1 ],L1 [ 2 ],L2 [ 2 ],L3 [ 2 ] } ; return)",
    "insertText": "RowMaj3x3RobustSolveLinearSystem(&Matrix[0], RHS)"
  },
  {
    "label": "GetBarycentricCoordinates()",
    "kind": "Method",
    "detail": "Function (} TVec4<T>)",
    "insertText": "GetBarycentricCoordinates(const TVec3<T>& Location)"
  },
  {
    "label": "GetFirstThreeBarycentricCoordinates()",
    "kind": "Method",
    "detail": "Function (TVec3<T> W =)",
    "insertText": "GetFirstThreeBarycentricCoordinates(Location)"
  },
  {
    "label": "GetPointFromBarycentricCoordinates()",
    "kind": "Method",
    "detail": "Function (} TVec3<T>)",
    "insertText": "GetPointFromBarycentricCoordinates(const TVec3<T>& Weights)"
  },
  {
    "label": "GetPointFromBarycentricCoordinates()",
    "kind": "Method",
    "detail": "Function (} TVec3<T>)",
    "insertText": "GetPointFromBarycentricCoordinates(const TVec4<T>& Weights)"
  },
  {
    "label": "SetNumUninitialized()",
    "kind": "Method",
    "detail": "Function (TArray<TTriangle<T>> Triangles ; Triangles .)",
    "insertText": "SetNumUninitialized(4)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Triangles [ 0 ] = TTriangle<)",
    "insertText": "T(X[0], X[1], X[2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Triangles [ 1 ] = TTriangle<)",
    "insertText": "T(X[0], X[3], X[1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Triangles [ 2 ] = TTriangle<)",
    "insertText": "T(X[0], X[2], X[3])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Triangles [ 3 ] = TTriangle<)",
    "insertText": "T(X[1], X[3], X[2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (} else { Triangles [ 0 ] = TTriangle<)",
    "insertText": "T(X[0], X[2], X[1])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Triangles [ 1 ] = TTriangle<)",
    "insertText": "T(X[0], X[1], X[3])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Triangles [ 2 ] = TTriangle<)",
    "insertText": "T(X[0], X[3], X[2])"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (Triangles [ 3 ] = TTriangle<)",
    "insertText": "T(X[1], X[2], X[3])"
  },
  {
    "label": "Inside()",
    "kind": "Method",
    "detail": "Function (} return Triangles ; } bool)",
    "insertText": "Inside(const TVec3<T>& Location, const T HalfThickness=0)"
  },
  {
    "label": "Inside()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Inside(const TArray<TTriangle<T>>& Tris, const TVec3<T>& Location, const T HalfThickness=0)"
  },
  {
    "label": "Outside()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Outside(const TArray<TTriangle<T>>& Tris, const TVec3<T>& Location, const T HalfThickness = 0)"
  },
  {
    "label": "TripleProduct()",
    "kind": "Method",
    "detail": "Function (T V1 =)",
    "insertText": "TripleProduct(Location - X[0], X[1] - X[0], X[2] - X[0])"
  },
  {
    "label": "TripleProduct()",
    "kind": "Method",
    "detail": "Function (T V2 =)",
    "insertText": "TripleProduct(X[3] - X[0], X[1] - X[0], Location - X[0])"
  },
  {
    "label": "TripleProduct()",
    "kind": "Method",
    "detail": "Function (T V3 =)",
    "insertText": "TripleProduct(X[3] - X[0], Location - X[0], X[2] - X[0])"
  },
  {
    "label": "TripleProduct()",
    "kind": "Method",
    "detail": "Function (T V4 =)",
    "insertText": "TripleProduct(X[3] - Location, X[1] - Location, X[2] - Location)"
  },
  {
    "label": "ProjectToSurface()",
    "kind": "Method",
    "detail": "Function (} TVec3<T>)",
    "insertText": "ProjectToSurface(const TArray<TTriangle<T>>& Tris, const TVec3<T>& Location)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (int32 Idx = 0 ; T Dist = TVec3<T)",
    "insertText": "DotProduct(Tris[0][0] - Location, Tris[0].GetNormal())"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (T DistTemp = TVec3<T)",
    "insertText": "DotProduct(Tris[1][0] - Location, Tris[1].GetNormal())"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (Idx = 1 ; Dist = DistTemp ; } DistTemp = TVec3<T)",
    "insertText": "DotProduct(Tris[2][0] - Location, Tris[2].GetNormal())"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (Idx = 2 ; Dist = DistTemp ; } DistTemp = TVec3<T)",
    "insertText": "DotProduct(Tris[3][0] - Location, Tris[3].GetNormal())"
  },
  {
    "label": "GetNormal()",
    "kind": "Method",
    "detail": "Function (Idx = 3 ; Dist = DistTemp ; } return Location + Dist* Tris [ Idx ] .)",
    "insertText": "GetNormal()"
  },
  {
    "label": "SurfacePoint()",
    "kind": "Method",
    "detail": "Function (} else { TVec3<T>)",
    "insertText": "SurfacePoint(Location)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (SurfacePoint - = TVec3<T)",
    "insertText": "DotProduct(Location - Tris[i][0], Norm)"
  },
  {
    "label": "FindClosestPointAndBary()",
    "kind": "Method",
    "detail": "Function (} } return SurfacePoint ; } } TVec3<T>)",
    "insertText": "FindClosestPointAndBary(const TVec3<T>& Location, TVec4<T>& OutBary, const T Tolerance = 0)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (OutBary = TVec4<)",
    "insertText": "T(TetWeights[0], TetWeights[1], TetWeights[2], static_cast<T>(1.0) - TetWeights[0] - TetWeights[1] - TetWeights[2])"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (const TVec3<int32> InvertedTriangleIndices [ 4 ] = { TVec3<)",
    "insertText": "int32(0,1,2), TVec3<int32>(0,3,1), TVec3<int32>(0,2,3), TVec3<int32>(1,3,2)"
  },
  {
    "label": "int32()",
    "kind": "Method",
    "detail": "Function (const TVec3<int32> NonInvertedTriangleIndices [ 4 ] = { TVec3<)",
    "insertText": "int32(0,2,1), TVec3<int32>(0,1,3), TVec3<int32>(0,3,2), TVec3<int32>(1,2,3)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (const TVec3<int32>* FaceIndices = IsInverted ? InvertedTriangleIndices : NonInvertedTriangleIndices ;)",
    "insertText": "for(int32 FaceId = 0; FaceId < 4; ++FaceId)"
  },
  {
    "label": "Tri()",
    "kind": "Method",
    "detail": "Function (const TVec3<int32>& TriIndices = FaceIndices [ FaceId ] ; const TTriangle<T>)",
    "insertText": "Tri(X[TriIndices[0]], X[TriIndices[1]], X[TriIndices[2]])"
  },
  {
    "label": "GetPlane()",
    "kind": "Method",
    "detail": "Function (const TPlaneConcrete<T,3> Plane = Tri .)",
    "insertText": "GetPlane(0)"
  },
  {
    "label": "DotProduct()",
    "kind": "Method",
    "detail": "Function (const T Dist = TVec3<T)",
    "insertText": "DotProduct(Location - Plane.X(), Plane.Normal())"
  },
  {
    "label": "Normal()",
    "kind": "Method",
    "detail": "Function (const TVec3<T> ClosestPointOnPlane = Location - Dist* Plane .)",
    "insertText": "Normal()"
  },
  {
    "label": "ComputeBarycentricInPlane()",
    "kind": "Method",
    "detail": "Function (const TVec2<T> TriBary =)",
    "insertText": "ComputeBarycentricInPlane(Tri[0], Tri[1], Tri[2], ClosestPointOnPlane)"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (OutBary = TVec4<)",
    "insertText": "T(static_cast<T>(0.))"
  },
  {
    "label": "T()",
    "kind": "Method",
    "detail": "Function (OutBary [ TriIndices [ 1 ] ] = TriBary [ 0 ] ; OutBary [ TriIndices [ 2 ] ] = TriBary [ 1 ] ; OutBary [ TriIndices [ 0 ] ] = static_cast<)",
    "insertText": "T(1.)"
  },
  {
    "label": "ClosestEdgeAlpha()",
    "kind": "Method",
    "detail": "Function (TVec3<T> ClosestEdgePoint = TVec3<T>::ZeroVector ; T)",
    "insertText": "ClosestEdgeAlpha(0)"
  },
  {
    "label": "max()",
    "kind": "Method",
    "detail": "Function (int32 ClosestEdgeIndex = INDEX_NONE ; T ClosestEdgeDistSq = std::numeric_limits<T)",
    "insertText": "max()"
  },
  {
    "label": "FindClosestPointAndAlphaOnLineSegment()",
    "kind": "Method",
    "detail": "Function (T Alpha ; const TVec3<T> ClosestPoint =)",
    "insertText": "FindClosestPointAndAlphaOnLineSegment(X[EdgeIndices[EdgeIndex][0]], X[EdgeIndices[EdgeIndex][1]], Location, Alpha)"
  },
  {
    "label": "DistSquared()",
    "kind": "Method",
    "detail": "Function (const T DistSq = TVec3<T)",
    "insertText": "DistSquared(Location, ClosestPoint)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (ClosestEdgeDistSq = DistSq ; ClosestEdgePoint = ClosestPoint ; ClosestEdgeAlpha = Alpha ; ClosestEdgeIndex = EdgeIndex ; } })",
    "insertText": "checkSlow(ClosestEdgeIndex != INDEX_NONE)"
  },
  {
    "label": "checkSlow()",
    "kind": "Method",
    "detail": "Function (OutBary [ EdgeIndices [ ClosestEdgeIndex ] [ 1 ] ] = ClosestEdgeAlpha ;)",
    "insertText": "checkSlow(TVec3<T>::DistSquared(ClosestEdgePoint, GetPointFromBarycentricCoordinates(OutBary)) < static_cast<T>(UE_SMALL_NUMBER))"
  },
  {
    "label": "Sign()",
    "kind": "Method",
    "detail": "Function (} int32)",
    "insertText": "Sign(const T Value)"
  },
  {
    "label": "Inside()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Inside(const TPlane<T, 3>& Plane, const TVec3<T>& Location, const T HalfThickness = 0)"
  },
  {
    "label": "Outside()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "Outside(const TPlane<T, 3>& Plane, const TVec3<T>& Location, const T HalfThickness = 0)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, TTetrahedron)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (TVec3<T> X [ 4 ] ; } ; using FTetrahedron = TTetrahedron<FReal> ; template<T> FChaosArchive&)",
    "insertText": "operator(FChaosArchive& Ar, TTetrahedron<T>& Value)"
  }
]