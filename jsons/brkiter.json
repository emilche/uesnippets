[
  {
    "label": "BreakIterator",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "BreakIterator"
  },
  {
    "label": "U_COMMON_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "U_COMMON_API"
  },
  {
    "label": "ICUBreakIteratorFactory",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ICUBreakIteratorFactory"
  },
  {
    "label": "ICUBreakIteratorService",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ICUBreakIteratorService"
  },
  {
    "label": "BreakIterator()",
    "kind": "Method",
    "detail": "Function (# ifndef BRKITER_H # define BRKITER_H # include \" unicode / utypes . h \" # if UCONFIG_NO_BREAK_ITERATION U_NAMESPACE_BEGIN class BreakIterator ; U_NAMESPACE_END # else # include \" unicode / uobject . h \" # include \" unicode / unistr . h \" # include \" unicode / chariter . h \" # include \" unicode / locid . h \" # include \" unicode / ubrk . h \" # include \" unicode / strenum . h \" # include \" unicode / utext . h \" # include \" unicode / umisc . h \" U_NAMESPACE_BEGIN class BreakIterator : public UObject { public : ~)",
    "insertText": "BreakIterator()"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "operator(const BreakIterator&)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "operator(const BreakIterator& rhs)"
  },
  {
    "label": "clone()",
    "kind": "Method",
    "detail": "Function (} BreakIterator*)",
    "insertText": "clone(void)"
  },
  {
    "label": "getDynamicClassID()",
    "kind": "Method",
    "detail": "Function (UClassID)",
    "insertText": "getDynamicClassID(void)"
  },
  {
    "label": "getText()",
    "kind": "Method",
    "detail": "Function (CharacterIterator&)",
    "insertText": "getText(void)"
  },
  {
    "label": "getUText()",
    "kind": "Method",
    "detail": "Function (UText*)",
    "insertText": "getUText(UText *fillIn, UErrorCode &status)"
  },
  {
    "label": "setText()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setText(const UnicodeString &text)"
  },
  {
    "label": "setText()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "setText(UText *text, UErrorCode &status)"
  },
  {
    "label": "adoptText()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "adoptText(CharacterIterator* it)"
  },
  {
    "label": "DONE()",
    "kind": "Method",
    "detail": "Function (enum {)",
    "insertText": "DONE(int32_t)"
  },
  {
    "label": "first()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "first(void)"
  },
  {
    "label": "last()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "last(void)"
  },
  {
    "label": "previous()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "previous(void)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "next(void)"
  },
  {
    "label": "current()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "current(void)"
  },
  {
    "label": "following()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "following(int32_t offset)"
  },
  {
    "label": "preceding()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "preceding(int32_t offset)"
  },
  {
    "label": "isBoundary()",
    "kind": "Method",
    "detail": "Function (UBool)",
    "insertText": "isBoundary(int32_t offset)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "next(int32_t n)"
  },
  {
    "label": "getRuleStatus()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getRuleStatus()"
  },
  {
    "label": "getRuleStatusVec()",
    "kind": "Method",
    "detail": "Function (int32_t)",
    "insertText": "getRuleStatusVec(int32_t *fillInVec, int32_t capacity, UErrorCode &status)"
  },
  {
    "label": "createWordInstance()",
    "kind": "Method",
    "detail": "Function (BreakIterator* U_EXPORT2)",
    "insertText": "createWordInstance(const Locale& where, UErrorCode& status)"
  },
  {
    "label": "createLineInstance()",
    "kind": "Method",
    "detail": "Function (BreakIterator* U_EXPORT2)",
    "insertText": "createLineInstance(const Locale& where, UErrorCode& status)"
  },
  {
    "label": "createCharacterInstance()",
    "kind": "Method",
    "detail": "Function (BreakIterator* U_EXPORT2)",
    "insertText": "createCharacterInstance(const Locale& where, UErrorCode& status)"
  },
  {
    "label": "createSentenceInstance()",
    "kind": "Method",
    "detail": "Function (BreakIterator* U_EXPORT2)",
    "insertText": "createSentenceInstance(const Locale& where, UErrorCode& status)"
  },
  {
    "label": "createTitleInstance()",
    "kind": "Method",
    "detail": "Function (# ifndef BreakIterator* U_EXPORT2)",
    "insertText": "createTitleInstance(const Locale& where, UErrorCode& status)"
  },
  {
    "label": "getAvailableLocales()",
    "kind": "Method",
    "detail": "Function (# endif const Locale* U_EXPORT2)",
    "insertText": "getAvailableLocales(int32_t& count)"
  },
  {
    "label": "getDisplayName()",
    "kind": "Method",
    "detail": "Function (UnicodeString& U_EXPORT2)",
    "insertText": "getDisplayName(const Locale& objectLocale, const Locale& displayLocale, UnicodeString& name)"
  },
  {
    "label": "getDisplayName()",
    "kind": "Method",
    "detail": "Function (UnicodeString& U_EXPORT2)",
    "insertText": "getDisplayName(const Locale& objectLocale, UnicodeString& name)"
  },
  {
    "label": "createBufferClone()",
    "kind": "Method",
    "detail": "Function (BreakIterator*)",
    "insertText": "createBufferClone(void *stackBuffer, int32_t &BufferSize, UErrorCode &status)"
  },
  {
    "label": "isBufferClone()",
    "kind": "Method",
    "detail": "Function (# ifndef UBool)",
    "insertText": "isBufferClone(void)"
  },
  {
    "label": "registerInstance()",
    "kind": "Method",
    "detail": "Function (# endif # if ! UCONFIG_NO_SERVICE URegistryKey U_EXPORT2)",
    "insertText": "registerInstance(BreakIterator* toAdopt, const Locale& locale, UBreakIteratorType kind, UErrorCode& status)"
  },
  {
    "label": "unregister()",
    "kind": "Method",
    "detail": "Function (UBool U_EXPORT2)",
    "insertText": "unregister(URegistryKey key, UErrorCode& status)"
  },
  {
    "label": "getAvailableLocales()",
    "kind": "Method",
    "detail": "Function (StringEnumeration* U_EXPORT2)",
    "insertText": "getAvailableLocales(void)"
  },
  {
    "label": "getLocale()",
    "kind": "Method",
    "detail": "Function (# endif Locale)",
    "insertText": "getLocale(ULocDataLocaleType type, UErrorCode& status)"
  },
  {
    "label": "getLocaleID()",
    "kind": "Method",
    "detail": "Function (# ifndef const char*)",
    "insertText": "getLocaleID(ULocDataLocaleType type, UErrorCode& status)"
  },
  {
    "label": "refreshInputText()",
    "kind": "Method",
    "detail": "Function (# endif BreakIterator&)",
    "insertText": "refreshInputText(UText *input, UErrorCode &status)"
  },
  {
    "label": "buildInstance()",
    "kind": "Method",
    "detail": "Function (private : BreakIterator*)",
    "insertText": "buildInstance(const Locale& loc, const char *type, UErrorCode& status)"
  },
  {
    "label": "createInstance()",
    "kind": "Method",
    "detail": "Function (BreakIterator*)",
    "insertText": "createInstance(const Locale& loc, int32_t kind, UErrorCode& status)"
  },
  {
    "label": "makeInstance()",
    "kind": "Method",
    "detail": "Function (BreakIterator*)",
    "insertText": "makeInstance(const Locale& loc, int32_t kind, UErrorCode& status)"
  },
  {
    "label": "BreakIterator()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "BreakIterator(const BreakIterator &other)"
  },
  {
    "label": "BreakIterator()",
    "kind": "Method",
    "detail": "Function (# ifndef)",
    "insertText": "BreakIterator(const Locale& valid, const Locale &actual)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (BreakIterator&)",
    "insertText": "operator(const BreakIterator &other)"
  },
  {
    "label": "isBufferClone()",
    "kind": "Method",
    "detail": "Function (# endif private : char actualLocale [ ULOC_FULLNAME_CAPACITY ] ; char validLocale [ ULOC_FULLNAME_CAPACITY ] ; } ; # ifndef UBool)",
    "insertText": "isBufferClone()"
  }
]