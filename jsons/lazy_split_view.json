[
  {
    "label": "__require_constant",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__require_constant"
  },
  {
    "label": "_Range",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Range"
  },
  {
    "label": "lazy_split_view",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "lazy_split_view"
  },
  {
    "label": "__outer_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__outer_iterator"
  },
  {
    "label": "__inner_iterator",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__inner_iterator"
  },
  {
    "label": "__outer_iterator_category",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__outer_iterator_category"
  },
  {
    "label": "value_type",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "value_type"
  },
  {
    "label": "__inner_iterator_category",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__inner_iterator_category"
  },
  {
    "label": "_Pattern",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "_Pattern"
  },
  {
    "label": "__fn",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "__fn"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# ifndef _LIBCPP___RANGES_LAZY_SPLIT_VIEW_H # define _LIBCPP___RANGES_LAZY_SPLIT_VIEW_H # include<__algorithm / in_in_result . h> # include<__algorithm / ranges_find . h> # include<__algorithm / ranges_mismatch . h> # include<__concepts / constructible . h> # include<__concepts / convertible_to . h> # include<__concepts / derived_from . h> # include<__config> # include<__functional / bind_back . h> # include<__functional / ranges_operations . h> # include<__iterator / concepts . h> # include<__iterator / default_sentinel . h> # include<__iterator / incrementable_traits . h> # include<__iterator / indirectly_comparable . h> # include<__iterator / iter_move . h> # include<__iterator / iter_swap . h> # include<__iterator / iterator_traits . h> # include<__memory / addressof . h> # include<__ranges / access . h> # include<__ranges / all . h> # include<__ranges / concepts . h> # include<__ranges / non_propagating_cache . h> # include<__ranges / range_adaptor . h> # include<__ranges / single_view . h> # include<__ranges / subrange . h> # include<__ranges / view_interface . h> # include<__utility / forward . h> # include<__utility / move . h> # include<type_traits> # if !)",
    "insertText": "defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER) # pragma GCC system_header #endif _LIBCPP_BEGIN_NAMESPACE_STD #if _LIBCPP_STD_VER > 17 && !defined(_LIBCPP_HAS_NO_INCOMPLETE_RANGES)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (template<auto> struct __require_constant ; template<class _Range> concept __tiny_range = sized_range<_Range>&& requires { __require_constant<remove_reference_t<_Range)",
    "insertText": "size()"
  },
  {
    "label": "equal_to()",
    "kind": "Method",
    "detail": "Function (template<input_range _View,forward_range _Pattern> requires view<_View>&& view<_Pattern>&& indirectly_comparable<iterator_t<_View>,iterator_t<_Pattern>,)",
    "insertText": "equal_to(forward_range<_View> || __tiny_range<_Pattern>)"
  },
  {
    "label": "_View()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_NO_UNIQUE_ADDRESS _View __base_ =)",
    "insertText": "_View()"
  },
  {
    "label": "_Pattern()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_NO_UNIQUE_ADDRESS _Pattern __pattern_ =)",
    "insertText": "_Pattern()"
  },
  {
    "label": "_MaybeCurrent()",
    "kind": "Method",
    "detail": "Function (using _MaybeCurrent = _If<! forward_range<_View>,__non_propagating_cache<iterator_t<_View>>,__empty_cache> ; _LIBCPP_NO_UNIQUE_ADDRESS _MaybeCurrent __current_ =)",
    "insertText": "_MaybeCurrent()"
  },
  {
    "label": "lazy_split_view()",
    "kind": "Method",
    "detail": "Function (template<bool> struct __outer_iterator ; template<bool> struct __inner_iterator ; public : _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "lazy_split_view()"
  },
  {
    "label": "lazy_split_view()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "lazy_split_view(_View __base, _Pattern __pattern) : __base_(std::move(__base)), __pattern_(std::move(__pattern))"
  },
  {
    "label": "lazy_split_view()",
    "kind": "Method",
    "detail": "Function (} template<input_range _Range> requires constructible_from<_View,views::all_t<_Range>>&& constructible_from<_Pattern,single_view<range_value_t<_Range>>> _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "lazy_split_view(_Range&& __r, range_value_t<_Range> __e) : __base_(views::all(std::forward<_Range>(__r))) , __pattern_(views::single(std::move(__e)))"
  },
  {
    "label": "base()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI _View)",
    "insertText": "base()"
  },
  {
    "label": "begin()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "begin()"
  },
  {
    "label": "__emplace()",
    "kind": "Method",
    "detail": "Function (} else { __current_ .)",
    "insertText": "__emplace(ranges::begin(__base_))"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "end()"
  },
  {
    "label": "__current()",
    "kind": "Method",
    "detail": "Function (bool __trailing_empty_ = false ; [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto&)",
    "insertText": "__current()"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (public : _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "value_type()"
  },
  {
    "label": "value_type()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "value_type(__outer_iterator __i) : __i_(std::move(__i))"
  },
  {
    "label": "__outer_iterator()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__outer_iterator(_Parent& __parent) requires (!forward_range<_Base>) : __parent_(std::addressof(__parent))"
  },
  {
    "label": "__outer_iterator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__outer_iterator(_Parent& __parent, iterator_t<_Base> __current) requires forward_range<_Base> : __parent_(std::addressof(__parent)), __current_(std::move(__current))"
  },
  {
    "label": "__outer_iterator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__outer_iterator(__outer_iterator<!_Const> __i) requires _Const && convertible_to<iterator_t<_View>, iterator_t<_Base>> : __parent_(__i.__parent_), __current_(std::move(__i.__current_))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI value_type)",
    "insertText": "operator()"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (const auto __end =)",
    "insertText": "end(__parent_->__base_)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (__trailing_empty_ = false ; return* this ; } const auto [ __pbegin,__pend ] = ranges::subrange { __parent_ -> __pattern_ } ;)",
    "insertText": "if(__pbegin == __pend)"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (} else if)",
    "insertText": "constexpr(__tiny_range<_Pattern>)"
  },
  {
    "label": "__current()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "__current() = ranges::find(std::move(__current()), __end, *__pbegin)"
  },
  {
    "label": "mismatch()",
    "kind": "Method",
    "detail": "Function (} } else { do { const auto [ __b,__p ] =)",
    "insertText": "mismatch(__current(), __end, __pbegin, __pend)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (__trailing_empty_ = true ; } break ; } })",
    "insertText": "while(++__current() != __end)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} return* this ; } _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "decltype(auto) operator++(int)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (auto __tmp =* this ; + +* this ; return __tmp ; } else { + +* this ; } } _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "operator(const __outer_iterator& __x, const __outer_iterator& __y)"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_LIBCPP_ASSERT(__x.__parent_, \"Cannot call comparison on a default-constructed iterator.\")"
  },
  {
    "label": "_OuterConst()",
    "kind": "Method",
    "detail": "Function (} } ; template<class> struct __inner_iterator_category { } ; template<forward_range _Tp> struct __inner_iterator_category<_Tp> { using iterator_category = _If<derived_from<iterator_traits<iterator_t<_Tp>>::iterator_category,forward_iterator_tag>,forward_iterator_tag,iterator_traits<iterator_t<_Tp>>::iterator_category> ; } ; template<bool _Const> struct __inner_iterator : __inner_iterator_category<__maybe_const<_Const,_View>> { private : using _Base = __maybe_const<_Const,_View> ; bool _OuterConst = _Const ; __outer_iterator<_Const> __i_ = __outer_iterator<)",
    "insertText": "_OuterConst()"
  },
  {
    "label": "__is_done()",
    "kind": "Method",
    "detail": "Function (bool __incremented_ = false ; _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "__is_done()"
  },
  {
    "label": "_LIBCPP_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_LIBCPP_ASSERT(__i_.__parent_, \"Cannot call comparison on a default-constructed iterator.\")"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (auto [ __pcur,__pend ] = ranges::subrange { __i_ . __parent_ -> __pattern_ } ; auto __end =)",
    "insertText": "end(__i_.__parent_->__base_)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(++__cur != __end)"
  },
  {
    "label": "__outer_current()",
    "kind": "Method",
    "detail": "Function (} [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI const auto&)",
    "insertText": "__outer_current()"
  },
  {
    "label": "__inner_iterator()",
    "kind": "Method",
    "detail": "Function (} public : using iterator_concept = __outer_iterator<_Const>::iterator_concept ; using value_type = range_value_t<_Base> ; using difference_type = range_difference_t<_Base> ; _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__inner_iterator()"
  },
  {
    "label": "__inner_iterator()",
    "kind": "Method",
    "detail": "Function (_LIBCPP_HIDE_FROM_ABI)",
    "insertText": "__inner_iterator(__outer_iterator<_Const> __i) : __i_(std::move(__i))"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "decltype(auto) operator*()"
  },
  {
    "label": "constexpr()",
    "kind": "Method",
    "detail": "Function (__incremented_ = true ; if)",
    "insertText": "constexpr(!forward_range<_Base>)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (auto __tmp =* this ; + +* this ; return __tmp ; } else { + +* this ; } } _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "operator(const __inner_iterator& __x, const __inner_iterator& __y)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI bool)",
    "insertText": "operator(const __inner_iterator& __x, default_sentinel_t)"
  },
  {
    "label": "decltype()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI)",
    "insertText": "decltype(auto) iter_move(const __inner_iterator& __i) noexcept(noexcept(ranges::iter_move(__i.__outer_current())))"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (} _LIBCPP_HIDE_FROM_ABI void)",
    "insertText": "iter_swap(const __inner_iterator& __x, const __inner_iterator& __y) noexcept(noexcept(ranges::iter_swap(__x.__outer_current(), __y.__outer_current())))"
  },
  {
    "label": "iter_swap()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "iter_swap(__x.__outer_current(), __y.__outer_current())"
  },
  {
    "label": "lazy_split_view()",
    "kind": "Method",
    "detail": "Function (lazy_split_view<views::all_t<_Range>, views::all_t<_Pattern>>)",
    "insertText": "lazy_split_view(_Range&&, _Pattern&&)"
  },
  {
    "label": "lazy_split_view()",
    "kind": "Method",
    "detail": "Function (lazy_split_view<views::all_t<_Range>, single_view<range_value_t<_Range>>>)",
    "insertText": "lazy_split_view(_Range&&, range_value_t<_Range>)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (namespace views { namespace __lazy_split_view { struct __fn : __range_adaptor_closure<__fn> { template<class _Range,class _Pattern> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Range&& __range, _Pattern&& __pattern) const noexcept(noexcept(lazy_split_view(std::forward<_Range>(__range), std::forward<_Pattern>(__pattern)))) -> decltype( lazy_split_view(std::forward<_Range>(__range), std::forward<_Pattern>(__pattern)))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} template<class _Pattern> requires constructible_from<decay_t<_Pattern>,_Pattern> [ [ nodiscard ] ] _LIBCPP_HIDE_FROM_ABI auto)",
    "insertText": "operator()(_Pattern&& __pattern) const noexcept(is_nothrow_constructible_v<decay_t<_Pattern>, _Pattern>)"
  }
]