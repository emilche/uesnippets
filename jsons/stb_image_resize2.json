[
  {
    "label": "stbir__info",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "stbir__info"
  },
  {
    "label": "STBIR_RESIZE",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "STBIR_RESIZE"
  },
  {
    "label": "STBIR_PROFILE_INFO",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "STBIR_PROFILE_INFO"
  },
  {
    "label": "stbir__scale_info",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "stbir__scale_info"
  },
  {
    "label": "STBIR__V_FIRST_INFO",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "STBIR__V_FIRST_INFO"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(STB_IMAGE_RESIZE_DO_HORIZONTALS) && !defined(STB_IMAGE_RESIZE_DO_VERTICALS) && !defined(STB_IMAGE_RESIZE_DO_CODERS)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (typedef unsigned short stbir_uint16 ; typedef unsigned int stbir_uint32 ; typedef unsigned __int64 stbir_uint64 ; # else # include<stdint . h> typedef uint8_t stbir_uint8 ; typedef uint16_t stbir_uint16 ; typedef uint32_t stbir_uint32 ; typedef uint64_t stbir_uint64 ; # endif # ifdef _M_IX86_FP #)",
    "insertText": "if(_M_IX86_FP >= 1 ) #ifndef STBIR_SSE #define STBIR_SSE #endif #endif #endif #if defined(_x86_64) || defined( __x86_64__ ) || defined( _M_X64 ) || defined(__x86_64) || defined(_M_AMD64) || defined(__SSE2__) || defined(STBIR_SSE) || defined(STBIR_SSE2) #ifndef STBIR_SSE2 #define STBIR_SSE2 #endif #if defined(__AVX__) || defined(STBIR_AVX2) #ifndef STBIR_AVX #ifndef STBIR_NO_AVX #define STBIR_AVX #endif #endif #endif #if defined(__AVX2__) || defined(STBIR_AVX2) #ifndef STBIR_NO_AVX2 #ifndef STBIR_AVX2 #define STBIR_AVX2 #endif #if defined( _MSC_VER ) && !defined(__clang__) #ifndef STBIR_FP16C #define STBIR_FP16C #endif #endif #endif #endif #ifdef __F16C__ #ifndef STBIR_FP16C #define STBIR_FP16C #endif #endif #endif #if defined( _M_ARM64 ) || defined( __aarch64__ ) || defined( __arm64__ ) || defined(_M_ARM) || (__ARM_NEON_FP & 4) != 0 && __ARM_FP16_FORMAT_IEEE != 0 #ifndef STBIR_NEON #define STBIR_NEON #endif #endif #if defined(_M_ARM) #ifdef STBIR_USE_FMA #undef STBIR_USE_FMA #endif #endif #if defined(__wasm__) && defined(__wasm_simd128__)"
  },
  {
    "label": "stbir_resize_uint8_srgb()",
    "kind": "Method",
    "detail": "Function (STBIR_1CHANNEL = 1,STBIR_2CHANNEL = 2,STBIR_RGB = 3,STBIR_BGR = 0,STBIR_4CHANNEL = 5,STBIR_RGBA = 4,STBIR_BGRA = 6,STBIR_ARGB = 7,STBIR_ABGR = 8,STBIR_RA = 9,STBIR_AR = 1 0,STBIR_RGBA_PM = 1 1,STBIR_BGRA_PM = 1 2,STBIR_ARGB_PM = 1 3,STBIR_ABGR_PM = 1 4,STBIR_RA_PM = 1 5,STBIR_AR_PM = 1 6,STBIR_RGBA_NO_AW = 1 1,STBIR_BGRA_NO_AW = 1 2,STBIR_ARGB_NO_AW = 1 3,STBIR_ABGR_NO_AW = 1 4,STBIR_RA_NO_AW = 1 5,STBIR_AR_NO_AW = 1 6,} stbir_pixel_layout ; STBIRDEF unsigned char*)",
    "insertText": "stbir_resize_uint8_srgb(const unsigned char *input_pixels , int input_w , int input_h, int input_stride_in_bytes, unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes, stbir_pixel_layout pixel_type)"
  },
  {
    "label": "stbir_resize_uint8_linear()",
    "kind": "Method",
    "detail": "Function (STBIRDEF unsigned char*)",
    "insertText": "stbir_resize_uint8_linear(const unsigned char *input_pixels , int input_w , int input_h, int input_stride_in_bytes, unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes, stbir_pixel_layout pixel_type)"
  },
  {
    "label": "stbir_resize_float_linear()",
    "kind": "Method",
    "detail": "Function (STBIRDEF float*)",
    "insertText": "stbir_resize_float_linear(const float *input_pixels , int input_w , int input_h, int input_stride_in_bytes, float *output_pixels, int output_w, int output_h, int output_stride_in_bytes, stbir_pixel_layout pixel_type)"
  },
  {
    "label": "stbir_resize()",
    "kind": "Method",
    "detail": "Function (typedef enum { STBIR_EDGE_CLAMP = 0,STBIR_EDGE_REFLECT = 1,STBIR_EDGE_WRAP = 2,STBIR_EDGE_ZERO = 3,} stbir_edge ; typedef enum { STBIR_FILTER_DEFAULT = 0,STBIR_FILTER_BOX = 1,STBIR_FILTER_TRIANGLE = 2,STBIR_FILTER_CUBICBSPLINE = 3,STBIR_FILTER_CATMULLROM = 4,STBIR_FILTER_MITCHELL = 5,STBIR_FILTER_POINT_SAMPLE = 6,STBIR_FILTER_OTHER = 7,} stbir_filter ; typedef enum { STBIR_TYPE_UINT8 = 0,STBIR_TYPE_UINT8_SRGB = 1,STBIR_TYPE_UINT8_SRGB_ALPHA = 2,STBIR_TYPE_UINT16 = 3,STBIR_TYPE_FLOAT = 4,STBIR_TYPE_HALF_FLOAT = 5 } stbir_datatype ; STBIRDEF void*)",
    "insertText": "stbir_resize(const void *input_pixels , int input_w , int input_h, int input_stride_in_bytes, void *output_pixels, int output_w, int output_h, int output_stride_in_bytes, stbir_pixel_layout pixel_layout, stbir_datatype data_type, stbir_edge edge, stbir_filter filter)"
  },
  {
    "label": "stbir_input_callback()",
    "kind": "Method",
    "detail": "Function (typedef void const*)",
    "insertText": "stbir_input_callback(void * optional_output, void const * input_ptr, int num_pixels, int x, int y, void * context)"
  },
  {
    "label": "stbir_output_callback()",
    "kind": "Method",
    "detail": "Function (typedef void)",
    "insertText": "stbir_output_callback(void const * output_ptr, int num_pixels, int y, void * context)"
  },
  {
    "label": "stbir__kernel_callback()",
    "kind": "Method",
    "detail": "Function (typedef float)",
    "insertText": "stbir__kernel_callback(float x, float scale, void * user_data)"
  },
  {
    "label": "stbir__support_callback()",
    "kind": "Method",
    "detail": "Function (typedef float)",
    "insertText": "stbir__support_callback(float scale, void * user_data)"
  },
  {
    "label": "stbir_resize_init()",
    "kind": "Method",
    "detail": "Function (typedef struct stbir__info stbir__info ; typedef struct STBIR_RESIZE { void* user_data ; void const* input_pixels ; int input_w,input_h ; double input_s0,input_t0,input_s1,input_t1 ; stbir_input_callback* input_cb ; void* output_pixels ; int output_w,output_h ; int output_subx,output_suby,output_subw,output_subh ; stbir_output_callback* output_cb ; int input_stride_in_bytes ; int output_stride_in_bytes ; int splits ; int fast_alpha ; int needs_rebuild ; int called_alloc ; stbir_pixel_layout input_pixel_layout_public ; stbir_pixel_layout output_pixel_layout_public ; stbir_datatype input_data_type ; stbir_datatype output_data_type ; stbir_filter horizontal_filter,vertical_filter ; stbir_edge horizontal_edge,vertical_edge ; stbir__kernel_callback* horizontal_filter_kernel ; stbir__support_callback* horizontal_filter_support ; stbir__kernel_callback* vertical_filter_kernel ; stbir__support_callback* vertical_filter_support ; stbir__info* samplers ; } STBIR_RESIZE ; STBIRDEF void)",
    "insertText": "stbir_resize_init(STBIR_RESIZE * resize, const void *input_pixels, int input_w, int input_h, int input_stride_in_bytes, void *output_pixels, int output_w, int output_h, int output_stride_in_bytes, stbir_pixel_layout pixel_layout, stbir_datatype data_type)"
  },
  {
    "label": "stbir_set_datatypes()",
    "kind": "Method",
    "detail": "Function (STBIRDEF void)",
    "insertText": "stbir_set_datatypes(STBIR_RESIZE * resize, stbir_datatype input_type, stbir_datatype output_type)"
  },
  {
    "label": "stbir_set_pixel_callbacks()",
    "kind": "Method",
    "detail": "Function (STBIRDEF void)",
    "insertText": "stbir_set_pixel_callbacks(STBIR_RESIZE * resize, stbir_input_callback * input_cb, stbir_output_callback * output_cb)"
  },
  {
    "label": "stbir_set_user_data()",
    "kind": "Method",
    "detail": "Function (STBIRDEF void)",
    "insertText": "stbir_set_user_data(STBIR_RESIZE * resize, void * user_data)"
  },
  {
    "label": "stbir_set_buffer_ptrs()",
    "kind": "Method",
    "detail": "Function (STBIRDEF void)",
    "insertText": "stbir_set_buffer_ptrs(STBIR_RESIZE * resize, const void * input_pixels, int input_stride_in_bytes, void * output_pixels, int output_stride_in_bytes)"
  },
  {
    "label": "stbir_set_pixel_layouts()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_set_pixel_layouts(STBIR_RESIZE * resize, stbir_pixel_layout input_pixel_layout, stbir_pixel_layout output_pixel_layout)"
  },
  {
    "label": "stbir_set_edgemodes()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_set_edgemodes(STBIR_RESIZE * resize, stbir_edge horizontal_edge, stbir_edge vertical_edge)"
  },
  {
    "label": "stbir_set_filters()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_set_filters(STBIR_RESIZE * resize, stbir_filter horizontal_filter, stbir_filter vertical_filter)"
  },
  {
    "label": "stbir_set_filter_callbacks()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_set_filter_callbacks(STBIR_RESIZE * resize, stbir__kernel_callback * horizontal_filter, stbir__support_callback * horizontal_support, stbir__kernel_callback * vertical_filter, stbir__support_callback * vertical_support)"
  },
  {
    "label": "stbir_set_pixel_subrect()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_set_pixel_subrect(STBIR_RESIZE * resize, int subx, int suby, int subw, int subh)"
  },
  {
    "label": "stbir_set_input_subrect()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_set_input_subrect(STBIR_RESIZE * resize, double s0, double t0, double s1, double t1)"
  },
  {
    "label": "stbir_set_output_pixel_subrect()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_set_output_pixel_subrect(STBIR_RESIZE * resize, int subx, int suby, int subw, int subh)"
  },
  {
    "label": "stbir_set_non_pm_alpha_speed_over_quality()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_set_non_pm_alpha_speed_over_quality(STBIR_RESIZE * resize, int non_pma_alpha_speed_over_quality)"
  },
  {
    "label": "stbir_build_samplers()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_build_samplers(STBIR_RESIZE * resize)"
  },
  {
    "label": "stbir_free_samplers()",
    "kind": "Method",
    "detail": "Function (STBIRDEF void)",
    "insertText": "stbir_free_samplers(STBIR_RESIZE * resize)"
  },
  {
    "label": "stbir_resize_extended()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_resize_extended(STBIR_RESIZE * resize)"
  },
  {
    "label": "stbir_build_samplers_with_splits()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_build_samplers_with_splits(STBIR_RESIZE * resize, int try_splits)"
  },
  {
    "label": "stbir_resize_extended_split()",
    "kind": "Method",
    "detail": "Function (STBIRDEF int)",
    "insertText": "stbir_resize_extended_split(STBIR_RESIZE * resize, int split_start, int split_count)"
  },
  {
    "label": "stbir_resize_build_profile_info()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIR_PROFILE typedef struct STBIR_PROFILE_INFO { stbir_uint64 total_clocks ; stbir_uint64 clocks [ 8 ] ; char const** descriptions ; stbir_uint32 count ; } STBIR_PROFILE_INFO ; STBIRDEF void)",
    "insertText": "stbir_resize_build_profile_info(STBIR_PROFILE_INFO * out_info, STBIR_RESIZE const * resize)"
  },
  {
    "label": "stbir_resize_extended_profile_info()",
    "kind": "Method",
    "detail": "Function (STBIRDEF void)",
    "insertText": "stbir_resize_extended_profile_info(STBIR_PROFILE_INFO * out_info, STBIR_RESIZE const * resize)"
  },
  {
    "label": "stbir_resize_split_profile_info()",
    "kind": "Method",
    "detail": "Function (STBIRDEF void)",
    "insertText": "stbir_resize_split_profile_info(STBIR_PROFILE_INFO * out_info, STBIR_RESIZE const * resize, int split_start, int split_num)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif # endif # if)",
    "insertText": "defined(STB_IMAGE_RESIZE_IMPLEMENTATION) || defined(STB_IMAGE_RESIZE2_IMPLEMENTATION) #ifndef STBIR_ASSERT #include <assert.h> #define STBIR_ASSERT(x) assert(x) #endif #ifndef STBIR_MALLOC #include <stdlib.h> #define STBIR_MALLOC(size,user_data) ((void)(user_data), malloc(size)) #define STBIR_FREE(ptr,user_data) ((void)(user_data), free(ptr)) #endif #ifdef _MSC_VER #define stbir__inline __forceinline #else #define stbir__inline __inline__ #if defined(__has_feature) #if __has_feature(address_sanitizer) || __has_feature(memory_sanitizer) #ifndef STBIR__SEPARATE_ALLOCATIONS #define STBIR__SEPARATE_ALLOCATIONS #endif #endif #endif #endif #if defined(__SANITIZE_ADDRESS__) #ifndef STBIR__SEPARATE_ALLOCATIONS #define STBIR__SEPARATE_ALLOCATIONS #endif #endif #ifndef STBIR_DONT_CHANGE_FP_CONTRACT #if defined(_MSC_VER) && !defined(__clang__) #if _MSC_VER > 1200 #pragma fp_contract(off) #endif #elif defined(__GNUC__) && !defined(__clang__) #pragma GCC optimize(\"fp-contract=off\") #else #pragma STDC FP_CONTRACT OFF #endif #endif #ifdef _MSC_VER #define STBIR__UNUSED(v) (void)(v) #else #define STBIR__UNUSED(v) (void)sizeof(v) #endif #define STBIR__ARRAY_SIZE(a) (sizeof((a))/sizeof((a)[0]))"
  },
  {
    "label": "stbir__decode_pixels_func()",
    "kind": "Method",
    "detail": "Function (STBIRI_1CHANNEL = 0,STBIRI_2CHANNEL = 1,STBIRI_RGB = 2,STBIRI_BGR = 3,STBIRI_4CHANNEL = 4,STBIRI_RGBA = 5,STBIRI_BGRA = 6,STBIRI_ARGB = 7,STBIRI_ABGR = 8,STBIRI_RA = 9,STBIRI_AR = 1 0,STBIRI_RGBA_PM = 1 1,STBIRI_BGRA_PM = 1 2,STBIRI_ARGB_PM = 1 3,STBIRI_ABGR_PM = 1 4,STBIRI_RA_PM = 1 5,STBIRI_AR_PM = 1 6,} stbir_internal_pixel_layout ; # define STBIR_BGR bad_dont_use_in_implementation # define STBIR_1CHANNEL STBIR_BGR # define STBIR_2CHANNEL STBIR_BGR # define STBIR_RGB STBIR_BGR # define STBIR_RGBA STBIR_BGR # define STBIR_4CHANNEL STBIR_BGR # define STBIR_BGRA STBIR_BGR # define STBIR_ARGB STBIR_BGR # define STBIR_ABGR STBIR_BGR # define STBIR_RA STBIR_BGR # define STBIR_AR STBIR_BGR # define STBIR_RGBA_PM STBIR_BGR # define STBIR_BGRA_PM STBIR_BGR # define STBIR_ARGB_PM STBIR_BGR # define STBIR_ABGR_PM STBIR_BGR # define STBIR_RA_PM STBIR_BGR # define STBIR_AR_PM STBIR_BGR unsigned char stbir__type_size [ ] = { 1,1,1,2,4,2 } ; typedef struct { int n0 ; int n1 ; } stbir__contributors ; typedef struct { int lowest ; int highest ; int widest ; } stbir__filter_extent_info ; typedef struct { int n0 ; int n1 ; int pixel_offset_for_input ; } stbir__span ; typedef struct stbir__scale_info { int input_full_size ; int output_sub_size ; float scale ; float inv_scale ; float pixel_shift ; int scale_is_rational ; stbir_uint32 scale_numerator,scale_denominator ; } stbir__scale_info ; typedef struct { stbir__contributors* contributors ; float* coefficients ; stbir__contributors* gather_prescatter_contributors ; float* gather_prescatter_coefficients ; stbir__scale_info scale_info ; float support ; stbir_filter filter_enum ; stbir__kernel_callback* filter_kernel ; stbir__support_callback* filter_support ; stbir_edge edge ; int coefficient_width ; int filter_pixel_width ; int filter_pixel_margin ; int num_contributors ; int contributors_size ; int coefficients_size ; stbir__filter_extent_info extent_info ; int is_gather ; int gather_prescatter_num_contributors ; int gather_prescatter_coefficient_width ; int gather_prescatter_contributors_size ; int gather_prescatter_coefficients_size ; } stbir__sampler ; typedef struct { stbir__contributors conservative ; int edge_sizes [ 2 ] ; stbir__span spans [ 2 ] ; } stbir__extents ; typedef struct { # ifdef STBIR_PROFILE union { struct { stbir_uint64 total,looping,vertical,horizontal,decode,encode,alpha,unalpha ; } named ; stbir_uint64 array [ 8 ] ; } profile ; stbir_uint64* current_zone_excluded_ptr ; # endif float* decode_buffer ; int ring_buffer_first_scanline ; int ring_buffer_last_scanline ; int ring_buffer_begin_index ; int start_output_y,end_output_y ; int start_input_y,end_input_y ; # ifdef STBIR__SEPARATE_ALLOCATIONS float** ring_buffers ; # else float* ring_buffer ; # endif float* vertical_buffer ; char no_cache_straddle [ 6 4 ] ; } stbir__per_split_info ; typedef void)",
    "insertText": "stbir__decode_pixels_func(float * decode, int width_times_channels, void const * input)"
  },
  {
    "label": "stbir__alpha_weight_func()",
    "kind": "Method",
    "detail": "Function (typedef void)",
    "insertText": "stbir__alpha_weight_func(float * decode_buffer, int width_times_channels)"
  },
  {
    "label": "stbir__horizontal_gather_channels_func()",
    "kind": "Method",
    "detail": "Function (typedef void)",
    "insertText": "stbir__horizontal_gather_channels_func(float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "stbir__alpha_unweight_func()",
    "kind": "Method",
    "detail": "Function (typedef void)",
    "insertText": "stbir__alpha_unweight_func(float * encode_buffer, int width_times_channels)"
  },
  {
    "label": "stbir__encode_pixels_func()",
    "kind": "Method",
    "detail": "Function (typedef void)",
    "insertText": "stbir__encode_pixels_func(void * output, int width_times_channels, float const * encode)"
  },
  {
    "label": "stbir__max_uint8_as_float_inverted()",
    "kind": "Method",
    "detail": "Function (struct stbir__info { # ifdef STBIR_PROFILE union { struct { stbir_uint64 total,build,alloc,horizontal,vertical,cleanup,pivot ; } named ; stbir_uint64 array [ 7 ] ; } profile ; stbir_uint64* current_zone_excluded_ptr ; # endif stbir__sampler horizontal ; stbir__sampler vertical ; void const* input_data ; void* output_data ; int input_stride_bytes ; int output_stride_bytes ; int ring_buffer_length_bytes ; int ring_buffer_num_entries ; stbir_datatype input_type ; stbir_datatype output_type ; stbir_input_callback* in_pixels_cb ; void* user_data ; stbir_output_callback* out_pixels_cb ; stbir__extents scanline_extents ; void* alloced_mem ; stbir__per_split_info* split_info ; stbir__decode_pixels_func* decode_pixels ; stbir__alpha_weight_func* alpha_weight ; stbir__horizontal_gather_channels_func* horizontal_gather_channels ; stbir__alpha_unweight_func* alpha_unweight ; stbir__encode_pixels_func* encode_pixels ; int alloc_ring_buffer_num_entries ; int splits ; stbir_internal_pixel_layout input_pixel_layout_internal ; stbir_internal_pixel_layout output_pixel_layout_internal ; int input_color_and_type ; int offset_x,offset_y ; int vertical_first ; int channels ; int effective_channels ; size_t alloced_total ; } ; # define stbir__max_uint8_as_float 2 5 5 . 0 f # define stbir__max_uint16_as_float 6 5 5 3 5 . 0 f # define)",
    "insertText": "stbir__max_uint8_as_float_inverted(1.0f/255.0f) #define stbir__max_uint16_as_float_inverted (1.0f/65535.0f) #define stbir__small_float ((float)1 / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20)) #define STBIR_CLAMP(x, xmin, xmax)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if((x) < (xmin) ) (x) = (xmin)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "if((x) > (xmax) ) (x) = (xmax)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (\\ })",
    "insertText": "while(0) static stbir__inline int stbir__min(int a, int b)"
  },
  {
    "label": "minval()",
    "kind": "Method",
    "detail": "Function (const stbir__FP32 almostone = { 0 x3f7fffff } ; const stbir__FP32)",
    "insertText": "minval(127-13)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (stbir_uint32 tab,bias,scale,t ; stbir__FP32 f ;)",
    "insertText": "if(!(in > minval.f))"
  },
  {
    "label": "fp32_to_srgb8_tab4()",
    "kind": "Method",
    "detail": "Function (f . f = in ; tab =)",
    "insertText": "fp32_to_srgb8_tab4(f.u - minval.u)"
  },
  {
    "label": "bias()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "bias(tab >> 16)"
  },
  {
    "label": "t()",
    "kind": "Method",
    "detail": "Function (scale = tab& 0 xffff ;)",
    "insertText": "t(f.u >> 12)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # ifndef STBIR_FORCE_GATHER_FILTER_SCANLINES_AMOUNT # define STBIR_FORCE_GATHER_FILTER_SCANLINES_AMOUNT 3 2 # endif # ifndef STBIR_FORCE_MINIMUM_SCANLINES_FOR_SPLITS # define STBIR_FORCE_MINIMUM_SCANLINES_FOR_SPLITS 4 # endif # if)",
    "insertText": "defined(_MSC_VER ) && !defined(__clang__) #define STBIR_STREAMOUT_PTR( star ) star __restrict #define STBIR_NO_UNROLL( ptr ) __assume(ptr) #elif defined( __clang__ ) #define STBIR_STREAMOUT_PTR( star ) star __restrict__ #define STBIR_NO_UNROLL( ptr ) __asm__ (\"\"::\"r\"(ptr)) #elif defined( __GNUC__ ) #define STBIR_STREAMOUT_PTR( star ) star __restrict__ #define STBIR_NO_UNROLL( ptr ) __asm__ (\"\"::\"r\"(ptr)) #else #define STBIR_STREAMOUT_PTR( star ) star #define STBIR_NO_UNROLL( ptr ) #endif #ifdef STBIR_NO_SIMD #ifdef STBIR_SSE2 #undef STBIR_SSE2 #endif #ifdef STBIR_AVX #undef STBIR_AVX #endif #ifdef STBIR_NEON #undef STBIR_NEON #endif #ifdef STBIR_AVX2 #undef STBIR_AVX2 #endif #ifdef STBIR_FP16C #undef STBIR_FP16C #endif #ifdef STBIR_WASM #undef STBIR_WASM #endif #ifdef STBIR_SIMD #undef STBIR_SIMD #endif #else #ifdef STBIR_SSE2 #include <emmintrin.h> #define stbir__simdf __m128 #define stbir__simdi __m128i #define stbir_simdi_castf( reg ) _mm_castps_si128(reg) #define stbir_simdf_casti( reg ) _mm_castsi128_ps(reg) #define stbir__simdf_load( reg, ptr ) (reg) = _mm_loadu_ps( (float const*)(ptr) ) #define stbir__simdi_load( reg, ptr ) (reg) = _mm_loadu_si128 ( (stbir__simdi const*)(ptr) ) #define stbir__simdf_load1( out, ptr ) (out) = _mm_load_ss( (float const*)(ptr) ) #define stbir__simdi_load1( out, ptr ) (out) = _mm_castps_si128( _mm_load_ss( (float const*)(ptr) )) #define stbir__simdf_load1z( out, ptr ) (out) = _mm_load_ss( (float const*)(ptr) ) #define stbir__simdf_frep4( fvar ) _mm_set_ps1( fvar ) #define stbir__simdf_load1frep4( out, fvar ) (out) = _mm_set_ps1( fvar ) #define stbir__simdf_load2( out, ptr ) (out) = _mm_castsi128_ps( _mm_loadl_epi64( (__m128i*)(ptr)) ) #define stbir__simdf_load2z( out, ptr ) (out) = _mm_castsi128_ps( _mm_loadl_epi64( (__m128i*)(ptr)) ) #define stbir__simdf_load2hmerge( out, reg, ptr ) (out) = _mm_castpd_ps(_mm_loadh_pd( _mm_castps_pd(reg), (double*)(ptr) )) #define stbir__simdf_zeroP() _mm_setzero_ps() #define stbir__simdf_zero( reg ) (reg) = _mm_setzero_ps() #define stbir__simdf_store( ptr, reg ) _mm_storeu_ps( (float*)(ptr), reg ) #define stbir__simdf_store1( ptr, reg ) _mm_store_ss( (float*)(ptr), reg ) #define stbir__simdf_store2( ptr, reg ) _mm_storel_epi64( (__m128i*)(ptr), _mm_castps_si128(reg) ) #define stbir__simdf_store2h( ptr, reg ) _mm_storeh_pd( (double*)(ptr), _mm_castps_pd(reg) ) #define stbir__simdi_store( ptr, reg ) _mm_storeu_si128( (__m128i*)(ptr), reg ) #define stbir__simdi_store1( ptr, reg ) _mm_store_ss( (float*)(ptr), _mm_castsi128_ps(reg) ) #define stbir__simdi_store2( ptr, reg ) _mm_storel_epi64( (__m128i*)(ptr), (reg) ) #define stbir__prefetch( ptr ) _mm_prefetch((char*)(ptr), _MM_HINT_T0 ) #define stbir__simdi_expand_u8_to_u32(out0,out1,out2,out3,ireg)"
  },
  {
    "label": "_mm_setzero_si128()",
    "kind": "Method",
    "detail": "Function (\\ stbir__simdi zero =)",
    "insertText": "_mm_setzero_si128()"
  },
  {
    "label": "_mm_unpacklo_epi8()",
    "kind": "Method",
    "detail": "Function (\\ out2 =)",
    "insertText": "_mm_unpacklo_epi8(ireg, zero)"
  },
  {
    "label": "_mm_unpackhi_epi8()",
    "kind": "Method",
    "detail": "Function (\\ out3 =)",
    "insertText": "_mm_unpackhi_epi8(ireg, zero)"
  },
  {
    "label": "_mm_unpacklo_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out0 =)",
    "insertText": "_mm_unpacklo_epi16(out2, zero)"
  },
  {
    "label": "_mm_unpackhi_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out1 =)",
    "insertText": "_mm_unpackhi_epi16(out2, zero)"
  },
  {
    "label": "_mm_unpacklo_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out2 =)",
    "insertText": "_mm_unpacklo_epi16(out3, zero)"
  },
  {
    "label": "_mm_unpackhi_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out3 =)",
    "insertText": "_mm_unpackhi_epi16(out3, zero)"
  },
  {
    "label": "stbir__simdi_expand_u8_to_1u32()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdi_expand_u8_to_1u32(out,ireg)"
  },
  {
    "label": "_mm_unpacklo_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "_mm_unpacklo_epi16(out, zero)"
  },
  {
    "label": "stbir__simdi_expand_u16_to_u32()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdi_expand_u16_to_u32(out0,out1,ireg)"
  },
  {
    "label": "_mm_unpacklo_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out0 =)",
    "insertText": "_mm_unpacklo_epi16(ireg, zero)"
  },
  {
    "label": "_mm_unpackhi_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out1 =)",
    "insertText": "_mm_unpackhi_epi16(ireg, zero)"
  },
  {
    "label": "stbir__simdf_convert_float_to_i32()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdf_convert_float_to_i32(i, f ) (i) = _mm_cvttps_epi32(f) #define stbir__simdf_convert_float_to_int( f ) _mm_cvtt_ss2si(f) #define stbir__simdf_convert_float_to_uint8( f ) ((unsigned char)_mm_cvtsi128_si32(_mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(f,STBIR__CONSTF(STBIR_max_uint8_as_float)),_mm_setzero_ps())))) #define stbir__simdf_convert_float_to_short( f ) ((unsigned short)_mm_cvtsi128_si32(_mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(f,STBIR__CONSTF(STBIR_max_uint16_as_float)),_mm_setzero_ps())))) #define stbir__simdi_to_int( i ) _mm_cvtsi128_si32(i) #define stbir__simdi_convert_i32_to_float(out, ireg) (out) = _mm_cvtepi32_ps( ireg ) #define stbir__simdf_add( out, reg0, reg1 ) (out) = _mm_add_ps( reg0, reg1 ) #define stbir__simdf_mult( out, reg0, reg1 ) (out) = _mm_mul_ps( reg0, reg1 ) #define stbir__simdf_mult_mem( out, reg, ptr ) (out) = _mm_mul_ps( reg, _mm_loadu_ps( (float const*)(ptr) ) ) #define stbir__simdf_mult1_mem( out, reg, ptr ) (out) = _mm_mul_ss( reg, _mm_load_ss( (float const*)(ptr) ) ) #define stbir__simdf_add_mem( out, reg, ptr ) (out) = _mm_add_ps( reg, _mm_loadu_ps( (float const*)(ptr) ) ) #define stbir__simdf_add1_mem( out, reg, ptr ) (out) = _mm_add_ss( reg, _mm_load_ss( (float const*)(ptr) ) ) #ifdef STBIR_USE_FMA #include <immintrin.h> #define stbir__simdf_madd( out, add, mul1, mul2 ) (out) = _mm_fmadd_ps( mul1, mul2, add ) #define stbir__simdf_madd1( out, add, mul1, mul2 ) (out) = _mm_fmadd_ss( mul1, mul2, add ) #define stbir__simdf_madd_mem( out, add, mul, ptr ) (out) = _mm_fmadd_ps( mul, _mm_loadu_ps( (float const*)(ptr) ), add ) #define stbir__simdf_madd1_mem( out, add, mul, ptr ) (out) = _mm_fmadd_ss( mul, _mm_load_ss( (float const*)(ptr) ), add ) #else #define stbir__simdf_madd( out, add, mul1, mul2 ) (out) = _mm_add_ps( add, _mm_mul_ps( mul1, mul2 ) ) #define stbir__simdf_madd1( out, add, mul1, mul2 ) (out) = _mm_add_ss( add, _mm_mul_ss( mul1, mul2 ) ) #define stbir__simdf_madd_mem( out, add, mul, ptr ) (out) = _mm_add_ps( add, _mm_mul_ps( mul, _mm_loadu_ps( (float const*)(ptr) ) ) ) #define stbir__simdf_madd1_mem( out, add, mul, ptr ) (out) = _mm_add_ss( add, _mm_mul_ss( mul, _mm_load_ss( (float const*)(ptr) ) ) ) #endif #define stbir__simdf_add1( out, reg0, reg1 ) (out) = _mm_add_ss( reg0, reg1 ) #define stbir__simdf_mult1( out, reg0, reg1 ) (out) = _mm_mul_ss( reg0, reg1 ) #define stbir__simdf_and( out, reg0, reg1 ) (out) = _mm_and_ps( reg0, reg1 ) #define stbir__simdf_or( out, reg0, reg1 ) (out) = _mm_or_ps( reg0, reg1 ) #define stbir__simdf_min( out, reg0, reg1 ) (out) = _mm_min_ps( reg0, reg1 ) #define stbir__simdf_max( out, reg0, reg1 ) (out) = _mm_max_ps( reg0, reg1 ) #define stbir__simdf_min1( out, reg0, reg1 ) (out) = _mm_min_ss( reg0, reg1 ) #define stbir__simdf_max1( out, reg0, reg1 ) (out) = _mm_max_ss( reg0, reg1 ) #define stbir__simdf_0123ABCDto3ABx( out, reg0, reg1 ) (out)=_mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( _mm_shuffle_ps( reg1,reg0, (0<<0) + (1<<2) + (2<<4) + (3<<6) )), (3<<0) + (0<<2) + (1<<4) + (2<<6) ) ) #define stbir__simdf_0123ABCDto23Ax( out, reg0, reg1 ) (out)=_mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( _mm_shuffle_ps( reg1,reg0, (0<<0) + (1<<2) + (2<<4) + (3<<6) )), (2<<0) + (3<<2) + (0<<4) + (1<<6) ))"
  },
  {
    "label": "stbir__simdf_aaa1()",
    "kind": "Method",
    "detail": "Function (0 . 0 f,1 . 0 f,0 . 0 f,1 . 0 f } ; const stbir__simdf STBIR_onezeros = { 1 . 0 f,0 . 0 f,1 . 0 f,0 . 0 f } ; # define)",
    "insertText": "stbir__simdf_aaa1(out, alp, ones ) (out)=_mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( _mm_movehl_ps( ones, alp ) ), (1<<0) + (1<<2) + (1<<4) + (2<<6) ) ) #define stbir__simdf_1aaa( out, alp, ones ) (out)=_mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( _mm_movelh_ps( ones, alp ) ), (0<<0) + (2<<2) + (2<<4) + (2<<6) ) ) #define stbir__simdf_a1a1( out, alp, ones) (out) = _mm_or_ps( _mm_castsi128_ps( _mm_srli_epi64( _mm_castps_si128(alp), 32 ) ), STBIR_zeroones ) #define stbir__simdf_1a1a( out, alp, ones) (out) = _mm_or_ps( _mm_castsi128_ps( _mm_slli_epi64( _mm_castps_si128(alp), 32 ) ), STBIR_onezeros ) #define stbir__simdf_swiz( reg, one, two, three, four ) _mm_castsi128_ps( _mm_shuffle_epi32( _mm_castps_si128( reg ), (one<<0) + (two<<2) + (three<<4) + (four<<6) ) ) #define stbir__simdi_and( out, reg0, reg1 ) (out) = _mm_and_si128( reg0, reg1 ) #define stbir__simdi_or( out, reg0, reg1 ) (out) = _mm_or_si128( reg0, reg1 ) #define stbir__simdi_16madd( out, reg0, reg1 ) (out) = _mm_madd_epi16( reg0, reg1 ) #define stbir__simdf_pack_to_8bytes(out,aa,bb)"
  },
  {
    "label": "_mm_min_ps()",
    "kind": "Method",
    "detail": "Function (\\ stbir__simdf af,bf ; \\ stbir__simdi a,b ; \\ af =)",
    "insertText": "_mm_min_ps(aa, STBIR_max_uint8_as_float)"
  },
  {
    "label": "_mm_min_ps()",
    "kind": "Method",
    "detail": "Function (\\ bf =)",
    "insertText": "_mm_min_ps(bb, STBIR_max_uint8_as_float)"
  },
  {
    "label": "_mm_max_ps()",
    "kind": "Method",
    "detail": "Function (\\ af =)",
    "insertText": "_mm_max_ps(af, _mm_setzero_ps())"
  },
  {
    "label": "_mm_max_ps()",
    "kind": "Method",
    "detail": "Function (\\ bf =)",
    "insertText": "_mm_max_ps(bf, _mm_setzero_ps())"
  },
  {
    "label": "_mm_cvttps_epi32()",
    "kind": "Method",
    "detail": "Function (\\ a =)",
    "insertText": "_mm_cvttps_epi32(af)"
  },
  {
    "label": "_mm_cvttps_epi32()",
    "kind": "Method",
    "detail": "Function (\\ b =)",
    "insertText": "_mm_cvttps_epi32(bf)"
  },
  {
    "label": "_mm_packs_epi32()",
    "kind": "Method",
    "detail": "Function (\\ a =)",
    "insertText": "_mm_packs_epi32(a, b)"
  },
  {
    "label": "_mm_packus_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "_mm_packus_epi16(a, a)"
  },
  {
    "label": "stbir__simdf_load4_transposed()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdf_load4_transposed(o0, o1, o2, o3, ptr ) \\ stbir__simdf_load( o0, (ptr))"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load(o1, (ptr)+4)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load(o2, (ptr)+8)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load(o3, (ptr)+12)"
  },
  {
    "label": "_mm_unpacklo_ps()",
    "kind": "Method",
    "detail": "Function (\\ { \\ __m128 tmp0,tmp1,tmp2,tmp3 ; \\ tmp0 =)",
    "insertText": "_mm_unpacklo_ps(o0, o1)"
  },
  {
    "label": "_mm_unpacklo_ps()",
    "kind": "Method",
    "detail": "Function (\\ tmp2 =)",
    "insertText": "_mm_unpacklo_ps(o2, o3)"
  },
  {
    "label": "_mm_unpackhi_ps()",
    "kind": "Method",
    "detail": "Function (\\ tmp1 =)",
    "insertText": "_mm_unpackhi_ps(o0, o1)"
  },
  {
    "label": "_mm_unpackhi_ps()",
    "kind": "Method",
    "detail": "Function (\\ tmp3 =)",
    "insertText": "_mm_unpackhi_ps(o2, o3)"
  },
  {
    "label": "_mm_movelh_ps()",
    "kind": "Method",
    "detail": "Function (\\ o0 =)",
    "insertText": "_mm_movelh_ps(tmp0, tmp2)"
  },
  {
    "label": "_mm_movehl_ps()",
    "kind": "Method",
    "detail": "Function (\\ o1 =)",
    "insertText": "_mm_movehl_ps(tmp2, tmp0)"
  },
  {
    "label": "_mm_movelh_ps()",
    "kind": "Method",
    "detail": "Function (\\ o2 =)",
    "insertText": "_mm_movelh_ps(tmp1, tmp3)"
  },
  {
    "label": "_mm_movehl_ps()",
    "kind": "Method",
    "detail": "Function (\\ o3 =)",
    "insertText": "_mm_movehl_ps(tmp3, tmp1)"
  },
  {
    "label": "stbir__interleave_pack_and_store_16_u8()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__interleave_pack_and_store_16_u8(ptr, r0, r1, r2, r3 ) \\ r0 = _mm_packs_epi32( r0, r1)"
  },
  {
    "label": "_mm_packs_epi32()",
    "kind": "Method",
    "detail": "Function (\\ r2 =)",
    "insertText": "_mm_packs_epi32(r2, r3)"
  },
  {
    "label": "_mm_unpacklo_epi16()",
    "kind": "Method",
    "detail": "Function (\\ r1 =)",
    "insertText": "_mm_unpacklo_epi16(r0, r2)"
  },
  {
    "label": "_mm_unpackhi_epi16()",
    "kind": "Method",
    "detail": "Function (\\ r3 =)",
    "insertText": "_mm_unpackhi_epi16(r0, r2)"
  },
  {
    "label": "_mm_unpacklo_epi16()",
    "kind": "Method",
    "detail": "Function (\\ r0 =)",
    "insertText": "_mm_unpacklo_epi16(r1, r3)"
  },
  {
    "label": "_mm_unpackhi_epi16()",
    "kind": "Method",
    "detail": "Function (\\ r2 =)",
    "insertText": "_mm_unpackhi_epi16(r1, r3)"
  },
  {
    "label": "_mm_packus_epi16()",
    "kind": "Method",
    "detail": "Function (\\ r0 =)",
    "insertText": "_mm_packus_epi16(r0, r2)"
  },
  {
    "label": "stbir__simdi_store()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdi_store(ptr, r0)"
  },
  {
    "label": "stbir__simdi_32shr()",
    "kind": "Method",
    "detail": "Function (\\ # define)",
    "insertText": "stbir__simdi_32shr(out, reg, imm ) out = _mm_srli_epi32( reg, imm ) #if defined(_MSC_VER) && !defined(__clang__) #define STBIR__CONST_32_TO_8( v ) (char)(unsigned char)((v)&255),(char)(unsigned char)(((v)>>8)&255),(char)(unsigned char)(((v)>>16)&255),(char)(unsigned char)(((v)>>24)&255) #define STBIR__CONST_4_32i( v ) STBIR__CONST_32_TO_8( v ), STBIR__CONST_32_TO_8( v ), STBIR__CONST_32_TO_8( v ), STBIR__CONST_32_TO_8( v ) #define STBIR__CONST_4d_32i( v0, v1, v2, v3 ) STBIR__CONST_32_TO_8( v0 ), STBIR__CONST_32_TO_8( v1 ), STBIR__CONST_32_TO_8( v2 ), STBIR__CONST_32_TO_8( v3 ) #else #define STBIR__CONST_4_32i( v ) (long long)((((stbir_uint64)(stbir_uint32)(v))<<32)|((stbir_uint64)(stbir_uint32)(v))),(long long)((((stbir_uint64)(stbir_uint32)(v))<<32)|((stbir_uint64)(stbir_uint32)(v))) #define STBIR__CONST_4d_32i( v0, v1, v2, v3 ) (long long)((((stbir_uint64)(stbir_uint32)(v1))<<32)|((stbir_uint64)(stbir_uint32)(v0))),(long long)((((stbir_uint64)(stbir_uint32)(v3))<<32)|((stbir_uint64)(stbir_uint32)(v2))) #endif #define STBIR__SIMDF_CONST(var, x)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (x,x,x,x } # define)",
    "insertText": "STBIR__SIMDI_CONST(var, x)"
  },
  {
    "label": "STBIR__CONST_4_32i()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__CONST_4_32i(x) } #define STBIR__CONSTF(var) (var) #define STBIR__CONSTI(var) (var) #if defined(STBIR_AVX) || defined(__SSE4_1__) #include <smmintrin.h> #define stbir__simdf_pack_to_8words(out,reg0,reg1) out = _mm_packus_epi32(_mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(reg0,STBIR__CONSTF(STBIR_max_uint16_as_float)),_mm_setzero_ps())), _mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(reg1,STBIR__CONSTF(STBIR_max_uint16_as_float)),_mm_setzero_ps()))) #else STBIR__SIMDI_CONST(stbir__s32_32768, 32768)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__SIMDI_CONST(stbir__s16_32768, ((32768<<16)|32768))"
  },
  {
    "label": "stbir__simdf_pack_to_8words()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__simdf_pack_to_8words(out,reg0,reg1)"
  },
  {
    "label": "_mm_cvttps_epi32()",
    "kind": "Method",
    "detail": "Function (\\ stbir__simdi tmp0,tmp1 ; \\ tmp0 =)",
    "insertText": "_mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(reg0,STBIR__CONSTF(STBIR_max_uint16_as_float)),_mm_setzero_ps()))"
  },
  {
    "label": "_mm_cvttps_epi32()",
    "kind": "Method",
    "detail": "Function (\\ tmp1 =)",
    "insertText": "_mm_cvttps_epi32(_mm_max_ps(_mm_min_ps(reg1,STBIR__CONSTF(STBIR_max_uint16_as_float)),_mm_setzero_ps()))"
  },
  {
    "label": "_mm_sub_epi32()",
    "kind": "Method",
    "detail": "Function (\\ tmp0 =)",
    "insertText": "_mm_sub_epi32(tmp0, stbir__s32_32768)"
  },
  {
    "label": "_mm_sub_epi32()",
    "kind": "Method",
    "detail": "Function (\\ tmp1 =)",
    "insertText": "_mm_sub_epi32(tmp1, stbir__s32_32768)"
  },
  {
    "label": "_mm_packs_epi32()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "_mm_packs_epi32(tmp0, tmp1)"
  },
  {
    "label": "_mm_sub_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "_mm_sub_epi16(out, stbir__s16_32768)"
  },
  {
    "label": "stbir__simdf8_load()",
    "kind": "Method",
    "detail": "Function (\\ } # endif # define STBIR_SIMD # ifdef STBIR_AVX # include<immintrin . h> # define STBIR_SIMD8 # define stbir__simdf8 __m256 # define stbir__simdi8 __m256i # define)",
    "insertText": "stbir__simdf8_load(out, ptr ) (out) = _mm256_loadu_ps( (float const *)(ptr) ) #define stbir__simdi8_load( out, ptr ) (out) = _mm256_loadu_si256( (__m256i const *)(ptr) ) #define stbir__simdf8_mult( out, a, b ) (out) = _mm256_mul_ps( (a), (b) ) #define stbir__simdf8_store( ptr, out ) _mm256_storeu_ps( (float*)(ptr), out ) #define stbir__simdi8_store( ptr, reg ) _mm256_storeu_si256( (__m256i*)(ptr), reg ) #define stbir__simdf8_frep8( fval ) _mm256_set1_ps( fval ) #define stbir__simdf8_min( out, reg0, reg1 ) (out) = _mm256_min_ps( reg0, reg1 ) #define stbir__simdf8_max( out, reg0, reg1 ) (out) = _mm256_max_ps( reg0, reg1 ) #define stbir__simdf8_add4halves( out, bot4, top8 ) (out) = _mm_add_ps( bot4, _mm256_extractf128_ps( top8, 1 ) ) #define stbir__simdf8_mult_mem( out, reg, ptr ) (out) = _mm256_mul_ps( reg, _mm256_loadu_ps( (float const*)(ptr) ) ) #define stbir__simdf8_add_mem( out, reg, ptr ) (out) = _mm256_add_ps( reg, _mm256_loadu_ps( (float const*)(ptr) ) ) #define stbir__simdf8_add( out, a, b ) (out) = _mm256_add_ps( a, b ) #define stbir__simdf8_load1b( out, ptr ) (out) = _mm256_broadcast_ss( ptr ) #define stbir__simdf_load1rep4( out, ptr ) (out) = _mm_broadcast_ss( ptr ) #define stbir__simdi8_convert_i32_to_float(out, ireg) (out) = _mm256_cvtepi32_ps( ireg ) #define stbir__simdf8_convert_float_to_i32( i, f ) (i) = _mm256_cvttps_epi32(f) #define stbir__simdf8_bot4s( out, a, b ) (out) = _mm256_permute2f128_ps(a,b, (0<<0)+(2<<4) ) #define stbir__simdf8_top4s( out, a, b ) (out) = _mm256_permute2f128_ps(a,b, (1<<0)+(3<<4) ) #define stbir__simdf8_gettop4( reg ) _mm256_extractf128_ps(reg,1) #ifdef STBIR_AVX2 #define stbir__simdi8_expand_u8_to_u32(out0,out1,ireg)"
  },
  {
    "label": "_mm256_setzero_si256()",
    "kind": "Method",
    "detail": "Function (\\ stbir__simdi8 a,zero =)",
    "insertText": "_mm256_setzero_si256()"
  },
  {
    "label": "_mm256_permute4x64_epi64()",
    "kind": "Method",
    "detail": "Function (\\ a =)",
    "insertText": "_mm256_permute4x64_epi64(_mm256_unpacklo_epi8( _mm256_permute4x64_epi64(_mm256_castsi128_si256(ireg),(0<<0)+(2<<2)+(1<<4)+(3<<6)), zero ),(0<<0)+(2<<2)+(1<<4)+(3<<6))"
  },
  {
    "label": "_mm256_unpacklo_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out0 =)",
    "insertText": "_mm256_unpacklo_epi16(a, zero)"
  },
  {
    "label": "_mm256_unpackhi_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out1 =)",
    "insertText": "_mm256_unpackhi_epi16(a, zero)"
  },
  {
    "label": "stbir__simdf8_pack_to_16bytes()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdf8_pack_to_16bytes(out,aa,bb)"
  },
  {
    "label": "_mm256_min_ps()",
    "kind": "Method",
    "detail": "Function (\\ stbir__simdi8 t ; \\ stbir__simdf8 af,bf ; \\ stbir__simdi8 a,b ; \\ af =)",
    "insertText": "_mm256_min_ps(aa, STBIR_max_uint8_as_floatX)"
  },
  {
    "label": "_mm256_min_ps()",
    "kind": "Method",
    "detail": "Function (\\ bf =)",
    "insertText": "_mm256_min_ps(bb, STBIR_max_uint8_as_floatX)"
  },
  {
    "label": "_mm256_max_ps()",
    "kind": "Method",
    "detail": "Function (\\ af =)",
    "insertText": "_mm256_max_ps(af, _mm256_setzero_ps())"
  },
  {
    "label": "_mm256_max_ps()",
    "kind": "Method",
    "detail": "Function (\\ bf =)",
    "insertText": "_mm256_max_ps(bf, _mm256_setzero_ps())"
  },
  {
    "label": "_mm256_cvttps_epi32()",
    "kind": "Method",
    "detail": "Function (\\ a =)",
    "insertText": "_mm256_cvttps_epi32(af)"
  },
  {
    "label": "_mm256_cvttps_epi32()",
    "kind": "Method",
    "detail": "Function (\\ b =)",
    "insertText": "_mm256_cvttps_epi32(bf)"
  },
  {
    "label": "_mm256_permute4x64_epi64()",
    "kind": "Method",
    "detail": "Function (\\ t =)",
    "insertText": "_mm256_permute4x64_epi64(_mm256_packs_epi32( a, b ), (0<<0)+(2<<2)+(1<<4)+(3<<6))"
  },
  {
    "label": "_mm256_castsi256_si128()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "_mm256_castsi256_si128(_mm256_permute4x64_epi64( _mm256_packus_epi16( t, t ), (0<<0)+(2<<2)+(1<<4)+(3<<6) ))"
  },
  {
    "label": "stbir__simdi8_expand_u16_to_u32()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdi8_expand_u16_to_u32(out,ireg) out = _mm256_unpacklo_epi16( _mm256_permute4x64_epi64(_mm256_castsi128_si256(ireg),(0<<0)+(2<<2)+(1<<4)+(3<<6)), _mm256_setzero_si256())"
  },
  {
    "label": "stbir__simdf8_pack_to_16words()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__simdf8_pack_to_16words(out,aa,bb)"
  },
  {
    "label": "_mm256_min_ps()",
    "kind": "Method",
    "detail": "Function (\\ stbir__simdf8 af,bf ; \\ stbir__simdi8 a,b ; \\ af =)",
    "insertText": "_mm256_min_ps(aa, STBIR_max_uint16_as_floatX)"
  },
  {
    "label": "_mm256_min_ps()",
    "kind": "Method",
    "detail": "Function (\\ bf =)",
    "insertText": "_mm256_min_ps(bb, STBIR_max_uint16_as_floatX)"
  },
  {
    "label": "stbir__simdi8_expand_u8_to_u32()",
    "kind": "Method",
    "detail": "Function (\\ } # else # define)",
    "insertText": "stbir__simdi8_expand_u8_to_u32(out0,out1,ireg)"
  },
  {
    "label": "_mm256_setr_m128i()",
    "kind": "Method",
    "detail": "Function (\\ out0 =)",
    "insertText": "_mm256_setr_m128i(_mm_unpacklo_epi16( a, zero ), _mm_unpackhi_epi16( a, zero ))"
  },
  {
    "label": "_mm_packs_epi32()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "_mm_packs_epi32(_mm256_castsi256_si128(a), _mm256_extractf128_si256( a, 1 ))"
  },
  {
    "label": "_mm_packus_epi16()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "_mm_packus_epi16(out, out)"
  },
  {
    "label": "_mm_packs_epi32()",
    "kind": "Method",
    "detail": "Function (\\ t =)",
    "insertText": "_mm_packs_epi32(_mm256_castsi256_si128(b), _mm256_extractf128_si256( b, 1 ))"
  },
  {
    "label": "_mm_packus_epi16()",
    "kind": "Method",
    "detail": "Function (\\ t =)",
    "insertText": "_mm_packus_epi16(t, t)"
  },
  {
    "label": "_mm_castps_si128()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "_mm_castps_si128(_mm_shuffle_ps( _mm_castsi128_ps(out), _mm_castsi128_ps(t), (0<<0)+(1<<2)+(0<<4)+(1<<6) ))"
  },
  {
    "label": "stbir__simdi8_expand_u16_to_u32()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdi8_expand_u16_to_u32(out,ireg)"
  },
  {
    "label": "_mm256_insertf128_si256()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "_mm256_insertf128_si256(_mm256_castsi128_si256( a ), b, 1)"
  },
  {
    "label": "_mm_packus_epi32()",
    "kind": "Method",
    "detail": "Function (\\ t0 =)",
    "insertText": "_mm_packus_epi32(_mm256_castsi256_si128(a), _mm256_extractf128_si256( a, 1 ))"
  },
  {
    "label": "_mm_packus_epi32()",
    "kind": "Method",
    "detail": "Function (\\ t1 =)",
    "insertText": "_mm_packus_epi32(_mm256_castsi256_si128(b), _mm256_extractf128_si256( b, 1 ))"
  },
  {
    "label": "_mm256_setr_m128i()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "_mm256_setr_m128i(t0, t1)"
  },
  {
    "label": "STBIR__CONST_4d_32i()",
    "kind": "Method",
    "detail": "Function (\\ } # endif __m256i stbir_00001111 = {)",
    "insertText": "STBIR__CONST_4d_32i(0, 0, 0, 0 ), STBIR__CONST_4d_32i( 1, 1, 1, 1)"
  },
  {
    "label": "stbir__simdf8_0123to00001111()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__simdf8_0123to00001111(out, in ) (out) = _mm256_permutevar_ps ( in, stbir_00001111)"
  },
  {
    "label": "STBIR__CONST_4d_32i()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__CONST_4d_32i(2, 2, 2, 2 ), STBIR__CONST_4d_32i( 3, 3, 3, 3)"
  },
  {
    "label": "stbir__simdf8_0123to22223333()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__simdf8_0123to22223333(out, in ) (out) = _mm256_permutevar_ps ( in, stbir_22223333 ) #define stbir__simdf8_0123to2222( out, in ) (out) = stbir__simdf_swiz(_mm256_castps256_ps128(in), 2,2,2,2 ) #define stbir__simdf8_load4b( out, ptr ) (out) = _mm256_broadcast_ps( (__m128 const *)(ptr))"
  },
  {
    "label": "STBIR__CONST_4d_32i()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__CONST_4d_32i(0, 0, 1, 1 ), STBIR__CONST_4d_32i( 2, 2, 3, 3)"
  },
  {
    "label": "stbir__simdf8_0123to00112233()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__simdf8_0123to00112233(out, in ) (out) = _mm256_permutevar_ps ( in, stbir_00112233 ) #define stbir__simdf8_add4( out, a8, b ) (out) = _mm256_add_ps( a8, _mm256_castps128_ps256( b ))"
  },
  {
    "label": "STBIR__CONST_4_32i()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__CONST_4_32i(0x80000000 ), STBIR__CONST_4d_32i( 0x80000000, 0x80000000, 0, 0)"
  },
  {
    "label": "stbir__simdf8_load6z()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__simdf8_load6z(out, ptr ) (out) = _mm256_maskload_ps( ptr, stbir_load6 ) #define stbir__simdf8_0123to00000000( out, in ) (out) = _mm256_shuffle_ps ( in, in, (0<<0)+(0<<2)+(0<<4)+(0<<6) ) #define stbir__simdf8_0123to11111111( out, in ) (out) = _mm256_shuffle_ps ( in, in, (1<<0)+(1<<2)+(1<<4)+(1<<6) ) #define stbir__simdf8_0123to22222222( out, in ) (out) = _mm256_shuffle_ps ( in, in, (2<<0)+(2<<2)+(2<<4)+(2<<6) ) #define stbir__simdf8_0123to33333333( out, in ) (out) = _mm256_shuffle_ps ( in, in, (3<<0)+(3<<2)+(3<<4)+(3<<6) ) #define stbir__simdf8_0123to21032103( out, in ) (out) = _mm256_shuffle_ps ( in, in, (2<<0)+(1<<2)+(0<<4)+(3<<6) ) #define stbir__simdf8_0123to32103210( out, in ) (out) = _mm256_shuffle_ps ( in, in, (3<<0)+(2<<2)+(1<<4)+(0<<6) ) #define stbir__simdf8_0123to12301230( out, in ) (out) = _mm256_shuffle_ps ( in, in, (1<<0)+(2<<2)+(3<<4)+(0<<6) ) #define stbir__simdf8_0123to10321032( out, in ) (out) = _mm256_shuffle_ps ( in, in, (1<<0)+(0<<2)+(3<<4)+(2<<6) ) #define stbir__simdf8_0123to30123012( out, in ) (out) = _mm256_shuffle_ps ( in, in, (3<<0)+(0<<2)+(1<<4)+(2<<6) ) #define stbir__simdf8_0123to11331133( out, in ) (out) = _mm256_shuffle_ps ( in, in, (1<<0)+(1<<2)+(3<<4)+(3<<6) ) #define stbir__simdf8_0123to00220022( out, in ) (out) = _mm256_shuffle_ps ( in, in, (0<<0)+(0<<2)+(2<<4)+(2<<6) ) #define stbir__simdf8_aaa1( out, alp, ones ) (out) = _mm256_blend_ps( alp, ones, (1<<0)+(1<<1)+(1<<2)+(0<<3)+(1<<4)+(1<<5)+(1<<6)+(0<<7))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(STBIR_AVX) || defined(__SSE4_1__) || defined(STBIR_SSE41) __m128 t = _mm_set_ss(x)"
  },
  {
    "label": "_mm_set_ss()",
    "kind": "Method",
    "detail": "Function (# else __m128 f =)",
    "insertText": "_mm_set_ss(x)"
  },
  {
    "label": "_mm_cvtepi32_ps()",
    "kind": "Method",
    "detail": "Function (__m128 t =)",
    "insertText": "_mm_cvtepi32_ps(_mm_cvttps_epi32(f))"
  },
  {
    "label": "_mm_add_ss()",
    "kind": "Method",
    "detail": "Function (__m128 r =)",
    "insertText": "_mm_add_ss(t, _mm_and_ps(_mm_cmplt_ss(f, t), _mm_set_ss(-1.0f)))"
  },
  {
    "label": "stbir_simd_ceilf()",
    "kind": "Method",
    "detail": "Function (# endif } # ifdef STBIR_CEILF # undef STBIR_CEILF # endif # define STBIR_CEILF stbir_simd_ceilf stbir__inline float)",
    "insertText": "stbir_simd_ceilf(float x)"
  },
  {
    "label": "_mm_add_ss()",
    "kind": "Method",
    "detail": "Function (__m128 r =)",
    "insertText": "_mm_add_ss(t, _mm_and_ps(_mm_cmplt_ss(t, f), _mm_set_ss(1.0f)))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif } # elif)",
    "insertText": "defined(STBIR_NEON) #include <arm_neon.h> #define stbir__simdf float32x4_t #define stbir__simdi uint32x4_t #define stbir_simdi_castf( reg ) vreinterpretq_u32_f32(reg) #define stbir_simdf_casti( reg ) vreinterpretq_f32_u32(reg) #define stbir__simdf_load( reg, ptr ) (reg) = vld1q_f32( (float const*)(ptr) ) #define stbir__simdi_load( reg, ptr ) (reg) = vld1q_u32( (uint32_t const*)(ptr) ) #define stbir__simdf_load1( out, ptr ) (out) = vld1q_dup_f32( (float const*)(ptr) ) #define stbir__simdi_load1( out, ptr ) (out) = vld1q_dup_u32( (uint32_t const*)(ptr) ) #define stbir__simdf_load1z( out, ptr ) (out) = vld1q_lane_f32( (float const*)(ptr), vdupq_n_f32(0), 0 ) #define stbir__simdf_frep4( fvar ) vdupq_n_f32( fvar ) #define stbir__simdf_load1frep4( out, fvar ) (out) = vdupq_n_f32( fvar ) #define stbir__simdf_load2( out, ptr ) (out) = vcombine_f32( vld1_f32( (float const*)(ptr) ), vcreate_f32(0) ) #define stbir__simdf_load2z( out, ptr ) (out) = vcombine_f32( vld1_f32( (float const*)(ptr) ), vcreate_f32(0) ) #define stbir__simdf_load2hmerge( out, reg, ptr ) (out) = vcombine_f32( vget_low_f32(reg), vld1_f32( (float const*)(ptr) ) ) #define stbir__simdf_zeroP() vdupq_n_f32(0) #define stbir__simdf_zero( reg ) (reg) = vdupq_n_f32(0) #define stbir__simdf_store( ptr, reg ) vst1q_f32( (float*)(ptr), reg ) #define stbir__simdf_store1( ptr, reg ) vst1q_lane_f32( (float*)(ptr), reg, 0) #define stbir__simdf_store2( ptr, reg ) vst1_f32( (float*)(ptr), vget_low_f32(reg) ) #define stbir__simdf_store2h( ptr, reg ) vst1_f32( (float*)(ptr), vget_high_f32(reg) ) #define stbir__simdi_store( ptr, reg ) vst1q_u32( (uint32_t*)(ptr), reg ) #define stbir__simdi_store1( ptr, reg ) vst1q_lane_u32( (uint32_t*)(ptr), reg, 0 ) #define stbir__simdi_store2( ptr, reg ) vst1_u32( (uint32_t*)(ptr), vget_low_u32(reg) ) #define stbir__prefetch( ptr ) #define stbir__simdi_expand_u8_to_u32(out0,out1,out2,out3,ireg)"
  },
  {
    "label": "vmovl_u8()",
    "kind": "Method",
    "detail": "Function (\\ uint16x8_t l =)",
    "insertText": "vmovl_u8(vget_low_u8 ( vreinterpretq_u8_u32(ireg) ))"
  },
  {
    "label": "vmovl_u8()",
    "kind": "Method",
    "detail": "Function (\\ uint16x8_t h =)",
    "insertText": "vmovl_u8(vget_high_u8( vreinterpretq_u8_u32(ireg) ))"
  },
  {
    "label": "vmovl_u16()",
    "kind": "Method",
    "detail": "Function (\\ out0 =)",
    "insertText": "vmovl_u16(vget_low_u16 ( l ))"
  },
  {
    "label": "vmovl_u16()",
    "kind": "Method",
    "detail": "Function (\\ out1 =)",
    "insertText": "vmovl_u16(vget_high_u16( l ))"
  },
  {
    "label": "vmovl_u16()",
    "kind": "Method",
    "detail": "Function (\\ out2 =)",
    "insertText": "vmovl_u16(vget_low_u16 ( h ))"
  },
  {
    "label": "vmovl_u16()",
    "kind": "Method",
    "detail": "Function (\\ out3 =)",
    "insertText": "vmovl_u16(vget_high_u16( h ))"
  },
  {
    "label": "vmovl_u8()",
    "kind": "Method",
    "detail": "Function (\\ uint16x8_t tmp =)",
    "insertText": "vmovl_u8(vget_low_u8( vreinterpretq_u8_u32(ireg) ))"
  },
  {
    "label": "vmovl_u16()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "vmovl_u16(vget_low_u16( tmp ))"
  },
  {
    "label": "vreinterpretq_u16_u32()",
    "kind": "Method",
    "detail": "Function (\\ uint16x8_t tmp =)",
    "insertText": "vreinterpretq_u16_u32(ireg)"
  },
  {
    "label": "vmovl_u16()",
    "kind": "Method",
    "detail": "Function (\\ out0 =)",
    "insertText": "vmovl_u16(vget_low_u16 ( tmp ))"
  },
  {
    "label": "vmovl_u16()",
    "kind": "Method",
    "detail": "Function (\\ out1 =)",
    "insertText": "vmovl_u16(vget_high_u16( tmp ))"
  },
  {
    "label": "stbir__simdf_convert_float_to_i32()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdf_convert_float_to_i32(i, f ) (i) = vreinterpretq_u32_s32( vcvtq_s32_f32(f) ) #define stbir__simdf_convert_float_to_int( f ) vgetq_lane_s32(vcvtq_s32_f32(f), 0) #define stbir__simdi_to_int( i ) (int)vgetq_lane_u32(i, 0) #define stbir__simdf_convert_float_to_uint8( f ) ((unsigned char)vgetq_lane_s32(vcvtq_s32_f32(vmaxq_f32(vminq_f32(f,STBIR__CONSTF(STBIR_max_uint8_as_float)),vdupq_n_f32(0))), 0)) #define stbir__simdf_convert_float_to_short( f ) ((unsigned short)vgetq_lane_s32(vcvtq_s32_f32(vmaxq_f32(vminq_f32(f,STBIR__CONSTF(STBIR_max_uint16_as_float)),vdupq_n_f32(0))), 0)) #define stbir__simdi_convert_i32_to_float(out, ireg) (out) = vcvtq_f32_s32( vreinterpretq_s32_u32(ireg) ) #define stbir__simdf_add( out, reg0, reg1 ) (out) = vaddq_f32( reg0, reg1 ) #define stbir__simdf_mult( out, reg0, reg1 ) (out) = vmulq_f32( reg0, reg1 ) #define stbir__simdf_mult_mem( out, reg, ptr ) (out) = vmulq_f32( reg, vld1q_f32( (float const*)(ptr) ) ) #define stbir__simdf_mult1_mem( out, reg, ptr ) (out) = vmulq_f32( reg, vld1q_dup_f32( (float const*)(ptr) ) ) #define stbir__simdf_add_mem( out, reg, ptr ) (out) = vaddq_f32( reg, vld1q_f32( (float const*)(ptr) ) ) #define stbir__simdf_add1_mem( out, reg, ptr ) (out) = vaddq_f32( reg, vld1q_dup_f32( (float const*)(ptr) ) ) #ifdef STBIR_USE_FMA #define stbir__simdf_madd( out, add, mul1, mul2 ) (out) = vfmaq_f32( add, mul1, mul2 ) #define stbir__simdf_madd1( out, add, mul1, mul2 ) (out) = vfmaq_f32( add, mul1, mul2 ) #define stbir__simdf_madd_mem( out, add, mul, ptr ) (out) = vfmaq_f32( add, mul, vld1q_f32( (float const*)(ptr) ) ) #define stbir__simdf_madd1_mem( out, add, mul, ptr ) (out) = vfmaq_f32( add, mul, vld1q_dup_f32( (float const*)(ptr) ) ) #else #define stbir__simdf_madd( out, add, mul1, mul2 ) (out) = vaddq_f32( add, vmulq_f32( mul1, mul2 ) ) #define stbir__simdf_madd1( out, add, mul1, mul2 ) (out) = vaddq_f32( add, vmulq_f32( mul1, mul2 ) ) #define stbir__simdf_madd_mem( out, add, mul, ptr ) (out) = vaddq_f32( add, vmulq_f32( mul, vld1q_f32( (float const*)(ptr) ) ) ) #define stbir__simdf_madd1_mem( out, add, mul, ptr ) (out) = vaddq_f32( add, vmulq_f32( mul, vld1q_dup_f32( (float const*)(ptr) ) ) ) #endif #define stbir__simdf_add1( out, reg0, reg1 ) (out) = vaddq_f32( reg0, reg1 ) #define stbir__simdf_mult1( out, reg0, reg1 ) (out) = vmulq_f32( reg0, reg1 ) #define stbir__simdf_and( out, reg0, reg1 ) (out) = vreinterpretq_f32_u32( vandq_u32( vreinterpretq_u32_f32(reg0), vreinterpretq_u32_f32(reg1) ) ) #define stbir__simdf_or( out, reg0, reg1 ) (out) = vreinterpretq_f32_u32( vorrq_u32( vreinterpretq_u32_f32(reg0), vreinterpretq_u32_f32(reg1) ) ) #define stbir__simdf_min( out, reg0, reg1 ) (out) = vminq_f32( reg0, reg1 ) #define stbir__simdf_max( out, reg0, reg1 ) (out) = vmaxq_f32( reg0, reg1 ) #define stbir__simdf_min1( out, reg0, reg1 ) (out) = vminq_f32( reg0, reg1 ) #define stbir__simdf_max1( out, reg0, reg1 ) (out) = vmaxq_f32( reg0, reg1 ) #define stbir__simdf_0123ABCDto3ABx( out, reg0, reg1 ) (out) = vextq_f32( reg0, reg1, 3 ) #define stbir__simdf_0123ABCDto23Ax( out, reg0, reg1 ) (out) = vextq_f32( reg0, reg1, 2 ) #define stbir__simdf_a1a1( out, alp, ones ) (out) = vzipq_f32(vuzpq_f32(alp, alp).val[1], ones).val[0] #define stbir__simdf_1a1a( out, alp, ones ) (out) = vzipq_f32(ones, vuzpq_f32(alp, alp).val[0]).val[0] #if defined( _M_ARM64 ) || defined( __aarch64__ ) || defined( __arm64__ ) #define stbir__simdf_aaa1( out, alp, ones ) (out) = vcopyq_laneq_f32(vdupq_n_f32(vgetq_lane_f32(alp, 3)), 3, ones, 3) #define stbir__simdf_1aaa( out, alp, ones ) (out) = vcopyq_laneq_f32(vdupq_n_f32(vgetq_lane_f32(alp, 0)), 0, ones, 0) #if defined( _MSC_VER ) && !defined(__clang__) #define stbir_make16(a,b,c,d) vcombine_u8( \\ vcreate_u8( (4*a+0) | ((4*a+1)<<8) | ((4*a+2)<<16) | ((4*a+3)<<24) | \\ ((stbir_uint64)(4*b+0)<<32) | ((stbir_uint64)(4*b+1)<<40) | ((stbir_uint64)(4*b+2)<<48) | ((stbir_uint64)(4*b+3)<<56)), \\ vcreate_u8( (4*c+0) | ((4*c+1)<<8) | ((4*c+2)<<16) | ((4*c+3)<<24) | \\ ((stbir_uint64)(4*d+0)<<32) | ((stbir_uint64)(4*d+1)<<40) | ((stbir_uint64)(4*d+2)<<48) | ((stbir_uint64)(4*d+3)<<56) ) ) #else #define stbir_make16(a,b,c,d) (uint8x16_t)"
  },
  {
    "label": "stbir__simdf_swiz()",
    "kind": "Method",
    "detail": "Function (4* a + 0,4* a + 1,4* a + 2,4* a + 3,4* b + 0,4* b + 1,4* b + 2,4* b + 3,4* c + 0,4* c + 1,4* c + 2,4* c + 3,4* d + 0,4* d + 1,4* d + 2,4* d + 3 } # endif # define)",
    "insertText": "stbir__simdf_swiz(reg, one, two, three, four ) vreinterpretq_f32_u8( vqtbl1q_u8( vreinterpretq_u8_f32(reg), stbir_make16(one, two, three, four) ) ) #define stbir__simdi_16madd( out, reg0, reg1)"
  },
  {
    "label": "vreinterpretq_s16_u32()",
    "kind": "Method",
    "detail": "Function (\\ int16x8_t r0 =)",
    "insertText": "vreinterpretq_s16_u32(reg0)"
  },
  {
    "label": "vreinterpretq_s16_u32()",
    "kind": "Method",
    "detail": "Function (\\ int16x8_t r1 =)",
    "insertText": "vreinterpretq_s16_u32(reg1)"
  },
  {
    "label": "vmull_s16()",
    "kind": "Method",
    "detail": "Function (\\ int32x4_t tmp0 =)",
    "insertText": "vmull_s16(vget_low_s16(r0), vget_low_s16(r1))"
  },
  {
    "label": "vmull_s16()",
    "kind": "Method",
    "detail": "Function (\\ int32x4_t tmp1 =)",
    "insertText": "vmull_s16(vget_high_s16(r0), vget_high_s16(r1))"
  },
  {
    "label": "stbir__simdf_aaa1()",
    "kind": "Method",
    "detail": "Function (\\ } # else # define)",
    "insertText": "stbir__simdf_aaa1(out, alp, ones ) (out) = vsetq_lane_f32(1.0f, vdupq_n_f32(vgetq_lane_f32(alp, 3)), 3) #define stbir__simdf_1aaa( out, alp, ones ) (out) = vsetq_lane_f32(1.0f, vdupq_n_f32(vgetq_lane_f32(alp, 0)), 0) #if defined( _MSC_VER ) && !defined(__clang__) static stbir__inline uint8x8x2_t stbir_make8x2(float32x4_t reg)"
  },
  {
    "label": "vget_low_u8()",
    "kind": "Method",
    "detail": "Function (uint8x8x2_t r = { {)",
    "insertText": "vget_low_u8(vreinterpretq_u8_f32(reg)), vget_high_u8(vreinterpretq_u8_f32(reg))"
  },
  {
    "label": "vget_low_u8()",
    "kind": "Method",
    "detail": "Function ({)",
    "insertText": "vget_low_u8(vreinterpretq_u8_f32(reg)), vget_high_u8(vreinterpretq_u8_f32(reg)) } } #define stbir_make8(a,b) (uint8x8_t)"
  },
  {
    "label": "stbir__simdf_swiz()",
    "kind": "Method",
    "detail": "Function (4* a + 0,4* a + 1,4* a + 2,4* a + 3,4* b + 0,4* b + 1,4* b + 2,4* b + 3 } # endif # define)",
    "insertText": "stbir__simdf_swiz(reg, one, two, three, four ) vreinterpretq_f32_u8( vcombine_u8( \\ vtbl2_u8( stbir_make8x2( reg ), stbir_make8( one, two ) ), \\ vtbl2_u8( stbir_make8x2( reg ), stbir_make8( three, four ) ) ) ) #define stbir__simdi_16madd( out, reg0, reg1)"
  },
  {
    "label": "vpadd_s32()",
    "kind": "Method",
    "detail": "Function (\\ int32x2_t out0 =)",
    "insertText": "vpadd_s32(vget_low_s32(tmp0), vget_high_s32(tmp0))"
  },
  {
    "label": "vpadd_s32()",
    "kind": "Method",
    "detail": "Function (\\ int32x2_t out1 =)",
    "insertText": "vpadd_s32(vget_low_s32(tmp1), vget_high_s32(tmp1))"
  },
  {
    "label": "stbir__simdi_and()",
    "kind": "Method",
    "detail": "Function (\\ } # endif # define)",
    "insertText": "stbir__simdi_and(out, reg0, reg1 ) (out) = vandq_u32( reg0, reg1 ) #define stbir__simdi_or( out, reg0, reg1 ) (out) = vorrq_u32( reg0, reg1 ) #define stbir__simdf_pack_to_8bytes(out,aa,bb)"
  },
  {
    "label": "vmaxq_f32()",
    "kind": "Method",
    "detail": "Function (\\ float32x4_t af =)",
    "insertText": "vmaxq_f32(vminq_f32(aa,STBIR__CONSTF(STBIR_max_uint8_as_float) ), vdupq_n_f32(0))"
  },
  {
    "label": "vmaxq_f32()",
    "kind": "Method",
    "detail": "Function (\\ float32x4_t bf =)",
    "insertText": "vmaxq_f32(vminq_f32(bb,STBIR__CONSTF(STBIR_max_uint8_as_float) ), vdupq_n_f32(0))"
  },
  {
    "label": "vqmovn_s32()",
    "kind": "Method",
    "detail": "Function (\\ int16x4_t ai =)",
    "insertText": "vqmovn_s32(vcvtq_s32_f32( af ))"
  },
  {
    "label": "vqmovn_s32()",
    "kind": "Method",
    "detail": "Function (\\ int16x4_t bi =)",
    "insertText": "vqmovn_s32(vcvtq_s32_f32( bf ))"
  },
  {
    "label": "vqmovun_s16()",
    "kind": "Method",
    "detail": "Function (\\ uint8x8_t out8 =)",
    "insertText": "vqmovun_s16(vcombine_s16(ai, bi))"
  },
  {
    "label": "vreinterpretq_u32_u8()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "vreinterpretq_u32_u8(vcombine_u8(out8, out8))"
  },
  {
    "label": "stbir__simdf_pack_to_8words()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdf_pack_to_8words(out,aa,bb)"
  },
  {
    "label": "vmaxq_f32()",
    "kind": "Method",
    "detail": "Function (\\ float32x4_t af =)",
    "insertText": "vmaxq_f32(vminq_f32(aa,STBIR__CONSTF(STBIR_max_uint16_as_float) ), vdupq_n_f32(0))"
  },
  {
    "label": "vmaxq_f32()",
    "kind": "Method",
    "detail": "Function (\\ float32x4_t bf =)",
    "insertText": "vmaxq_f32(vminq_f32(bb,STBIR__CONSTF(STBIR_max_uint16_as_float) ), vdupq_n_f32(0))"
  },
  {
    "label": "vcvtq_s32_f32()",
    "kind": "Method",
    "detail": "Function (\\ int32x4_t ai =)",
    "insertText": "vcvtq_s32_f32(af)"
  },
  {
    "label": "vcvtq_s32_f32()",
    "kind": "Method",
    "detail": "Function (\\ int32x4_t bi =)",
    "insertText": "vcvtq_s32_f32(bf)"
  },
  {
    "label": "vreinterpretq_u32_u16()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "vreinterpretq_u32_u16(vcombine_u16(vqmovun_s32(ai), vqmovun_s32(bi)))"
  },
  {
    "label": "stbir__interleave_pack_and_store_16_u8()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__interleave_pack_and_store_16_u8(ptr, r0, r1, r2, r3)"
  },
  {
    "label": "vzip_s16()",
    "kind": "Method",
    "detail": "Function (\\ int16x4x2_t tmp0 =)",
    "insertText": "vzip_s16(vqmovn_s32(vreinterpretq_s32_u32(r0)), vqmovn_s32(vreinterpretq_s32_u32(r2)))"
  },
  {
    "label": "vzip_s16()",
    "kind": "Method",
    "detail": "Function (\\ int16x4x2_t tmp1 =)",
    "insertText": "vzip_s16(vqmovn_s32(vreinterpretq_s32_u32(r1)), vqmovn_s32(vreinterpretq_s32_u32(r3)))"
  },
  {
    "label": "vqmovun_s16()",
    "kind": "Method",
    "detail": "Function (\\ uint8x8x2_t out = \\ { { \\)",
    "insertText": "vqmovun_s16(vcombine_s16(tmp0.val[0], tmp0.val[1]) ), \\ vqmovun_s16( vcombine_s16(tmp1.val[0], tmp1.val[1]))"
  },
  {
    "label": "vst2_u8()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "vst2_u8(ptr, out)"
  },
  {
    "label": "stbir__simdf_load4_transposed()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdf_load4_transposed(o0, o1, o2, o3, ptr)"
  },
  {
    "label": "vld4q_f32()",
    "kind": "Method",
    "detail": "Function (\\ float32x4x4_t tmp =)",
    "insertText": "vld4q_f32(ptr)"
  },
  {
    "label": "stbir__simdi_32shr()",
    "kind": "Method",
    "detail": "Function (\\ o0 = tmp . val [ 0 ] ; \\ o1 = tmp . val [ 1 ] ; \\ o2 = tmp . val [ 2 ] ; \\ o3 = tmp . val [ 3 ] ; \\ } # define)",
    "insertText": "stbir__simdi_32shr(out, reg, imm ) out = vshrq_n_u32( reg, imm ) #if defined( _MSC_VER ) && !defined(__clang__) #define STBIR__SIMDF_CONST(var, x) __declspec(align(8))"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (x,x,x,x } # define)",
    "insertText": "STBIR__SIMDI_CONST(var, x) __declspec(align(8))"
  },
  {
    "label": "STBIR__CONSTF()",
    "kind": "Method",
    "detail": "Function (x,x,x,x } # define)",
    "insertText": "STBIR__CONSTF(var) (*(const float32x4_t*)var) #define STBIR__CONSTI(var) (*(const uint32x4_t*)var) #else #define STBIR__SIMDF_CONST(var, x)"
  },
  {
    "label": "STBIR__CONSTF()",
    "kind": "Method",
    "detail": "Function (x,x,x,x } # define)",
    "insertText": "STBIR__CONSTF(var) (var) #define STBIR__CONSTI(var) (var) #endif #ifdef STBIR_FLOORF #undef STBIR_FLOORF #endif #define STBIR_FLOORF stbir_simd_floorf static stbir__inline float stbir_simd_floorf(float x)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_M_ARM64 ) || defined( __aarch64__ ) || defined( __arm64__ ) return vget_lane_f32( vrndm_f32( vdup_n_f32(x) ), 0)"
  },
  {
    "label": "vdup_n_f32()",
    "kind": "Method",
    "detail": "Function (# else float32x2_t f =)",
    "insertText": "vdup_n_f32(x)"
  },
  {
    "label": "vcvt_f32_s32()",
    "kind": "Method",
    "detail": "Function (float32x2_t t =)",
    "insertText": "vcvt_f32_s32(vcvt_s32_f32(f))"
  },
  {
    "label": "vclt_f32()",
    "kind": "Method",
    "detail": "Function (uint32x2_t a =)",
    "insertText": "vclt_f32(f, t)"
  },
  {
    "label": "vreinterpret_u32_f32()",
    "kind": "Method",
    "detail": "Function (uint32x2_t b =)",
    "insertText": "vreinterpret_u32_f32(vdup_n_f32(-1.0f))"
  },
  {
    "label": "vadd_f32()",
    "kind": "Method",
    "detail": "Function (float32x2_t r =)",
    "insertText": "vadd_f32(t, vreinterpret_f32_u32(vand_u32(a, b)))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(_M_ARM64 ) || defined( __aarch64__ ) || defined( __arm64__ ) return vget_lane_f32( vrndp_f32( vdup_n_f32(x) ), 0)"
  },
  {
    "label": "vclt_f32()",
    "kind": "Method",
    "detail": "Function (uint32x2_t a =)",
    "insertText": "vclt_f32(t, f)"
  },
  {
    "label": "vreinterpret_u32_f32()",
    "kind": "Method",
    "detail": "Function (uint32x2_t b =)",
    "insertText": "vreinterpret_u32_f32(vdup_n_f32(1.0f))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# endif } # define STBIR_SIMD # elif)",
    "insertText": "defined(STBIR_WASM) #include <wasm_simd128.h> #define stbir__simdf v128_t #define stbir__simdi v128_t #define stbir_simdi_castf( reg ) (reg) #define stbir_simdf_casti( reg ) (reg) #define stbir__simdf_load( reg, ptr ) (reg) = wasm_v128_load( (void const*)(ptr) ) #define stbir__simdi_load( reg, ptr ) (reg) = wasm_v128_load( (void const*)(ptr) ) #define stbir__simdf_load1( out, ptr ) (out) = wasm_v128_load32_splat( (void const*)(ptr) ) #define stbir__simdi_load1( out, ptr ) (out) = wasm_v128_load32_splat( (void const*)(ptr) ) #define stbir__simdf_load1z( out, ptr ) (out) = wasm_v128_load32_zero( (void const*)(ptr) ) #define stbir__simdf_frep4( fvar ) wasm_f32x4_splat( fvar ) #define stbir__simdf_load1frep4( out, fvar ) (out) = wasm_f32x4_splat( fvar ) #define stbir__simdf_load2( out, ptr ) (out) = wasm_v128_load64_splat( (void const*)(ptr) ) #define stbir__simdf_load2z( out, ptr ) (out) = wasm_v128_load64_zero( (void const*)(ptr) ) #define stbir__simdf_load2hmerge( out, reg, ptr ) (out) = wasm_v128_load64_lane( (void const*)(ptr), reg, 1 ) #define stbir__simdf_zeroP() wasm_f32x4_const_splat(0) #define stbir__simdf_zero( reg ) (reg) = wasm_f32x4_const_splat(0) #define stbir__simdf_store( ptr, reg ) wasm_v128_store( (void*)(ptr), reg ) #define stbir__simdf_store1( ptr, reg ) wasm_v128_store32_lane( (void*)(ptr), reg, 0 ) #define stbir__simdf_store2( ptr, reg ) wasm_v128_store64_lane( (void*)(ptr), reg, 0 ) #define stbir__simdf_store2h( ptr, reg ) wasm_v128_store64_lane( (void*)(ptr), reg, 1 ) #define stbir__simdi_store( ptr, reg ) wasm_v128_store( (void*)(ptr), reg ) #define stbir__simdi_store1( ptr, reg ) wasm_v128_store32_lane( (void*)(ptr), reg, 0 ) #define stbir__simdi_store2( ptr, reg ) wasm_v128_store64_lane( (void*)(ptr), reg, 0 ) #define stbir__prefetch( ptr ) #define stbir__simdi_expand_u8_to_u32(out0,out1,out2,out3,ireg)"
  },
  {
    "label": "wasm_u16x8_extend_low_u8x16()",
    "kind": "Method",
    "detail": "Function (\\ v128_t l =)",
    "insertText": "wasm_u16x8_extend_low_u8x16(ireg)"
  },
  {
    "label": "wasm_u16x8_extend_high_u8x16()",
    "kind": "Method",
    "detail": "Function (\\ v128_t h =)",
    "insertText": "wasm_u16x8_extend_high_u8x16(ireg)"
  },
  {
    "label": "wasm_u32x4_extend_low_u16x8()",
    "kind": "Method",
    "detail": "Function (\\ out0 =)",
    "insertText": "wasm_u32x4_extend_low_u16x8(l)"
  },
  {
    "label": "wasm_u32x4_extend_high_u16x8()",
    "kind": "Method",
    "detail": "Function (\\ out1 =)",
    "insertText": "wasm_u32x4_extend_high_u16x8(l)"
  },
  {
    "label": "wasm_u32x4_extend_low_u16x8()",
    "kind": "Method",
    "detail": "Function (\\ out2 =)",
    "insertText": "wasm_u32x4_extend_low_u16x8(h)"
  },
  {
    "label": "wasm_u32x4_extend_high_u16x8()",
    "kind": "Method",
    "detail": "Function (\\ out3 =)",
    "insertText": "wasm_u32x4_extend_high_u16x8(h)"
  },
  {
    "label": "wasm_u32x4_extend_low_u16x8()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "wasm_u32x4_extend_low_u16x8(tmp)"
  },
  {
    "label": "wasm_u32x4_extend_low_u16x8()",
    "kind": "Method",
    "detail": "Function (\\ out0 =)",
    "insertText": "wasm_u32x4_extend_low_u16x8(ireg)"
  },
  {
    "label": "wasm_u32x4_extend_high_u16x8()",
    "kind": "Method",
    "detail": "Function (\\ out1 =)",
    "insertText": "wasm_u32x4_extend_high_u16x8(ireg)"
  },
  {
    "label": "stbir__simdf_convert_float_to_i32()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdf_convert_float_to_i32(i, f ) (i) = wasm_i32x4_trunc_sat_f32x4(f) #define stbir__simdf_convert_float_to_int( f ) wasm_i32x4_extract_lane(wasm_i32x4_trunc_sat_f32x4(f), 0) #define stbir__simdi_to_int( i ) wasm_i32x4_extract_lane(i, 0) #define stbir__simdf_convert_float_to_uint8( f ) ((unsigned char)wasm_i32x4_extract_lane(wasm_i32x4_trunc_sat_f32x4(wasm_f32x4_max(wasm_f32x4_min(f,STBIR_max_uint8_as_float),wasm_f32x4_const_splat(0))), 0)) #define stbir__simdf_convert_float_to_short( f ) ((unsigned short)wasm_i32x4_extract_lane(wasm_i32x4_trunc_sat_f32x4(wasm_f32x4_max(wasm_f32x4_min(f,STBIR_max_uint16_as_float),wasm_f32x4_const_splat(0))), 0)) #define stbir__simdi_convert_i32_to_float(out, ireg) (out) = wasm_f32x4_convert_i32x4(ireg) #define stbir__simdf_add( out, reg0, reg1 ) (out) = wasm_f32x4_add( reg0, reg1 ) #define stbir__simdf_mult( out, reg0, reg1 ) (out) = wasm_f32x4_mul( reg0, reg1 ) #define stbir__simdf_mult_mem( out, reg, ptr ) (out) = wasm_f32x4_mul( reg, wasm_v128_load( (void const*)(ptr) ) ) #define stbir__simdf_mult1_mem( out, reg, ptr ) (out) = wasm_f32x4_mul( reg, wasm_v128_load32_splat( (void const*)(ptr) ) ) #define stbir__simdf_add_mem( out, reg, ptr ) (out) = wasm_f32x4_add( reg, wasm_v128_load( (void const*)(ptr) ) ) #define stbir__simdf_add1_mem( out, reg, ptr ) (out) = wasm_f32x4_add( reg, wasm_v128_load32_splat( (void const*)(ptr) ) ) #define stbir__simdf_madd( out, add, mul1, mul2 ) (out) = wasm_f32x4_add( add, wasm_f32x4_mul( mul1, mul2 ) ) #define stbir__simdf_madd1( out, add, mul1, mul2 ) (out) = wasm_f32x4_add( add, wasm_f32x4_mul( mul1, mul2 ) ) #define stbir__simdf_madd_mem( out, add, mul, ptr ) (out) = wasm_f32x4_add( add, wasm_f32x4_mul( mul, wasm_v128_load( (void const*)(ptr) ) ) ) #define stbir__simdf_madd1_mem( out, add, mul, ptr ) (out) = wasm_f32x4_add( add, wasm_f32x4_mul( mul, wasm_v128_load32_splat( (void const*)(ptr) ) ) ) #define stbir__simdf_add1( out, reg0, reg1 ) (out) = wasm_f32x4_add( reg0, reg1 ) #define stbir__simdf_mult1( out, reg0, reg1 ) (out) = wasm_f32x4_mul( reg0, reg1 ) #define stbir__simdf_and( out, reg0, reg1 ) (out) = wasm_v128_and( reg0, reg1 ) #define stbir__simdf_or( out, reg0, reg1 ) (out) = wasm_v128_or( reg0, reg1 ) #define stbir__simdf_min( out, reg0, reg1 ) (out) = wasm_f32x4_min( reg0, reg1 ) #define stbir__simdf_max( out, reg0, reg1 ) (out) = wasm_f32x4_max( reg0, reg1 ) #define stbir__simdf_min1( out, reg0, reg1 ) (out) = wasm_f32x4_min( reg0, reg1 ) #define stbir__simdf_max1( out, reg0, reg1 ) (out) = wasm_f32x4_max( reg0, reg1 ) #define stbir__simdf_0123ABCDto3ABx( out, reg0, reg1 ) (out) = wasm_i32x4_shuffle( reg0, reg1, 3, 4, 5, -1 ) #define stbir__simdf_0123ABCDto23Ax( out, reg0, reg1 ) (out) = wasm_i32x4_shuffle( reg0, reg1, 2, 3, 4, -1 ) #define stbir__simdf_aaa1(out,alp,ones) (out) = wasm_i32x4_shuffle(alp, ones, 3, 3, 3, 4) #define stbir__simdf_1aaa(out,alp,ones) (out) = wasm_i32x4_shuffle(alp, ones, 4, 0, 0, 0) #define stbir__simdf_a1a1(out,alp,ones) (out) = wasm_i32x4_shuffle(alp, ones, 1, 4, 3, 4) #define stbir__simdf_1a1a(out,alp,ones) (out) = wasm_i32x4_shuffle(alp, ones, 4, 0, 4, 2) #define stbir__simdf_swiz( reg, one, two, three, four ) wasm_i32x4_shuffle(reg, reg, one, two, three, four) #define stbir__simdi_and( out, reg0, reg1 ) (out) = wasm_v128_and( reg0, reg1 ) #define stbir__simdi_or( out, reg0, reg1 ) (out) = wasm_v128_or( reg0, reg1 ) #define stbir__simdi_16madd( out, reg0, reg1 ) (out) = wasm_i32x4_dot_i16x8( reg0, reg1 ) #define stbir__simdf_pack_to_8bytes(out,aa,bb)"
  },
  {
    "label": "wasm_f32x4_max()",
    "kind": "Method",
    "detail": "Function (\\ v128_t af =)",
    "insertText": "wasm_f32x4_max(wasm_f32x4_min(aa, STBIR_max_uint8_as_float), wasm_f32x4_const_splat(0))"
  },
  {
    "label": "wasm_f32x4_max()",
    "kind": "Method",
    "detail": "Function (\\ v128_t bf =)",
    "insertText": "wasm_f32x4_max(wasm_f32x4_min(bb, STBIR_max_uint8_as_float), wasm_f32x4_const_splat(0))"
  },
  {
    "label": "wasm_i32x4_trunc_sat_f32x4()",
    "kind": "Method",
    "detail": "Function (\\ v128_t ai =)",
    "insertText": "wasm_i32x4_trunc_sat_f32x4(af)"
  },
  {
    "label": "wasm_i32x4_trunc_sat_f32x4()",
    "kind": "Method",
    "detail": "Function (\\ v128_t bi =)",
    "insertText": "wasm_i32x4_trunc_sat_f32x4(bf)"
  },
  {
    "label": "wasm_i16x8_narrow_i32x4()",
    "kind": "Method",
    "detail": "Function (\\ v128_t out16 =)",
    "insertText": "wasm_i16x8_narrow_i32x4(ai, bi)"
  },
  {
    "label": "wasm_u8x16_narrow_i16x8()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "wasm_u8x16_narrow_i16x8(out16, out16)"
  },
  {
    "label": "wasm_f32x4_max()",
    "kind": "Method",
    "detail": "Function (\\ v128_t af =)",
    "insertText": "wasm_f32x4_max(wasm_f32x4_min(aa, STBIR_max_uint16_as_float), wasm_f32x4_const_splat(0))"
  },
  {
    "label": "wasm_f32x4_max()",
    "kind": "Method",
    "detail": "Function (\\ v128_t bf =)",
    "insertText": "wasm_f32x4_max(wasm_f32x4_min(bb, STBIR_max_uint16_as_float), wasm_f32x4_const_splat(0))"
  },
  {
    "label": "wasm_u16x8_narrow_i32x4()",
    "kind": "Method",
    "detail": "Function (\\ out =)",
    "insertText": "wasm_u16x8_narrow_i32x4(ai, bi)"
  },
  {
    "label": "wasm_i16x8_narrow_i32x4()",
    "kind": "Method",
    "detail": "Function (\\ v128_t tmp0 =)",
    "insertText": "wasm_i16x8_narrow_i32x4(r0, r1)"
  },
  {
    "label": "wasm_i16x8_narrow_i32x4()",
    "kind": "Method",
    "detail": "Function (\\ v128_t tmp1 =)",
    "insertText": "wasm_i16x8_narrow_i32x4(r2, r3)"
  },
  {
    "label": "wasm_u8x16_narrow_i16x8()",
    "kind": "Method",
    "detail": "Function (\\ v128_t tmp =)",
    "insertText": "wasm_u8x16_narrow_i16x8(tmp0, tmp1)"
  },
  {
    "label": "wasm_i8x16_shuffle()",
    "kind": "Method",
    "detail": "Function (\\ tmp =)",
    "insertText": "wasm_i8x16_shuffle(tmp, tmp, 0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15)"
  },
  {
    "label": "wasm_v128_store()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "wasm_v128_store((void*)(ptr), tmp)"
  },
  {
    "label": "wasm_v128_load()",
    "kind": "Method",
    "detail": "Function (\\ v128_t t0 =)",
    "insertText": "wasm_v128_load(ptr)"
  },
  {
    "label": "wasm_v128_load()",
    "kind": "Method",
    "detail": "Function (\\ v128_t t1 =)",
    "insertText": "wasm_v128_load(ptr+4)"
  },
  {
    "label": "wasm_v128_load()",
    "kind": "Method",
    "detail": "Function (\\ v128_t t2 =)",
    "insertText": "wasm_v128_load(ptr+8)"
  },
  {
    "label": "wasm_v128_load()",
    "kind": "Method",
    "detail": "Function (\\ v128_t t3 =)",
    "insertText": "wasm_v128_load(ptr+12)"
  },
  {
    "label": "wasm_i32x4_shuffle()",
    "kind": "Method",
    "detail": "Function (\\ v128_t s0 =)",
    "insertText": "wasm_i32x4_shuffle(t0, t1, 0, 4, 2, 6)"
  },
  {
    "label": "wasm_i32x4_shuffle()",
    "kind": "Method",
    "detail": "Function (\\ v128_t s1 =)",
    "insertText": "wasm_i32x4_shuffle(t0, t1, 1, 5, 3, 7)"
  },
  {
    "label": "wasm_i32x4_shuffle()",
    "kind": "Method",
    "detail": "Function (\\ v128_t s2 =)",
    "insertText": "wasm_i32x4_shuffle(t2, t3, 0, 4, 2, 6)"
  },
  {
    "label": "wasm_i32x4_shuffle()",
    "kind": "Method",
    "detail": "Function (\\ v128_t s3 =)",
    "insertText": "wasm_i32x4_shuffle(t2, t3, 1, 5, 3, 7)"
  },
  {
    "label": "wasm_i32x4_shuffle()",
    "kind": "Method",
    "detail": "Function (\\ o0 =)",
    "insertText": "wasm_i32x4_shuffle(s0, s2, 0, 1, 4, 5)"
  },
  {
    "label": "wasm_i32x4_shuffle()",
    "kind": "Method",
    "detail": "Function (\\ o1 =)",
    "insertText": "wasm_i32x4_shuffle(s1, s3, 0, 1, 4, 5)"
  },
  {
    "label": "wasm_i32x4_shuffle()",
    "kind": "Method",
    "detail": "Function (\\ o2 =)",
    "insertText": "wasm_i32x4_shuffle(s0, s2, 2, 3, 6, 7)"
  },
  {
    "label": "wasm_i32x4_shuffle()",
    "kind": "Method",
    "detail": "Function (\\ o3 =)",
    "insertText": "wasm_i32x4_shuffle(s1, s3, 2, 3, 6, 7)"
  },
  {
    "label": "stbir__simdi_32shr()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdi_32shr(out, reg, imm ) out = wasm_u32x4_shr( reg, imm ) typedef float stbir__f32x4 __attribute__((__vector_size__(16), __aligned__(16)))"
  },
  {
    "label": "STBIR__SIMDF_CONST()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "STBIR__SIMDF_CONST(var, x) stbir__simdf var = (v128_t)(stbir__f32x4)"
  },
  {
    "label": "STBIR__CONSTF()",
    "kind": "Method",
    "detail": "Function (x,x,x,x } # define)",
    "insertText": "STBIR__CONSTF(var) (var) #define STBIR__CONSTI(var) (var) #ifdef STBIR_FLOORF #undef STBIR_FLOORF #endif #define STBIR_FLOORF stbir_simd_floorf static stbir__inline float stbir_simd_floorf(float x)"
  },
  {
    "label": "STBIR__CONSTF()",
    "kind": "Method",
    "detail": "Function (} # define STBIR_SIMD # endif # endif # ifdef STBIR_SIMD8 # define stbir__simdfX stbir__simdf8 # define stbir__simdiX stbir__simdi8 # define stbir__simdfX_load stbir__simdf8_load # define stbir__simdiX_load stbir__simdi8_load # define stbir__simdfX_mult stbir__simdf8_mult # define stbir__simdfX_add_mem stbir__simdf8_add_mem # define stbir__simdfX_madd_mem stbir__simdf8_madd_mem # define stbir__simdfX_store stbir__simdf8_store # define stbir__simdiX_store stbir__simdi8_store # define stbir__simdf_frepX stbir__simdf8_frep8 # define stbir__simdfX_madd stbir__simdf8_madd # define stbir__simdfX_min stbir__simdf8_min # define stbir__simdfX_max stbir__simdf8_max # define stbir__simdfX_aaa1 stbir__simdf8_aaa1 # define stbir__simdfX_1aaa stbir__simdf8_1aaa # define stbir__simdfX_a1a1 stbir__simdf8_a1a1 # define stbir__simdfX_1a1a stbir__simdf8_1a1a # define stbir__simdfX_convert_float_to_i32 stbir__simdf8_convert_float_to_i32 # define stbir__simdfX_pack_to_words stbir__simdf8_pack_to_16words # define stbir__simdfX_zero stbir__simdf8_zero # define STBIR_onesX STBIR_ones8 # define STBIR_max_uint8_as_floatX STBIR_max_uint8_as_float8 # define STBIR_max_uint16_as_floatX STBIR_max_uint16_as_float8 # define STBIR_simd_point5X STBIR_simd_point58 # define stbir__simdfX_float_count 8 # define stbir__simdfX_0123to1230 stbir__simdf8_0123to12301230 # define stbir__simdfX_0123to2103 stbir__simdf8_0123to21032103 const stbir__simdf8 STBIR_max_uint16_as_float_inverted8 = { stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted,stbir__max_uint16_as_float_inverted } ; const stbir__simdf8 STBIR_max_uint8_as_float_inverted8 = { stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted,stbir__max_uint8_as_float_inverted } ; const stbir__simdf8 STBIR_ones8 = { 1 . 0,1 . 0,1 . 0,1 . 0,1 . 0,1 . 0,1 . 0,1 . 0 } ; const stbir__simdf8 STBIR_simd_point58 = { 0 . 5,0 . 5,0 . 5,0 . 5,0 . 5,0 . 5,0 . 5,0 . 5 } ; const stbir__simdf8 STBIR_max_uint8_as_float8 = { stbir__max_uint8_as_float,stbir__max_uint8_as_float,stbir__max_uint8_as_float,stbir__max_uint8_as_float,stbir__max_uint8_as_float,stbir__max_uint8_as_float,stbir__max_uint8_as_float,stbir__max_uint8_as_float } ; const stbir__simdf8 STBIR_max_uint16_as_float8 = { stbir__max_uint16_as_float,stbir__max_uint16_as_float,stbir__max_uint16_as_float,stbir__max_uint16_as_float,stbir__max_uint16_as_float,stbir__max_uint16_as_float,stbir__max_uint16_as_float,stbir__max_uint16_as_float } ; # else # define stbir__simdfX stbir__simdf # define stbir__simdiX stbir__simdi # define stbir__simdfX_load stbir__simdf_load # define stbir__simdiX_load stbir__simdi_load # define stbir__simdfX_mult stbir__simdf_mult # define stbir__simdfX_add_mem stbir__simdf_add_mem # define stbir__simdfX_madd_mem stbir__simdf_madd_mem # define stbir__simdfX_store stbir__simdf_store # define stbir__simdiX_store stbir__simdi_store # define stbir__simdf_frepX stbir__simdf_frep4 # define stbir__simdfX_madd stbir__simdf_madd # define stbir__simdfX_min stbir__simdf_min # define stbir__simdfX_max stbir__simdf_max # define stbir__simdfX_aaa1 stbir__simdf_aaa1 # define stbir__simdfX_1aaa stbir__simdf_1aaa # define stbir__simdfX_a1a1 stbir__simdf_a1a1 # define stbir__simdfX_1a1a stbir__simdf_1a1a # define stbir__simdfX_convert_float_to_i32 stbir__simdf_convert_float_to_i32 # define stbir__simdfX_pack_to_words stbir__simdf_pack_to_8words # define stbir__simdfX_zero stbir__simdf_zero # define STBIR_onesX)",
    "insertText": "STBIR__CONSTF(STBIR_ones) #define STBIR_simd_point5X STBIR__CONSTF(STBIR_simd_point5) #define STBIR_max_uint8_as_floatX STBIR__CONSTF(STBIR_max_uint8_as_float) #define STBIR_max_uint16_as_floatX STBIR__CONSTF(STBIR_max_uint16_as_float) #define stbir__simdfX_float_count 4 #define stbir__if_simdf8_cast_to_simdf4( val ) ( val ) #define stbir__simdfX_0123to1230 stbir__simdf_0123to1230 #define stbir__simdfX_0123to2103 stbir__simdf_0123to2103 #endif #if defined(STBIR_NEON) && !defined(_M_ARM) #if defined( _MSC_VER ) && !defined(__clang__)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# else typedef float16_t stbir__FP16 ; # endif # else typedef union stbir__FP16 { unsigned short u ; } stbir__FP16 ; # endif # if !)",
    "insertText": "defined(STBIR_NEON) && !defined(STBIR_FP16C) || defined(STBIR_NEON) && defined(_M_ARM) static stbir__inline float stbir__half_to_float( stbir__FP16 h)"
  },
  {
    "label": "magic()",
    "kind": "Method",
    "detail": "Function (const stbir__FP32)",
    "insertText": "magic(254 - 15)"
  },
  {
    "label": "was_infnan()",
    "kind": "Method",
    "detail": "Function (const stbir__FP32)",
    "insertText": "was_infnan(127 + 16)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (stbir__FP32 o ; o .)",
    "insertText": "u(h.u & 0x7fff)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (o . f* = magic . f ;)",
    "insertText": "if(o.f >= was_infnan.f)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (o .)",
    "insertText": "u(h.u & 0x8000)"
  },
  {
    "label": "f16max()",
    "kind": "Method",
    "detail": "Function (stbir__FP32 f32infty = { 2 5 5<<2 3 } ; stbir__FP32)",
    "insertText": "f16max(127 + 16)"
  },
  {
    "label": "denorm_magic()",
    "kind": "Method",
    "detail": "Function (stbir__FP32)",
    "insertText": "denorm_magic((127 - 15) + (23 - 10) + 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (unsigned int sign_mask = 0 x80000000u ; stbir__FP16 o = { 0 } ; stbir__FP32 f ; unsigned int sign ; f . f = val ; sign = f . u& sign_mask ; f . u ^ = sign ;)",
    "insertText": "if(f.u >= f16max.u) o.u = (f.u > f32infty.u)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (f . f + = denorm_magic . f ; o .)",
    "insertText": "u(unsigned short) ( f.u - denorm_magic.u)"
  },
  {
    "label": "mant_odd()",
    "kind": "Method",
    "detail": "Function (} else { unsigned int)",
    "insertText": "mant_odd(f.u >> 13)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (f . u = f .)",
    "insertText": "u((15u - 127) << 23)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (f . u + = mant_odd ; o .)",
    "insertText": "u(unsigned short) ( f.u >> 13)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } o . u | = sign>> 1 6 ; return o ; } # endif # if)",
    "insertText": "defined(STBIR_FP16C) #include <immintrin.h> static stbir__inline void stbir__half_to_float_SIMD(float * output, stbir__FP16 const * input)"
  },
  {
    "label": "_mm256_storeu_ps()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm256_storeu_ps((float*)output, _mm256_cvtph_ps( _mm_loadu_si128( (__m128i const* )input ) ))"
  },
  {
    "label": "stbir__float_to_half_SIMD()",
    "kind": "Method",
    "detail": "Function (} stbir__inline void)",
    "insertText": "stbir__float_to_half_SIMD(stbir__FP16 * output, float const * input)"
  },
  {
    "label": "_mm_storeu_si128()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "_mm_storeu_si128((__m128i*)output, _mm256_cvtps_ph( _mm256_loadu_ps( input ), 0 ))"
  },
  {
    "label": "stbir__half_to_float()",
    "kind": "Method",
    "detail": "Function (} stbir__inline float)",
    "insertText": "stbir__half_to_float(stbir__FP16 h)"
  },
  {
    "label": "stbir__float_to_half()",
    "kind": "Method",
    "detail": "Function (} stbir__inline stbir__FP16)",
    "insertText": "stbir__float_to_half(float f)"
  },
  {
    "label": "u()",
    "kind": "Method",
    "detail": "Function (stbir__FP16 h ; h .)",
    "insertText": "u(unsigned short) _mm_cvtsi128_si32( _mm_cvtps_ph( _mm_set_ss( f ), 0 ))"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(mask_nosign, 0x7fff)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(smallest_normal, 0x0400)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(infinity, 0x7c00)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(expadjust_normal, (127 - 15) << 23)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(magic_denorm, 113 << 23)"
  },
  {
    "label": "_mm_loadu_si128()",
    "kind": "Method",
    "detail": "Function (__m128i i =)",
    "insertText": "_mm_loadu_si128((__m128i const*)(input))"
  },
  {
    "label": "_mm_unpacklo_epi16()",
    "kind": "Method",
    "detail": "Function (__m128i h =)",
    "insertText": "_mm_unpacklo_epi16(i, _mm_setzero_si128())"
  },
  {
    "label": "STBIR__CONSTI()",
    "kind": "Method",
    "detail": "Function (__m128i mnosign =)",
    "insertText": "STBIR__CONSTI(mask_nosign)"
  },
  {
    "label": "STBIR__CONSTI()",
    "kind": "Method",
    "detail": "Function (__m128i eadjust =)",
    "insertText": "STBIR__CONSTI(expadjust_normal)"
  },
  {
    "label": "STBIR__CONSTI()",
    "kind": "Method",
    "detail": "Function (__m128i smallest =)",
    "insertText": "STBIR__CONSTI(smallest_normal)"
  },
  {
    "label": "STBIR__CONSTI()",
    "kind": "Method",
    "detail": "Function (__m128i infty =)",
    "insertText": "STBIR__CONSTI(infinity)"
  },
  {
    "label": "_mm_and_si128()",
    "kind": "Method",
    "detail": "Function (__m128i expmant =)",
    "insertText": "_mm_and_si128(mnosign, h)"
  },
  {
    "label": "_mm_xor_si128()",
    "kind": "Method",
    "detail": "Function (__m128i justsign =)",
    "insertText": "_mm_xor_si128(h, expmant)"
  },
  {
    "label": "_mm_cmpgt_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i b_notinfnan =)",
    "insertText": "_mm_cmpgt_epi32(infty, expmant)"
  },
  {
    "label": "_mm_cmpgt_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i b_isdenorm =)",
    "insertText": "_mm_cmpgt_epi32(smallest, expmant)"
  },
  {
    "label": "_mm_slli_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i shifted =)",
    "insertText": "_mm_slli_epi32(expmant, 13)"
  },
  {
    "label": "_mm_andnot_si128()",
    "kind": "Method",
    "detail": "Function (__m128i adj_infnan =)",
    "insertText": "_mm_andnot_si128(b_notinfnan, eadjust)"
  },
  {
    "label": "_mm_add_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i adjusted =)",
    "insertText": "_mm_add_epi32(eadjust, shifted)"
  },
  {
    "label": "_mm_add_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i den1 =)",
    "insertText": "_mm_add_epi32(shifted, STBIR__CONSTI(magic_denorm))"
  },
  {
    "label": "_mm_add_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i adjusted2 =)",
    "insertText": "_mm_add_epi32(adjusted, adj_infnan)"
  },
  {
    "label": "_mm_sub_ps()",
    "kind": "Method",
    "detail": "Function (__m128 den2 =)",
    "insertText": "_mm_sub_ps(_mm_castsi128_ps(den1), *(const __m128 *)&magic_denorm)"
  },
  {
    "label": "_mm_and_ps()",
    "kind": "Method",
    "detail": "Function (__m128 adjusted3 =)",
    "insertText": "_mm_and_ps(den2, _mm_castsi128_ps(b_isdenorm))"
  },
  {
    "label": "_mm_andnot_ps()",
    "kind": "Method",
    "detail": "Function (__m128 adjusted4 =)",
    "insertText": "_mm_andnot_ps(_mm_castsi128_ps(b_isdenorm), _mm_castsi128_ps(adjusted2))"
  },
  {
    "label": "_mm_or_ps()",
    "kind": "Method",
    "detail": "Function (__m128 adjusted5 =)",
    "insertText": "_mm_or_ps(adjusted3, adjusted4)"
  },
  {
    "label": "_mm_slli_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i sign =)",
    "insertText": "_mm_slli_epi32(justsign, 16)"
  },
  {
    "label": "_mm_or_ps()",
    "kind": "Method",
    "detail": "Function (__m128 final =)",
    "insertText": "_mm_or_ps(adjusted5, _mm_castsi128_ps(sign))"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(output + 0, final)"
  },
  {
    "label": "_mm_unpackhi_epi16()",
    "kind": "Method",
    "detail": "Function (h =)",
    "insertText": "_mm_unpackhi_epi16(i, _mm_setzero_si128())"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(output + 4, final)"
  },
  {
    "label": "stbir__float_to_half_SIMD()",
    "kind": "Method",
    "detail": "Function (} stbir__inline void)",
    "insertText": "stbir__float_to_half_SIMD(void * output, float const * input)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(mask_sign, 0x80000000u)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(c_f16max, (127 + 16) << 23)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(c_nanbit, 0x200)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(c_infty_as_fp16, 0x7c00)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(c_min_normal, (127 - 14) << 23)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(c_subnorm_magic, ((127 - 15) + (23 - 10) + 1) << 23)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(c_normal_bias, 0xfff - ((127 - 15) << 23))"
  },
  {
    "label": "_mm_loadu_ps()",
    "kind": "Method",
    "detail": "Function (__m128 f =)",
    "insertText": "_mm_loadu_ps(input)"
  },
  {
    "label": "_mm_castsi128_ps()",
    "kind": "Method",
    "detail": "Function (__m128 msign =)",
    "insertText": "_mm_castsi128_ps(STBIR__CONSTI(mask_sign))"
  },
  {
    "label": "_mm_and_ps()",
    "kind": "Method",
    "detail": "Function (__m128 justsign =)",
    "insertText": "_mm_and_ps(msign, f)"
  },
  {
    "label": "_mm_xor_ps()",
    "kind": "Method",
    "detail": "Function (__m128 absf =)",
    "insertText": "_mm_xor_ps(f, justsign)"
  },
  {
    "label": "_mm_castps_si128()",
    "kind": "Method",
    "detail": "Function (__m128i absf_int =)",
    "insertText": "_mm_castps_si128(absf)"
  },
  {
    "label": "STBIR__CONSTI()",
    "kind": "Method",
    "detail": "Function (__m128i f16max =)",
    "insertText": "STBIR__CONSTI(c_f16max)"
  },
  {
    "label": "_mm_cmpunord_ps()",
    "kind": "Method",
    "detail": "Function (__m128 b_isnan =)",
    "insertText": "_mm_cmpunord_ps(absf, absf)"
  },
  {
    "label": "_mm_cmpgt_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i b_isregular =)",
    "insertText": "_mm_cmpgt_epi32(f16max, absf_int)"
  },
  {
    "label": "_mm_and_si128()",
    "kind": "Method",
    "detail": "Function (__m128i nanbit =)",
    "insertText": "_mm_and_si128(_mm_castps_si128(b_isnan), STBIR__CONSTI(c_nanbit))"
  },
  {
    "label": "_mm_or_si128()",
    "kind": "Method",
    "detail": "Function (__m128i inf_or_nan =)",
    "insertText": "_mm_or_si128(nanbit, STBIR__CONSTI(c_infty_as_fp16))"
  },
  {
    "label": "STBIR__CONSTI()",
    "kind": "Method",
    "detail": "Function (__m128i min_normal =)",
    "insertText": "STBIR__CONSTI(c_min_normal)"
  },
  {
    "label": "_mm_cmpgt_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i b_issub =)",
    "insertText": "_mm_cmpgt_epi32(min_normal, absf_int)"
  },
  {
    "label": "_mm_add_ps()",
    "kind": "Method",
    "detail": "Function (__m128 subnorm1 =)",
    "insertText": "_mm_add_ps(absf, _mm_castsi128_ps(STBIR__CONSTI(c_subnorm_magic)))"
  },
  {
    "label": "_mm_sub_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i subnorm2 =)",
    "insertText": "_mm_sub_epi32(_mm_castps_si128(subnorm1), STBIR__CONSTI(c_subnorm_magic))"
  },
  {
    "label": "_mm_slli_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i mantoddbit =)",
    "insertText": "_mm_slli_epi32(absf_int, 31 - 13)"
  },
  {
    "label": "_mm_srai_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i mantodd =)",
    "insertText": "_mm_srai_epi32(mantoddbit, 31)"
  },
  {
    "label": "_mm_add_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i round1 =)",
    "insertText": "_mm_add_epi32(absf_int, STBIR__CONSTI(c_normal_bias))"
  },
  {
    "label": "_mm_sub_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i round2 =)",
    "insertText": "_mm_sub_epi32(round1, mantodd)"
  },
  {
    "label": "_mm_srli_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i normal =)",
    "insertText": "_mm_srli_epi32(round2, 13)"
  },
  {
    "label": "_mm_or_si128()",
    "kind": "Method",
    "detail": "Function (__m128i nonspecial =)",
    "insertText": "_mm_or_si128(_mm_and_si128(subnorm2, b_issub), _mm_andnot_si128(b_issub, normal))"
  },
  {
    "label": "_mm_or_si128()",
    "kind": "Method",
    "detail": "Function (__m128i joined =)",
    "insertText": "_mm_or_si128(_mm_and_si128(nonspecial, b_isregular), _mm_andnot_si128(b_isregular, inf_or_nan))"
  },
  {
    "label": "_mm_srai_epi32()",
    "kind": "Method",
    "detail": "Function (__m128i sign_shift =)",
    "insertText": "_mm_srai_epi32(_mm_castps_si128(justsign), 16)"
  },
  {
    "label": "_mm_or_si128()",
    "kind": "Method",
    "detail": "Function (__m128i final2,final =)",
    "insertText": "_mm_or_si128(joined, sign_shift)"
  },
  {
    "label": "_mm_loadu_ps()",
    "kind": "Method",
    "detail": "Function (f =)",
    "insertText": "_mm_loadu_ps(input+4)"
  },
  {
    "label": "_mm_and_si128()",
    "kind": "Method",
    "detail": "Function (nanbit =)",
    "insertText": "_mm_and_si128(_mm_castps_si128(b_isnan), c_nanbit)"
  },
  {
    "label": "_mm_packs_epi32()",
    "kind": "Method",
    "detail": "Function (final =)",
    "insertText": "_mm_packs_epi32(final, final2)"
  },
  {
    "label": "stbir__simdi_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_store(output,final)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # elif)",
    "insertText": "defined(STBIR_WASM) || (defined(STBIR_NEON) && defined(_MSC_VER) && defined(_M_ARM)) static stbir__inline void stbir__half_to_float_SIMD(float * output, stbir__FP16 const * input)"
  },
  {
    "label": "stbir__half_to_float()",
    "kind": "Method",
    "detail": "Function (output [ i ] =)",
    "insertText": "stbir__half_to_float(input[i])"
  },
  {
    "label": "stbir__float_to_half()",
    "kind": "Method",
    "detail": "Function (output [ i ] =)",
    "insertText": "stbir__float_to_half(input[i])"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} } # elif)",
    "insertText": "defined(STBIR_NEON) && defined(_MSC_VER) && defined(_M_ARM64) && !defined(__clang__) static stbir__inline void stbir__half_to_float_SIMD(float * output, stbir__FP16 const * input)"
  },
  {
    "label": "vld1_f16()",
    "kind": "Method",
    "detail": "Function (float16x4_t in0 =)",
    "insertText": "vld1_f16(input + 0)"
  },
  {
    "label": "vld1_f16()",
    "kind": "Method",
    "detail": "Function (float16x4_t in1 =)",
    "insertText": "vld1_f16(input + 4)"
  },
  {
    "label": "vst1q_f32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vst1q_f32(output + 0, vcvt_f32_f16(in0))"
  },
  {
    "label": "vst1q_f32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vst1q_f32(output + 4, vcvt_f32_f16(in1))"
  },
  {
    "label": "vcvt_f16_f32()",
    "kind": "Method",
    "detail": "Function (float16x4_t out0 =)",
    "insertText": "vcvt_f16_f32(vld1q_f32(input + 0))"
  },
  {
    "label": "vcvt_f16_f32()",
    "kind": "Method",
    "detail": "Function (float16x4_t out1 =)",
    "insertText": "vcvt_f16_f32(vld1q_f32(input + 4))"
  },
  {
    "label": "vst1_f16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vst1_f16(output+0, out0)"
  },
  {
    "label": "vst1_f16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vst1_f16(output+4, out1)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # elif)",
    "insertText": "defined(STBIR_NEON) static stbir__inline void stbir__half_to_float_SIMD(float * output, stbir__FP16 const * input)"
  },
  {
    "label": "vld1q_f16()",
    "kind": "Method",
    "detail": "Function (float16x8_t in =)",
    "insertText": "vld1q_f16(input)"
  },
  {
    "label": "vst1q_f32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vst1q_f32(output + 0, vcvt_f32_f16(vget_low_f16(in)))"
  },
  {
    "label": "vst1q_f32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vst1q_f32(output + 4, vcvt_f32_f16(vget_high_f16(in)))"
  },
  {
    "label": "vst1q_f16()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vst1q_f16(output, vcombine_f16(out0, out1))"
  },
  {
    "label": "stbir__simdf_0123to3333()",
    "kind": "Method",
    "detail": "Function (} # endif # ifdef STBIR_SIMD # define)",
    "insertText": "stbir__simdf_0123to3333(out, reg ) (out) = stbir__simdf_swiz( reg, 3,3,3,3 ) #define stbir__simdf_0123to2222( out, reg ) (out) = stbir__simdf_swiz( reg, 2,2,2,2 ) #define stbir__simdf_0123to1111( out, reg ) (out) = stbir__simdf_swiz( reg, 1,1,1,1 ) #define stbir__simdf_0123to0000( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,0,0 ) #define stbir__simdf_0123to0003( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,0,3 ) #define stbir__simdf_0123to0001( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,0,1 ) #define stbir__simdf_0123to1122( out, reg ) (out) = stbir__simdf_swiz( reg, 1,1,2,2 ) #define stbir__simdf_0123to2333( out, reg ) (out) = stbir__simdf_swiz( reg, 2,3,3,3 ) #define stbir__simdf_0123to0023( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,2,3 ) #define stbir__simdf_0123to1230( out, reg ) (out) = stbir__simdf_swiz( reg, 1,2,3,0 ) #define stbir__simdf_0123to2103( out, reg ) (out) = stbir__simdf_swiz( reg, 2,1,0,3 ) #define stbir__simdf_0123to3210( out, reg ) (out) = stbir__simdf_swiz( reg, 3,2,1,0 ) #define stbir__simdf_0123to2301( out, reg ) (out) = stbir__simdf_swiz( reg, 2,3,0,1 ) #define stbir__simdf_0123to3012( out, reg ) (out) = stbir__simdf_swiz( reg, 3,0,1,2 ) #define stbir__simdf_0123to0011( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,1,1 ) #define stbir__simdf_0123to1100( out, reg ) (out) = stbir__simdf_swiz( reg, 1,1,0,0 ) #define stbir__simdf_0123to2233( out, reg ) (out) = stbir__simdf_swiz( reg, 2,2,3,3 ) #define stbir__simdf_0123to1133( out, reg ) (out) = stbir__simdf_swiz( reg, 1,1,3,3 ) #define stbir__simdf_0123to0022( out, reg ) (out) = stbir__simdf_swiz( reg, 0,0,2,2 ) #define stbir__simdf_0123to1032( out, reg ) (out) = stbir__simdf_swiz( reg, 1,0,3,2)"
  },
  {
    "label": "STBIR__SIMDF_CONST()",
    "kind": "Method",
    "detail": "Function (stbir_uint32 m128i_u32 [ 4 ] ; int m128i_i32 [ 4 ] ; stbir__simdi m128i_i128 ; } stbir__simdi_u32 ; const int STBIR_mask [ 9 ] = { 0,0,0,- 1,- 1,- 1,0,0,0 } ; const)",
    "insertText": "STBIR__SIMDF_CONST(STBIR_max_uint8_as_float, stbir__max_uint8_as_float)"
  },
  {
    "label": "STBIR__SIMDF_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDF_CONST(STBIR_max_uint16_as_float, stbir__max_uint16_as_float)"
  },
  {
    "label": "STBIR__SIMDF_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDF_CONST(STBIR_max_uint8_as_float_inverted, stbir__max_uint8_as_float_inverted)"
  },
  {
    "label": "STBIR__SIMDF_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDF_CONST(STBIR_max_uint16_as_float_inverted, stbir__max_uint16_as_float_inverted)"
  },
  {
    "label": "STBIR__SIMDF_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDF_CONST(STBIR_simd_point5, 0.5f)"
  },
  {
    "label": "STBIR__SIMDF_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDF_CONST(STBIR_ones, 1.0f)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(STBIR_almost_zero, (127 - 13) << 23)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(STBIR_almost_one, 0x3f7fffff)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(STBIR_mastissa_mask, 0xff)"
  },
  {
    "label": "STBIR__SIMDI_CONST()",
    "kind": "Method",
    "detail": "Function (const)",
    "insertText": "STBIR__SIMDI_CONST(STBIR_topscale, 0x02000000)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(star ) STBIR_STREAMOUT_PTR( star ) #define STBIR_SIMD_NO_UNROLL(ptr) STBIR_NO_UNROLL(ptr) #ifdef STBIR_MEMCPY #undef STBIR_MEMCPY #endif #define STBIR_MEMCPY stbir_simd_memcpy static void stbir_simd_memcpy( void * dest, void const * src, size_t bytes)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (char)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(*) d = (char*)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (char)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(* ) d_end = ((char*) dest)"
  },
  {
    "label": "ofs_to_src()",
    "kind": "Method",
    "detail": "Function (ptrdiff_t)",
    "insertText": "ofs_to_src(char*)src - (char*)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(( ( d >= ( (char*)src) + bytes ) ) || ( ( d + bytes ) <= (char*)src ))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (d [ 0 ] = d [ ofs_to_src ] ; + + d ; })",
    "insertText": "while(d < d_end)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (} } else { stbir__simdf x ;)",
    "insertText": "stbir__simdf_load(x, ( d + ofs_to_src ))"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(d, x)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "d(char*)( ( ( (size_t)d ) + 16 ) & ~15)"
  },
  {
    "label": "STBIR_SIMD_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_SIMD_NO_UNROLL(d)"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (d + = 1 6 ; } } } else { stbir__simdfX x0,x1,x2,x3 ;)",
    "insertText": "stbir__simdfX_load(x0, ( d + ofs_to_src ) + 0*stbir__simdfX_float_count)"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_load(x1, ( d + ofs_to_src ) + 4*stbir__simdfX_float_count)"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_load(x2, ( d + ofs_to_src ) + 8*stbir__simdfX_float_count)"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_load(x3, ( d + ofs_to_src ) + 12*stbir__simdfX_float_count)"
  },
  {
    "label": "stbir__simdfX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_store(d + 0*stbir__simdfX_float_count, x0)"
  },
  {
    "label": "stbir__simdfX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_store(d + 4*stbir__simdfX_float_count, x1)"
  },
  {
    "label": "stbir__simdfX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_store(d + 8*stbir__simdfX_float_count, x2)"
  },
  {
    "label": "stbir__simdfX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_store(d + 12*stbir__simdfX_float_count, x3)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "d(char*)( ( ( (size_t)d ) + (16*stbir__simdfX_float_count) ) & ~((16*stbir__simdfX_float_count)-1))"
  },
  {
    "label": "d_end()",
    "kind": "Method",
    "detail": "Function (d =)",
    "insertText": "d_end(16*stbir__simdfX_float_count)"
  },
  {
    "label": "d()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "d(16*stbir__simdfX_float_count)"
  },
  {
    "label": "stbir_overlapping_memcpy()",
    "kind": "Method",
    "detail": "Function (} } } void)",
    "insertText": "stbir_overlapping_memcpy(void * dest, void const * src, size_t bytes)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (char)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(*) sd = (char*)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (char)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(* ) s_end = ((char*) src)"
  },
  {
    "label": "ofs_to_dest()",
    "kind": "Method",
    "detail": "Function (ptrdiff_t)",
    "insertText": "ofs_to_dest(char*)dest - (char*)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (char)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(* ) s_end16 = ((char*) src) + (bytes&~15)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(x, sd)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(( sd + ofs_to_dest ), x)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (sd + = 1 6 ; })",
    "insertText": "while(sd < s_end16)"
  },
  {
    "label": "STBIR_SIMD_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (} do {)",
    "insertText": "STBIR_SIMD_NO_UNROLL(sd)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (sd + = 4 ; })",
    "insertText": "while(sd < s_end)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (} # else # define)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(star ) STBIR_STREAMOUT_PTR( star ) #define STBIR_SIMD_NO_UNROLL(ptr) #endif #ifdef STBIR_PROFILE #if defined(_x86_64) || defined( __x86_64__ ) || defined( _M_X64 ) || defined(__x86_64) || defined(__SSE2__) || defined(STBIR_SSE) || defined( _M_IX86_FP ) || defined(__i386) || defined( __i386__ ) || defined( _M_IX86 ) || defined( _X86_ ) #ifdef _MSC_VER STBIRDEF stbir_uint64 __rdtsc()"
  },
  {
    "label": "STBIR_PROFILE_FUNC()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "STBIR_PROFILE_FUNC() __rdtsc() #else static stbir__inline stbir_uint64 STBIR_PROFILE_FUNC()"
  },
  {
    "label": "volatile()",
    "kind": "Method",
    "detail": "Function (stbir_uint32 lo,hi ; asm)",
    "insertText": "volatile(\"rdtsc\" : \"=a\" (lo), \"=d\" (hi))"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (} # endif # elif)",
    "insertText": "defined(_M_ARM64 ) || defined( __aarch64__ ) || defined( __arm64__ ) || defined(__ARM_NEON__) #if defined( _MSC_VER ) && !defined(__clang__) #define STBIR_PROFILE_FUNC() _ReadStatusReg(ARM64_CNTVCT) #else static stbir__inline stbir_uint64 STBIR_PROFILE_FUNC()"
  },
  {
    "label": "volatile()",
    "kind": "Method",
    "detail": "Function (stbir_uint64 tsc ; asm)",
    "insertText": "volatile(\"mrs %0, cntvct_el0\" : \"=r\" (tsc))"
  },
  {
    "label": "STBIR_PROFILE_FUNC()",
    "kind": "Method",
    "detail": "Function (stbir_uint64 wh # # thiszonetime =)",
    "insertText": "STBIR_PROFILE_FUNC()"
  },
  {
    "label": "STBIR_PROFILE_END_ll()",
    "kind": "Method",
    "detail": "Function (stbir_uint64* wh # # save_parent_excluded_ptr = info -> current_zone_excluded_ptr ; stbir_uint64 wh # # current_zone_excluded = 0 ; info -> current_zone_excluded_ptr =& wh # # current_zone_excluded ; # define)",
    "insertText": "STBIR_PROFILE_END_ll(info, wh ) wh##thiszonetime = STBIR_PROFILE_FUNC()"
  },
  {
    "label": "STBIR_PROFILE_FIRST_START_ll()",
    "kind": "Method",
    "detail": "Function (info -> profile . named . wh + = wh # # thiszonetime - wh # # current_zone_excluded ;* wh # # save_parent_excluded_ptr + = wh # # thiszonetime ; info -> current_zone_excluded_ptr = wh # # save_parent_excluded_ptr ; } # define)",
    "insertText": "STBIR_PROFILE_FIRST_START_ll(info, wh)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (profile.array[i]=0)",
    "insertText": "for(i=0;i<STBIR__ARRAY_SIZE(info->profile.array);i++)"
  },
  {
    "label": "STBIR_PROFILE_START_ll()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "STBIR_PROFILE_START_ll(info, wh)"
  },
  {
    "label": "STBIR_PROFILE_CLEAR_EXTRAS_ll()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "STBIR_PROFILE_CLEAR_EXTRAS_ll(info, num)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int extra ;)",
    "insertText": "for(extra=1;extra<(num);extra++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int i ;)",
    "insertText": "for(i=0;i<STBIR__ARRAY_SIZE((info)->profile.array);i++) (info)"
  },
  {
    "label": "STBIR_PROFILE_START()",
    "kind": "Method",
    "detail": "Function (} } # define)",
    "insertText": "STBIR_PROFILE_START(wh ) STBIR_PROFILE_START_ll( split_info, wh ) #define STBIR_PROFILE_END( wh ) STBIR_PROFILE_END_ll( split_info, wh ) #define STBIR_PROFILE_FIRST_START( wh ) STBIR_PROFILE_FIRST_START_ll( split_info, wh ) #define STBIR_PROFILE_CLEAR_EXTRAS() STBIR_PROFILE_CLEAR_EXTRAS_ll( split_info, split_count ) #define STBIR_PROFILE_BUILD_START( wh ) STBIR_PROFILE_START_ll( profile_info, wh ) #define STBIR_PROFILE_BUILD_END( wh ) STBIR_PROFILE_END_ll( profile_info, wh ) #define STBIR_PROFILE_BUILD_FIRST_START( wh ) STBIR_PROFILE_FIRST_START_ll( profile_info, wh ) #define STBIR_PROFILE_BUILD_CLEAR( info)"
  },
  {
    "label": "STBIR_PROFILE_START()",
    "kind": "Method",
    "detail": "Function (} # else # define STBIR_ONLY_PROFILE_GET_SPLIT_INFO # define STBIR_ONLY_PROFILE_SET_SPLIT_INFO # define STBIR_ONLY_PROFILE_BUILD_GET_INFO # define STBIR_ONLY_PROFILE_BUILD_SET_INFO # define)",
    "insertText": "STBIR_PROFILE_START(wh ) #define STBIR_PROFILE_END( wh ) #define STBIR_PROFILE_FIRST_START( wh ) #define STBIR_PROFILE_CLEAR_EXTRAS( ) #define STBIR_PROFILE_BUILD_START( wh ) #define STBIR_PROFILE_BUILD_END( wh ) #define STBIR_PROFILE_BUILD_FIRST_START( wh ) #define STBIR_PROFILE_BUILD_CLEAR( info ) #endif #ifndef STBIR_CEILF #include <math.h> #if _MSC_VER <= 1200 #define STBIR_CEILF(x) ((float)ceil((float)(x))) #define STBIR_FLOORF(x) ((float)floor((float)(x))) #else #define STBIR_CEILF(x) ceilf(x) #define STBIR_FLOORF(x) floorf(x) #endif #endif #ifndef STBIR_MEMCPY #include <string.h> #define STBIR_MEMCPY( dest, src, len ) memcpy( dest, src, len ) #endif #ifndef STBIR_SIMD static void stbir_overlapping_memcpy( void * dest, void const * src, size_t bytes)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (char)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(* ) s_end8 = ((char*) src) + (bytes&~7)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (sd + = 8 ; })",
    "insertText": "while(sd < s_end8)"
  },
  {
    "label": "STBIR_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (} do {)",
    "insertText": "STBIR_NO_UNROLL(sd)"
  },
  {
    "label": "stbir__filter_trapezoid()",
    "kind": "Method",
    "detail": "Function (} # endif float)",
    "insertText": "stbir__filter_trapezoid(float x, float scale, void * user_data)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (float halfscale = scale / 2 ; float t = 0 . 5 f + halfscale ;)",
    "insertText": "STBIR_ASSERT(scale <= 1)"
  },
  {
    "label": "STBIR__UNUSED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__UNUSED(user_data)"
  },
  {
    "label": "stbir__support_trapezoid()",
    "kind": "Method",
    "detail": "Function (} } float)",
    "insertText": "stbir__support_trapezoid(float scale, void * user_data)"
  },
  {
    "label": "STBIR__UNUSED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__UNUSED(s)"
  },
  {
    "label": "STBIR__UNUSED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__UNUSED(x)"
  },
  {
    "label": "stbir__filter_catmullrom()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "stbir__filter_catmullrom(float x, float s, void * user_data)"
  },
  {
    "label": "stbir__filter_mitchell()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "stbir__filter_mitchell(float x, float s, void * user_data)"
  },
  {
    "label": "stbir__support_zero()",
    "kind": "Method",
    "detail": "Function (} float)",
    "insertText": "stbir__support_zero(float s, void * user_data)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(support != 0)"
  },
  {
    "label": "stbir__get_coefficient_width()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "stbir__get_coefficient_width(stbir__sampler * samp, int is_gather, void * user_data)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (float scale = samp -> scale_info . scale ; stbir__support_callback* support = samp -> filter_support ;)",
    "insertText": "switch(is_gather)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (default :)",
    "insertText": "STBIR_ASSERT((is_gather >= 0 ) && (is_gather <= 2 ))"
  },
  {
    "label": "stbir__edge_zero_full()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "stbir__edge_zero_full(int n, int max)"
  },
  {
    "label": "STBIR__UNUSED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__UNUSED(n)"
  },
  {
    "label": "STBIR__UNUSED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__UNUSED(max)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int max2 = max* 2 ;)",
    "insertText": "if(n >= max2)"
  },
  {
    "label": "stbir__edge_wrap_func()",
    "kind": "Method",
    "detail": "Function (} } typedef int)",
    "insertText": "stbir__edge_wrap_func(int n, int max)"
  },
  {
    "label": "stbir__edge_wrap()",
    "kind": "Method",
    "detail": "Function (stbir__edge_wrap_func* stbir__edge_wrap_slow [ ] = { stbir__edge_clamp_full,stbir__edge_reflect_full,stbir__edge_wrap_full,stbir__edge_zero_full,} ; stbir__inline int)",
    "insertText": "stbir__edge_wrap(stbir_edge edge, int n, int max)"
  },
  {
    "label": "stbir__get_extents()",
    "kind": "Method",
    "detail": "Function (} # define STBIR__MERGE_RUNS_PIXEL_THRESHOLD 1 6 void)",
    "insertText": "stbir__get_extents(stbir__sampler * samp, stbir__extents * scanline_extents)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (int j,stop ; int left_margin,right_margin ; int min_n = 0 x7fffffff,max_n = - 0 x7fffffff ; int min_left = 0 x7fffffff,max_left = - 0 x7fffffff ; int min_right = 0 x7fffffff,max_right = - 0 x7fffffff ; stbir_edge edge = samp -> edge ; stbir__contributors* contributors = samp -> contributors ; int output_sub_size = samp -> scale_info . output_sub_size ; int input_full_size = samp -> scale_info . input_full_size ; int filter_pixel_margin = samp -> filter_pixel_margin ;)",
    "insertText": "STBIR_ASSERT(samp->is_gather)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (stop = output_sub_size ;)",
    "insertText": "for(j = 0; j < stop; j++)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(contributors[j].n1 >= contributors[j].n0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (min_n = contributors [ j ] . n0 ; stop = j + filter_pixel_margin ;)",
    "insertText": "if(stop > output_sub_size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} } stop = 0 ;)",
    "insertText": "for(j = output_sub_size - 1; j >= stop; j--)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (max_n = contributors [ j ] . n1 ; stop = j - filter_pixel_margin ;)",
    "insertText": "if(stop<0)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "STBIR_ASSERT(scanline_extents->conservative.n0 <= min_n)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(scanline_extents->conservative.n1 >= max_n)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (left_margin = 0 ;)",
    "insertText": "if(min_n < 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (left_margin = - min_n ; min_n = 0 ; } right_margin = 0 ;)",
    "insertText": "if(max_n >= input_full_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (right_margin = max_n - input_full_size + 1 ; max_n = input_full_size - 1 ; } scanline_extents -> edge_sizes [ 0 ] = left_margin ; scanline_extents -> edge_sizes [ 1 ] = right_margin ; scanline_extents -> spans [ 0 ] . n0 = min_n ; scanline_extents -> spans [ 0 ] . n1 = max_n ; scanline_extents -> spans [ 0 ] . pixel_offset_for_input = min_n ; scanline_extents -> spans [ 1 ] . n0 = 0 ; scanline_extents -> spans [ 1 ] . n1 = - 1 ; scanline_extents -> spans [ 1 ] . pixel_offset_for_input = 0 ;)",
    "insertText": "if(edge == STBIR_EDGE_ZERO)"
  },
  {
    "label": "stbir__edge_wrap()",
    "kind": "Method",
    "detail": "Function (int p =)",
    "insertText": "stbir__edge_wrap(edge, j, input_full_size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(j = input_full_size ; j < (input_full_size + right_margin) ; j++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(min_left != 0x7fffffff)"
  },
  {
    "label": "stbir__min()",
    "kind": "Method",
    "detail": "Function (scanline_extents -> spans [ 0 ] . n0 = min_n =)",
    "insertText": "stbir__min(min_n, min_left)"
  },
  {
    "label": "stbir__max()",
    "kind": "Method",
    "detail": "Function (scanline_extents -> spans [ 0 ] . n1 = max_n =)",
    "insertText": "stbir__max(max_n, max_left)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (scanline_extents -> spans [ 0 ] . pixel_offset_for_input = min_n ; left_margin = 0 ; } })",
    "insertText": "if(min_right != 0x7fffffff)"
  },
  {
    "label": "stbir__min()",
    "kind": "Method",
    "detail": "Function (scanline_extents -> spans [ 0 ] . n0 = min_n =)",
    "insertText": "stbir__min(min_n, min_right)"
  },
  {
    "label": "stbir__max()",
    "kind": "Method",
    "detail": "Function (scanline_extents -> spans [ 0 ] . n1 = max_n =)",
    "insertText": "stbir__max(max_n, max_right)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (stbir__span* newspan = scanline_extents -> spans + 1 ;)",
    "insertText": "STBIR_ASSERT(right_margin == 0)"
  },
  {
    "label": "n1()",
    "kind": "Method",
    "detail": "Function (scanline_extents -> spans [ 1 ] . pixel_offset_for_input = scanline_extents -> spans [ 0 ] . n0 ; scanline_extents -> spans [ 1 ] . n0 = scanline_extents -> spans [ 0 ] . n0 ; scanline_extents -> spans [ 1 ] . n1 = scanline_extents -> spans [ 0 ] . n1 ; - - newspan ; } newspan -> pixel_offset_for_input = min_left ; newspan -> n0 = - left_margin ; newspan ->)",
    "insertText": "n1(max_left - min_left)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (scanline_extents -> edge_sizes [ 0 ] = 0 ; return ; })",
    "insertText": "if(( right_margin ) && ( min_right != 0x7fffffff ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (stbir__span* newspan = scanline_extents -> spans + 1 ;)",
    "insertText": "if(min_right < scanline_extents->spans[0].n0)"
  },
  {
    "label": "n1()",
    "kind": "Method",
    "detail": "Function (scanline_extents -> spans [ 1 ] . pixel_offset_for_input = scanline_extents -> spans [ 0 ] . n0 ; scanline_extents -> spans [ 1 ] . n0 = scanline_extents -> spans [ 0 ] . n0 ; scanline_extents -> spans [ 1 ] . n1 = scanline_extents -> spans [ 0 ] . n1 ; - - newspan ; } newspan -> pixel_offset_for_input = min_right ; newspan -> n0 = scanline_extents -> spans [ 1 ] . n1 + 1 ; newspan -> n1 = scanline_extents -> spans [ 1 ] .)",
    "insertText": "n1(max_right - min_right)"
  },
  {
    "label": "stbir__calculate_in_pixel_range()",
    "kind": "Method",
    "detail": "Function (scanline_extents -> edge_sizes [ 1 ] = 0 ; return ; } } void)",
    "insertText": "stbir__calculate_in_pixel_range(int * first_pixel, int * last_pixel, float out_pixel_center, float out_filter_radius, float inv_scale, float out_shift, int input_size, stbir_edge edge)"
  },
  {
    "label": "in_pixel_influence_lowerbound()",
    "kind": "Method",
    "detail": "Function (int first,last ; float out_pixel_influence_lowerbound = out_pixel_center - out_filter_radius ; float out_pixel_influence_upperbound = out_pixel_center + out_filter_radius ; float)",
    "insertText": "in_pixel_influence_lowerbound(out_pixel_influence_lowerbound + out_shift)"
  },
  {
    "label": "in_pixel_influence_upperbound()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "in_pixel_influence_upperbound(out_pixel_influence_upperbound + out_shift)"
  },
  {
    "label": "first()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "first(int)(STBIR_FLOORF(in_pixel_influence_lowerbound + 0.5f))"
  },
  {
    "label": "last()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "last(int)(STBIR_FLOORF(in_pixel_influence_upperbound - 0.5f))"
  },
  {
    "label": "stbir__calculate_coefficients_for_gather_upsample()",
    "kind": "Method",
    "detail": "Function (}* first_pixel = first ;* last_pixel = last ; } void)",
    "insertText": "stbir__calculate_coefficients_for_gather_upsample(float out_filter_radius, stbir__kernel_callback * kernel, stbir__scale_info * scale_info, int num_contributors, stbir__contributors* contributors, float* coefficient_group, int coefficient_width, stbir_edge edge, void * user_data)"
  },
  {
    "label": "polyphase()",
    "kind": "Method",
    "detail": "Function (int n,end ; float inv_scale = scale_info -> inv_scale ; float out_shift = scale_info -> pixel_shift ; int input_size = scale_info -> input_full_size ; int numerator = scale_info -> scale_numerator ; int)",
    "insertText": "polyphase(( scale_info->scale_is_rational ) && ( numerator < num_contributors ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (end = num_contributors ;)",
    "insertText": "if(polyphase)"
  },
  {
    "label": "out_pixel_center()",
    "kind": "Method",
    "detail": "Function (int i ; int last_non_zero ; float)",
    "insertText": "out_pixel_center(float)"
  },
  {
    "label": "in_center_of_out()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "in_center_of_out(out_pixel_center + out_shift)"
  },
  {
    "label": "stbir__calculate_in_pixel_range()",
    "kind": "Method",
    "detail": "Function (int in_first_pixel,in_last_pixel ;)",
    "insertText": "stbir__calculate_in_pixel_range(&in_first_pixel, &in_last_pixel, out_pixel_center, out_filter_radius, inv_scale, out_shift, input_size, edge)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (last_non_zero = - 1 ;)",
    "insertText": "for(i = 0; i <= in_last_pixel - in_first_pixel; i++)"
  },
  {
    "label": "in_pixel_center()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "in_pixel_center(float)(i + in_first_pixel)"
  },
  {
    "label": "kernel()",
    "kind": "Method",
    "detail": "Function (float coeff =)",
    "insertText": "kernel(in_center_of_out - in_pixel_center, inv_scale, user_data)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(( in_last_pixel - in_first_pixel ) != 0)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (+ + in_first_pixel ; i - - ; continue ; } coeff = 0 ; } else last_non_zero = i ; coefficient_group [ i ] = coeff ; } in_last_pixel = last_non_zero + in_first_pixel ; contributors -> n0 = in_first_pixel ; contributors -> n1 = in_last_pixel ;)",
    "insertText": "STBIR_ASSERT(contributors->n1 >= contributors->n0)"
  },
  {
    "label": "stbir__insert_coeff()",
    "kind": "Method",
    "detail": "Function (+ + contributors ; coefficient_group + = coefficient_width ; } } void)",
    "insertText": "stbir__insert_coeff(stbir__contributors * contribs, float * coeffs, int new_pixel, float new_coeff)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int j,o = contribs -> n0 - new_pixel ;)",
    "insertText": "for(j = contribs->n1 - contribs->n0 ; j <= 0 ; j--)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (coeffs [ 0 ] = new_coeff ; contribs -> n0 = new_pixel ; } else { coeffs [ new_pixel - contribs -> n0 ] + = new_coeff ; } } else { int j,e = new_pixel - contribs -> n0 ;)",
    "insertText": "for(j = ( contribs->n1 - contribs->n0 ) + 1 ; j < e ; j++)"
  },
  {
    "label": "stbir__calculate_out_pixel_range()",
    "kind": "Method",
    "detail": "Function (coeffs [ e ] = new_coeff ; contribs -> n1 = new_pixel ; } } void)",
    "insertText": "stbir__calculate_out_pixel_range(int * first_pixel, int * last_pixel, float in_pixel_center, float in_pixels_radius, float scale, float out_shift, int out_size)"
  },
  {
    "label": "out_first_pixel()",
    "kind": "Method",
    "detail": "Function (float in_pixel_influence_lowerbound = in_pixel_center - in_pixels_radius ; float in_pixel_influence_upperbound = in_pixel_center + in_pixels_radius ; float out_pixel_influence_lowerbound = in_pixel_influence_lowerbound* scale - out_shift ; float out_pixel_influence_upperbound = in_pixel_influence_upperbound* scale - out_shift ; int)",
    "insertText": "out_first_pixel(int)(STBIR_FLOORF(out_pixel_influence_lowerbound + 0.5f))"
  },
  {
    "label": "out_last_pixel()",
    "kind": "Method",
    "detail": "Function (int)",
    "insertText": "out_last_pixel(int)(STBIR_FLOORF(out_pixel_influence_upperbound - 0.5f))"
  },
  {
    "label": "stbir__calculate_coefficients_for_gather_downsample()",
    "kind": "Method",
    "detail": "Function (* first_pixel = out_first_pixel ;* last_pixel = out_last_pixel ; } void)",
    "insertText": "stbir__calculate_coefficients_for_gather_downsample(int start, int end, float in_pixels_radius, stbir__kernel_callback * kernel, stbir__scale_info * scale_info, int coefficient_width, int num_contributors, stbir__contributors * contributors, float * coefficient_group, void * user_data)"
  },
  {
    "label": "polyphase()",
    "kind": "Method",
    "detail": "Function (int in_pixel ; int i ; int first_out_inited = - 1 ; float scale = scale_info -> scale ; float out_shift = scale_info -> pixel_shift ; int out_size = scale_info -> output_sub_size ; int numerator = scale_info -> scale_numerator ; int)",
    "insertText": "polyphase(( scale_info->scale_is_rational ) && ( numerator < out_size ))"
  },
  {
    "label": "STBIR__UNUSED()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__UNUSED(num_contributors)"
  },
  {
    "label": "in_pixel_center()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "in_pixel_center(float)"
  },
  {
    "label": "stbir__calculate_out_pixel_range()",
    "kind": "Method",
    "detail": "Function (float out_center_of_in = in_pixel_center* scale - out_shift ; int out_first_pixel,out_last_pixel ;)",
    "insertText": "stbir__calculate_out_pixel_range(&out_first_pixel, &out_last_pixel, in_pixel_center, in_pixels_radius, scale, out_shift, out_size)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = 0; i <= out_last_pixel - out_first_pixel; i++)"
  },
  {
    "label": "out_pixel_center()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "out_pixel_center(float)(i + out_first_pixel)"
  },
  {
    "label": "kernel()",
    "kind": "Method",
    "detail": "Function (float x = out_pixel_center - out_center_of_in ; float coeff =)",
    "insertText": "kernel(x, scale, user_data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function ({ int out = i + out_first_pixel ; float* coeffs = coefficient_group + out* coefficient_width ; stbir__contributors* contribs = contributors + out ;)",
    "insertText": "if(out > first_out_inited)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(out == ( first_out_inited + 1 ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (first_out_inited = out ; contribs -> n0 = in_pixel ; contribs -> n1 = in_pixel ; coeffs [ 0 ] = coeff ; } else {)",
    "insertText": "if(coeffs[0] == 0.0f)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(( in_pixel - contribs->n0 ) == 1)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (contribs -> n0 = in_pixel ; } contribs -> n1 = in_pixel ;)",
    "insertText": "STBIR_ASSERT(( in_pixel - contribs->n0 ) < coefficient_width)"
  },
  {
    "label": "stbir__cleanup_gathered_coefficients()",
    "kind": "Method",
    "detail": "Function (coeffs [ in_pixel - contribs -> n0 ] = coeff ; } } } } } # ifdef STBIR_RENORMALIZE_IN_FLOAT # define STBIR_RENORM_TYPE float # else # define STBIR_RENORM_TYPE double # endif void)",
    "insertText": "stbir__cleanup_gathered_coefficients(stbir_edge edge, stbir__filter_extent_info* filter_info, stbir__scale_info * scale_info, int num_contributors, stbir__contributors* contributors, float * coefficient_group, int coefficient_width)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int i ; STBIR_RENORM_TYPE filter_scale,total_filter = 0 ; int e ; e = contribs -> n1 - contribs -> n0 ;)",
    "insertText": "for(i = 0 ; i <= e ; i++)"
  },
  {
    "label": "total_filter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "total_filter(STBIR_RENORM_TYPE)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(( coeffs[i] >= -2.0f ) && ( coeffs[i] <= 2.0f ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(( total_filter < stbir__small_float ) && ( total_filter > -stbir__small_float ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (contribs -> n1 = contribs -> n0 ; coeffs [ 0 ] = 0 . 0 f ; } else {)",
    "insertText": "if(( total_filter < (1.0f-stbir__small_float) ) || ( total_filter > (1.0f+stbir__small_float) ))"
  },
  {
    "label": "filter_scale()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "filter_scale((STBIR_RENORM_TYPE)1.0)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (stbir__contributors* prev_contribs = contributors ; stbir__contributors* cur_contribs = contributors + numerator ;)",
    "insertText": "for(n = numerator ; n < num_contributors ; n++)"
  },
  {
    "label": "stbir_overlapping_memcpy()",
    "kind": "Method",
    "detail": "Function (cur_contribs -> n0 = prev_contribs -> n0 + denominator ; cur_contribs -> n1 = prev_contribs -> n1 + denominator ; + + cur_contribs ; + + prev_contribs ; })",
    "insertText": "stbir_overlapping_memcpy(coefficient_group + numerator * coefficient_width, coefficient_group, ( num_contributors - numerator ) * coefficient_width * sizeof( coeffs[ 0 ] ))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} coeffs = coefficient_group ; contribs = contributors ;)",
    "insertText": "for(n = 0; n < num_contributors; n++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int j,left,skips = 0 ; skips = - contribs -> n0 ; contribs -> n0 = 0 ; left = contribs -> n1 - contribs -> n0 + 1 ;)",
    "insertText": "if(left > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } else)",
    "insertText": "if(( edge == STBIR_EDGE_CLAMP ) || ( edge == STBIR_EDGE_REFLECT ))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int start = contribs -> n0 ; int endi = contribs -> n1 ; contribs -> n1 = input_last_n1 ;)",
    "insertText": "for(i = input_size; i <= endi; i++ ) stbir__insert_coeff( contribs, coeffs, stbir__edge_wrap_slow[edge]( i, input_size ), coeffs[i-start])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(contribs->n0 < 0)"
  },
  {
    "label": "coeffs()",
    "kind": "Method",
    "detail": "Function (int save_n0 ; float save_n0_coeff ; float* c =)",
    "insertText": "coeffs(contribs->n0 + 1)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (save_n0 = contribs -> n0 ; save_n0_coeff = c [ 0 ] ; contribs -> n0 = 0 ;)",
    "insertText": "for(i = 0 ; i <= contribs->n1 ; i++)"
  },
  {
    "label": "stbir__insert_coeff()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__insert_coeff(contribs, coeffs, stbir__edge_wrap_slow[edge]( save_n0, input_size ), save_n0_coeff)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(contribs->n0 <= contribs->n1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (int diff = contribs -> n1 - contribs -> n0 + 1 ;)",
    "insertText": "while(diff && ( coeffs[ diff-1 ] == 0.0f ))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = diff ; i < coefficient_width ; i++)"
  },
  {
    "label": "stbir__pack_coefficients()",
    "kind": "Method",
    "detail": "Function (} + + contribs ; coeffs + = coefficient_width ; } filter_info -> lowest = lowest ; filter_info -> highest = highest ; filter_info -> widest = widest ; } # undef STBIR_RENORM_TYPE int)",
    "insertText": "stbir__pack_coefficients(int num_contributors, stbir__contributors* contributors, float * coefficents, int coefficient_width, int widest, int row0, int row1)"
  },
  {
    "label": "STBIR_MOVE_1()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "STBIR_MOVE_1(dest, src)"
  },
  {
    "label": "STBIR_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_NO_UNROLL(dest)"
  },
  {
    "label": "STBIR_MOVE_2()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "STBIR_MOVE_2(dest, src)"
  },
  {
    "label": "STBIR_MOVE_4()",
    "kind": "Method",
    "detail": "Function (} # ifdef STBIR_SIMD # define)",
    "insertText": "STBIR_MOVE_4(dest, src)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(t, src)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(dest, t)"
  },
  {
    "label": "STBIR__UNUSED()",
    "kind": "Method",
    "detail": "Function (} # endif int row_end = row1 + 1 ;)",
    "insertText": "STBIR__UNUSED(row0)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (float* pc = coefficents ; float* coeffs = coefficents ; float* pc_end = coefficents + num_contributors* widest ;)",
    "insertText": "switch(widest)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + pc ; coeffs + = coefficient_width ; })",
    "insertText": "while(pc < pc_end)"
  },
  {
    "label": "STBIR_MOVE_2()",
    "kind": "Method",
    "detail": "Function (break ; case 2 : do {)",
    "insertText": "STBIR_MOVE_2(pc, coeffs)"
  },
  {
    "label": "STBIR_MOVE_1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MOVE_1(pc+2, coeffs+2)"
  },
  {
    "label": "STBIR_MOVE_4()",
    "kind": "Method",
    "detail": "Function (break ; case 4 : do {)",
    "insertText": "STBIR_MOVE_4(pc, coeffs)"
  },
  {
    "label": "STBIR_MOVE_1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MOVE_1(pc+4, coeffs+4)"
  },
  {
    "label": "STBIR_MOVE_2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MOVE_2(pc+4, coeffs+4)"
  },
  {
    "label": "STBIR_MOVE_1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MOVE_1(pc+6, coeffs+6)"
  },
  {
    "label": "STBIR_MOVE_4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MOVE_4(pc+4, coeffs+4)"
  },
  {
    "label": "STBIR_MOVE_1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MOVE_1(pc+8, coeffs+8)"
  },
  {
    "label": "STBIR_MOVE_2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MOVE_2(pc+8, coeffs+8)"
  },
  {
    "label": "STBIR_MOVE_1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MOVE_1(pc+10, coeffs+10)"
  },
  {
    "label": "STBIR_MOVE_4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MOVE_4(pc+8, coeffs+8)"
  },
  {
    "label": "STBIR_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (break ; default : do { float* copy_end = pc + widest - 4 ; float* c = coeffs ; do {)",
    "insertText": "STBIR_NO_UNROLL(pc)"
  },
  {
    "label": "STBIR_MOVE_4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MOVE_4(pc, c)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (pc + = 4 ; c + = 4 ; })",
    "insertText": "while(pc <= copy_end)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (copy_end + = 4 ;)",
    "insertText": "while(pc < copy_end)"
  },
  {
    "label": "STBIR_MOVE_1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MOVE_1(pc, c)"
  },
  {
    "label": "widest()",
    "kind": "Method",
    "detail": "Function (break ; } } coefficents [ widest* num_contributors ] = 8 8 8 8 . 0 f ; { stbir__contributors* contribs = contributors + num_contributors - 1 ; float* coeffs = coefficents +)",
    "insertText": "widest(num_contributors - 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int stop_range = widest ;)",
    "insertText": "if(widest > 12)"
  },
  {
    "label": "stop_range()",
    "kind": "Method",
    "detail": "Function (int mod ; mod = widest& 3 ;)",
    "insertText": "stop_range(( ( contribs->n1 - contribs->n0 + 1 ) - mod + 3 ) & ~3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(( contribs->n0 + stop_range ) > row_end)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (int new_n0 = row_end - stop_range ; int num = contribs -> n1 - contribs -> n0 + 1 ; int backup = contribs -> n0 - new_n0 ; float* from_co = coeffs + num - 1 ; float* to_co = from_co + backup ;)",
    "insertText": "STBIR_ASSERT(( new_n0 >= row0 ) && ( new_n0 < contribs->n0 ))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (* to_co - - =* from_co - - ; - - num ; })",
    "insertText": "while(to_co >= coeffs)"
  },
  {
    "label": "stbir__calculate_filters()",
    "kind": "Method",
    "detail": "Function (} } } - - contribs ; coeffs - = widest ; } } return widest ; # undef STBIR_MOVE_1 # undef STBIR_MOVE_2 # undef STBIR_MOVE_4 } void)",
    "insertText": "stbir__calculate_filters(stbir__sampler * samp, stbir__sampler * other_axis_for_pivot, void * user_data STBIR_ONLY_PROFILE_BUILD_GET_INFO)"
  },
  {
    "label": "switch()",
    "kind": "Method",
    "detail": "Function (int n ; float scale = samp -> scale_info . scale ; stbir__kernel_callback* kernel = samp -> filter_kernel ; stbir__support_callback* support = samp -> filter_support ; float inv_scale = samp -> scale_info . inv_scale ; int input_full_size = samp -> scale_info . input_full_size ; int gather_num_contributors = samp -> num_contributors ; stbir__contributors* gather_contributors = samp -> contributors ; float* gather_coeffs = samp -> coefficients ; int gather_coefficient_width = samp -> coefficient_width ;)",
    "insertText": "switch(samp->is_gather)"
  },
  {
    "label": "stbir__calculate_coefficients_for_gather_upsample()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__calculate_coefficients_for_gather_upsample(out_pixels_radius, kernel, &samp->scale_info, gather_num_contributors, gather_contributors, gather_coeffs, gather_coefficient_width, samp->edge, user_data)"
  },
  {
    "label": "STBIR_PROFILE_BUILD_START()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_BUILD_START(cleanup)"
  },
  {
    "label": "stbir__cleanup_gathered_coefficients()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__cleanup_gathered_coefficients(samp->edge, &samp->extent_info, &samp->scale_info, gather_num_contributors, gather_contributors, gather_coeffs, gather_coefficient_width)"
  },
  {
    "label": "STBIR_PROFILE_BUILD_END()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_BUILD_END(cleanup)"
  },
  {
    "label": "support()",
    "kind": "Method",
    "detail": "Function (} break ; case 0 : case 2 : { float in_pixels_radius =)",
    "insertText": "support(scale,user_data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int filter_pixel_margin = samp -> filter_pixel_margin ; int input_end = input_full_size + filter_pixel_margin ;)",
    "insertText": "if(!samp->is_gather)"
  },
  {
    "label": "stbir__calculate_coefficients_for_gather_downsample()",
    "kind": "Method",
    "detail": "Function (gather_contributors = other_axis_for_pivot -> contributors ; gather_coeffs = other_axis_for_pivot -> coefficients ; gather_coefficient_width = other_axis_for_pivot -> coefficient_width ; gather_num_contributors = other_axis_for_pivot -> num_contributors ; samp -> extent_info . lowest = other_axis_for_pivot -> extent_info . lowest ; samp -> extent_info . highest = other_axis_for_pivot -> extent_info . highest ; samp -> extent_info . widest = other_axis_for_pivot -> extent_info . widest ; goto jump_right_to_pivot ; } gather_contributors = samp -> gather_prescatter_contributors ; gather_coeffs = samp -> gather_prescatter_coefficients ; gather_coefficient_width = samp -> gather_prescatter_coefficient_width ; gather_num_contributors = samp -> gather_prescatter_num_contributors ; })",
    "insertText": "stbir__calculate_coefficients_for_gather_downsample(-filter_pixel_margin, input_end, in_pixels_radius, kernel, &samp->scale_info, gather_coefficient_width, gather_num_contributors, gather_contributors, gather_coeffs, user_data)"
  },
  {
    "label": "STBIR_PROFILE_BUILD_START()",
    "kind": "Method",
    "detail": "Function (stbir__contributors* scatter_contributors ; int highest_set ; jump_right_to_pivot :)",
    "insertText": "STBIR_PROFILE_BUILD_START(pivot)"
  },
  {
    "label": "highest_set()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "highest_set(-filter_pixel_margin)"
  },
  {
    "label": "coefficients()",
    "kind": "Method",
    "detail": "Function (int k ; int gn0 = gather_contributors -> n0,gn1 = gather_contributors -> n1 ; int scatter_coefficient_width = samp -> coefficient_width ; float* scatter_coeffs = samp ->)",
    "insertText": "coefficients(gn0 + filter_pixel_margin)"
  },
  {
    "label": "contributors()",
    "kind": "Method",
    "detail": "Function (float* g_coeffs = gather_coeffs ; scatter_contributors = samp ->)",
    "insertText": "contributors(gn0 + filter_pixel_margin)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float gc =* g_coeffs + + ;)",
    "insertText": "if(( ( gc >= stbir__small_float ) || ( gc <= -stbir__small_float ) ))"
  },
  {
    "label": "contributors()",
    "kind": "Method",
    "detail": "Function ({ stbir__contributors* clear_contributors = samp ->)",
    "insertText": "contributors(highest_set + filter_pixel_margin + 1)"
  },
  {
    "label": "stbir__insert_coeff()",
    "kind": "Method",
    "detail": "Function (clear_contributors -> n0 = 0 ; clear_contributors -> n1 = - 1 ; + + clear_contributors ; } } scatter_contributors -> n0 = n ; scatter_contributors -> n1 = n ; scatter_coeffs [ 0 ] = gc ; highest_set = k ; } else {)",
    "insertText": "stbir__insert_coeff(scatter_contributors, scatter_coeffs, n, gc)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "STBIR_ASSERT(( scatter_contributors->n1 - scatter_contributors->n0 + 1 ) <= scatter_coefficient_width)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (stbir__contributors* end_contributors = samp -> contributors + samp -> num_contributors ;)",
    "insertText": "while(clear_contributors < end_contributors)"
  },
  {
    "label": "STBIR_PROFILE_BUILD_END()",
    "kind": "Method",
    "detail": "Function (clear_contributors -> n0 = 0 ; clear_contributors -> n1 = - 1 ; + + clear_contributors ; } })",
    "insertText": "STBIR_PROFILE_BUILD_END(pivot)"
  },
  {
    "label": "stbir__fancy_alpha_weight_4ch()",
    "kind": "Method",
    "detail": "Function (} } break ; } } # define stbir__coder_min_num 1 # define STB_IMAGE_RESIZE_DO_CODERS # include STBIR__HEADER_FILENAME # define stbir__decode_suffix BGRA # define stbir__decode_swizzle # define stbir__decode_order0 2 # define stbir__decode_order1 1 # define stbir__decode_order2 0 # define stbir__decode_order3 3 # define stbir__encode_order0 2 # define stbir__encode_order1 1 # define stbir__encode_order2 0 # define stbir__encode_order3 3 # define stbir__coder_min_num 4 # define STB_IMAGE_RESIZE_DO_CODERS # include STBIR__HEADER_FILENAME # define stbir__decode_suffix ARGB # define stbir__decode_swizzle # define stbir__decode_order0 1 # define stbir__decode_order1 2 # define stbir__decode_order2 3 # define stbir__decode_order3 0 # define stbir__encode_order0 3 # define stbir__encode_order1 0 # define stbir__encode_order2 1 # define stbir__encode_order3 2 # define stbir__coder_min_num 4 # define STB_IMAGE_RESIZE_DO_CODERS # include STBIR__HEADER_FILENAME # define stbir__decode_suffix ABGR # define stbir__decode_swizzle # define stbir__decode_order0 3 # define stbir__decode_order1 2 # define stbir__decode_order2 1 # define stbir__decode_order3 0 # define stbir__encode_order0 3 # define stbir__encode_order1 2 # define stbir__encode_order2 1 # define stbir__encode_order3 0 # define stbir__coder_min_num 4 # define STB_IMAGE_RESIZE_DO_CODERS # include STBIR__HEADER_FILENAME # define stbir__decode_suffix AR # define stbir__decode_swizzle # define stbir__decode_order0 1 # define stbir__decode_order1 0 # define stbir__decode_order2 3 # define stbir__decode_order3 2 # define stbir__encode_order0 1 # define stbir__encode_order1 0 # define stbir__encode_order2 3 # define stbir__encode_order3 2 # define stbir__coder_min_num 2 # define STB_IMAGE_RESIZE_DO_CODERS # include STBIR__HEADER_FILENAME void)",
    "insertText": "stbir__fancy_alpha_weight_4ch(float * out_buffer, int width_times_channels)"
  },
  {
    "label": "STBIR_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "STBIR_STREAMOUT_PTR(*)"
  },
  {
    "label": "out_buffer()",
    "kind": "Method",
    "detail": "Function (float const* end_decode =)",
    "insertText": "out_buffer(width_times_channels / 4)"
  },
  {
    "label": "STBIR_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "STBIR_STREAMOUT_PTR(*) decode = (float*)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIR_SIMD # ifdef STBIR_SIMD8 decode + = 1 6 ;)",
    "insertText": "while(decode <= end_decode)"
  },
  {
    "label": "STBIR_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (stbir__simdf8 d0,d1,a0,a1,p0,p1 ;)",
    "insertText": "STBIR_NO_UNROLL(decode)"
  },
  {
    "label": "stbir__simdf8_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_load(d0, decode-16)"
  },
  {
    "label": "stbir__simdf8_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_load(d1, decode-16+8)"
  },
  {
    "label": "stbir__simdf8_0123to33333333()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_0123to33333333(a0, d0)"
  },
  {
    "label": "stbir__simdf8_0123to33333333()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_0123to33333333(a1, d1)"
  },
  {
    "label": "stbir__simdf8_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_mult(p0, a0, d0)"
  },
  {
    "label": "stbir__simdf8_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_mult(p1, a1, d1)"
  },
  {
    "label": "stbir__simdf8_bot4s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_bot4s(a0, d0, p0)"
  },
  {
    "label": "stbir__simdf8_bot4s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_bot4s(a1, d1, p1)"
  },
  {
    "label": "stbir__simdf8_top4s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_top4s(d0, d0, p0)"
  },
  {
    "label": "stbir__simdf8_top4s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_top4s(d1, d1, p1)"
  },
  {
    "label": "stbir__simdf8_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_store(out, a0)"
  },
  {
    "label": "stbir__simdf8_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_store(out+7, d0)"
  },
  {
    "label": "stbir__simdf8_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_store(out+14, a1)"
  },
  {
    "label": "stbir__simdf8_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_store(out+21, d1)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(d0, decode-8)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(d1, decode-8+4)"
  },
  {
    "label": "stbir__simdf_0123to3333()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_0123to3333(a0, d0)"
  },
  {
    "label": "stbir__simdf_0123to3333()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_0123to3333(a1, d1)"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(p0, a0, d0)"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(p1, a1, d1)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(out, d0)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(out+4, p0)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(out+7, d1)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(out+7+4, p1)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (decode + = 8 ; out + = 1 4 ; } decode - = 8 ; # endif # ifdef STBIR_SIMD8)",
    "insertText": "while(decode < end_decode ) #else if ( decode < end_decode)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (stbir__simdf d,a,p ;)",
    "insertText": "stbir__simdf_load(d, decode)"
  },
  {
    "label": "stbir__simdf_0123to3333()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_0123to3333(a, d)"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(p, a, d)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(out, d)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(out+4, p)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (decode + = 4 ; out + = 7 ; } # else)",
    "insertText": "while(decode < end_decode)"
  },
  {
    "label": "stbir__fancy_alpha_weight_2ch()",
    "kind": "Method",
    "detail": "Function (float r = decode [ 0 ],g = decode [ 1 ],b = decode [ 2 ],alpha = decode [ 3 ] ; out [ 0 ] = r ; out [ 1 ] = g ; out [ 2 ] = b ; out [ 3 ] = alpha ; out [ 4 ] = r* alpha ; out [ 5 ] = g* alpha ; out [ 6 ] = b* alpha ; out + = 7 ; decode + = 4 ; } # endif } void)",
    "insertText": "stbir__fancy_alpha_weight_2ch(float * out_buffer, int width_times_channels)"
  },
  {
    "label": "out_buffer()",
    "kind": "Method",
    "detail": "Function (float const* end_decode =)",
    "insertText": "out_buffer(width_times_channels / 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIR_SIMD decode + = 8 ;)",
    "insertText": "if(decode <= end_decode)"
  },
  {
    "label": "stbir__simdf8_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_load(d0, decode-8)"
  },
  {
    "label": "stbir__simdf8_0123to11331133()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_0123to11331133(p0, d0)"
  },
  {
    "label": "stbir__simdf8_0123to00220022()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_0123to00220022(a0, d0)"
  },
  {
    "label": "stbir__simdf8_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_mult(p0, p0, a0)"
  },
  {
    "label": "stbir__simdf_store2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store2(out, stbir__if_simdf8_cast_to_simdf4( d0 ))"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(out+2, stbir__if_simdf8_cast_to_simdf4( p0 ))"
  },
  {
    "label": "stbir__simdf_store2h()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store2h(out+3, stbir__if_simdf8_cast_to_simdf4( d0 ))"
  },
  {
    "label": "stbir__simdf_store2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store2(out+6, stbir__simdf8_gettop4( d0 ))"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(out+8, stbir__simdf8_gettop4( p0 ))"
  },
  {
    "label": "stbir__simdf_store2h()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store2h(out+9, stbir__simdf8_gettop4( d0 ))"
  },
  {
    "label": "stbir__simdf_0123to1133()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_0123to1133(p0, d0)"
  },
  {
    "label": "stbir__simdf_0123to1133()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_0123to1133(p1, d1)"
  },
  {
    "label": "stbir__simdf_0123to0022()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_0123to0022(a0, d0)"
  },
  {
    "label": "stbir__simdf_0123to0022()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_0123to0022(a1, d1)"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(p0, p0, a0)"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(p1, p1, a1)"
  },
  {
    "label": "stbir__simdf_store2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store2(out, d0)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(out+2, p0)"
  },
  {
    "label": "stbir__simdf_store2h()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store2h(out+3, d0)"
  },
  {
    "label": "stbir__simdf_store2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store2(out+6, d1)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(out+8, p1)"
  },
  {
    "label": "stbir__simdf_store2h()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store2h(out+9, d1)"
  },
  {
    "label": "STBIR_SIMD_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (float x = decode [ 0 ],y = decode [ 1 ] ;)",
    "insertText": "STBIR_SIMD_NO_UNROLL(decode)"
  },
  {
    "label": "stbir__fancy_alpha_unweight_4ch()",
    "kind": "Method",
    "detail": "Function (out [ 0 ] = x ; out [ 1 ] = y ; out [ 2 ] = x* y ; out + = 3 ; decode + = 2 ; } } void)",
    "insertText": "stbir__fancy_alpha_unweight_4ch(float * encode_buffer, int width_times_channels)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (float)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(*)"
  },
  {
    "label": "STBIR_SIMD_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (float const* end_output = encode_buffer + width_times_channels ; do { float alpha = input [ 3 ] ; # ifdef STBIR_SIMD stbir__simdf i,ia ;)",
    "insertText": "STBIR_SIMD_NO_UNROLL(encode)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(i, input)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(encode, i)"
  },
  {
    "label": "stbir__simdf_load1frep4()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "stbir__simdf_load1frep4(ia, 1.0f / alpha)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(i, input+4)"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(i, i, ia)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (encode [ 3 ] = alpha ; } # else)",
    "insertText": "if(alpha < stbir__small_float)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (encode [ 0 ] = input [ 0 ] ; encode [ 1 ] = input [ 1 ] ; encode [ 2 ] = input [ 2 ] ; } else { float ialpha = 1 . 0 f / alpha ; encode [ 0 ] = input [ 4 ]* ialpha ; encode [ 1 ] = input [ 5 ]* ialpha ; encode [ 2 ] = input [ 6 ]* ialpha ; } encode [ 3 ] = alpha ; # endif input + = 7 ; encode + = 4 ; })",
    "insertText": "while(encode < end_output)"
  },
  {
    "label": "stbir__fancy_alpha_unweight_2ch()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbir__fancy_alpha_unweight_2ch(float * encode_buffer, int width_times_channels)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float const* end_output = encode_buffer + width_times_channels ; do { float alpha = input [ 1 ] ; encode [ 0 ] = input [ 0 ] ;)",
    "insertText": "if(alpha >= stbir__small_float)"
  },
  {
    "label": "stbir__simple_alpha_weight_4ch()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbir__simple_alpha_weight_4ch(float * decode_buffer, int width_times_channels)"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_load(d0, decode-2*stbir__simdfX_float_count)"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_load(d1, decode-2*stbir__simdfX_float_count+stbir__simdfX_float_count)"
  },
  {
    "label": "stbir__simdfX_aaa1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_aaa1(a0, d0, STBIR_onesX)"
  },
  {
    "label": "stbir__simdfX_aaa1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_aaa1(a1, d1, STBIR_onesX)"
  },
  {
    "label": "stbir__simdfX_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_mult(d0, d0, a0)"
  },
  {
    "label": "stbir__simdfX_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_mult(d1, d1, a1)"
  },
  {
    "label": "stbir__simdfX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_store(decode-2*stbir__simdfX_float_count, d0)"
  },
  {
    "label": "stbir__simdfX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_store(decode-2*stbir__simdfX_float_count+stbir__simdfX_float_count, d1)"
  },
  {
    "label": "stbir__simdf_aaa1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_aaa1(a, d, STBIR__CONSTF(STBIR_ones))"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(d, d, a)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(decode, d)"
  },
  {
    "label": "stbir__simple_alpha_weight_2ch()",
    "kind": "Method",
    "detail": "Function (float alpha = decode [ 3 ] ; decode [ 0 ]* = alpha ; decode [ 1 ]* = alpha ; decode [ 2 ]* = alpha ; decode + = 4 ; } # endif } void)",
    "insertText": "stbir__simple_alpha_weight_2ch(float * decode_buffer, int width_times_channels)"
  },
  {
    "label": "stbir__simdfX_a1a1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_a1a1(a0, d0, STBIR_onesX)"
  },
  {
    "label": "stbir__simdfX_a1a1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_a1a1(a1, d1, STBIR_onesX)"
  },
  {
    "label": "stbir__simple_alpha_unweight_4ch()",
    "kind": "Method",
    "detail": "Function (decode [ 0 ]* = alpha ; decode + = 2 ; } } void)",
    "insertText": "stbir__simple_alpha_unweight_4ch(float * encode_buffer, int width_times_channels)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(i, encode)"
  },
  {
    "label": "stbir__simple_alpha_unweight_2ch()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbir__simple_alpha_unweight_2ch(float * encode_buffer, int width_times_channels)"
  },
  {
    "label": "stbir__simple_flip_3ch()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbir__simple_flip_3ch(float * decode_buffer, int width_times_channels)"
  },
  {
    "label": "stbir__decode_scanline()",
    "kind": "Method",
    "detail": "Function (decode [ 0 ] = decode [ 2 ] ; decode [ 2 ] = t ; decode + = 3 ; } } void)",
    "insertText": "stbir__decode_scanline(stbir__info const * stbir_info, int n, float * output_buffer STBIR_ONLY_PROFILE_GET_SPLIT_INFO)"
  },
  {
    "label": "stbir__edge_wrap()",
    "kind": "Method",
    "detail": "Function (int channels = stbir_info -> channels ; int effective_channels = stbir_info -> effective_channels ; int input_sample_in_bytes = stbir__type_size [ stbir_info -> input_type ]* channels ; stbir_edge edge_horizontal = stbir_info -> horizontal . edge ; stbir_edge edge_vertical = stbir_info -> vertical . edge ; int row =)",
    "insertText": "stbir__edge_wrap(edge_vertical, n, stbir_info->vertical.scale_info.input_full_size)"
  },
  {
    "label": "input_plane_data()",
    "kind": "Method",
    "detail": "Function (input_stride_bytes)",
    "insertText": "input_plane_data((char *) stbir_info->input_data ) + (size_t)row * (size_t)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (stbir__span const* spans = stbir_info -> scanline_extents . spans ; float* full_decode_buffer = output_buffer - stbir_info -> scanline_extents . conservative . n0* effective_channels ;)",
    "insertText": "STBIR_ASSERT(!(edge_vertical == STBIR_EDGE_ZERO && (n < 0 || n >= stbir_info->vertical.scale_info.input_full_size)))"
  },
  {
    "label": "full_decode_buffer()",
    "kind": "Method",
    "detail": "Function (width = spans -> n1 + 1 - spans -> n0 ; decode_buffer = full_decode_buffer + spans -> n0* effective_channels ; end_decode =)",
    "insertText": "full_decode_buffer(spans->n1 + 1)"
  },
  {
    "label": "input_data()",
    "kind": "Method",
    "detail": "Function (pixel_offset_for_input * input_sample_in_bytes)",
    "insertText": "input_data((char*)input_plane_data)"
  },
  {
    "label": "in_pixels_cb()",
    "kind": "Method",
    "detail": "Function (input_data = stbir_info ->)",
    "insertText": "in_pixels_cb(( (char*) end_decode ) - ( width * input_sample_in_bytes ), input_plane_data, width, spans->pixel_offset_for_input, row, stbir_info->user_data)"
  },
  {
    "label": "STBIR_PROFILE_START()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "STBIR_PROFILE_START(decode)"
  },
  {
    "label": "decode_pixels()",
    "kind": "Method",
    "detail": "Function (stbir_info ->)",
    "insertText": "decode_pixels((float*)end_decode - width_times_channels, width_times_channels, input_data)"
  },
  {
    "label": "STBIR_PROFILE_END()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_END(decode)"
  },
  {
    "label": "STBIR_PROFILE_START()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_START(alpha)"
  },
  {
    "label": "alpha_weight()",
    "kind": "Method",
    "detail": "Function (stbir_info ->)",
    "insertText": "alpha_weight(decode_buffer, width_times_channels)"
  },
  {
    "label": "STBIR_PROFILE_END()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_END(alpha)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} + + spans ; })",
    "insertText": "while(spans <= ( &stbir_info->scanline_extents.spans[1] ))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int e,start_x [ 2 ] ; int input_full_size = stbir_info -> horizontal . scale_info . input_full_size ; start_x [ 0 ] = - stbir_info -> scanline_extents . edge_sizes [ 0 ] ; start_x [ 1 ] = input_full_size ;)",
    "insertText": "for(e = 0; e < 2 ; e++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int margin = stbir_info -> scanline_extents . edge_sizes [ e ] ;)",
    "insertText": "if(margin)"
  },
  {
    "label": "stbir__edge_wrap()",
    "kind": "Method",
    "detail": "Function (int x = start_x [ e ] ; float* marg = full_decode_buffer + x* effective_channels ; float const* src = full_decode_buffer +)",
    "insertText": "stbir__edge_wrap(edge_horizontal, x, input_full_size)"
  },
  {
    "label": "STBIR_MEMCPY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MEMCPY(marg, src, margin * effective_channels * sizeof(float))"
  },
  {
    "label": "stbir__1_coeff_only()",
    "kind": "Method",
    "detail": "Function (} } } } # ifdef STBIR_SIMD # define)",
    "insertText": "stbir__1_coeff_only()"
  },
  {
    "label": "stbir__simdf_load1()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load1(c, hc)"
  },
  {
    "label": "stbir__simdf_mult1_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_mult1_mem(tot, c, decode)"
  },
  {
    "label": "stbir__2_coeff_only()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__2_coeff_only()"
  },
  {
    "label": "stbir__simdf_load2z()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load2z(c, hc)"
  },
  {
    "label": "stbir__simdf_load2()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load2(d, decode)"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_mult(tot, c, d)"
  },
  {
    "label": "stbir__simdf_0123to1230()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to1230(c, tot)"
  },
  {
    "label": "stbir__simdf_add1()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_add1(tot, tot, c)"
  },
  {
    "label": "stbir__3_coeff_only()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__3_coeff_only()"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load(c, hc)"
  },
  {
    "label": "stbir__simdf_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_mult_mem(tot, c, decode)"
  },
  {
    "label": "stbir__simdf_0123to2301()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to2301(t, tot)"
  },
  {
    "label": "stbir__simdf_add1()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_add1(tot, tot, t)"
  },
  {
    "label": "stbir__store_output_tiny()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output_tiny() \\ stbir__simdf_store1( output, tot)"
  },
  {
    "label": "stbir__4_coeff_start()",
    "kind": "Method",
    "detail": "Function (\\ horizontal_coefficients + = coefficient_width ; \\ + + horizontal_contributors ; \\ output + = 1 ; # define)",
    "insertText": "stbir__4_coeff_start()"
  },
  {
    "label": "stbir__4_coeff_continue_from_4()",
    "kind": "Method",
    "detail": "Function (\\ # define)",
    "insertText": "stbir__4_coeff_continue_from_4(ofs ) \\ STBIR_SIMD_NO_UNROLL(decode)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load(c, hc + (ofs))"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot, tot, c, decode+(ofs))"
  },
  {
    "label": "stbir__1_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__1_coeff_remnant(ofs)"
  },
  {
    "label": "stbir__simdf_load1z()",
    "kind": "Method",
    "detail": "Function (stbir__simdf d ; \\)",
    "insertText": "stbir__simdf_load1z(c, hc + (ofs))"
  },
  {
    "label": "stbir__simdf_load1()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load1(d, decode + (ofs))"
  },
  {
    "label": "stbir__simdf_madd()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd(tot, tot, d, c)"
  },
  {
    "label": "stbir__2_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "stbir__2_coeff_remnant(ofs)"
  },
  {
    "label": "stbir__simdf_load2z()",
    "kind": "Method",
    "detail": "Function (stbir__simdf d ; \\)",
    "insertText": "stbir__simdf_load2z(c, hc+(ofs))"
  },
  {
    "label": "stbir__simdf_load2()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load2(d, decode+(ofs))"
  },
  {
    "label": "stbir__3_coeff_setup()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "stbir__3_coeff_setup()"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load(mask, STBIR_mask + 3)"
  },
  {
    "label": "stbir__3_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__3_coeff_remnant(ofs ) \\ stbir__simdf_load( c, hc+(ofs))"
  },
  {
    "label": "stbir__simdf_and()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_and(c, c, mask)"
  },
  {
    "label": "stbir__store_output()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output() \\ stbir__simdf_0123to2301( c, tot)"
  },
  {
    "label": "stbir__simdf_add()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_add(tot, tot, c)"
  },
  {
    "label": "stbir__simdf_store1()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store1(output, tot)"
  },
  {
    "label": "stbir__store_output_tiny()",
    "kind": "Method",
    "detail": "Function (\\ tot = decode [ 0 ]* hc [ 0 ] ; \\ tot + = decode [ 1 ]* hc [ 1 ] ; \\ tot + = decode [ 2 ]* hc [ 2 ] ; # define)",
    "insertText": "stbir__store_output_tiny()"
  },
  {
    "label": "stbir__4_coeff_continue_from_4()",
    "kind": "Method",
    "detail": "Function (\\ tot0 = decode [ 0 ]* hc [ 0 ] ; \\ tot1 = decode [ 1 ]* hc [ 1 ] ; \\ tot2 = decode [ 2 ]* hc [ 2 ] ; \\ tot3 = decode [ 3 ]* hc [ 3 ] ; # define)",
    "insertText": "stbir__4_coeff_continue_from_4(ofs ) \\ tot0 += decode[0+(ofs)] * hc[0+(ofs)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (\\ tot1 + =)",
    "insertText": "decode(ofs)] * hc[1+(ofs)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (\\ tot2 + =)",
    "insertText": "decode(ofs)] * hc[2+(ofs)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (\\ tot3 + =)",
    "insertText": "decode(ofs)] * hc[3+(ofs)"
  },
  {
    "label": "stbir__1_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__1_coeff_remnant(ofs ) \\ tot0 += decode[0+(ofs)] * hc[0+(ofs)"
  },
  {
    "label": "stbir__2_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__2_coeff_remnant(ofs ) \\ tot0 += decode[0+(ofs)] * hc[0+(ofs)"
  },
  {
    "label": "stbir__3_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (\\ # define)",
    "insertText": "stbir__3_coeff_remnant(ofs ) \\ tot0 += decode[0+(ofs)] * hc[0+(ofs)"
  },
  {
    "label": "stbir__store_output()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output() \\ output[0] = (tot0+tot2)+(tot1+tot3)"
  },
  {
    "label": "stbir__simdf_load1z()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load1z(c, hc)"
  },
  {
    "label": "stbir__simdf_0123to0011()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to0011(c, c)"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_mult(tot, d, c)"
  },
  {
    "label": "stbir__simdf_load2()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load2(c, hc)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load(cs, hc)"
  },
  {
    "label": "stbir__simdf_0123to0011()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to0011(c, cs)"
  },
  {
    "label": "stbir__simdf_0123to2222()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to2222(c, cs)"
  },
  {
    "label": "stbir__simdf_load2z()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load2z(d, decode+4)"
  },
  {
    "label": "stbir__store_output_tiny()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output_tiny() \\ stbir__simdf_0123to2301( c, tot)"
  },
  {
    "label": "stbir__simdf_store2()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store2(output, tot)"
  },
  {
    "label": "stbir__simdf8_load4b()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_load4b(cs, hc)"
  },
  {
    "label": "stbir__simdf8_0123to00112233()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_0123to00112233(c, cs)"
  },
  {
    "label": "stbir__simdf8_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_mult_mem(tot0, c, decode)"
  },
  {
    "label": "stbir__simdf8_load4b()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_load4b(cs, hc + (ofs))"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot0, tot0, c, decode+(ofs)*2)"
  },
  {
    "label": "stbir__simdf_load1z()",
    "kind": "Method",
    "detail": "Function (stbir__simdf t ; \\)",
    "insertText": "stbir__simdf_load1z(t, hc + (ofs))"
  },
  {
    "label": "stbir__simdf_0123to0011()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to0011(t, t)"
  },
  {
    "label": "stbir__simdf_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_mult_mem(t, t, decode+(ofs)*2)"
  },
  {
    "label": "stbir__simdf8_add4()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_add4(tot0, tot0, t)"
  },
  {
    "label": "stbir__simdf_load2()",
    "kind": "Method",
    "detail": "Function (stbir__simdf t ; \\)",
    "insertText": "stbir__simdf_load2(t, hc + (ofs))"
  },
  {
    "label": "stbir__3_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "stbir__3_coeff_remnant(ofs)"
  },
  {
    "label": "stbir__simdf8_load6z()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_load6z(d, decode+(ofs)*2)"
  },
  {
    "label": "stbir__simdf8_madd()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd(tot0, tot0, c, d)"
  },
  {
    "label": "stbir__store_output()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "stbir__store_output()"
  },
  {
    "label": "stbir__simdf8_add4halves()",
    "kind": "Method",
    "detail": "Function (stbir__simdf t,d ; \\)",
    "insertText": "stbir__simdf8_add4halves(t, stbir__if_simdf8_cast_to_simdf4(tot0), tot0)"
  },
  {
    "label": "stbir__simdf_0123to2301()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to2301(d, t)"
  },
  {
    "label": "stbir__simdf_add()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_add(t, t, d)"
  },
  {
    "label": "stbir__simdf_store2()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store2(output, t)"
  },
  {
    "label": "stbir__simdf_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_mult_mem(tot0, c, decode)"
  },
  {
    "label": "stbir__simdf_0123to2233()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to2233(c, cs)"
  },
  {
    "label": "stbir__simdf_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_mult_mem(tot1, c, decode+4)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load(cs, hc + (ofs))"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot0, tot0, c, decode+(ofs)*2)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot1, tot1, c, decode+(ofs)*2+4)"
  },
  {
    "label": "stbir__simdf_load1z()",
    "kind": "Method",
    "detail": "Function (stbir__simdf d ; \\)",
    "insertText": "stbir__simdf_load1z(cs, hc + (ofs))"
  },
  {
    "label": "stbir__simdf_load2()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load2(d, decode + (ofs) * 2)"
  },
  {
    "label": "stbir__simdf_madd()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd(tot0, tot0, d, c)"
  },
  {
    "label": "stbir__2_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "stbir__2_coeff_remnant(ofs ) \\ stbir__simdf_load2( cs, hc + (ofs))"
  },
  {
    "label": "stbir__simdf_load2z()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load2z(d, decode + (ofs) * 2 + 4)"
  },
  {
    "label": "stbir__simdf_madd()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd(tot1, tot1, d, c)"
  },
  {
    "label": "stbir__store_output()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "stbir__store_output() \\ stbir__simdf_add( tot0, tot0, tot1)"
  },
  {
    "label": "stbir__simdf_0123to2301()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to2301(c, tot0)"
  },
  {
    "label": "stbir__simdf_add()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_add(tot0, tot0, c)"
  },
  {
    "label": "stbir__simdf_store2()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store2(output, tot0)"
  },
  {
    "label": "stbir__4_coeff_continue_from_4()",
    "kind": "Method",
    "detail": "Function (\\ c = hc [ 0 ] ; \\ tota0 = decode [ 0 ]* c ; \\ totb0 = decode [ 1 ]* c ; \\ c = hc [ 1 ] ; \\ tota1 = decode [ 2 ]* c ; \\ totb1 = decode [ 3 ]* c ; \\ c = hc [ 2 ] ; \\ tota2 = decode [ 4 ]* c ; \\ totb2 = decode [ 5 ]* c ; \\ c = hc [ 3 ] ; \\ tota3 = decode [ 6 ]* c ; \\ totb3 = decode [ 7 ]* c ; # define)",
    "insertText": "stbir__4_coeff_continue_from_4(ofs ) \\ c = hc[0+(ofs)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (\\ tota0 + =)",
    "insertText": "decode(ofs)"
  },
  {
    "label": "hc()",
    "kind": "Method",
    "detail": "Function (\\ c =)",
    "insertText": "hc(ofs)"
  },
  {
    "label": "stbir__1_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__1_coeff_remnant(ofs ) \\ c = hc[0+(ofs)"
  },
  {
    "label": "stbir__2_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__2_coeff_remnant(ofs ) \\ c = hc[0+(ofs)"
  },
  {
    "label": "stbir__3_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__3_coeff_remnant(ofs ) \\ c = hc[0+(ofs)"
  },
  {
    "label": "stbir__store_output()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output() \\ output[0] = (tota0+tota2)+(tota1+tota3)"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "output(totb0+totb2)+(totb1+totb3)"
  },
  {
    "label": "stbir__simdf_0123to0001()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to0001(c, c)"
  },
  {
    "label": "stbir__simdf_load2()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load2(cs, hc)"
  },
  {
    "label": "stbir__simdf_0123to0000()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to0000(c, cs)"
  },
  {
    "label": "stbir__simdf_0123to1111()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to1111(c, cs)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load(d, decode+3)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load(d, decode+6)"
  },
  {
    "label": "stbir__store_output_tiny()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output_tiny() \\ stbir__simdf_store2( output, tot)"
  },
  {
    "label": "stbir__simdf_0123to2301()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to2301(tot, tot)"
  },
  {
    "label": "stbir__simdf_store1()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store1(output+2, tot)"
  },
  {
    "label": "stbir__simdf8_0123to00001111()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_0123to00001111(c, cs)"
  },
  {
    "label": "stbir__simdf8_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_mult_mem(tot0, c, decode - 1)"
  },
  {
    "label": "stbir__simdf8_0123to22223333()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_0123to22223333(c, cs)"
  },
  {
    "label": "stbir__simdf8_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_mult_mem(tot1, c, decode+6 - 1)"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot0, tot0, c, decode+(ofs)*3 - 1)"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot1, tot1, c, decode+(ofs)*3 + 6 - 1)"
  },
  {
    "label": "stbir__1_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__1_coeff_remnant(ofs ) \\ STBIR_SIMD_NO_UNROLL(decode)"
  },
  {
    "label": "stbir__simdf_load1rep4()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load1rep4(t, hc + (ofs))"
  },
  {
    "label": "stbir__simdf8_madd_mem4()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem4(tot0, tot0, t, decode+(ofs)*3 - 1)"
  },
  {
    "label": "stbir__2_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__2_coeff_remnant(ofs ) \\ STBIR_SIMD_NO_UNROLL(decode)"
  },
  {
    "label": "stbir__simdf8_load4b()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_load4b(cs, hc + (ofs) - 2)"
  },
  {
    "label": "stbir__3_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__3_coeff_remnant(ofs ) \\ STBIR_SIMD_NO_UNROLL(decode)"
  },
  {
    "label": "stbir__simdf8_0123to2222()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_0123to2222(t, cs)"
  },
  {
    "label": "stbir__simdf8_madd_mem4()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem4(tot1, tot1, t, decode+(ofs)*3 + 6 - 1)"
  },
  {
    "label": "stbir__store_output()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output() \\ stbir__simdf8_add( tot0, tot0, tot1)"
  },
  {
    "label": "stbir__simdf_0123to1230()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to1230(t, stbir__if_simdf8_cast_to_simdf4( tot0 ))"
  },
  {
    "label": "stbir__simdf8_add4halves()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_add4halves(t, t, tot0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (\\ horizontal_coefficients + = coefficient_width ; \\ + + horizontal_contributors ; \\ output + = 3 ; \\)",
    "insertText": "if(output < output_end)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store(output-3, t)"
  },
  {
    "label": "stbir__simdf_0123to2301()",
    "kind": "Method",
    "detail": "Function (\\ continue ; \\ } \\ { stbir__simdf tt ;)",
    "insertText": "stbir__simdf_0123to2301(tt, t)"
  },
  {
    "label": "stbir__simdf_store2()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store2(output-3, t)"
  },
  {
    "label": "stbir__simdf_store1()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store1(output+2-3, tt)"
  },
  {
    "label": "stbir__simdf_0123to0001()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to0001(c, cs)"
  },
  {
    "label": "stbir__simdf_0123to1122()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to1122(c, cs)"
  },
  {
    "label": "stbir__simdf_0123to2333()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to2333(c, cs)"
  },
  {
    "label": "stbir__simdf_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_mult_mem(tot2, c, decode+8)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot0, tot0, c, decode+(ofs)*3)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot1, tot1, c, decode+(ofs)*3+4)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot2, tot2, c, decode+(ofs)*3+8)"
  },
  {
    "label": "stbir__simdf_load2z()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load2z(cs, hc + (ofs))"
  },
  {
    "label": "stbir__simdf_load2z()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load2z(d, decode+(ofs)*3+4)"
  },
  {
    "label": "stbir__simdf_madd()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd(tot1, tot1, c, d)"
  },
  {
    "label": "stbir__simdf_load1z()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load1z(d, decode+(ofs)*3+8)"
  },
  {
    "label": "stbir__simdf_madd()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd(tot2, tot2, c, d)"
  },
  {
    "label": "stbir__store_output()",
    "kind": "Method",
    "detail": "Function (} # define)",
    "insertText": "stbir__store_output() \\ stbir__simdf_0123ABCDto3ABx( c, tot0, tot1)"
  },
  {
    "label": "stbir__simdf_0123ABCDto23Ax()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123ABCDto23Ax(cs, tot1, tot2)"
  },
  {
    "label": "stbir__simdf_0123to1230()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to1230(tot2, tot2)"
  },
  {
    "label": "stbir__simdf_add()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_add(tot0, tot0, cs)"
  },
  {
    "label": "stbir__simdf_add()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_add(c, c, tot2)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store(output-3, tot0)"
  },
  {
    "label": "stbir__simdf_0123to2301()",
    "kind": "Method",
    "detail": "Function (\\ continue ; \\ } \\)",
    "insertText": "stbir__simdf_0123to2301(tot1, tot0)"
  },
  {
    "label": "stbir__simdf_store2()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store2(output-3, tot0)"
  },
  {
    "label": "stbir__simdf_store1()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store1(output+2-3, tot1)"
  },
  {
    "label": "stbir__store_output()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output() \\ output[0] = (tota0+totc0)+(totb0+totd0)"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "output(tota1+totc1)+(totb1+totd1)"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "output(tota2+totc2)+(totb2+totd2)"
  },
  {
    "label": "stbir__simdf_0123to0000()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to0000(c, c)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot, tot, c, decode+4)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot, tot, c, decode+8)"
  },
  {
    "label": "stbir__store_output_tiny()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output_tiny() \\ stbir__simdf_store( output, tot)"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot0, tot0, c, decode+8)"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot0, tot0, c, decode+(ofs)*4)"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot0, tot0, c, decode+(ofs)*4+8)"
  },
  {
    "label": "stbir__simdf8_madd_mem4()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem4(tot0, tot0, t, decode+(ofs)*4)"
  },
  {
    "label": "stbir__simdf8_madd_mem4()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem4(tot0, tot0, t, decode+(ofs)*4+8)"
  },
  {
    "label": "stbir__store_output()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output() \\ stbir__simdf8_add4halves( t, stbir__if_simdf8_cast_to_simdf4(tot0), tot0)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store(output, t)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot0, tot0, c, decode+8)"
  },
  {
    "label": "stbir__simdf_0123to3333()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_0123to3333(c, cs)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot1, tot1, c, decode+12)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot0, tot0, c, decode+(ofs)*4)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot1, tot1, c, decode+(ofs)*4+4)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot0, tot0, c, decode+(ofs)*4+8)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot1, tot1, c, decode+(ofs)*4+12)"
  },
  {
    "label": "stbir__simdf_load1()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load1(c, hc + (ofs))"
  },
  {
    "label": "stbir__simdf_load2()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_load2(cs, hc + (ofs))"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store(output, tot0)"
  },
  {
    "label": "stbir__simdf_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_mult_mem(tot1, c, decode+3)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot0, tot0, c, decode+7)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot1, tot1, c,decode+10)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot1, tot1, c, decode+10)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot0, tot0, c, decode+14)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot1, tot1, c, decode+17)"
  },
  {
    "label": "stbir__store_output_tiny()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output_tiny() \\ stbir__simdf_store( output+3, tot1)"
  },
  {
    "label": "stbir__simdf8_0123to00000000()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_0123to00000000(c, cs)"
  },
  {
    "label": "stbir__simdf8_0123to11111111()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_0123to11111111(c, cs)"
  },
  {
    "label": "stbir__simdf8_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_mult_mem(tot1, c, decode+7)"
  },
  {
    "label": "stbir__simdf8_0123to22222222()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_0123to22222222(c, cs)"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot0, tot0, c, decode+14)"
  },
  {
    "label": "stbir__simdf8_0123to33333333()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_0123to33333333(c, cs)"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot1, tot1, c, decode+21)"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot0, tot0, c, decode+(ofs)*7)"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot1, tot1, c, decode+(ofs)*7+7)"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot0, tot0, c, decode+(ofs)*7+14)"
  },
  {
    "label": "stbir__simdf8_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_madd_mem(tot1, tot1, c, decode+(ofs)*7+21)"
  },
  {
    "label": "stbir__simdf8_load1b()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_load1b(c, hc + (ofs))"
  },
  {
    "label": "stbir__simdf8_load1b()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_load1b(c, hc + (ofs)+1)"
  },
  {
    "label": "stbir__simdf8_store()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf8_store(output-7, tot0)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (\\ continue ; \\ } \\)",
    "insertText": "stbir__simdf_store(output-7+3, stbir__simdf_swiz(stbir__simdf8_gettop4(tot0),0,0,1,2))"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store(output-7, stbir__if_simdf8_cast_to_simdf4(tot0))"
  },
  {
    "label": "stbir__simdf_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_mult_mem(tot2, c, decode+7)"
  },
  {
    "label": "stbir__simdf_mult_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_mult_mem(tot3, c, decode+10)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot2, tot2, c, decode+21)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot3, tot3, c, decode+24)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot0, tot0, c, decode+(ofs)*7)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot1, tot1, c, decode+(ofs)*7+3)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot2, tot2, c, decode+(ofs)*7+7)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot3, tot3, c, decode+(ofs)*7+10)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot0, tot0, c, decode+(ofs)*7+14)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot1, tot1, c, decode+(ofs)*7+17)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot2, tot2, c, decode+(ofs)*7+21)"
  },
  {
    "label": "stbir__simdf_madd_mem()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_madd_mem(tot3, tot3, c, decode+(ofs)*7+24)"
  },
  {
    "label": "stbir__store_output()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__store_output() \\ stbir__simdf_add( tot0, tot0, tot2)"
  },
  {
    "label": "stbir__simdf_add()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_add(tot1, tot1, tot3)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_store(output+3, tot1)"
  },
  {
    "label": "STBIR_VERTICAL_GATHERFUNC()",
    "kind": "Method",
    "detail": "Function (\\ output [ 1 ] = x1 + y1 ; \\ output [ 2 ] = x2 + y2 ; \\ output [ 3 ] = x3 + y3 ; \\ output [ 4 ] = x4 + y4 ; \\ output [ 5 ] = x5 + y5 ; \\ output [ 6 ] = x6 + y6 ; \\ horizontal_coefficients + = coefficient_width ; \\ + + horizontal_contributors ; \\ output + = 7 ; # endif # define STBIR__horizontal_channels 7 # define STB_IMAGE_RESIZE_DO_HORIZONTALS # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 1 # define STB_IMAGE_RESIZE_DO_VERTICALS # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 1 # define STB_IMAGE_RESIZE_DO_VERTICALS # define STB_IMAGE_RESIZE_VERTICAL_CONTINUE # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 2 # define STB_IMAGE_RESIZE_DO_VERTICALS # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 2 # define STB_IMAGE_RESIZE_DO_VERTICALS # define STB_IMAGE_RESIZE_VERTICAL_CONTINUE # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 3 # define STB_IMAGE_RESIZE_DO_VERTICALS # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 3 # define STB_IMAGE_RESIZE_DO_VERTICALS # define STB_IMAGE_RESIZE_VERTICAL_CONTINUE # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 4 # define STB_IMAGE_RESIZE_DO_VERTICALS # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 4 # define STB_IMAGE_RESIZE_DO_VERTICALS # define STB_IMAGE_RESIZE_VERTICAL_CONTINUE # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 5 # define STB_IMAGE_RESIZE_DO_VERTICALS # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 5 # define STB_IMAGE_RESIZE_DO_VERTICALS # define STB_IMAGE_RESIZE_VERTICAL_CONTINUE # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 6 # define STB_IMAGE_RESIZE_DO_VERTICALS # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 6 # define STB_IMAGE_RESIZE_DO_VERTICALS # define STB_IMAGE_RESIZE_VERTICAL_CONTINUE # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 7 # define STB_IMAGE_RESIZE_DO_VERTICALS # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 7 # define STB_IMAGE_RESIZE_DO_VERTICALS # define STB_IMAGE_RESIZE_VERTICAL_CONTINUE # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 8 # define STB_IMAGE_RESIZE_DO_VERTICALS # include STBIR__HEADER_FILENAME # define STBIR__vertical_channels 8 # define STB_IMAGE_RESIZE_DO_VERTICALS # define STB_IMAGE_RESIZE_VERTICAL_CONTINUE # include STBIR__HEADER_FILENAME typedef void)",
    "insertText": "STBIR_VERTICAL_GATHERFUNC(float * output, float const * coeffs, float const ** inputs, float const * input0_end)"
  },
  {
    "label": "STBIR_VERTICAL_SCATTERFUNC()",
    "kind": "Method",
    "detail": "Function (STBIR_VERTICAL_GATHERFUNC* stbir__vertical_gathers [ 8 ] = { stbir__vertical_gather_with_1_coeffs,stbir__vertical_gather_with_2_coeffs,stbir__vertical_gather_with_3_coeffs,stbir__vertical_gather_with_4_coeffs,stbir__vertical_gather_with_5_coeffs,stbir__vertical_gather_with_6_coeffs,stbir__vertical_gather_with_7_coeffs,stbir__vertical_gather_with_8_coeffs } ; STBIR_VERTICAL_GATHERFUNC* stbir__vertical_gathers_continues [ 8 ] = { stbir__vertical_gather_with_1_coeffs_cont,stbir__vertical_gather_with_2_coeffs_cont,stbir__vertical_gather_with_3_coeffs_cont,stbir__vertical_gather_with_4_coeffs_cont,stbir__vertical_gather_with_5_coeffs_cont,stbir__vertical_gather_with_6_coeffs_cont,stbir__vertical_gather_with_7_coeffs_cont,stbir__vertical_gather_with_8_coeffs_cont } ; typedef void)",
    "insertText": "STBIR_VERTICAL_SCATTERFUNC(float ** outputs, float const * coeffs, float const * input, float const * input_end)"
  },
  {
    "label": "stbir__encode_scanline()",
    "kind": "Method",
    "detail": "Function (STBIR_VERTICAL_SCATTERFUNC* stbir__vertical_scatter_sets [ 8 ] = { stbir__vertical_scatter_with_1_coeffs,stbir__vertical_scatter_with_2_coeffs,stbir__vertical_scatter_with_3_coeffs,stbir__vertical_scatter_with_4_coeffs,stbir__vertical_scatter_with_5_coeffs,stbir__vertical_scatter_with_6_coeffs,stbir__vertical_scatter_with_7_coeffs,stbir__vertical_scatter_with_8_coeffs } ; STBIR_VERTICAL_SCATTERFUNC* stbir__vertical_scatter_blends [ 8 ] = { stbir__vertical_scatter_with_1_coeffs_cont,stbir__vertical_scatter_with_2_coeffs_cont,stbir__vertical_scatter_with_3_coeffs_cont,stbir__vertical_scatter_with_4_coeffs_cont,stbir__vertical_scatter_with_5_coeffs_cont,stbir__vertical_scatter_with_6_coeffs_cont,stbir__vertical_scatter_with_7_coeffs_cont,stbir__vertical_scatter_with_8_coeffs_cont } ; void)",
    "insertText": "stbir__encode_scanline(stbir__info const * stbir_info, void *output_buffer_data, float * encode_buffer, int row STBIR_ONLY_PROFILE_GET_SPLIT_INFO)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int num_pixels = stbir_info -> horizontal . scale_info . output_sub_size ; int channels = stbir_info -> channels ; int width_times_channels = num_pixels* channels ; void* output_buffer ;)",
    "insertText": "if(stbir_info->alpha_unweight)"
  },
  {
    "label": "STBIR_PROFILE_START()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_START(unalpha)"
  },
  {
    "label": "alpha_unweight()",
    "kind": "Method",
    "detail": "Function (stbir_info ->)",
    "insertText": "alpha_unweight(encode_buffer, width_times_channels)"
  },
  {
    "label": "STBIR_PROFILE_END()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_END(unalpha)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} output_buffer = output_buffer_data ;)",
    "insertText": "if(stbir_info->out_pixels_cb)"
  },
  {
    "label": "STBIR_PROFILE_START()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_START(encode)"
  },
  {
    "label": "encode_pixels()",
    "kind": "Method",
    "detail": "Function (stbir_info ->)",
    "insertText": "encode_pixels(output_buffer, width_times_channels, encode_buffer)"
  },
  {
    "label": "STBIR_PROFILE_END()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_END(encode)"
  },
  {
    "label": "stbir__get_ring_buffer_entry()",
    "kind": "Method",
    "detail": "Function (} float*)",
    "insertText": "stbir__get_ring_buffer_entry(stbir__info const * stbir_info, stbir__per_split_info const * split_info, int index)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(index < stbir_info->ring_buffer_num_entries)"
  },
  {
    "label": "return()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIR__SEPARATE_ALLOCATIONS return split_info -> ring_buffers [ index ] ; # else)",
    "insertText": "return(float*) ( ( (char*) split_info->ring_buffer ) + ( index * stbir_info->ring_buffer_length_bytes ))"
  },
  {
    "label": "stbir__get_ring_buffer_scanline()",
    "kind": "Method",
    "detail": "Function (# endif } float*)",
    "insertText": "stbir__get_ring_buffer_scanline(stbir__info const * stbir_info, stbir__per_split_info const * split_info, int get_scanline)"
  },
  {
    "label": "ring_buffer_index()",
    "kind": "Method",
    "detail": "Function (ring_buffer_num_entries)",
    "insertText": "ring_buffer_index(split_info->ring_buffer_begin_index + (get_scanline - split_info->ring_buffer_first_scanline))"
  },
  {
    "label": "stbir__resample_horizontal_gather()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbir__resample_horizontal_gather(stbir__info const * stbir_info, float* output_buffer, float const * input_buffer STBIR_ONLY_PROFILE_GET_SPLIT_INFO)"
  },
  {
    "label": "input_buffer()",
    "kind": "Method",
    "detail": "Function (float const* decode_buffer =)",
    "insertText": "input_buffer(stbir_info->scanline_extents.conservative.n0 * stbir_info->effective_channels)"
  },
  {
    "label": "STBIR_PROFILE_START()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_START(horizontal)"
  },
  {
    "label": "STBIR_PROFILE_END()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_END(horizontal)"
  },
  {
    "label": "stbir__resample_vertical_gather()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbir__resample_vertical_gather(stbir__info const * stbir_info, stbir__per_split_info* split_info, int n, int contrib_n0, int contrib_n1, float const * vertical_coefficients)"
  },
  {
    "label": "width()",
    "kind": "Method",
    "detail": "Function (horizontal.scale_info.output_sub_size)",
    "insertText": "width(vertical_first) ? ( stbir_info->scanline_extents.conservative.n1-stbir_info->scanline_extents.conservative.n0+1)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (int width_times_channels = stbir_info -> effective_channels* width ;)",
    "insertText": "STBIR_ASSERT(stbir_info->vertical.is_gather)"
  },
  {
    "label": "STBIR_PROFILE_START()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_START(vertical)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function ({ int k = 0,total = contrib_n1 - contrib_n0 + 1 ;)",
    "insertText": "STBIR_ASSERT(total > 0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (k + = cnt ; total - = cnt ; })",
    "insertText": "while(total)"
  },
  {
    "label": "STBIR_PROFILE_END()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "STBIR_PROFILE_END(vertical)"
  },
  {
    "label": "stbir__resample_horizontal_gather()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__resample_horizontal_gather(stbir_info, encode_buffer, decode_buffer STBIR_ONLY_PROFILE_SET_SPLIT_INFO)"
  },
  {
    "label": "stbir__encode_scanline()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "stbir__encode_scanline(stbir_info, ( (char *) stbir_info->output_data ) + ((size_t)n * (size_t)stbir_info->output_stride_bytes), encode_buffer, n STBIR_ONLY_PROFILE_SET_SPLIT_INFO)"
  },
  {
    "label": "stbir__decode_and_resample_for_vertical_gather_loop()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbir__decode_and_resample_for_vertical_gather_loop(stbir__info const * stbir_info, stbir__per_split_info* split_info, int n)"
  },
  {
    "label": "stbir__decode_scanline()",
    "kind": "Method",
    "detail": "Function (int ring_buffer_index ; float* ring_buffer ;)",
    "insertText": "stbir__decode_scanline(stbir_info, n, split_info->decode_buffer STBIR_ONLY_PROFILE_SET_SPLIT_INFO)"
  },
  {
    "label": "ring_buffer_index()",
    "kind": "Method",
    "detail": "Function (ring_buffer_num_entries)",
    "insertText": "ring_buffer_index(split_info->ring_buffer_begin_index + (split_info->ring_buffer_last_scanline - split_info->ring_buffer_first_scanline))"
  },
  {
    "label": "stbir__get_ring_buffer_entry()",
    "kind": "Method",
    "detail": "Function (ring_buffer =)",
    "insertText": "stbir__get_ring_buffer_entry(stbir_info, split_info, ring_buffer_index)"
  },
  {
    "label": "stbir__resample_horizontal_gather()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__resample_horizontal_gather(stbir_info, ring_buffer, split_info->decode_buffer STBIR_ONLY_PROFILE_SET_SPLIT_INFO)"
  },
  {
    "label": "stbir__vertical_gather_loop()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbir__vertical_gather_loop(stbir__info const * stbir_info, stbir__per_split_info* split_info, int split_count)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (start_output_y = split_info -> start_output_y ; end_output_y = split_info [ split_count - 1 ] . end_output_y ; vertical_contributors + = start_output_y ; vertical_coefficients + = start_output_y* stbir_info -> vertical . coefficient_width ; split_info -> ring_buffer_begin_index = 0 ; split_info -> ring_buffer_first_scanline = vertical_contributors -> n0 ; split_info -> ring_buffer_last_scanline = split_info -> ring_buffer_first_scanline - 1 ;)",
    "insertText": "for(y = start_output_y; y < end_output_y; y++)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (int in_first_scanline,in_last_scanline ; in_first_scanline = vertical_contributors -> n0 ; in_last_scanline = vertical_contributors -> n1 ;)",
    "insertText": "STBIR_ASSERT(in_first_scanline >= split_info->ring_buffer_first_scanline)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(( split_info->ring_buffer_last_scanline - split_info->ring_buffer_first_scanline + 1 ) <= stbir_info->ring_buffer_num_entries)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (split_info -> ring_buffer_first_scanline + + ; split_info -> ring_buffer_begin_index + + ; })",
    "insertText": "if(stbir_info->vertical_first)"
  },
  {
    "label": "stbir__get_ring_buffer_scanline()",
    "kind": "Method",
    "detail": "Function (float* ring_buffer =)",
    "insertText": "stbir__get_ring_buffer_scanline(stbir_info, split_info, ++split_info->ring_buffer_last_scanline)"
  },
  {
    "label": "stbir__decode_scanline()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__decode_scanline(stbir_info, split_info->ring_buffer_last_scanline, ring_buffer STBIR_ONLY_PROFILE_SET_SPLIT_INFO)"
  },
  {
    "label": "stbir__decode_and_resample_for_vertical_gather_loop()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "stbir__decode_and_resample_for_vertical_gather_loop(stbir_info, split_info, split_info->ring_buffer_last_scanline + 1)"
  },
  {
    "label": "stbir__resample_vertical_gather()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "stbir__resample_vertical_gather(stbir_info, split_info, y, in_first_scanline, in_last_scanline, vertical_coefficients)"
  },
  {
    "label": "STBIR__FLOAT_BUFFER_IS_EMPTY()",
    "kind": "Method",
    "detail": "Function (+ + vertical_contributors ; vertical_coefficients + = stbir_info -> vertical . coefficient_width ; } } # define STBIR__FLOAT_EMPTY_MARKER 3 . 0 e + 3 8 F # define)",
    "insertText": "STBIR__FLOAT_BUFFER_IS_EMPTY(ptr) ((ptr)[0]==STBIR__FLOAT_EMPTY_MARKER) static void stbir__encode_first_scanline_from_scatter(stbir__info const * stbir_info, stbir__per_split_info* split_info)"
  },
  {
    "label": "stbir__get_ring_buffer_entry()",
    "kind": "Method",
    "detail": "Function (float* ring_buffer_entry =)",
    "insertText": "stbir__get_ring_buffer_entry(stbir_info, split_info, split_info->ring_buffer_begin_index)"
  },
  {
    "label": "stbir__encode_scanline()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__encode_scanline(stbir_info, ( (char *)stbir_info->output_data ) + ( (size_t)split_info->ring_buffer_first_scanline * (size_t)stbir_info->output_stride_bytes ), ring_buffer_entry, split_info->ring_buffer_first_scanline STBIR_ONLY_PROFILE_SET_SPLIT_INFO)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ring_buffer_begin_index = 0)",
    "insertText": "if(++split_info->ring_buffer_begin_index == stbir_info->ring_buffer_num_entries)"
  },
  {
    "label": "stbir__horizontal_resample_and_encode_first_scanline_from_scatter()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbir__horizontal_resample_and_encode_first_scanline_from_scatter(stbir__info const * stbir_info, stbir__per_split_info* split_info)"
  },
  {
    "label": "stbir__resample_horizontal_gather()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__resample_horizontal_gather(stbir_info, split_info->vertical_buffer, ring_buffer_entry STBIR_ONLY_PROFILE_SET_SPLIT_INFO)"
  },
  {
    "label": "stbir__encode_scanline()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__encode_scanline(stbir_info, ( (char *)stbir_info->output_data ) + ( (size_t)split_info->ring_buffer_first_scanline * (size_t)stbir_info->output_stride_bytes ), split_info->vertical_buffer, split_info->ring_buffer_first_scanline STBIR_ONLY_PROFILE_SET_SPLIT_INFO)"
  },
  {
    "label": "stbir__resample_vertical_scatter()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "stbir__resample_vertical_scatter(stbir__info const * stbir_info, stbir__per_split_info* split_info, int n0, int n1, float const * vertical_coefficients, float const * vertical_buffer, float const * vertical_buffer_end)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(!stbir_info->vertical.is_gather)"
  },
  {
    "label": "stbir__get_ring_buffer_scanline()",
    "kind": "Method",
    "detail": "Function (outputs [ i ] =)",
    "insertText": "stbir__get_ring_buffer_scanline(stbir_info, split_info, k+i+n0)"
  },
  {
    "label": "break()",
    "kind": "Method",
    "detail": "Function (n = i ;)",
    "insertText": "break((STBIR__FLOAT_BUFFER_IS_EMPTY( outputs[0] ))?stbir__vertical_scatter_sets:stbir__vertical_scatter_blends)[n-1]( outputs, vertical_coefficients + k, vertical_buffer, vertical_buffer_end)"
  },
  {
    "label": "stbir__handle_scanline_for_scatter_func()",
    "kind": "Method",
    "detail": "Function (} typedef void)",
    "insertText": "stbir__handle_scanline_for_scatter_func(stbir__info const * stbir_info, stbir__per_split_info* split_info)"
  },
  {
    "label": "stbir__vertical_scatter_loop()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__vertical_scatter_loop(stbir__info const * stbir_info, stbir__per_split_info* split_info, int split_count)"
  },
  {
    "label": "scanline_scatter_buffer_end()",
    "kind": "Method",
    "detail": "Function (handle_scanline_for_scatter = stbir__horizontal_resample_and_encode_first_scanline_from_scatter ; scanline_scatter_buffer = split_info -> decode_buffer ;)",
    "insertText": "scanline_scatter_buffer_end((char*) scanline_scatter_buffer ) + sizeof( float ) * stbir_info->effective_channels * (stbir_info->scanline_extents.conservative.n1-stbir_info->scanline_extents.conservative.n0+1)"
  },
  {
    "label": "scanline_scatter_buffer_end()",
    "kind": "Method",
    "detail": "Function (effective_channels * stbir_info->horizontal.scale_info.output_sub_size)",
    "insertText": "scanline_scatter_buffer_end((char*) scanline_scatter_buffer ) + sizeof( float)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (} split_info -> ring_buffer_first_scanline = start_output_y ; split_info -> ring_buffer_last_scanline = - 1 ; split_info -> ring_buffer_begin_index = - 1 ;)",
    "insertText": "for(y = 0 ; y < stbir_info->ring_buffer_num_entries ; y++ ) stbir__get_ring_buffer_entry( stbir_info, split_info, y)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (on_first_input_y = 1 ; last_input_y = start_input_y ;)",
    "insertText": "for(y = start_input_y ; y < end_input_y; y++)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (int out_first_scanline,out_last_scanline ; out_first_scanline = vertical_contributors -> n0 ; out_last_scanline = vertical_contributors -> n1 ;)",
    "insertText": "STBIR_ASSERT(out_last_scanline - out_first_scanline + 1 <= stbir_info->ring_buffer_num_entries)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (start_input_y = y)",
    "insertText": "if(( on_first_input_y ) && ( y > start_input_y ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (on_first_input_y = 0 ;)",
    "insertText": "if(out_first_scanline < start_output_y)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (vc + = start_output_y - out_first_scanline ; out_first_scanline = start_output_y ; })",
    "insertText": "if(out_last_scanline >= end_output_y)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(split_info->ring_buffer_begin_index <= out_first_scanline)"
  },
  {
    "label": "stbir__decode_scanline()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__decode_scanline(stbir_info, y, split_info->decode_buffer STBIR_ONLY_PROFILE_SET_SPLIT_INFO)"
  },
  {
    "label": "stbir__resample_vertical_scatter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__resample_vertical_scatter(stbir_info, split_info, out_first_scanline, out_last_scanline, vc, (float*)scanline_scatter_buffer, (float*)scanline_scatter_buffer_end)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (} + + vertical_contributors ; vertical_coefficients + = stbir_info -> vertical . coefficient_width ; })",
    "insertText": "while(split_info->ring_buffer_first_scanline < end_output_y ) handle_scanline_for_scatter(stbir_info, split_info)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (+ + last_input_y ;)",
    "insertText": "for(y = 0 ; y < split_count; y++ ) if ( split_info[y].end_input_y > last_input_y)"
  },
  {
    "label": "stbir__set_sampler()",
    "kind": "Method",
    "detail": "Function (} stbir__kernel_callback* stbir__builtin_kernels [ ] = { 0,stbir__filter_trapezoid,stbir__filter_triangle,stbir__filter_cubic,stbir__filter_catmullrom,stbir__filter_mitchell,stbir__filter_point } ; stbir__support_callback* stbir__builtin_supports [ ] = { 0,stbir__support_trapezoid,stbir__support_one,stbir__support_two,stbir__support_two,stbir__support_two,stbir__support_zeropoint5 } ; void)",
    "insertText": "stbir__set_sampler(stbir__sampler * samp, stbir_filter filter, stbir__kernel_callback * kernel, stbir__support_callback * support, stbir_edge edge, stbir__scale_info * scale_info, int always_gather, void * user_data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (filter = STBIR_DEFAULT_FILTER_DOWNSAMPLE ;)",
    "insertText": "if(scale_info->scale >= ( 1.0f - stbir__small_float ))"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT((unsigned)samp->filter_enum < STBIR_FILTER_OTHER)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (samp -> filter_kernel = stbir__builtin_kernels [ filter ] ; samp -> filter_support = stbir__builtin_supports [ filter ] ;)",
    "insertText": "if(kernel && support)"
  },
  {
    "label": "stbir__get_filter_pixel_width()",
    "kind": "Method",
    "detail": "Function (samp -> filter_kernel = kernel ; samp -> filter_support = support ; samp -> filter_enum = STBIR_FILTER_OTHER ; } samp -> edge = edge ; samp -> filter_pixel_width =)",
    "insertText": "stbir__get_filter_pixel_width(samp->filter_support, scale_info->scale, user_data)"
  },
  {
    "label": "stbir__get_coefficient_width()",
    "kind": "Method",
    "detail": "Function (samp -> coefficient_width =)",
    "insertText": "stbir__get_coefficient_width(samp, samp->is_gather, user_data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (filter_pixel_margin = scale_info->input_full_size)",
    "insertText": "if(edge == STBIR_EDGE_WRAP ) if ( samp->filter_pixel_margin > scale_info->input_full_size)"
  },
  {
    "label": "stbir__get_contributors()",
    "kind": "Method",
    "detail": "Function (samp -> num_contributors =)",
    "insertText": "stbir__get_contributors(samp, samp->is_gather)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (samp -> contributors_size = samp -> num_contributors*)",
    "insertText": "sizeof(stbir__contributors)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (samp -> coefficients_size = samp -> num_contributors* samp -> coefficient_width*)",
    "insertText": "sizeof(float) + sizeof(float)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (samp -> gather_prescatter_contributors = 0 ; samp -> gather_prescatter_coefficients = 0 ;)",
    "insertText": "if(samp->is_gather == 0)"
  },
  {
    "label": "stbir__get_contributors()",
    "kind": "Method",
    "detail": "Function (samp -> gather_prescatter_coefficient_width = samp -> filter_pixel_width ; samp -> gather_prescatter_num_contributors =)",
    "insertText": "stbir__get_contributors(samp, 2)"
  },
  {
    "label": "sizeof()",
    "kind": "Method",
    "detail": "Function (samp -> gather_prescatter_coefficients_size = samp -> gather_prescatter_num_contributors* samp -> gather_prescatter_coefficient_width*)",
    "insertText": "sizeof(float)"
  },
  {
    "label": "stbir__get_conservative_extents()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "stbir__get_conservative_extents(stbir__sampler * samp, stbir__contributors * range, void * user_data)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (float scale = samp -> scale_info . scale ; float out_shift = samp -> scale_info . pixel_shift ; stbir__support_callback* support = samp -> filter_support ; int input_full_size = samp -> scale_info . input_full_size ; stbir_edge edge = samp -> edge ; float inv_scale = samp -> scale_info . inv_scale ;)",
    "insertText": "STBIR_ASSERT(samp->is_gather != 0)"
  },
  {
    "label": "support()",
    "kind": "Method",
    "detail": "Function (int in_first_pixel,in_last_pixel ; float out_filter_radius =)",
    "insertText": "support(inv_scale, user_data)"
  },
  {
    "label": "stbir__calculate_in_pixel_range()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__calculate_in_pixel_range(&in_first_pixel, &in_last_pixel, 0.5, out_filter_radius, inv_scale, out_shift, input_full_size, edge)"
  },
  {
    "label": "stbir__calculate_in_pixel_range()",
    "kind": "Method",
    "detail": "Function (range -> n0 = in_first_pixel ;)",
    "insertText": "stbir__calculate_in_pixel_range(&in_first_pixel, &in_last_pixel, ( (float)(samp->scale_info.output_sub_size-1) ) + 0.5f, out_filter_radius, inv_scale, out_shift, input_full_size, edge)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (range -> n1 = in_last_pixel ; } else)",
    "insertText": "if(samp->is_gather == 2)"
  },
  {
    "label": "support()",
    "kind": "Method",
    "detail": "Function (float in_pixels_radius =)",
    "insertText": "support(scale, user_data)"
  },
  {
    "label": "stbir__calculate_in_pixel_range()",
    "kind": "Method",
    "detail": "Function (int filter_pixel_margin = samp -> filter_pixel_margin ; int output_sub_size = samp -> scale_info . output_sub_size ; int input_end ; int n ; int in_first_pixel,in_last_pixel ;)",
    "insertText": "stbir__calculate_in_pixel_range(&in_first_pixel, &in_last_pixel, 0, 0, inv_scale, out_shift, input_full_size, edge)"
  },
  {
    "label": "stbir__calculate_in_pixel_range()",
    "kind": "Method",
    "detail": "Function (range -> n0 = in_first_pixel ;)",
    "insertText": "stbir__calculate_in_pixel_range(&in_first_pixel, &in_last_pixel, (float)output_sub_size, 0, inv_scale, out_shift, input_full_size, edge)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (range -> n1 = in_last_pixel ; n = range -> n0 + 1 ; input_end = - filter_pixel_margin ;)",
    "insertText": "while(n >= input_end)"
  },
  {
    "label": "stbir__calculate_out_pixel_range()",
    "kind": "Method",
    "detail": "Function (int out_first_pixel,out_last_pixel ;)",
    "insertText": "stbir__calculate_out_pixel_range(&out_first_pixel, &out_last_pixel, ((float)n)+0.5f, in_pixels_radius, scale, out_shift, output_sub_size)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (- - n ; } n = range -> n1 - 1 ; input_end = n + 1 + filter_pixel_margin ;)",
    "insertText": "while(n <= input_end)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + n ; } })",
    "insertText": "if(samp->edge == STBIR_EDGE_WRAP)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (n0 = 0)",
    "insertText": "if(( marg + STBIR__MERGE_RUNS_PIXEL_THRESHOLD ) >= range->n0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(( range->n0 < 0 ) && ( range->n1 < (input_full_size-1) ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (n1 = input_full_size - 1)",
    "insertText": "if(( input_full_size - marg - STBIR__MERGE_RUNS_PIXEL_THRESHOLD - 1 ) <= range->n1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (n0 = 0)",
    "insertText": "if(range->n0 < 0)"
  },
  {
    "label": "stbir__get_split_info()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "stbir__get_split_info(stbir__per_split_info* split_info, int splits, int output_height, int vertical_pixel_margin, int input_full_height)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int i,cur ; int left = output_height ; cur = 0 ;)",
    "insertText": "for(i = 0 ; i < splits ; i++)"
  },
  {
    "label": "left()",
    "kind": "Method",
    "detail": "Function (int each ; split_info [ i ] . start_output_y = cur ; each =)",
    "insertText": "left(splits - i)"
  },
  {
    "label": "stbir__free_internal_mem()",
    "kind": "Method",
    "detail": "Function (split_info [ i ] . end_output_y = cur + each ; cur + = each ; left - = each ; split_info [ i ] . start_input_y = - vertical_pixel_margin ; split_info [ i ] . end_input_y = input_full_height + vertical_pixel_margin ; } } void)",
    "insertText": "stbir__free_internal_mem(stbir__info *info)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "STBIR__FREE_AND_CLEAR(ptr)"
  },
  {
    "label": "p()",
    "kind": "Method",
    "detail": "Function (void*)",
    "insertText": "p(ptr)"
  },
  {
    "label": "STBIR_FREE()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_FREE(p, info->user_data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "if(info)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (# ifndef STBIR__SEPARATE_ALLOCATIONS)",
    "insertText": "STBIR__FREE_AND_CLEAR(info->alloced_mem)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# else int i,j ;)",
    "insertText": "if(( info->vertical.gather_prescatter_contributors ) && ( (void*)info->vertical.gather_prescatter_contributors != (void*)info->split_info[0].decode_buffer ))"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__FREE_AND_CLEAR(info->vertical.gather_prescatter_coefficients)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__FREE_AND_CLEAR(info->vertical.gather_prescatter_contributors)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "for(i = 0 ; i < info->splits ; i++)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (split_info[i].ring_buffers[j])",
    "insertText": "if(info->effective_channels == 3)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "STBIR__FREE_AND_CLEAR(info->split_info[i].ring_buffers[j])"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "STBIR__FREE_AND_CLEAR(info->split_info[i].decode_buffer)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__FREE_AND_CLEAR(info->split_info[i].ring_buffers)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__FREE_AND_CLEAR(info->split_info[i].vertical_buffer)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "STBIR__FREE_AND_CLEAR(info->split_info)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__FREE_AND_CLEAR(info->vertical.coefficients)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__FREE_AND_CLEAR(info->vertical.contributors)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "STBIR__FREE_AND_CLEAR(info->horizontal.coefficients)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__FREE_AND_CLEAR(info->horizontal.contributors)"
  },
  {
    "label": "STBIR__FREE_AND_CLEAR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__FREE_AND_CLEAR(info)"
  },
  {
    "label": "stbir__get_max_split()",
    "kind": "Method",
    "detail": "Function (# endif } # undef STBIR__FREE_AND_CLEAR } int)",
    "insertText": "stbir__get_max_split(int splits, int height)"
  },
  {
    "label": "height()",
    "kind": "Method",
    "detail": "Function (int each =)",
    "insertText": "height(splits - i)"
  },
  {
    "label": "stbir__should_do_vertical_first()",
    "kind": "Method",
    "detail": "Function (height - = each ; } return max ; } stbir__horizontal_gather_channels_func** stbir__horizontal_gather_n_coeffs_funcs [ 8 ] = { 0,stbir__horizontal_gather_1_channels_with_n_coeffs_funcs,stbir__horizontal_gather_2_channels_with_n_coeffs_funcs,stbir__horizontal_gather_3_channels_with_n_coeffs_funcs,stbir__horizontal_gather_4_channels_with_n_coeffs_funcs,0,0,stbir__horizontal_gather_7_channels_with_n_coeffs_funcs } ; stbir__horizontal_gather_channels_func** stbir__horizontal_gather_channels_funcs [ 8 ] = { 0,stbir__horizontal_gather_1_channels_funcs,stbir__horizontal_gather_2_channels_funcs,stbir__horizontal_gather_3_channels_funcs,stbir__horizontal_gather_4_channels_funcs,0,0,stbir__horizontal_gather_7_channels_funcs } ; # define STBIR_RESIZE_CLASSIFICATIONS 8 float stbir__compute_weights [ 5 ] [ STBIR_RESIZE_CLASSIFICATIONS ] [ 4 ] = { { { 1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,0 . 3 1 2 5 0 f,1 . 0 0 0 0 0 f },{ 0 . 5 6 2 5 0 f,0 . 5 9 3 7 5 f,0 . 0 0 0 0 0 f,0 . 9 6 8 7 5 f },{ 1 . 0 0 0 0 0 f,0 . 0 6 2 5 0 f,0 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 0 0 0 0 f,0 . 0 9 3 7 5 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 3 1 2 5 f,0 . 1 2 5 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 6 2 5 0 f,0 . 1 2 5 0 0 f,0 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,0 . 0 0 0 0 0 f,0 . 0 3 1 2 5 f },},{ { 0 . 0 0 0 0 0 f,0 . 8 4 3 7 5 f,0 . 0 0 0 0 0 f,0 . 0 3 1 2 5 f },{ 0 . 0 9 3 7 5 f,0 . 9 3 7 5 0 f,0 . 0 0 0 0 0 f,0 . 7 8 1 2 5 f },{ 0 . 8 7 5 0 0 f,0 . 2 1 8 7 5 f,0 . 0 0 0 0 0 f,0 . 9 6 8 7 5 f },{ 0 . 0 9 3 7 5 f,0 . 0 9 3 7 5 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 3 1 2 5 f,0 . 1 2 5 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 6 2 5 0 f,0 . 1 2 5 0 0 f,0 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,0 . 0 0 0 0 0 f,0 . 5 3 1 2 5 f },},{ { 0 . 0 0 0 0 0 f,0 . 5 3 1 2 5 f,0 . 0 0 0 0 0 f,0 . 0 3 1 2 5 f },{ 0 . 0 6 2 5 0 f,0 . 9 6 8 7 5 f,0 . 0 0 0 0 0 f,0 . 5 3 1 2 5 f },{ 0 . 8 7 5 0 0 f,0 . 1 8 7 5 0 f,0 . 0 0 0 0 0 f,0 . 9 3 7 5 0 f },{ 0 . 0 0 0 0 0 f,0 . 0 9 3 7 5 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 3 1 2 5 f,0 . 1 2 5 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 6 2 5 0 f,0 . 1 2 5 0 0 f,0 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,0 . 0 0 0 0 0 f,0 . 5 6 2 5 0 f },},{ { 0 . 0 0 0 0 0 f,0 . 5 0 0 0 0 f,0 . 0 0 0 0 0 f,0 . 7 1 8 7 5 f },{ 0 . 0 6 2 5 0 f,0 . 8 4 3 7 5 f,0 . 0 0 0 0 0 f,0 . 8 7 5 0 0 f },{ 1 . 0 0 0 0 0 f,0 . 5 0 0 0 0 f,0 . 5 0 0 0 0 f,0 . 9 6 8 7 5 f },{ 1 . 0 0 0 0 0 f,0 . 0 9 3 7 5 f,0 . 3 1 2 5 0 f,0 . 5 0 0 0 0 f },{ 1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 1 . 0 0 0 0 0 f,0 . 0 3 1 2 5 f,0 . 0 3 1 2 5 f,0 . 5 3 1 2 5 f },{ 0 . 1 8 7 5 0 f,0 . 1 2 5 0 0 f,0 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,0 . 0 3 1 2 5 f,0 . 1 8 7 5 0 f },},{ { 0 . 0 0 0 0 0 f,0 . 5 9 3 7 5 f,0 . 0 0 0 0 0 f,0 . 9 6 8 7 5 f },{ 0 . 0 6 2 5 0 f,0 . 8 1 2 5 0 f,0 . 0 6 2 5 0 f,0 . 5 9 3 7 5 f },{ 0 . 7 5 0 0 0 f,0 . 4 3 7 5 0 f,0 . 1 2 5 0 0 f,0 . 9 6 8 7 5 f },{ 0 . 8 7 5 0 0 f,0 . 0 6 2 5 0 f,0 . 1 8 7 5 0 f,0 . 4 3 7 5 0 f },{ 1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 1 5 6 2 5 f,0 . 1 2 5 0 0 f,1 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 6 2 5 0 f,0 . 1 2 5 0 0 f,0 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f },{ 0 . 0 0 0 0 0 f,1 . 0 0 0 0 0 f,0 . 0 3 1 2 5 f,0 . 3 4 3 7 5 f },} } ; typedef struct STBIR__V_FIRST_INFO { double v_cost,h_cost ; int control_v_first ; int v_first ; int v_resize_classification ; int is_gather ; } STBIR__V_FIRST_INFO ; # ifdef STBIR__V_FIRST_INFO_BUFFER STBIR__V_FIRST_INFO STBIR__V_FIRST_INFO_BUFFER = { 0 } ; # define STBIR__V_FIRST_INFO_POINTER& STBIR__V_FIRST_INFO_BUFFER # else # define STBIR__V_FIRST_INFO_POINTER 0 # endif int)",
    "insertText": "stbir__should_do_vertical_first(float weights_table[STBIR_RESIZE_CLASSIFICATIONS][4], int horizontal_filter_pixel_width, float horizontal_scale, int horizontal_output_size, int vertical_filter_pixel_width, float vertical_scale, int vertical_output_size, int is_gather, STBIR__V_FIRST_INFO * info)"
  },
  {
    "label": "v_cost()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "v_cost(float)vertical_filter_pixel_width * weights[2] + vertical_scale * (float)"
  },
  {
    "label": "vertical_first()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "vertical_first(v_cost <= h_cost)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (info -> h_cost = h_cost ; info -> v_cost = v_cost ; info -> v_resize_classification = v_classification ; info -> v_first = vertical_first ; info -> is_gather = is_gather ; })",
    "insertText": "if(( info ) && ( info->control_v_first ) ) vertical_first = ( info->control_v_first == 2)"
  },
  {
    "label": "stbir__get_max_split()",
    "kind": "Method",
    "detail": "Function (char stbir_channel_count_index [ 8 ] = { 9,0,1,2,3,9,9,4 } ; stbir__info* info = 0 ; void* alloced = 0 ; size_t alloced_total = 0 ; int vertical_first ; int decode_buffer_size,ring_buffer_length_bytes,ring_buffer_size,vertical_buffer_size,alloc_ring_buffer_num_entries ; int alpha_weighting_type = 0 ; int conservative_split_output_size =)",
    "insertText": "stbir__get_max_split(splits, vertical->scale_info.output_sub_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (stbir_internal_pixel_layout input_pixel_layout = stbir__pixel_layout_convert_public_to_internal [ input_pixel_layout_public ] ; stbir_internal_pixel_layout output_pixel_layout = stbir__pixel_layout_convert_public_to_internal [ output_pixel_layout_public ] ; int channels = stbir__pixel_channels [ input_pixel_layout ] ; int effective_channels = channels ;)",
    "insertText": "if(( horizontal->filter_enum != STBIR_FILTER_POINT_SAMPLE ) || ( vertical->filter_enum != STBIR_FILTER_POINT_SAMPLE ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (alpha_weighting_type = 4 ; } else { int fancy_alpha_effective_cnts [ 6 ] = { 7,7,7,7,3,3 } ; alpha_weighting_type = 2 ; effective_channels = fancy_alpha_effective_cnts [ input_pixel_layout - STBIRI_RGBA ] ; } } else)",
    "insertText": "if(( input_pixel_layout >= STBIRI_RGBA_PM ) && ( input_pixel_layout <= STBIRI_AR_PM ) && ( output_pixel_layout >= STBIRI_RGBA ) && ( output_pixel_layout <= STBIRI_AR ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (alpha_weighting_type = 3 ; } else)",
    "insertText": "if(( input_pixel_layout >= STBIRI_RGBA ) && ( input_pixel_layout <= STBIRI_AR ) && ( output_pixel_layout >= STBIRI_RGBA_PM ) && ( output_pixel_layout <= STBIRI_AR_PM ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (alpha_weighting_type = 1 ; } })",
    "insertText": "if(channels != stbir__pixel_channels[ output_pixel_layout ])"
  },
  {
    "label": "stbir__should_do_vertical_first()",
    "kind": "Method",
    "detail": "Function (vertical_first =)",
    "insertText": "stbir__should_do_vertical_first(stbir__compute_weights[ (int)stbir_channel_count_index[ effective_channels ] ], horizontal->filter_pixel_width, horizontal->scale_info.scale, horizontal->scale_info.output_sub_size, vertical->filter_pixel_width, vertical->scale_info.scale, vertical->scale_info.output_sub_size, vertical->is_gather, STBIR__V_FIRST_INFO_POINTER)"
  },
  {
    "label": "decode_buffer_size()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decode_buffer_size(conservative->n1 - conservative->n0 + 1 ) * effective_channels * sizeof(float) + sizeof(float)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if)",
    "insertText": "defined(STBIR__SEPARATE_ALLOCATIONS ) && defined(STBIR_SIMD8) if ( effective_channels == 3 ) decode_buffer_size += sizeof(float)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (alloc_ring_buffer_num_entries = vertical -> filter_pixel_width + 1 ;)",
    "insertText": "if(( !vertical->is_gather ) && ( alloc_ring_buffer_num_entries > conservative_split_output_size ))"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (int i ; void* advance_mem = alloced ; int copy_horizontal = 0 ; stbir__sampler* possibly_use_horizontal_for_pivot = 0 ; # ifdef STBIR__SEPARATE_ALLOCATIONS # define)",
    "insertText": "STBIR__NEXT_PTR(ptr, size, ntype ) if ( alloced)"
  },
  {
    "label": "STBIR_MALLOC()",
    "kind": "Method",
    "detail": "Function (void* p =)",
    "insertText": "STBIR_MALLOC(size, user_data)"
  },
  {
    "label": "stbir__free_internal_mem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__free_internal_mem(info)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (} # else # define)",
    "insertText": "STBIR__NEXT_PTR(ptr, size, ntype ) advance_mem = (void*) ( ( ((size_t)advance_mem) + 15 ) & ~15)"
  },
  {
    "label": "advance_mem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "advance_mem((char*)advance_mem) + (size)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "STBIR__NEXT_PTR(info, sizeof( stbir__info ), stbir__info)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__NEXT_PTR(info->split_info, sizeof( stbir__per_split_info ) * splits, stbir__per_split_info)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (stbir__alpha_weight_func* fancy_alpha_weights [ 6 ] = { stbir__fancy_alpha_weight_4ch,stbir__fancy_alpha_weight_4ch,stbir__fancy_alpha_weight_4ch,stbir__fancy_alpha_weight_4ch,stbir__fancy_alpha_weight_2ch,stbir__fancy_alpha_weight_2ch } ; stbir__alpha_unweight_func* fancy_alpha_unweights [ 6 ] = { stbir__fancy_alpha_unweight_4ch,stbir__fancy_alpha_unweight_4ch,stbir__fancy_alpha_unweight_4ch,stbir__fancy_alpha_unweight_4ch,stbir__fancy_alpha_unweight_2ch,stbir__fancy_alpha_unweight_2ch } ; stbir__alpha_weight_func* simple_alpha_weights [ 6 ] = { stbir__simple_alpha_weight_4ch,stbir__simple_alpha_weight_4ch,stbir__simple_alpha_weight_4ch,stbir__simple_alpha_weight_4ch,stbir__simple_alpha_weight_2ch,stbir__simple_alpha_weight_2ch } ; stbir__alpha_unweight_func* simple_alpha_unweights [ 6 ] = { stbir__simple_alpha_unweight_4ch,stbir__simple_alpha_unweight_4ch,stbir__simple_alpha_unweight_4ch,stbir__simple_alpha_unweight_4ch,stbir__simple_alpha_unweight_2ch,stbir__simple_alpha_unweight_2ch } ; info -> alloced_mem = alloced ; info -> alloced_total = alloced_total ; info -> channels = channels ; info -> effective_channels = effective_channels ; info -> offset_x = new_x ; info -> offset_y = new_y ; info -> alloc_ring_buffer_num_entries = alloc_ring_buffer_num_entries ; info -> ring_buffer_num_entries = 0 ; info -> ring_buffer_length_bytes = ring_buffer_length_bytes ; info -> splits = splits ; info -> vertical_first = vertical_first ; info -> input_pixel_layout_internal = input_pixel_layout ; info -> output_pixel_layout_internal = output_pixel_layout ; info -> alpha_weight = 0 ; info -> alpha_unweight = 0 ;)",
    "insertText": "if(alpha_weighting_type == 2)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (info -> alpha_weight = fancy_alpha_weights [ input_pixel_layout - STBIRI_RGBA ] ; info -> alpha_unweight = fancy_alpha_unweights [ output_pixel_layout - STBIRI_RGBA ] ; } else)",
    "insertText": "if(alpha_weighting_type == 4)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (info -> alpha_weight = simple_alpha_weights [ input_pixel_layout - STBIRI_RGBA ] ; info -> alpha_unweight = simple_alpha_unweights [ output_pixel_layout - STBIRI_RGBA ] ; } else)",
    "insertText": "if(alpha_weighting_type == 1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (info -> alpha_weight = simple_alpha_weights [ input_pixel_layout - STBIRI_RGBA ] ; } else)",
    "insertText": "if(alpha_weighting_type == 3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (info -> alpha_unweight = simple_alpha_unweights [ output_pixel_layout - STBIRI_RGBA ] ; })",
    "insertText": "if(( ( input_pixel_layout == STBIRI_RGB ) && ( output_pixel_layout == STBIRI_BGR ) ) || ( ( input_pixel_layout == STBIRI_BGR ) && ( output_pixel_layout == STBIRI_RGB ) ))"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__NEXT_PTR(info->split_info[i].decode_buffer, decode_buffer_size, float)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (split_info[i].decode_buffer)",
    "insertText": "if(( info ) && ( effective_channels == 3 ))"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "STBIR__NEXT_PTR(info->split_info[i].ring_buffers, alloc_ring_buffer_num_entries * sizeof(float*), float*)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function ({ int j ;)",
    "insertText": "for(j = 0 ; j < alloc_ring_buffer_num_entries ; j++)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__NEXT_PTR(info->split_info[i].ring_buffers[j], ring_buffer_length_bytes, float)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (# endif } } # else)",
    "insertText": "STBIR__NEXT_PTR(info->split_info[i].ring_buffer, ring_buffer_size, float)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "STBIR__NEXT_PTR(info->split_info[i].vertical_buffer, vertical_buffer_size, float)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(vertical->is_gather == 0)"
  },
  {
    "label": "temp_mem_amt()",
    "kind": "Method",
    "detail": "Function (int both ; int temp_mem_amt ; both = vertical -> gather_prescatter_contributors_size + vertical -> gather_prescatter_coefficients_size ; # ifdef STBIR__SEPARATE_ALLOCATIONS temp_mem_amt = decode_buffer_size ; # else)",
    "insertText": "temp_mem_amt(decode_buffer_size + ring_buffer_size + vertical_buffer_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(temp_mem_amt >= both)"
  },
  {
    "label": "gather_prescatter_contributors()",
    "kind": "Method",
    "detail": "Function (split_info[0].decode_buffer)",
    "insertText": "gather_prescatter_contributors(stbir__contributors*)"
  },
  {
    "label": "gather_prescatter_coefficients()",
    "kind": "Method",
    "detail": "Function (vertical ->)",
    "insertText": "gather_prescatter_coefficients(float*) ( ( (char*)info->split_info[0].decode_buffer ) + vertical->gather_prescatter_contributors_size)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (} } else {)",
    "insertText": "STBIR__NEXT_PTR(vertical->gather_prescatter_contributors, vertical->gather_prescatter_contributors_size, stbir__contributors)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__NEXT_PTR(vertical->gather_prescatter_coefficients, vertical->gather_prescatter_coefficients_size, float)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "STBIR__NEXT_PTR(horizontal->contributors, horizontal->contributors_size, stbir__contributors)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__NEXT_PTR(horizontal->coefficients, horizontal->coefficients_size, float)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (float diff_scale = horizontal -> scale_info . scale - vertical -> scale_info . scale ; float diff_shift = horizontal -> scale_info . pixel_shift - vertical -> scale_info . pixel_shift ;)",
    "insertText": "if(diff_scale < 0.0f)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (copy_horizontal = 1 ; goto no_vert_alloc ; } possibly_use_horizontal_for_pivot = horizontal ; } })",
    "insertText": "STBIR__NEXT_PTR(vertical->contributors, vertical->contributors_size, stbir__contributors)"
  },
  {
    "label": "STBIR__NEXT_PTR()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR__NEXT_PTR(vertical->coefficients, vertical->coefficients_size, float)"
  },
  {
    "label": "STBIR_PROFILE_BUILD_START()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_BUILD_START(horizontal)"
  },
  {
    "label": "stbir__calculate_filters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__calculate_filters(horizontal, 0, user_data STBIR_ONLY_PROFILE_BUILD_SET_INFO)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (horizontal_gather_channels = stbir__horizontal_gather_channels_funcs[ effective_channels ][ horizontal->extent_info.widest - 1 ])",
    "insertText": "if(horizontal->extent_info.widest <= 12)"
  },
  {
    "label": "stbir__get_extents()",
    "kind": "Method",
    "detail": "Function (info -> scanline_extents . conservative . n0 = conservative -> n0 ; info -> scanline_extents . conservative . n1 = conservative -> n1 ;)",
    "insertText": "stbir__get_extents(horizontal, &info->scanline_extents)"
  },
  {
    "label": "stbir__pack_coefficients()",
    "kind": "Method",
    "detail": "Function (horizontal -> coefficient_width =)",
    "insertText": "stbir__pack_coefficients(horizontal->num_contributors, horizontal->contributors, horizontal->coefficients, horizontal->coefficient_width, horizontal->extent_info.widest, info->scanline_extents.conservative.n0, info->scanline_extents.conservative.n1)"
  },
  {
    "label": "STBIR_MEMCPY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MEMCPY(&info->horizontal, horizontal, sizeof( stbir__sampler ))"
  },
  {
    "label": "STBIR_PROFILE_BUILD_END()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_BUILD_END(horizontal)"
  },
  {
    "label": "STBIR_MEMCPY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MEMCPY(&info->vertical, horizontal, sizeof( stbir__sampler ))"
  },
  {
    "label": "STBIR_PROFILE_BUILD_START()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "STBIR_PROFILE_BUILD_START(vertical)"
  },
  {
    "label": "stbir__calculate_filters()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__calculate_filters(vertical, possibly_use_horizontal_for_pivot, user_data STBIR_ONLY_PROFILE_BUILD_SET_INFO)"
  },
  {
    "label": "STBIR_MEMCPY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MEMCPY(&info->vertical, vertical, sizeof( stbir__sampler ))"
  },
  {
    "label": "STBIR_PROFILE_BUILD_END()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_BUILD_END(vertical)"
  },
  {
    "label": "stbir__get_split_info()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "stbir__get_split_info(info->split_info, info->splits, info->vertical.scale_info.output_sub_size, info->vertical.filter_pixel_margin, info->vertical.scale_info.input_full_size)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (ring_buffer_num_entries = conservative_split_output_size)",
    "insertText": "if(( !info->vertical.is_gather ) && ( info->ring_buffer_num_entries > conservative_split_output_size ))"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(info->ring_buffer_num_entries <= info->alloc_ring_buffer_num_entries)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (scanline_extents.spans[0].n1 - info->scanline_extents.spans[0].n0)",
    "insertText": "if(info->scanline_extents.spans[0].n1 > info->scanline_extents.spans[1].n1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (info -> split_info [ i ] . decode_buffer [ ofs ] = 9 9 9 9 . 0 f ;)",
    "insertText": "if(vertical_first)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (int j ;)",
    "insertText": "for(j = 0; j < info->ring_buffer_num_entries ; j++)"
  },
  {
    "label": "stbir__get_ring_buffer_entry()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__get_ring_buffer_entry(info, info->split_info + i, j)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} } } } # undef STBIR__NEXT_PTR)",
    "insertText": "if(info == 0)"
  },
  {
    "label": "alloced_total()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "alloced_total(15 + (size_t)advance_mem)"
  },
  {
    "label": "STBIR_MALLOC()",
    "kind": "Method",
    "detail": "Function (alloced =)",
    "insertText": "STBIR_MALLOC(alloced_total, user_data)"
  },
  {
    "label": "stbir__perform_resize()",
    "kind": "Method",
    "detail": "Function (} else return info ; } } int)",
    "insertText": "stbir__perform_resize(stbir__info const * info, int split_start, int split_count)"
  },
  {
    "label": "STBIR_PROFILE_CLEAR_EXTRAS()",
    "kind": "Method",
    "detail": "Function (stbir__per_split_info* split_info = info -> split_info + split_start ;)",
    "insertText": "STBIR_PROFILE_CLEAR_EXTRAS()"
  },
  {
    "label": "STBIR_PROFILE_FIRST_START()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_FIRST_START(looping)"
  },
  {
    "label": "STBIR_PROFILE_END()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_END(looping)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (stbir__decode_pixels_func* decode_simple [ STBIR_TYPE_HALF_FLOAT - STBIR_TYPE_UINT8_SRGB + 1 ] = { stbir__decode_uint8_srgb,stbir__decode_uint8_srgb,0,stbir__decode_float_linear,stbir__decode_half_float_linear,} ; stbir__decode_pixels_func* decode_alphas [ STBIRI_AR - STBIRI_RGBA + 1 ] [ STBIR_TYPE_HALF_FLOAT - STBIR_TYPE_UINT8_SRGB + 1 ] = { { stbir__decode_uint8_srgb4_linearalpha,stbir__decode_uint8_srgb,0,stbir__decode_float_linear,stbir__decode_half_float_linear },{ stbir__decode_uint8_srgb4_linearalpha_BGRA,stbir__decode_uint8_srgb_BGRA,0,stbir__decode_float_linear_BGRA,stbir__decode_half_float_linear_BGRA },{ stbir__decode_uint8_srgb4_linearalpha_ARGB,stbir__decode_uint8_srgb_ARGB,0,stbir__decode_float_linear_ARGB,stbir__decode_half_float_linear_ARGB },{ stbir__decode_uint8_srgb4_linearalpha_ABGR,stbir__decode_uint8_srgb_ABGR,0,stbir__decode_float_linear_ABGR,stbir__decode_half_float_linear_ABGR },{ stbir__decode_uint8_srgb2_linearalpha,stbir__decode_uint8_srgb,0,stbir__decode_float_linear,stbir__decode_half_float_linear },{ stbir__decode_uint8_srgb2_linearalpha_AR,stbir__decode_uint8_srgb_AR,0,stbir__decode_float_linear_AR,stbir__decode_half_float_linear_AR },} ; stbir__decode_pixels_func* decode_simple_scaled_or_not [ 2 ] [ 2 ] = { { stbir__decode_uint8_linear_scaled,stbir__decode_uint8_linear },{ stbir__decode_uint16_linear_scaled,stbir__decode_uint16_linear },} ; stbir__decode_pixels_func* decode_alphas_scaled_or_not [ STBIRI_AR - STBIRI_RGBA + 1 ] [ 2 ] [ 2 ] = { { { stbir__decode_uint8_linear_scaled,stbir__decode_uint8_linear },{ stbir__decode_uint16_linear_scaled,stbir__decode_uint16_linear } },{ { stbir__decode_uint8_linear_scaled_BGRA,stbir__decode_uint8_linear_BGRA },{ stbir__decode_uint16_linear_scaled_BGRA,stbir__decode_uint16_linear_BGRA } },{ { stbir__decode_uint8_linear_scaled_ARGB,stbir__decode_uint8_linear_ARGB },{ stbir__decode_uint16_linear_scaled_ARGB,stbir__decode_uint16_linear_ARGB } },{ { stbir__decode_uint8_linear_scaled_ABGR,stbir__decode_uint8_linear_ABGR },{ stbir__decode_uint16_linear_scaled_ABGR,stbir__decode_uint16_linear_ABGR } },{ { stbir__decode_uint8_linear_scaled,stbir__decode_uint8_linear },{ stbir__decode_uint16_linear_scaled,stbir__decode_uint16_linear } },{ { stbir__decode_uint8_linear_scaled_AR,stbir__decode_uint8_linear_AR },{ stbir__decode_uint16_linear_scaled_AR,stbir__decode_uint16_linear_AR } } } ; stbir__encode_pixels_func* encode_simple [ STBIR_TYPE_HALF_FLOAT - STBIR_TYPE_UINT8_SRGB + 1 ] = { stbir__encode_uint8_srgb,stbir__encode_uint8_srgb,0,stbir__encode_float_linear,stbir__encode_half_float_linear,} ; stbir__encode_pixels_func* encode_alphas [ STBIRI_AR - STBIRI_RGBA + 1 ] [ STBIR_TYPE_HALF_FLOAT - STBIR_TYPE_UINT8_SRGB + 1 ] = { { stbir__encode_uint8_srgb4_linearalpha,stbir__encode_uint8_srgb,0,stbir__encode_float_linear,stbir__encode_half_float_linear },{ stbir__encode_uint8_srgb4_linearalpha_BGRA,stbir__encode_uint8_srgb_BGRA,0,stbir__encode_float_linear_BGRA,stbir__encode_half_float_linear_BGRA },{ stbir__encode_uint8_srgb4_linearalpha_ARGB,stbir__encode_uint8_srgb_ARGB,0,stbir__encode_float_linear_ARGB,stbir__encode_half_float_linear_ARGB },{ stbir__encode_uint8_srgb4_linearalpha_ABGR,stbir__encode_uint8_srgb_ABGR,0,stbir__encode_float_linear_ABGR,stbir__encode_half_float_linear_ABGR },{ stbir__encode_uint8_srgb2_linearalpha,stbir__encode_uint8_srgb,0,stbir__encode_float_linear,stbir__encode_half_float_linear },{ stbir__encode_uint8_srgb2_linearalpha_AR,stbir__encode_uint8_srgb_AR,0,stbir__encode_float_linear_AR,stbir__encode_half_float_linear_AR } } ; stbir__encode_pixels_func* encode_simple_scaled_or_not [ 2 ] [ 2 ] = { { stbir__encode_uint8_linear_scaled,stbir__encode_uint8_linear },{ stbir__encode_uint16_linear_scaled,stbir__encode_uint16_linear },} ; stbir__encode_pixels_func* encode_alphas_scaled_or_not [ STBIRI_AR - STBIRI_RGBA + 1 ] [ 2 ] [ 2 ] = { { { stbir__encode_uint8_linear_scaled,stbir__encode_uint8_linear },{ stbir__encode_uint16_linear_scaled,stbir__encode_uint16_linear } },{ { stbir__encode_uint8_linear_scaled_BGRA,stbir__encode_uint8_linear_BGRA },{ stbir__encode_uint16_linear_scaled_BGRA,stbir__encode_uint16_linear_BGRA } },{ { stbir__encode_uint8_linear_scaled_ARGB,stbir__encode_uint8_linear_ARGB },{ stbir__encode_uint16_linear_scaled_ARGB,stbir__encode_uint16_linear_ARGB } },{ { stbir__encode_uint8_linear_scaled_ABGR,stbir__encode_uint8_linear_ABGR },{ stbir__encode_uint16_linear_scaled_ABGR,stbir__encode_uint16_linear_ABGR } },{ { stbir__encode_uint8_linear_scaled,stbir__encode_uint8_linear },{ stbir__encode_uint16_linear_scaled,stbir__encode_uint16_linear } },{ { stbir__encode_uint8_linear_scaled_AR,stbir__encode_uint8_linear_AR },{ stbir__encode_uint16_linear_scaled_AR,stbir__encode_uint16_linear_AR } } } ; stbir__decode_pixels_func* decode_pixels = 0 ; stbir__encode_pixels_func* encode_pixels = 0 ; stbir_datatype input_type,output_type ; input_type = resize -> input_data_type ; output_type = resize -> output_data_type ; info -> input_data = resize -> input_pixels ; info -> input_stride_bytes = resize -> input_stride_in_bytes ; info -> output_stride_bytes = resize -> output_stride_in_bytes ;)",
    "insertText": "if(( info->horizontal.filter_enum == STBIR_FILTER_POINT_SAMPLE ) && ( info->vertical.filter_enum == STBIR_FILTER_POINT_SAMPLE ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (input_stride_bytes = info->channels * info->horizontal.scale_info.input_full_size * stbir__type_size[input_type])",
    "insertText": "if(info->input_stride_bytes == 0)"
  },
  {
    "label": "output_data()",
    "kind": "Method",
    "detail": "Function (info ->)",
    "insertText": "output_data((char*) resize->output_pixels ) + ( (size_t) info->offset_y * (size_t) resize->output_stride_in_bytes ) + ( info->offset_x * info->channels * stbir__type_size[output_type])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (info -> in_pixels_cb = resize -> input_cb ; info -> user_data = resize -> user_data ; info -> out_pixels_cb = resize -> output_cb ;)",
    "insertText": "if(( input_type == STBIR_TYPE_UINT8 ) || ( input_type == STBIR_TYPE_UINT16 ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int non_scaled = 0 ;)",
    "insertText": "if(( !info->alpha_weight ) && ( !info->alpha_unweight ) ) if ( ( ( input_type == STBIR_TYPE_UINT8 ) && ( output_type == STBIR_TYPE_UINT8 ) ) || ( ( input_type == STBIR_TYPE_UINT16 ) && ( output_type == STBIR_TYPE_UINT16 ) ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(info->input_pixel_layout_internal <= STBIRI_4CHANNEL)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(( output_type == STBIR_TYPE_UINT8 ) || ( output_type == STBIR_TYPE_UINT16 ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} else {)",
    "insertText": "if(info->output_pixel_layout_internal <= STBIRI_4CHANNEL)"
  },
  {
    "label": "stbir__clip()",
    "kind": "Method",
    "detail": "Function (} info -> input_type = input_type ; info -> output_type = output_type ; info -> decode_pixels = decode_pixels ; info -> encode_pixels = encode_pixels ; } void)",
    "insertText": "stbir__clip(int * outx, int * outsubw, int outw, double * u0, double * u1)"
  },
  {
    "label": "per()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "per((double)*outx ) / ( (double)*outsubw)"
  },
  {
    "label": "per()",
    "kind": "Method",
    "detail": "Function (adj =)",
    "insertText": "per(*u1 - *u0)"
  },
  {
    "label": "outw()",
    "kind": "Method",
    "detail": "Function (* u0 - = adj ;* outx = 0 ; } over =)",
    "insertText": "outw(*outx + *outsubw)"
  },
  {
    "label": "per()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "per((double)over ) / ( (double)*outsubw)"
  },
  {
    "label": "stbir__double_to_rational()",
    "kind": "Method",
    "detail": "Function (* u1 + = adj ;* outsubw = outw -* outx ; } } int)",
    "insertText": "stbir__double_to_rational(double f, stbir_uint32 limit, stbir_uint32 *numer, stbir_uint32 *denom, int limit_denom)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (bot = 1<<2 5 ;)",
    "insertText": "for(;;)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (stbir_uint64 est,temp ;)",
    "insertText": "if(( ( limit_denom ) ? denom_estimate : numer_estimate ) >= limit)"
  },
  {
    "label": "err()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "err((double)numer_estimate / (double)denom_estimate)"
  },
  {
    "label": "numer()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "numer(stbir_uint32)"
  },
  {
    "label": "denom()",
    "kind": "Method",
    "detail": "Function (*)",
    "insertText": "denom(stbir_uint32)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (est = top / bot ; temp = top % bot ; top = bot ; bot = temp ; temp = est* denom_estimate + denom_last ; denom_last = denom_estimate ; denom_estimate = temp ; temp = est* numer_estimate + numer_last ; numer_last = numer_estimate ; numer_estimate = temp ; })",
    "insertText": "if(limit_denom)"
  },
  {
    "label": "numer_estimate()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "numer_estimate(stbir_uint64)( f * (double)limit + 0.5)"
  },
  {
    "label": "denom_estimate()",
    "kind": "Method",
    "detail": "Function (denom_estimate = limit ; } else { numer_estimate = limit ;)",
    "insertText": "denom_estimate(stbir_uint64)( ( (double)limit / f ) + 0.5)"
  },
  {
    "label": "err()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "err(denom_estimate ) ? ( ( (double)(stbir_uint32)numer_estimate / (double)(stbir_uint32)denom_estimate ) - f)"
  },
  {
    "label": "stbir__calculate_region_transform()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "stbir__calculate_region_transform(stbir__scale_info * scale_info, int output_full_range, int * output_offset, int output_sub_range, int input_full_range, double input_s0, double input_s1)"
  },
  {
    "label": "output_range()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "output_range(double)"
  },
  {
    "label": "input_range()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "input_range(double)"
  },
  {
    "label": "output_s()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "output_s((double)output_sub_range)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (ratio = output_s / input_s ;)",
    "insertText": "scale(output_range / input_range)"
  },
  {
    "label": "scale()",
    "kind": "Method",
    "detail": "Function (scale_info ->)",
    "insertText": "scale(float)"
  },
  {
    "label": "inv_scale()",
    "kind": "Method",
    "detail": "Function (scale_info ->)",
    "insertText": "inv_scale(float)( 1.0 / scale)"
  },
  {
    "label": "stbir__clip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__clip(output_offset, &output_sub_range, output_full_range, &input_s0, &input_s1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (input_s = input_s1 - input_s0 ;)",
    "insertText": "if(input_s <= stbir__small_float)"
  },
  {
    "label": "pixel_shift()",
    "kind": "Method",
    "detail": "Function (scale_info ->)",
    "insertText": "pixel_shift(float) ( input_s0 * ratio * output_range)"
  },
  {
    "label": "stbir__double_to_rational()",
    "kind": "Method",
    "detail": "Function (scale_info -> scale_is_rational =)",
    "insertText": "stbir__double_to_rational(scale, ( scale <= 1.0 ) ? output_full_range : input_full_range, &scale_info->scale_numerator, &scale_info->scale_denominator, ( scale >= 1.0 ))"
  },
  {
    "label": "stbir__init_and_set_layout()",
    "kind": "Method",
    "detail": "Function (scale_info -> input_full_size = input_full_range ; scale_info -> output_sub_size = output_sub_range ; return 1 ; } void)",
    "insertText": "stbir__init_and_set_layout(STBIR_RESIZE * resize, stbir_pixel_layout pixel_layout, stbir_datatype data_type)"
  },
  {
    "label": "stbir__init_and_set_layout()",
    "kind": "Method",
    "detail": "Function (resize -> input_pixels = input_pixels ; resize -> input_w = input_w ; resize -> input_h = input_h ; resize -> input_stride_in_bytes = input_stride_in_bytes ; resize -> output_pixels = output_pixels ; resize -> output_w = output_w ; resize -> output_h = output_h ; resize -> output_stride_in_bytes = output_stride_in_bytes ; resize -> fast_alpha = 0 ;)",
    "insertText": "stbir__init_and_set_layout(resize, pixel_layout, data_type)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (resize -> input_data_type = input_type ; resize -> output_data_type = output_type ;)",
    "insertText": "if(( resize->samplers ) && ( !resize->needs_rebuild ) ) stbir__update_info_from_resize( resize->samplers, resize)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (resize -> input_cb = input_cb ; resize -> output_cb = output_cb ;)",
    "insertText": "if(( resize->samplers ) && ( !resize->needs_rebuild ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (resize -> input_s0 = s0 ; resize -> input_t0 = t0 ; resize -> input_s1 = s1 ; resize -> input_t1 = t1 ; resize -> needs_rebuild = 1 ;)",
    "insertText": "if(( s1 < stbir__small_float ) || ( (s1-s0) < stbir__small_float ) || ( t1 < stbir__small_float ) || ( (t1-t0) < stbir__small_float ) || ( s0 > (1.0f-stbir__small_float) ) || ( t0 > (1.0f-stbir__small_float) ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (resize -> output_subx = subx ; resize -> output_suby = suby ; resize -> output_subw = subw ; resize -> output_subh = subh ; resize -> needs_rebuild = 1 ;)",
    "insertText": "if(( subx >= resize->output_w ) || ( ( subx + subw ) <= 0 ) || ( suby >= resize->output_h ) || ( ( suby + subh ) <= 0 ) || ( subw == 0 ) || ( subh == 0 ))"
  },
  {
    "label": "t0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "t0((double)suby ) / ( (double)resize->output_h)"
  },
  {
    "label": "s1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "s1((double)(subx+subw) ) / ( (double)resize->output_w)"
  },
  {
    "label": "t1()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "t1((double)(suby+subh) ) / ( (double)resize->output_h)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (stbir__contributors conservative = { 0,0 } ; stbir__sampler horizontal,vertical ; int new_output_subx,new_output_suby ; stbir__info* out_info ; # ifdef STBIR_PROFILE stbir__info profile_infod ; stbir__info* profile_info =& profile_infod ; # endif)",
    "insertText": "if(resize->samplers)"
  },
  {
    "label": "STBIR_RETURN_ERROR_AND_ASSERT()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "STBIR_RETURN_ERROR_AND_ASSERT(exp ) STBIR_ASSERT( !(exp))"
  },
  {
    "label": "STBIR_RETURN_ERROR_AND_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_RETURN_ERROR_AND_ASSERT((unsigned)resize->horizontal_filter >= STBIR_FILTER_OTHER) STBIR_RETURN_ERROR_AND_ASSERT( (unsigned)resize->vertical_filter >= STBIR_FILTER_OTHER) #undef STBIR_RETURN_ERROR_AND_ASSERT if ( splits <= 0)"
  },
  {
    "label": "STBIR_PROFILE_BUILD_FIRST_START()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_BUILD_FIRST_START(build)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (new_output_subx = resize -> output_subx ; new_output_suby = resize -> output_suby ;)",
    "insertText": "if(!stbir__calculate_region_transform( &horizontal.scale_info, resize->output_w, &new_output_subx, resize->output_subw, resize->input_w, resize->input_s0, resize->input_s1 ))"
  },
  {
    "label": "stbir__set_sampler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__set_sampler(&horizontal, resize->horizontal_filter, resize->horizontal_filter_kernel, resize->horizontal_filter_support, resize->horizontal_edge, &horizontal.scale_info, 1, resize->user_data)"
  },
  {
    "label": "stbir__get_conservative_extents()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__get_conservative_extents(&horizontal, &conservative, resize->user_data)"
  },
  {
    "label": "stbir__set_sampler()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__set_sampler(&vertical, resize->vertical_filter, resize->horizontal_filter_kernel, resize->vertical_filter_support, resize->vertical_edge, &vertical.scale_info, 0, resize->user_data)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (splits = vertical . scale_info . output_sub_size / STBIR_FORCE_MINIMUM_SCANLINES_FOR_SPLITS ;)",
    "insertText": "if(splits == 0)"
  },
  {
    "label": "STBIR_PROFILE_BUILD_START()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "STBIR_PROFILE_BUILD_START(alloc)"
  },
  {
    "label": "stbir__alloc_internal_mem_and_build_samplers()",
    "kind": "Method",
    "detail": "Function (out_info =)",
    "insertText": "stbir__alloc_internal_mem_and_build_samplers(&horizontal, &vertical, &conservative, resize->input_pixel_layout_public, resize->output_pixel_layout_public, splits, new_output_subx, new_output_suby, resize->fast_alpha, resize->user_data STBIR_ONLY_PROFILE_BUILD_SET_INFO)"
  },
  {
    "label": "STBIR_PROFILE_BUILD_END()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_BUILD_END(alloc)"
  },
  {
    "label": "STBIR_PROFILE_BUILD_END()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_PROFILE_BUILD_END(build)"
  },
  {
    "label": "STBIR_MEMCPY()",
    "kind": "Method",
    "detail": "Function (resize -> splits = splits ; resize -> samplers = out_info ; resize -> needs_rebuild = 0 ; # ifdef STBIR_PROFILE)",
    "insertText": "STBIR_MEMCPY(&out_info->profile, &profile_infod.profile, sizeof( out_info->profile ))"
  },
  {
    "label": "stbir__update_info_from_resize()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "stbir__update_info_from_resize(out_info, resize)"
  },
  {
    "label": "stbir__free_internal_mem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__free_internal_mem(resize->samplers)"
  },
  {
    "label": "stbir_build_samplers_with_splits()",
    "kind": "Method",
    "detail": "Function (resize -> samplers = 0 ; resize -> called_alloc = 0 ; } } STBIRDEF int)",
    "insertText": "stbir_build_samplers_with_splits(STBIR_RESIZE * resize, int splits)"
  },
  {
    "label": "stbir__perform_build()",
    "kind": "Method",
    "detail": "Function (resize -> called_alloc = 1 ; return)",
    "insertText": "stbir__perform_build(resize, splits)"
  },
  {
    "label": "STBIR_PROFILE_BUILD_CLEAR()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "STBIR_PROFILE_BUILD_CLEAR(resize->samplers)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (int result ;)",
    "insertText": "if(( resize->samplers == 0 ) || ( resize->needs_rebuild ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (resize -> samplers = 0 ; })",
    "insertText": "if(!stbir_build_samplers( resize ))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (resize -> called_alloc = alloc_state ;)",
    "insertText": "if(resize->samplers == 0)"
  },
  {
    "label": "stbir__perform_resize()",
    "kind": "Method",
    "detail": "Function (} result =)",
    "insertText": "stbir__perform_resize(resize->samplers, 0, resize->splits)"
  },
  {
    "label": "stbir_free_samplers()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir_free_samplers(resize)"
  },
  {
    "label": "STBIR_ASSERT()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_ASSERT(resize->samplers)"
  },
  {
    "label": "stbir__check_output_stuff()",
    "kind": "Method",
    "detail": "Function (} int)",
    "insertText": "stbir__check_output_stuff(void ** ret_ptr, int * ret_pitch, void * output_pixels, int type_size, int output_w, int output_h, int output_stride_in_bytes, stbir_internal_pixel_layout pixel_layout)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (size_t size ; int pitch ; void* ptr ; pitch = output_w* type_size* stbir__pixel_channels [ pixel_layout ] ;)",
    "insertText": "if(pitch == 0)"
  },
  {
    "label": "size()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "size(size_t)output_stride_in_bytes * (size_t)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (* ret_ptr = 0 ;* ret_pitch = output_stride_in_bytes ;)",
    "insertText": "if(output_pixels == 0)"
  },
  {
    "label": "STBIR_MALLOC()",
    "kind": "Method",
    "detail": "Function (ptr =)",
    "insertText": "STBIR_MALLOC(size, 0)"
  },
  {
    "label": "stbir_resize_uint8_linear()",
    "kind": "Method",
    "detail": "Function (* ret_ptr = ptr ;* ret_pitch = pitch ; } return 1 ; } STBIRDEF unsigned char*)",
    "insertText": "stbir_resize_uint8_linear(const unsigned char *input_pixels , int input_w , int input_h, int input_stride_in_bytes, unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes, stbir_pixel_layout pixel_layout)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (STBIR_RESIZE resize ; unsigned char* optr ; int opitch ;)",
    "insertText": "if(!stbir__check_output_stuff( (void**)&optr, &opitch, output_pixels, sizeof( unsigned char ), output_w, output_h, output_stride_in_bytes, stbir__pixel_layout_convert_public_to_internal[ pixel_layout ] ))"
  },
  {
    "label": "stbir_resize_init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir_resize_init(&resize, input_pixels, input_w, input_h, input_stride_in_bytes, (optr) ? optr : output_pixels, output_w, output_h, opitch, pixel_layout, STBIR_TYPE_UINT8)"
  },
  {
    "label": "stbir_resize_uint8_srgb()",
    "kind": "Method",
    "detail": "Function (} STBIRDEF unsigned char*)",
    "insertText": "stbir_resize_uint8_srgb(const unsigned char *input_pixels , int input_w , int input_h, int input_stride_in_bytes, unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes, stbir_pixel_layout pixel_layout)"
  },
  {
    "label": "stbir_resize_init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir_resize_init(&resize, input_pixels, input_w, input_h, input_stride_in_bytes, (optr) ? optr : output_pixels, output_w, output_h, opitch, pixel_layout, STBIR_TYPE_UINT8_SRGB)"
  },
  {
    "label": "stbir_resize_float_linear()",
    "kind": "Method",
    "detail": "Function (} STBIRDEF float*)",
    "insertText": "stbir_resize_float_linear(const float *input_pixels , int input_w , int input_h, int input_stride_in_bytes, float *output_pixels, int output_w, int output_h, int output_stride_in_bytes, stbir_pixel_layout pixel_layout)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (STBIR_RESIZE resize ; float* optr ; int opitch ;)",
    "insertText": "if(!stbir__check_output_stuff( (void**)&optr, &opitch, output_pixels, sizeof( float ), output_w, output_h, output_stride_in_bytes, stbir__pixel_layout_convert_public_to_internal[ pixel_layout ] ))"
  },
  {
    "label": "stbir_resize_init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir_resize_init(&resize, input_pixels, input_w, input_h, input_stride_in_bytes, (optr) ? optr : output_pixels, output_w, output_h, opitch, pixel_layout, STBIR_TYPE_FLOAT)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (STBIR_RESIZE resize ; float* optr ; int opitch ;)",
    "insertText": "if(!stbir__check_output_stuff( (void**)&optr, &opitch, output_pixels, stbir__type_size[data_type], output_w, output_h, output_stride_in_bytes, stbir__pixel_layout_convert_public_to_internal[ pixel_layout ] ))"
  },
  {
    "label": "stbir_resize_init()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir_resize_init(&resize, input_pixels, input_w, input_h, input_stride_in_bytes, (optr) ? optr : output_pixels, output_w, output_h, output_stride_in_bytes, pixel_layout, data_type)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (resize . horizontal_edge = edge ; resize . vertical_edge = edge ; resize . horizontal_filter = filter ; resize . vertical_filter = filter ;)",
    "insertText": "if(!stbir_resize_extended( &resize ))"
  },
  {
    "label": "stbir_resize_build_profile_info()",
    "kind": "Method",
    "detail": "Function (} # ifdef STBIR_PROFILE STBIRDEF void)",
    "insertText": "stbir_resize_build_profile_info(STBIR_PROFILE_INFO * info, STBIR_RESIZE const * resize)"
  },
  {
    "label": "testa()",
    "kind": "Method",
    "detail": "Function (char const* bdescriptions [ 6 ] = { \" Building \",\" Allocating \",\" Horizontal sampler \",\" Vertical sampler \",\" Coefficient cleanup \",\" Coefficient piovot \" } ; stbir__info* samp = resize -> samplers ; int i ; typedef int)",
    "insertText": "testa(STBIR__ARRAY_SIZE( bdescriptions ) == (STBIR__ARRAY_SIZE( samp->profile.array )-1))"
  },
  {
    "label": "testb()",
    "kind": "Method",
    "detail": "Function (typedef int)",
    "insertText": "testb(sizeof( samp->profile.array ) == (sizeof(samp->profile.named)))"
  },
  {
    "label": "testc()",
    "kind": "Method",
    "detail": "Function (typedef int)",
    "insertText": "testc(sizeof( info->clocks ) >= (sizeof(samp->profile.named)))"
  },
  {
    "label": "STBIR__ARRAY_SIZE()",
    "kind": "Method",
    "detail": "Function (info -> total_clocks = samp -> profile . named . total ; info -> descriptions = bdescriptions ; info -> count =)",
    "insertText": "STBIR__ARRAY_SIZE(bdescriptions)"
  },
  {
    "label": "stbir_resize_split_profile_info()",
    "kind": "Method",
    "detail": "Function (} STBIRDEF void)",
    "insertText": "stbir_resize_split_profile_info(STBIR_PROFILE_INFO * info, STBIR_RESIZE const * resize, int split_start, int split_count)"
  },
  {
    "label": "testa()",
    "kind": "Method",
    "detail": "Function (char const* descriptions [ 7 ] = { \" Looping \",\" Vertical sampling \",\" Horizontal sampling \",\" Scanline input \",\" Scanline output \",\" Alpha weighting \",\" Alpha unweighting \" } ; stbir__per_split_info* split_info ; int s,i ; typedef int)",
    "insertText": "testa(STBIR__ARRAY_SIZE( descriptions ) == (STBIR__ARRAY_SIZE( split_info->profile.array )-1))"
  },
  {
    "label": "testb()",
    "kind": "Method",
    "detail": "Function (typedef int)",
    "insertText": "testb(sizeof( split_info->profile.array ) == (sizeof(split_info->profile.named)))"
  },
  {
    "label": "testc()",
    "kind": "Method",
    "detail": "Function (typedef int)",
    "insertText": "testc(sizeof( info->clocks ) >= (sizeof(split_info->profile.named)))"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (split_start = 0 ; split_count = resize -> samplers -> splits ; })",
    "insertText": "if(( split_start >= resize->splits ) || ( split_start < 0 ) || ( ( split_start + split_count ) > resize->splits ) || ( split_count <= 0 ))"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (info -> total_clocks = 0 ; info -> descriptions = 0 ; info -> count = 0 ; return ; } split_info = resize -> samplers -> split_info + split_start ;)",
    "insertText": "for(i = 0 ; i < STBIR__ARRAY_SIZE( descriptions ) ; i++)"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (stbir_uint64 sum = 0 ;)",
    "insertText": "for(s = 0 ; s < split_count ; s++)"
  },
  {
    "label": "STBIR__ARRAY_SIZE()",
    "kind": "Method",
    "detail": "Function (info -> clocks [ i ] = sum ; } info -> total_clocks = split_info -> profile . named . total ; info -> descriptions = descriptions ; info -> count =)",
    "insertText": "STBIR__ARRAY_SIZE(descriptions)"
  },
  {
    "label": "stbir_resize_extended_profile_info()",
    "kind": "Method",
    "detail": "Function (} STBIRDEF void)",
    "insertText": "stbir_resize_extended_profile_info(STBIR_PROFILE_INFO * info, STBIR_RESIZE const * resize)"
  },
  {
    "label": "stbir_resize_split_profile_info()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir_resize_split_profile_info(info, resize, -1, 0)"
  },
  {
    "label": "STBIR_strs_join2()",
    "kind": "Method",
    "detail": "Function (} # endif # undef STBIR_BGR # undef STBIR_1CHANNEL # undef STBIR_2CHANNEL # undef STBIR_RGB # undef STBIR_RGBA # undef STBIR_4CHANNEL # undef STBIR_BGRA # undef STBIR_ARGB # undef STBIR_ABGR # undef STBIR_RA # undef STBIR_AR # undef STBIR_RGBA_PM # undef STBIR_BGRA_PM # undef STBIR_ARGB_PM # undef STBIR_ABGR_PM # undef STBIR_RA_PM # undef STBIR_AR_PM # endif # else # define)",
    "insertText": "STBIR_strs_join2(start, mid, end ) start##mid##end #define STBIR_strs_join1( start, mid, end ) STBIR_strs_join2( start, mid, end ) #define STBIR_strs_join24( start, mid1, mid2, end ) start##mid1##mid2##end #define STBIR_strs_join14( start, mid1, mid2, end ) STBIR_strs_join24( start, mid1, mid2, end ) #ifdef STB_IMAGE_RESIZE_DO_CODERS #ifdef stbir__decode_suffix #define STBIR__CODER_NAME( name ) STBIR_strs_join1( name, _, stbir__decode_suffix ) #else #define STBIR__CODER_NAME( name ) name #endif #ifdef stbir__decode_swizzle #define stbir__decode_simdf8_flip(reg) STBIR_strs_join1( STBIR_strs_join1( STBIR_strs_join1( STBIR_strs_join1( stbir__simdf8_0123to,stbir__decode_order0,stbir__decode_order1),stbir__decode_order2,stbir__decode_order3),stbir__decode_order0,stbir__decode_order1),stbir__decode_order2,stbir__decode_order3)(reg, reg) #define stbir__decode_simdf4_flip(reg) STBIR_strs_join1( STBIR_strs_join1( stbir__simdf_0123to,stbir__decode_order0,stbir__decode_order1),stbir__decode_order2,stbir__decode_order3)(reg, reg) #define stbir__encode_simdf8_unflip(reg) STBIR_strs_join1( STBIR_strs_join1( STBIR_strs_join1( STBIR_strs_join1( stbir__simdf8_0123to,stbir__encode_order0,stbir__encode_order1),stbir__encode_order2,stbir__encode_order3),stbir__encode_order0,stbir__encode_order1),stbir__encode_order2,stbir__encode_order3)(reg, reg) #define stbir__encode_simdf4_unflip(reg) STBIR_strs_join1( STBIR_strs_join1( stbir__simdf_0123to,stbir__encode_order0,stbir__encode_order1),stbir__encode_order2,stbir__encode_order3)(reg, reg) #else #define stbir__decode_order0 0 #define stbir__decode_order1 1 #define stbir__decode_order2 2 #define stbir__decode_order3 3 #define stbir__encode_order0 0 #define stbir__encode_order1 1 #define stbir__encode_order2 2 #define stbir__encode_order3 3 #define stbir__decode_simdf8_flip(reg) #define stbir__decode_simdf4_flip(reg) #define stbir__encode_simdf8_unflip(reg) #define stbir__encode_simdf4_unflip(reg) #endif #ifdef STBIR_SIMD8 #define stbir__encode_simdfX_unflip stbir__encode_simdf8_unflip #else #define stbir__encode_simdfX_unflip stbir__encode_simdf4_unflip #endif static void STBIR__CODER_NAME( stbir__decode_uint8_linear_scaled )( float * decodep, int width_times_channels, void const * inputp)"
  },
  {
    "label": "decode_end()",
    "kind": "Method",
    "detail": "Function (float*)",
    "insertText": "decode_end(float*)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (unsigned char const*)",
    "insertText": "input(unsigned char const*)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIR_SIMD unsigned char const* end_input_m16 = input + width_times_channels - 1 6 ;)",
    "insertText": "if(width_times_channels >= 16)"
  },
  {
    "label": "stbir__simdi_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_load(i, input)"
  },
  {
    "label": "stbir__simdi8_expand_u8_to_u32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi8_expand_u8_to_u32(o0, o1, i)"
  },
  {
    "label": "stbir__simdi8_convert_i32_to_float()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi8_convert_i32_to_float(of0, o0)"
  },
  {
    "label": "stbir__simdi8_convert_i32_to_float()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi8_convert_i32_to_float(of1, o1)"
  },
  {
    "label": "stbir__simdf8_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_mult(of0, of0, STBIR_max_uint8_as_float_inverted8)"
  },
  {
    "label": "stbir__simdf8_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_mult(of1, of1, STBIR_max_uint8_as_float_inverted8)"
  },
  {
    "label": "stbir__decode_simdf8_flip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__decode_simdf8_flip(of0)"
  },
  {
    "label": "stbir__decode_simdf8_flip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__decode_simdf8_flip(of1)"
  },
  {
    "label": "stbir__simdf8_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_store(decode + 0, of0)"
  },
  {
    "label": "stbir__simdf8_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_store(decode + 8, of1)"
  },
  {
    "label": "stbir__simdi_expand_u8_to_u32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_expand_u8_to_u32(o0,o1,o2,o3,i)"
  },
  {
    "label": "stbir__simdi_convert_i32_to_float()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_convert_i32_to_float(of0, o0)"
  },
  {
    "label": "stbir__simdi_convert_i32_to_float()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_convert_i32_to_float(of1, o1)"
  },
  {
    "label": "stbir__simdi_convert_i32_to_float()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_convert_i32_to_float(of2, o2)"
  },
  {
    "label": "stbir__simdi_convert_i32_to_float()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_convert_i32_to_float(of3, o3)"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(of0, of0, STBIR__CONSTF(STBIR_max_uint8_as_float_inverted))"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(of1, of1, STBIR__CONSTF(STBIR_max_uint8_as_float_inverted))"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(of2, of2, STBIR__CONSTF(STBIR_max_uint8_as_float_inverted))"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(of3, of3, STBIR__CONSTF(STBIR_max_uint8_as_float_inverted))"
  },
  {
    "label": "stbir__decode_simdf4_flip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__decode_simdf4_flip(of0)"
  },
  {
    "label": "stbir__decode_simdf4_flip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__decode_simdf4_flip(of1)"
  },
  {
    "label": "stbir__decode_simdf4_flip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__decode_simdf4_flip(of2)"
  },
  {
    "label": "stbir__decode_simdf4_flip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__decode_simdf4_flip(of3)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(decode + 0, of0)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(decode + 4, of1)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(decode + 8, of2)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(decode + 12, of3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif decode + = 1 6 ; input + = 1 6 ;)",
    "insertText": "if(decode <= decode_end)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (decode = decode_end ; input = end_input_m16 ; } return ; } # endif # if stbir__coder_min_num ! = 3 decode + = 4 ;)",
    "insertText": "while(decode <= decode_end)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decode((float)(input[stbir__decode_order0]))"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decode((float)(input[stbir__decode_order1]))"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decode((float)(input[stbir__decode_order2]))"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "decode((float)(input[stbir__decode_order3]))"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (decode + = 4 ; input + = 4 ; } decode - = 4 ; # endif # if stbir__coder_min_num<4)",
    "insertText": "while(decode < decode_end)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (# endif decode + = stbir__coder_min_num ; input + = stbir__coder_min_num ; } # endif } void)",
    "insertText": "STBIR__CODER_NAME(stbir__encode_uint8_linear_scaled )( void * outputp, int width_times_channels, float const * encode)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (unsigned char)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(* ) output = (unsigned char *)"
  },
  {
    "label": "end_output()",
    "kind": "Method",
    "detail": "Function (unsigned char*)",
    "insertText": "end_output((unsigned char *) output)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIR_SIMD)",
    "insertText": "if(width_times_channels >= stbir__simdfX_float_count*2)"
  },
  {
    "label": "stbir__simdfX_madd_mem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_madd_mem(e0, STBIR_simd_point5X, STBIR_max_uint8_as_floatX, encode)"
  },
  {
    "label": "stbir__simdfX_madd_mem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_madd_mem(e1, STBIR_simd_point5X, STBIR_max_uint8_as_floatX, encode+stbir__simdfX_float_count)"
  },
  {
    "label": "stbir__encode_simdfX_unflip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__encode_simdfX_unflip(e0)"
  },
  {
    "label": "stbir__encode_simdfX_unflip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__encode_simdfX_unflip(e1)"
  },
  {
    "label": "stbir__simdf8_pack_to_16bytes()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIR_SIMD8)",
    "insertText": "stbir__simdf8_pack_to_16bytes(i, e0, e1)"
  },
  {
    "label": "stbir__simdi_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_store(output, i)"
  },
  {
    "label": "stbir__simdf_pack_to_8bytes()",
    "kind": "Method",
    "detail": "Function (# else)",
    "insertText": "stbir__simdf_pack_to_8bytes(i, e0, e1)"
  },
  {
    "label": "stbir__simdi_store2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_store2(output, i)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif encode + = stbir__simdfX_float_count* 2 ; output + = stbir__simdfX_float_count* 2 ;)",
    "insertText": "if(output <= end_output)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (output = end_output ; encode = end_encode_m8 ; } return ; } # if stbir__coder_min_num ! = 3 output + = 4 ;)",
    "insertText": "while(output <= end_output)"
  },
  {
    "label": "STBIR_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (stbir__simdf e0 ; stbir__simdi i0 ;)",
    "insertText": "STBIR_NO_UNROLL(encode)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(e0, encode)"
  },
  {
    "label": "stbir__simdf_madd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_madd(e0, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint8_as_float), e0)"
  },
  {
    "label": "stbir__encode_simdf4_unflip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__encode_simdf4_unflip(e0)"
  },
  {
    "label": "stbir__simdf_pack_to_8bytes()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_pack_to_8bytes(i0, e0, e0)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (output + = 4 ; encode + = 4 ; } output - = 4 ; # endif # if stbir__coder_min_num<4)",
    "insertText": "while(output < end_output)"
  },
  {
    "label": "stbir__simdf_madd1_mem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_madd1_mem(e0, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint8_as_float), encode+stbir__encode_order0)"
  },
  {
    "label": "stbir__simdf_convert_float_to_uint8()",
    "kind": "Method",
    "detail": "Function (output [ 0 ] =)",
    "insertText": "stbir__simdf_convert_float_to_uint8(e0)"
  },
  {
    "label": "stbir__simdf_madd1_mem()",
    "kind": "Method",
    "detail": "Function (# if stbir__coder_min_num> = 2)",
    "insertText": "stbir__simdf_madd1_mem(e0, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint8_as_float), encode+stbir__encode_order1)"
  },
  {
    "label": "stbir__simdf_madd1_mem()",
    "kind": "Method",
    "detail": "Function (# endif # if stbir__coder_min_num> = 3)",
    "insertText": "stbir__simdf_madd1_mem(e0, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint8_as_float), encode+stbir__encode_order2)"
  },
  {
    "label": "STBIR_CLAMP()",
    "kind": "Method",
    "detail": "Function (float f ; f = encode [ stbir__encode_order0 ]* stbir__max_uint8_as_float + 0 . 5 f ;)",
    "insertText": "STBIR_CLAMP(f, 0, 255)"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "output(unsigned char)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (# endif output + = stbir__coder_min_num ; encode + = stbir__coder_min_num ; } # endif # endif } void)",
    "insertText": "STBIR__CODER_NAME(stbir__decode_uint8_linear)( float * decodep, int width_times_channels, void const * inputp)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (# endif decode + = stbir__coder_min_num ; input + = stbir__coder_min_num ; } # endif } void)",
    "insertText": "STBIR__CODER_NAME(stbir__encode_uint8_linear )( void * outputp, int width_times_channels, float const * encode)"
  },
  {
    "label": "stbir__simdfX_add_mem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_add_mem(e0, STBIR_simd_point5X, encode)"
  },
  {
    "label": "stbir__simdfX_add_mem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_add_mem(e1, STBIR_simd_point5X, encode+stbir__simdfX_float_count)"
  },
  {
    "label": "stbir__simdf_add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_add(e0, STBIR__CONSTF(STBIR_simd_point5), e0)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (# endif output + = stbir__coder_min_num ; encode + = stbir__coder_min_num ; } # endif } void)",
    "insertText": "STBIR__CODER_NAME(stbir__decode_uint8_srgb)( float * decodep, int width_times_channels, void const * inputp)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (unsigned char const*)",
    "insertText": "input(unsigned char const *)"
  },
  {
    "label": "stbir__min_max_shift20()",
    "kind": "Method",
    "detail": "Function (decode [ 0 ] = stbir__srgb_uchar_to_linear_float [ input [ stbir__decode_order0 ] ] ; # if stbir__coder_min_num> = 2 decode [ 1 ] = stbir__srgb_uchar_to_linear_float [ input [ stbir__decode_order1 ] ] ; # endif # if stbir__coder_min_num> = 3 decode [ 2 ] = stbir__srgb_uchar_to_linear_float [ input [ stbir__decode_order2 ] ] ; # endif decode + = stbir__coder_min_num ; input + = stbir__coder_min_num ; } # endif } # define)",
    "insertText": "stbir__min_max_shift20(i, f ) \\ stbir__simdf_max( f, f, stbir_simdf_casti(STBIR__CONSTI( STBIR_almost_zero )))"
  },
  {
    "label": "stbir__simdf_min()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_min(f, f, stbir_simdf_casti(STBIR__CONSTI( STBIR_almost_one )))"
  },
  {
    "label": "stbir__simdi_32shr()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdi_32shr(i, stbir_simdi_castf( f ), 20)"
  },
  {
    "label": "stbir__scale_and_convert()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__scale_and_convert(i, f ) \\ stbir__simdf_madd( f, STBIR__CONSTF( STBIR_simd_point5 ), STBIR__CONSTF( STBIR_max_uint8_as_float ), f)"
  },
  {
    "label": "stbir__simdf_max()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_max(f, f, stbir__simdf_zeroP())"
  },
  {
    "label": "stbir__simdf_min()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_min(f, f, STBIR__CONSTF( STBIR_max_uint8_as_float ))"
  },
  {
    "label": "stbir__simdf_convert_float_to_i32()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdf_convert_float_to_i32(i, f)"
  },
  {
    "label": "stbir__linear_to_srgb_finish()",
    "kind": "Method",
    "detail": "Function (# define)",
    "insertText": "stbir__linear_to_srgb_finish(i, f)"
  },
  {
    "label": "stbir__simdi_32shr()",
    "kind": "Method",
    "detail": "Function (\\ stbir__simdi temp ; \\)",
    "insertText": "stbir__simdi_32shr(temp, stbir_simdi_castf( f ), 12)"
  },
  {
    "label": "stbir__simdi_and()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdi_and(temp, temp, STBIR__CONSTI(STBIR_mastissa_mask))"
  },
  {
    "label": "stbir__simdi_or()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdi_or(temp, temp, STBIR__CONSTI(STBIR_topscale))"
  },
  {
    "label": "stbir__simdi_16madd()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdi_16madd(i, i, temp)"
  },
  {
    "label": "stbir__simdi_32shr()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__simdi_32shr(i, i, 16)"
  },
  {
    "label": "stbir__simdi_table_lookup2()",
    "kind": "Method",
    "detail": "Function (\\ } # define)",
    "insertText": "stbir__simdi_table_lookup2(v0,v1, table)"
  },
  {
    "label": "stbir__simdi_table_lookup3()",
    "kind": "Method",
    "detail": "Function (\\ stbir__simdi_u32 temp0,temp1 ; \\ temp0 . m128i_i128 = v0 ; \\ temp1 . m128i_i128 = v1 ; \\ temp0 . m128i_u32 [ 0 ] = table [ temp0 . m128i_i32 [ 0 ] ] ; temp0 . m128i_u32 [ 1 ] = table [ temp0 . m128i_i32 [ 1 ] ] ; temp0 . m128i_u32 [ 2 ] = table [ temp0 . m128i_i32 [ 2 ] ] ; temp0 . m128i_u32 [ 3 ] = table [ temp0 . m128i_i32 [ 3 ] ] ; \\ temp1 . m128i_u32 [ 0 ] = table [ temp1 . m128i_i32 [ 0 ] ] ; temp1 . m128i_u32 [ 1 ] = table [ temp1 . m128i_i32 [ 1 ] ] ; temp1 . m128i_u32 [ 2 ] = table [ temp1 . m128i_i32 [ 2 ] ] ; temp1 . m128i_u32 [ 3 ] = table [ temp1 . m128i_i32 [ 3 ] ] ; \\ v0 = temp0 . m128i_i128 ; \\ v1 = temp1 . m128i_i128 ; \\ } # define)",
    "insertText": "stbir__simdi_table_lookup3(v0,v1,v2, table)"
  },
  {
    "label": "stbir__simdi_table_lookup4()",
    "kind": "Method",
    "detail": "Function (\\ stbir__simdi_u32 temp0,temp1,temp2 ; \\ temp0 . m128i_i128 = v0 ; \\ temp1 . m128i_i128 = v1 ; \\ temp2 . m128i_i128 = v2 ; \\ temp0 . m128i_u32 [ 0 ] = table [ temp0 . m128i_i32 [ 0 ] ] ; temp0 . m128i_u32 [ 1 ] = table [ temp0 . m128i_i32 [ 1 ] ] ; temp0 . m128i_u32 [ 2 ] = table [ temp0 . m128i_i32 [ 2 ] ] ; temp0 . m128i_u32 [ 3 ] = table [ temp0 . m128i_i32 [ 3 ] ] ; \\ temp1 . m128i_u32 [ 0 ] = table [ temp1 . m128i_i32 [ 0 ] ] ; temp1 . m128i_u32 [ 1 ] = table [ temp1 . m128i_i32 [ 1 ] ] ; temp1 . m128i_u32 [ 2 ] = table [ temp1 . m128i_i32 [ 2 ] ] ; temp1 . m128i_u32 [ 3 ] = table [ temp1 . m128i_i32 [ 3 ] ] ; \\ temp2 . m128i_u32 [ 0 ] = table [ temp2 . m128i_i32 [ 0 ] ] ; temp2 . m128i_u32 [ 1 ] = table [ temp2 . m128i_i32 [ 1 ] ] ; temp2 . m128i_u32 [ 2 ] = table [ temp2 . m128i_i32 [ 2 ] ] ; temp2 . m128i_u32 [ 3 ] = table [ temp2 . m128i_i32 [ 3 ] ] ; \\ v0 = temp0 . m128i_i128 ; \\ v1 = temp1 . m128i_i128 ; \\ v2 = temp2 . m128i_i128 ; \\ } # define)",
    "insertText": "stbir__simdi_table_lookup4(v0,v1,v2,v3, table)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (\\ stbir__simdi_u32 temp0,temp1,temp2,temp3 ; \\ temp0 . m128i_i128 = v0 ; \\ temp1 . m128i_i128 = v1 ; \\ temp2 . m128i_i128 = v2 ; \\ temp3 . m128i_i128 = v3 ; \\ temp0 . m128i_u32 [ 0 ] = table [ temp0 . m128i_i32 [ 0 ] ] ; temp0 . m128i_u32 [ 1 ] = table [ temp0 . m128i_i32 [ 1 ] ] ; temp0 . m128i_u32 [ 2 ] = table [ temp0 . m128i_i32 [ 2 ] ] ; temp0 . m128i_u32 [ 3 ] = table [ temp0 . m128i_i32 [ 3 ] ] ; \\ temp1 . m128i_u32 [ 0 ] = table [ temp1 . m128i_i32 [ 0 ] ] ; temp1 . m128i_u32 [ 1 ] = table [ temp1 . m128i_i32 [ 1 ] ] ; temp1 . m128i_u32 [ 2 ] = table [ temp1 . m128i_i32 [ 2 ] ] ; temp1 . m128i_u32 [ 3 ] = table [ temp1 . m128i_i32 [ 3 ] ] ; \\ temp2 . m128i_u32 [ 0 ] = table [ temp2 . m128i_i32 [ 0 ] ] ; temp2 . m128i_u32 [ 1 ] = table [ temp2 . m128i_i32 [ 1 ] ] ; temp2 . m128i_u32 [ 2 ] = table [ temp2 . m128i_i32 [ 2 ] ] ; temp2 . m128i_u32 [ 3 ] = table [ temp2 . m128i_i32 [ 3 ] ] ; \\ temp3 . m128i_u32 [ 0 ] = table [ temp3 . m128i_i32 [ 0 ] ] ; temp3 . m128i_u32 [ 1 ] = table [ temp3 . m128i_i32 [ 1 ] ] ; temp3 . m128i_u32 [ 2 ] = table [ temp3 . m128i_i32 [ 2 ] ] ; temp3 . m128i_u32 [ 3 ] = table [ temp3 . m128i_i32 [ 3 ] ] ; \\ v0 = temp0 . m128i_i128 ; \\ v1 = temp1 . m128i_i128 ; \\ v2 = temp2 . m128i_i128 ; \\ v3 = temp3 . m128i_i128 ; \\ } void)",
    "insertText": "STBIR__CODER_NAME(stbir__encode_uint8_srgb )( void * outputp, int width_times_channels, float const * encode)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (unsigned char)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(* ) output = (unsigned char*)"
  },
  {
    "label": "end_output()",
    "kind": "Method",
    "detail": "Function (unsigned char*)",
    "insertText": "end_output((unsigned char*) output)"
  },
  {
    "label": "stbir__simdf_load4_transposed()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load4_transposed(f0, f1, f2, f3, encode)"
  },
  {
    "label": "stbir__min_max_shift20()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__min_max_shift20(i0, f0)"
  },
  {
    "label": "stbir__min_max_shift20()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__min_max_shift20(i1, f1)"
  },
  {
    "label": "stbir__min_max_shift20()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__min_max_shift20(i2, f2)"
  },
  {
    "label": "stbir__min_max_shift20()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__min_max_shift20(i3, f3)"
  },
  {
    "label": "stbir__simdi_table_lookup4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_table_lookup4(i0, i1, i2, i3, ( fp32_to_srgb8_tab4 - (127-13)*8 ))"
  },
  {
    "label": "stbir__linear_to_srgb_finish()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__linear_to_srgb_finish(i0, f0)"
  },
  {
    "label": "stbir__linear_to_srgb_finish()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__linear_to_srgb_finish(i1, f1)"
  },
  {
    "label": "stbir__linear_to_srgb_finish()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__linear_to_srgb_finish(i2, f2)"
  },
  {
    "label": "stbir__linear_to_srgb_finish()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__linear_to_srgb_finish(i3, f3)"
  },
  {
    "label": "stbir__interleave_pack_and_store_16_u8()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__interleave_pack_and_store_16_u8(output, STBIR_strs_join1(i, ,stbir__encode_order0), STBIR_strs_join1(i, ,stbir__encode_order1), STBIR_strs_join1(i, ,stbir__encode_order2), STBIR_strs_join1(i, ,stbir__encode_order3))"
  },
  {
    "label": "stbir__linear_to_srgb_uchar()",
    "kind": "Method",
    "detail": "Function (output [ 0 - 4 ] =)",
    "insertText": "stbir__linear_to_srgb_uchar(encode[stbir__encode_order0])"
  },
  {
    "label": "stbir__linear_to_srgb_uchar()",
    "kind": "Method",
    "detail": "Function (output [ 1 - 4 ] =)",
    "insertText": "stbir__linear_to_srgb_uchar(encode[stbir__encode_order1])"
  },
  {
    "label": "stbir__linear_to_srgb_uchar()",
    "kind": "Method",
    "detail": "Function (output [ 2 - 4 ] =)",
    "insertText": "stbir__linear_to_srgb_uchar(encode[stbir__encode_order2])"
  },
  {
    "label": "stbir__linear_to_srgb_uchar()",
    "kind": "Method",
    "detail": "Function (output [ 3 - 4 ] =)",
    "insertText": "stbir__linear_to_srgb_uchar(encode[stbir__encode_order3])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif output + = stbir__coder_min_num ; encode + = stbir__coder_min_num ; } # endif } #)",
    "insertText": "if(stbir__coder_min_num == 4 ) || ( ( stbir__coder_min_num == 1 ) && ( !defined(stbir__decode_swizzle) ) ) static void STBIR__CODER_NAME(stbir__decode_uint8_srgb4_linearalpha)( float * decodep, int width_times_channels, void const * inputp)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR__CODER_NAME(stbir__encode_uint8_srgb4_linearalpha )( void * outputp, int width_times_channels, float const * encode)"
  },
  {
    "label": "stbir__scale_and_convert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__scale_and_convert(i3, f3)"
  },
  {
    "label": "stbir__simdi_table_lookup3()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_table_lookup3(i0, i1, i2, ( fp32_to_srgb8_tab4 - (127-13)*8 ))"
  },
  {
    "label": "stbir__linear_to_srgb_uchar()",
    "kind": "Method",
    "detail": "Function (output [ stbir__decode_order0 ] =)",
    "insertText": "stbir__linear_to_srgb_uchar(encode[0])"
  },
  {
    "label": "stbir__linear_to_srgb_uchar()",
    "kind": "Method",
    "detail": "Function (output [ stbir__decode_order1 ] =)",
    "insertText": "stbir__linear_to_srgb_uchar(encode[1])"
  },
  {
    "label": "stbir__linear_to_srgb_uchar()",
    "kind": "Method",
    "detail": "Function (output [ stbir__decode_order2 ] =)",
    "insertText": "stbir__linear_to_srgb_uchar(encode[2])"
  },
  {
    "label": "stbir__decode_order3()",
    "kind": "Method",
    "detail": "Function (output [)",
    "insertText": "stbir__decode_order3(unsigned char)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (} # endif #)",
    "insertText": "if(stbir__coder_min_num == 2 ) || ( ( stbir__coder_min_num == 1 ) && ( !defined(stbir__decode_swizzle) ) ) static void STBIR__CODER_NAME(stbir__decode_uint8_srgb2_linearalpha)( float * decodep, int width_times_channels, void const * inputp)"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (decode [ 0 - 4 ] = stbir__srgb_uchar_to_linear_float [ input [ stbir__decode_order0 ] ] ;)",
    "insertText": "decode((float) input[stbir__decode_order1])"
  },
  {
    "label": "decode()",
    "kind": "Method",
    "detail": "Function (decode [ 2 - 4 ] = stbir__srgb_uchar_to_linear_float [ input [ stbir__decode_order0 + 2 ] ] ;)",
    "insertText": "decode((float) input[stbir__decode_order1+2])"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (input + = 4 ; decode + = 4 ; } decode - = 4 ;)",
    "insertText": "if(decode < decode_end)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (} } void)",
    "insertText": "STBIR__CODER_NAME(stbir__encode_uint8_srgb2_linearalpha )( void * outputp, int width_times_channels, float const * encode)"
  },
  {
    "label": "stbir__scale_and_convert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__scale_and_convert(i1, f1)"
  },
  {
    "label": "stbir__simdi_table_lookup2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_table_lookup2(i0, i2, ( fp32_to_srgb8_tab4 - (127-13)*8 ))"
  },
  {
    "label": "stbir__decode_order1()",
    "kind": "Method",
    "detail": "Function (output [)",
    "insertText": "stbir__decode_order1(unsigned char)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (} # endif void)",
    "insertText": "STBIR__CODER_NAME(stbir__decode_uint16_linear_scaled)( float * decodep, int width_times_channels, void const * inputp)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (unsigned short const*)",
    "insertText": "input(unsigned short const *)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIR_SIMD unsigned short const* end_input_m8 = input + width_times_channels - 8 ;)",
    "insertText": "if(width_times_channels >= 8)"
  },
  {
    "label": "stbir__simdi8_expand_u16_to_u32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi8_expand_u16_to_u32(o, i)"
  },
  {
    "label": "stbir__simdi8_convert_i32_to_float()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi8_convert_i32_to_float(of, o)"
  },
  {
    "label": "stbir__simdf8_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_mult(of, of, STBIR_max_uint16_as_float_inverted8)"
  },
  {
    "label": "stbir__decode_simdf8_flip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__decode_simdf8_flip(of)"
  },
  {
    "label": "stbir__simdf8_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_store(decode + 0, of)"
  },
  {
    "label": "stbir__simdi_expand_u16_to_u32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_expand_u16_to_u32(o0,o1,i)"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(of0, of0, STBIR__CONSTF(STBIR_max_uint16_as_float_inverted))"
  },
  {
    "label": "stbir__simdf_mult()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_mult(of1, of1, STBIR__CONSTF(STBIR_max_uint16_as_float_inverted))"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (# endif decode + = stbir__coder_min_num ; input + = stbir__coder_min_num ; } # endif } void)",
    "insertText": "STBIR__CODER_NAME(stbir__encode_uint16_linear_scaled)( void * outputp, int width_times_channels, float const * encode)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (unsigned short)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(* ) output = (unsigned short*)"
  },
  {
    "label": "end_output()",
    "kind": "Method",
    "detail": "Function (unsigned short*)",
    "insertText": "end_output((unsigned short*) output)"
  },
  {
    "label": "stbir__simdfX_madd_mem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_madd_mem(e0, STBIR_simd_point5X, STBIR_max_uint16_as_floatX, encode)"
  },
  {
    "label": "stbir__simdfX_madd_mem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_madd_mem(e1, STBIR_simd_point5X, STBIR_max_uint16_as_floatX, encode+stbir__simdfX_float_count)"
  },
  {
    "label": "stbir__simdfX_pack_to_words()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_pack_to_words(i, e0, e1)"
  },
  {
    "label": "stbir__simdiX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdiX_store(output, i)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(e, encode)"
  },
  {
    "label": "stbir__simdf_madd()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_madd(e, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint16_as_float), e)"
  },
  {
    "label": "stbir__encode_simdf4_unflip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__encode_simdf4_unflip(e)"
  },
  {
    "label": "stbir__simdf_pack_to_8words()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_pack_to_8words(i, e, e)"
  },
  {
    "label": "stbir__simdi_store2()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_store2(output-4, i)"
  },
  {
    "label": "stbir__simdf_madd1_mem()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_madd1_mem(e, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint16_as_float), encode+stbir__encode_order0)"
  },
  {
    "label": "stbir__simdf_convert_float_to_short()",
    "kind": "Method",
    "detail": "Function (output [ 0 ] =)",
    "insertText": "stbir__simdf_convert_float_to_short(e)"
  },
  {
    "label": "stbir__simdf_madd1_mem()",
    "kind": "Method",
    "detail": "Function (# if stbir__coder_min_num> = 2)",
    "insertText": "stbir__simdf_madd1_mem(e, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint16_as_float), encode+stbir__encode_order1)"
  },
  {
    "label": "stbir__simdf_madd1_mem()",
    "kind": "Method",
    "detail": "Function (# endif # if stbir__coder_min_num> = 3)",
    "insertText": "stbir__simdf_madd1_mem(e, STBIR__CONSTF(STBIR_simd_point5), STBIR__CONSTF(STBIR_max_uint16_as_float), encode+stbir__encode_order2)"
  },
  {
    "label": "STBIR_CLAMP()",
    "kind": "Method",
    "detail": "Function (f = encode [ stbir__encode_order0 ]* stbir__max_uint16_as_float + 0 . 5 f ;)",
    "insertText": "STBIR_CLAMP(f, 0, 65535)"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "output(unsigned short)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (# endif output + = stbir__coder_min_num ; encode + = stbir__coder_min_num ; } # endif # endif } void)",
    "insertText": "STBIR__CODER_NAME(stbir__decode_uint16_linear)( float * decodep, int width_times_channels, void const * inputp)"
  },
  {
    "label": "stbir__simdi_expand_u16_to_u32()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdi_expand_u16_to_u32(o0, o1, i)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (# endif decode + = stbir__coder_min_num ; input + = stbir__coder_min_num ; } # endif } void)",
    "insertText": "STBIR__CODER_NAME(stbir__encode_uint16_linear)( void * outputp, int width_times_channels, float const * encode)"
  },
  {
    "label": "stbir__simdf_add()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_add(e, STBIR__CONSTF(STBIR_simd_point5), e)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (# endif output + = stbir__coder_min_num ; encode + = stbir__coder_min_num ; } # endif } void)",
    "insertText": "STBIR__CODER_NAME(stbir__decode_half_float_linear)( float * decodep, int width_times_channels, void const * inputp)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (stbir__FP16 const*)",
    "insertText": "input(stbir__FP16 const *)"
  },
  {
    "label": "stbir__half_to_float_SIMD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__half_to_float_SIMD(decode, input)"
  },
  {
    "label": "stbir__simdf8_load()",
    "kind": "Method",
    "detail": "Function (# ifdef stbir__decode_swizzle # ifdef STBIR_SIMD8 { stbir__simdf8 of ;)",
    "insertText": "stbir__simdf8_load(of, decode)"
  },
  {
    "label": "stbir__simdf8_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_store(decode, of)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (} # else { stbir__simdf of0,of1 ;)",
    "insertText": "stbir__simdf_load(of0, decode)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(of1, decode+4)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(decode, of0)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(decode+4, of1)"
  },
  {
    "label": "stbir__half_to_float()",
    "kind": "Method",
    "detail": "Function (decode [ 0 - 4 ] =)",
    "insertText": "stbir__half_to_float(input[stbir__decode_order0])"
  },
  {
    "label": "stbir__half_to_float()",
    "kind": "Method",
    "detail": "Function (decode [ 1 - 4 ] =)",
    "insertText": "stbir__half_to_float(input[stbir__decode_order1])"
  },
  {
    "label": "stbir__half_to_float()",
    "kind": "Method",
    "detail": "Function (decode [ 2 - 4 ] =)",
    "insertText": "stbir__half_to_float(input[stbir__decode_order2])"
  },
  {
    "label": "stbir__half_to_float()",
    "kind": "Method",
    "detail": "Function (decode [ 3 - 4 ] =)",
    "insertText": "stbir__half_to_float(input[stbir__decode_order3])"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (# endif decode + = stbir__coder_min_num ; input + = stbir__coder_min_num ; } # endif } void)",
    "insertText": "STBIR__CODER_NAME(stbir__encode_half_float_linear )( void * outputp, int width_times_channels, float const * encode)"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (stbir__FP16)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(* ) output = (stbir__FP16*)"
  },
  {
    "label": "end_output()",
    "kind": "Method",
    "detail": "Function (stbir__FP16*)",
    "insertText": "end_output((stbir__FP16*) output)"
  },
  {
    "label": "stbir__simdf8_load()",
    "kind": "Method",
    "detail": "Function (# ifdef stbir__decode_swizzle # ifdef STBIR_SIMD8 { stbir__simdf8 of ;)",
    "insertText": "stbir__simdf8_load(of, encode)"
  },
  {
    "label": "stbir__encode_simdf8_unflip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__encode_simdf8_unflip(of)"
  },
  {
    "label": "stbir__float_to_half_SIMD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__float_to_half_SIMD(output, (float*)&of)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (} # else { stbir__simdf of [ 2 ] ;)",
    "insertText": "stbir__simdf_load(of[0], encode)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(of[1], encode+4)"
  },
  {
    "label": "stbir__encode_simdf4_unflip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__encode_simdf4_unflip(of[0])"
  },
  {
    "label": "stbir__encode_simdf4_unflip()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__encode_simdf4_unflip(of[1])"
  },
  {
    "label": "stbir__float_to_half_SIMD()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__float_to_half_SIMD(output, (float*)of)"
  },
  {
    "label": "stbir__float_to_half_SIMD()",
    "kind": "Method",
    "detail": "Function (} # endif # else)",
    "insertText": "stbir__float_to_half_SIMD(output, encode)"
  },
  {
    "label": "STBIR_SIMD_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_SIMD_NO_UNROLL(output)"
  },
  {
    "label": "stbir__float_to_half()",
    "kind": "Method",
    "detail": "Function (output [ 0 - 4 ] =)",
    "insertText": "stbir__float_to_half(encode[stbir__encode_order0])"
  },
  {
    "label": "stbir__float_to_half()",
    "kind": "Method",
    "detail": "Function (output [ 1 - 4 ] =)",
    "insertText": "stbir__float_to_half(encode[stbir__encode_order1])"
  },
  {
    "label": "stbir__float_to_half()",
    "kind": "Method",
    "detail": "Function (output [ 2 - 4 ] =)",
    "insertText": "stbir__float_to_half(encode[stbir__encode_order2])"
  },
  {
    "label": "stbir__float_to_half()",
    "kind": "Method",
    "detail": "Function (output [ 3 - 4 ] =)",
    "insertText": "stbir__float_to_half(encode[stbir__encode_order3])"
  },
  {
    "label": "STBIR_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_NO_UNROLL(output)"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (# endif output + = stbir__coder_min_num ; encode + = stbir__coder_min_num ; } # endif } void)",
    "insertText": "STBIR__CODER_NAME(stbir__decode_float_linear)( float * decodep, int width_times_channels, void const * inputp)"
  },
  {
    "label": "input()",
    "kind": "Method",
    "detail": "Function (float const*)",
    "insertText": "input(float const *)"
  },
  {
    "label": "stbir__simdf8_load()",
    "kind": "Method",
    "detail": "Function (# ifdef stbir__decode_swizzle # ifdef STBIR_SIMD8 { stbir__simdf8 of0,of1 ;)",
    "insertText": "stbir__simdf8_load(of0, input)"
  },
  {
    "label": "stbir__simdf8_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_load(of1, input+8)"
  },
  {
    "label": "stbir__simdf8_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_store(decode, of0)"
  },
  {
    "label": "stbir__simdf8_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf8_store(decode+8, of1)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (} # else { stbir__simdf of0,of1,of2,of3 ;)",
    "insertText": "stbir__simdf_load(of0, input)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(of1, input+4)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(of2, input+8)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(of3, input+12)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(decode+8, of2)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(decode+12, of3)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (decode [ 0 ] = input [ stbir__decode_order0 ] ; # if stbir__coder_min_num> = 2 decode [ 1 ] = input [ stbir__decode_order1 ] ; # endif # if stbir__coder_min_num> = 3 decode [ 2 ] = input [ stbir__decode_order2 ] ; # endif decode + = stbir__coder_min_num ; input + = stbir__coder_min_num ; } # endif # else)",
    "insertText": "if((void*)decodep != inputp ) STBIR_MEMCPY( decodep, inputp, width_times_channels * sizeof( float ))"
  },
  {
    "label": "STBIR__CODER_NAME()",
    "kind": "Method",
    "detail": "Function (# endif } void)",
    "insertText": "STBIR__CODER_NAME(stbir__encode_float_linear )( void * outputp, int width_times_channels, float const * encode)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (# if !)",
    "insertText": "defined(STBIR_FLOAT_HIGH_CLAMP ) && !defined(STBIR_FLOAT_LO_CLAMP) && !defined(stbir__decode_swizzle) if ( (void*)outputp != (void*) encode ) STBIR_MEMCPY( outputp, encode, width_times_channels * sizeof( float ))"
  },
  {
    "label": "STBIR_SIMD_STREAMOUT_PTR()",
    "kind": "Method",
    "detail": "Function (# else float)",
    "insertText": "STBIR_SIMD_STREAMOUT_PTR(* ) output = (float*)"
  },
  {
    "label": "end_output()",
    "kind": "Method",
    "detail": "Function (float*)",
    "insertText": "end_output((float*) output)"
  },
  {
    "label": "stbir_scalar_hi_clamp()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIR_FLOAT_HIGH_CLAMP # define)",
    "insertText": "stbir_scalar_hi_clamp(v ) if ( v > STBIR_FLOAT_HIGH_CLAMP)"
  },
  {
    "label": "stbir_scalar_hi_clamp()",
    "kind": "Method",
    "detail": "Function (# else # define)",
    "insertText": "stbir_scalar_hi_clamp(v ) #endif #ifdef STBIR_FLOAT_LOW_CLAMP #define stbir_scalar_lo_clamp( v ) if ( v < STBIR_FLOAT_LOW_CLAMP)"
  },
  {
    "label": "stbir_scalar_lo_clamp()",
    "kind": "Method",
    "detail": "Function (# else # define)",
    "insertText": "stbir_scalar_lo_clamp(v ) #endif #ifdef STBIR_SIMD #ifdef STBIR_FLOAT_HIGH_CLAMP const stbir__simdfX high_clamp = stbir__simdf_frepX(STBIR_FLOAT_HIGH_CLAMP)"
  },
  {
    "label": "stbir__simdf_frepX()",
    "kind": "Method",
    "detail": "Function (# endif # ifdef STBIR_FLOAT_LOW_CLAMP const stbir__simdfX low_clamp =)",
    "insertText": "stbir__simdf_frepX(STBIR_FLOAT_LOW_CLAMP)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (# endif)",
    "insertText": "if(width_times_channels >= ( stbir__simdfX_float_count * 2 ))"
  },
  {
    "label": "width_times_channels()",
    "kind": "Method",
    "detail": "Function (float const* end_encode_m8 = encode +)",
    "insertText": "width_times_channels(stbir__simdfX_float_count * 2)"
  },
  {
    "label": "end_output()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "end_output(stbir__simdfX_float_count * 2)"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_load(e0, encode)"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_load(e1, encode+stbir__simdfX_float_count)"
  },
  {
    "label": "stbir__simdfX_min()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIR_FLOAT_HIGH_CLAMP)",
    "insertText": "stbir__simdfX_min(e0, e0, high_clamp)"
  },
  {
    "label": "stbir__simdfX_min()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_min(e1, e1, high_clamp)"
  },
  {
    "label": "stbir__simdfX_max()",
    "kind": "Method",
    "detail": "Function (# endif # ifdef STBIR_FLOAT_LOW_CLAMP)",
    "insertText": "stbir__simdfX_max(e0, e0, low_clamp)"
  },
  {
    "label": "stbir__simdfX_max()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_max(e1, e1, low_clamp)"
  },
  {
    "label": "stbir__simdfX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_store(output, e0)"
  },
  {
    "label": "stbir__simdfX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_store(output+stbir__simdfX_float_count, e1)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (encode + = stbir__simdfX_float_count* 2 ; output + = stbir__simdfX_float_count* 2 ;)",
    "insertText": "if(output < end_output)"
  },
  {
    "label": "stbir__simdf_min()",
    "kind": "Method",
    "detail": "Function (# ifdef STBIR_FLOAT_HIGH_CLAMP)",
    "insertText": "stbir__simdf_min(e0, e0, high_clamp)"
  },
  {
    "label": "stbir__simdf_max()",
    "kind": "Method",
    "detail": "Function (# endif # ifdef STBIR_FLOAT_LOW_CLAMP)",
    "insertText": "stbir__simdf_max(e0, e0, low_clamp)"
  },
  {
    "label": "stbir__simdf_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_store(output-4, e0)"
  },
  {
    "label": "stbir_scalar_hi_clamp()",
    "kind": "Method",
    "detail": "Function (e = encode [ stbir__encode_order0 ] ;)",
    "insertText": "stbir_scalar_hi_clamp(e)"
  },
  {
    "label": "stbir_scalar_lo_clamp()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir_scalar_lo_clamp(e)"
  },
  {
    "label": "defined()",
    "kind": "Method",
    "detail": "Function (output [ 2 ] = e ; # endif output + = stbir__coder_min_num ; encode + = stbir__coder_min_num ; } # endif # endif } # undef stbir__decode_suffix # undef stbir__decode_simdf8_flip # undef stbir__decode_simdf4_flip # undef stbir__decode_order0 # undef stbir__decode_order1 # undef stbir__decode_order2 # undef stbir__decode_order3 # undef stbir__encode_order0 # undef stbir__encode_order1 # undef stbir__encode_order2 # undef stbir__encode_order3 # undef stbir__encode_simdf8_unflip # undef stbir__encode_simdf4_unflip # undef stbir__encode_simdfX_unflip # undef STBIR__CODER_NAME # undef stbir__coder_min_num # undef stbir__decode_swizzle # undef stbir_scalar_hi_clamp # undef stbir_scalar_lo_clamp # undef STB_IMAGE_RESIZE_DO_CODERS # elif)",
    "insertText": "defined(STB_IMAGE_RESIZE_DO_VERTICALS) #ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE #define STBIR_chans( start, end ) STBIR_strs_join14(start,STBIR__vertical_channels,end,_cont) #else #define STBIR_chans( start, end ) STBIR_strs_join1(start,STBIR__vertical_channels,end) #endif #if STBIR__vertical_channels >= 1 #define stbIF0( code ) code #else #define stbIF0( code ) #endif #if STBIR__vertical_channels >= 2 #define stbIF1( code ) code #else #define stbIF1( code ) #endif #if STBIR__vertical_channels >= 3 #define stbIF2( code ) code #else #define stbIF2( code ) #endif #if STBIR__vertical_channels >= 4 #define stbIF3( code ) code #else #define stbIF3( code ) #endif #if STBIR__vertical_channels >= 5 #define stbIF4( code ) code #else #define stbIF4( code ) #endif #if STBIR__vertical_channels >= 6 #define stbIF5( code ) code #else #define stbIF5( code ) #endif #if STBIR__vertical_channels >= 7 #define stbIF6( code ) code #else #define stbIF6( code ) #endif #if STBIR__vertical_channels >= 8 #define stbIF7( code ) code #else #define stbIF7( code ) #endif static void STBIR_chans( stbir__vertical_scatter_with_,_coeffs)( float ** outputs, float const * vertical_coefficients, float const * input, float const * input_end)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbIF0(float STBIR_SIMD_STREAMOUT_PTR( * ) output0 = outputs[0]; float c0s = vertical_coefficients[0]; ) stbIF1( float STBIR_SIMD_STREAMOUT_PTR( * ) output1 = outputs[1]; float c1s = vertical_coefficients[1]; ) stbIF2( float STBIR_SIMD_STREAMOUT_PTR( * ) output2 = outputs[2]; float c2s = vertical_coefficients[2]; ) stbIF3( float STBIR_SIMD_STREAMOUT_PTR( * ) output3 = outputs[3]; float c3s = vertical_coefficients[3]; ) stbIF4( float STBIR_SIMD_STREAMOUT_PTR( * ) output4 = outputs[4]; float c4s = vertical_coefficients[4]; ) stbIF5( float STBIR_SIMD_STREAMOUT_PTR( * ) output5 = outputs[5]; float c5s = vertical_coefficients[5]; ) stbIF6( float STBIR_SIMD_STREAMOUT_PTR( * ) output6 = outputs[6]; float c6s = vertical_coefficients[6]; ) stbIF7( float STBIR_SIMD_STREAMOUT_PTR( * ) output7 = outputs[7]; float c7s = vertical_coefficients[7];)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbIF0(stbir__simdfX c0 = stbir__simdf_frepX( c0s ); ) stbIF1(stbir__simdfX c1 = stbir__simdf_frepX( c1s ); ) stbIF2(stbir__simdfX c2 = stbir__simdf_frepX( c2s ); ) stbIF3(stbir__simdfX c3 = stbir__simdf_frepX( c3s ); ) stbIF4(stbir__simdfX c4 = stbir__simdf_frepX( c4s ); ) stbIF5(stbir__simdfX c5 = stbir__simdf_frepX( c5s ); ) stbIF6(stbir__simdfX c6 = stbir__simdf_frepX( c6s ); ) stbIF7(stbir__simdfX c7 = stbir__simdf_frepX( c7s ); ) while ( ( (char*)input_end - (char*) input ) >= (16*stbir__simdfX_float_count))"
  },
  {
    "label": "STBIR_SIMD_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (stbir__simdfX o0,o1,o2,o3,r0,r1,r2,r3 ;)",
    "insertText": "STBIR_SIMD_NO_UNROLL(output0)"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_load(r0, input)"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_load(r1, input+stbir__simdfX_float_count)"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_load(r2, input+(2*stbir__simdfX_float_count))"
  },
  {
    "label": "stbir__simdfX_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_load(r3, input+(3*stbir__simdfX_float_count))"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (# ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE)",
    "insertText": "stbIF0(stbir__simdfX_load( o0, output0 ); stbir__simdfX_load( o1, output0+stbir__simdfX_float_count ); stbir__simdfX_load( o2, output0+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( o3, output0+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c0 ); stbir__simdfX_madd( o1, o1, r1, c0 ); stbir__simdfX_madd( o2, o2, r2, c0 ); stbir__simdfX_madd( o3, o3, r3, c0 ); stbir__simdfX_store( output0, o0 ); stbir__simdfX_store( output0+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output0+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output0+(3*stbir__simdfX_float_count), o3 ); ) stbIF1( stbir__simdfX_load( o0, output1 ); stbir__simdfX_load( o1, output1+stbir__simdfX_float_count ); stbir__simdfX_load( o2, output1+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( o3, output1+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c1 ); stbir__simdfX_madd( o1, o1, r1, c1 ); stbir__simdfX_madd( o2, o2, r2, c1 ); stbir__simdfX_madd( o3, o3, r3, c1 ); stbir__simdfX_store( output1, o0 ); stbir__simdfX_store( output1+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output1+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output1+(3*stbir__simdfX_float_count), o3 ); ) stbIF2( stbir__simdfX_load( o0, output2 ); stbir__simdfX_load( o1, output2+stbir__simdfX_float_count ); stbir__simdfX_load( o2, output2+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( o3, output2+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c2 ); stbir__simdfX_madd( o1, o1, r1, c2 ); stbir__simdfX_madd( o2, o2, r2, c2 ); stbir__simdfX_madd( o3, o3, r3, c2 ); stbir__simdfX_store( output2, o0 ); stbir__simdfX_store( output2+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output2+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output2+(3*stbir__simdfX_float_count), o3 ); ) stbIF3( stbir__simdfX_load( o0, output3 ); stbir__simdfX_load( o1, output3+stbir__simdfX_float_count ); stbir__simdfX_load( o2, output3+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( o3, output3+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c3 ); stbir__simdfX_madd( o1, o1, r1, c3 ); stbir__simdfX_madd( o2, o2, r2, c3 ); stbir__simdfX_madd( o3, o3, r3, c3 ); stbir__simdfX_store( output3, o0 ); stbir__simdfX_store( output3+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output3+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output3+(3*stbir__simdfX_float_count), o3 ); ) stbIF4( stbir__simdfX_load( o0, output4 ); stbir__simdfX_load( o1, output4+stbir__simdfX_float_count ); stbir__simdfX_load( o2, output4+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( o3, output4+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c4 ); stbir__simdfX_madd( o1, o1, r1, c4 ); stbir__simdfX_madd( o2, o2, r2, c4 ); stbir__simdfX_madd( o3, o3, r3, c4 ); stbir__simdfX_store( output4, o0 ); stbir__simdfX_store( output4+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output4+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output4+(3*stbir__simdfX_float_count), o3 ); ) stbIF5( stbir__simdfX_load( o0, output5 ); stbir__simdfX_load( o1, output5+stbir__simdfX_float_count ); stbir__simdfX_load( o2, output5+(2*stbir__simdfX_float_count)); stbir__simdfX_load( o3, output5+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c5 ); stbir__simdfX_madd( o1, o1, r1, c5 ); stbir__simdfX_madd( o2, o2, r2, c5 ); stbir__simdfX_madd( o3, o3, r3, c5 ); stbir__simdfX_store( output5, o0 ); stbir__simdfX_store( output5+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output5+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output5+(3*stbir__simdfX_float_count), o3 ); ) stbIF6( stbir__simdfX_load( o0, output6 ); stbir__simdfX_load( o1, output6+stbir__simdfX_float_count ); stbir__simdfX_load( o2, output6+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( o3, output6+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c6 ); stbir__simdfX_madd( o1, o1, r1, c6 ); stbir__simdfX_madd( o2, o2, r2, c6 ); stbir__simdfX_madd( o3, o3, r3, c6 ); stbir__simdfX_store( output6, o0 ); stbir__simdfX_store( output6+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output6+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output6+(3*stbir__simdfX_float_count), o3 ); ) stbIF7( stbir__simdfX_load( o0, output7 ); stbir__simdfX_load( o1, output7+stbir__simdfX_float_count ); stbir__simdfX_load( o2, output7+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( o3, output7+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c7 ); stbir__simdfX_madd( o1, o1, r1, c7 ); stbir__simdfX_madd( o2, o2, r2, c7 ); stbir__simdfX_madd( o3, o3, r3, c7 ); stbir__simdfX_store( output7, o0 ); stbir__simdfX_store( output7+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output7+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output7+(3*stbir__simdfX_float_count), o3 ); ) #else stbIF0( stbir__simdfX_mult( o0, r0, c0 ); stbir__simdfX_mult( o1, r1, c0 ); stbir__simdfX_mult( o2, r2, c0 ); stbir__simdfX_mult( o3, r3, c0 ); stbir__simdfX_store( output0, o0 ); stbir__simdfX_store( output0+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output0+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output0+(3*stbir__simdfX_float_count), o3 ); ) stbIF1( stbir__simdfX_mult( o0, r0, c1 ); stbir__simdfX_mult( o1, r1, c1 ); stbir__simdfX_mult( o2, r2, c1 ); stbir__simdfX_mult( o3, r3, c1 ); stbir__simdfX_store( output1, o0 ); stbir__simdfX_store( output1+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output1+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output1+(3*stbir__simdfX_float_count), o3 ); ) stbIF2( stbir__simdfX_mult( o0, r0, c2 ); stbir__simdfX_mult( o1, r1, c2 ); stbir__simdfX_mult( o2, r2, c2 ); stbir__simdfX_mult( o3, r3, c2 ); stbir__simdfX_store( output2, o0 ); stbir__simdfX_store( output2+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output2+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output2+(3*stbir__simdfX_float_count), o3 ); ) stbIF3( stbir__simdfX_mult( o0, r0, c3 ); stbir__simdfX_mult( o1, r1, c3 ); stbir__simdfX_mult( o2, r2, c3 ); stbir__simdfX_mult( o3, r3, c3 ); stbir__simdfX_store( output3, o0 ); stbir__simdfX_store( output3+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output3+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output3+(3*stbir__simdfX_float_count), o3 ); ) stbIF4( stbir__simdfX_mult( o0, r0, c4 ); stbir__simdfX_mult( o1, r1, c4 ); stbir__simdfX_mult( o2, r2, c4 ); stbir__simdfX_mult( o3, r3, c4 ); stbir__simdfX_store( output4, o0 ); stbir__simdfX_store( output4+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output4+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output4+(3*stbir__simdfX_float_count), o3 ); ) stbIF5( stbir__simdfX_mult( o0, r0, c5 ); stbir__simdfX_mult( o1, r1, c5 ); stbir__simdfX_mult( o2, r2, c5 ); stbir__simdfX_mult( o3, r3, c5 ); stbir__simdfX_store( output5, o0 ); stbir__simdfX_store( output5+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output5+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output5+(3*stbir__simdfX_float_count), o3 ); ) stbIF6( stbir__simdfX_mult( o0, r0, c6 ); stbir__simdfX_mult( o1, r1, c6 ); stbir__simdfX_mult( o2, r2, c6 ); stbir__simdfX_mult( o3, r3, c6 ); stbir__simdfX_store( output6, o0 ); stbir__simdfX_store( output6+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output6+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output6+(3*stbir__simdfX_float_count), o3 ); ) stbIF7( stbir__simdfX_mult( o0, r0, c7 ); stbir__simdfX_mult( o1, r1, c7 ); stbir__simdfX_mult( o2, r2, c7 ); stbir__simdfX_mult( o3, r3, c7 ); stbir__simdfX_store( output7, o0 ); stbir__simdfX_store( output7+stbir__simdfX_float_count, o1 ); stbir__simdfX_store( output7+(2*stbir__simdfX_float_count), o2 ); stbir__simdfX_store( output7+(3*stbir__simdfX_float_count), o3 ); ) #endif input += (4*stbir__simdfX_float_count)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbIF0(output0 += (4*stbir__simdfX_float_count); ) stbIF1( output1 += (4*stbir__simdfX_float_count); ) stbIF2( output2 += (4*stbir__simdfX_float_count); ) stbIF3( output3 += (4*stbir__simdfX_float_count); ) stbIF4( output4 += (4*stbir__simdfX_float_count); ) stbIF5( output5 += (4*stbir__simdfX_float_count); ) stbIF6( output6 += (4*stbir__simdfX_float_count); ) stbIF7( output7 += (4*stbir__simdfX_float_count); ) } while ( ( (char*)input_end - (char*) input ) >= 16)"
  },
  {
    "label": "stbir__simdf_load()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdf_load(r0, input)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (# ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE)",
    "insertText": "stbIF0(stbir__simdf_load( o0, output0 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c0 ) ); stbir__simdf_store( output0, o0 ); ) stbIF1( stbir__simdf_load( o0, output1 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c1 ) ); stbir__simdf_store( output1, o0 ); ) stbIF2( stbir__simdf_load( o0, output2 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c2 ) ); stbir__simdf_store( output2, o0 ); ) stbIF3( stbir__simdf_load( o0, output3 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c3 ) ); stbir__simdf_store( output3, o0 ); ) stbIF4( stbir__simdf_load( o0, output4 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c4 ) ); stbir__simdf_store( output4, o0 ); ) stbIF5( stbir__simdf_load( o0, output5 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c5 ) ); stbir__simdf_store( output5, o0 ); ) stbIF6( stbir__simdf_load( o0, output6 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c6 ) ); stbir__simdf_store( output6, o0 ); ) stbIF7( stbir__simdf_load( o0, output7 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c7 ) ); stbir__simdf_store( output7, o0 ); ) #else stbIF0( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c0 ) ); stbir__simdf_store( output0, o0 ); ) stbIF1( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c1 ) ); stbir__simdf_store( output1, o0 ); ) stbIF2( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c2 ) ); stbir__simdf_store( output2, o0 ); ) stbIF3( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c3 ) ); stbir__simdf_store( output3, o0 ); ) stbIF4( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c4 ) ); stbir__simdf_store( output4, o0 ); ) stbIF5( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c5 ) ); stbir__simdf_store( output5, o0 ); ) stbIF6( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c6 ) ); stbir__simdf_store( output6, o0 ); ) stbIF7( stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c7 ) ); stbir__simdf_store( output7, o0 );)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbIF0(output0 += 4; ) stbIF1( output1 += 4; ) stbIF2( output2 += 4; ) stbIF3( output3 += 4; ) stbIF4( output4 += 4; ) stbIF5( output5 += 4; ) stbIF6( output6 += 4; ) stbIF7( output7 += 4; ) } } #else while ( ( (char*)input_end - (char*) input ) >= 16)"
  },
  {
    "label": "STBIR_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (float r0,r1,r2,r3 ;)",
    "insertText": "STBIR_NO_UNROLL(input)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (r0 = input [ 0 ],r1 = input [ 1 ],r2 = input [ 2 ],r3 = input [ 3 ] ; # ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE)",
    "insertText": "stbIF0(output0[0] += ( r0 * c0s ); output0[1] += ( r1 * c0s ); output0[2] += ( r2 * c0s ); output0[3] += ( r3 * c0s ); ) stbIF1( output1[0] += ( r0 * c1s ); output1[1] += ( r1 * c1s ); output1[2] += ( r2 * c1s ); output1[3] += ( r3 * c1s ); ) stbIF2( output2[0] += ( r0 * c2s ); output2[1] += ( r1 * c2s ); output2[2] += ( r2 * c2s ); output2[3] += ( r3 * c2s ); ) stbIF3( output3[0] += ( r0 * c3s ); output3[1] += ( r1 * c3s ); output3[2] += ( r2 * c3s ); output3[3] += ( r3 * c3s ); ) stbIF4( output4[0] += ( r0 * c4s ); output4[1] += ( r1 * c4s ); output4[2] += ( r2 * c4s ); output4[3] += ( r3 * c4s ); ) stbIF5( output5[0] += ( r0 * c5s ); output5[1] += ( r1 * c5s ); output5[2] += ( r2 * c5s ); output5[3] += ( r3 * c5s ); ) stbIF6( output6[0] += ( r0 * c6s ); output6[1] += ( r1 * c6s ); output6[2] += ( r2 * c6s ); output6[3] += ( r3 * c6s ); ) stbIF7( output7[0] += ( r0 * c7s ); output7[1] += ( r1 * c7s ); output7[2] += ( r2 * c7s ); output7[3] += ( r3 * c7s ); ) #else stbIF0( output0[0] = ( r0 * c0s ); output0[1] = ( r1 * c0s ); output0[2] = ( r2 * c0s ); output0[3] = ( r3 * c0s ); ) stbIF1( output1[0] = ( r0 * c1s ); output1[1] = ( r1 * c1s ); output1[2] = ( r2 * c1s ); output1[3] = ( r3 * c1s ); ) stbIF2( output2[0] = ( r0 * c2s ); output2[1] = ( r1 * c2s ); output2[2] = ( r2 * c2s ); output2[3] = ( r3 * c2s ); ) stbIF3( output3[0] = ( r0 * c3s ); output3[1] = ( r1 * c3s ); output3[2] = ( r2 * c3s ); output3[3] = ( r3 * c3s ); ) stbIF4( output4[0] = ( r0 * c4s ); output4[1] = ( r1 * c4s ); output4[2] = ( r2 * c4s ); output4[3] = ( r3 * c4s ); ) stbIF5( output5[0] = ( r0 * c5s ); output5[1] = ( r1 * c5s ); output5[2] = ( r2 * c5s ); output5[3] = ( r3 * c5s ); ) stbIF6( output6[0] = ( r0 * c6s ); output6[1] = ( r1 * c6s ); output6[2] = ( r2 * c6s ); output6[3] = ( r3 * c6s ); ) stbIF7( output7[0] = ( r0 * c7s ); output7[1] = ( r1 * c7s ); output7[2] = ( r2 * c7s ); output7[3] = ( r3 * c7s );)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbIF0(output0 += 4; ) stbIF1( output1 += 4; ) stbIF2( output2 += 4; ) stbIF3( output3 += 4; ) stbIF4( output4 += 4; ) stbIF5( output5 += 4; ) stbIF6( output6 += 4; ) stbIF7( output7 += 4; ) } #endif while ( input < input_end)"
  },
  {
    "label": "STBIR_NO_UNROLL()",
    "kind": "Method",
    "detail": "Function (float r = input [ 0 ] ;)",
    "insertText": "STBIR_NO_UNROLL(output0)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (# ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE)",
    "insertText": "stbIF0(output0[0] += ( r * c0s ); ) stbIF1( output1[0] += ( r * c1s ); ) stbIF2( output2[0] += ( r * c2s ); ) stbIF3( output3[0] += ( r * c3s ); ) stbIF4( output4[0] += ( r * c4s ); ) stbIF5( output5[0] += ( r * c5s ); ) stbIF6( output6[0] += ( r * c6s ); ) stbIF7( output7[0] += ( r * c7s ); ) #else stbIF0( output0[0] = ( r * c0s ); ) stbIF1( output1[0] = ( r * c1s ); ) stbIF2( output2[0] = ( r * c2s ); ) stbIF3( output3[0] = ( r * c3s ); ) stbIF4( output4[0] = ( r * c4s ); ) stbIF5( output5[0] = ( r * c5s ); ) stbIF6( output6[0] = ( r * c6s ); ) stbIF7( output7[0] = ( r * c7s );)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbIF0(++output0; ) stbIF1( ++output1; ) stbIF2( ++output2; ) stbIF3( ++output3; ) stbIF4( ++output4; ) stbIF5( ++output5; ) stbIF6( ++output6; ) stbIF7( ++output7; ) } } static void STBIR_chans( stbir__vertical_gather_with_,_coeffs)( float * outputp, float const * vertical_coefficients, float const ** inputs, float const * input0_end)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbIF0(float const * input0 = inputs[0]; float c0s = vertical_coefficients[0]; ) stbIF1( float const * input1 = inputs[1]; float c1s = vertical_coefficients[1]; ) stbIF2( float const * input2 = inputs[2]; float c2s = vertical_coefficients[2]; ) stbIF3( float const * input3 = inputs[3]; float c3s = vertical_coefficients[3]; ) stbIF4( float const * input4 = inputs[4]; float c4s = vertical_coefficients[4]; ) stbIF5( float const * input5 = inputs[5]; float c5s = vertical_coefficients[5]; ) stbIF6( float const * input6 = inputs[6]; float c6s = vertical_coefficients[6]; ) stbIF7( float const * input7 = inputs[7]; float c7s = vertical_coefficients[7]; ) #if ( STBIR__vertical_channels == 1 ) && !defined(STB_IMAGE_RESIZE_VERTICAL_CONTINUE) if ( ( c0s >= (1.0f-0.000001f) ) && ( c0s <= (1.0f+0.000001f) ))"
  },
  {
    "label": "STBIR_MEMCPY()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_MEMCPY(output, input0, (char*)input0_end - (char*)input0)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbIF0(stbir__prefetch( input0 + (16*stbir__simdfX_float_count) ); ) stbIF1( stbir__prefetch( input1 + (16*stbir__simdfX_float_count) ); ) stbIF2( stbir__prefetch( input2 + (16*stbir__simdfX_float_count) ); ) stbIF3( stbir__prefetch( input3 + (16*stbir__simdfX_float_count) ); ) stbIF4( stbir__prefetch( input4 + (16*stbir__simdfX_float_count) ); ) stbIF5( stbir__prefetch( input5 + (16*stbir__simdfX_float_count) ); ) stbIF6( stbir__prefetch( input6 + (16*stbir__simdfX_float_count) ); ) stbIF7( stbir__prefetch( input7 + (16*stbir__simdfX_float_count) ); ) #ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE stbIF0( stbir__simdfX_load( o0, output ); stbir__simdfX_load( o1, output+stbir__simdfX_float_count ); stbir__simdfX_load( o2, output+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( o3, output+(3*stbir__simdfX_float_count) ); stbir__simdfX_load( r0, input0 ); stbir__simdfX_load( r1, input0+stbir__simdfX_float_count ); stbir__simdfX_load( r2, input0+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( r3, input0+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c0 ); stbir__simdfX_madd( o1, o1, r1, c0 ); stbir__simdfX_madd( o2, o2, r2, c0 ); stbir__simdfX_madd( o3, o3, r3, c0 ); ) #else stbIF0( stbir__simdfX_load( r0, input0 ); stbir__simdfX_load( r1, input0+stbir__simdfX_float_count ); stbir__simdfX_load( r2, input0+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( r3, input0+(3*stbir__simdfX_float_count) ); stbir__simdfX_mult( o0, r0, c0 ); stbir__simdfX_mult( o1, r1, c0 ); stbir__simdfX_mult( o2, r2, c0 ); stbir__simdfX_mult( o3, r3, c0 ); ) #endif stbIF1( stbir__simdfX_load( r0, input1 ); stbir__simdfX_load( r1, input1+stbir__simdfX_float_count ); stbir__simdfX_load( r2, input1+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( r3, input1+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c1 ); stbir__simdfX_madd( o1, o1, r1, c1 ); stbir__simdfX_madd( o2, o2, r2, c1 ); stbir__simdfX_madd( o3, o3, r3, c1 ); ) stbIF2( stbir__simdfX_load( r0, input2 ); stbir__simdfX_load( r1, input2+stbir__simdfX_float_count ); stbir__simdfX_load( r2, input2+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( r3, input2+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c2 ); stbir__simdfX_madd( o1, o1, r1, c2 ); stbir__simdfX_madd( o2, o2, r2, c2 ); stbir__simdfX_madd( o3, o3, r3, c2 ); ) stbIF3( stbir__simdfX_load( r0, input3 ); stbir__simdfX_load( r1, input3+stbir__simdfX_float_count ); stbir__simdfX_load( r2, input3+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( r3, input3+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c3 ); stbir__simdfX_madd( o1, o1, r1, c3 ); stbir__simdfX_madd( o2, o2, r2, c3 ); stbir__simdfX_madd( o3, o3, r3, c3 ); ) stbIF4( stbir__simdfX_load( r0, input4 ); stbir__simdfX_load( r1, input4+stbir__simdfX_float_count ); stbir__simdfX_load( r2, input4+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( r3, input4+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c4 ); stbir__simdfX_madd( o1, o1, r1, c4 ); stbir__simdfX_madd( o2, o2, r2, c4 ); stbir__simdfX_madd( o3, o3, r3, c4 ); ) stbIF5( stbir__simdfX_load( r0, input5 ); stbir__simdfX_load( r1, input5+stbir__simdfX_float_count ); stbir__simdfX_load( r2, input5+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( r3, input5+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c5 ); stbir__simdfX_madd( o1, o1, r1, c5 ); stbir__simdfX_madd( o2, o2, r2, c5 ); stbir__simdfX_madd( o3, o3, r3, c5 ); ) stbIF6( stbir__simdfX_load( r0, input6 ); stbir__simdfX_load( r1, input6+stbir__simdfX_float_count ); stbir__simdfX_load( r2, input6+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( r3, input6+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c6 ); stbir__simdfX_madd( o1, o1, r1, c6 ); stbir__simdfX_madd( o2, o2, r2, c6 ); stbir__simdfX_madd( o3, o3, r3, c6 ); ) stbIF7( stbir__simdfX_load( r0, input7 ); stbir__simdfX_load( r1, input7+stbir__simdfX_float_count ); stbir__simdfX_load( r2, input7+(2*stbir__simdfX_float_count) ); stbir__simdfX_load( r3, input7+(3*stbir__simdfX_float_count) ); stbir__simdfX_madd( o0, o0, r0, c7 ); stbir__simdfX_madd( o1, o1, r1, c7 ); stbir__simdfX_madd( o2, o2, r2, c7 ); stbir__simdfX_madd( o3, o3, r3, c7 ); ) stbir__simdfX_store( output, o0)"
  },
  {
    "label": "stbir__simdfX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_store(output+stbir__simdfX_float_count, o1)"
  },
  {
    "label": "stbir__simdfX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_store(output+(2*stbir__simdfX_float_count), o2)"
  },
  {
    "label": "stbir__simdfX_store()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__simdfX_store(output+(3*stbir__simdfX_float_count), o3)"
  },
  {
    "label": "output()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "output(4*stbir__simdfX_float_count)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbIF0(input0 += (4*stbir__simdfX_float_count); ) stbIF1( input1 += (4*stbir__simdfX_float_count); ) stbIF2( input2 += (4*stbir__simdfX_float_count); ) stbIF3( input3 += (4*stbir__simdfX_float_count); ) stbIF4( input4 += (4*stbir__simdfX_float_count); ) stbIF5( input5 += (4*stbir__simdfX_float_count); ) stbIF6( input6 += (4*stbir__simdfX_float_count); ) stbIF7( input7 += (4*stbir__simdfX_float_count); ) } while ( ( (char*)input0_end - (char*) input0 ) >= 16)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (# ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE)",
    "insertText": "stbIF0(stbir__simdf_load( o0, output ); stbir__simdf_load( r0, input0 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c0 ) ); ) #else stbIF0( stbir__simdf_load( r0, input0 ); stbir__simdf_mult( o0, r0, stbir__if_simdf8_cast_to_simdf4( c0 ) ); ) #endif stbIF1( stbir__simdf_load( r0, input1 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c1 ) ); ) stbIF2( stbir__simdf_load( r0, input2 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c2 ) ); ) stbIF3( stbir__simdf_load( r0, input3 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c3 ) ); ) stbIF4( stbir__simdf_load( r0, input4 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c4 ) ); ) stbIF5( stbir__simdf_load( r0, input5 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c5 ) ); ) stbIF6( stbir__simdf_load( r0, input6 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c6 ) ); ) stbIF7( stbir__simdf_load( r0, input7 ); stbir__simdf_madd( o0, o0, r0, stbir__if_simdf8_cast_to_simdf4( c7 ) ); ) stbir__simdf_store( output, o0)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (output + = 4 ;)",
    "insertText": "stbIF0(input0 += 4; ) stbIF1( input1 += 4; ) stbIF2( input2 += 4; ) stbIF3( input3 += 4; ) stbIF4( input4 += 4; ) stbIF5( input5 += 4; ) stbIF6( input6 += 4; ) stbIF7( input7 += 4; ) } } #else while ( ( (char*)input0_end - (char*) input0 ) >= 16)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (# ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE)",
    "insertText": "stbIF0(o0 = output[0] + input0[0] * c0s; o1 = output[1] + input0[1] * c0s; o2 = output[2] + input0[2] * c0s; o3 = output[3] + input0[3] * c0s; ) #else stbIF0( o0 = input0[0] * c0s; o1 = input0[1] * c0s; o2 = input0[2] * c0s; o3 = input0[3] * c0s; ) #endif stbIF1( o0 += input1[0] * c1s; o1 += input1[1] * c1s; o2 += input1[2] * c1s; o3 += input1[3] * c1s; ) stbIF2( o0 += input2[0] * c2s; o1 += input2[1] * c2s; o2 += input2[2] * c2s; o3 += input2[3] * c2s; ) stbIF3( o0 += input3[0] * c3s; o1 += input3[1] * c3s; o2 += input3[2] * c3s; o3 += input3[3] * c3s; ) stbIF4( o0 += input4[0] * c4s; o1 += input4[1] * c4s; o2 += input4[2] * c4s; o3 += input4[3] * c4s; ) stbIF5( o0 += input5[0] * c5s; o1 += input5[1] * c5s; o2 += input5[2] * c5s; o3 += input5[3] * c5s; ) stbIF6( o0 += input6[0] * c6s; o1 += input6[1] * c6s; o2 += input6[2] * c6s; o3 += input6[3] * c6s; ) stbIF7( o0 += input7[0] * c7s; o1 += input7[1] * c7s; o2 += input7[2] * c7s; o3 += input7[3] * c7s;)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (output [ 1 ] = o1 ; output [ 2 ] = o2 ; output [ 3 ] = o3 ; output + = 4 ;)",
    "insertText": "stbIF0(input0 += 4; ) stbIF1( input1 += 4; ) stbIF2( input2 += 4; ) stbIF3( input3 += 4; ) stbIF4( input4 += 4; ) stbIF5( input5 += 4; ) stbIF6( input6 += 4; ) stbIF7( input7 += 4; ) } #endif while ( input0 < input0_end)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (# ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE)",
    "insertText": "stbIF0(o0 = output[0] + input0[0] * c0s; ) #else stbIF0( o0 = input0[0] * c0s; ) #endif stbIF1( o0 += input1[0] * c1s; ) stbIF2( o0 += input2[0] * c2s; ) stbIF3( o0 += input3[0] * c3s; ) stbIF4( o0 += input4[0] * c4s; ) stbIF5( o0 += input5[0] * c5s; ) stbIF6( o0 += input6[0] * c6s; ) stbIF7( o0 += input7[0] * c7s;)"
  },
  {
    "label": "stbIF0()",
    "kind": "Method",
    "detail": "Function (+ + output ;)",
    "insertText": "stbIF0(++input0; ) stbIF1( ++input1; ) stbIF2( ++input2; ) stbIF3( ++input3; ) stbIF4( ++input4; ) stbIF5( ++input5; ) stbIF6( ++input6; ) stbIF7( ++input7; ) } } #undef stbIF0 #undef stbIF1 #undef stbIF2 #undef stbIF3 #undef stbIF4 #undef stbIF5 #undef stbIF6 #undef stbIF7 #undef STB_IMAGE_RESIZE_DO_VERTICALS #undef STBIR__vertical_channels #undef STB_IMAGE_RESIZE_DO_HORIZONTALS #undef STBIR_strs_join24 #undef STBIR_strs_join14 #undef STBIR_chans #ifdef STB_IMAGE_RESIZE_VERTICAL_CONTINUE #undef STB_IMAGE_RESIZE_VERTICAL_CONTINUE #endif #else #define STBIR_chans( start, end ) STBIR_strs_join1(start,STBIR__horizontal_channels,end) #ifndef stbir__2_coeff_only #define stbir__2_coeff_only() \\ stbir__1_coeff_only()"
  },
  {
    "label": "stbir__1_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__1_coeff_remnant(1)"
  },
  {
    "label": "stbir__2_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# endif # ifndef stbir__2_coeff_remnant # define)",
    "insertText": "stbir__2_coeff_remnant(ofs ) \\ stbir__1_coeff_remnant(ofs)"
  },
  {
    "label": "stbir__1_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__1_coeff_remnant((ofs)+1)"
  },
  {
    "label": "stbir__3_coeff_only()",
    "kind": "Method",
    "detail": "Function (# endif # ifndef stbir__3_coeff_only # define)",
    "insertText": "stbir__3_coeff_only() \\ stbir__2_coeff_only()"
  },
  {
    "label": "stbir__1_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__1_coeff_remnant(2)"
  },
  {
    "label": "stbir__3_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (# endif # ifndef stbir__3_coeff_remnant # define)",
    "insertText": "stbir__3_coeff_remnant(ofs ) \\ stbir__2_coeff_remnant(ofs)"
  },
  {
    "label": "stbir__1_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__1_coeff_remnant((ofs)+2)"
  },
  {
    "label": "stbir__3_coeff_setup()",
    "kind": "Method",
    "detail": "Function (# endif # ifndef stbir__3_coeff_setup # define)",
    "insertText": "stbir__3_coeff_setup() #endif #ifndef stbir__4_coeff_start #define stbir__4_coeff_start() \\ stbir__2_coeff_only()"
  },
  {
    "label": "stbir__2_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__2_coeff_remnant(2)"
  },
  {
    "label": "stbir__4_coeff_continue_from_4()",
    "kind": "Method",
    "detail": "Function (# endif # ifndef stbir__4_coeff_continue_from_4 # define)",
    "insertText": "stbir__4_coeff_continue_from_4(ofs ) \\ stbir__2_coeff_remnant(ofs)"
  },
  {
    "label": "stbir__2_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (\\)",
    "insertText": "stbir__2_coeff_remnant((ofs)+2)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (# endif # ifndef stbir__store_output_tiny # define stbir__store_output_tiny stbir__store_output # endif void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_1_coeff)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "while(output < output_end)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_2_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_3_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_4_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_5_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "stbir__1_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__1_coeff_remnant(4)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_6_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "stbir__2_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__2_coeff_remnant(4)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_7_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "stbir__3_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__3_coeff_remnant(4)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_8_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "stbir__4_coeff_continue_from_4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__4_coeff_continue_from_4(4)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_9_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "stbir__1_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__1_coeff_remnant(8)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_10_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "stbir__2_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__2_coeff_remnant(8)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_11_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "stbir__3_coeff_remnant()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__3_coeff_remnant(8)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_12_coeffs)( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "stbir__4_coeff_continue_from_4()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "stbir__4_coeff_continue_from_4(8)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod0 )( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (- - n ; })",
    "insertText": "while(n > 0)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod1 )( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod2 )( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod3 )( float * output_buffer, unsigned int output_sub_size, float const * decode_buffer, stbir__contributors const * horizontal_contributors, float const * horizontal_coefficients, int coefficient_width)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (} stbir__horizontal_gather_channels_func*)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_funcs)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod0), STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod1), STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod2), STBIR_chans(stbir__horizontal_gather_,_channels_with_n_coeffs_mod3)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (stbir__horizontal_gather_channels_func*)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_funcs)"
  },
  {
    "label": "STBIR_chans()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "STBIR_chans(stbir__horizontal_gather_,_channels_with_1_coeff), STBIR_chans(stbir__horizontal_gather_,_channels_with_2_coeffs), STBIR_chans(stbir__horizontal_gather_,_channels_with_3_coeffs), STBIR_chans(stbir__horizontal_gather_,_channels_with_4_coeffs), STBIR_chans(stbir__horizontal_gather_,_channels_with_5_coeffs), STBIR_chans(stbir__horizontal_gather_,_channels_with_6_coeffs), STBIR_chans(stbir__horizontal_gather_,_channels_with_7_coeffs), STBIR_chans(stbir__horizontal_gather_,_channels_with_8_coeffs), STBIR_chans(stbir__horizontal_gather_,_channels_with_9_coeffs), STBIR_chans(stbir__horizontal_gather_,_channels_with_10_coeffs), STBIR_chans(stbir__horizontal_gather_,_channels_with_11_coeffs), STBIR_chans(stbir__horizontal_gather_,_channels_with_12_coeffs)"
  }
]