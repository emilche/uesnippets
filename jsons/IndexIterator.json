[
  {
    "label": "State",
    "kind": "Enum",
    "detail": "enum declaration",
    "insertText": "State"
  },
  {
    "label": "NullFilter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "NullFilter"
  },
  {
    "label": "ValueVoxelCIter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueVoxelCIter"
  },
  {
    "label": "Parent",
    "kind": "Type",
    "detail": "struct declaration",
    "insertText": "Parent"
  },
  {
    "label": "IndexIter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "IndexIter"
  },
  {
    "label": "ValueIndexIter",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "ValueIndexIter"
  },
  {
    "label": "iterCount()",
    "kind": "Method",
    "detail": "Function (# ifndef OPENVDB_POINTS_INDEX_ITERATOR_HAS_BEEN_INCLUDED # define OPENVDB_POINTS_INDEX_ITERATOR_HAS_BEEN_INCLUDED # include<openvdb / version . h> # include<openvdb / Types . h> namespace openvdb { OPENVDB_USE_VERSION_NAMESPACE namespace OPENVDB_VERSION_NAME { namespace points { template<IterT> Index64)",
    "insertText": "iterCount(const IterT& iter)"
  },
  {
    "label": "initialized()",
    "kind": "Method",
    "detail": "Function (namespace index { enum State { PARTIAL = 0,NONE,ALL } ; } class NullFilter { public : bool)",
    "insertText": "initialized()"
  },
  {
    "label": "valid()",
    "kind": "Method",
    "detail": "Function (} template<IterT> bool)",
    "insertText": "valid(const IterT&)"
  },
  {
    "label": "Parent()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Parent(Index32 offset): mOffset(offset)"
  },
  {
    "label": "getValue()",
    "kind": "Method",
    "detail": "Function (} Index32)",
    "insertText": "getValue(unsigned)"
  },
  {
    "label": "ValueVoxelCIter()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "ValueVoxelCIter(Index32 prevOffset, Index32 offset) : mOffset(offset), mParent(prevOffset)"
  },
  {
    "label": "ValueVoxelCIter()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "ValueVoxelCIter(const ValueVoxelCIter& other) : mOffset(other.mOffset), mParent(other.mParent), mValid(other.mValid)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} Index32)",
    "insertText": "operator()"
  },
  {
    "label": "bool()",
    "kind": "Method",
    "detail": "Function (mValid = false ; return* this ; } operator)",
    "insertText": "bool()"
  },
  {
    "label": "parent()",
    "kind": "Method",
    "detail": "Function (} Parent&)",
    "insertText": "parent()"
  },
  {
    "label": "noreturn()",
    "kind": "Method",
    "detail": "Function (} Coord getCoord [ [)",
    "insertText": "noreturn()"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(RuntimeError, \"ValueVoxelCIter does not provide a valid Coord.\")"
  },
  {
    "label": "noreturn()",
    "kind": "Method",
    "detail": "Function (} void getCoord [ [)",
    "insertText": "noreturn(Coord&)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(RuntimeError, \"ValueVoxelCIter does not test if voxel is active.\")"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "operator(const ValueVoxelCIter& other)"
  },
  {
    "label": "ValueIndexIter()",
    "kind": "Method",
    "detail": "Function (} private : Index32 mOffset = 0 ; Parent mParent ; bool mValid = true ; } ; template<IteratorT,FilterT> class IndexIter { public : class ValueIndexIter { public :)",
    "insertText": "ValueIndexIter(const IteratorT& iter) : mIter(iter), mParent(&mIter.parent())"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mParent)"
  },
  {
    "label": "start()",
    "kind": "Method",
    "detail": "Function (Index32)",
    "insertText": "start(mIter.offset() > 0 ? Index32(mParent->getValue(mIter.offset() - 1)) : Index32(0))"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "reset(start, *mIter)"
  },
  {
    "label": "ValueIndexIter()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "ValueIndexIter(const ValueIndexIter& other) : mEnd(other.mEnd), mItem(other.mItem), mIter(other.mIter), mParent(other.mParent)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} ValueIndexIter&)",
    "insertText": "operator(const ValueIndexIter&)"
  },
  {
    "label": "end()",
    "kind": "Method",
    "detail": "Function (Index32)",
    "insertText": "end()"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mIter)"
  },
  {
    "label": "while()",
    "kind": "Method",
    "detail": "Function (+ + mItem ;)",
    "insertText": "while(mItem >= mEnd && mIter.next())"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "reset(mParent->getValue(mIter.offset() - 1), *mIter)"
  },
  {
    "label": "next()",
    "kind": "Method",
    "detail": "Function (} return* this ; } bool)",
    "insertText": "next()"
  },
  {
    "label": "increment()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "increment()"
  },
  {
    "label": "getCoord()",
    "kind": "Method",
    "detail": "Function (} Coord)",
    "insertText": "getCoord()"
  },
  {
    "label": "getCoord()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "getCoord(Coord& xyz)"
  },
  {
    "label": "isValueOn()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "isValueOn()"
  },
  {
    "label": "valueIter()",
    "kind": "Method",
    "detail": "Function (} const IteratorT&)",
    "insertText": "valueIter()"
  },
  {
    "label": "IndexIter()",
    "kind": "Method",
    "detail": "Function (} private : Index32 mEnd = 0 ; Index32 mItem = 0 ; IteratorT mIter ; const IteratorT::NodeType* mParent ; } ;)",
    "insertText": "IndexIter(const IteratorT& iterator, const FilterT& filter) : mIterator(iterator) , mFilter(filter)"
  },
  {
    "label": "OPENVDB_THROW()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "OPENVDB_THROW(RuntimeError, \"Filter needs to be initialized before constructing the iterator.\")"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (})",
    "insertText": "if(mIterator)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (this ->)",
    "insertText": "reset(*mIterator, mIterator.end())"
  },
  {
    "label": "IndexIter()",
    "kind": "Method",
    "detail": "Function (} })",
    "insertText": "IndexIter(const IndexIter& other) : mIterator(other.mIterator) , mFilter(other.mFilter)"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (} } IndexIter&)",
    "insertText": "operator(const IndexIter& other)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (mIterator = other . mIterator ; mFilter = other . mFilter ;)",
    "insertText": "if(!mFilter.initialized())"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (} void)",
    "insertText": "reset(Index32 begin, Index32 end)"
  },
  {
    "label": "reset()",
    "kind": "Method",
    "detail": "Function (mIterator .)",
    "insertText": "reset(begin, end)"
  },
  {
    "label": "assert()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "assert(mIterator)"
  },
  {
    "label": "test()",
    "kind": "Method",
    "detail": "Function (} bool)",
    "insertText": "test()"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (+ + mIterator ;)",
    "insertText": "if(!mIterator.test() || mFilter.template valid<ValueIndexIter>(mIterator))"
  },
  {
    "label": "operator()",
    "kind": "Method",
    "detail": "Function (break ; } } return* this ; } IndexIter)",
    "insertText": "operator(int)"
  },
  {
    "label": "newIterator()",
    "kind": "Method",
    "detail": "Function (IndexIter)",
    "insertText": "newIterator(*this)"
  },
  {
    "label": "filter()",
    "kind": "Method",
    "detail": "Function (} const FilterT&)",
    "insertText": "filter()"
  },
  {
    "label": "for()",
    "kind": "Method",
    "detail": "Function (Index64 size = 0 ;)",
    "insertText": "for(IterT newIter(iter); newIter; ++newIter, ++size)"
  }
]