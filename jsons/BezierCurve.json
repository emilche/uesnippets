[
  {
    "label": "CADKERNEL_API",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "CADKERNEL_API"
  },
  {
    "label": "FEntity",
    "kind": "Type",
    "detail": "class declaration",
    "insertText": "FEntity"
  },
  {
    "label": "FBezierCurve()",
    "kind": "Method",
    "detail": "Function (# pragma once # include \" Geo / Curves / Curve . h \" # include \" NURBSCurve . h \" namespace UE::CADKernel { class FBezierCurve : public FCurve { class FEntity ; protected : bool bIsRational = false ; int32 Degree = 0 ; TArray<double> NodalVector ; int32 NumSegments = 0 ; TArray<FPoint> Poles ; TArray<double> Weights ;)",
    "insertText": "FBezierCurve(const TArray<FPoint>& InPoles)"
  },
  {
    "label": "Num()",
    "kind": "Method",
    "detail": "Function (InPoles } { Degree = Poles .)",
    "insertText": "Num()"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (NumSegments = 1 ; NodalVector .)",
    "insertText": "Add(0.)"
  },
  {
    "label": "Add()",
    "kind": "Method",
    "detail": "Function (NodalVector .)",
    "insertText": "Add(1.)"
  },
  {
    "label": "SetNum()",
    "kind": "Method",
    "detail": "Function (Weights .)",
    "insertText": "SetNum(Poles.Num())"
  },
  {
    "label": "FBezierCurve()",
    "kind": "Method",
    "detail": "Function (Weight = 1 . ; } })",
    "insertText": "FBezierCurve(const FNurbsCurveData& NurbsCurveData)"
  },
  {
    "label": "FBezierCurve()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "FBezierCurve()"
  },
  {
    "label": "IsBezier()",
    "kind": "Method",
    "detail": "Function (public : bool)",
    "insertText": "IsBezier(const FNurbsCurveData& NurbsCurveData)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Serialize(FCADKernelArchive& Ar)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Serialize(Ar)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Serialize(bIsRational)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Serialize(Degree)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Serialize(NumSegments)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Serialize(NodalVector)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Serialize(Poles)"
  },
  {
    "label": "Serialize()",
    "kind": "Method",
    "detail": "Function (Ar .)",
    "insertText": "Serialize(Weights)"
  },
  {
    "label": "GetInfo()",
    "kind": "Method",
    "detail": "Function (} # ifdef CADKERNEL_DEV FInfoEntity&)",
    "insertText": "GetInfo(FInfoEntity&)"
  },
  {
    "label": "GetCurveType()",
    "kind": "Method",
    "detail": "Function (# endif ECurve)",
    "insertText": "GetCurveType()"
  },
  {
    "label": "Offset()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Offset(const FPoint& OffsetDirection)"
  },
  {
    "label": "EvaluatePoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "EvaluatePoint(double Coordinate, FCurvePoint& OutPoint, int32 DerivativeOrder = 0)"
  },
  {
    "label": "Evaluate2DPoint()",
    "kind": "Method",
    "detail": "Function (void)",
    "insertText": "Evaluate2DPoint(double Coordinate, FCurvePoint2D& OutPoint, int32 DerivativeOrder = 0)"
  },
  {
    "label": "EvaluatePoint()",
    "kind": "Method",
    "detail": "Function (FCurvePoint CurvePoint ;)",
    "insertText": "EvaluatePoint(Coordinate, CurvePoint, DerivativeOrder)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OutPoint . DerivativeOrder = DerivativeOrder ; OutPoint . Point [ 0 ] = CurvePoint . Point [ 0 ] ; OutPoint . Point [ 1 ] = CurvePoint . Point [ 1 ] ;)",
    "insertText": "if(DerivativeOrder > 0)"
  },
  {
    "label": "if()",
    "kind": "Method",
    "detail": "Function (OutPoint . Gradient [ 0 ] = CurvePoint . Gradient [ 0 ] ; OutPoint . Gradient [ 1 ] = CurvePoint . Gradient [ 1 ] ;)",
    "insertText": "if(DerivativeOrder > 1)"
  },
  {
    "label": "ExtendTo()",
    "kind": "Method",
    "detail": "Function (OutPoint . Laplacian [ 0 ] = CurvePoint . Laplacian [ 0 ] ; OutPoint . Laplacian [ 1 ] = CurvePoint . Laplacian [ 1 ] ; } } } void)",
    "insertText": "ExtendTo(const FPoint& Point)"
  }
]